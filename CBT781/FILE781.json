{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012801000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE781.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE781.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\x05'", "DS1TRBAL": "b'\\xb9\\x02'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05M\\x00\\x0b\\x05N\\x00\\x06\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00\\t\\x01\\x13\\x00\\x1f\\x01\\x13\\x00\\x1f\\x13\\x16\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-01-01T00:00:00", "modifydate": "2013-01-01T13:16:09", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-486"}, "text": "REGULAR CBT TAPE - VERSION 486    FILE:  781\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT486.FILE781\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 10 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,917 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/01/13    13:16:09    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00X\\x01\\x08\\x11O\\x01\\x08\\x11O\\x13A\\x00&\\x00#\\x00\\x00\\xe3\\xe2\\xc8\\xf0\\xf0\\xf9@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2008-04-23T00:00:00", "modifydate": "2008-04-23T13:41:58", "lines": 38, "newlines": 35, "modlines": 0, "user": "TSH009"}, "text": " This is a modification of the IBM supplied RACSEQ program.  It has\n been modified to be able to write its output in XML format. It has\n also been extended to write to a specified DDName, DSName, Sysout\n class, or UNIX Path.When writing to a DSName, it can either be an\n existing DSName, or a new one. If it is a new one, the DSName will be\n allocated with either the system defaults, the SMS defaults as\n assigned by the ACS routines, or with the characteristics specified\n via a USING() and/or LIKE() parameter.\n\n Command format:\n\n RACSEQ CLASS(classname) PROFILE(profilename)\n    NONXML | XML\n    Terminal | DDName(ddname) | DSName(dsname) | Sysout(class) | Path(path)\n    USING(attr-list-name)\n    LIKE(existing.dataset.name)\n\n The defaults are NONXML and Terminal, which results in the same output as\n the code distributed by IBM.\n\n The attr-list-name is the name previously established by a ATTRIB command.\n\n The \"dsname\" honors the normal TSO standard of prepending the name\n specified by the PREFIX unless it is enclosed in apostrophes.\n\n The class in the Sysout parameter must be exactly one character in\n the set A..Z0..9. You cannot specify other SYSOUT characteristics\n such as FORM or DEST. If you need this type of support, then use an\n ALLOCATE command to allocate the SYSOUT dataset, and reference the\n allocated DDName in the DDName() parameter.\n\n The value in the Path() parameter must start at the root. That is\n because I don't have an easy way to determine any relative path\n names. So this is easier for me than fielding questions. Again, I'm\n being a bit lazy.\n\n This code is being distributed in source form only. You must assemble\n it into an appropriate library.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#IBMCODE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x08\\x11_\\x01\\x08\\x11_\\tP\\x00=\\x00<\\x00\\x00\\xc9\\xc2\\xd4\\xc4\\xd6\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-04-24T00:00:00", "modifydate": "2008-04-24T09:50:46", "lines": 61, "newlines": 60, "modlines": 0, "user": "IBMDOC"}, "text": "Note:  This is IBM documentation for their sample code\n       which was found at:\n\n   http://www.ibm.com/servers/eserver/zseries/zos/racf/racseq.html\n\n       Note their disclaimer at the end, which allows us to copy\n       their code and distribute it here.  Their sample code is\n       found in member @IBMCODE in this pds.\n\n--------------------------------------------------------------------\n\n        The RACSEQ command\n\nRACSEQ is a sample TSO command which demonstrates the profile\nextract functions of the R_admin RACF callable service\n(IRRSEQ00). The command accepts a class name and a profile name\nand displays the contents of every field in the profile. It\ndiffers from LISTUSER and LISTGRP in that the output is displayed\nin a simplified and somewhat architected manner which lends\nitself more easily to consumption by programs; for example, by a\nREXX exec using the OUTTRAP function.\n\nThe RACSEQ package consists of these files:\n\n    * Assembler source code for the RACSEQ utility in text format\n      (use this format for casual viewing)\n    * Assembler source code for the RACSEQ utility in TSO\n      TRANSMIT format (use this format for installing)\n    * Documentation in PDF format\n\nYou can download these files either by using your browser or by\nusing anonymous file transfer protocol (ftp). From your browser,\nselect \"file\" and \"save as\". For anonymous ftp, use the site\nftp.software.ibm.com. RACSEQ can be found in the directory\n/eserver/zseries/zos/racf/racseq/. Be sure to FTP the TSO\nTRANSMIT and text files to your MVS environment into data sets\nwhich are in fixed-blocked format and which have a record length\nof 80.\n\nWe welcome your comments and questions on the RACSEQ utility.\nPlease direct them to the RACF-L mailing list. Subscription\ninformation for RACF-L can be found from the RACF-L Discussion\nList Page.\n\n        Disclaimers\n\nThis program contains code made available by IBM Corporation on\nan \"AS-IS\" basis. Any one receiving this program is considered to\nbe licensed under IBM copyrights to use the IBM-provided code in\nany way he or she deems fit, including copying it and\nredistributing it, except that it may be neither sold nor\nincorporated within a product that is sold.  No license under any\nIBM patents or patent applications is to be implied from this\ncopyright license.\n\nThe software is provided \"as-is\", and IBM disclaims all\nwarranties, express or implied, including but not limited to\nimplied warranties of merchantability or fitness for a particular\npurpose.\n\nThis page was last updated July 2006.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#IBMDOC": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01\\x08\\x11_\\x01\\x08\\x11_\\x10H\\x00\\xec\\x00\\xe0\\x00\\x00\\xc9\\xc2\\xd4\\xc4\\xd6\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-04-24T00:00:00", "modifydate": "2008-04-24T10:48:37", "lines": 236, "newlines": 224, "modlines": 0, "user": "IBMDOC"}, "text": "Note:  This is a transcription of the IBM documentation PDF for\n----   the RACSEQ command, as distributed by IBM, under the general\n       category of \"sample programs\".  Please see the disclaimer\n       at the end of this documentation, to note that it is permitted\n       to reproduce this documentation here.\n\n\n                              RACSEQ Command\n\nAuthor: Bruce R. Wells\nz/OS Security Server RACF\nbrwells@us.ibm.com\n\n\n        Change Date       Change Description\n        -----------       ------------------\n        05/18/2006        Introduction of RACSEQ\n        07/19/2006        Add the source file to the package\n                          in TSO TRANSMIT format\n\n\nOverview\n\nRACSEQ is a sample TSO command which demonstrates, in a hopefully\nuseful manner, the profile extract functions of the R_admin RACF\ncallable service (IRRSEQ00).  The command accepts a class name and a\nprofile name and displays the contents of every field in the profile.\nIt differs from LISTUSER and LISTGRP in that the output is displayed\nin a simplified and somewhat architected manner which lends itself\nmore easily to consumption by programs; for example, by a REXX exec\nusing the OUTTRAP function.\n\nYou should read the R_admin documentation in the RACF Callable\nServices publication for an overview of the extract functions.  The\nfield names displayed by RACSEQ are defined in Appendix A of this\npublication.  The extract functions were introduced in z/OS Version 1\nRelease 7.  For an online z/OS R7 version, go to\n\nhttp://publibz.boulder.ibm.com/cgi-bin/bookmgr_OS390/BOOKS/ICHZD160/\n     CCONTENTS?SHELF=ICHZBK60&DN=SA22-7691-08&DT=20050626220222\n\nThe assembler source code of RACSEQ may also be useful as a general\nguide to calling IRRSEQ00, since many of the parameters are used for\nother functions of the interface.\n\nSyntax\n\nRACSEQ \u00ddCLASS(class-name)\u00a8 PROFILE(profile-name)\nCLASS - Specifies the class in which the desired profile exists.\n        The supported values are USER,\n        GROUP, and CONNECT. If omitted, the default is USER.\nPROFILE - Specifies the profile name to be displayed.  For the\n        CONNECT class, the profile name consists of a user ID and a\n        group name separated by a period (for example,\n        \"IBMUSER.SYS1\").  The good news is that profile-name is\n        case-sensitive, and so lower-case profiles like the irrcerta\n        USER profile can be displayed.  The bad news is that\n        profile-name is case-sensitive, so you must remember to enter\n        it in upper case for the vast majority of cases (no pun\n        intended).  If you forget to upper-case the profile name, you\n        will receive a message indicating that the IRRSEQ00 return\n        combination was 4/4/4.\n\nAuthorization Required\n\nThe code runs under the authority of the user issuing the command.\nIt does not need to be APF authorized, or in the list of authorized\nTSO commands.  Depending on how your installation is protecting the\nR_admin callable service, you may need READ access to the\nIRR.RADMIN.LISTUSER or IRR.RADMIN.LISTGRP resources in the FACILITY\nclass.\n\nExample\n\nRACSEQ CLASS(GROUP) PROFILE(RAPTORS)\nDisplaying profile RAPTORS in class GROUP. Segments:02\nSegment: BASE Fields:08\nSUPGROUP:SYS1\nCREATDAT:04/18/06\nOWNER :IBMUSER\nTERMUACC:FALSE\nDATA :BIRDS OF PREY KNOW THEY'RE COOL\nRepeat field:SUBGRPCT Subfields:01 Occurrences:0004\nSUBGROUP:HAWKS\n---------------------------------------------\nSUBGROUP:FALCONS\n---------------------------------------------\nSUBGROUP:EAGLES\n---------------------------------------------\nSUBGROUP:OWLS\n---------------------------------------------\nRepeat field:CONNECTS Subfields:02 Occurrences:0007\nGUSERID :BRUCE\nGAUTH :CONNECT\n---------------------------------------------\nGUSERID :KESTREL\nGAUTH :USE\n---------------------------------------------\nGUSERID :OSPREY\nGAUTH :USE\n---------------------------------------------\nGUSERID :REDTAIL\nGAUTH :JOIN\n---------------------------------------------\nGUSERID :SAWWHET\nGAUTH :CREATE\n---------------------------------------------\nGUSERID :HARRIER\nGAUTH :USE\n---------------------------------------------\nGUSERID :SNOWY\nGAUTH :USE\n---------------------------------------------\nUNIVERSL:FALSE\nSegment: OMVS Fields:01\nGID :4\n\n* The first line echoes the class name and profile name, and\n  indicates how many segments to expect.\n\n* Each segment is identified in a message which also indicates\n  how many fields to expect within the segment.  The fields within\n  that segment are displayed, and then the next segment appears.\n\n* Each field name is identified with its value.\n\n* The value for boolean fields is either TRUE or FALSE.\n\n* If the field is a repeat field, special processing occurs.  First,\n  the repeat field name is displayed, along with an indication of the\n  number of occurrences, and the number of subfields within each\n  occurrence.  Each subfield for an occurrence is displayed, followed\n  by a separator line.  The entire repeat field construct counts as a\n  single field within the number of fields displayed for a segment.\n  See Callable Services for more detail on repeating fields.\n\nPackage Contents\n\nThis package contains\n* This README file\n\n* racseq.asm.txt - the source code for the command (for casual\n  browsing on the web site.  Use the following file to actually\n  install the code.)\n\n* racseq.asm.xmit - the source code in TSO XMIT format\n\nInstallation Instructions\n\n* Download the assembler source code (racseq.asm.xmit) to your\n  workstation using a browser.  Then transfer it to your z/OS system\n  using FTP in binary mode.  You must transfer it into a fixed-block\n  80 data set.  For example, on Windows, this can be accomplished by\n  specifying the following FTP client command before initiating the\n  transfer quote site lrecl=80 recfm=fb blksize=0\n\n* From a TSO session on z/OS, issue the RECEIVE command to\n  unpackage the file.  The syntax of the RECEIVE command is:\n\nRECEIVE INDATASET(dsname)\n\nRECEIVE prompts you for a target data set name.\n\nNote: If you receive a message from the RECEIVE command that\n      indicates the input data set is in an incorrect format,\n      verify that:\n- The files were FTP'd in binary format\n- The input files are in fixed block format\n\n* Assemble the source.\n\n* Link-edit the object code.  Note that you have to include the\n  IBM-supplied IRRSEQ00 stub module into your program.  This stub\n  is located in SYS1.CSSLIB.  For example:\n\n//SEQLINK EXEC PGM=IEWL,PARM='NCAL,LIST,LET,XREF,SIZE=(300K,30K)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1 DD DSN=&SYSUT1,UNIT=SYSDA,SPACE=(1024,(50,20))\n//SYSLMOD DD DISP=SHR,DSN=PROD.LINKLIB\n//AOSBN DD DSN=MY.RACSEQ.OBJ,DISP=SHR\n//CSSLIB DD DSN=SYS1.CSSLIB,DISP=SHR\n//SYSLIN DD *\nINCLUDE AOSBN(RACSEQ)\nINCLUDE CSSLIB(IRRSEQ00)\nENTRY RACSEQ\nNAME RACSEQ(R)\n/*\n\nMessages\n\nApart from normal command output, RACSEQ may issue a number of\nerror messages.\n\nR_admin Error! SAFrc x - RACFrc y - RACFreason z\n\nExplanation: The return code combinations are all documented in\n   Callable Services.  A couple of the more likely combinations you\n   may encounter are\n\n* 4/4/4 - Profile does not exist.  Perhaps you forgot to enter\n   the profile name in upper case.\n\n* 8/8/24 - You are not authorized to display the profile\n\nError! Unsupported class!\nExplanation: Self-explanatory.\n\nSyntax: RACSEQ CLASS(class) PROFILE(profile)\n\nExplanation: This is the command syntax displayed when you enter\n   a syntactically incorrect command, such as by omitting the\n   PROFILE keyword.\n\nIKJPARS error! Return Code n\nExplanation: An unexpected error occurred from the TSO parse service.\n\nDisclaimers, etc.\n\nThis program contains code made available by IBM Corporation on an AS\nIS basis.  Any one receiving this program is considered to be licensed\nunder IBM copyrights to use the IBM-provided source code in any way he\nor she deems fit, including copying it, compiling it, modifying it,\nand redistributing it, with or without modifications, except that it\nmay be neither sold nor incorporated within a product that is sold.\nNo license under any IBM patents or patent applications is to be\nimplied from this copyright license.  The software is provided\n\"as-is\", and IBM disclaims all warranties, express or implied,\nincluding but not limited to implied warranties of merchantibility or\nfitness for a particular purpose.  IBM shall not be liable for any\ndirect, indirect, incidental, special or consequential damages arising\nout of this agreement or the use or operation of the software.\n\nA user of this program should understand that IBM cannot provide\ntechnical support for the program and will not be responsible for any\nconsequences of use of the program.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE781": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00\\x01\\x01\\x13\\x00\\x1f\\x01\\x13\\x00\\x1f\\x13\\x16\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-01-01T00:00:00", "modifydate": "2013-01-01T13:16:01", "lines": 20, "newlines": 20, "modlines": 0, "user": "CBT-486"}, "text": "//***FILE 781 is from John McKown, and is his modification of an    *   FILE 781\n//*           IBM-distributed sample program called RACSEQ.  The    *   FILE 781\n//*           disclaimer of the IBM sample program allows that it   *   FILE 781\n//*           be reproduced here, so that members #IBMDOC,          *   FILE 781\n//*           #IBMCODE and @IBMCODE are transcribed here, pretty    *   FILE 781\n//*           much verbatim.                                        *   FILE 781\n//*                                                                 *   FILE 781\n//*       email:  \"McKown, John\" <john.archie.mckown@GMAIL.com>     *   FILE 781\n//*                                                                 *   FILE 781\n//*     This is a modification of the IBM supplied RACSEQ           *   FILE 781\n//*     program.  It has been modified to be able to write its      *   FILE 781\n//*     output in XML format.  It has also been extended to write   *   FILE 781\n//*     to a specified DDName, DSName, Sysout class, or UNIX        *   FILE 781\n//*     Path.  When writing to a DSName, it can either be an        *   FILE 781\n//*     existing DSName, or a new one.  If it is a new one, the     *   FILE 781\n//*     DSName will be allocated with either the system defaults,   *   FILE 781\n//*     the SMS defaults as assigned by the ACS routines, or with   *   FILE 781\n//*     the characteristics specified via a USING() and/or LIKE()   *   FILE 781\n//*     parameter.                                                  *   FILE 781\n//*                                                                 *   FILE 781\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@IBMCODE": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x08\\x11_\\x01\\x08\\x11_\\tH\\x03\\x84\\x03\\x84\\x00\\x00\\xc9\\xc2\\xd4\\xe2\\xc1\\xd4\\xd7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-24T00:00:00", "modifydate": "2008-04-24T09:48:50", "lines": 900, "newlines": 900, "modlines": 0, "user": "IBMSAMP"}, "text": "RACSEQ TITLE 'RACSEQ - USE R_ADMIN TO EXTRACT RACF PROFILE'\n***********************************************************************\n***********************************************************************\n***                                                                 ***\n***  MODULE - RACSEQ                                                ***\n***                                                                 ***\n***      This TSO command invokes the extract function of R_admin   ***\n***      (IRRSEQ00) and displays every profile field to the         ***\n***      display using PUTLINE.                                     ***\n***                                                                 ***\n***      It is invoked from the TSO command line like:              ***\n***        RACSEQ CLASS(classname) PROFILE(profilename)             ***\n***                                                                 ***\n***      The supported classes are USER, GROUP, and CONNECT.        ***\n***      If not specified, CLASS defaults to USER. All values for   ***\n***      CLASS will be folded to upper case by TSO parse services.  ***\n***                                                                 ***\n***      The PROFILE field is a user ID or group name for USER      ***\n***      and GROUP, respectively. For CONNECT, it is the user ID    ***\n***      followed by a period followed by the group name. E.G.      ***\n***       IBMUSER.SYS1                                              ***\n***                                                                 ***\n***      NOTE: \"profilename\" is case-sensitive! This means you can  ***\n***            display lower case user IDs such as irrcerta, but    ***\n***            it also means you must remember to upper-case the    ***\n***            user ID for most cases.  If you forget, you will     ***\n***            receive a 4/4/4 return code combination!             ***\n***                                                                 ***\n***  INPUT: R1 points to the address of the CPPL                    ***\n***                                                                 ***\n***  RETURN CODES:                                                  ***\n***     0 - This sample always returns 0 unless altered.            ***\n***  non0 - Parse rc or SAF rc from R_admin                         ***\n***                                                                 ***\n***  Register usage:                                                ***\n***   R11 - Autodata base register                                  ***\n***   R12 - Base register                                           ***\n***   R13 - Savearea address                                        ***\n***  Further register usage is documented in the code below.        ***\n***                                                                 ***\n***********************************************************************\n***********************************************************************\n         EJECT\n***********************************************************************\n***********************************************************************\n***                                                                 ***\n***      COPYRIGHT IBM CORPORATION, 2006                            ***\n***                                                                 ***\n***      THIS CODE HAS NOT BEEN SUBMITTED TO ANY FORMAL IBM TEST    ***\n***      AND IS DISTRIBUTED ON AN \"AS IS\" BASIS WITHOUT ANY         ***\n***      WARRANTY EITHER EXPRESS OR IMPLIED. THE IMPLEMENTATION     ***\n***      OF ANY OF THE TECHNIQUES DESCRIBED OR USED HEREIN IS A     ***\n***      CUSTOMER RESPONSIBILITY AND DEPENDS ON THE CUSTOMER'S      ***\n***      OPERATIONAL ENVIRONMENT. WHILE EACH ITEM MAY HAVE BEEN     ***\n***      REVIEWED FOR ACCURACY IN A SPECIFIC SITUATION AND MAY      ***\n***      RUN IN A SPECIFIC ENVIRONMENT, THERE IS NO GUARANTEE       ***\n***      THAT THE SAME OR SIMILAR RESULTS WILL BE OBTAINED ELSE-    ***\n***      WHERE. CUSTOMERS ATTEMPTING TO ADAPT THESE TECHNIQUES TO   ***\n***      THEIR OWN ENVIRONMENTS DO SO AT THEIR OWN RISK.            ***\n***                                                                 ***\n***********************************************************************\n***********************************************************************\n         EJECT\nRACSEQ   CSECT ,                   An R_admin sample routine\nRACSEQ   AMODE 31\nRACSEQ   RMODE 31\nRACSEQ   CSECT\n         SAVE  (14,12),,RACSEQ-&SYSDATE-&SYSTIME\n         LR    R12,R15             program addressability\n         USING RACSEQ,R12          set base register\n         LR    R10,R1              save input CPPL address\n*\n* Get dynamic storage\n*\n         L     R0,DYNSIZE          dynamic area size to R0\n         GETMAIN RU,LV=(0)         getmain dynamic area\n*              LV=(0),SP=229\n         LR    R11,R1              dynamic area addressability\n         USING DATD,R11            base\n         ST    R13,SAVEAREA+4      save caller's savearea address\n         ST    R11,8(R13)          save our savearea address\n         LR    R13,R11             our savearea address to R13\n         ST    R10,CPPLPTR         save saved input CPPL address\n         EJECT\n*\n* Initialize PUTLINE Output Line Descriptor (OLD) segment pointers\n* for use throughout this program. The pointers to the segments (i.e.\n* message line and inserts) remain constant; each message will set the\n* number of segments and the actual length/data.\n* Register usage\n*  R2 = CPPLUPT for PUTLINE\n*  R3 = CPPLECT for PUTLINE\n*  R5 = Disposable work reg\n*  R10 = Disposable work reg\n*\n         LA    R10,SEG1LEN\n         ST    R10,OLDSEGA1\n         LA    R10,SEG2LEN\n         ST    R10,OLDSEGA2\n         LA    R10,SEG3LEN\n         ST    R10,OLDSEGA3\n         LA    R10,SEG4LEN\n         ST    R10,OLDSEGA4\n*\n* Initialize parse stuff and parse the input command image.\n*\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         LA    R6,DYNPPL            GET ADDRESS OF PPL\n         USING PPL,R6               AND ESTABLISH ADDRESSABILITY\n         MVC   PPLUPT,CPPLUPT       PUT IN THE UPT ADDRESS FROM CPPL\n         L     R2,CPPLUPT           And keep it around in R2\n         MVC   PPLECT,CPPLECT       PUT IN THE ECT ADDRESS FROM CPPL\n         L     R3,CPPLECT           And keep it around in R3\n         MVC   PPLCBUF,CPPLCBUF     PUT IN THE COMMAND BUFFER ADDRESS\n         L     R5,=A(RACPDE)        Get address of parse macros (PCL)\n         ST    R5,PPLPCL            STORE IT IN THE PPL\n         LA    R5,PDLPTR            Get address of parse result anchor\n         ST    R5,PPLANS            STORE IT IN THE PPL\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)   INVOKE PARSE\n         LTR   R15,R15              IF PARSE RETURN CODE IS ZERO\n         BZ    GETANS               Go process results\n         DROP  R1\n*\n* Unexpected parse error.  Print return code and bail.\n*\n         ST    R15,SAFRC            Store rc\n         MVC   OLDNUM,=A(2)         One message segment\n         LA    R10,L'MSG9+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG9\n         LA    R10,6                2-digit rc + header\n         STH   R10,SEG2LEN\n         LA    R10,L'MSG9           Insert position of rc (eol)\n         STH   R10,SEG2OFF\n         CVD   R15,PACKDEC1         Convert 2 digits of parse rc\n         LA    R10,PACKDEC1\n         UNPK  0(2,R10),6(2,R10)\n         OI    1(R10),X'F0'         Fix the sign nibble\n         MVC   SEG2DATA(2),PACKDEC1 Move 2-char parse rc\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         B     GETOUT               Get out of Dodge\n*\n* Get the class name and profile name from parse output. The class\n* name will determine the R_Admin function code to use.\n*\nGETANS   DS    0H\n         L     R1,PPLANS            Get the PDL anchor address\n         L     R1,0(R1)             Get the PDL address itself\n         ST    R1,PDLPTR            Save it for later\n         DROP  R6\n         USING SEQPDL,R1            Get addressability to PDL\n         EJECT\n*\n* Initialize IRRSEQ00 parameters\n*\n         MVI   FUNCODE,ADMN_XTR_USER Assume USER class for now\n         OC    PDLCLASS,PDLCLASS    CLASS specified?\n         BZ    MOREPRMS             No, default to USER\n         L     R10,CLSPTR           Get class name ptr\n         CLC   GRPCLS(5),0(R10)     GROUP class?\n         BNE   CHKCON               Nope\n         MVI   FUNCODE,ADMN_XTR_GROUP Yup\n         B     MOREPRMS             Continue with R_admin parms\nCHKCON   DS    0H\n         CLC   CONCLS(7),0(R10)     CONNECT class?\n         BNE   CHKUSR               Nope\n         MVI   FUNCODE,ADMN_XTR_CONNECT Yup\n         B     MOREPRMS             Continue with R_admin parms\nCHKUSR   DS    0H\n         CLC   USERCLS(4),0(R10)    USER class?\n         BE    MOREPRMS             Yup\n         DROP  R1\n*\n*        Error - unsupported class. Issue a message.\n*\n         MVC   OLDNUM,=A(1)         One message segment\n         LA    R10,L'MSG7+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG7\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         B     GETOUT               Get out of dodge\n         USING SEQPDL,R1            Get addressability to PDL\nMOREPRMS DS    0H\n         XC    ALET,ALET            Use zero ALET\n         XC    SAFRC,SAFRC          Initialize return/reason codes\n         XC    RACFRC,RACFRC\n         XC    RACFRS,RACFRS\n         XC    USERLEN,USERLEN      Not supplying \"run-as\" user\n         XC    ACEE,ACEE            Not supplying \"run-as\" ACEE\n         MVI   SUBPOOL,127          Use subpool 127\n         XC    OUTMSG,OUTMSG        Clear output message pointer\n*\n* In the Parm_list area, fill in the version and the user length,\n* and copy the input user ID to the contiguous storage after the\n* Parm_list storage.\n*\n         LA    R6,RADPLIST\n         USING ADMN_PROF_MAP,R6\n         MVI   ADMN_PROF_VERSION,0\n         OC    PDLPROF,PDLPROF      PROFILE specified?\n         BNZ   GETPROF\n*\n*        Error.  No profile.  Issue syntax message.\n*\n         MVC   OLDNUM,=A(1)         One message segment\n         LA    R10,L'MSG8+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG8\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         B     GETOUT               Get out of Dodge\nGETPROF  DS    0H\n         USING SEQPDL,R1            Get addressability to PDL\n         LH    R8,PROFLEN           Get profile length\n         ST    R8,ADMN_PROF_NAMELEN Save length in plist header\n         L     R9,PROFPTR\n* The following instruction moves too much storage, but the extra will\n* be ignored because we just set the length accurately. But, this is\n* lazy and an execute instruction should be used.\n         MVC   EXTPROF,0(R9)        Move profile name to R_admin plist\n         DROP  R1\n         DROP  R6\n         EJECT\n*\n* Initialize IRRSEQ00 call parameter list.  That is, a list of\n* addresses to the individual parameters set up above.\n*\n         LA    R1,WORKAREA\n         ST    R1,WORKAREA@\n         LA    R1,ALET\n         ST    R1,ALET1@\n         ST    R1,ALET2@\n         ST    R1,ALET3@\n         LA    R1,SAFRC\n         ST    R1,SAFRC@\n         LA    R1,RACFRC\n         ST    R1,RACFRC@\n         LA    R1,RACFRS\n         ST    R1,RACFRS@\n         LA    R1,FUNCODE\n         ST    R1,FUNCODE@\n         LA    R1,RADPLIST\n         ST    R1,RADPLIST@\n         LA    R1,USER\n         ST    R1,USER@\n         LA    R1,ACEE\n         ST    R1,ACEE@\n         LA    R1,SUBPOOL\n         ST    R1,SUBPOOL@\n         LA    R1,OUTMSG\n         ST    R1,OUTMSG@\n         OC    OUTMSG@,=X'80000000'       Turn on VL bit in last parm\n*\n* Call R_admin.  We've manually built the plist which would correspond\n* to the following CALL statement (continuation characters omitted).\n*\n*        CALL  IRRSEQ00,\n*              (WORKAREA,\n*              ALET,SAFRC,\n*              ALET,RACFRC,\n*              ALET,RACFRS,\n*              FUNCODE,\n*              RADPLIST,\n*              0,0,              Not passing \"run-as\" user or ACEE\n*              SUBPOOL,\n*              OUTMSG),VL\n         LA    R1,WORKAREA@      Get list of addrs in R1\n         L     R15,=V(IRRSEQ00)\n         BALR  R14,R15\n*\n* Test return code and issue an error message if non-zero\n*\n         ICM   R5,B'1111',SAFRC     Get SAF return code\n         BZ    GOODSEQ\n*\n* Convert the return/reason codes for message inserts\n*\n         CVD   R5,PACKDEC1          Convert binary to packed decimal\n         LA    R5,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal\n         OI    1(R5),X'F0'          Fix the sign nibble\n         L     R5,RACFRC            Convert the RACF rc too\n         CVD   R5,PACKDEC2\n         LA    R5,PACKDEC2\n         UNPK  0(2,R5),6(2,R5)\n         OI    1(R5),X'F0'\n         L     R5,RACFRS            Convert the RACF reason code too\n         CVD   R5,PACKDEC3\n         LA    R5,PACKDEC3\n         UNPK  0(2,R5),6(2,R5)\n         OI    1(R5),X'F0'\n         MVC   OLDNUM,=A(4)         Four message segments\n         LA    R5,L'MSG6+4\n         STH   R5,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG6\n         LA    R5,6                 All inserts will be 2 chars + hdr\n         STH   R5,SEG2LEN\n         STH   R5,SEG3LEN\n         STH   R5,SEG4LEN\n         LA    R5,22                Insert position of SAF rc\n         STH   R5,SEG2OFF\n         MVC   SEG2DATA(2),PACKDEC1 Move 2-char SAF rc\n         LA    R5,32                Insert position of RACF rc\n         STH   R5,SEG3OFF\n         MVC   SEG3DATA(2),PACKDEC2 Move 2-char RACF rc\n         LA    R5,L'MSG6            Insert position of RACF rc (eol)\n         STH   R5,SEG4OFF\n         MVC   SEG4DATA(2),PACKDEC3 Move 2-char RACF rc\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         B     GETOUT\n         EJECT\n*\n* R_admin worked! We'll start the command output by simply echoing\n* the class and profile name, just to reassure the user. Also say\n* how many segments there are.\n*\nGOODSEQ  DS    0H                   Issue warm and fuzzy message\n         MVC   OLDNUM,=A(4)         Four message segments\n         LA    R5,L'MSG1+4\n         STH   R5,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG1\n         L     R1,PDLPTR\n         USING SEQPDL,R1\n         LH    R5,PROFLEN           Get profile name length\n         LA    R5,4(R5)             Add 4 for header (length/offset)\n         STH   R5,SEG2LEN\n         LA    R5,20                Offset of first insert\n         STH   R5,SEG2OFF\n         L     R14,PROFPTR          Source: profile pointer from parse\n         LA    R15,SEG2DATA         Target: segment data\n         LH    R5,SEG2LEN           Get profile length back\n         BCTR  R5,0                 Decrement for execute\n         EX    R5,MOVESTR           Move profile name to msg data\n*\n         LA    R5,30                Offset of second insert\n         STH   R5,SEG3OFF\n         ICM   R9,B'1111',CLSPTR    Get Class pointer from PDL\n         BZ    USEUSER              Not specified, default to USER\n         LH    R5,CLSLEN            Get class name length\n         LA    R5,4(R5)             Add 4 for header (len/offset)\n         STH   R5,SEG3LEN\n         MVC   SEG3DATA,0(R9)       Move class name to msg data\n         B     SEGNUMS              Proceed\n         DROP  R1\nUSEUSER  DS    0H                   Display USER class\n         LA    R5,8                 4 for \"USER\" + header\n         STH   R5,SEG3LEN\n         MVC   SEG3DATA(4),=C'USER' Move USER class name to msg data\nSEGNUMS  DS    0H                   Insert number of segments\n         LA    R5,6                 Max 2-digit #segments\n         STH   R5,SEG4LEN\n         LA    R5,L'MSG1            Offset of third insert (eol)\n         STH   R5,SEG4OFF\n         USING ADMN_PROF_MAP,R1\n         L     R1,OUTMSG            Get output address in R1\n         L     R5,ADMN_PROF_NUMSEG  Number of segment descriptors\n         CVD   R5,PACKDEC1          Convert binary to packed decimal\n         LA    R5,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal\n         OI    1(R5),X'F0'          Fix the sign nibble\n         MVC   SEG4DATA(2),PACKDEC1 Move 2-char number of segments\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         EJECT\n***********************************************************************\n*\n* Now process the output.  For each segment descriptor, print a message\n* indicating the segment name.  For each of its field descriptors,\n* print the field name and its data.\n*  - For boolean field, print TRUE or FALSE\n*  - For repeat fields, print each of its constituent fields\n*\n* Register usage\n*  R1 = R_admin output buffer (OUTMSG)\n*  R2 = Number of segment descriptors to process\n*  R3 = Address of current segment descriptor\n*  R4 = Number of field descriptors to process\n*  R5 = Address of current field descriptor\n*\n***********************************************************************\n         USING ADMN_PROF_MAP,R1\n         L     R1,OUTMSG             Get output address in R1\n         L     R2,ADMN_PROF_NUMSEG   Number of segment descriptors\n         LA    R3,ADMN_PROF_PROFNAME Get addr of profile name\n         A     R3,ADMN_PROF_NAMELEN  Add length of profile name to get *\n                                     addr of 1st segment descriptor\n         USING ADMN_PROF_SEGDESC,R3  Basing for segment descriptor\n*\n         L     R5,ADMN_PROF_FIELDOFFSET Get offset to 1st field desc.\n         AR    R5,R1                 Add to base to get address\n         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor\n*\nDOSEGS   DS    0H                    For each segment descriptor\n         L     R4,ADMN_PROF_NUMFIELDS Number of field descriptors for  *\n                                     this segment\n         BAL   R14,SEGMSG            Issue segment message\n*\nDOFIELDS DS    0H                    For each field descriptor\n         XR    R9,R9                 Clear R9 for insert\n         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Get type of field\n         L     R8,=A(ADMN_PROF_RPTHDR) Is it a repeat field header?\n         CR    R9,R8\n         BE    REPEAT                Yes, repeat field\n* Boolean fields and normal character fields land here. Go print them.\n         BAL   R14,FLDMSG            Display field name and value\n         B     NEXTFLD               Get next field\nREPEAT   DS    0H\n         BAL   R15,DOREPEAT          Go process repeat field. R5 will  *\n                                     point to next FD on return\n         B     NEXTFLD2              Continue with main fields\n*\n* Set basing for next field descriptor. Decrement count of fields\n* to see if we are finished.\n*\nNEXTFLD  DS    0H\n         LA    R5,ADMN_PROF_NEXTFIELD Get next FD address\nNEXTFLD2 DS    0H\n         BCT   R4,DOFIELDS           Decrement number of fields\n         B     NEXTSEG               Done with fields. Check next seg\n*\n* Set basing for next segment descriptor. Decrement count of segments\n* to see if we are finished. Note that R5 is already pointing to the\n* first field descriptor in the next segment.\n*\nNEXTSEG  DS    0H\n         LA    R3,ADMN_PROF_NEXTSEG  Get next SD address\n         BCT   R2,DOSEGS             Decrement number of segments\n         B     FREEOUT               Done with segments, finish up\n         EJECT\n*\n* free the R_admin output storage\n*\nFREEOUT  DS    0H\n         L     R0,ADMN_PROF_OUTLEN Output area size to R0\n         FREEMAIN RU,SP=127,       freemain                            *\n               LV=(0),             dynamic                             *\n               A=(1)               area\n         DROP  R1\n*\n* free the parse PDL and our dynamic storage and return...\n*\nGETOUT   DS    0H\n         LA    R1,PDLPTR           Point to the PDL pointer\n         IKJRLSA (R1)              Free storage that parse allocated\n         L     R0,DYNSIZE          Dynamic area size to R0\n         L     R13,SAVEAREA+4      Restore R13\n         LR    R1,R11              Dynamic data address to R1\n         FREEMAIN RU,LV=(0),A=(1)  Freemain dynamic area\n         L     R15,SAFRC           Make SAF rc overall rc\n         RETURN (14,12),T,RC=(15)  Restore registers and return\nMOVESTR  MVC   0(*-*,R15),0(R14)\n         EJECT\n*---------------------------------------------------------------------*\n* DOREPEAT:                                                           *\n*                                                                     *\n* For repeat fields, cycle through each subfield for each occurrence. *\n*                                                                     *\n* Register input:  R5  = address of repeat field header descriptor    *\n*                  R14 = return address                               *\n*                                                                     *\n* Register output: R5  = address of the next field descriptor after   *\n*                        the entire repeat field just processed       *\n*                                                                     *\n* Register usage:                                                     *\n*  R6 - Number of occurrences of repeat field                         *\n*  R7 - Number of subfields within each occurrence                    *\n*  R8 - Address of subfield descriptor                                *\n*  R9 - Work register                                                 *\n*---------------------------------------------------------------------*\nDOREPEAT DS    0H\n         BAL   R14,RPTMSG            Go print header field\n         L     R6,ADMN_PROF_RPTNUM   Number of occurrences\n         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address\nRPTOCC   DS    0H                    Process occurrence\n         L     R7,ADMN_PROF_FIELDDIM Number of subfields per occurrence\n         DROP  R5\nRPTSFLD  DS    0H                    Process subfield\n         ST    R5,SAVEFD             Save header field descriptor\n         LR    R5,R8                 Get subfield desc in R5 for FLDMSG\n         BAL   R14,FLDMSG            Print subfield name and value\n         L     R5,SAVEFD             Get header FD back\n         USING ADMN_PROF_FIELDDESC,R8 Basing for subfield descriptor\n         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address\n         BCT   R7,RPTSFLD            Loop if subfields remaining\n         BAL   R14,SEPMSG            Print separator\n         BCT   R6,RPTOCC             Loop if occurrences remaining\n         LR    R5,R8                 All done. Set R5 to next FD addr\n         BR    R15                   Return to caller\n         DROP  R8\n*---------------------------------------------------------------------*\n* SEGMSG:                                                             *\n*                                                                     *\n* At the beginning of each segment, issue a message identifying the   *\n* segment name.                                                       *\n*                                                                     *\n* Register input:  R3  = address of segment descriptor                *\n*                  R4  = number of fields in this segment             *\n*                  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*---------------------------------------------------------------------*\nSEGMSG   DS    0H\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(3)         Three message segments\n         LA    R10,L'MSG2+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG2\n         LA    R10,8+4              Get segment name length + header\n         STH   R10,SEG2LEN\n         LA    R10,10               Offset of 1st insert\n         STH   R10,SEG2OFF\n         MVC   SEG2DATA(8),ADMN_PROF_SEGNAME  Move in segment name\n         LA    R2,6                 Max 2-digit number of fields\n         STH   R2,SEG3LEN\n         LA    R2,L'MSG2            Insert position of insert (eol)\n         STH   R2,SEG3OFF\n         CVD   R4,PACKDEC1          Convert binary to packed decimal\n         LA    R2,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal\n         OI    1(R2),X'F0'          Fix the sign nibble\n         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of fields\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         DROP  R1\n         EJECT\n*---------------------------------------------------------------------*\n* RPTMSG:                                                             *\n*                                                                     *\n* At the beginning of each repeat field, print a message identifying  *\n* the repeat field header name. There is no data to print.            *\n*                                                                     *\n* Register input:  R5  = address of field descriptor                  *\n*                  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nRPTMSG   DS    0H\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(4)         Four message segments\n         LA    R10,L'MSG3+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG3\n         LA    R10,8+4              Get field name length + header\n         STH   R10,SEG2LEN\n         LA    R10,16               Offset of 1st insert\n         STH   R10,SEG2OFF\n         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor\n         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name\n*\n         LA    R2,6                 Max 2-digit #subfields\n         STH   R2,SEG3LEN\n         LA    R2,27                Offset of 2nd insert\n         STH   R2,SEG3OFF\n         L     R4,ADMN_PROF_FIELDDIM Number of subfields per occurrence\n         CVD   R4,PACKDEC1          Convert binary to packed decimal\n         LA    R2,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal\n         OI    1(R2),X'F0'          Fix the sign nibble\n         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of subfields\n*\n         LA    R2,8                 Max 4-digit #occurrences\n         STH   R2,SEG4LEN\n         LA    R2,L'MSG3            Offset of 3rd insert (end of line)\n         STH   R2,SEG4OFF\n         L     R4,ADMN_PROF_RPTNUM  Number of occurrences\n         CVD   R4,PACKDEC2          Convert binary to packed decimal\n         LA    R2,PACKDEC2          Point to source\n         UNPK  0(4,R2),5(3,R2)      Then to zoned decimal\n         OI    3(R2),X'F0'          Fix the sign nibble\n         MVC   SEG4DATA(4),PACKDEC2 Move 4-char number of occurrences\n*\n         DROP  R5\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         DROP  R1\n         EJECT\n*---------------------------------------------------------------------*\n* FLDMSG:                                                             *\n*                                                                     *\n* For each field, display the field name and its value.               *\n*                                                                     *\n* Register input:  R5  = address of field descriptor                  *\n*                  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*---------------------------------------------------------------------*\nFLDMSG   DS    0H\n         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(3)         Three message segments\n         XC    SEG1OFF,SEG1OFF      Segment 1 offset always 0\n         XR    R9,R9                Clear R9 for insert\n         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Get type of field\n         L     R8,=A(ADMN_PROF_REPEAT)\n         NR    R9,R8                Piece of repeat field?\n         BZ    NOTRPT               Nope\n         LA    R10,L'MSG4RPT+4      Use extra indentation for repeat\n         STH   R10,SEG1LEN\n         MVC   SEG1DATA,MSG4RPT\n         MVC   SEG2OFF,=AL2(5)      Indent field name 5 spaces\n         LA    R10,L'MSG4RPT        Offset of 3rd insert (end of line)\n         STH   R10,SEG3OFF\n         B     NXTMSEG\nNOTRPT   DS    0H\n         LA    R10,L'MSG4+4\n         STH   R10,SEG1LEN\n         MVC   SEG1DATA,MSG4\n         MVC   SEG2OFF,=AL2(3)      Indent field name 3 spaces\n         LA    R10,L'MSG4           Offset of 3rd insert (end of line)\n         STH   R10,SEG3OFF\nNXTMSEG  DS    0H\n         LA    R10,8+4              Get field name length + header\n         STH   R10,SEG2LEN\n         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name\n*\n         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Reload field type\n         L     R8,=A(ADMN_PROF_BOOLEAN)\n         NR    R9,R8                      Is field boolean?\n         BZ    NOTBOOL\n         L     R9,ADMN_PROF_FIELDFLAG     Get flag word\n         L     R8,=A(ADMN_PROF_VALUE)     Get equate for true/false\n         SLL   R8,16                      Move halfword to fullword\n         NR    R9,R8                      Is boolean value bit on?\n         BZ    NOTTRUE\n         LA    R10,4+4              Length(\"TRUE\") + header\n         STH   R10,SEG3LEN\n         MVC   SEG3DATA,=C'TRUE'\n         B     DOFPUT\nNOTTRUE  DS    0H\n         LA    R10,5+4              Length(\"FALSE\") + header\n         STH   R10,SEG3LEN\n         MVC   SEG3DATA,=C'FALSE'\n         B     DOFPUT\nNOTBOOL  DS    0H\n         L     R10,ADMN_PROF_FIELDLEN     Get length of field data\n         C     R10,=A(L'SEG3DATA)         Is value > buffer length?\n         BNH   NOPROB                     No\n         LA    R10,L'SEG3DATA             Lazy again, just truncate\nNOPROB   DS    0H\n         ST    R10,SAVEDLEN               Save it for later\n         LA    R10,4(R10)                 Add 4 for header\n         STH   R10,SEG3LEN                Store it\n         L     R14,ADMN_PROF_DATA_OFFSET  Get offset of field data\n         A     R14,OUTMSG                 Add to start of output block\n         LA    R15,SEG3DATA               Target: msg segment 3 data\n         L     R10,SAVEDLEN               Reload field length\n         BCTR  R10,0                Decrement length for move\n         EX    R10,MOVESTR          Move field data\nDOFPUT   DS    0H\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         DROP  R1\n         EJECT\n*---------------------------------------------------------------------*\n* SEPMSG:                                                             *\n*                                                                     *\n* Print a separator line between occurrences of a repeat field.       *\n*                                                                     *\n* Register input:  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSEPMSG   DS    0H\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(1)         One message segment\n         LA    R10,L'MSG5+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA,MSG5\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         DROP  R1\n         EJECT\n*\n***********************************************************************\n*\n*\n* PARSE macros used to describe the command operands\n*\n*\n***********************************************************************\nRACPDE   IKJPARM\nKWCLASS  IKJKEYWD\n         IKJNAME 'CLASS',SUBFLD=SEQCLASS\nKWPROF   IKJKEYWD\n         IKJNAME 'PROFILE',SUBFLD=SEQPROF\nSEQCLASS IKJSUBF\nSFCLASS  IKJIDENT 'CLASS',MAXLNTH=8,FIRST=ANY,OTHER=ANY,               *\n               DEFAULT='USER',                                         *\n               HELP=('RACF class name from which to extract')\n*\nSEQPROF  IKJSUBF\nSFPROF   IKJIDENT 'PROFILE',MAXLNTH=255,FIRST=ANY,OTHER=ANY,           *\n               HELP=('RACF profile name to extract'),ASIS,             *\n               PROMPT='Profile name. Use <user>.<group> for CONNECT'\n         IKJENDP\n         EJECT\n*\n* static data\n*\n         DS    0D\nDYNSIZE  DC    AL4(SIZEDATD)       dynamic area size\nUSERCLS  DC    CL4'USER'           USER class\nGRPCLS   DC    CL5'GROUP'          GROUP class\nCONCLS   DC    CL7'CONNECT'        CONNECT class\nPUTSEQ   PUTLINE MF=L\n*\n* Define text of command output and error messages. There must be\n* a leading blank so that we are immune to the TSO PROFILE MSGID\n* setting.\n*\nMSG1     DC    CL41' Displaying profile  in class . Segments:'\nMSG2     DC    CL18' Segment:  Fields:'\nMSG3     DC    CL40'   Repeat field: Subfields: Occurrences:'\nMSG4     DC    CL4'   :'             2 spaces||fieldname||:||value\nMSG4RPT  DC    CL6'     :'           4 spaces||fieldname||:||value\nMSG5     DC    CL50'     ---------------------------------------------'\nMSG6     DC    CL46' R_admin Error! SAFrc  - RACFrc  - RACFreason '\nMSG7     DC    CL26' Error! Unsupported class!'\nMSG8     DC    CL45' Syntax: RACSEQ CLASS(class) PROFILE(profile)'\nMSG9     DC    CL28' IKJPARS error! Return Code '\n         DS    0D\n         LTORG\n*\n* DSECT for this routine's dynamic area\n*\nDATD     DSECT\n         DS    0D\nSAVEAREA DS    18F                 register save area\nREGSAVE  DS    16F                 internal subroutine save area\nSAVEDLEN DS    F                   Temp variable for field data length\nSAVEFD   DS    F                   Temp variable for @ field descriptor\nDYNPPL   DS    CL(L_PPL)           PPL area\nPPLPTR   DS    F                   Pointer to DYNPPL\nCPPLPTR  DS    F                   Pointer to input CPPL\nPDLPTR   DS    F                   Pointer to output PDL\nMYECB    DS    F                   Command ECB\nPUTIOPL  DS    4F                  E-form IOPL area for PUTLINE\nPUTECB   DS    F                   ECB for PUTLINE\nPACKDEC1 DS    CL8                 Output for CVD\nPACKDEC2 DS    CL8                 Output for CVD\nPACKDEC3 DS    CL8                 Output for CVD\n*\n* Output Line Descriptor (OLD) fields for PUTLINE\nOLDNUM   DS    F                   Number of segments\nOLDSEGA1 DS    F                   Pointer to first message segment\nOLDSEGA2 DS    F                   Pointer to second message segment\nOLDSEGA3 DS    F                   Pointer to third message segment\nOLDSEGA4 DS    F                   Pointer to fourth message segment\nSEG1LEN  DS    H                   Segment 1 length\nSEG1OFF  DS    H                   Segment 1 offset\nSEG1DATA DS    CL100               Segment 1 data\nSEG2LEN  DS    H                   Segment 2 length\nSEG2OFF  DS    H                   Segment 2 offset\nSEG2DATA DS    CL100               Segment 2 data\nSEG3LEN  DS    H                   Segment 3 length\nSEG3OFF  DS    H                   Segment 3 offset\nSEG3DATA DS    CL255               Segment 3 data\nSEG4LEN  DS    H                   Segment 4 length\nSEG4OFF  DS    H                   Segment 4 offset\nSEG4DATA DS    CL255               Segment 4 data\n*\n* Parms for IRRSEQ00\n*\nWORKAREA DS    CL1024\nALET     DS    F\nSAFRC    DS    F\nRACFRC   DS    F\nRACFRS   DS    F\nFUNCODE  DS    AL1\nUSER     DS    0CL9\nUSERLEN  DS    AL1\nUSERID   DS    CL8\nACEE     DS    F\nSUBPOOL  DS    AL1\nOUTMSG   DS    F\nRADPLIST DS    CL(ADMN_PROF_PROFNAME-ADMN_PROF_MAP) Plist header\nEXTPROF  DS    CL17                                 Profile to extract\n*\n* Parm list for IRRSEQ00.  That is, a list of adresses to the actual\n* Parameter data defined above.\n*\nWORKAREA@ DS    A\nALET1@    DS    A\nSAFRC@    DS    A\nALET2@    DS    A\nRACFRC@   DS    A\nALET3@    DS    A\nRACFRS@   DS    A\nFUNCODE@  DS    A\nRADPLIST@ DS    A\nUSER@     DS    A\nACEE@     DS    A\nSUBPOOL@  DS    A\nOUTMSG@   DS    A\nSIZEDATD EQU   *-DATD              length of DSECT\n*\n***********************************************************************\n* The following DSECT maps the results of the parse.                  *\n***********************************************************************\n         EJECT\nSEQPDL   DSECT\nPDLHDR   DS    CL8\nPDLCLASS DS    H\nPDLPROF  DS    H\nPDECLASS DS    0CL8\nCLSPTR   DS    F\nCLSLEN   DS    H\n         DS    CL2\nPDEPROF  DS    0CL8\nPROFPTR  DS    F\nPROFLEN  DS    H\n         DS    CL2\n*\n* equates\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n*\n* MAPPINGS\n*\n         IKJCPPL\n         IKJPPL\nL_PPL    EQU   *-PPL\n         EJECT\n         IRRPCOMP\n         EJECT\n         CVT   DSECT=YES        CVT MAPPING NEEDED FOR CALLTSSR MACRO\n         END   RACSEQ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMACL": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00C\\x01\\x08\\x11O\\x01\\x08\\x11O\\x11\\t\\x00)\\x00\\x91\\x00\\x00\\xe3\\xe2\\xc8\\xf0\\xf0\\xf9@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-04-23T00:00:00", "modifydate": "2008-04-23T11:09:43", "lines": 41, "newlines": 145, "modlines": 0, "user": "TSH009"}, "text": "// SET SORCLIB=SOURCE.LIBRARY\n// SET LNKLIB=OUTPUT.LINK.LIBRARY\n// INCLUDE MEMBER=BBREL\n//*SET BBREL=BB9603\n//STEP010  EXEC  ASMACL,\n//             PARM.ASM=(ASA,BATCH,\n//             'LIST(133)','LANGUAGE(EN)',\n//             'SIZE(MAX)'),\n//             PARM.LKED=(MAP,\n//             'LET=4',\n//             'LIST=ALL',\n//             XREF)\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,\n//             DISP=SHR\n//         DD  DSN=SYS1.MODGEN,\n//             DISP=SHR\n//         DD  DSN=ASM.SASMMAC1,\n//             DISP=SHR\n//         DD  DSN=ASM.SASMMAC2,\n//             DISP=SHR\n//ASM.SYSIN DD DSN=&SORCLIB(RACSEQ),\n//             DISP=SHR\n//*\n//LKED.SYSLMOD DD DSN=&LNKLIB,\n//             DISP=SHR,\n//             UNIT=SYSALLDA\n//LKED.SYSPRINT DD DSN=&&OUTPUT2,\n//             DISP=(NEW,PASS),\n//             SPACE=(TRK,(10,10),RLSE)\n//LKED.SYSIN DD *\n NAME RACSEQ(R)\n/*\n//LKED.SYSLIB DD DSN=&LNKLIB,\n//             DISP=SHR\n//         DD  DSN=SYS1.CSSLIB,\n//             DISP=SHR\n//         DD  DSN=CEE.SCEELKED,\n//             DISP=SHR\n//         DD DSN=SYS1.LINKLIB,\n//             DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBUPDTE": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x08\\x11O\\x01\\x08\\x11O\\x12Y\\x05\\xc9\\x05\\xb9\\x00\\x00\\xe3\\xe2\\xc8\\xf0\\xf0\\xf9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-04-23T00:00:00", "modifydate": "2008-04-23T12:59:32", "lines": 1481, "newlines": 1465, "modlines": 0, "user": "TSH009"}, "text": "//* INSERT JOB CARD HERE\n//* YOU MUST DOWNLOAD THE RACSEQ SOURCE CODE FROM THE IBM\n//* WEB SITE AT:\n//* http://www.ibm.com/servers/eserver/zseries/zos/racf/racseq.html\n//* PLACE THE SOURCE CODE IN THIS LIBRARY UNDER THE NAME RACSEQ\n//* AFTER THAT, ASSEMBLE THE CODE INTO A TSO ACCESSABLE LIBRARY\n//* USING JCL MODELLED ON MEMBER ASMACL\n// SET THISDSN=this.dsn\n//* MODIFY this.dsn ABOVE TO THE ACTUAL DSN\n//STEP010  EXEC  PGM=IEBUPDTE,\n//             PARM=MOD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DISP=OLD,DSN=&THISDSN\n//SYSUT2   DD  DISP=OLD,DSN=*.SYSUT1\n//*\n//SYSIN    DD  *\n./  CHANGE LIST=ALL,NAME=RACSEQ\n./ DELETE  SEQ1=00010003,SEQ2=00010003\nRACSEQ   TITLE 'RACSEQ - USE R_ADMIN TO EXTRACT RACF PROFILE'\n         PRINT OFF\n         COPY  IEABRC\n         PRINT ON\n         SYSSTATE ARCHLVL=2\n./ DELETE  SEQ1=00660003,SEQ2=00670003\nRACSEQ   RMODE ANY\n./ DELETE  SEQ1=00690003,SEQ2=00710003\n*        USING RACSEQ,R12          set base register\n         LARL  R12,DATA           POINT TO STATIC DATA AREA\n         USING DATA,R12\n         LR    R10,R1             SAVE CPPL ADDRESS\n./ DELETE  SEQ1=00760003,SEQ2=00770003\n         STORAGE OBTAIN,                                               X\n               LOC=24,                                                 X\n               LENGTH=(0)\n         USING S99RB,DYNS99RB\n         LARL  R10,BR5            POINT TO \"NO OUTPUT\" SUBROUTINE\n         ST    R10,DO_PUT@        PUT IT IN SUBROUTINE ADDRESS\n         XC    OPENSW,OPENSW\n         LHI   0,-1\n         ST    0,UNIXFD           Initialize UNIX File Descriptor\n         MVC   DCBOUT(LDCB),DCBINIT\n         USING IHADCB,DCBOUT\n         MVC   OPEN24(LOPEN24),OPEN24I\n         LA    0,OPEN24           POINT TO EXIT\n         ST    0,EXLST\n         MVI   EXLST,X'85'        OPEN EXIT CODE+HOB ON.\n         LA    0,EXLST\n         STCM  0,B'0111',DCBEXLSA POINT TO EXLST IN DCB\n         LA    R0,PUTECB\n./ DELETE  SEQ1=01220003,SEQ2=01220003\n         JZ    GETANS               Go process results\n         XC    DYNEFF(L_EFF),DYNEFF\n         LA    1,DYNEFF\n         USING GFDSECTD,1\n         MVC   GFCPPLP,CPPLPTR\n         ST    15,GFRCODE\n         LHI   0,GFPARSE\n         STH   0,GFCALLID\n         ST    1,DYNEFF@\n         DROP  1\n         LA    1,DYNEFF@\n         OI    0(1),X'80'\n         LINK  EP=IKJEFF19\n./ DELETE  SEQ1=01290003,SEQ2=01290003\n         LHI   R10,L'MSG9+4\n./ DELETE  SEQ1=01320003,SEQ2=01330003\n         MVC   SEG1DATA(L'MSG9),MSG9\n         LHI   R10,6                2-digit rc + header\n./ DELETE  SEQ1=01350003,SEQ2=01350003\n         LHI   R10,L'MSG9           Insert position of rc (eol)\n./ DELETE  SEQ1=01420003,SEQ2=01450003\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n./ DELETE  SEQ1=01520003,SEQ2=01520003\n         L     R1,0(,R1)            Get the PDL address itself\n./ DELETE  SEQ1=01620003,SEQ2=01620003\n         JZ    MOREPRMS             No, default to USER\n./ DELETE  SEQ1=01650003,SEQ2=01650003\n         JNE   CHKCON               Nope\n./ DELETE  SEQ1=01670003,SEQ2=01670003\n         J     MOREPRMS             Continue with R_admin parms\n./ DELETE  SEQ1=01700003,SEQ2=01700003\n         JNE   CHKUSR               Nope\n./ DELETE  SEQ1=01720003,SEQ2=01720003\n         J     MOREPRMS             Continue with R_admin parms\n./ DELETE  SEQ1=01750003,SEQ2=01750003\n         JE    MOREPRMS             Yup\n./ DELETE  SEQ1=01810003,SEQ2=01810003\n         LHI   R10,L'MSG7+4\n./ DELETE  SEQ1=01840003,SEQ2=01890003\n         MVC   SEG1DATA(L'MSG7),MSG7\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\n         L     R1,PDLPTR\n         USING SEQPDL,R1            Get addressability to PDL\n./ DELETE  SEQ1=02080003,SEQ2=02080003\n         JNZ   GETPROF\n./ DELETE  SEQ1=02130003,SEQ2=02130003\n         LHI   R10,L'MSG8+4\n./ DELETE  SEQ1=02160003,SEQ2=02160003\n         MVC   SEG1DATA(L'MSG8),MSG8\n./ DELETE  SEQ1=02180003,SEQ2=02210003\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\n./ DELETE  SEQ1=02790003,SEQ2=02790003\n         BASR  R14,R15\n./ DELETE  SEQ1=02830003,SEQ2=02840003\n         LT    R5,SAFRC           Get SAF return code\n         JZ    GOODSEQ\n./ DELETE  SEQ1=03030003,SEQ2=03030003\n         LHI   R5,L'MSG6+4\n./ DELETE  SEQ1=03060003,SEQ2=03070003\n         MVC   SEG1DATA(L'MSG6),MSG6\n         LHI   R5,6                 All inserts will be 2 chars + hdr\n./ DELETE  SEQ1=03110003,SEQ2=03110003\n         LHI   R5,22                Insert position of SAF rc\n./ DELETE  SEQ1=03140003,SEQ2=03140003\n         LHI   R5,32                Insert position of RACF rc\n./ DELETE  SEQ1=03170003,SEQ2=03170003\n         LHI   R5,L'MSG6            Insert position of RACF rc (eol)\n./ DELETE  SEQ1=03200003,SEQ2=03230003\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\n         L     R1,PDLPTR\n         USING SEQPDL,R1\n         LH    R9,PDLOUTPUT\n         LTR   R9,R9\n         JZ    CONTXML            NO OUTPUT PARMS AT ALL\n*\n         AHI   R9,-1              MAKE ZERO BASED\n         SLL   R9,2               MAKE OFFSET\n         C     R9,MAXTBL          COMPARE TO MAX\n         JNL   OUTX               TOO BIG???\n         L     R10,OUTP(R9)       PROCESSING ROUTINE\n         L     R9,OUTTBL(R9)      GET OFFSET\n         LA    R9,PDEXML1(R9)     GET ADDRESS\n         BR    R10                PROCESS OPTION\n*\n* PROCESS OTHER OPTIONS\nOUTX     DS    0H\n         L     R8,MAXTBL\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         LHI   R0,L'ERR1+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'ERR1),ERR1\n         MVC   OLDNUM,=A(1)\n         J     DO_TERM\nDODDN    DS    0H\n* DDN(...)\n         TM    XML1FLG,X'80'      ANY DDN?\n         JZ    NODDN              NO???\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG14),MSG14\n         MVC   SEG1LEN,=AL2(4+L'MSG14)\n         MVC   SEG2OFF,=AL2(L'MSG14)\n         LH    9,XML1LEN\n         AHI   9,4\n         STH   9,SEG2LEN\n         AHI   9,-5\n         JM    NODDN\n         MVC   OLDNUM,=A(2)\n         L     14,XML1PTR\n         LA    R15,SEG2DATA\n         EX    9,MOVESTR\n         MVC   DCBDDNAM,=CL8' '\n         LA    R15,DCBDDNAM\n         EX    9,MOVESTR\n         LARL  5,DOOPEN3          WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\nNODDN    DS    0H\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG15),MSG15\n         MVC   SEG1LEN,=AL2(4+L'MSG15)\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nDODSN    DS    0H\n* DSNAME(...)\n         TM    XML2FLG,X'80'      ANY DSN?\n         JZ    NODSN              NO???\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG12),MSG12\n         MVC   SEG1LEN,=AL2(4+L'MSG12)\n         MVC   SEG2OFF,=AL2(L'MSG12)\n         LH    9,XML2LEN          GET LENGTH OF DSN\n         AHI   9,5\n         STH   9,SEG2LEN\n         AHI   9,-6\n         JM    NODSN\n         L     10,XML2PTR         POINT TO DSN\n         EX    9,MOVESEG2         MOVE IT IN\n         MVC   OLDNUM,=A(2)\n         JAS   5,DO_TERM\n         MVC   S99RBLN,=AL1(L_S99RB)\n         MVI   S99VERB,S99VRBAL\n         LA    R5,TEXTP\n         ST    R5,S99TXTPP\n         LA    R5,DYNS99RB\n         ST    R5,DYNS99R@\n         OI    DYNS99R@,X'80'     SET END-OF-LIST ON\n         LA    0,DSNT\n         ST    0,TEXTP+0\n         LA    0,DDNT\n         ST    0,TEXTP+4\n         LA    0,DISP1T\n         ST    0,TEXTP+8\n         LA    0,DISP2T\n         ST    0,TEXTP+12\n         LA    0,DISP3T\n         ST    0,TEXTP+16\n         LA    0,FREET\n         ST    0,TEXTP+20\n         LA    0,MEMBERT\n         ST    0,TEXTP+24\n         LA    0,LIKET\n         ST    0,TEXTP+28\n         LA    0,USINGT\n         ST    0,TEXTP+32\n         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING\n         ST    0,TEXTP+36\n         OI    TEXTP+36,X'80'\n         MVC   MEMBERT,=AL2(0)\n         MVC   LIKET,=AL2(0)\n         MVC   USINGT,=AL2(0)\n         LH    R9,XML2MEM\n         LTR   R9,R9              MEMBER NAME?\n         JZ    NOMEM              NOPE\n         STH   R9,MEMBERT+4\n         MVC   MEMBERT(2),=AL2(DALMEMBR)\n         MVC   MEMBERT+2(2),=AL2(1)\n         LA    15,MEMBERT+6\n         L     14,XML2MEM\n         AHI   9,-1\n         EX    9,MOVESTR          MOVE IN MEMBER NAME\nNOMEM    DS    0H\n         L     R1,PDLPTR\n         MVC   DSNT(2),=AL2(DALDSNAM)\n         MVC   DSNT+2(2),=AL2(1)\n         LH    5,XML2LEN\n         STH   5,DSNT+4\n         LA    15,DSNT+6\n         L     14,XML2PTR\n         AHI   5,-1\n         EX    5,MOVESTR\n         MVC   DISP1T(2),=AL2(DALSTATS)\n         MVC   DISP1T+2(2),=AL2(1)\n         MVC   DISP1T+4(2),=AL2(1)\n         MVI   DISP1T+6,X'01'     DISP=OLD\n         MVC   DISP2T(2),=AL2(DALNDISP)\n         MVC   DISP2T+2(2),=AL2(1)\n         MVC   DISP2T+4(2),=AL2(1)\n         MVI   DISP2T+6,X'08'     DISP=KEEP\n         MVC   DISP3T(2),=AL2(DALCDISP)\n         MVC   DISP3T+2(2),=AL2(1)\n         MVC   DISP3T+4(2),=AL2(1)\n         MVI   DISP3T+6,X'08'     DISP=KEEP\n         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE\n         XC    FREET+2(2),FREET+2\n         LH    5,LIKELEN\n         LTR   5,5\n         JZ    NOLIKE\n         MVC   LIKET(2),=AL2(DALDCBDS)\n         MVC   LIKET+2(2),=AL2(1)\n         STH   5,LIKET+4\n         AHI   5,-1\n         LA    15,LIKET+6\n         L     14,LIKEPTR\n         EX    5,MOVESTR\nNOLIKE   DS    0H\n         LH    5,USNGLEN\n         LTR   5,5\n         JZ    NOUSING\n         MVC   USINGT(2),=AL2(DALDCBDD)\n         MVC   USINGT+2(2),=AL2(1)\n         STH   5,USINGT+4\n         AHI   5,-1\n         LA    15,USINGT+6\n         L     14,USNGPTR\n         EX    5,MOVESTR\n         LA    R1,USINGT\nNOUSING  DS    0H\n         MVC   DDNT(2),=AL2(DALRTDDN)\n         MVC   DDNT+2(2),=AL2(1)\n         MVC   DDNT+4(2),=AL2(8)\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         DYNALLOC ,               DO DYNAMIC ALLOCATION\n         LTR   R15,R15\n         JZ    DOOPEN2\n         MVI   DISP1T+6,X'04'     DISP=NEW\n         MVI   DISP2T+6,X'02'     DISP=CATLG\n         MVI   DISP3T+6,X'02'     DISP=CATLG\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         DYNALLOC ,               TRY DISP=(NEW,CATLG,CATLG)\n         LTR   R15,R15\n         JZ    DOOPEN2\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DYNERR             WRITE MESSAGE TO USER\nDOOPEN2  DS    0H\n         LH    5,DDNT+4           GET LENGTH OF DDNAME\n         MVC   DCBDDNAM,=CL8' '   BLANK IT\n         LA    15,DCBDDNAM\n         LA    14,DDNT+6\n         AHI   5,-1\n         EX    5,MOVESTR\nDOOPEN3  DS    0H\n         MVC   OPEN(LOPEN),OPENMFL\n         LA    R1,OPEN\n         OPEN  (DCBOUT,(OUTPUT)),MF=(E,(1)),MODE=31\n         LTR   R5,R15\n         JZ    OPENOK\n         WTO   'OPEN FAILED',ROUTCDE=11\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nOPENOK   DS    0H\n         MVI   OPENSW,1           SAY WE DID THE OPEN\n         TM    DCBDSORG,DCBDSGPS\n         JZ    NOT_PS\n         TM    DCBRECFM,DCBRECF+DCBRECV\n         JNM   BAD_RECFM\n         LARL  5,DO_FILE_F        RECFM=F\n         ST    5,DO_PUT@\n         TM    DCBRECFM,DCBRECF\n         JO    CONTXML\n         LARL  5,DO_FILE_V        RECFM=V\n         ST    5,DO_PUT@\n         J     CONTXML\nBAD_RECFM DS   0H\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         LHI   R0,L'ERR2+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'ERR2),ERR2\n         MVC   OLDNUM,=A(1)\n         J     DO_TERM            Tell the user the recfm is bad\nNOT_PS   DS    0H\n         LHI   R0,L'ERR3+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'ERR3),ERR3\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         J     DO_TERM            Tell the user the DSORG is bad\nNODSN    DS    0H\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG11),MSG11\n         MVC   SEG1LEN,=AL2(4+L'MSG11)\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nDOPATH   DS    0H\n*|PATH(...)\n         LARL  5,DO_UNIX          OUTPUT TO UNIX FILE\n         ST    5,DO_PUT@\n         TM    XML3FLG,X'80'      ANY PATH?\n         JZ    NOPATH             NO???\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG16),MSG16\n         MVC   SEG1LEN,=AL2(4+L'MSG16)\n         MVC   SEG2OFF,=AL2(L'MSG16)\n         LH    9,XML3LEN         GET LENGTH OF PATH\n         AHI   9,5\n         STH   9,SEG2LEN\n         AHI   9,-6\n         JM    NOPATH             NULL?\n         L     10,XML3PTR         POINT TO PATH\n         CLI   0(10),C'/'         Path must begin at root\n         JNE   NOTROOT            But it isn't.\n         EX    9,MOVESEG2         MOVE IT IN\n         AHI   9,1                RESTORE TRUE LENGTH\n         ST    R9,PATHLEN         SAVE IN PARM LIST\n         LA    0,PATHLEN          +0\n         LA    1,SEG2DATA         +4\n         LA    R2,O_FLAG          +8\n         LA    3,UNIXMODE         +12\n         LA    R4,UNIXFD          +16\n         LA    R5,RET_CODE        +20\n         LA    R6,RSN_CODE        +24\n         STM   R0,R6,TEXTP\n         OI    TEXTP+24,X'80'\n         LA    R1,TEXTP\n         LINK  SF=(E,BPX1OPN)\n         LT    R15,UNIXFD\n         JM    UNIXFAIL           Open failed\n         LOAD  EP=BPX1WRT\n         ST    R0,BPX1WRT\n         MVC   OLDNUM,=A(2)\n         LARL  5,CONTXML          WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nUNIXFAIL DS    0H                 UNIX file failed to open\n         LHI   R0,L'ERR4+4\n         STH   R0,SEG1LEN\n         LHI   R0,8\n         STH   R0,SEG2LEN\n         STH   R0,SEG3LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG2OFF,=AL2(33)\n         MVC   SEG3OFF,=AL2(41)\n         MVC   SEG1DATA(L'ERR4),ERR4\n         UNPK  PACKDEC1(9),RET_CODE\n         TR    PACKDEC1(8),TOHEX-C'0'\n         MVC   SEG2DATA(8),PACKDEC1\n         UNPK  PACKDEC1(9),RSN_CODE\n         TR    PACKDEC1(8),TOHEX-C'0'\n         MVC   SEG2DATA(8),PACKDEC1\n         MVC   OLDNUM,=A(3)\n         LARL  R5,GETOUT\n         MVC   SAFRC,=F'20'\n         J     DO_TERM            Tell user UNIX open failed.\nNOTROOT  DS    0H\n         MVC   OLDNUM,=A(1)\n         LHI   R0,L'MSG22+4\n         STH   R0,SEG1LEN\n         MVC   SEG1DATA(L'MSG22),MSG22\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT          Where to go after message\n         J     DO_TERM            Write message to user's terminal\nNOPATH   DS    0H\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG17),MSG17\n         MVC   SEG1LEN,=AL2(4+L'MSG17)\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nDOTERM   DS    0H\n         LARL  5,DO_TERM\n         ST    5,DO_PUT@\n         J     CONTXML\nDOSYSOUT DS    0H\n         TM    SYSCFLG,X'80'      SYSOUT CLASS SPECIFIED?\n         JZ    NOCLASS            ERROR\n         LT    9,SYSCPTR          GET POINTER TO CLASS\n         JZ    NOCLASS            HUH?\n         CLC   SYSCLEN,=AL2(1)    CHECK LENGTH\n         JNE   BADCLASS\n*\n* Issue message to let the user know the sysout class\n         MVC   OLDNUM,=A(2)\n         LHI   R10,L'MSG21\n         STH   R10,SEG2OFF\n         AHI   R10,4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG21),MSG21\n         MVC   SEG2LEN,=AL2(5)\n*\n* MOVE THE SYSOUT CLASS\n         MVC   SEG2DATA(1),0(R9)  MOVE INTO MESSAGE\n         MVC   SYSOUTT+6,0(R9)    MOVE INTO DYNALLOC TEXT UNIT\n         JAS   5,DO_TERM\n*\n* MORE CODE TO ACTUALLY IMPLEMENT THIS\n         MVC   S99RBLN,=AL1(L_S99RB)\n         MVI   S99VERB,S99VRBAL\n         LA    R5,TEXTP\n         ST    R5,S99TXTPP\n         LA    R5,DYNS99RB\n         ST    R5,DYNS99R@\n         OI    DYNS99R@,X'80'     SET END-OF-LIST ON\n         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE\n         XC    FREET+2(2),FREET+2\n         MVC   DDNT(2),=AL2(DALRTDDN)\n         MVC   DDNT+2(2),=AL2(1)\n         MVC   DDNT+4(2),=AL2(8)\n         MVC   SYSOUTT(2),=AL2(DALSYSOU)\n         MVC   SYSOUTT+2(2),=AL2(1)\n         MVC   SYSOUTT+4(2),=AL2(1)\n         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE\n         XC    FREET+2(2),FREET+2\n         L     1,PDLPTR\n         LH    5,LIKELEN\n         LTR   5,5\n         JZ    NOLIKE2\n         MVC   LIKET(2),=AL2(DALDCBDS)\n         MVC   LIKET+2(2),=AL2(1)\n         STH   5,LIKET+4\n         AHI   5,-1\n         LA    15,LIKET+6\n         L     14,LIKEPTR\n         EX    5,MOVESTR\nNOLIKE2  DS    0H\n         L     1,PDLPTR\n         LH    5,USNGLEN\n         LTR   5,5\n         JZ    NOUSING2\n         L     1,PDLPTR\n         MVC   USINGT(2),=AL2(DALDCBDD)\n         MVC   USINGT+2(2),=AL2(1)\n         STH   5,USINGT+4\n         AHI   5,-1\n         LA    15,USINGT+6\n         L     14,USNGPTR\n         EX    5,MOVESTR\nNOUSING2 DS    0H\n         DROP  R1\n         LA    0,SYSOUTT\n         ST    0,TEXTP+0\n         LA    0,FREET\n         ST    0,TEXTP+4\n         LA    0,DDNT\n         ST    0,TEXTP+8\n         LA    0,USINGT\n         ST    0,TEXTP+12\n         LA    0,LIKET\n         ST    0,TEXTP+16\n         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING\n         ST    0,TEXTP+20\n         OI    TEXTP+20,X'80'\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         DYNALLOC ,               DO DYNAMIC ALLOCATION\n         LTR   R15,R15\n         JZ    DOOPEN2\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DYNERR             WRITE MESSAGE TO USER\nNOCLASS  DS    0H\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG18+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG18),MSG18\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nBADCLASS DS    0H\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG19+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG19),MSG19\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\nXMLERROR DS    0H\n* MORE THAN ONE OF DDN, DSNAME, OR PATH SPECIFIED\n* INSERT MORE CODE\n*\n*        Error - more than one of DDN, DSNAME, or PATH entered\n*\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG10+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG10),MSG10\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nCONTXML  DS    0H\n         L     R1,PDLPTR\n         USING SEQPDL,R1\n* 1 ==> NONXML SPECIFIED OR DEFAULTED\n* 2 ==> XML SPECIFIED\n         MVC   XMLSWITCH,PDLXML\n         CLC   PDLXML,=AL2(2)\n         JNE   NOXML\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG20+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG20),MSG20\n         JAS   5,DO_TERM\n         LHI   R10,L'XMLBEGIN+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'XMLBEGIN),XMLBEGIN\n         L     5,DO_PUT@\n         BASR  5,5\nNOXML    DS    0H\n./ DELETE  SEQ1=03320003,SEQ2=03320003\n         LHI   R5,L'MSG1+4\n./ DELETE  SEQ1=03350003,SEQ2=03350003\n         MVC   SEG1DATA(L'MSG1),MSG1\n./ DELETE  SEQ1=03390003,SEQ2=03390003\n         AHI   R5,4                 Add 4 for header (length/offset)\n./ DELETE  SEQ1=03410003,SEQ2=03410003\n         LHI   R5,20                Offset of first insert\n./ DELETE  SEQ1=03460003,SEQ2=03460003\n         AHI   R5,-1                Decrement for execute\n./ DELETE  SEQ1=03490003,SEQ2=03490003\n         LHI   R5,30                Offset of second insert\n./ DELETE  SEQ1=03510003,SEQ2=03520003\n         LT    R9,CLSPTR            Get Class pointer from PDL\n         JZ    USEUSER              Not specified, default to USER\n./ DELETE  SEQ1=03540003,SEQ2=03540003\n         AHI   R5,4                 Add 4 for header (len/offset)\n         LA    R15,SEG3DATA\n         LR    R14,R9\n         AHI   5,-1\n         EX    5,MOVESTR\n./ DELETE  SEQ1=03570003,SEQ2=03570003\n         J     SEGNUMS              Proceed\n./ DELETE  SEQ1=03600003,SEQ2=03600003\n         LHI   R5,8                 4 for \"USER\" + header\n./ DELETE  SEQ1=03640003,SEQ2=03640003\n         LHI   R5,6                 Max 2-digit #segments\n./ DELETE  SEQ1=03660003,SEQ2=03660003\n         LHI   R5,L'MSG1            Offset of third insert (eol)\n./ DELETE  SEQ1=03770003,SEQ2=03790003\n         CLI   XMLSWITCH+1,2      XML FORMAT?\n         JNE   NOTXML1\n         LHI   0,18\n         STH   0,SEG2OFF\n         LHI   0,35\n         STH   0,SEG3OFF\n         LHI   0,53\n         STH   0,SEG4OFF\n         LHI   5,L'XML1+4\n         STH   5,SEG1LEN\n         MVC   SEG1DATA(L'XML1),XML1\nNOTXML1  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n./ DELETE  SEQ1=04120003,SEQ2=04120003\n         JAS   R14,SEGMSG            Issue segment message\n./ DELETE  SEQ1=04150003,SEQ2=04190003\n         LLH   R9,ADMN_PROF_FIELDTYPE  Get type of field\n         C     R9,=A(ADMN_PROF_RPTHDR) Is it a repeat field header?\n         JE    REPEAT                Yes, repeat field\n./ DELETE  SEQ1=04210003,SEQ2=04220003\n         JAS   R14,FLDMSG            Display field name and value\n         J     NEXTFLD               Get next field\n*\n./ DELETE  SEQ1=04240003,SEQ2=04240003\n         JAS   R15,DOREPEAT          Go process repeat field. R5 will  *\n./ DELETE  SEQ1=04260003,SEQ2=04260003\n         J     NEXTFLD2              Continue with main fields\n./ DELETE  SEQ1=04340003,SEQ2=04350003\n         JCT   R4,DOFIELDS           Decrement number of fields\n./ DELETE  SEQ1=04430003,SEQ2=04440003\n         CLI   XMLSWITCH+1,2      XML OUTPUT?\n         JNE   NOXML2\n         MVC   OLDNUM,=A(2)\n         XC    SEG1OFF,SEG1OFF\n         LHI   R0,L'XMLEND+4\n         STH   R0,SEG1LEN\n         MVC   SEG1DATA(L'XMLEND),XMLEND\n         MVC   SEG2LEN(2+2+8),RACSEGSV\n         LHI   R0,3\n         STH   R0,SEG2OFF\n         LR    R14,R5             SAVE\n         L     R5,DO_PUT@\n         BASR  R5,R5\n         LR    R5,R14             RESTORE\nNOXML2   DS    0H\n         JCT   R2,DOSEGS             Decrement number of segments\n         J     FREEOUT               Done with segments, finish up\n         CLI   XMLSWITCH+1,2      XML?\n         JNE   FREEOUT2           No\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         LHI   0,L'XML1B+4\n         STH   0,SEG1LEN\n         MVC   SEG1DATA(L'XML1B),XML1B\n         L     R5,DO_PUT@\n         BASR  R5,R5\nFREEOUT2 DS    0H\n         L     R1,OUTMSG\n./ DELETE  SEQ1=04510003,SEQ2=04530003\n         STORAGE RELEASE,                                              X\n               LENGTH=(0),                                             X\n               ADDR=(1),                                               X\n               SP=127\n         LT    R2,UNIXFD\n         JM    NOUNIX\n         LA    R2,UNIXFD          +0\n         LA    R3,RET_VAL         +4\n         LA    R4,RET_CODE        +8\n         LA    R5,RSN_CODE        +12\n         STM   R2,R5,REGSAVE      +16\n         OI    REGSAVE+16,X'80'\n         LA    R1,REGSAVE         POINT TO PARM LIST\n         LINK  SF=(E,BPX1CLO)\nNOUNIX   DS    0H\n         CLI   OPENSW,1\n         JNE   NOCLOSE\n         MVC   OPEN(LOPEN),OPENMFL\n         LA    R1,OPEN\n         CLOSE (DCBOUT),MF=(E,(1)),MODE=31\nNOCLOSE  DS    0H\n./ DELETE  SEQ1=04640003,SEQ2=04650003\n         L     R5,SAFRC\n         STORAGE RELEASE,                                              X\n               LENGTH=(0),                                             X\n               ADDR=(1)\n         LR    R15,R5\n./ DELETE  SEQ1=04670003,SEQ2=04670003\n./ DELETE  SEQ1=04750003,SEQ2=04750003\n*                  R15 = return address                               *\n./ DELETE  SEQ1=04870003,SEQ2=04870003\n         ST    R5,SAVEFD2\n         ST    R15,SAVEFD3\n         JAS   R14,RPTMSG            Go print header field\n./ DELETE  SEQ1=04960003,SEQ2=04960003\n         JAS   R14,FLDMSG            Print subfield name and value\n./ DELETE  SEQ1=05000003,SEQ2=05040003\n         JCT   R7,RPTSFLD            Loop if subfields remaining\n         CLI   XMLSWITCH+1,2      XML?\n         JE    NOSEP              No separator needed\n         JAS   R14,SEPMSG            Print separator\nNOSEP    DS    0H\n         JCT   R6,RPTOCC             Loop if occurrences remaining\n         CLI   XMLSWITCH+1,2\n         JNE   NOTXMLA\n         L     R5,SAVEFD2\n         USING ADMN_PROF_FIELDDESC,R5 Basing for subfield descriptor\n         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name\n         DROP  R5\n         MVC   SEG1DATA(L'XMLEND),XMLEND\n         LHI   0,L'XMLEND+4\n         STH   0,SEG1LEN\n         LHI   0,3\n         STH   0,SEG2OFF\n         XC    SEG1OFF,SEG1OFF\n         LA    1,SEG2DATA+7\n         LHI   6,8\nSQZA     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZA\n         BCTR  R1,0\n         JCT   R6,SQZA\nESQZA    DS    0H\n         AHI   R6,4\n         STH   R6,SEG2LEN\n         MVC   OLDNUM,=A(2)\n         L     R5,DO_PUT@\n         BASR  R5,R5\nNOTXMLA  DS    0H\n         LR    R5,R8                 All done. Set R5 to next FD addr\n         L     R15,SAVEFD3\n         BR    R15                   Return to caller\n*        DROP  R8\n./ DELETE  SEQ1=05230003,SEQ2=05230003\n         LHI   R10,L'MSG2+4\n./ DELETE  SEQ1=05260003,SEQ2=05270003\n         MVC   SEG1DATA(L'MSG2),MSG2\n         LHI   R10,8+4              Get segment name length + header\n./ DELETE  SEQ1=05290003,SEQ2=05290003\n         LHI   R10,10               Offset of 1st insert\n./ DELETE  SEQ1=05320003,SEQ2=05320003\n         MVC   RACSEGSV+2+2(8),SEG2DATA\n         LHI   R2,6                 Max 2-digit number of fields\n./ DELETE  SEQ1=05340003,SEQ2=05340003\n         LHI   R2,L'MSG2            Insert position of insert (eol)\n./ DELETE  SEQ1=05410003,SEQ2=05470003\n         CLI   XMLSWITCH+1,2      XML?\n         JNE   NOTXML2            NO\n         MVC   SEG1DATA(L'XML2),XML2\n         LHI   0,L'XML2+4\n         STH   0,SEG1LEN\n         LHI   0,2\n         STH   0,SEG2OFF\n*\n* SQUEEZE OUT TRAILING BLANKS\n         LA    R1,SEG2DATA\n         LH    R2,SEG2LEN\n         AHI   R2,-4\n         AR    R1,R2\n         AHI   R1,-1\nSQZ1     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZ1\n         BCTR  R1,0               BACK UP ONE BYTE\n         BRCT  R2,SQZ1\nESQZ1    DS    0H\n         AHI   R2,4\n         STH   R2,SEG2LEN\n         LHI   0,11\n         STH   0,SEG3OFF\n         MVC   RACSEGSV(2+2+8),SEG2LEN\nNOTXML2  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n*        JAS   5,DO_TERM\n./ DELETE  SEQ1=05500003,SEQ2=05500003\n./ DELETE  SEQ1=05690003,SEQ2=05690003\n         LHI   R10,L'MSG3+4\n./ DELETE  SEQ1=05720003,SEQ2=05730003\n         MVC   SEG1DATA(L'MSG3),MSG3\n         LHI   R10,8+4              Get field name length + header\n./ DELETE  SEQ1=05750003,SEQ2=05750003\n         LHI   R10,16               Offset of 1st insert\n./ DELETE  SEQ1=05800003,SEQ2=05800003\n         LHI   R2,6                 Max 2-digit #subfields\n./ DELETE  SEQ1=05820003,SEQ2=05820003\n         LHI   R2,27                Offset of 2nd insert\n./ DELETE  SEQ1=05910003,SEQ2=05910003\n         LHI   R2,8                 Max 4-digit #occurrences\n./ DELETE  SEQ1=05930003,SEQ2=05930003\n         LHI   R2,L'MSG3            Offset of 3rd insert (end of line)\n./ DELETE  SEQ1=06030003,SEQ2=06090003\n         CLI   XMLSWITCH+1,2      XML?\n         JNE   NOTXML3\n         MVC   SEG1DATA(L'XML3),XML3\n         LHI   0,L'XML3+4\n         STH   0,SEG1LEN\n         LHI   0,2\n         STH   0,SEG2OFF\n         LA    1,SEG2DATA\n         LH    2,SEG2LEN\n         AHI   2,-4\n         AR    R1,R2\n         AHI   R1,-1\nSQZ3     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZ3\n         BCTR  R1,0\n         JCT   R2,SQZ3\nESQZ3    DS    0H\n         AHI   R2,4\n         STH   R2,SEG2LEN\n         LHI   0,14\n         STH   0,SEG3OFF\n         LHI   0,39\n         STH   0,SEG4OFF\nNOTXML3  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n./ DELETE  SEQ1=06120003,SEQ2=06120003\n./ DELETE  SEQ1=06310003,SEQ2=06360003\n         LLH   R9,ADMN_PROF_FIELDTYPE\n         N     R9,=A(ADMN_PROF_REPEAT)\n         JZ    NOTRPT               Nope\n         LHI   R10,L'MSG4RPT+4      Use extra indentation for repeat\n./ DELETE  SEQ1=06380003,SEQ2=06380003\n         MVC   SEG1DATA(L'MSG4RPT),MSG4RPT\n./ DELETE  SEQ1=06400003,SEQ2=06400003\n         LHI   R10,L'MSG4RPT        Offset of 3rd insert (end of line)\n./ DELETE  SEQ1=06420003,SEQ2=06420003\n         J     NXTMSEG\n./ DELETE  SEQ1=06440003,SEQ2=06440003\n         LHI   R10,L'MSG4+4\n./ DELETE  SEQ1=06460003,SEQ2=06460003\n         MVC   SEG1DATA(L'MSG4),MSG4\n./ DELETE  SEQ1=06480003,SEQ2=06480003\n         LHI   R10,L'MSG4           Offset of 3rd insert (end of line)\n./ DELETE  SEQ1=06510003,SEQ2=06510003\n         LHI   R10,8+4              Get field name length + header\n./ DELETE  SEQ1=06580003,SEQ2=06580003\n         JZ    NOTBOOL\n./ DELETE  SEQ1=06630003,SEQ2=06640003\n         JZ    NOTTRUE\n         LHI   R10,4+4              Length(\"TRUE\") + header\n./ DELETE  SEQ1=06660003,SEQ2=06670003\n         MVC   SEG3DATA(4),=C'TRUE'\n         J     DOFPUT\n./ DELETE  SEQ1=06690003,SEQ2=06690003\n         LHI   R10,5+4              Length(\"FALSE\") + header\n./ DELETE  SEQ1=06710003,SEQ2=06720003\n         MVC   SEG3DATA(5),=C'FALSE'\n         J     DOFPUT\n./ DELETE  SEQ1=06760003,SEQ2=06770003\n         JNH   NOPROB                     No\n         LHI   R10,L'SEG3DATA             Lazy again, just truncate\n./ DELETE  SEQ1=06800003,SEQ2=06800003\n         AHI   R10,4                      Add 4 for header\n./ DELETE  SEQ1=06860003,SEQ2=06860003\n         AHI   R10,-1               Decrement length for move\n./ DELETE  SEQ1=06890003,SEQ2=06950003\n         CLI   XMLSWITCH+1,2      XML OUTPUT?\n         JNE   NOTXML4\n         LHI   0,L'XML4+4\n         STH   0,SEG1LEN\n         MVC   SEG1DATA(L'XML4),XML4\n         LHI   0,2\n         STH   0,SEG2OFF\n         LHI   0,3\n         STH   0,SEG3OFF\n         LHI   0,5\n         STH   0,SEG4OFF\n         LA    R1,SEG2DATA\n         LH    R2,SEG2LEN\n         AHI   R2,-4\n         AR    R1,R2\n         AHI   R1,-1\nSQZ4     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZ4\n         BCTR  R1,0\n         JCT   R2,SQZ4\nESQZ4    DS    0H\n         AHI   R2,4\n         STH   R2,SEG2LEN\n         MVC   SEG4LEN,SEG2LEN\n         MVC   SEG4DATA,SEG2DATA\n         MVC   OLDNUM,=A(4)\nNOTXML4  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n./ DELETE  SEQ1=06980003,SEQ2=06980003\n./ DELETE  SEQ1=07150003,SEQ2=07150003\n         LHI   R10,L'MSG5+4\n./ DELETE  SEQ1=07180003,SEQ2=07180003\n         MVC   SEG1DATA(L'MSG5),MSG5\n         L     5,DO_PUT@\n         BASR  5,5\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         EJECT\n*\n***********************************************************************\n*\n*\n* Routine called by parse to validate a UNIX path\n*\n*\n***********************************************************************\nVALDPATH DS    0H\n         STM   14,12,12(13)\n         LM    5,7,0(1)           LOAD PARAMETERS\n* R5 POINTS TO THE PDE\n* R6 IS THE ADDRESS OF A WORK AREA\n* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE\n         L     8,0(,5)            POINT TO OPERAND\n         LH    10,4(,5)           LENGTH OF OPERAND\n         AHI   10,-1              DEC\n         SLR   15,15\n         JM    PATHERR1\nVALRET   DS    0H\n         l     14,12(,13)\n         LM    0,12,20(13)\n         BSM   0,14               RETURN TO PARSE\nPATHERR1 DS    0H\n         LHI   15,4\n         J     VALRET\n         EJECT\n*\n***********************************************************************\n*\n*\n* Routine called by parse to validate a DSN\n*\n*\n***********************************************************************\nVALIDSN  DS    0H\n         STM   14,12,12(13)\n         LM    5,7,0(1)           LOAD PARAMETERS\n* R5 POINTS TO THE PDE\n* R6 IS THE ADDRESS OF A WORK AREA\n* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE\n         SLR   15,15\n         J     VALRET             RETURN TO PARSE\n         EJECT\nRC24     DS    0H\n         MVC   SAFRC,=F'24'\n         J     GETOUT\nDO_TERM DS     0H\n         STM   R0,R15,PUTSAVE\n         DROP  R1\n         LA    R4,OLDNUM\n./ DELETE  SEQ1=07260003,SEQ2=07270003\n         LTR   R15,R15\n         JNZ   *+2\n         LM    R0,R15,PUTSAVE\n         BR    5\nDO_FILE_F DS   0H                 OUTPUT USING DCB\n         STM   R0,R15,PUTSAVE\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n./ DELETE  SEQ1=07290003,SEQ2=07290003\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LTR   R15,R15            Putline OK?\n         JNZ   RC24               No, exit with RC=24\n         L     2,PUTSEQ+8         Get address of record\n         LH    3,0(,2)            Get length of record\n         AHI   3,-4               Remove length of LLBB prefix\n         CH    3,DCBLRECL         Compare record length\n         JNH   DO_F_PUT\n*\n* DATASET LRECL TOO SMALL, INFORM USER\nBAD_RECLEN DS  0H\n         CVD   3,PACKDEC1\n*        UNPK  SEG2DATA(2*L'PACKDEC1-1),PACKDEC1\n*        OI    SEG2DATA+2*L'PACKDEC1-2,C'0'\n         MVC   EDMKFLD,EDMKINIT\n         LA    R1,EDMKFLD\n         EDMK  EDMKFLD,PACKDEC1\n         LR    R14,R1\n         LA    R15,SEG2DATA\n         LA    R9,EDMKFLD+L'EDMKFLD-1\n         SLR   R9,R1\n         EX    9,MOVESTR\n         AHI   R9,5\n         STH   R9,SEG2LEN\n         LHI   R0,L'ERR5+4\n         STH   R0,SEG1LEN\n*        LHI   R0,2*L'PACKDEC1-1+4\n*        STH   R0,SEG2LEN\n*        STH   R0,SEG3LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG2OFF,=AL2(46)\n         MVC   SEG3OFF,=AL2(L'ERR5)\n         MVC   SEG1DATA(L'ERR5),ERR5\n         LH    R0,DCBLRECL\n         CVD   R0,PACKDEC1\n         MVC   EDMKFLD,EDMKINIT\n         LA    R1,EDMKFLD\n         EDMK  EDMKFLD,PACKDEC1\n         LR    R14,R1\n         LA    R15,SEG3DATA\n         LA    R9,EDMKFLD+L'EDMKFLD-1\n         SLR   R9,R1\n         EX    9,MOVESTR\n         AHI   R9,5\n         STH   R9,SEG3LEN\n*        UNPK  SEG3DATA(2*L'PACKDEC1-1),PACKDEC1\n*        OI    SEG3DATA+2*L'PACKDEC1-2,C'0'\n         MVC   OLDNUM,=A(3)\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         J     DO_TERM            Tell terminal user record too long\nDO_F_PUT DS    0H\n         PUT   DCBOUT             Get buffer\n         LH    3,DCBLRECL\n         AHI   3,-2\n         MVI   0(1),C' '\n         LR    14,1\n         LA    15,1(,1)\n         EX    3,MOVESTR          BLANK OUT I/O BUFFER\n         LH    3,0(,2)            Length of record to write\n         AHI   3,-5               Actual lrecl-1\n         LA    14,4(,2)           First character of actual data\n         LR    15,1               Buffer address\n         EX    3,MOVESTR          Move data to buffer\n         LR    R1,R2              Get buffer address\n         LH    R0,0(,R1)          Get length\n         STORAGE RELEASE,                                              X\n               ADDR=(1),                                               X\n               LENGTH=(0),                                             X\n               SP=1\n         LM    R0,R15,PUTSAVE\n         BR    5\nDO_FILE_V DS   0H                 OUTPUT USING DCB\n         STM   R0,R15,PUTSAVE\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         LA    R4,OLDNUM\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LTR   R15,R15            Putline OK?\n         JNZ   RC24               No, exit with RC=24\n         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE\n         LH    3,0(,14)           GET ITS LENGTH\n         CH    9,DCBLRECL         Will it fit?\n         JH    BAD_RECLEN         Yes\n         PUT   DCBOUT\n         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE\n         LR    R15,R1             BUFFER RETURNED BY PUT\n         AHI   9,-1               ADJ LENGTH FOR EX\n         EX    9,MOVESTR          MOVE THE RECORD TO THE BUFFER\n         L     R1,PUTSEQ+8        Get buffer address\n         LH    R0,0(,R1)          Get length\n         STORAGE RELEASE,                                              X\n               ADDR=(1),                                               X\n               LENGTH=(0),                                             X\n               SP=1\n         LM    R0,R15,PUTSAVE\n         BR    5\nDO_UNIX  DS    0H                 OUTPUT USING UNIX\n         STM   R0,R15,PUTSAVE\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LTR   R15,R15            Putline OK?\n         JNZ   RC24               No, exit with RC=24\n         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE\n         LH    9,0(,14)           GET ITS LENGTH\n*        STH   9,SEG1LEN\n*        XC    SEG1OFF,SEG1OFF\n         AHI   9,-5               Actual length of data -1\n         LA    R14,4(,R14)        POINT TO DATA\n         LA    R15,SEG1DATA       SOMEWHERE TO PUT IT\n         EX    R9,MOVESTR         MOVE IT TO BUFFER\n         LA    R14,1(R9,R15)\n         MVI   0(R14),X'15'       EBCDIC NEWLINE\n         AHI   R9,2               Length of record plus the NL\n*        MVC   OLDNUM,=A(1)\n*        PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,\n*              OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         ST    R9,SAVEDLEN\n         L     R15,BPX1WRT\n         L     R2,UNIXFD\n         LA    R3,SEG1DATA\n         L     R4,SAVEDLEN\n         LA    R2,SEG1DATA\n         ST    R2,TEXTP\n         CALL  (15),(UNIXFD,                                           X\n               TEXTP,                                                  X\n               =F'0',                                                  X\n               SAVEDLEN,                                               X\n               RET_VAL,                                                X\n               RET_CODE,                                               X\n               RSN_CODE),VL,                                           X\n               MF=(E,TEXTP+4)\n         LM    R0,R1,RET_CODE\n         LT    R9,RET_VAL\n         JM    WRITFAIL           WRITE FAILED\n         C     R9,SAVEDLEN        WROTE ALL THE BYTES?\n         JNE   WRT2FAIL           FAILED AGAIN\n         L     R1,PUTSEQ+8        Get buffer address\n         LH    R0,0(,R1)          Get length\n         STORAGE RELEASE,                                              X\n               ADDR=(1),                                               X\n               LENGTH=(0),                                             X\n               SP=1\n         LM    R0,R15,PUTSAVE\n         BR    5\nWRITFAIL DS    0H\n         MVC   SAFRC,=F'20'\n         UNPK  PACKDEC1(9),RET_CODE(5)\n         TR    PACKDEC1(8),TOHEX-C'0'\n         UNPK  PACKDEC2(9),RSN_CODE(5)\n         TR    PACKDEC2(8),TOHEX-C'0'\n         LHI   R0,L'MSG23+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG23),MSG23\n         LHI   R0,8\n         STH   R0,SEG2LEN\n         STH   R0,SEG3LEN\n         LHI   R0,37\n         STH   R0,SEG2OFF\n         LHI   R0,45\n         STH   R0,SEG3OFF\n         MVC   SEG2DATA(8),PACKDEC1\n         MVC   SEG3DATA(8),PACKDEC2\n         MVC   OLDNUM,=A(3)\n         LARL  R5,GETOUT\n         J     DO_TERM\nWRT2FAIL DS    0H\n         MVC   SAFRC,=F'20'\n         LHI   R0,L'MSG24\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG24),MSG24\n         MVC   SEG2LEN,=AL2(8)\n         MVC   SEG3LEN,=AL2(8)\n         MVC   SEG2OFF,=AL2(32)\n         MVC   SEG3OFF,=AL2(43)\n         CVD   R9,PACKDEC1\n         OI    PACKDEC1+7,C'0'\n         MVC   SEG2DATA(8),PACKDEC1\n         L     R9,SAVEDLEN\n         CVD   R9,PACKDEC1\n         OI    PACKDEC1+7,C'0'\n         MVC   SEG3DATA(8),PACKDEC1\n         LARL  R5,GETOUT\n         J     DO_TERM\n*        J     GETOUT\nBR5      DS    0H                 NO OUTPUT AT ALL?\n         WTO   'BR5',ROUTCDE=11\n         BR    5\nDYNERR   DS    0H                      SAVE RETCODE FOR DAIRFAIL\n         USING DFDSECTD,DRFLPARM       SET ADDRESSIBLITY TO PARM LIST\n         ST    R15,DRFLR15             SAVE RETCODE FOR DAIRFAIL\n         ST    R1,DFS99RBP\n         LA    R1,DRFLPARM             LOAD DAIRFAIL PARM LIST ADDRESS\n         XC    DRFLPARM(DFLEN),DRFLPARM CLEAR AREA FIRST\n         LA    R15,DRFLR15             GET ADDRESS OF SAVED REG 15\n         ST    R15,DFRCP               SAVE IN DAIRFAIL PARM LIST\n         LA    R15,FULL0               GET ADDRESS OF OF DUMMY F02\n         ST    R15,DFJEFF02            SAVE IN DAIRFAIL PARM LIST\n         LA    R15,DRFLID              GET ADDRESS OF CALLER'S FLAGS\n         ST    R15,DFIDP               SAVE IN DAIRFAIL PARM LIST\n         LINK  SF=(E,LINKDRFL)         LINK TO DAIRFAIL SERVICE ROUTINE\n         BR    5\nKWOUTPUT IKJKEYWD DEFAULT='TERMINAL'\n         IKJNAME 'DDNAME',SUBFLD=DDN,                                  X\n               ALIAS=('FI','FILE')\n         IKJNAME 'DSNAME',SUBFLD=DSNAME,                               X\n               ALIAS=('DATASET','DA')\n         IKJNAME 'PATH',SUBFLD=PATH ALIAS=('PATH')\n         IKJNAME 'TERMINAL'\n         IKJNAME 'SYSOUT',SUBFLD=OUTCLASS\nKWALLOC  IKJKEYWD\n         IKJNAME 'USING',SUBFLD=USING1\n         IKJNAME 'LIKE',SUBFLD=LIKE1\nKWXML    IKJKEYWD DEFAULT='NONXML'\n         IKJNAME  'NONXML'\n         IKJNAME  'XML'\nDDN      IKJSUBF\nXMLDD    IKJIDENT 'DDN',UPPERCASE,MAXLNTH=8,FIRST=ALPHA,               X\n               OTHER=ALPHANUM,                                         X\n               HELP=('DD name to use for XML output')\nDSNAME   IKJSUBF\nXMLDS    IKJPOSIT DSNAME,USID,                                         X\n               HELP=('Dataset Name to be used for XML output')\nPATH     IKJSUBF\nXMLPAT   IKJIDENT 'PATH',ASIS,MAXLNTH=255,                             X\n               FIRST=ANY,OTHER=ANY,                                    X\n               VALIDCK=VALDPATH,                                       X\n               HELP=('UNIX path and file name')\nOUTCLASS IKJSUBF\nOUTCLAS  IKJIDENT 'SYSOUT',UPPERCASE,MAXLNTH=1,                        X\n               FIRST=NONATNUM,                                         X\n               HELP=('SYSOUT class (A..Z,0..9)')\nUSING1   IKJSUBF\nUSING    IKJIDENT 'USING',UPPERCASE,MAXLNTH=8,                         X\n               FIRST=ALPHA,OTHER=ALPHANUM,                             X\n               HELP=('ATTR name for dataset allocation considerations')\nLIKE1    IKJSUBF\nLIKE     IKJPOSIT DSNAME,USID,                                         X\n               HELP=('Dataset Name to be used as a model for allocatingX\n                a new output dataset.')\n./ DELETE  SEQ1=07570003,SEQ2=07570003\nDATA     DS    0D\nOUTTBL   DC    A(PDEXML1-PDEXML1)\n         DC    A(PDEXML2-PDEXML1)\n         DC    A(PDEXML3-PDEXML1)\n         DC    A(0)               NO PDE FOR TERMINAL\n         DC    A(PDESYSC-PDEXML1)\n         DC    A(0)               NO PDE FOR XML/NONXML\nLXMLTBL  EQU   *-OUTTBL\nMAXTBL   DC    A(LXMLTBL)\nOUTP     DC    A(DODDN),A(DODSN),A(DOPATH)\n         DC    A(DOTERM),A(DOSYSOUT)\nMOVESEG2 MVC   SEG2DATA+0(0),0(10)\nMOVESTR  MVC   0(*-*,R15),0(R14)\nXMLBEGIN DC    C' <?xml version=\"1.0\"?>'\nXML1     DC    C' <RACSEQ><PROFILE></PROFILE><CLASS></CLASS><SEGMENTS><X\n               /SEGMENTS>' 18/35/53\nXML1B    DC    C' </RACSEQ>'\nXML2     DC    C' <><FIELDS></FIELDS>' 2/11\nXML3     DC    C' <><SUBFIELDS></SUBFIELDS><OCCURRENCES></OCCURRENCES>'\n*                  2           14 39\nXMLEND   DC    C' </>' 3\nXML4     DC    C' <></>' 2/3/5\nMSG10    DC    C' Error! At most one of DDN, DSNAME, and PATH may be spX\n                ecified'\nMSG11    DC    C' Error! No data set name specified!'\nMSG12    DC    C' Output to DSN:'\nMSG14    DC    C' Output to DD:'\nMSG15    DC    C' Error! No DD name specified!'\nMSG16    DC    C' Output to PATH:'\nMSG17    DC    C' Error! No path name specified!'\nMSG18    DC    C' Error! SYSOUT has no operand.'\nMSG19    DC    C' Error! SYSOUT is not exactly 1 character.'\nMSG20    DC    C' Output will be in XML format.'\nMSG21    DC    C' Output will be directed to SYSOUT class '\nMSG22    DC    C' PATH must begin at the root. It may not be relative.'\nMSG23    DC    C' UNIX write failed. RET_VAL=-1, RC=0x ,RSN=0x'\nMSG24    DC    C' UNIX write incomplete. Desired= , Written='\nERR1     DC    C' Logic error. No logic to process a specified option.'\nERR2     DC    C' RECFM is unrecognized or invalid. Aborting.'\nERR3     DC    C' DSORG unusable. Must be PS. Aborting'\nERR4     DC    C' Open for UNIX file failed. RC=0x ,RSN=0x'\nERR5     DC    C' Error. LRECL too small for record. Record is  bytes  x\n               long. File LRECL is '\nEDMKINIT DC    (2*L'PACKDEC1-1)X'20'\nTOHEX    DC    C'0123456789ABCDEF'\n         DS    0D\nDCBINIT  DCB   MACRF=(PL),                                             X\n               DSORG=PS\nLDCB     EQU   *-DCBINIT\nOPENMFL  OPEN  (DCBINIT,(OUTPUT)),MF=L,MODE=31\nLOPEN    EQU   *-OPENMFL\n         DS    0D\nLDATA    EQU   *-DATA\nFULL0    DC    F'0'                    ADDRESS OF NULL IKJEFF02 ROUTINE\nDRFLR15  DC    A(0)\nDRFLPARM DC    XL(DFLEN)'00'\nDRFLID   DC    AL1(DFWTP),AL1(DFSVC99)\nBPX1WRT  DS    F                  DYNAMIC ADDRESS OF BPX1WRT\nLINKDRFL LINK  EP=IKJEFF18,SF=L        LINK TO DAIRFAIL SERVICE ROUTINE\nBPX1CLO  LINK  EP=BPX1CLO,SF=L\nBPX1OPN  LINK  EP=BPX1OPN,SF=L\n*\n* Mapped by BPXYMODE & BPXYFTYP\nUNIXMODE DC    AL1(0),AL1(0),AL1(S_IRUSR)\n         DC    AL1(S_IRWXU2+S_IRGRP)\n*\n* Mapped by BPXYOPNF\nO_FLAG DC      AL1(0),AL1(0),AL1(0)\n         DC    AL1(O_CREAT+O_TRUNC+O_WRONLY)\n*\n* THEN FOLLOWING CODE IS COPIED INTO THE 24-BIT DYNAMIC\n* AREA SO THAT OPEN, IN 24 BIT MODE, CAN USE IT\n* IT SIMPLY DOES A BRANCH-AND-SET-MODE TO THE REAL\n* EXIT AT OPEN31.\nOPEN24I  DS    0D\n         LA    1,0(,1)            CLEAR HOB OF R1 SO IT WON'T HURT\n*                                 ANYTHING IN 31 BIT MODE\n         L     15,AOPEN31-OPEN24I(,15)\n         BSM   14,15              INVOKE 31 BIT EXIT\nAOPEN31  DC    A(X'80000000'+OPEN31)\nLOPEN24  EQU   *-OPEN24I\n*\n* END OF COPIED CODE\n*\n* DCB OPEN EXIT R1 POINTS TO DCB UPON ENTRY\nOPEN31   DS    0H\n         CLI   DCBRECFM-IHADCB(R1),0\n         JNE   GOTRECFM\n         MVI   DCBRECFM-IHADCB(R1),DCBRECV+DCBRECBR\nGOTRECFM DS    0H\n         SLR   R0,R0\n         CH    R0,DCBLRECL-IHADCB(R1)\n         JNZ   GOTLRECL\n         LHI   3,125\n         STH   3,DCBLRECL-IHADCB(R1)\nGOTLRECL DS    0H\n         CH    R0,DCBBLKSI-IHADCB(R1)\n         JNZ   GOTBLKSI\n         LHI   R3,4096\n         STH   R3,DCBBLKSI-IHADCB(R1)\nGOTBLKSI DS    0H\n         TM    DCBRECFM-IHADCB(R1),DCBRECU\n         JO    RECFMU\n         TM    DCBRECFM-IHADCB(R1),DCBRECV\n         JO    RECFMV\n         TM    DCBRECFM-IHADCB(R1),DCBRECF\n         JO    RECFMF\n         J     BSM014\nRECFMU   DS    0H\n         MVC   DCBLRECL-IHADCB(1),DCBBLKSI-IHADCB(R1)\n         J     BSM014\nRECFMV   DS    0H\n         LH    R3,DCBBLKSI\n         AHI   R3,-4\n         CH    R3,DCBLRECL\n         JNL   BSM014\n         STH   R3,DCBLRECL\n         J     BSM014\nRECFMF   DS    0H\n         LH    R3,DCBBLKSI\n         SLR   R2,R2\n         LH    R0,DCBLRECL\n         DR    R2,R0\n         LTR   R2,R2\n         JZ    BSM014\n         MH    R3,DCBLRECL-IHADCB(R1)\n         STH   R3,DCBBLKSI-IHADCB(R1)\nBSM014   DS    0H\n         BSM   0,14               RETURN TO OPEN\nUNIXFD   DS    F                  UNIX File Descriptor\nPATHLEN  DS    F\nRET_VAL  DS    F                  UNIX return value\nRET_CODE DS    F                  UNIX return code\nRSN_CODE DS    F                  UNIX reason code\nSAVEFD2  DS    F                   Temp variable for @ field descriptor\nSAVEFD3  DS    F                   Temp variable for @ field descriptor\nPUTSAVE  DS    16F\nEDMKFLD  DS    CL(2*L'PACKDEC1-1)' '\nDYNEFF@  DS    F\nDYNEFF   DS    (L_EFF)C\nDO_PUT@  DS    A\nDYNS99R@ DS    A\nDYNS99RB DS    (L_S99RB)C' '\n         DS    0F\nTEXTP    DS    A  +0              ADDRESS OF DSN TEXT UNIT\n         DS    A   4              ADDRESS OF RETURN DDN TEXT UNIT\n         DS    A   8              ADDRESS OF DISP1\n         DS    A   12             ADDRESS OF DISP2\n         DS    A   16             ADDRESS OF DISP3\n         DS    A   20             FREE=CLOSE\n         DS    A   24             ADDRESS OF MEMBER\n         DS    A   28             ADDRESS OF LIKET\n         DS    A   32             ADDRESS OF USING\n         DS    A   36             ADDRESS OF NOTHING\nDSNT     DS    H,H,H,CL44         KEY=DALDSNAM\nMEMBERT  DS    H,H,H,CL8          KEY=DALMEMBR\nDISP1T   DS    3H,X               KEY=DALSTATS\nDISP2T   DS    3H,X               KEY=DALNDISP\nDISP3T   DS    3H,X               KEY=DALCDISP\nFREET    DS    2H                 KEY=DALCLOSE\nLIKET    DS    3H,CL44            KEY=DALDCBDS\nUSINGT   DS    3H,CL8             KEY=DALDCBDD\nDDNT     DS    3H,CL8             KEY=DALRTDDN\nSYSOUTT  DS    3H,C               KEY=DALSYSOU\nRACSEGSV DS    H,H,CL8            len, offset, data\n         DS    0F\nDCBOUT    DS    (LDCB)C' '\n         DS    0F\nOPEN     DS    (LOPEN)C' '\nXMLSWITCH DS    H\nOPENSW   DS    X\n         DS    0D\nOPEN24   DS    (LOPEN24)XL1\nEXLST    DS    F\n         DS    0D\nPDLOUTPUT DS   H\nPDLALLOC DS    H\nPDLXML   DS    H\n*\n* PDE FOR THE CLASS()\n*\n* PDE FOR PROFILE()\n*\n* PDE FOR DDN()\nPDEXML1  DS    0CL8\nXML1PTR  DS    A\nXML1LEN  DS    H\nXML1FLG  DS    X,X\n*\n* PDE FOR DSNAME()\nPDEXML2  DS    0CL24\nXML2PTR  DS    A\nXML2LEN  DS    H\nXML2FLG  DS    X,X\nXML2MEM  DS    A\nXML2LN2  DS    H\nXML2FLG2 DS    X,X\nXML2PSWD DS    A\nXML2LN3  DS    H\nXML2FLG3 DS    X,X\n*\n* PDE FOR PATH()\nPDEXML3  DS    0CL8\nXML3PTR  DS    A\nXML3LEN  DS    H\nXML3FLG  DS    X,X\n*\n* PDE FOR TERMINAL (AIN'T ONE!)\n*DETERM  DS    0CL8\n*ERMPTR  DS    A\n*ERMLEN  DS    H\n*ERMFLG  DS    X,X\n*\n* PDE FOR SYSOUT()\nPDESYSC  DS    0CL8\nSYSCPTR  DS    A\nSYSCLEN  DS    H\nSYSCFLG  DS    X\n         DS    X\n*\n* PDE FOR USING()\nPDEUSNG  DS    0CL8\nUSNGPTR  DS    A\nUSNGLEN  DS    H\nUSNGFLG  DS    X,X\n*\n* PDE FOR LIKE()\nPDELIKE  DS    0CL24\nLIKEPTR  DS    A\nLIKELEN  DS    H\nLIKEFLG  DS    X,X\nLIKEMEM  DS    A\nLIKELN2  DS    H\nLIKEFLG2 DS    X,X\nLIKEPSWD DS    A\nLIKELN3  DS    H\nLIKEFLG3 DS    X,X\n* PDE FOR XML/NONXML (AIN'T ONE!)\n         IKJEFFGF GFDSECT=YES\nL_EFF    EQU   *-GFDSECTD\n         EJECT\n         DCBD  DSORG=PS\n         IEFZB4D2\n         IEFZB4D0\nL_S99RB  EQU   S99RBEND-S99RB\n         IEFSJDKY\n         IKJEFFDF DFDSECT=YES      DAIRFAIL PARM LIST MAP\n         BPXYOPNF\n         BPXYMODE\n         BPXYFTYP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACSEQ": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x08\\x11O\\x01\\x08\\x11O\\x13#\\x088\\x088\\x00\\x00\\xe3\\xe2\\xc8\\xf0\\xf0\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-23T00:00:00", "modifydate": "2008-04-23T13:23:59", "lines": 2104, "newlines": 2104, "modlines": 0, "user": "TSH009"}, "text": "RACSEQ   TITLE 'RACSEQ - USE R_ADMIN TO EXTRACT RACF PROFILE'\n         PRINT OFF\n         COPY  IEABRC\n         PRINT ON\n         SYSSTATE ARCHLVL=2\n***********************************************************************\n***********************************************************************\n***                                                                 ***\n***  MODULE - RACSEQ                                                ***\n***                                                                 ***\n***      This TSO command invokes the extract function of R_admin   ***\n***      (IRRSEQ00) and displays every profile field to the         ***\n***      display using PUTLINE.                                     ***\n***                                                                 ***\n***      It is invoked from the TSO command line like:              ***\n***        RACSEQ CLASS(classname) PROFILE(profilename)             ***\n***                                                                 ***\n***      The supported classes are USER, GROUP, and CONNECT.        ***\n***      If not specified, CLASS defaults to USER. All values for   ***\n***      CLASS will be folded to upper case by TSO parse services.  ***\n***                                                                 ***\n***      The PROFILE field is a user ID or group name for USER      ***\n***      and GROUP, respectively. For CONNECT, it is the user ID    ***\n***      followed by a period followed by the group name. E.G.      ***\n***       IBMUSER.SYS1                                              ***\n***                                                                 ***\n***      NOTE: \"profilename\" is case-sensitive! This means you can  ***\n***            display lower case user IDs such as irrcerta, but    ***\n***            it also means you must remember to upper-case the    ***\n***            user ID for most cases.  If you forget, you will     ***\n***            receive a 4/4/4 return code combination!             ***\n***                                                                 ***\n***  INPUT: R1 points to the address of the CPPL                    ***\n***                                                                 ***\n***  RETURN CODES:                                                  ***\n***     0 - This sample always returns 0 unless altered.            ***\n***  non0 - Parse rc or SAF rc from R_admin                         ***\n***                                                                 ***\n***  Register usage:                                                ***\n***   R11 - Autodata base register                                  ***\n***   R12 - Base register                                           ***\n***   R13 - Savearea address                                        ***\n***  Further register usage is documented in the code below.        ***\n***                                                                 ***\n***********************************************************************\n***********************************************************************\n         EJECT\n***********************************************************************\n***********************************************************************\n***                                                                 ***\n***      COPYRIGHT IBM CORPORATION, 2006                            ***\n***                                                                 ***\n***      THIS CODE HAS NOT BEEN SUBMITTED TO ANY FORMAL IBM TEST    ***\n***      AND IS DISTRIBUTED ON AN \"AS IS\" BASIS WITHOUT ANY         ***\n***      WARRANTY EITHER EXPRESS OR IMPLIED. THE IMPLEMENTATION     ***\n***      OF ANY OF THE TECHNIQUES DESCRIBED OR USED HEREIN IS A     ***\n***      CUSTOMER RESPONSIBILITY AND DEPENDS ON THE CUSTOMER'S      ***\n***      OPERATIONAL ENVIRONMENT. WHILE EACH ITEM MAY HAVE BEEN     ***\n***      REVIEWED FOR ACCURACY IN A SPECIFIC SITUATION AND MAY      ***\n***      RUN IN A SPECIFIC ENVIRONMENT, THERE IS NO GUARANTEE       ***\n***      THAT THE SAME OR SIMILAR RESULTS WILL BE OBTAINED ELSE-    ***\n***      WHERE. CUSTOMERS ATTEMPTING TO ADAPT THESE TECHNIQUES TO   ***\n***      THEIR OWN ENVIRONMENTS DO SO AT THEIR OWN RISK.            ***\n***                                                                 ***\n***********************************************************************\n***********************************************************************\n         EJECT\nRACSEQ   CSECT ,                   An R_admin sample routine\nRACSEQ   AMODE 31\nRACSEQ   RMODE ANY\n         SAVE  (14,12),,RACSEQ-&SYSDATE-&SYSTIME\n*        USING RACSEQ,R12          set base register\n*\n* Get dynamic storage\n*\n         LARL  R12,DATA           POINT TO STATIC DATA AREA\n         USING DATA,R12\n         LR    R10,R1             SAVE CPPL ADDRESS\n         L     R0,DYNSIZE          dynamic area size to R0\n         STORAGE OBTAIN,                                               X\n               LOC=24,                                                 X\n               LENGTH=(0)\n         LR    R11,R1              dynamic area addressability\n         USING DATD,R11            base\n         USING S99RB,DYNS99RB\n         ST    R13,SAVEAREA+4      save caller's savearea address\n         ST    R11,8(R13)          save our savearea address\n         LR    R13,R11             our savearea address to R13\n         ST    R10,CPPLPTR         save saved input CPPL address\n         EJECT\n*\n* Initialize PUTLINE Output Line Descriptor (OLD) segment pointers\n* for use throughout this program. The pointers to the segments (i.e.\n* message line and inserts) remain constant; each message will set the\n* number of segments and the actual length/data.\n* Register usage\n*  R2 = CPPLUPT for PUTLINE\n*  R3 = CPPLECT for PUTLINE\n*  R5 = Disposable work reg\n*  R10 = Disposable work reg\n*\n         LA    R10,SEG1LEN\n         ST    R10,OLDSEGA1\n         LA    R10,SEG2LEN\n         ST    R10,OLDSEGA2\n         LA    R10,SEG3LEN\n         ST    R10,OLDSEGA3\n         LA    R10,SEG4LEN\n         ST    R10,OLDSEGA4\n         LARL  R10,BR5            POINT TO \"NO OUTPUT\" SUBROUTINE\n         ST    R10,DO_PUT@        PUT IT IN SUBROUTINE ADDRESS\n         XC    OPENSW,OPENSW\n         LHI   0,-1\n         ST    0,UNIXFD           Initialize UNIX File Descriptor\n         MVC   DCBOUT(LDCB),DCBINIT\n         USING IHADCB,DCBOUT\n         MVC   OPEN24(LOPEN24),OPEN24I\n         LA    0,OPEN24           POINT TO EXIT\n         ST    0,EXLST\n         MVI   EXLST,X'85'        OPEN EXIT CODE+HOB ON.\n         LA    0,EXLST\n         STCM  0,B'0111',DCBEXLSA POINT TO EXLST IN DCB\n*\n* Initialize parse stuff and parse the input command image.\n*\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         LA    R6,DYNPPL            GET ADDRESS OF PPL\n         USING PPL,R6               AND ESTABLISH ADDRESSABILITY\n         MVC   PPLUPT,CPPLUPT       PUT IN THE UPT ADDRESS FROM CPPL\n         L     R2,CPPLUPT           And keep it around in R2\n         MVC   PPLECT,CPPLECT       PUT IN THE ECT ADDRESS FROM CPPL\n         L     R3,CPPLECT           And keep it around in R3\n         LA    R0,PUTECB\n         MVC   PPLCBUF,CPPLCBUF     PUT IN THE COMMAND BUFFER ADDRESS\n         L     R5,=A(RACPDE)        Get address of parse macros (PCL)\n         ST    R5,PPLPCL            STORE IT IN THE PPL\n         LA    R5,PDLPTR            Get address of parse result anchor\n         ST    R5,PPLANS            STORE IT IN THE PPL\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)   INVOKE PARSE\n         LTR   R15,R15              IF PARSE RETURN CODE IS ZERO\n         JZ    GETANS               Go process results\n         DROP  R1\n*\n* Unexpected parse error.  Print return code and bail.\n*\n         ST    R15,SAFRC            Store rc\n         XC    DYNEFF(L_EFF),DYNEFF\n         LA    1,DYNEFF\n         USING GFDSECTD,1\n         MVC   GFCPPLP,CPPLPTR\n         ST    15,GFRCODE\n         LHI   0,GFPARSE\n         STH   0,GFCALLID\n         ST    1,DYNEFF@\n         DROP  1\n         LA    1,DYNEFF@\n         OI    0(1),X'80'\n         LINK  EP=IKJEFF19\n         MVC   OLDNUM,=A(2)         One message segment\n         LHI   R10,L'MSG9+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG9),MSG9\n         LHI   R10,6                2-digit rc + header\n         STH   R10,SEG2LEN\n         LHI   R10,L'MSG9           Insert position of rc (eol)\n         STH   R10,SEG2OFF\n         CVD   R15,PACKDEC1         Convert 2 digits of parse rc\n         LA    R10,PACKDEC1\n         UNPK  0(2,R10),6(2,R10)\n         OI    1(R10),X'F0'         Fix the sign nibble\n         MVC   SEG2DATA(2),PACKDEC1 Move 2-char parse rc\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\n* Get the class name and profile name from parse output. The class\n* name will determine the R_Admin function code to use.\n*\nGETANS   DS    0H\n         L     R1,PPLANS            Get the PDL anchor address\n         L     R1,0(,R1)            Get the PDL address itself\n         ST    R1,PDLPTR            Save it for later\n         DROP  R6\n         USING SEQPDL,R1            Get addressability to PDL\n         EJECT\n*\n* Initialize IRRSEQ00 parameters\n*\n         MVI   FUNCODE,ADMN_XTR_USER Assume USER class for now\n         OC    PDLCLASS,PDLCLASS    CLASS specified?\n         JZ    MOREPRMS             No, default to USER\n         L     R10,CLSPTR           Get class name ptr\n         CLC   GRPCLS(5),0(R10)     GROUP class?\n         JNE   CHKCON               Nope\n         MVI   FUNCODE,ADMN_XTR_GROUP Yup\n         J     MOREPRMS             Continue with R_admin parms\nCHKCON   DS    0H\n         CLC   CONCLS(7),0(R10)     CONNECT class?\n         JNE   CHKUSR               Nope\n         MVI   FUNCODE,ADMN_XTR_CONNECT Yup\n         J     MOREPRMS             Continue with R_admin parms\nCHKUSR   DS    0H\n         CLC   USERCLS(4),0(R10)    USER class?\n         JE    MOREPRMS             Yup\n         DROP  R1\n*\n*        Error - unsupported class. Issue a message.\n*\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG7+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG7),MSG7\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\nMOREPRMS DS    0H\n         L     R1,PDLPTR\n         USING SEQPDL,R1            Get addressability to PDL\n         XC    ALET,ALET            Use zero ALET\n         XC    SAFRC,SAFRC          Initialize return/reason codes\n         XC    RACFRC,RACFRC\n         XC    RACFRS,RACFRS\n         XC    USERLEN,USERLEN      Not supplying \"run-as\" user\n         XC    ACEE,ACEE            Not supplying \"run-as\" ACEE\n         MVI   SUBPOOL,127          Use subpool 127\n         XC    OUTMSG,OUTMSG        Clear output message pointer\n*\n* In the Parm_list area, fill in the version and the user length,\n* and copy the input user ID to the contiguous storage after the\n* Parm_list storage.\n*\n         LA    R6,RADPLIST\n         USING ADMN_PROF_MAP,R6\n         MVI   ADMN_PROF_VERSION,0\n         OC    PDLPROF,PDLPROF      PROFILE specified?\n         JNZ   GETPROF\n*\n*        Error.  No profile.  Issue syntax message.\n*\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG8+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG8),MSG8\n         DROP  R1\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\nGETPROF  DS    0H\n         USING SEQPDL,R1            Get addressability to PDL\n         LH    R8,PROFLEN           Get profile length\n         ST    R8,ADMN_PROF_NAMELEN Save length in plist header\n         L     R9,PROFPTR\n* The following instruction moves too much storage, but the extra will\n* be ignored because we just set the length accurately. But, this is\n* lazy and an execute instruction should be used.\n         MVC   EXTPROF,0(R9)        Move profile name to R_admin plist\n         DROP  R1\n         DROP  R6\n         EJECT\n*\n* Initialize IRRSEQ00 call parameter list.  That is, a list of\n* addresses to the individual parameters set up above.\n*\n         LA    R1,WORKAREA\n         ST    R1,WORKAREA@\n         LA    R1,ALET\n         ST    R1,ALET1@\n         ST    R1,ALET2@\n         ST    R1,ALET3@\n         LA    R1,SAFRC\n         ST    R1,SAFRC@\n         LA    R1,RACFRC\n         ST    R1,RACFRC@\n         LA    R1,RACFRS\n         ST    R1,RACFRS@\n         LA    R1,FUNCODE\n         ST    R1,FUNCODE@\n         LA    R1,RADPLIST\n         ST    R1,RADPLIST@\n         LA    R1,USER\n         ST    R1,USER@\n         LA    R1,ACEE\n         ST    R1,ACEE@\n         LA    R1,SUBPOOL\n         ST    R1,SUBPOOL@\n         LA    R1,OUTMSG\n         ST    R1,OUTMSG@\n         OC    OUTMSG@,=X'80000000'       Turn on VL bit in last parm\n*\n* Call R_admin.  We've manually built the plist which would correspond\n* to the following CALL statement (continuation characters omitted).\n*\n*        CALL  IRRSEQ00,\n*              (WORKAREA,\n*              ALET,SAFRC,\n*              ALET,RACFRC,\n*              ALET,RACFRS,\n*              FUNCODE,\n*              RADPLIST,\n*              0,0,              Not passing \"run-as\" user or ACEE\n*              SUBPOOL,\n*              OUTMSG),VL\n         LA    R1,WORKAREA@      Get list of addrs in R1\n         L     R15,=V(IRRSEQ00)\n         BASR  R14,R15\n*\n* Test return code and issue an error message if non-zero\n*\n         LT    R5,SAFRC           Get SAF return code\n         JZ    GOODSEQ\n*\n* Convert the return/reason codes for message inserts\n*\n         CVD   R5,PACKDEC1          Convert binary to packed decimal\n         LA    R5,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal\n         OI    1(R5),X'F0'          Fix the sign nibble\n         L     R5,RACFRC            Convert the RACF rc too\n         CVD   R5,PACKDEC2\n         LA    R5,PACKDEC2\n         UNPK  0(2,R5),6(2,R5)\n         OI    1(R5),X'F0'\n         L     R5,RACFRS            Convert the RACF reason code too\n         CVD   R5,PACKDEC3\n         LA    R5,PACKDEC3\n         UNPK  0(2,R5),6(2,R5)\n         OI    1(R5),X'F0'\n         MVC   OLDNUM,=A(4)         Four message segments\n         LHI   R5,L'MSG6+4\n         STH   R5,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG6),MSG6\n         LHI   R5,6                 All inserts will be 2 chars + hdr\n         STH   R5,SEG2LEN\n         STH   R5,SEG3LEN\n         STH   R5,SEG4LEN\n         LHI   R5,22                Insert position of SAF rc\n         STH   R5,SEG2OFF\n         MVC   SEG2DATA(2),PACKDEC1 Move 2-char SAF rc\n         LHI   R5,32                Insert position of RACF rc\n         STH   R5,SEG3OFF\n         MVC   SEG3DATA(2),PACKDEC2 Move 2-char RACF rc\n         LHI   R5,L'MSG6            Insert position of RACF rc (eol)\n         STH   R5,SEG4OFF\n         MVC   SEG4DATA(2),PACKDEC3 Move 2-char RACF rc\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\n         EJECT\n*\n* R_admin worked! We'll start the command output by simply echoing\n* the class and profile name, just to reassure the user. Also say\n* how many segments there are.\n*\nGOODSEQ  DS    0H                   Issue warm and fuzzy message\n         L     R1,PDLPTR\n         USING SEQPDL,R1\n         LH    R9,PDLOUTPUT\n         LTR   R9,R9\n         JZ    CONTXML            NO OUTPUT PARMS AT ALL\n*\n         AHI   R9,-1              MAKE ZERO BASED\n         SLL   R9,2               MAKE OFFSET\n         C     R9,MAXTBL          COMPARE TO MAX\n         JNL   OUTX               TOO BIG???\n         L     R10,OUTP(R9)       PROCESSING ROUTINE\n         L     R9,OUTTBL(R9)      GET OFFSET\n         LA    R9,PDEXML1(R9)     GET ADDRESS\n         BR    R10                PROCESS OPTION\n*\n* PROCESS OTHER OPTIONS\nOUTX     DS    0H\n         L     R8,MAXTBL\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         LHI   R0,L'ERR1+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'ERR1),ERR1\n         MVC   OLDNUM,=A(1)\n         J     DO_TERM\nDODDN    DS    0H\n* DDN(...)\n         TM    XML1FLG,X'80'      ANY DDN?\n         JZ    NODDN              NO???\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG14),MSG14\n         MVC   SEG1LEN,=AL2(4+L'MSG14)\n         MVC   SEG2OFF,=AL2(L'MSG14)\n         LH    9,XML1LEN\n         AHI   9,4\n         STH   9,SEG2LEN\n         AHI   9,-5\n         JM    NODDN\n         MVC   OLDNUM,=A(2)\n         L     14,XML1PTR\n         LA    R15,SEG2DATA\n         EX    9,MOVESTR\n         MVC   DCBDDNAM,=CL8' '\n         LA    R15,DCBDDNAM\n         EX    9,MOVESTR\n         LARL  5,DOOPEN3          WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\nNODDN    DS    0H\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG15),MSG15\n         MVC   SEG1LEN,=AL2(4+L'MSG15)\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nDODSN    DS    0H\n* DSNAME(...)\n         TM    XML2FLG,X'80'      ANY DSN?\n         JZ    NODSN              NO???\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG12),MSG12\n         MVC   SEG1LEN,=AL2(4+L'MSG12)\n         MVC   SEG2OFF,=AL2(L'MSG12)\n         LH    9,XML2LEN          GET LENGTH OF DSN\n         AHI   9,5\n         STH   9,SEG2LEN\n         AHI   9,-6\n         JM    NODSN\n         L     10,XML2PTR         POINT TO DSN\n         EX    9,MOVESEG2         MOVE IT IN\n         MVC   OLDNUM,=A(2)\n         JAS   5,DO_TERM\n         MVC   S99RBLN,=AL1(L_S99RB)\n         MVI   S99VERB,S99VRBAL\n         LA    R5,TEXTP\n         ST    R5,S99TXTPP\n         LA    R5,DYNS99RB\n         ST    R5,DYNS99R@\n         OI    DYNS99R@,X'80'     SET END-OF-LIST ON\n         LA    0,DSNT\n         ST    0,TEXTP+0\n         LA    0,DDNT\n         ST    0,TEXTP+4\n         LA    0,DISP1T\n         ST    0,TEXTP+8\n         LA    0,DISP2T\n         ST    0,TEXTP+12\n         LA    0,DISP3T\n         ST    0,TEXTP+16\n         LA    0,FREET\n         ST    0,TEXTP+20\n         LA    0,MEMBERT\n         ST    0,TEXTP+24\n         LA    0,LIKET\n         ST    0,TEXTP+28\n         LA    0,USINGT\n         ST    0,TEXTP+32\n         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING\n         ST    0,TEXTP+36\n         OI    TEXTP+36,X'80'\n         MVC   MEMBERT,=AL2(0)\n         MVC   LIKET,=AL2(0)\n         MVC   USINGT,=AL2(0)\n         LH    R9,XML2MEM\n         LTR   R9,R9              MEMBER NAME?\n         JZ    NOMEM              NOPE\n         STH   R9,MEMBERT+4\n         MVC   MEMBERT(2),=AL2(DALMEMBR)\n         MVC   MEMBERT+2(2),=AL2(1)\n         LA    15,MEMBERT+6\n         L     14,XML2MEM\n         AHI   9,-1\n         EX    9,MOVESTR          MOVE IN MEMBER NAME\nNOMEM    DS    0H\n         L     R1,PDLPTR\n         MVC   DSNT(2),=AL2(DALDSNAM)\n         MVC   DSNT+2(2),=AL2(1)\n         LH    5,XML2LEN\n         STH   5,DSNT+4\n         LA    15,DSNT+6\n         L     14,XML2PTR\n         AHI   5,-1\n         EX    5,MOVESTR\n         MVC   DISP1T(2),=AL2(DALSTATS)\n         MVC   DISP1T+2(2),=AL2(1)\n         MVC   DISP1T+4(2),=AL2(1)\n         MVI   DISP1T+6,X'01'     DISP=OLD\n         MVC   DISP2T(2),=AL2(DALNDISP)\n         MVC   DISP2T+2(2),=AL2(1)\n         MVC   DISP2T+4(2),=AL2(1)\n         MVI   DISP2T+6,X'08'     DISP=KEEP\n         MVC   DISP3T(2),=AL2(DALCDISP)\n         MVC   DISP3T+2(2),=AL2(1)\n         MVC   DISP3T+4(2),=AL2(1)\n         MVI   DISP3T+6,X'08'     DISP=KEEP\n         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE\n         XC    FREET+2(2),FREET+2\n         LH    5,LIKELEN\n         LTR   5,5\n         JZ    NOLIKE\n         MVC   LIKET(2),=AL2(DALDCBDS)\n         MVC   LIKET+2(2),=AL2(1)\n         STH   5,LIKET+4\n         AHI   5,-1\n         LA    15,LIKET+6\n         L     14,LIKEPTR\n         EX    5,MOVESTR\nNOLIKE   DS    0H\n         LH    5,USNGLEN\n         LTR   5,5\n         JZ    NOUSING\n         MVC   USINGT(2),=AL2(DALDCBDD)\n         MVC   USINGT+2(2),=AL2(1)\n         STH   5,USINGT+4\n         AHI   5,-1\n         LA    15,USINGT+6\n         L     14,USNGPTR\n         EX    5,MOVESTR\n         LA    R1,USINGT\nNOUSING  DS    0H\n         MVC   DDNT(2),=AL2(DALRTDDN)\n         MVC   DDNT+2(2),=AL2(1)\n         MVC   DDNT+4(2),=AL2(8)\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         DYNALLOC ,               DO DYNAMIC ALLOCATION\n         LTR   R15,R15\n         JZ    DOOPEN2\n         MVI   DISP1T+6,X'04'     DISP=NEW\n         MVI   DISP2T+6,X'02'     DISP=CATLG\n         MVI   DISP3T+6,X'02'     DISP=CATLG\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         DYNALLOC ,               TRY DISP=(NEW,CATLG,CATLG)\n         LTR   R15,R15\n         JZ    DOOPEN2\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DYNERR             WRITE MESSAGE TO USER\nDOOPEN2  DS    0H\n         LH    5,DDNT+4           GET LENGTH OF DDNAME\n         MVC   DCBDDNAM,=CL8' '   BLANK IT\n         LA    15,DCBDDNAM\n         LA    14,DDNT+6\n         AHI   5,-1\n         EX    5,MOVESTR\nDOOPEN3  DS    0H\n         MVC   OPEN(LOPEN),OPENMFL\n         LA    R1,OPEN\n         OPEN  (DCBOUT,(OUTPUT)),MF=(E,(1)),MODE=31\n         LTR   R5,R15\n         JZ    OPENOK\n         WTO   'OPEN FAILED',ROUTCDE=11\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nOPENOK   DS    0H\n         MVI   OPENSW,1           SAY WE DID THE OPEN\n         TM    DCBDSORG,DCBDSGPS\n         JZ    NOT_PS\n         TM    DCBRECFM,DCBRECF+DCBRECV\n         JNM   BAD_RECFM\n         LARL  5,DO_FILE_F        RECFM=F\n         ST    5,DO_PUT@\n         TM    DCBRECFM,DCBRECF\n         JO    CONTXML\n         LARL  5,DO_FILE_V        RECFM=V\n         ST    5,DO_PUT@\n         J     CONTXML\nBAD_RECFM DS   0H\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         LHI   R0,L'ERR2+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'ERR2),ERR2\n         MVC   OLDNUM,=A(1)\n         J     DO_TERM            Tell the user the recfm is bad\nNOT_PS   DS    0H\n         LHI   R0,L'ERR3+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'ERR3),ERR3\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         J     DO_TERM            Tell the user the DSORG is bad\nNODSN    DS    0H\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG11),MSG11\n         MVC   SEG1LEN,=AL2(4+L'MSG11)\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nDOPATH   DS    0H\n*|PATH(...)\n         LARL  5,DO_UNIX          OUTPUT TO UNIX FILE\n         ST    5,DO_PUT@\n         TM    XML3FLG,X'80'      ANY PATH?\n         JZ    NOPATH             NO???\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG16),MSG16\n         MVC   SEG1LEN,=AL2(4+L'MSG16)\n         MVC   SEG2OFF,=AL2(L'MSG16)\n         LH    9,XML3LEN         GET LENGTH OF PATH\n         AHI   9,5\n         STH   9,SEG2LEN\n         AHI   9,-6\n         JM    NOPATH             NULL?\n         L     10,XML3PTR         POINT TO PATH\n         CLI   0(10),C'/'         Path must begin at root\n         JNE   NOTROOT            But it isn't.\n         EX    9,MOVESEG2         MOVE IT IN\n         AHI   9,1                RESTORE TRUE LENGTH\n         ST    R9,PATHLEN         SAVE IN PARM LIST\n         LA    0,PATHLEN          +0\n         LA    1,SEG2DATA         +4\n         LA    R2,O_FLAG          +8\n         LA    3,UNIXMODE         +12\n         LA    R4,UNIXFD          +16\n         LA    R5,RET_CODE        +20\n         LA    R6,RSN_CODE        +24\n         STM   R0,R6,TEXTP\n         OI    TEXTP+24,X'80'\n         LA    R1,TEXTP\n         LINK  SF=(E,BPX1OPN)\n         LT    R15,UNIXFD\n         JM    UNIXFAIL           Open failed\n         LOAD  EP=BPX1WRT\n         ST    R0,BPX1WRT\n         MVC   OLDNUM,=A(2)\n         LARL  5,CONTXML          WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nUNIXFAIL DS    0H                 UNIX file failed to open\n         LHI   R0,L'ERR4+4\n         STH   R0,SEG1LEN\n         LHI   R0,8\n         STH   R0,SEG2LEN\n         STH   R0,SEG3LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG2OFF,=AL2(33)\n         MVC   SEG3OFF,=AL2(41)\n         MVC   SEG1DATA(L'ERR4),ERR4\n         UNPK  PACKDEC1(9),RET_CODE\n         TR    PACKDEC1(8),TOHEX-C'0'\n         MVC   SEG2DATA(8),PACKDEC1\n         UNPK  PACKDEC1(9),RSN_CODE\n         TR    PACKDEC1(8),TOHEX-C'0'\n         MVC   SEG2DATA(8),PACKDEC1\n         MVC   OLDNUM,=A(3)\n         LARL  R5,GETOUT\n         MVC   SAFRC,=F'20'\n         J     DO_TERM            Tell user UNIX open failed.\nNOTROOT  DS    0H\n         MVC   OLDNUM,=A(1)\n         LHI   R0,L'MSG22+4\n         STH   R0,SEG1LEN\n         MVC   SEG1DATA(L'MSG22),MSG22\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT          Where to go after message\n         J     DO_TERM            Write message to user's terminal\nNOPATH   DS    0H\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG17),MSG17\n         MVC   SEG1LEN,=AL2(4+L'MSG17)\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nDOTERM   DS    0H\n         LARL  5,DO_TERM\n         ST    5,DO_PUT@\n         J     CONTXML\nDOSYSOUT DS    0H\n         TM    SYSCFLG,X'80'      SYSOUT CLASS SPECIFIED?\n         JZ    NOCLASS            ERROR\n         LT    9,SYSCPTR          GET POINTER TO CLASS\n         JZ    NOCLASS            HUH?\n         CLC   SYSCLEN,=AL2(1)    CHECK LENGTH\n         JNE   BADCLASS\n*\n* Issue message to let the user know the sysout class\n         MVC   OLDNUM,=A(2)\n         LHI   R10,L'MSG21\n         STH   R10,SEG2OFF\n         AHI   R10,4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG21),MSG21\n         MVC   SEG2LEN,=AL2(5)\n*\n* MOVE THE SYSOUT CLASS\n         MVC   SEG2DATA(1),0(R9)  MOVE INTO MESSAGE\n         MVC   SYSOUTT+6,0(R9)    MOVE INTO DYNALLOC TEXT UNIT\n         JAS   5,DO_TERM\n*\n* MORE CODE TO ACTUALLY IMPLEMENT THIS\n         MVC   S99RBLN,=AL1(L_S99RB)\n         MVI   S99VERB,S99VRBAL\n         LA    R5,TEXTP\n         ST    R5,S99TXTPP\n         LA    R5,DYNS99RB\n         ST    R5,DYNS99R@\n         OI    DYNS99R@,X'80'     SET END-OF-LIST ON\n         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE\n         XC    FREET+2(2),FREET+2\n         MVC   DDNT(2),=AL2(DALRTDDN)\n         MVC   DDNT+2(2),=AL2(1)\n         MVC   DDNT+4(2),=AL2(8)\n         MVC   SYSOUTT(2),=AL2(DALSYSOU)\n         MVC   SYSOUTT+2(2),=AL2(1)\n         MVC   SYSOUTT+4(2),=AL2(1)\n         MVC   FREET(2),=AL2(DALCLOSE) FREE=CLOSE\n         XC    FREET+2(2),FREET+2\n         L     1,PDLPTR\n         LH    5,LIKELEN\n         LTR   5,5\n         JZ    NOLIKE2\n         MVC   LIKET(2),=AL2(DALDCBDS)\n         MVC   LIKET+2(2),=AL2(1)\n         STH   5,LIKET+4\n         AHI   5,-1\n         LA    15,LIKET+6\n         L     14,LIKEPTR\n         EX    5,MOVESTR\nNOLIKE2  DS    0H\n         L     1,PDLPTR\n         LH    5,USNGLEN\n         LTR   5,5\n         JZ    NOUSING2\n         L     1,PDLPTR\n         MVC   USINGT(2),=AL2(DALDCBDD)\n         MVC   USINGT+2(2),=AL2(1)\n         STH   5,USINGT+4\n         AHI   5,-1\n         LA    15,USINGT+6\n         L     14,USNGPTR\n         EX    5,MOVESTR\nNOUSING2 DS    0H\n         DROP  R1\n         LA    0,SYSOUTT\n         ST    0,TEXTP+0\n         LA    0,FREET\n         ST    0,TEXTP+4\n         LA    0,DDNT\n         ST    0,TEXTP+8\n         LA    0,USINGT\n         ST    0,TEXTP+12\n         LA    0,LIKET\n         ST    0,TEXTP+16\n         LA    0,=AL2(0)          THIS IS REALLY A DO NOTHING\n         ST    0,TEXTP+20\n         OI    TEXTP+20,X'80'\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         DYNALLOC ,               DO DYNAMIC ALLOCATION\n         LTR   R15,R15\n         JZ    DOOPEN2\n         LA    R1,DYNS99R@        POINT TO PARM LIST\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DYNERR             WRITE MESSAGE TO USER\nNOCLASS  DS    0H\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG18+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG18),MSG18\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nBADCLASS DS    0H\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG19+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG19),MSG19\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\n*\nXMLERROR DS    0H\n* MORE THAN ONE OF DDN, DSNAME, OR PATH SPECIFIED\n* INSERT MORE CODE\n*\n*        Error - more than one of DDN, DSNAME, or PATH entered\n*\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG10+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG10),MSG10\n         MVC   SAFRC,=F'20'\n         LARL  5,GETOUT           WHERE TO GO BACK TO\n         J     DO_TERM            WRITE MESSAGE TO USER\nCONTXML  DS    0H\n         L     R1,PDLPTR\n         USING SEQPDL,R1\n* 1 ==> NONXML SPECIFIED OR DEFAULTED\n* 2 ==> XML SPECIFIED\n         MVC   XMLSWITCH,PDLXML\n         CLC   PDLXML,=AL2(2)\n         JNE   NOXML\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG20+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG20),MSG20\n         JAS   5,DO_TERM\n         LHI   R10,L'XMLBEGIN+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'XMLBEGIN),XMLBEGIN\n         L     5,DO_PUT@\n         BASR  5,5\nNOXML    DS    0H\n         MVC   OLDNUM,=A(4)         Four message segments\n         LHI   R5,L'MSG1+4\n         STH   R5,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG1),MSG1\n         L     R1,PDLPTR\n         USING SEQPDL,R1\n         LH    R5,PROFLEN           Get profile name length\n         AHI   R5,4                 Add 4 for header (length/offset)\n         STH   R5,SEG2LEN\n         LHI   R5,20                Offset of first insert\n         STH   R5,SEG2OFF\n         L     R14,PROFPTR          Source: profile pointer from parse\n         LA    R15,SEG2DATA         Target: segment data\n         LH    R5,SEG2LEN           Get profile length back\n         AHI   R5,-1                Decrement for execute\n         EX    R5,MOVESTR           Move profile name to msg data\n*\n         LHI   R5,30                Offset of second insert\n         STH   R5,SEG3OFF\n         LT    R9,CLSPTR            Get Class pointer from PDL\n         JZ    USEUSER              Not specified, default to USER\n         LH    R5,CLSLEN            Get class name length\n         AHI   R5,4                 Add 4 for header (len/offset)\n         STH   R5,SEG3LEN\n         LA    R15,SEG3DATA\n         LR    R14,R9\n         AHI   5,-1\n         EX    5,MOVESTR\n         MVC   SEG3DATA,0(R9)       Move class name to msg data\n         J     SEGNUMS              Proceed\n         DROP  R1\nUSEUSER  DS    0H                   Display USER class\n         LHI   R5,8                 4 for \"USER\" + header\n         STH   R5,SEG3LEN\n         MVC   SEG3DATA(4),=C'USER' Move USER class name to msg data\nSEGNUMS  DS    0H                   Insert number of segments\n         LHI   R5,6                 Max 2-digit #segments\n         STH   R5,SEG4LEN\n         LHI   R5,L'MSG1            Offset of third insert (eol)\n         STH   R5,SEG4OFF\n         USING ADMN_PROF_MAP,R1\n         L     R1,OUTMSG            Get output address in R1\n         L     R5,ADMN_PROF_NUMSEG  Number of segment descriptors\n         CVD   R5,PACKDEC1          Convert binary to packed decimal\n         LA    R5,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R5),6(2,R5)      Then to zoned decimal\n         OI    1(R5),X'F0'          Fix the sign nibble\n         MVC   SEG4DATA(2),PACKDEC1 Move 2-char number of segments\n         DROP  R1\n         CLI   XMLSWITCH+1,2      XML FORMAT?\n         JNE   NOTXML1\n         LHI   0,18\n         STH   0,SEG2OFF\n         LHI   0,35\n         STH   0,SEG3OFF\n         LHI   0,53\n         STH   0,SEG4OFF\n         LHI   5,L'XML1+4\n         STH   5,SEG1LEN\n         MVC   SEG1DATA(L'XML1),XML1\nNOTXML1  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n         EJECT\n***********************************************************************\n*\n* Now process the output.  For each segment descriptor, print a message\n* indicating the segment name.  For each of its field descriptors,\n* print the field name and its data.\n*  - For boolean field, print TRUE or FALSE\n*  - For repeat fields, print each of its constituent fields\n*\n* Register usage\n*  R1 = R_admin output buffer (OUTMSG)\n*  R2 = Number of segment descriptors to process\n*  R3 = Address of current segment descriptor\n*  R4 = Number of field descriptors to process\n*  R5 = Address of current field descriptor\n*\n***********************************************************************\n         USING ADMN_PROF_MAP,R1\n         L     R1,OUTMSG             Get output address in R1\n         L     R2,ADMN_PROF_NUMSEG   Number of segment descriptors\n         LA    R3,ADMN_PROF_PROFNAME Get addr of profile name\n         A     R3,ADMN_PROF_NAMELEN  Add length of profile name to get *\n                                     addr of 1st segment descriptor\n         USING ADMN_PROF_SEGDESC,R3  Basing for segment descriptor\n*\n         L     R5,ADMN_PROF_FIELDOFFSET Get offset to 1st field desc.\n         AR    R5,R1                 Add to base to get address\n         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor\n*\nDOSEGS   DS    0H                    For each segment descriptor\n         L     R4,ADMN_PROF_NUMFIELDS Number of field descriptors for  *\n                                     this segment\n         JAS   R14,SEGMSG            Issue segment message\n*\nDOFIELDS DS    0H                    For each field descriptor\n         LLH   R9,ADMN_PROF_FIELDTYPE  Get type of field\n         C     R9,=A(ADMN_PROF_RPTHDR) Is it a repeat field header?\n         JE    REPEAT                Yes, repeat field\n* Boolean fields and normal character fields land here. Go print them.\n         JAS   R14,FLDMSG            Display field name and value\n         J     NEXTFLD               Get next field\n*\nREPEAT   DS    0H\n         JAS   R15,DOREPEAT          Go process repeat field. R5 will  *\n                                     point to next FD on return\n         J     NEXTFLD2              Continue with main fields\n*\n* Set basing for next field descriptor. Decrement count of fields\n* to see if we are finished.\n*\nNEXTFLD  DS    0H\n         LA    R5,ADMN_PROF_NEXTFIELD Get next FD address\nNEXTFLD2 DS    0H\n         JCT   R4,DOFIELDS           Decrement number of fields\n*\n* Set basing for next segment descriptor. Decrement count of segments\n* to see if we are finished. Note that R5 is already pointing to the\n* first field descriptor in the next segment.\n*\nNEXTSEG  DS    0H\n         LA    R3,ADMN_PROF_NEXTSEG  Get next SD address\n         CLI   XMLSWITCH+1,2      XML OUTPUT?\n         JNE   NOXML2\n         MVC   OLDNUM,=A(2)\n         XC    SEG1OFF,SEG1OFF\n         LHI   R0,L'XMLEND+4\n         STH   R0,SEG1LEN\n         MVC   SEG1DATA(L'XMLEND),XMLEND\n         MVC   SEG2LEN(2+2+8),RACSEGSV\n         LHI   R0,3\n         STH   R0,SEG2OFF\n         LR    R14,R5             SAVE\n         L     R5,DO_PUT@\n         BASR  R5,R5\n         LR    R5,R14             RESTORE\nNOXML2   DS    0H\n         JCT   R2,DOSEGS             Decrement number of segments\n         J     FREEOUT               Done with segments, finish up\n         EJECT\n*\n* free the R_admin output storage\n*\nFREEOUT  DS    0H\n         CLI   XMLSWITCH+1,2      XML?\n         JNE   FREEOUT2           No\n         MVC   OLDNUM,=A(1)\n         XC    SEG1OFF,SEG1OFF\n         LHI   0,L'XML1B+4\n         STH   0,SEG1LEN\n         MVC   SEG1DATA(L'XML1B),XML1B\n         L     R5,DO_PUT@\n         BASR  R5,R5\nFREEOUT2 DS    0H\n         L     R1,OUTMSG\n         L     R0,ADMN_PROF_OUTLEN Output area size to R0\n         STORAGE RELEASE,                                              X\n               LENGTH=(0),                                             X\n               ADDR=(1),                                               X\n               SP=127\n         DROP  R1\n*\n* free the parse PDL and our dynamic storage and return...\n*\nGETOUT   DS    0H\n         LA    R1,PDLPTR           Point to the PDL pointer\n         IKJRLSA (R1)              Free storage that parse allocated\n         LT    R2,UNIXFD\n         JM    NOUNIX\n         LA    R2,UNIXFD          +0\n         LA    R3,RET_VAL         +4\n         LA    R4,RET_CODE        +8\n         LA    R5,RSN_CODE        +12\n         STM   R2,R5,REGSAVE      +16\n         OI    REGSAVE+16,X'80'\n         LA    R1,REGSAVE         POINT TO PARM LIST\n         LINK  SF=(E,BPX1CLO)\nNOUNIX   DS    0H\n         CLI   OPENSW,1\n         JNE   NOCLOSE\n         MVC   OPEN(LOPEN),OPENMFL\n         LA    R1,OPEN\n         CLOSE (DCBOUT),MF=(E,(1)),MODE=31\nNOCLOSE  DS    0H\n         L     R0,DYNSIZE          Dynamic area size to R0\n         L     R13,SAVEAREA+4      Restore R13\n         LR    R1,R11              Dynamic data address to R1\n         L     R5,SAFRC\n         STORAGE RELEASE,                                              X\n               LENGTH=(0),                                             X\n               ADDR=(1)\n         LR    R15,R5\n         RETURN (14,12),T,RC=(15)  Restore registers and return\n         EJECT\n*---------------------------------------------------------------------*\n* DOREPEAT:                                                           *\n*                                                                     *\n* For repeat fields, cycle through each subfield for each occurrence. *\n*                                                                     *\n* Register input:  R5  = address of repeat field header descriptor    *\n*                  R15 = return address                               *\n*                                                                     *\n* Register output: R5  = address of the next field descriptor after   *\n*                        the entire repeat field just processed       *\n*                                                                     *\n* Register usage:                                                     *\n*  R6 - Number of occurrences of repeat field                         *\n*  R7 - Number of subfields within each occurrence                    *\n*  R8 - Address of subfield descriptor                                *\n*  R9 - Work register                                                 *\n*---------------------------------------------------------------------*\nDOREPEAT DS    0H\n         ST    R5,SAVEFD2\n         ST    R15,SAVEFD3\n         JAS   R14,RPTMSG            Go print header field\n         L     R6,ADMN_PROF_RPTNUM   Number of occurrences\n         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address\nRPTOCC   DS    0H                    Process occurrence\n         L     R7,ADMN_PROF_FIELDDIM Number of subfields per occurrence\n         DROP  R5\nRPTSFLD  DS    0H                    Process subfield\n         ST    R5,SAVEFD             Save header field descriptor\n         LR    R5,R8                 Get subfield desc in R5 for FLDMSG\n         JAS   R14,FLDMSG            Print subfield name and value\n         L     R5,SAVEFD             Get header FD back\n         USING ADMN_PROF_FIELDDESC,R8 Basing for subfield descriptor\n         LA    R8,ADMN_PROF_NEXTFIELD Get next FD address\n         DROP  R8\n         JCT   R7,RPTSFLD            Loop if subfields remaining\n         CLI   XMLSWITCH+1,2      XML?\n         JE    NOSEP              No separator needed\n         JAS   R14,SEPMSG            Print separator\nNOSEP    DS    0H\n         JCT   R6,RPTOCC             Loop if occurrences remaining\n         CLI   XMLSWITCH+1,2\n         JNE   NOTXMLA\n         L     R5,SAVEFD2\n         USING ADMN_PROF_FIELDDESC,R5 Basing for subfield descriptor\n         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name\n         DROP  R5\n         MVC   SEG1DATA(L'XMLEND),XMLEND\n         LHI   0,L'XMLEND+4\n         STH   0,SEG1LEN\n         LHI   0,3\n         STH   0,SEG2OFF\n         XC    SEG1OFF,SEG1OFF\n         LA    1,SEG2DATA+7\n         LHI   6,8\nSQZA     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZA\n         BCTR  R1,0\n         JCT   R6,SQZA\nESQZA    DS    0H\n         AHI   R6,4\n         STH   R6,SEG2LEN\n         MVC   OLDNUM,=A(2)\n         L     R5,DO_PUT@\n         BASR  R5,R5\nNOTXMLA  DS    0H\n         LR    R5,R8                 All done. Set R5 to next FD addr\n         L     R15,SAVEFD3\n         BR    R15                   Return to caller\n*        DROP  R8\n*---------------------------------------------------------------------*\n* SEGMSG:                                                             *\n*                                                                     *\n* At the beginning of each segment, issue a message identifying the   *\n* segment name.                                                       *\n*                                                                     *\n* Register input:  R3  = address of segment descriptor                *\n*                  R4  = number of fields in this segment             *\n*                  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*---------------------------------------------------------------------*\nSEGMSG   DS    0H\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(3)         Three message segments\n         LHI   R10,L'MSG2+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG2),MSG2\n         LHI   R10,8+4              Get segment name length + header\n         STH   R10,SEG2LEN\n         LHI   R10,10               Offset of 1st insert\n         STH   R10,SEG2OFF\n         MVC   SEG2DATA(8),ADMN_PROF_SEGNAME  Move in segment name\n         MVC   RACSEGSV+2+2(8),SEG2DATA\n         LHI   R2,6                 Max 2-digit number of fields\n         STH   R2,SEG3LEN\n         LHI   R2,L'MSG2            Insert position of insert (eol)\n         STH   R2,SEG3OFF\n         CVD   R4,PACKDEC1          Convert binary to packed decimal\n         LA    R2,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal\n         OI    1(R2),X'F0'          Fix the sign nibble\n         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of fields\n         CLI   XMLSWITCH+1,2      XML?\n         JNE   NOTXML2            NO\n         MVC   SEG1DATA(L'XML2),XML2\n         LHI   0,L'XML2+4\n         STH   0,SEG1LEN\n         LHI   0,2\n         STH   0,SEG2OFF\n*\n* SQUEEZE OUT TRAILING BLANKS\n         LA    R1,SEG2DATA\n         LH    R2,SEG2LEN\n         AHI   R2,-4\n         AR    R1,R2\n         AHI   R1,-1\nSQZ1     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZ1\n         BCTR  R1,0               BACK UP ONE BYTE\n         BRCT  R2,SQZ1\nESQZ1    DS    0H\n         AHI   R2,4\n         STH   R2,SEG2LEN\n         LHI   0,11\n         STH   0,SEG3OFF\n         MVC   RACSEGSV(2+2+8),SEG2LEN\nNOTXML2  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n*        JAS   5,DO_TERM\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         EJECT\n*---------------------------------------------------------------------*\n* RPTMSG:                                                             *\n*                                                                     *\n* At the beginning of each repeat field, print a message identifying  *\n* the repeat field header name. There is no data to print.            *\n*                                                                     *\n* Register input:  R5  = address of field descriptor                  *\n*                  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nRPTMSG   DS    0H\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(4)         Four message segments\n         LHI   R10,L'MSG3+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG3),MSG3\n         LHI   R10,8+4              Get field name length + header\n         STH   R10,SEG2LEN\n         LHI   R10,16               Offset of 1st insert\n         STH   R10,SEG2OFF\n         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor\n         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name\n*\n         LHI   R2,6                 Max 2-digit #subfields\n         STH   R2,SEG3LEN\n         LHI   R2,27                Offset of 2nd insert\n         STH   R2,SEG3OFF\n         L     R4,ADMN_PROF_FIELDDIM Number of subfields per occurrence\n         CVD   R4,PACKDEC1          Convert binary to packed decimal\n         LA    R2,PACKDEC1          Going to use 8 byte field for both\n         UNPK  0(2,R2),6(2,R2)      Then to zoned decimal\n         OI    1(R2),X'F0'          Fix the sign nibble\n         MVC   SEG3DATA(2),PACKDEC1 Move 2-char number of subfields\n*\n         LHI   R2,8                 Max 4-digit #occurrences\n         STH   R2,SEG4LEN\n         LHI   R2,L'MSG3            Offset of 3rd insert (end of line)\n         STH   R2,SEG4OFF\n         L     R4,ADMN_PROF_RPTNUM  Number of occurrences\n         CVD   R4,PACKDEC2          Convert binary to packed decimal\n         LA    R2,PACKDEC2          Point to source\n         UNPK  0(4,R2),5(3,R2)      Then to zoned decimal\n         OI    3(R2),X'F0'          Fix the sign nibble\n         MVC   SEG4DATA(4),PACKDEC2 Move 4-char number of occurrences\n*\n         DROP  R5\n         CLI   XMLSWITCH+1,2      XML?\n         JNE   NOTXML3\n         MVC   SEG1DATA(L'XML3),XML3\n         LHI   0,L'XML3+4\n         STH   0,SEG1LEN\n         LHI   0,2\n         STH   0,SEG2OFF\n         LA    1,SEG2DATA\n         LH    2,SEG2LEN\n         AHI   2,-4\n         AR    R1,R2\n         AHI   R1,-1\nSQZ3     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZ3\n         BCTR  R1,0\n         JCT   R2,SQZ3\nESQZ3    DS    0H\n         AHI   R2,4\n         STH   R2,SEG2LEN\n         LHI   0,14\n         STH   0,SEG3OFF\n         LHI   0,39\n         STH   0,SEG4OFF\nNOTXML3  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         EJECT\n*---------------------------------------------------------------------*\n* FLDMSG:                                                             *\n*                                                                     *\n* For each field, display the field name and its value.               *\n*                                                                     *\n* Register input:  R5  = address of field descriptor                  *\n*                  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*---------------------------------------------------------------------*\nFLDMSG   DS    0H\n         USING ADMN_PROF_FIELDDESC,R5 Basing for field descriptor\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(3)         Three message segments\n         XC    SEG1OFF,SEG1OFF      Segment 1 offset always 0\n         LLH   R9,ADMN_PROF_FIELDTYPE\n         N     R9,=A(ADMN_PROF_REPEAT)\n         JZ    NOTRPT               Nope\n         LHI   R10,L'MSG4RPT+4      Use extra indentation for repeat\n         STH   R10,SEG1LEN\n         MVC   SEG1DATA(L'MSG4RPT),MSG4RPT\n         MVC   SEG2OFF,=AL2(5)      Indent field name 5 spaces\n         LHI   R10,L'MSG4RPT        Offset of 3rd insert (end of line)\n         STH   R10,SEG3OFF\n         J     NXTMSEG\nNOTRPT   DS    0H\n         LHI   R10,L'MSG4+4\n         STH   R10,SEG1LEN\n         MVC   SEG1DATA(L'MSG4),MSG4\n         MVC   SEG2OFF,=AL2(3)      Indent field name 3 spaces\n         LHI   R10,L'MSG4           Offset of 3rd insert (end of line)\n         STH   R10,SEG3OFF\nNXTMSEG  DS    0H\n         LHI   R10,8+4              Get field name length + header\n         STH   R10,SEG2LEN\n         MVC   SEG2DATA(8),ADMN_PROF_FIELDNAME  Move in field name\n*\n         ICM   R9,B'0011',ADMN_PROF_FIELDTYPE   Reload field type\n         L     R8,=A(ADMN_PROF_BOOLEAN)\n         NR    R9,R8                      Is field boolean?\n         JZ    NOTBOOL\n         L     R9,ADMN_PROF_FIELDFLAG     Get flag word\n         L     R8,=A(ADMN_PROF_VALUE)     Get equate for true/false\n         SLL   R8,16                      Move halfword to fullword\n         NR    R9,R8                      Is boolean value bit on?\n         JZ    NOTTRUE\n         LHI   R10,4+4              Length(\"TRUE\") + header\n         STH   R10,SEG3LEN\n         MVC   SEG3DATA(4),=C'TRUE'\n         J     DOFPUT\nNOTTRUE  DS    0H\n         LHI   R10,5+4              Length(\"FALSE\") + header\n         STH   R10,SEG3LEN\n         MVC   SEG3DATA(5),=C'FALSE'\n         J     DOFPUT\nNOTBOOL  DS    0H\n         L     R10,ADMN_PROF_FIELDLEN     Get length of field data\n         C     R10,=A(L'SEG3DATA)         Is value > buffer length?\n         JNH   NOPROB                     No\n         LHI   R10,L'SEG3DATA             Lazy again, just truncate\nNOPROB   DS    0H\n         ST    R10,SAVEDLEN               Save it for later\n         AHI   R10,4                      Add 4 for header\n         STH   R10,SEG3LEN                Store it\n         L     R14,ADMN_PROF_DATA_OFFSET  Get offset of field data\n         A     R14,OUTMSG                 Add to start of output block\n         LA    R15,SEG3DATA               Target: msg segment 3 data\n         L     R10,SAVEDLEN               Reload field length\n         AHI   R10,-1               Decrement length for move\n         EX    R10,MOVESTR          Move field data\nDOFPUT   DS    0H\n         CLI   XMLSWITCH+1,2      XML OUTPUT?\n         JNE   NOTXML4\n         LHI   0,L'XML4+4\n         STH   0,SEG1LEN\n         MVC   SEG1DATA(L'XML4),XML4\n         LHI   0,2\n         STH   0,SEG2OFF\n         LHI   0,3\n         STH   0,SEG3OFF\n         LHI   0,5\n         STH   0,SEG4OFF\n         LA    R1,SEG2DATA\n         LH    R2,SEG2LEN\n         AHI   R2,-4\n         AR    R1,R2\n         AHI   R1,-1\nSQZ4     DS    0H\n         CLI   0(R1),C' '\n         JNE   ESQZ4\n         BCTR  R1,0\n         JCT   R2,SQZ4\nESQZ4    DS    0H\n         AHI   R2,4\n         STH   R2,SEG2LEN\n         MVC   SEG4LEN,SEG2LEN\n         MVC   SEG4DATA,SEG2DATA\n         MVC   OLDNUM,=A(4)\nNOTXML4  DS    0H\n         L     5,DO_PUT@\n         BASR  5,5\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         EJECT\n*---------------------------------------------------------------------*\n* SEPMSG:                                                             *\n*                                                                     *\n* Print a separator line between occurrences of a repeat field.       *\n*                                                                     *\n* Register input:  R14 = return address                               *\n*                                                                     *\n* Register output:                                                    *\n*                                                                     *\n* Register usage:                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\nSEPMSG   DS    0H\n         STM   14,12,REGSAVE        Save caller's regs\n         MVC   OLDNUM,=A(1)         One message segment\n         LHI   R10,L'MSG5+4\n         STH   R10,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG5),MSG5\n         L     5,DO_PUT@\n         BASR  5,5\n         LM    14,12,REGSAVE        Restore caller's regs\n         BR    R14                  Return to caller\n         EJECT\n*\n***********************************************************************\n*\n*\n* Routine called by parse to validate a UNIX path\n*\n*\n***********************************************************************\nVALDPATH DS    0H\n         STM   14,12,12(13)\n         LM    5,7,0(1)           LOAD PARAMETERS\n* R5 POINTS TO THE PDE\n* R6 IS THE ADDRESS OF A WORK AREA\n* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE\n         L     8,0(,5)            POINT TO OPERAND\n         LH    10,4(,5)           LENGTH OF OPERAND\n         AHI   10,-1              DEC\n         SLR   15,15\n         JM    PATHERR1\nVALRET   DS    0H\n         l     14,12(,13)\n         LM    0,12,20(13)\n         BSM   0,14               RETURN TO PARSE\nPATHERR1 DS    0H\n         LHI   15,4\n         J     VALRET\n         EJECT\n*\n***********************************************************************\n*\n*\n* Routine called by parse to validate a DSN\n*\n*\n***********************************************************************\nVALIDSN  DS    0H\n         STM   14,12,12(13)\n         LM    5,7,0(1)           LOAD PARAMETERS\n* R5 POINTS TO THE PDE\n* R6 IS THE ADDRESS OF A WORK AREA\n* R7 MAY BE USED TO POINT TO A SECOND LEVEL MESSAGE\n         SLR   15,15\n         J     VALRET             RETURN TO PARSE\n         EJECT\nRC24     DS    0H\n         MVC   SAFRC,=F'24'\n         J     GETOUT\nDO_TERM DS     0H\n         STM   R0,R15,PUTSAVE\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         LA    R4,OLDNUM\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LTR   R15,R15\n         JNZ   *+2\n         LM    R0,R15,PUTSAVE\n         BR    5\nDO_FILE_F DS   0H                 OUTPUT USING DCB\n         STM   R0,R15,PUTSAVE\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LTR   R15,R15            Putline OK?\n         JNZ   RC24               No, exit with RC=24\n         L     2,PUTSEQ+8         Get address of record\n         LH    3,0(,2)            Get length of record\n         AHI   3,-4               Remove length of LLBB prefix\n         CH    3,DCBLRECL         Compare record length\n         JNH   DO_F_PUT\n*\n* DATASET LRECL TOO SMALL, INFORM USER\nBAD_RECLEN DS  0H\n         CVD   3,PACKDEC1\n*        UNPK  SEG2DATA(2*L'PACKDEC1-1),PACKDEC1\n*        OI    SEG2DATA+2*L'PACKDEC1-2,C'0'\n         MVC   EDMKFLD,EDMKINIT\n         LA    R1,EDMKFLD\n         EDMK  EDMKFLD,PACKDEC1\n         LR    R14,R1\n         LA    R15,SEG2DATA\n         LA    R9,EDMKFLD+L'EDMKFLD-1\n         SLR   R9,R1\n         EX    9,MOVESTR\n         AHI   R9,5\n         STH   R9,SEG2LEN\n         LHI   R0,L'ERR5+4\n         STH   R0,SEG1LEN\n*        LHI   R0,2*L'PACKDEC1-1+4\n*        STH   R0,SEG2LEN\n*        STH   R0,SEG3LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG2OFF,=AL2(46)\n         MVC   SEG3OFF,=AL2(L'ERR5)\n         MVC   SEG1DATA(L'ERR5),ERR5\n         LH    R0,DCBLRECL\n         CVD   R0,PACKDEC1\n         MVC   EDMKFLD,EDMKINIT\n         LA    R1,EDMKFLD\n         EDMK  EDMKFLD,PACKDEC1\n         LR    R14,R1\n         LA    R15,SEG3DATA\n         LA    R9,EDMKFLD+L'EDMKFLD-1\n         SLR   R9,R1\n         EX    9,MOVESTR\n         AHI   R9,5\n         STH   R9,SEG3LEN\n*        UNPK  SEG3DATA(2*L'PACKDEC1-1),PACKDEC1\n*        OI    SEG3DATA+2*L'PACKDEC1-2,C'0'\n         MVC   OLDNUM,=A(3)\n         MVC   SAFRC,=F'20'\n         LARL  R5,GETOUT\n         J     DO_TERM            Tell terminal user record too long\nDO_F_PUT DS    0H\n         PUT   DCBOUT             Get buffer\n         LH    3,DCBLRECL\n         AHI   3,-2\n         MVI   0(1),C' '\n         LR    14,1\n         LA    15,1(,1)\n         EX    3,MOVESTR          BLANK OUT I/O BUFFER\n         LH    3,0(,2)            Length of record to write\n         AHI   3,-5               Actual lrecl-1\n         LA    14,4(,2)           First character of actual data\n         LR    15,1               Buffer address\n         EX    3,MOVESTR          Move data to buffer\n         LR    R1,R2              Get buffer address\n         LH    R0,0(,R1)          Get length\n         STORAGE RELEASE,                                              X\n               ADDR=(1),                                               X\n               LENGTH=(0),                                             X\n               SP=1\n         LM    R0,R15,PUTSAVE\n         BR    5\nDO_FILE_V DS   0H                 OUTPUT USING DCB\n         STM   R0,R15,PUTSAVE\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         LA    R4,OLDNUM\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LTR   R15,R15            Putline OK?\n         JNZ   RC24               No, exit with RC=24\n         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE\n         LH    3,0(,14)           GET ITS LENGTH\n         CH    9,DCBLRECL         Will it fit?\n         JH    BAD_RECLEN         Yes\n         PUT   DCBOUT\n         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE\n         LR    R15,R1             BUFFER RETURNED BY PUT\n         AHI   9,-1               ADJ LENGTH FOR EX\n         EX    9,MOVESTR          MOVE THE RECORD TO THE BUFFER\n         L     R1,PUTSEQ+8        Get buffer address\n         LH    R0,0(,R1)          Get length\n         STORAGE RELEASE,                                              X\n               ADDR=(1),                                               X\n               LENGTH=(0),                                             X\n               SP=1\n         LM    R0,R15,PUTSAVE\n         BR    5\nDO_UNIX  DS    0H                 OUTPUT USING UNIX\n         STM   R0,R15,PUTSAVE\n         L     R1,CPPLPTR           Get address of CPPL\n         USING CPPL,R1              And establish addressability\n         L     R2,CPPLUPT\n         L     R3,CPPLECT\n         DROP  R1\n         XC    PUTECB,PUTECB        Clear ECB\n         PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,          *\n               OUTPUT=(OLDNUM,FORMAT,SINGLE,INFOR),MF=(E,PUTIOPL)\n         LTR   R15,R15            Putline OK?\n         JNZ   RC24               No, exit with RC=24\n         L     14,PUTSEQ+8        POINT TO RECORD FROM PUTLINE\n         LH    9,0(,14)           GET ITS LENGTH\n*        STH   9,SEG1LEN\n*        XC    SEG1OFF,SEG1OFF\n         AHI   9,-5               Actual length of data -1\n         LA    R14,4(,R14)        POINT TO DATA\n         LA    R15,SEG1DATA       SOMEWHERE TO PUT IT\n         EX    R9,MOVESTR         MOVE IT TO BUFFER\n         LA    R14,1(R9,R15)\n         MVI   0(R14),X'15'       EBCDIC NEWLINE\n         AHI   R9,2               Length of record plus the NL\n*        MVC   OLDNUM,=A(1)\n*        PUTLINE    PARM=PUTSEQ,UPT=(R2),ECT=(R3),ECB=PUTECB,\n*              OUTPUT=(OLDNUM,TERM,SINGLE,INFOR),MF=(E,PUTIOPL)\n         ST    R9,SAVEDLEN\n         L     R15,BPX1WRT\n         L     R2,UNIXFD\n         LA    R3,SEG1DATA\n         L     R4,SAVEDLEN\n         LA    R2,SEG1DATA\n         ST    R2,TEXTP\n         CALL  (15),(UNIXFD,                                           X\n               TEXTP,                                                  X\n               =F'0',                                                  X\n               SAVEDLEN,                                               X\n               RET_VAL,                                                X\n               RET_CODE,                                               X\n               RSN_CODE),VL,                                           X\n               MF=(E,TEXTP+4)\n         LM    R0,R1,RET_CODE\n         LT    R9,RET_VAL\n         JM    WRITFAIL           WRITE FAILED\n         C     R9,SAVEDLEN        WROTE ALL THE BYTES?\n         JNE   WRT2FAIL           FAILED AGAIN\n         L     R1,PUTSEQ+8        Get buffer address\n         LH    R0,0(,R1)          Get length\n         STORAGE RELEASE,                                              X\n               ADDR=(1),                                               X\n               LENGTH=(0),                                             X\n               SP=1\n         LM    R0,R15,PUTSAVE\n         BR    5\nWRITFAIL DS    0H\n         MVC   SAFRC,=F'20'\n         UNPK  PACKDEC1(9),RET_CODE(5)\n         TR    PACKDEC1(8),TOHEX-C'0'\n         UNPK  PACKDEC2(9),RSN_CODE(5)\n         TR    PACKDEC2(8),TOHEX-C'0'\n         LHI   R0,L'MSG23+4\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG23),MSG23\n         LHI   R0,8\n         STH   R0,SEG2LEN\n         STH   R0,SEG3LEN\n         LHI   R0,37\n         STH   R0,SEG2OFF\n         LHI   R0,45\n         STH   R0,SEG3OFF\n         MVC   SEG2DATA(8),PACKDEC1\n         MVC   SEG3DATA(8),PACKDEC2\n         MVC   OLDNUM,=A(3)\n         LARL  R5,GETOUT\n         J     DO_TERM\nWRT2FAIL DS    0H\n         MVC   SAFRC,=F'20'\n         LHI   R0,L'MSG24\n         STH   R0,SEG1LEN\n         XC    SEG1OFF,SEG1OFF\n         MVC   SEG1DATA(L'MSG24),MSG24\n         MVC   SEG2LEN,=AL2(8)\n         MVC   SEG3LEN,=AL2(8)\n         MVC   SEG2OFF,=AL2(32)\n         MVC   SEG3OFF,=AL2(43)\n         CVD   R9,PACKDEC1\n         OI    PACKDEC1+7,C'0'\n         MVC   SEG2DATA(8),PACKDEC1\n         L     R9,SAVEDLEN\n         CVD   R9,PACKDEC1\n         OI    PACKDEC1+7,C'0'\n         MVC   SEG3DATA(8),PACKDEC1\n         LARL  R5,GETOUT\n         J     DO_TERM\n*        J     GETOUT\nBR5      DS    0H                 NO OUTPUT AT ALL?\n         WTO   'BR5',ROUTCDE=11\n         BR    5\nDYNERR   DS    0H                      SAVE RETCODE FOR DAIRFAIL\n         USING DFDSECTD,DRFLPARM       SET ADDRESSIBLITY TO PARM LIST\n         ST    R15,DRFLR15             SAVE RETCODE FOR DAIRFAIL\n         ST    R1,DFS99RBP\n         LA    R1,DRFLPARM             LOAD DAIRFAIL PARM LIST ADDRESS\n         XC    DRFLPARM(DFLEN),DRFLPARM CLEAR AREA FIRST\n         LA    R15,DRFLR15             GET ADDRESS OF SAVED REG 15\n         ST    R15,DFRCP               SAVE IN DAIRFAIL PARM LIST\n         LA    R15,FULL0               GET ADDRESS OF OF DUMMY F02\n         ST    R15,DFJEFF02            SAVE IN DAIRFAIL PARM LIST\n         LA    R15,DRFLID              GET ADDRESS OF CALLER'S FLAGS\n         ST    R15,DFIDP               SAVE IN DAIRFAIL PARM LIST\n         LINK  SF=(E,LINKDRFL)         LINK TO DAIRFAIL SERVICE ROUTINE\n         BR    5\n*\n***********************************************************************\n*\n*\n* PARSE macros used to describe the command operands\n*\n*\n***********************************************************************\nRACPDE   IKJPARM\nKWCLASS  IKJKEYWD\n         IKJNAME 'CLASS',SUBFLD=SEQCLASS\nKWPROF   IKJKEYWD\n         IKJNAME 'PROFILE',SUBFLD=SEQPROF\nKWOUTPUT IKJKEYWD DEFAULT='TERMINAL'\n         IKJNAME 'DDNAME',SUBFLD=DDN,                                  X\n               ALIAS=('FI','FILE')\n         IKJNAME 'DSNAME',SUBFLD=DSNAME,                               X\n               ALIAS=('DATASET','DA')\n         IKJNAME 'PATH',SUBFLD=PATH ALIAS=('PATH')\n         IKJNAME 'TERMINAL'\n         IKJNAME 'SYSOUT',SUBFLD=OUTCLASS\nKWALLOC  IKJKEYWD\n         IKJNAME 'USING',SUBFLD=USING1\n         IKJNAME 'LIKE',SUBFLD=LIKE1\nKWXML    IKJKEYWD DEFAULT='NONXML'\n         IKJNAME  'NONXML'\n         IKJNAME  'XML'\nSEQCLASS IKJSUBF\nSFCLASS  IKJIDENT 'CLASS',MAXLNTH=8,FIRST=ANY,OTHER=ANY,               *\n               DEFAULT='USER',                                         *\n               HELP=('RACF class name from which to extract')\n*\nSEQPROF  IKJSUBF\nSFPROF   IKJIDENT 'PROFILE',MAXLNTH=255,FIRST=ANY,OTHER=ANY,           *\n               HELP=('RACF profile name to extract'),ASIS,             *\n               PROMPT='Profile name. Use <user>.<group> for CONNECT'\nDDN      IKJSUBF\nXMLDD    IKJIDENT 'DDN',UPPERCASE,MAXLNTH=8,FIRST=ALPHA,               X\n               OTHER=ALPHANUM,                                         X\n               HELP=('DD name to use for XML output')\nDSNAME   IKJSUBF\nXMLDS    IKJPOSIT DSNAME,USID,                                         X\n               HELP=('Dataset Name to be used for XML output')\nPATH     IKJSUBF\nXMLPAT   IKJIDENT 'PATH',ASIS,MAXLNTH=255,                             X\n               FIRST=ANY,OTHER=ANY,                                    X\n               VALIDCK=VALDPATH,                                       X\n               HELP=('UNIX path and file name')\nOUTCLASS IKJSUBF\nOUTCLAS  IKJIDENT 'SYSOUT',UPPERCASE,MAXLNTH=1,                        X\n               FIRST=NONATNUM,                                         X\n               HELP=('SYSOUT class (A..Z,0..9)')\nUSING1   IKJSUBF\nUSING    IKJIDENT 'USING',UPPERCASE,MAXLNTH=8,                         X\n               FIRST=ALPHA,OTHER=ALPHANUM,                             X\n               HELP=('ATTR name for dataset allocation considerations')\nLIKE1    IKJSUBF\nLIKE     IKJPOSIT DSNAME,USID,                                         X\n               HELP=('Dataset Name to be used as a model for allocatingX\n                a new output dataset.')\n         IKJENDP\n         EJECT\n*\n* static data\n*\nDATA     DS    0D\nDYNSIZE  DC    AL4(SIZEDATD)       dynamic area size\nUSERCLS  DC    CL4'USER'           USER class\nGRPCLS   DC    CL5'GROUP'          GROUP class\nCONCLS   DC    CL7'CONNECT'        CONNECT class\nPUTSEQ   PUTLINE MF=L\nOUTTBL   DC    A(PDEXML1-PDEXML1)\n         DC    A(PDEXML2-PDEXML1)\n         DC    A(PDEXML3-PDEXML1)\n         DC    A(0)               NO PDE FOR TERMINAL\n         DC    A(PDESYSC-PDEXML1)\n         DC    A(0)               NO PDE FOR XML/NONXML\nLXMLTBL  EQU   *-OUTTBL\nMAXTBL   DC    A(LXMLTBL)\nOUTP     DC    A(DODDN),A(DODSN),A(DOPATH)\n         DC    A(DOTERM),A(DOSYSOUT)\nMOVESEG2 MVC   SEG2DATA+0(0),0(10)\nMOVESTR  MVC   0(*-*,R15),0(R14)\n*\n* Define text of command output and error messages. There must be\n* a leading blank so that we are immune to the TSO PROFILE MSGID\n* setting.\n*\nXMLBEGIN DC    C' <?xml version=\"1.0\"?>'\nMSG1     DC    CL41' Displaying profile  in class . Segments:'\nXML1     DC    C' <RACSEQ><PROFILE></PROFILE><CLASS></CLASS><SEGMENTS><X\n               /SEGMENTS>' 18/35/53\nXML1B    DC    C' </RACSEQ>'\nMSG2     DC    CL18' Segment:  Fields:'\nXML2     DC    C' <><FIELDS></FIELDS>' 2/11\nMSG3     DC    CL40'   Repeat field: Subfields: Occurrences:'\nXML3     DC    C' <><SUBFIELDS></SUBFIELDS><OCCURRENCES></OCCURRENCES>'\n*                  2           14 39\nXMLEND   DC    C' </>' 3\nMSG4     DC    CL4'   :'             2 spaces||fieldname||:||value\nXML4     DC    C' <></>' 2/3/5\nMSG4RPT  DC    CL6'     :'           4 spaces||fieldname||:||value\nMSG5     DC    CL50'     ---------------------------------------------'\nMSG6     DC    CL46' R_admin Error! SAFrc  - RACFrc  - RACFreason '\nMSG7     DC    CL26' Error! Unsupported class!'\nMSG8     DC    CL45' Syntax: RACSEQ CLASS(class) PROFILE(profile)'\nMSG9     DC    CL28' IKJPARS error! Return Code '\nMSG10    DC    C' Error! At most one of DDN, DSNAME, and PATH may be spX\n                ecified'\nMSG11    DC    C' Error! No data set name specified!'\nMSG12    DC    C' Output to DSN:'\nMSG14    DC    C' Output to DD:'\nMSG15    DC    C' Error! No DD name specified!'\nMSG16    DC    C' Output to PATH:'\nMSG17    DC    C' Error! No path name specified!'\nMSG18    DC    C' Error! SYSOUT has no operand.'\nMSG19    DC    C' Error! SYSOUT is not exactly 1 character.'\nMSG20    DC    C' Output will be in XML format.'\nMSG21    DC    C' Output will be directed to SYSOUT class '\nMSG22    DC    C' PATH must begin at the root. It may not be relative.'\nMSG23    DC    C' UNIX write failed. RET_VAL=-1, RC=0x ,RSN=0x'\nMSG24    DC    C' UNIX write incomplete. Desired= , Written='\nERR1     DC    C' Logic error. No logic to process a specified option.'\nERR2     DC    C' RECFM is unrecognized or invalid. Aborting.'\nERR3     DC    C' DSORG unusable. Must be PS. Aborting'\nERR4     DC    C' Open for UNIX file failed. RC=0x ,RSN=0x'\nERR5     DC    C' Error. LRECL too small for record. Record is  bytes  x\n               long. File LRECL is '\nEDMKINIT DC    (2*L'PACKDEC1-1)X'20'\nTOHEX    DC    C'0123456789ABCDEF'\n         DS    0D\n         LTORG\n         DS    0D\nDCBINIT  DCB   MACRF=(PL),                                             X\n               DSORG=PS\nLDCB     EQU   *-DCBINIT\nOPENMFL  OPEN  (DCBINIT,(OUTPUT)),MF=L,MODE=31\nLOPEN    EQU   *-OPENMFL\n         DS    0D\nLDATA    EQU   *-DATA\nFULL0    DC    F'0'                    ADDRESS OF NULL IKJEFF02 ROUTINE\nDRFLR15  DC    A(0)\nDRFLPARM DC    XL(DFLEN)'00'\nDRFLID   DC    AL1(DFWTP),AL1(DFSVC99)\nBPX1WRT  DS    F                  DYNAMIC ADDRESS OF BPX1WRT\nLINKDRFL LINK  EP=IKJEFF18,SF=L        LINK TO DAIRFAIL SERVICE ROUTINE\nBPX1CLO  LINK  EP=BPX1CLO,SF=L\nBPX1OPN  LINK  EP=BPX1OPN,SF=L\n*\n* Mapped by BPXYMODE & BPXYFTYP\nUNIXMODE DC    AL1(0),AL1(0),AL1(S_IRUSR)\n         DC    AL1(S_IRWXU2+S_IRGRP)\n*\n* Mapped by BPXYOPNF\nO_FLAG DC      AL1(0),AL1(0),AL1(0)\n         DC    AL1(O_CREAT+O_TRUNC+O_WRONLY)\n*\n* THEN FOLLOWING CODE IS COPIED INTO THE 24-BIT DYNAMIC\n* AREA SO THAT OPEN, IN 24 BIT MODE, CAN USE IT\n* IT SIMPLY DOES A BRANCH-AND-SET-MODE TO THE REAL\n* EXIT AT OPEN31.\nOPEN24I  DS    0D\n         LA    1,0(,1)            CLEAR HOB OF R1 SO IT WON'T HURT\n*                                 ANYTHING IN 31 BIT MODE\n         L     15,AOPEN31-OPEN24I(,15)\n         BSM   14,15              INVOKE 31 BIT EXIT\nAOPEN31  DC    A(X'80000000'+OPEN31)\nLOPEN24  EQU   *-OPEN24I\n*\n* END OF COPIED CODE\n*\n* DCB OPEN EXIT R1 POINTS TO DCB UPON ENTRY\nOPEN31   DS    0H\n         CLI   DCBRECFM-IHADCB(R1),0\n         JNE   GOTRECFM\n         MVI   DCBRECFM-IHADCB(R1),DCBRECV+DCBRECBR\nGOTRECFM DS    0H\n         SLR   R0,R0\n         CH    R0,DCBLRECL-IHADCB(R1)\n         JNZ   GOTLRECL\n         LHI   3,125\n         STH   3,DCBLRECL-IHADCB(R1)\nGOTLRECL DS    0H\n         CH    R0,DCBBLKSI-IHADCB(R1)\n         JNZ   GOTBLKSI\n         LHI   R3,4096\n         STH   R3,DCBBLKSI-IHADCB(R1)\nGOTBLKSI DS    0H\n         TM    DCBRECFM-IHADCB(R1),DCBRECU\n         JO    RECFMU\n         TM    DCBRECFM-IHADCB(R1),DCBRECV\n         JO    RECFMV\n         TM    DCBRECFM-IHADCB(R1),DCBRECF\n         JO    RECFMF\n         J     BSM014\nRECFMU   DS    0H\n         MVC   DCBLRECL-IHADCB(1),DCBBLKSI-IHADCB(R1)\n         J     BSM014\nRECFMV   DS    0H\n         LH    R3,DCBBLKSI\n         AHI   R3,-4\n         CH    R3,DCBLRECL\n         JNL   BSM014\n         STH   R3,DCBLRECL\n         J     BSM014\nRECFMF   DS    0H\n         LH    R3,DCBBLKSI\n         SLR   R2,R2\n         LH    R0,DCBLRECL\n         DR    R2,R0\n         LTR   R2,R2\n         JZ    BSM014\n         MH    R3,DCBLRECL-IHADCB(R1)\n         STH   R3,DCBBLKSI-IHADCB(R1)\nBSM014   DS    0H\n         BSM   0,14               RETURN TO OPEN\n*\n* DSECT for this routine's dynamic area\n*\nDATD     DSECT\n         DS    0D\nSAVEAREA DS    18F                 register save area\nREGSAVE  DS    16F                 internal subroutine save area\nUNIXFD   DS    F                  UNIX File Descriptor\nPATHLEN  DS    F\nRET_VAL  DS    F                  UNIX return value\nRET_CODE DS    F                  UNIX return code\nRSN_CODE DS    F                  UNIX reason code\nSAVEDLEN DS    F                   Temp variable for field data length\nSAVEFD   DS    F                   Temp variable for @ field descriptor\nSAVEFD2  DS    F                   Temp variable for @ field descriptor\nSAVEFD3  DS    F                   Temp variable for @ field descriptor\nPUTSAVE  DS    16F\nDYNPPL   DS    CL(L_PPL)           PPL area\nPPLPTR   DS    F                   Pointer to DYNPPL\nCPPLPTR  DS    F                   Pointer to input CPPL\nPDLPTR   DS    F                   Pointer to output PDL\nMYECB    DS    F                   Command ECB\nPUTIOPL  DS    4F                  E-form IOPL area for PUTLINE\nPUTECB   DS    F                   ECB for PUTLINE\nPACKDEC1 DS    CL8                 Output for CVD\nPACKDEC2 DS    CL8                 Output for CVD\nPACKDEC3 DS    CL8                 Output for CVD\nEDMKFLD  DS    CL(2*L'PACKDEC1-1)' '\n*\n* Output Line Descriptor (OLD) fields for PUTLINE\nOLDNUM   DS    F                   Number of segments\nOLDSEGA1 DS    F                   Pointer to first message segment\nOLDSEGA2 DS    F                   Pointer to second message segment\nOLDSEGA3 DS    F                   Pointer to third message segment\nOLDSEGA4 DS    F                   Pointer to fourth message segment\nSEG1LEN  DS    H                   Segment 1 length\nSEG1OFF  DS    H                   Segment 1 offset\nSEG1DATA DS    CL100               Segment 1 data\nSEG2LEN  DS    H                   Segment 2 length\nSEG2OFF  DS    H                   Segment 2 offset\nSEG2DATA DS    CL100               Segment 2 data\nSEG3LEN  DS    H                   Segment 3 length\nSEG3OFF  DS    H                   Segment 3 offset\nSEG3DATA DS    CL255               Segment 3 data\nSEG4LEN  DS    H                   Segment 4 length\nSEG4OFF  DS    H                   Segment 4 offset\nSEG4DATA DS    CL255               Segment 4 data\n*\n* Parms for IRRSEQ00\n*\nWORKAREA DS    CL1024\nALET     DS    F\nSAFRC    DS    F\nRACFRC   DS    F\nRACFRS   DS    F\nFUNCODE  DS    AL1\nUSER     DS    0CL9\nUSERLEN  DS    AL1\nUSERID   DS    CL8\nACEE     DS    F\nSUBPOOL  DS    AL1\nOUTMSG   DS    F\nRADPLIST DS    CL(ADMN_PROF_PROFNAME-ADMN_PROF_MAP) Plist header\nEXTPROF  DS    CL17                                 Profile to extract\nDYNEFF@  DS    F\nDYNEFF   DS    (L_EFF)C\nDO_PUT@  DS    A\nDYNS99R@ DS    A\nDYNS99RB DS    (L_S99RB)C' '\n         DS    0F\nTEXTP    DS    A  +0              ADDRESS OF DSN TEXT UNIT\n         DS    A   4              ADDRESS OF RETURN DDN TEXT UNIT\n         DS    A   8              ADDRESS OF DISP1\n         DS    A   12             ADDRESS OF DISP2\n         DS    A   16             ADDRESS OF DISP3\n         DS    A   20             FREE=CLOSE\n         DS    A   24             ADDRESS OF MEMBER\n         DS    A   28             ADDRESS OF LIKET\n         DS    A   32             ADDRESS OF USING\n         DS    A   36             ADDRESS OF NOTHING\nDSNT     DS    H,H,H,CL44         KEY=DALDSNAM\nMEMBERT  DS    H,H,H,CL8          KEY=DALMEMBR\nDISP1T   DS    3H,X               KEY=DALSTATS\nDISP2T   DS    3H,X               KEY=DALNDISP\nDISP3T   DS    3H,X               KEY=DALCDISP\nFREET    DS    2H                 KEY=DALCLOSE\nLIKET    DS    3H,CL44            KEY=DALDCBDS\nUSINGT   DS    3H,CL8             KEY=DALDCBDD\nDDNT     DS    3H,CL8             KEY=DALRTDDN\nSYSOUTT  DS    3H,C               KEY=DALSYSOU\n*\n* Parm list for IRRSEQ00.  That is, a list of adresses to the actual\n* Parameter data defined above.\n*\nWORKAREA@ DS    A\nALET1@    DS    A\nSAFRC@    DS    A\nALET2@    DS    A\nRACFRC@   DS    A\nALET3@    DS    A\nRACFRS@   DS    A\nFUNCODE@  DS    A\nRADPLIST@ DS    A\nUSER@     DS    A\nACEE@     DS    A\nSUBPOOL@  DS    A\nOUTMSG@   DS    A\nRACSEGSV DS    H,H,CL8            len, offset, data\n         DS    0F\nDCBOUT    DS    (LDCB)C' '\n         DS    0F\nOPEN     DS    (LOPEN)C' '\nXMLSWITCH DS    H\nOPENSW   DS    X\n         DS    0D\nOPEN24   DS    (LOPEN24)XL1\nEXLST    DS    F\n         DS    0D\nSIZEDATD EQU   *-DATD              length of DSECT\n*\n***********************************************************************\n* The following DSECT maps the results of the parse.                  *\n***********************************************************************\n         EJECT\nSEQPDL   DSECT\nPDLHDR   DS    CL8\nPDLCLASS DS    H\nPDLPROF  DS    H\nPDLOUTPUT DS   H\nPDLALLOC DS    H\nPDLXML   DS    H\n*\n* PDE FOR THE CLASS()\nPDECLASS DS    0CL8\nCLSPTR   DS    F\nCLSLEN   DS    H\n         DS    CL2\n*\n* PDE FOR PROFILE()\nPDEPROF  DS    0CL8\nPROFPTR  DS    F\nPROFLEN  DS    H\n         DS    CL2\n*\n* PDE FOR DDN()\nPDEXML1  DS    0CL8\nXML1PTR  DS    A\nXML1LEN  DS    H\nXML1FLG  DS    X,X\n*\n* PDE FOR DSNAME()\nPDEXML2  DS    0CL24\nXML2PTR  DS    A\nXML2LEN  DS    H\nXML2FLG  DS    X,X\nXML2MEM  DS    A\nXML2LN2  DS    H\nXML2FLG2 DS    X,X\nXML2PSWD DS    A\nXML2LN3  DS    H\nXML2FLG3 DS    X,X\n*\n* PDE FOR PATH()\nPDEXML3  DS    0CL8\nXML3PTR  DS    A\nXML3LEN  DS    H\nXML3FLG  DS    X,X\n*\n* PDE FOR TERMINAL (AIN'T ONE!)\n*DETERM  DS    0CL8\n*ERMPTR  DS    A\n*ERMLEN  DS    H\n*ERMFLG  DS    X,X\n*\n* PDE FOR SYSOUT()\nPDESYSC  DS    0CL8\nSYSCPTR  DS    A\nSYSCLEN  DS    H\nSYSCFLG  DS    X\n         DS    X\n*\n* PDE FOR USING()\nPDEUSNG  DS    0CL8\nUSNGPTR  DS    A\nUSNGLEN  DS    H\nUSNGFLG  DS    X,X\n*\n* PDE FOR LIKE()\nPDELIKE  DS    0CL24\nLIKEPTR  DS    A\nLIKELEN  DS    H\nLIKEFLG  DS    X,X\nLIKEMEM  DS    A\nLIKELN2  DS    H\nLIKEFLG2 DS    X,X\nLIKEPSWD DS    A\nLIKELN3  DS    H\nLIKEFLG3 DS    X,X\n* PDE FOR XML/NONXML (AIN'T ONE!)\n*\n* equates\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n*\n* MAPPINGS\n*\n         IKJCPPL\n         IKJPPL\nL_PPL    EQU   *-PPL\n         IKJEFFGF GFDSECT=YES\nL_EFF    EQU   *-GFDSECTD\n         EJECT\n         IRRPCOMP\n         EJECT\n         CVT   DSECT=YES        CVT MAPPING NEEDED FOR CALLTSSR MACRO\n         EJECT\n         DCBD  DSORG=PS\n         IEFZB4D2\n         IEFZB4D0\nL_S99RB  EQU   S99RBEND-S99RB\n         IEFSJDKY\n         IKJEFFDF DFDSECT=YES      DAIRFAIL PARM LIST MAP\n         BPXYOPNF\n         BPXYMODE\n         BPXYFTYP\n         END   RACSEQ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACSEQ1": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00B\\x01\\x08\\x11O\\x01\\x08\\x11O\\x13\\x10\\x00\\x18\\x00\\x18\\x00\\x00\\xe3\\xe2\\xc8\\xf0\\xf0\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-23T00:00:00", "modifydate": "2008-04-23T13:10:42", "lines": 24, "newlines": 24, "modlines": 0, "user": "TSH009"}, "text": "//         JOB (H00000I),'RACSEQ8',\n//         CLASS=D,\n//         MSGCLASS=X,\n//         NOTIFY=&SYSUID\n//STEP010  EXEC  PGM=IKJEFT01,\n//             REGION=4096K,\n//             DYNAMNBR=40\n//STEPLIB DD DISP=SHR,DSN=STEPLIB\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n RACSEQ CLASS(USER) PROFILE(user) +\n    DSNAME(existing.dsn.to.overwrite)\n RACSEQ CLASS(USER) PROFILE(user) +\n    SYSOUT(x)\n RACSEQ CLASS(USER) PROFILE(user) +\n    LIKE(some.existing.dsn) +\n    XML DSNAME(new.dsn.to.create)\n ATTRIB ATTRLIST RECFM(V B) LRECL(137) DSORG(PS)\n RACSEQ CLASS(USER) PROFILE(user) +\n    USING(ATTRLIST) +\n    XML DSNAME(new.dsn.to.create)\n RACSEQ CLASS(USER) PROFILE(user) +\n    XML PATH('/u/myid/somefile.xml')\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT781/FILE781.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT781", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}