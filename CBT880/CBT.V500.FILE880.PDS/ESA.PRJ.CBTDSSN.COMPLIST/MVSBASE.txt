
15694A01 V1.13 z/OS XL C++             //'ESA.PRJ.CBTDSSN.CPP(MVSBASE)'                      30.11.12 08:25:52
0                                      * * * * *   P R O L O G   * * * * *
    Compiler options. . . . . . . :AGGRCOPY(NOOVERLAP)             ANSIALIAS       ARCH(7)         ARGPARSE        NOASCII
                                  :NOATTRIBUTE     ASSERT(RESTRICT)                BITFIELD(UNSIGNED)              CHARS(UNSIGNED)
                                  :NOCOMPACT       NOCOMPRESS      CVFT            NODFP           DIGRAPH         DLL(CALLBACKANY)
                                  :ENUMSIZE(SMALL) NOEVENTS        EXECOPS         EXH             NOEXPMAC        NOEXPORTALL
                                  :NOFASTTEMPINC   FLAG(I)         NOGOFF          GONUMBER        HALT(16)
                                  :NOHGPR(NOPRESERVE)              NOHOT           NOIGNERRNO      ILP32           NOINITAUTO
                                  :NOINLRPT        NOLIBANSI       NOLIST          LONGNAME        NOMAKEDEP       NOMARGINS
                                  :MAXMEM(2097152) MEMORY          NAMEMANGLING(zOSV1R2)           NESTINC(255)    OBJECT
                                  :OBJECTMODEL(COMPAT)             NOOE            NOOFFSET        OPTIMIZE(2)     PLIST(HOST)
                                  :NOPORT          NOPPONLY        PREFETCH        REDIR           NOREPORT        ROSTRING
                                  :ROCONST         RTTI(ALL)       NOSEQUENCE      NOSHOWINC       NOSHOWMACROS    SOURCE
                                  :SKIPSRC(SHOW)   SPILL(3600)     START           NOSTATICINLINE  STRICT
                                  :NOSTRICT_INDUCTION              TARGET(LE,CURRENT)              TEMPLATEDEPTH(300)
                                  :NOTEMPLATEREGISTRY              TEMPLATERECOMPILE               TERMINAL        TEST(HOOK)
                                  :TMPLPARSE(NO)   TUNE(7)         UNROLL(AUTO)    UTF             NOWARN0X        NOWARN64
                                  :NOWSIZEOF       NOXREF
                                  :NOCICS
                                  :NOCONVLIT
                                  :NOCSECT
                                  :DEBUG(FORMAT(ISD),LEVEL(0),HOOK(NOLINE,NOBLOCK,NOPATH,CALL,FUNC),NOSYMBOL)
                                  :DEFINE(__OS390__=1,_POSIX_SOURCE=1,_XOPEN_SOURCE_EXTENDED=1,MU_STANDALONE=1,ISIS_PF_MU=1)
                                  :FLOAT(HEX,FOLD,NOMAF,AFP(NOVOLATILE)) ROUND(Z)
                                  :NOHALTONMSG
                                  :INFO(LAN)
                                  :INLINE(AUTO,NOREPORT,100,1000)
                                  :NOIPA
                                  :KEYWORD(bool,explicit,export,false,mutable,namespace,true,typename,using,restrict,__restrict__,
                                   __restrict,_Pragma,__alignof__,__asm__,__attribute__,__const__,__extension__,__volatile__,
                                   __inline__,__signed__,__typeof__,__I,_Complex,__complex__,__real__,__imag__)
                                  :NOKEYWORD(char16_t,char32_t,decltype,static_assert,typeof)
                                  :LANGLVL(ANONSTRUCT,ANONUNION,ANSIFOR,ANSISINIT,NOAUTOTYPEDEDUCTION,C99VLA,C99__FUNC__,
                                   NOC99LONGLONG,NOC99PREPROCESSOR,NOCOMPATRVALUEBINDING,NODBCS,NODECLTYPE,NODELEGATINGCTORS,
                                   DEPENDENTBASELOOKUP,NODOLLARINNAMES,EMPTYSTRUCT,NOEXTENDEDFRIEND,NOEXTENDEDINTEGERSAFE,
                                   EXTERNTEMPLATE,ILLPTOM,IMPLICITINT,NOINLINENAMESPACE,LIBEXT,LONGLONG,NONEWEXCP,OFFSETNONPOD,
                                   NOOLDDIGRAPH,OLDFRIEND,NOOLDMATH,NOOLDSTR,OLDTEMPACC,NOOLDTMPLALIGN,OLDTMPLSPEC,NOSTATIC_ASSERT,
                                   NOTEMPSASLOCALS,NOTEXTAFTERENDIF,GNU_LABELVALUE,GNU_COMPUTEDGOTO,TRAILENUM,TYPEDEFCLASS,NOUCS,
                                   VARARGMACROS,NOVARIADICTEMPLATES,GNU_INCLUDE_NEXT,ZEROEXTARRAY,NOC99COMPLEX,NOC99COMPLEXHEADER,
                                   NOGNU_COMPLEX,GNU_SUFFIXIJ)
                                  :LOCALE(DE_DE.IBM-273)
                                  :NOLSEARCH
                                  :OPTFILE(DD:OPTFILE)
                                  :NORTCHECK
                                  :SEARCH(//'CEE.SCEEH.+', //'CBC.SCLBH.+', CEE.SCEEH.+, CBC.SCLBH.+, DD:USERLIB)
                                  :NOSERVICE
                                  :NOSQL
                                  :NOSUPPRESS
                                  :TEMPINC(./tempinc)
                                  :NOXPLINK(NOBACKCHAIN,NOCALLBACK,GUARD,OSCALL(UPSTACK),NOSTOREARGS)
    Version Macros. . . . . . . . : __COMPILER_VER__=0x410D0000
                                  : __LIBREL__=0x410D0000
                                  : __TARGET_LIB__=0x410D0000
    Source margins. . . . . . . . :
      Varying length. . . . . . . : 1 - 32760
      Fixed length. . . . . . . . : 1 - 32760
    Sequence columns. . . . . . . :
      Varying length. . . . . . . : none
      Fixed length. . . . . . . . : none
    Locale name . . . . . . . . . : DE_DE.IBM-273
    Code set. . . . . . . . . . . : IBM-273
    Listing name. . . . . . . . . : DD:SYSCPRT
0                                 * * * * *   E N D   O F   P R O L O G   * * * * *
-
15694A01 V1.13 z/OS XL C++             //'ESA.PRJ.CBTDSSN.CPP(MVSBASE)'                      30.11.12 08:25:52
-
                                       * * * * *   S O U R C E   * * * * *
0            1 |
             2 | /*******************************************************************************
             3 | * Copyright ISIS Papyrus Technologies Limited
             4 | *-------------------------------------------------------------------------------
             5 | * File:              $Source: /data/cvs/src/mvs/mvsbase.cpp,v $
             6 | *-------------------------------------------------------------------------------
             7 | * Description:
             8 | *   ???
             9 | *******************************************************************************/
            10 |
            11 |
            12 | #include "isisdef.h"
            13 | #include <stdlib.h>
            14 | #include <string.h>
            15 | #include <strings.h>
            16 | #ifndef MU_STANDALONE
            17 | #include "pcsdll.hpp"
            18 | #include "systems.hpp" //szm20041028
            19 | #else
            20 | 	#ifndef stricmp
            21 |     #define stricmp strcmpi
            22 | 	#endif
            23 | 	#ifndef strcmpi
            24 | 		#define strcmpi strcasecmp
            25 | 	#endif
            26 | 	#define MVSBatch() 1
            27 | 	#ifndef PCS_MAX_PATH
            28 | 		#define PCS_MAX_PATH 1024
            29 | 	#endif
            30 | #endif
            31 |
            32 | #include "mvsbase.hpp"
            33 | #if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0 //szm20050810
            34 | #include "isismisc.hpp"
            35 | #endif
            36 | #include "misc.hpp"
            37 | #ifdef CALL_TAG
            38 | #include "pphctags.hpp"
            39 | #endif
            40 | #ifdef OWN_STDIO
            41 | #include "stdio.hpp"
            42 | #else
            43 | #include <assert.h>
            44 | #include <stdio.h>
            45 | #endif
            46 |
            47 | #include <stdlib.h>
            48 | #include <strings.h>
            49 | #include <ctype.h>
            50 | #include <new.h>
            51 |
            52 | #if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)
            53 |
            54 | #include "ibmdebug.hpp"
            55 | #if defined(ISIS_PF_MI) ]] defined (ISIS_PF_MU)
            56 | #include <ctest.h>
            57 | #endif
            58 | #endif
            59 |
            60 | #define MVSBASE  0
            61 | char mvsSTRING::parseSepCh=0 ; //szm20061218 mvsSTRING parse escape ch is null|||||||
            62 |
            63 | mvsSTRING nullstring(""); //szm20050629
            64 |
            65 | //KV20050203 why not for ms,mu ??
            66 | //#if defined(ISIS_PF_MS)==0 && defined(ISIS_PF_MU)==0
            67 | void * memcpyp(void * target , const void * source, size_t tsize, size_t ssize, int pad)
            68 | 	ä
            69 | 	if ( target == 0 ]] source == 0 ]] tsize <= 0) return NULL;
            70 | 	if( tsize<=ssize)
            71 | 		memcpy(target,source,tsize);
            72 | 	else
            73 | 		ä
            74 | 		memcpy(target,source,ssize);
            75 | 		for(;ssize<tsize;ssize++) *((char *)target+ssize) = char(pad);
            76 | 		ü
            77 | 	return target;
            78 | 	ü
            79 |
            80 | static const char * SAS_HFS = "hfs";
            81 | static const char * IBM_HFS = "///";
            82 | static const char * SAS_DSN = "dsn";
            83 | static const char * IBM_DSN = "//";
            84 | static const char * SAS_DDN = "ddn";
            85 | static const char * IBM_DDN  = "dd";
            86 | static const char * IBM_DDN_SLASH = "//dd";
            87 | static const char * _MEM     = "mem"; //szm0040909
            88 | static const char * IBM_OMS  = "oms"; //szm20080215 ToDo 17339
            89 | static const char * IBM_HTTP = "http"; //szm20090709
            90 | static const char * IBM_HTTPS = "https"; //szm20090709
            91 |
            92 |
            93 | genOpenNameType genOpenType(const char *name)
            94 | 	ä
            95 | 	char  nmÄ256Ü;
            96 | 	char  npÄ256Ü;
            97 | 	char  pfÄ32Ü;
            98 | 	memset(pf,0,sizeof(pf));
            99 | 	genOpenNameType t = ont_unknown;
           100 |
           101 | 	if (name == 0 ]] strlen(name) > sizeof(nm))
           102 | 		return(t);
           103 |
           104 | 	strcpy(np,name);
           105 | 	char * n = (char *)np;
           106 | 	char * c = NULL;
           107 | 	if ((c = strchr(n,int(':'))) NEQ NULL)
           108 | 		ä
           109 | 		*c = 0;
           110 | 		strcpy(pf,n);
           111 | 		n  =  c+1;
           112 | 		ü
           113 | 	if (stricmp(pf,IBM_OMS))  //szm20080215 ToDo 17339
           114 | 		ä                       //szm20080215 ToDo 17339
           115 | 		if (stricmp(pf,SAS_HFS) == 0) t = sas_hfs;
           116 | 		else if (stricmp(pf,_MEM) == 0) t = ont_mem;   //szm0040909
           117 | 		else if (stricmp(pf,IBM_DDN) == 0 ]] stricmp(pf,IBM_DDN_SLASH) == 0) t = ibm_ddn;
           118 | 		else  if (stricmp(pf,SAS_DDN) == 0) t = sas_ddn;
           119 | 		else if (stricmp(pf,SAS_DSN) == 0) t = sas_dsn;
           120 |     else if (stricmp(pf,IBM_HTTP) == 0]]stricmp(pf,IBM_HTTPS) == 0) t = ibm_hfs; //szm20090709
           121 | 		else
           122 | 			ä
           123 |       if (strncasecmp   (np,IBM_HFS,strlen(IBM_HFS)) == 0 ]] (npÄ0Ü == '/' && npÄ1Ü-'/') ]](npÄ0Ü ==
           123 |  '.' && npÄ1Ü=='/'))//szm20090709
           124 | 				t = ibm_hfs;
           125 | 			else if (strncasecmp   (np,IBM_DSN,strlen(IBM_DSN)) == 0) t = ibm_dsn;
           126 | 			//KV20050419 in mvsbatch execution dataset names and ddnames don't need prefix
           127 | 			// in unix execution such names are interpreted as unix file names
           128 | 			else if(MVSBatch())
           129 | 				ä
           130 | 				if (*n == '"' ]] *n =='Ö'') t = ibm_dsn;
           131 | 				else if (strchr(n,'(') && (strchr(n,'(')-n) <= 8 ) t = ont_ddn;
           132 | 				else if (strchr(n,'.')) t = ont_dsn;
           133 | 				else if (strlen(n) <= 8) t = ont_ddn;
           134 | 				else if (strlen(n) <=18 && strchr(n,'(') && strchr(n,')')) t = ont_ddn;
           135 | 				else
           136 | 					t = ont_unknown;
           137 | 				ü
           138 | 			else
           139 | 				ä
           140 | 				t=ibm_hfs;
           141 | 				ü
           142 | 			ü
           143 | 		ü //szm20080215 ToDo 17339
           144 | #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) //ZA030711
           145 | 	//  HOST_IBM_TRACE_sd(name,t);
           146 | #endif
           147 | 	return t;
           148 | 	ü
           149 |
           150 |
           151 | //KV20060329 buffer nm to avoid static variable
           152 | char * onlyMemberName(const char * n, char* nm)
           153 | 	ä
           154 | 	mvsSTRING s(n), p0, p1, p2;
           155 | 	s.parse(p0,"(",p1,")",p2);
           156 | 	strcpy(nm,(char *)(p1));
           157 | 	return nm;
           158 | 	ü
           159 |
           160 | //KV20060329 buffer nm to avoid static variable
           161 | char * stripMemberName(const char * n, char* nm)
           162 | 	ä
           163 | 	mvsSTRING s(n), p0, p1, p2;
           164 | 	s.parse(p0,"(",p1,")",p2);
           165 | 	strcpy(nm,(char *)(p0+p2));
           166 | 	return nm;
           167 | 	ü
           168 |
           169 | //KV20060329 buffer nm to avoid static variable
           170 | ISIS_EXT_C
           171 | char * genOpenName(const char *name,char *nm)
           172 | 	ä
           173 | 	char  npÄ256Ü;
           174 | 	char  pfÄ32Ü;
           175 | 	memset(pf,0,sizeof(pf));
           176 | 	genOpenNameType t = ont_unknown;
           177 |
           178 | 	if (name == 0 ]] strlen(name) > PCS_MAX_PATH-1)
           179 | 		return("??invalid name??");
           180 |
           181 | 	if (*name-'"' && *name-'Ö'')
           182 | 		ä
           183 | 		strcpy(np,name);
           184 | 		ü
           185 | 	else
           186 | 		ä
           187 | 		strcpy(np,name+1);
           188 | 		//KV20030714: avoid deleting ending qoutes for //'datat.set.name'
           189 | 		if (npÄstrlen(np)-1Ü == '"' ]] npÄstrlen(np)-1Ü == 'Ö'')
           190 | 			npÄstrlen(np)-1Ü  = 0;
           191 | 		ü
           192 | 	for(int i =strlen(np)-1;i>=0&&npÄiÜ==' ';i--)npÄiÜ=0;
           193 | 	t = genOpenType(np);
           194 |
           195 | 	char * n = (char *)np;
           196 | 	char * c = NULL;
           197 | 	if ((c = strchr(n,int(':'))) NEQ NULL)
           198 | 		ä
           199 | 		*c = 0;
           200 | 		strcpy(pf,n);
           201 | 		n  =  c+1;
           202 | 		ü
           203 |
           204 | #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) // IBM or UNIX (not SAS)szm20031030
           205 | 	if (strcmp("(*)",n+strlen(n)-3)==0) //szm 20100628 zOS 1.11 fopen difference
           206 | 		*(n+strlen(n)-3) = 0;       //szm 20100628 zOS 1.11 fopen difference
           207 | 	switch(t)
           208 | 		ä
           209 | 		case ont_mem:         //szm0040909
           210 | 			sprintf(nm,"mem:%s",n);
           211 | 			break;
           212 | 		case ibm_dsn:
           213 | 			if (*(n+2) - 'Ö'')
           214 | 				sprintf(nm,"//'%s'",n+2);
           215 | 			else
           216 | 				strcpy(nm,n);
           217 | 			break;
           218 | 		case sas_dsn:
           219 | 		case ont_dsn:
           220 | 			if (*n - 'Ö'')
           221 | 				sprintf(nm,"//'%s'",n);
           222 | 			else
           223 | 				sprintf(nm,"//%s",n);
           224 | 			break;
           225 | 		case ibm_ddn:
           226 | 		case sas_ddn:
           227 | 		case ont_ddn:
           228 | 			sprintf(nm,"//dd:%s",n);
           229 | 			break;
           230 | 		case sas_hfs:
           231 | 			sprintf(nm,"%s",n);
           232 | 			break;
           233 | 		case ibm_hfs:
           234 | 		case ont_unknown:
           235 | 			sprintf(nm,"%s",n);
           236 | 			break;
           237 | 		ü
           238 | #else
           239 | 	switch(t)
           240 | 		ä
           241 | 		case ont_mem:         //szm0040909
           242 | 			sprintf(nm,"mem:%s",n);
           243 | 			break;
           244 | 		case ibm_dsn:
           245 | 		case sas_dsn:
           246 | 		case ont_dsn:
           247 | 			sprintf(nm,"dsn:%s",n);
           248 | 			break;
           249 | 		case ibm_ddn:
           250 | 		case sas_ddn:
           251 | 		case ont_ddn:
           252 | 			sprintf(nm,"ddn:%s",n);
           253 | 			break;
           254 | 		case ibm_hfs:
           255 | 			sprintf(nm,"hfs:%s",nm+3);
           256 | 			break;
           257 | 		case sas_hfs:
           258 | 			sprintf(nm,"hfs:%s",n);
           259 | 			break;
           260 | 		case ont_unknown:
           261 | 			sprintf(nm,"%s",n);
           262 | 			break;
           263 | 		ü
           264 | #endif
           265 | #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)
           266 | 	HOST_IBM_TRACE_sss(name,nm,n);
           267 | #endif
           268 | 	return (nm);
           269 | 	ü
           270 |
           271 | USHORT  Ushort(int i)
           272 | 	ä return ((unsigned short)i);ü
           273 | USHORT  Ushort(short s)
           274 | 	ä return ((unsigned short)s);ü
           275 | USHORT  Ushort(char c)
           276 | 	ä return ((unsigned short)c);ü
           277 |
           278 |
           279 | /*--------------------------------------------------------------+
           280 | ]  mvsSTRING global class                                          ]
           281 | ]                                                               ]
           282 | ]                                                               ]
           283 | +--------------------------------------------------------------*/
           284 |
           285 | /*
           286 | FORMAT F_alcu(aLEFT,cUPPER);
           287 | FORMAT F_alcw(aLEFT,cWORD);
           288 | FORMAT F_arcu(aRIGHT,cUPPER);
           289 | */
           290 |
           291 | mvsSTRING::mvsSTRING()
           292 | 	ä
           293 | 	st.l = 1;
           294 | 	st.c = new charÄ1Ü;
           295 | 	st.type = str::_VALID;
           296 | 	st.ltype = str::VARIABLE;
           297 | 	*st.c = null;ü
           298 | mvsSTRING::mvsSTRING(const char * y)
           299 | 	ä
           300 | 	char * x = (y ? (char *) y : "");
           301 | 	st.l = (long int ) strlen(x);
           302 | 	st.c = new charÄst.l+1Ü;
           303 | 	st.type = str::_VALID;
           304 | 	st.ltype = str::VARIABLE;
           305 | 	strcpy(st.c,x);
           306 | 	ü
           307 | mvsSTRING::mvsSTRING(const mvsSTRING & x )
           308 | 	ä
           309 | 	st.l = x.st.l;
           310 | 	st.c = new charÄst.l+1Ü;
           311 | 	st.type = x.st.type ;
           312 | 	st.ltype = x.st.ltype ;
           313 | 	memcpy(st.c,x.st.c,st.l+1);
           314 | 	ü
           315 | mvsSTRING::mvsSTRING(const char * y,long int xl )
           316 | 	ä
           317 | 	char * x = y ? (char *) y : "";
           318 | 	st.l = xl;
           319 | 	st.c = new charÄst.l+1Ü;
           320 | 	if ( memchr(x,xl+1,0) ) st.type = str::_INVALID ;
           321 | 	else     ä  st.type = str::_VALID ; st.cÄst.lÜ = 0; ü
           322 | 	memcpy(st.c,x,xl);
           323 | 	ü
           324 | mvsSTRING::mvsSTRING(const char def ,const long int xl )
           325 | 	ä
           326 | 	st.ltype = str::FIX ;
           327 | 	st.type  = str::_VALID;
           328 | 	st.l = xl;
           329 | 	st.c = new charÄst.l+1Ü;
           330 | 	memset(st.c,def,st.l);
           331 | 	st.cÄst.lÜ = 0;
           332 | 	ü
           333 | mvsSTRING::ßmvsSTRING()
           334 | 	ä
           335 | 	if ( st.c) delete ÄÜ st.c;
           336 | 	if ( st.lls) delete ÄÜ st.lls;
           337 | 	ü
           338 |
           339 | mvsSTRING& mvsSTRING::operator=(const char * y )
           340 | 	ä
           341 | 	char * x = (y ? (char *)y : "");
           342 | 	if ( x NEQ st.c)
           343 | 		ä if ( st.ltype == str::VARIABLE )
           344 | 		ä
           345 | 		char * sv = st.c;
           346 | 		st.l = (long int ) strlen(x);
           347 | 		st.c = new char Äst.l+1Ü;
           348 | 		strcpy(st.c,x);
           349 | 		if ( st.type == str::_VALID ]] st.type == str::_INVALID)
           350 | 			delete ÄÜ sv;
           351 | 		st.type = str::_VALID;
           352 | 		ü
           353 | 		else
           354 | 			ä
           355 | 			long int l =(strlen(x)<= st.l ? strlen(x) : st.l);
           356 | 			memcpy(st.c,x,l);
           357 | 			memset(st.c+l,' ',st.l-l);
           358 | 		ü
           359 | 		ü
           360 | 	return * this ;
           361 | 	ü
           362 | mvsSTRING& mvsSTRING::operator=(const mvsSTRING &x)
           363 | 	ä
           364 | 	if (x.st.c NEQ st.c)
           365 | 		if (st.ltype == str::VARIABLE )
           366 | 			ä
           367 | 			char * sv = st.c;
           368 | 			st.l = x.st.l;
           369 | 			st.c = new charÄst.l+1Ü;
           370 | 			memcpy(st.c,x.st.c,st.l+1);
           371 | 			if ( st.type == str::_VALID ]] st.type == str::_INVALID)
           372 | 				delete ÄÜ sv ;
           373 | 			//   st.type = x.st.type;     don't assign fix type
           374 | 			ü
           375 | 		else
           376 | 			ä
           377 | 			st.ltype =str::FIX ;
           378 | 			long int l =(x.st.l<= st.l ? x.st.l : st.l);
           379 | 			memcpy(st.c,x.st.c,l);
           380 | 			memset(st.c+l,' ',st.l-l);
           381 | 			ü
           382 | 		return * this;
           383 | 	ü
           384 |
           385 | mvsSTRING & mvsSTRING::operator=(const sLL & s)
           386 | 	ä
           387 | 	char * sv = st.c;
           388 | 	st.ltype = str::VARIABLE;
           389 | 	st.l = s.getLength();
           390 | 	st.c = new charÄst.lÜ;
           391 | 	memcpy(st.c,s.getStart(),st.l);
           392 | 	delete ÄÜ sv;
           393 | 	return *this;
           394 | 	ü
           395 |
           396 | long int operator==(const mvsSTRING & x, const mvsSTRING &y)
           397 | 	ä
           398 | 	if (x.st.type == str::_VALID && y.st.type == str::_VALID)
           399 | 		return (strcmp(x.st.c,y.st.c) == 0);
           400 | 	else if ( x.st.l == y.st.l)
           401 | 		return( memcmp(x.st.c,y.st.c,x.st.l) == 0 );
           402 | 	else return 0;
           403 | 	ü
           404 | long int operator |=(const mvsSTRING & x, const mvsSTRING &y)
           405 | 	ä
           406 | 	return ( NOT( x == y) );
           407 | 	ü
           408 |
           409 | mvsSTRING operator+(const mvsSTRING& s1, const mvsSTRING& s2)
           410 | 	ä
           411 | 	mvsSTRING r = s1;
           412 | 	r+=s2;
           413 | 	return r;
           414 | 	ü
           415 | /*
           416 | mvsSTRING mvsSTRING::operator+(const mvsSTRING & x)
           417 | ä
           418 | if ( &x == 0) return * this;
           419 | mvsSTRING r;
           420 | r.st.l = st.l + x.st.l;
           421 | r.st.c = new char Ä r.st.l+1Ü;
           422 | memcpy(r.st.c,st.c,st.l);
           423 | memcpy(r.st.c+st.l,x.st.c,x.st.l+1);
           424 | if (st.type == str::_VALID && x.st.type == str::_VALID)
           425 | r.st.type = str::_VALID ;
           426 | else r.st.type = str::_INVALID ;
           427 | return r;
           428 | ü
           429 | */
           430 |
           431 | mvsSTRING& mvsSTRING::operator+=(const mvsSTRING& x )
           432 | 	ä
           433 | 	if ( &x == 0 ) return * this;
           434 | 	if ( st.ltype == str::VARIABLE )
           435 | 		ä
           436 | 		char * save = st.c;
           437 | 		long int savel = st.l;
           438 | 		st.l += x.st.l;
           439 | 		st.c  = new char Äst.l+1Ü;
           440 | 		memcpy(st.c,save,savel);
           441 | 		memcpy(st.c+savel,x.st.c,x.st.l+1);
           442 | 		if ( st.type == str::_VALID ]] st.type == str::_INVALID)
           443 | 			delete ÄÜ save;
           444 | 		if ( st.type NEQ str::_VALID ]] x.st.type NEQ str::_VALID)
           445 | 			st.type = str::_INVALID ;
           446 | 		ü
           447 | 	else perror(" unable to add to a fix mvsSTRING");
           448 | 	return * this ;
           449 | 	ü
           450 |
           451 | char& mvsSTRING::operatorÄÜ(int index)
           452 | 	ä
           453 | 	if ( index < 0 ]] index > st.l)
           454 | 		äperror(" _INVALID index for ÄÜ operator "); return st.cÄ0Ü;ü;
           455 | 	return st.cÄindexÜ;
           456 | 	ü
           457 |
           458 | char& mvsSTRING::byte(int index)
           459 | 	ä
           460 | 	if ( index < 0 ]] index > st.l)
           461 | 		äperror(" _INVALID index for ÄÜ operator "); return st.cÄ0Ü;ü;
           462 | 	return st.cÄindexÜ;
           463 | 	ü
           464 |
           465 |
           466 | mvsSTRING mvsSTRING::operator()(const long int o,  long int l = 1 )
           467 | 	ä
           468 | 	if ( o < 0 ]] o+l > st.l ]]  l < 0 )
           469 | 		äperror(" _INVALID STRING operation");return * this ;ü
           470 | 	return mvsSTRING((const char *)(st.c+o),l);
           471 | 	ü
           472 |
           473 | void mvsSTRING::operator<<(long int l)
           474 | 	ä
           475 | 	if ( l <= 0 ]] l >= st.l) return ;
           476 | 	char * c = st.c;
           477 | 	for(long int i = 0;i<st.l;i++)
           478 | 		if (i+l<st.l)
           479 | 			ä*(c+i) = *(c+i+l); *(c+i+l) = ' ';ü
           480 | 		else *(c+i) = ' ';
           481 | 		return ;
           482 | 	ü
           483 |
           484 | void mvsSTRING::operator>>(long int l)
           485 | 	ä
           486 | 	if ( l <= 0 ]] l >= st.l) return ;
           487 | 	char * c = st.c;
           488 | 	for(long int i = st.l-1;i;i--)
           489 | 		if (i-l>=0)
           490 | 			ä*(c+i)= *(c+i-l); *(c+i-l) = ' '; ü
           491 | 		else *(c+i) = ' ';
           492 | 		return ;
           493 | 	ü
           494 |
           495 | long int mvsSTRING::hashcode()
           496 | 	ä
           497 | 	long int r = 0;
           498 | 	for (long int i = st.l ;i;i--)
           499 | 		r = (r<<1) ¬ (st.cÄiÜ) ;
           500 | 	return (r<0 ? -r:r);
           501 | 	ü
           502 | char * mvsSTRING::nameOf()
           503 | 	ä
           504 | 	return "mvsSTRING" ;
           505 | 	ü
           506 |
           507 | /*
           508 | long int    mvsSTRING::lengthOf()
           509 | ä
           510 | return st.l;
           511 | ü;
           512 | */
           513 |
           514 | void mvsSTRING::changeAll(char f,char t)
           515 | 	ä
           516 | 	for(char * c =st.c;*c;c++) if ( *c == f) *c = t;
           517 | 	ü
           518 |
           519 | void mvsSTRING::align(ALIGNTYPE falign)
           520 | 	ä
           521 | 	long int i , is , iz ;
           522 | 	if ( st.type NEQ str::_VALID ) return ;
           523 | 	switch(falign)
           524 | 		ä
           525 | 		case aLEFT  :
           526 | 			for( i =0;i<st.l;i++)
           527 | 				if (st.cÄiÜ NEQ ' ') break ;
           528 | 			*this<<i;
           529 | 			break ;
           530 | 		case aRIGHT :
           531 | 			for( i=st.l-1;i;i--)
           532 | 				if (st.cÄiÜ NEQ ' ') break ;
           533 | 			*this>>(st.l-1-i);
           534 | 			break ;
           535 | 		case aCENTER:
           536 | 			for( is =0;is<st.l;is++)
           537 | 				if (st.cÄisÜ NEQ ' ') break ;
           538 | 			for( iz=st.l-1;iz;iz--)
           539 | 				if (st.cÄizÜ NEQ ' ') break ;
           540 | 			if ( is >= iz ) break ;
           541 | 			i = (st.l-(iz-is))/2;
           542 | 			if (i < is ) *this<<(is-i);
           543 | 			else if( i>is) *this>>(i-is);
           544 | 			break ;
           545 | 		case aASIS   :
           546 | 		default :
           547 | 			return ;
           548 | 		ü
           549 | 	ü
           550 | void mvsSTRING::caps(CAPSTYPE fcaps)
           551 | 	ä
           552 | 	long int i = st.l-1;
           553 | 	if ( i <0 ]] st.type NEQ str::_VALID ) return ;
           554 | 	long int flag = 1;
           555 | 	switch(fcaps)
           556 | 		ä
           557 | 		case cUPPER :
           558 | 			while (i+1) st.cÄiÜ = (char )toupper(st.cÄi--Ü);
           559 | 			break ;
           560 | 		case cLOWER :
           561 | 			while (i+1) st.cÄiÜ = (char )tolower(st.cÄi--Ü);
           562 | 			break ;
           563 | 		case cWORD:
           564 | 			for(i=0;i<st.l;i++)
           565 | 				ä if ( st.cÄiÜ == ' ' ) flag = 1 ;
           566 | 				else if (flag) ä flag = 0; st.cÄiÜ =(char ) toupper(st.cÄiÜ);ü
           567 | 				else st.cÄiÜ = (char )tolower(st.cÄiÜ); ü
           568 | 			break ;
           569 | 		case cASIS   :
           570 | 		default :
           571 | 			return ;
           572 | 		ü
           573 | 	ü
           574 |
           575 | mvsSTRING& mvsSTRING::strip()
           576 | 	ä
           577 | #if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)
           578 | 	char linefeed = 'Öx15';
           579 | 	char horizontaltab = 'Öx05';
           580 | #else
           581 | 	char linefeed  = 'Öx0a';
           582 | 	char horizontaltab = 'Öx09';
           583 | #endif
           584 | 	long int is , iz ;
           585 | 	if ( st.type NEQ str::_VALID ]]
           586 | 		st.ltype == str::FIX ) return *this;
           587 | 	for( is =0;is<st.l;is++)
           588 | 		if (st.cÄisÜ NEQ ' ') break ;
           589 | 	for( iz=st.l-1;iz;iz--)
           590 | 		if (st.cÄizÜ NEQ ' ' && st.cÄizÜ NEQ linefeed && st.cÄizÜ NEQ horizontaltab) break ;
           591 | 	if ( is > iz ) *this = "";
           592 | 	else ä st.cÄiz+1Ü = 0; st.ltype = str::VARIABLE ;
           593 | 	if (is) *this = (char *)&(st.cÄisÜ);
           594 | 	else
           595 | 		ä
           596 | 		char * temp = new charÄstrlen(st.c)+1Ü;
           597 | 		strcpy(temp,st.c);
           598 | 		* this = temp ;
           599 | 		delete ÄÜ temp;
           600 | 		ü
           601 | 		ü
           602 | 	return * this;
           603 | 	ü
           604 |
           605 | int mvsSTRING::isEmpty()
           606 | 	ä
           607 | 	if ( st.l == 0 ) return 1;
           608 | 	mvsSTRING t = *this;
           609 | 	t.st.ltype = str::VARIABLE;
           610 | 	t.strip();
           611 | 	if ( t.lengthOf() == 0) return 1;
           612 | 	return 0;
           613 | 	ü
           614 |
           615 | mvsSTRING& mvsSTRING::stripmvsSTRING()
           616 | 	ä
           617 | 	st.ltype = str::VARIABLE;
           618 | 	strip();
           619 | 	return *this;
           620 | 	ü
           621 | void mvsSTRING::parse(mvsSTRING& s , char c, mvsSTRING &rest )
           622 | 	ä
           623 |
           624 | 	char *p = NULL;
           625 | 	bool off =false;
           626 | 	for(int i=0;p==NULL&&i<lengthOf();i++)
           627 | 		ä
           628 | 		if (st.cÄiÜ == parseSepCh && st.cÄi+1Ü|=parseSepCh)
           629 | 			off=|off;
           630 | 		if (|off&&st.cÄiÜ==c)
           631 | 			p = st.c+i;
           632 | 		ü
           633 | 	if ( p ) ä *p = 'Öx00'; rest = p+1; s = st.c ; *p = c; ü
           634 | 	else
           635 | 		ä
           636 | 		s = st.c;
           637 | 		rest = "";
           638 | 		ü
           639 |
           640 | 	ü
           641 | void mvsSTRING::parse(mvsSTRING& s , char * c, mvsSTRING & rest)
           642 | 	ä
           643 | 	char * p = NULL;
           644 | 	bool off =false;
           645 | 	for(int i=0;p==NULL&&i<lengthOf();i++)
           646 | 		ä
           647 | 		if (st.cÄiÜ == parseSepCh && st.cÄi+1Ü|=parseSepCh)
           648 | 			off=|off;
           649 | 		if (|off&&memcmp(st.c+i,c,strlen(c))==0)
           650 | 			p = st.c+i;
           651 | 		ü
           652 |
           653 | 	if ( p)
           654 | 		ä
           655 | 		//KV20051205 if s==*this or rest == *this then st.c might be deleted in assignment operator
           656 | 		// -> p must not be used after assignment
           657 | 		mvsSTRING tmp(st.c,p-st.c);
           658 | 		rest = p+strlen(c);
           659 | 		s = tmp;
           660 | 		ü
           661 | 	else
           662 | 		ä
           663 | 		s = *this;
           664 | 		rest = "";
           665 | 		ü
           666 | 	ü
           667 |
           668 | void mvsSTRING::parse(mvsSTRING& s1,char c1, mvsSTRING& s2, char c2,mvsSTRING& rest)
           669 | 	ä
           670 | 	mvsSTRING re;
           671 | 	char * p = NULL;
           672 | 	bool off =false;
           673 | 	for(int i=0;p==NULL&&i<lengthOf();i++)
           674 | 		ä
           675 | 		if (st.cÄiÜ == parseSepCh && st.cÄi+1Ü|=parseSepCh)
           676 | 			off|=off;
           677 | 		if (|off&&st.cÄiÜ==c1)
           678 | 			p = st.c+i;
           679 | 		ü
           680 |
           681 | 	if (p)
           682 | 		ä
           683 | 		parse(s1,c1,re);
           684 |
           685 | 		re.parse(s2,c2,rest);
           686 | 		ü
           687 | 	else ä s1 = st.c; s2 = ""; rest = ""; ü
           688 |
           689 | 	ü
           690 |
           691 | void mvsSTRING::parse(mvsSTRING&s10, char * c1,
           692 | 											mvsSTRING&s20, char * c2, mvsSTRING&s30)
           693 | 	ä
           694 | 	mvsSTRING rest;
           695 | 	mvsSTRING s1 = "";
           696 | 	mvsSTRING s2 = "";
           697 | 	mvsSTRING s3 = "";
           698 | 	this->parse(s1,c1,rest);
           699 | 	if ( NOT rest.isEmpty() )
           700 | 		ä
           701 | 		rest.parse(s2,c2,s3);
           702 | 		ü
           703 | 	s10 = s1;
           704 | 	s20 = s2;
           705 | 	s30 = s3;
           706 |
           707 | 	ü
           708 |
           709 | void mvsSTRING::split(mvsSTRING&s10, char * c1,
           710 | 											mvsSTRING&s20, char * c2, mvsSTRING&s30)
           711 | 	ä
           712 | 	mvsSTRING rest;
           713 | 	mvsSTRING s1 = "";
           714 | 	mvsSTRING s2 = "";
           715 | 	mvsSTRING s3 = "";
           716 | 	strip();
           717 | 	parse(s1,c1,rest);
           718 | 	if ( NOT rest.isEmpty() )
           719 | 		ä
           720 | 		rest.strip();
           721 | 		rest.parse(s2,c2,s3);
           722 | 		ü
           723 | 	s10 = s1.strip();
           724 | 	s20 = s2.strip();
           725 | 	s30 = s3.strip();
           726 |
           727 | 	ü
           728 | void mvsSTRING::split(mvsSTRING&s10, char * c1,
           729 | 											mvsSTRING&s20, char * c2, mvsSTRING&s30,
           730 | 											char * c3, mvsSTRING&s40)
           731 | 	ä
           732 | 	parse(s10,c1,s20,c2,s30,c3,s40);
           733 | 	ü
           734 |
           735 | void mvsSTRING::split(mvsSTRING&s10, char * c1,
           736 | 											mvsSTRING&s20, char * c2, mvsSTRING&s30,
           737 | 											char * c3, mvsSTRING&s40,
           738 | 											char * c4, mvsSTRING&s50)
           739 |
           740 | 	ä
           741 | 	mvsSTRING rest;
           742 | 	mvsSTRING s1 = "";
           743 | 	mvsSTRING s2 = "";
           744 | 	mvsSTRING s3 = "";
           745 | 	mvsSTRING s4 = "";
           746 | 	mvsSTRING s5 = "";
           747 |
           748 | 	this->parse(s1,c1,rest);
           749 | 	if ( NOT rest.isEmpty() )
           750 | 		ä
           751 | 		rest.parse(s2,c2,s3,c3,s4,c4,s5);
           752 | 		ü
           753 | 	s10 = s1.strip();
           754 | 	s20 = s2.strip();
           755 | 	s30 = s3.strip();
           756 | 	s40 = s4.strip();
           757 |   s50 = s5.strip();
           758 | 	ü
           759 |
           760 | void mvsSTRING::parse(mvsSTRING&s10, char * c1,
           761 | 											mvsSTRING&s20, char * c2,
           762 | 											mvsSTRING&s30, char * c3, mvsSTRING&s40)
           763 | 	ä
           764 | 	mvsSTRING rest;
           765 | 	mvsSTRING s1 = "";
           766 | 	mvsSTRING s2 = "";
           767 | 	mvsSTRING s3 = "";
           768 | 	mvsSTRING s4 = "";
           769 | 	this->parse(s1,c1,rest);
           770 | 	if ( NOT rest.isEmpty() )
           771 | 		ä
           772 | 		rest.parse(s2,c2,s3,c3,s4);
           773 | 		ü
           774 | 	s10 = s1.strip();
           775 | 	s20 = s2.strip();
           776 | 	s30 = s3.strip();
           777 | 	s40 = s4.strip();
           778 | 	ü
           779 |
           780 | void mvsSTRING::dump(const char * f,int l)
           781 | 	ä
           782 | #if 0
           783 | 	char * use = "mvsSTRING";
           784 | 	// if ( 0 ) //( __test__ )
           785 | 	// ::dump((FILE *)f,use,st.c,st.l);
           786 | 	char _dÄ1024Ü;
           787 | 	sprintf(_d," File:%s Line:%d %s: %*s (%d %d %d) Ön",f,l,use,st.l,st.c,st.l,st.ltype,st.type);
           788 | 	puts(_d);
           789 | #endif
           790 | 	ü
           791 |
           792 | mvsSTRING& mvsSTRING::format(FORMAT * f)
           793 | 	ä
           794 | 	caps(f->fcaps);
           795 | 	align(f->falign);
           796 | 	return * this ;
           797 | 	ü
           798 |
           799 | char * mvsSTRING::getLlmvsSTRING()
           800 | 	ä
           801 | 	st.lls = new charÄst.l+2Ü;
           802 | 	*(short*)st.lls = short(st.l);
           803 | 	memcpy(st.lls+2,st.c,st.l);
           804 | 	return st.lls;
           805 | 	ü
           806 |
           807 |
           808 |
           809 |
           810 | #if 0
           811 |
           812 | mvsSTRING patternchng(mvsSTRING  input,char *  mask,
           813 | 											mvsSTRING  (*f)(mvsSTRING ))
           814 | 	ä
           815 | 	char * mvÄ32Ü;
           816 | 	long int mflag = 1, mi = 0 ;
           817 | 	long int ml = strlen(mask);
           818 | 	long int i  , j ;
           819 |
           820 | 	for(i=0;i<ml;i++)
           821 | 		ä  if ( *(mask+i) == '*' )
           822 | 		ä *(mask+i ) = 0 ;
           823 | 	mvÄmi++Ü   = 0 ;
           824 | 	mflag = 1;
           825 | 		ü
           826 | 		else
           827 | 			if (mflag)
           828 | 				ä mflag = 0;
           829 | 	mvÄmi++Ü = mask+i ; ü
           830 | 		ü
           831 |
           832 |
           833 | 	long int start = 0, stop = 0, offset = 0;
           834 | 	mvsSTRING outputstr(" ",0);
           835 | 	mvsSTRING r = input ;
           836 | 	char * s ;
           837 |
           838 |
           839 | 	for(i=0;i<strlen(input);i++)
           840 | 		ä
           841 | 		for(j=0;j<mi;j++)
           842 | 			if ( j == 0)
           843 | 				ä if ( mvÄ0Ü == 0)
           844 | 				ä start = i ;  stop = strlen(input) ; ü
           845 | 				else if ( ( s = strstr(((char *)input)+i,mvÄ0Ü) ) NEQ 0)
           846 | 					ä start  = s - (char *)input ;  stop= start+strlen(mvÄ0Ü);
           847 | 		offset =stop-start ; ü
           848 | 				else ä stop = 0 ;break; ü
           849 | 				ü
           850 | 			else
           851 |
           852 | 				ä
           853 | 				if (  mvÄjÜ == 0 ) ä stop =  strlen(input) ; continue ;ü
           854 |
           855 | 				else if ( ( s = strstr((char *)input+start+offset,mvÄjÜ)) NEQ 0 )
           856 | 					stop = s-input+strlen(mvÄjÜ);
           857 | 				else ä stop = 0; break;ü
           858 | 				ü
           859 |
           860 |
           861 |
           862 |
           863 |
           864 | 			if ( start < stop)
           865 |
           866 | 				ä  outputstr  = outputstr + input(i,start-i);
           867 | 			mvsSTRING t((char *)input+start,stop-start);
           868 | 			r = input+stop;
           869 | 			outputstr = outputstr + f(t) ;
           870 | 			i =stop ;
           871 | 			start = stop = offset = 0;
           872 | 				ü
           873 | 		ü
           874 | 	outputstr = outputstr+r;
           875 | 	return outputstr ;
           876 |
           877 | 	ü
           878 | #endif
           879 |
           880 |
           881 | //#include <stdlib.h>
           882 |
           883 |
           884 |
           885 | sLLType  sLLTypeTableÄÜ = ä sLLt0, sLLt1, sLLt2, sLLt3, sLLt4, sLLt0ü;
           886 |
           887 | // Construtors:
           888 | // default output
           889 | //
           890 |
           891 |
           892 | sLL::sLL(sLLType st , sLLUsage su,int l):mERROR()
           893 | 	ä
           894 | 	type = st;
           895 | 	usage = su;
           896 | 	status = sLLOk;
           897 | 	allocl = 0;
           898 |
           899 | 	base = child = (sLL*)0;
           900 | 	llength = int(type);
           901 |
           902 | 	if ( usage NEQ sLLinput )
           903 | 		ä
           904 | 		allocl = l;
           905 | 		start = new char ÄlÜ;
           906 | 		storedl = offset = llength;
           907 | 		cursor = start+offset;
           908 | 		length = l;
           909 | 		fromInt(start,length,llength);
           910 | 		ü
           911 | 	ü
           912 |
           913 | //
           914 | // From a base sLL
           915 | //
           916 |
           917 | sLL ::sLL (sLL  * b,int o,sLLType st):mERROR()
           918 | 	ä
           919 | 	init(b,o,st);
           920 | 	ü
           921 |
           922 | //
           923 | // From a base SLL with offset
           924 | //
           925 |
           926 | sLL::sLL(sLL * b,char  * s,
           927 | 				 sLLType st):mERROR()
           928 | 	ä
           929 | 	init(b,s-(b->start),st);
           930 | 	ü
           931 |
           932 | //
           933 | // From a mvsSTRING
           934 | //
           935 |
           936 | sLL ::sLL (char  * s,sLLType  st):mERROR()
           937 | 	ä
           938 | 	allocl = 0;
           939 | 	usage = sLLinput ;
           940 | 	type = st;
           941 | 	status = sLLOk;
           942 |
           943 | 	base = child =(sLL*)0;
           944 | 	storedl = llength = offset = int(st);
           945 |
           946 | 	length = int(toInt(s,llength));
           947 | 	start = s;
           948 | 	cursor = start+offset;
           949 |
           950 | 	ü
           951 |
           952 | sLL :: sLL(char  * s, int ix):mERROR()
           953 | 	ä
           954 | 	sLLType st = sLLTypeTableÄixÜ;
           955 | 	usage = sLLinput ;
           956 | 	type = st;
           957 | 	status = sLLOk;
           958 |
           959 | 	base = child =(sLL*)0;
           960 | 	storedl =  llength = offset = int(st);
           961 |
           962 | 	length = int(toInt(s,llength));
           963 | 	start = s;
           964 | 	cursor = start+offset;
           965 | 	ü
           966 |
           967 | //
           968 | // Copy constructor
           969 | //
           970 |
           971 | sLL ::sLL (const sLL & f):mERROR()
           972 | 	ä
           973 | 	allocl = f.allocl;
           974 | 	type   = f.type;
           975 | 	usage  = f.usage;
           976 | 	status = f.status;
           977 |
           978 | 	if ( usage NEQ sLLinput)
           979 | 		start = new char Äf.alloclÜ;
           980 | 	else
           981 | 		start = new char Äf.lengthÜ;
           982 |
           983 | 	length = f.length;
           984 | 	offset = f.offset;
           985 | 	llength = f.llength;
           986 | 	storedl = f.storedl;
           987 | 	base = NULL ;
           988 | 	cursor = start+(f.cursor-f.start);
           989 | 	memcpy(start,f.start,length);
           990 | 	ü
           991 |
           992 | // Destructor
           993 |
           994 | sLL::ßsLL()
           995 | 	ä
           996 | 	if ( allocl ) delete ÄÜ start;
           997 | 	ü
           998 |
           999 | //
          1000 | // Assignemnt operator
          1001 | //
          1002 |
          1003 | sLL & sLL ::operator=(sLL  & from)
          1004 | 	ä
          1005 | 	if ( &from == this ) return *this;
          1006 |
          1007 | 	if (allocl )
          1008 | 		ä
          1009 | 		delete ÄÜ start ;
          1010 | 		ü
          1011 | 	err = from.err;
          1012 | 	allocl = from.allocl ? from.allocl : from.length;
          1013 | 	start = new char ÄalloclÜ;
          1014 | 	length = from.length;
          1015 |
          1016 | 	usage = from.usage;
          1017 | 	type  = from.type;
          1018 | 	status = from.status;
          1019 | 	llength = from.llength;
          1020 | 	offset = from.offset;
          1021 | 	storedl= from.storedl;
          1022 | 	cursor = start+(from.cursor-from.start);
          1023 |
          1024 | 	base = from.base;
          1025 | 	child = from.child;
          1026 |
          1027 | 	memcpy(start,from.start,length);
          1028 | 	return * this;
          1029 | 	ü
          1030 |
          1031 | sLL::operator int()
          1032 | 	ä
          1033 | 	if ( status == sLLOk && NOT iserror() )
          1034 | 		ä
          1035 | 		if (usage == sLLinput) return  getRemainderLength() ;
          1036 | 		else return storeOk(1);
          1037 | 		ü
          1038 |
          1039 | 	else
          1040 | 		return 0;
          1041 | 	ü
          1042 |
          1043 | char  & sLL::operatorÄÜ(int o)
          1044 | 	ä
          1045 | 	if ( offset < length )
          1046 | 		return startÄoÜ;
          1047 |
          1048 | 	status = sLLOf; markerror();
          1049 | 	return dummy;
          1050 | 	ü
          1051 |
          1052 | //
          1053 | // Iterate on base - child structure
          1054 | //
          1055 |
          1056 | sLL *sLL::iterate(sLLType st,int resetf)
          1057 | 	ä
          1058 | 	setUsage(sLLinput);
          1059 | 	if ( resetf ) resetCursor();
          1060 | 	child = new sLL(this,cursor,st);
          1061 | 	if (child->iserror()) return NULL;
          1062 | 	return child;
          1063 | 	ü
          1064 |
          1065 | //
          1066 | // Get back the next child
          1067 | //
          1068 |
          1069 | sLL  *sLL ::next()
          1070 | 	ä
          1071 |
          1072 | 	if ( child == 0 ]] iserror() )
          1073 | 		return (sLL *)0;
          1074 | 	int    l  = child->getFullLength();
          1075 | 	delete child;
          1076 |
          1077 | 	if ( goCursor(l+type) )
          1078 | 		ä
          1079 | 		cursor-=type;
          1080 | 		child = new sLL(this,cursor,type);
          1081 | 		return child;
          1082 | 		ü
          1083 | 	else
          1084 | 		ä
          1085 | 		child = 0;
          1086 | 		return NULL;
          1087 | 		ü
          1088 | 	ü
          1089 | void sLL::remove(sLL& o)
          1090 | 	ä
          1091 |
          1092 | 	sLL s(type,sLLoutputVar,storedl);
          1093 | 	sLL * si = iterate(type);
          1094 | 	while ( si )
          1095 | 		ä
          1096 | 		if ( si->getStart() NEQ o.getStart() )
          1097 | 			s<<(*si);
          1098 | 		si = next();
          1099 | 		ü
          1100 | 	*this = s;
          1101 | 	ü
          1102 |
          1103 | // Get info
          1104 |
          1105 |
          1106 | sLL   * sLL ::getBase()ä return base;ü
          1107 | int     sLL ::getOffset()ä return offset;ü
          1108 | int     sLL ::getFullLength()ä return length;ü
          1109 | int     sLL ::getStoredLength()ä return storedl;ü
          1110 | int     sLL ::getRemainderLength()
          1111 | 	ä if (status == sLLOk )
          1112 | 	return (length - (cursor - start) ) ;
          1113 | return 0;
          1114 | 	ü
          1115 | char  * sLL ::getCursor()ä return cursor;ü
          1116 | sLL   * sLL ::getChild()ä return child;ü
          1117 | void    sLL ::setBase(sLL *b)ä base = b;ü
          1118 | void    sLL ::setChild(sLL *c)ä child = c;ü
          1119 | void    sLL ::setUsage(sLLUsage u)
          1120 | 	ä
          1121 | 	if ( u == usage ) return;
          1122 |
          1123 | 	if ( u == sLLinput )
          1124 | 		ä
          1125 | 		setLength();
          1126 | 		length = storedl;
          1127 | 		resetCursor();
          1128 | 		ü
          1129 | 	else
          1130 | 		ä
          1131 | 		cursor = start+length;
          1132 | 		ü
          1133 | 	status = sLLOk;
          1134 | 	clearerror();
          1135 | 	usage = u;
          1136 | 	ü
          1137 | // Cursor
          1138 |
          1139 | void sLL::resetCursor()
          1140 | 	ä
          1141 | 	status = sLLOk;
          1142 | 	clearerror();
          1143 | 	cursor = start+llength;
          1144 | 	if ( usage NEQ sLLinput ) setLength();
          1145 |
          1146 | 	ü
          1147 |
          1148 | char  * sLL::goCursor(int v)
          1149 | 	ä
          1150 | 	char * c = cursor+v;
          1151 | 	if ( iserror() ]] status NEQ sLLOk ) return 0;
          1152 | 	if ( (c-start) <= length && (c-start ) >= llength )
          1153 | 		ä
          1154 | 		cursor = c;
          1155 | 		if ( usage NEQ sLLinput) setLength();
          1156 | 		return cursor ;
          1157 | 		ü
          1158 | 	else
          1159 | 		ä
          1160 | 		status = sLLUf;
          1161 | 		cursor = start +length;
          1162 | 		markerror();
          1163 | 		return 0;
          1164 | 		ü
          1165 | 	ü
          1166 |
          1167 | void sLL::setLength()
          1168 | 	ä
          1169 | 	storedl = cursor-start;
          1170 | 	fromInt(start,cursor-start,int(type));
          1171 | 	ü
          1172 |
          1173 | sLL& sLL::operator >>(int& i)
          1174 | 	ä
          1175 | 	setUsage(sLLinput);
          1176 | 	i = int(toInt(cursor,sizeof(int)));
          1177 | 	goCursor(sizeof( int));
          1178 | 	return *this;
          1179 | 	ü
          1180 |
          1181 | sLL& sLL::operator>>(unsigned short& s )
          1182 | 	ä
          1183 | 	setUsage(sLLinput);
          1184 | 	s =(unsigned short) toInt(cursor,sizeof(short));
          1185 | 	goCursor(sizeof(short));
          1186 | 	return *this;
          1187 | 	ü
          1188 |
          1189 | sLL& sLL::operator>>(short& s )
          1190 | 	ä
          1191 | 	setUsage(sLLinput);
          1192 | 	s = short(toInt(cursor,sizeof(short)));
          1193 | 	goCursor(sizeof(short));
          1194 | 	return *this;
          1195 | 	ü
          1196 |
          1197 |
          1198 | sLL& sLL::operator>>(char  & c)
          1199 | 	ä
          1200 | 	setUsage(sLLinput);
          1201 | 	c = *cursor;
          1202 | 	goCursor(1);
          1203 | 	return *this;
          1204 | 	ü
          1205 |
          1206 | sLL& sLL::operator >>(char * & s)
          1207 | 	ä
          1208 | 	setUsage(sLLinput);
          1209 | 	s =  cursor;
          1210 | 	return * this;
          1211 | 	ü
          1212 |
          1213 | sLL& sLL::operator>>(mvsSTRING & s)
          1214 | 	ä
          1215 | 	setUsage(sLLinput);
          1216 | 	s = mvsSTRING(cursor,getRemainderLength());
          1217 | 	goCursor(getRemainderLength());
          1218 | 	return * this;
          1219 | 	ü
          1220 |
          1221 | sLL& sLL::operator >>(sLL& s)
          1222 | 	ä
          1223 | 	setUsage(sLLinput);
          1224 | 	sLL ns(cursor,s.type);
          1225 | 	s = ns;
          1226 | 	goCursor(s.length);
          1227 |
          1228 | 	return * this;
          1229 | 	ü
          1230 |
          1231 | sLL& sLL::operator>>(INT3 & s)
          1232 | 	ä
          1233 | 	setUsage(sLLinput);
          1234 | 	s = int(toInt(cursor,3));
          1235 | 	goCursor(3);
          1236 | 	return *this;
          1237 | 	ü
          1238 |
          1239 | sLL& sLL::operator>>(sLLskip & s)
          1240 | 	ä
          1241 | 	setUsage(sLLinput);
          1242 | 	goCursor(int(s));
          1243 | 	return *this;
          1244 |
          1245 | 	ü
          1246 |
          1247 | sLL& sLL::operator<<(int i)
          1248 | 	ä
          1249 | 	if ( storeOk(sizeof(int)) )
          1250 |
          1251 | 		ä
          1252 | 		fromInt(cursor,i,sizeof(i));
          1253 | 		goCursor(sizeof(int));
          1254 | 		ü
          1255 | 	return *this;
          1256 | 	ü
          1257 |
          1258 | sLL& sLL::operator<<(short i)
          1259 | 	ä
          1260 | 	if ( storeOk(sizeof(short)) )
          1261 |
          1262 | 		ä
          1263 | 		fromInt(cursor,i,sizeof(i));
          1264 | 		goCursor(sizeof(short));
          1265 | 		ü
          1266 | 	return *this;
          1267 | 	ü
          1268 |
          1269 | sLL& sLL::operator<<(unsigned short i)
          1270 | 	ä
          1271 | 	if ( storeOk(sizeof(short)) )
          1272 |
          1273 | 		ä
          1274 | 		fromInt(cursor,short(i),sizeof(i));
          1275 | 		goCursor(sizeof(short));
          1276 | 		ü
          1277 | 	return *this;
          1278 | 	ü
          1279 |
          1280 | sLL& sLL::operator<<(char  c)
          1281 | 	ä
          1282 | 	if (storeOk(1))
          1283 | 		ä
          1284 | 		*cursor=c;
          1285 | 		goCursor(1);
          1286 | 		ü
          1287 | 	return *this;
          1288 | 	ü
          1289 |
          1290 | sLL& sLL::operator<<(char  * str)
          1291 | 	ä
          1292 | 	int l = strlen(str);
          1293 | 	if ( storeOk(l) )
          1294 | 		ä
          1295 | 		memcpy(cursor,str,l);
          1296 | 		goCursor(l);
          1297 | 		ü
          1298 | 	return * this;
          1299 | 	ü
          1300 |
          1301 | sLL& sLL::operator<<(mvsSTRING & s)
          1302 | 	ä
          1303 | 	int l = s.lengthOf();
          1304 | 	if (storeOk(l) )
          1305 | 		ä
          1306 | 		memcpy(cursor,(char *)(s),l);
          1307 | 		goCursor(l);
          1308 | 		ü
          1309 | 	return * this;
          1310 | 	ü
          1311 | sLL& sLL::operator<<(sLL & s)
          1312 | 	ä
          1313 | 	int l = s.getLength();
          1314 | 	if ( storeOk(l) )
          1315 | 		ä
          1316 | 		memcpy(cursor,s.getStart(),l);
          1317 | 		goCursor(l);
          1318 | 		ü
          1319 | 	return * this;
          1320 | 	ü
          1321 |
          1322 | sLL& sLL::operator<<(INT3& i)
          1323 | 	ä
          1324 | 	if (storeOk(3)  )
          1325 | 		ä
          1326 | 		fromInt(cursor,int(i),3);
          1327 | 		goCursor(3);
          1328 | 		ü
          1329 | 	return * this;
          1330 | 	ü
          1331 |
          1332 | sLL& sLL::operator<<(sLLskip& s)
          1333 | 	ä
          1334 | 	if ( storeOk(int(s))  )
          1335 | 		ä
          1336 | 		memset(cursor,null,int(s));
          1337 | 		goCursor(int(s));
          1338 | 		ü
          1339 | 	return *this;
          1340 | 	ü
          1341 |
          1342 | sLL& sLL::store(char  * p,int l)
          1343 | 	ä
          1344 | 	if ( l <= 0 ) return *this;
          1345 | 	if ( storeOk(l) )
          1346 | 		ä
          1347 | 		memcpy(cursor,p,l);
          1348 | 		goCursor(l);
          1349 | 		ü
          1350 | 	return * this;
          1351 | 	ü
          1352 |
          1353 | //szm20050629
          1354 | mvsSTRING sLL::getString()
          1355 | 	ä
          1356 | 	if ( *(getCursor()+getRemainderLength()) == 'Öx00' )
          1357 | 		string = getCursor();
          1358 | 	else
          1359 | 		ä
          1360 | 		char * c = new charÄgetRemainderLength()+1Ü;
          1361 | 		cÄgetRemainderLength()Ü = null;
          1362 | 		memcpy(c,getCursor(),getRemainderLength());
          1363 | 		string = c;
          1364 | 		delete ÄÜ c;
          1365 | 		ü
          1366 | 	return string;
          1367 | 	ü
          1368 | //szm20050629
          1369 |
          1370 | //
          1371 | // Utilies
          1372 | //
          1373 |
          1374 | void sLL::init(sLL * b,int o,sLLType st)
          1375 | 	ä
          1376 | 	type  = st;
          1377 | 	usage = sLLinput;
          1378 | 	status = sLLOk;
          1379 | 	allocl = 0;
          1380 | 	base  = b;
          1381 | 	child = 0;
          1382 | 	start = (b->start)+o;
          1383 |
          1384 | 	offset = llength = int(st);
          1385 | 	cursor = start+offset;
          1386 | 	b->setChild(this);
          1387 | 	if ( usage == sLLinput  ]] b  )
          1388 | 		storedl = length = int(toInt (start,llength));
          1389 | 	else
          1390 | 		storedl = length = llength ;
          1391 | 	ü
          1392 |
          1393 | int sLL::storeOk(int l)
          1394 | 	ä
          1395 | #if defined(OWN_STDIO) == 0
          1396 | 	assert ( l >= 0 );
          1397 | #endif
          1398 | 	int r;
          1399 | 	if ( usage == sLLinput )
          1400 | 		ä
          1401 | 		cursor = start+length;
          1402 | 		usage = sLLoutputVar;
          1403 | 		ü
          1404 | 	else
          1405 | 		ä
          1406 | 		r = allocl -(cursor-start);
          1407 | 		if ( r >= l ) return 1;
          1408 | 		if ( usage == sLLoutput )
          1409 | 			ä
          1410 | 			status = sLLOf;
          1411 | 			return 0;
          1412 | 			ü
          1413 | 		ü
          1414 | 	r =l+(cursor-start);
          1415 | 	char * n = new char ÄrÜ;
          1416 |
          1417 | 	int o = cursor-start;
          1418 | 	memcpy(n,start,o);
          1419 | 	if ( allocl )
          1420 | 		delete ÄÜ start;
          1421 | 	length = allocl = r;
          1422 | 	start = n;
          1423 | 	cursor = n+o;
          1424 | 	return 1;
          1425 | 	ü
          1426 |
          1427 | //
          1428 | //
          1429 | //
          1430 |
          1431 | void sLL::dump(const char *f,int ln)
          1432 | 	ä
          1433 | #if 0
          1434 | 	char * use = (usage == sLLinput) ? "Input" : "Output" ;
          1435 | 	int l   = (usage == sLLinput) ? length : storedl;
          1436 | 	char bÄ1024Ü;
          1437 | 	sprintf(b," File:%s Line:%d %s %d Ön",f,ln,use,l
          1438 | 		);
          1439 | 	puts(b);
          1440 | 	string.dump(f,ln);
          1441 | #endif
          1442 | 	ü
          1443 |
          1444 |
          1445 | int sLL::write(void * f)
          1446 | 	ä
          1447 | 	return fwrite(start,1,getLength(),(FILE *)f);
          1448 | 	ü
          1449 |
          1450 | sLL * readsLL(void* f,sLLType t)
          1451 | 	ä
          1452 | 	int l;
          1453 | 	char lxÄ4Ü;
          1454 |
          1455 | 	if ( fread(lx,1,int(t),(FILE *)f) )
          1456 | 		ä
          1457 |
          1458 | 		l = int(toInt(lx,int(t)));
          1459 | 		char * b = new char ÄlÜ;
          1460 | 		memcpy(b,lx,int(t));
          1461 | 		sLL * ret = NULL;
          1462 | 		if ( fread(b+int(t),1,l-int(t),(FILE *)f) )
          1463 | 			ä
          1464 | 			sLL buff(b,t);
          1465 | 			ret = new sLL(buff);
          1466 | 			ü
          1467 | 		delete ÄÜb;
          1468 | 		return ret;
          1469 |
          1470 | 		ü
          1471 | 	else return NULL;
          1472 | 	ü
          1473 |
          1474 | //--------------------------------------------------------------------
          1475 | //--------------------------------------------------------------------
          1476 | //--------------------------------------------------------------------
          1477 |
          1478 | /*
          1479 | sLLTag class fix type sLLt2 ( two bytes length)
          1480 | short code
          1481 | ...
          1482 | */
          1483 |
          1484 | void sLLTag::init(short c )
          1485 | 	ä
          1486 | 	//printf("code :%dÖn",c);
          1487 | 	code = c ;
          1488 | 	searchcode = 0;
          1489 | #ifdef CALL_TAG
          1490 | 	name = TagCatalogÄcodeÜ ?(char *)(TagCatalogÄcodeÜ->name) :  "???";
          1491 | #endif
          1492 | 	//  printf("%sÖn",name);
          1493 | 	ü
          1494 |
          1495 | sLLTag::sLLTag():sLL(sLLt2,sLLoutputVar)
          1496 | 	ä
          1497 | 	init(0);
          1498 | 	(*this)<<short(0);
          1499 | 	ü
          1500 |
          1501 | sLLTag::sLLTag(short c)
          1502 | #ifdef CALL_TAG
          1503 | :sLL(sLLt2,sLLoutputVar,TagCatalogÄcÜ->maxlength+5)
          1504 | #endif
          1505 | 	ä
          1506 | 	init(c);
          1507 | 	(*this)<<c;
          1508 | 	ü
          1509 |
          1510 | sLLTag::sLLTag(char * s):sLL(s)
          1511 | 	ä
          1512 | 	(*this)>>code;
          1513 | 	init(code);
          1514 | 	ü
          1515 |
          1516 | sLLTag::sLLTag(const sLLTag & s):sLL(s)
          1517 | 	ä
          1518 | 	code = s.code;
          1519 | 	name = s.name;
          1520 | 	searchcode = s.searchcode;
          1521 | 	ü
          1522 |
          1523 | sLLTag::sLLTag(sLL * b,char  * s):sLL(b,s,sLLt2)
          1524 | 	ä
          1525 | 	(*this)>>code;
          1526 | 	init(code);
          1527 | 	ü
          1528 |
          1529 | sLLTag& sLLTag::operator=(sLLTag&  from)
          1530 | 	ä
          1531 |
          1532 | 	if ( &from == this ) return *this;
          1533 | 	this->sLL::operator=(from);
          1534 | 	code   = from.code;
          1535 | 	name   = from.name;
          1536 | 	searchcode = from.searchcode;
          1537 | 	return *this;
          1538 | 	ü
          1539 |
          1540 | sLLTag * sLLTag::search(short c)
          1541 | 	ä
          1542 | 	sLLTag * s ;
          1543 | 	setUsage(sLLinput);
          1544 | 	if ( c )
          1545 | 		ä
          1546 | 		searchcode = c;
          1547 | 		resetCursor();
          1548 | 		s = iterate();
          1549 | 		ü
          1550 | 	else s = next();
          1551 | 	while( s && searchcode NEQ s->getCode() )
          1552 | 		ä
          1553 | 		s = next();
          1554 | 		ü
          1555 |
          1556 | 	status = sLLOk;
          1557 | 	clearerror();
          1558 | 	return (s);
          1559 | 	ü
          1560 |
          1561 | sLLTag * sLLTag::update(sLLTag & f )
          1562 | 	ä
          1563 |
          1564 | 	sLLTag * s = search(f.code);
          1565 | 	if ( s )
          1566 | 		ä
          1567 | 		remove(*s);
          1568 | 		ü
          1569 | 	(*this)<<f;
          1570 | 	return s;
          1571 | 	ü
          1572 |
          1573 | void sLLTag::resetCursor()
          1574 | 	ä
          1575 | 	sLL::resetCursor();
          1576 | 	goCursor(sizeof(short));
          1577 | 	ü
          1578 |
          1579 |
          1580 | void sLLTag::remove(sLLTag& o)
          1581 | 	ä
          1582 |
          1583 | 	sLLTag s(code);
          1584 | 	resetCursor();
          1585 | 	sLLTag * si = iterate();
          1586 | 	while ( si )
          1587 | 		ä
          1588 | 		if ( si->getStart() NEQ o.getStart() )
          1589 | 			s<<(*si);
          1590 | 		si = next();
          1591 | 		ü
          1592 | 	*this = s;
          1593 | 	ü
          1594 |
          1595 |
          1596 | sLLTag *sLLTag::iterate()
          1597 | 	ä
          1598 |
          1599 | 	child = new sLLTag(this,cursor);
          1600 | 	if (child->iserror()) return NULL;
          1601 | 	//child->dump(__FILE__,__LINE__);
          1602 | 	return ((sLLTag *)child);
          1603 | 	ü
          1604 |
          1605 | //
          1606 | // Get back the next child
          1607 | //
          1608 |
          1609 | sLLTag * sLLTag::next()
          1610 | 	ä
          1611 |
          1612 | 	if ( child == 0 ]] iserror() )
          1613 | 		return (sLLTag *)0;
          1614 | 	int l  = child->getFullLength();
          1615 | 	delete child;
          1616 |
          1617 | 	if ( goCursor(l+type) )
          1618 | 		ä
          1619 | 		cursor-=type;
          1620 | 		child = new sLLTag(this,cursor);
          1621 | 		//child->dump(__FILE__,__LINE__);
          1622 | 		return ((sLLTag *)child);
          1623 | 		ü
          1624 | 	else
          1625 | 		ä
          1626 | 		child = 0;
          1627 | 		return NULL;
          1628 | 		ü
          1629 | 	ü
          1630 |
          1631 | void sLLTag::dump(const char *f,int ln)
          1632 | 	ä
          1633 | #if 0
          1634 | 	char bÄ1024Ü;
          1635 | 	sprintf(b," File:%s Line:%d Name:%s Code:%d Ön",f,ln,name,code);
          1636 | 	puts(b);
          1637 | 	sLL::dump("",0);
          1638 | #endif
          1639 | 	ü
0                                   * * * * *   E N D   O F   S O U R C E   * * * * *
-

15694A01 V1.13 z/OS XL C++             //'ESA.PRJ.CBTDSSN.CPP(MVSBASE)'                      30.11.12 08:25:52
0                                    * * * * *   I N C L U D E S   * * * * *
     1  =  //'ESA.PRJ.CBTDSSN.HPP(ISISDEF)'
     2  =  //'CEE.SCEEH.H(STDLIB)'
     3  =  //'CEE.SCEEH.H(FEATURES)'
     4  =  //'CEE.SCEEH.H(BUILTINS)'
     5  =  //'CEE.SCEEH.H(STDDEF)'
     6  =  //'CEE.SCEEH.H(STRING)'
     7  =  //'CEE.SCEEH.H(STRINGS)'
     8  =  //'CEE.SCEEH.SYS.H(TYPES)'
     9  =  //'ESA.PRJ.CBTDSSN.HPP(MVSBASE)'
    10  =  //'ESA.PRJ.CBTDSSN.HPP(MERROR)'
    11  =  //'ESA.PRJ.CBTDSSN.HPP(DSNAMEUT)'
    12  =  //'CEE.SCEEH.H(ASSERT)'
    13  =  //'CEE.SCEEH.H(STDIO)'
    14  =  //'ESA.PRJ.CBTDSSN.HPP(MISC)'
    15  =  //'CEE.SCEEH.H(TIME)'
    16  =  //'CEE.SCEEH.H(ASSERT)'
    17  =  //'CEE.SCEEH.H(CTYPE)'
    18  =  //'CEE.SCEEH.H(NEW)'
    19  =  //'CEE.SCEEH(NEW)'
    20  =  //'CEE.SCEEH(EXCEPTIO)'
    21  =  //'CEE.SCEEH(XSTDDEF)'
    22  =  //'CEE.SCEEH.H(YVALS)'
    23  =  //'CEE.SCEEH(CSTDDEF)'
    24  =  //'ESA.PRJ.CBTDSSN.HPP(IBMDEBUG)'
    25  =  //'CEE.SCEEH.H(CTEST)'
-                                 * * * * *   E N D   O F   I N C L U D E S   * * * * *
0
15694A01 V1.13 z/OS XL C++             //'ESA.PRJ.CBTDSSN.CPP(MVSBASE)'                      30.11.12 08:25:52
-                           * * * * *   M E S S A G E   S U M M A R Y   * * * * *
0TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
                (U)       (S)         (E)        (W)          (I)
     0           0         0           0          0            0
0                    * * * * *   E N D   O F   M E S S A G E   S U M M A R Y   * * * * *
0                        * * * * *   E N D   O F   C O M P I L A T I O N   * * * * *
