??=pragma filetag("IBM-273")
??=pragma nomargins nosequence


























class mERROR;

class mERRORPSTACK ä
private:
   long int ip;
   long int max;
   mERROR * * sp;
public:
   mERRORPSTACK(long int size=256);
   void push(mERROR * value);
   mERROR * examine();
   int    callNextHandler(int);
   mERROR * pop();
   void  reset();
  ßmERRORPSTACK();

ü;


class mERROR
ä
protected:
   char err;
   int (* handler)(int);
enum ERROR_ACTIONäWarning, Abortü;
public:

static int max_rc;

friend class mERRORPSTACK;
   mERROR();
   mERROR(int (*)(int) );
	 virtual ßmERROR()äü;
   long int iserror()äreturn err;ü
   int  markerror(int code = 1)
   ä
    err = 1;
    if (handler) return (handler(code));
    else return 0;
   ü
   void clearerror()äerr = 0;ü
   void setmERRORHandler(int (*h)(int))ähandler = h;ü
   int error(char *,ERROR_ACTION);
ü;

extern mERRORPSTACK mErrorPStack;












extern "C"
char * genOpenName(const char *name, char *nm);



                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



  extern "C" ä


                   #pragma nomargins nosequence
                   #pragma checkout(suspend)




extern "C" ä




































































































































































































































ü

                   #pragma checkout(resume)
                   #pragma nomargins nosequence
                   #pragma checkout(suspend)















                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



   extern "C" ä

   typedef  int ptrdiff_t;

       typedef unsigned int size_t;





   ü

                   #pragma checkout(resume)

  extern "C" ä





        extern "builtin"

        int     __clcl (void*, void*, unsigned int*,
                        unsigned int*, unsigned char);




        extern "builtin"

        int     __stck (unsigned long long *);




        extern "builtin"

        int     __stcke (void *);




        #pragma pack (1)

          typedef struct __stcke_tod ä
            unsigned char      c;
            unsigned long long slice;
            unsigned int       i;
          ü __stcke_tod_t;

          typedef struct __stcke_tag ä
            unsigned char  zeros;
            __stcke_tod_t  tod;
            unsigned short p_field;
          ü __stcke_t;
        #pragma pack (reset)





        extern "builtin" ä

        void  __tr (unsigned char*, const unsigned char*,              Ö
       unsigned char);

      ü

        extern "builtin" ä

        int  __ed (unsigned char*, unsigned char*, unsigned char);
        int  __edmk (unsigned char*, unsigned char*,                   Ö
   unsigned char, unsigned char**);
        int  __trt (unsigned char*, const unsigned char*,              Ö
       unsigned char, unsigned char*, unsigned char**);
        int  __nc (unsigned char*, unsigned char*, unsigned char);
        int  __oc (unsigned char*, unsigned char*, unsigned char);
        int  __xc (unsigned char*, unsigned char*, unsigned char);
        void __pack (unsigned char*, unsigned char,                    Ö
  unsigned char*, unsigned char);
        void __unpk (unsigned char*, unsigned char,                    Ö
  unsigned char*, unsigned char);

      ü

        long double  __fmaddl (long double, long double, long double);


























      extern "builtin" ä

        int    __lper (float*, float);
        int    __lpdr (double*, double);
        int    __lner (float*, float);
        int    __lndr (double*, double);
        float  __sqer (float);
        double __sqdr (double);

      ü






      extern "builtin" ä

        float       __fier (float);
        double      __fidr (double);
        long double __fixr (long double);
        int         __cfer (int*, int, float);
        int         __cfdr (int*, int, double);
        int         __cfxr (int*, int, long double);
        int         __lpxr (long double*, long double);
        int         __lnxr (long double*, long double);
        long double __sqxr (long double);

      ü










      extern "builtin" ä

        int __thder (double*, float);
        int __thdr  (double*, double);
        int __tbedr (float*, int, double);
        int __tbdr  (double*, int, double);

      ü




      extern "builtin" ä

        unsigned short __lrvh  (unsigned short*);
        unsigned int   __lrv   (unsigned int*);
        void  __strvh (unsigned short, unsigned short*);
        void  __strv  (unsigned int, unsigned int*);

      ü













      extern "builtin" ä

        int  __cvb(char *op2);
        void __cvd(int op1, char *op2);
        int  __zap(unsigned char *op1, unsigned char len1,
                   unsigned char *op2, unsigned char len2);





          int __clcle(char *op1, unsigned long op1_len, unsigned char oÖ
p2,
                      char *op3, unsigned long op3_len);
          int __mvcle(char *op1, unsigned long op1_len, unsigned char oÖ
p2,
                      char *op3, unsigned long op3_len);





          int __tre(char *op1, unsigned long op1_len,
                    char *op2, unsigned char test_char);


            long long __cvbg(char *op2);
            void      __cvdg(long long op1, char *op2);










      ü








































        typedef union ä
            struct __dword ä
                unsigned int __high_word;
                unsigned int __low_word;
            ü __s_dword;
            unsigned long long __dword;
        ü __plo_entry_t;

        typedef union ä
            unsigned long long   __val;
            unsigned long long * __ptr;
        ü __plo_ull_ullptr_t;

        typedef union ä
            unsigned int       * __uint_ptr;
            unsigned long long * __ull_ptr;
        ü __plo_uintptr_ullptr_t;

        typedef __plo_ull_ullptr_t __plo_plistÄ18Ü;







          extern "builtin" ä

          int __plo_CL     (void *lock,
                            unsigned int *op1c, unsigned int *op2,
                            unsigned int *op3, unsigned int *op4);
          int __plo_CS     (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2);
          int __plo_DCS    (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2,
                            unsigned int *op3c, unsigned int op3r,
                            unsigned int *op4);
          int __plo_CSST   (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2,
                            unsigned int op3, unsigned int *op4);
          int __plo_CSDST  (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2, void *param_list);
          int __plo_CSTST  (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2, void *param_list);

        ü
















  ü

                   #pragma checkout(resume)


    typedef struct __div_t
      ä
      int quot;
      int rem;
      ü div_t;

    typedef struct __ldiv_t
      ä
      long int quot;
      long int rem;
      ü ldiv_t;

   typedef struct ä
               long long quot;
               long long rem;
   ü lldiv_t;

       typedef struct ä
                 long  __uheap_size;
                 long  __uheap_bytes_alloc;
                 long  __uheap_bytes_free;
       ü hreport_t;





      extern "builtin"
      void **_Gtab(int);

      extern "builtin"
      const void *_gtca(void);








      long long int strtoll(const char * restrict, char * * restrict, iÖ
nt);
      unsigned long long int strtoull(const char * restrict, char * * rÖ
estrict, int);
        #pragma map (strtoll,   "Ö174Ö174STRLL")
        #pragma map (strtoull,  "Ö174Ö174STRULL")

    double   atof (const char *);
    int      atoi (const char *);
    long int atol (const char *);
    double   strtod (const char * restrict, char * * restrict);
    long int strtol (const char * restrict, char * * restrict,
                      int);
    unsigned long int strtoul (const char * restrict,
                                char * * restrict, int);
    int      rand (void);
    void     srand (unsigned int);
        long long int strtoll (const char * restrict,
                                char * * restrict, int);
        unsigned long long int strtoull (const char * restrict,
                                          char * * restrict, int);




      void *   calloc (size_t, size_t);
      void     free (void *);
      void *   malloc (size_t);
      void *   realloc (void *, size_t);



    extern "builtin"
    int       __abs (int);



     #pragma map (__getenv,        "Ö174Ö174GETENV")



    void     abort (void);
    int      atexit (void (*)(void));
    void     exit (int);
    char *   getenv (const char *);
    char *   __getenv (const char *);
    int      system (const char *);
    void *   bsearch (const void *, const void *,
                      size_t, size_t,
                      int (*)(const void *,
                                    const void *));
    void     qsort (void *, size_t, size_t,
                    int (*)(const void *,
                                  const void *));

    int unatexit(void (*)(void));


        int      __heaprpt(hreport_t *);

    extern "C++" ä
      inline int abs (int x) ä return __abs(x); ü
    ü






    div_t    div (int, int);
    long int labs (long int);
    ldiv_t   ldiv (long int, long int);
    int      mblen (const char *, size_t);
    int      mbtowc (wchar_t * restrict,
                      const char * restrict, size_t);
    int      wctomb (char *, wchar_t);
    size_t   mbstowcs (wchar_t * restrict,
                        const char * restrict, size_t);
    size_t   wcstombs (char * restrict,
                        const wchar_t * restrict, size_t);


      long long llabs(long long );
      lldiv_t lldiv(long long , long long );











      void (*  fetch (const char *))();
      void (*  fetchep (void (*)()))();
      int    release (void (*)());


        inline int fortrc (void)
          ä  return (*( (int *)((char *)_gtca() + 568) ))/4; ü



      #pragma map (rpmatch, "Ö174Ö174RPMTCH")
      #pragma map (csid,    "Ö174Ö174CSID")
      #pragma map (wcsid,   "Ö174Ö174WCSID")

      int __librel (void);
        int clearenv (void);
      int rpmatch(const char *);
      int csid(const char *);
      int wcsid(const wchar_t);


      typedef unsigned int cs_t;

      typedef union ä
        struct ä
          unsigned int first_word;
          unsigned int second_word;
        ü double_word;
        double alignment_dummy;
      ü cds_t;

        extern "builtin"

      int     __cs (cs_t *, cs_t *, cs_t);
      int     (cs) (cs_t *, cs_t *, cs_t);

        extern "builtin"

        int     __cs1 (void *, void *, void *);




        extern "builtin"

      int     __cds (cds_t *, cds_t *, cds_t);
      int     (cds) (cds_t *, cds_t *, cds_t);

        extern "builtin"

        int     __cds1 (void *, void *, void *);












    #pragma map(__EnvnA, "Ö174Ö174ENVNA")

    char *** __EnvnA(void);
    char *** __Envn(void);








            extern "builtin"
            void *__alloca(unsigned int x);




















        double       drand48(void);
        double       erand48(unsigned short int Ä3Ü);
        long int     jrand48(unsigned short int Ä3Ü);
        void         lcong48(unsigned short int Ä7Ü);
        long int     lrand48(void);
        long int     mrand48(void);
        long int     nrand48(unsigned short int Ä3Ü);
          int          putenv(const char *);
        unsigned short int  *seed48(unsigned short int Ä3Ü);
        void         srand48(long int);
          void         setkey(const char *);










        long         a64l(const char *);
        char        *ecvt(double, int, int * restrict,
                                       int * restrict);
        char        *fcvt(double, int, int * restrict,
                                       int * restrict);
        char        *gcvt(double, int, char *);
        int          getsubopt(char **, char *const *, char **);
        char        *initstate(unsigned, char *, size_t);
        char        *l64a(long);
        int          mkstemp(char *);
        char        *mktemp(char *);
        long         random(void);
        char        *realpath(const char * restrict,
                                    char * restrict);
        char        *setstate(const char *);
        void         srandom(unsigned);
           int          ttyslot(void);
           void        *valloc(size_t);
          int          grantpt(int);
          char        *ptsname(int);
          int          unlockpt(int);




       int rand_r(unsigned int *);




    int __discarddata(void *, size_t);



          int setenv (const char *, const char *, int);









  ü


  extern "C++" ä
        inline long abs (long x) ä return labs(x); ü
        inline ldiv_t div (long x, long y)
        ä return ldiv(x,y); ü
  ü


                   #pragma checkout(resume)


                   #pragma nomargins nosequence
                   #pragma checkout(suspend)






                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



    extern "C" ä



                   #pragma nomargins nosequence
                   #pragma checkout(suspend)






    extern "C" ä








          typedef unsigned int dev_t ;




             typedef int gid_t;




          typedef unsigned int  ino_t ;



          typedef int mode_t ;




          typedef int nlink_t ;





            typedef  int off_t ;


           typedef long long off64_t;


          typedef signed int pid_t ;




            typedef signed int ssize_t ;




             typedef int uid_t;







          typedef long time_t ;



          typedef unsigned long clock_t;



          typedef struct ä
                     unsigned int   __sigs_0;
                     unsigned int   __sigs_1;
                  ü sigset_t ;



          typedef unsigned char cc_t;



          typedef unsigned int speed_t ;



          typedef unsigned int tcflag_t ;







          typedef unsigned int mtm_t ;




          typedef unsigned int rdev_t ;




          typedef char tid_tÄ8Ü;


            typedef struct ä
                      char __Ä0x08Ü;
            ü __osenv_token;







          typedef struct ä
                     char __Ä0x08Ü;
          ü pthread_t;

          typedef  struct ä
                      char __Ä0x58Ü;
          ü pthread_attr_t;

             typedef struct ä
                        unsigned long __m;
             ü pthread_mutex_t;

          typedef struct ä
                     char __Ä0x04Ü;
          ü pthread_mutexattr_t;

                typedef struct ä
                     char __Ä0x04Ü;
                ü pthread_cond_t;

          typedef struct ä
                     char __Ä0x04Ü;
          ü pthread_condattr_t;

          typedef struct ä
                     char __Ä0x04Ü;
          ü pthread_key_t;

          typedef int pthread_once_t;

             typedef struct ä
                        char __Ä0x04Ü;
              ü pthread_rwlockattr_t;

             typedef struct ä
                        char __Ä0x04Ü;
              ü pthread_rwlock_t;







         typedef long key_t;







         typedef int id_t;

         typedef unsigned int  useconds_t;


         typedef unsigned char sa_family_t;



         typedef unsigned short in_port_t;


            typedef long mcontext_tÄ40Ü;





          typedef  unsigned char  u_char;

          typedef  unsigned int   u_int;

          typedef  unsigned short ushort;

          typedef  unsigned short u_short;

          typedef  unsigned long  u_long;





         typedef unsigned long in_addr_t;

         typedef in_addr_t ip_addr_t;


         typedef  char *    caddr_t;






         typedef signed long blkcnt_t;

         typedef signed int    blksize_t;

         typedef unsigned long fsblkcnt_t;

         typedef unsigned int  fsfilcnt_t;


         typedef signed int    suseconds_t;







  ü

                   #pragma checkout(resume)




     struct __file;
     typedef int _GETCFUNC(struct __file *);
     typedef int _PUTCFUNC(int, struct __file *);
     struct __file
        ä
        unsigned char  *__bufPtr;
        long int        __countIn;
        long int        __countOut;
        _GETCFUNC      *__fcbgetc;
        _PUTCFUNC      *__fcbputc;
        unsigned int    __cntlinterpret : 1;
        unsigned int    __fcb_ascii : 1;
        unsigned int    __fcb_orientation : 2;
        ü;

     struct __ffile
       ä
       struct __file *__fp;
       ü;

     typedef struct __ffile *__FILEP;


     typedef struct __ffile FILE;

  struct __fpos_t ä
    long int __fpos_elemÄ8Ü;
    ü;

  typedef struct __fpos_t fpos_t;






      typedef char  *___valist;
    typedef ___valist  va_list;










     typedef const unsigned short *__cusp;









      #pragma map (vprintf, "Ö174Ö174VPRNT")
      #pragma map (vfprintf, "Ö174Ö174VFPRT")
        #pragma map (vsprintf, "Ö174Ö174VSPRT")




    void     clearerr (FILE *);
    int      fclose (FILE *);
    int      feof (FILE *);
    int      ferror (FILE *);
    int      fflush (FILE *);
    int      fgetc (FILE *);
    int      fgetpos (FILE * restrict, fpos_t * restrict);
    char    *fgets (char * restrict, int, FILE * restrict);
    FILE    *fopen (const char * restrict,
                    const char * restrict);
    int      fprintf (FILE * restrict,
                       const char * restrict, ...);
    int      fputc (int, FILE *);
    int      fputs (const char * restrict, FILE * restrict);
    size_t   fread (void * restrict, size_t,
                    size_t, FILE * restrict);
    FILE    *freopen (const char * restrict,
                      const char * restrict, FILE * restrict);
    int      fscanf (FILE * restrict,
                      const char * restrict, ...);
    int      fseek (FILE *, long int, int);
    int      fsetpos (FILE *, const fpos_t *);
    long int ftell (FILE *);
   size_t   fwrite (const void * restrict, size_t, size_t,
                     FILE * restrict);
    int      getc (FILE *);
    int      getchar (void);
    char    *gets (char *);
    void     perror (const char *);
    int      printf (const char * restrict, ...);
    int      putc (int, FILE *);
    int      putchar (int);
    int      puts (const char *);
    int      remove (const char *);
    int      rename (const char *, const char *);
    void     rewind (FILE *);
    int      scanf (const char * restrict, ...);
    void     setbuf (FILE * restrict, char * restrict);
    int      setvbuf (FILE * restrict, char * restrict,
                      int, size_t);
      int      sprintf (char * restrict,
                         const char * restrict, ...);
    int      sscanf (const char * restrict,
                     const char * restrict, ...);
    FILE    *tmpfile (void);
    char    *tmpnam (char *);
    int      ungetc (int, FILE *);
    int      vfprintf (FILE * restrict,
                        const char * restrict, ___valist);
    int      vprintf (const char * restrict, ___valist);
    int      vsprintf (char * restrict,
                        const char * restrict, ___valist);


         off_t ftello(FILE *);
         int fseeko(FILE *, off_t, int);








      struct __S99struc
        ä
             unsigned char __S99RBLN;
             unsigned char __S99VERB;
             unsigned short __S99FLAG1;
             unsigned short __S99ERROR;
             unsigned short __S99INFO;
             void *__S99TXTPP;
             void *__S99S99X;
             unsigned int   __S99FLAG2;
        ü;

      typedef struct __S99struc __S99parms;


    struct __S99rbx
          ä
        char           __S99EIDÄ6Ü;
        unsigned char  __S99EVER;
        unsigned char  __S99EOPTS;
        unsigned char  __S99ESUBP;
        unsigned char  __S99EKEY;
        unsigned char  __S99EMGSV;
        unsigned char  __S99ENMSG;
        void *__S99ECPPL;
        char           __reserved;
        char           __S99ERES;
        unsigned char  __S99ERCO;
        unsigned char  __S99ERCF;
        int            __S99EWRC;
        void *__S99EMSGP;
        unsigned short __S99EERR;
        unsigned short __S99EINFO;
        int            __reserv2;
        ü;

     typedef struct __S99rbx  __S99rbx_t;

     struct  __S99emparms ä
        unsigned char  __EMFUNCT;
        unsigned char  __EMIDNUM;
        unsigned char  __EMNMSGBK;
        unsigned char  __filler1;
        void *__EMS99RBP;
        int            __EMRETCOD;
        void *__EMCPPLP;
        void *__EMBUFP;
        int            __reserv1;
        int            __reserv2;
        ü;

       typedef struct __S99emparms  __S99emparms_t;



    typedef enum ä
       __disk       =  0,
       __terminal   =  1,
       __printer    =  2,
       __tape       =  3,
       __tdq        =  5,
       __dummy      =  6,

       __msgfile    =  7,

       __memory     =  8,
       __hfs        =  9,
       __hiperspace = 10,

       __msgrtn     = 11,

       __other      = 0xff
    ü __device_t;








    struct __fileData ä
         unsigned int   __recfmF   :    1,
                        __recfmV   :    1,
                        __recfmU   :    1,
                        __recfmS   :    1,
                        __recfmBlk :    1,
                        __recfmASA :    1,
                        __recfmM   :    1,
                        __dsorgPO  :    1,
                        __dsorgPDSmem : 1,
                        __dsorgPDSdir : 1,
                        __dsorgPS  :    1,
                        __dsorgConcat : 1,
                        __dsorgMem :    1,
                        __dsorgHiper  : 1,
                        __dsorgTemp:    1,
                        __dsorgVSAM:    1,

                        __dsorgHFS :    1,

                        __openmode :    2,
                        __modeflag :    4,
                        __dsorgPDSE :   1,

                        __vsamRLS :     3,
                        __vsamEA  :     1,
                        __recfmB  :     1,
                        __reserve2 :    3;

         __device_t     __device;
         unsigned long  __blksize,
                        __maxreclen;
         union ä
           struct ä
             unsigned short __vsam_type;
             unsigned long  __vsam_keylen;
             unsigned long  __vsam_RKP;
           ü __vsam;
           struct ä
             unsigned short __disk_vsam_type;
             unsigned char  __disk_access_method;
             unsigned char  __disk_noseek_to_seek;
             long           __disk_reserveÄ2Ü;
           ü __disk;
         ü __device_specific;
         char *         __dsname;
         void *         __reserve4;
    ü;

    typedef struct __fileData fldata_t;


























      int    svc99 (__S99parms *);
      int    flocate (FILE *, const void *, size_t, int);
      int    fdelrec (FILE *);
      size_t fupdate (const void *, size_t, FILE *);
      int    clrmemf (int);
      int    fldata (FILE *, char *, fldata_t *);








    typedef struct ä
              unsigned int  __fill,
                            __recnum;
    ü __rrds_key_type;


      typedef struct __amrctype ä

       union ä
               int __error;
          struct ä
            unsigned short __syscode,
                           __rc;
          ü __abend;
          struct ä
             unsigned char __fdbk_fill,
                           __rc,
                           __ftncd,
                           __fdbk;
          ü __feedback;
          struct ä
             unsigned short __svc99_info,
                            __svc99_error;
          ü __alloc;
       ü __code;
       unsigned int  __RBA;
       unsigned int      __last_op;
       struct ä
        unsigned int   __len_fill;
        unsigned int   __len;
        char           __strÄ120Ü;
        unsigned int   __parmr0;
        unsigned int   __parmr1;
        unsigned int   __fill2Ä2Ü;
        char           __str2Ä64Ü;

       ü __msg;

       unsigned char        __rplfdbwdÄ4Ü;
       unsigned long long   __XRBA;

       unsigned char        __amrc_noseek_to_seek;

       char                 __amrc_padÄ23Ü;

    ü __amrc_type;


    typedef __amrc_type *__amrc_ptr;


    typedef struct __amrc2type ä
             int       __error2;

        FILE          *__fileptr;
             int       __reservedÄ6Ü;
    ü __amrc2_type;


    typedef __amrc2_type *__amrc2_ptr;























        FILE *fdopen(int, const char *);
        int fileno(FILE *);
        char *ctermid(char *);















         char *cuserid(char *);


          int          getopt(int, char * const ÄÜ, const char *);


         int getw(FILE *);
         int putw(int, FILE *);

       extern char *optarg;
       extern int optind, opterr, optopt;













       int pclose(FILE *);
       FILE *popen(const char *, const char *);
       char  *tempnam(const char *, const char *);












     #pragma map (__snprtf,  "Ö174Ö174SNPRTF")

   int __snprtf(char *restrict, size_t, const char *restrict, ...);



    ü

                   #pragma checkout(resume)


  extern "C" ä


  void  __abort(void);
  void  assert(int);




  ü



extern "C" ä






      inline __FILEP* const * __gtab_filep(int e)       ä return (__FILÖ
EP* const *)_Gtab(e); ü




ü
                   #pragma checkout(resume)







enum genOpenNameType
ä  sas_hfs,
   ibm_hfs,
   sas_ddn,
   ibm_ddn,
   sas_dsn,
   ibm_dsn,
   ont_dsn,
   ont_ddn,
   ont_mem,
   ont_unknown,
   genOpenNameType_int = -1
ü;

genOpenNameType genOpenType(const char *);
char * stripMemberName(const char *name, char* nm);
char * onlyMemberName(const char *name, char* nm);



unsigned short  Ushort(int i);
unsigned short  Ushort(short s);
unsigned short  Ushort(char c);






void * memcpyp(void * target , const void * source, size_t tsize, size_Ö
t ssize, int pad);










enum ALIGNTYPEäaLEFT=1, aRIGHT=3, aCENTER=2, aASIS=0, ALINGNTYPE_int = Ö
-1 ü;
enum CAPSTYPEäcUPPER=3, cLOWER=4, cWORD=2, cASIS=0, CAPSTYPE_int = -1ü;
enum FIELDTYPEä
                      fCHAR =0,
                      fALPHANUMERIC=1,
                      fALPHABETIC=2,
                      fNUMERIC= 3,
                      fSLLTAG = 20,
                      fLOGICAL=4 ,fHEXA=16,
                      fBINARY=17 ,fDATE=5 ,fFTIME=6, fLISTBOX = 19,
                      FIELDTYPE_int = -1ü;




class FORMAT
ä
   protected:
   public:
   ALIGNTYPE falign;
   CAPSTYPE fcaps;
  FORMAT() :  fcaps(cUPPER),
    falign(aLEFT)äü

  FORMAT(ALIGNTYPE a ,CAPSTYPE c=cASIS )
  ä

    falign = a;
      fcaps = c;
  ü
  ßFORMAT()äü
ü;





extern FORMAT F_alcu;
extern FORMAT F_alcw;
extern FORMAT F_arcu;



struct str ä
enum status ä _VALID, _INVALID, status_int = -1 ü;
enum length ä FIX, VARIABLE ü;
char  * c;
char  * lls;
long int     l;
status type;
length ltype;
str()ä c = lls = 0; l = 0; type = _VALID; ltype = VARIABLE; ü
      ü;




class sLL;

class mvsSTRING ä
   protected:
   str st;
   public:
   static char parseSepCh;
   mvsSTRING();
   mvsSTRING(const char *);
   mvsSTRING(const mvsSTRING &);
   mvsSTRING(const char *,long int l );
   mvsSTRING(const char , const long int l);

		virtual ßmvsSTRING();

  virtual mvsSTRING& operator=(const char * );
  virtual mvsSTRING& operator=(const mvsSTRING &);
		virtual mvsSTRING& operator=(const sLL &);

  virtual operator char *() const
  ä
  if ( st.type == str::_VALID )
      return st.c;

   return st.c;
   ü
   virtual operator unsigned char *() const
  ä
  if ( st.type == str::_VALID )
      return (unsigned char *)st.c;

   return (unsigned char *)st.c;
   ü
   virtual operator const char *() const
   ä
    return (const char *)st.c;
   ü
   virtual operator const unsigned char *() const
   ä
    return (const unsigned char *)st.c;
   ü
   friend long int operator==(const mvsSTRING & , const mvsSTRING &);
   friend long int operator|=(const mvsSTRING & , const mvsSTRING &);
   friend mvsSTRING operator+(const mvsSTRING & , const mvsSTRING &);

   mvsSTRING& operator+=(const mvsSTRING&);
   void operator<<(long int );
   void operator>>(long int );

   virtual char& operatorÄÜ(int);
   virtual char& byte(int);
   mvsSTRING operator()(const long int , long int );

   long int hashcode();
  char * nameOf();
   long int  lengthOf() constäreturn st.l;ü
   long int toint()
          ä long int ret = 0;
             if ( st.l >= sizeof(long int) )
                     ret = * (long int *)(st.c);
           else if ( st.l == sizeof(short) )
              ret = * (short *)(st.c);
           else if ( st.l == 1)
              ret = *st.c;
         return ret ;
       ü
   void fromint(long int i)
       ä
             if ( st.l >= sizeof(long int) )
                      *(long int *)(st.c) = i;
           else if ( st.l == sizeof(short) )
              *(short *)(st.c) = (short )i;
           else if ( st.l == 1)
          *st.c =(char) i;
       ü
  void changeAll(char ,char );
  void align(ALIGNTYPE );
  void caps(CAPSTYPE);
  mvsSTRING & strip();
  int  isEmpty();
  mvsSTRING& stripmvsSTRING();
    mvsSTRING& format(FORMAT *);
  void parse(mvsSTRING&, char, mvsSTRING&);
  void parse(mvsSTRING&, char, mvsSTRING&, char ,mvsSTRING &);
  void parse(mvsSTRING&, char *,mvsSTRING&);
  void parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &);
  void split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &);
	void split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mvÖ
sSTRING &);
	void split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mvÖ
sSTRING &,char *,mvsSTRING&);
	void parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &,char *,mÖ
vsSTRING &);
	void dump(const char * ,int);
  char * getLlmvsSTRING();
ü;

	extern mvsSTRING nullstring;



extern mvsSTRING nullmvsSTRING;



class LLC_mvsSTRING : public mvsSTRING
ä
   short codev;
  public:
  LLC_mvsSTRING():mvsSTRING(), codev(0)äü
  LLC_mvsSTRING(char * s):mvsSTRING(),codev(0)
    ä
     short l = *(short*) s;
     if ( l >= 4 )

				ä
				mvsSTRING x = mvsSTRING(s+4,l-4);
				mvsSTRING::operator=(x);
				codev = *(short *)(s+2);
				ü
    ü
   LLC_mvsSTRING(long int c):mvsSTRING() , codev(c)äü
  ßLLC_mvsSTRING()äü
   long int   code(void)äreturn codev;ü
 operator long int()
       ä long int ret = 0;
          if ( st.l == sizeof(long int) )
                  ret = * (long int *)(st.c);
         else if ( st.l == sizeof(short) )
            ret = * (short *)(st.c);
       else if ( st.l == 1)
            ret = *st.c;
       return ret ;
    ü
ü;




mvsSTRING patternchng(mvsSTRING input , mvsSTRING mask,
  mvsSTRING (*function)(mvsSTRING));







class mvsSTRING;
class mERROR;








class mvsSTRING;
class mERROR;

class INT3
ä
private :
   long v;
public:
   INT3(long u)ä v = u;ü
   operator long()äreturn v;ü
   INT3 & operator=(long u)ä v = u;return *this;ü

ü;









enum sLLUsage ä sLLinput , sLLoutput , sLLoutputVarü ;





enum sLLType   äsLLt0 = 0, sLLt1 = 1  ,sLLt2 = 2 , sLLt3 = 3 , sLLt4 = Ö
4 ü;
enum sLLStatus äsLLOk = 0, sLLUf = 1  ,sLLOf = 2ü;

class sLL;


class sLLskipä
private:
   int i;
public:
   sLLskip(int v):i(v)äü
   operator int()äreturn i;ü
ü;

class sLL:public  mERROR
ä

protected:

      int length;
      int offset;
      int llength;
      int allocl;
      int storedl;

      sLL * base;
      sLL * child;


      char * start;
      char * cursor;
      sLLType type;
      sLLStatus status;
      char   dummy;
			mvsSTRING  string;
protected:
      sLLUsage usage;

protected:

    void init(sLL *,int,sLLType);
    int storeOk(int);

public:





    sLL (sLLType = sLLt2,
            sLLUsage = sLLoutput,int=1024 );
    sLL (sLL * , int ,
            sLLType = sLLt2);
    sLL (sLL * ,char *,
            sLLType = sLLt2);
    sLL (char *,
            sLLType = sLLt2);
      sLL (char *,
                   int );


    sLL (const sLL &);

    virtual ßsLL ();

    virtual sLL & operator=(sLL &);





      operator int();


    char & operatorÄÜ(int);

			int   getLength() const
				ä
				if ( usage == sLLinput ) return length;
				else return storedl;
				ü

			char * getStart() const
				ä return start; ü

    sLL * getBase();
    int   getOffset();
    sLL * getChild();


    int   getFullLength();
    int   getRemainderLength();
    int   getStoredLength();

    char * getCursor();
			mvsSTRING  getString();
    void  setChild(sLL*);
    void  setBase(sLL *);


    void   setLength();
    virtual void resetCursor();

    char * goCursor(int);
    void   setUsage(sLLUsage);





    sLL * next();
    sLL * iterate(sLLType,int = 0);
    void remove(sLL& );






    sLL& operator>>(int&);
    sLL& operator>>(short&);
    sLL& operator>>(unsigned short&);
    sLL& operator>>(char &);
    sLL& operator>>(char * &);
    sLL& operator>>(mvsSTRING &);
    sLL& operator>>(sLL &);
    sLL& operator>>(INT3 &);
    sLL& operator>>(sLLskip &);




    sLL& operator<<(int);
    sLL& operator<<(short);
    sLL& operator<<(unsigned short);
    sLL& operator<<(char );
    sLL& operator<<(char *);
    sLL& operator<<(mvsSTRING &);
    sLL& operator<<(sLL& );
    sLL& operator<<(INT3 &);
    sLL& operator<<(sLLskip &);
    sLL& store(char *,int);






   int write(void *);
   friend sLL * readsLL(void *,sLLType);
			virtual void dump(const char *,int);

ü;

class sLLTag: public sLL
ä
private:
   short      code;
   char       * name;
   short      searchcode;
   void       init(short);
public:
   sLLTag();
   sLLTag(short);

   sLLTag(char *);
   sLLTag(sLL * , char *);
   sLLTag(const sLLTag &);

   ßsLLTag()äü
		sLLTag& operator=(sLLTag&);

   short      getCode()ä return code;ü
   char *     getName()ä return name ;ü
   sLLTag *   search(short=0);
   void       resetCursor();
   void       remove(sLLTag &);
   sLLTag *   update(sLLTag& );
   sLLTag *   next();
   sLLTag *   iterate();
	 virtual void dump(const char *,int);
ü;



















                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



    extern "C" ä







        struct timespec
            ä
            time_t tv_sec;
            long   tv_nsec;
            ü;






  struct tm
     ä
     int tm_sec;
     int tm_min;
     int tm_hour;
     int tm_mday;
     int tm_mon;
     int tm_year;
     int tm_wday;
     int tm_yday;
     int tm_isdst;
     ü;

    #pragma map(clock,"Ö174Ö174OCLCK")









     clock_t     clock (void);
     double      difftime (time_t, time_t);
     time_t      mktime (struct tm *);
     time_t      time (time_t *);
     char       *asctime (const struct tm *);
     char       *ctime (const time_t *);
     struct tm  *gmtime (const time_t *);
     struct tm  *localtime (const time_t *);
     size_t      strftime (char * restrict, size_t,
                           const char * restrict,
                           const struct tm * restrict);
     void        __tzset(void);


      char    *strptime(const char *restrict, const char *restrict,
                        struct tm *restrict);


    inline char *ctime(const time_t *t) äreturn(asctime(localtime(t)));ü
       inline double difftime (time_t t1, time_t t0)
                              äreturn((double)((t1) - (t0)));ü









         void tzset(void);

      extern char *tznameÄ2Ü;



      #pragma map(__TzznA, "Ö174Ö174TZZNA")

      char  *(*__TzznA(void))Ä2Ü;
      char  *(*__Tzzn(void))Ä2Ü;










      extern int daylight;
      extern long int timezone;




        long int *__tzone(void);
        int *__dlght(void);



      extern int   getdate_err;


        struct tm *getdate(const char *);

        int *__gderr(void);



    char * asctime_r(const struct tm *restrict, char *restrict);
    char * ctime_r(const time_t *, char*);
    struct tm * gmtime_r(const time_t *restrict, struct tm *restrict);
    struct tm * localtime_r(const time_t *restrict, struct tm *restrictÖ
);














             ü


                   #pragma checkout(resume)




unsigned long cvb(unsigned long,unsigned long = 8);
unsigned long cvd(unsigned long);
void    formatTime(char *,int,char *);

int dump(FILE *,char *, char *,  int );
int dump(FILE *,char *, void * , int );
int dump(char *,int, char *, int);

int  fromInt(char *,long ,int  = sizeof(long));
long toInt(char *,int);
long toInt(unsigned char *,int);
int  roundToInt(double);

int   Char2Hex(char *);
char * Hex2Char(char );
int   isnull(char *,int = 0 );



char*   getTimeStemp();
int     DatetoTm(tm&,char *);
char *  DatetoString(tm, char *);

void  getUniqueKEY(char *);
void  getUniqueLongKEY(char *);
char*   DatetoString();
char *	DatetoIBM(char * from);







int   strcmpiList(const char *,const char *ÄÜ,int &);

char *strrev(char *s);

mvsSTRING makemvsSTRING(char *,int);

  int stcpma(char * ,const char * );
  void * memcpyp(void *,const void*,size_t,size_t,int);



char * Astrupr(char *, int);
char * ConvertmvsSTRINGToAscii( char *, int);
char aup(char);

void  swab( char *,char *, int);
char *  StrDup(char *);

char   bit_rotate(unsigned char);
mvsSTRING makemvsSTRING(char *,int);
extern char __test__ ;

extern unsigned char ETOAÄ256Ü;
extern unsigned char ATOEÄ256Ü;

inline int ffixed(FILE * f)
ä
      fldata_t ft;
      char fnÄ256Ü;
      if (fldata(f,fn,&ft) == 0)
         return (ft.__recfmF);
      else
				return 0;
ü

inline void  strerror_r(int err, char *errmsg, int size)
ä
    const char* msg=strerror(err);
    if(strlen(msg)>size-1)
    ä
        strncpy(errmsg,msg,size-1);
        errmsgÄsize-1Ü='Ö0';
    ü
    else
    ä
        strcpy(errmsg,msg);
    ü
ü



namespace isis_ns_mvs
	ä




	enum MSGETypesämsgundef = 0, msgint    = 1,
		msgshort = 2, msgcharp  = 3,
		msgchar  = 4,  msgmvsSTRING = 5ü;


	enum MSGEFormämsgfundef = 0, msgfd = 1, msgfs = 2, msgfx =3 , msgfc = Ö
4ü;
	class MSGE
		ä
		private:
			int         length;
			MSGEForm    form;
			MSGETypes   type;
			char *      to;
			unionä
				char     mchar;
				int      mint;
				short    mshort;
				char   * mcharp;
				mvsSTRING * mmvsSTRING;
				ü;
		public:
			MSGE();
			MSGE(int i,int l=sizeof(int), MSGEForm f = msgfd);
			MSGE(short s,int l = sizeof(short), MSGEForm f= msgfd);
			MSGE(char * c,int l = 0, MSGEForm f = msgfs);
			MSGE(const mvsSTRING &s,int l = 0,MSGEForm f = msgfs );
			MSGE(char c);

			ßMSGE()
				ä
				if ( type == msgmvsSTRING) delete mmvsSTRING;
				if ( to ) delete ÄÜ to;
				ü
			char * format();
		ü;


	class EOLä
		ü;
	const EOL eol=EOL();

	MSGE * tCHARp(char * ,int  = 0);

	MSGE * tINT(int ,int = sizeof(int));

	MSGE * tSHORT(int ,int  = sizeof(short));

	MSGE * tmvsSTRING(mvsSTRING & ,int  = 0);

	MSGE * tHEX(int  ,int = (sizeof(int)*2) );

	MSGE * tHEX(char * , int);




	enum FLAG_VALUEä FLAG_TEXT = 5, FLAG_IO = 4ü;

	typedef   struct  ENTRY
		ä
		char * name     ;
		char flag       ;
		int  xcoord     ;
		int  ycoord     ;
		int  length     ;
		char attrib     ;
		int  access     ;
		char fieldtype  ;
		char align      ;
		char caps       ;
		char * defvalue ;
		ü
	entry               ;





	typedef   struct  SELECTION
		ä
		char * line     ;
		int  access     ;
		ü
	selection           ;
	struct et
		ä
		char *   cid ;
		char * * ett;
		ü ;





	struct TEXTENTRY
		ä
		int i;
		char * t;
		ü;


	class  MessageTEXT
		ä
		private:
			char timestemp;
			int (*printfv)(char *);
			char * msgfilename;
			bool   logger;
			bool   onlylogger;
			FILE  * msgfile;
			TEXTENTRY *  vector;
			MSGE * vÄ8Ü;
			int    vi;
			int    number;
			char   defltÄ256Ü;

		public:
			MessageTEXT(char * = 0,char * = 0);
			ßMessageTEXT();
			MessageTEXT& operator<<(char *);
			MessageTEXT& operator<<(const mvsSTRING &);

			MessageTEXT& operator<<(int );
			char *       operator<<(const EOL);
			MessageTEXT& operator<<(void *);
			char * getText(int);
			int    copyText(int, char *, int);
			char * print(char *);
			void   resetPrintFv()ä printfv = 0;ü
		void   setPrintFv(int (*pfv)(char *))ä printfv= pfv;ü
	void   setLogger(const char *);
	void   setOnlyLogger(const char * l)
		ä
		setLogger(l);
		onlylogger = logger;
		ü
	void   setFILE(FILE *);
	FILE*  getFILE()äreturn msgfile;ü
void   setFileName(char *);
void   setTimeStempFlag(char c = 1)ätimestemp = c;ü
char   getTimeStempFlag()ä return timestemp;ü
void   setNumber(int n);
		ü;

	extern "C" typedef void * (*EXT_C_fp)();


	class ExternalTEXT
		ä
		private:
			EXT_C_fp fp;
			char   language;
			char   modulnameÄ8Ü;
			void * text ;
			void init(char * name);
		public:
			ExternalTEXT(char * name,char lang);
			ExternalTEXT(char * name);


			int         MSGTEXT(int id, char * buff,int len);
			char      * HelpText(char * hid);
			entry     * EntryText(char * hid);
			selection * SelectionText(char * hid);
		ü;

	extern ExternalTEXT * externaltext;



	extern  MessageTEXT * messagetext;
	int initMessageText();

	int     Error(int , ...);
	char *  Message(int , ...);
	char *  getErrorText();
	char *  getMessageText();
	MessageTEXT& Err(int);
	MessageTEXT& Msg(int);

	ü

using namespace isis_ns_mvs;








extern "OS" int  SQLASM(void);

extern "OS" int  DSNALI(...);
extern "OS" int  DSNTIAR(...);
extern "OS" void DSNHLI(void *);

const int data_dim = 30;
const int data_len = 72;


typedef struct varchar
ä
  short len;
  char  valueÄ4096Ü;
ü VARCHAR;

typedef struct
 ä
  short error_len;
  char error_textÄdata_dimÜÄdata_lenÜ;
 ü ERROR_MESSAGE;

enum  CallTypeäConnect,
       Disconnect,
       Commit,
       Rollback,
       Prepare,
       Open,
       Close,
       Executeü;












class ARCHSQL:public mERROR
ä
private:
  int rc;
  void * tecb,* secb,* ribptr,* eibptr;
  long retcode , reasoncode;
  char functionÄ13Ü;
  char ssnmÄ5Ü;
  char planÄ9Ü;
  char reuseÄ9Ü;
  char collectionÄ19Ü;
  char correlation_idÄ13Ü;
  char accounting_tokenÄ23Ü;
  char accounting_intervalÄ7Ü;
  int  rrs;
  int status;
  ERROR_MESSAGE error_message;
  void * loadlistÄ8Ü;
public:
  ARCHSQL();
  ßARCHSQL();
  int call(CallType);
  void setDynamicSQL(char *);
  void * getLoadlist()ä return loadlistÄ0Ü;ü
  void setSubSystem(char *n)ämemcpy(ssnm,n,4);ssnmÄ4Ü = 0;ü
  void setPlan(char * p)ämemcpyp(plan,p,8,strlen(p),' '); planÄ8Ü = 0;ü
  void setCollection(char * p)ämemcpyp(collection,p,8,strlen(p),' '); cÖ
ollectionÄ8Ü = 0;ü
  void setPlanName(char *n)ämemcpy(plan,n,8);planÄ8Ü = 0;ü
ü;

void  getUniqueKey(char *);
void  getUniqueKEY(char *);








struct chainE ä

	chainE * prev ;
	chainE * next ;
	char * chainEid   ;
	int    chainEidl  ;

	chainE()ächainEid = 0; chainEidl = 0; prev = next = 0;ü

	chainE(char * i,int l =0)
	ä
		if (i)
		ä
			if ( l ) chainEidl = l; else chainEidl =int(strlen(i));
			chainEid = new charÄchainEidl+1Ü; memcpy(chainEid,i,chainEidl+1);
		ü
		else chainEid =0;
		prev=next=0;
	ü

	chainE(const char * i,int l =0)
	ä
		if (i)
		ä
			if ( l ) chainEidl = l; else chainEidl =int(strlen(i));
			chainEid = new charÄchainEidl+1Ü; memcpy(chainEid,i,chainEidl+1);
		ü
		else chainEid =0;
		prev=next=0;
	ü

	chainE(const mvsSTRING * s)
	ä
		if (s)
		ä
			chainEidl = int((mvsSTRING *)s->lengthOf());
			chainEid = new charÄchainEidl+1Ü;
			memcpy(chainEid,(char *)mvsSTRING(*s),chainEidl+1);
		ü
		else chainEid =0;
		prev=next=0;
	ü
	virtual ßchainE()
	ä
		delete chainEid ;
	ü
	virtual void print()äü
ü;


class mCHAIN ä

protected:
	chainE * first;
	chainE * last ;

	chainE * pgo;
	long int    counter;
public:
	friend class CHAINITER ;

	mCHAIN()
	ä

		first = last = pgo = 0; counter = 0;
	ü

	mCHAIN(chainE * nc)
	ä
		pgo = 0;
		first = nc ; last = nc ;
		counter = 1;
	ü

	virtual ßmCHAIN();
	virtual   long int    add(chainE * nc,chainE * c,long int code = 1);
	virtual long int addfirst(chainE * nc )
	ä return add(nc,first,-1) ; ü
	virtual long int addlast(chainE * nc )
	ä return add(nc,last,+1) ; ü
	virtual long int before(chainE * nc , chainE * c)
	äreturn add(nc,c,-1);ü
	virtual long int after(chainE * nc , chainE * c)
	äreturn add(nc,c,+1);ü
	virtual long int del(chainE * c);
	virtual void swap(chainE * a , chainE * b);



	virtual chainE* goNext();
	virtual chainE* goPrev();
	virtual chainE* goFirst();
	virtual chainE* goLast();
	virtual chainE* go(int);
	virtual chainE * searchEQ(const char * id,size_t =0);
	virtual chainE * search(const char * id,size_t =0);
	virtual chainE * search(const mvsSTRING &);
	virtual chainE * search(char *id,size_t length =0)ä return search((conÖ
st char *)id,length);ü
	virtual chainE * search(mvsSTRING &s)ä return search((const mvsSTRING&Ö
)s);ü

	virtual void sort(long int direction);
	virtual void print_all_ids();
	virtual void print();
	friend int idcmp(chainE* , chainE*);
ü;

enum SORTEDTYPEäUNIQUE =0 ,NOUNIQUE =1 ü;

class SORTEDmCHAIN:public mCHAIN
ä
private:
	SORTEDTYPE unique;
public:
	SORTEDmCHAIN(SORTEDTYPE st = UNIQUE):
			mCHAIN(), unique(st)äü;
			SORTEDmCHAIN(chainE *nc, SORTEDTYPE st = UNIQUE)
				:mCHAIN(nc), unique(st)äü;
			long int add(chainE * nc,chainE * = 0,long int = 0);
			virtual ßSORTEDmCHAIN()äü
ü;

class mSTACK:public mCHAIN
ä
private:
public:
	mSTACK():mCHAIN()äü
	mSTACK(chainE * nc):mCHAIN(nc)äü

	virtual long int push(chainE * nc)äreturn addlast(nc);ü
	virtual chainE * examine(int i = 0 )
	ä
		if ( i >= 0 ) return last;
		i = -i;
		if ( counter-i < 0 ) return 0;
		return go(counter-i);

	ü
	virtual chainE * pop()ächainE * r = last; if (last) del(last);return rÖ
;ü
ü;

class mHASH:public mCHAIN
ä
private:
	chainE * * table;
	int    hash;
	int		pi;
public:
	mHASH(int h = 1023);
	ßmHASH();
	long int add(chainE *);
	long int del(chainE *);
	chainE * next();
	chainE * search(chainE *);
private:
	size_t  hashCode(chainE *c)
	ä
		int r = 0;
		if (c->chainEid)
			for (int i = c->chainEidl;i;i--)
				r = (r<<1) ¬ (c->chainEidÄi-1Ü) ;
		return size_t(r<0 ? -r:r);
	ü
ü;

class CHAINITERä
private:
	mCHAIN * c;
	chainE * a;
public:
	CHAINITER(mCHAIN &ch) äc = &ch ; a = (c->first ? c->first:0) ; ü
	CHAINITER(mCHAIN *ch) äc =  ch ; a = (c->first ? c->first:0) ; ü
	ßCHAINITER()äü
	chainE * next() ä

		chainE * r = a ;
		if ( a == 0 ) a =c->first ;
		else a = a->next ;
		return r;
	ü
	chainE * operator()()ä return next(); ü
	void reset() ä a = (c ? c->first:0);ü
ü;

int idcmp(chainE* , chainE*);










class JOBENV
ä
public:
enum JOBENV_ACTION
ä
	Abort,
   Continue
ü;
public:
    mvsSTRING jobName;
    mvsSTRING jobId;
    mvsSTRING stepName;
    mvsSTRING procStepName;
    mvsSTRING program;
		mvsSTRING programRb;
    static int  debug;
public:
    JOBENV(char *);
    ßJOBENV()äü
    void print();
    void static Error(char *,JOBENV_ACTION);
    int  static DEBUG(int,char*);
    int  static DEBUG(int,char*,int);
    int  static DEBUG(int,size_t);
    int  static DEBUG(int,char*,char*);
    int  static DEBUG(int,char*,char*,char*);
    int  static DEBUG(int,char*,char*,char*,char*);
    int  static DEBUG(int,char*,char *,int);
ü;

extern JOBENV * jobEnv;



const short  eiop00  = 0;
const short  eiop01  = 1;
const short  eiop02  = 2;
const short  eiop03  = 3;
const short  eiop04  = 4;
const short  eiop05  = 5;
const short  eiop06  = 6;
const short  eiop07  = 7;
const short  eiop08  = 8;
const short  eiop09  = 9;
const short  eiop10  =10;
const short  eiop11  =11;
const short  eiop12  =12;
const short  eiop13  =13;
const short  eiop14  =14;
const short  eiop15  =15;
const short  eiop16  =16;
const short  eiop17  =17;
const short  eiop18  =18;
const short  eiop19  =19;
const short  eiop20  =20;
const short  eiop21  =21;
const short  eiop22  =22;
const short  eiop23  =23;
const short  eiop24  =24;
const short  eiop25  =25;
const short  eiop26  =26;

const int eirc_ok    = 0;
const int eirc_replace    = 4;
const int eirc_insert    = 8;
const int eirc_delete    = 12;
const int eirc_modified  = 16;
const int eirc_disconnect  = 20;
const int eirc_disconnect_after = 24;
const int eirc_wtor        = 28;
const int eirc_end_function= 32;
const int eirc_end_dataset = 36;


extern const char * ADRDSSU;
extern const char * KEYWORD_INCLUDE_MARK;
extern const char * KEYWORD_DUMP;
extern const char * KEYWORD_RESTORE;
extern const char * KEYWORD_DB_PLAN;
extern const char * KEYWORD_DB_SUBSYS;
extern const char * KEYWORD_PREFIX;
extern const char * KEYWORD_SYSIN;
extern const char * KEYWORD_ADR012I;
extern const char * KEYWORD_DEBUG;
extern const char * KEYWORD_COMPR;
extern const char * KEYWORD_REFDT;
extern const char * KEYWORD_SQLFILE;
extern const char * KEYWORD_DIRECT;
extern const char * KEYWORD_MAXLENGTH;
extern const char * KEYWORD_USEDB2;
extern const char * KEYWORD_USEDB2_FILE;






extern "OS" int UIMASM(...);




















const  unsigned PSATOLD = 0x21c;
const  unsigned PSAAOLD = 0x224;
const  unsigned TCBFSA  = 0x70/4;
const  unsigned TCBUSER = 0xA8;
const  unsigned tcbuser = 0xa8;
const  unsigned SAVEr1  = 0x18/4;
static unsigned POSTcode = 0x40000000;
static unsigned WAITcode = 0x80000000;

class SUBTASK;
class JOBENV;


typedef void       (*SUBTASK_FUNCTION)(void*);
typedef void       * addressP;
inline addressP getASCB()äreturn(*(addressP*)PSAAOLD);ü
inline addressP getTCB()äreturn (*(addressP *)PSATOLD);ü


enum SUBTASK_STATUS
ä
    Reset,
    Started,
    WaitingForWork,
    WaitingForMain,
    Working,
    Stopping
ü;
typedef struct PROGRAM_ARGUMENTS ä
  short  arg_l;
  char   arg_vÄ1024Ü;
  ü programArguments;

 class SUBTASK: public mERROR
ä
private:
  char * dll;
protected:
  MessageTEXT * messageText;
  JOBENV *      jobEnv;
  void * TCB;
  unsigned ECB;
  unsigned StopECB;
  unsigned WorkECB;
  unsigned MainECB;
  unsigned SuspendECB;
  unsigned *  ecblistÄ2Ü;
   void(* address)(void);
  void (*subrun)();
  int R15 ;
  SUBTASK_FUNCTION functionsÄ4Ü;
  void  * argÄ4Ü;
  int subtask_rc;
  int suspendflag;
  SUBTASK_STATUS status;
  char   nameÄ9Ü;
  char   subtaskposted;
  char   first_start;
  int    timeout;
public:
  friend void run();
  SUBTASK();
  SUBTASK(char *);
  SUBTASK(addressP,SUBTASK_FUNCTION,char*);
  SUBTASK(int,char * *,char *,char *);
  virtual ßSUBTASK();
  virtual int    attach();
  virtual int    detach();
  virtual int    callAsync(int);
  virtual int    callSync(int);
  virtual int    waitForSubtask();
  virtual int    waitForEndOfSubtask();
  virtual void   start();
  virtual void   stop();
  virtual void   chap(int);
  virtual void   exit(int);
  virtual int    isTerminated()ä return (ECB&0x7fffffff);ü
  SUBTASK_STATUS askStatus()äreturn status;ü
  MessageTEXT * getMessageText()äreturn messageText;ü
  JOBENV      * getJobEnv()äreturn jobEnv;ü
  addressP      getParam()äreturn(addressP(argV));ü
  addressP      getTCB()äreturn(addressP(TCB));ü
  int           getTimeout()äreturn timeout;ü
  char *        getDllName()ä return dll;ü
  void          setDllName(char *d)ä dll = d;ü
  char * *  argV;
  int       argC;

static addressP GetTCB()äreturn (*(addressP *)PSATOLD);ü
static addressP GetASCB()äreturn(*(addressP*)PSAAOLD);ü

protected:
  int    checkR15(char *);
  void   init(char *);
  void   error(char *);
ü;

 class DLL_SUBTASK
ä
private:
public:
  SUBTASK * subtask;
  DLL_SUBTASK(int,char * *,char *,char * = "SUBRUN ");
  ßDLL_SUBTASK();
  void      start()äsubtask->start();ü
  void      stop()äsubtask->stop();ü
  int       detach()äreturn(subtask->detach());ü
  addressP  getTCB()äreturn(subtask->getTCB());ü
ü;

 class MAIN_SUBTASK:public SUBTASK
ä
private:
mvsSTRING startmvsSTRING;
 void * plistÄ1Ü;
programArguments   argument;
programArguments * argumentP;
public:
 MAIN_SUBTASK();
 MAIN_SUBTASK(int,char * *,char *);
 MAIN_SUBTASK(programArguments *,char * );
 virtual int  attach();
ü;

                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



    extern "C" ä








                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



    extern "C" ä








































  ü

                   #pragma checkout(resume)






















      struct flock ä
            short l_type;
            short l_whence;
               int   l_rsrvd1;
            off_t l_start;
               int   l_rsrvd2;
            off_t l_len;
            pid_t l_pid;
      ü;




        int creat(const char *, mode_t) ;
        int fcntl(int, int, ... );
        int open(const char *, int, ... );











     ü

                   #pragma checkout(resume)
                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



  extern "C" ä




































































               #pragma map (getlogin, "Ö174Ö174GETLG2")


         #pragma map (__getlogin1, "Ö174Ö174GETLOG")
         #pragma map (__pid_affinity,"Ö174Ö174PIDÖ174AF")

          #pragma map(__login_applid,"Ö174Ö174LOGNAP")
         #pragma map(__certificate,"Ö174Ö174CERTIF")

           void _exit(int);
           int   access(const char *, int );
           int   __certificate(int, int, char *, ...);
           unsigned int alarm(unsigned int);
           int   chdir(const char *);
           int   chown(const char *, uid_t, gid_t);
           int   close(int);
           char *ctermid(char *);
           int   dup(int);
           int   dup2(int, int);
           int   execl(const char *, const char *, ... );
           int   execle(const char *, const char *, ... );
           int   execlp(const char *, const char *, ... );
           int   execv(const char *, char *const ÄÜ);
           int   execve(const char *, char *const ÄÜ, char * const ÄÜ);
           int   execvp(const char *, char *const ÄÜ );
           pid_t fork(void);
           long  fpathconf(int, int);
           char *getcwd(char *, size_t);
           gid_t getegid(void);
           uid_t geteuid(void);
           gid_t getgid(void);
           int   getgroups(int, gid_t ÄÜ);
             int   getgroupsbyname(char ÄÜ, int, gid_t ÄÜ);
             int   __osenv(int, int, __osenv_token *);
           char *__getlogin1(void);
           char *getlogin(void);
           pid_t getpgrp(void);
           pid_t getpid(void);
           pid_t getppid(void);
           uid_t getuid(void);
           int   isatty(int);
           int   link(const char *, const char *);
           int __login(int, int, int, void *, int, char *,
                         int, char *, int);
           off_t lseek(int, off_t, int);
           long  pathconf(const char *, int);
           int   pause(void);
           int   __pid_affinity(int, pid_t, pid_t, int);
           int   pipe(int Ä2Ü);
           ssize_t read(int, void *, size_t);
           int   rmdir(const char *);
           int   setgid(gid_t);
           int   setpgid(pid_t, pid_t);
           pid_t setsid(void);
           int   setuid(uid_t);
           unsigned int sleep(unsigned int );
           long  sysconf(int);
           pid_t tcgetpgrp(int);
           int   tcsetpgrp(int, pid_t);
           char *ttyname(int);
           int   unlink(const char *);
           ssize_t write(int, const void *, size_t);

         int __login_applid(int, int, int, void *, int, char *, int, chÖ
ar *, int, const char *);
















           int   fchown(int , uid_t, gid_t);
           int   fsync(int);
           int   ftruncate(int, off_t);
           int   readlink(const char *, char *, size_t );
           int   setegid(gid_t);
           int   seteuid(uid_t);
           int   symlink(const char *, const char *);
             int   extlink_np(const char *, const char *);


































          extern char *optarg;
          extern int optind, opterr, optopt;

































             void         __cnvblk(char ÄÜ, char ÄÜ, int);
               int          chroot(const char *);
             char        *crypt(const char *, const char *);
             void         encrypt(char Ä64Ü, int);
             int          nice(int);
           extern char **__opargf(void);
           extern int  *__operrf(void);
           extern int  *__opindf(void);
           extern int  *__opoptf(void);
           size_t       confstr(int, char *, size_t);
             char        *cuserid(char *);
           int          getopt(int, char * const ÄÜ, const char *);
             char        *getpass(const char *);
           void         swab(const void *restrict,
                                   void *restrict, ssize_t);






                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



    extern "C" ä




                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



    extern "C" ä






       typedef    signed  char   int8_t;
       typedef    signed  short  int16_t;
       typedef    signed  int    int32_t;


       typedef signed long long  int64_t;




       typedef  unsigned  char  uint8_t;


       typedef  unsigned  short uint16_t;


       typedef  unsigned  int   uint32_t;

       typedef unsigned long long uint64_t;

       typedef    signed long    intptr_t;
       typedef  unsigned long   uintptr_t;



    ü

                   #pragma checkout(resume)




    ü

                   #pragma checkout(resume)



























             int          fchdir(int);
               int          getdtablesize(void);
             pid_t        getpgid(pid_t);
             pid_t        getsid(pid_t);
             char        *getwd(char *);
             int          lchown(const char *, uid_t, gid_t);
             int          setregid(gid_t, gid_t);
             int          setreuid(uid_t, uid_t);
             void         sync(void);
             int          truncate(const char *, off_t);
             useconds_t    ualarm(useconds_t, useconds_t);
             int          brk(void *);
             int          getpagesize(void);
               void        *sbrk(intptr_t);
           int          lockf(int, int, off_t);
           pid_t        setpgrp(void);
           int          usleep(useconds_t);
           pid_t        vfork(void);











      int getlogin_r(char *, size_t );
      int ttyname_r(int, char *, size_t );


      ssize_t pread(int, void *, size_t, off_t);

      ssize_t pwrite(int, const void *, size_t, off_t);




















      int          __atoe(char *);
      int          __atoe_l(char *, int);
      int          __check_resource_auth_np(char *, char *, char *,
                                            char *, char *, int);
      int          __convert_id_np( int, char *, char *, char *);
      int          __etoa(char *);
      int          __etoa_l(char *, int);
      int          __isPosixOn(void);
      int          __openMvsRel(void);
      int          __openVmRel(void);
      int          __smf_record(int, int, int, char *);
      int          __wsinit(void (*)());

    int __smf_record2(int, int, int, char *, unsigned int);








          long         gethostid(void);
          int          gethostname(char *, size_t);
















      int __must_stay_clean(int);



  ü

                   #pragma checkout(resume)
                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



    extern "C" ä









    int __errno2(void);
    int *__err2ad(void);















           extern int errno;
           extern int *__errno(void);
























































































































































  ü

                   #pragma checkout(resume)
                   #pragma nomargins nosequence
                   #pragma checkout(suspend)



   extern "C" ä




















          int  bcmp (const void *, const void *, size_t);
          void bcopy (const void *, void *, size_t);
          void bzero (void *, size_t);
          int ffs (int);
          char * index  (const char *, int);
          char * rindex (const char *, int);
          int  strcasecmp (const char *, const char *);
          int  strncasecmp (const char *, const char *, size_t);





         extern "builtin"  ä

         void * __memcpy (void *, const void *, size_t);
         int    __memcmp (const void *, const void *, size_t);
         void * __memset (void *, int, size_t);
         char * __strchr (const char *, int);
         char * __strrchr (const char *, int);

         ü






  ü

                   #pragma checkout(resume)









static const char fullQueryÄÜ =
" SELECT * FROM DSSDATASETS A "
" WHERE ( %m% ) AND "
" ( DATE(KEY) <= DATE('%d%') ) AND "
" ( "
" A.KEY =  "
" (SELECT MAX(B.KEY) FROM DSSDATASETS B WHERE A.DATASET = B.DATASET  "
" AND DATE(B.KEY) <= DATE('%d%') ) "
" ) " ;


EXEC SQL BEGIN DECLARE SECTION;

















typedef struct _TIMESTAMP
ä
  short len;
  char  arrÄ28Ü;
ü TIMESTAMP;

struct _DssDatasetRecord
ä
   struct ä short len; char arr Ä 28 Ü ; ü key;
   struct ä short len; char arr Ä 28 Ü ; ü job;
   struct ä short len; char arr Ä 45 Ü ; ü dataset;
   struct ä short len; char arr Ä 37 Ü ; ü volumes;
   long int type;
   long int recordsize;
ü DssDatasetRecord;

class TcbARCHSQL:public chainE
ä
private:
   ARCHSQL * archsql;
public:
   TcbARCHSQL(char * t,ARCHSQL * a):chainE(t),archsql(a)
   äü
   ARCHSQL * get()äreturn archsql;ü
ü;

static char * initDynamicSql();

class SQLINTERFACE:
 public  mERROR
ä
protected:
 static char * plan;
 static char * subsystem;
 static mCHAIN  tasks;
 static ERROR_MESSAGE * error_message;
protected:
 static char * dSql;
public:
	static bool useDB2;
	static FILE * fileDB2;
public:
 SQLINTERFACE();
   ßSQLINTERFACE();
   void diag(char *);
   int  commit();
   enum Error_Actionä Abort, Continueü;
   void Error(char *,Error_Action);
   ARCHSQL * connectDB();
   void tryToConnect();
ü;

class DssJob:
 public SQLINTERFACE,
 public mCHAIN,
 public CHAINITER,
 public chainE
ä
private:
   struct ä short len; char arr Ä 28 Ü ; ü t;
   struct ä short len; char arr Ä 28 Ü ; ü record_key;
   struct ä short len; char arr Ä 28 Ü ; ü record_job;
   struct ä short len; char arr Ä 45 Ü ; ü record_dataset;
   struct ä short len; char arr Ä 37 Ü ; ü record_volumes;
   long int record_type;
   long int record_size;
public:
   struct ä short len; char arr Ä 28 Ü ; ü timestamp;
   struct ä short len; char arr Ä 9 Ü ; ü jobName;
   struct ä short len; char arr Ä 9 Ü ; ü jobNumber;
   struct ä short len; char arr Ä 9 Ü ; ü program;
   struct ä short len; char arr Ä 255 Ü ; ü dataset;
   long int datasetcount;
   struct ä short len; char arr Ä 30000 Ü ; ü joblog;
   struct ä short len; char arr Ä 32000 Ü ; ü dynamicSql;
public:
  static mCHAIN dssJobs;
  static int    allOnline();
  int    doWeNeed(const char *);
public:
 DssJob();
 DssJob(TIMESTAMP&);
 DssJob(const char *);
 virtual ßDssJob();
 int insert();
 int query(mCHAIN*,char * =0);
 char * getDatasetName()
ä
  return ((char *)dataset.arr);
ü
private:
 void init();
ü;

class DssDataset:
 public SQLINTERFACE,
 public chainE
ä
private:
 DssJob * job;
public:
   struct ä short len; char arr Ä 28 Ü ; ü timestamp;
   struct ä short len; char arr Ä 45 Ü ; ü dataset;
   struct ä short len; char arr Ä 37 Ü ; ü volumes;
   long int type;
   long int recordsize;
public:
 DssDataset(DssJob *,char *,char *,int = 0,int =0);
 int compare(const char *n)
   ä
   for(int i =0;i<45&&dataset.arrÄiÜ&&dataset.arrÄiÜ-' '&&nÄiÜ&&nÄiÜ-' Ö
';i++)
     if (dataset.arrÄiÜ - nÄiÜ) return 0;
   return 1;
   ü
   virtual ßDssDataset();
   int insert();
ü;

EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE SQLDA;
EXEC SQL INCLUDE SQLCA;
static bool _useDB2()
ä
if (getenv(KEYWORD_USEDB2) && strcasecmp(getenv(KEYWORD_USEDB2),"NO") =Ö
= 0)
ä
    char wÄ128Ü;
    SQLINTERFACE::fileDB2 = fopen(genOpenName(KEYWORD_USEDB2_FILE,w),"wÖ
");
    Msg(10000+1003)<<eol;
    return false;
ü
else
    return true;
ü

char *      SQLINTERFACE::plan        = strdup(getenv(KEYWORD_DB_PLAN));
char *      SQLINTERFACE::subsystem   = strdup(getenv(KEYWORD_DB_SUBSYSÖ
));
char *      SQLINTERFACE::dSql        = initDynamicSql();
mCHAIN      DssJob::dssJobs;
mCHAIN      SQLINTERFACE::tasks;
bool        SQLINTERFACE::useDB2     = _useDB2();
FILE *      SQLINTERFACE::fileDB2    =  0;



ERROR_MESSAGE * SQLINTERFACE::error_message = new ERROR_MESSAGE();
SQLINTERFACE::SQLINTERFACE():mERROR()
ä
  tryToConnect();
ü

void SQLINTERFACE::tryToConnect()
ä


  char tÄ12Ü;
  sprintf(t,"%p",getTCB());
  if (tasks.search(t) == 0)
      tasks.addlast(new TcbARCHSQL(t,connectDB()));
      JOBENV::DEBUG(1,t);
ü

ARCHSQL * SQLINTERFACE::connectDB()
ä
      ARCHSQL * archsql = new ARCHSQL();
      if (useDB2)
      ä
      if (subsystem==0) return 0;
      ARCHSQL * archsql = new ARCHSQL();
      archsql->setSubSystem(subsystem);
      char _planÄÜ = "        ";
      memcpy(_plan,plan,strlen(plan));
      archsql->setPlan(_plan);
      if (| archsql->call(Connect))
       markerror();
      ü
      else
      ARCHSQL * archsql = (ARCHSQL*)1;
      error_message->error_len = short(data_dim*data_len);
      if (useDB2)
      Msg(10000+1000)<<subsystem<<plan<<tHEX(int(getTCB()))<<eol;
      return archsql;
ü

SQLINTERFACE::ßSQLINTERFACE()
ä
ü

void SQLINTERFACE::diag(char *t)
ä
 if (useDB2)
 ä
 Msg(10000+1001)<<t<<SQLCODE<<(char *)(sqlca.sqlerrmc)<<eol;
 int rc = DSNTIAR(&sqlca,error_message,&data_len);
 if ( rc )
  Msg(10000+9707)<<long(rc)<<eol;
 else
 ä
   for(int i = 0;i<data_dim;i++)
   if (| mvsSTRING(error_message->error_textÄiÜ,data_len).isEmpty())
      Msg(10000+9708)<<mvsSTRING(error_message->error_textÄiÜ,data_len)Ö
<<eol;
 ü
 ü

 Msg(100000+9709)<<"diag"<<eol;
ü

int SQLINTERFACE::commit()
ä
tryToConnect();
if (useDB2)
ä
  EXEC SQL COMMIT;
ü
  return 1;
ü

void SQLINTERFACE::Error(char * t,Error_Action a)
ä


 Msg(100000+9709)<<"error"<<eol;

ü

static char * initDynamicSql()
ä
  char bÄ32000Ü;
  char _genFileNameÄ1024Ü;
  size_t o = 0;
  FILE * sqlFile = 0;
  if (SQLINTERFACE::useDB2 && access(KEYWORD_SQLFILE,0x04)==0)
  sqlFile=  fopen(genOpenName(KEYWORD_SQLFILE,_genFileName),"r");
  if (sqlFile)
  while(fgets(b+o,sizeof(b)-o,sqlFile))
  ä
    o = strchr(b+o,'Ön')-b;
    if (o>0) *(b+o) = 0;
      else
    break;
  ü
  if (sqlFile)
    fclose(sqlFile);
  else
    strcpy(b,fullQuery);
  JOBENV::DEBUG(1,(char *)b);
  char * rb = new charÄstrlen(b)+1Ü;
  strcpy(rb,b);
  return (rb);
ü





DssJob::DssJob():
SQLINTERFACE(),
chainE(""),
mCHAIN(),
CHAINITER(this)
ä
char _genFileNameÄ1024Ü;
FILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),"r");
if (f==0)
ä
   init();
ü
else
		 fclose(f);

ü

DssJob::DssJob(const char * d):
SQLINTERFACE(),
chainE(""),
mCHAIN(),
CHAINITER(this)
ä
char _genFileNameÄ1024Ü;
FILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),"r");
if (f==0)
ä
   init();
ü
else
	 fclose(f);
 strcpy(dataset.arr,d);
 dataset.len = strlen(d);
ü
DssJob::DssJob(TIMESTAMP& ts):
SQLINTERFACE(),
chainE(ts.arr),
mCHAIN(),
CHAINITER(this)
ä
 init();
 memcpy(t.arr,ts.arr,ts.len);
 t.len = ts.len;
 if (useDB2)
 ä
 EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;
 EXEC SQL SELECT KEY, JOBNAME, JOBNUMBER, DATASET
 INTO
 :timestamp,
 :jobName,
 :jobNumber,
 :dataset
 FROM DSSJOBS WHERE KEY = :t;
 if (SQLCODE == 100)
    markerror();
 ü
 char * c;
 dataset.arrÄsizeof(dataset.arr)-1Ü = 0;
 if ((c = strchr(dataset.arr,' ')))
     *c = 0;
 return;
SQLERROR:
  diag("SELECT");
  markerror();
ü


DssJob::ßDssJob()
ä
ü

void DssJob::init()
ä
   memset(&timestamp,0,sizeof(timestamp));
   ä jobName.len = short((((sizeof(jobName.arr))>(strlen((char *)jobEnvÖ
->jobName)))?(strlen((char *)jobEnv->jobName)):(sizeof(jobName.arr))));Ö
 strncpy(jobName.arr,(char *)jobEnv->jobName,jobName.len); ü;
   ä jobNumber.len = short((((sizeof(jobNumber.arr))>(strlen((char *)joÖ
bEnv->jobId)))?(strlen((char *)jobEnv->jobId)):(sizeof(jobNumber.arr)))Ö
); strncpy(jobNumber.arr,(char *)jobEnv->jobId,jobNumber.len); ü;
   ä program.len = short((((sizeof(program.arr))>(strlen((char *)jobEnvÖ
->program)))?(strlen((char *)jobEnv->program)):(sizeof(program.arr))));Ö
 strncpy(program.arr,(char *)jobEnv->program,program.len); ü;
   datasetcount = 0;
   memset(&joblog,0,sizeof(joblog));
   tryToConnect();
   if (useDB2)
   ä
   EXEC SQL SET :timestamp = CURRENT TIMESTAMP;
   SQLERROR:
   if (SQLCODE) diag("SET");
   ü
   else
   ä
   time_t temp;
   struct tm *timeptr;
   temp = time(0);
   timeptr = localtime(&temp);
   timestamp.len = strftime(timestamp.arr,sizeof(timestamp.arr)-1,"%Y-%Ö
m-%d-%H.%M.%S", timeptr);
   ü
   mvsSTRING _dataset;
   _dataset = mvsSTRING(getenv(KEYWORD_PREFIX)) + "/" +
             jobEnv->jobName + jobEnv->jobId +
             mvsSTRING(timestamp.arr,timestamp.len);
   dataset.len = short(_dataset.lengthOf());
   JOBENV::DEBUG(1,(char *)_dataset);
   memcpy(dataset.arr,(char *)_dataset,dataset.len+1);
ü

int DssJob::insert()
ä
   CHAINITER::reset();
   DssDataset * ds;
   DssDataset * dp;
   tryToConnect();
   if (useDB2)
   ä
   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;
   EXEC SQL INSERT INTO DSSJOBS
    VALUES(:timestamp,
           :jobName, :jobNumber, :program, :dataset, :joblog);
   ü
   else
   ä
     if (fileDB2)
     fprintf(fileDB2,"insert into DSSJOBS:Ön");
     if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","jobName",jobName.len,jÖ
obName.len,jobName.arr);;
     if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","jobNumber",jobNumber.lÖ
en,jobNumber.len,jobNumber.arr);;
     if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","program",program.len,pÖ
rogram.len,program.arr);;
     if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","dataset",dataset.len,dÖ
ataset.len,dataset.arr);;
     if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","joblog",joblog.len,jobÖ
log.len,joblog.arr);;
    ü

   ds = (DssDataset *)CHAINITER::next();
   while(ds)
   ä
    if(| ds->insert())
     Error(Msg(10000+1002)<<ds->dataset.arr<<eol,Abort);
     dp = ds;
     ds = (DssDataset *)CHAINITER::next();
     mCHAIN::del(dp);
     delete dp;
   ü
  commit();
  return 1;
SQLERROR:
  diag("INSERT INTO DSSJOBS");
  markerror();
  return 0;
ü

static char todayÄ12Ü;

int DssJob::query(mCHAIN *m,char * date)
ä
   if (useDB2==false)
	return 0;
   CHAINITER iter(*m);
   mvsSTRING like(" ");
   chainE * mask = iter.next();
   if ( date == 0 )
   ä
     date = today;
     formatTime(today,sizeof(today),"%d.%m.%Y");
     JOBENV::DEBUG(1,(char *)date);
   ü
   int likeFlag = 0;
   while(mask)
   ä
      int i, j;
      for(i=0, j=0;mask->chainEidÄiÜ;i++)
      ä
         if(mask->chainEidÄiÜ |= '*')
            mask->chainEidÄj++Ü = mask->chainEidÄiÜ;
         else if (mask->chainEidÄi+1Ü |= '*')
         ä
            mask->chainEidÄj++Ü = '%';
            likeFlag = 1;
         ü
       ü
       if (mask->chainEidÄj-1Ü |= '%')
           mask->chainEidÄj++Ü = '%';
      mask->chainEidÄjÜ = 0;
      like = like + "A.DATASET LIKE '"+mvsSTRING(mask->chainEid)+"' ";
      if (mask->next)
         like = like + " OR ";
      mask = iter.next();
   ü
   JOBENV::DEBUG(1,(char *)like);
     ä
     char * pÄ8Ü;
     Msg(10000+122)<<dSql<<eol;
     size_t l = strlen(dSql);
     int j = 0;
     for(int i = 0;i<l&&j<8;i++)
       if (dSqlÄiÜ=='%' && dSqlÄi+2Ü == '%')
         ä
         switch (dSqlÄi+1Ü)
           ä
           case 'M':
           case 'm': pÄj++Ü = like;
             break;
           case 'D':
           case 'd': pÄj++Ü = date;
             break;
           default :
             JOBENV::Error(Msg(10000+121)<<dSqlÄiÜ<<eol,JOBENV::Abort);
           ü
           dSqlÄi+1Ü = 's';
         strcpy(dSql+i+2,dSql+i+3);
         l -= 2;
         ü
       switch(j)
         ä
         default:
         case 0:
         strcpy(dynamicSql.arr,dSql);
         break;
         case 1:
         sprintf(dynamicSql.arr,dSql,pÄ0Ü);
         break;
         case 2:
         sprintf(dynamicSql.arr,dSql,pÄ0Ü,pÄ1Ü);
         break;
         case 3:
         sprintf(dynamicSql.arr,dSql,pÄ0Ü,pÄ1Ü,pÄ2Ü);
         break;
         case 4:
         sprintf(dynamicSql.arr,dSql,pÄ0Ü,pÄ1Ü,pÄ2Ü,pÄ3Ü);
         break;
         case 5:
         sprintf(dynamicSql.arr,dSql,pÄ0Ü,pÄ1Ü,pÄ2Ü,pÄ3Ü,pÄ4Ü);
         break;
         case 6:
         sprintf(dynamicSql.arr,dSql,pÄ0Ü,pÄ1Ü,pÄ2Ü,pÄ3Ü,pÄ4Ü,
           pÄ5Ü);
         break;
         case 7:
         sprintf(dynamicSql.arr,dSql,pÄ0Ü,pÄ1Ü,pÄ2Ü,pÄ3Ü,pÄ4Ü,
           pÄ5Ü,pÄ6Ü);
         break;
         ü
     ü
   JOBENV::DEBUG(1,(char *)dynamicSql.arr);
   Msg(10000+123)<<dynamicSql.arr<<eol;
   dynamicSql.len =short(strlen(dynamicSql.arr));
   tryToConnect();
	 DssJob * job = 0;
   int fetchCount = 0;
   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;
   EXEC SQL PREPARE FULL_QUERY FROM :dynamicSql;
   EXEC SQL DECLARE C_FULL_QUERY CURSOR FOR FULL_QUERY;
   EXEC SQL OPEN C_FULL_QUERY;

   for (;;)
   ä
      EXEC SQL FETCH C_FULL_QUERY INTO
      :record_key,
      :record_job,
      :record_dataset,
      :record_volumes,
      :record_size;
      if (SQLCODE == 100) break;

        if (job == 0 ]]
         memcmp(job->timestamp.arr,record_job.arr,job->timestamp.len))
    ä
         job = new DssJob((TIMESTAMP&)record_job);
         dssJobs.addlast(job);
         fetchCount++;
        ü
        DssDataset * dataset = new DssDataset(job,
                                        record_dataset.arr,
                                        record_volumes.arr,
                                        record_type,
                                        record_size);
   ü
   EXEC SQL CLOSE C_FULL_QUERY;
   return fetchCount;
SQLERROR:
   diag("FULL QUERY");
   markerror();
   return -1;
ü

int DssJob::doWeNeed(const char * d)
  ä
  CHAINITER iter(this);
  DssDataset * ds =(DssDataset *)iter.next();
  while (ds)
    ä
    if (ds->compare(d))
      return 1;
    ds =(DssDataset *)iter.next();
    ü
  return 0;
  ü

int DssJob::allOnline()
ä
 char _genFileNameÄ1024Ü;
  FILE *   restore = fopen(genOpenName("RESTORE",_genFileName),"wb");
  if (| restore)
     JOBENV::Error(Msg(10000+110)<<"RESTORE"<<eol,JOBENV::Abort);
  int rc = 1;
  CHAINITER iter(dssJobs);
  DssJob * job = (DssJob*)iter.next();
  while (job)
  ä
    int file = open(genOpenName(job->getDatasetName(),_genFileName),0x0Ö
2+0);
    if (file < 0)
    ä
       rc = 0;
       JOBENV::Error(Msg(10000+120)<<job->getDatasetName()<<strerror((*Ö
__errno()))
         <<eol,JOBENV::Continue);
       fprintf(restore,"%sÖn",job->getDatasetName());
    ü
    else
       close(file);
    job = (DssJob*)iter.next();
  ü
  fclose(restore);
  return rc;
ü






DssDataset::DssDataset(DssJob* j,char *n,char *v,int t,int s):
SQLINTERFACE(),
chainE(n),
job(j)
ä
   job->addlast(this);
   dataset.len = (((strlen(n))>(sizeof(dataset.arr)))?(sizeof(dataset.aÖ
rr)):(strlen(n)));
   strncpy(dataset.arr,n,dataset.len);
   dataset.arrÄdataset.lenÜ = 0;

   volumes.len = (((strlen(v))>(sizeof(volumes.arr)-1))?(sizeof(volumesÖ
.arr)-1):(strlen(v)));
   strncpy(volumes.arr,v,volumes.len);
   volumes.arrÄvolumes.lenÜ = 0;
   type = t;
   recordsize = s;
   JOBENV::DEBUG(1,"Dataset construct",n,v);
ü

DssDataset::ßDssDataset()
ä
ü

int DssDataset::insert()
ä
   tryToConnect();
   memcpy(timestamp.arr,job->timestamp.arr,job->timestamp.len+1);
   timestamp.len = job->timestamp.len;
   JOBENV::DEBUG(1,"Dataset insert:",dataset.arr);
   if (useDB2)
   ä
   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;
   EXEC SQL INSERT INTO DSSDATASETS
   VALUES(CURRENT TIMESTAMP,
   :timestamp,
   :dataset,
   :volumes,
   :type,
   :recordsize);
   ü
   else
   ä
   if (SQLINTERFACE::fileDB2)
   fprintf(SQLINTERFACE::fileDB2,"insert into DSSDATASETS:Ön");
   if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","timestamp",timestamp.lenÖ
,timestamp.len,timestamp.arr);;
   if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","dataset",dataset.len,datÖ
aset.len,dataset.arr);;
   if (fileDB2) fprintf(fileDB2," %s:%*.*sÖn","volumes",volumes.len,volÖ
umes.len,volumes.arr);;
   if (fileDB2)
   fprintf(SQLINTERFACE::fileDB2," type:%dÖn size:%dÖn",type,recordsizeÖ
);
   ü
  return 1;
SQLERROR:
  diag("INSERT INTO DSSDATASETS");
  markerror();
  return 0;
ü

