{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "ESA", "INMTNODE": "JES2P390", "INMTUID": "ESA", "INMFTIME": "20121130073638000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1299251, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 255, "INMBLKSZ": 32760, "INMRECFM": "VB", "INMDIR": 1, "INMDSNAM": "ESA.PRJ.CBTDSSN.CPP", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1299251, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1299251, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ESA.PRJ.CBTDSSN.CPP": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32760, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"ADLER32": {"ttr": 1363, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* adler32.c -- compute the Adler-32 checksum of a data stream\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* \u00a7(#) $Id: adler32.c,v 1.2 2003/09/11 11:16:22 matthiasw Exp $ */\n\n#include \"zlib.h\"\n\n#define BASE 65521L /* largest prime smaller than 65536 */\n#define NMAX 5552\n/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2\u00ac32-1 */\n\n#define DO1(buf,i)  \u00e4s1 += buf\u00c4i\u00dc; s2 += s1;\u00fc\n#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);\n#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);\n#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n#define DO16(buf)   DO8(buf,0); DO8(buf,8);\n\n/* ========================================================================= */\nuLong ZEXPORT adler32(adler, buf, len)\n    uLong adler;\n    const Bytef *buf;\n    uInt len;\n\u00e4\n    unsigned long s1 = adler & 0xffff;\n    unsigned long s2 = (adler >> 16) & 0xffff;\n    int k;\n\n    if (buf == Z_NULL) return 1L;\n\n    while (len > 0) \u00e4\n        k = len < NMAX ? len : NMAX;\n        len -= k;\n        while (k >= 16) \u00e4\n            DO16(buf);\n\t    buf += 16;\n            k -= 16;\n        \u00fc\n        if (k |= 0) do \u00e4\n            s1 += *buf++;\n\t    s2 += s1;\n        \u00fc while (--k);\n        s1 %= BASE;\n        s2 %= BASE;\n    \u00fc\n    return (s2 << 16) ] s1;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CASMIF": {"ttr": 1357, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/casmif.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n#if  defined(OWN_STDIO) == 1\n#include \"stdio.hpp\"\n//#include \"crctable.hpp\"\n#include \"filesys.hpp\"\n#endif\n\n#include \"casmif.hpp\"\n#include \"mchain.hpp\"\n#include \"merror.hpp\"\n#include \"mvsbase.hpp\"\n#include \"mvstime.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0  //szm\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"msgmgr.hpp\"\n#ifndef OWN_STDIO\n#include <assert.h>\n#endif\n\nISIS_EXT_ASM unsigned int ASMIF(void *);\nstatic pMvsInterface  _mvsInterface\u00c4\u00dc = \u00e40,0,0,0,0,0,0,0\u00fc;\nstatic pcsul          _tcb\u00c4\u00dc         = \u00e40,0,0,0,0,0,0,0\u00fc;\n//szm20081215 zIIP\nbool MvsInterface::zIIP = getenv(\"ISIS_ZIIP_SUPPORT\")?true:false;\npcsul  MvsInterface::wlmEnclave = 0;\n//szm20081215 zIIP\n\n//ZA030610 always 8\nstatic int            MAX_TCB        = 8;\nstatic char CRITICAL_MAJOR\u00c4\u00dc = \"ASM__MVS\";\nstatic char CRITICAL_MINOR\u00c4\u00dc = \"ASM__MVS__CRITICAL\";\nstatic char MSG_MAJOR\u00c4\u00dc      = \"ASM__MSG\";\nstatic char MSG_MINOR\u00c4\u00dc      = \"OMSMSGMN\";\nstatic char ASM_MAJOR\u00c4\u00dc      = \"OMS     \";\nstatic char ASM_MSG\u00c4\u00dc        = \"ASM_MSG\";\nstatic char WAIT_MAJOR\u00c4\u00dc     = \"ASM_WAIT\";\nstatic char POST_MAJOR\u00c4\u00dc     = \"ASM_POST\";\n#ifndef sym_init\n#define sym_init -1\n#endif\n\n//20060418MessageTEXT * messagetext = NULL; //szm2041120\n\nstatic int _init_messagetext = initMessageText();\n\nint  GlobalTraceFlag = getenv(\"TRACE\") ? atoi(getenv(\"TRACE\")):0;\nint  GlobalCicsFlag  = 0;\nstatic char* MSGQ    = getenv(\"MSGQ\") ? getenv(\"MSGQ\"):\"SASO\";\nstatic int   MvsTimer_status = 0;\n\nstatic void btracef(const char * text)\n \u00e4\n printf(\" %s \u00d6n\",text);\n \u00fc\n\n\nstatic int CompareAndSwap(pcsul &p1,pcsul p2,void *p3)\n \u00e4\n // if ( p1 == *p3 ) *p3 = p2\n // else p1 = *p3\n return 1;\n \u00fc\n\n#if (MEM_SUPPORT)\n//\n//------------------------------------------------------------------------------\n//\n\nvoid * OwnRealloc(void *a, size_t size)\n \u00e4\n if ( size == 0 )\n  return NULL;\n else if ( a == NULL )\n  return (OwnMalloc(size));\n void * n = OwnMalloc(size);\n if ( NOT n ) return NULL;\n size_t oldsize =*((int *)a-2)-16;\n assert(oldsize > 0);\n if ( oldsize < size )\n  memcpy(n,a,oldsize);\n else\n  memcpy(n,a,size);\n OwnFree(a);\n return n;\n \u00fc\n#endif\n/*-----------------------------------------------------------------\nMvsInterface\n------------------------------------------------------------------*/\n\nvoid MvsInterface::trace(char * t)\n \u00e4\n if ( GlobalTraceFlag && file )\n  fprintf(file,\"%s\u00d6n\",t);\n \u00fc\n\nvoid MvsInterface::tracedump(char * t,void * bv,int  bl)\n \u00e4\n if ( GlobalTraceFlag )\n  \u00e4\n  if ( file )\n   fprintf(file,\"%s === %p\u00d6n\",t,bv);\n  char p\u00c4512\u00dc;\n  char * b = (char *)bv;\n  for(int o = 0;o<=bl;o+=16)\n   \u00e4\n   dump(p,o,b,bl);\n   fprintf(file,\"%s %s \u00d6n\",DatetoString(),p);\n   \u00fc\n  \u00fc\n \u00fc\n\nvoid MvsInterface::extractOper(char * text)\n \u00e4\n mvsSTRING s(text), p1, p2, st;\n s.parse(p1,\"=\",st,\" \",p2);\n while ( st.lengthOf() )\n  \u00e4\n  char* c = strchr((char *)st,'=');\n  if ( c )\n   *c = 0;\n  else\n   c = \" 1\";\n  if ( strcmp(st,\"TRACE\") == 0)\n   GlobalTraceFlag = atoi(getenv(\"TRACE\"));\n  s = p1+p2;\n  s.parse(p1,\" =\",st,\" \",p2);\n  \u00fc\n strcpy(text,s);\n \u00fc\n\n/*-----------------------------------------------------------------\nMvsStcInterface\n------------------------------------------------------------------*/\n\nchar * function_name_table\u00c4\u00dc  = \u00e4\n \"CLEANUP\",\n \"GETTOKEN\",\n \"CREATETOKEN\",\n \"DELETETOKEN\",\n \"ALLOCATEPAGES\",\n \"FREEPAGES\",\n \"ENQ\",\n \"DEQ\",\n \"SLEEP\",\n \"GETECB\",\n \"WAIT\",\n \"POST\",\n \"RESET\",\n \"SELECT\",\n \"CONNECTSHMEM\",\n \"DISCONNECTSHMEM\",\n \"OPER\",\n \"WTO\",\n \"MALLOC\",\n \"FREE\",\n \"SVC\",\n \"ATTCHMVS\",\n \"CLOCK\",\n \"TIMEUSED\",    //szm0050301\n \"TDUMP\",       //szm\n \"LOGGER\",\n \"VTOC\",\n \"SRB\",\n \"WLM\",\n \"OBTAIN\",\n \"TESTAUTH\",\n \"DIAGNOSE\",\n \"VSMLIST\",\n NULL\n \u00fc;\n\n\nMvsInterface::MvsInterface()\n \u00e4\n srb = false;\n jobname\u00c48\u00dc = programname\u00c48\u00dc = 0x00;\n if ( GlobalTraceFlag && NOT GlobalCicsFlag )\n  \u00e4\n  file  = fopen(\"SYSPRINT\",\"w\");\n  \u00fc\n else file = 0;\n CASMIF(sym_init);\n memcpy(jobname,pASM->asm_jobname,8);\n memcpy(programname,pASM->asm_programname,8);\n // TRACE(4,Msg(9503)<<\">MvsInterface\"<<jobname<<programname<<eol);\n \u00fc\n\nMvsInterface::\u00dfMvsInterface()\n \u00e4\n if ( file ) fclose(file);\n CASMIF(sym_cleanup);\n pASM = 0;\n TRACE(4,SMsg(9501)<<\"<MvsInterface\"<<eol);\n \u00fc\n\nint MvsInterface::TCPCALL(int      function,\n             void *   p0,void *   p1,void *   p2,void * p3,\n             void *   p4,void *   p5,void *   p6,void * p7)\n \u00e4\n CASMIF(function,p0,p1,p2,p3,\n  p4,p5,p6,p7);\n#if 0\n if ( rc == -1 )\n  \u00e4\n  CASMIF(sym_lasterror);\n  TRACE(1,Msg(9502)<<\">Socket errror\"<<int(rc)<<eol);\n  MsgEnq();\n  Msg(9511)<<function_name_table\u00c4function\u00dc\n  <<\" code:\"<<rc<<eol;\n  MsgDeq();\n  return -1;\n  \u00fc\n#endif\n return rc;\n \u00fc\n\nint MvsInterface::CASMIF(int      function,\n             void * p0,void * p1,void * p2,void *p3,\n             void * p4,void * p5,void * p6,void *p7)\n \u00e4\n if (function == sym_init)\n  \u00e4\n  pASM = (pasm)ASMIF(0);\n  assert(pASM);\n  pASM->asm_mvs = this;\n  \u00fc\n else\n  \u00e4\n  pASM->asm_function_code = char(function);\n  pASM->asm_parms\u00c40\u00dc= p0;\n  pASM->asm_parms\u00c41\u00dc= p1;\n  pASM->asm_parms\u00c42\u00dc= p2;\n  pASM->asm_parms\u00c43\u00dc= p3;\n  pASM->asm_parms\u00c44\u00dc= p4;\n  pASM->asm_parms\u00c45\u00dc= p5;\n  pASM->asm_parms\u00c46\u00dc= p6;\n  pASM->asm_parms\u00c47\u00dc= p7;\n  ASMIF(pASM);\n  rc = int(pASM->asm_rc);\n  reason = int(pASM->asm_reason);\n  //szm20030616 no check for ENQ/DEQ\n  if ( function NEQ sym_sleep &&  function NEQ sym_wait && function NEQ sym_attachmvs\n   && function NEQ sym_svc &&  function NEQ sym_clock && function NEQ sym_logger && function NEQ sym_wlm\n   && function NEQ sym_srb   // no check for SRB\n   &&function NEQ sym_obtain)\n   check(rc,function,\" CASMIF \");\n  else\n   return (rc);\n  \u00fc\n return (rc==0);\n \u00fc\nint MvsInterface::check(int r,char *function,char * action)\n \u00e4\n char hex\u00c49\u00dc;\n sprintf(hex,\"%8.8x\",reason);\n if ( GlobalTraceFlag == 4 )\n  TRACE(4,SMsg(9505)<<\" Checking \"<<rc<<hex<<function<<action<<eol);\n if ( r )\n  \u00e4\n  MsgEnq();\n  Msg(9510)<<function<<action<<r<<eol;\n  MsgDeq();\n  \u00fc\n return r;\n \u00fc\n\n\nint MvsInterface::check(int r,int function,char * action)\n \u00e4\n\n char hex\u00c49\u00dc;\n sprintf(hex,\"%8.8x\",reason);\n char hexrsn\u00c49\u00dc;\n sprintf(hexrsn,\"%8.8x\",pASM->asm_bpx1_rsncode);\n if ( GlobalTraceFlag == 4 )\n  TRACE(4,SMsg(9505)<<\" Checking \"<<int(rc)<<hex<<\n  function_name_table\u00c4function\u00dc<<action<<eol);\n if ( r )\n  \u00e4\n  switch(function)\n   \u00e4\n   case sym_select:      if ( r < 0 )\n    \u00e4\n    MsgEnq();\n    Msg(9510)<<function_name_table\u00c4function\u00dc<<\n     hex<<hexrsn<<eol;\n    MsgDeq();\n    \u00fc\n              break;\n   case sym_enq:         if ( r == -1 ) break;\n   case sym_wait:        if ( r == -1 ) break;\n   case sym_gettoken:    if ( r == 4 ) break;\n   case sym_deletetoken: if ( r == 4 ) break;\n   case sym_disconnectshmem: if ( r == 4 ) break;\n   case sym_vtoc:        if ( r ==4 ) break;\n   default:\n    MsgEnq();\n    Msg(9510)<<function_name_table\u00c4function\u00dc<<\n     r<<hex<<eol;\n    MsgDeq();\n   \u00fc\n  \u00fc\n return r;\n \u00fc\n\n\npcsul MvsInterface::GetTCB()\n \u00e4\n return (*(pcsul *)PSATOLD);\n \u00fc\n\npcsul MvsInterface::GetASCB()\n \u00e4\n return(*(pcsul *)PSAAOLD);\n \u00fc\n\nint MvsInterface::CheckASCB(pcsul ascb)\n \u00e4\n return(NOT (memcmp(\"ASCB\",(char *)ascb,4)));\n \u00fc\n\npcsul MvsInterface::GetToken(char * n)\n \u00e4\n TRACE(4,SMsg(9502)<<\">GetToken\"<<n<<eol);\n if ( n  &&  CASMIF(sym_gettoken,n,wt))\n  \u00e4\n  TRACEDUMP(4,SMsg(9501)<<\"<GetToken\"<<eol,(void *)wt,sizeof(*wt));\n  return ((pcsul)wt);\n  \u00fc\n return ((pcsul)NULL);\n \u00fc\n\npcsul MvsInterface::CreateToken(char *n,pcsul * v)\n \u00e4\n TRACE(4,SMsg(9502)<<\">CreateToken\"<<n<<eol);\n wt\u00c40\u00dc = v\u00c40\u00dc;\n wt\u00c41\u00dc = v\u00c41\u00dc;\n wt\u00c42\u00dc = v\u00c42\u00dc;\n wt\u00c43\u00dc = v\u00c43\u00dc;\n rc = 16;\n if ( n )\n  \u00e4\n  CASMIF(sym_createtoken,n,wt);\n  if ( rc == 4 )\n   \u00e4\n   CASMIF(sym_deletetoken,n);\n   CASMIF(sym_createtoken,n,wt);\n   \u00fc\n  \u00fc\n TRACEDUMP(4,SMsg(9501)<<\">CreateToken\"<<eol,(void *)wt,sizeof(*wt));\n return (rc==0);\n \u00fc\n\nvoid MvsInterface::DeleteToken(char *n)\n \u00e4\n TRACEDUMP(4,SMsg(9501)<<\">DeleteToken\"<<eol,(void *)n,strlen(n));\n CASMIF(sym_deletetoken,n);\n TRACE(4,SMsg(9501)<<\"<DeleteToken\"<<eol);\n \u00fc\n\n\nint MvsInterface::WaitEcb(pcsul  ms,\n             void * pecb0,void * pecb1,void * pecb2,void * pecb3)\n \u00e4\n TRACEDUMP(4,SMsg(9503)<<\">WaitEcb\"<<rc<<ms<<eol,pecb0,20);\n CASMIF(sym_wait,(void *)ms,pecb0,pecb1,pecb2,pecb3);\n TRACE(4,SMsg(9502)<<\"<WaitEcb\"<<rc<<eol);\n return rc;\n \u00fc\n\nint MvsInterface::PostEcb(void * pecb,pcsul code)\n \u00e4\n TRACE(3,SMsg(9502)<<\">PostEcb\"<<code<<eol);\n CASMIF(sym_post,pecb,(void *)code);\n TRACEDUMP(3,SMsg(9502)<<\"<PostEcb\"<<rc<<eol,pecb,20);\n return rc;\n \u00fc\n\nint MvsInterface::Enq(char * n,int ms)\n \u00e4\n TRACE(4,SMsg(9503)<<\">Enq\"<<n<<ms<<eol);\n CASMIF(sym_enq,ASM_MAJOR,n,(void *)strlen(n),(void *)ms);\n TRACE(4,SMsg(9502)<<\"<Enq\"<<rc<<eol);\n if ( rc == 0 ) return 1;\n else if ( rc < 0 ) return 0;\n else return -1;\n \u00fc\n\nint MvsInterface::Deq(char * n)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Deq\"<<n<<eol);\n CASMIF(sym_deq,ASM_MAJOR,n,(void *)strlen(n));\n TRACE(4,SMsg(9503)<<\"<Deq\"<<rc<<n<<eol);\n return (rc==0);\n \u00fc\n\n\nint MvsInterface::Svc(int n, void *p)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Svc\"<<n<<eol);\n CASMIF(sym_svc,(void *)n,(void *)p);\n TRACE(4,SMsg(9503)<<\"<Svc\"<<rc<<n<<eol);\n return (rc);\n \u00fc\n\nint MvsInterface::AttachMvs(const char * module,const char * parms)\n \u00e4\n size_t l_module= strlen(module);\n size_t l_parms = strlen(parms);\n TRACE(4,SMsg(9503)<<\">AttachMvs\"<<module<<parms<<eol);\n CASMIF(sym_attachmvs,(void *)&l_module,(void *)module,(void *)&l_parms,(void *)parms);\n TRACE(4,SMsg(9503)<<\"<AttachMvs\"<<rc<<module<<eol);\n return (rc);\n \u00fc\n\nvoid MvsInterface::Clock(void * stck)\n \u00e4\n CASMIF(sym_clock,stck);\n \u00fc\n\n//szm\nvoid MvsInterface::Timeused(void * time) //szm\n \u00e4\n CASMIF(sym_timeused,time);\n \u00fc\n\nlong long clock_mvs()\n \u00e4\n long long here;\n mvs()->Timeused(&here);\n return here;\n \u00fc\n//szm\n//szm\nint MvsInterface::Tdump(const char * n,const char *d,int dd = 0)\n \u00e4\n return (CASMIF(sym_tdump,(void *)n,(void *)d,(void *)dd));\n \u00fc\n\nint tdump(const char *n, const char *d,int dd)\n \u00e4\n return mvs()->Tdump(n,d,dd);\n \u00fc\n\n//szm20071005 get back reason code\nint mvsReasonCode()\n \u00e4\n return mvs()->getReasonCode();\n \u00fc\n//szm20071005 get back reason code\n\n\n//szm\n\n//szm20051118 LOGGER\n//szm\nint MvsInterface::LoggerOpen(const char * stream)\n \u00e4\n char zeros\u00c417\u00dc = \"\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\u00d60\";\n char token\u00c417\u00dc = \"                \";\n memcpy(token,stream,(strlen(stream)<16?strlen(stream):16));\n pcsul  p =NULL;\n\n if (strcmp(stream,(const char *)(pASM->asm_streamname))==0)\n  \u00e4\n  if (memcmp(pASM->asm_streamtoken,zeros,16)==0)\n   \u00e4\n   if (p=GetToken(token))\n    memcpy(pASM->asm_streamtoken,(char *)p,16);\n   else\n    if (CASMIF(sym_logger,(void *)0,(void *)stream,(void *)strlen(stream))==0)\n     CreateToken(token,(pcsul *)(pASM->asm_streamtoken));\n    else\n     return 0;\n   \u00fc\n  return 1;\n  \u00fc\n\n if (CASMIF(sym_logger,(void *)0,(void *)stream,(void *)strlen(stream))|=0);\n return 0;\n\n CreateToken(token,(pcsul *)(pASM->asm_streamtoken));\n return 1;\n \u00fc\nint MvsInterface::Logger(const char * stream,size_t l)\n \u00e4\n return (CASMIF(sym_logger,(void *)1,(void *)stream,(void *)(l?l:strlen(stream)))==0);\n \u00fc\n//szm\nint MvsInterface::BrowseLogger(const char * & addr,size_t *  & length,int direction,int all,char * date_time)\n \u00e4\n  if (direction ==0) //szm\n   direction = 2;\n return (CASMIF(sym_logger,(void *)(direction),(void *)&addr,(void *)&length,(void *)all,(void *)date_time));\n \u00fc\n\n//szm\nint MvsInterface::LoggerClose()\n \u00e4\n //return (CASMIF(sym_logger,(void *)-1)); szm\n // never close the logger\n return 1;\n \u00fc\n//szm20051118 LOGGER\n//szm20051121 VTOC\nint MvsInterface::VtocOpen(const char * ddname,const char * mask,char *dscb)\n \u00e4\n char _mask\u00c446\u00dc;\n char _ddname\u00c49\u00dc;\n memcpy(_mask+1,mask,44);\n _mask\u00c445\u00dc = 0;\n if (strchr(_mask+1,' '))\n  *strchr(_mask+1,' ')= 0;\n _mask\u00c40\u00dc = strlen(_mask+1);\n memset(_ddname,' ',8);\n _ddname\u00c48\u00dc = 0;\n memcpy(_ddname,ddname,(strlen(ddname)<=8)?strlen(ddname):8);\n CASMIF(sym_vtoc,(void *)0,(void *)_ddname,(void *)_mask,(void *)dscb);\n return rc;\n \u00fc\nint MvsInterface::Vtoc(char * dscb)\n \u00e4\n CASMIF(sym_vtoc,(void *)1,(void *)0,(void *)0,(void *)dscb);\n return rc;\n \u00fc\nint MvsInterface::VtocClose()\n \u00e4\n return (CASMIF(sym_vtoc,(void *)-1));\n \u00fc\n//szm20051121 VTOC\n\n//szm\nint MvsInterface::initEnclave()\n  \u00e4\n \treturn wlmEnclave;\n  \u00fc\n\nint MvsInterface::Srb()\n \u00e4\n if (srb)\n  \u00e4\n CASMIF(sym_srb);\n srb = false;\n //printf(\" exit from SRB:%p %p srbFlag:%d\u00d6n\",pASM,this,pASM->asm_srb_mode);\n  \u00fc\n else\n  \u00e4\n  //printf(\" entry to SRB:%p %p srbFlag:%d\u00d6n\",pASM,this,pASM->asm_srb_mode);\n  srb = true;\n  CASMIF(sym_srb);\n  \u00fc\n return rc;\n \u00fc\n\n\nint MvsInterface::Wlm(const char * subsys,const char * subsysnm)\n \u00e4\n /*\n if (CASMIF(sym_wlm,(void *)subsys,(void *)subsysnm)|=0)\n  \u00e4\n  printf(\" WLM function:%8.8s rc:%d(%8.8x) rsn:%d(%8.8x)\u00d6n\",\n   pASM->asm_wlm_macro,pASM->asm_wlm_retcode,pASM->asm_wlm_retcode,\n   pASM->asm_wlm_rsncode,pASM->asm_wlm_rsncode);\n  return 8;\n  \u00fc\n */\n\n return 0;\n \u00fc\n\nint MvsInterface::Obtain(const char * dsn, const char * volser,char * dscb)\n\u00e4\n return (CASMIF(sym_obtain,(void *)dsn,(void *)volser,(void *)dscb));\n\u00fc\n\nint MvsInterface::Testauth()\n\u00e4\n return (CASMIF(sym_testauth));\n\u00fc\n\nint MvsInterface::Diagnose(int function,void * reply)\n\u00e4\n return(CASMIF(sym_diagnose,(void *)function,reply));\n\u00fc\n\n\nint MvsInterface::Vsmlist(void * ascb,void * address, int length )\n\u00e4\n return(CASMIF(sym_vsmlist,ascb,address,(void *)length));\n\u00fc\n\nvoid MvsInterface::Chap(pcsul t,int p)\n \u00e4\n TRACE(4,SMsg(9503)<<\">Chap\"<<t<<long(p)<<eol);\n#ifdef __SASC_\n CHAP(p,&t);\n#endif\n TRACE(4,SMsg(9501)<<\"<Chap\"<<eol);\n \u00fc\n\npcsul MvsInterface::Attach(char * pgm,char ** param,pcsul ecb)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Attach\"<<pgm<<eol);\n pcsul tcb = 0;\n *(pcsul *)ecb = 0;\n pcsul lparam\u00c416\u00dc;\n int i;\n for(i =0;i<16 && param\u00c4i\u00dc;i++)lparam\u00c4i\u00dc = (pcsul)(param\u00c4i\u00dc);\n lparam\u00c4i\u00dc = lparam\u00c4i\u00dc ] 0x80000000;\n check(rc,\"Attach\",\"ATTACH\");\n TRACE(4,SMsg(9501)<<\"<Attach\"<<eol);\n return tcb;\n \u00fc\n\nvoid MvsInterface::Detach(pcsul tcb)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Detach\"<<tcb<<eol);\n check(rc,\"Deatch\",\"DETACH\");\n TRACE(4,SMsg(9501)<<\"<Detach\"<<eol);\n \u00fc\n\nvoid MvsInterface::Sleep(int ms)\n \u00e4\n TRACE(4,SMsg(9502)<<\">Sleep\"<<ms<<eol);\n if (ms) CASMIF(sym_sleep,(void *)ms);\n TRACE(4,SMsg(9501)<<\"<Sleep\"<<eol);\n \u00fc\n\nint MvsInterface::Oper(char *to,const size_t length)\n \u00e4\n TRACE(4,SMsg(9501)<<\">Oper\"<<eol);\n memset(to,0,length);\n CASMIF(sym_oper,(void *)to,(void *)length);\n if ( rc == 0 ) extractOper(to);\n TRACE(4,SMsg(9503)<<\"<Oper\"<<to<<rc<<eol);\n return rc;\n \u00fc\n\nvoid MvsInterface::Wto(const char *text,const int desc)\n \u00e4\n if ( text == 0 ) return;\n TRACE(4,SMsg(9502)<<\">Wto\"<<text<<eol);\n char  t\u00c4128\u00dc;\n memset(t,0,sizeof(t));\n strncpy(t,text,sizeof(t)-1);\n for(char * ct = t;*ct;ct++) if( *ct == '\u00d6n') *ct = ' ';\n CASMIF(sym_wto,(void *)t,(void *)strlen(t),(void *)desc);\n TRACE(4,SMsg(9501)<<\"<Wto\"<<eol);\n \u00fc\n\nvoid * MvsInterface::Malloc(size_t size)\n \u00e4\n void * a = 0;\n CASMIF(sym_malloc,(void *)size,(void *)&a);\n check(rc,\"Malloc\",\"MALLOC\");\n return a;\n \u00fc\n\nvoid  MvsInterface::Free(void * a)\n \u00e4\n CASMIF(sym_free,(void *)a);\n check(rc,\"Free\",\"FREE\");\n return ;\n \u00fc\n\n\nint MvsInterface::Select(pcsul numfds,\n             void *rfds,void *wfds,void *efds,void *time)\n \u00e4\n CASMIF(sym_select,(void *)numfds,rfds,wfds,efds,time);\n TRACE(4,SMsg(9502)<<\"<Select\"<<rc<<eol);\n return rc;\n \u00fc\n\n/*-----------------------------------------------------------------\nCOMMON functions\n------------------------------------------------------------------*/\n\nint isCics()\u00e4 return GlobalCicsFlag;\u00fc\n\n\nMvsInterface * getTcbUser()\n \u00e4\n pcsul  p = * (pcsul  * )PSATOLD;\n pasm pASM = ((pasm)*(pasm *)(p+TCBUSER));\n if (pASM)\n  return((MvsInterface *)(pASM->asm_mvs));\n else\n  return((MvsInterface * )NULL);\n \u00fc\n\n\nMvsInterface * mvs()\n \u00e4\n int i = 0;\n for(;i<MAX_TCB && _mvsInterface\u00c4i\u00dc;i++)\n  if (_tcb\u00c4i\u00dc == *(pcsul *)PSATOLD) break;\n assert(i<MAX_TCB);\n if (_mvsInterface\u00c4i\u00dc && _tcb\u00c4i\u00dc == *(pcsul *)PSATOLD)\n  return(_mvsInterface\u00c4i\u00dc);\n _tcb\u00c4i\u00dc = *(pcsul *)PSATOLD;\n return (_mvsInterface\u00c4i\u00dc = (MvsInterface*)new MvsInterface());\n \u00fc\n\nint MsgEnq()\n \u00e4\n int rc = 0;\n rc = ( ENQ(MSG_MAJOR,MSG_MINOR,E,8,STEP,NONE) == 0);\n return rc;\n \u00fc\n\nint MsgDeq()\n \u00e4\n int rc = 0;\n rc = ( DEQ(MSG_MAJOR,MSG_MINOR,8,STEP,NONE) == 0);\n return rc;\n \u00fc\n\n//KV\nSyncVar::SyncVar(pcsul w)\n \u00e4\n var  = 0;\n wait = w;\n ecb  = 0;\n \u00fc\n\nSyncVar::SyncVar(const SyncVar & v)\n \u00e4\n var  = v.var;\n wait = v.wait;\n ecb = 0;\n \u00fc\nSyncVar::\u00dfSyncVar()\n \u00e4\n if (ecb&WAITcode)\n  mvs()->PostEcb(&ecb,0);\n \u00fc\nSyncVar& SyncVar::operator=(pcsul t)\n \u00e4\n // printf(\" %p TCB %s %d\u00d6n\",*(pcsul *)PSATOLD,\">operator\",t);\n // btrace(&btracef);\n for(;;)\n  \u00e4\n  // if ( p1 == *p3 ) *p3 = p2\n  // else p1 = *p3\n  pcsul x = var;\n  if (CompareAndSwap(x,t,&var)==0)\n   break;\n  \u00fc\n mvs()->PostEcb(&ecb,t);\n //printf(\" %p TCB %s %p\u00d6n\",*(pcsul *)PSATOLD,\"<operator\",var);\n return(*this);\n \u00fc\n\nSyncVar::operator int()\n \u00e4\n //printf(\" %p TCB %s %p\u00d6n\",*(pcsul *)PSATOLD,\"init()\",var);\n return int(var);\n \u00fc\n\npcsul waitSyncVar(SyncVar &s)\n \u00e4\n //printf(\" %p TCB  %s %p\u00d6n\",*(pcsul *)PSATOLD,\">wait\",s.var);\n //szm20040624 avoid dumplicate wait on ECB's (S301)\n if (int(s.ecb)&0x80000000)\n  mvs()->Sleep(100);\n else\n  if (mvs()->WaitEcb(s.wait,&s.ecb) <0)\n   return (-1);\n // printf(\" %p TCB  %s %p\u00d6n\",*(pcsul *)PSATOLD,\"<wait\",s.var);\n return(s.var);\n \u00fc\npcsul waitSyncVars(SyncVar &s1,SyncVar &s2)\n \u00e4\n //printf(\" %p TCB %s %p %p\u00d6n\",*(pcsul *)PSATOLD,\">waits\",s1.var, s2.var);\n //szm20040624 avoid dumplicate wait on ECB's (S301)\n if (int(s1.ecb)&0x80000000 ]] int(s2.ecb)&0x80000000)\n  mvs()->Sleep(100);\n else\n  if\n   (mvs()->WaitEcb((s1.wait<s2.wait?s1.wait:s2.wait),&s1.ecb,&s2.ecb) < 0)\n   return (-1);\n //printf(\" %p TCB %s %p %p\u00d6n\",*(pcsul *)PSATOLD,\"<waits\",s1.var, s2.var);\n return(1);\n \u00fc\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 1387, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* compress.c -- compress a memory buffer\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* \u00a7(#) $Id: compress.c,v 1.2 2003/09/11 11:16:22 matthiasw Exp $ */\n\n#include \"zlib.h\"\n\n/* ===========================================================================\n     Compresses the source buffer into the destination buffer. The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer. Upon entry, destLen is the total size of the\n   destination buffer, which must be at least 0.1% larger than sourceLen plus\n   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\nint ZEXPORT compress2 (dest, destLen, source, sourceLen, level)\n    Bytef *dest;\n    uLongf *destLen;\n    const Bytef *source;\n    uLong sourceLen;\n    int level;\n\u00e4\n    z_stream stream;\n    int err;\n\n    stream.next_in = (Bytef*)source;\n    stream.avail_in = (uInt)sourceLen;\n#ifdef MAXSEG_64K\n    /* Check for source > 64K on 16-bit machine: */\n    if ((uLong)stream.avail_in |= sourceLen) return Z_BUF_ERROR;\n#endif\n    stream.next_out = dest;\n    stream.avail_out = (uInt)*destLen;\n    if ((uLong)stream.avail_out |= *destLen) return Z_BUF_ERROR;\n\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n    stream.opaque = (voidpf)0;\n\n    err = deflateInit(&stream, level);\n    if (err |= Z_OK) return err;\n\n    err = deflate(&stream, Z_FINISH);\n    if (err |= Z_STREAM_END) \u00e4\n        deflateEnd(&stream);\n        return err == Z_OK ? Z_BUF_ERROR : err;\n    \u00fc\n    *destLen = stream.total_out;\n\n    err = deflateEnd(&stream);\n    return err;\n\u00fc\n\n/* ===========================================================================\n */\nint ZEXPORT compress (dest, destLen, source, sourceLen)\n    Bytef *dest;\n    uLongf *destLen;\n    const Bytef *source;\n    uLong sourceLen;\n\u00e4\n    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRC32": {"ttr": 1373, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* crc32.c -- compute the CRC-32 of a data stream\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* \u00a7(#) $Id: crc32.c,v 1.2 2003/09/11 11:16:22 matthiasw Exp $ */\n\n#include \"zlib.h\"\n\n#define local static\n\n#ifdef DYNAMIC_CRC_TABLE\n\nlocal int crc_table_empty = 1;\nlocal uLongf crc_table\u00c4256\u00dc;\nlocal void make_crc_table OF((void));\n\n/*\n  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:\n  x\u00ac32+x\u00ac26+x\u00ac23+x\u00ac22+x\u00ac16+x\u00ac12+x\u00ac11+x\u00ac10+x\u00ac8+x\u00ac7+x\u00ac5+x\u00ac4+x\u00ac2+x+1.\n\n  Polynomials over GF(2) are represented in binary, one bit per coefficient,\n  with the lowest powers in the most significant bit.  Then adding polynomials\n  is just exclusive-or, and multiplying a polynomial by x is a right shift by\n  one.  If we call the above polynomial p, and represent a byte as the\n  polynomial q, also with the lowest power in the most significant bit (so the\n  byte 0xb1 is the polynomial x\u00ac7+x\u00ac3+x+1), then the CRC is (q*x\u00ac32) mod p,\n  where a mod b means the remainder after dividing a by b.\n\n  This calculation is done using the shift-register method of multiplying and\n  taking the remainder.  The register is initialized to zero, and for each\n  incoming bit, x\u00ac32 is added mod p to the register if the bit is a one (where\n  x\u00ac32 mod p is p+x\u00ac32 = x\u00ac26+...+1), and the register is multiplied mod p by\n  x (which is shifting right by one and adding x\u00ac32 mod p if the bit shifted\n  out is a one).  We start with the highest power (least significant bit) of\n  q and repeat for all eight bits of q.\n\n  The table is simply the CRC of all possible eight bit values.  This is all\n  the information needed to generate CRC's on data a byte at a time for all\n  combinations of CRC register values and incoming bytes.\n*/\nlocal void make_crc_table()\n\u00e4\n  uLong c;\n  int n, k;\n  uLong poly;            /* polynomial exclusive-or pattern */\n  /* terms of polynomial defining this crc (except x\u00ac32): */\n  static const Byte p\u00c4\u00dc = \u00e40,1,2,4,5,7,8,10,11,12,16,22,23,26\u00fc;\n\n  /* make exclusive-or pattern from polynomial (0xedb88320L) */\n  poly = 0L;\n  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)\n    poly ]= 1L << (31 - p\u00c4n\u00dc);\n\n  for (n = 0; n < 256; n++)\n  \u00e4\n    c = (uLong)n;\n    for (k = 0; k < 8; k++)\n      c = c & 1 ? poly \u00ac (c >> 1) : c >> 1;\n    crc_table\u00c4n\u00dc = c;\n  \u00fc\n  crc_table_empty = 0;\n\u00fc\n#else\n/* ========================================================================\n * Table of CRC-32's of all single-byte values (made by make_crc_table)\n */\nlocal const uLongf crc_table\u00c4256\u00dc = \u00e4\n  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,\n  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,\n  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,\n  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,\n  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,\n  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,\n  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,\n  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,\n  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,\n  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,\n  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,\n  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,\n  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,\n  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,\n  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,\n  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,\n  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,\n  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,\n  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,\n  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,\n  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,\n  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,\n  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,\n  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,\n  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,\n  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,\n  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,\n  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,\n  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,\n  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,\n  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,\n  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,\n  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,\n  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,\n  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,\n  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,\n  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,\n  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,\n  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,\n  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,\n  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,\n  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,\n  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,\n  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,\n  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,\n  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,\n  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,\n  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,\n  0x2d02ef8dL\n\u00fc;\n#endif\n\n/* =========================================================================\n * This function can be used by asm versions of crc32()\n */\nconst uLongf * ZEXPORT get_crc_table()\n\u00e4\n#ifdef DYNAMIC_CRC_TABLE\n  if (crc_table_empty) make_crc_table();\n#endif\n  return (const uLongf *)crc_table;\n\u00fc\n\n/* ========================================================================= */\n#define DO1(buf) crc = crc_table\u00c4((int)crc \u00ac (*buf++)) & 0xff\u00dc \u00ac (crc >> 8);\n#define DO2(buf)  DO1(buf); DO1(buf);\n#define DO4(buf)  DO2(buf); DO2(buf);\n#define DO8(buf)  DO4(buf); DO4(buf);\n\n/* ========================================================================= */\nuLong ZEXPORT crc32(crc, buf, len)\n    uLong crc;\n    const Bytef *buf;\n    uInt len;\n\u00e4\n    if (buf == Z_NULL) return 0L;\n#ifdef DYNAMIC_CRC_TABLE\n    if (crc_table_empty)\n      make_crc_table();\n#endif\n    crc = crc \u00ac 0xffffffffL;\n    while (len >= 8)\n    \u00e4\n      DO8(buf);\n      len -= 8;\n    \u00fc\n    if (len) do \u00e4\n      DO1(buf);\n    \u00fc while (--len);\n    return crc \u00ac 0xffffffffL;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFLATE": {"ttr": 1383, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* deflate.c -- compress data using the deflation algorithm\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process depends on being able to identify portions\n *      of the input text which are identical to earlier input (within a\n *      sliding window trailing behind the input currently being processed).\n *\n *      The most straightforward technique turns out to be the fastest for\n *      most input files: try all possible matches and select the longest.\n *      The key feature of this algorithm is that insertions into the string\n *      dictionary are very simple and thus fast, and deletions are avoided\n *      completely. Insertions are performed at each input character, whereas\n *      string matches are performed only when the previous match ends. So it\n *      is preferable to spend more time in matches to allow very fast string\n *      insertions and avoid deletions. The matching algorithm for small\n *      strings is inspired from that of Rabin & Karp. A brute force approach\n *      is used to find longer strings when a small match has been found.\n *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze\n *      (by Leonid Broukhis).\n *         A previous version of this file used a more sophisticated algorithm\n *      (by Fiala and Greene) which is guaranteed to run in linear amortized\n *      time, but has a larger average cost, uses more memory and is patented.\n *      However the F&G algorithm may be faster for some highly redundant\n *      files if the parameter max_chain_length (described below) is too large.\n *\n *  ACKNOWLEDGEMENTS\n *\n *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and\n *      I found it in 'freeze' written by Leonid Broukhis.\n *      Thanks to many people for bug reports and testing.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n *      Available in ftp://ds.internic.net/rfc/rfc1951.txt\n *\n *      A description of the Rabin and Karp algorithm is given in the book\n *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n *\n *      Fiala,E.R., and Greene,D.H.\n *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595\n *\n */\n\n/* \u00a7(#) $Id: deflate.c,v 1.2 2003/09/11 11:16:22 matthiasw Exp $ */\n\n#include \"deflate.h\"\n\nconst char deflate_copyright\u00c4\u00dc =\n   \" deflate 1.1.4 Copyright 1995-2002 Jean-loup Gailly \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\n\n/* ===========================================================================\n *  Function prototypes.\n */\ntypedef enum \u00e4\n    need_more,      /* block not completed, need more input or more output */\n    block_done,     /* block flush performed */\n    finish_started, /* finish started, need only more output at next deflate */\n    finish_done     /* finish done, accept no more input or output */\n\u00fc block_state;\n\ntypedef block_state (*compress_func) OF((deflate_state *s, int flush));\n/* Compression function. Returns the block state after the call. */\n\nlocal void fill_window    OF((deflate_state *s));\nlocal block_state deflate_stored OF((deflate_state *s, int flush));\nlocal block_state deflate_fast   OF((deflate_state *s, int flush));\nlocal block_state deflate_slow   OF((deflate_state *s, int flush));\nlocal void lm_init        OF((deflate_state *s));\nlocal void putShortMSB    OF((deflate_state *s, uInt b));\nlocal void flush_pending  OF((z_streamp strm));\nlocal int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));\n#ifdef ASMV\n      void match_init OF((void)); /* asm code initialization */\n      uInt longest_match  OF((deflate_state *s, IPos cur_match));\n#else\nlocal uInt longest_match  OF((deflate_state *s, IPos cur_match));\n#endif\n\n#ifdef DEBUG\nlocal  void check_match OF((deflate_state *s, IPos start, IPos match,\n                            int length));\n#endif\n\n/* ===========================================================================\n * Local data\n */\n\n#define NIL 0\n/* Tail of hash chains */\n\n#ifndef TOO_FAR\n#  define TOO_FAR 4096\n#endif\n/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */\n\n#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n/* Minimum amount of lookahead, except at the end of the input file.\n * See deflate.c for comments about the MIN_MATCH+1.\n */\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\ntypedef struct config_s \u00e4\n   ush good_length; /* reduce lazy search above this match length */\n   ush max_lazy;    /* do not perform lazy search above this match length */\n   ush nice_length; /* quit search above this match length */\n   ush max_chain;\n   compress_func func;\n\u00fc config;\n\nlocal const config configuration_table\u00c410\u00dc = \u00e4\n/*      good lazy nice chain */\n/* 0 */ \u00e40,    0,  0,    0, deflate_stored\u00fc,  /* store only */\n/* 1 */ \u00e44,    4,  8,    4, deflate_fast\u00fc, /* maximum speed, no lazy matches */\n/* 2 */ \u00e44,    5, 16,    8, deflate_fast\u00fc,\n/* 3 */ \u00e44,    6, 32,   32, deflate_fast\u00fc,\n\n/* 4 */ \u00e44,    4, 16,   16, deflate_slow\u00fc,  /* lazy matches */\n/* 5 */ \u00e48,   16, 32,   32, deflate_slow\u00fc,\n/* 6 */ \u00e48,   16, 128, 128, deflate_slow\u00fc,\n/* 7 */ \u00e48,   32, 128, 256, deflate_slow\u00fc,\n/* 8 */ \u00e432, 128, 258, 1024, deflate_slow\u00fc,\n/* 9 */ \u00e432, 258, 258, 4096, deflate_slow\u00fc\u00fc; /* maximum compression */\n\n/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n * meaning.\n */\n\n#define EQUAL 0\n/* result of memcmp for equal strings */\n\nstruct static_tree_desc_s \u00e4int dummy;\u00fc; /* for buggy compilers */\n\n/* ===========================================================================\n * Update a hash value with the given input byte\n * IN  assertion: all calls to to UPDATE_HASH are made with consecutive\n *    input characters, so that a running hash key can be computed from the\n *    previous key instead of complete recalculation each time.\n */\n#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) \u00ac (c)) & s->hash_mask)\n\n\n/* ===========================================================================\n * Insert string str in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * If this file is compiled with -DFASTEST, the compression level is forced\n * to 1, and no hash chains are maintained.\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n *    input characters and the first MIN_MATCH bytes of str are valid\n *    (except for the last MIN_MATCH-1 bytes of the input file).\n */\n#ifdef FASTEST\n#define INSERT_STRING(s, str, match_head) \u00d6\n   (UPDATE_HASH(s, s->ins_h, s->window\u00c4(str) + (MIN_MATCH-1)\u00dc), \u00d6\n    match_head = s->head\u00c4s->ins_h\u00dc, \u00d6\n    s->head\u00c4s->ins_h\u00dc = (Pos)(str))\n#else\n#define INSERT_STRING(s, str, match_head) \u00d6\n   (UPDATE_HASH(s, s->ins_h, s->window\u00c4(str) + (MIN_MATCH-1)\u00dc), \u00d6\n    s->prev\u00c4(str) & s->w_mask\u00dc = match_head = s->head\u00c4s->ins_h\u00dc, \u00d6\n    s->head\u00c4s->ins_h\u00dc = (Pos)(str))\n#endif\n\n/* ===========================================================================\n * Initialize the hash table (avoiding 64K overflow for 16 bit systems).\n * prev\u00c4\u00dc will be initialized on the fly.\n */\n#define CLEAR_HASH(s) \u00d6\n    s->head\u00c4s->hash_size-1\u00dc = NIL; \u00d6\n    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));\n\n/* ========================================================================= */\nint ZEXPORT deflateInit_(strm, level, version, stream_size)\n    z_streamp strm;\n    int level;\n    const char *version;\n    int stream_size;\n\u00e4\n    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,\n\t\t\t Z_DEFAULT_STRATEGY, version, stream_size);\n    /* To do: ignore strm->next_in if we use it as window */\n\u00fc\n\n/* ========================================================================= */\nint ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n\t\t  version, stream_size)\n    z_streamp strm;\n    int  level;\n    int  method;\n    int  windowBits;\n    int  memLevel;\n    int  strategy;\n    const char *version;\n    int stream_size;\n\u00e4\n    deflate_state *s;\n    int noheader = 0;\n    static const char* my_version = ZLIB_VERSION;\n\n    ushf *overlay;\n    /* We overlay pending_buf and d_buf+l_buf. This works since the average\n     * output size for (length,distance) codes is <= 24 bits.\n     */\n\n    if (version == Z_NULL ]] version\u00c40\u00dc |= my_version\u00c40\u00dc ]]\n        stream_size |= sizeof(z_stream)) \u00e4\n\treturn Z_VERSION_ERROR;\n    \u00fc\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n\n    strm->msg = Z_NULL;\n    if (strm->zalloc == Z_NULL) \u00e4\n\tstrm->zalloc = zcalloc;\n\tstrm->opaque = (voidpf)0;\n    \u00fc\n    if (strm->zfree == Z_NULL) strm->zfree = zcfree;\n\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#ifdef FASTEST\n    level = 1;\n#endif\n\n    if (windowBits < 0) \u00e4 /* undocumented feature: suppress zlib header */\n        noheader = 1;\n        windowBits = -windowBits;\n    \u00fc\n    if (memLevel < 1 ]] memLevel > MAX_MEM_LEVEL ]] method |= Z_DEFLATED ]]\n        windowBits < 9 ]] windowBits > 15 ]] level < 0 ]] level > 9 ]]\n\tstrategy < 0 ]] strategy > Z_HUFFMAN_ONLY) \u00e4\n        return Z_STREAM_ERROR;\n    \u00fc\n    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));\n    if (s == Z_NULL) return Z_MEM_ERROR;\n    strm->state = (struct internal_state FAR *)s;\n    s->strm = strm;\n\n    s->noheader = noheader;\n    s->w_bits = windowBits;\n    s->w_size = 1 << s->w_bits;\n    s->w_mask = s->w_size - 1;\n\n    s->hash_bits = memLevel + 7;\n    s->hash_size = 1 << s->hash_bits;\n    s->hash_mask = s->hash_size - 1;\n    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);\n\n    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));\n    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));\n    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));\n\n    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    s->pending_buf = (uchf *) overlay;\n    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\n\n    if (s->window == Z_NULL ]] s->prev == Z_NULL ]] s->head == Z_NULL ]]\n        s->pending_buf == Z_NULL) \u00e4\n        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);\n        deflateEnd (strm);\n        return Z_MEM_ERROR;\n    \u00fc\n    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n    s->level = level;\n    s->strategy = strategy;\n    s->method = (Byte)method;\n\n    return deflateReset(strm);\n\u00fc\n\n/* ========================================================================= */\nint ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n    z_streamp strm;\n    const Bytef *dictionary;\n    uInt  dictLength;\n\u00e4\n    deflate_state *s;\n    uInt length = dictLength;\n    uInt n;\n    IPos hash_head = 0;\n\n    if (strm == Z_NULL ]] strm->state == Z_NULL ]] dictionary == Z_NULL ]]\n        strm->state->status |= INIT_STATE) return Z_STREAM_ERROR;\n\n    s = strm->state;\n    strm->adler = adler32(strm->adler, dictionary, dictLength);\n\n    if (length < MIN_MATCH) return Z_OK;\n    if (length > MAX_DIST(s)) \u00e4\n\tlength = MAX_DIST(s);\n#ifndef USE_DICT_HEAD\n\tdictionary += dictLength - length; /* use the tail of the dictionary */\n#endif\n    \u00fc\n    zmemcpy(s->window, dictionary, length);\n    s->strstart = length;\n    s->block_start = (long)length;\n\n    /* Insert all strings in the hash table (except for the last two bytes).\n     * s->lookahead stays null, so s->ins_h will be recomputed at the next\n     * call of fill_window.\n     */\n    s->ins_h = s->window\u00c40\u00dc;\n    UPDATE_HASH(s, s->ins_h, s->window\u00c41\u00dc);\n    for (n = 0; n <= length - MIN_MATCH; n++) \u00e4\n\tINSERT_STRING(s, n, hash_head);\n    \u00fc\n    if (hash_head) hash_head = 0;  /* to make compiler happy */\n    return Z_OK;\n\u00fc\n\n/* ========================================================================= */\nint ZEXPORT deflateReset (strm)\n    z_streamp strm;\n\u00e4\n    deflate_state *s;\n\n    if (strm == Z_NULL ]] strm->state == Z_NULL ]]\n        strm->zalloc == Z_NULL ]] strm->zfree == Z_NULL) return Z_STREAM_ERROR;\n\n    strm->total_in = strm->total_out = 0;\n    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */\n    strm->data_type = Z_UNKNOWN;\n\n    s = (deflate_state *)strm->state;\n    s->pending = 0;\n    s->pending_out = s->pending_buf;\n\n    if (s->noheader < 0) \u00e4\n        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */\n    \u00fc\n    s->status = s->noheader ? BUSY_STATE : INIT_STATE;\n    strm->adler = 1;\n    s->last_flush = Z_NO_FLUSH;\n\n    _tr_init(s);\n    lm_init(s);\n\n    return Z_OK;\n\u00fc\n\n/* ========================================================================= */\nint ZEXPORT deflateParams(strm, level, strategy)\n    z_streamp strm;\n    int level;\n    int strategy;\n\u00e4\n    deflate_state *s;\n    compress_func func;\n    int err = Z_OK;\n\n    if (strm == Z_NULL ]] strm->state == Z_NULL) return Z_STREAM_ERROR;\n    s = strm->state;\n\n    if (level == Z_DEFAULT_COMPRESSION) \u00e4\n\tlevel = 6;\n    \u00fc\n    if (level < 0 ]] level > 9 ]] strategy < 0 ]] strategy > Z_HUFFMAN_ONLY) \u00e4\n\treturn Z_STREAM_ERROR;\n    \u00fc\n    func = configuration_table\u00c4s->level\u00dc.func;\n\n    if (func |= configuration_table\u00c4level\u00dc.func && strm->total_in |= 0) \u00e4\n\t/* Flush the last buffer: */\n\terr = deflate(strm, Z_PARTIAL_FLUSH);\n    \u00fc\n    if (s->level |= level) \u00e4\n\ts->level = level;\n\ts->max_lazy_match   = configuration_table\u00c4level\u00dc.max_lazy;\n\ts->good_match       = configuration_table\u00c4level\u00dc.good_length;\n\ts->nice_match       = configuration_table\u00c4level\u00dc.nice_length;\n\ts->max_chain_length = configuration_table\u00c4level\u00dc.max_chain;\n    \u00fc\n    s->strategy = strategy;\n    return err;\n\u00fc\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nlocal void putShortMSB (s, b)\n    deflate_state *s;\n    uInt b;\n\u00e4\n    put_byte(s, (Byte)(b >> 8));\n    put_byte(s, (Byte)(b & 0xff));\n\u00fc\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->next_out buffer and copying into it.\n * (See also read_buf()).\n */\nlocal void flush_pending(strm)\n    z_streamp strm;\n\u00e4\n    unsigned len = strm->state->pending;\n\n    if (len > strm->avail_out) len = strm->avail_out;\n    if (len == 0) return;\n\n    zmemcpy(strm->next_out, strm->state->pending_out, len);\n    strm->next_out  += len;\n    strm->state->pending_out  += len;\n    strm->total_out += len;\n    strm->avail_out  -= len;\n    strm->state->pending -= len;\n    if (strm->state->pending == 0) \u00e4\n        strm->state->pending_out = strm->state->pending_buf;\n    \u00fc\n\u00fc\n\n/* ========================================================================= */\nint ZEXPORT deflate (strm, flush)\n    z_streamp strm;\n    int flush;\n\u00e4\n    int old_flush; /* value of flush param for previous deflate call */\n    deflate_state *s;\n\n    if (strm == Z_NULL ]] strm->state == Z_NULL ]]\n\tflush > Z_FINISH ]] flush < 0) \u00e4\n        return Z_STREAM_ERROR;\n    \u00fc\n    s = strm->state;\n\n    if (strm->next_out == Z_NULL ]]\n        (strm->next_in == Z_NULL && strm->avail_in |= 0) ]]\n\t(s->status == FINISH_STATE && flush |= Z_FINISH)) \u00e4\n        ERR_RETURN(strm, Z_STREAM_ERROR);\n    \u00fc\n    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);\n\n    s->strm = strm; /* just in case */\n    old_flush = s->last_flush;\n    s->last_flush = flush;\n\n    /* Write the zlib header */\n    if (s->status == INIT_STATE) \u00e4\n\n        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n        uInt level_flags = (s->level-1) >> 1;\n\n        if (level_flags > 3) level_flags = 3;\n        header ]= (level_flags << 6);\n\tif (s->strstart |= 0) header ]= PRESET_DICT;\n        header += 31 - (header % 31);\n\n        s->status = BUSY_STATE;\n        putShortMSB(s, header);\n\n\t/* Save the adler32 of the preset dictionary: */\n\tif (s->strstart |= 0) \u00e4\n\t    putShortMSB(s, (uInt)(strm->adler >> 16));\n\t    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n\t\u00fc\n\tstrm->adler = 1L;\n    \u00fc\n\n    /* Flush as much pending output as possible */\n    if (s->pending |= 0) \u00e4\n        flush_pending(strm);\n        if (strm->avail_out == 0) \u00e4\n\t    /* Since avail_out is 0, deflate will be called again with\n\t     * more output space, but possibly with both pending and\n\t     * avail_in equal to zero. There won't be anything to do,\n\t     * but this is not an error situation so make sure we\n\t     * return OK instead of BUF_ERROR at next call of deflate:\n             */\n\t    s->last_flush = -1;\n\t    return Z_OK;\n\t\u00fc\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUFF_ERROR.\n     */\n    \u00fc else if (strm->avail_in == 0 && flush <= old_flush &&\n\t       flush |= Z_FINISH) \u00e4\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    \u00fc\n\n    /* User must not provide more input after the first FINISH: */\n    if (s->status == FINISH_STATE && strm->avail_in |= 0) \u00e4\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    \u00fc\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm->avail_in |= 0 ]] s->lookahead |= 0 ]]\n        (flush |= Z_NO_FLUSH && s->status |= FINISH_STATE)) \u00e4\n        block_state bstate;\n\n\tbstate = (*(configuration_table\u00c4s->level\u00dc.func))(s, flush);\n\n        if (bstate == finish_started ]] bstate == finish_done) \u00e4\n            s->status = FINISH_STATE;\n        \u00fc\n        if (bstate == need_more ]] bstate == finish_started) \u00e4\n\t    if (strm->avail_out == 0) \u00e4\n\t        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n\t    \u00fc\n\t    return Z_OK;\n\t    /* If flush |= Z_NO_FLUSH && avail_out == 0, the next call\n\t     * of deflate should use the same flush parameter to make sure\n\t     * that the flush is complete. So we don't have to output an\n\t     * empty block here, this will be done at next call. This also\n\t     * ensures that for a very small output buffer, we emit at most\n\t     * one empty block.\n\t     */\n\t\u00fc\n        if (bstate == block_done) \u00e4\n            if (flush == Z_PARTIAL_FLUSH) \u00e4\n                _tr_align(s);\n            \u00fc else \u00e4 /* FULL_FLUSH or SYNC_FLUSH */\n                _tr_stored_block(s, (char*)0, 0L, 0);\n                /* For a full flush, this empty block will be recognized\n                 * as a special marker by inflate_sync().\n                 */\n                if (flush == Z_FULL_FLUSH) \u00e4\n                    CLEAR_HASH(s);             /* forget history */\n                \u00fc\n            \u00fc\n            flush_pending(strm);\n\t    if (strm->avail_out == 0) \u00e4\n\t      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n\t      return Z_OK;\n\t    \u00fc\n        \u00fc\n    \u00fc\n    Assert(strm->avail_out > 0, \"bug2\");\n\n    if (flush |= Z_FINISH) return Z_OK;\n    if (s->noheader) return Z_STREAM_END;\n\n    /* Write the zlib trailer (adler32) */\n    putShortMSB(s, (uInt)(strm->adler >> 16));\n    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    s->noheader = -1; /* write the trailer only once| */\n    return s->pending |= 0 ? Z_OK : Z_STREAM_END;\n\u00fc\n\n/* ========================================================================= */\nint ZEXPORT deflateEnd (strm)\n    z_streamp strm;\n\u00e4\n    int status;\n\n    if (strm == Z_NULL ]] strm->state == Z_NULL) return Z_STREAM_ERROR;\n\n    status = strm->state->status;\n    if (status |= INIT_STATE && status |= BUSY_STATE &&\n\tstatus |= FINISH_STATE) \u00e4\n      return Z_STREAM_ERROR;\n    \u00fc\n\n    /* Deallocate in reverse order of allocations: */\n    TRY_FREE(strm, strm->state->pending_buf);\n    TRY_FREE(strm, strm->state->head);\n    TRY_FREE(strm, strm->state->prev);\n    TRY_FREE(strm, strm->state->window);\n\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n\n    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n\u00fc\n\n/* =========================================================================\n * Copy the source state to the destination state.\n * To simplify the source, this is not supported for 16-bit MSDOS (which\n * doesn't have enough memory anyway to duplicate compression states).\n */\nint ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n\u00e4\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n\n\n    if (source == Z_NULL ]] dest == Z_NULL ]] source->state == Z_NULL) \u00e4\n        return Z_STREAM_ERROR;\n    \u00fc\n\n    ss = source->state;\n\n    *dest = *source;\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    *ds = *ss;\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n\n    if (ds->window == Z_NULL ]] ds->prev == Z_NULL ]] ds->head == Z_NULL ]]\n        ds->pending_buf == Z_NULL) \u00e4\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    \u00fc\n    /* following zmemcpy do not work for 16-bit MSDOS */\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif\n\u00fc\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->next_in buffer and copying from it.\n * (See also flush_pending()).\n */\nlocal int read_buf(strm, buf, size)\n    z_streamp strm;\n    Bytef *buf;\n    unsigned size;\n\u00e4\n    unsigned len = strm->avail_in;\n\n    if (len > size) len = size;\n    if (len == 0) return 0;\n\n    strm->avail_in  -= len;\n\n    if (|strm->state->noheader) \u00e4\n        strm->adler = adler32(strm->adler, strm->next_in, len);\n    \u00fc\n    zmemcpy(buf, strm->next_in, len);\n    strm->next_in  += len;\n    strm->total_in += len;\n\n    return (int)len;\n\u00fc\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nlocal void lm_init (s)\n    deflate_state *s;\n\u00e4\n    s->window_size = (ulg)2L*s->w_size;\n\n    CLEAR_HASH(s);\n\n    /* Set the default configuration parameters:\n     */\n    s->max_lazy_match   = configuration_table\u00c4s->level\u00dc.max_lazy;\n    s->good_match       = configuration_table\u00c4s->level\u00dc.good_length;\n    s->nice_match       = configuration_table\u00c4s->level\u00dc.nice_length;\n    s->max_chain_length = configuration_table\u00c4s->level\u00dc.max_chain;\n\n    s->strstart = 0;\n    s->block_start = 0L;\n    s->lookahead = 0;\n    s->match_length = s->prev_length = MIN_MATCH-1;\n    s->match_available = 0;\n    s->ins_h = 0;\n#ifdef ASMV\n    match_init(); /* initialize the asm code */\n#endif\n\u00fc\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\n#ifndef ASMV\n/* For 80x86 and 680x0, an optimized version will be provided in match.asm or\n * match.S. The code will be functionally equivalent.\n */\n#ifndef FASTEST\nlocal uInt longest_match(s, cur_match)\n    deflate_state *s;\n    IPos cur_match;                             /* current match */\n\u00e4\n    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                       /* matched string */\n    register int len;                           /* length of current match */\n    int best_len = s->prev_length;              /* best match length so far */\n    int nice_match = s->nice_match;             /* stop if match long enough */\n    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n        s->strstart - (IPos)MAX_DIST(s) : NIL;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n    Posf *prev = s->prev;\n    uInt wmask = s->w_mask;\n\n#ifdef UNALIGNED_OK\n    /* Compare two bytes at a time. Note: this is not always beneficial.\n     * Try with and without -DUNALIGNED_OK to check.\n     */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n    register ush scan_start = *(ushf*)scan;\n    register ush scan_end   = *(ushf*)(scan+best_len-1);\n#else\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n    register Byte scan_end1  = scan\u00c4best_len-1\u00dc;\n    register Byte scan_end   = scan\u00c4best_len\u00dc;\n#endif\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    /* Do not waste too much time if we already have a good match: */\n    if (s->prev_length >= s->good_match) \u00e4\n        chain_length >>= 2;\n    \u00fc\n    /* Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     */\n    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n\n    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    do \u00e4\n        Assert(cur_match < s->strstart, \"no future\");\n        match = s->window + cur_match;\n\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2:\n         */\n#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n        /* This code assumes sizeof(unsigned short) == 2. Do not use\n         * UNALIGNED_OK if your compiler uses a different size.\n         */\n        if (*(ushf*)(match+best_len-1) |= scan_end ]]\n            *(ushf*)match |= scan_start) continue;\n\n        /* It is not necessary to compare scan\u00c42\u00dc and match\u00c42\u00dc since they are\n         * always equal when the other bytes match, given that the hash keys\n         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n         * lookahead only every 4th comparison; the 128th check will be made\n         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n         * necessary to put more guard bytes at the end of the window, or\n         * to check more often for insufficient lookahead.\n         */\n        Assert(scan\u00c42\u00dc == match\u00c42\u00dc, \"scan\u00c42\u00dc?\");\n        scan++, match++;\n        do \u00e4\n        \u00fc while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 scan < strend);\n        /* The funny \"do \u00e4\u00fc\" generates better code on most compilers */\n\n        /* Here, scan <= window+strstart+257 */\n        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        if (*scan == *match) scan++;\n\n        len = (MAX_MATCH - 1) - (int)(strend-scan);\n        scan = strend - (MAX_MATCH-1);\n\n#else /* UNALIGNED_OK */\n\n        if (match\u00c4best_len\u00dc   |= scan_end  ]]\n            match\u00c4best_len-1\u00dc |= scan_end1 ]]\n            *match            |= *scan     ]]\n            *++match          |= scan\u00c41\u00dc)      continue;\n\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan\u00c42\u00dc and match\u00c42\u00dc since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n        scan += 2, match++;\n        Assert(*scan == *match, \"match\u00c42\u00dc?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n        do \u00e4\n        \u00fc while (*++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 scan < strend);\n\n        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n        len = MAX_MATCH - (int)(strend - scan);\n        scan = strend - MAX_MATCH;\n\n#endif /* UNALIGNED_OK */\n\n        if (len > best_len) \u00e4\n            s->match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) break;\n#ifdef UNALIGNED_OK\n            scan_end = *(ushf*)(scan+best_len-1);\n#else\n            scan_end1  = scan\u00c4best_len-1\u00dc;\n            scan_end   = scan\u00c4best_len\u00dc;\n#endif\n        \u00fc\n    \u00fc while ((cur_match = prev\u00c4cur_match & wmask\u00dc) > limit\n             && --chain_length |= 0);\n\n    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n    return s->lookahead;\n\u00fc\n\n#else /* FASTEST */\n/* ---------------------------------------------------------------------------\n * Optimized version for level == 1 only\n */\nlocal uInt longest_match(s, cur_match)\n    deflate_state *s;\n    IPos cur_match;                             /* current match */\n\u00e4\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                       /* matched string */\n    register int len;                           /* length of current match */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    Assert(cur_match < s->strstart, \"no future\");\n\n    match = s->window + cur_match;\n\n    /* Return failure if the match length is less than 2:\n     */\n    if (match\u00c40\u00dc |= scan\u00c40\u00dc ]] match\u00c41\u00dc |= scan\u00c41\u00dc) return MIN_MATCH-1;\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan\u00c42\u00dc and match\u00c42\u00dc since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2, match += 2;\n    Assert(*scan == *match, \"match\u00c42\u00dc?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do \u00e4\n    \u00fc while (*++scan == *++match && *++scan == *++match &&\n\t     *++scan == *++match && *++scan == *++match &&\n\t     *++scan == *++match && *++scan == *++match &&\n\t     *++scan == *++match && *++scan == *++match &&\n\t     scan < strend);\n\n    Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (int)(strend - scan);\n\n    if (len < MIN_MATCH) return MIN_MATCH - 1;\n\n    s->match_start = cur_match;\n    return len <= s->lookahead ? len : s->lookahead;\n\u00fc\n#endif /* FASTEST */\n#endif /* ASMV */\n\n#ifdef DEBUG\n/* ===========================================================================\n * Check that the match at match_start is indeed a match.\n */\nlocal void check_match(s, start, match, length)\n    deflate_state *s;\n    IPos start, match;\n    int length;\n\u00e4\n    /* check that the match is indeed a match */\n    if (zmemcmp(s->window + match,\n                s->window + start, length) |= EQUAL) \u00e4\n        fprintf(stderr, \" start %u, match %u, length %d\u00d6n\",\n\t\tstart, match, length);\n        do \u00e4\n\t    fprintf(stderr, \"%c%c\", s->window\u00c4match++\u00dc, s->window\u00c4start++\u00dc);\n\t\u00fc while (--length |= 0);\n        z_error(\"invalid match\");\n    \u00fc\n    if (z_verbose > 1) \u00e4\n        fprintf(stderr,\"\u00d6\u00d6\u00c4%d,%d\u00dc\", start-match, length);\n        do \u00e4 putc(s->window\u00c4start++\u00dc, stderr); \u00fc while (--length |= 0);\n    \u00fc\n\u00fc\n#else\n#  define check_match(s, start, match, length)\n#endif\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nlocal void fill_window(s)\n    deflate_state *s;\n\u00e4\n    register unsigned n, m;\n    register Posf *p;\n    unsigned more;    /* Amount of free space at the end of the window. */\n    uInt wsize = s->w_size;\n\n    do \u00e4\n        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n\n        /* Deal with |\u00a7#$% 64K limit: */\n        if (more == 0 && s->strstart == 0 && s->lookahead == 0) \u00e4\n            more = wsize;\n\n        \u00fc else if (more == (unsigned)(-1)) \u00e4\n            /* Very unlikely, but possible on 16 bit machine if strstart == 0\n             * and lookahead == 1 (input done one byte at time)\n             */\n            more--;\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        \u00fc else if (s->strstart >= wsize+MAX_DIST(s)) \u00e4\n\n            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);\n            s->match_start -= wsize;\n            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */\n            s->block_start -= (long) wsize;\n\n            /* Slide the hash table (could be avoided with 32 bit values\n               at the expense of memory usage). We slide even when level == 0\n               to keep the hash table consistent if we switch back to level > 0\n               later. (Using level 0 permanently is not an optimal usage of\n               zlib, so we don't care about this pathological case.)\n             */\n\t    n = s->hash_size;\n\t    p = &s->head\u00c4n\u00dc;\n\t    do \u00e4\n\t\tm = *--p;\n\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n\t    \u00fc while (--n);\n\n\t    n = wsize;\n#ifndef FASTEST\n\t    p = &s->prev\u00c4n\u00dc;\n\t    do \u00e4\n\t\tm = *--p;\n\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n\t\t/* If n is not on any hash chain, prev\u00c4n\u00dc is garbage but\n\t\t * its value will never be used.\n\t\t */\n\t    \u00fc while (--n);\n#endif\n            more += wsize;\n        \u00fc\n        if (s->strm->avail_in == 0) return;\n\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        Assert(more >= 2, \"more < 2\");\n\n        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n        s->lookahead += n;\n\n        /* Initialize the hash value now that we have some input: */\n        if (s->lookahead >= MIN_MATCH) \u00e4\n            s->ins_h = s->window\u00c4s->strstart\u00dc;\n            UPDATE_HASH(s, s->ins_h, s->window\u00c4s->strstart+1\u00dc);\n#if MIN_MATCH |= 3\n            Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n        \u00fc\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n    \u00fc while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in |= 0);\n\u00fc\n\n/* ===========================================================================\n * Flush the current block, with given end-of-file flag.\n * IN assertion: strstart is set to the end of the current match.\n */\n#define FLUSH_BLOCK_ONLY(s, eof) \u00e4 \u00d6\n   _tr_flush_block(s, (s->block_start >= 0L ? \u00d6\n                   (charf *)&s->window\u00c4(unsigned)s->block_start\u00dc : \u00d6\n                   (charf *)Z_NULL), \u00d6\n\t\t(ulg)((long)s->strstart - s->block_start), \u00d6\n\t\t(eof)); \u00d6\n   s->block_start = s->strstart; \u00d6\n   flush_pending(s->strm); \u00d6\n   Tracev((stderr,\"\u00c4FLUSH\u00dc\")); \u00d6\n\u00fc\n\n/* Same but force premature exit if necessary. */\n#define FLUSH_BLOCK(s, eof) \u00e4 \u00d6\n   FLUSH_BLOCK_ONLY(s, eof); \u00d6\n   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \u00d6\n\u00fc\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nlocal block_state deflate_stored(s, flush)\n    deflate_state *s;\n    int flush;\n\u00e4\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n     * to pending_buf_size, and each stored block has a 5 byte header:\n     */\n    ulg max_block_size = 0xffff;\n    ulg max_start;\n\n    if (max_block_size > s->pending_buf_size - 5) \u00e4\n        max_block_size = s->pending_buf_size - 5;\n    \u00fc\n\n    /* Copy as much as possible from input to output: */\n    for (;;) \u00e4\n        /* Fill the window as much as possible: */\n        if (s->lookahead <= 1) \u00e4\n\n            Assert(s->strstart < s->w_size+MAX_DIST(s) ]]\n\t\t   s->block_start >= (long)s->w_size, \"slide too late\");\n\n            fill_window(s);\n            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;\n\n            if (s->lookahead == 0) break; /* flush the current block */\n        \u00fc\n\tAssert(s->block_start >= 0L, \"block gone\");\n\n\ts->strstart += s->lookahead;\n\ts->lookahead = 0;\n\n\t/* Emit a stored block if pending_buf will be full: */\n \tmax_start = s->block_start + max_block_size;\n        if (s->strstart == 0 ]] (ulg)s->strstart >= max_start) \u00e4\n\t    /* strstart == 0 is possible when wraparound on 16-bit machine */\n\t    s->lookahead = (uInt)(s->strstart - max_start);\n\t    s->strstart = (uInt)max_start;\n            FLUSH_BLOCK(s, 0);\n\t\u00fc\n\t/* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) \u00e4\n            FLUSH_BLOCK(s, 0);\n\t\u00fc\n    \u00fc\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n\u00fc\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nlocal block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n\u00e4\n    IPos hash_head = NIL; /* head of the hash chain */\n    int bflush;           /* set if current block must be flushed */\n\n    for (;;) \u00e4\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) \u00e4\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) \u00e4\n\t        return need_more;\n\t    \u00fc\n            if (s->lookahead == 0) break; /* flush the current block */\n        \u00fc\n\n        /* Insert the string window\u00c4strstart .. strstart+2\u00dc in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        if (s->lookahead >= MIN_MATCH) \u00e4\n            INSERT_STRING(s, s->strstart, hash_head);\n        \u00fc\n\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head |= NIL && s->strstart - hash_head <= MAX_DIST(s)) \u00e4\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            if (s->strategy |= Z_HUFFMAN_ONLY) \u00e4\n                s->match_length = longest_match (s, hash_head);\n            \u00fc\n            /* longest_match() sets match_start */\n        \u00fc\n        if (s->match_length >= MIN_MATCH) \u00e4\n            check_match(s, s->strstart, s->match_start, s->match_length);\n\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n\n            s->lookahead -= s->match_length;\n\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) \u00e4\n                s->match_length--; /* string at strstart already in hash table */\n                do \u00e4\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     * always MIN_MATCH bytes ahead.\n                     */\n                \u00fc while (--s->match_length |= 0);\n                s->strstart++;\n            \u00fc else\n#endif\n\t    \u00e4\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window\u00c4s->strstart\u00dc;\n                UPDATE_HASH(s, s->ins_h, s->window\u00c4s->strstart+1\u00dc);\n#if MIN_MATCH |= 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n                 * matter since it will be recomputed at next deflate call.\n                 */\n            \u00fc\n        \u00fc else \u00e4\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\", s->window\u00c4s->strstart\u00dc));\n            _tr_tally_lit (s, s->window\u00c4s->strstart\u00dc, bflush);\n            s->lookahead--;\n            s->strstart++;\n        \u00fc\n        if (bflush) FLUSH_BLOCK(s, 0);\n    \u00fc\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n\u00fc\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nlocal block_state deflate_slow(s, flush)\n    deflate_state *s;\n    int flush;\n\u00e4\n    IPos hash_head = NIL;    /* head of hash chain */\n    int bflush;              /* set if current block must be flushed */\n\n    /* Process the input block. */\n    for (;;) \u00e4\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) \u00e4\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) \u00e4\n\t        return need_more;\n\t    \u00fc\n            if (s->lookahead == 0) break; /* flush the current block */\n        \u00fc\n\n        /* Insert the string window\u00c4strstart .. strstart+2\u00dc in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        if (s->lookahead >= MIN_MATCH) \u00e4\n            INSERT_STRING(s, s->strstart, hash_head);\n        \u00fc\n\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        s->prev_length = s->match_length, s->prev_match = s->match_start;\n        s->match_length = MIN_MATCH-1;\n\n        if (hash_head |= NIL && s->prev_length < s->max_lazy_match &&\n            s->strstart - hash_head <= MAX_DIST(s)) \u00e4\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            if (s->strategy |= Z_HUFFMAN_ONLY) \u00e4\n                s->match_length = longest_match (s, hash_head);\n            \u00fc\n            /* longest_match() sets match_start */\n\n            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ]]\n                 (s->match_length == MIN_MATCH &&\n                  s->strstart - s->match_start > TOO_FAR))) \u00e4\n\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                s->match_length = MIN_MATCH-1;\n            \u00fc\n        \u00fc\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) \u00e4\n            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n\n            check_match(s, s->strstart-1, s->prev_match, s->prev_length);\n\n            _tr_tally_dist(s, s->strstart -1 - s->prev_match,\n\t\t\t   s->prev_length - MIN_MATCH, bflush);\n\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             */\n            s->lookahead -= s->prev_length-1;\n            s->prev_length -= 2;\n            do \u00e4\n                if (++s->strstart <= max_insert) \u00e4\n                    INSERT_STRING(s, s->strstart, hash_head);\n                \u00fc\n            \u00fc while (--s->prev_length |= 0);\n            s->match_available = 0;\n            s->match_length = MIN_MATCH-1;\n            s->strstart++;\n\n            if (bflush) FLUSH_BLOCK(s, 0);\n\n        \u00fc else if (s->match_available) \u00e4\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            Tracevv((stderr,\"%c\", s->window\u00c4s->strstart-1\u00dc));\n\t    _tr_tally_lit(s, s->window\u00c4s->strstart-1\u00dc, bflush);\n\t    if (bflush) \u00e4\n                FLUSH_BLOCK_ONLY(s, 0);\n            \u00fc\n            s->strstart++;\n            s->lookahead--;\n            if (s->strm->avail_out == 0) return need_more;\n        \u00fc else \u00e4\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            s->match_available = 1;\n            s->strstart++;\n            s->lookahead--;\n        \u00fc\n    \u00fc\n    Assert (flush |= Z_NO_FLUSH, \"no flush?\");\n    if (s->match_available) \u00e4\n        Tracevv((stderr,\"%c\", s->window\u00c4s->strstart-1\u00dc));\n        _tr_tally_lit(s, s->window\u00c4s->strstart-1\u00dc, bflush);\n        s->match_available = 0;\n    \u00fc\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSSCLAS": {"ttr": 1351, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"dssclas.hpp\"\n#include \"dssmain.hpp\"\n#include \"jobenv.hpp\"\n\n\nchar \t\t\tDSS::ddnamelist\u00c448\u00dc;\nchar \t\t\tDSS::pagenumber\u00c44\u00dc;\naddress \tDSS::uim = NULL;\n\nDSSPARM * makeDSSPARM(size_t l,void * v)\n\u00e4\n DSSPARM * rc = (DSSPARM *)malloc(l+2);\n rc->length = short(l);\n memcpy(rc->data,v,l);\n return rc;\n\u00fc\n\n\nDSS::DSS(char * argv,DssJob * j)\n\u00e4\n        JOBENV::DEBUG(1,\"DSS construct\");\n        adrdssu = load(ADRDSSU);\n        dssparm\u00c40\u00dc = makeDSSPARM(strlen(argv),(address)argv);\n        memset(ddnamelist,0,sizeof(ddnamelist));\n        memcpy(ddnamelist+32,\"SYSIN   \",8);\n        memcpy(ddnamelist+40,\"SYSPRINT\",8);\n        dssparm\u00c41\u00dc = makeDSSPARM(sizeof(ddnamelist),(address)ddnamelist);\n        memcpy(pagenumber,\"0001\",4);\n        dssparm\u00c42\u00dc = makeDSSPARM(sizeof(pagenumber),(address)pagenumber);\n        uim        = (address)UIMASM;\n\t\t    uim        = address(0x80000000 +long(uim));\n        dssparm\u00c43\u00dc = makeDSSPARM(4,(address)&uim);\n        address pthis =(address) this;\n        dssparm\u00c44\u00dc = makeDSSPARM(4,(address)&pthis);\n        dssparm\u00c44\u00dc = (DSSPARM *)(0x80000000 +long(dssparm\u00c44\u00dc));\n        function   = invalid;\n        job        = j;\n\u00fc\n\nDSS::\u00dfDSS()\n\u00e4\n        JOBENV::DEBUG(1,\"DSS destruct\");\n        unload(ADRDSSU);\n        for(int i =0;i<5;i++)\n                free(dssparm\u00c4i\u00dc);\n        exit(0);\n\u00fc\n\nint DSS::run(DssJob * j)\n\u00e4\n        JOBENV::DEBUG(1,\"DSS run\");\n        job = j;\n        return (call(adrdssu,dssparm));\n\u00fc\n\nadrdssu_address DSS::load(const char * name)\n\u00e4\n\t\t\t\tadrdssu_address rc = 0;\n        return rc;\n\u00fc\n\nvoid DSS::unload(const char * name)\n\u00e4\n\n\u00fc\n\nint DSS::call(address a,DSSPARM **p)\n\u00e4\nint rc = 0;\n\t\t\t\trc = UIMASM(dssparm\u00c40\u00dc,dssparm\u00c41\u00dc,dssparm\u00c42\u00dc,dssparm\u00c43\u00dc,dssparm\u00c44\u00dc);\n        return rc;\n\u00fc\n\n\nvoid DSS::exit(int rc)\n\u00e4\n\t\t\texit(rc);\n\u00fc\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DSSDB": {"ttr": 1391, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include \"isisdef.h\"\n#include \"merror.hpp\"\n#include \"mvsbase.hpp\"\n#include \"rarcsql.hpp\" //szm20050125\n#include \"mchain.hpp\"\n#include \"jobenv.hpp\"\n#include \"dssmain.hpp\"\n#include \"misc.hpp\"\n#include \"subtask.hpp\"\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <strings.h>\n#define  _XOPEN_SOURCE_EXTENDED 1\n\n#define assign(t,f) \u00d6\n\u00e4  t.len = \u00d6\n  short(min(sizeof(t.arr),strlen((char *)f))); \u00d6\n  strncpy(t.arr,(char *)f,t.len); \u00d6\n\u00fc\n\n#define PUTDB2(n) \u00d6\n\tif (fileDB2)  \u00d6\n\tfprintf(fileDB2,\" %s:%*.*s\u00d6n\",#n,n.len,n.len,n.arr);\n\n\n//#include \"pardb2a.h\"\n// this header will be fix included\n\n#ifndef O_BINARY\n\t#define O_BINARY 0\n#endif\n\n#define assign(t,f) \u00d6\n\u00e4                   \u00d6\n  t.len = \u00d6\n  short(min(sizeof(t.arr),strlen((char *)f))); \u00d6\n  strncpy(t.arr,(char *)f,t.len); \u00d6\n  \u00fc\n\nstatic const char fullQuery\u00c4\u00dc =\n\" SELECT * FROM DSSDATASETS A \"\n\" WHERE ( %m% ) AND \"\n\" ( DATE(KEY) <= DATE('%d%') ) AND \"\n\" ( \"\n\" A.KEY =  \"\n\" (SELECT MAX(B.KEY) FROM DSSDATASETS B WHERE A.DATASET = B.DATASET  \"\n\" AND DATE(B.KEY) <= DATE('%d%') ) \"\n\" ) \" ;\n\n\nEXEC SQL BEGIN DECLARE SECTION;\n#include \"dssdb.hpp\"\nEXEC SQL END DECLARE SECTION;\nEXEC SQL INCLUDE SQLDA;\nEXEC SQL INCLUDE SQLCA;\n#define SQLCA sqlca\n#define SQLDA sqlda\nstatic bool _useDB2()\n\u00e4\nif (getenv(KEYWORD_USEDB2) && strcasecmp(getenv(KEYWORD_USEDB2),\"NO\") == 0)\n\u00e4\n    char w\u00c4128\u00dc;\n    SQLINTERFACE::fileDB2 = fopen(genOpenName(KEYWORD_USEDB2_FILE,w),\"w\");\n    Msg(10000+1003)<<eol;\n    return false;\n\u00fc\nelse\n    return true;\n\u00fc\n\nchar *      SQLINTERFACE::plan        = strdup(getenv(KEYWORD_DB_PLAN));\nchar *      SQLINTERFACE::subsystem   = strdup(getenv(KEYWORD_DB_SUBSYS));\nchar *      SQLINTERFACE::dSql        = initDynamicSql();\nmCHAIN      DssJob::dssJobs;\nmCHAIN      SQLINTERFACE::tasks;\nbool        SQLINTERFACE::useDB2     = _useDB2();\nFILE *      SQLINTERFACE::fileDB2    =  NULL;\n\n\n\nERROR_MESSAGE * SQLINTERFACE::error_message = new ERROR_MESSAGE();\nSQLINTERFACE::SQLINTERFACE():mERROR()\n\u00e4\n  tryToConnect();\n\u00fc\n\nvoid SQLINTERFACE::tryToConnect()\n\u00e4\n\n\n  char t\u00c412\u00dc;\n  sprintf(t,\"%p\",getTCB());\n  if (tasks.search(t) == NULL)\n      tasks.addlast(new TcbARCHSQL(t,connectDB()));\n      JOBENV::DEBUG(1,t);\n\u00fc\n\nARCHSQL * SQLINTERFACE::connectDB()\n\u00e4\n      ARCHSQL * archsql = new ARCHSQL();\n      if (useDB2)\n      \u00e4\n      if (subsystem==NULL) return NULL;\n      ARCHSQL * archsql = new ARCHSQL();\n      archsql->setSubSystem(subsystem);\n      char _plan\u00c4\u00dc = \"        \";\n      memcpy(_plan,plan,strlen(plan));\n      archsql->setPlan(_plan);\n      if (NOT archsql->call(Connect))\n       markerror();\n      \u00fc\n      else\n      ARCHSQL * archsql = (ARCHSQL*)1;\n      error_message->error_len = short(data_dim*data_len);\n      if (useDB2)\n      Msg(10000+1000)<<subsystem<<plan<<tHEX(int(getTCB()))<<eol;\n      return archsql;\n\u00fc\n\nSQLINTERFACE::\u00dfSQLINTERFACE()\n\u00e4\n\u00fc\n\nvoid SQLINTERFACE::diag(char *t)\n\u00e4\n if (useDB2)\n \u00e4\n Msg(10000+1001)<<t<<SQLCODE<<(char *)(sqlca.sqlerrmc)<<eol;\n int rc = DSNTIAR(&sqlca,error_message,&data_len);\n if ( rc )\n  Msg(10000+9707)<<long(rc)<<eol;\n else\n \u00e4\n   for(int i = 0;i<data_dim;i++)\n   if (NOT mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len).isEmpty())\n      Msg(10000+9708)<<mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len)<<eol;\n \u00fc\n \u00fc\n //abort();//szm20090403 only message at DB error\n Msg(100000+9709)<<\"diag\"<<eol; //szm20090403 only message at DB error\n\u00fc\n\nint SQLINTERFACE::commit()\n\u00e4\ntryToConnect();\nif (useDB2)\n\u00e4\n  EXEC SQL COMMIT;\n\u00fc\n  return 1;\n\u00fc\n\nvoid SQLINTERFACE::Error(char * t,Error_Action a)\n\u00e4\n// if (a = Abort)//szm20090403 only message at DB error\n//    abort();   //szm20090403 only message at DB error\n Msg(100000+9709)<<\"error\"<<eol; //szm20090403 only message at DB error\n\n\u00fc\n\nstatic char * initDynamicSql()\n\u00e4\n  char b\u00c432000\u00dc;\n  char _genFileName\u00c41024\u00dc;\n  size_t o = 0;\n  FILE * sqlFile = NULL;\n  if (SQLINTERFACE::useDB2 && access(KEYWORD_SQLFILE,R_OK)==0)\n  sqlFile=  fopen(genOpenName(KEYWORD_SQLFILE,_genFileName),\"r\");\n  if (sqlFile)\n  while(fgets(b+o,sizeof(b)-o,sqlFile))\n  \u00e4\n    o = strchr(b+o,'\u00d6n')-b;\n    if (o>0) *(b+o) = 0;\n      else\n    break;\n  \u00fc\n  if (sqlFile)\n    fclose(sqlFile);\n  else\n    strcpy(b,fullQuery);\n  JOBENV::DEBUG(1,(char *)b);\n  char * rb = new char\u00c4strlen(b)+1\u00dc;\n  strcpy(rb,b);\n  return (rb);\n\u00fc\n\n//-------------------------------------------------------------------\n//-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\nDssJob::DssJob():\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==NULL)\n\u00e4\n   init();\n\u00fc\nelse\n\t\t fclose(f);\n\n\u00fc\n\nDssJob::DssJob(const char * d):\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==NULL)\n\u00e4\n   init();\n\u00fc\nelse\n\t fclose(f);\n strcpy(dataset.arr,d);\n dataset.len = strlen(d);\n\u00fc\nDssJob::DssJob(TIMESTAMP& ts):\nSQLINTERFACE(),\nchainE(ts.arr),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\n init();\n memcpy(t.arr,ts.arr,ts.len);\n t.len = ts.len;\n if (useDB2)\n \u00e4\n EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n EXEC SQL SELECT KEY, JOBNAME, JOBNUMBER, DATASET\n INTO\n :timestamp,\n :jobName,\n :jobNumber,\n :dataset\n FROM DSSJOBS WHERE KEY = :t;\n if (SQLCODE == 100)\n    markerror();\n \u00fc\n char * c;\n dataset.arr\u00c4sizeof(dataset.arr)-1\u00dc = 0;\n if ((c = strchr(dataset.arr,' ')))\n     *c = 0;\n return;\nSQLERROR:\n  diag(\"SELECT\");\n  markerror();\n\u00fc\n\n\nDssJob::\u00dfDssJob()\n\u00e4\n\u00fc\n\nvoid DssJob::init()\n\u00e4\n   memset(&timestamp,0,sizeof(timestamp));\n   assign(jobName,jobEnv->jobName);\n   assign(jobNumber,jobEnv->jobId);\n   assign(program,jobEnv->program);\n   datasetcount = 0;\n   memset(&joblog,0,sizeof(joblog));\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n   EXEC SQL SET :timestamp = CURRENT TIMESTAMP;\n   SQLERROR:\n   if (SQLCODE) diag(\"SET\");\n   \u00fc\n   else\n   \u00e4\n   time_t temp;\n   struct tm *timeptr;\n   temp = time(NULL);\n   timeptr = localtime(&temp);\n   timestamp.len = strftime(timestamp.arr,sizeof(timestamp.arr)-1,\"%Y-%m-%d-%H.%M.%S\", timeptr);\n   \u00fc\n   mvsSTRING _dataset;\n   _dataset = mvsSTRING(getenv(KEYWORD_PREFIX)) + \"/\" +\n             jobEnv->jobName + jobEnv->jobId +\n             mvsSTRING(timestamp.arr,timestamp.len);\n   dataset.len = short(_dataset.lengthOf());\n   JOBENV::DEBUG(1,(char *)_dataset);\n   memcpy(dataset.arr,(char *)_dataset,dataset.len+1);\n\u00fc\n\nint DssJob::insert()\n\u00e4\n   CHAINITER::reset();\n   DssDataset * ds;\n   DssDataset * dp;\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n   EXEC SQL INSERT INTO DSSJOBS\n    VALUES(:timestamp,\n           :jobName, :jobNumber, :program, :dataset, :joblog);\n   \u00fc\n   else\n   \u00e4\n     if (fileDB2)\n     fprintf(fileDB2,\"insert into DSSJOBS:\u00d6n\");\n     PUTDB2(jobName);\n     PUTDB2(jobNumber);\n     PUTDB2(program);\n     PUTDB2(dataset);\n     PUTDB2(joblog);\n    \u00fc\n\n   ds = (DssDataset *)CHAINITER::next();\n   while(ds)\n   \u00e4\n    if(NOT ds->insert())\n     Error(Msg(10000+1002)<<ds->dataset.arr<<eol,Abort);\n     dp = ds;\n     ds = (DssDataset *)CHAINITER::next();\n     mCHAIN::del(dp);\n     delete dp;\n   \u00fc\n  commit();\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSJOBS\");\n  markerror();\n  return 0;\n\u00fc\n\nstatic char today\u00c412\u00dc;\n\nint DssJob::query(mCHAIN *m,char * date)\n\u00e4\n   if (useDB2==false)\n\treturn 0;\n   CHAINITER iter(*m);\n   mvsSTRING like(\" \");\n   chainE * mask = iter.next();\n   if ( date == NULL )\n   \u00e4\n     date = today;\n     formatTime(today,sizeof(today),\"%d.%m.%Y\");\n     JOBENV::DEBUG(1,(char *)date);\n   \u00fc\n   int likeFlag = 0;\n   while(mask)\n   \u00e4\n      int i, j;\n      for(i=0, j=0;mask->chainEid\u00c4i\u00dc;i++)\n      \u00e4\n         if(mask->chainEid\u00c4i\u00dc NEQ '*')\n            mask->chainEid\u00c4j++\u00dc = mask->chainEid\u00c4i\u00dc;\n         else if (mask->chainEid\u00c4i+1\u00dc NEQ '*')\n         \u00e4\n            mask->chainEid\u00c4j++\u00dc = '%';\n            likeFlag = 1;\n         \u00fc\n       \u00fc\n       if (mask->chainEid\u00c4j-1\u00dc NEQ '%')\n           mask->chainEid\u00c4j++\u00dc = '%';\n      mask->chainEid\u00c4j\u00dc = 0;\n      like = like + \"A.DATASET LIKE '\"+mvsSTRING(mask->chainEid)+\"' \";\n      if (mask->next)\n         like = like + \" OR \";\n      mask = iter.next();\n   \u00fc\n   JOBENV::DEBUG(1,(char *)like);\n     \u00e4\n     char * p\u00c48\u00dc;\n     Msg(10000+122)<<dSql<<eol;\n     size_t l = strlen(dSql);\n     int j = 0;\n     for(int i = 0;i<l&&j<8;i++)\n       if (dSql\u00c4i\u00dc=='%' && dSql\u00c4i+2\u00dc == '%')\n         \u00e4\n         switch (dSql\u00c4i+1\u00dc)\n           \u00e4\n           case 'M':\n           case 'm': p\u00c4j++\u00dc = like;\n             break;\n           case 'D':\n           case 'd': p\u00c4j++\u00dc = date;\n             break;\n           default :\n             JOBENV::Error(Msg(10000+121)<<dSql\u00c4i\u00dc<<eol,JOBENV::Abort);\n           \u00fc\n           dSql\u00c4i+1\u00dc = 's';\n         strcpy(dSql+i+2,dSql+i+3);\n         l -= 2;\n         \u00fc\n       switch(j)\n         \u00e4\n         default:\n         case 0:\n         strcpy(dynamicSql.arr,dSql);\n         break;\n         case 1:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc);\n         break;\n         case 2:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc);\n         break;\n         case 3:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc);\n         break;\n         case 4:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc);\n         break;\n         case 5:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc);\n         break;\n         case 6:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc);\n         break;\n         case 7:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc,p\u00c46\u00dc);\n         break;\n         \u00fc\n     \u00fc\n   JOBENV::DEBUG(1,(char *)dynamicSql.arr);\n   Msg(10000+123)<<dynamicSql.arr<<eol;\n   dynamicSql.len =short(strlen(dynamicSql.arr));\n   tryToConnect();\n\t DssJob * job = NULL;\n   int fetchCount = 0;\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n   EXEC SQL PREPARE FULL_QUERY FROM :dynamicSql;\n   EXEC SQL DECLARE C_FULL_QUERY CURSOR FOR FULL_QUERY;\n   EXEC SQL OPEN C_FULL_QUERY;\n\n   for (;;)\n   \u00e4\n      EXEC SQL FETCH C_FULL_QUERY INTO\n      :record_key,\n      :record_job,\n      :record_dataset,\n      :record_volumes,\n      :record_size;\n      if (SQLCODE == 100) break;\n\n        if (job == NULL ]]\n         memcmp(job->timestamp.arr,record_job.arr,job->timestamp.len))\n    \u00e4\n         job = new DssJob((TIMESTAMP&)record_job);\n         dssJobs.addlast(job);\n         fetchCount++;\n        \u00fc\n        DssDataset * dataset = new DssDataset(job,\n                                        record_dataset.arr,\n                                        record_volumes.arr,\n                                        record_type,\n                                        record_size);\n   \u00fc\n   EXEC SQL CLOSE C_FULL_QUERY;\n   return fetchCount;\nSQLERROR:\n   diag(\"FULL QUERY\");\n   markerror();\n   return -1;\n\u00fc\n\nint DssJob::doWeNeed(const char * d)\n  \u00e4\n  CHAINITER iter(this);\n  DssDataset * ds =(DssDataset *)iter.next();\n  while (ds)\n    \u00e4\n    if (ds->compare(d))\n      return 1;\n    ds =(DssDataset *)iter.next();\n    \u00fc\n  return 0;\n  \u00fc\n\nint DssJob::allOnline()\n\u00e4\n char _genFileName\u00c41024\u00dc;\n  FILE *   restore = fopen(genOpenName(\"RESTORE\",_genFileName),\"wb\");\n  if (NOT restore)\n     JOBENV::Error(Msg(10000+110)<<\"RESTORE\"<<eol,JOBENV::Abort);\n  int rc = 1;\n  CHAINITER iter(dssJobs);\n  DssJob * job = (DssJob*)iter.next();\n  while (job)\n  \u00e4\n    int file = open(genOpenName(job->getDatasetName(),_genFileName),O_RDONLY+O_BINARY);\n    if (file < 0)\n    \u00e4\n       rc = 0;\n       JOBENV::Error(Msg(10000+120)<<job->getDatasetName()<<strerror(errno)\n         <<eol,JOBENV::Continue);\n       fprintf(restore,\"%s\u00d6n\",job->getDatasetName());\n    \u00fc\n    else\n       close(file);\n    job = (DssJob*)iter.next();\n  \u00fc\n  fclose(restore);\n  return rc;\n\u00fc\n\n\n//-------------------------------------------------------------------\n//-------------------------------------------------------------------\n//-------------------------------------------------------------------\n\nDssDataset::DssDataset(DssJob* j,char *n,char *v,int t,int s):\nSQLINTERFACE(),\nchainE(n),\njob(j)\n\u00e4\n   job->addlast(this);\n   dataset.len = min(strlen(n),sizeof(dataset.arr));\n   strncpy(dataset.arr,n,dataset.len);\n   dataset.arr\u00c4dataset.len\u00dc = 0;\n\n   volumes.len = min(strlen(v),sizeof(volumes.arr)-1);//szm20090403 max 6 volumes\n   strncpy(volumes.arr,v,volumes.len);\n   volumes.arr\u00c4volumes.len\u00dc = 0;\n   type = t;\n   recordsize = s;\n   JOBENV::DEBUG(1,\"Dataset construct\",n,v);\n\u00fc\n\nDssDataset::\u00dfDssDataset()\n\u00e4\n\u00fc\n\nint DssDataset::insert()\n\u00e4\n   tryToConnect();\n   memcpy(timestamp.arr,job->timestamp.arr,job->timestamp.len+1);\n   timestamp.len = job->timestamp.len;\n   JOBENV::DEBUG(1,\"Dataset insert:\",dataset.arr);\n   if (useDB2)\n   \u00e4\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n   EXEC SQL INSERT INTO DSSDATASETS\n   VALUES(CURRENT TIMESTAMP,\n   :timestamp,\n   :dataset,\n   :volumes,\n   :type,\n   :recordsize);\n   \u00fc\n   else\n   \u00e4\n   if (SQLINTERFACE::fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\"insert into DSSDATASETS:\u00d6n\");\n   PUTDB2(timestamp);\n   PUTDB2(dataset);\n   PUTDB2(volumes);\n   if (fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\" type:%d\u00d6n size:%d\u00d6n\",type,recordsize);\n   \u00fc\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSDATASETS\");\n  markerror();\n  return 0;\n\u00fc\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DSSFILE": {"ttr": 1355, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include \"isisdef.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#include <assert.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <unistd.h>\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n#include \"dssfile.hpp\"\n#include \"dssmain.hpp\"\n#include \"jobenv.hpp\"\n#include \"subtask.hpp\"\n#include \"msgmgr.hpp\"\n#include \"casmif.hpp\"\n\nint _edc_add_errno2 = setenv(\"_EDC_ADD_ERRNO2\",\"1\",1);\nstatic int compressMethod = (getenv(KEYWORD_COMPR)?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t atoi(getenv(KEYWORD_COMPR)):-1);\nstatic  size_t MAX_IOLENGTH  = (getenv(KEYWORD_MAXLENGTH))?atoi(getenv(KEYWORD_MAXLENGTH))*1024*1024:1024*1024*512;\n\nDSSFILE::DSSFILE(const char * n,DSSFILE_TYPE t,size_t max):\nmERROR(),\nfileName(n), type(t), buff_size(max)\n\t\u00e4\n\tfile    = NULL;\n\tcount = compressedCount = 0;\n\tseqNo = 0;\n\tbuff = (UCHAR *) malloc(max);\n\tif (buff == NULL)\n\t\tError(Msg(10000+1)<<short(max)<<eol,Abort);\n\tzStream = (z_streamp)malloc(sizeof(z_stream));\n\tmemset(zStream,0,sizeof(z_stream));\n\tfileName.strip();\n\tinit();\n\t\u00fc\n\nDSSFILE::\u00dfDSSFILE()\n\t\u00e4\n\tterm();\n\tif (zStream)\n\t\tfree(zStream);\n\tzStream = NULL;\n\tif (buff)\n\t\tfree(buff);\n\tbuff = NULL;\n\t\u00fc\n\nint DSSFILE::init()\n\t\u00e4\n\tchar _fileName\u00c41024\u00dc;\n\tchar _genFileName\u00c41024\u00dc;\n\tif (seqNo)\n\t\tsprintf(_fileName,\"%s.%d\",(char *)fileName,seqNo);\n\telse\n\t\tsprintf(_fileName,\"%s\",(char *)fileName);\n\tMsg(10000+13)<<_fileName<<eol;\n\tseqNo+=1;\n\n\tJOBENV::DEBUG(1,_fileName);\n\n\tint  flag = O_RDONLY;\n\tioLength = 0;\n\tmode_t mode = 0;\n\tmode =  S_IRUSR ] S_IWUSR ] S_IXUSR ]\n\t\tS_IRGRP ] S_IWGRP ] S_IXGRP ]\n\t\tS_IROTH ] S_IWOTH ] S_IXOTH;\n\tJOBENV::DEBUG(1,int(mode));\n\tif (type == DSSFILE_output)\n\t\t\u00e4\n\t\tflag = O_WRONLY+O_CREAT;\n\t\tfile = open(genOpenName(_fileName,_genFileName),flag+O_BINARY,flag,mode);\n\t\tif (file NEQ -1)\n\t\t\tclose(file);\n\t\tint rc= chmod(genOpenName(_fileName,_genFileName),mode);\n\t\tJOBENV::DEBUG(1,rc);\n\n\t\t\u00fc\n\tfile = open(genOpenName(_fileName,_genFileName),flag+O_BINARY,flag);\n\tif (file==-1&&seqNo>1&&type==DSSFILE_input)\n\t\treturn 0;\n\tif (file == -1)\n\t\t\u00e4\n\t\tperror(_fileName);\n\t\tError(Msg(10000+2)<<_fileName<<flag<<mode<<strerror(errno)<<eol,Abort);\n\t\t\u00fc\n\n\tif (type == DSSFILE_input)\n\t\t\u00e4\n\t\tif ( (fileF = fdopen(file,\"rb\")) == NULL)\n\t\t\t\u00e4\n\t\t\tperror(_fileName);\n\t\t\tError(Msg(10000+12)<<_fileName<<\"rb\"<<strerror(errno)<<eol,Abort);\n\t\t\t\u00fc\n\t\tzStream->next_in    = (Bytef*)buff;\n\t\tzStream->avail_in   = 0;\n\t\tif (seqNo==1)\n\t\t\t\u00e4\n\t\t\tif ((zRc = inflateInit(zStream)) NEQ Z_OK)\n\t\t\t\tError(Msg(10000+3)<<\"inflateInit\"<<zRc<<eol,Abort);\n\t\t\t\u00fc\n\t\telse\n\t\t\tif ((zRc = inflateReset(zStream)) NEQ Z_OK)\n\t\t\t\tError(Msg(10000+3)<<\"inflateReset\"<<zRc<<eol,Abort);\n\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tif ((fileF = fdopen(file,\"wb\")) == NULL)\n\t\t\t\u00e4\n\t\t\tperror(_fileName);\n\t\t\tError(Msg(10000+12)<<_fileName<<\"wb\"<<strerror(errno)<<eol,Abort);\n\t\t\t\u00fc\n\t\tzStream->next_out    = (Bytef*)buff;\n\t\tzStream->avail_out   = buff_size;\n\t\tif (seqNo==1)\n\t\t\t\u00e4\n\t\t\tif ((zRc =deflateInit(zStream,compressMethod)) NEQ Z_OK)\n\t\t\t\tError(Msg(10000+3)<<\"deflateInit\"<<zRc<<eol,Abort);\n\t\t\t\u00fc\n\t\telse\n\t\t\tif ((zRc =deflateReset(zStream)) NEQ Z_OK)\n\t\t\t\tError(Msg(10000+3)<<\"deflateReset\"<<zRc<<eol,Abort);\n\t\t\u00fc\n\treturn 1;\n\t\u00fc\n\nint DSSFILE::term()\n\t\u00e4\n\tJOBENV::DEBUG(1,\"term\");\n\tif(type ==DSSFILE_output&&fileF)\n\t\tflush();\n\tif (fileF)\n\t\tfclose(fileF);\n\tfileF = NULL;\n\treturn 1;\n\t\u00fc\n\nint DSSFILE::_put(void * b,size_t l,int flush)\n\t\u00e4\n\tif (iserror())\n\t\treturn 0;\n\tint send_size;\n\t//printf(\"Put%d\u00d6n\",l);\n\tif (flush==Z_NO_FLUSH)\n\t\t\u00e4\n\t\tzStream->next_in    = (Bytef*)b;\n\t\tzStream->avail_in   =  l;\n\t\tsend_size = buff_size;\n\t\t\u00fc\n\tok = 0;\n\twhile(NOT ok)\n    switch((zRc = deflate(zStream,flush)))\n\t\t\t\u00e4\n\t\t\tcase Z_NEED_DICT:\n\t\t\t\tError(Msg(10000+3)<<\"deflate\"<<zRc<<eol,Continue);\n\t\t\t\tok = -1;\n\t\t\t\tbreak;\n\t\t\tcase Z_STREAM_END:\n\t\t\t\tsend_size = buff_size - zStream->avail_out;\n\t\t\t\tif (send_size NEQ int(fwrite(buff,1,send_size,fileF)))\n\t\t\t\t\t\u00e4   ok = -1;\n\t\t\t\tError(Msg(10000+3)<<\"write\"<<errno<<eol,Abort);\n\t\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\t\u00e4\n\t\t\t\t\t//printf(\"Write Stream End%d\u00d6n\",send_size);\n\t\t\t\t\tioLength += l;\n\t\t\t\t\tcount += send_size;\n\t\t\t\t\tcompressedCount = zStream->total_out;\n\t\t\t\t\t\u00fc\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase Z_OK:\n\t\t\t\tif(zStream->avail_out == 0)\n\t\t\t\t\t\u00e4\n\t\t\t\t\tsend_size = buff_size - zStream->avail_out;\n\t\t\t\t\tif (send_size NEQ int(fwrite(buff,1,send_size,fileF)))\n\t\t\t\t\t\t\u00e4   ok = -1;\n\t\t\t\t\tError(Msg(10000+3)<<\"write\"<<errno<<eol,Abort);\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\telse\n\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t//printf(\"Write %d\u00d6n\",send_size);\n\t\t\t\t\t\tioLength += l;\n\t\t\t\t\t\tzStream->next_out  = (Bytef*)buff;\n\t\t\t\t\t\tzStream->avail_out = buff_size;\n\t\t\t\t\t\tcount += send_size;\n\t\t\t\t\t\tcompressedCount = zStream->total_out;\n\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\u00fc\n\t\t\t\tif(zStream->avail_in == 0&&l>0)\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tError(Msg(10000+3)<<\"deflate\"<<zRc<<eol,Continue);\n\t\t\t\tok = -1;\n\t\t\t\tbreak;\n\t\t\t\u00fc\n\tJOBENV::DEBUG(1,ioLength);\n\tif (ioLength>MAX_IOLENGTH&&l==4)\n\t\t\u00e4\n\t\tioLength = 0;\n\t\tterm();\n\t\tif (init()==0)\n\t\t\tError(Msg(10000+3)<<\"deflate\"<<zRc<<eol,Abort);\n\t\t\u00fc\n\treturn(ok>0?1:0);\n\t\u00fc\n\nint DSSFILE::_get(void *b,size_t l,int flush)\n\t\u00e4\n\tif (iserror()]]fileF==NULL)\n\t\treturn 0;\n\tint recv_size = -1;\n\tok = 0;\n\tzStream->next_out  = (Bytef*)b;\n\tzStream->avail_out = l;\n\t//printf(\"Get%d\u00d6n\",l);\n\twhile(NOT ok)\n\t\t\u00e4\n\t\tif (zStream->avail_in == 0 )\n\t\t\t\u00e4\n\t\t\trecv_size = fread(buff,1,buff_size,fileF);\n\t\t\t//printf(\"Read %d\u00d6n\",recv_size);\n\n\t\t\tif (recv_size < 0)\n\t\t\t\t\u00e4  ok = -1;\n\t\t\tError(Msg(10000+3)<<\"read\"<<errno<<eol,Continue);\n\t\t\t\t\u00fc\n\t\t\tzStream->avail_in = recv_size;\n\t\t\tzStream->next_in  =(Bytef*)buff;\n\t\t\tif (recv_size==0)\n\t\t\t\tflush=Z_FINISH;\n\t\t\t\u00fc\n    if (NOT ok) switch((zRc=inflate(zStream,flush)))\n\t\t\t\u00e4\n\t\t\t\t\t\t\t\tcase Z_NEED_DICT:\n\t\t\t\t\t\t\t\t\tError(Msg(10000+3)<<\"inflate\"<<zRc<<eol,Continue);\n\t\t\t\t\t\t\t\t\tok = -1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase Z_STREAM_END:\n\t\t\t\t\t\t\t\tcase Z_BUF_ERROR:\n\t\t\t\t\t\t\t\tcase Z_OK:\n\t\t\t\t\t\t\t\t\tif (recv_size == 0 )\n\t\t\t\t\t\t\t\t\t\t\u00e4\n\t\t\t\t\t\t\t\t\t\tterm();\n\t\t\t\t\t\t\t\t\t\tBytef * _b = zStream->next_out;\n\t\t\t\t\t\t\t\t\t\tsize_t _l  = zStream->avail_out;\n\t\t\t\t\t\t\t\t\t\tif (init()==0)\n\t\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t\tzStream->next_out   = _b;\n\t\t\t\t\t\t\t\t\t\tzStream->avail_out  = _l;\n\t\t\t\t\t\t\t\t\t\t\u00fc\n\t\t\t\t\t\t\t\t\tif (zStream->avail_out == 0)\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tError(Msg(10000+3)<<\"inflate\"<<zRc<<eol,Continue);\n\t\t\t\t\t\t\t\t\tok = -1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\u00fc\n\t\t\u00fc\n\tcount +=l;\n\tcompressedCount = zStream->total_in;\n\treturn(ok>0?1:0);\n\t\u00fc\n\nint DSSFILE::put(void * b,size_t l)\n\t\u00e4\n\tif( _put((void *)&l,sizeof(size_t)) && _put(b,l))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n\t\u00fc\n\nint DSSFILE::get(void *b)\n\t\u00e4\n\tsize_t l = 0;\n\tif (_get((void*)&l,sizeof(size_t)))\n\t\t\u00e4\n\t\tif ( _get(b,l))\n\t\t\treturn l;\n\t\t\u00fc\n\treturn 0;\n\t\u00fc\n\nint DSSFILE::flush()\n\t\u00e4\n\treturn(_put(0,0,Z_FINISH));\n\t\u00fc\n\nvoid DSSFILE::Error(char *,Error_Action a)\n\t\u00e4\n\tif (a == Continue)\n\t\treturn;\n\telse\n\t\t\u00e4\n\t\tMsg(10000+9999)<<eol;\n\t\tabort();\n\t\t\u00fc\n\t\u00fc\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DSSFSRB": {"ttr": 1337, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include \"isisdef.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#include <assert.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"dssfile.hpp\"\n#include \"dssmain.hpp\"\n#include \"jobenv.hpp\"\n#include \"subtask.hpp\"\n#include \"msgmgr.hpp\"\nint _edc_add_errno2 = setenv(\"_EDC_ADD_ERRNO2\",\"1\",1);\nstatic int compressMethod = (getenv(KEYWORD_COMPR)?\n                             atoi(getenv(KEYWORD_COMPR)):-1);\nstatic  size_t MAX_IOLENGTH  = (getenv(KEYWORD_MAXLENGTH))?atoi(getenv(KEYWORD_MAXLENGTH))*1024*1024:1024*1024*512;\n\nDSSFILE::DSSFILE(const char * n,DSSFILE_TYPE t,size_t max):\nmERROR(),\nfileName(n), type(t), buff_size(max)\n  \u00e4\n  file    = NULL;\n  count = compressedCount = 0;\n  seqNo = 0;\n  buff = (UCHAR *) malloc(max);\n  if (buff == NULL)\n    Error(Msg(10000+1)<<short(max)<<eol,Abort);\n  zStream = (z_streamp)malloc(sizeof(z_stream));\n  memset(zStream,0,sizeof(z_stream));\n  fileName.strip();\n  init();\n  \u00fc\n\nDSSFILE::\u00dfDSSFILE()\n  \u00e4\n  term();\n  if (zStream)\n    free(zStream);\n  zStream = NULL;\n  if (buff)\n    free(buff);\n  buff = NULL;\n  \u00fc\n\nint DSSFILE::init()\n  \u00e4\n  char _fileName\u00c41024\u00dc;\n\tchar _genFileName\u00c41024\u00dc;\n  if (seqNo)\n    sprintf(_fileName,\"%s.%d\",(char *)fileName,seqNo);\n  else\n    sprintf(_fileName,\"%s\",(char *)fileName);\n  Msg(10000+13)<<_fileName<<eol;\n  seqNo+=1;\n\n  JOBENV::DEBUG(1,_fileName);\n\n  int  flag = O_RDONLY;\n  ioLength = 0;\n\tmode_t mode = 0;\n  mode =  S_IRUSR ] S_IWUSR ] S_IXUSR ]\n\t\t\t\t\tS_IRGRP ] S_IWGRP ] S_IXGRP ]\n\t\t\t\t\tS_IROTH ] S_IWOTH ] S_IXOTH;\n\tJOBENV::DEBUG(1,int(mode));\n  if (type == DSSFILE_output)\n    \u00e4\n    flag = O_WRONLY+O_CREAT;\n    file = open(genOpenName(_fileName,_genFileName),flag+O_BINARY,flag,mode);\n    if (file NEQ -1)\n      close(file);\n    int rc= chmod(genOpenName(_fileName,_genFileName),mode);\n\t\tJOBENV::DEBUG(1,rc);\n\n    \u00fc\n  file = open(genOpenName(_fileName,_genFileName),flag+O_BINARY,flag);\n  if (file==-1&&seqNo>1&&type==DSSFILE_input)\n    return 0;\n  if (file == -1)\n    \u00e4\n    perror(_fileName);\n    Error(Msg(10000+2)<<_fileName<<flag<<mode<<strerror(errno)<<eol,Abort);\n    \u00fc\n\n  if (type == DSSFILE_input)\n    \u00e4\n    if ( (fileF = fdopen(file,\"rb\")) == NULL)\n      \u00e4\n      perror(_fileName);\n      Error(Msg(10000+12)<<_fileName<<\"rb\"<<strerror(errno)<<eol,Abort);\n      \u00fc\n    zStream->next_in    = (Bytef*)buff;\n    zStream->avail_in   = 0;\n    if (seqNo==1)\n      \u00e4\n      if ((zRc = inflateInit(zStream)) NEQ Z_OK)\n        Error(Msg(10000+3)<<\"inflateInit\"<<zRc<<eol,Abort);\n      \u00fc\n    else\n      if ((zRc = inflateReset(zStream)) NEQ Z_OK)\n        Error(Msg(10000+3)<<\"inflateReset\"<<zRc<<eol,Abort);\n\n    \u00fc\n  else\n    \u00e4\n    if ((fileF = fdopen(file,\"wb\")) == NULL)\n      \u00e4\n      perror(_fileName);\n      Error(Msg(10000+12)<<_fileName<<\"wb\"<<strerror(errno)<<eol,Abort);\n      \u00fc\n    zStream->next_out    = (Bytef*)buff;\n    zStream->avail_out   = buff_size;\n    if (seqNo==1)\n      \u00e4\n      if ((zRc =deflateInit(zStream,compressMethod)) NEQ Z_OK)\n        Error(Msg(10000+3)<<\"deflateInit\"<<zRc<<eol,Abort);\n      \u00fc\n    else\n      if ((zRc =deflateReset(zStream)) NEQ Z_OK)\n        Error(Msg(10000+3)<<\"deflateReset\"<<zRc<<eol,Abort);\n    \u00fc\n  return 1;\n  \u00fc\n\nint DSSFILE::term()\n  \u00e4\n  JOBENV::DEBUG(1,\"term\");\n  if(type ==DSSFILE_output&&fileF)\n    flush();\n  if (fileF)\n    fclose(fileF);\n  fileF = NULL;\n  return 1;\n  \u00fc\n\nint DSSFILE::_put(void * b,size_t l,int flush)\n  \u00e4\n  if (iserror())\n    return 0;\n  int send_size;\n  //printf(\"Put%d\u00d6n\",l);\n  if (flush==Z_NO_FLUSH)\n    \u00e4\n    zStream->next_in    = (Bytef*)b;\n    zStream->avail_in   =  l;\n    send_size = buff_size;\n    \u00fc\n  ok = 0;\n  while(NOT ok)\n    switch((zRc = deflate(zStream,flush)))\n    \u00e4\n      case Z_NEED_DICT:\n        Error(Msg(10000+3)<<\"deflate\"<<zRc<<eol,Continue);\n        ok = -1;\n        break;\n      case Z_STREAM_END:\n          send_size = buff_size - zStream->avail_out;\n          if (send_size NEQ int(fwrite(buff,1,send_size,fileF)))\n            \u00e4   ok = -1;\n          Error(Msg(10000+3)<<\"write\"<<errno<<eol,Abort);\n            \u00fc\n          else\n            \u00e4\n            //printf(\"Write Stream End%d\u00d6n\",send_size);\n            ioLength += l;\n            count += send_size;\n            compressedCount = zStream->total_out;\n            \u00fc\n          ok = 1;\n        break;\n      case Z_OK:\n        if(zStream->avail_out == 0)\n          \u00e4\n           send_size = buff_size - zStream->avail_out;\n          if (send_size NEQ int(fwrite(buff,1,send_size,fileF)))\n            \u00e4   ok = -1;\n          Error(Msg(10000+3)<<\"write\"<<errno<<eol,Abort);\n            \u00fc\n          else\n            \u00e4\n            //printf(\"Write %d\u00d6n\",send_size);\n            ioLength += l;\n            zStream->next_out  = (Bytef*)buff;\n            zStream->avail_out = buff_size;\n            count += send_size;\n            compressedCount = zStream->total_out;\n            \u00fc\n          \u00fc\n        if(zStream->avail_in == 0&&l>0)\n          ok = 1;\n        break;\n      default:\n        Error(Msg(10000+3)<<\"deflate\"<<zRc<<eol,Continue);\n        ok = -1;\n        break;\n    \u00fc\n  JOBENV::DEBUG(1,ioLength);\n  if (ioLength>MAX_IOLENGTH&&l==4)\n    \u00e4\n    ioLength = 0;\n    term();\n    if (init()==0)\n      Error(Msg(10000+3)<<\"deflate\"<<zRc<<eol,Abort);\n    \u00fc\n  return(ok>0?1:0);\n  \u00fc\n\nint DSSFILE::_get(void *b,size_t l,int flush)\n  \u00e4\n  if (iserror()]]fileF==NULL)\n    return 0;\n  int recv_size = -1;\n  ok = 0;\n  zStream->next_out  = (Bytef*)b;\n  zStream->avail_out = l;\n  //printf(\"Get%d\u00d6n\",l);\n  while(NOT ok)\n    \u00e4\n    if (zStream->avail_in == 0 )\n      \u00e4\n      recv_size = fread(buff,1,buff_size,fileF);\n      //printf(\"Read %d\u00d6n\",recv_size);\n\n      if (recv_size < 0)\n        \u00e4  ok = -1;\n      Error(Msg(10000+3)<<\"read\"<<errno<<eol,Continue);\n        \u00fc\n      zStream->avail_in = recv_size;\n      zStream->next_in  =(Bytef*)buff;\n      if (recv_size==0)\n        flush=Z_FINISH;\n      \u00fc\n    if (NOT ok) switch((zRc=inflate(zStream,flush)))\n      \u00e4\n                case Z_NEED_DICT:\n                  Error(Msg(10000+3)<<\"inflate\"<<zRc<<eol,Continue);\n                  ok = -1;\n                  break;\n                case Z_STREAM_END:\n                case Z_BUF_ERROR:\n                case Z_OK:\n                  if (recv_size == 0 )\n                    \u00e4\n                    term();\n                    Bytef * _b = zStream->next_out;\n                    size_t _l  = zStream->avail_out;\n                    if (init()==0)\n                      return 0;\n                    zStream->next_out   = _b;\n                    zStream->avail_out  = _l;\n                    \u00fc\n                  if (zStream->avail_out == 0)\n                    ok = 1;\n                  break;\n                default:\n                  Error(Msg(10000+3)<<\"inflate\"<<zRc<<eol,Continue);\n                  ok = -1;\n                  break;\n      \u00fc\n    \u00fc\n  count +=l;\n  compressedCount = zStream->total_in;\n  return(ok>0?1:0);\n  \u00fc\n\nint DSSFILE::put(void * b,size_t l)\n  \u00e4\n  if( _put((void *)&l,sizeof(size_t)) && _put(b,l))\n    return 1;\n  else\n    return 0;\n  \u00fc\n\nint DSSFILE::get(void *b)\n  \u00e4\n  size_t l = 0;\n  if (_get((void*)&l,sizeof(size_t)))\n  \u00e4\n    if ( _get(b,l))\n      return l;\n  \u00fc\n  return 0;\n  \u00fc\n\nint DSSFILE::flush()\n  \u00e4\n  return(_put(0,0,Z_FINISH));\n  \u00fc\n\nvoid DSSFILE::Error(char *,Error_Action a)\n  \u00e4\n  if (a == Continue)\n    return;\n  else\n    \u00e4\n    Msg(10000+9999)<<eol;\n    abort();\n    \u00fc\n  \u00fc\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DSSMAIN": {"ttr": 1333, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#pragma runopts(POSIX(ON),ANYHEAP(,,ANY),ALL31(ON),HEAP(,,ANY),STACK(,,ANY),STORAGE(NONE,NONE,NONE))\n#include \"isisdef.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <fcntl.h>\n\n#include <unistd.h>\n\n#include \"msgmgr.hpp\"\n#include \"mvsbase.hpp\"\n#include \"mchain.hpp\"\n#include \"merror.hpp\"\n#include \"rarcsql.hpp\"\n#include \"dssclas.hpp\"\n#include \"dssmain.hpp\"\n#include \"dssdb.hpp\"\n#include \"dssfile.hpp\"\n#include \"jobenv.hpp\"\n#include \"adreib.hpp\"\n#include \"adrufob.hpp\"\n#include \"eirec21.hpp\"\n#include \"eirec23.hpp\"\n#include \"misc.hpp\"\n//#include \"isismisc.hpp\"\n\ntypedef struct adreib _adreib;\ntypedef struct adrufob ADRUFOB;\ntypedef struct eirec21  EIREC21;\ntypedef struct eirec23  EIREC23;\n\nconst char * ADRDSSU              = \"ADRDSSU \";\nconst char * KEYWORD_INCLUDE_MARK = \"/*include*/\";\nconst char * KEYWORD_DUMP         = \"DUMP\";\nconst char * KEYWORD_RESTORE      = \"RESTORE\";\nconst char * KEYWORD_DB_PLAN      = \"PLAN\";\nconst char * KEYWORD_DB_SUBSYS    = \"SUBSYS\";\nconst char * KEYWORD_PREFIX       = \"PREFIX\";\nconst char * KEYWORD_SYSIN        = \"SYSIN\";\nconst char * KEYWORD_ADR012I      = \"ADR012I\";\nconst char * KEYWORD_DEBUG        = \"DEBUG\";\nconst char * KEYWORD_TRACE        = \"TRACE\";\nconst char * KEYWORD_COMPR        = \"COMPR\";\nconst char * KEYWORD_REFDT        = \"REFDT\";\nconst char * KEYWORD_SQLFILE      = \"SQL\";\nconst char * KEYWORD_DIRECT       = \"DIRECT\";\nconst char * KEYWORD_MAXLENGTH    = \"MAXLENGTH\";\nconst char * KEYWORD_USEDB2\t  \t\t= \"USEDB2\";\nconst char * KEYWORD_USEDB2_FILE  = \"DB2OUT\";\nconst char * KEYWORD_ADRDSSU      = \"ADRDSSU\";\n\nstatic DSS *          dss = NULL;\nstatic mCHAIN    *    input      = new mCHAIN();\nstatic CHAINITER *    inputIter  = new CHAINITER(*input);\nstatic int            inputEof   = 0;\nstatic mCHAIN    *    msgChain   = new mCHAIN();\nstatic CHAINITER *    msgIter    = new CHAINITER(*input);\nstatic char           buff\u00c4DSSFILE_MAX_BUFFER\u00dc;\nstatic FILE      *    trace      = NULL;\nstatic char  date\u00c412\u00dc;\nstatic char  dateToIBM\u00c412\u00dc;\n\nstatic bool backspaceFlag = false;\nstatic int  backspaceLength = 0;\nstatic int   direct = 0;\n\nstatic bool adrdssu = false;\n\n#define _VERSION_  \"V7R0M0\"\n\nint main(int argc,char *argv\u00c4\u00dc)\n\u00e4\n\tchar _genFileName\u00c41024\u00dc;\n\tint rc = 0;\n\tmessagetext = new MessageTEXT();\n\tjobEnv  = new JOBENV(argv\u00c40\u00dc);\n\tDssJob * job = new DssJob();\n\tdss = new DSS(argv\u00c41\u00dc,job);\n\tformatTime(date,sizeof(date),\"%d.%m.%Y\");\n\tJOBENV::DEBUG(1,date);\n\tMsg(5500)<<argv\u00c40\u00dc<<_VERSION_<<__DATE__<<eol; //szm\n\tmCHAIN * includes    = new mCHAIN();\n\tchar     buff\u00c4256\u00dc;\n\tif (getenv(KEYWORD_TRACE))\n\t\u00e4\n\t\ttrace = fopen(genOpenName(getenv(KEYWORD_TRACE),_genFileName),\"w\");\n\t\u00fc\n\tFILE *   sysin = fopen(genOpenName(KEYWORD_SYSIN,_genFileName),\"r\");\n\tif (NOT sysin)\n\t\tJOBENV::Error(Msg(10000+110)<<KEYWORD_SYSIN<<eol,JOBENV::Abort);\n\tif (getenv(KEYWORD_ADRDSSU))\n\t\tadrdssu = atoi(getenv(KEYWORD_ADRDSSU));\n\telse\n\t\tadrdssu = false;\n\twhile(fgets(buff,sizeof(buff)-1,sysin))\n\t\u00e4\n\t\tif ( strchr(buff,'\u00d6n') )\n\t\t\t*strchr(buff,'\u00d6n') = 0;\n\t\tchainE * rec = new chainE(buff);\n\t\tMsg(10000+112)<<buff<<eol;\n\t\tinput->addlast(rec);\n\t\tmvsSTRING parse(rec->chainEid);\n\t\tparse.strip();\n\t\tif ( dss->function == DSS::invalid )\n\t\t\u00e4\n\t\t\tif (memcmpi((const char *)parse,KEYWORD_DUMP,strlen(KEYWORD_DUMP))==0)\n\t\t\t\tdss->function = DSS::dump;\n\t\t\telse if (memcmpi((const char *)parse,KEYWORD_RESTORE,strlen(KEYWORD_RESTORE))==0)\n\t\t\t\tdss->function = DSS::restore;\n\t\t\u00fc\n\t\telse if(strstr((char *)parse,KEYWORD_INCLUDE_MARK) && dss->function == DSS::restore)\n\t\t\u00e4\n\t\t\tmvsSTRING inc, rest;\n\t\t\tparse.parse(inc,\" \",rest);\n\t\t\tinc.strip();\n\t\t\tMsg(10000+113)<<inc<<eol;\n\t\t\tincludes->addlast(new chainE((char *)inc));\n\t\t\u00fc\n\t\telse if(strstr((char *)parse,KEYWORD_REFDT) && dss->function == DSS::restore)\n\t\t\u00e4\n\t\t\tmvsSTRING dt = strchr(strstr((char *)parse,KEYWORD_REFDT),' ');\n\t\t\tmvsSTRING oper, dateS, rest;\n\t\t\tdt.strip();\n\t\t\tdt.parse(oper,\" \",dateS,\")\",rest);\n\t\t\tdateS.strip();\n\t\t\tstrcpy(date,(char *)dateS);\n\t\t\tmemcpy(dateToIBM,DatetoIBM(date),sizeof(dateToIBM));\n\t\t\tMsg(10000+116)<<date<<dateToIBM<<eol;\n\t\t\u00fc\n\t\u00fc\n\tfclose(sysin);\n\tsysin = NULL;\n\tFILE * _fd = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\n\tif (_fd) fclose(_fd);\n\tif (_fd)\n\t\tsysin = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\n\tif (sysin)\n\t\u00e4\n\t\twhile(fgets(buff,sizeof(buff)-1,sysin))\n\t\t\u00e4\n\t\t\tif ( strchr(buff,'\u00d6n') )\n\t\t\t\t*strchr(buff,'\u00d6n') = 0;\n\t\t\tif ( strchr(buff,' ') )\n\t\t\t\t*strchr(buff,' ') = 0;\n\t\t\tdirect = 1;\n\t\t\tMsg(10000+126)<<buff<<eol;\n\t\t\tDssJob::dssJobs.addlast(new DssJob(buff));\n\t\t\u00fc\n\t\tfclose(sysin);\n\t\u00fc\n\n\tsysin = NULL;\n\tint qrc = 0;\n\tswitch(dss->function)\n\t\u00e4\n\tcase DSS::dump:\n\t\tMsg(10000+114)<<eol;\n\t\tinputIter->reset();\n\t\trc = dss->run(job);\n\t\tbreak;\n\tcase DSS::restore:\n\t\tMsg(10000+115)<<eol;\n\t\t\u00e4\n\t\t\tif (direct==0)\n\t\t\t\u00e4\n\t\t\t\tif ((qrc = dss->getJob()->query(includes,date)) < 0)\n\t\t\t\t\tJOBENV::Error(Msg(10000+111)<<eol,JOBENV::Abort);\n\t\t\t\u00fc\n\t\t\tif ( NOT DssJob::allOnline() )\n\t\t\t\tJOBENV::Error(Msg(10000+118)<<eol,JOBENV::Abort);\n\t\t\tCHAINITER iter(DssJob::dssJobs);\n\t\t\tDssJob * toRestore = (DssJob*)iter.next();\n\t\t\tif (direct==0 &&(toRestore==NULL ]] qrc == 0))\n\t\t\t\u00e4\n\t\t\t\tJOBENV::Error(Msg(10000+117)<<eol,JOBENV::Continue);\n\t\t\t\trc = 4;\n\t\t\t\u00fc\n\t\t\twhile(toRestore)\n\t\t\t\u00e4\n\t\t\t\tinputEof = 0;\n\t\t\t\tinputIter->reset();\n\t\t\t\trc ]= dss->run(toRestore);\n\t\t\t\ttoRestore = (DssJob*)iter.next();\n\t\t\t\u00fc\n\t\t\u00fc\n\t\tbreak;\n\tcase DSS::invalid:\n\tdefault:\n\t\tJOBENV::Error(Msg(10000+111)<<eol,JOBENV::Abort);\n\t\tbreak;\n\t\u00fc\n\tMsg(10000+119)<<rc<<eol;\n\t//printf(\" DSSN ended with rc:%d\u00d6n\",rc);\n\t_exit(rc);\n\tdelete job;\n\tdelete includes;\n\tdelete dss;\n\t_exit(rc);\n\t//return rc;\n\u00fc\n\nchar * options\u00c4\u00dc =\n\u00e4\n\t\"Function StartUp\",\n\t\"Sysin Record\",\n\t\"Printing SYSPRINT\",\n\t\"Reading Physical Tape\",\n\t\"Reading Logical Tape\",\n\t\"Writing Logical Tape\",\n\t\"Writing Physical Tape\",\n\t\"Reading Disk Track\",\n\t\"Writing Disk Track\",\n\t\"Reading Utility Sysprint\",\n\t\"Writing Utility Sysprint\",\n\t\"Writing WTO\",\n\t\"Writing WTOR\",\n\t\"Presenting ADRUFO\",\n\t\"Function Ending\",\n\t\"Presenting WTOR response\",\n\t\"OPEN Tape volume verification\",\n\t\"OPEN Tape volume nonspecific\",\n\t\"Insert Logical VSAM\",\n\t\"Output TAPE error\",\n\t\"Volume Notification\",\n\t\"Dataset Verification\",\n\t\"Bypass Verification\",\n\t\"Dataset processed\",\n\t\"Concurrent Copy\",\n\t\"Backspace\",\n\t\"Dump Volume\",\n\t\"Physical Dataset Processed\"\n\u00fc;\n\nextern \"C\"\nint UIM(void  * eib)\n\u00e4\n\tstatic DSSFILE  * dssFile  = NULL;\n\tstatic int dssStart        = 1;\n\n\t_adreib  * adreib  = (_adreib *)eib;\n\tdss                = (DSS *)(adreib->eiuseptr);\n\tDssJob *  job      = dss->getJob();\n\tJOBENV::DEBUG(1,\"UIM entry:\",options\u00c4adreib->eioption\u00dc);\n\tadreib->eiretcod = eirc_ok; //set default o.k.\n\tadreib->eixalow0 = 0xff; // allow all kind of actions ( replace delete etc.\n\tif (adrdssu)\n\t\u00e4\n\t\u00fc\n\telse\n\t\u00e4\n\t\tswitch(adreib->eioption)\n\t\t\u00e4\n\t\tcase eiop00:\n\t\t\t\u00e4\n\t\t\t\tif (dssStart)\n\t\t\t\t\u00e4\n\t\t\t\t\tdssStart = 0;\n\t\t\t\t\tMsg(10000+130)<<\"V7R0M0\"<<__DATE__<<eol;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tif (dss->function == DSS::dump)\n\t\t\t\t\t\tdssFile = new DSSFILE(job->getDatasetName(),DSSFILE_output);\n\t\t\t\t\telse\n\t\t\t\t\t\tdssFile = new DSSFILE(job->getDatasetName(),DSSFILE_input);\n\t\t\t\t\tif(NOT dssFile ]] dssFile->iserror())\n\t\t\t\t\t\tJOBENV::Error(Msg(10000+111)<<eol,JOBENV::Abort);\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\tadreib->eiretcod =  eirc_ok;\n\t\t\tbreak;\n\t\tcase eiop01:\n\t\t\tif (NOT inputEof)\n\t\t\t\u00e4\n\t\t\t\tchainE  * rec = inputIter->next();\n\t\t\t\tif ( rec)\n\t\t\t\t\u00e4\n\t\t\t\t\tadreib->eirecptr = int(rec->chainEid);\n\t\t\t\t\tadreib->eireclen = strlen(rec->chainEid);\n\t\t\t\t\tchar * c = NULL;\n\t\t\t\t\tif ((c = strstr((char *)adreib->eirecptr,KEYWORD_INCLUDE_MARK)))\n\t\t\t\t\t\tmemset(c,' ',strlen(KEYWORD_INCLUDE_MARK));\n\t\t\t\t\telse if (strstr((char *)adreib->eirecptr,KEYWORD_REFDT) && dss->function == DSS::restore)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tchar * dt = strchr(strstr((char *)adreib->eirecptr,KEYWORD_REFDT),' ');\n\t\t\t\t\t\tmemcpy(dt+4,dateToIBM,strlen(date));\n\t\t\t\t\t\u00fc\n\t\t\t\t\tJOBENV::DEBUG(1,(char *)adreib->eirecptr);\n\t\t\t\t\tadreib->eiretcod = eirc_insert;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tinputEof = 1;\n\t\t\t\t\tif (adreib->eireclen)\n\t\t\t\t\t\tadreib->eiretcod =  eirc_delete;\n\t\t\t\t\telse\n\t\t\t\t\t\tadreib->eiretcod =  eirc_disconnect;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\telse if (adreib->eireclen)\n\t\t\t\tadreib->eiretcod =  eirc_delete;\n\t\t\telse\n\t\t\t\tadreib->eiretcod =  eirc_disconnect;\n\t\t\tbreak;\n\t\tcase eiop02:\n\t\t\tif (0)\n\t\t\t\t//if (memcmpi(KEYWORD_ADR012I,(char *)adreib->eirecptr,strlen(KEYWORD_ADR012I)) == 0)\n\t\t\t\u00e4\n\t\t\t\tif (msgIter == NULL)\n\t\t\t\t\tmsgIter = new CHAINITER(*msgChain);\n\t\t\t\tchainE * next = msgIter->next();\n\t\t\t\tif (next == NULL)\n\t\t\t\t\u00e4\n\t\t\t\t\tdelete msgIter;\n\t\t\t\t\tadreib->eiretcod = eirc_ok;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tadreib->eirecptr = int(next->chainEid);\n\t\t\t\t\tadreib->eireclen = next->chainEidl;\n\t\t\t\t\tadreib->eiretcod = eirc_insert;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tif (dss->function == DSS::dump &&\n\t\t\t\t\tjob->joblog.len+adreib->eireclen < sizeof(job->joblog.arr))\n\t\t\t\t\u00e4\n\t\t\t\t\tmemcpy(job->joblog.arr+job->joblog.len,(char *)adreib->eirecptr,\n\t\t\t\t\t\tadreib->eireclen);\n\t\t\t\t\tjob->joblog.len += adreib->eireclen;\n\t\t\t\t\tjob->joblog.arr\u00c4job->joblog.len++\u00dc = 0;\n\t\t\t\t\u00fc\n\t\t\t\tadreib->eiretcod = eirc_ok;\n\t\t\t\tbreak;\n\t\tcase eiop03:\n\t\t\t\u00e4\n\t\t\t\tif (backspaceFlag)\n\t\t\t\t\u00e4\n\t\t\t\t\t//JOBENV::DEBUG(1,\"backspace Physical Tape Record\");\n\t\t\t\t\tadreib->eirecptr = int(buff);\n\t\t\t\t\tadreib->eireclen = backspaceLength;\n\t\t\t\t\tadreib->eiretcod = eirc_insert;\n\t\t\t\t\tbackspaceFlag = false;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\t\tsize_t l = dssFile->get(buff);\n\t\t\t\t\tif (l)\n\t\t\t\t\t\u00e4\n\t\t\t\t\t\tbackspaceLength = l;\n\t\t\t\t\t\t//JOBENV::DEBUG(1,l);\n\t\t\t\t\t\t// fwrite(buff,1,l,trace);\n\t\t\t\t\t\tadreib->eirecptr = int(buff);\n\t\t\t\t\t\tadreib->eireclen = l;\n\t\t\t\t\t\tadreib->eiretcod = eirc_insert;\n\t\t\t\t\t\u00fc\n\t\t\t\t\telse\n\t\t\t\t\t\tadreib->eiretcod = eirc_disconnect;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\tcase eiop06:\n\t\t\tif (dssFile->put((char *)adreib->eirecptr,adreib->eireclen))\n\t\t\t\tadreib->eiretcod = eirc_delete;\n\t\t\telse\n\t\t\t\tadreib->eiretcod = eirc_disconnect;\n\t\t\tbreak;\n\t\tcase eiop13:\n\t\t\t\u00e4\n\t\t\t\tADRUFOB * adrufob =(ADRUFOB *)adreib->eirecptr;\n\t\t\t\tadrufob->ufaiflgs &= (255-ufuimch);\n\t\t\t\tadrufob->ufaiflgs ]= (ufnoin+ufnoout);\n\t\t\t\tadreib->eiretcod = eirc_modified;\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\tcase eiop14:\n\t\t\t\u00e4\n\t\t\t\tif (dss->function == DSS::dump)\n\t\t\t\t\tjob->insert();\n\t\t\t\tif (dssFile)\n\t\t\t\t\tdelete dssFile;\n\t\t\t\tdssFile = NULL;\n\t\t\t\u00fc\n\t\t\tadreib->eiretcod =  eirc_ok;\n\t\t\tbreak;\n\t\tcase eiop21:\n\t\t\tadreib->eiretcod =  eirc_ok;\n\t\t\tif (dss->function==DSS::restore)\n\t\t\t\u00e4\n\t\t\t\tEIREC21 * rec21 = (EIREC21 *)(adreib->eirecptr);\n\t\t\t\tif (direct==0&&job->doWeNeed((char *)rec21->ei21dsn)==0)\n\t\t\t\t\u00e4\n\t\t\t\t\tMsg(10000+125)<<mvsSTRING((char *)rec21->ei21dsn,sizeof(rec21->ei21dsn))<<eol;\n\t\t\t\t\tadreib->eiretcod =  eirc_end_dataset;\n\t\t\t\t\u00fc\n\t\t\t\telse\n\t\t\t\t\tMsg(10000+124)<<mvsSTRING((char *)rec21->ei21dsn,sizeof(rec21->ei21dsn))<<eol;\n\t\t\t\u00fc\n\t\t\tbreak;\n\t\tcase eiop23:\n\t\t\tif (dss->function == DSS::dump)\n\t\t\t\u00e4\n\t\t\t\tEIREC23 * rec23 = (EIREC23 *)(adreib->eirecptr);\n\t\t\t\tif(rec23->ei23vol_ && memcmp(rec23->e23bytes,nulls,8))\n\t\t\t\t\tnew DssDataset(job,\n\t\t\t\t\tmvsSTRING((char *)rec23->ei23dsn,sizeof(rec23->ei23dsn)),\n\t\t\t\t\tmvsSTRING((char *)rec23->ei23vser,6*rec23->ei23vol_),\n\t\t\t\t\tint(*(int *)(&rec23->e23sdsrg)));\n\t\t\t\u00fc\n\t\t\tadreib->eiretcod = eirc_ok;\n\t\t\tbreak;\n\t\tcase eiop25:\n\t\t\tbackspaceFlag = true;\n\t\t\tadreib->eiretcod =  eirc_ok;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tadreib->eiretcod =  eirc_ok;\n\t\t\tbreak;\n\t\t\u00fc\n\t\u00fc\n\tif (adreib->eirecptr&&adreib->eireclen>0)\n\t\u00e4\n\t\tif (trace)\n\t\t\tfwrite((char *)adreib->eirecptr,1,adreib->eireclen,trace);\n\t\tJOBENV::DEBUG(1,\"dump:\",(char *)adreib->eirecptr,adreib->eireclen);\n\t\u00fc\n\tJOBENV::DEBUG(3,\"UIM exit:\",adreib->eiretcod);\n\treturn int(adreib->eiretcod);\n\u00fc\n\nextern \"C\" int DBError(char * s)\n\u00e4\n\tMsg(10000+9704)<<s<<eol;\n\treturn 1;\n\u00fc\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "EBCDICUT": {"ttr": 1335, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/isislib/ebcdicut.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   Definitions for ascii/ebcdic conversion\n*******************************************************************************/\n#define ISIS_DONT_USE_PCSDLL\n#include \"isisdef.h\"\n// EBCDIC->ASCII table (273->850)\nextern const unsigned char isis_etoa\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x9F, 0x09, 0xB0, 0x7F,\n  0xB1, 0xB2, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0xB4, 0x0A, 0x08, 0xBA,\n  0x18, 0x19, 0xBB, 0xBC, 0x1C, 0x1D, 0x1E, 0x1F,\n  0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0x0A, 0x17, 0x1B,\n  0xC4, 0xC5, 0xC8, 0xC9, 0xCA, 0x05, 0x06, 0x07,\n  0xCB, 0xCC, 0x16, 0xCD, 0xCE, 0xD5, 0xD9, 0x04,\n  0xDA, 0xDB, 0xDC, 0xDF, 0x14, 0x15, 0xF2, 0x1A,\n  0x20, 0xFF, 0x83, 0x7B, 0x85, 0xA0, 0xC6, 0x86,\n  0x87, 0xA4, 0x8E, 0x2E, 0x3C, 0x28, 0x2B, 0x21,\n  0x26, 0x82, 0x88, 0x89, 0x8A, 0xA1, 0x8C, 0x8B,\n  0x8D, 0x7E, 0x9A, 0x24, 0x2A, 0x29, 0x3B, 0x5E,\n  0x2D, 0x2F, 0xB6, 0x5B, 0xB7, 0xB5, 0xC7, 0x8F,\n  0x80, 0xA5, 0x94, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,\n  0x9B, 0x90, 0xD2, 0xD3, 0xD4, 0xD6, 0xD7, 0xD8,\n  0xDE, 0x60, 0x3A, 0x23, 0xF5, 0x27, 0x3D, 0x22,\n  0x9D, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n  0x68, 0x69, 0xAE, 0xAF, 0xD0, 0xEC, 0xE7, 0xF1,\n  0xF8, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n  0x71, 0x72, 0xA6, 0xA7, 0x91, 0xF7, 0x92, 0xCF,\n  0xE6, 0xE1, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n  0x79, 0x7A, 0xAD, 0xA8, 0xD1, 0xED, 0xE8, 0xA9,\n  0xBD, 0x9C, 0xBE, 0xFA, 0xB8, 0x40, 0xF4, 0xAC,\n  0xAB, 0xF3, 0xAA, 0x7C, 0xEE, 0xF9, 0xEF, 0x9E,\n  0x84, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n  0x48, 0x49, 0xF0, 0x93, 0xDD, 0x95, 0xA2, 0xE4,\n  0x81, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n  0x51, 0x52, 0xFB, 0x96, 0x7D, 0x97, 0xA3, 0x98,\n  0x5C, 0xF6, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n  0x59, 0x5A, 0xFD, 0xE2, 0x5C, 0xE3, 0xE0, 0xE5,\n  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n  0x38, 0x39, 0xFC, 0xEA, 0x5D, 0xEB, 0xE9, 0xFE\n\u00fc ;\n\n// ASCII->EBCDIC table (850->273)\nextern const unsigned char isis_atoe\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n  0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,\n  0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,\n  0x40, 0x4F, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,\n  0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,\n  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n  0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,\n  0xB5, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n  0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,\n  0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n  0xE7, 0xE8, 0xE9, 0x63, 0xEC, 0xFC, 0x5F, 0x6D,\n  0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n  0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n  0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,\n  0xA7, 0xA8, 0xA9, 0x43, 0xBB, 0xDC, 0x59, 0x07,\n  0x68, 0xD0, 0x51, 0x42, 0xC0, 0x44, 0x47, 0x48,\n  0x52, 0x53, 0x54, 0x57, 0x56, 0x58, 0x4A, 0x67,\n  0x71, 0x9C, 0x9E, 0xCB, 0x6A, 0xCD, 0xDB, 0xDD,\n  0xDF, 0xE0, 0x5A, 0x70, 0xB1, 0x80, 0xBF, 0x04,\n  0x45, 0x55, 0xCE, 0xDE, 0x49, 0x69, 0x9A, 0x9B,\n  0xAB, 0xAF, 0xBA, 0xB8, 0xB7, 0xAA, 0x8A, 0x8B,\n  0x06, 0x08, 0x09, 0x0A, 0x14, 0x65, 0x62, 0x64,\n  0xB4, 0x15, 0x17, 0x1A, 0x1B, 0xB0, 0xB2, 0x20,\n  0x21, 0x22, 0x23, 0x24, 0x28, 0x29, 0x46, 0x66,\n  0x2A, 0x2B, 0x2C, 0x30, 0x31, 0x33, 0x34, 0x9F,\n  0x8C, 0xAC, 0x72, 0x73, 0x74, 0x35, 0x75, 0x76,\n  0x77, 0x36, 0x38, 0x39, 0x3A, 0xCC, 0x78, 0x3B,\n  0xEE, 0xA1, 0xEB, 0xED, 0xCF, 0xEF, 0xA0, 0x8E,\n  0xAE, 0xFE, 0xFB, 0xFD, 0x8D, 0xAD, 0xBC, 0xBE,\n  0xCA, 0x8F, 0x3E, 0xB9, 0xB6, 0x7C, 0xE1, 0x9D,\n  0x90, 0xBD, 0xB3, 0xDA, 0xFA, 0xEA, 0xFF, 0x41\n\u00fc ;\n\n// EBCDIC->ASCII table (273->ISO8859-1)\nextern const unsigned char isis_etoa_ISO8859_1\u00c4256\u00dc =\n\u00e4\n   0x00, 0x01, 0x02, 0x03, 0x9C, 0x09, 0x86, 0x7F,\n   0x97, 0x8D, 0x8E, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n   0x10, 0x11, 0x12, 0x13, 0x9D, 0x0A, 0x08, 0x87,\n   0x18, 0x19, 0x92, 0x8F, 0x1C, 0x1D, 0x1E, 0x1F,\n   0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1B,\n   0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x05, 0x06, 0x07,\n   0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04,\n   0x98, 0x99, 0x9A, 0x9B, 0x14, 0x15, 0x9E, 0x1A,\n   0x20, 0xA0, 0xE2, 0x7B, 0xE0, 0xE1, 0xE3, 0xE5,\n   0xE7, 0xF1, 0xC4, 0x2E, 0x3C, 0x28, 0x2B, 0x21,\n   0x26, 0xE9, 0xEA, 0xEB, 0xE8, 0xED, 0xEE, 0xEF,\n   0xEC, 0x7E, 0xDC, 0x24, 0x2A, 0x29, 0x3B, 0x5E,\n   0x2D, 0x2F, 0xC2, 0x5B, 0xC0, 0xC1, 0xC3, 0xC5,\n   0xC7, 0xD1, 0xF6, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,\n   0xF8, 0xC9, 0xCA, 0xCB, 0xC8, 0xCD, 0xCE, 0xCF,\n   0xCC, 0x60, 0x3A, 0x23, 0xA7, 0x27, 0x3D, 0x22,\n   0xD8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n   0x68, 0x69, 0xAB, 0xBB, 0xF0, 0xFD, 0xFE, 0xB1,\n   0xB0, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n   0x71, 0x72, 0xAA, 0xBA, 0xE6, 0xB8, 0xC6, 0xA4,\n   0xB5, 0xDF, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n   0x79, 0x7A, 0xA1, 0xBF, 0xD0, 0xDD, 0xDE, 0xAE,\n   0xA2, 0xA3, 0xA5, 0xB7, 0xA9, 0x40, 0xB6, 0xBC,\n   0xBD, 0xBE, 0xAC, 0x7C, 0xAF, 0xA8, 0xB4, 0xD7,\n   0xE4, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n   0x48, 0x49, 0xAD, 0xF4, 0xA6, 0xF2, 0xF3, 0xF5,\n   0xFC, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n   0x51, 0x52, 0xB9, 0xFB, 0x7D, 0xF9, 0xFA, 0xFF,\n   0xD6, 0xF7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n   0x59, 0x5A, 0xB2, 0xD4, 0x5C, 0xD2, 0xD3, 0xD5,\n   0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n   0x38, 0x39, 0xB3, 0xDB, 0x5D, 0xD9, 0xDA, 0x9F\n\u00fc ;\n\n// ASCII->EBCDIC table (ISO8859-1->273)\nextern const unsigned char isis_atoe_ISO8859_1\u00c4256\u00dc =\n\u00e4\n  0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n  0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n  0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,\n  0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,\n  0x40, 0x4F, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,\n  0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,\n  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n  0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,\n  0xB5, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n  0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,\n  0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n  0xE7, 0xE8, 0xE9, 0x63, 0xEC, 0xFC, 0x5F, 0x6D,\n  0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n  0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n  0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,\n  0xA7, 0xA8, 0xA9, 0x43, 0xBB, 0xDC, 0x59, 0x07,\n  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x06, 0x17,\n  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x09, 0x0A, 0x1B,\n  0x30, 0x31, 0x1A, 0x33, 0x34, 0x35, 0x36, 0x08,\n  0x38, 0x39, 0x3A, 0x3B, 0x04, 0x14, 0x3E, 0xFF,\n  0x41, 0xAA, 0xB0, 0xB1, 0x9F, 0xB2, 0xCC, 0x7C,\n  0xBD, 0xB4, 0x9A, 0x8A, 0xBA, 0xCA, 0xAF, 0xBC,\n  0x90, 0x8F, 0xEA, 0xFA, 0xBE, 0xA0, 0xB6, 0xB3,\n  0x9D, 0xDA, 0x9B, 0x8B, 0xB7, 0xB8, 0xB9, 0xAB,\n  0x64, 0x65, 0x62, 0x66, 0x4A, 0x67, 0x9E, 0x68,\n  0x74, 0x71, 0x72, 0x73, 0x78, 0x75, 0x76, 0x77,\n  0xAC, 0x69, 0xED, 0xEE, 0xEB, 0xEF, 0xE0, 0xBF,\n  0x80, 0xFD, 0xFE, 0xFB, 0x5A, 0xAD, 0xAE, 0xA1,\n  0x44, 0x45, 0x42, 0x46, 0xC0, 0x47, 0x9C, 0x48,\n  0x54, 0x51, 0x52, 0x53, 0x58, 0x55, 0x56, 0x57,\n  0x8C, 0x49, 0xCD, 0xCE, 0xCB, 0xCF, 0x6A, 0xE1,\n  0x70, 0xDD, 0xDE, 0xDB, 0xD0, 0x8D, 0x8E, 0xDF\n\u00fc ;\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDSSDB": {"ttr": 1407, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "??=pragma filetag(\"IBM-273\")\n??=pragma nomargins nosequence\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <string.h>\n#include <stddef.h>\nextern \"OS\" void DSNHLI(void *);\ntypedef struct\n              \u00e4 short   SQLPLLEN;\n                short   SQLFLAGS;\n                short   SQLCTYPE;\n                char    SQLPROGN??(8??);\n                unsigned short SQLTIMES??(4??);\n                short   SQLSECTN;\n                char   *SQLCODEP;\n                char   *SQLVPARM;\n                char   *SQLAPARM;\n                short   SQLSTNM7;\n                short   SQLSTYPE;\n                long    SQLSTNUM;\n                unsigned long SQLRSRVD??(5??);\n              \u00fc SQLPLIST;\ntypedef struct\n              \u00e4 short    SQLTYPE;\n                short    SQLLEN;\n                char    *SQLADDR;\n                char    *SQLIND;\n                short    SQLNAMLEN;\n                char     SQLNAMDATA??(30??);\n              \u00fc SQLELTS;\ntypedef SQLELTS     *SQLELTS_PTR;\ntypedef struct\n              \u00e4 long          SQLLONGLEN;\n                unsigned long RESERVED;\n                char         *SQLDATALEN;\n                short         SQLNAMLEN;\n                char          SQLNAMDATA??(30??);\n              \u00fc SQLELTS2;\ntypedef struct\n    \u00e4 char   SQLDAID??(8??);\n      long   SQLDABC;\n      short  SQLN;\n      short  SQLD;\n      char  SQLPVELT??( sizeof(SQLELTS) ??);\n    \u00fc SQLPVARS;\ntypedef SQLPVARS *SQLPVARS_PTR;\nchar    SQLTEMP??( 129 ??) ;\nlong    DSNTEMP ;\nlong    DSNNROWS ;\nchar    DSNPNM??( 387 ??) ;\n#define SQL_FILE_READ 2\n#define SQL_FILE_CREATE 8\n#define SQL_FILE_OVERWRITE 16\n#define SQL_FILE_APPEND 32\nclass mERROR;\n\nclass mERRORPSTACK \u00e4\nprivate:\n   long int ip;\n   long int max;\n   mERROR * * sp;\npublic:\n   mERRORPSTACK(long int size=256);\n   void push(mERROR * value);\n   mERROR * examine();\n   int    callNextHandler(int);\n   mERROR * pop();\n   void  reset();\n  \u00dfmERRORPSTACK();\n\n\u00fc;\n\n\nclass mERROR\n\u00e4\nprotected:\n   char err;\n   int (* handler)(int);\nenum ERROR_ACTION\u00e4Warning, Abort\u00fc;\npublic:\n\nstatic int max_rc;\n\nfriend class mERRORPSTACK;\n   mERROR();\n   mERROR(int (*)(int) );\n\t virtual \u00dfmERROR()\u00e4\u00fc;\n   long int iserror()\u00e4return err;\u00fc\n   int  markerror(int code = 1)\n   \u00e4\n    err = 1;\n    if (handler) return (handler(code));\n    else return 0;\n   \u00fc\n   void clearerror()\u00e4err = 0;\u00fc\n   void setmERRORHandler(int (*h)(int))\u00e4handler = h;\u00fc\n   int error(char *,ERROR_ACTION);\n\u00fc;\n\nextern mERRORPSTACK mErrorPStack;\n\n\n\n\n\n\n\n\n\n\n\n\nextern \"C\"\nchar * genOpenName(const char *name, char *nm);\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n  extern \"C\" \u00e4\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\nextern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n   extern \"C\" \u00e4\n\n   typedef  int ptrdiff_t;\n\n       typedef unsigned int size_t;\n\n\n\n\n\n   \u00fc\n\n                   #pragma checkout(resume)\n\n  extern \"C\" \u00e4\n\n\n\n\n\n        extern \"builtin\"\n\n        int     __clcl (void*, void*, unsigned int*,\n                        unsigned int*, unsigned char);\n\n\n\n\n        extern \"builtin\"\n\n        int     __stck (unsigned long long *);\n\n\n\n\n        extern \"builtin\"\n\n        int     __stcke (void *);\n\n\n\n\n        #pragma pack (1)\n\n          typedef struct __stcke_tod \u00e4\n            unsigned char      c;\n            unsigned long long slice;\n            unsigned int       i;\n          \u00fc __stcke_tod_t;\n\n          typedef struct __stcke_tag \u00e4\n            unsigned char  zeros;\n            __stcke_tod_t  tod;\n            unsigned short p_field;\n          \u00fc __stcke_t;\n        #pragma pack (reset)\n\n\n\n\n\n        extern \"builtin\" \u00e4\n\n        void  __tr (unsigned char*, const unsigned char*,              \u00d6\n       unsigned char);\n\n      \u00fc\n\n        extern \"builtin\" \u00e4\n\n        int  __ed (unsigned char*, unsigned char*, unsigned char);\n        int  __edmk (unsigned char*, unsigned char*,                   \u00d6\n   unsigned char, unsigned char**);\n        int  __trt (unsigned char*, const unsigned char*,              \u00d6\n       unsigned char, unsigned char*, unsigned char**);\n        int  __nc (unsigned char*, unsigned char*, unsigned char);\n        int  __oc (unsigned char*, unsigned char*, unsigned char);\n        int  __xc (unsigned char*, unsigned char*, unsigned char);\n        void __pack (unsigned char*, unsigned char,                    \u00d6\n  unsigned char*, unsigned char);\n        void __unpk (unsigned char*, unsigned char,                    \u00d6\n  unsigned char*, unsigned char);\n\n      \u00fc\n\n        long double  __fmaddl (long double, long double, long double);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int    __lper (float*, float);\n        int    __lpdr (double*, double);\n        int    __lner (float*, float);\n        int    __lndr (double*, double);\n        float  __sqer (float);\n        double __sqdr (double);\n\n      \u00fc\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        float       __fier (float);\n        double      __fidr (double);\n        long double __fixr (long double);\n        int         __cfer (int*, int, float);\n        int         __cfdr (int*, int, double);\n        int         __cfxr (int*, int, long double);\n        int         __lpxr (long double*, long double);\n        int         __lnxr (long double*, long double);\n        long double __sqxr (long double);\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int __thder (double*, float);\n        int __thdr  (double*, double);\n        int __tbedr (float*, int, double);\n        int __tbdr  (double*, int, double);\n\n      \u00fc\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        unsigned short __lrvh  (unsigned short*);\n        unsigned int   __lrv   (unsigned int*);\n        void  __strvh (unsigned short, unsigned short*);\n        void  __strv  (unsigned int, unsigned int*);\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int  __cvb(char *op2);\n        void __cvd(int op1, char *op2);\n        int  __zap(unsigned char *op1, unsigned char len1,\n                   unsigned char *op2, unsigned char len2);\n\n\n\n\n\n          int __clcle(char *op1, unsigned long op1_len, unsigned char o\u00d6\np2,\n                      char *op3, unsigned long op3_len);\n          int __mvcle(char *op1, unsigned long op1_len, unsigned char o\u00d6\np2,\n                      char *op3, unsigned long op3_len);\n\n\n\n\n\n          int __tre(char *op1, unsigned long op1_len,\n                    char *op2, unsigned char test_char);\n\n\n            long long __cvbg(char *op2);\n            void      __cvdg(long long op1, char *op2);\n\n\n\n\n\n\n\n\n\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        typedef union \u00e4\n            struct __dword \u00e4\n                unsigned int __high_word;\n                unsigned int __low_word;\n            \u00fc __s_dword;\n            unsigned long long __dword;\n        \u00fc __plo_entry_t;\n\n        typedef union \u00e4\n            unsigned long long   __val;\n            unsigned long long * __ptr;\n        \u00fc __plo_ull_ullptr_t;\n\n        typedef union \u00e4\n            unsigned int       * __uint_ptr;\n            unsigned long long * __ull_ptr;\n        \u00fc __plo_uintptr_ullptr_t;\n\n        typedef __plo_ull_ullptr_t __plo_plist\u00c418\u00dc;\n\n\n\n\n\n\n\n          extern \"builtin\" \u00e4\n\n          int __plo_CL     (void *lock,\n                            unsigned int *op1c, unsigned int *op2,\n                            unsigned int *op3, unsigned int *op4);\n          int __plo_CS     (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2);\n          int __plo_DCS    (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2,\n                            unsigned int *op3c, unsigned int op3r,\n                            unsigned int *op4);\n          int __plo_CSST   (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2,\n                            unsigned int op3, unsigned int *op4);\n          int __plo_CSDST  (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2, void *param_list);\n          int __plo_CSTST  (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2, void *param_list);\n\n        \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n    typedef struct __div_t\n      \u00e4\n      int quot;\n      int rem;\n      \u00fc div_t;\n\n    typedef struct __ldiv_t\n      \u00e4\n      long int quot;\n      long int rem;\n      \u00fc ldiv_t;\n\n   typedef struct \u00e4\n               long long quot;\n               long long rem;\n   \u00fc lldiv_t;\n\n       typedef struct \u00e4\n                 long  __uheap_size;\n                 long  __uheap_bytes_alloc;\n                 long  __uheap_bytes_free;\n       \u00fc hreport_t;\n\n\n\n\n\n      extern \"builtin\"\n      void **_Gtab(int);\n\n      extern \"builtin\"\n      const void *_gtca(void);\n\n\n\n\n\n\n\n\n      long long int strtoll(const char * restrict, char * * restrict, i\u00d6\nnt);\n      unsigned long long int strtoull(const char * restrict, char * * r\u00d6\nestrict, int);\n        #pragma map (strtoll,   \"\u00d6174\u00d6174STRLL\")\n        #pragma map (strtoull,  \"\u00d6174\u00d6174STRULL\")\n\n    double   atof (const char *);\n    int      atoi (const char *);\n    long int atol (const char *);\n    double   strtod (const char * restrict, char * * restrict);\n    long int strtol (const char * restrict, char * * restrict,\n                      int);\n    unsigned long int strtoul (const char * restrict,\n                                char * * restrict, int);\n    int      rand (void);\n    void     srand (unsigned int);\n        long long int strtoll (const char * restrict,\n                                char * * restrict, int);\n        unsigned long long int strtoull (const char * restrict,\n                                          char * * restrict, int);\n\n\n\n\n      void *   calloc (size_t, size_t);\n      void     free (void *);\n      void *   malloc (size_t);\n      void *   realloc (void *, size_t);\n\n\n\n    extern \"builtin\"\n    int       __abs (int);\n\n\n\n     #pragma map (__getenv,        \"\u00d6174\u00d6174GETENV\")\n\n\n\n    void     abort (void);\n    int      atexit (void (*)(void));\n    void     exit (int);\n    char *   getenv (const char *);\n    char *   __getenv (const char *);\n    int      system (const char *);\n    void *   bsearch (const void *, const void *,\n                      size_t, size_t,\n                      int (*)(const void *,\n                                    const void *));\n    void     qsort (void *, size_t, size_t,\n                    int (*)(const void *,\n                                  const void *));\n\n    int unatexit(void (*)(void));\n\n\n        int      __heaprpt(hreport_t *);\n\n    extern \"C++\" \u00e4\n      inline int abs (int x) \u00e4 return __abs(x); \u00fc\n    \u00fc\n\n\n\n\n\n\n    div_t    div (int, int);\n    long int labs (long int);\n    ldiv_t   ldiv (long int, long int);\n    int      mblen (const char *, size_t);\n    int      mbtowc (wchar_t * restrict,\n                      const char * restrict, size_t);\n    int      wctomb (char *, wchar_t);\n    size_t   mbstowcs (wchar_t * restrict,\n                        const char * restrict, size_t);\n    size_t   wcstombs (char * restrict,\n                        const wchar_t * restrict, size_t);\n\n\n      long long llabs(long long );\n      lldiv_t lldiv(long long , long long );\n\n\n\n\n\n\n\n\n\n\n\n      void (*  fetch (const char *))();\n      void (*  fetchep (void (*)()))();\n      int    release (void (*)());\n\n\n        inline int fortrc (void)\n          \u00e4  return (*( (int *)((char *)_gtca() + 568) ))/4; \u00fc\n\n\n\n      #pragma map (rpmatch, \"\u00d6174\u00d6174RPMTCH\")\n      #pragma map (csid,    \"\u00d6174\u00d6174CSID\")\n      #pragma map (wcsid,   \"\u00d6174\u00d6174WCSID\")\n\n      int __librel (void);\n        int clearenv (void);\n      int rpmatch(const char *);\n      int csid(const char *);\n      int wcsid(const wchar_t);\n\n\n      typedef unsigned int cs_t;\n\n      typedef union \u00e4\n        struct \u00e4\n          unsigned int first_word;\n          unsigned int second_word;\n        \u00fc double_word;\n        double alignment_dummy;\n      \u00fc cds_t;\n\n        extern \"builtin\"\n\n      int     __cs (cs_t *, cs_t *, cs_t);\n      int     (cs) (cs_t *, cs_t *, cs_t);\n\n        extern \"builtin\"\n\n        int     __cs1 (void *, void *, void *);\n\n\n\n\n        extern \"builtin\"\n\n      int     __cds (cds_t *, cds_t *, cds_t);\n      int     (cds) (cds_t *, cds_t *, cds_t);\n\n        extern \"builtin\"\n\n        int     __cds1 (void *, void *, void *);\n\n\n\n\n\n\n\n\n\n\n\n\n    #pragma map(__EnvnA, \"\u00d6174\u00d6174ENVNA\")\n\n    char *** __EnvnA(void);\n    char *** __Envn(void);\n\n\n\n\n\n\n\n\n            extern \"builtin\"\n            void *__alloca(unsigned int x);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        double       drand48(void);\n        double       erand48(unsigned short int \u00c43\u00dc);\n        long int     jrand48(unsigned short int \u00c43\u00dc);\n        void         lcong48(unsigned short int \u00c47\u00dc);\n        long int     lrand48(void);\n        long int     mrand48(void);\n        long int     nrand48(unsigned short int \u00c43\u00dc);\n          int          putenv(const char *);\n        unsigned short int  *seed48(unsigned short int \u00c43\u00dc);\n        void         srand48(long int);\n          void         setkey(const char *);\n\n\n\n\n\n\n\n\n\n\n        long         a64l(const char *);\n        char        *ecvt(double, int, int * restrict,\n                                       int * restrict);\n        char        *fcvt(double, int, int * restrict,\n                                       int * restrict);\n        char        *gcvt(double, int, char *);\n        int          getsubopt(char **, char *const *, char **);\n        char        *initstate(unsigned, char *, size_t);\n        char        *l64a(long);\n        int          mkstemp(char *);\n        char        *mktemp(char *);\n        long         random(void);\n        char        *realpath(const char * restrict,\n                                    char * restrict);\n        char        *setstate(const char *);\n        void         srandom(unsigned);\n           int          ttyslot(void);\n           void        *valloc(size_t);\n          int          grantpt(int);\n          char        *ptsname(int);\n          int          unlockpt(int);\n\n\n\n\n       int rand_r(unsigned int *);\n\n\n\n\n    int __discarddata(void *, size_t);\n\n\n\n          int setenv (const char *, const char *, int);\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n\n  extern \"C++\" \u00e4\n        inline long abs (long x) \u00e4 return labs(x); \u00fc\n        inline ldiv_t div (long x, long y)\n        \u00e4 return ldiv(x,y); \u00fc\n  \u00fc\n\n\n                   #pragma checkout(resume)\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n          typedef unsigned int dev_t ;\n\n\n\n\n             typedef int gid_t;\n\n\n\n\n          typedef unsigned int  ino_t ;\n\n\n\n          typedef int mode_t ;\n\n\n\n\n          typedef int nlink_t ;\n\n\n\n\n\n            typedef  int off_t ;\n\n\n           typedef long long off64_t;\n\n\n          typedef signed int pid_t ;\n\n\n\n\n            typedef signed int ssize_t ;\n\n\n\n\n             typedef int uid_t;\n\n\n\n\n\n\n\n          typedef long time_t ;\n\n\n\n          typedef unsigned long clock_t;\n\n\n\n          typedef struct \u00e4\n                     unsigned int   __sigs_0;\n                     unsigned int   __sigs_1;\n                  \u00fc sigset_t ;\n\n\n\n          typedef unsigned char cc_t;\n\n\n\n          typedef unsigned int speed_t ;\n\n\n\n          typedef unsigned int tcflag_t ;\n\n\n\n\n\n\n\n          typedef unsigned int mtm_t ;\n\n\n\n\n          typedef unsigned int rdev_t ;\n\n\n\n\n          typedef char tid_t\u00c48\u00dc;\n\n\n            typedef struct \u00e4\n                      char __\u00c40x08\u00dc;\n            \u00fc __osenv_token;\n\n\n\n\n\n\n\n          typedef struct \u00e4\n                     char __\u00c40x08\u00dc;\n          \u00fc pthread_t;\n\n          typedef  struct \u00e4\n                      char __\u00c40x58\u00dc;\n          \u00fc pthread_attr_t;\n\n             typedef struct \u00e4\n                        unsigned long __m;\n             \u00fc pthread_mutex_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_mutexattr_t;\n\n                typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n                \u00fc pthread_cond_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_condattr_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_key_t;\n\n          typedef int pthread_once_t;\n\n             typedef struct \u00e4\n                        char __\u00c40x04\u00dc;\n              \u00fc pthread_rwlockattr_t;\n\n             typedef struct \u00e4\n                        char __\u00c40x04\u00dc;\n              \u00fc pthread_rwlock_t;\n\n\n\n\n\n\n\n         typedef long key_t;\n\n\n\n\n\n\n\n         typedef int id_t;\n\n         typedef unsigned int  useconds_t;\n\n\n         typedef unsigned char sa_family_t;\n\n\n\n         typedef unsigned short in_port_t;\n\n\n            typedef long mcontext_t\u00c440\u00dc;\n\n\n\n\n\n          typedef  unsigned char  u_char;\n\n          typedef  unsigned int   u_int;\n\n          typedef  unsigned short ushort;\n\n          typedef  unsigned short u_short;\n\n          typedef  unsigned long  u_long;\n\n\n\n\n\n         typedef unsigned long in_addr_t;\n\n         typedef in_addr_t ip_addr_t;\n\n\n         typedef  char *    caddr_t;\n\n\n\n\n\n\n         typedef signed long blkcnt_t;\n\n         typedef signed int    blksize_t;\n\n         typedef unsigned long fsblkcnt_t;\n\n         typedef unsigned int  fsfilcnt_t;\n\n\n         typedef signed int    suseconds_t;\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n     struct __file;\n     typedef int _GETCFUNC(struct __file *);\n     typedef int _PUTCFUNC(int, struct __file *);\n     struct __file\n        \u00e4\n        unsigned char  *__bufPtr;\n        long int        __countIn;\n        long int        __countOut;\n        _GETCFUNC      *__fcbgetc;\n        _PUTCFUNC      *__fcbputc;\n        unsigned int    __cntlinterpret : 1;\n        unsigned int    __fcb_ascii : 1;\n        unsigned int    __fcb_orientation : 2;\n        \u00fc;\n\n     struct __ffile\n       \u00e4\n       struct __file *__fp;\n       \u00fc;\n\n     typedef struct __ffile *__FILEP;\n\n\n     typedef struct __ffile FILE;\n\n  struct __fpos_t \u00e4\n    long int __fpos_elem\u00c48\u00dc;\n    \u00fc;\n\n  typedef struct __fpos_t fpos_t;\n\n\n\n\n\n\n      typedef char  *___valist;\n    typedef ___valist  va_list;\n\n\n\n\n\n\n\n\n\n\n     typedef const unsigned short *__cusp;\n\n\n\n\n\n\n\n\n\n      #pragma map (vprintf, \"\u00d6174\u00d6174VPRNT\")\n      #pragma map (vfprintf, \"\u00d6174\u00d6174VFPRT\")\n        #pragma map (vsprintf, \"\u00d6174\u00d6174VSPRT\")\n\n\n\n\n    void     clearerr (FILE *);\n    int      fclose (FILE *);\n    int      feof (FILE *);\n    int      ferror (FILE *);\n    int      fflush (FILE *);\n    int      fgetc (FILE *);\n    int      fgetpos (FILE * restrict, fpos_t * restrict);\n    char    *fgets (char * restrict, int, FILE * restrict);\n    FILE    *fopen (const char * restrict,\n                    const char * restrict);\n    int      fprintf (FILE * restrict,\n                       const char * restrict, ...);\n    int      fputc (int, FILE *);\n    int      fputs (const char * restrict, FILE * restrict);\n    size_t   fread (void * restrict, size_t,\n                    size_t, FILE * restrict);\n    FILE    *freopen (const char * restrict,\n                      const char * restrict, FILE * restrict);\n    int      fscanf (FILE * restrict,\n                      const char * restrict, ...);\n    int      fseek (FILE *, long int, int);\n    int      fsetpos (FILE *, const fpos_t *);\n    long int ftell (FILE *);\n   size_t   fwrite (const void * restrict, size_t, size_t,\n                     FILE * restrict);\n    int      getc (FILE *);\n    int      getchar (void);\n    char    *gets (char *);\n    void     perror (const char *);\n    int      printf (const char * restrict, ...);\n    int      putc (int, FILE *);\n    int      putchar (int);\n    int      puts (const char *);\n    int      remove (const char *);\n    int      rename (const char *, const char *);\n    void     rewind (FILE *);\n    int      scanf (const char * restrict, ...);\n    void     setbuf (FILE * restrict, char * restrict);\n    int      setvbuf (FILE * restrict, char * restrict,\n                      int, size_t);\n      int      sprintf (char * restrict,\n                         const char * restrict, ...);\n    int      sscanf (const char * restrict,\n                     const char * restrict, ...);\n    FILE    *tmpfile (void);\n    char    *tmpnam (char *);\n    int      ungetc (int, FILE *);\n    int      vfprintf (FILE * restrict,\n                        const char * restrict, ___valist);\n    int      vprintf (const char * restrict, ___valist);\n    int      vsprintf (char * restrict,\n                        const char * restrict, ___valist);\n\n\n         off_t ftello(FILE *);\n         int fseeko(FILE *, off_t, int);\n\n\n\n\n\n\n\n\n      struct __S99struc\n        \u00e4\n             unsigned char __S99RBLN;\n             unsigned char __S99VERB;\n             unsigned short __S99FLAG1;\n             unsigned short __S99ERROR;\n             unsigned short __S99INFO;\n             void *__S99TXTPP;\n             void *__S99S99X;\n             unsigned int   __S99FLAG2;\n        \u00fc;\n\n      typedef struct __S99struc __S99parms;\n\n\n    struct __S99rbx\n          \u00e4\n        char           __S99EID\u00c46\u00dc;\n        unsigned char  __S99EVER;\n        unsigned char  __S99EOPTS;\n        unsigned char  __S99ESUBP;\n        unsigned char  __S99EKEY;\n        unsigned char  __S99EMGSV;\n        unsigned char  __S99ENMSG;\n        void *__S99ECPPL;\n        char           __reserved;\n        char           __S99ERES;\n        unsigned char  __S99ERCO;\n        unsigned char  __S99ERCF;\n        int            __S99EWRC;\n        void *__S99EMSGP;\n        unsigned short __S99EERR;\n        unsigned short __S99EINFO;\n        int            __reserv2;\n        \u00fc;\n\n     typedef struct __S99rbx  __S99rbx_t;\n\n     struct  __S99emparms \u00e4\n        unsigned char  __EMFUNCT;\n        unsigned char  __EMIDNUM;\n        unsigned char  __EMNMSGBK;\n        unsigned char  __filler1;\n        void *__EMS99RBP;\n        int            __EMRETCOD;\n        void *__EMCPPLP;\n        void *__EMBUFP;\n        int            __reserv1;\n        int            __reserv2;\n        \u00fc;\n\n       typedef struct __S99emparms  __S99emparms_t;\n\n\n\n    typedef enum \u00e4\n       __disk       =  0,\n       __terminal   =  1,\n       __printer    =  2,\n       __tape       =  3,\n       __tdq        =  5,\n       __dummy      =  6,\n\n       __msgfile    =  7,\n\n       __memory     =  8,\n       __hfs        =  9,\n       __hiperspace = 10,\n\n       __msgrtn     = 11,\n\n       __other      = 0xff\n    \u00fc __device_t;\n\n\n\n\n\n\n\n\n    struct __fileData \u00e4\n         unsigned int   __recfmF   :    1,\n                        __recfmV   :    1,\n                        __recfmU   :    1,\n                        __recfmS   :    1,\n                        __recfmBlk :    1,\n                        __recfmASA :    1,\n                        __recfmM   :    1,\n                        __dsorgPO  :    1,\n                        __dsorgPDSmem : 1,\n                        __dsorgPDSdir : 1,\n                        __dsorgPS  :    1,\n                        __dsorgConcat : 1,\n                        __dsorgMem :    1,\n                        __dsorgHiper  : 1,\n                        __dsorgTemp:    1,\n                        __dsorgVSAM:    1,\n\n                        __dsorgHFS :    1,\n\n                        __openmode :    2,\n                        __modeflag :    4,\n                        __dsorgPDSE :   1,\n\n                        __vsamRLS :     3,\n                        __vsamEA  :     1,\n                        __recfmB  :     1,\n                        __reserve2 :    3;\n\n         __device_t     __device;\n         unsigned long  __blksize,\n                        __maxreclen;\n         union \u00e4\n           struct \u00e4\n             unsigned short __vsam_type;\n             unsigned long  __vsam_keylen;\n             unsigned long  __vsam_RKP;\n           \u00fc __vsam;\n           struct \u00e4\n             unsigned short __disk_vsam_type;\n             unsigned char  __disk_access_method;\n             unsigned char  __disk_noseek_to_seek;\n             long           __disk_reserve\u00c42\u00dc;\n           \u00fc __disk;\n         \u00fc __device_specific;\n         char *         __dsname;\n         void *         __reserve4;\n    \u00fc;\n\n    typedef struct __fileData fldata_t;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int    svc99 (__S99parms *);\n      int    flocate (FILE *, const void *, size_t, int);\n      int    fdelrec (FILE *);\n      size_t fupdate (const void *, size_t, FILE *);\n      int    clrmemf (int);\n      int    fldata (FILE *, char *, fldata_t *);\n\n\n\n\n\n\n\n\n    typedef struct \u00e4\n              unsigned int  __fill,\n                            __recnum;\n    \u00fc __rrds_key_type;\n\n\n      typedef struct __amrctype \u00e4\n\n       union \u00e4\n               int __error;\n          struct \u00e4\n            unsigned short __syscode,\n                           __rc;\n          \u00fc __abend;\n          struct \u00e4\n             unsigned char __fdbk_fill,\n                           __rc,\n                           __ftncd,\n                           __fdbk;\n          \u00fc __feedback;\n          struct \u00e4\n             unsigned short __svc99_info,\n                            __svc99_error;\n          \u00fc __alloc;\n       \u00fc __code;\n       unsigned int  __RBA;\n       unsigned int      __last_op;\n       struct \u00e4\n        unsigned int   __len_fill;\n        unsigned int   __len;\n        char           __str\u00c4120\u00dc;\n        unsigned int   __parmr0;\n        unsigned int   __parmr1;\n        unsigned int   __fill2\u00c42\u00dc;\n        char           __str2\u00c464\u00dc;\n\n       \u00fc __msg;\n\n       unsigned char        __rplfdbwd\u00c44\u00dc;\n       unsigned long long   __XRBA;\n\n       unsigned char        __amrc_noseek_to_seek;\n\n       char                 __amrc_pad\u00c423\u00dc;\n\n    \u00fc __amrc_type;\n\n\n    typedef __amrc_type *__amrc_ptr;\n\n\n    typedef struct __amrc2type \u00e4\n             int       __error2;\n\n        FILE          *__fileptr;\n             int       __reserved\u00c46\u00dc;\n    \u00fc __amrc2_type;\n\n\n    typedef __amrc2_type *__amrc2_ptr;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        FILE *fdopen(int, const char *);\n        int fileno(FILE *);\n        char *ctermid(char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         char *cuserid(char *);\n\n\n          int          getopt(int, char * const \u00c4\u00dc, const char *);\n\n\n         int getw(FILE *);\n         int putw(int, FILE *);\n\n       extern char *optarg;\n       extern int optind, opterr, optopt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n       int pclose(FILE *);\n       FILE *popen(const char *, const char *);\n       char  *tempnam(const char *, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n     #pragma map (__snprtf,  \"\u00d6174\u00d6174SNPRTF\")\n\n   int __snprtf(char *restrict, size_t, const char *restrict, ...);\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n  extern \"C\" \u00e4\n\n\n  void  __abort(void);\n  void  assert(int);\n\n\n\n\n  \u00fc\n\n\n\nextern \"C\" \u00e4\n\n\n\n\n\n\n      inline __FILEP* const * __gtab_filep(int e)       \u00e4 return (__FIL\u00d6\nEP* const *)_Gtab(e); \u00fc\n\n\n\n\n\u00fc\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\nenum genOpenNameType\n\u00e4  sas_hfs,\n   ibm_hfs,\n   sas_ddn,\n   ibm_ddn,\n   sas_dsn,\n   ibm_dsn,\n   ont_dsn,\n   ont_ddn,\n   ont_mem,\n   ont_unknown,\n   genOpenNameType_int = -1\n\u00fc;\n\ngenOpenNameType genOpenType(const char *);\nchar * stripMemberName(const char *name, char* nm);\nchar * onlyMemberName(const char *name, char* nm);\n\n\n\nunsigned short  Ushort(int i);\nunsigned short  Ushort(short s);\nunsigned short  Ushort(char c);\n\n\n\n\n\n\nvoid * memcpyp(void * target , const void * source, size_t tsize, size_\u00d6\nt ssize, int pad);\n\n\n\n\n\n\n\n\n\n\nenum ALIGNTYPE\u00e4aLEFT=1, aRIGHT=3, aCENTER=2, aASIS=0, ALINGNTYPE_int = \u00d6\n-1 \u00fc;\nenum CAPSTYPE\u00e4cUPPER=3, cLOWER=4, cWORD=2, cASIS=0, CAPSTYPE_int = -1\u00fc;\nenum FIELDTYPE\u00e4\n                      fCHAR =0,\n                      fALPHANUMERIC=1,\n                      fALPHABETIC=2,\n                      fNUMERIC= 3,\n                      fSLLTAG = 20,\n                      fLOGICAL=4 ,fHEXA=16,\n                      fBINARY=17 ,fDATE=5 ,fFTIME=6, fLISTBOX = 19,\n                      FIELDTYPE_int = -1\u00fc;\n\n\n\n\nclass FORMAT\n\u00e4\n   protected:\n   public:\n   ALIGNTYPE falign;\n   CAPSTYPE fcaps;\n  FORMAT() :  fcaps(cUPPER),\n    falign(aLEFT)\u00e4\u00fc\n\n  FORMAT(ALIGNTYPE a ,CAPSTYPE c=cASIS )\n  \u00e4\n\n    falign = a;\n      fcaps = c;\n  \u00fc\n  \u00dfFORMAT()\u00e4\u00fc\n\u00fc;\n\n\n\n\n\nextern FORMAT F_alcu;\nextern FORMAT F_alcw;\nextern FORMAT F_arcu;\n\n\n\nstruct str \u00e4\nenum status \u00e4 _VALID, _INVALID, status_int = -1 \u00fc;\nenum length \u00e4 FIX, VARIABLE \u00fc;\nchar  * c;\nchar  * lls;\nlong int     l;\nstatus type;\nlength ltype;\nstr()\u00e4 c = lls = 0; l = 0; type = _VALID; ltype = VARIABLE; \u00fc\n      \u00fc;\n\n\n\n\nclass sLL;\n\nclass mvsSTRING \u00e4\n   protected:\n   str st;\n   public:\n   static char parseSepCh;\n   mvsSTRING();\n   mvsSTRING(const char *);\n   mvsSTRING(const mvsSTRING &);\n   mvsSTRING(const char *,long int l );\n   mvsSTRING(const char , const long int l);\n\n\t\tvirtual \u00dfmvsSTRING();\n\n  virtual mvsSTRING& operator=(const char * );\n  virtual mvsSTRING& operator=(const mvsSTRING &);\n\t\tvirtual mvsSTRING& operator=(const sLL &);\n\n  virtual operator char *() const\n  \u00e4\n  if ( st.type == str::_VALID )\n      return st.c;\n\n   return st.c;\n   \u00fc\n   virtual operator unsigned char *() const\n  \u00e4\n  if ( st.type == str::_VALID )\n      return (unsigned char *)st.c;\n\n   return (unsigned char *)st.c;\n   \u00fc\n   virtual operator const char *() const\n   \u00e4\n    return (const char *)st.c;\n   \u00fc\n   virtual operator const unsigned char *() const\n   \u00e4\n    return (const unsigned char *)st.c;\n   \u00fc\n   friend long int operator==(const mvsSTRING & , const mvsSTRING &);\n   friend long int operator|=(const mvsSTRING & , const mvsSTRING &);\n   friend mvsSTRING operator+(const mvsSTRING & , const mvsSTRING &);\n\n   mvsSTRING& operator+=(const mvsSTRING&);\n   void operator<<(long int );\n   void operator>>(long int );\n\n   virtual char& operator\u00c4\u00dc(int);\n   virtual char& byte(int);\n   mvsSTRING operator()(const long int , long int );\n\n   long int hashcode();\n  char * nameOf();\n   long int  lengthOf() const\u00e4return st.l;\u00fc\n   long int toint()\n          \u00e4 long int ret = 0;\n             if ( st.l >= sizeof(long int) )\n                     ret = * (long int *)(st.c);\n           else if ( st.l == sizeof(short) )\n              ret = * (short *)(st.c);\n           else if ( st.l == 1)\n              ret = *st.c;\n         return ret ;\n       \u00fc\n   void fromint(long int i)\n       \u00e4\n             if ( st.l >= sizeof(long int) )\n                      *(long int *)(st.c) = i;\n           else if ( st.l == sizeof(short) )\n              *(short *)(st.c) = (short )i;\n           else if ( st.l == 1)\n          *st.c =(char) i;\n       \u00fc\n  void changeAll(char ,char );\n  void align(ALIGNTYPE );\n  void caps(CAPSTYPE);\n  mvsSTRING & strip();\n  int  isEmpty();\n  mvsSTRING& stripmvsSTRING();\n    mvsSTRING& format(FORMAT *);\n  void parse(mvsSTRING&, char, mvsSTRING&);\n  void parse(mvsSTRING&, char, mvsSTRING&, char ,mvsSTRING &);\n  void parse(mvsSTRING&, char *,mvsSTRING&);\n  void parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &);\n  void split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &);\n\tvoid split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mv\u00d6\nsSTRING &);\n\tvoid split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mv\u00d6\nsSTRING &,char *,mvsSTRING&);\n\tvoid parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &,char *,m\u00d6\nvsSTRING &);\n\tvoid dump(const char * ,int);\n  char * getLlmvsSTRING();\n\u00fc;\n\n\textern mvsSTRING nullstring;\n\n\n\nextern mvsSTRING nullmvsSTRING;\n\n\n\nclass LLC_mvsSTRING : public mvsSTRING\n\u00e4\n   short codev;\n  public:\n  LLC_mvsSTRING():mvsSTRING(), codev(0)\u00e4\u00fc\n  LLC_mvsSTRING(char * s):mvsSTRING(),codev(0)\n    \u00e4\n     short l = *(short*) s;\n     if ( l >= 4 )\n\n\t\t\t\t\u00e4\n\t\t\t\tmvsSTRING x = mvsSTRING(s+4,l-4);\n\t\t\t\tmvsSTRING::operator=(x);\n\t\t\t\tcodev = *(short *)(s+2);\n\t\t\t\t\u00fc\n    \u00fc\n   LLC_mvsSTRING(long int c):mvsSTRING() , codev(c)\u00e4\u00fc\n  \u00dfLLC_mvsSTRING()\u00e4\u00fc\n   long int   code(void)\u00e4return codev;\u00fc\n operator long int()\n       \u00e4 long int ret = 0;\n          if ( st.l == sizeof(long int) )\n                  ret = * (long int *)(st.c);\n         else if ( st.l == sizeof(short) )\n            ret = * (short *)(st.c);\n       else if ( st.l == 1)\n            ret = *st.c;\n       return ret ;\n    \u00fc\n\u00fc;\n\n\n\n\nmvsSTRING patternchng(mvsSTRING input , mvsSTRING mask,\n  mvsSTRING (*function)(mvsSTRING));\n\n\n\n\n\n\n\nclass mvsSTRING;\nclass mERROR;\n\n\n\n\n\n\n\n\nclass mvsSTRING;\nclass mERROR;\n\nclass INT3\n\u00e4\nprivate :\n   long v;\npublic:\n   INT3(long u)\u00e4 v = u;\u00fc\n   operator long()\u00e4return v;\u00fc\n   INT3 & operator=(long u)\u00e4 v = u;return *this;\u00fc\n\n\u00fc;\n\n\n\n\n\n\n\n\n\nenum sLLUsage \u00e4 sLLinput , sLLoutput , sLLoutputVar\u00fc ;\n\n\n\n\n\nenum sLLType   \u00e4sLLt0 = 0, sLLt1 = 1  ,sLLt2 = 2 , sLLt3 = 3 , sLLt4 = \u00d6\n4 \u00fc;\nenum sLLStatus \u00e4sLLOk = 0, sLLUf = 1  ,sLLOf = 2\u00fc;\n\nclass sLL;\n\n\nclass sLLskip\u00e4\nprivate:\n   int i;\npublic:\n   sLLskip(int v):i(v)\u00e4\u00fc\n   operator int()\u00e4return i;\u00fc\n\u00fc;\n\nclass sLL:public  mERROR\n\u00e4\n\nprotected:\n\n      int length;\n      int offset;\n      int llength;\n      int allocl;\n      int storedl;\n\n      sLL * base;\n      sLL * child;\n\n\n      char * start;\n      char * cursor;\n      sLLType type;\n      sLLStatus status;\n      char   dummy;\n\t\t\tmvsSTRING  string;\nprotected:\n      sLLUsage usage;\n\nprotected:\n\n    void init(sLL *,int,sLLType);\n    int storeOk(int);\n\npublic:\n\n\n\n\n\n    sLL (sLLType = sLLt2,\n            sLLUsage = sLLoutput,int=1024 );\n    sLL (sLL * , int ,\n            sLLType = sLLt2);\n    sLL (sLL * ,char *,\n            sLLType = sLLt2);\n    sLL (char *,\n            sLLType = sLLt2);\n      sLL (char *,\n                   int );\n\n\n    sLL (const sLL &);\n\n    virtual \u00dfsLL ();\n\n    virtual sLL & operator=(sLL &);\n\n\n\n\n\n      operator int();\n\n\n    char & operator\u00c4\u00dc(int);\n\n\t\t\tint   getLength() const\n\t\t\t\t\u00e4\n\t\t\t\tif ( usage == sLLinput ) return length;\n\t\t\t\telse return storedl;\n\t\t\t\t\u00fc\n\n\t\t\tchar * getStart() const\n\t\t\t\t\u00e4 return start; \u00fc\n\n    sLL * getBase();\n    int   getOffset();\n    sLL * getChild();\n\n\n    int   getFullLength();\n    int   getRemainderLength();\n    int   getStoredLength();\n\n    char * getCursor();\n\t\t\tmvsSTRING  getString();\n    void  setChild(sLL*);\n    void  setBase(sLL *);\n\n\n    void   setLength();\n    virtual void resetCursor();\n\n    char * goCursor(int);\n    void   setUsage(sLLUsage);\n\n\n\n\n\n    sLL * next();\n    sLL * iterate(sLLType,int = 0);\n    void remove(sLL& );\n\n\n\n\n\n\n    sLL& operator>>(int&);\n    sLL& operator>>(short&);\n    sLL& operator>>(unsigned short&);\n    sLL& operator>>(char &);\n    sLL& operator>>(char * &);\n    sLL& operator>>(mvsSTRING &);\n    sLL& operator>>(sLL &);\n    sLL& operator>>(INT3 &);\n    sLL& operator>>(sLLskip &);\n\n\n\n\n    sLL& operator<<(int);\n    sLL& operator<<(short);\n    sLL& operator<<(unsigned short);\n    sLL& operator<<(char );\n    sLL& operator<<(char *);\n    sLL& operator<<(mvsSTRING &);\n    sLL& operator<<(sLL& );\n    sLL& operator<<(INT3 &);\n    sLL& operator<<(sLLskip &);\n    sLL& store(char *,int);\n\n\n\n\n\n\n   int write(void *);\n   friend sLL * readsLL(void *,sLLType);\n\t\t\tvirtual void dump(const char *,int);\n\n\u00fc;\n\nclass sLLTag: public sLL\n\u00e4\nprivate:\n   short      code;\n   char       * name;\n   short      searchcode;\n   void       init(short);\npublic:\n   sLLTag();\n   sLLTag(short);\n\n   sLLTag(char *);\n   sLLTag(sLL * , char *);\n   sLLTag(const sLLTag &);\n\n   \u00dfsLLTag()\u00e4\u00fc\n\t\tsLLTag& operator=(sLLTag&);\n\n   short      getCode()\u00e4 return code;\u00fc\n   char *     getName()\u00e4 return name ;\u00fc\n   sLLTag *   search(short=0);\n   void       resetCursor();\n   void       remove(sLLTag &);\n   sLLTag *   update(sLLTag& );\n   sLLTag *   next();\n   sLLTag *   iterate();\n\t virtual void dump(const char *,int);\n\u00fc;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n        struct timespec\n            \u00e4\n            time_t tv_sec;\n            long   tv_nsec;\n            \u00fc;\n\n\n\n\n\n\n  struct tm\n     \u00e4\n     int tm_sec;\n     int tm_min;\n     int tm_hour;\n     int tm_mday;\n     int tm_mon;\n     int tm_year;\n     int tm_wday;\n     int tm_yday;\n     int tm_isdst;\n     \u00fc;\n\n    #pragma map(clock,\"\u00d6174\u00d6174OCLCK\")\n\n\n\n\n\n\n\n\n\n     clock_t     clock (void);\n     double      difftime (time_t, time_t);\n     time_t      mktime (struct tm *);\n     time_t      time (time_t *);\n     char       *asctime (const struct tm *);\n     char       *ctime (const time_t *);\n     struct tm  *gmtime (const time_t *);\n     struct tm  *localtime (const time_t *);\n     size_t      strftime (char * restrict, size_t,\n                           const char * restrict,\n                           const struct tm * restrict);\n     void        __tzset(void);\n\n\n      char    *strptime(const char *restrict, const char *restrict,\n                        struct tm *restrict);\n\n\n    inline char *ctime(const time_t *t) \u00e4return(asctime(localtime(t)));\u00fc\n       inline double difftime (time_t t1, time_t t0)\n                              \u00e4return((double)((t1) - (t0)));\u00fc\n\n\n\n\n\n\n\n\n\n         void tzset(void);\n\n      extern char *tzname\u00c42\u00dc;\n\n\n\n      #pragma map(__TzznA, \"\u00d6174\u00d6174TZZNA\")\n\n      char  *(*__TzznA(void))\u00c42\u00dc;\n      char  *(*__Tzzn(void))\u00c42\u00dc;\n\n\n\n\n\n\n\n\n\n\n      extern int daylight;\n      extern long int timezone;\n\n\n\n\n        long int *__tzone(void);\n        int *__dlght(void);\n\n\n\n      extern int   getdate_err;\n\n\n        struct tm *getdate(const char *);\n\n        int *__gderr(void);\n\n\n\n    char * asctime_r(const struct tm *restrict, char *restrict);\n    char * ctime_r(const time_t *, char*);\n    struct tm * gmtime_r(const time_t *restrict, struct tm *restrict);\n    struct tm * localtime_r(const time_t *restrict, struct tm *restrict\u00d6\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             \u00fc\n\n\n                   #pragma checkout(resume)\n\n\n\n\nunsigned long cvb(unsigned long,unsigned long = 8);\nunsigned long cvd(unsigned long);\nvoid    formatTime(char *,int,char *);\n\nint dump(FILE *,char *, char *,  int );\nint dump(FILE *,char *, void * , int );\nint dump(char *,int, char *, int);\n\nint  fromInt(char *,long ,int  = sizeof(long));\nlong toInt(char *,int);\nlong toInt(unsigned char *,int);\nint  roundToInt(double);\n\nint   Char2Hex(char *);\nchar * Hex2Char(char );\nint   isnull(char *,int = 0 );\n\n\n\nchar*   getTimeStemp();\nint     DatetoTm(tm&,char *);\nchar *  DatetoString(tm, char *);\n\nvoid  getUniqueKEY(char *);\nvoid  getUniqueLongKEY(char *);\nchar*   DatetoString();\nchar *\tDatetoIBM(char * from);\n\n\n\n\n\n\n\nint   strcmpiList(const char *,const char *\u00c4\u00dc,int &);\n\nchar *strrev(char *s);\n\nmvsSTRING makemvsSTRING(char *,int);\n\n  int stcpma(char * ,const char * );\n  void * memcpyp(void *,const void*,size_t,size_t,int);\n\n\n\nchar * Astrupr(char *, int);\nchar * ConvertmvsSTRINGToAscii( char *, int);\nchar aup(char);\n\nvoid  swab( char *,char *, int);\nchar *  StrDup(char *);\n\nchar   bit_rotate(unsigned char);\nmvsSTRING makemvsSTRING(char *,int);\nextern char __test__ ;\n\nextern unsigned char ETOA\u00c4256\u00dc;\nextern unsigned char ATOE\u00c4256\u00dc;\n\ninline int ffixed(FILE * f)\n\u00e4\n      fldata_t ft;\n      char fn\u00c4256\u00dc;\n      if (fldata(f,fn,&ft) == 0)\n         return (ft.__recfmF);\n      else\n\t\t\t\treturn 0;\n\u00fc\n\ninline void  strerror_r(int err, char *errmsg, int size)\n\u00e4\n    const char* msg=strerror(err);\n    if(strlen(msg)>size-1)\n    \u00e4\n        strncpy(errmsg,msg,size-1);\n        errmsg\u00c4size-1\u00dc='\u00d60';\n    \u00fc\n    else\n    \u00e4\n        strcpy(errmsg,msg);\n    \u00fc\n\u00fc\n\n\n\nnamespace isis_ns_mvs\n\t\u00e4\n\n\n\n\n\tenum MSGETypes\u00e4msgundef = 0, msgint    = 1,\n\t\tmsgshort = 2, msgcharp  = 3,\n\t\tmsgchar  = 4,  msgmvsSTRING = 5\u00fc;\n\n\n\tenum MSGEForm\u00e4msgfundef = 0, msgfd = 1, msgfs = 2, msgfx =3 , msgfc = \u00d6\n4\u00fc;\n\tclass MSGE\n\t\t\u00e4\n\t\tprivate:\n\t\t\tint         length;\n\t\t\tMSGEForm    form;\n\t\t\tMSGETypes   type;\n\t\t\tchar *      to;\n\t\t\tunion\u00e4\n\t\t\t\tchar     mchar;\n\t\t\t\tint      mint;\n\t\t\t\tshort    mshort;\n\t\t\t\tchar   * mcharp;\n\t\t\t\tmvsSTRING * mmvsSTRING;\n\t\t\t\t\u00fc;\n\t\tpublic:\n\t\t\tMSGE();\n\t\t\tMSGE(int i,int l=sizeof(int), MSGEForm f = msgfd);\n\t\t\tMSGE(short s,int l = sizeof(short), MSGEForm f= msgfd);\n\t\t\tMSGE(char * c,int l = 0, MSGEForm f = msgfs);\n\t\t\tMSGE(const mvsSTRING &s,int l = 0,MSGEForm f = msgfs );\n\t\t\tMSGE(char c);\n\n\t\t\t\u00dfMSGE()\n\t\t\t\t\u00e4\n\t\t\t\tif ( type == msgmvsSTRING) delete mmvsSTRING;\n\t\t\t\tif ( to ) delete \u00c4\u00dc to;\n\t\t\t\t\u00fc\n\t\t\tchar * format();\n\t\t\u00fc;\n\n\n\tclass EOL\u00e4\n\t\t\u00fc;\n\tconst EOL eol=EOL();\n\n\tMSGE * tCHARp(char * ,int  = 0);\n\n\tMSGE * tINT(int ,int = sizeof(int));\n\n\tMSGE * tSHORT(int ,int  = sizeof(short));\n\n\tMSGE * tmvsSTRING(mvsSTRING & ,int  = 0);\n\n\tMSGE * tHEX(int  ,int = (sizeof(int)*2) );\n\n\tMSGE * tHEX(char * , int);\n\n\n\n\n\tenum FLAG_VALUE\u00e4 FLAG_TEXT = 5, FLAG_IO = 4\u00fc;\n\n\ttypedef   struct  ENTRY\n\t\t\u00e4\n\t\tchar * name     ;\n\t\tchar flag       ;\n\t\tint  xcoord     ;\n\t\tint  ycoord     ;\n\t\tint  length     ;\n\t\tchar attrib     ;\n\t\tint  access     ;\n\t\tchar fieldtype  ;\n\t\tchar align      ;\n\t\tchar caps       ;\n\t\tchar * defvalue ;\n\t\t\u00fc\n\tentry               ;\n\n\n\n\n\n\ttypedef   struct  SELECTION\n\t\t\u00e4\n\t\tchar * line     ;\n\t\tint  access     ;\n\t\t\u00fc\n\tselection           ;\n\tstruct et\n\t\t\u00e4\n\t\tchar *   cid ;\n\t\tchar * * ett;\n\t\t\u00fc ;\n\n\n\n\n\n\tstruct TEXTENTRY\n\t\t\u00e4\n\t\tint i;\n\t\tchar * t;\n\t\t\u00fc;\n\n\n\tclass  MessageTEXT\n\t\t\u00e4\n\t\tprivate:\n\t\t\tchar timestemp;\n\t\t\tint (*printfv)(char *);\n\t\t\tchar * msgfilename;\n\t\t\tbool   logger;\n\t\t\tbool   onlylogger;\n\t\t\tFILE  * msgfile;\n\t\t\tTEXTENTRY *  vector;\n\t\t\tMSGE * v\u00c48\u00dc;\n\t\t\tint    vi;\n\t\t\tint    number;\n\t\t\tchar   deflt\u00c4256\u00dc;\n\n\t\tpublic:\n\t\t\tMessageTEXT(char * = 0,char * = 0);\n\t\t\t\u00dfMessageTEXT();\n\t\t\tMessageTEXT& operator<<(char *);\n\t\t\tMessageTEXT& operator<<(const mvsSTRING &);\n\n\t\t\tMessageTEXT& operator<<(int );\n\t\t\tchar *       operator<<(const EOL);\n\t\t\tMessageTEXT& operator<<(void *);\n\t\t\tchar * getText(int);\n\t\t\tint    copyText(int, char *, int);\n\t\t\tchar * print(char *);\n\t\t\tvoid   resetPrintFv()\u00e4 printfv = 0;\u00fc\n\t\tvoid   setPrintFv(int (*pfv)(char *))\u00e4 printfv= pfv;\u00fc\n\tvoid   setLogger(const char *);\n\tvoid   setOnlyLogger(const char * l)\n\t\t\u00e4\n\t\tsetLogger(l);\n\t\tonlylogger = logger;\n\t\t\u00fc\n\tvoid   setFILE(FILE *);\n\tFILE*  getFILE()\u00e4return msgfile;\u00fc\nvoid   setFileName(char *);\nvoid   setTimeStempFlag(char c = 1)\u00e4timestemp = c;\u00fc\nchar   getTimeStempFlag()\u00e4 return timestemp;\u00fc\nvoid   setNumber(int n);\n\t\t\u00fc;\n\n\textern \"C\" typedef void * (*EXT_C_fp)();\n\n\n\tclass ExternalTEXT\n\t\t\u00e4\n\t\tprivate:\n\t\t\tEXT_C_fp fp;\n\t\t\tchar   language;\n\t\t\tchar   modulname\u00c48\u00dc;\n\t\t\tvoid * text ;\n\t\t\tvoid init(char * name);\n\t\tpublic:\n\t\t\tExternalTEXT(char * name,char lang);\n\t\t\tExternalTEXT(char * name);\n\n\n\t\t\tint         MSGTEXT(int id, char * buff,int len);\n\t\t\tchar      * HelpText(char * hid);\n\t\t\tentry     * EntryText(char * hid);\n\t\t\tselection * SelectionText(char * hid);\n\t\t\u00fc;\n\n\textern ExternalTEXT * externaltext;\n\n\n\n\textern  MessageTEXT * messagetext;\n\tint initMessageText();\n\n\tint     Error(int , ...);\n\tchar *  Message(int , ...);\n\tchar *  getErrorText();\n\tchar *  getMessageText();\n\tMessageTEXT& Err(int);\n\tMessageTEXT& Msg(int);\n\n\t\u00fc\n\nusing namespace isis_ns_mvs;\n\n\n\n\n\n\n\n\nextern \"OS\" int  SQLASM(void);\n\nextern \"OS\" int  DSNALI(...);\nextern \"OS\" int  DSNTIAR(...);\nextern \"OS\" void DSNHLI(void *);\n\nconst int data_dim = 30;\nconst int data_len = 72;\n\n\ntypedef struct varchar\n\u00e4\n  short len;\n  char  value\u00c44096\u00dc;\n\u00fc VARCHAR;\n\ntypedef struct\n \u00e4\n  short error_len;\n  char error_text\u00c4data_dim\u00dc\u00c4data_len\u00dc;\n \u00fc ERROR_MESSAGE;\n\nenum  CallType\u00e4Connect,\n       Disconnect,\n       Commit,\n       Rollback,\n       Prepare,\n       Open,\n       Close,\n       Execute\u00fc;\n\n\n\n\n\n\n\n\n\n\n\n\nclass ARCHSQL:public mERROR\n\u00e4\nprivate:\n  int rc;\n  void * tecb,* secb,* ribptr,* eibptr;\n  long retcode , reasoncode;\n  char function\u00c413\u00dc;\n  char ssnm\u00c45\u00dc;\n  char plan\u00c49\u00dc;\n  char reuse\u00c49\u00dc;\n  char collection\u00c419\u00dc;\n  char correlation_id\u00c413\u00dc;\n  char accounting_token\u00c423\u00dc;\n  char accounting_interval\u00c47\u00dc;\n  int  rrs;\n  int status;\n  ERROR_MESSAGE error_message;\n  void * loadlist\u00c48\u00dc;\npublic:\n  ARCHSQL();\n  \u00dfARCHSQL();\n  int call(CallType);\n  void setDynamicSQL(char *);\n  void * getLoadlist()\u00e4 return loadlist\u00c40\u00dc;\u00fc\n  void setSubSystem(char *n)\u00e4memcpy(ssnm,n,4);ssnm\u00c44\u00dc = 0;\u00fc\n  void setPlan(char * p)\u00e4memcpyp(plan,p,8,strlen(p),' '); plan\u00c48\u00dc = 0;\u00fc\n  void setCollection(char * p)\u00e4memcpyp(collection,p,8,strlen(p),' '); c\u00d6\nollection\u00c48\u00dc = 0;\u00fc\n  void setPlanName(char *n)\u00e4memcpy(plan,n,8);plan\u00c48\u00dc = 0;\u00fc\n\u00fc;\n\nvoid  getUniqueKey(char *);\nvoid  getUniqueKEY(char *);\n\n\n\n\n\n\n\n\nstruct chainE \u00e4\n\n\tchainE * prev ;\n\tchainE * next ;\n\tchar * chainEid   ;\n\tint    chainEidl  ;\n\n\tchainE()\u00e4chainEid = 0; chainEidl = 0; prev = next = 0;\u00fc\n\n\tchainE(char * i,int l =0)\n\t\u00e4\n\t\tif (i)\n\t\t\u00e4\n\t\t\tif ( l ) chainEidl = l; else chainEidl =int(strlen(i));\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc; memcpy(chainEid,i,chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\n\tchainE(const char * i,int l =0)\n\t\u00e4\n\t\tif (i)\n\t\t\u00e4\n\t\t\tif ( l ) chainEidl = l; else chainEidl =int(strlen(i));\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc; memcpy(chainEid,i,chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\n\tchainE(const mvsSTRING * s)\n\t\u00e4\n\t\tif (s)\n\t\t\u00e4\n\t\t\tchainEidl = int((mvsSTRING *)s->lengthOf());\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc;\n\t\t\tmemcpy(chainEid,(char *)mvsSTRING(*s),chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\tvirtual \u00dfchainE()\n\t\u00e4\n\t\tdelete chainEid ;\n\t\u00fc\n\tvirtual void print()\u00e4\u00fc\n\u00fc;\n\n\nclass mCHAIN \u00e4\n\nprotected:\n\tchainE * first;\n\tchainE * last ;\n\n\tchainE * pgo;\n\tlong int    counter;\npublic:\n\tfriend class CHAINITER ;\n\n\tmCHAIN()\n\t\u00e4\n\n\t\tfirst = last = pgo = 0; counter = 0;\n\t\u00fc\n\n\tmCHAIN(chainE * nc)\n\t\u00e4\n\t\tpgo = 0;\n\t\tfirst = nc ; last = nc ;\n\t\tcounter = 1;\n\t\u00fc\n\n\tvirtual \u00dfmCHAIN();\n\tvirtual   long int    add(chainE * nc,chainE * c,long int code = 1);\n\tvirtual long int addfirst(chainE * nc )\n\t\u00e4 return add(nc,first,-1) ; \u00fc\n\tvirtual long int addlast(chainE * nc )\n\t\u00e4 return add(nc,last,+1) ; \u00fc\n\tvirtual long int before(chainE * nc , chainE * c)\n\t\u00e4return add(nc,c,-1);\u00fc\n\tvirtual long int after(chainE * nc , chainE * c)\n\t\u00e4return add(nc,c,+1);\u00fc\n\tvirtual long int del(chainE * c);\n\tvirtual void swap(chainE * a , chainE * b);\n\n\n\n\tvirtual chainE* goNext();\n\tvirtual chainE* goPrev();\n\tvirtual chainE* goFirst();\n\tvirtual chainE* goLast();\n\tvirtual chainE* go(int);\n\tvirtual chainE * searchEQ(const char * id,size_t =0);\n\tvirtual chainE * search(const char * id,size_t =0);\n\tvirtual chainE * search(const mvsSTRING &);\n\tvirtual chainE * search(char *id,size_t length =0)\u00e4 return search((con\u00d6\nst char *)id,length);\u00fc\n\tvirtual chainE * search(mvsSTRING &s)\u00e4 return search((const mvsSTRING&\u00d6\n)s);\u00fc\n\n\tvirtual void sort(long int direction);\n\tvirtual void print_all_ids();\n\tvirtual void print();\n\tfriend int idcmp(chainE* , chainE*);\n\u00fc;\n\nenum SORTEDTYPE\u00e4UNIQUE =0 ,NOUNIQUE =1 \u00fc;\n\nclass SORTEDmCHAIN:public mCHAIN\n\u00e4\nprivate:\n\tSORTEDTYPE unique;\npublic:\n\tSORTEDmCHAIN(SORTEDTYPE st = UNIQUE):\n\t\t\tmCHAIN(), unique(st)\u00e4\u00fc;\n\t\t\tSORTEDmCHAIN(chainE *nc, SORTEDTYPE st = UNIQUE)\n\t\t\t\t:mCHAIN(nc), unique(st)\u00e4\u00fc;\n\t\t\tlong int add(chainE * nc,chainE * = 0,long int = 0);\n\t\t\tvirtual \u00dfSORTEDmCHAIN()\u00e4\u00fc\n\u00fc;\n\nclass mSTACK:public mCHAIN\n\u00e4\nprivate:\npublic:\n\tmSTACK():mCHAIN()\u00e4\u00fc\n\tmSTACK(chainE * nc):mCHAIN(nc)\u00e4\u00fc\n\n\tvirtual long int push(chainE * nc)\u00e4return addlast(nc);\u00fc\n\tvirtual chainE * examine(int i = 0 )\n\t\u00e4\n\t\tif ( i >= 0 ) return last;\n\t\ti = -i;\n\t\tif ( counter-i < 0 ) return 0;\n\t\treturn go(counter-i);\n\n\t\u00fc\n\tvirtual chainE * pop()\u00e4chainE * r = last; if (last) del(last);return r\u00d6\n;\u00fc\n\u00fc;\n\nclass mHASH:public mCHAIN\n\u00e4\nprivate:\n\tchainE * * table;\n\tint    hash;\n\tint\t\tpi;\npublic:\n\tmHASH(int h = 1023);\n\t\u00dfmHASH();\n\tlong int add(chainE *);\n\tlong int del(chainE *);\n\tchainE * next();\n\tchainE * search(chainE *);\nprivate:\n\tsize_t  hashCode(chainE *c)\n\t\u00e4\n\t\tint r = 0;\n\t\tif (c->chainEid)\n\t\t\tfor (int i = c->chainEidl;i;i--)\n\t\t\t\tr = (r<<1) \u00ac (c->chainEid\u00c4i-1\u00dc) ;\n\t\treturn size_t(r<0 ? -r:r);\n\t\u00fc\n\u00fc;\n\nclass CHAINITER\u00e4\nprivate:\n\tmCHAIN * c;\n\tchainE * a;\npublic:\n\tCHAINITER(mCHAIN &ch) \u00e4c = &ch ; a = (c->first ? c->first:0) ; \u00fc\n\tCHAINITER(mCHAIN *ch) \u00e4c =  ch ; a = (c->first ? c->first:0) ; \u00fc\n\t\u00dfCHAINITER()\u00e4\u00fc\n\tchainE * next() \u00e4\n\n\t\tchainE * r = a ;\n\t\tif ( a == 0 ) a =c->first ;\n\t\telse a = a->next ;\n\t\treturn r;\n\t\u00fc\n\tchainE * operator()()\u00e4 return next(); \u00fc\n\tvoid reset() \u00e4 a = (c ? c->first:0);\u00fc\n\u00fc;\n\nint idcmp(chainE* , chainE*);\n\n\n\n\n\n\n\n\n\n\nclass JOBENV\n\u00e4\npublic:\nenum JOBENV_ACTION\n\u00e4\n\tAbort,\n   Continue\n\u00fc;\npublic:\n    mvsSTRING jobName;\n    mvsSTRING jobId;\n    mvsSTRING stepName;\n    mvsSTRING procStepName;\n    mvsSTRING program;\n\t\tmvsSTRING programRb;\n    static int  debug;\npublic:\n    JOBENV(char *);\n    \u00dfJOBENV()\u00e4\u00fc\n    void print();\n    void static Error(char *,JOBENV_ACTION);\n    int  static DEBUG(int,char*);\n    int  static DEBUG(int,char*,int);\n    int  static DEBUG(int,size_t);\n    int  static DEBUG(int,char*,char*);\n    int  static DEBUG(int,char*,char*,char*);\n    int  static DEBUG(int,char*,char*,char*,char*);\n    int  static DEBUG(int,char*,char *,int);\n\u00fc;\n\nextern JOBENV * jobEnv;\n\n\n\nconst short  eiop00  = 0;\nconst short  eiop01  = 1;\nconst short  eiop02  = 2;\nconst short  eiop03  = 3;\nconst short  eiop04  = 4;\nconst short  eiop05  = 5;\nconst short  eiop06  = 6;\nconst short  eiop07  = 7;\nconst short  eiop08  = 8;\nconst short  eiop09  = 9;\nconst short  eiop10  =10;\nconst short  eiop11  =11;\nconst short  eiop12  =12;\nconst short  eiop13  =13;\nconst short  eiop14  =14;\nconst short  eiop15  =15;\nconst short  eiop16  =16;\nconst short  eiop17  =17;\nconst short  eiop18  =18;\nconst short  eiop19  =19;\nconst short  eiop20  =20;\nconst short  eiop21  =21;\nconst short  eiop22  =22;\nconst short  eiop23  =23;\nconst short  eiop24  =24;\nconst short  eiop25  =25;\nconst short  eiop26  =26;\n\nconst int eirc_ok    = 0;\nconst int eirc_replace    = 4;\nconst int eirc_insert    = 8;\nconst int eirc_delete    = 12;\nconst int eirc_modified  = 16;\nconst int eirc_disconnect  = 20;\nconst int eirc_disconnect_after = 24;\nconst int eirc_wtor        = 28;\nconst int eirc_end_function= 32;\nconst int eirc_end_dataset = 36;\n\n\nextern const char * ADRDSSU;\nextern const char * KEYWORD_INCLUDE_MARK;\nextern const char * KEYWORD_DUMP;\nextern const char * KEYWORD_RESTORE;\nextern const char * KEYWORD_DB_PLAN;\nextern const char * KEYWORD_DB_SUBSYS;\nextern const char * KEYWORD_PREFIX;\nextern const char * KEYWORD_SYSIN;\nextern const char * KEYWORD_ADR012I;\nextern const char * KEYWORD_DEBUG;\nextern const char * KEYWORD_COMPR;\nextern const char * KEYWORD_REFDT;\nextern const char * KEYWORD_SQLFILE;\nextern const char * KEYWORD_DIRECT;\nextern const char * KEYWORD_MAXLENGTH;\nextern const char * KEYWORD_USEDB2;\nextern const char * KEYWORD_USEDB2_FILE;\n\n\n\n\n\n\nextern \"OS\" int UIMASM(...);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst  unsigned PSATOLD = 0x21c;\nconst  unsigned PSAAOLD = 0x224;\nconst  unsigned TCBFSA  = 0x70/4;\nconst  unsigned TCBUSER = 0xA8;\nconst  unsigned tcbuser = 0xa8;\nconst  unsigned SAVEr1  = 0x18/4;\nstatic unsigned POSTcode = 0x40000000;\nstatic unsigned WAITcode = 0x80000000;\n\nclass SUBTASK;\nclass JOBENV;\n\n\ntypedef void       (*SUBTASK_FUNCTION)(void*);\ntypedef void       * addressP;\ninline addressP getASCB()\u00e4return(*(addressP*)PSAAOLD);\u00fc\ninline addressP getTCB()\u00e4return (*(addressP *)PSATOLD);\u00fc\n\n\nenum SUBTASK_STATUS\n\u00e4\n    Reset,\n    Started,\n    WaitingForWork,\n    WaitingForMain,\n    Working,\n    Stopping\n\u00fc;\ntypedef struct PROGRAM_ARGUMENTS \u00e4\n  short  arg_l;\n  char   arg_v\u00c41024\u00dc;\n  \u00fc programArguments;\n\n class SUBTASK: public mERROR\n\u00e4\nprivate:\n  char * dll;\nprotected:\n  MessageTEXT * messageText;\n  JOBENV *      jobEnv;\n  void * TCB;\n  unsigned ECB;\n  unsigned StopECB;\n  unsigned WorkECB;\n  unsigned MainECB;\n  unsigned SuspendECB;\n  unsigned *  ecblist\u00c42\u00dc;\n   void(* address)(void);\n  void (*subrun)();\n  int R15 ;\n  SUBTASK_FUNCTION functions\u00c44\u00dc;\n  void  * arg\u00c44\u00dc;\n  int subtask_rc;\n  int suspendflag;\n  SUBTASK_STATUS status;\n  char   name\u00c49\u00dc;\n  char   subtaskposted;\n  char   first_start;\n  int    timeout;\npublic:\n  friend void run();\n  SUBTASK();\n  SUBTASK(char *);\n  SUBTASK(addressP,SUBTASK_FUNCTION,char*);\n  SUBTASK(int,char * *,char *,char *);\n  virtual \u00dfSUBTASK();\n  virtual int    attach();\n  virtual int    detach();\n  virtual int    callAsync(int);\n  virtual int    callSync(int);\n  virtual int    waitForSubtask();\n  virtual int    waitForEndOfSubtask();\n  virtual void   start();\n  virtual void   stop();\n  virtual void   chap(int);\n  virtual void   exit(int);\n  virtual int    isTerminated()\u00e4 return (ECB&0x7fffffff);\u00fc\n  SUBTASK_STATUS askStatus()\u00e4return status;\u00fc\n  MessageTEXT * getMessageText()\u00e4return messageText;\u00fc\n  JOBENV      * getJobEnv()\u00e4return jobEnv;\u00fc\n  addressP      getParam()\u00e4return(addressP(argV));\u00fc\n  addressP      getTCB()\u00e4return(addressP(TCB));\u00fc\n  int           getTimeout()\u00e4return timeout;\u00fc\n  char *        getDllName()\u00e4 return dll;\u00fc\n  void          setDllName(char *d)\u00e4 dll = d;\u00fc\n  char * *  argV;\n  int       argC;\n\nstatic addressP GetTCB()\u00e4return (*(addressP *)PSATOLD);\u00fc\nstatic addressP GetASCB()\u00e4return(*(addressP*)PSAAOLD);\u00fc\n\nprotected:\n  int    checkR15(char *);\n  void   init(char *);\n  void   error(char *);\n\u00fc;\n\n class DLL_SUBTASK\n\u00e4\nprivate:\npublic:\n  SUBTASK * subtask;\n  DLL_SUBTASK(int,char * *,char *,char * = \"SUBRUN \");\n  \u00dfDLL_SUBTASK();\n  void      start()\u00e4subtask->start();\u00fc\n  void      stop()\u00e4subtask->stop();\u00fc\n  int       detach()\u00e4return(subtask->detach());\u00fc\n  addressP  getTCB()\u00e4return(subtask->getTCB());\u00fc\n\u00fc;\n\n class MAIN_SUBTASK:public SUBTASK\n\u00e4\nprivate:\nmvsSTRING startmvsSTRING;\n void * plist\u00c41\u00dc;\nprogramArguments   argument;\nprogramArguments * argumentP;\npublic:\n MAIN_SUBTASK();\n MAIN_SUBTASK(int,char * *,char *);\n MAIN_SUBTASK(programArguments *,char * );\n virtual int  attach();\n\u00fc;\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      struct flock \u00e4\n            short l_type;\n            short l_whence;\n               int   l_rsrvd1;\n            off_t l_start;\n               int   l_rsrvd2;\n            off_t l_len;\n            pid_t l_pid;\n      \u00fc;\n\n\n\n\n        int creat(const char *, mode_t) ;\n        int fcntl(int, int, ... );\n        int open(const char *, int, ... );\n\n\n\n\n\n\n\n\n\n\n\n     \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n  extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n               #pragma map (getlogin, \"\u00d6174\u00d6174GETLG2\")\n\n\n         #pragma map (__getlogin1, \"\u00d6174\u00d6174GETLOG\")\n         #pragma map (__pid_affinity,\"\u00d6174\u00d6174PID\u00d6174AF\")\n\n          #pragma map(__login_applid,\"\u00d6174\u00d6174LOGNAP\")\n         #pragma map(__certificate,\"\u00d6174\u00d6174CERTIF\")\n\n           void _exit(int);\n           int   access(const char *, int );\n           int   __certificate(int, int, char *, ...);\n           unsigned int alarm(unsigned int);\n           int   chdir(const char *);\n           int   chown(const char *, uid_t, gid_t);\n           int   close(int);\n           char *ctermid(char *);\n           int   dup(int);\n           int   dup2(int, int);\n           int   execl(const char *, const char *, ... );\n           int   execle(const char *, const char *, ... );\n           int   execlp(const char *, const char *, ... );\n           int   execv(const char *, char *const \u00c4\u00dc);\n           int   execve(const char *, char *const \u00c4\u00dc, char * const \u00c4\u00dc);\n           int   execvp(const char *, char *const \u00c4\u00dc );\n           pid_t fork(void);\n           long  fpathconf(int, int);\n           char *getcwd(char *, size_t);\n           gid_t getegid(void);\n           uid_t geteuid(void);\n           gid_t getgid(void);\n           int   getgroups(int, gid_t \u00c4\u00dc);\n             int   getgroupsbyname(char \u00c4\u00dc, int, gid_t \u00c4\u00dc);\n             int   __osenv(int, int, __osenv_token *);\n           char *__getlogin1(void);\n           char *getlogin(void);\n           pid_t getpgrp(void);\n           pid_t getpid(void);\n           pid_t getppid(void);\n           uid_t getuid(void);\n           int   isatty(int);\n           int   link(const char *, const char *);\n           int __login(int, int, int, void *, int, char *,\n                         int, char *, int);\n           off_t lseek(int, off_t, int);\n           long  pathconf(const char *, int);\n           int   pause(void);\n           int   __pid_affinity(int, pid_t, pid_t, int);\n           int   pipe(int \u00c42\u00dc);\n           ssize_t read(int, void *, size_t);\n           int   rmdir(const char *);\n           int   setgid(gid_t);\n           int   setpgid(pid_t, pid_t);\n           pid_t setsid(void);\n           int   setuid(uid_t);\n           unsigned int sleep(unsigned int );\n           long  sysconf(int);\n           pid_t tcgetpgrp(int);\n           int   tcsetpgrp(int, pid_t);\n           char *ttyname(int);\n           int   unlink(const char *);\n           ssize_t write(int, const void *, size_t);\n\n         int __login_applid(int, int, int, void *, int, char *, int, ch\u00d6\nar *, int, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n           int   fchown(int , uid_t, gid_t);\n           int   fsync(int);\n           int   ftruncate(int, off_t);\n           int   readlink(const char *, char *, size_t );\n           int   setegid(gid_t);\n           int   seteuid(uid_t);\n           int   symlink(const char *, const char *);\n             int   extlink_np(const char *, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          extern char *optarg;\n          extern int optind, opterr, optopt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             void         __cnvblk(char \u00c4\u00dc, char \u00c4\u00dc, int);\n               int          chroot(const char *);\n             char        *crypt(const char *, const char *);\n             void         encrypt(char \u00c464\u00dc, int);\n             int          nice(int);\n           extern char **__opargf(void);\n           extern int  *__operrf(void);\n           extern int  *__opindf(void);\n           extern int  *__opoptf(void);\n           size_t       confstr(int, char *, size_t);\n             char        *cuserid(char *);\n           int          getopt(int, char * const \u00c4\u00dc, const char *);\n             char        *getpass(const char *);\n           void         swab(const void *restrict,\n                                   void *restrict, ssize_t);\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n       typedef    signed  char   int8_t;\n       typedef    signed  short  int16_t;\n       typedef    signed  int    int32_t;\n\n\n       typedef signed long long  int64_t;\n\n\n\n\n       typedef  unsigned  char  uint8_t;\n\n\n       typedef  unsigned  short uint16_t;\n\n\n       typedef  unsigned  int   uint32_t;\n\n       typedef unsigned long long uint64_t;\n\n       typedef    signed long    intptr_t;\n       typedef  unsigned long   uintptr_t;\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             int          fchdir(int);\n               int          getdtablesize(void);\n             pid_t        getpgid(pid_t);\n             pid_t        getsid(pid_t);\n             char        *getwd(char *);\n             int          lchown(const char *, uid_t, gid_t);\n             int          setregid(gid_t, gid_t);\n             int          setreuid(uid_t, uid_t);\n             void         sync(void);\n             int          truncate(const char *, off_t);\n             useconds_t    ualarm(useconds_t, useconds_t);\n             int          brk(void *);\n             int          getpagesize(void);\n               void        *sbrk(intptr_t);\n           int          lockf(int, int, off_t);\n           pid_t        setpgrp(void);\n           int          usleep(useconds_t);\n           pid_t        vfork(void);\n\n\n\n\n\n\n\n\n\n\n\n      int getlogin_r(char *, size_t );\n      int ttyname_r(int, char *, size_t );\n\n\n      ssize_t pread(int, void *, size_t, off_t);\n\n      ssize_t pwrite(int, const void *, size_t, off_t);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int          __atoe(char *);\n      int          __atoe_l(char *, int);\n      int          __check_resource_auth_np(char *, char *, char *,\n                                            char *, char *, int);\n      int          __convert_id_np( int, char *, char *, char *);\n      int          __etoa(char *);\n      int          __etoa_l(char *, int);\n      int          __isPosixOn(void);\n      int          __openMvsRel(void);\n      int          __openVmRel(void);\n      int          __smf_record(int, int, int, char *);\n      int          __wsinit(void (*)());\n\n    int __smf_record2(int, int, int, char *, unsigned int);\n\n\n\n\n\n\n\n\n          long         gethostid(void);\n          int          gethostname(char *, size_t);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int __must_stay_clean(int);\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n    int __errno2(void);\n    int *__err2ad(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n           extern int errno;\n           extern int *__errno(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n   extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          int  bcmp (const void *, const void *, size_t);\n          void bcopy (const void *, void *, size_t);\n          void bzero (void *, size_t);\n          int ffs (int);\n          char * index  (const char *, int);\n          char * rindex (const char *, int);\n          int  strcasecmp (const char *, const char *);\n          int  strncasecmp (const char *, const char *, size_t);\n\n\n\n\n\n         extern \"builtin\"  \u00e4\n\n         void * __memcpy (void *, const void *, size_t);\n         int    __memcmp (const void *, const void *, size_t);\n         void * __memset (void *, int, size_t);\n         char * __strchr (const char *, int);\n         char * __strrchr (const char *, int);\n\n         \u00fc\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\nstatic const char fullQuery\u00c4\u00dc =\n\" SELECT * FROM DSSDATASETS A \"\n\" WHERE ( %m% ) AND \"\n\" ( DATE(KEY) <= DATE('%d%') ) AND \"\n\" ( \"\n\" A.KEY =  \"\n\" (SELECT MAX(B.KEY) FROM DSSDATASETS B WHERE A.DATASET = B.DATASET  \"\n\" AND DATE(B.KEY) <= DATE('%d%') ) \"\n\" ) \" ;\n\n\n/***$$$\nEXEC SQL BEGIN DECLARE SECTION\n$$$***/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntypedef struct _TIMESTAMP\n\u00e4\n  short len;\n  char  arr\u00c428\u00dc;\n\u00fc TIMESTAMP;\n\nstruct _DssDatasetRecord\n\u00e4\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc key;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc job;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc volumes;\n   long int type;\n   long int recordsize;\n\u00fc DssDatasetRecord;\n\nclass TcbARCHSQL:public chainE\n\u00e4\nprivate:\n   ARCHSQL * archsql;\npublic:\n   TcbARCHSQL(char * t,ARCHSQL * a):chainE(t),archsql(a)\n   \u00e4\u00fc\n   ARCHSQL * get()\u00e4return archsql;\u00fc\n\u00fc;\n\nstatic char * initDynamicSql();\n\nclass SQLINTERFACE:\n public  mERROR\n\u00e4\nprotected:\n static char * plan;\n static char * subsystem;\n static mCHAIN  tasks;\n static ERROR_MESSAGE * error_message;\nprotected:\n static char * dSql;\npublic:\n\tstatic bool useDB2;\n\tstatic FILE * fileDB2;\npublic:\n SQLINTERFACE();\n   \u00dfSQLINTERFACE();\n   void diag(char *);\n   int  commit();\n   enum Error_Action\u00e4 Abort, Continue\u00fc;\n   void Error(char *,Error_Action);\n   ARCHSQL * connectDB();\n   void tryToConnect();\n\u00fc;\n\nclass DssJob:\n public SQLINTERFACE,\n public mCHAIN,\n public CHAINITER,\n public chainE\n\u00e4\nprivate:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc t;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc record_key;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc record_job;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc record_dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc record_volumes;\n   long int record_type;\n   long int record_size;\npublic:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc timestamp;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc jobName;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc jobNumber;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc program;\n   struct \u00e4 short len; char arr \u00c4 255 \u00dc ; \u00fc dataset;\n   long int datasetcount;\n   struct \u00e4 short len; char arr \u00c4 30000 \u00dc ; \u00fc joblog;\n   struct \u00e4 short len; char arr \u00c4 32000 \u00dc ; \u00fc dynamicSql;\npublic:\n  static mCHAIN dssJobs;\n  static int    allOnline();\n  int    doWeNeed(const char *);\npublic:\n DssJob();\n DssJob(TIMESTAMP&);\n DssJob(const char *);\n virtual \u00dfDssJob();\n int insert();\n int query(mCHAIN*,char * =0);\n char * getDatasetName()\n\u00e4\n  return ((char *)dataset.arr);\n\u00fc\nprivate:\n void init();\n\u00fc;\n\nclass DssDataset:\n public SQLINTERFACE,\n public chainE\n\u00e4\nprivate:\n DssJob * job;\npublic:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc timestamp;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc volumes;\n   long int type;\n   long int recordsize;\npublic:\n DssDataset(DssJob *,char *,char *,int = 0,int =0);\n int compare(const char *n)\n   \u00e4\n   for(int i =0;i<45&&dataset.arr\u00c4i\u00dc&&dataset.arr\u00c4i\u00dc-' '&&n\u00c4i\u00dc&&n\u00c4i\u00dc-' \u00d6\n';i++)\n     if (dataset.arr\u00c4i\u00dc - n\u00c4i\u00dc) return 0;\n   return 1;\n   \u00fc\n   virtual \u00dfDssDataset();\n   int insert();\n\u00fc;\n\n/***$$$\nEXEC SQL END DECLARE SECTION\n$$$***/\n\n/***$$$\nEXEC SQL INCLUDE SQLDA\n$$$***/\n#ifndef  SQLDASIZE                 /* Permit duplicate Includes      */\n /**/\n struct sqlvar\n        \u00e4 short  sqltype;\n          short  sqllen;\n          char  *sqldata;\n          short *sqlind;\n          struct sqlname\n                \u00e4 short  length;\n                  char   data??(30??);\n                \u00fc sqlname;\n        \u00fc;\n /**/\n struct sqlvar2\n        \u00e4 struct\n                \u00e4 long   sqllonglen;\n         unsigned long   reserved;\n                \u00fc len;\n          char  *sqldatalen;\n          struct sqldistinct_type\n                \u00e4 short  length;\n                  char   data??(30??);\n                \u00fc sqldatatype_name;\n        \u00fc;\n /**/\n struct sqlda\n        \u00e4 char   sqldaid??(8??);\n          long   sqldabc;\n          short  sqln;\n          short  sqld;\n          struct sqlvar sqlvar??(1??);\n    \u00fc;\n /**/\n/*********************************************************************/\n/* Macros for using the sqlvar2 fields.                              */\n/*********************************************************************/\n /**/\n/*********************************************************************/\n/*   '2' in the 7th byte of sqldaid indicates a doubled number of    */\n/*       sqlvar entries.                                             */\n/*   '3' in the 7th byte of sqldaid indicates a tripled number of    */\n/*       sqlvar entries.                                             */\n/*********************************************************************/\n#define   SQLDOUBLED  '2'\n#define   SQLTRIPLED  '3'\n#define   SQLSINGLED  ' '\n /**/\n/*********************************************************************/\n/* GETSQLDOUBLED(daptr) returns 1 if the SQLDA pointed to by         */\n/* daptr has been doubled, or 0 if it has not been doubled.          */\n/*********************************************************************/\n#define GETSQLDOUBLED(daptr) \u00d6\n    (((daptr)->sqldaid??(6??) == ( char) SQLDOUBLED) ? \u00d6\n    (1)         : \u00d6\n    (0)           )\n /**/\n/*********************************************************************/\n/* GETSQLTRIPLED(daptr) returns 1 if the SQLDA pointed to by         */\n/* daptr has been tripled, or 0 if it has not been tripled.          */\n/*********************************************************************/\n#define GETSQLTRIPLED(daptr) \u00d6\n    (((daptr)->sqldaid??(6??) == ( char) SQLTRIPLED) ? \u00d6\n    (1)         : \u00d6\n    (0)           )\n /**/\n/*********************************************************************/\n/* SETSQLDOUBLED(daptr, SQLDOUBLED) sets the 7th byte of sqldaid     */\n/* to '2'.                                                         */\n/* SETSQLDOUBLED(daptr, SQLSINGLED) sets the 7th byte of sqldaid     */\n/* to be a ' '.                                                    */\n/*********************************************************************/\n#define SETSQLDOUBLED(daptr, newvalue) \u00d6\n    (((daptr)->sqldaid??(6??) = (newvalue)))\n /**/\n/*********************************************************************/\n/* SETSQLTRIPLED(daptr) sets the 7th byte of sqldaid                 */\n/* to '3'.                                                         */\n/*********************************************************************/\n#define SETSQLTRIPLED(daptr) \u00d6\n    (((daptr)->sqldaid??(6??) = (SQLTRIPLED)))\n /**/\n/*********************************************************************/\n/* GETSQLDALONGLEN(daptr,n) returns the data length of the nth       */\n/* entry in the sqlda pointed to by daptr. Use this only if the      */\n/* sqlda was doubled or tripled and the nth SQLVAR entry has a       */\n/* LOB datatype.                                                     */\n/*********************************************************************/\n#define GETSQLDALONGLEN(daptr,n)    (    \u00d6\n    (long) (((struct sqlvar2 *) &((daptr)->sqlvar??((n) + \u00d6\n           ((daptr)->sqld)??))) \u00d6\n            ->len.sqllonglen))\n /**/\n/*********************************************************************/\n/* SETSQLDALONGLEN(daptr,n,len) sets the sqllonglen field of the     */\n/* sqlda pointed to by daptr to len for the nth entry. Use this only */\n/* if the sqlda was doubled or tripled and the nth SQLVAR entry has  */\n/* a LOB datatype.                                                   */\n/*********************************************************************/\n#define SETSQLDALONGLEN(daptr,n,length)  \u00e4 \u00d6\n    struct sqlvar2     *var2ptr; \u00d6\n    var2ptr = (struct sqlvar2 *) \u00d6\n        &((daptr)->sqlvar??((n) + ((daptr)->sqld)??)); \u00d6\n    var2ptr->len.sqllonglen  =  (long ) (length); \u00d6\n    \u00fc\n /**/\n/*********************************************************************/\n/* GETSQLDALENPTR(daptr,n) returns a pointer to the data length for  */\n/* the nth entry in the sqlda pointed to by daptr. Unlike the inline */\n/* value (union sql8bytelen len), which is 8 bytes, the sqldatalen   */\n/* pointer field returns a pointer to a long (4 byte) integer.       */\n/* If the SQLDATALEN pointer is zero, a NULL pointer is be returned. */\n/*                                                                   */\n/* NOTE: Use this only if the sqlda has been doubled or tripled.     */\n/*********************************************************************/\n#define GETSQLDALENPTR(daptr,n) (   \u00d6\n    (((struct sqlvar2 *) &(daptr)->sqlvar??((n) + (daptr)->sqld??)) \u00d6\n                           ->sqldatalen == NULL) ? \u00d6\n    ((long *) NULL ) : \u00d6\n    ((long *) ((struct sqlvar2 *) \u00d6\n        &(daptr)->sqlvar??((n) + (daptr)->sqld??)) \u00d6\n                                    ->sqldatalen ) )\n /**/\n/*********************************************************************/\n/* SETSQLDALENPTR(daptr,n,ptr) sets a pointer to the data length for */\n/* the nth entry in the sqlda pointed to by daptr.                   */\n/* Use this only if the sqlda has been doubled or tripled.           */\n/*********************************************************************/\n#define SETSQLDALENPTR(daptr,n,ptr)  \u00e4  \u00d6\n    struct sqlvar2 *var2ptr;    \u00d6\n    var2ptr = (struct sqlvar2 *) \u00d6\n        &((daptr)->sqlvar??((n) + ((daptr)->sqld)??)); \u00d6\n    var2ptr->sqldatalen  = (char *) ptr; \u00d6\n    \u00fc\n /**/\n#define SQLDASIZE(n) \u00d6\n   ( sizeof(struct sqlda) + ((n)-1) * sizeof(struct sqlvar) )\n#endif /* SQLDASIZE */\n\n/***$$$\nEXEC SQL INCLUDE SQLCA\n$$$***/\n#ifndef SQLCODE\nstruct sqlca\n  \u00e4 unsigned  char     sqlcaid??(8??);\n              long     sqlcabc;\n              long     sqlcode;\n              short    sqlerrml;\n    unsigned  char     sqlerrmc??(70??);\n    unsigned  char     sqlerrp??(8??);\n              long     sqlerrd??(6??);\n    unsigned  char     sqlwarn??(11??);\n    unsigned  char     sqlstate??(5??);\n            \u00fc ;\n#define SQLCODE  sqlca.sqlcode\n#define SQLWARN0 sqlca.sqlwarn??(0??)\n#define SQLWARN1 sqlca.sqlwarn??(1??)\n#define SQLWARN2 sqlca.sqlwarn??(2??)\n#define SQLWARN3 sqlca.sqlwarn??(3??)\n#define SQLWARN4 sqlca.sqlwarn??(4??)\n#define SQLWARN5 sqlca.sqlwarn??(5??)\n#define SQLWARN6 sqlca.sqlwarn??(6??)\n#define SQLWARN7 sqlca.sqlwarn??(7??)\n#define SQLWARN8 sqlca.sqlwarn??(8??)\n#define SQLWARN9 sqlca.sqlwarn??(9??)\n#define SQLWARNA sqlca.sqlwarn??(10??)\n#define SQLSTATE sqlca.sqlstate\n#endif\nstruct sqlca sqlca;\n\nstatic bool _useDB2()\n\u00e4\nif (getenv(KEYWORD_USEDB2) && strcasecmp(getenv(KEYWORD_USEDB2),\"NO\") =\u00d6\n= 0)\n\u00e4\n    char w\u00c4128\u00dc;\n    SQLINTERFACE::fileDB2 = fopen(genOpenName(KEYWORD_USEDB2_FILE,w),\"w\u00d6\n\");\n    Msg(10000+1003)<<eol;\n    return false;\n\u00fc\nelse\n    return true;\n\u00fc\n\nchar *      SQLINTERFACE::plan        = strdup(getenv(KEYWORD_DB_PLAN));\nchar *      SQLINTERFACE::subsystem   = strdup(getenv(KEYWORD_DB_SUBSYS\u00d6\n));\nchar *      SQLINTERFACE::dSql        = initDynamicSql();\nmCHAIN      DssJob::dssJobs;\nmCHAIN      SQLINTERFACE::tasks;\nbool        SQLINTERFACE::useDB2     = _useDB2();\nFILE *      SQLINTERFACE::fileDB2    =  0;\n\n\n\nERROR_MESSAGE * SQLINTERFACE::error_message = new ERROR_MESSAGE();\nSQLINTERFACE::SQLINTERFACE():mERROR()\n\u00e4\n  tryToConnect();\n\u00fc\n\nvoid SQLINTERFACE::tryToConnect()\n\u00e4\n\n\n  char t\u00c412\u00dc;\n  sprintf(t,\"%p\",getTCB());\n  if (tasks.search(t) == 0)\n      tasks.addlast(new TcbARCHSQL(t,connectDB()));\n      JOBENV::DEBUG(1,t);\n\u00fc\n\nARCHSQL * SQLINTERFACE::connectDB()\n\u00e4\n      ARCHSQL * archsql = new ARCHSQL();\n      if (useDB2)\n      \u00e4\n      if (subsystem==0) return 0;\n      ARCHSQL * archsql = new ARCHSQL();\n      archsql->setSubSystem(subsystem);\n      char _plan\u00c4\u00dc = \"        \";\n      memcpy(_plan,plan,strlen(plan));\n      archsql->setPlan(_plan);\n      if (| archsql->call(Connect))\n       markerror();\n      \u00fc\n      else\n      ARCHSQL * archsql = (ARCHSQL*)1;\n      error_message->error_len = short(data_dim*data_len);\n      if (useDB2)\n      Msg(10000+1000)<<subsystem<<plan<<tHEX(int(getTCB()))<<eol;\n      return archsql;\n\u00fc\n\nSQLINTERFACE::\u00dfSQLINTERFACE()\n\u00e4\n\u00fc\n\nvoid SQLINTERFACE::diag(char *t)\n\u00e4\n if (useDB2)\n \u00e4\n Msg(10000+1001)<<t<<SQLCODE<<(char *)(sqlca.sqlerrmc)<<eol;\n int rc = DSNTIAR(&sqlca,error_message,&data_len);\n if ( rc )\n  Msg(10000+9707)<<long(rc)<<eol;\n else\n \u00e4\n   for(int i = 0;i<data_dim;i++)\n   if (| mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len).isEmpty())\n      Msg(10000+9708)<<mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len)\u00d6\n<<eol;\n \u00fc\n \u00fc\n\n Msg(100000+9709)<<\"diag\"<<eol;\n\u00fc\n\nint SQLINTERFACE::commit()\n\u00e4\ntryToConnect();\nif (useDB2)\n\u00e4\n\n/***$$$\n  EXEC SQL COMMIT\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST1 =\n  \u00e464, 4, 150,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 0, 0, 0, 0, 1208, 310, 4239, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR1;\n  SQLPLIST1.SQLCODEP = (char *) &sqlca;\n  SQLPLIST1.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST1.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST1.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST1.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST1);\n  \u00fc\n\n\u00fc\n  return 1;\n\u00fc\n\nvoid SQLINTERFACE::Error(char * t,Error_Action a)\n\u00e4\n\n\n Msg(100000+9709)<<\"error\"<<eol;\n\n\u00fc\n\nstatic char * initDynamicSql()\n\u00e4\n  char b\u00c432000\u00dc;\n  char _genFileName\u00c41024\u00dc;\n  size_t o = 0;\n  FILE * sqlFile = 0;\n  if (SQLINTERFACE::useDB2 && access(KEYWORD_SQLFILE,0x04)==0)\n  sqlFile=  fopen(genOpenName(KEYWORD_SQLFILE,_genFileName),\"r\");\n  if (sqlFile)\n  while(fgets(b+o,sizeof(b)-o,sqlFile))\n  \u00e4\n    o = strchr(b+o,'\u00d6n')-b;\n    if (o>0) *(b+o) = 0;\n      else\n    break;\n  \u00fc\n  if (sqlFile)\n    fclose(sqlFile);\n  else\n    strcpy(b,fullQuery);\n  JOBENV::DEBUG(1,(char *)b);\n  char * rb = new char\u00c4strlen(b)+1\u00dc;\n  strcpy(rb,b);\n  return (rb);\n\u00fc\n\n\n\n\n\nDssJob::DssJob():\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==0)\n\u00e4\n   init();\n\u00fc\nelse\n\t\t fclose(f);\n\n\u00fc\n\nDssJob::DssJob(const char * d):\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==0)\n\u00e4\n   init();\n\u00fc\nelse\n\t fclose(f);\n strcpy(dataset.arr,d);\n dataset.len = strlen(d);\n\u00fc\nDssJob::DssJob(TIMESTAMP& ts):\nSQLINTERFACE(),\nchainE(ts.arr),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\n init();\n memcpy(t.arr,ts.arr,ts.len);\n t.len = ts.len;\n if (useDB2)\n \u00e4\n\n/***$$$\n EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n EXEC SQL SELECT KEY, JOBNAME, JOBNUMBER, DATASET\n INTO\n :timestamp,\n :jobName,\n :jobNumber,\n :dataset\n FROM DSSJOBS WHERE KEY = :t\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST3 =\n  \u00e464, 17412, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 2, 0, 0, 0, 1208, 231, 4328, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR3;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 1) ??);\n     \u00fc SQLPVARS3;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLAVELT??( (sizeof(SQLELTS) * 4) ??);\n     \u00fc SQLAVARS3;\n  SQLELTS_PTR3 = (SQLELTS *) &SQLPVARS3.SQLPVELT;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 28;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( t );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS3.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS3.SQLDABC = 60;\n  SQLPVARS3.SQLN    = 1;\n  SQLPVARS3.SQLD    = 1;\n  SQLPLIST3.SQLVPARM = (char *) &SQLPVARS3.SQLDAID;\n  SQLELTS_PTR3 = (SQLELTS *) &SQLAVARS3.SQLAVELT;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 28;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  SQLELTS_PTR3 = SQLELTS_PTR3 + 1;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 9;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( jobName );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  SQLELTS_PTR3 = SQLELTS_PTR3 + 1;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 9;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( jobNumber );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  SQLELTS_PTR3 = SQLELTS_PTR3 + 1;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 255;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( dataset );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  strcpy(SQLAVARS3.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLAVARS3.SQLDABC = 192;\n  SQLAVARS3.SQLN    = 4;\n  SQLAVARS3.SQLD    = 4;\n  SQLPLIST3.SQLAPARM = (char *) &SQLAVARS3.SQLDAID;\n  SQLPLIST3.SQLCODEP = (char *) &sqlca;\n  SQLPLIST3.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST3.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST3.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST3.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST3);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n if (SQLCODE == 100)\n    markerror();\n \u00fc\n char * c;\n dataset.arr\u00c4sizeof(dataset.arr)-1\u00dc = 0;\n if ((c = strchr(dataset.arr,' ')))\n     *c = 0;\n return;\nSQLERROR:\n  diag(\"SELECT\");\n  markerror();\n\u00fc\n\n\nDssJob::\u00dfDssJob()\n\u00e4\n\u00fc\n\nvoid DssJob::init()\n\u00e4\n   memset(&timestamp,0,sizeof(timestamp));\n   \u00e4 jobName.len = short((((sizeof(jobName.arr))>(strlen((char *)jobEnv\u00d6\n->jobName)))?(strlen((char *)jobEnv->jobName)):(sizeof(jobName.arr))));\u00d6\n strncpy(jobName.arr,(char *)jobEnv->jobName,jobName.len); \u00fc;\n   \u00e4 jobNumber.len = short((((sizeof(jobNumber.arr))>(strlen((char *)jo\u00d6\nbEnv->jobId)))?(strlen((char *)jobEnv->jobId)):(sizeof(jobNumber.arr)))\u00d6\n); strncpy(jobNumber.arr,(char *)jobEnv->jobId,jobNumber.len); \u00fc;\n   \u00e4 program.len = short((((sizeof(program.arr))>(strlen((char *)jobEnv\u00d6\n->program)))?(strlen((char *)jobEnv->program)):(sizeof(program.arr))));\u00d6\n strncpy(program.arr,(char *)jobEnv->program,program.len); \u00fc;\n   datasetcount = 0;\n   memset(&joblog,0,sizeof(joblog));\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n\n/***$$$\n   EXEC SQL SET :timestamp = CURRENT TIMESTAMP\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST4 =\n  \u00e464, 1028, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 3, 0, 0, 0, 1208, 746, 4370, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR4;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLAVELT??( (sizeof(SQLELTS) * 1) ??);\n     \u00fc SQLAVARS4;\n  SQLELTS_PTR4 = (SQLELTS *) &SQLAVARS4.SQLAVELT;\n  SQLELTS_PTR4->SQLTYPE = 448;\n  SQLELTS_PTR4->SQLLEN  = 28;\n  SQLELTS_PTR4->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR4->SQLIND  = NULL;\n  SQLELTS_PTR4->SQLNAMLEN  = 0;\n  strcpy(SQLAVARS4.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLAVARS4.SQLDABC = 60;\n  SQLAVARS4.SQLN    = 1;\n  SQLAVARS4.SQLD    = 1;\n  SQLPLIST4.SQLAPARM = (char *) &SQLAVARS4.SQLDAID;\n  SQLPLIST4.SQLCODEP = (char *) &sqlca;\n  SQLPLIST4.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST4.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST4.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST4.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST4);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   SQLERROR:\n   if (SQLCODE) diag(\"SET\");\n   \u00fc\n   else\n   \u00e4\n   time_t temp;\n   struct tm *timeptr;\n   temp = time(0);\n   timeptr = localtime(&temp);\n   timestamp.len = strftime(timestamp.arr,sizeof(timestamp.arr)-1,\"%Y-%\u00d6\nm-%d-%H.%M.%S\", timeptr);\n   \u00fc\n   mvsSTRING _dataset;\n   _dataset = mvsSTRING(getenv(KEYWORD_PREFIX)) + \"/\" +\n             jobEnv->jobName + jobEnv->jobId +\n             mvsSTRING(timestamp.arr,timestamp.len);\n   dataset.len = short(_dataset.lengthOf());\n   JOBENV::DEBUG(1,(char *)_dataset);\n   memcpy(dataset.arr,(char *)_dataset,dataset.len+1);\n\u00fc\n\nint DssJob::insert()\n\u00e4\n   CHAINITER::reset();\n   DssDataset * ds;\n   DssDataset * dp;\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n\n/***$$$\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n   EXEC SQL INSERT INTO DSSJOBS\n    VALUES(:timestamp,\n           :jobName, :jobNumber, :program, :dataset, :joblog)\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST6 =\n  \u00e464, 16388, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 4, 0, 0, 0, 1208, 232, 4401, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR6;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 6) ??);\n     \u00fc SQLPVARS6;\n  SQLELTS_PTR6 = (SQLELTS *) &SQLPVARS6.SQLPVELT;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 28;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 9;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( jobName );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 9;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( jobNumber );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 9;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( program );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 255;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( dataset );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 30000;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( joblog );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS6.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS6.SQLDABC = 280;\n  SQLPVARS6.SQLN    = 6;\n  SQLPVARS6.SQLD    = 6;\n  SQLPLIST6.SQLVPARM = (char *) &SQLPVARS6.SQLDAID;\n  SQLPLIST6.SQLCODEP = (char *) &sqlca;\n  SQLPLIST6.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST6.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST6.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST6.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST6);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   \u00fc\n   else\n   \u00e4\n     if (fileDB2)\n     fprintf(fileDB2,\"insert into DSSJOBS:\u00d6n\");\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"jobName\",jobName.len,j\u00d6\nobName.len,jobName.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"jobNumber\",jobNumber.l\u00d6\nen,jobNumber.len,jobNumber.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"program\",program.len,p\u00d6\nrogram.len,program.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"dataset\",dataset.len,d\u00d6\nataset.len,dataset.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"joblog\",joblog.len,job\u00d6\nlog.len,joblog.arr);;\n    \u00fc\n\n   ds = (DssDataset *)CHAINITER::next();\n   while(ds)\n   \u00e4\n    if(| ds->insert())\n     Error(Msg(10000+1002)<<ds->dataset.arr<<eol,Abort);\n     dp = ds;\n     ds = (DssDataset *)CHAINITER::next();\n     mCHAIN::del(dp);\n     delete dp;\n   \u00fc\n  commit();\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSJOBS\");\n  markerror();\n  return 0;\n\u00fc\n\nstatic char today\u00c412\u00dc;\n\nint DssJob::query(mCHAIN *m,char * date)\n\u00e4\n   if (useDB2==false)\n\treturn 0;\n   CHAINITER iter(*m);\n   mvsSTRING like(\" \");\n   chainE * mask = iter.next();\n   if ( date == 0 )\n   \u00e4\n     date = today;\n     formatTime(today,sizeof(today),\"%d.%m.%Y\");\n     JOBENV::DEBUG(1,(char *)date);\n   \u00fc\n   int likeFlag = 0;\n   while(mask)\n   \u00e4\n      int i, j;\n      for(i=0, j=0;mask->chainEid\u00c4i\u00dc;i++)\n      \u00e4\n         if(mask->chainEid\u00c4i\u00dc |= '*')\n            mask->chainEid\u00c4j++\u00dc = mask->chainEid\u00c4i\u00dc;\n         else if (mask->chainEid\u00c4i+1\u00dc |= '*')\n         \u00e4\n            mask->chainEid\u00c4j++\u00dc = '%';\n            likeFlag = 1;\n         \u00fc\n       \u00fc\n       if (mask->chainEid\u00c4j-1\u00dc |= '%')\n           mask->chainEid\u00c4j++\u00dc = '%';\n      mask->chainEid\u00c4j\u00dc = 0;\n      like = like + \"A.DATASET LIKE '\"+mvsSTRING(mask->chainEid)+\"' \";\n      if (mask->next)\n         like = like + \" OR \";\n      mask = iter.next();\n   \u00fc\n   JOBENV::DEBUG(1,(char *)like);\n     \u00e4\n     char * p\u00c48\u00dc;\n     Msg(10000+122)<<dSql<<eol;\n     size_t l = strlen(dSql);\n     int j = 0;\n     for(int i = 0;i<l&&j<8;i++)\n       if (dSql\u00c4i\u00dc=='%' && dSql\u00c4i+2\u00dc == '%')\n         \u00e4\n         switch (dSql\u00c4i+1\u00dc)\n           \u00e4\n           case 'M':\n           case 'm': p\u00c4j++\u00dc = like;\n             break;\n           case 'D':\n           case 'd': p\u00c4j++\u00dc = date;\n             break;\n           default :\n             JOBENV::Error(Msg(10000+121)<<dSql\u00c4i\u00dc<<eol,JOBENV::Abort);\n           \u00fc\n           dSql\u00c4i+1\u00dc = 's';\n         strcpy(dSql+i+2,dSql+i+3);\n         l -= 2;\n         \u00fc\n       switch(j)\n         \u00e4\n         default:\n         case 0:\n         strcpy(dynamicSql.arr,dSql);\n         break;\n         case 1:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc);\n         break;\n         case 2:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc);\n         break;\n         case 3:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc);\n         break;\n         case 4:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc);\n         break;\n         case 5:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc);\n         break;\n         case 6:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc);\n         break;\n         case 7:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc,p\u00c46\u00dc);\n         break;\n         \u00fc\n     \u00fc\n   JOBENV::DEBUG(1,(char *)dynamicSql.arr);\n   Msg(10000+123)<<dynamicSql.arr<<eol;\n   dynamicSql.len =short(strlen(dynamicSql.arr));\n   tryToConnect();\n\t DssJob * job = 0;\n   int fetchCount = 0;\n\n/***$$$\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n   EXEC SQL PREPARE FULL_QUERY FROM :dynamicSql\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST8 =\n  \u00e464, 16388, 35,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 14, 4538, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR8;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 2) ??);\n     \u00fc SQLPVARS8;\n  SQLELTS_PTR8 = (SQLELTS *) &SQLPVARS8.SQLPVELT;\n  SQLELTS_PTR8->SQLTYPE = 452;\n  SQLELTS_PTR8->SQLLEN  = 0;\n  SQLELTS_PTR8->SQLADDR = 0;\n  SQLELTS_PTR8->SQLNAMLEN  = 0;\n  SQLELTS_PTR8 = SQLELTS_PTR8 + 1;\n  SQLELTS_PTR8->SQLTYPE = 448;\n  SQLELTS_PTR8->SQLLEN  = 32000;\n  SQLELTS_PTR8->SQLADDR = (char *)\n  &( dynamicSql );\n  SQLELTS_PTR8->SQLIND  = NULL;\n  SQLELTS_PTR8->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS8.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS8.SQLDABC = 104;\n  SQLPVARS8.SQLN    = 2;\n  SQLPVARS8.SQLD    = 2;\n  SQLPLIST8.SQLVPARM = (char *) &SQLPVARS8.SQLDAID;\n  SQLPLIST8.SQLCODEP = (char *) &sqlca;\n  SQLPLIST8.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST8.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST8.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST8.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST8);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n\n/***$$$\n   EXEC SQL DECLARE C_FULL_QUERY CURSOR FOR FULL_QUERY\n$$$***/\n\n\n/***$$$\n   EXEC SQL OPEN C_FULL_QUERY\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST10 =\n  \u00e464, 4, 50,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 3, 4540, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR10;\n  SQLPLIST10.SQLCODEP = (char *) &sqlca;\n  SQLPLIST10.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST10.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST10.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST10.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST10);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n\n   for (;;)\n   \u00e4\n\n/***$$$\n      EXEC SQL FETCH C_FULL_QUERY INTO\n      :record_key,\n      :record_job,\n      :record_dataset,\n      :record_volumes,\n      :record_size\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST11 =\n  \u00e464, 1028, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 4, 4544, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR11;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLAVELT??( (sizeof(SQLELTS) * 5) ??);\n     \u00fc SQLAVARS11;\n  SQLELTS_PTR11 = (SQLELTS *) &SQLAVARS11.SQLAVELT;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 28;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_key );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 28;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_job );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 45;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_dataset );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 37;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_volumes );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 496;\n  SQLELTS_PTR11->SQLLEN  = 4;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_size );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  strcpy(SQLAVARS11.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLAVARS11.SQLDABC = 236;\n  SQLAVARS11.SQLN    = 5;\n  SQLAVARS11.SQLD    = 5;\n  SQLPLIST11.SQLAPARM = (char *) &SQLAVARS11.SQLDAID;\n  SQLPLIST11.SQLCODEP = (char *) &sqlca;\n  SQLPLIST11.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST11.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST11.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST11.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST11);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n      if (SQLCODE == 100) break;\n\n        if (job == 0 ]]\n         memcmp(job->timestamp.arr,record_job.arr,job->timestamp.len))\n    \u00e4\n         job = new DssJob((TIMESTAMP&)record_job);\n         dssJobs.addlast(job);\n         fetchCount++;\n        \u00fc\n        DssDataset * dataset = new DssDataset(job,\n                                        record_dataset.arr,\n                                        record_volumes.arr,\n                                        record_type,\n                                        record_size);\n   \u00fc\n\n/***$$$\n   EXEC SQL CLOSE C_FULL_QUERY\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST12 =\n  \u00e464, 4, 45,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 5, 4565, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR12;\n  SQLPLIST12.SQLCODEP = (char *) &sqlca;\n  SQLPLIST12.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST12.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST12.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST12.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST12);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   return fetchCount;\nSQLERROR:\n   diag(\"FULL QUERY\");\n   markerror();\n   return -1;\n\u00fc\n\nint DssJob::doWeNeed(const char * d)\n  \u00e4\n  CHAINITER iter(this);\n  DssDataset * ds =(DssDataset *)iter.next();\n  while (ds)\n    \u00e4\n    if (ds->compare(d))\n      return 1;\n    ds =(DssDataset *)iter.next();\n    \u00fc\n  return 0;\n  \u00fc\n\nint DssJob::allOnline()\n\u00e4\n char _genFileName\u00c41024\u00dc;\n  FILE *   restore = fopen(genOpenName(\"RESTORE\",_genFileName),\"wb\");\n  if (| restore)\n     JOBENV::Error(Msg(10000+110)<<\"RESTORE\"<<eol,JOBENV::Abort);\n  int rc = 1;\n  CHAINITER iter(dssJobs);\n  DssJob * job = (DssJob*)iter.next();\n  while (job)\n  \u00e4\n    int file = open(genOpenName(job->getDatasetName(),_genFileName),0x0\u00d6\n2+0);\n    if (file < 0)\n    \u00e4\n       rc = 0;\n       JOBENV::Error(Msg(10000+120)<<job->getDatasetName()<<strerror((*\u00d6\n__errno()))\n         <<eol,JOBENV::Continue);\n       fprintf(restore,\"%s\u00d6n\",job->getDatasetName());\n    \u00fc\n    else\n       close(file);\n    job = (DssJob*)iter.next();\n  \u00fc\n  fclose(restore);\n  return rc;\n\u00fc\n\n\n\n\n\n\nDssDataset::DssDataset(DssJob* j,char *n,char *v,int t,int s):\nSQLINTERFACE(),\nchainE(n),\njob(j)\n\u00e4\n   job->addlast(this);\n   dataset.len = (((strlen(n))>(sizeof(dataset.arr)))?(sizeof(dataset.a\u00d6\nrr)):(strlen(n)));\n   strncpy(dataset.arr,n,dataset.len);\n   dataset.arr\u00c4dataset.len\u00dc = 0;\n\n   volumes.len = (((strlen(v))>(sizeof(volumes.arr)-1))?(sizeof(volumes\u00d6\n.arr)-1):(strlen(v)));\n   strncpy(volumes.arr,v,volumes.len);\n   volumes.arr\u00c4volumes.len\u00dc = 0;\n   type = t;\n   recordsize = s;\n   JOBENV::DEBUG(1,\"Dataset construct\",n,v);\n\u00fc\n\nDssDataset::\u00dfDssDataset()\n\u00e4\n\u00fc\n\nint DssDataset::insert()\n\u00e4\n   tryToConnect();\n   memcpy(timestamp.arr,job->timestamp.arr,job->timestamp.len+1);\n   timestamp.len = job->timestamp.len;\n   JOBENV::DEBUG(1,\"Dataset insert:\",dataset.arr);\n   if (useDB2)\n   \u00e4\n\n/***$$$\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n   EXEC SQL INSERT INTO DSSDATASETS\n   VALUES(CURRENT TIMESTAMP,\n   :timestamp,\n   :dataset,\n   :volumes,\n   :type,\n   :recordsize)\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST14 =\n  \u00e464, 16388, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 5, 0, 0, 0, 1208, 232, 4653, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR14;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 5) ??);\n     \u00fc SQLPVARS14;\n  SQLELTS_PTR14 = (SQLELTS *) &SQLPVARS14.SQLPVELT;\n  SQLELTS_PTR14->SQLTYPE = 448;\n  SQLELTS_PTR14->SQLLEN  = 28;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 448;\n  SQLELTS_PTR14->SQLLEN  = 255;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( dataset );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 448;\n  SQLELTS_PTR14->SQLLEN  = 37;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( volumes );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 496;\n  SQLELTS_PTR14->SQLLEN  = 4;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( type );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 496;\n  SQLELTS_PTR14->SQLLEN  = 4;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( DssDatasetRecord.recordsize );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS14.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS14.SQLDABC = 236;\n  SQLPVARS14.SQLN    = 5;\n  SQLPVARS14.SQLD    = 5;\n  SQLPLIST14.SQLVPARM = (char *) &SQLPVARS14.SQLDAID;\n  SQLPLIST14.SQLCODEP = (char *) &sqlca;\n  SQLPLIST14.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST14.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST14.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST14.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST14);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   \u00fc\n   else\n   \u00e4\n   if (SQLINTERFACE::fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\"insert into DSSDATASETS:\u00d6n\");\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"timestamp\",timestamp.len\u00d6\n,timestamp.len,timestamp.arr);;\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"dataset\",dataset.len,dat\u00d6\naset.len,dataset.arr);;\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"volumes\",volumes.len,vol\u00d6\numes.len,volumes.arr);;\n   if (fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\" type:%d\u00d6n size:%d\u00d6n\",type,recordsize\u00d6\n);\n   \u00fc\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSDATASETS\");\n  markerror();\n  return 0;\n\u00fc\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GZIO": {"ttr": 1385, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* gzio.c -- IO on .gz files\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * Compile this file with -DNO_DEFLATE to avoid the compression code.\n */\n\n/* \u00a7(#) $Id: gzio.c,v 1.2 2003/09/11 11:16:22 matthiasw Exp $ */\n\n#include <stdio.h>\n\n#include \"zutil.h\"\n\nstruct internal_state \u00e4int dummy;\u00fc; /* for buggy compilers */\n\n#ifndef Z_BUFSIZE\n#  ifdef MAXSEG_64K\n#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */\n#  else\n#    define Z_BUFSIZE 16384\n#  endif\n#endif\n#ifndef Z_PRINTF_BUFSIZE\n#  define Z_PRINTF_BUFSIZE 4096\n#endif\n\n#define ALLOC(size) malloc(size)\n#define TRYFREE(p) \u00e4if (p) free(p);\u00fc\n\nstatic int gz_magic\u00c42\u00dc = \u00e40x1f, 0x8b\u00fc; /* gzip magic header */\n\n/* gzip flag byte */\n#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */\n#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */\n#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */\n#define ORIG_NAME    0x08 /* bit 3 set: original file name present */\n#define COMMENT      0x10 /* bit 4 set: file comment present */\n#define RESERVED     0xE0 /* bits 5..7: reserved */\n\ntypedef struct gz_stream \u00e4\n    z_stream stream;\n    int      z_err;   /* error code for last stream operation */\n    int      z_eof;   /* set if end of input file */\n    FILE     *file;   /* .gz file */\n    Byte     *inbuf;  /* input buffer */\n    Byte     *outbuf; /* output buffer */\n    uLong    crc;     /* crc32 of uncompressed data */\n    char     *msg;    /* error message */\n    char     *path;   /* path name for debugging only */\n    int      transparent; /* 1 if input file is not a .gz file */\n    char     mode;    /* 'w' or 'r' */\n    long     startpos; /* start of compressed data in file (header skipped) */\n\u00fc gz_stream;\n\n\nlocal gzFile gz_open      OF((const char *path, const char *mode, int  fd));\nlocal int do_flush        OF((gzFile file, int flush));\nlocal int    get_byte     OF((gz_stream *s));\nlocal void   check_header OF((gz_stream *s));\nlocal int    destroy      OF((gz_stream *s));\nlocal void   putLong      OF((FILE *file, uLong x));\nlocal uLong  getLong      OF((gz_stream *s));\n\n/* ===========================================================================\n     Opens a gzip (.gz) file for reading or writing. The mode parameter\n   is as in fopen (\"rb\" or \"wb\"). The file is given either by file descriptor\n   or path name (if fd == -1).\n     gz_open return NULL if the file could not be opened or if there was\n   insufficient memory to allocate the (de)compression state; errno\n   can be checked to distinguish the two cases (if errno is zero, the\n   zlib error is Z_MEM_ERROR).\n*/\nlocal gzFile gz_open (path, mode, fd)\n    const char *path;\n    const char *mode;\n    int  fd;\n\u00e4\n    int err;\n    int level = Z_DEFAULT_COMPRESSION; /* compression level */\n    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */\n    char *p = (char*)mode;\n    gz_stream *s;\n    char fmode\u00c480\u00dc; /* copy of mode, without the compression level */\n    char *m = fmode;\n\n    if (|path ]] |mode) return Z_NULL;\n\n    s = (gz_stream *)ALLOC(sizeof(gz_stream));\n    if (|s) return Z_NULL;\n\n    s->stream.zalloc = (alloc_func)0;\n    s->stream.zfree = (free_func)0;\n    s->stream.opaque = (voidpf)0;\n    s->stream.next_in = s->inbuf = Z_NULL;\n    s->stream.next_out = s->outbuf = Z_NULL;\n    s->stream.avail_in = s->stream.avail_out = 0;\n    s->file = NULL;\n    s->z_err = Z_OK;\n    s->z_eof = 0;\n    s->crc = crc32(0L, Z_NULL, 0);\n    s->msg = NULL;\n    s->transparent = 0;\n\n    s->path = (char*)ALLOC(strlen(path)+1);\n    if (s->path == NULL) \u00e4\n        return destroy(s), (gzFile)Z_NULL;\n    \u00fc\n    strcpy(s->path, path); /* do this early for debugging */\n\n    s->mode = '\u00d60';\n    do \u00e4\n        if (*p == 'r') s->mode = 'r';\n        if (*p == 'w' ]] *p == 'a') s->mode = 'w';\n        if (*p >= '0' && *p <= '9') \u00e4\n\t    level = *p - '0';\n\t\u00fc else if (*p == 'f') \u00e4\n\t  strategy = Z_FILTERED;\n\t\u00fc else if (*p == 'h') \u00e4\n\t  strategy = Z_HUFFMAN_ONLY;\n\t\u00fc else \u00e4\n\t    *m++ = *p; /* copy the mode */\n\t\u00fc\n    \u00fc while (*p++ && m |= fmode + sizeof(fmode));\n    if (s->mode == '\u00d60') return destroy(s), (gzFile)Z_NULL;\n\n    if (s->mode == 'w') \u00e4\n#ifdef NO_DEFLATE\n        err = Z_STREAM_ERROR;\n#else\n        err = deflateInit2(&(s->stream), level,\n                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);\n        /* windowBits is passed < 0 to suppress zlib header */\n\n        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n#endif\n        if (err |= Z_OK ]] s->outbuf == Z_NULL) \u00e4\n            return destroy(s), (gzFile)Z_NULL;\n        \u00fc\n    \u00fc else \u00e4\n        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);\n\n        err = inflateInit2(&(s->stream), -MAX_WBITS);\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are\n         * present after the compressed stream.\n         */\n        if (err |= Z_OK ]] s->inbuf == Z_NULL) \u00e4\n            return destroy(s), (gzFile)Z_NULL;\n        \u00fc\n    \u00fc\n    s->stream.avail_out = Z_BUFSIZE;\n\n    errno = 0;\n    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);\n\n    if (s->file == NULL) \u00e4\n        return destroy(s), (gzFile)Z_NULL;\n    \u00fc\n    if (s->mode == 'w') \u00e4\n        /* Write a very simple .gz header:\n         */\n        fprintf(s->file, \"%c%c%c%c%c%c%c%c%c%c\", gz_magic\u00c40\u00dc, gz_magic\u00c41\u00dc,\n             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);\n\ts->startpos = 10L;\n\t/* We use 10L instead of ftell(s->file) to because ftell causes an\n         * fflush on some systems. This version of the library doesn't use\n         * startpos anyway in write mode, so this initialization is not\n         * necessary.\n         */\n    \u00fc else \u00e4\n\tcheck_header(s); /* skip the .gz header */\n\ts->startpos = (ftell(s->file) - s->stream.avail_in);\n    \u00fc\n\n    return (gzFile)s;\n\u00fc\n\n/* ===========================================================================\n     Opens a gzip (.gz) file for reading or writing.\n*/\ngzFile ZEXPORT gzopen (path, mode)\n    const char *path;\n    const char *mode;\n\u00e4\n    return gz_open (path, mode, -1);\n\u00fc\n\n/* ===========================================================================\n     Associate a gzFile with the file descriptor fd. fd is not dup'ed here\n   to mimic the behavio(u)r of fdopen.\n*/\ngzFile ZEXPORT gzdopen (fd, mode)\n    int fd;\n    const char *mode;\n\u00e4\n    char name\u00c420\u00dc;\n\n    if (fd < 0) return (gzFile)Z_NULL;\n    sprintf(name, \"<fd:%d>\", fd); /* for debugging */\n\n    return gz_open (name, mode, fd);\n\u00fc\n\n/* ===========================================================================\n * Update the compression level and strategy\n */\nint ZEXPORT gzsetparams (file, level, strategy)\n    gzFile file;\n    int level;\n    int strategy;\n\u00e4\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL ]] s->mode |= 'w') return Z_STREAM_ERROR;\n\n    /* Make room to allow flushing */\n    if (s->stream.avail_out == 0) \u00e4\n\n\ts->stream.next_out = s->outbuf;\n\tif (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) |= Z_BUFSIZE) \u00e4\n\t    s->z_err = Z_ERRNO;\n\t\u00fc\n\ts->stream.avail_out = Z_BUFSIZE;\n    \u00fc\n\n    return deflateParams (&(s->stream), level, strategy);\n\u00fc\n\n/* ===========================================================================\n     Read a byte from a gz_stream; update next_in and avail_in. Return EOF\n   for end of file.\n   IN assertion: the stream s has been sucessfully opened for reading.\n*/\nlocal int get_byte(s)\n    gz_stream *s;\n\u00e4\n    if (s->z_eof) return EOF;\n    if (s->stream.avail_in == 0) \u00e4\n\terrno = 0;\n\ts->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n\tif (s->stream.avail_in == 0) \u00e4\n\t    s->z_eof = 1;\n\t    if (ferror(s->file)) s->z_err = Z_ERRNO;\n\t    return EOF;\n\t\u00fc\n\ts->stream.next_in = s->inbuf;\n    \u00fc\n    s->stream.avail_in--;\n    return *(s->stream.next_in)++;\n\u00fc\n\n/* ===========================================================================\n      Check the gzip header of a gz_stream opened for reading. Set the stream\n    mode to transparent if the gzip magic header is not present; set s->err\n    to Z_DATA_ERROR if the magic header is present but the rest of the header\n    is incorrect.\n    IN assertion: the stream s has already been created sucessfully;\n       s->stream.avail_in is zero for the first time, but may be non-zero\n       for concatenated .gz files.\n*/\nlocal void check_header(s)\n    gz_stream *s;\n\u00e4\n    int method; /* method byte */\n    int flags;  /* flags byte */\n    uInt len;\n    int c;\n\n    /* Check the gzip magic header */\n    for (len = 0; len < 2; len++) \u00e4\n\tc = get_byte(s);\n\tif (c |= gz_magic\u00c4len\u00dc) \u00e4\n\t    if (len |= 0) s->stream.avail_in++, s->stream.next_in--;\n\t    if (c |= EOF) \u00e4\n\t\ts->stream.avail_in++, s->stream.next_in--;\n\t\ts->transparent = 1;\n\t    \u00fc\n\t    s->z_err = s->stream.avail_in |= 0 ? Z_OK : Z_STREAM_END;\n\t    return;\n\t\u00fc\n    \u00fc\n    method = get_byte(s);\n    flags = get_byte(s);\n    if (method |= Z_DEFLATED ]] (flags & RESERVED) |= 0) \u00e4\n\ts->z_err = Z_DATA_ERROR;\n\treturn;\n    \u00fc\n\n    /* Discard time, xflags and OS code: */\n    for (len = 0; len < 6; len++) (void)get_byte(s);\n\n    if ((flags & EXTRA_FIELD) |= 0) \u00e4 /* skip the extra field */\n\tlen  =  (uInt)get_byte(s);\n\tlen += ((uInt)get_byte(s))<<8;\n\t/* len is garbage if EOF but the loop below will quit anyway */\n\twhile (len-- |= 0 && get_byte(s) |= EOF) ;\n    \u00fc\n    if ((flags & ORIG_NAME) |= 0) \u00e4 /* skip the original file name */\n\twhile ((c = get_byte(s)) |= 0 && c |= EOF) ;\n    \u00fc\n    if ((flags & COMMENT) |= 0) \u00e4   /* skip the .gz file comment */\n\twhile ((c = get_byte(s)) |= 0 && c |= EOF) ;\n    \u00fc\n    if ((flags & HEAD_CRC) |= 0) \u00e4  /* skip the header crc */\n\tfor (len = 0; len < 2; len++) (void)get_byte(s);\n    \u00fc\n    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;\n\u00fc\n\n /* ===========================================================================\n * Cleanup then free the given gz_stream. Return a zlib error code.\n   Try freeing in the reverse order of allocations.\n */\nlocal int destroy (s)\n    gz_stream *s;\n\u00e4\n    int err = Z_OK;\n\n    if (|s) return Z_STREAM_ERROR;\n\n    TRYFREE(s->msg);\n\n    if (s->stream.state |= NULL) \u00e4\n\tif (s->mode == 'w') \u00e4\n#ifdef NO_DEFLATE\n\t    err = Z_STREAM_ERROR;\n#else\n\t    err = deflateEnd(&(s->stream));\n#endif\n\t\u00fc else if (s->mode == 'r') \u00e4\n\t    err = inflateEnd(&(s->stream));\n\t\u00fc\n    \u00fc\n    if (s->file |= NULL && fclose(s->file)) \u00e4\n#ifdef ESPIPE\n\tif (errno |= ESPIPE) /* fclose is broken for pipes in HP/UX */\n#endif\n\t    err = Z_ERRNO;\n    \u00fc\n    if (s->z_err < 0) err = s->z_err;\n\n    TRYFREE(s->inbuf);\n    TRYFREE(s->outbuf);\n    TRYFREE(s->path);\n    TRYFREE(s);\n    return err;\n\u00fc\n\n/* ===========================================================================\n     Reads the given number of uncompressed bytes from the compressed file.\n   gzread returns the number of bytes actually read (0 for end of file).\n*/\nint ZEXPORT gzread (file, buf, len)\n    gzFile file;\n    voidp buf;\n    unsigned len;\n\u00e4\n    gz_stream *s = (gz_stream*)file;\n    Bytef *start = (Bytef*)buf; /* starting point for crc computation */\n    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */\n\n    if (s == NULL ]] s->mode |= 'r') return Z_STREAM_ERROR;\n\n    if (s->z_err == Z_DATA_ERROR ]] s->z_err == Z_ERRNO) return -1;\n    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */\n\n    next_out = (Byte*)buf;\n    s->stream.next_out = (Bytef*)buf;\n    s->stream.avail_out = len;\n\n    while (s->stream.avail_out |= 0) \u00e4\n\n\tif (s->transparent) \u00e4\n\t    /* Copy first the lookahead bytes: */\n\t    uInt n = s->stream.avail_in;\n\t    if (n > s->stream.avail_out) n = s->stream.avail_out;\n\t    if (n > 0) \u00e4\n\t\tzmemcpy(s->stream.next_out, s->stream.next_in, n);\n\t\tnext_out += n;\n\t\ts->stream.next_out = next_out;\n\t\ts->stream.next_in   += n;\n\t\ts->stream.avail_out -= n;\n\t\ts->stream.avail_in  -= n;\n\t    \u00fc\n\t    if (s->stream.avail_out > 0) \u00e4\n\t\ts->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,\n\t\t\t\t\t     s->file);\n\t    \u00fc\n\t    len -= s->stream.avail_out;\n\t    s->stream.total_in  += (uLong)len;\n\t    s->stream.total_out += (uLong)len;\n            if (len == 0) s->z_eof = 1;\n\t    return (int)len;\n\t\u00fc\n        if (s->stream.avail_in == 0 && |s->z_eof) \u00e4\n\n            errno = 0;\n            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n            if (s->stream.avail_in == 0) \u00e4\n                s->z_eof = 1;\n\t\tif (ferror(s->file)) \u00e4\n\t\t    s->z_err = Z_ERRNO;\n\t\t    break;\n\t\t\u00fc\n            \u00fc\n            s->stream.next_in = s->inbuf;\n        \u00fc\n        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);\n\n\tif (s->z_err == Z_STREAM_END) \u00e4\n\t    /* Check CRC and original size */\n\t    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n\t    start = s->stream.next_out;\n\n\t    if (getLong(s) |= s->crc) \u00e4\n\t\ts->z_err = Z_DATA_ERROR;\n\t    \u00fc else \u00e4\n\t        (void)getLong(s);\n                /* The uncompressed length returned by above getlong() may\n                 * be different from s->stream.total_out) in case of\n\t\t * concatenated .gz files. Check for such files:\n\t\t */\n\t\tcheck_header(s);\n\t\tif (s->z_err == Z_OK) \u00e4\n\t\t    uLong total_in = s->stream.total_in;\n\t\t    uLong total_out = s->stream.total_out;\n\n\t\t    inflateReset(&(s->stream));\n\t\t    s->stream.total_in = total_in;\n\t\t    s->stream.total_out = total_out;\n\t\t    s->crc = crc32(0L, Z_NULL, 0);\n\t\t\u00fc\n\t    \u00fc\n\t\u00fc\n\tif (s->z_err |= Z_OK ]] s->z_eof) break;\n    \u00fc\n    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n\n    return (int)(len - s->stream.avail_out);\n\u00fc\n\n\n/* ===========================================================================\n      Reads one byte from the compressed file. gzgetc returns this byte\n   or -1 in case of end of file or error.\n*/\nint ZEXPORT gzgetc(file)\n    gzFile file;\n\u00e4\n    unsigned char c;\n\n    return gzread(file, &c, 1) == 1 ? c : -1;\n\u00fc\n\n\n/* ===========================================================================\n      Reads bytes from the compressed file until len-1 characters are\n   read, or a newline character is read and transferred to buf, or an\n   end-of-file condition is encountered.  The string is then terminated\n   with a null character.\n      gzgets returns buf, or Z_NULL in case of error.\n\n      The current implementation is not optimized at all.\n*/\nchar * ZEXPORT gzgets(file, buf, len)\n    gzFile file;\n    char *buf;\n    int len;\n\u00e4\n    char *b = buf;\n    if (buf == Z_NULL ]] len <= 0) return Z_NULL;\n\n    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ |= '\u00d6n') ;\n    *buf = '\u00d60';\n    return b == buf && len > 0 ? Z_NULL : b;\n\u00fc\n\n\n#ifndef NO_DEFLATE\n/* ===========================================================================\n     Writes the given number of uncompressed bytes into the compressed file.\n   gzwrite returns the number of bytes actually written (0 in case of error).\n*/\nint ZEXPORT gzwrite (file, buf, len)\n    gzFile file;\n    const voidp buf;\n    unsigned len;\n\u00e4\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL ]] s->mode |= 'w') return Z_STREAM_ERROR;\n\n    s->stream.next_in = (Bytef*)buf;\n    s->stream.avail_in = len;\n\n    while (s->stream.avail_in |= 0) \u00e4\n\n        if (s->stream.avail_out == 0) \u00e4\n\n            s->stream.next_out = s->outbuf;\n            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) |= Z_BUFSIZE) \u00e4\n                s->z_err = Z_ERRNO;\n                break;\n            \u00fc\n            s->stream.avail_out = Z_BUFSIZE;\n        \u00fc\n        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);\n        if (s->z_err |= Z_OK) break;\n    \u00fc\n    s->crc = crc32(s->crc, (const Bytef *)buf, len);\n\n    return (int)(len - s->stream.avail_in);\n\u00fc\n\n/* ===========================================================================\n     Converts, formats, and writes the args to the compressed file under\n   control of the format string, as in fprintf. gzprintf returns the number of\n   uncompressed bytes actually written (0 in case of error).\n*/\n#ifdef STDC\n#include <stdarg.h>\n\nint ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n\u00e4\n    char buf\u00c4Z_PRINTF_BUFSIZE\u00dc;\n    va_list va;\n    int len;\n\n    va_start(va, format);\n#ifdef HAS_vsnprintf\n    (void)vsnprintf(buf, sizeof(buf), format, va);\n#else\n    (void)vsprintf(buf, format, va);\n#endif\n    va_end(va);\n    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */\n    if (len <= 0) return 0;\n\n    return gzwrite(file, buf, (unsigned)len);\n\u00fc\n#else /* not ANSI C */\n\nint ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n\t               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)\n    gzFile file;\n    const char *format;\n    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n\ta11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n\u00e4\n    char buf\u00c4Z_PRINTF_BUFSIZE\u00dc;\n    int len;\n\n#ifdef HAS_snprintf\n    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,\n\t     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#else\n    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,\n\t    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#endif\n    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */\n    if (len <= 0) return 0;\n\n    return gzwrite(file, buf, len);\n\u00fc\n#endif\n\n/* ===========================================================================\n      Writes c, converted to an unsigned char, into the compressed file.\n   gzputc returns the value that was written, or -1 in case of error.\n*/\nint ZEXPORT gzputc(file, c)\n    gzFile file;\n    int c;\n\u00e4\n    unsigned char cc = (unsigned char) c; /* required for big endian systems */\n\n    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;\n\u00fc\n\n\n/* ===========================================================================\n      Writes the given null-terminated string to the compressed file, excluding\n   the terminating null character.\n      gzputs returns the number of characters written, or -1 in case of error.\n*/\nint ZEXPORT gzputs(file, s)\n    gzFile file;\n    const char *s;\n\u00e4\n    return gzwrite(file, (char*)s, (unsigned)strlen(s));\n\u00fc\n\n\n/* ===========================================================================\n     Flushes all pending output into the compressed file. The parameter\n   flush is as in the deflate() function.\n*/\nlocal int do_flush (file, flush)\n    gzFile file;\n    int flush;\n\u00e4\n    uInt len;\n    int done = 0;\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL ]] s->mode |= 'w') return Z_STREAM_ERROR;\n\n    s->stream.avail_in = 0; /* should be zero already anyway */\n\n    for (;;) \u00e4\n        len = Z_BUFSIZE - s->stream.avail_out;\n\n        if (len |= 0) \u00e4\n            if ((uInt)fwrite(s->outbuf, 1, len, s->file) |= len) \u00e4\n                s->z_err = Z_ERRNO;\n                return Z_ERRNO;\n            \u00fc\n            s->stream.next_out = s->outbuf;\n            s->stream.avail_out = Z_BUFSIZE;\n        \u00fc\n        if (done) break;\n        s->z_err = deflate(&(s->stream), flush);\n\n\t/* Ignore the second of two consecutive flushes: */\n\tif (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;\n\n        /* deflate has finished flushing only when it hasn't used up\n         * all the available space in the output buffer:\n         */\n        done = (s->stream.avail_out |= 0 ]] s->z_err == Z_STREAM_END);\n\n        if (s->z_err |= Z_OK && s->z_err |= Z_STREAM_END) break;\n    \u00fc\n    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n\u00fc\n\nint ZEXPORT gzflush (file, flush)\n     gzFile file;\n     int flush;\n\u00e4\n    gz_stream *s = (gz_stream*)file;\n    int err = do_flush (file, flush);\n\n    if (err) return err;\n    fflush(s->file);\n    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n\u00fc\n#endif /* NO_DEFLATE */\n\n/* ===========================================================================\n      Sets the starting position for the next gzread or gzwrite on the given\n   compressed file. The offset represents a number of bytes in the\n      gzseek returns the resulting offset location as measured in bytes from\n   the beginning of the uncompressed stream, or -1 in case of error.\n      SEEK_END is not implemented, returns error.\n      In this version of the library, gzseek can be extremely slow.\n*/\nz_off_t ZEXPORT gzseek (file, offset, whence)\n    gzFile file;\n    z_off_t offset;\n    int whence;\n\u00e4\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL ]] whence == SEEK_END ]]\n\ts->z_err == Z_ERRNO ]] s->z_err == Z_DATA_ERROR) \u00e4\n\treturn -1L;\n    \u00fc\n\n    if (s->mode == 'w') \u00e4\n#ifdef NO_DEFLATE\n\treturn -1L;\n#else\n\tif (whence == SEEK_SET) \u00e4\n\t    offset -= s->stream.total_in;\n\t\u00fc\n\tif (offset < 0) return -1L;\n\n\t/* At this point, offset is the number of zero bytes to write. */\n\tif (s->inbuf == Z_NULL) \u00e4\n\t    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */\n\t    zmemzero(s->inbuf, Z_BUFSIZE);\n\t\u00fc\n\twhile (offset > 0)  \u00e4\n\t    uInt size = Z_BUFSIZE;\n\t    if (offset < Z_BUFSIZE) size = (uInt)offset;\n\n\t    size = gzwrite(file, s->inbuf, size);\n\t    if (size == 0) return -1L;\n\n\t    offset -= size;\n\t\u00fc\n\treturn (z_off_t)s->stream.total_in;\n#endif\n    \u00fc\n    /* Rest of function is for reading only */\n\n    /* compute absolute position */\n    if (whence == SEEK_CUR) \u00e4\n\toffset += s->stream.total_out;\n    \u00fc\n    if (offset < 0) return -1L;\n\n    if (s->transparent) \u00e4\n\t/* map to fseek */\n\ts->stream.avail_in = 0;\n\ts->stream.next_in = s->inbuf;\n        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;\n\n\ts->stream.total_in = s->stream.total_out = (uLong)offset;\n\treturn offset;\n    \u00fc\n\n    /* For a negative seek, rewind and use positive seek */\n    if ((uLong)offset >= s->stream.total_out) \u00e4\n\toffset -= s->stream.total_out;\n    \u00fc else if (gzrewind(file) < 0) \u00e4\n\treturn -1L;\n    \u00fc\n    /* offset is now the number of bytes to skip. */\n\n    if (offset |= 0 && s->outbuf == Z_NULL) \u00e4\n\ts->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n    \u00fc\n    while (offset > 0)  \u00e4\n\tint size = Z_BUFSIZE;\n\tif (offset < Z_BUFSIZE) size = (int)offset;\n\n\tsize = gzread(file, s->outbuf, (uInt)size);\n\tif (size <= 0) return -1L;\n\toffset -= size;\n    \u00fc\n    return (z_off_t)s->stream.total_out;\n\u00fc\n\n/* ===========================================================================\n     Rewinds input file.\n*/\nint ZEXPORT gzrewind (file)\n    gzFile file;\n\u00e4\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL ]] s->mode |= 'r') return -1;\n\n    s->z_err = Z_OK;\n    s->z_eof = 0;\n    s->stream.avail_in = 0;\n    s->stream.next_in = s->inbuf;\n    s->crc = crc32(0L, Z_NULL, 0);\n\n    if (s->startpos == 0) \u00e4 /* not a compressed file */\n\trewind(s->file);\n\treturn 0;\n    \u00fc\n\n    (void) inflateReset(&s->stream);\n    return fseek(s->file, s->startpos, SEEK_SET);\n\u00fc\n\n/* ===========================================================================\n     Returns the starting position for the next gzread or gzwrite on the\n   given compressed file. This position represents a number of bytes in the\n   uncompressed data stream.\n*/\nz_off_t ZEXPORT gztell (file)\n    gzFile file;\n\u00e4\n    return gzseek(file, 0L, SEEK_CUR);\n\u00fc\n\n/* ===========================================================================\n     Returns 1 when EOF has previously been detected reading the given\n   input stream, otherwise zero.\n*/\nint ZEXPORT gzeof (file)\n    gzFile file;\n\u00e4\n    gz_stream *s = (gz_stream*)file;\n\n    return (s == NULL ]] s->mode |= 'r') ? 0 : s->z_eof;\n\u00fc\n\n/* ===========================================================================\n   Outputs a long in LSB order to the given file\n*/\nlocal void putLong (file, x)\n    FILE *file;\n    uLong x;\n\u00e4\n    int n;\n    for (n = 0; n < 4; n++) \u00e4\n        fputc((int)(x & 0xff), file);\n        x >>= 8;\n    \u00fc\n\u00fc\n\n/* ===========================================================================\n   Reads a long in LSB order from the given gz_stream. Sets z_err in case\n   of error.\n*/\nlocal uLong getLong (s)\n    gz_stream *s;\n\u00e4\n    uLong x = (uLong)get_byte(s);\n    int c;\n\n    x += ((uLong)get_byte(s))<<8;\n    x += ((uLong)get_byte(s))<<16;\n    c = get_byte(s);\n    if (c == EOF) s->z_err = Z_DATA_ERROR;\n    x += ((uLong)c)<<24;\n    return x;\n\u00fc\n\n/* ===========================================================================\n     Flushes all pending output if necessary, closes the compressed file\n   and deallocates all the (de)compression state.\n*/\nint ZEXPORT gzclose (file)\n    gzFile file;\n\u00e4\n    int err;\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL) return Z_STREAM_ERROR;\n\n    if (s->mode == 'w') \u00e4\n#ifdef NO_DEFLATE\n\treturn Z_STREAM_ERROR;\n#else\n        err = do_flush (file, Z_FINISH);\n        if (err |= Z_OK) return destroy((gz_stream*)file);\n\n        putLong (s->file, s->crc);\n        putLong (s->file, s->stream.total_in);\n#endif\n    \u00fc\n    return destroy((gz_stream*)file);\n\u00fc\n\n/* ===========================================================================\n     Returns the error message for the last error which occured on the\n   given compressed file. errnum is set to zlib error number. If an\n   error occured in the file system and not in the compression library,\n   errnum is set to Z_ERRNO and the application may consult errno\n   to get the exact error code.\n*/\nconst char*  ZEXPORT gzerror (file, errnum)\n    gzFile file;\n    int *errnum;\n\u00e4\n    char *m;\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL) \u00e4\n        *errnum = Z_STREAM_ERROR;\n        return (const char*)ERR_MSG(Z_STREAM_ERROR);\n    \u00fc\n    *errnum = s->z_err;\n    if (*errnum == Z_OK) return (const char*)\"\";\n\n    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);\n\n    if (m == NULL ]] *m == '\u00d60') m = (char*)ERR_MSG(s->z_err);\n\n    TRYFREE(s->msg);\n    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);\n    strcpy(s->msg, s->path);\n    strcat(s->msg, \": \");\n    strcat(s->msg, m);\n    return (const char*)s->msg;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFBLOCK": {"ttr": 1365, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* infblock.c -- interpret and process block types to last block\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"infblock.h\"\n#include \"inftrees.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n\nstruct inflate_codes_state \u00e4int dummy;\u00fc; /* for buggy compilers */\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n/* Table for deflate from PKZIP's appnote.txt. */\nlocal const uInt border\u00c4\u00dc = \u00e4 /* Order of the bit length code lengths */\n        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\u00fc;\n\n/*\n   Notes beyond the 1.93a appnote.txt:\n\n   1. Distance pointers never point before the beginning of the output\n      stream.\n   2. Distance pointers can point back across blocks, up to 32k away.\n   3. There is an implied maximum of 7 bits for the bit length table and\n      15 bits for the actual data.\n   4. If only one code exists, then it is encoded using one bit.  (Zero\n      would be more efficient, but perhaps a little confusing.)  If two\n      codes exist, they are coded using one bit each (0 and 1).\n   5. There is no way of sending zero distance codes--a dummy must be\n      sent if there are none.  (History: a pre 2.0 version of PKZIP would\n      store blocks with no distance codes, but this was discovered to be\n      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow\n      zero distance codes, which is sent as one code of zero bits in\n      length.\n   6. There are up to 286 literal/length codes.  Code 256 represents the\n      end-of-block.  Note however that the static length tree defines\n      288 codes just to fill out the Huffman codes.  Codes 286 and 287\n      cannot be used though, since there is no length base or extra bits\n      defined for them.  Similarily, there are up to 30 distance codes.\n      However, static trees define 32 codes (all 5 bits) to fill out the\n      Huffman codes, but the last two had better not show up in the data.\n   7. Unzip can check dynamic Huffman blocks for complete code sets.\n      The exception is that a single code would not be complete (see #4).\n   8. The five bits following the block type is really the number of\n      literal codes sent minus 257.\n   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits\n      (1+6+6).  Therefore, to output three times the length, you output\n      three codes (1+1+1), whereas to output four times the same length,\n      you only need two codes (1+3).  Hmm.\n  10. In the tree reconstruction algorithm, Code = Code + Increment\n      only if BitLength(i) is not zero.  (Pretty obvious.)\n  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)\n  12. Note: length code 284 can represent 227-258, but length code 285\n      really is 258.  The last length deserves its own, short code\n      since it gets used a lot in very redundant files.  The length\n      258 is special since 258 - 3 (the min match length) is 255.\n  13. The literal/length and distance code bit lengths are read as a\n      single stream of lengths.  It is possible (and advantageous) for\n      a repeat code (16, 17, or 18) to go across the boundary between\n      the two sets of lengths.\n */\n\n\nvoid inflate_blocks_reset(s, z, c)\ninflate_blocks_statef *s;\nz_streamp z;\nuLongf *c;\n\u00e4\n  if (c |= Z_NULL)\n    *c = s->check;\n  if (s->mode == BTREE ]] s->mode == DTREE)\n    ZFREE(z, s->sub.trees.blens);\n  if (s->mode == CODES)\n    inflate_codes_free(s->sub.decode.codes, z);\n  s->mode = TYPE;\n  s->bitk = 0;\n  s->bitb = 0;\n  s->read = s->write = s->window;\n  if (s->checkfn |= Z_NULL)\n    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);\n  Tracev((stderr, \"inflate:   blocks reset\u00d6n\"));\n\u00fc\n\n\ninflate_blocks_statef *inflate_blocks_new(z, c, w)\nz_streamp z;\ncheck_func c;\nuInt w;\n\u00e4\n  inflate_blocks_statef *s;\n\n  if ((s = (inflate_blocks_statef *)ZALLOC\n       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)\n    return s;\n  if ((s->hufts =\n       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)\n  \u00e4\n    ZFREE(z, s);\n    return Z_NULL;\n  \u00fc\n  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)\n  \u00e4\n    ZFREE(z, s->hufts);\n    ZFREE(z, s);\n    return Z_NULL;\n  \u00fc\n  s->end = s->window + w;\n  s->checkfn = c;\n  s->mode = TYPE;\n  Tracev((stderr, \"inflate:   blocks allocated\u00d6n\"));\n  inflate_blocks_reset(s, z, Z_NULL);\n  return s;\n\u00fc\n\n\nint inflate_blocks(s, z, r)\ninflate_blocks_statef *s;\nz_streamp z;\nint r;\n\u00e4\n  uInt t;               /* temporary storage */\n  uLong b;              /* bit buffer */\n  uInt k;               /* bits in bit buffer */\n  Bytef *p;             /* input data pointer */\n  uInt n;               /* bytes available there */\n  Bytef *q;             /* output window write pointer */\n  uInt m;               /* bytes to end of window or read pointer */\n\n  /* copy input/output information to locals (UPDATE macro restores) */\n  LOAD\n\n  /* process input based on current state */\n  while (1) switch (s->mode)\n  \u00e4\n    case TYPE:\n      NEEDBITS(3)\n      t = (uInt)b & 7;\n      s->last = t & 1;\n      switch (t >> 1)\n      \u00e4\n        case 0:                         /* stored */\n          Tracev((stderr, \"inflate:     stored block%s\u00d6n\",\n                 s->last ? \" (last)\" : \"\"));\n          DUMPBITS(3)\n          t = k & 7;                    /* go to byte boundary */\n          DUMPBITS(t)\n          s->mode = LENS;               /* get length of stored block */\n          break;\n        case 1:                         /* fixed */\n          Tracev((stderr, \"inflate:     fixed codes block%s\u00d6n\",\n                 s->last ? \" (last)\" : \"\"));\n          \u00e4\n            uInt bl, bd;\n            inflate_huft *tl, *td;\n\n            inflate_trees_fixed(&bl, &bd, &tl, &td, z);\n            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);\n            if (s->sub.decode.codes == Z_NULL)\n            \u00e4\n              r = Z_MEM_ERROR;\n              LEAVE\n            \u00fc\n          \u00fc\n          DUMPBITS(3)\n          s->mode = CODES;\n          break;\n        case 2:                         /* dynamic */\n          Tracev((stderr, \"inflate:     dynamic codes block%s\u00d6n\",\n                 s->last ? \" (last)\" : \"\"));\n          DUMPBITS(3)\n          s->mode = TABLE;\n          break;\n        case 3:                         /* illegal */\n          DUMPBITS(3)\n          s->mode = BAD;\n          z->msg = (char*)\"invalid block type\";\n          r = Z_DATA_ERROR;\n          LEAVE\n      \u00fc\n      break;\n    case LENS:\n      NEEDBITS(32)\n      if ((((\u00dfb) >> 16) & 0xffff) |= (b & 0xffff))\n      \u00e4\n        s->mode = BAD;\n        z->msg = (char*)\"invalid stored block lengths\";\n        r = Z_DATA_ERROR;\n        LEAVE\n      \u00fc\n      s->sub.left = (uInt)b & 0xffff;\n      b = k = 0;                      /* dump bits */\n      Tracev((stderr, \"inflate:       stored length %u\u00d6n\", s->sub.left));\n      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);\n      break;\n    case STORED:\n      if (n == 0)\n        LEAVE\n      NEEDOUT\n      t = s->sub.left;\n      if (t > n) t = n;\n      if (t > m) t = m;\n      zmemcpy(q, p, t);\n      p += t;  n -= t;\n      q += t;  m -= t;\n      if ((s->sub.left -= t) |= 0)\n        break;\n      Tracev((stderr, \"inflate:       stored end, %lu total out\u00d6n\",\n              z->total_out + (q >= s->read ? q - s->read :\n              (s->end - s->read) + (q - s->window))));\n      s->mode = s->last ? DRY : TYPE;\n      break;\n    case TABLE:\n      NEEDBITS(14)\n      s->sub.trees.table = t = (uInt)b & 0x3fff;\n#ifndef PKZIP_BUG_WORKAROUND\n      if ((t & 0x1f) > 29 ]] ((t >> 5) & 0x1f) > 29)\n      \u00e4\n        s->mode = BAD;\n        z->msg = (char*)\"too many length or distance symbols\";\n        r = Z_DATA_ERROR;\n        LEAVE\n      \u00fc\n#endif\n      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)\n      \u00e4\n        r = Z_MEM_ERROR;\n        LEAVE\n      \u00fc\n      DUMPBITS(14)\n      s->sub.trees.index = 0;\n      Tracev((stderr, \"inflate:       table sizes ok\u00d6n\"));\n      s->mode = BTREE;\n    case BTREE:\n      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))\n      \u00e4\n        NEEDBITS(3)\n        s->sub.trees.blens\u00c4border\u00c4s->sub.trees.index++\u00dc\u00dc = (uInt)b & 7;\n        DUMPBITS(3)\n      \u00fc\n      while (s->sub.trees.index < 19)\n        s->sub.trees.blens\u00c4border\u00c4s->sub.trees.index++\u00dc\u00dc = 0;\n      s->sub.trees.bb = 7;\n      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,\n                             &s->sub.trees.tb, s->hufts, z);\n      if (t |= Z_OK)\n      \u00e4\n        r = t;\n        if (r == Z_DATA_ERROR)\n        \u00e4\n          ZFREE(z, s->sub.trees.blens);\n          s->mode = BAD;\n        \u00fc\n        LEAVE\n      \u00fc\n      s->sub.trees.index = 0;\n      Tracev((stderr, \"inflate:       bits tree ok\u00d6n\"));\n      s->mode = DTREE;\n    case DTREE:\n      while (t = s->sub.trees.table,\n             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))\n      \u00e4\n        inflate_huft *h;\n        uInt i, j, c;\n\n        t = s->sub.trees.bb;\n        NEEDBITS(t)\n        h = s->sub.trees.tb + ((uInt)b & inflate_mask\u00c4t\u00dc);\n        t = h->bits;\n        c = h->base;\n        if (c < 16)\n        \u00e4\n          DUMPBITS(t)\n          s->sub.trees.blens\u00c4s->sub.trees.index++\u00dc = c;\n        \u00fc\n        else /* c == 16..18 */\n        \u00e4\n          i = c == 18 ? 7 : c - 14;\n          j = c == 18 ? 11 : 3;\n          NEEDBITS(t + i)\n          DUMPBITS(t)\n          j += (uInt)b & inflate_mask\u00c4i\u00dc;\n          DUMPBITS(i)\n          i = s->sub.trees.index;\n          t = s->sub.trees.table;\n          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ]]\n              (c == 16 && i < 1))\n          \u00e4\n            ZFREE(z, s->sub.trees.blens);\n            s->mode = BAD;\n            z->msg = (char*)\"invalid bit length repeat\";\n            r = Z_DATA_ERROR;\n            LEAVE\n          \u00fc\n          c = c == 16 ? s->sub.trees.blens\u00c4i - 1\u00dc : 0;\n          do \u00e4\n            s->sub.trees.blens\u00c4i++\u00dc = c;\n          \u00fc while (--j);\n          s->sub.trees.index = i;\n        \u00fc\n      \u00fc\n      s->sub.trees.tb = Z_NULL;\n      \u00e4\n        uInt bl, bd;\n        inflate_huft *tl, *td;\n        inflate_codes_statef *c;\n\n        bl = 9;         /* must be <= 9 for lookahead assumptions */\n        bd = 6;         /* must be <= 9 for lookahead assumptions */\n        t = s->sub.trees.table;\n        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),\n                                  s->sub.trees.blens, &bl, &bd, &tl, &td,\n                                  s->hufts, z);\n        if (t |= Z_OK)\n        \u00e4\n          if (t == (uInt)Z_DATA_ERROR)\n          \u00e4\n            ZFREE(z, s->sub.trees.blens);\n            s->mode = BAD;\n          \u00fc\n          r = t;\n          LEAVE\n        \u00fc\n        Tracev((stderr, \"inflate:       trees ok\u00d6n\"));\n        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)\n        \u00e4\n          r = Z_MEM_ERROR;\n          LEAVE\n        \u00fc\n        s->sub.decode.codes = c;\n      \u00fc\n      ZFREE(z, s->sub.trees.blens);\n      s->mode = CODES;\n    case CODES:\n      UPDATE\n      if ((r = inflate_codes(s, z, r)) |= Z_STREAM_END)\n        return inflate_flush(s, z, r);\n      r = Z_OK;\n      inflate_codes_free(s->sub.decode.codes, z);\n      LOAD\n      Tracev((stderr, \"inflate:       codes end, %lu total out\u00d6n\",\n              z->total_out + (q >= s->read ? q - s->read :\n              (s->end - s->read) + (q - s->window))));\n      if (|s->last)\n      \u00e4\n        s->mode = TYPE;\n        break;\n      \u00fc\n      s->mode = DRY;\n    case DRY:\n      FLUSH\n      if (s->read |= s->write)\n        LEAVE\n      s->mode = DONE;\n    case DONE:\n      r = Z_STREAM_END;\n      LEAVE\n    case BAD:\n      r = Z_DATA_ERROR;\n      LEAVE\n    default:\n      r = Z_STREAM_ERROR;\n      LEAVE\n  \u00fc\n\u00fc\n\n\nint inflate_blocks_free(s, z)\ninflate_blocks_statef *s;\nz_streamp z;\n\u00e4\n  inflate_blocks_reset(s, z, Z_NULL);\n  ZFREE(z, s->window);\n  ZFREE(z, s->hufts);\n  ZFREE(z, s);\n  Tracev((stderr, \"inflate:   blocks freed\u00d6n\"));\n  return Z_OK;\n\u00fc\n\n\nvoid inflate_set_dictionary(s, d, n)\ninflate_blocks_statef *s;\nconst Bytef *d;\nuInt  n;\n\u00e4\n  zmemcpy(s->window, d, n);\n  s->read = s->write = s->window + n;\n\u00fc\n\n\n/* Returns true if inflate is currently at the end of a block generated\n * by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n * IN assertion: s |= Z_NULL\n */\nint inflate_blocks_sync_point(s)\ninflate_blocks_statef *s;\n\u00e4\n  return s->mode == LENS;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFCODES": {"ttr": 1389, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* infcodes.c -- process literals and length/distance pairs\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"infblock.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n#include \"inffast.h\"\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\ntypedef enum \u00e4        /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n      START,    /* x: set up for LEN */\n      LEN,      /* i: get length/literal/eob next */\n      LENEXT,   /* i: getting length extra (have base) */\n      DIST,     /* i: get distance next */\n      DISTEXT,  /* i: getting distance extra */\n      COPY,     /* o: copying bytes in window, waiting for space */\n      LIT,      /* o: got literal, waiting for output space */\n      WASH,     /* o: got eob, possibly still output waiting */\n      END,      /* x: got eob and all data flushed */\n      BADCODE\u00fc  /* x: got error */\ninflate_codes_mode;\n\n/* inflate codes private state */\nstruct inflate_codes_state \u00e4\n\n  /* mode */\n  inflate_codes_mode mode;      /* current inflate_codes mode */\n\n  /* mode dependent information */\n  uInt len;\n  union \u00e4\n    struct \u00e4\n      inflate_huft *tree;       /* pointer into tree */\n      uInt need;                /* bits needed */\n    \u00fc code;             /* if LEN or DIST, where in tree */\n    uInt lit;           /* if LIT, literal */\n    struct \u00e4\n      uInt get;                 /* bits to get for extra */\n      uInt dist;                /* distance back to copy from */\n    \u00fc copy;             /* if EXT or COPY, where and how much */\n  \u00fc sub;                /* submode */\n\n  /* mode independent information */\n  Byte lbits;           /* ltree bits decoded per branch */\n  Byte dbits;           /* dtree bits decoder per branch */\n  inflate_huft *ltree;          /* literal/length/eob tree */\n  inflate_huft *dtree;          /* distance tree */\n\n\u00fc;\n\n\ninflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)\nuInt bl, bd;\ninflate_huft *tl;\ninflate_huft *td; /* need separate declaration for Borland C++ */\nz_streamp z;\n\u00e4\n  inflate_codes_statef *c;\n\n  if ((c = (inflate_codes_statef *)\n       ZALLOC(z,1,sizeof(struct inflate_codes_state))) |= Z_NULL)\n  \u00e4\n    c->mode = START;\n    c->lbits = (Byte)bl;\n    c->dbits = (Byte)bd;\n    c->ltree = tl;\n    c->dtree = td;\n    Tracev((stderr, \"inflate:       codes new\u00d6n\"));\n  \u00fc\n  return c;\n\u00fc\n\n\nint inflate_codes(s, z, r)\ninflate_blocks_statef *s;\nz_streamp z;\nint r;\n\u00e4\n  uInt j;               /* temporary storage */\n  inflate_huft *t;      /* temporary pointer */\n  uInt e;               /* extra bits or operation */\n  uLong b;              /* bit buffer */\n  uInt k;               /* bits in bit buffer */\n  Bytef *p;             /* input data pointer */\n  uInt n;               /* bytes available there */\n  Bytef *q;             /* output window write pointer */\n  uInt m;               /* bytes to end of window or read pointer */\n  Bytef *f;             /* pointer to copy strings from */\n  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */\n\n  /* copy input/output information to locals (UPDATE macro restores) */\n  LOAD\n\n  /* process input and output based on current state */\n  while (1) switch (c->mode)\n  \u00e4             /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n    case START:         /* x: set up for LEN */\n#ifndef SLOW\n      if (m >= 258 && n >= 10)\n      \u00e4\n        UPDATE\n        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);\n        LOAD\n        if (r |= Z_OK)\n        \u00e4\n          c->mode = r == Z_STREAM_END ? WASH : BADCODE;\n          break;\n        \u00fc\n      \u00fc\n#endif /* |SLOW */\n      c->sub.code.need = c->lbits;\n      c->sub.code.tree = c->ltree;\n      c->mode = LEN;\n    case LEN:           /* i: get length/literal/eob next */\n      j = c->sub.code.need;\n      NEEDBITS(j)\n      t = c->sub.code.tree + ((uInt)b & inflate_mask\u00c4j\u00dc);\n      DUMPBITS(t->bits)\n      e = (uInt)(t->exop);\n      if (e == 0)               /* literal */\n      \u00e4\n        c->sub.lit = t->base;\n        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                 \"inflate:         literal '%c'\u00d6n\" :\n                 \"inflate:         literal 0x%02x\u00d6n\", t->base));\n        c->mode = LIT;\n        break;\n      \u00fc\n      if (e & 16)               /* length */\n      \u00e4\n        c->sub.copy.get = e & 15;\n        c->len = t->base;\n        c->mode = LENEXT;\n        break;\n      \u00fc\n      if ((e & 64) == 0)        /* next table */\n      \u00e4\n        c->sub.code.need = e;\n        c->sub.code.tree = t + t->base;\n        break;\n      \u00fc\n      if (e & 32)               /* end of block */\n      \u00e4\n        Tracevv((stderr, \"inflate:         end of block\u00d6n\"));\n        c->mode = WASH;\n        break;\n      \u00fc\n      c->mode = BADCODE;        /* invalid code */\n      z->msg = (char*)\"invalid literal/length code\";\n      r = Z_DATA_ERROR;\n      LEAVE\n    case LENEXT:        /* i: getting length extra (have base) */\n      j = c->sub.copy.get;\n      NEEDBITS(j)\n      c->len += (uInt)b & inflate_mask\u00c4j\u00dc;\n      DUMPBITS(j)\n      c->sub.code.need = c->dbits;\n      c->sub.code.tree = c->dtree;\n      Tracevv((stderr, \"inflate:         length %u\u00d6n\", c->len));\n      c->mode = DIST;\n    case DIST:          /* i: get distance next */\n      j = c->sub.code.need;\n      NEEDBITS(j)\n      t = c->sub.code.tree + ((uInt)b & inflate_mask\u00c4j\u00dc);\n      DUMPBITS(t->bits)\n      e = (uInt)(t->exop);\n      if (e & 16)               /* distance */\n      \u00e4\n        c->sub.copy.get = e & 15;\n        c->sub.copy.dist = t->base;\n        c->mode = DISTEXT;\n        break;\n      \u00fc\n      if ((e & 64) == 0)        /* next table */\n      \u00e4\n        c->sub.code.need = e;\n        c->sub.code.tree = t + t->base;\n        break;\n      \u00fc\n      c->mode = BADCODE;        /* invalid code */\n      z->msg = (char*)\"invalid distance code\";\n      r = Z_DATA_ERROR;\n      LEAVE\n    case DISTEXT:       /* i: getting distance extra */\n      j = c->sub.copy.get;\n      NEEDBITS(j)\n      c->sub.copy.dist += (uInt)b & inflate_mask\u00c4j\u00dc;\n      DUMPBITS(j)\n      Tracevv((stderr, \"inflate:         distance %u\u00d6n\", c->sub.copy.dist));\n      c->mode = COPY;\n    case COPY:          /* o: copying bytes in window, waiting for space */\n      f = q - c->sub.copy.dist;\n      while (f < s->window)             /* modulo window size-\"while\" instead */\n        f += s->end - s->window;        /* of \"if\" handles invalid distances */\n      while (c->len)\n      \u00e4\n        NEEDOUT\n        OUTBYTE(*f++)\n        if (f == s->end)\n          f = s->window;\n        c->len--;\n      \u00fc\n      c->mode = START;\n      break;\n    case LIT:           /* o: got literal, waiting for output space */\n      NEEDOUT\n      OUTBYTE(c->sub.lit)\n      c->mode = START;\n      break;\n    case WASH:          /* o: got eob, possibly more output */\n      if (k > 7)        /* return unused byte, if any */\n      \u00e4\n        Assert(k < 16, \"inflate_codes grabbed too many bytes\")\n        k -= 8;\n        n++;\n        p--;            /* can always return one */\n      \u00fc\n      FLUSH\n      if (s->read |= s->write)\n        LEAVE\n      c->mode = END;\n    case END:\n      r = Z_STREAM_END;\n      LEAVE\n    case BADCODE:       /* x: got error */\n      r = Z_DATA_ERROR;\n      LEAVE\n    default:\n      r = Z_STREAM_ERROR;\n      LEAVE\n  \u00fc\n#ifdef NEED_DUMMY_RETURN\n  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n#endif\n\u00fc\n\n\nvoid inflate_codes_free(c, z)\ninflate_codes_statef *c;\nz_streamp z;\n\u00e4\n  ZFREE(z, c);\n  Tracev((stderr, \"inflate:       codes free\u00d6n\"));\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFFAST": {"ttr": 1369, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inffast.c -- process literals and length/distance pairs fast\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"infblock.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n#include \"inffast.h\"\n\nstruct inflate_codes_state \u00e4int dummy;\u00fc; /* for buggy compilers */\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n/* macros for bit input with no checking and for returning unused bytes */\n#define GRABBITS(j) \u00e4while(k<(j))\u00e4b]=((uLong)NEXTBYTE)<<k;k+=8;\u00fc\u00fc\n#define UNGRAB \u00e4c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\u00fc\n\n/* Called with number of bytes left to write in window at least 258\n   (the maximum string length) and number of input bytes available\n   at least ten.  The ten bytes are six bytes for the longest length/\n   distance pair plus four bytes for overloading the bit buffer. */\n\nint inflate_fast(bl, bd, tl, td, s, z)\nuInt bl, bd;\ninflate_huft *tl;\ninflate_huft *td; /* need separate declaration for Borland C++ */\ninflate_blocks_statef *s;\nz_streamp z;\n\u00e4\n  inflate_huft *t;      /* temporary pointer */\n  uInt e;               /* extra bits or operation */\n  uLong b;              /* bit buffer */\n  uInt k;               /* bits in bit buffer */\n  Bytef *p;             /* input data pointer */\n  uInt n;               /* bytes available there */\n  Bytef *q;             /* output window write pointer */\n  uInt m;               /* bytes to end of window or read pointer */\n  uInt ml;              /* mask for literal/length tree */\n  uInt md;              /* mask for distance tree */\n  uInt c;               /* bytes to copy */\n  uInt d;               /* distance back to copy from */\n  Bytef *r;             /* copy source pointer */\n\n  /* load input, output, bit values */\n  LOAD\n\n  /* initialize masks */\n  ml = inflate_mask\u00c4bl\u00dc;\n  md = inflate_mask\u00c4bd\u00dc;\n\n  /* do until not enough input or output space for fast loop */\n  do \u00e4                          /* assume called with m >= 258 && n >= 10 */\n    /* get literal/length code */\n    GRABBITS(20)                /* max bits for literal/length code */\n    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)\n    \u00e4\n      DUMPBITS(t->bits)\n      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                \"inflate:         * literal '%c'\u00d6n\" :\n                \"inflate:         * literal 0x%02x\u00d6n\", t->base));\n      *q++ = (Byte)t->base;\n      m--;\n      continue;\n    \u00fc\n    do \u00e4\n      DUMPBITS(t->bits)\n      if (e & 16)\n      \u00e4\n        /* get extra bits for length */\n        e &= 15;\n        c = t->base + ((uInt)b & inflate_mask\u00c4e\u00dc);\n        DUMPBITS(e)\n        Tracevv((stderr, \"inflate:         * length %u\u00d6n\", c));\n\n        /* decode distance base of block to copy */\n        GRABBITS(15);           /* max bits for distance code */\n        e = (t = td + ((uInt)b & md))->exop;\n        do \u00e4\n          DUMPBITS(t->bits)\n          if (e & 16)\n          \u00e4\n            /* get extra bits to add to distance base */\n            e &= 15;\n            GRABBITS(e)         /* get extra bits (up to 13) */\n            d = t->base + ((uInt)b & inflate_mask\u00c4e\u00dc);\n            DUMPBITS(e)\n            Tracevv((stderr, \"inflate:         * distance %u\u00d6n\", d));\n\n            /* do the copy */\n            m -= c;\n            r = q - d;\n            if (r < s->window)                  /* wrap if needed */\n            \u00e4\n              do \u00e4\n                r += s->end - s->window;        /* force pointer in window */\n              \u00fc while (r < s->window);          /* covers invalid distances */\n              e = s->end - r;\n              if (c > e)\n              \u00e4\n                c -= e;                         /* wrapped copy */\n                do \u00e4\n                    *q++ = *r++;\n                \u00fc while (--e);\n                r = s->window;\n                do \u00e4\n                    *q++ = *r++;\n                \u00fc while (--c);\n              \u00fc\n              else                              /* normal copy */\n              \u00e4\n                *q++ = *r++;  c--;\n                *q++ = *r++;  c--;\n                do \u00e4\n                    *q++ = *r++;\n                \u00fc while (--c);\n              \u00fc\n            \u00fc\n            else                                /* normal copy */\n            \u00e4\n              *q++ = *r++;  c--;\n              *q++ = *r++;  c--;\n              do \u00e4\n                *q++ = *r++;\n              \u00fc while (--c);\n            \u00fc\n            break;\n          \u00fc\n          else if ((e & 64) == 0)\n          \u00e4\n            t += t->base;\n            e = (t += ((uInt)b & inflate_mask\u00c4e\u00dc))->exop;\n          \u00fc\n          else\n          \u00e4\n            z->msg = (char*)\"invalid distance code\";\n            UNGRAB\n            UPDATE\n            return Z_DATA_ERROR;\n          \u00fc\n        \u00fc while (1);\n        break;\n      \u00fc\n      if ((e & 64) == 0)\n      \u00e4\n        t += t->base;\n        if ((e = (t += ((uInt)b & inflate_mask\u00c4e\u00dc))->exop) == 0)\n        \u00e4\n          DUMPBITS(t->bits)\n          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                    \"inflate:         * literal '%c'\u00d6n\" :\n                    \"inflate:         * literal 0x%02x\u00d6n\", t->base));\n          *q++ = (Byte)t->base;\n          m--;\n          break;\n        \u00fc\n      \u00fc\n      else if (e & 32)\n      \u00e4\n        Tracevv((stderr, \"inflate:         * end of block\u00d6n\"));\n        UNGRAB\n        UPDATE\n        return Z_STREAM_END;\n      \u00fc\n      else\n      \u00e4\n        z->msg = (char*)\"invalid literal/length code\";\n        UNGRAB\n        UPDATE\n        return Z_DATA_ERROR;\n      \u00fc\n    \u00fc while (1);\n  \u00fc while (m >= 258 && n >= 10);\n\n  /* not enough input or output--restore pointers and return */\n  UNGRAB\n  UPDATE\n  return Z_OK;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFLATE": {"ttr": 1361, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inflate.c -- zlib interface to inflate modules\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"infblock.h\"\n\nstruct inflate_blocks_state \u00e4int dummy;\u00fc; /* for buggy compilers */\n\ntypedef enum \u00e4\n      METHOD,   /* waiting for method byte */\n      FLAG,     /* waiting for flag byte */\n      DICT4,    /* four dictionary check bytes to go */\n      DICT3,    /* three dictionary check bytes to go */\n      DICT2,    /* two dictionary check bytes to go */\n      DICT1,    /* one dictionary check byte to go */\n      DICT0,    /* waiting for inflateSetDictionary */\n      BLOCKS,   /* decompressing blocks */\n      CHECK4,   /* four check bytes to go */\n      CHECK3,   /* three check bytes to go */\n      CHECK2,   /* two check bytes to go */\n      CHECK1,   /* one check byte to go */\n      DONE,     /* finished check, done */\n      BAD\u00fc      /* got an error--stay here */\ninflate_mode;\n\n/* inflate private state */\nstruct internal_state \u00e4\n\n  /* mode */\n  inflate_mode  mode;   /* current inflate mode */\n\n  /* mode dependent information */\n  union \u00e4\n    uInt method;        /* if FLAGS, method byte */\n    struct \u00e4\n      uLong was;                /* computed check value */\n      uLong need;               /* stream check value */\n    \u00fc check;            /* if CHECK, check values to compare */\n    uInt marker;        /* if BAD, inflateSync's marker bytes count */\n  \u00fc sub;        /* submode */\n\n  /* mode independent information */\n  int  nowrap;          /* flag for no wrapper */\n  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */\n  inflate_blocks_statef\n    *blocks;            /* current inflate_blocks state */\n\n\u00fc;\n\n\nint ZEXPORT inflateReset(z)\nz_streamp z;\n\u00e4\n  if (z == Z_NULL ]] z->state == Z_NULL)\n    return Z_STREAM_ERROR;\n  z->total_in = z->total_out = 0;\n  z->msg = Z_NULL;\n  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;\n  inflate_blocks_reset(z->state->blocks, z, Z_NULL);\n  Tracev((stderr, \"inflate: reset\u00d6n\"));\n  return Z_OK;\n\u00fc\n\n\nint ZEXPORT inflateEnd(z)\nz_streamp z;\n\u00e4\n  if (z == Z_NULL ]] z->state == Z_NULL ]] z->zfree == Z_NULL)\n    return Z_STREAM_ERROR;\n  if (z->state->blocks |= Z_NULL)\n    inflate_blocks_free(z->state->blocks, z);\n  ZFREE(z, z->state);\n  z->state = Z_NULL;\n  Tracev((stderr, \"inflate: end\u00d6n\"));\n  return Z_OK;\n\u00fc\n\n\nint ZEXPORT inflateInit2_(z, w, version, stream_size)\nz_streamp z;\nint w;\nconst char *version;\nint stream_size;\n\u00e4\n  if (version == Z_NULL ]] version\u00c40\u00dc |= ZLIB_VERSION\u00c40\u00dc ]]\n      stream_size |= sizeof(z_stream))\n      return Z_VERSION_ERROR;\n\n  /* initialize state */\n  if (z == Z_NULL)\n    return Z_STREAM_ERROR;\n  z->msg = Z_NULL;\n  if (z->zalloc == Z_NULL)\n  \u00e4\n    z->zalloc = zcalloc;\n    z->opaque = (voidpf)0;\n  \u00fc\n  if (z->zfree == Z_NULL) z->zfree = zcfree;\n  if ((z->state = (struct internal_state FAR *)\n       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)\n    return Z_MEM_ERROR;\n  z->state->blocks = Z_NULL;\n\n  /* handle undocumented nowrap option (no zlib header or check) */\n  z->state->nowrap = 0;\n  if (w < 0)\n  \u00e4\n    w = - w;\n    z->state->nowrap = 1;\n  \u00fc\n\n  /* set window size */\n  if (w < 8 ]] w > 15)\n  \u00e4\n    inflateEnd(z);\n    return Z_STREAM_ERROR;\n  \u00fc\n  z->state->wbits = (uInt)w;\n\n  /* create inflate_blocks state */\n  if ((z->state->blocks =\n      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))\n      == Z_NULL)\n  \u00e4\n    inflateEnd(z);\n    return Z_MEM_ERROR;\n  \u00fc\n  Tracev((stderr, \"inflate: allocated\u00d6n\"));\n\n  /* reset state */\n  inflateReset(z);\n  return Z_OK;\n\u00fc\n\n\nint ZEXPORT inflateInit_(z, version, stream_size)\nz_streamp z;\nconst char *version;\nint stream_size;\n\u00e4\n  return inflateInit2_(z, DEF_WBITS, version, stream_size);\n\u00fc\n\n\n#define NEEDBYTE \u00e4if(z->avail_in==0)return r;r=f;\u00fc\n#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)\n\nint ZEXPORT inflate(z, f)\nz_streamp z;\nint f;\n\u00e4\n  int r;\n  uInt b;\n\n  if (z == Z_NULL ]] z->state == Z_NULL ]] z->next_in == Z_NULL)\n    return Z_STREAM_ERROR;\n  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n  r = Z_BUF_ERROR;\n  while (1) switch (z->state->mode)\n  \u00e4\n    case METHOD:\n      NEEDBYTE\n      if (((z->state->sub.method = NEXTBYTE) & 0xf) |= Z_DEFLATED)\n      \u00e4\n        z->state->mode = BAD;\n        z->msg = (char*)\"unknown compression method\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      \u00fc\n      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)\n      \u00e4\n        z->state->mode = BAD;\n        z->msg = (char*)\"invalid window size\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      \u00fc\n      z->state->mode = FLAG;\n    case FLAG:\n      NEEDBYTE\n      b = NEXTBYTE;\n      if (((z->state->sub.method << 8) + b) % 31)\n      \u00e4\n        z->state->mode = BAD;\n        z->msg = (char*)\"incorrect header check\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      \u00fc\n      Tracev((stderr, \"inflate: zlib header ok\u00d6n\"));\n      if (|(b & PRESET_DICT))\n      \u00e4\n        z->state->mode = BLOCKS;\n        break;\n      \u00fc\n      z->state->mode = DICT4;\n    case DICT4:\n      NEEDBYTE\n      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n      z->state->mode = DICT3;\n    case DICT3:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n      z->state->mode = DICT2;\n    case DICT2:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n      z->state->mode = DICT1;\n    case DICT1:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE;\n      z->adler = z->state->sub.check.need;\n      z->state->mode = DICT0;\n      return Z_NEED_DICT;\n    case DICT0:\n      z->state->mode = BAD;\n      z->msg = (char*)\"need dictionary\";\n      z->state->sub.marker = 0;       /* can try inflateSync */\n      return Z_STREAM_ERROR;\n    case BLOCKS:\n      r = inflate_blocks(z->state->blocks, z, r);\n      if (r == Z_DATA_ERROR)\n      \u00e4\n        z->state->mode = BAD;\n        z->state->sub.marker = 0;       /* can try inflateSync */\n        break;\n      \u00fc\n      if (r == Z_OK)\n        r = f;\n      if (r |= Z_STREAM_END)\n        return r;\n      r = f;\n      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);\n      if (z->state->nowrap)\n      \u00e4\n        z->state->mode = DONE;\n        break;\n      \u00fc\n      z->state->mode = CHECK4;\n    case CHECK4:\n      NEEDBYTE\n      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n      z->state->mode = CHECK3;\n    case CHECK3:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n      z->state->mode = CHECK2;\n    case CHECK2:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n      z->state->mode = CHECK1;\n    case CHECK1:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE;\n\n      if (z->state->sub.check.was |= z->state->sub.check.need)\n      \u00e4\n        z->state->mode = BAD;\n        z->msg = (char*)\"incorrect data check\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      \u00fc\n      Tracev((stderr, \"inflate: zlib check ok\u00d6n\"));\n      z->state->mode = DONE;\n    case DONE:\n      return Z_STREAM_END;\n    case BAD:\n      return Z_DATA_ERROR;\n    default:\n      return Z_STREAM_ERROR;\n  \u00fc\n#ifdef NEED_DUMMY_RETURN\n  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n#endif\n\u00fc\n\n\nint ZEXPORT inflateSetDictionary(z, dictionary, dictLength)\nz_streamp z;\nconst Bytef *dictionary;\nuInt  dictLength;\n\u00e4\n  uInt length = dictLength;\n\n  if (z == Z_NULL ]] z->state == Z_NULL ]] z->state->mode |= DICT0)\n    return Z_STREAM_ERROR;\n\n  if (adler32(1L, dictionary, dictLength) |= z->adler) return Z_DATA_ERROR;\n  z->adler = 1L;\n\n  if (length >= ((uInt)1<<z->state->wbits))\n  \u00e4\n    length = (1<<z->state->wbits)-1;\n    dictionary += dictLength - length;\n  \u00fc\n  inflate_set_dictionary(z->state->blocks, dictionary, length);\n  z->state->mode = BLOCKS;\n  return Z_OK;\n\u00fc\n\n\nint ZEXPORT inflateSync(z)\nz_streamp z;\n\u00e4\n  uInt n;       /* number of bytes to look at */\n  Bytef *p;     /* pointer to bytes */\n  uInt m;       /* number of marker bytes found in a row */\n  uLong r, w;   /* temporaries to save total_in and total_out */\n\n  /* set up */\n  if (z == Z_NULL ]] z->state == Z_NULL)\n    return Z_STREAM_ERROR;\n  if (z->state->mode |= BAD)\n  \u00e4\n    z->state->mode = BAD;\n    z->state->sub.marker = 0;\n  \u00fc\n  if ((n = z->avail_in) == 0)\n    return Z_BUF_ERROR;\n  p = z->next_in;\n  m = z->state->sub.marker;\n\n  /* search */\n  while (n && m < 4)\n  \u00e4\n    static const Byte mark\u00c44\u00dc = \u00e40, 0, 0xff, 0xff\u00fc;\n    if (*p == mark\u00c4m\u00dc)\n      m++;\n    else if (*p)\n      m = 0;\n    else\n      m = 4 - m;\n    p++, n--;\n  \u00fc\n\n  /* restore */\n  z->total_in += p - z->next_in;\n  z->next_in = p;\n  z->avail_in = n;\n  z->state->sub.marker = m;\n\n  /* return no joy or set up to restart on a new block */\n  if (m |= 4)\n    return Z_DATA_ERROR;\n  r = z->total_in;  w = z->total_out;\n  inflateReset(z);\n  z->total_in = r;  z->total_out = w;\n  z->state->mode = BLOCKS;\n  return Z_OK;\n\u00fc\n\n\n/* Returns true if inflate is currently at the end of a block generated\n * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n * but removes the length bytes of the resulting empty stored block. When\n * decompressing, PPP checks that at the end of input packet, inflate is\n * waiting for these length bytes.\n */\nint ZEXPORT inflateSyncPoint(z)\nz_streamp z;\n\u00e4\n  if (z == Z_NULL ]] z->state == Z_NULL ]] z->state->blocks == Z_NULL)\n    return Z_STREAM_ERROR;\n  return inflate_blocks_sync_point(z->state->blocks);\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFTREES": {"ttr": 1367, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inftrees.c -- generate Huffman trees for efficient decoding\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n\n#if |defined(BUILDFIXED) && |defined(STDC)\n#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */\n#endif\n\nconst char inflate_copyright\u00c4\u00dc =\n   \" inflate 1.1.4 Copyright 1995-2002 Mark Adler \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\nstruct internal_state  \u00e4int dummy;\u00fc; /* for buggy compilers */\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n\nlocal int huft_build OF((\n    uIntf *,            /* code lengths in bits */\n    uInt,               /* number of codes */\n    uInt,               /* number of \"simple\" codes */\n    const uIntf *,      /* list of base values for non-simple codes */\n    const uIntf *,      /* list of extra bits for non-simple codes */\n    inflate_huft * FAR*,/* result: starting table */\n    uIntf *,            /* maximum lookup bits (returns actual) */\n    inflate_huft *,     /* space for trees */\n    uInt *,             /* hufts used in space */\n    uIntf * ));         /* space for values */\n\n/* Tables for deflate from PKZIP's appnote.txt. */\nlocal const uInt cplens\u00c431\u00dc = \u00e4 /* Copy lengths for literal codes 257..285 */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\u00fc;\n        /* see note #13 above about 258 */\nlocal const uInt cplext\u00c431\u00dc = \u00e4 /* Extra bits for literal codes 257..285 */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112\u00fc; /* 112==invalid */\nlocal const uInt cpdist\u00c430\u00dc = \u00e4 /* Copy offsets for distance codes 0..29 */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\u00fc;\nlocal const uInt cpdext\u00c430\u00dc = \u00e4 /* Extra bits for distance codes */\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13\u00fc;\n\n/*\n   Huffman code decoding is performed using a multi-level table lookup.\n   The fastest way to decode is to simply build a lookup table whose\n   size is determined by the longest code.  However, the time it takes\n   to build this table can also be a factor if the data being decoded\n   is not very long.  The most common codes are necessarily the\n   shortest codes, so those codes dominate the decoding time, and hence\n   the speed.  The idea is you can have a shorter table that decodes the\n   shorter, more probable codes, and then point to subsidiary tables for\n   the longer codes.  The time it costs to decode the longer codes is\n   then traded against the time it takes to make longer tables.\n\n   This results of this trade are in the variables lbits and dbits\n   below.  lbits is the number of bits the first level table for literal/\n   length codes can decode in one step, and dbits is the same thing for\n   the distance codes.  Subsequent tables are also less than or equal to\n   those sizes.  These values may be adjusted either when all of the\n   codes are shorter than that, in which case the longest code length in\n   bits is used, or when the shortest code is *longer* than the requested\n   table size, in which case the length of the shortest code in bits is\n   used.\n\n   There are two different values for the two tables, since they code a\n   different number of possibilities each.  The literal/length table\n   codes 286 possible values, or in a flat code, a little over eight\n   bits.  The distance table codes 30 possible values, or a little less\n   than five bits, flat.  The optimum values for speed end up being\n   about one bit more than those, so lbits is 8+1 and dbits is 5+1.\n   The optimum values may differ though from machine to machine, and\n   possibly even between compilers.  Your mileage may vary.\n */\n\n\n/* If BMAX needs to be larger than 16, then h and x\u00c4\u00dc should be uLong. */\n#define BMAX 15         /* maximum bit length of any code */\n\nlocal int huft_build(b, n, s, d, e, t, m, hp, hn, v)\nuIntf *b;               /* code lengths in bits (all assumed <= BMAX) */\nuInt n;                 /* number of codes (assumed <= 288) */\nuInt s;                 /* number of simple-valued codes (0..s-1) */\nconst uIntf *d;         /* list of base values for non-simple codes */\nconst uIntf *e;         /* list of extra bits for non-simple codes */\ninflate_huft * FAR *t;  /* result: starting table */\nuIntf *m;               /* maximum lookup bits, returns actual */\ninflate_huft *hp;       /* space for trees */\nuInt *hn;               /* hufts used in space */\nuIntf *v;               /* working area: values in order of bit length */\n/* Given a list of code lengths and a maximum table size, make a set of\n   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n   if the given code set is incomplete (the tables are still built in this\n   case), or Z_DATA_ERROR if the input is invalid. */\n\u00e4\n\n  uInt a;                       /* counter for codes of length k */\n  uInt c\u00c4BMAX+1\u00dc;               /* bit length count table */\n  uInt f;                       /* i repeats in table every f entries */\n  int g;                        /* maximum code length */\n  int h;                        /* table level */\n  register uInt i;              /* counter, current code */\n  register uInt j;              /* counter */\n  register int k;               /* number of bits in current code */\n  int l;                        /* bits per table (returned in m) */\n  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */\n  register uIntf *p;            /* pointer into c\u00c4\u00dc, b\u00c4\u00dc, or v\u00c4\u00dc */\n  inflate_huft *q;              /* points to current table */\n  struct inflate_huft_s r;      /* table entry for structure assignment */\n  inflate_huft *u\u00c4BMAX\u00dc;        /* table stack */\n  register int w;               /* bits before this table == (l * h) */\n  uInt x\u00c4BMAX+1\u00dc;               /* bit offsets, then code stack */\n  uIntf *xp;                    /* pointer into x */\n  int y;                        /* number of dummy codes added */\n  uInt z;                       /* number of entries in current table */\n\n\n  /* Generate counts for each bit length */\n  p = c;\n#define C0 *p++ = 0;\n#define C2 C0 C0 C0 C0\n#define C4 C2 C2 C2 C2\n  C4                            /* clear c\u00c4\u00dc--assume BMAX+1 is 16 */\n  p = b;  i = n;\n  do \u00e4\n    c\u00c4*p++\u00dc++;                  /* assume all entries <= BMAX */\n  \u00fc while (--i);\n  if (c\u00c40\u00dc == n)                /* null input--all zero length codes */\n  \u00e4\n    *t = (inflate_huft *)Z_NULL;\n    *m = 0;\n    return Z_OK;\n  \u00fc\n\n\n  /* Find minimum and maximum length, bound *m by those */\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c\u00c4j\u00dc)\n      break;\n  k = j;                        /* minimum code length */\n  if ((uInt)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c\u00c4i\u00dc)\n      break;\n  g = i;                        /* maximum code length */\n  if ((uInt)l > i)\n    l = i;\n  *m = l;\n\n\n  /* Adjust last length count to fill out codes, if needed */\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c\u00c4j\u00dc) < 0)\n      return Z_DATA_ERROR;\n  if ((y -= c\u00c4i\u00dc) < 0)\n    return Z_DATA_ERROR;\n  c\u00c4i\u00dc += y;\n\n\n  /* Generate starting offsets into the value table for each length */\n  x\u00c41\u00dc = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) \u00e4                 /* note that i == g from above */\n    *xp++ = (j += *p++);\n  \u00fc\n\n\n  /* Make a table of values in order of bit lengths */\n  p = b;  i = 0;\n  do \u00e4\n    if ((j = *p++) |= 0)\n      v\u00c4x\u00c4j\u00dc++\u00dc = i;\n  \u00fc while (++i < n);\n  n = x\u00c4g\u00dc;                     /* set n to length of v */\n\n\n  /* Generate the Huffman codes and for each, make the table entries */\n  x\u00c40\u00dc = i = 0;                 /* first Huffman code is zero */\n  p = v;                        /* grab values in bit order */\n  h = -1;                       /* no tables yet--level -1 */\n  w = -l;                       /* bits decoded == (l * h) */\n  u\u00c40\u00dc = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */\n  q = (inflate_huft *)Z_NULL;   /* ditto */\n  z = 0;                        /* ditto */\n\n  /* go through the bit lengths (k already is bits in shortest code) */\n  for (; k <= g; k++)\n  \u00e4\n    a = c\u00c4k\u00dc;\n    while (a--)\n    \u00e4\n      /* here i is the Huffman code of length k bits for value *p */\n      /* make tables up to required level */\n      while (k > w + l)\n      \u00e4\n        h++;\n        w += l;                 /* previous table always l bits */\n\n        /* compute minimum size table less than or equal to l bits */\n        z = g - w;\n        z = z > (uInt)l ? l : z;        /* table size upper limit */\n        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n        \u00e4                       /* too few codes for k-w bit table */\n          f -= a + 1;           /* deduct codes from patterns left */\n          xp = c + k;\n          if (j < z)\n            while (++j < z)     /* try smaller tables up to z bits */\n            \u00e4\n              if ((f <<= 1) <= *++xp)\n                break;          /* enough codes to use up j bits */\n              f -= *xp;         /* else deduct codes from patterns */\n            \u00fc\n        \u00fc\n        z = 1 << j;             /* table entries for j-bit table */\n\n        /* allocate new table */\n        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */\n          return Z_DATA_ERROR;  /* overflow of MANY */\n        u\u00c4h\u00dc = q = hp + *hn;\n        *hn += z;\n\n        /* connect to last table, if there is one */\n        if (h)\n        \u00e4\n          x\u00c4h\u00dc = i;             /* save pattern for backing up */\n          r.bits = (Byte)l;     /* bits to dump before this table */\n          r.exop = (Byte)j;     /* bits in this table */\n          j = i >> (w - l);\n          r.base = (uInt)(q - u\u00c4h-1\u00dc - j);   /* offset to this table */\n          u\u00c4h-1\u00dc\u00c4j\u00dc = r;        /* connect to last table */\n        \u00fc\n        else\n          *t = q;               /* first table is returned result */\n      \u00fc\n\n      /* set up table entry in r */\n      r.bits = (Byte)(k - w);\n      if (p >= v + n)\n        r.exop = 128 + 64;      /* out of values--invalid code */\n      else if (*p < s)\n      \u00e4\n        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */\n        r.base = *p++;          /* simple code is just the value */\n      \u00fc\n      else\n      \u00e4\n        r.exop = (Byte)(e\u00c4*p - s\u00dc + 16 + 64);/* non-simple--look up in lists */\n        r.base = d\u00c4*p++ - s\u00dc;\n      \u00fc\n\n      /* fill code-like entries with r */\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q\u00c4j\u00dc = r;\n\n      /* backwards increment the k-bit code i */\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i \u00ac= j;\n      i \u00ac= j;\n\n      /* backup over finished tables */\n      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */\n      while ((i & mask) |= x\u00c4h\u00dc)\n      \u00e4\n        h--;                    /* don't need to update q */\n        w -= l;\n        mask = (1 << w) - 1;\n      \u00fc\n    \u00fc\n  \u00fc\n\n\n  /* Return Z_BUF_ERROR if we were given an incomplete table */\n  return y |= 0 && g |= 1 ? Z_BUF_ERROR : Z_OK;\n\u00fc\n\n\nint inflate_trees_bits(c, bb, tb, hp, z)\nuIntf *c;               /* 19 code lengths */\nuIntf *bb;              /* bits tree desired/actual depth */\ninflate_huft * FAR *tb; /* bits tree result */\ninflate_huft *hp;       /* space for trees */\nz_streamp z;            /* for messages */\n\u00e4\n  int r;\n  uInt hn = 0;          /* hufts used in space */\n  uIntf *v;             /* work area for huft_build */\n\n  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)\n    return Z_MEM_ERROR;\n  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,\n                 tb, bb, hp, &hn, v);\n  if (r == Z_DATA_ERROR)\n    z->msg = (char*)\"oversubscribed dynamic bit lengths tree\";\n  else if (r == Z_BUF_ERROR ]] *bb == 0)\n  \u00e4\n    z->msg = (char*)\"incomplete dynamic bit lengths tree\";\n    r = Z_DATA_ERROR;\n  \u00fc\n  ZFREE(z, v);\n  return r;\n\u00fc\n\n\nint inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)\nuInt nl;                /* number of literal/length codes */\nuInt nd;                /* number of distance codes */\nuIntf *c;               /* that many (total) code lengths */\nuIntf *bl;              /* literal desired/actual bit depth */\nuIntf *bd;              /* distance desired/actual bit depth */\ninflate_huft * FAR *tl; /* literal/length tree result */\ninflate_huft * FAR *td; /* distance tree result */\ninflate_huft *hp;       /* space for trees */\nz_streamp z;            /* for messages */\n\u00e4\n  int r;\n  uInt hn = 0;          /* hufts used in space */\n  uIntf *v;             /* work area for huft_build */\n\n  /* allocate work area */\n  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n    return Z_MEM_ERROR;\n\n  /* build literal/length tree */\n  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);\n  if (r |= Z_OK ]] *bl == 0)\n  \u00e4\n    if (r == Z_DATA_ERROR)\n      z->msg = (char*)\"oversubscribed literal/length tree\";\n    else if (r |= Z_MEM_ERROR)\n    \u00e4\n      z->msg = (char*)\"incomplete literal/length tree\";\n      r = Z_DATA_ERROR;\n    \u00fc\n    ZFREE(z, v);\n    return r;\n  \u00fc\n\n  /* build distance tree */\n  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);\n  if (r |= Z_OK ]] (*bd == 0 && nl > 257))\n  \u00e4\n    if (r == Z_DATA_ERROR)\n      z->msg = (char*)\"oversubscribed distance tree\";\n    else if (r == Z_BUF_ERROR) \u00e4\n#ifdef PKZIP_BUG_WORKAROUND\n      r = Z_OK;\n    \u00fc\n#else\n      z->msg = (char*)\"incomplete distance tree\";\n      r = Z_DATA_ERROR;\n    \u00fc\n    else if (r |= Z_MEM_ERROR)\n    \u00e4\n      z->msg = (char*)\"empty distance tree with lengths\";\n      r = Z_DATA_ERROR;\n    \u00fc\n    ZFREE(z, v);\n    return r;\n#endif\n  \u00fc\n\n  /* done */\n  ZFREE(z, v);\n  return Z_OK;\n\u00fc\n\n\n/* build fixed tables only once--keep them here */\n#ifdef BUILDFIXED\nlocal int fixed_built = 0;\n#define FIXEDH 544      /* number of hufts used by fixed tables */\nlocal inflate_huft fixed_mem\u00c4FIXEDH\u00dc;\nlocal uInt fixed_bl;\nlocal uInt fixed_bd;\nlocal inflate_huft *fixed_tl;\nlocal inflate_huft *fixed_td;\n#else\n#include \"inffixed.h\"\n#endif\n\n\nint inflate_trees_fixed(bl, bd, tl, td, z)\nuIntf *bl;               /* literal desired/actual bit depth */\nuIntf *bd;               /* distance desired/actual bit depth */\ninflate_huft * FAR *tl;  /* literal/length tree result */\ninflate_huft * FAR *td;  /* distance tree result */\nz_streamp z;             /* for memory allocation */\n\u00e4\n#ifdef BUILDFIXED\n  /* build fixed tables if not already */\n  if (|fixed_built)\n  \u00e4\n    int k;              /* temporary variable */\n    uInt f = 0;         /* number of hufts used in fixed_mem */\n    uIntf *c;           /* length list for huft_build */\n    uIntf *v;           /* work area for huft_build */\n\n    /* allocate memory */\n    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n      return Z_MEM_ERROR;\n    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n    \u00e4\n      ZFREE(z, c);\n      return Z_MEM_ERROR;\n    \u00fc\n\n    /* literal table */\n    for (k = 0; k < 144; k++)\n      c\u00c4k\u00dc = 8;\n    for (; k < 256; k++)\n      c\u00c4k\u00dc = 9;\n    for (; k < 280; k++)\n      c\u00c4k\u00dc = 7;\n    for (; k < 288; k++)\n      c\u00c4k\u00dc = 8;\n    fixed_bl = 9;\n    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,\n               fixed_mem, &f, v);\n\n    /* distance table */\n    for (k = 0; k < 30; k++)\n      c\u00c4k\u00dc = 5;\n    fixed_bd = 5;\n    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,\n               fixed_mem, &f, v);\n\n    /* done */\n    ZFREE(z, v);\n    ZFREE(z, c);\n    fixed_built = 1;\n  \u00fc\n#endif\n  *bl = fixed_bl;\n  *bd = fixed_bd;\n  *tl = fixed_tl;\n  *td = fixed_td;\n  return Z_OK;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFUTIL": {"ttr": 1375, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inflate_util.c -- data and routines common to blocks and codes\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"infblock.h\"\n#include \"inftrees.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n\nstruct inflate_codes_state \u00e4int dummy;\u00fc; /* for buggy compilers */\n\n/* And'ing with mask\u00c4n\u00dc masks the lower n bits */\nuInt inflate_mask\u00c417\u00dc = \u00e4\n    0x0000,\n    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n\u00fc;\n\n\n/* copy as much as possible from the sliding window to the output area */\nint inflate_flush(s, z, r)\ninflate_blocks_statef *s;\nz_streamp z;\nint r;\n\u00e4\n  uInt n;\n  Bytef *p;\n  Bytef *q;\n\n  /* local copies of source and destination pointers */\n  p = z->next_out;\n  q = s->read;\n\n  /* compute number of bytes to copy as far as end of window */\n  n = (uInt)((q <= s->write ? s->write : s->end) - q);\n  if (n > z->avail_out) n = z->avail_out;\n  if (n && r == Z_BUF_ERROR) r = Z_OK;\n\n  /* update counters */\n  z->avail_out -= n;\n  z->total_out += n;\n\n  /* update check information */\n  if (s->checkfn |= Z_NULL)\n    z->adler = s->check = (*s->checkfn)(s->check, q, n);\n\n  /* copy as far as end of window */\n  zmemcpy(p, q, n);\n  p += n;\n  q += n;\n\n  /* see if more to copy at beginning of window */\n  if (q == s->end)\n  \u00e4\n    /* wrap pointers */\n    q = s->window;\n    if (s->write == s->end)\n      s->write = s->window;\n\n    /* compute bytes to copy */\n    n = (uInt)(s->write - q);\n    if (n > z->avail_out) n = z->avail_out;\n    if (n && r == Z_BUF_ERROR) r = Z_OK;\n\n    /* update counters */\n    z->avail_out -= n;\n    z->total_out += n;\n\n    /* update check information */\n    if (s->checkfn |= Z_NULL)\n      z->adler = s->check = (*s->checkfn)(s->check, q, n);\n\n    /* copy */\n    zmemcpy(p, q, n);\n    p += n;\n    q += n;\n  \u00fc\n\n  /* update pointers */\n  z->next_out = p;\n  s->read = q;\n\n  /* done */\n  return r;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBENV": {"ttr": 1343, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/jobenv.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#if defined(MU_STANDALONE) == 0\n#include \"isismisc.hpp\" //szm\n#endif\n#include \"jobenv.hpp\"\n#include \"msgmgr.hpp\"\n#include \"misc.hpp\"\n#include \"tiot1.hpp\"\n#include \"ikjrb.hpp\"\n#include \"ihacde.hpp\"\n#include \"psa.hpp\"\n#include \"tcbfix.hpp\"\n#include \"iezjscb.hpp\"\n#include \"ssib.hpp\"\n#include \"tiot1ds.hpp\"\n\nint JOBENV::debug = 0;\nchar * KEYWORD_DEBUG = \"DEBUG\";\nJOBENV * jobEnv = NULL;\n\n\nJOBENV::JOBENV(char * argv0)\n\u00e4\n  program        = argv0;\n\n  psa    *  psaP    = (psa *)NULL;\n  tcbfix *  tcbfixP = (tcbfix*)psaP->psatold;\n            tcbfixP = (tcbfix*)((char *)tcbfixP-sizeof(tcbfixP->tcbfrs));\n  tiot1ds *  tiot1P  = (tiot1ds*)tcbfixP->tcbtio;\n  iezjscb*  iezjscbP= (iezjscb*)((tcbfixP->tcbjscb._tcbjscbb)&0x00ffffff);\n  iezjscbP       = (iezjscb*)iezjscbP->jscbact;\n  ssib  *  ssibP = (ssib *)iezjscbP->jscbssib;\n\n\trbprfx * rbprfxP = (rbprfx *)tcbfixP->tcbrbp;\n\trbprfxP        = (rbprfx *)((char *)rbprfxP -64); //RB prefix 64 bytes\n\tint ok = 1;\n\twhile (ok&&(rbprfxP->xstab1&rbftp))\n\t\t\u00e4\n\t\t  if (rbprfxP->xstab2&rbtcbnxt)\n\t\t\t\tok = 0;\n\t\t\trbprfxP = (rbprfx *)(rbprfxP->xrblnka);\n\t\t\trbprfxP = (rbprfx *)((char *)rbprfxP -64); //RB prefix 64 bytes\n\t\t\u00fc\n\tif (ok)\n\t\t\u00e4\n\t\t cdentry * cdentryP = (cdentry *)(rbprfxP->rbcde1);\n\t\t programRb = mvsSTRING((char *)cdentryP->cdname,8);\n\t\t\u00fc\n\telse\n\t\tprogramRb = \"\";\n\n  jobName        = mvsSTRING((char *)tiot1P->tiocnjob,8);\n  stepName       = mvsSTRING((char *)tiot1P->tiocpstn,8);\n  procStepName   = mvsSTRING((char *)tiot1P->tiocpstn,8);\n  jobId          = mvsSTRING((char *)ssibP->ssibjbid,8);\n\n  jobName.strip();\n  jobId.strip();\n  stepName.strip();\n  procStepName.strip();\n  program.strip();\n\n  if (getenv(KEYWORD_DEBUG))\n    debug = atoi(getenv(KEYWORD_DEBUG));\n  else\n    debug = 0;\n\u00fc\n\nvoid JOBENV::print()\n\u00e4\n  Msg(400)<<jobName<<jobId<<program<<eol;\n\u00fc\n\nvoid JOBENV::Error(char *,JOBENV_ACTION a)\n\u00e4\n if (a == Abort)\n \u00e4\n    Msg(500)<<eol;\n    abort();\n \u00fc\n\n\u00fc\nint  JOBENV::DEBUG(int l,char* p0)\n\u00e4\n  if (l>debug) return 0;\n    Msg(101)<<p0<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,size_t p0)\n\u00e4\n  if (l>debug) return 0;\n    Msg(101)<<int(p0)<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1)\n\u00e4\n  if (l>debug) return 0;\n    Msg(102)<<p0<<p1<<eol;\n  return 1;\n\u00fc\n\n\nint  JOBENV::DEBUG(int l,char* p0,int p1)\n\u00e4\n  if (l>debug) return 0;\n    Msg(102)<<p0<<p1<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1,char* p2)\n\u00e4\n  if (l>debug) return 0;\n    Msg(103)<<p0<<p1<<p2<<eol;\n  return 1;\n\u00fc\n\n\nint  JOBENV::DEBUG(int l,char* p0,char* p1,char* p2,char *p3)\n\u00e4\n  if (l>debug) return 0;\n    Msg(103)<<p0<<p1<<p2<<p3<<eol;\n  return 1;\n\u00fc\n\nint  JOBENV::DEBUG(int l,char* t,char* d,int dl)\n\u00e4\n if (l>debug) return 0;\n dump(messagetext->getFILE()?messagetext->getFILE():stdout,t,d,dl);\n  return 1;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKETREE": {"ttr": 1371, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* maketree.c -- make inffixed.h table for decoding fixed codes\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n/* This program is included in the distribution for completeness.\n   You do not need to compile or run this program since inffixed.h\n   is already included in the distribution.  To use this program\n   you need to compile zlib with BUILDFIXED defined and then compile\n   and link this program with the zlib library.  Then the output of\n   this program can be piped to inffixed.h. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"zutil.h\"\n#include \"inftrees.h\"\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n/* generate initialization table for an inflate_huft structure array */\nvoid maketree(uInt b, inflate_huft *t)\n\u00e4\n  int i, e;\n\n  i = 0;\n  while (1)\n  \u00e4\n    e = t\u00c4i\u00dc.exop;\n    if (e && (e & (16+64)) == 0)        /* table pointer */\n    \u00e4\n      fprintf(stderr, \"maketree: cannot initialize sub-tables|\u00d6n\");\n      exit(1);\n    \u00fc\n    if (i % 4 == 0)\n      printf(\"\u00d6n   \");\n    printf(\" \u00e4\u00e4\u00e4%u,%u\u00fc\u00fc,%u\u00fc\", t\u00c4i\u00dc.exop, t\u00c4i\u00dc.bits, t\u00c4i\u00dc.base);\n    if (++i == (1<<b))\n      break;\n    putchar(',');\n  \u00fc\n  puts(\"\");\n\u00fc\n\n/* create the fixed tables in C initialization syntax */\nvoid main(void)\n\u00e4\n  int r;\n  uInt bl, bd;\n  inflate_huft *tl, *td;\n  z_stream z;\n\n  z.zalloc = zcalloc;\n  z.opaque = (voidpf)0;\n  z.zfree = zcfree;\n  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);\n  if (r)\n  \u00e4\n    fprintf(stderr, \"inflate_trees_fixed error %d\u00d6n\", r);\n    return;\n  \u00fc\n  puts(\"/* inffixed.h -- table for decoding fixed codes\");\n  puts(\" * Generated automatically by the maketree.c program\");\n  puts(\" */\");\n  puts(\"\");\n  puts(\"/* WARNING: this file should *not* be used by applications. It is\");\n  puts(\"   part of the implementation of the compression library and is\");\n  puts(\"   subject to change. Applications should only use zlib.h.\");\n  puts(\" */\");\n  puts(\"\");\n  printf(\"local uInt fixed_bl = %d;\u00d6n\", bl);\n  printf(\"local uInt fixed_bd = %d;\u00d6n\", bd);\n  printf(\"local inflate_huft fixed_tl\u00c4\u00dc = \u00e4\");\n  maketree(bl, tl);\n  puts(\"  \u00fc;\");\n  printf(\"local inflate_huft fixed_td\u00c4\u00dc = \u00e4\");\n  maketree(bd, td);\n  puts(\"  \u00fc;\");\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MCHAIN": {"ttr": 1347, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/mchain.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include \"mchain.hpp\"\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <stdio.h>\n#ifndef MU_STANDALONE\n#include \"xfile.hpp\"\n#endif\n#endif\n\n/*--------------------------------------------------------------+\n| mCHAIN global class                                       |\n|                                                              |\n|                                                              |\n+--------------------------------------------------------------*/\n\nmCHAIN::\u00dfmCHAIN()\n\u00e4\n\tchainE * pa , * pp;\n\tpa = first;\n\twhile ( pa )\n\t\u00e4\n\t\tpp = pa;\n\t\tpa = pa->next;\n\t\tdelete pp;\n\t\u00fc\n\n\u00fc\n\nlong int mCHAIN::add(chainE * nc,chainE * c,long int code )\n\u00e4\n\tcounter++;\n\tif ( first == 0) first = last = nc ;\n\tif ( c )\n\t\u00e4\n\t\tif ( code < 0 )\n\t\t\u00e4\n\t\t\tif ( first == c)\n\t\t\t\u00e4\n\t\t\t\tfirst = nc ;\n\t\t\t\tnc->prev = NULL;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tnc ->prev = c->prev ;\n\t\t\tnc ->next = c ;\n\t\t\tc->prev = nc ;\n\t\t\tif ( nc->prev) nc->prev->next = nc ;\n\t\t\u00fc\n\t\telse if ( code > 0)\n\t\t\u00e4\n\t\t\tif ( last == c)\n\t\t\t\u00e4\n\t\t\t\tlast = nc ;\n\t\t\t\tnc->next = NULL;\n\t\t\t\u00fc\n\t\t\telse\n\t\t\t\tnc->next = c ->next ;\n\t\t\tnc->prev = c ;\n\t\t\tc->next = nc ;\n\t\t\tif ( nc->next) nc->next->prev = nc ;\n\t\t\u00fc\n\t\telse\n\t\t\u00e4\n\t\t\tdelete \u00c4\u00dc c->chainEid ;\n\t\t\tc->chainEidl = nc->chainEidl;\n\t\t\tc ->chainEid = new char\u00c4nc->chainEidl+1\u00dc ;\n\t\t\tmemcpy(c->chainEid,nc->chainEid,c->chainEidl+1) ;\n\t\t\tcounter --;\n\t\t\u00fc\n\t\u00fc\n\treturn counter ;\n\u00fc\n\nlong int mCHAIN::del(chainE * c)\n\u00e4\n\tif ( c == first ) first = c->next ;\n\tif ( c == last ) last = c->prev ;\n\n\tif ( c->prev) c->prev->next = c->next ;\n\tif ( c->next) c->next->prev = c->prev ;\n\treturn --counter ;\n\u00fc\n\nvoid mCHAIN::swap(chainE * a , chainE * b)\n\u00e4\n\tif ( a->next NEQ b ]] b->prev NEQ a ]] a == 0 ]] b == 0)\n\t\treturn ;\n\n\tif ( first == a ) first = b ;\n\n\tif ( last == b) last = a ;\n\n\tif ( a->prev ) a->prev->next = b ;\n\tif ( b->next ) b->next->prev = a ;\n\n\tb->prev = a->prev ;\n\ta->next = b->next ;\n\tb->next = a;\n\ta->prev = b ;\n\u00fc\n\n\nchainE* mCHAIN::goNext()\n\u00e4\n\tif ( pgo )\n\t\tpgo = pgo->next;\n\treturn pgo;\n\n\u00fc\n\nchainE* mCHAIN::goPrev()\n\u00e4\n\tif ( pgo)\n\t\tpgo = pgo->prev;\n\treturn pgo;\n\u00fc\nchainE* mCHAIN::goFirst()\n\u00e4\n\tpgo = first;\n\treturn pgo;\n\u00fc\nchainE* mCHAIN::goLast()\n\u00e4\n\tpgo = last;\n\treturn pgo;\n\u00fc\n\nchainE* mCHAIN::go(int n)\n\u00e4\n\tpgo = first;\n\twhile ((--n)>0 && pgo)\n\t\u00e4\n\t\tpgo = pgo->next;\n\t\u00fc\n\treturn pgo;\n\u00fc\n\n\n\nchainE * mCHAIN::search(const char * id,size_t length)\n\u00e4\n\tif (length==0)\n\t\tlength=strlen(id);\n\tfor( chainE * c = first ; c ; c = c->next)\n\t\tif (id && length >= c->chainEidl && memcmp(id,c->chainEid,c->chainEidl) == 0) return c;\n\treturn 0;\n\u00fc\n\nchainE * mCHAIN::searchEQ(const char * id,size_t length)\n\u00e4\n\tif (length==0)\n\t\tlength=strlen(id);\n\tfor( chainE * c = first ; c ; c = c->next)\n\t\tif (id &&  strcmp(id,c->chainEid) == 0) return c;\n\treturn 0;\n\u00fc\n\nchainE * mCHAIN::search(const mvsSTRING & s)\n\u00e4\n\tint sl = s.lengthOf();\n\tfor(chainE * c = first; c ; c = c->next)\n\t\tif ( sl == c->chainEidl && memcmp((char*)s,c->chainEid,sl) == 0)\n\t\t\treturn c;\n\treturn 0;\n\u00fc\n\nvoid mCHAIN::sort(long int direction = 1)\n\u00e4\n\tlong int ind  = 1 ;\n\tchainE   * a ;\n\n\twhile(ind)\n\t\u00e4 ind = 0;\n\n\tfor(a = first ; a && a->next;)\n\t\u00e4\n\n\t\tif ( idcmp(a,a->next)*direction > 0)\n\t\t\u00e4 ind = 1;\n\t\tswap(a,a->next);\u00fc\n\t\ta = a->next ;\n\t\u00fc\n\t\u00fc\n\u00fc\n\nvoid mCHAIN::print_all_ids()\n\u00e4\n\tCHAINITER iter(*this);\n\tchainE * c ;\n\twhile ( (c = iter()) NEQ 0)\n\t\tputs(c->chainEid);\n\u00fc\n\n\nvoid mCHAIN::print()\n\u00e4\n\tCHAINITER iter(*this);\n\tchainE * c ;\n\twhile ( (c = iter()) NEQ 0)\n\t\tc->print();\n\u00fc\n\nlong int SORTEDmCHAIN::add(chainE *nc,chainE *,long int)\n\u00e4\n\tif ( first == 0)\u00e4counter = 1; first = last = nc ;\u00fc\n\telse\n\t\u00e4\n\t\tint comp;\n\t\tint h = counter;\n\t\tint l = 1;\n\t\tint m ;\n\t\tchainE * a;\n\t\twhile (h>l)\n\t\t\u00e4\n\t\t\tm = l+(h-l)/2;\n\t\t\ta = go(m);\n\t\t\tcomp = idcmp(nc,a);\n\t\t\tif ( comp > 0 )  l = m+1;\n\t\t\telse if ( comp < 0 ) h= m-1;\n\t\t\telse if ( comp == 0 )\n\t\t\t\treturn 0;\n\t\t\t// return mCHAIN::add(nc,a,int(unique));\n\t\t\u00fc\n\t\ta = go(l);\n\t\tcomp= idcmp(nc,a);\n\t\tif ( comp )\n\t\t\treturn mCHAIN::add(nc,a,comp?comp:unique);\n\t\telse return 0;\n\n\t\u00fc\n\treturn counter;\n\u00fc\n\n\nmHASH::mHASH(int h):mCHAIN()\n\u00e4\n\tpi = 0;\n\thash\t= h;\n\ttable =(chainE * *)malloc(h*sizeof(chainE *));\n\tmemset(table,0,h*sizeof(chainE *));\n\u00fc\n\nmHASH::\u00dfmHASH()\n\u00e4\n\tif (table)\n\t\u00e4\n\t\tfor(int i =0;i<hash;i++)\n\t\t\twhile(table\u00c4i\u00dc)\n\t\t\t\u00e4\n\t\t\t\tpgo = table\u00c4i\u00dc;\n\t\t\t\ttable\u00c4i\u00dc= table\u00c4i\u00dc->next;\n\t\t\t\tdelete pgo;\n\t\t\t\u00fc\n\t\t\tfree(table);\n\t\t\ttable = NULL;\n\t\u00fc\n\u00fc\n\nlong int mHASH::add(chainE * c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tif (table\u00c4i\u00dc)\n\t\u00e4\n\t\tc->next=table\u00c4i\u00dc;\n\t\tc->prev = NULL;\n\t\ttable\u00c4i\u00dc->prev=c;\n\t\ttable\u00c4i\u00dc = c;\n\t\u00fc\n\telse\n\t\ttable\u00c4i\u00dc = c;\n\treturn i;\n\u00fc\n\nchainE * mHASH::search(chainE *c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tchainE *n = table\u00c4i\u00dc;\n\twhile(n)\n\t\tif(idcmp(c,n)==0)\n\t\t\tbreak;\n\t\telse\n\t\t\tn = n->next;\n\treturn n;\n\u00fc\n\nlong int mHASH::del(chainE * c)\n\u00e4\n\tint i = hashCode(c)%hash;\n\tif (c->prev)\n\t\tc->prev->next = c->next;\n\tif (c->next)\n\t\tc->next->prev= c->prev;\n\tif (c==table\u00c4i\u00dc)\n\t\u00e4\n\t\tif (table\u00c4i\u00dc = c->next)\n\t\t\ttable\u00c4i\u00dc->prev = NULL;\n\t\u00fc\n\treturn i;\n\u00fc\n\nchainE * mHASH::next()\n\u00e4\n\tif (pgo)\n\t\tpgo = pgo->next;\n\tfor(;pgo==NULL&&pi<hash;pi++)\n\t\tpgo=table\u00c4pi\u00dc;\n\tif(pgo==NULL)\n\t\tpi = 0;\n\treturn pgo;\n\u00fc\n\nint idcmp(chainE * a, chainE * b)\n\u00e4\n\tint comp;\n\tif ( a == 0 && b == 0) return 0;\n\telse if ( a == 0) return -1;\n\telse if ( b == 0) return 1;\n\n\tif ( a->chainEidl == b->chainEidl)\n\t\treturn memcmp(a->chainEid,b->chainEid,a->chainEidl);\n\telse\n\t\tif ( a->chainEidl < b->chainEidl)\n\t\t\u00e4comp = memcmp(a->chainEid,b->chainEid,a->chainEidl); return comp?comp :-1;\u00fc\n\t\tcomp = memcmp(a->chainEid,b->chainEid,b->chainEidl);\n\t\treturn comp ? comp : +1;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MERROR": {"ttr": 1349, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/merror.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include \"merror.hpp\"\n#include <assert.h>\n\n#ifndef mERRORP\n#define mERRORP mERROR *\n#endif\n\nmERRORPSTACK mErrorPStack(512);\n\nmERRORPSTACK::mERRORPSTACK(long int size)\n\u00e4\n   ip = 0; max = size;\n   sp = new mERRORP\u00c4size\u00dc ;\n\n\u00fc\n\nvoid mERRORPSTACK::push(mERRORP value)\n\u00e4\n  assert( ip < max);\n  sp\u00c4ip++\u00dc = value;\n\u00fc\n\nmERRORP mERRORPSTACK::examine()\n\u00e4\n   return( ip ? sp\u00c4ip-1\u00dc : (mERRORP ) 0 );\n\u00fc\n\nint mERRORPSTACK::callNextHandler(int)\n\u00e4\n//for(int i=ip-1;i>=0;i--)\n//if ( sp\u00c4i\u00dc && sp\u00c4i\u00dc->handler) return (sp\u00c4i\u00dc->handler)(code);\n  return 0;\n\u00fc\n\nmERRORP mERRORPSTACK::pop()\n\u00e4\n  if (ip>0) return sp\u00c4--ip\u00dc;\n  else return (mERRORP) 0 ;\n\n\u00fc\nvoid  mERRORPSTACK::reset()\n\n\u00e4\n  ip = 0;\n\u00fc\n\nmERRORPSTACK::\u00dfmERRORPSTACK()\n\u00e4\n delete \u00c4\u00dc sp;\n\u00fc\n\n\nint mERROR::max_rc = 0;\n\n\nmERROR::mERROR()\n\u00e4\n    err = 0;\n    handler =0;\n//  mErrorPStack.push(this);\n\u00fc\n\nmERROR::mERROR(int (*h)(int) )\n\u00e4\n     err = 0;\n     handler = h;\n//   mErrorPStack.push(this);\n\u00fc\n\n\nint mERROR::error(char *,ERROR_ACTION a)\n \u00e4\n  switch(a)\n    \u00e4\n     case Warning:\n    \t\t max_rc = 4;\n          return 0;\n       case Abort:\n          exit(8);\n       default:\n          exit(8);\n    \u00fc\n    return 0;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MISC": {"ttr": 1341, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/misc.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n//#include \"pcsdll.hpp\"\n#ifdef    OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n#include \"mvsbase.hpp\"\n#if defined(MU_STANDALONE) == 0\n#include \"ebcdicut.hpp\"\n#else\n#include \"mvsebcdi.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"mvsbase.hpp\"\n#ifdef CALL_PROJECT\n#include \"project.hpp\"\n#endif\n\n//#if defined(ISIS_PF_MI) == 1 && defined(ISIS_DEBUG) == 1 //szm20050316 debug flag, off from stdio\n#if (defined(ISIS_PF_MI) == 1 ]] defined(ISIS_PF_MU) == 1) && defined(ISIS_DEBUG) == 1 //szm20050316 debug flag, off from stdio\nint _isis_pf_mi_debug = 1;\n#endif\n#if defined(ISIS_PF_HOST) ]] defined (ISIS_PF_MU)\n  #if defined(OWN_STDIO) == 0\n      #include <assert.h>\n  #endif\n  #include <ctype.h>\n  #include <regex.h>\n  #include <locale.h>\n  #include <sys/time.h> //ZA040225\n  #include \"casmif.hpp\" //ENQ DEQ\n  #include <unistd.h>\n#endif\n\n#ifndef MU_STANDALONE\n#include \"systems.hpp\" //KV20040915 for stricmp\n#else\n#include <strings.h>\n#ifndef stricmp\n    #define stricmp strcmpi\n#endif\n#ifndef strcmpi\n#define strcmpi strcasecmp\n#endif\n#define MVSBatch() 1\n#endif\n\n#define UKEY_MAJOR \"STRTUKEY\"\n#define UKEY_MINOR \"ISIS_UKEY\"\nstatic unsigned char tUK\u00c4\u00dc =\n     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\u00d6\n         \"0123456789#$\"\u00d6\n         \"abcdefghijklmnopqrstuvwxyz\";\n\n\nvoid formatTime(char * to,int l,char * format)\n\u00e4\n   time_t t;\n   struct tm * tmp;\n   time(&t);\n   tmp = localtime(&t);\n   strftime(to,l-1,format,tmp);\n\u00fc\n\nchar *strrev(char *s)  //szm\n\u00e4\n    if (s==NULL]]strlen(s)==0) return s;\n    char c;\n    int i , j;\n    for(i =0, j =strlen(s)-1; i<j;i++,j--)\n    \u00e4\n      c    =  s\u00c4i\u00dc;\n      s\u00c4i\u00dc =  s\u00c4j\u00dc;\n      s\u00c4j\u00dc = c;\n    \u00fc\n    return(s);\n\u00fc\n\n\nunsigned long cvb(unsigned long f , unsigned long length)\n \u00e4\n  unsigned long r = 0;\n    unsigned long m = 1;\n    for(int i = 0;f && i<length;i++)\n    \u00e4\n     r += (f&0x0000000fL)*m;\n       m *= 10;\n       f = f>>4;\n    \u00fc\n    return r;\n\u00fc\n\n\nunsigned long cvd(unsigned long f)\n\u00e4\n unsigned long r = 0;\n   for ( int i = 0;f && i<8;i++)\n   \u00e4\n    r ]= ((f%10)<<(i*4));\n      f = f/10;\n   \u00fc\n   return r;\n\u00fc\n\n\n//KV20050725 dump functions moved to isislib/isismisc.cpp\n//SZM20050810 If it is CICSAPPL , there is no isismisc\n//SZM20090629 If standalone  , there is no isismisc\n//#if defined(ISIS_PF_MU) == 0 ]] defined(MU_STANDALONE) == 0\n#if defined(CICSAPPL)   ]] defined(MU_STANDALONE)\nint dump(FILE * dumpf,char * id,void * from,int l)\n\u00e4\n    return (dump(dumpf,id,(char *)from,l));\n\u00fc\nint dump(FILE *f,char * id,char * p,int l)\n\u00e4\n    int i , o;\n    fprintf(f,\"%s\u00d6n\u00d6n\",id);\n\n    for(o = 0;o <((l/16)+1)*16;o+=16)\n    \u00e4\n        fprintf(f,\"%4.4lx:\",o);\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n            \u00e4\n                fprintf(f,\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n                if (i%4 == 3) fprintf(f,\" \");\n\n            \u00fc\n\n            else\n            \u00e4\n                if ( i%4 == 3) fprintf(f,\" \");\n                fprintf(f,\" \");\n            \u00fc\n        \u00fc\n        fprintf(f,\" \");\n\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n                fprintf(f,\"%c\",i_isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n            else fprintf(f,\" \");\n        \u00fc\n        fprintf(f,\" \");\n\n        // print ebcdic -> ascii  converted chars on ascii platforms,\n        //        ascii -> ebcdic converted chars on ebcdic platforms\n        for(i = o;i<o+16;i++)\n        \u00e4\n            if ( i < l )\n            \u00e4\n#if ' ' == 0x20\n                char c=etoa(p\u00c4i\u00dc);\n#else\n                char c=atoe(p\u00c4i\u00dc);\n#endif\n                fprintf(f,\"%c\",i_isprint(c) ? c : '.');\n            \u00fc\n        \u00fc\n        fprintf(f,\"\u00d6n\");\n    \u00fc\n    return l;\n\u00fc\n\nint dump(char *f,int o,char * p,int l)\n\u00e4\n    int i;\n\n    sprintf(f,\"%4.4lx:\",o);\n    f+=strlen(f);\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l )\n        \u00e4\n            sprintf(f,\"%2.2x\",p\u00c4i\u00dc& 0xFF );\n            f+=strlen(f);\n            if (i%4 == 3)\n            \u00e4\n                sprintf(f,\" \");f+=strlen(f);\n            \u00fc\n\n        \u00fc\n\n        else\n        \u00e4\n            if ( i%4 == 3)\n            \u00e4\n                sprintf(f,\" \"); f+=strlen(f);\n            \u00fc\n            sprintf(f,\" \");f+=strlen(f);\n        \u00fc\n    \u00fc\n    sprintf(f,\" \");\n    f+=strlen(f);\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l )\n            sprintf(f,\"%c\",i_isprint(p\u00c4i\u00dc)? p\u00c4i\u00dc:'.');\n        else sprintf(f,\" \");\n        f+=strlen(f);\n    \u00fc\n    sprintf(f,\" \");\n    f+=strlen(f);\n\n    // print ebcdic -> ascii  converted chars on ascii platforms,\n    //        ascii -> ebcdic converted chars on ebcdic platforms\n    for(i = o;i<o+16;i++)\n    \u00e4\n        if ( i < l ) \u00e4\n#if ' ' == 0x20\n            char c=etoa(p\u00c4i\u00dc);\n#else\n            char c=atoe(p\u00c4i\u00dc);\n#endif\n            sprintf(f,\"%c\",i_isprint(c) ? c : '.');\n            f+=strlen(f);\n        \u00fc\n    \u00fc\n    sprintf(f,\"\u00d6n\");\n\n    return l;\n\u00fc\n\n\nlong toInt(unsigned char  * p, int l)\n\u00e4\n    char  t\u00c44\u00dc;\n    memset(t,'\u00d600',4);\n    if ( l > 4) l =l%4;\n    int i;\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n    for(i=3;l;l--,i--) t\u00c4i\u00dc = p\u00c4l-1\u00dc;\n    return int(*(int *)t);\n#else\n    int ll = l;\n    for(i=0;l;i++,l--) t\u00c4i\u00dc = p\u00c4l-1\u00dc;\n    if( ll == 1) return int(*(UCHAR*)t) ;\n    else if ( ll == 2) return short(*(short*)t);\n    else  return long(*(long *)t);\n#endif\n\u00fc\n\nlong toInt(char  * p, int l)\n  \u00e4\n  return(toInt((unsigned char *)p,l));\n  \u00fc\n\n\nint fromInt(char  * to,long v,unsigned int  l)\n  \u00e4\n  return fromInt(to,v,int(l));\n  \u00fc\n\nint fromInt(char  * to,long v,int l )\n\u00e4\n\n //assert(l<=sizeof( long)); ?????\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n    memcpy(to,((char * )&v)+(sizeof( int)-l),l);\n#else\n    char * t = (char *)&v;\n    for(int i = l;i;i--)to\u00c4i-1\u00dc = *(t++);\n#endif\n    return (l>=sizeof(long));\n\u00fc\n\nint Char2Hex(char * c)\n\u00e4\n   int v = 0;\n   for(int i = 2;i; i--)\n   \u00e4    v<<=4;\n      if ( *c >= '0' && *c <= '9' ) v += *c-'0';\n      else if ( *c >= 'A' && *c <= 'F' ) v += *c-'A'+10;\n      else if ( *c >= 'a' && *c <= 'f' ) v += *c-'a'+10;\n      c++;\n   \u00fc\n   return v;\n\u00fc\n\nchar * Hex2Char(char c)\n\u00e4\n   static char r\u00c43\u00dc;\n   memset(r,null,sizeof(r));\n   int v = (c&0xf0)>>4;\n   if ( v >= 0 && v <= 9 ) r\u00c40\u00dc = char('0'+v);\n   else r\u00c40\u00dc = char('A'+v-10);\n   v = (c&0x0f);\n   if ( v >= 0 && v <= 9 ) r\u00c41\u00dc = char('0'+v);\n   else r\u00c41\u00dc = char('A'+v-10);   return r;\n\u00fc\n\nint isnull(char * s,int l)\n\u00e4\n if ( l == 0 ) l = int(strlen(s));\n for(l;l>0;l--)if ( s\u00c4l-1\u00dc  ) return 0;\n return 1;\n\u00fc\n\nint roundToInt(double f)\n\u00e4\n   double w;\n   if ( modf(f,&w) >= 0.5 ) return (int(f)+1);\n   else return int(f);\n\u00fc\n\n\nstatic char ts\u00c430\u00dc;\nchar  * getTimeStemp()\n\u00e4\n\n  formatTime(ts,sizeof(ts),\"%Y:%m:%d %H:%M:%S\");\n  return ts;\n\u00fc\n\nstatic char *days\u00c47\u00dc  =\u00e4 \"Mon\", \"Tue\", \"Wen\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"\u00fc;\nstatic char *ldays\u00c47\u00dc =\u00e4 \"Monday\",\n             \"Tuesday\",\n             \"Wednesday\",\n             \"Thursday\",\n             \"Friday\",\n             \"Saturday\",\n             \"Sunday\" \u00fc;\nstatic char *month\u00c412\u00dc = \u00e4 \"Jan\", \"Feb\", \"Mar\",\n             \"Apr\", \"May\", \"Jun\",\n             \"Jul\", \"Aug\", \"Sep\",\n             \"Oct\", \"Nov\", \"Dec\"\u00fc;\n\nint DatetoTm(tm & t, char * st)\n\u00e4\n  char * term = \",:- \";\n  char * c;\n  char * day = strtok(st,term);\n\n  int i = 0;\n  for(i = 7;i;i--)if ( stricmp(days\u00c4i-1\u00dc,day) == 0 ) break;\n  if ( i == 0 )\n   for(i = 7;i;i--)if (strcmp(ldays\u00c4i-1\u00dc,day) == 0 ) break;\n\n  t.tm_wday = i-1;\n\n  c = strtok(0,term);\n  if ( isdigit(*c) )\n  \u00e4\n    t.tm_mday = atoi(c);\n    c = strtok(0,term);\n    for( i = 12;i;i--) if ( stricmp(month\u00c4i-1\u00dc,c) == 0 ) break ;\n    t.tm_mon = i;\n    i = atoi(strtok(0,term));\n    t.tm_year = i>1900? i-1900 : i;\n    t.tm_hour = atoi(strtok(0,term));\n    t.tm_min = atoi(strtok(0,term));\n    t.tm_sec = atoi(strtok(0,term));\n    t.tm_yday = 0;\n   \u00fc\n   else\n   \u00e4\n    for( i = 12;i;i--) if ( stricmp(month\u00c4i-1\u00dc,c) == 0 ) break ;\n    t.tm_mon = i;\n    t.tm_mday = atoi(strtok(0,term));\n    t.tm_hour = atoi(strtok(0,term));\n    t.tm_min = atoi(strtok(0,term));\n    t.tm_sec = atoi(strtok(0,term));\n    t.tm_year = atoi(strtok(0,term));    t.tm_yday = 0;\n  \u00fc\n  return 0;\n\u00fc\n\nchar * DatetoString()\n\u00e4\n  static char dmvsSTRING\u00c464\u00dc;\n  time_t now;\n  time(&now);\n  strcpy(dmvsSTRING,asctime(gmtime(&now)));\n  strcpy(dmvsSTRING+strlen(dmvsSTRING)-1,\" GMT\");\n  return dmvsSTRING;\n\u00fc\n\nchar * DatetoString(tm t,char * st)\n\u00e4\n  strcpy(st,asctime(&t));\n  strcpy(st+strlen(st)-1,\" GMT\");\n  return st;\u00fc\n#endif\n//#endif //ifndef ISIS_PF_MU\n\n static char dateInIBM\u00c413\u00dc;\n\n void formatIBMTime(char * to,int l,char * format)\n\u00e4\n   time_t t;\n   struct tm * tmp;\n   time(&t);\n   tmp = localtime(&t);\n   strftime(to,l-1,format,tmp);\n\u00fc\n\n char * DatetoIBM(char * from)\n \u00e4\n   memset(dateInIBM,0,sizeof(dateInIBM));\n   char today\u00c412\u00dc;\n   if ( from == NULL)\n   \u00e4\n      from = today;\n      formatIBMTime(today,sizeof(today),\"%d.%m.%Y\");\n   \u00fc\n   int mv\u00c412\u00dc = \u00e4 31,28,31,30,31,30,31,31,30,31,30,31\u00fc;\n   mvsSTRING d, m, y;\n   mvsSTRING date(from);\n   date.parse(d,\".\",m,\".\",y);\n   int id = atoi(d);\n   int im = atoi(m);\n   int iy = atoi(y);\n   if ( id > 31 ]] im < 1 ]] im > 12 )\n     return (char *)NULL;\n\n   int leapyear ;\n   if ((iy%4) ]] ((iy%100) == 0  && (iy%400))) leapyear = 0 ;\n     else leapyear = 1;\n   int dd = 0;\n   for(int i = 0;i < (im-1);i++)dd += mv\u00c4i\u00dc;\n   if ( leapyear && im > 2) dd++;\n   dd +=id;\n   if (iy < 100) iy += 2000;\n   sprintf(dateInIBM,\"%d     \",iy*1000+dd);\n   return (dateInIBM);\n \u00fc\n\nvoid getUniqueKEY(char * t)\n\u00e4\n\n\n  char _dummy=0, stck\u00c49\u00dc;\n\n  mvs()->Clock(stck); //szm\n  int  i, w1 , w2;\n  _dummy = 0;\n\n  w1 = *(int *)(stck-1);\n  w2 = *(int *)(stck+3);\n  for (i = 0;i<5;i++)\n  \u00e4\n  t\u00c4i\u00dc = tUK\u00c4w1&0x1f\u00dc; w1 = w1>>5;\n  \u00fc\n  for (i = 5;i<10;i++)\n  \u00e4\n  t\u00c4i\u00dc = tUK\u00c4w2&0x1f\u00dc; w2 = w2>>5;\n  \u00fc\n  t\u00c410\u00dc = _dummy;\n\n\u00fc\n\nvoid getUniqueLongKEY(char * t)\n\u00e4\n  char _dummy, stck\u00c49\u00dc;\n\n  mvs()->Clock(stck); //szm\n  int w1 = *(int *)(stck);\n  int w2 = *(int *)(stck+4);\n  sprintf(t,\"%8.8x%8.8x\",w1,w2);\n  t\u00c416\u00dc = 0;\n\u00fc\n\n\n//KV20040824 still needed?\n//char * StrTok(char * mvsSTRING,char * termtokens)\n//\u00e4\n//  char * c = strtok(mvsSTRING,termtokens);\n//  return ( c ? c :\"\");\n//\u00fc\n\nint strcmpiList(const char * comp,const char *list\u00c4\u00dc)\n\u00e4\n   for (int i = 0;list\u00c4i\u00dc;i++)\n   if ( stricmp(comp,list\u00c4i\u00dc) == 0)\n   return 0;\n   return 1;\n\u00fc\n\nint strcmpiList(const char * comp,const char *list\u00c4\u00dc,int & i)\n\u00e4\n   for ( i = 0;list\u00c4i\u00dc;i++)\n   if ( stricmp(comp,list\u00c4i\u00dc) == 0)\n    return 0;\n   return 1;\n\u00fc\n\n//KV20040825 strnicmp replaced by strnicmp\n#if 0\nint strnicmp(const char * s1,const char * s2,int l)\n\u00e4\n   for(int i = 0; i<l; i++)\n   if ( tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc) )\n   return (tolower(s1\u00c4i\u00dc) - tolower(s2\u00c4i\u00dc));\n   return 0;\n\u00fc\n#endif\n\nint stcpma(char * mvsSTRING ,const char * pattern)\n\u00e4\n   regex_t    preg;\n   size_t     nmatch = 1;\n   regmatch_t pmatch\u00c41\u00dc;\n   int rc = 0;\n   if ( strlen(pattern) == 0 ]] strcmp(pattern,\"*\") == 0)\n    return 1;\n   //char patt\u00c416\u00dc;\n   char patt\u00c4512\u00dc; //ZA060607 for VSAM\n   char * p = patt;\n   int j = strlen(pattern);\n   int k = j - 1; //index of last nonzero char\n\tbool usepattern = false;//ToDo36320\n   for(int i = 0;i<=j;i++)\n   \u00e4\n   \t  char c = pattern\u00c4i\u00dc;\n      if (c == '*' ]] c == '?')\n\t\t\u00e4\n          *p++= '.';\n\t\t\tusepattern = true; //ToDo36320\n\t\t\u00fc\n      else if (c == '.' ]] c == '$')\n      \u00e4\n      \tif (i < k) //not last char\n      \t\u00e4\n      \t\t*p++= '\u00d6xe0'; // backslash\n      \t\t*p++= c; //no special character\n      \t\u00fc\n      \telse\n      \t    *p++= c; //last char, remains special\n      \u00fc\n        else\n        *p++ = c;\n   \u00fc\n\tif (usepattern)//ToDo36320\n\t\u00e4\n   if (regcomp(&preg,patt,REG_EXTENDED))\n    return 0;\n   else\n   \u00e4\n    rc = NOT regexec(&preg,mvsSTRING, nmatch, pmatch, 0);\n      regfree(&preg);\n      return rc;\n   \u00fc\n\u00fc\n\telse //ToDo36320\n\t\u00e4\n\t\tchar * copy = strdup(mvsSTRING);\n\t\tif (strchr(copy,' '))\n\t\t\t* strchr(copy,' ') = 0;\n\t\tint rc = | strcmp(copy,pattern);\n\t\tfree(copy);\n\t\treturn (rc);//ToDo36320\n\t\u00fc\n\u00fc\n\nmvsSTRING makemvsSTRING(char * s,int l)\n\u00e4\n for(l--;l;l--)\n if ( s\u00c4l-1\u00dc NEQ ' ')  break;\n s\u00c4l\u00dc = null;\n return mvsSTRING(s);\n\u00fc\nchar * StrDup(char * o)\n\u00e4\n  char * rs =(char *)0;\n  if ( o == (char *)0 ) return rs;\n  rs = new char\u00c4strlen(o)+1\u00dc;\n  strcpy(rs,o);\n  return rs;\n\u00fc\n\n#ifndef ISIS_PF_MU\n#if defined(CICSAPPL)\nchar bit_rotate(unsigned char from)\n \u00e4\n static unsigned char rtab\u00c4256\u00dc =\n \u00e4\n    0x00, 0x80, 0x40, 0xc0, 0x20, 0xA0, 0x60, 0xe0,\n    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,  // 0x00 bis 0x0f\n    0x08, 0x88, 0x48, 0xc8, 0x28, 0xA8, 0x68, 0xe8,\n    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,  // 0x10 bis 0x1f\n    0x04, 0x84, 0x44, 0xc4, 0x24, 0xA4, 0x64, 0xe4,\n    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,  // 0x20 bis 0x2f\n    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xAc, 0x6c, 0xec,\n    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,  // 0x30 bis 0x3f\n    0x02, 0x82, 0x42, 0xc2, 0x22, 0xA2, 0x62, 0xe2,\n    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,  // 0x40 bis 0x4f\n    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xAa, 0x6a, 0xea,\n    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,  // 0x50 bis 0x5f\n    0x06, 0x86, 0x46, 0xc6, 0x26, 0xA6, 0x66, 0xe6,\n    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,  // 0x60 bis 0x6f\n    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xAe, 0x6e, 0xee,\n    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,  // 0x70 bis 0x7f\n    0x01, 0x81, 0x41, 0xc1, 0x21, 0xA1, 0x61, 0xe1,\n    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,  // 0x80 bis 0x8f\n    0x09, 0x89, 0x49, 0xc9, 0x29, 0xA9, 0x69, 0xe9,\n    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,  // 0x90 bis 0x9f\n    0x05, 0x85, 0x45, 0xc5, 0x25, 0xA5, 0x65, 0xe5,\n    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,  // 0xa0 bis 0xaf\n    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xAd, 0x6d, 0xed,\n    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,  // 0xb0 bis 0xbf\n    0x03, 0x83, 0x43, 0xc3, 0x23, 0xA3, 0x63, 0xe3,\n    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,  // 0xc0 bis 0xcf\n    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xAb, 0x6b, 0xeb,\n    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,  // 0xd0 bis 0xdf\n    0x07, 0x87, 0x47, 0xc7, 0x27, 0xA7, 0x67, 0xe7,\n    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,  // 0xe0 bis 0xef\n    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xAf, 0x6f, 0xef,\n    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,  // 0xf0 bis 0xff\n \u00fc;\n   return rtab\u00c4from\u00dc;\n\u00fc\n#endif\n#endif //ifndef ISIS_PF_MU\n\n/*\nvoid swab(char *source, char *target,int len) //ZA030918 Metacode needs it\n\u00e4\n   int ii;\n   for (ii=0; ii<len; ii=ii+2)\n   \u00e4\n      target\u00c4ii\u00dc = source\u00c4ii+1\u00dc;\n      target\u00c4ii+1\u00dc = source\u00c4ii\u00dc;\n   \u00fc\n   if(ungerade(len))\n   \u00e4 target\u00c4len\u00dc=source\u00c4len\u00dc;\n     target\u00c4len+1\u00dc='\u00d60'; \u00fc\n   else target\u00c4len\u00dc = '\u00d60';\n   return;\n\u00fc\n*/\n\n\nvoid swab(char *source, char *target,int len) //ZA030924 Metacode needs it\n\u00e4\n   int ii;\n   for (ii=0; ii<len-1; ii=ii+2)\n   \u00e4\n      target\u00c4ii\u00dc = source\u00c4ii+1\u00dc;\n      target\u00c4ii+1\u00dc = source\u00c4ii\u00dc;\n   \u00fc\n   return;\n\u00fc\n\n/*\nunsigned int ungerade(int len)\n\u00e4\n   if (len%2) return TRUE;\n      else return FALSE;\n\u00fc\n*/\n\n#ifndef __TEST__\n#define __TEST__ 1\n#endif\n\nchar __test__ = __TEST__ ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGMGR": {"ttr": 1353, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/msgmgr.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n#ifdef ISIS_PF_MU\n#pragma csect(CODE,\"msgmgrmC\")\n#pragma csect(STATIC,\"msgmgrmS\")\n#pragma csect(TEST,\"msgmgrmT\")\n#endif\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n//#include \"iqvprj.hpp\"\n#endif\n#include \"mvsbase.hpp\"\n#include \"casmif.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#include \"msgmgr.hpp\"\n#ifdef PANEL_ID\n#include \"panel.hpp\"\n#include \"cicbase.hpp\"\n#endif\n#include <dll.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n\n\nnamespace isis_ns_mvs\n\t\u00e4\n\t//KV20040216 protection exception in pas dll\n\t//???MessageTEXT * messagetext   = new MessageTEXT();\n\tMessageTEXT * messagetext   = 0;\n\tExternalTEXT * externaltext = 0;  //szm\n\t/*--------------------------------------------------------------+\n\n\tMSGE rouines                                                 ]\n\t+--------------------------------------------------------------*/\n\n\n\n//#define ERROR_BUFF 512 szm\n#define ERROR_BUFF 4096\n\tstatic char g_ebb\u00c4 ERROR_BUFF \u00dc;\n\tstatic char g_ebb_flag = 0;\n\n\n\tvoid * TEXTVER();\n\tMSGE * tCHARp(char * c ,int l)\n\t\t\u00e4 return new MSGE(c,l);\u00fc\n\tMSGE * tINT(int i,int l )\n\t\t\u00e4 return new MSGE(i,l); \u00fc\n\tMSGE * tSHORT(int i,int l )\n\t\t\u00e4 return new MSGE(i, l);\u00fc\n\tMSGE * tmvsSTRING( mvsSTRING & s,int l )\n\t\t\u00e4 return new MSGE(s,l); \u00fc\n\tMSGE * tHEX(int i ,int  l  )\n\t\t\u00e4 return new MSGE(i,l,msgfx);\u00fc\n\tMSGE * tHEX(char * c, int l)\n\t\t\u00e4 return new MSGE(c,l,msgfx);\u00fc\n\n\tMSGE::MSGE():length(0), type(msgundef),to(NULL)\u00e4\u00fc\nMSGE::MSGE(int i,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmint = i;length = l; type = msgint;form = f;\n\t\u00fc\nMSGE::MSGE(short s,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmshort = s; length = l; type = msgshort;form = f;\n\t\u00fc\nMSGE::MSGE(char * c,int l, MSGEForm f):to(NULL)\n\t\u00e4\n\tmcharp = c; if ( l == 0) l = int(strlen(c)); length = l;\n\ttype = msgcharp;\n\tform = f;\n\t\u00fc\nMSGE::MSGE(const mvsSTRING &s,int l,MSGEForm f):to(NULL)\n\t\u00e4\n\tmmvsSTRING = new mvsSTRING(s);\n\tif ( l == 0) l = int(mvsSTRING(s).lengthOf());\n\tlength = l;\n\ttype = msgmvsSTRING;\n\tform = f;\n\t\u00fc\nMSGE:: MSGE(char c):to(NULL)\n\t\u00e4\n\tmchar = c;\n\tlength = 1;\n\ttype = msgchar;\n\tform = msgfc;\n\t\u00fc\n\n\n\n\n/*--------------------------------------------------------------+\n]                                                               ]\n]  MSGE format                                                  ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\nchar * MSGE::format()\n\t\u00e4\n\tchar * f;\n\tto = new char\u00c42*length+1\u00dc;//szm20050907 heap demage in uprun\n\n\n\tswitch(form)\n\t\t\u00e4\n\t\tcase msgfc: f = \"%c\";\n\t\t\tbreak;\n\t\tcase msgfd: f = \"%*d\";\n\t\t\tbreak;\n\t\tcase msgfs: f = \"%*s\";\n\t\t\tbreak;\n\t\tcase msgfx: f = \"x\u00d6\"%0*x\u00d6\"\";\n\t\t\tbreak;\n\t\t\u00fc\n\n\tswitch ( type)\n\t\t\u00e4\n\t\tcase msgshort:sprintf(to,f,length,mshort);\n\t\t\tbreak;\n\t\tcase msgint  :sprintf(to,f,length,mint);\n\t\t\tbreak;\n\t\tcase msgcharp:sprintf(to,f,length,mcharp);\n\t\t\tbreak;\n\t\tcase msgmvsSTRING: sprintf(to,f,length,(char * )(*mmvsSTRING));\n\t\t\tbreak;\n\t\tcase msgchar: sprintf(to,f,mchar);\n\t\t\tbreak;\n\t\t\u00fc\n\treturn to;\n\t\u00fc\n\n\n/*--------------------------------------------------------------+\n]                                                               ]\n]  TEXT class                                                   ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\nstatic TEXTENTRY Textvector\u00c4\u00dc =\n\t\u00e4\n#define  MESSAGE_TEXT\n#define t( a , b ) \u00e4 a , b \u00fc ,\n#include \"msgtext.hpp\"\n#undef t\n#undef   MESSAGE_TEXT\n\t\t\u00e40,0\u00fc\n\t\u00fc;\n\nint initMessageText()\n\n\t\t\u00e4\n\t\tif (messagetext==NULL)\n\t\t\tmessagetext = new MessageTEXT();\n\t\treturn 0;\n\t\t\u00fc\n\nMessageTEXT::MessageTEXT(char * fn ,char * logstream)\n\t\u00e4\n\tif ( fn)\n\t\t\u00e4\n\t\tmsgfilename = new char\u00c4strlen(fn)+1\u00dc;\n\t\tstrcpy(msgfilename,fn);\n\t\t\u00fc\n\telse msgfilename = 0;\n\tonlylogger = false;\n\tlogger = false; //szm20060410 init logger\n\tif (logstream)\n\t\t\u00e4\n\t\tif (mvs()->LoggerOpen(logstream))\n\t\t\tlogger = true;\n\t\telse\n\t\t\tlogger = false;\n\t\t\u00fc\n\tmsgfile = NULL; //szm\n\tvector = Textvector;\n\tprintfv = 0;\n\ttimestemp = 1;\n\t\u00fc\n\nvoid MessageTEXT::setFileName(char * fn)\n\t\u00e4\n\tif ( fn)\n\t\t\u00e4\n\t\tmsgfilename = new char\u00c4strlen(fn)+1\u00dc;\n\t\tstrcpy(msgfilename,fn);\n\t\t\u00fc\n\telse msgfilename = 0;\n\t\u00fc\n\nvoid MessageTEXT::setLogger(const char *logstream)\n\t\u00e4\n\tif (logstream)\n\t\t\u00e4\n\t\tif (mvs()->LoggerOpen(logstream))\n\t\t\tlogger = true;\n\t\telse\n\t\t\tlogger = false;\n\t\t\u00fc\n\t\u00fc\n\nMessageTEXT::\u00dfMessageTEXT()\n\t\u00e4\n\tif (msgfile) fclose(msgfile); //szm\n\tif (logger)  mvs()->LoggerClose();\n\tlogger = false;\n\tdelete \u00c4\u00dc msgfilename;\n\t\u00fc\n\nchar * MessageTEXT::getText(int i)\n\t\u00e4\n\t// printf(\"Message %d \u00d6n\",i);\n\n\tTEXTENTRY * te = Textvector;\n\twhile (te->t && (te->i > 0)  )\n\t\t\u00e4\n\t\tif ( te->i == i )\n\t\t\t\u00e4\n\t\t\t//      printf(\"%s\u00d6n\",te->t);\n\t\t\treturn te->t;\n\t\t\t\u00fc\n\t\tte++;\n\t\t\u00fc\n\t// printf(\"Undefined message %d\u00d6n\",i );\n\tsprintf(deflt,\"Undefined message %d\u00d6n\",i );\n\treturn deflt;\n\n\t\u00fc\n\nint MessageTEXT::copyText(int i,char * to,int l)\n\t\u00e4\n\tchar   tm\u00c4ERROR_BUFF\u00dc;\n\tchar * from = getText(i);\n\tif (messagetext->getTimeStempFlag() )\n\t\t\u00e4\n\t\tchar tt\u00c432\u00dc;\n\t\tchar fm\u00c4\u00dc = \"%Y:%m:%d %H:%M:%S \";\n\t\tformatTime(tt,sizeof(tt),fm);\n\t\tstrcpy(tm,tt);\n\t\tstrcat(tm,from);\n\t\tfrom = tm;\n\t\t\u00fc\n\n\tint lf = strlen(from);\n\tif ( lf <= l)\n\t\tstrcpy(to,from);\n\telse\n\t\t\u00e4\n\t\tmemcpy(to,from,l-1);\n\t\tto\u00c4l-1\u00dc  = null;\n\t\t\u00fc\n\treturn ( l -lf );\n\t\u00fc\n\nchar * MessageTEXT::print(char * t)\n\t\u00e4\n\tif (|onlylogger)\n\t\t\u00e4\n\t\tif ( msgfilename)\n\t\t\t\u00e4\n\t\t\tif (msgfile == NULL)\n\t\t\t\tmsgfile = fopen(msgfilename,\"wt,type=record\"); //szm\n\t\t\tif (msgfile)\n\t\t\t\t\u00e4\n\n\t\t\t\t//fprintf(msgfile,\"%s\u00d6n\",t); szm\n\t\t\t\tfputs(t,msgfile);\n\t\t\t\tfflush(msgfile);\n\t\t\t\t//fclose(msgfile); //szm\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\tif ( printfv ) printfv(t);\n\t\telse\n\t\t\tputs(t);\n\t\t\u00fc\n\tif (logger)\n\t\tmvs()->Logger(t);\n\treturn t;\n\t\u00fc\n\nvoid MessageTEXT::setNumber(int n)\n\t\u00e4\n\tnumber = n;\n\tvi = 0;\n\tfor (int i=0;i<8;i++)v\u00c4i\u00dc = 0;\n\t\u00fc\n\n\nMessageTEXT&  MessageTEXT::operator<<(int i)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tINT(i);\n\treturn * this;\n\t\u00fc\n#if 0   //szm\nMessageTEXT&  MessageTEXT::operator<<(short i)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tSHORT(i);\n\treturn * this;\n\t\u00fc\n#endif\nMessageTEXT&  MessageTEXT::operator<<(char *c)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tCHARp(c);\n\treturn * this;\n\t\u00fc\n\nMessageTEXT&  MessageTEXT::operator<<(const mvsSTRING& s)\n\t\u00e4\n\tmvsSTRING temp = s;\n\tv\u00c4vi++\u00dc = tmvsSTRING(temp);\n\treturn * this;\n\t\u00fc\n\nMessageTEXT&  MessageTEXT::operator<<(void * p)\n\t\u00e4\n\tv\u00c4vi++\u00dc = tHEX((char *)p,8);\n\treturn * this;\n\t\u00fc\nchar * MessageTEXT::operator<<(const EOL eol)\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tint i;\n\tmemset(ebb,null,sizeof(ebb));\n\tcopyText(number,format,ERROR_BUFF);\n\n\tfor(i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = v\u00c4i\u00dc;\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);              break;\n\t\t\u00fc\n\n\tprint(ebb);\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\n\t\tif ( v\u00c4i\u00dc )\n\t\t\t\u00e4 delete v\u00c4i\u00dc ; v\u00c4i\u00dc = 0;\u00fc\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->err(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn g_ebb;\n\t\u00fc\n\n\n/*--------------------------------------------------------------+\n]  Text formatting                                              ]\n]                                                               ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n\n\n\nMessageTEXT& Err(int number)\n\t\u00e4\n\tif (messagetext==NULL)\n\t\tmessagetext = new MessageTEXT();\n\tmessagetext->setNumber(number);\n\treturn (*messagetext);\n\t\u00fc\nMessageTEXT& Msg(int number)\n\t\u00e4\n\tif (messagetext==NULL)\n\t\tmessagetext = new MessageTEXT();\n\tmessagetext->setNumber(number);\n\treturn (*messagetext);\n\t\u00fc\n\nint   Error(int number , ...   )\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tMSGE *mv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tmemset(ebb,null,sizeof(ebb));\n\tva_list ap;\n\tva_start(ap, number);\n\n\tmessagetext->copyText(number,format,ERROR_BUFF);\n\n\tint i;\n\tfor(i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tmv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = (MSGE *)(va_arg(ap,void *));\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\tmv \u00c4i\u00dc = msge;\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);               break;\n\t\t\u00fc\n\n\tmessagetext->print(ebb);\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tif ( mv\u00c4i\u00dc ) delete mv\u00c4i\u00dc ;\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->err(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn 0;\n\t\u00fc\n\n\nchar *  Message(int number , ...   )\n\t\u00e4\n\tchar ebb\u00c4 ERROR_BUFF \u00dc;\n\tchar *iv\u00c48\u00dc;\n\tMSGE *mv\u00c48\u00dc;\n\tchar format\u00c4ERROR_BUFF\u00dc;\n\n\tmemset(ebb,null,sizeof(ebb));\n\tva_list ap;\n\tva_start(ap, number);\n\n\tmessagetext->copyText(number,format,ERROR_BUFF);\n\n\tint i;\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tiv\u00c4i\u00dc = 0;\n\t\tmv\u00c4i\u00dc = 0;\n\t\tMSGE * msge = (MSGE *)(va_arg(ap,void *));\n\t\tif ( msge == 0 ) break;\n\t\tiv \u00c4i\u00dc = msge->format();\n\t\tmv \u00c4i\u00dc = msge;\n\t\t\u00fc\n\n\tswitch(i)\n\t\t\u00e4\n\t\tcase 0 : sprintf(ebb,format);\n\t\t\tbreak;\n\t\tcase 1 : sprintf(ebb,format,iv\u00c40\u00dc);\n\t\t\tbreak;\n\t\tcase 2 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc);\n\t\t\tbreak;\n\t\tcase 3 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc);\n\t\t\tbreak;\n\t\tcase 4 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc);\n\t\t\tbreak;\n\t\tcase 5 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc);\n\t\t\tbreak;\n\t\tcase 6 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc);\n\t\t\tbreak;\n\t\tcase 7 : sprintf(ebb,format,iv\u00c40\u00dc,iv\u00c41\u00dc,iv\u00c42\u00dc,iv\u00c43\u00dc,iv\u00c44\u00dc,iv\u00c45\u00dc,iv\u00c46\u00dc);\n\t\t\tbreak;\n\t\tdefault: sprintf(ebb,format);               break;\n\t\t\u00fc\n\n\n\tstrcpy(g_ebb,ebb);\n\tfor( i = 0;i<8;i++)\n\t\t\u00e4\n\t\tif ( mv\u00c4i\u00dc ) delete mv\u00c4i\u00dc ;\n\t\telse break;\n\t\t\u00fc\n#ifdef  PANEL_ID\n\tPanelSetMessageUncond(\n\t\tmessagetext->getTimeStempFlag() ? g_ebb+19 :  g_ebb ) ;\n\tcicsbase->log(g_ebb);\n#endif\n\tg_ebb_flag = 1;\n\treturn g_ebb;\n\t\u00fc\n\n\nchar * getErrorText()\n\t\u00e4\n\tif ( g_ebb_flag == 0 ) return 0;\n\tg_ebb_flag = 0;\n\tif (messagetext->getTimeStempFlag()) return g_ebb+19;\n\telse return g_ebb ;\n\t\u00fc\n\nchar * getMessageText()\n\t\u00e4\n\tif (messagetext->getTimeStempFlag()) return g_ebb+19;\n\telse return g_ebb ;\n\t\u00fc\n\nExternalTEXT::ExternalTEXT(char * name ):language('E')\n\t\u00e4init(name);\u00fc\nExternalTEXT::ExternalTEXT(char * name, char lang ):language(lang)\n\t\u00e4init(name);\u00fc\n\nvoid ExternalTEXT::init(char * name)\n\t\u00e4\n\tmodulname\u00c40\u00dc = language==' ' ? 'E':language;\n\tstrcpy(modulname+1,name);\n\tdllhandle * handle = dllload(modulname);\n\t//fp = (void *(*)())dllqueryfn(handle,\"_dynamn\");\n\tfp = (EXT_C_fp)dllqueryfn(handle,\"_dynamn\");\n\tif (fp == 0)\n\t\t\u00e4\n\t\tchar _b\u00c4128\u00dc;\n\t\tsprintf(_b,\"unable to load the '%s' text module \u00d6n handle:%p function:%p d\u00d6n\",modulname,handle,fp);\n\t\tputs(_b);\n\t\tabort();\n\t\t\u00fc\n\ttext = fp();\n\t\u00fc\n\nint ExternalTEXT::MSGTEXT(int id, char * buff,int len)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\t\u00e4 if ( id == atoi(etp->cid) )\n\t\t\t\u00e4\n\t\t\tstrncpy(buff,*(etp->ett),len-1);\n\t\t\t*(buff+len-1) = 0;\n\t\t\treturn 1;\n\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t*buff = 0;\n\t\treturn 0;\n\t\u00fc\n\nchar * ExternalTEXT::HelpText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn *(etp->ett);\n\treturn 0;\n\t\u00fc\n\nselection* ExternalTEXT::SelectionText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn (selection *)(etp->ett);\n\treturn 0;\n\t\u00fc\n\nentry * ExternalTEXT::EntryText(char * hid)\n\t\u00e4\n\tif (text)\n\t\tfor ( et * etp = (et *) text;etp->ett;etp++)\n\t\t\tif ( strcmp(hid,etp->cid) == 0 )\n\t\t\t\treturn (entry *)(etp->ett);\n\treturn 0;\n\t\u00fc\n\n\t\u00fc //namespace isis_ns_mvs\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGTEXT": {"ttr": 1339, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/msgtext.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\nt(9001,\"IQW9001E the program '%s' called from '%s' ended with %s\")\nt(9002,\"IQW9002E the received line  length %s is too long for the scanner\")\nt(9003,\"IQW9003E invalid HTTP header record: '%s'\")\nt(9004,\"IQW9004E the request header format is invalid '%s'\")\nt(9005,\"IQW9005E unable to load the '%s' program\")\nt(9006,\"IQW9006E unable to open '%s' file for '%s' HTML\")\nt(9007,\"IQW9007E unable to open cache-list: '%s'\")\nt(9008,\"IQW9008E internal variable access error '%s'\")\nt(9010,\"IQW9010E service unvaliable '%s'\")\nt(9011,\"IQW9011E bad request for '%s'\")\nt(9012,\"IQW9012E unable to processs '%s' request\")\nt(9020,\"IQW9020E invalid query '%s'\")\nt(9021,\"IQW9021E Error from DB/2:'%s'\")\nt(9022,\"IQW9022E Nothing selected\")\nt(9024,\"IQW9024E Nothing selected\")\nt(9025,\"IQW9025E inavlid skeleton '%s'\")\nt(9050,\"IQW9050E invalid multpart/form-data format:%s\")\nt(9051,\"IQW9051E invalid entry in multipart/form-data:%s\")\nt(9052,\"IQW9052E invalid content type:%s\")\nt(9053,\"IQW9053E boundary missing\")\nt(9054,\"IQW9054E invalid AFP input data\")\nt(9091,\" %s\")\nt(9092,\" %s %s\")\nt(9093,\" %s %s %s\")\nt(9120,\"IQW9120E invalid URL entry '%s' in '%s' URL\")\nt(9121,\"IQW9121E logic error for '%s' in '%s' URL\")\nt(9122,\"IQW9122E unable to open '%s'\")\nt(9123,\"IQW9123E unable to get '%s' skeleton HTML\")\nt(9124,\"IQW9124E unable to get'%s' directory\")\nt(9125,\"IQW9125E unable toget '%s' from catalog\")\nt(9126,\"IQW9126E invalid URL '%s'\")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSBASE": {"ttr": 1359, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*******************************************************************************\n* Copyright ISIS Papyrus Technologies Limited\n*-------------------------------------------------------------------------------\n* File:              $Source: /data/cvs/src/mvs/mvsbase.cpp,v $\n*-------------------------------------------------------------------------------\n* Description:\n*   ???\n*******************************************************************************/\n\n\n#include \"isisdef.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#ifndef MU_STANDALONE\n#include \"pcsdll.hpp\"\n#include \"systems.hpp\" //szm\n#else\n\t#ifndef stricmp\n    #define stricmp strcmpi\n\t#endif\n\t#ifndef strcmpi\n\t\t#define strcmpi strcasecmp\n\t#endif\n\t#define MVSBatch() 1\n\t#ifndef PCS_MAX_PATH\n\t\t#define PCS_MAX_PATH 1024\n\t#endif\n#endif\n\n#include \"mvsbase.hpp\"\n#if defined(CICSAPPL) == 0 && defined(MU_STANDALONE) == 0 //szm\n#include \"isismisc.hpp\"\n#endif\n#include \"misc.hpp\"\n#ifdef CALL_TAG\n#include \"pphctags.hpp\"\n#endif\n#ifdef OWN_STDIO\n#include \"stdio.hpp\"\n#else\n#include <assert.h>\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <strings.h>\n#include <ctype.h>\n#include <new.h>\n\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n\n#include \"ibmdebug.hpp\"\n#if defined(ISIS_PF_MI) ]] defined (ISIS_PF_MU)\n#include <ctest.h>\n#endif\n#endif\n\n#define MVSBASE  0\nchar mvsSTRING::parseSepCh=0 ; //szm20061218 mvsSTRING parse escape ch is null|||||||\n\nmvsSTRING nullstring(\"\"); //szm\n\n//KV20050203 why not for ms,mu ??\n//#if defined(ISIS_PF_MS)==0 && defined(ISIS_PF_MU)==0\nvoid * memcpyp(void * target , const void * source, size_t tsize, size_t ssize, int pad)\n\t\u00e4\n\tif ( target == 0 ]] source == 0 ]] tsize <= 0) return NULL;\n\tif( tsize<=ssize)\n\t\tmemcpy(target,source,tsize);\n\telse\n\t\t\u00e4\n\t\tmemcpy(target,source,ssize);\n\t\tfor(;ssize<tsize;ssize++) *((char *)target+ssize) = char(pad);\n\t\t\u00fc\n\treturn target;\n\t\u00fc\n\nstatic const char * SAS_HFS = \"hfs\";\nstatic const char * IBM_HFS = \"///\";\nstatic const char * SAS_DSN = \"dsn\";\nstatic const char * IBM_DSN = \"//\";\nstatic const char * SAS_DDN = \"ddn\";\nstatic const char * IBM_DDN  = \"dd\";\nstatic const char * IBM_DDN_SLASH = \"//dd\";\nstatic const char * _MEM     = \"mem\"; //szm0040909\nstatic const char * IBM_OMS  = \"oms\"; //szm20080215 ToDo 17339\nstatic const char * IBM_HTTP = \"http\"; //szm\nstatic const char * IBM_HTTPS = \"https\"; //szm\n\n\ngenOpenNameType genOpenType(const char *name)\n\t\u00e4\n\tchar  nm\u00c4256\u00dc;\n\tchar  np\u00c4256\u00dc;\n\tchar  pf\u00c432\u00dc;\n\tmemset(pf,0,sizeof(pf));\n\tgenOpenNameType t = ont_unknown;\n\n\tif (name == 0 ]] strlen(name) > sizeof(nm))\n\t\treturn(t);\n\n\tstrcpy(np,name);\n\tchar * n = (char *)np;\n\tchar * c = NULL;\n\tif ((c = strchr(n,int(':'))) NEQ NULL)\n\t\t\u00e4\n\t\t*c = 0;\n\t\tstrcpy(pf,n);\n\t\tn  =  c+1;\n\t\t\u00fc\n\tif (stricmp(pf,IBM_OMS))  //szm20080215 ToDo 17339\n\t\t\u00e4                       //szm20080215 ToDo 17339\n\t\tif (stricmp(pf,SAS_HFS) == 0) t = sas_hfs;\n\t\telse if (stricmp(pf,_MEM) == 0) t = ont_mem;   //szm0040909\n\t\telse if (stricmp(pf,IBM_DDN) == 0 ]] stricmp(pf,IBM_DDN_SLASH) == 0) t = ibm_ddn;\n\t\telse  if (stricmp(pf,SAS_DDN) == 0) t = sas_ddn;\n\t\telse if (stricmp(pf,SAS_DSN) == 0) t = sas_dsn;\n    else if (stricmp(pf,IBM_HTTP) == 0]]stricmp(pf,IBM_HTTPS) == 0) t = ibm_hfs; //szm\n\t\telse\n\t\t\t\u00e4\n      if (strncasecmp   (np,IBM_HFS,strlen(IBM_HFS)) == 0 ]] (np\u00c40\u00dc == '/' && np\u00c41\u00dc-'/') ]](np\u00c40\u00dc == '.' && np\u00c41\u00dc=='/'))//szm\n\t\t\t\tt = ibm_hfs;\n\t\t\telse if (strncasecmp   (np,IBM_DSN,strlen(IBM_DSN)) == 0) t = ibm_dsn;\n\t\t\t//KV20050419 in mvsbatch execution dataset names and ddnames don't need prefix\n\t\t\t// in unix execution such names are interpreted as unix file names\n\t\t\telse if(MVSBatch())\n\t\t\t\t\u00e4\n\t\t\t\tif (*n == '\"' ]] *n =='\u00d6'') t = ibm_dsn;\n\t\t\t\telse if (strchr(n,'(') && (strchr(n,'(')-n) <= 8 ) t = ont_ddn;\n\t\t\t\telse if (strchr(n,'.')) t = ont_dsn;\n\t\t\t\telse if (strlen(n) <= 8) t = ont_ddn;\n\t\t\t\telse if (strlen(n) <=18 && strchr(n,'(') && strchr(n,')')) t = ont_ddn;\n\t\t\t\telse\n\t\t\t\t\tt = ont_unknown;\n\t\t\t\t\u00fc\n\t\t\telse\n\t\t\t\t\u00e4\n\t\t\t\tt=ibm_hfs;\n\t\t\t\t\u00fc\n\t\t\t\u00fc\n\t\t\u00fc //szm20080215 ToDo 17339\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) //ZA030711\n\t//  HOST_IBM_TRACE_sd(name,t);\n#endif\n\treturn t;\n\t\u00fc\n\n\n//KV20060329 buffer nm to avoid static variable\nchar * onlyMemberName(const char * n, char* nm)\n\t\u00e4\n\tmvsSTRING s(n), p0, p1, p2;\n\ts.parse(p0,\"(\",p1,\")\",p2);\n\tstrcpy(nm,(char *)(p1));\n\treturn nm;\n\t\u00fc\n\n//KV20060329 buffer nm to avoid static variable\nchar * stripMemberName(const char * n, char* nm)\n\t\u00e4\n\tmvsSTRING s(n), p0, p1, p2;\n\ts.parse(p0,\"(\",p1,\")\",p2);\n\tstrcpy(nm,(char *)(p0+p2));\n\treturn nm;\n\t\u00fc\n\n//KV20060329 buffer nm to avoid static variable\nISIS_EXT_C\nchar * genOpenName(const char *name,char *nm)\n\t\u00e4\n\tchar  np\u00c4256\u00dc;\n\tchar  pf\u00c432\u00dc;\n\tmemset(pf,0,sizeof(pf));\n\tgenOpenNameType t = ont_unknown;\n\n\tif (name == 0 ]] strlen(name) > PCS_MAX_PATH-1)\n\t\treturn(\"??invalid name??\");\n\n\tif (*name-'\"' && *name-'\u00d6'')\n\t\t\u00e4\n\t\tstrcpy(np,name);\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tstrcpy(np,name+1);\n\t\t//KV20030714: avoid deleting ending qoutes for //'datat.set.name'\n\t\tif (np\u00c4strlen(np)-1\u00dc == '\"' ]] np\u00c4strlen(np)-1\u00dc == '\u00d6'')\n\t\t\tnp\u00c4strlen(np)-1\u00dc  = 0;\n\t\t\u00fc\n\tfor(int i =strlen(np)-1;i>=0&&np\u00c4i\u00dc==' ';i--)np\u00c4i\u00dc=0;\n\tt = genOpenType(np);\n\n\tchar * n = (char *)np;\n\tchar * c = NULL;\n\tif ((c = strchr(n,int(':'))) NEQ NULL)\n\t\t\u00e4\n\t\t*c = 0;\n\t\tstrcpy(pf,n);\n\t\tn  =  c+1;\n\t\t\u00fc\n\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU) // IBM or UNIX (not SAS)szm20031030\n\tif (strcmp(\"(*)\",n+strlen(n)-3)==0) //szm 20100628 zOS 1.11 fopen difference\n\t\t*(n+strlen(n)-3) = 0;       //szm 20100628 zOS 1.11 fopen difference\n\tswitch(t)\n\t\t\u00e4\n\t\tcase ont_mem:         //szm0040909\n\t\t\tsprintf(nm,\"mem:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_dsn:\n\t\t\tif (*(n+2) - '\u00d6'')\n\t\t\t\tsprintf(nm,\"//'%s'\",n+2);\n\t\t\telse\n\t\t\t\tstrcpy(nm,n);\n\t\t\tbreak;\n\t\tcase sas_dsn:\n\t\tcase ont_dsn:\n\t\t\tif (*n - '\u00d6'')\n\t\t\t\tsprintf(nm,\"//'%s'\",n);\n\t\t\telse\n\t\t\t\tsprintf(nm,\"//%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_ddn:\n\t\tcase sas_ddn:\n\t\tcase ont_ddn:\n\t\t\tsprintf(nm,\"//dd:%s\",n);\n\t\t\tbreak;\n\t\tcase sas_hfs:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_hfs:\n\t\tcase ont_unknown:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\t\u00fc\n#else\n\tswitch(t)\n\t\t\u00e4\n\t\tcase ont_mem:         //szm0040909\n\t\t\tsprintf(nm,\"mem:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_dsn:\n\t\tcase sas_dsn:\n\t\tcase ont_dsn:\n\t\t\tsprintf(nm,\"dsn:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_ddn:\n\t\tcase sas_ddn:\n\t\tcase ont_ddn:\n\t\t\tsprintf(nm,\"ddn:%s\",n);\n\t\t\tbreak;\n\t\tcase ibm_hfs:\n\t\t\tsprintf(nm,\"hfs:%s\",nm+3);\n\t\t\tbreak;\n\t\tcase sas_hfs:\n\t\t\tsprintf(nm,\"hfs:%s\",n);\n\t\t\tbreak;\n\t\tcase ont_unknown:\n\t\t\tsprintf(nm,\"%s\",n);\n\t\t\tbreak;\n\t\t\u00fc\n#endif\n#if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n\tHOST_IBM_TRACE_sss(name,nm,n);\n#endif\n\treturn (nm);\n\t\u00fc\n\nUSHORT  Ushort(int i)\n\t\u00e4 return ((unsigned short)i);\u00fc\nUSHORT  Ushort(short s)\n\t\u00e4 return ((unsigned short)s);\u00fc\nUSHORT  Ushort(char c)\n\t\u00e4 return ((unsigned short)c);\u00fc\n\n\n/*--------------------------------------------------------------+\n]  mvsSTRING global class                                          ]\n]                                                               ]\n]                                                               ]\n+--------------------------------------------------------------*/\n\n/*\nFORMAT F_alcu(aLEFT,cUPPER);\nFORMAT F_alcw(aLEFT,cWORD);\nFORMAT F_arcu(aRIGHT,cUPPER);\n*/\n\nmvsSTRING::mvsSTRING()\n\t\u00e4\n\tst.l = 1;\n\tst.c = new char\u00c41\u00dc;\n\tst.type = str::_VALID;\n\tst.ltype = str::VARIABLE;\n\t*st.c = null;\u00fc\nmvsSTRING::mvsSTRING(const char * y)\n\t\u00e4\n\tchar * x = (y ? (char *) y : \"\");\n\tst.l = (long int ) strlen(x);\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tst.type = str::_VALID;\n\tst.ltype = str::VARIABLE;\n\tstrcpy(st.c,x);\n\t\u00fc\nmvsSTRING::mvsSTRING(const mvsSTRING & x )\n\t\u00e4\n\tst.l = x.st.l;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tst.type = x.st.type ;\n\tst.ltype = x.st.ltype ;\n\tmemcpy(st.c,x.st.c,st.l+1);\n\t\u00fc\nmvsSTRING::mvsSTRING(const char * y,long int xl )\n\t\u00e4\n\tchar * x = y ? (char *) y : \"\";\n\tst.l = xl;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tif ( memchr(x,xl+1,0) ) st.type = str::_INVALID ;\n\telse     \u00e4  st.type = str::_VALID ; st.c\u00c4st.l\u00dc = 0; \u00fc\n\tmemcpy(st.c,x,xl);\n\t\u00fc\nmvsSTRING::mvsSTRING(const char def ,const long int xl )\n\t\u00e4\n\tst.ltype = str::FIX ;\n\tst.type  = str::_VALID;\n\tst.l = xl;\n\tst.c = new char\u00c4st.l+1\u00dc;\n\tmemset(st.c,def,st.l);\n\tst.c\u00c4st.l\u00dc = 0;\n\t\u00fc\nmvsSTRING::\u00dfmvsSTRING()\n\t\u00e4\n\tif ( st.c) delete \u00c4\u00dc st.c;\n\tif ( st.lls) delete \u00c4\u00dc st.lls;\n\t\u00fc\n\nmvsSTRING& mvsSTRING::operator=(const char * y )\n\t\u00e4\n\tchar * x = (y ? (char *)y : \"\");\n\tif ( x NEQ st.c)\n\t\t\u00e4 if ( st.ltype == str::VARIABLE )\n\t\t\u00e4\n\t\tchar * sv = st.c;\n\t\tst.l = (long int ) strlen(x);\n\t\tst.c = new char \u00c4st.l+1\u00dc;\n\t\tstrcpy(st.c,x);\n\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\tdelete \u00c4\u00dc sv;\n\t\tst.type = str::_VALID;\n\t\t\u00fc\n\t\telse\n\t\t\t\u00e4\n\t\t\tlong int l =(strlen(x)<= st.l ? strlen(x) : st.l);\n\t\t\tmemcpy(st.c,x,l);\n\t\t\tmemset(st.c+l,' ',st.l-l);\n\t\t\u00fc\n\t\t\u00fc\n\treturn * this ;\n\t\u00fc\nmvsSTRING& mvsSTRING::operator=(const mvsSTRING &x)\n\t\u00e4\n\tif (x.st.c NEQ st.c)\n\t\tif (st.ltype == str::VARIABLE )\n\t\t\t\u00e4\n\t\t\tchar * sv = st.c;\n\t\t\tst.l = x.st.l;\n\t\t\tst.c = new char\u00c4st.l+1\u00dc;\n\t\t\tmemcpy(st.c,x.st.c,st.l+1);\n\t\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\t\tdelete \u00c4\u00dc sv ;\n\t\t\t//   st.type = x.st.type;     don't assign fix type\n\t\t\t\u00fc\n\t\telse\n\t\t\t\u00e4\n\t\t\tst.ltype =str::FIX ;\n\t\t\tlong int l =(x.st.l<= st.l ? x.st.l : st.l);\n\t\t\tmemcpy(st.c,x.st.c,l);\n\t\t\tmemset(st.c+l,' ',st.l-l);\n\t\t\t\u00fc\n\t\treturn * this;\n\t\u00fc\n\nmvsSTRING & mvsSTRING::operator=(const sLL & s)\n\t\u00e4\n\tchar * sv = st.c;\n\tst.ltype = str::VARIABLE;\n\tst.l = s.getLength();\n\tst.c = new char\u00c4st.l\u00dc;\n\tmemcpy(st.c,s.getStart(),st.l);\n\tdelete \u00c4\u00dc sv;\n\treturn *this;\n\t\u00fc\n\nlong int operator==(const mvsSTRING & x, const mvsSTRING &y)\n\t\u00e4\n\tif (x.st.type == str::_VALID && y.st.type == str::_VALID)\n\t\treturn (strcmp(x.st.c,y.st.c) == 0);\n\telse if ( x.st.l == y.st.l)\n\t\treturn( memcmp(x.st.c,y.st.c,x.st.l) == 0 );\n\telse return 0;\n\t\u00fc\nlong int operator |=(const mvsSTRING & x, const mvsSTRING &y)\n\t\u00e4\n\treturn ( NOT( x == y) );\n\t\u00fc\n\nmvsSTRING operator+(const mvsSTRING& s1, const mvsSTRING& s2)\n\t\u00e4\n\tmvsSTRING r = s1;\n\tr+=s2;\n\treturn r;\n\t\u00fc\n/*\nmvsSTRING mvsSTRING::operator+(const mvsSTRING & x)\n\u00e4\nif ( &x == 0) return * this;\nmvsSTRING r;\nr.st.l = st.l + x.st.l;\nr.st.c = new char \u00c4 r.st.l+1\u00dc;\nmemcpy(r.st.c,st.c,st.l);\nmemcpy(r.st.c+st.l,x.st.c,x.st.l+1);\nif (st.type == str::_VALID && x.st.type == str::_VALID)\nr.st.type = str::_VALID ;\nelse r.st.type = str::_INVALID ;\nreturn r;\n\u00fc\n*/\n\nmvsSTRING& mvsSTRING::operator+=(const mvsSTRING& x )\n\t\u00e4\n\tif ( &x == 0 ) return * this;\n\tif ( st.ltype == str::VARIABLE )\n\t\t\u00e4\n\t\tchar * save = st.c;\n\t\tlong int savel = st.l;\n\t\tst.l += x.st.l;\n\t\tst.c  = new char \u00c4st.l+1\u00dc;\n\t\tmemcpy(st.c,save,savel);\n\t\tmemcpy(st.c+savel,x.st.c,x.st.l+1);\n\t\tif ( st.type == str::_VALID ]] st.type == str::_INVALID)\n\t\t\tdelete \u00c4\u00dc save;\n\t\tif ( st.type NEQ str::_VALID ]] x.st.type NEQ str::_VALID)\n\t\t\tst.type = str::_INVALID ;\n\t\t\u00fc\n\telse perror(\" unable to add to a fix mvsSTRING\");\n\treturn * this ;\n\t\u00fc\n\nchar& mvsSTRING::operator\u00c4\u00dc(int index)\n\t\u00e4\n\tif ( index < 0 ]] index > st.l)\n\t\t\u00e4perror(\" _INVALID index for \u00c4\u00dc operator \"); return st.c\u00c40\u00dc;\u00fc;\n\treturn st.c\u00c4index\u00dc;\n\t\u00fc\n\nchar& mvsSTRING::byte(int index)\n\t\u00e4\n\tif ( index < 0 ]] index > st.l)\n\t\t\u00e4perror(\" _INVALID index for \u00c4\u00dc operator \"); return st.c\u00c40\u00dc;\u00fc;\n\treturn st.c\u00c4index\u00dc;\n\t\u00fc\n\n\nmvsSTRING mvsSTRING::operator()(const long int o,  long int l = 1 )\n\t\u00e4\n\tif ( o < 0 ]] o+l > st.l ]]  l < 0 )\n\t\t\u00e4perror(\" _INVALID STRING operation\");return * this ;\u00fc\n\treturn mvsSTRING((const char *)(st.c+o),l);\n\t\u00fc\n\nvoid mvsSTRING::operator<<(long int l)\n\t\u00e4\n\tif ( l <= 0 ]] l >= st.l) return ;\n\tchar * c = st.c;\n\tfor(long int i = 0;i<st.l;i++)\n\t\tif (i+l<st.l)\n\t\t\t\u00e4*(c+i) = *(c+i+l); *(c+i+l) = ' ';\u00fc\n\t\telse *(c+i) = ' ';\n\t\treturn ;\n\t\u00fc\n\nvoid mvsSTRING::operator>>(long int l)\n\t\u00e4\n\tif ( l <= 0 ]] l >= st.l) return ;\n\tchar * c = st.c;\n\tfor(long int i = st.l-1;i;i--)\n\t\tif (i-l>=0)\n\t\t\t\u00e4*(c+i)= *(c+i-l); *(c+i-l) = ' '; \u00fc\n\t\telse *(c+i) = ' ';\n\t\treturn ;\n\t\u00fc\n\nlong int mvsSTRING::hashcode()\n\t\u00e4\n\tlong int r = 0;\n\tfor (long int i = st.l ;i;i--)\n\t\tr = (r<<1) \u00ac (st.c\u00c4i\u00dc) ;\n\treturn (r<0 ? -r:r);\n\t\u00fc\nchar * mvsSTRING::nameOf()\n\t\u00e4\n\treturn \"mvsSTRING\" ;\n\t\u00fc\n\n/*\nlong int    mvsSTRING::lengthOf()\n\u00e4\nreturn st.l;\n\u00fc;\n*/\n\nvoid mvsSTRING::changeAll(char f,char t)\n\t\u00e4\n\tfor(char * c =st.c;*c;c++) if ( *c == f) *c = t;\n\t\u00fc\n\nvoid mvsSTRING::align(ALIGNTYPE falign)\n\t\u00e4\n\tlong int i , is , iz ;\n\tif ( st.type NEQ str::_VALID ) return ;\n\tswitch(falign)\n\t\t\u00e4\n\t\tcase aLEFT  :\n\t\t\tfor( i =0;i<st.l;i++)\n\t\t\t\tif (st.c\u00c4i\u00dc NEQ ' ') break ;\n\t\t\t*this<<i;\n\t\t\tbreak ;\n\t\tcase aRIGHT :\n\t\t\tfor( i=st.l-1;i;i--)\n\t\t\t\tif (st.c\u00c4i\u00dc NEQ ' ') break ;\n\t\t\t*this>>(st.l-1-i);\n\t\t\tbreak ;\n\t\tcase aCENTER:\n\t\t\tfor( is =0;is<st.l;is++)\n\t\t\t\tif (st.c\u00c4is\u00dc NEQ ' ') break ;\n\t\t\tfor( iz=st.l-1;iz;iz--)\n\t\t\t\tif (st.c\u00c4iz\u00dc NEQ ' ') break ;\n\t\t\tif ( is >= iz ) break ;\n\t\t\ti = (st.l-(iz-is))/2;\n\t\t\tif (i < is ) *this<<(is-i);\n\t\t\telse if( i>is) *this>>(i-is);\n\t\t\tbreak ;\n\t\tcase aASIS   :\n\t\tdefault :\n\t\t\treturn ;\n\t\t\u00fc\n\t\u00fc\nvoid mvsSTRING::caps(CAPSTYPE fcaps)\n\t\u00e4\n\tlong int i = st.l-1;\n\tif ( i <0 ]] st.type NEQ str::_VALID ) return ;\n\tlong int flag = 1;\n\tswitch(fcaps)\n\t\t\u00e4\n\t\tcase cUPPER :\n\t\t\twhile (i+1) st.c\u00c4i\u00dc = (char )toupper(st.c\u00c4i--\u00dc);\n\t\t\tbreak ;\n\t\tcase cLOWER :\n\t\t\twhile (i+1) st.c\u00c4i\u00dc = (char )tolower(st.c\u00c4i--\u00dc);\n\t\t\tbreak ;\n\t\tcase cWORD:\n\t\t\tfor(i=0;i<st.l;i++)\n\t\t\t\t\u00e4 if ( st.c\u00c4i\u00dc == ' ' ) flag = 1 ;\n\t\t\t\telse if (flag) \u00e4 flag = 0; st.c\u00c4i\u00dc =(char ) toupper(st.c\u00c4i\u00dc);\u00fc\n\t\t\t\telse st.c\u00c4i\u00dc = (char )tolower(st.c\u00c4i\u00dc); \u00fc\n\t\t\tbreak ;\n\t\tcase cASIS   :\n\t\tdefault :\n\t\t\treturn ;\n\t\t\u00fc\n\t\u00fc\n\nmvsSTRING& mvsSTRING::strip()\n\t\u00e4\n#if defined(ISIS_PF_HOST) ]] defined(ISIS_PF_MU)\n\tchar linefeed = '\u00d6x15';\n\tchar horizontaltab = '\u00d6x05';\n#else\n\tchar linefeed  = '\u00d6x0a';\n\tchar horizontaltab = '\u00d6x09';\n#endif\n\tlong int is , iz ;\n\tif ( st.type NEQ str::_VALID ]]\n\t\tst.ltype == str::FIX ) return *this;\n\tfor( is =0;is<st.l;is++)\n\t\tif (st.c\u00c4is\u00dc NEQ ' ') break ;\n\tfor( iz=st.l-1;iz;iz--)\n\t\tif (st.c\u00c4iz\u00dc NEQ ' ' && st.c\u00c4iz\u00dc NEQ linefeed && st.c\u00c4iz\u00dc NEQ horizontaltab) break ;\n\tif ( is > iz ) *this = \"\";\n\telse \u00e4 st.c\u00c4iz+1\u00dc = 0; st.ltype = str::VARIABLE ;\n\tif (is) *this = (char *)&(st.c\u00c4is\u00dc);\n\telse\n\t\t\u00e4\n\t\tchar * temp = new char\u00c4strlen(st.c)+1\u00dc;\n\t\tstrcpy(temp,st.c);\n\t\t* this = temp ;\n\t\tdelete \u00c4\u00dc temp;\n\t\t\u00fc\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nint mvsSTRING::isEmpty()\n\t\u00e4\n\tif ( st.l == 0 ) return 1;\n\tmvsSTRING t = *this;\n\tt.st.ltype = str::VARIABLE;\n\tt.strip();\n\tif ( t.lengthOf() == 0) return 1;\n\treturn 0;\n\t\u00fc\n\nmvsSTRING& mvsSTRING::stripmvsSTRING()\n\t\u00e4\n\tst.ltype = str::VARIABLE;\n\tstrip();\n\treturn *this;\n\t\u00fc\nvoid mvsSTRING::parse(mvsSTRING& s , char c, mvsSTRING &rest )\n\t\u00e4\n\n\tchar *p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff=|off;\n\t\tif (|off&&st.c\u00c4i\u00dc==c)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\tif ( p ) \u00e4 *p = '\u00d6x00'; rest = p+1; s = st.c ; *p = c; \u00fc\n\telse\n\t\t\u00e4\n\t\ts = st.c;\n\t\trest = \"\";\n\t\t\u00fc\n\n\t\u00fc\nvoid mvsSTRING::parse(mvsSTRING& s , char * c, mvsSTRING & rest)\n\t\u00e4\n\tchar * p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff=|off;\n\t\tif (|off&&memcmp(st.c+i,c,strlen(c))==0)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\n\tif ( p)\n\t\t\u00e4\n\t\t//KV20051205 if s==*this or rest == *this then st.c might be deleted in assignment operator\n\t\t// -> p must not be used after assignment\n\t\tmvsSTRING tmp(st.c,p-st.c);\n\t\trest = p+strlen(c);\n\t\ts = tmp;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\ts = *this;\n\t\trest = \"\";\n\t\t\u00fc\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING& s1,char c1, mvsSTRING& s2, char c2,mvsSTRING& rest)\n\t\u00e4\n\tmvsSTRING re;\n\tchar * p = NULL;\n\tbool off =false;\n\tfor(int i=0;p==NULL&&i<lengthOf();i++)\n\t\t\u00e4\n\t\tif (st.c\u00c4i\u00dc == parseSepCh && st.c\u00c4i+1\u00dc|=parseSepCh)\n\t\t\toff|=off;\n\t\tif (|off&&st.c\u00c4i\u00dc==c1)\n\t\t\tp = st.c+i;\n\t\t\u00fc\n\n\tif (p)\n\t\t\u00e4\n\t\tparse(s1,c1,re);\n\n\t\tre.parse(s2,c2,rest);\n\t\t\u00fc\n\telse \u00e4 s1 = st.c; s2 = \"\"; rest = \"\"; \u00fc\n\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3);\n\t\t\u00fc\n\ts10 = s1;\n\ts20 = s2;\n\ts30 = s3;\n\n\t\u00fc\n\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tstrip();\n\tparse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.strip();\n\t\trest.parse(s2,c2,s3);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\n\t\u00fc\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30,\n\t\t\t\t\t\t\t\t\t\t\tchar * c3, mvsSTRING&s40)\n\t\u00e4\n\tparse(s10,c1,s20,c2,s30,c3,s40);\n\t\u00fc\n\nvoid mvsSTRING::split(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2, mvsSTRING&s30,\n\t\t\t\t\t\t\t\t\t\t\tchar * c3, mvsSTRING&s40,\n\t\t\t\t\t\t\t\t\t\t\tchar * c4, mvsSTRING&s50)\n\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tmvsSTRING s4 = \"\";\n\tmvsSTRING s5 = \"\";\n\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3,c3,s4,c4,s5);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\ts40 = s4.strip();\n  s50 = s5.strip();\n\t\u00fc\n\nvoid mvsSTRING::parse(mvsSTRING&s10, char * c1,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s20, char * c2,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING&s30, char * c3, mvsSTRING&s40)\n\t\u00e4\n\tmvsSTRING rest;\n\tmvsSTRING s1 = \"\";\n\tmvsSTRING s2 = \"\";\n\tmvsSTRING s3 = \"\";\n\tmvsSTRING s4 = \"\";\n\tthis->parse(s1,c1,rest);\n\tif ( NOT rest.isEmpty() )\n\t\t\u00e4\n\t\trest.parse(s2,c2,s3,c3,s4);\n\t\t\u00fc\n\ts10 = s1.strip();\n\ts20 = s2.strip();\n\ts30 = s3.strip();\n\ts40 = s4.strip();\n\t\u00fc\n\nvoid mvsSTRING::dump(const char * f,int l)\n\t\u00e4\n#if 0\n\tchar * use = \"mvsSTRING\";\n\t// if ( 0 ) //( __test__ )\n\t// ::dump((FILE *)f,use,st.c,st.l);\n\tchar _d\u00c41024\u00dc;\n\tsprintf(_d,\" File:%s Line:%d %s: %*s (%d %d %d) \u00d6n\",f,l,use,st.l,st.c,st.l,st.ltype,st.type);\n\tputs(_d);\n#endif\n\t\u00fc\n\nmvsSTRING& mvsSTRING::format(FORMAT * f)\n\t\u00e4\n\tcaps(f->fcaps);\n\talign(f->falign);\n\treturn * this ;\n\t\u00fc\n\nchar * mvsSTRING::getLlmvsSTRING()\n\t\u00e4\n\tst.lls = new char\u00c4st.l+2\u00dc;\n\t*(short*)st.lls = short(st.l);\n\tmemcpy(st.lls+2,st.c,st.l);\n\treturn st.lls;\n\t\u00fc\n\n\n\n\n#if 0\n\nmvsSTRING patternchng(mvsSTRING  input,char *  mask,\n\t\t\t\t\t\t\t\t\t\t\tmvsSTRING  (*f)(mvsSTRING ))\n\t\u00e4\n\tchar * mv\u00c432\u00dc;\n\tlong int mflag = 1, mi = 0 ;\n\tlong int ml = strlen(mask);\n\tlong int i  , j ;\n\n\tfor(i=0;i<ml;i++)\n\t\t\u00e4  if ( *(mask+i) == '*' )\n\t\t\u00e4 *(mask+i ) = 0 ;\n\tmv\u00c4mi++\u00dc   = 0 ;\n\tmflag = 1;\n\t\t\u00fc\n\t\telse\n\t\t\tif (mflag)\n\t\t\t\t\u00e4 mflag = 0;\n\tmv\u00c4mi++\u00dc = mask+i ; \u00fc\n\t\t\u00fc\n\n\n\tlong int start = 0, stop = 0, offset = 0;\n\tmvsSTRING outputstr(\" \",0);\n\tmvsSTRING r = input ;\n\tchar * s ;\n\n\n\tfor(i=0;i<strlen(input);i++)\n\t\t\u00e4\n\t\tfor(j=0;j<mi;j++)\n\t\t\tif ( j == 0)\n\t\t\t\t\u00e4 if ( mv\u00c40\u00dc == 0)\n\t\t\t\t\u00e4 start = i ;  stop = strlen(input) ; \u00fc\n\t\t\t\telse if ( ( s = strstr(((char *)input)+i,mv\u00c40\u00dc) ) NEQ 0)\n\t\t\t\t\t\u00e4 start  = s - (char *)input ;  stop= start+strlen(mv\u00c40\u00dc);\n\t\toffset =stop-start ; \u00fc\n\t\t\t\telse \u00e4 stop = 0 ;break; \u00fc\n\t\t\t\t\u00fc\n\t\t\telse\n\n\t\t\t\t\u00e4\n\t\t\t\tif (  mv\u00c4j\u00dc == 0 ) \u00e4 stop =  strlen(input) ; continue ;\u00fc\n\n\t\t\t\telse if ( ( s = strstr((char *)input+start+offset,mv\u00c4j\u00dc)) NEQ 0 )\n\t\t\t\t\tstop = s-input+strlen(mv\u00c4j\u00dc);\n\t\t\t\telse \u00e4 stop = 0; break;\u00fc\n\t\t\t\t\u00fc\n\n\n\n\n\n\t\t\tif ( start < stop)\n\n\t\t\t\t\u00e4  outputstr  = outputstr + input(i,start-i);\n\t\t\tmvsSTRING t((char *)input+start,stop-start);\n\t\t\tr = input+stop;\n\t\t\toutputstr = outputstr + f(t) ;\n\t\t\ti =stop ;\n\t\t\tstart = stop = offset = 0;\n\t\t\t\t\u00fc\n\t\t\u00fc\n\toutputstr = outputstr+r;\n\treturn outputstr ;\n\n\t\u00fc\n#endif\n\n\n//#include <stdlib.h>\n\n\n\nsLLType  sLLTypeTable\u00c4\u00dc = \u00e4 sLLt0, sLLt1, sLLt2, sLLt3, sLLt4, sLLt0\u00fc;\n\n// Construtors:\n// default output\n//\n\n\nsLL::sLL(sLLType st , sLLUsage su,int l):mERROR()\n\t\u00e4\n\ttype = st;\n\tusage = su;\n\tstatus = sLLOk;\n\tallocl = 0;\n\n\tbase = child = (sLL*)0;\n\tllength = int(type);\n\n\tif ( usage NEQ sLLinput )\n\t\t\u00e4\n\t\tallocl = l;\n\t\tstart = new char \u00c4l\u00dc;\n\t\tstoredl = offset = llength;\n\t\tcursor = start+offset;\n\t\tlength = l;\n\t\tfromInt(start,length,llength);\n\t\t\u00fc\n\t\u00fc\n\n//\n// From a base sLL\n//\n\nsLL ::sLL (sLL  * b,int o,sLLType st):mERROR()\n\t\u00e4\n\tinit(b,o,st);\n\t\u00fc\n\n//\n// From a base SLL with offset\n//\n\nsLL::sLL(sLL * b,char  * s,\n\t\t\t\t sLLType st):mERROR()\n\t\u00e4\n\tinit(b,s-(b->start),st);\n\t\u00fc\n\n//\n// From a mvsSTRING\n//\n\nsLL ::sLL (char  * s,sLLType  st):mERROR()\n\t\u00e4\n\tallocl = 0;\n\tusage = sLLinput ;\n\ttype = st;\n\tstatus = sLLOk;\n\n\tbase = child =(sLL*)0;\n\tstoredl = llength = offset = int(st);\n\n\tlength = int(toInt(s,llength));\n\tstart = s;\n\tcursor = start+offset;\n\n\t\u00fc\n\nsLL :: sLL(char  * s, int ix):mERROR()\n\t\u00e4\n\tsLLType st = sLLTypeTable\u00c4ix\u00dc;\n\tusage = sLLinput ;\n\ttype = st;\n\tstatus = sLLOk;\n\n\tbase = child =(sLL*)0;\n\tstoredl =  llength = offset = int(st);\n\n\tlength = int(toInt(s,llength));\n\tstart = s;\n\tcursor = start+offset;\n\t\u00fc\n\n//\n// Copy constructor\n//\n\nsLL ::sLL (const sLL & f):mERROR()\n\t\u00e4\n\tallocl = f.allocl;\n\ttype   = f.type;\n\tusage  = f.usage;\n\tstatus = f.status;\n\n\tif ( usage NEQ sLLinput)\n\t\tstart = new char \u00c4f.allocl\u00dc;\n\telse\n\t\tstart = new char \u00c4f.length\u00dc;\n\n\tlength = f.length;\n\toffset = f.offset;\n\tllength = f.llength;\n\tstoredl = f.storedl;\n\tbase = NULL ;\n\tcursor = start+(f.cursor-f.start);\n\tmemcpy(start,f.start,length);\n\t\u00fc\n\n// Destructor\n\nsLL::\u00dfsLL()\n\t\u00e4\n\tif ( allocl ) delete \u00c4\u00dc start;\n\t\u00fc\n\n//\n// Assignemnt operator\n//\n\nsLL & sLL ::operator=(sLL  & from)\n\t\u00e4\n\tif ( &from == this ) return *this;\n\n\tif (allocl )\n\t\t\u00e4\n\t\tdelete \u00c4\u00dc start ;\n\t\t\u00fc\n\terr = from.err;\n\tallocl = from.allocl ? from.allocl : from.length;\n\tstart = new char \u00c4allocl\u00dc;\n\tlength = from.length;\n\n\tusage = from.usage;\n\ttype  = from.type;\n\tstatus = from.status;\n\tllength = from.llength;\n\toffset = from.offset;\n\tstoredl= from.storedl;\n\tcursor = start+(from.cursor-from.start);\n\n\tbase = from.base;\n\tchild = from.child;\n\n\tmemcpy(start,from.start,length);\n\treturn * this;\n\t\u00fc\n\nsLL::operator int()\n\t\u00e4\n\tif ( status == sLLOk && NOT iserror() )\n\t\t\u00e4\n\t\tif (usage == sLLinput) return  getRemainderLength() ;\n\t\telse return storeOk(1);\n\t\t\u00fc\n\n\telse\n\t\treturn 0;\n\t\u00fc\n\nchar  & sLL::operator\u00c4\u00dc(int o)\n\t\u00e4\n\tif ( offset < length )\n\t\treturn start\u00c4o\u00dc;\n\n\tstatus = sLLOf; markerror();\n\treturn dummy;\n\t\u00fc\n\n//\n// Iterate on base - child structure\n//\n\nsLL *sLL::iterate(sLLType st,int resetf)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tif ( resetf ) resetCursor();\n\tchild = new sLL(this,cursor,st);\n\tif (child->iserror()) return NULL;\n\treturn child;\n\t\u00fc\n\n//\n// Get back the next child\n//\n\nsLL  *sLL ::next()\n\t\u00e4\n\n\tif ( child == 0 ]] iserror() )\n\t\treturn (sLL *)0;\n\tint    l  = child->getFullLength();\n\tdelete child;\n\n\tif ( goCursor(l+type) )\n\t\t\u00e4\n\t\tcursor-=type;\n\t\tchild = new sLL(this,cursor,type);\n\t\treturn child;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tchild = 0;\n\t\treturn NULL;\n\t\t\u00fc\n\t\u00fc\nvoid sLL::remove(sLL& o)\n\t\u00e4\n\n\tsLL s(type,sLLoutputVar,storedl);\n\tsLL * si = iterate(type);\n\twhile ( si )\n\t\t\u00e4\n\t\tif ( si->getStart() NEQ o.getStart() )\n\t\t\ts<<(*si);\n\t\tsi = next();\n\t\t\u00fc\n\t*this = s;\n\t\u00fc\n\n// Get info\n\n\nsLL   * sLL ::getBase()\u00e4 return base;\u00fc\nint     sLL ::getOffset()\u00e4 return offset;\u00fc\nint     sLL ::getFullLength()\u00e4 return length;\u00fc\nint     sLL ::getStoredLength()\u00e4 return storedl;\u00fc\nint     sLL ::getRemainderLength()\n\t\u00e4 if (status == sLLOk )\n\treturn (length - (cursor - start) ) ;\nreturn 0;\n\t\u00fc\nchar  * sLL ::getCursor()\u00e4 return cursor;\u00fc\nsLL   * sLL ::getChild()\u00e4 return child;\u00fc\nvoid    sLL ::setBase(sLL *b)\u00e4 base = b;\u00fc\nvoid    sLL ::setChild(sLL *c)\u00e4 child = c;\u00fc\nvoid    sLL ::setUsage(sLLUsage u)\n\t\u00e4\n\tif ( u == usage ) return;\n\n\tif ( u == sLLinput )\n\t\t\u00e4\n\t\tsetLength();\n\t\tlength = storedl;\n\t\tresetCursor();\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tcursor = start+length;\n\t\t\u00fc\n\tstatus = sLLOk;\n\tclearerror();\n\tusage = u;\n\t\u00fc\n// Cursor\n\nvoid sLL::resetCursor()\n\t\u00e4\n\tstatus = sLLOk;\n\tclearerror();\n\tcursor = start+llength;\n\tif ( usage NEQ sLLinput ) setLength();\n\n\t\u00fc\n\nchar  * sLL::goCursor(int v)\n\t\u00e4\n\tchar * c = cursor+v;\n\tif ( iserror() ]] status NEQ sLLOk ) return 0;\n\tif ( (c-start) <= length && (c-start ) >= llength )\n\t\t\u00e4\n\t\tcursor = c;\n\t\tif ( usage NEQ sLLinput) setLength();\n\t\treturn cursor ;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tstatus = sLLUf;\n\t\tcursor = start +length;\n\t\tmarkerror();\n\t\treturn 0;\n\t\t\u00fc\n\t\u00fc\n\nvoid sLL::setLength()\n\t\u00e4\n\tstoredl = cursor-start;\n\tfromInt(start,cursor-start,int(type));\n\t\u00fc\n\nsLL& sLL::operator >>(int& i)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ti = int(toInt(cursor,sizeof(int)));\n\tgoCursor(sizeof( int));\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(unsigned short& s )\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts =(unsigned short) toInt(cursor,sizeof(short));\n\tgoCursor(sizeof(short));\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(short& s )\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = short(toInt(cursor,sizeof(short)));\n\tgoCursor(sizeof(short));\n\treturn *this;\n\t\u00fc\n\n\nsLL& sLL::operator>>(char  & c)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tc = *cursor;\n\tgoCursor(1);\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator >>(char * & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts =  cursor;\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator>>(mvsSTRING & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = mvsSTRING(cursor,getRemainderLength());\n\tgoCursor(getRemainderLength());\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator >>(sLL& s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tsLL ns(cursor,s.type);\n\ts = ns;\n\tgoCursor(s.length);\n\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator>>(INT3 & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\ts = int(toInt(cursor,3));\n\tgoCursor(3);\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator>>(sLLskip & s)\n\t\u00e4\n\tsetUsage(sLLinput);\n\tgoCursor(int(s));\n\treturn *this;\n\n\t\u00fc\n\nsLL& sLL::operator<<(int i)\n\t\u00e4\n\tif ( storeOk(sizeof(int)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,i,sizeof(i));\n\t\tgoCursor(sizeof(int));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(short i)\n\t\u00e4\n\tif ( storeOk(sizeof(short)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,i,sizeof(i));\n\t\tgoCursor(sizeof(short));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(unsigned short i)\n\t\u00e4\n\tif ( storeOk(sizeof(short)) )\n\n\t\t\u00e4\n\t\tfromInt(cursor,short(i),sizeof(i));\n\t\tgoCursor(sizeof(short));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(char  c)\n\t\u00e4\n\tif (storeOk(1))\n\t\t\u00e4\n\t\t*cursor=c;\n\t\tgoCursor(1);\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::operator<<(char  * str)\n\t\u00e4\n\tint l = strlen(str);\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,str,l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(mvsSTRING & s)\n\t\u00e4\n\tint l = s.lengthOf();\n\tif (storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,(char *)(s),l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\nsLL& sLL::operator<<(sLL & s)\n\t\u00e4\n\tint l = s.getLength();\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,s.getStart(),l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(INT3& i)\n\t\u00e4\n\tif (storeOk(3)  )\n\t\t\u00e4\n\t\tfromInt(cursor,int(i),3);\n\t\tgoCursor(3);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\nsLL& sLL::operator<<(sLLskip& s)\n\t\u00e4\n\tif ( storeOk(int(s))  )\n\t\t\u00e4\n\t\tmemset(cursor,null,int(s));\n\t\tgoCursor(int(s));\n\t\t\u00fc\n\treturn *this;\n\t\u00fc\n\nsLL& sLL::store(char  * p,int l)\n\t\u00e4\n\tif ( l <= 0 ) return *this;\n\tif ( storeOk(l) )\n\t\t\u00e4\n\t\tmemcpy(cursor,p,l);\n\t\tgoCursor(l);\n\t\t\u00fc\n\treturn * this;\n\t\u00fc\n\n//szm20050629\nmvsSTRING sLL::getString()\n\t\u00e4\n\tif ( *(getCursor()+getRemainderLength()) == '\u00d6x00' )\n\t\tstring = getCursor();\n\telse\n\t\t\u00e4\n\t\tchar * c = new char\u00c4getRemainderLength()+1\u00dc;\n\t\tc\u00c4getRemainderLength()\u00dc = null;\n\t\tmemcpy(c,getCursor(),getRemainderLength());\n\t\tstring = c;\n\t\tdelete \u00c4\u00dc c;\n\t\t\u00fc\n\treturn string;\n\t\u00fc\n//szm\n\n//\n// Utilies\n//\n\nvoid sLL::init(sLL * b,int o,sLLType st)\n\t\u00e4\n\ttype  = st;\n\tusage = sLLinput;\n\tstatus = sLLOk;\n\tallocl = 0;\n\tbase  = b;\n\tchild = 0;\n\tstart = (b->start)+o;\n\n\toffset = llength = int(st);\n\tcursor = start+offset;\n\tb->setChild(this);\n\tif ( usage == sLLinput  ]] b  )\n\t\tstoredl = length = int(toInt (start,llength));\n\telse\n\t\tstoredl = length = llength ;\n\t\u00fc\n\nint sLL::storeOk(int l)\n\t\u00e4\n#if defined(OWN_STDIO) == 0\n\tassert ( l >= 0 );\n#endif\n\tint r;\n\tif ( usage == sLLinput )\n\t\t\u00e4\n\t\tcursor = start+length;\n\t\tusage = sLLoutputVar;\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tr = allocl -(cursor-start);\n\t\tif ( r >= l ) return 1;\n\t\tif ( usage == sLLoutput )\n\t\t\t\u00e4\n\t\t\tstatus = sLLOf;\n\t\t\treturn 0;\n\t\t\t\u00fc\n\t\t\u00fc\n\tr =l+(cursor-start);\n\tchar * n = new char \u00c4r\u00dc;\n\n\tint o = cursor-start;\n\tmemcpy(n,start,o);\n\tif ( allocl )\n\t\tdelete \u00c4\u00dc start;\n\tlength = allocl = r;\n\tstart = n;\n\tcursor = n+o;\n\treturn 1;\n\t\u00fc\n\n//\n//\n//\n\nvoid sLL::dump(const char *f,int ln)\n\t\u00e4\n#if 0\n\tchar * use = (usage == sLLinput) ? \"Input\" : \"Output\" ;\n\tint l   = (usage == sLLinput) ? length : storedl;\n\tchar b\u00c41024\u00dc;\n\tsprintf(b,\" File:%s Line:%d %s %d \u00d6n\",f,ln,use,l\n\t\t);\n\tputs(b);\n\tstring.dump(f,ln);\n#endif\n\t\u00fc\n\n\nint sLL::write(void * f)\n\t\u00e4\n\treturn fwrite(start,1,getLength(),(FILE *)f);\n\t\u00fc\n\nsLL * readsLL(void* f,sLLType t)\n\t\u00e4\n\tint l;\n\tchar lx\u00c44\u00dc;\n\n\tif ( fread(lx,1,int(t),(FILE *)f) )\n\t\t\u00e4\n\n\t\tl = int(toInt(lx,int(t)));\n\t\tchar * b = new char \u00c4l\u00dc;\n\t\tmemcpy(b,lx,int(t));\n\t\tsLL * ret = NULL;\n\t\tif ( fread(b+int(t),1,l-int(t),(FILE *)f) )\n\t\t\t\u00e4\n\t\t\tsLL buff(b,t);\n\t\t\tret = new sLL(buff);\n\t\t\t\u00fc\n\t\tdelete \u00c4\u00dcb;\n\t\treturn ret;\n\n\t\t\u00fc\n\telse return NULL;\n\t\u00fc\n\n//--------------------------------------------------------------------\n//--------------------------------------------------------------------\n//--------------------------------------------------------------------\n\n/*\nsLLTag class fix type sLLt2 ( two bytes length)\nshort code\n...\n*/\n\nvoid sLLTag::init(short c )\n\t\u00e4\n\t//printf(\"code :%d\u00d6n\",c);\n\tcode = c ;\n\tsearchcode = 0;\n#ifdef CALL_TAG\n\tname = TagCatalog\u00c4code\u00dc ?(char *)(TagCatalog\u00c4code\u00dc->name) :  \"???\";\n#endif\n\t//  printf(\"%s\u00d6n\",name);\n\t\u00fc\n\nsLLTag::sLLTag():sLL(sLLt2,sLLoutputVar)\n\t\u00e4\n\tinit(0);\n\t(*this)<<short(0);\n\t\u00fc\n\nsLLTag::sLLTag(short c)\n#ifdef CALL_TAG\n:sLL(sLLt2,sLLoutputVar,TagCatalog\u00c4c\u00dc->maxlength+5)\n#endif\n\t\u00e4\n\tinit(c);\n\t(*this)<<c;\n\t\u00fc\n\nsLLTag::sLLTag(char * s):sLL(s)\n\t\u00e4\n\t(*this)>>code;\n\tinit(code);\n\t\u00fc\n\nsLLTag::sLLTag(const sLLTag & s):sLL(s)\n\t\u00e4\n\tcode = s.code;\n\tname = s.name;\n\tsearchcode = s.searchcode;\n\t\u00fc\n\nsLLTag::sLLTag(sLL * b,char  * s):sLL(b,s,sLLt2)\n\t\u00e4\n\t(*this)>>code;\n\tinit(code);\n\t\u00fc\n\nsLLTag& sLLTag::operator=(sLLTag&  from)\n\t\u00e4\n\n\tif ( &from == this ) return *this;\n\tthis->sLL::operator=(from);\n\tcode   = from.code;\n\tname   = from.name;\n\tsearchcode = from.searchcode;\n\treturn *this;\n\t\u00fc\n\nsLLTag * sLLTag::search(short c)\n\t\u00e4\n\tsLLTag * s ;\n\tsetUsage(sLLinput);\n\tif ( c )\n\t\t\u00e4\n\t\tsearchcode = c;\n\t\tresetCursor();\n\t\ts = iterate();\n\t\t\u00fc\n\telse s = next();\n\twhile( s && searchcode NEQ s->getCode() )\n\t\t\u00e4\n\t\ts = next();\n\t\t\u00fc\n\n\tstatus = sLLOk;\n\tclearerror();\n\treturn (s);\n\t\u00fc\n\nsLLTag * sLLTag::update(sLLTag & f )\n\t\u00e4\n\n\tsLLTag * s = search(f.code);\n\tif ( s )\n\t\t\u00e4\n\t\tremove(*s);\n\t\t\u00fc\n\t(*this)<<f;\n\treturn s;\n\t\u00fc\n\nvoid sLLTag::resetCursor()\n\t\u00e4\n\tsLL::resetCursor();\n\tgoCursor(sizeof(short));\n\t\u00fc\n\n\nvoid sLLTag::remove(sLLTag& o)\n\t\u00e4\n\n\tsLLTag s(code);\n\tresetCursor();\n\tsLLTag * si = iterate();\n\twhile ( si )\n\t\t\u00e4\n\t\tif ( si->getStart() NEQ o.getStart() )\n\t\t\ts<<(*si);\n\t\tsi = next();\n\t\t\u00fc\n\t*this = s;\n\t\u00fc\n\n\nsLLTag *sLLTag::iterate()\n\t\u00e4\n\n\tchild = new sLLTag(this,cursor);\n\tif (child->iserror()) return NULL;\n\t//child->dump(__FILE__,__LINE__);\n\treturn ((sLLTag *)child);\n\t\u00fc\n\n//\n// Get back the next child\n//\n\nsLLTag * sLLTag::next()\n\t\u00e4\n\n\tif ( child == 0 ]] iserror() )\n\t\treturn (sLLTag *)0;\n\tint l  = child->getFullLength();\n\tdelete child;\n\n\tif ( goCursor(l+type) )\n\t\t\u00e4\n\t\tcursor-=type;\n\t\tchild = new sLLTag(this,cursor);\n\t\t//child->dump(__FILE__,__LINE__);\n\t\treturn ((sLLTag *)child);\n\t\t\u00fc\n\telse\n\t\t\u00e4\n\t\tchild = 0;\n\t\treturn NULL;\n\t\t\u00fc\n\t\u00fc\n\nvoid sLLTag::dump(const char *f,int ln)\n\t\u00e4\n#if 0\n\tchar b\u00c41024\u00dc;\n\tsprintf(b,\" File:%s Line:%d Name:%s Code:%d \u00d6n\",f,ln,name,code);\n\tputs(b);\n\tsLL::dump(\"\",0);\n#endif\n\t\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RARCSQL": {"ttr": 1345, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include \"isisdef.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include \"rarcsql.hpp\"\n#include \"jobenv.hpp\"\n#include \"casmif.hpp\"\n#include <sys/time.h>\n\nISIS_EXT_C typedef int  (* ppdberror)(char *); //szm\nppdberror  pdberror;                           //szm20050413\n\nextern \"C\" int locDBError(char *)\n\u00e4\n\t return 0;\n\u00fc\n\n#ifndef unsigned\n#define unsigned\n#endif\n\n\nstatic char bhex\u00c424\u00dc;\n\nchar * hex(int v,int l)\n\u00e4\n sprintf(bhex,\"%*.*x\u00d6n\",2*l,2*l,v);\n return bhex;\n\u00fc\n\ntypedef struct\n              \u00e4 short   SQLPLLEN;\n                short   SQLFLAGS;\n                short   SQLCTYPE;\n                char    SQLPROGN\u00c48\u00dc;\n                short   SQLTIMES\u00c44\u00dc;\n                short   SQLSECTN;\n                char   *SQLCODEP;\n                char   *SQLVPARM;\n                char   *SQLAPARM;\n                short   SQLSTNUM;\n                short   SQLSTYPE;\n              \u00fc SQLPLIST;\ntypedef struct\n              \u00e4 short    SQLTYPE;\n                short    SQLLEN;\n                char    *SQLADDR;\n                char    *SQLIND;\n              \u00fc SQLELTS;\ntypedef SQLELTS     *SQLELTS_PTR;\nchar    SQLTEMP\u00c4 19 \u00dc ;\nchar    DSNPNM\u00c4 57 \u00dc ;\n\n/***$$$\n  EXEC SQL INCLUDE SQLCA\n$$$***/\n#ifndef SQLCODE\nstruct sqlca\n  \u00e4 unsigned  char     sqlcaid\u00c48\u00dc;\n              long     sqlcabc;\n              long     sqlcode;\n              short    sqlerrml;\n    unsigned  char     sqlerrmc\u00c470\u00dc;\n    unsigned  char     sqlerrp\u00c48\u00dc;\n              long     sqlerrd\u00c46\u00dc;\n    unsigned  char     sqlwarn\u00c411\u00dc;\n    unsigned  char     sqlstate\u00c45\u00dc;\n            \u00fc ;\n#define SQLCODE  sqlca.sqlcode\n#define SQLWARN0 sqlca.sqlwarn\u00c40\u00dc\n#define SQLWARN1 sqlca.sqlwarn\u00c41\u00dc\n#define SQLWARN2 sqlca.sqlwarn\u00c42\u00dc\n#define SQLWARN3 sqlca.sqlwarn\u00c43\u00dc\n#define SQLWARN4 sqlca.sqlwarn\u00c44\u00dc\n#define SQLWARN5 sqlca.sqlwarn\u00c45\u00dc\n#define SQLWARN6 sqlca.sqlwarn\u00c46\u00dc\n#define SQLWARN7 sqlca.sqlwarn\u00c47\u00dc\n#define SQLWARN8 sqlca.sqlwarn\u00c48\u00dc\n#define SQLWARN9 sqlca.sqlwarn\u00c49\u00dc\n#define SQLWARNA sqlca.sqlwarn\u00c410\u00dc\n#define SQLSTATE sqlca.sqlstate\n#endif\nstruct sqlca sqlca;\n\n\n/***$$$\n  EXEC SQL INCLUDE SQLDA\n$$$***/\n#ifndef SQLDASIZE\nstruct sqlda\n   \u00e4  unsigned char   sqldaid\u00c48\u00dc;\n               long   sqldabc;\n               short  sqln;\n               short  sqld;\n               struct sqlvar\n                  \u00e4 short          sqltype;\n                    short          sqllen;\n                    unsigned char *sqldata;\n                    short         *sqlind;\n                    struct sqlname\n                       \u00e4 short         length;\n                         unsigned char data\u00c430\u00dc;\n                       \u00fc sqlname;\n                  \u00fc sqlvar\u00c41\u00dc;\n            \u00fc ;\n#define SQLDASIZE(n) \u00d6\n   ( sizeof( sqlda) + ((n)-1) * sizeof( sqlvar) )\n#endif\n\n\n/***$$$\n  EXEC SQL BEGIN DECLARE SECTION\n$$$***/\n\n\n  struct \u00e4\n  short len;\n  char  value\u00c4512\u00dc;\n  \u00fc prepare;\n\n\n/***$$$\n  EXEC SQL END DECLARE SECTION\n$$$***/\n\n\n\n\nconst char * IDENTIFY           = \"IDENTIFY          \";\nconst char * SIGNON             = \"SIGNON            \";\nconst char * CREATE_THREAD      = \"CREATE THREAD     \";\nconst char * TERMINATE_THREAD   = \"TERMINATE THREAD  \";\nconst char * TERMINATE_IDENTIFY = \"TERMINATE IDENTIFY\";\nconst char * CONNECT            = \"CONNECT           \";\n\nARCHSQL::ARCHSQL()\n\u00e4\n  status = 0;\n  secb = tecb = 0;\n  ribptr = 0;\n  eibptr = 0;\n\n  memset(ssnm,' ',4);\n  memset(plan,' ',8);\n  memset(collection,' ',sizeof(collection));\n  memset(reuse,' ',sizeof(reuse));  //That makes it INITIAL\n  messagetext = new MessageTEXT(0); //ZA030519\n  JOBENV job(\"RARCSQL\");\n  memset(correlation_id,' ',sizeof(correlation_id));\n  strcpy(correlation_id,job.jobId);\n  memset(accounting_token,' ',sizeof(accounting_token));\n  sprintf(accounting_token,\"%s%s\",(char *)job.jobName,(char*)job.jobId); //ZA090713\n  memset(accounting_interval,' ',sizeof(accounting_interval));\n  if (pdberror==NULL)     //szm\n\t\t\tpdberror=locDBError;\n\t// first call initializes list of load module entry points\n  rrs = SQLASM();\n\u00fc\n\nARCHSQL::\u00dfARCHSQL()\n\u00e4\n  if ( status )\n  call(Disconnect);\n  // second call clears list of load module entry points\n  SQLASM();\n\u00fc\n\nint ARCHSQL::call(CallType t)\n\u00e4\n  int msg = 0;\n  retcode = reasoncode = 0;\n  switch(t)\n  \u00e4\n  case Connect:\n    if (rrs)\n    \u00e4\n      rc = DSNALI(IDENTIFY,\n            &ssnm\u00c40\u00dc,\n            &ribptr,&eibptr,&tecb,&secb,\n            &retcode,&reasoncode);\n\t\t\tif (rc<0) //szm20050829 second connect returns -1 or -2 if parm error\n\t\t\t\t\u00e4\n\t\t\t\tif (rc == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\tassert(\"SSQLASM parm error\"|=0);\n\t\t\t\t\u00fc\n      if ( retcode NEQ 0)\n      \u00e4\n      \t//ZA030519 97.. message numbers changed to 98.. message numbers\n        pdberror(Msg(9821)<<IDENTIFY<<\n        //#ifdef ISIS_PF_HOST_IBM //ZA050715\n        #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n        (int)retcode<<hex(reasoncode,4)<<eol);\n        #else\n        long(retcode)<<hex(reasoncode,4)<<eol);\n        #endif\n        return 0;\n      \u00fc\n    \u00fc\n    else\n    \u00e4\n      rc = DSNALI(CONNECT,\n            &ssnm\u00c40\u00dc,\n            &tecb,&secb,&ribptr,&retcode,&reasoncode);\n\t\t\tif (rc<0) //szm20050829 second connect returns -1 or -2 if parm error\n\t\t\t\u00e4\n\t\t\t\tif (rc == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\tassert(\"SSQLASM parm error\"|=0);\n\t\t\t\u00fc\n      if ( retcode NEQ 0)\n      \u00e4\n        if (retcode NEQ 200 ]] reasoncode NEQ 0x00c10201u)\n        \u00e4\n        //#ifdef ISIS_PF_HOST_IBM //ZA050715\n        #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n        pdberror(Msg(9801)<<(int)retcode<<hex(reasoncode,4)<<eol);\n        #else\n        pdberror(Msg(9801)<<long(retcode)<<hex(reasoncode,4)<<eol);\n        #endif\n        return 0;\n      \u00fc\n      else //ZA050304 already connected\n      \u00e4\n        status = 1;\n        break;\n      \u00fc\n     \u00fc\n   \u00fc\n  case Open:\n  if (rrs)\n  \u00e4\n      rc = DSNALI(SIGNON,\n            &correlation_id\u00c40\u00dc,\n            &accounting_token\u00c40\u00dc,\n            &accounting_interval\u00c40\u00dc,\n            &retcode,&reasoncode);\n\n      if ( retcode NEQ 0)\n      \u00e4\n        pdberror(Msg(9821)<<SIGNON<<\n        //#ifdef ISIS_PF_HOST_IBM //ZA050715\n        #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n        (int)retcode<<hex(reasoncode,4)<<eol);\n        #else\n        long(retcode)<<hex(reasoncode,4)<<eol);\n        #endif\n        return 0;\n      \u00fc\n      if (collection\u00c40\u00dc NEQ ' ' && collection\u00c40\u00dc NEQ  0)\n        plan\u00c40\u00dc = '?';\n      rc = DSNALI(CREATE_THREAD,\n            &plan\u00c40\u00dc,\n            &collection\u00c40\u00dc,\n            &reuse\u00c40\u00dc, //ToDo: 25777 Citibank\n            &retcode,&reasoncode);\n\n      if ( retcode NEQ 0)\n      \u00e4\n        pdberror(Msg(9821)<<CREATE_THREAD<<\n        //#ifdef ISIS_PF_HOST_IBM //ZA050715\n        #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n        (int)retcode<<hex(reasoncode,4)<<eol);\n        #else\n        long(retcode)<<hex(reasoncode,4)<<eol);\n        #endif\n        return 0;\n      \u00fc\n  \u00fc\n  else\n  \u00e4\n    rc = DSNALI(\"OPEN        \",\n          &ssnm\u00c40\u00dc,\n          &plan\u00c40\u00dc,\n          &retcode,&reasoncode);\n\n    if ( retcode NEQ 0 )\n    \u00e4\n      //#ifdef ISIS_PF_HOST_IBM //ZA050715\n      #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n      pdberror(Msg(9811)<<(int)retcode<<hex(reasoncode,4)<<eol);\n      #else\n      pdberror(Msg(9811)<<long(retcode)<<hex(reasoncode,4)<<eol);\n      #endif\n      return 0;\n    \u00fc\n  \u00fc\n  status = 1;\n  break;\n  case Close:\n    if (rrs)\n    \u00e4\n      rc = DSNALI(TERMINATE_THREAD,\n            &retcode,&reasoncode);\n\n      if ( retcode NEQ 0)\n      \u00e4\n        pdberror(Msg(9821)<<TERMINATE_THREAD<<\n        //#ifdef ISIS_PF_HOST_IBM //ZA050715\n        #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n        (int)retcode<<hex(reasoncode,4)<<eol);\n        #else\n        long(retcode)<<hex(reasoncode,4)<<eol);\n        #endif\n        return 0;\n      \u00fc\n    \u00fc\n    else\n    \u00e4\n      rc = DSNALI(\"CLOSE       \",\n            \"SYNC\",\n            &retcode,&reasoncode);\n\n\t\t\tif ( retcode NEQ 0)\n      \u00e4\n        //#ifdef ISIS_PF_HOST_IBM //ZA050715\n        #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n        pdberror(Msg(9812)<<(int)retcode<<hex(reasoncode,4)<<eol);\n        #else\n        pdberror(Msg(9812)<<long(retcode)<<hex(reasoncode,4)<<eol);\n        #endif\n        return 0;\n      \u00fc\n    \u00fc\n/***$$$\n    EXEC SQL WHENEVER SQLERROR   GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n    EXEC SQL WHENEVER SQLWARNING GOTO SQLWARNING\n$$$***/\n\n\n/***$$$\n    EXEC SQL WHENEVER NOT FOUND GOTO SQLNOTFOUND\n$$$***/\n\n   status = 1;\n   break;\n  case Disconnect:\n  if (rrs)\n  \u00e4\n      rc = DSNALI(TERMINATE_IDENTIFY,\n            &retcode,&reasoncode);\n\n      if ( retcode NEQ 0)\n      \u00e4\n        pdberror(Msg(9821)<<TERMINATE_IDENTIFY<<\n        //#ifdef ISIS_PF_HOST_IBM //ZA050715\n        #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n        (int)retcode<<hex(reasoncode,4)<<eol);\n        #else\n        long(retcode)<<hex(reasoncode,4)<<eol);\n        #endif\n        return 0;\n     \u00fc\n  \u00fc\n  else\n  \u00e4\n    rc = DSNALI(\"DISCONNECT  \",\n          &retcode,&reasoncode);\n\n\t\tif (retcode && (NOT ( retcode == 4 && reasoncode == 0x00c10824u)) )\n    \u00e4\n      //#ifdef ISIS_PF_HOST_IBM //ZA050715\n      #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n      pdberror(Msg(9802)<<(int)retcode<<(int)reasoncode<<eol);\n      #else\n      pdberror(Msg(9802)<<long(retcode)<<long(reasoncode)<<eol);\n      #endif\n      return 0;\n    \u00fc\n    status = 0;\n   \u00fc\n   status = 0;\n   return 1;\n    break;\n  case Prepare:\n\n/***$$$\n    EXEC SQL PREPARE S1 FROM :prepare\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST4 =\n  //\u00e440, 8192, 35, \"ARCHSQL \", 0, 0, 0, 0,\n  \u00e440, 8192, 35, \"ARCHSQL\", 0, 0, 0, 0,\n   1, 0, 0, 0, 70, 14\u00fc;\n  SQLELTS_PTR SQLELTS_PTR4;\n  SQLPLIST4.SQLVPARM = (char *) &prepare;\n  SQLPLIST4.SQLCODEP = (char *) &sqlca;\n  SQLPLIST4.SQLTIMES\u00c4 0 \u00dc = 0x15EC;\n  SQLPLIST4.SQLTIMES\u00c4 1 \u00dc = 0xE8EE;\n  SQLPLIST4.SQLTIMES\u00c4 2 \u00dc = 0x0228;\n  SQLPLIST4.SQLTIMES\u00c4 3 \u00dc = 0x99B4;\n  DSNHLI ( (unsigned int * ) &SQLPLIST4);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n  if (SQLCODE > 0 && SQLCODE NEQ 100 ]]\n      SQLWARN0 == 'W') goto SQLWARNING;\n  if (SQLCODE == 100)  goto  SQLNOTFOUND;\n\n    status = 1;\n    break;\n  case Execute:\n\n/***$$$\n    EXEC SQL EXECUTE S1\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST5 =\n  //\u00e440, 0, 30, \"ARCHSQL \", 0, 0, 0, 0,\n  \u00e440, 0, 30, \"ARCHSQL\", 0, 0, 0, 0,\n   1, 0, 0, 0, 74, 15\u00fc;\n  SQLELTS_PTR SQLELTS_PTR5;\n  SQLPLIST5.SQLCODEP = (char *) &sqlca;\n  SQLPLIST5.SQLTIMES\u00c4 0 \u00dc = 0x15EC;\n  SQLPLIST5.SQLTIMES\u00c4 1 \u00dc = 0xE8EE;\n  SQLPLIST5.SQLTIMES\u00c4 2 \u00dc = 0x0228;\n  SQLPLIST5.SQLTIMES\u00c4 3 \u00dc = 0x99B4;\n  DSNHLI ( (unsigned int * ) &SQLPLIST5);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n  if (SQLCODE > 0 && SQLCODE NEQ 100 ]]\n      SQLWARN0 == 'W') goto SQLWARNING;\n  if (SQLCODE == 100)  goto  SQLNOTFOUND;\n\n    status = 1;\n    break;\n  case Commit:\n\n/***$$$\n    EXEC SQL COMMIT\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST6 =\n  //\u00e440, 0, 150, \"ARCHSQL \", 0, 0, 0, 0,\n  \u00e440, 0, 150, \"ARCHSQL\", 0, 0, 0, 0,\n   0, 0, 0, 0, 78, 310\u00fc;\n  SQLELTS_PTR SQLELTS_PTR6;\n  SQLPLIST6.SQLCODEP = (char *) &sqlca;\n  SQLPLIST6.SQLTIMES\u00c4 0 \u00dc = 0x15EC;\n  SQLPLIST6.SQLTIMES\u00c4 1 \u00dc = 0xE8EE;\n  SQLPLIST6.SQLTIMES\u00c4 2 \u00dc = 0x0228;\n  SQLPLIST6.SQLTIMES\u00c4 3 \u00dc = 0x99B4;\n  DSNHLI ( (unsigned int * ) &SQLPLIST6);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n  if (SQLCODE > 0 && SQLCODE NEQ 100 ]]\n      SQLWARN0 == 'W') goto SQLWARNING;\n  if (SQLCODE == 100)  goto  SQLNOTFOUND;\n\n    status = 1;\n    break;\n  case Rollback:\n\n/***$$$\n    EXEC SQL ROLLBACK\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST7 =\n  //\u00e440, 0, 155, \"ARCHSQL \", 0, 0, 0, 0,\n  \u00e440, 0, 155, \"ARCHSQL\", 0, 0, 0, 0,\n   0, 0, 0, 0, 82, 277\u00fc;\n  SQLELTS_PTR SQLELTS_PTR7;\n  SQLPLIST7.SQLCODEP = (char *) &sqlca;\n  SQLPLIST7.SQLTIMES\u00c4 0 \u00dc = 0x15EC;\n  SQLPLIST7.SQLTIMES\u00c4 1 \u00dc = 0xE8EE;\n  SQLPLIST7.SQLTIMES\u00c4 2 \u00dc = 0x0228;\n  SQLPLIST7.SQLTIMES\u00c4 3 \u00dc = 0x99B4;\n  DSNHLI ( (unsigned int * ) &SQLPLIST7);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n  if (SQLCODE > 0 && SQLCODE NEQ 100 ]]\n      SQLWARN0 == 'W') goto SQLWARNING;\n  if (SQLCODE == 100)  goto  SQLNOTFOUND;\n\n    status = 1;\n    break;\n  default :\n    status = 0;\n    break;\n   \u00fc\n  return status;\n  SQLERROR: msg = 9804;\n  //   err = ERROR;\n       goto common;\n  SQLWARNING: msg = 9805;\n  //   err = WARNING;\n       goto common;\n  SQLNOTFOUND: msg = 9806;\n  //   err = WARNING;\n  common:\n    //#ifdef ISIS_PF_HOST_IBM //ZA050715\n    #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n    pdberror(Msg(msg)<<(int)SQLCODE<<eol);\n    #else\n    pdberror(Msg(msg)<<SQLCODE<<eol);\n    #endif\n    rc = DSNTIAR(&sqlca,&error_message,&data_len);\n    if ( rc )\n      //#ifdef ISIS_PF_HOST_IBM //ZA050715\n      #if defined(ISIS_PF_MI) ]] defined(ISIS_PF_MU)\n      pdberror(Msg(9807)<<(int)rc<<eol);\n      #else\n      pdberror(Msg(9807)<<long(rc)<<eol);\n      #endif\n    else\n    \u00e4\n      for(int i = 0;i<data_dim;i++)\n      pdberror(Msg(9808)<<mvsSTRING(error_message.error_text\u00c4i\u00dc,data_len)<<eol);\n    \u00fc\n  return status;\n\u00fc\n\nvoid ARCHSQL::setDynamicSQL(char * s)\n\u00e4\n  prepare.len = strlen(s);\n  strcpy(prepare.value,s);\n\u00fc\n\n//KV20050216 moved from isismisc.cpp\nstatic unsigned char tUK\u00c4\u00dc =\n     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\u00d6\n         \"0123456789#$\"\u00d6\n         \"abcdefghijklmnopqrstuvwxyz\";\n#define UKEY_MAJOR \"STRTUKEY\"\n#define UKEY_MINOR \"ISIS_UKEY\"\n\nvoid getUniqueKey(char * t)\n\u00e4\n  char _dummy=0;                     //HL??\n  struct timeval tv;\n  struct timezone tz;\n  int i;\n  ENQ(UKEY_MAJOR,UKEY_MINOR,E,8,STEP,NONE);\n#if defined(MU_STANDALONE) == 0\n  PCSSleep(1);\n#else\n\tsleep(1);\n#endif\n  i = gettimeofday(&tv,&tz);\n  DEQ(UKEY_MAJOR,UKEY_MINOR,8,STEP,NONE);\n  memcpy((void*)t,(void*)&tv.tv_sec,4);\n  memcpy((void*)&t\u00c44\u00dc,(void*)&tv.tv_usec,4);\n  for (i = 0;i<8;i++)\n    if (NOT t\u00c4i\u00dc)\n      t\u00c4i\u00dc = 64; //change nulls to EBCDIC blanks\n  t\u00c48\u00dc = _dummy;\n\n\u00fc\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TREES": {"ttr": 1377, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* trees.c -- output deflated data using Huffman coding\n * Copyright (C) 1995-2002 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process uses several Huffman trees. The more\n *      common source values are represented by shorter bit sequences.\n *\n *      Each code tree is stored in a compressed form which is itself\n * a Huffman encoding of the lengths of all the code strings (in\n * ascending order by source values).  The actual code strings are\n * reconstructed from the lengths in the inflate process, as described\n * in the deflate specification.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"'Deflate' Compressed Data Format Specification\".\n *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc\n *\n *      Storer, James A.\n *          Data Compression:  Methods and Theory, pp. 49-50.\n *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.\n *\n *      Sedgewick, R.\n *          Algorithms, p290.\n *          Addison-Wesley, 1983. ISBN 0-201-06672-6.\n */\n\n/* \u00a7(#) $Id: trees.c,v 1.3 2003/09/11 11:16:22 matthiasw Exp $ */\n\n/* #define GEN_TREES_H */\n\n#include \"deflate.h\"\n\n#ifdef DEBUG\n#  include <ctype.h>\n#endif\n\n/* ===========================================================================\n * Constants\n */\n\n#define MAX_BL_BITS 7\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\n#define END_BLOCK 256\n/* end of block literal code */\n\n#define REP_3_6      16\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n#define REPZ_3_10    17\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n#define REPZ_11_138  18\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nlocal const int extra_lbits\u00c4LENGTH_CODES\u00dc /* extra bits for each length code */\n   = \u00e40,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0\u00fc;\n\nlocal const int extra_dbits\u00c4D_CODES\u00dc /* extra bits for each distance code */\n   = \u00e40,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13\u00fc;\n\nlocal const int extra_blbits\u00c4BL_CODES\u00dc/* extra bits for each bit length code */\n   = \u00e40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7\u00fc;\n\nlocal const uch bl_order\u00c4BL_CODES\u00dc\n   = \u00e416,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15\u00fc;\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n#define Buf_size (8 * 2*sizeof(char))\n/* Number of bits used within bi_buf. (bi_buf might be implemented on\n * more than 16 bits on some systems.)\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n#define DIST_CODE_LEN  512 /* see definition of array dist_code below */\n\n#if defined(GEN_TREES_H) ]] |defined(STDC)\n/* non ANSI compilers may not accept trees.h */\n\nlocal ct_data static_ltree\u00c4L_CODES+2\u00dc;\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nlocal ct_data static_dtree\u00c4D_CODES\u00dc;\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nuch _dist_code\u00c4DIST_CODE_LEN\u00dc;\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nuch _length_code\u00c4MAX_MATCH-MIN_MATCH+1\u00dc;\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nlocal int base_length\u00c4LENGTH_CODES\u00dc;\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nlocal int base_dist\u00c4D_CODES\u00dc;\n/* First normalized distance for each code (0 = distance of 1) */\n\n#else\n#  include \"trees.h\"\n#endif /* GEN_TREES_H */\n\nstruct static_tree_desc_s \u00e4\n    const ct_data *static_tree;  /* static tree or NULL */\n    const intf *extra_bits;      /* extra bits for each code or NULL */\n    int     extra_base;          /* base index for extra_bits */\n    int     elems;               /* max number of elements in the tree */\n    int     max_length;          /* max bit length for the codes */\n\u00fc;\n\nlocal static_tree_desc  static_l_desc =\n\u00e4static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS\u00fc;\n\nlocal static_tree_desc  static_d_desc =\n\u00e4static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS\u00fc;\n\nlocal static_tree_desc  static_bl_desc =\n\u00e4(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS\u00fc;\n\n/* ===========================================================================\n * Local (static) routines in this file.\n */\n\nlocal void tr_static_init OF((void));\nlocal void init_block     OF((deflate_state *s));\nlocal void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));\nlocal void gen_bitlen     OF((deflate_state *s, tree_desc *desc));\nlocal void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));\nlocal void build_tree     OF((deflate_state *s, tree_desc *desc));\nlocal void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));\nlocal void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));\nlocal int  build_bl_tree  OF((deflate_state *s));\nlocal void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,\n                              int blcodes));\nlocal void compress_block OF((deflate_state *s, ct_data *ltree,\n                              ct_data *dtree));\nlocal void set_data_type  OF((deflate_state *s));\nlocal unsigned bi_reverse OF((unsigned value, int length));\nlocal void bi_windup      OF((deflate_state *s));\nlocal void bi_flush       OF((deflate_state *s));\nlocal void copy_block     OF((deflate_state *s, charf *buf, unsigned len,\n                              int header));\n\n#ifdef GEN_TREES_H\nlocal void gen_trees_header OF((void));\n#endif\n\n#ifndef DEBUG\n#  define send_code(s, c, tree) send_bits(s, tree\u00c4c\u00dc.Code, tree\u00c4c\u00dc.Len)\n   /* Send a code of the given tree. c and tree must not have side effects */\n\n#else /* DEBUG */\n#  define send_code(s, c, tree) \u00d6\n     \u00e4 if (z_verbose>2) fprintf(stderr,\"\u00d6ncd %3d \",(c)); \u00d6\n       send_bits(s, tree\u00c4c\u00dc.Code, tree\u00c4c\u00dc.Len); \u00fc\n#endif\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\n#define put_short(s, w) \u00e4 \u00d6\n    put_byte(s, (uch)((w) & 0xff)); \u00d6\n    put_byte(s, (uch)((ush)(w) >> 8)); \u00d6\n\u00fc\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\n#ifdef DEBUG\nlocal void send_bits      OF((deflate_state *s, int value, int length));\n\nlocal void send_bits(s, value, length)\n    deflate_state *s;\n    int value;  /* value to send */\n    int length; /* number of bits */\n\u00e4\n    Tracevv((stderr,\" l %2d v %4x \", length, value));\n    Assert(length > 0 && length <= 15, \"invalid length\");\n    s->bits_sent += (ulg)length;\n\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n     * unused bits in value.\n     */\n    if (s->bi_valid > (int)Buf_size - length) \u00e4\n        s->bi_buf ]= (value << s->bi_valid);\n        put_short(s, s->bi_buf);\n        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);\n        s->bi_valid += length - Buf_size;\n    \u00fc else \u00e4\n        s->bi_buf ]= value << s->bi_valid;\n        s->bi_valid += length;\n    \u00fc\n\u00fc\n#else /* |DEBUG */\n\n#define send_bits(s, value, length) \u00d6\n\u00e4 int len = length;\u00d6\n  if (s->bi_valid > (int)Buf_size - len) \u00e4\u00d6\n    int val = value;\u00d6\n    s->bi_buf ]= (val << s->bi_valid);\u00d6\n    put_short(s, s->bi_buf);\u00d6\n    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\u00d6\n    s->bi_valid += len - Buf_size;\u00d6\n  \u00fc else \u00e4\u00d6\n    s->bi_buf ]= (value) << s->bi_valid;\u00d6\n    s->bi_valid += len;\u00d6\n  \u00fc\u00d6\n\u00fc\n#endif /* DEBUG */\n\n\n#define MAX(a,b) (a >= b ? a : b)\n/* the arguments must not have side effects */\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nlocal void tr_static_init()\n\u00e4\n#if defined(GEN_TREES_H) ]] |defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count\u00c4MAX_BITS+1\u00dc;\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) \u00e4\n        base_length\u00c4code\u00dc = length;\n        for (n = 0; n < (1<<extra_lbits\u00c4code\u00dc); n++) \u00e4\n            _length_code\u00c4length++\u00dc = (uch)code;\n        \u00fc\n    \u00fc\n    Assert (length == 256, \"tr_static_init: length |= 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code\u00c4255\u00dc to use the best encoding:\n     */\n    _length_code\u00c4length-1\u00dc = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) \u00e4\n        base_dist\u00c4code\u00dc = dist;\n        for (n = 0; n < (1<<extra_dbits\u00c4code\u00dc); n++) \u00e4\n            _dist_code\u00c4dist++\u00dc = (uch)code;\n        \u00fc\n    \u00fc\n    Assert (dist == 256, \"tr_static_init: dist |= 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) \u00e4\n        base_dist\u00c4code\u00dc = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits\u00c4code\u00dc-7)); n++) \u00e4\n            _dist_code\u00c4256 + dist++\u00dc = (uch)code;\n        \u00fc\n    \u00fc\n    Assert (dist == 256, \"tr_static_init: 256+dist |= 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count\u00c4bits\u00dc = 0;\n    n = 0;\n    while (n <= 143) static_ltree\u00c4n++\u00dc.Len = 8, bl_count\u00c48\u00dc++;\n    while (n <= 255) static_ltree\u00c4n++\u00dc.Len = 9, bl_count\u00c49\u00dc++;\n    while (n <= 279) static_ltree\u00c4n++\u00dc.Len = 7, bl_count\u00c47\u00dc++;\n    while (n <= 287) static_ltree\u00c4n++\u00dc.Len = 8, bl_count\u00c48\u00dc++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) \u00e4\n        static_dtree\u00c4n\u00dc.Len = 5;\n        static_dtree\u00c4n\u00dc.Code = bi_reverse((unsigned)n, 5);\n    \u00fc\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) ]] |defined(STDC) */\n\u00fc\n\n/* ===========================================================================\n * Genererate the file trees.h describing the static trees.\n */\n#ifdef GEN_TREES_H\n#  ifndef DEBUG\n#    include <stdio.h>\n#  endif\n\n#  define SEPARATOR(i, last, width) \u00d6\n      ((i) == (last)? \"\u00d6n\u00fc;\u00d6n\u00d6n\" :    \u00d6\n       ((i) % (width) == (width)-1 ? \",\u00d6n\" : \", \"))\n\nvoid gen_trees_header()\n\u00e4\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header |= NULL, \"Can't open trees.h\");\n    fprintf(header,\n\t    \"/* header created automatically with -DGEN_TREES_H */\u00d6n\u00d6n\");\n\n    fprintf(header, \"local const ct_data static_ltree\u00c4L_CODES+2\u00dc = \u00e4\u00d6n\");\n    for (i = 0; i < L_CODES+2; i++) \u00e4\n\tfprintf(header, \"\u00e4\u00e4%3u\u00fc,\u00e4%3u\u00fc\u00fc%s\", static_ltree\u00c4i\u00dc.Code,\n\t\tstatic_ltree\u00c4i\u00dc.Len, SEPARATOR(i, L_CODES+1, 5));\n    \u00fc\n\n    fprintf(header, \"local const ct_data static_dtree\u00c4D_CODES\u00dc = \u00e4\u00d6n\");\n    for (i = 0; i < D_CODES; i++) \u00e4\n\tfprintf(header, \"\u00e4\u00e4%2u\u00fc,\u00e4%2u\u00fc\u00fc%s\", static_dtree\u00c4i\u00dc.Code,\n\t\tstatic_dtree\u00c4i\u00dc.Len, SEPARATOR(i, D_CODES-1, 5));\n    \u00fc\n\n    fprintf(header, \"const uch _dist_code\u00c4DIST_CODE_LEN\u00dc = \u00e4\u00d6n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) \u00e4\n\tfprintf(header, \"%2u%s\", _dist_code\u00c4i\u00dc,\n\t\tSEPARATOR(i, DIST_CODE_LEN-1, 20));\n    \u00fc\n\n    fprintf(header, \"const uch _length_code\u00c4MAX_MATCH-MIN_MATCH+1\u00dc= \u00e4\u00d6n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) \u00e4\n\tfprintf(header, \"%2u%s\", _length_code\u00c4i\u00dc,\n\t\tSEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    \u00fc\n\n    fprintf(header, \"local const int base_length\u00c4LENGTH_CODES\u00dc = \u00e4\u00d6n\");\n    for (i = 0; i < LENGTH_CODES; i++) \u00e4\n\tfprintf(header, \"%1u%s\", base_length\u00c4i\u00dc,\n\t\tSEPARATOR(i, LENGTH_CODES-1, 20));\n    \u00fc\n\n    fprintf(header, \"local const int base_dist\u00c4D_CODES\u00dc = \u00e4\u00d6n\");\n    for (i = 0; i < D_CODES; i++) \u00e4\n\tfprintf(header, \"%5u%s\", base_dist\u00c4i\u00dc,\n\t\tSEPARATOR(i, D_CODES-1, 10));\n    \u00fc\n\n    fclose(header);\n\u00fc\n#endif /* GEN_TREES_H */\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nvoid _tr_init(s)\n    deflate_state *s;\n\u00e4\n    tr_static_init();\n\n    s->l_desc.dyn_tree = s->dyn_ltree;\n    s->l_desc.stat_desc = &static_l_desc;\n\n    s->d_desc.dyn_tree = s->dyn_dtree;\n    s->d_desc.stat_desc = &static_d_desc;\n\n    s->bl_desc.dyn_tree = s->bl_tree;\n    s->bl_desc.stat_desc = &static_bl_desc;\n\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n    s->last_eob_len = 8; /* enough lookahead for inflate */\n#ifdef DEBUG\n    s->compressed_len = 0L;\n    s->bits_sent = 0L;\n#endif\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n\u00fc\n\n/* ===========================================================================\n * Initialize a new block.\n */\nlocal void init_block(s)\n    deflate_state *s;\n\u00e4\n    int n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree\u00c4n\u00dc.Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree\u00c4n\u00dc.Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree\u00c4n\u00dc.Freq = 0;\n\n    s->dyn_ltree\u00c4END_BLOCK\u00dc.Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n\u00fc\n\n#define SMALLEST 1\n/* Index within the heap array of least frequent node in the Huffman tree */\n\n\n/* ===========================================================================\n * Remove the smallest element from the heap and recreate the heap with\n * one less element. Updates heap and heap_len.\n */\n#define pqremove(s, tree, top) \u00d6\n\u00e4\u00d6\n    top = s->heap\u00c4SMALLEST\u00dc; \u00d6\n    s->heap\u00c4SMALLEST\u00dc = s->heap\u00c4s->heap_len--\u00dc; \u00d6\n    pqdownheap(s, tree, SMALLEST); \u00d6\n\u00fc\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n#define smaller(tree, n, m, depth) \u00d6\n   (tree\u00c4n\u00dc.Freq < tree\u00c4m\u00dc.Freq ]] \u00d6\n   (tree\u00c4n\u00dc.Freq == tree\u00c4m\u00dc.Freq && depth\u00c4n\u00dc <= depth\u00c4m\u00dc))\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nlocal void pqdownheap(s, tree, k)\n    deflate_state *s;\n    ct_data *tree;  /* the tree to restore */\n    int k;               /* node to move down */\n\u00e4\n    int v = s->heap\u00c4k\u00dc;\n    int j = k << 1;  /* left son of k */\n    while (j <= s->heap_len) \u00e4\n        /* Set j to the smallest of the two sons: */\n        if (j < s->heap_len &&\n            smaller(tree, s->heap\u00c4j+1\u00dc, s->heap\u00c4j\u00dc, s->depth)) \u00e4\n            j++;\n        \u00fc\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s->heap\u00c4j\u00dc, s->depth)) break;\n\n        /* Exchange v with the smallest son */\n        s->heap\u00c4k\u00dc = s->heap\u00c4j\u00dc;  k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n    \u00fc\n    s->heap\u00c4k\u00dc = v;\n\u00fc\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap\u00c4heap_max\u00dc and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nlocal void gen_bitlen(s, desc)\n    deflate_state *s;\n    tree_desc *desc;    /* the tree descriptor */\n\u00e4\n    ct_data *tree        = desc->dyn_tree;\n    int max_code         = desc->max_code;\n    const ct_data *stree = desc->stat_desc->static_tree;\n    const intf *extra    = desc->stat_desc->extra_bits;\n    int base             = desc->stat_desc->extra_base;\n    int max_length       = desc->stat_desc->max_length;\n    int h;              /* heap index */\n    int n, m;           /* iterate over the tree elements */\n    int bits;           /* bit length */\n    int xbits;          /* extra bits */\n    ush f;              /* frequency */\n    int overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count\u00c4bits\u00dc = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree\u00c4s->heap\u00c4s->heap_max\u00dc\u00dc.Len = 0; /* root of the heap */\n\n    for (h = s->heap_max+1; h < HEAP_SIZE; h++) \u00e4\n        n = s->heap\u00c4h\u00dc;\n        bits = tree\u00c4tree\u00c4n\u00dc.Dad\u00dc.Len + 1;\n        if (bits > max_length) bits = max_length, overflow++;\n        tree\u00c4n\u00dc.Len = (ush)bits;\n        /* We overwrite tree\u00c4n\u00dc.Dad which is no longer needed */\n\n        if (n > max_code) continue; /* not a leaf node */\n\n        s->bl_count\u00c4bits\u00dc++;\n        xbits = 0;\n        if (n >= base) xbits = extra\u00c4n-base\u00dc;\n        f = tree\u00c4n\u00dc.Freq;\n        s->opt_len += (ulg)f * (bits + xbits);\n        if (stree) s->static_len += (ulg)f * (stree\u00c4n\u00dc.Len + xbits);\n    \u00fc\n    if (overflow == 0) return;\n\n    Trace((stderr,\"\u00d6nbit length overflow\u00d6n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do \u00e4\n        bits = max_length-1;\n        while (s->bl_count\u00c4bits\u00dc == 0) bits--;\n        s->bl_count\u00c4bits\u00dc--;      /* move one leaf down the tree */\n        s->bl_count\u00c4bits+1\u00dc += 2; /* move one overflow item as its brother */\n        s->bl_count\u00c4max_length\u00dc--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count\u00c4max_length\u00dc\n         */\n        overflow -= 2;\n    \u00fc while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits |= 0; bits--) \u00e4\n        n = s->bl_count\u00c4bits\u00dc;\n        while (n |= 0) \u00e4\n            m = s->heap\u00c4--h\u00dc;\n            if (m > max_code) continue;\n            if (tree\u00c4m\u00dc.Len |= (unsigned) bits) \u00e4\n                Trace((stderr,\"code %d bits %d->%d\u00d6n\", m, tree\u00c4m\u00dc.Len, bits));\n                s->opt_len += ((long)bits - (long)tree\u00c4m\u00dc.Len)\n                              *(long)tree\u00c4m\u00dc.Freq;\n                tree\u00c4m\u00dc.Len = (ush)bits;\n            \u00fc\n            n--;\n        \u00fc\n    \u00fc\n\u00fc\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nlocal void gen_codes (tree, max_code, bl_count)\n    ct_data *tree;             /* the tree to decorate */\n    int max_code;              /* largest code with non zero frequency */\n    ushf *bl_count;            /* number of codes at each bit length */\n\u00e4\n    ush next_code\u00c4MAX_BITS+1\u00dc; /* next code value for each bit length */\n    ush code = 0;              /* running code value */\n    int bits;                  /* bit index */\n    int n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS; bits++) \u00e4\n        next_code\u00c4bits\u00dc = code = (code + bl_count\u00c4bits-1\u00dc) << 1;\n    \u00fc\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    Assert (code + bl_count\u00c4MAX_BITS\u00dc-1 == (1<<MAX_BITS)-1,\n            \"inconsistent bit counts\");\n    Tracev((stderr,\"\u00d6ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) \u00e4\n        int len = tree\u00c4n\u00dc.Len;\n        if (len == 0) continue;\n        /* Now reverse the bits */\n        tree\u00c4n\u00dc.Code = bi_reverse(next_code\u00c4len\u00dc++, len);\n\n        Tracecv(tree |= static_ltree, (stderr,\"\u00d6nn %3d %c l %2d c %4x (%x) \",\n             n, (i_isgraph(n) ? n : ' '), len, tree\u00c4n\u00dc.Code, next_code\u00c4len\u00dc-1));\n    \u00fc\n\u00fc\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nlocal void build_tree(s, desc)\n    deflate_state *s;\n    tree_desc *desc; /* the tree descriptor */\n\u00e4\n    ct_data *tree         = desc->dyn_tree;\n    const ct_data *stree  = desc->stat_desc->static_tree;\n    int elems             = desc->stat_desc->elems;\n    int n, m;          /* iterate over heap elements */\n    int max_code = -1; /* largest code with non zero frequency */\n    int node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap\u00c4SMALLEST\u00dc. The sons of heap\u00c4n\u00dc are heap\u00c42*n\u00dc and heap\u00c42*n+1\u00dc.\n     * heap\u00c40\u00dc is not used.\n     */\n    s->heap_len = 0, s->heap_max = HEAP_SIZE;\n\n    for (n = 0; n < elems; n++) \u00e4\n        if (tree\u00c4n\u00dc.Freq |= 0) \u00e4\n            s->heap\u00c4++(s->heap_len)\u00dc = max_code = n;\n            s->depth\u00c4n\u00dc = 0;\n        \u00fc else \u00e4\n            tree\u00c4n\u00dc.Len = 0;\n        \u00fc\n    \u00fc\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s->heap_len < 2) \u00e4\n        node = s->heap\u00c4++(s->heap_len)\u00dc = (max_code < 2 ? ++max_code : 0);\n        tree\u00c4node\u00dc.Freq = 1;\n        s->depth\u00c4node\u00dc = 0;\n        s->opt_len--; if (stree) s->static_len -= stree\u00c4node\u00dc.Len;\n        /* node is 0 or 1 so it does not have extra bits */\n    \u00fc\n    desc->max_code = max_code;\n\n    /* The elements heap\u00c4heap_len/2+1 .. heap_len\u00dc are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do \u00e4\n        pqremove(s, tree, n);  /* n = node of least frequency */\n        m = s->heap\u00c4SMALLEST\u00dc; /* m = node of next least frequency */\n\n        s->heap\u00c4--(s->heap_max)\u00dc = n; /* keep the nodes sorted by frequency */\n        s->heap\u00c4--(s->heap_max)\u00dc = m;\n\n        /* Create a new node father of n and m */\n        tree\u00c4node\u00dc.Freq = tree\u00c4n\u00dc.Freq + tree\u00c4m\u00dc.Freq;\n        s->depth\u00c4node\u00dc = (uch) (MAX(s->depth\u00c4n\u00dc, s->depth\u00c4m\u00dc) + 1);\n        tree\u00c4n\u00dc.Dad = tree\u00c4m\u00dc.Dad = (ush)node;\n#ifdef DUMP_BL_TREE\n        if (tree == s->bl_tree) \u00e4\n            fprintf(stderr,\"\u00d6nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree\u00c4node\u00dc.Freq, n, tree\u00c4n\u00dc.Freq, m, tree\u00c4m\u00dc.Freq);\n        \u00fc\n#endif\n        /* and insert the new node in the heap */\n        s->heap\u00c4SMALLEST\u00dc = node++;\n        pqdownheap(s, tree, SMALLEST);\n\n    \u00fc while (s->heap_len >= 2);\n\n    s->heap\u00c4--(s->heap_max)\u00dc = s->heap\u00c4SMALLEST\u00dc;\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, (tree_desc *)desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes ((ct_data *)tree, max_code, s->bl_count);\n\u00fc\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nlocal void scan_tree (s, tree, max_code)\n    deflate_state *s;\n    ct_data *tree;   /* the tree to be scanned */\n    int max_code;    /* and its largest code of non zero frequency */\n\u00e4\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree\u00c40\u00dc.Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    if (nextlen == 0) max_count = 138, min_count = 3;\n    tree\u00c4max_code+1\u00dc.Len = (ush)0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) \u00e4\n        curlen = nextlen; nextlen = tree\u00c4n+1\u00dc.Len;\n        if (++count < max_count && curlen == nextlen) \u00e4\n            continue;\n        \u00fc else if (count < min_count) \u00e4\n            s->bl_tree\u00c4curlen\u00dc.Freq += count;\n        \u00fc else if (curlen |= 0) \u00e4\n            if (curlen |= prevlen) s->bl_tree\u00c4curlen\u00dc.Freq++;\n            s->bl_tree\u00c4REP_3_6\u00dc.Freq++;\n        \u00fc else if (count <= 10) \u00e4\n            s->bl_tree\u00c4REPZ_3_10\u00dc.Freq++;\n        \u00fc else \u00e4\n            s->bl_tree\u00c4REPZ_11_138\u00dc.Freq++;\n        \u00fc\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) \u00e4\n            max_count = 138, min_count = 3;\n        \u00fc else if (curlen == nextlen) \u00e4\n            max_count = 6, min_count = 3;\n        \u00fc else \u00e4\n            max_count = 7, min_count = 4;\n        \u00fc\n    \u00fc\n\u00fc\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nlocal void send_tree (s, tree, max_code)\n    deflate_state *s;\n    ct_data *tree; /* the tree to be scanned */\n    int max_code;       /* and its largest code of non zero frequency */\n\u00e4\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree\u00c40\u00dc.Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    /* tree\u00c4max_code+1\u00dc.Len = -1; */  /* guard already set */\n    if (nextlen == 0) max_count = 138, min_count = 3;\n\n    for (n = 0; n <= max_code; n++) \u00e4\n        curlen = nextlen; nextlen = tree\u00c4n+1\u00dc.Len;\n        if (++count < max_count && curlen == nextlen) \u00e4\n            continue;\n        \u00fc else if (count < min_count) \u00e4\n            do \u00e4 send_code(s, curlen, s->bl_tree); \u00fc while (--count |= 0);\n\n        \u00fc else if (curlen |= 0) \u00e4\n            if (curlen |= prevlen) \u00e4\n                send_code(s, curlen, s->bl_tree); count--;\n            \u00fc\n            Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);\n\n        \u00fc else if (count <= 10) \u00e4\n            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);\n\n        \u00fc else \u00e4\n            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);\n        \u00fc\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) \u00e4\n            max_count = 138, min_count = 3;\n        \u00fc else if (curlen == nextlen) \u00e4\n            max_count = 6, min_count = 3;\n        \u00fc else \u00e4\n            max_count = 7, min_count = 4;\n        \u00fc\n    \u00fc\n\u00fc\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nlocal int build_bl_tree(s)\n    deflate_state *s;\n\u00e4\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);\n    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, (tree_desc *)(&(s->bl_desc)));\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) \u00e4\n        if (s->bl_tree\u00c4bl_order\u00c4max_blindex\u00dc\u00dc.Len |= 0) break;\n    \u00fc\n    /* Update opt_len to include the bit length tree and counts */\n    s->opt_len += 3*(max_blindex+1) + 5+5+4;\n    Tracev((stderr, \"\u00d6ndyn trees: dyn %ld, stat %ld\",\n            s->opt_len, s->static_len));\n\n    return max_blindex;\n\u00fc\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nlocal void send_all_trees(s, lcodes, dcodes, blcodes)\n    deflate_state *s;\n    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\u00e4\n    int rank;                    /* index in bl_order */\n\n    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n            \"too many codes\");\n    Tracev((stderr, \"\u00d6nbl counts: \"));\n    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes-1,   5);\n    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) \u00e4\n        Tracev((stderr, \"\u00d6nbl code %2d \", bl_order\u00c4rank\u00dc));\n        send_bits(s, s->bl_tree\u00c4bl_order\u00c4rank\u00dc\u00dc.Len, 3);\n    \u00fc\n    Tracev((stderr, \"\u00d6nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */\n    Tracev((stderr, \"\u00d6nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */\n    Tracev((stderr, \"\u00d6ndist tree: sent %ld\", s->bits_sent));\n\u00fc\n\n/* ===========================================================================\n * Send a stored block\n */\nvoid _tr_stored_block(s, buf, stored_len, eof)\n    deflate_state *s;\n    charf *buf;       /* input block */\n    ulg stored_len;   /* length of input block */\n    int eof;          /* true if this is the last block for a file */\n\u00e4\n    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */\n#ifdef DEBUG\n    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)\u00df7L;\n    s->compressed_len += (stored_len + 4) << 3;\n#endif\n    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */\n\u00fc\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n * The current inflate code requires 9 bits of lookahead. If the\n * last two codes for the previous block (real code plus EOB) were coded\n * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\n * the last real code. In this case we send two empty static blocks instead\n * of one. (There are no problems if the previous block is stored or fixed.)\n * To simplify the code, we assume the worst case of last real code encoded\n * on one bit only.\n */\nvoid _tr_align(s)\n    deflate_state *s;\n\u00e4\n    send_bits(s, STATIC_TREES<<1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n#ifdef DEBUG\n    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */\n#endif\n    bi_flush(s);\n    /* Of the 10 bits for the empty block, we have already sent\n     * (10 - bi_valid) bits. The lookahead for the last real code (before\n     * the EOB of the previous block) was thus at least one plus the length\n     * of the EOB plus what we have just sent of the empty static block.\n     */\n    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) \u00e4\n        send_bits(s, STATIC_TREES<<1, 3);\n        send_code(s, END_BLOCK, static_ltree);\n#ifdef DEBUG\n        s->compressed_len += 10L;\n#endif\n        bi_flush(s);\n    \u00fc\n    s->last_eob_len = 7;\n\u00fc\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nvoid _tr_flush_block(s, buf, stored_len, eof)\n    deflate_state *s;\n    charf *buf;       /* input block, or NULL if too old */\n    ulg stored_len;   /* length of input block */\n    int eof;          /* true if this is the last block for a file */\n\u00e4\n    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */\n    int max_blindex = 0;  /* index of last bit length code of non zero freq */\n\n    /* Build the Huffman trees unless a stored block is forced */\n    if (s->level > 0) \u00e4\n\n\t /* Check if the file is ascii or binary */\n\tif (s->data_type == Z_UNKNOWN) set_data_type(s);\n\n\t/* Construct the literal and distance trees */\n\tbuild_tree(s, (tree_desc *)(&(s->l_desc)));\n\tTracev((stderr, \"\u00d6nlit data: dyn %ld, stat %ld\", s->opt_len,\n\t\ts->static_len));\n\n\tbuild_tree(s, (tree_desc *)(&(s->d_desc)));\n\tTracev((stderr, \"\u00d6ndist data: dyn %ld, stat %ld\", s->opt_len,\n\t\ts->static_len));\n\t/* At this point, opt_len and static_len are the total bit lengths of\n\t * the compressed block data, excluding the tree representations.\n\t */\n\n\t/* Build the bit length tree for the above two trees, and get the index\n\t * in bl_order of the last bit length code to send.\n\t */\n\tmax_blindex = build_bl_tree(s);\n\n\t/* Determine the best encoding. Compute first the block length in bytes*/\n\topt_lenb = (s->opt_len+3+7)>>3;\n\tstatic_lenb = (s->static_len+3+7)>>3;\n\n\tTracev((stderr, \"\u00d6nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n\t\topt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n\t\ts->last_lit));\n\n\tif (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n\n    \u00fc else \u00e4\n        Assert(buf |= (char*)0, \"lost buf\");\n\topt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n    \u00fc\n\n#ifdef FORCE_STORED\n    if (buf |= (char*)0) \u00e4 /* force stored block */\n#else\n    if (stored_len+4 <= opt_lenb && buf |= (char*)0) \u00e4\n                       /* 4: two words for the lengths */\n#endif\n        /* The test buf |= NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, eof);\n\n#ifdef FORCE_STATIC\n    \u00fc else if (static_lenb >= 0) \u00e4 /* force static trees */\n#else\n    \u00fc else if (static_lenb == opt_lenb) \u00e4\n#endif\n        send_bits(s, (STATIC_TREES<<1)+eof, 3);\n        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);\n#ifdef DEBUG\n        s->compressed_len += 3 + s->static_len;\n#endif\n    \u00fc else \u00e4\n        send_bits(s, (DYN_TREES<<1)+eof, 3);\n        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,\n                       max_blindex+1);\n        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);\n#ifdef DEBUG\n        s->compressed_len += 3 + s->opt_len;\n#endif\n    \u00fc\n    Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2\u00ac32, for files larger than 512 MB\n     * and uLong implemented on 32 bits.\n     */\n    init_block(s);\n\n    if (eof) \u00e4\n        bi_windup(s);\n#ifdef DEBUG\n        s->compressed_len += 7;  /* align on byte boundary */\n#endif\n    \u00fc\n    Tracev((stderr,\"\u00d6ncomprlen %lu(%lu) \", s->compressed_len>>3,\n           s->compressed_len-7*eof));\n\u00fc\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nint _tr_tally (s, dist, lc)\n    deflate_state *s;\n    unsigned dist;  /* distance of matched string */\n    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\u00e4\n    s->d_buf\u00c4s->last_lit\u00dc = (ush)dist;\n    s->l_buf\u00c4s->last_lit++\u00dc = (uch)lc;\n    if (dist == 0) \u00e4\n        /* lc is the unmatched char */\n        s->dyn_ltree\u00c4lc\u00dc.Freq++;\n    \u00fc else \u00e4\n        s->matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;             /* dist = match distance - 1 */\n        Assert((ush)dist < (ush)MAX_DIST(s) &&\n               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n               (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s->dyn_ltree\u00c4_length_code\u00c4lc\u00dc+LITERALS+1\u00dc.Freq++;\n        s->dyn_dtree\u00c4d_code(dist)\u00dc.Freq++;\n    \u00fc\n\n#ifdef TRUNCATE_BLOCK\n    /* Try to guess if it is profitable to stop the current block here */\n    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) \u00e4\n        /* Compute an upper bound for the compressed length */\n        ulg out_length = (ulg)s->last_lit*8L;\n        ulg in_length = (ulg)((long)s->strstart - s->block_start);\n        int dcode;\n        for (dcode = 0; dcode < D_CODES; dcode++) \u00e4\n            out_length += (ulg)s->dyn_dtree\u00c4dcode\u00dc.Freq *\n                (5L+extra_dbits\u00c4dcode\u00dc);\n        \u00fc\n        out_length >>= 3;\n        Tracev((stderr,\"\u00d6nlast_lit %u, in %ld, out \u00df%ld(%ld%%) \",\n               s->last_lit, in_length, out_length,\n               100L - out_length*100L/in_length));\n        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;\n    \u00fc\n#endif\n    return (s->last_lit == s->lit_bufsize-1);\n    /* We avoid equality with lit_bufsize because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n\u00fc\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nlocal void compress_block(s, ltree, dtree)\n    deflate_state *s;\n    ct_data *ltree; /* literal tree */\n    ct_data *dtree; /* distance tree */\n\u00e4\n    unsigned dist;      /* distance of matched string */\n    int lc;             /* match length or unmatched char (if dist == 0) */\n    unsigned lx = 0;    /* running index in l_buf */\n    unsigned code;      /* the code to send */\n    int extra;          /* number of extra bits to send */\n\n    if (s->last_lit |= 0) do \u00e4\n        dist = s->d_buf\u00c4lx\u00dc;\n        lc = s->l_buf\u00c4lx++\u00dc;\n        if (dist == 0) \u00e4\n            send_code(s, lc, ltree); /* send a literal byte */\n            Tracecv(i_isgraph(lc), (stderr,\" '%c' \", lc));\n        \u00fc else \u00e4\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code\u00c4lc\u00dc;\n            send_code(s, code+LITERALS+1, ltree); /* send the length code */\n            extra = extra_lbits\u00c4code\u00dc;\n            if (extra |= 0) \u00e4\n                lc -= base_length\u00c4code\u00dc;\n                send_bits(s, lc, extra);       /* send the extra length bits */\n            \u00fc\n            dist--; /* dist is now the match distance - 1 */\n            code = d_code(dist);\n            Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);       /* send the distance code */\n            extra = extra_dbits\u00c4code\u00dc;\n            if (extra |= 0) \u00e4\n                dist -= base_dist\u00c4code\u00dc;\n                send_bits(s, dist, extra);   /* send the extra distance bits */\n            \u00fc\n        \u00fc /* literal or match pair ? */\n\n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n        Assert(s->pending < s->lit_bufsize + 2*lx, \"pendingBuf overflow\");\n\n    \u00fc while (lx < s->last_lit);\n\n    send_code(s, END_BLOCK, ltree);\n    s->last_eob_len = ltree\u00c4END_BLOCK\u00dc.Len;\n\u00fc\n\n/* ===========================================================================\n * Set the data type to ASCII or BINARY, using a crude approximation:\n * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.\n * IN assertion: the fields freq of dyn_ltree are set and the total of all\n * frequencies does not exceed 64K (to fit in an int on 16 bit machines).\n */\nlocal void set_data_type(s)\n    deflate_state *s;\n\u00e4\n    int n = 0;\n    unsigned ascii_freq = 0;\n    unsigned bin_freq = 0;\n    while (n < 7)        bin_freq += s->dyn_ltree\u00c4n++\u00dc.Freq;\n    while (n < 128)    ascii_freq += s->dyn_ltree\u00c4n++\u00dc.Freq;\n    while (n < LITERALS) bin_freq += s->dyn_ltree\u00c4n++\u00dc.Freq;\n    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);\n\u00fc\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nlocal unsigned bi_reverse(code, len)\n    unsigned code; /* the value to invert */\n    int len;       /* its bit length */\n\u00e4\n    register unsigned res = 0;\n    do \u00e4\n        res ]= code & 1;\n        code >>= 1, res <<= 1;\n    \u00fc while (--len > 0);\n    return res >> 1;\n\u00fc\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nlocal void bi_flush(s)\n    deflate_state *s;\n\u00e4\n    if (s->bi_valid == 16) \u00e4\n        put_short(s, s->bi_buf);\n        s->bi_buf = 0;\n        s->bi_valid = 0;\n    \u00fc else if (s->bi_valid >= 8) \u00e4\n        put_byte(s, (Byte)s->bi_buf);\n        s->bi_buf >>= 8;\n        s->bi_valid -= 8;\n    \u00fc\n\u00fc\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nlocal void bi_windup(s)\n    deflate_state *s;\n\u00e4\n    if (s->bi_valid > 8) \u00e4\n        put_short(s, s->bi_buf);\n    \u00fc else if (s->bi_valid > 0) \u00e4\n        put_byte(s, (Byte)s->bi_buf);\n    \u00fc\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n#ifdef DEBUG\n    s->bits_sent = (s->bits_sent+7) & \u00df7;\n#endif\n\u00fc\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nlocal void copy_block(s, buf, len, header)\n    deflate_state *s;\n    charf    *buf;    /* the input data */\n    unsigned len;     /* its length */\n    int      header;  /* true if block header must be written */\n\u00e4\n    bi_windup(s);        /* align on byte boundary */\n    s->last_eob_len = 8; /* enough lookahead for inflate */\n\n    if (header) \u00e4\n        put_short(s, (ush)len);\n        put_short(s, (ush)\u00dflen);\n#ifdef DEBUG\n        s->bits_sent += 2*16;\n#endif\n    \u00fc\n#ifdef DEBUG\n    s->bits_sent += (ulg)len<<3;\n#endif\n    while (len--) \u00e4\n        put_byte(s, *buf++);\n    \u00fc\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNCOMPR": {"ttr": 1379, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* uncompr.c -- decompress a memory buffer\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* \u00a7(#) $Id: uncompr.c,v 1.2 2003/09/11 11:16:22 matthiasw Exp $ */\n\n#include \"zlib.h\"\n\n/* ===========================================================================\n     Decompresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer. Upon entry, destLen is the total\n   size of the destination buffer, which must be large enough to hold the\n   entire uncompressed data. (The size of the uncompressed data must have\n   been saved previously by the compressor and transmitted to the decompressor\n   by some mechanism outside the scope of this compression library.)\n   Upon exit, destLen is the actual size of the compressed buffer.\n     This function can be used to decompress a whole file at once if the\n   input file is mmap'ed.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer, or Z_DATA_ERROR if the input data was corrupted.\n*/\nint ZEXPORT uncompress (dest, destLen, source, sourceLen)\n    Bytef *dest;\n    uLongf *destLen;\n    const Bytef *source;\n    uLong sourceLen;\n\u00e4\n    z_stream stream;\n    int err;\n\n    stream.next_in = (Bytef*)source;\n    stream.avail_in = (uInt)sourceLen;\n    /* Check for source > 64K on 16-bit machine: */\n    if ((uLong)stream.avail_in |= sourceLen) return Z_BUF_ERROR;\n\n    stream.next_out = dest;\n    stream.avail_out = (uInt)*destLen;\n    if ((uLong)stream.avail_out |= *destLen) return Z_BUF_ERROR;\n\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n\n    err = inflateInit(&stream);\n    if (err |= Z_OK) return err;\n\n    err = inflate(&stream, Z_FINISH);\n    if (err |= Z_STREAM_END) \u00e4\n        inflateEnd(&stream);\n        return err == Z_OK ? Z_BUF_ERROR : err;\n    \u00fc\n    *destLen = stream.total_out;\n\n    err = inflateEnd(&stream);\n    return err;\n\u00fc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZUTIL": {"ttr": 1381, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* zutil.c -- target dependent utility functions for the compression library\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* \u00a7(#) $Id: zutil.c,v 1.2 2003/09/11 11:16:22 matthiasw Exp $ */\n\n#include \"zutil.h\"\n\nstruct internal_state      \u00e4int dummy;\u00fc; /* for buggy compilers */\n\n#ifndef STDC\nextern void exit OF((int));\n#endif\n\nconst char *z_errmsg\u00c410\u00dc = \u00e4\n\"need dictionary\",     /* Z_NEED_DICT       2  */\n\"stream end\",          /* Z_STREAM_END      1  */\n\"\",                    /* Z_OK              0  */\n\"file error\",          /* Z_ERRNO         (-1) */\n\"stream error\",        /* Z_STREAM_ERROR  (-2) */\n\"data error\",          /* Z_DATA_ERROR    (-3) */\n\"insufficient memory\", /* Z_MEM_ERROR     (-4) */\n\"buffer error\",        /* Z_BUF_ERROR     (-5) */\n\"incompatible version\",/* Z_VERSION_ERROR (-6) */\n\"\"\u00fc;\n\n\nconst char * ZEXPORT zlibVersion()\n\u00e4\n    return ZLIB_VERSION;\n\u00fc\n\n#ifdef DEBUG\n\n#  ifndef verbose\n#    define verbose 0\n#  endif\nint z_verbose = verbose;\n\nvoid z_error (m)\n    char *m;\n\u00e4\n    fprintf(stderr, \"%s\u00d6n\", m);\n    exit(1);\n\u00fc\n#endif\n\n/* exported to allow conversion of error code to string for compress() and\n * uncompress()\n */\nconst char * ZEXPORT zError(err)\n    int err;\n\u00e4\n    return ERR_MSG(err);\n\u00fc\n\n\n#ifndef HAVE_MEMCPY\n\nvoid zmemcpy(dest, source, len)\n    Bytef* dest;\n    const Bytef* source;\n    uInt  len;\n\u00e4\n    if (len == 0) return;\n    do \u00e4\n        *dest++ = *source++; /* ??? to be unrolled */\n    \u00fc while (--len |= 0);\n\u00fc\n\nint zmemcmp(s1, s2, len)\n    const Bytef* s1;\n    const Bytef* s2;\n    uInt  len;\n\u00e4\n    uInt j;\n\n    for (j = 0; j < len; j++) \u00e4\n        if (s1\u00c4j\u00dc |= s2\u00c4j\u00dc) return 2*(s1\u00c4j\u00dc > s2\u00c4j\u00dc)-1;\n    \u00fc\n    return 0;\n\u00fc\n\nvoid zmemzero(dest, len)\n    Bytef* dest;\n    uInt  len;\n\u00e4\n    if (len == 0) return;\n    do \u00e4\n        *dest++ = 0;  /* ??? to be unrolled */\n    \u00fc while (--len |= 0);\n\u00fc\n#endif\n\n#ifdef __TURBOC__\n#if (defined( __BORLANDC__) ]] |defined(SMALL_MEDIUM)) && |defined(__32BIT__)\n/* Small and medium model in Turbo C are for now limited to near allocation\n * with reduced MAX_WBITS and MAX_MEM_LEVEL\n */\n#  define MY_ZCALLOC\n\n/* Turbo C malloc() does not allow dynamic allocation of 64K bytes\n * and farmalloc(64K) returns a pointer with an offset of 8, so we\n * must fix the pointer. Warning: the pointer must be put back to its\n * original form in order to free it, use zcfree().\n */\n\n#define MAX_PTR 10\n/* 10*64K = 640K */\n\nlocal int next_ptr = 0;\n\ntypedef struct ptr_table_s \u00e4\n    voidpf org_ptr;\n    voidpf new_ptr;\n\u00fc ptr_table;\n\nlocal ptr_table table\u00c4MAX_PTR\u00dc;\n/* This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n */\n\nvoidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n\u00e4\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) \u00e4\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf |= 0) return buf;\n    \u00fc else \u00e4\n        buf = farmalloc(bsize + 16L);\n    \u00fc\n    if (buf == NULL ]] next_ptr >= MAX_PTR) return NULL;\n    table\u00c4next_ptr\u00dc.org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table\u00c4next_ptr++\u00dc.new_ptr = buf;\n    return buf;\n\u00fc\n\nvoid  zcfree (voidpf opaque, voidpf ptr)\n\u00e4\n    int n;\n    if (*(ush*)&ptr |= 0) \u00e4 /* object < 64K */\n        farfree(ptr);\n        return;\n    \u00fc\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) \u00e4\n        if (ptr |= table\u00c4n\u00dc.new_ptr) continue;\n\n        farfree(table\u00c4n\u00dc.org_ptr);\n        while (++n < next_ptr) \u00e4\n            table\u00c4n-1\u00dc = table\u00c4n\u00dc;\n        \u00fc\n        next_ptr--;\n        return;\n    \u00fc\n    ptr = opaque; /* just to make some compilers happy */\n    Assert(0, \"zcfree: ptr not found\");\n\u00fc\n#endif\n#endif /* __TURBOC__ */\n\n\n#if defined(M_I86) && |defined(__32BIT__)\n/* Microsoft C in 16-bit mode */\n\n#  define MY_ZCALLOC\n\n#if (|defined(_MSC_VER) ]] (_MSC_VER <= 600))\n#  define _halloc  halloc\n#  define _hfree   hfree\n#endif\n\nvoidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n\u00e4\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n\u00fc\n\nvoid  zcfree (voidpf opaque, voidpf ptr)\n\u00e4\n    if (opaque) opaque = 0; /* to make compiler happy */\n    _hfree(ptr);\n\u00fc\n\n#endif /* MSC */\n\n\n#ifndef MY_ZCALLOC /* Any system without a special alloc function */\n\n#ifndef STDC\nextern voidp  calloc OF((uInt items, uInt size));\nextern void   free   OF((voidpf ptr));\n#endif\n\nvoidpf zcalloc (opaque, items, size)\n    voidpf opaque;\n    unsigned items;\n    unsigned size;\n\u00e4\n    if (opaque) items += size - size; /* make compiler happy */\n    return (voidpf)calloc(items, size);\n\u00fc\n\nvoid  zcfree (opaque, ptr)\n    voidpf opaque;\n    voidpf ptr;\n\u00e4\n    free(ptr);\n    if (opaque) return; /* make compiler happy */\n\u00fc\n\n#endif /* MY_ZCALLOC */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT880/CBT.V500.FILE880.PDS/CPP.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT880/CBT.V500.FILE880.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}