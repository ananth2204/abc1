{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "ESA", "INMTNODE": "JES2P390", "INMTUID": "ESA", "INMFTIME": "20121130073653000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1155481, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "ESA.PRJ.CBTDSSN.PPONLY", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1155481, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1155481, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ESA.PRJ.CBTDSSN.PPONLY": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"DSSDB": {"ttr": 167, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "??=pragma filetag(\"IBM-273\")\n??=pragma nomargins nosequence\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass mERROR;\n\nclass mERRORPSTACK \u00e4\nprivate:\n   long int ip;\n   long int max;\n   mERROR * * sp;\npublic:\n   mERRORPSTACK(long int size=256);\n   void push(mERROR * value);\n   mERROR * examine();\n   int    callNextHandler(int);\n   mERROR * pop();\n   void  reset();\n  \u00dfmERRORPSTACK();\n\n\u00fc;\n\n\nclass mERROR\n\u00e4\nprotected:\n   char err;\n   int (* handler)(int);\nenum ERROR_ACTION\u00e4Warning, Abort\u00fc;\npublic:\n\nstatic int max_rc;\n\nfriend class mERRORPSTACK;\n   mERROR();\n   mERROR(int (*)(int) );\n\t virtual \u00dfmERROR()\u00e4\u00fc;\n   long int iserror()\u00e4return err;\u00fc\n   int  markerror(int code = 1)\n   \u00e4\n    err = 1;\n    if (handler) return (handler(code));\n    else return 0;\n   \u00fc\n   void clearerror()\u00e4err = 0;\u00fc\n   void setmERRORHandler(int (*h)(int))\u00e4handler = h;\u00fc\n   int error(char *,ERROR_ACTION);\n\u00fc;\n\nextern mERRORPSTACK mErrorPStack;\n\n\n\n\n\n\n\n\n\n\n\n\nextern \"C\"\nchar * genOpenName(const char *name, char *nm);\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n  extern \"C\" \u00e4\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\nextern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n   extern \"C\" \u00e4\n\n   typedef  int ptrdiff_t;\n\n       typedef unsigned int size_t;\n\n\n\n\n\n   \u00fc\n\n                   #pragma checkout(resume)\n\n  extern \"C\" \u00e4\n\n\n\n\n\n        extern \"builtin\"\n\n        int     __clcl (void*, void*, unsigned int*,\n                        unsigned int*, unsigned char);\n\n\n\n\n        extern \"builtin\"\n\n        int     __stck (unsigned long long *);\n\n\n\n\n        extern \"builtin\"\n\n        int     __stcke (void *);\n\n\n\n\n        #pragma pack (1)\n\n          typedef struct __stcke_tod \u00e4\n            unsigned char      c;\n            unsigned long long slice;\n            unsigned int       i;\n          \u00fc __stcke_tod_t;\n\n          typedef struct __stcke_tag \u00e4\n            unsigned char  zeros;\n            __stcke_tod_t  tod;\n            unsigned short p_field;\n          \u00fc __stcke_t;\n        #pragma pack (reset)\n\n\n\n\n\n        extern \"builtin\" \u00e4\n\n        void  __tr (unsigned char*, const unsigned char*,              \u00d6\n       unsigned char);\n\n      \u00fc\n\n        extern \"builtin\" \u00e4\n\n        int  __ed (unsigned char*, unsigned char*, unsigned char);\n        int  __edmk (unsigned char*, unsigned char*,                   \u00d6\n   unsigned char, unsigned char**);\n        int  __trt (unsigned char*, const unsigned char*,              \u00d6\n       unsigned char, unsigned char*, unsigned char**);\n        int  __nc (unsigned char*, unsigned char*, unsigned char);\n        int  __oc (unsigned char*, unsigned char*, unsigned char);\n        int  __xc (unsigned char*, unsigned char*, unsigned char);\n        void __pack (unsigned char*, unsigned char,                    \u00d6\n  unsigned char*, unsigned char);\n        void __unpk (unsigned char*, unsigned char,                    \u00d6\n  unsigned char*, unsigned char);\n\n      \u00fc\n\n        long double  __fmaddl (long double, long double, long double);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int    __lper (float*, float);\n        int    __lpdr (double*, double);\n        int    __lner (float*, float);\n        int    __lndr (double*, double);\n        float  __sqer (float);\n        double __sqdr (double);\n\n      \u00fc\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        float       __fier (float);\n        double      __fidr (double);\n        long double __fixr (long double);\n        int         __cfer (int*, int, float);\n        int         __cfdr (int*, int, double);\n        int         __cfxr (int*, int, long double);\n        int         __lpxr (long double*, long double);\n        int         __lnxr (long double*, long double);\n        long double __sqxr (long double);\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int __thder (double*, float);\n        int __thdr  (double*, double);\n        int __tbedr (float*, int, double);\n        int __tbdr  (double*, int, double);\n\n      \u00fc\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        unsigned short __lrvh  (unsigned short*);\n        unsigned int   __lrv   (unsigned int*);\n        void  __strvh (unsigned short, unsigned short*);\n        void  __strv  (unsigned int, unsigned int*);\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int  __cvb(char *op2);\n        void __cvd(int op1, char *op2);\n        int  __zap(unsigned char *op1, unsigned char len1,\n                   unsigned char *op2, unsigned char len2);\n\n\n\n\n\n          int __clcle(char *op1, unsigned long op1_len, unsigned char o\u00d6\np2,\n                      char *op3, unsigned long op3_len);\n          int __mvcle(char *op1, unsigned long op1_len, unsigned char o\u00d6\np2,\n                      char *op3, unsigned long op3_len);\n\n\n\n\n\n          int __tre(char *op1, unsigned long op1_len,\n                    char *op2, unsigned char test_char);\n\n\n            long long __cvbg(char *op2);\n            void      __cvdg(long long op1, char *op2);\n\n\n\n\n\n\n\n\n\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        typedef union \u00e4\n            struct __dword \u00e4\n                unsigned int __high_word;\n                unsigned int __low_word;\n            \u00fc __s_dword;\n            unsigned long long __dword;\n        \u00fc __plo_entry_t;\n\n        typedef union \u00e4\n            unsigned long long   __val;\n            unsigned long long * __ptr;\n        \u00fc __plo_ull_ullptr_t;\n\n        typedef union \u00e4\n            unsigned int       * __uint_ptr;\n            unsigned long long * __ull_ptr;\n        \u00fc __plo_uintptr_ullptr_t;\n\n        typedef __plo_ull_ullptr_t __plo_plist\u00c418\u00dc;\n\n\n\n\n\n\n\n          extern \"builtin\" \u00e4\n\n          int __plo_CL     (void *lock,\n                            unsigned int *op1c, unsigned int *op2,\n                            unsigned int *op3, unsigned int *op4);\n          int __plo_CS     (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2);\n          int __plo_DCS    (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2,\n                            unsigned int *op3c, unsigned int op3r,\n                            unsigned int *op4);\n          int __plo_CSST   (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2,\n                            unsigned int op3, unsigned int *op4);\n          int __plo_CSDST  (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2, void *param_list);\n          int __plo_CSTST  (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2, void *param_list);\n\n        \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n    typedef struct __div_t\n      \u00e4\n      int quot;\n      int rem;\n      \u00fc div_t;\n\n    typedef struct __ldiv_t\n      \u00e4\n      long int quot;\n      long int rem;\n      \u00fc ldiv_t;\n\n   typedef struct \u00e4\n               long long quot;\n               long long rem;\n   \u00fc lldiv_t;\n\n       typedef struct \u00e4\n                 long  __uheap_size;\n                 long  __uheap_bytes_alloc;\n                 long  __uheap_bytes_free;\n       \u00fc hreport_t;\n\n\n\n\n\n      extern \"builtin\"\n      void **_Gtab(int);\n\n      extern \"builtin\"\n      const void *_gtca(void);\n\n\n\n\n\n\n\n\n      long long int strtoll(const char * restrict, char * * restrict, i\u00d6\nnt);\n      unsigned long long int strtoull(const char * restrict, char * * r\u00d6\nestrict, int);\n        #pragma map (strtoll,   \"\u00d6174\u00d6174STRLL\")\n        #pragma map (strtoull,  \"\u00d6174\u00d6174STRULL\")\n\n    double   atof (const char *);\n    int      atoi (const char *);\n    long int atol (const char *);\n    double   strtod (const char * restrict, char * * restrict);\n    long int strtol (const char * restrict, char * * restrict,\n                      int);\n    unsigned long int strtoul (const char * restrict,\n                                char * * restrict, int);\n    int      rand (void);\n    void     srand (unsigned int);\n        long long int strtoll (const char * restrict,\n                                char * * restrict, int);\n        unsigned long long int strtoull (const char * restrict,\n                                          char * * restrict, int);\n\n\n\n\n      void *   calloc (size_t, size_t);\n      void     free (void *);\n      void *   malloc (size_t);\n      void *   realloc (void *, size_t);\n\n\n\n    extern \"builtin\"\n    int       __abs (int);\n\n\n\n     #pragma map (__getenv,        \"\u00d6174\u00d6174GETENV\")\n\n\n\n    void     abort (void);\n    int      atexit (void (*)(void));\n    void     exit (int);\n    char *   getenv (const char *);\n    char *   __getenv (const char *);\n    int      system (const char *);\n    void *   bsearch (const void *, const void *,\n                      size_t, size_t,\n                      int (*)(const void *,\n                                    const void *));\n    void     qsort (void *, size_t, size_t,\n                    int (*)(const void *,\n                                  const void *));\n\n    int unatexit(void (*)(void));\n\n\n        int      __heaprpt(hreport_t *);\n\n    extern \"C++\" \u00e4\n      inline int abs (int x) \u00e4 return __abs(x); \u00fc\n    \u00fc\n\n\n\n\n\n\n    div_t    div (int, int);\n    long int labs (long int);\n    ldiv_t   ldiv (long int, long int);\n    int      mblen (const char *, size_t);\n    int      mbtowc (wchar_t * restrict,\n                      const char * restrict, size_t);\n    int      wctomb (char *, wchar_t);\n    size_t   mbstowcs (wchar_t * restrict,\n                        const char * restrict, size_t);\n    size_t   wcstombs (char * restrict,\n                        const wchar_t * restrict, size_t);\n\n\n      long long llabs(long long );\n      lldiv_t lldiv(long long , long long );\n\n\n\n\n\n\n\n\n\n\n\n      void (*  fetch (const char *))();\n      void (*  fetchep (void (*)()))();\n      int    release (void (*)());\n\n\n        inline int fortrc (void)\n          \u00e4  return (*( (int *)((char *)_gtca() + 568) ))/4; \u00fc\n\n\n\n      #pragma map (rpmatch, \"\u00d6174\u00d6174RPMTCH\")\n      #pragma map (csid,    \"\u00d6174\u00d6174CSID\")\n      #pragma map (wcsid,   \"\u00d6174\u00d6174WCSID\")\n\n      int __librel (void);\n        int clearenv (void);\n      int rpmatch(const char *);\n      int csid(const char *);\n      int wcsid(const wchar_t);\n\n\n      typedef unsigned int cs_t;\n\n      typedef union \u00e4\n        struct \u00e4\n          unsigned int first_word;\n          unsigned int second_word;\n        \u00fc double_word;\n        double alignment_dummy;\n      \u00fc cds_t;\n\n        extern \"builtin\"\n\n      int     __cs (cs_t *, cs_t *, cs_t);\n      int     (cs) (cs_t *, cs_t *, cs_t);\n\n        extern \"builtin\"\n\n        int     __cs1 (void *, void *, void *);\n\n\n\n\n        extern \"builtin\"\n\n      int     __cds (cds_t *, cds_t *, cds_t);\n      int     (cds) (cds_t *, cds_t *, cds_t);\n\n        extern \"builtin\"\n\n        int     __cds1 (void *, void *, void *);\n\n\n\n\n\n\n\n\n\n\n\n\n    #pragma map(__EnvnA, \"\u00d6174\u00d6174ENVNA\")\n\n    char *** __EnvnA(void);\n    char *** __Envn(void);\n\n\n\n\n\n\n\n\n            extern \"builtin\"\n            void *__alloca(unsigned int x);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        double       drand48(void);\n        double       erand48(unsigned short int \u00c43\u00dc);\n        long int     jrand48(unsigned short int \u00c43\u00dc);\n        void         lcong48(unsigned short int \u00c47\u00dc);\n        long int     lrand48(void);\n        long int     mrand48(void);\n        long int     nrand48(unsigned short int \u00c43\u00dc);\n          int          putenv(const char *);\n        unsigned short int  *seed48(unsigned short int \u00c43\u00dc);\n        void         srand48(long int);\n          void         setkey(const char *);\n\n\n\n\n\n\n\n\n\n\n        long         a64l(const char *);\n        char        *ecvt(double, int, int * restrict,\n                                       int * restrict);\n        char        *fcvt(double, int, int * restrict,\n                                       int * restrict);\n        char        *gcvt(double, int, char *);\n        int          getsubopt(char **, char *const *, char **);\n        char        *initstate(unsigned, char *, size_t);\n        char        *l64a(long);\n        int          mkstemp(char *);\n        char        *mktemp(char *);\n        long         random(void);\n        char        *realpath(const char * restrict,\n                                    char * restrict);\n        char        *setstate(const char *);\n        void         srandom(unsigned);\n           int          ttyslot(void);\n           void        *valloc(size_t);\n          int          grantpt(int);\n          char        *ptsname(int);\n          int          unlockpt(int);\n\n\n\n\n       int rand_r(unsigned int *);\n\n\n\n\n    int __discarddata(void *, size_t);\n\n\n\n          int setenv (const char *, const char *, int);\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n\n  extern \"C++\" \u00e4\n        inline long abs (long x) \u00e4 return labs(x); \u00fc\n        inline ldiv_t div (long x, long y)\n        \u00e4 return ldiv(x,y); \u00fc\n  \u00fc\n\n\n                   #pragma checkout(resume)\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n          typedef unsigned int dev_t ;\n\n\n\n\n             typedef int gid_t;\n\n\n\n\n          typedef unsigned int  ino_t ;\n\n\n\n          typedef int mode_t ;\n\n\n\n\n          typedef int nlink_t ;\n\n\n\n\n\n            typedef  int off_t ;\n\n\n           typedef long long off64_t;\n\n\n          typedef signed int pid_t ;\n\n\n\n\n            typedef signed int ssize_t ;\n\n\n\n\n             typedef int uid_t;\n\n\n\n\n\n\n\n          typedef long time_t ;\n\n\n\n          typedef unsigned long clock_t;\n\n\n\n          typedef struct \u00e4\n                     unsigned int   __sigs_0;\n                     unsigned int   __sigs_1;\n                  \u00fc sigset_t ;\n\n\n\n          typedef unsigned char cc_t;\n\n\n\n          typedef unsigned int speed_t ;\n\n\n\n          typedef unsigned int tcflag_t ;\n\n\n\n\n\n\n\n          typedef unsigned int mtm_t ;\n\n\n\n\n          typedef unsigned int rdev_t ;\n\n\n\n\n          typedef char tid_t\u00c48\u00dc;\n\n\n            typedef struct \u00e4\n                      char __\u00c40x08\u00dc;\n            \u00fc __osenv_token;\n\n\n\n\n\n\n\n          typedef struct \u00e4\n                     char __\u00c40x08\u00dc;\n          \u00fc pthread_t;\n\n          typedef  struct \u00e4\n                      char __\u00c40x58\u00dc;\n          \u00fc pthread_attr_t;\n\n             typedef struct \u00e4\n                        unsigned long __m;\n             \u00fc pthread_mutex_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_mutexattr_t;\n\n                typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n                \u00fc pthread_cond_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_condattr_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_key_t;\n\n          typedef int pthread_once_t;\n\n             typedef struct \u00e4\n                        char __\u00c40x04\u00dc;\n              \u00fc pthread_rwlockattr_t;\n\n             typedef struct \u00e4\n                        char __\u00c40x04\u00dc;\n              \u00fc pthread_rwlock_t;\n\n\n\n\n\n\n\n         typedef long key_t;\n\n\n\n\n\n\n\n         typedef int id_t;\n\n         typedef unsigned int  useconds_t;\n\n\n         typedef unsigned char sa_family_t;\n\n\n\n         typedef unsigned short in_port_t;\n\n\n            typedef long mcontext_t\u00c440\u00dc;\n\n\n\n\n\n          typedef  unsigned char  u_char;\n\n          typedef  unsigned int   u_int;\n\n          typedef  unsigned short ushort;\n\n          typedef  unsigned short u_short;\n\n          typedef  unsigned long  u_long;\n\n\n\n\n\n         typedef unsigned long in_addr_t;\n\n         typedef in_addr_t ip_addr_t;\n\n\n         typedef  char *    caddr_t;\n\n\n\n\n\n\n         typedef signed long blkcnt_t;\n\n         typedef signed int    blksize_t;\n\n         typedef unsigned long fsblkcnt_t;\n\n         typedef unsigned int  fsfilcnt_t;\n\n\n         typedef signed int    suseconds_t;\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n     struct __file;\n     typedef int _GETCFUNC(struct __file *);\n     typedef int _PUTCFUNC(int, struct __file *);\n     struct __file\n        \u00e4\n        unsigned char  *__bufPtr;\n        long int        __countIn;\n        long int        __countOut;\n        _GETCFUNC      *__fcbgetc;\n        _PUTCFUNC      *__fcbputc;\n        unsigned int    __cntlinterpret : 1;\n        unsigned int    __fcb_ascii : 1;\n        unsigned int    __fcb_orientation : 2;\n        \u00fc;\n\n     struct __ffile\n       \u00e4\n       struct __file *__fp;\n       \u00fc;\n\n     typedef struct __ffile *__FILEP;\n\n\n     typedef struct __ffile FILE;\n\n  struct __fpos_t \u00e4\n    long int __fpos_elem\u00c48\u00dc;\n    \u00fc;\n\n  typedef struct __fpos_t fpos_t;\n\n\n\n\n\n\n      typedef char  *___valist;\n    typedef ___valist  va_list;\n\n\n\n\n\n\n\n\n\n\n     typedef const unsigned short *__cusp;\n\n\n\n\n\n\n\n\n\n      #pragma map (vprintf, \"\u00d6174\u00d6174VPRNT\")\n      #pragma map (vfprintf, \"\u00d6174\u00d6174VFPRT\")\n        #pragma map (vsprintf, \"\u00d6174\u00d6174VSPRT\")\n\n\n\n\n    void     clearerr (FILE *);\n    int      fclose (FILE *);\n    int      feof (FILE *);\n    int      ferror (FILE *);\n    int      fflush (FILE *);\n    int      fgetc (FILE *);\n    int      fgetpos (FILE * restrict, fpos_t * restrict);\n    char    *fgets (char * restrict, int, FILE * restrict);\n    FILE    *fopen (const char * restrict,\n                    const char * restrict);\n    int      fprintf (FILE * restrict,\n                       const char * restrict, ...);\n    int      fputc (int, FILE *);\n    int      fputs (const char * restrict, FILE * restrict);\n    size_t   fread (void * restrict, size_t,\n                    size_t, FILE * restrict);\n    FILE    *freopen (const char * restrict,\n                      const char * restrict, FILE * restrict);\n    int      fscanf (FILE * restrict,\n                      const char * restrict, ...);\n    int      fseek (FILE *, long int, int);\n    int      fsetpos (FILE *, const fpos_t *);\n    long int ftell (FILE *);\n   size_t   fwrite (const void * restrict, size_t, size_t,\n                     FILE * restrict);\n    int      getc (FILE *);\n    int      getchar (void);\n    char    *gets (char *);\n    void     perror (const char *);\n    int      printf (const char * restrict, ...);\n    int      putc (int, FILE *);\n    int      putchar (int);\n    int      puts (const char *);\n    int      remove (const char *);\n    int      rename (const char *, const char *);\n    void     rewind (FILE *);\n    int      scanf (const char * restrict, ...);\n    void     setbuf (FILE * restrict, char * restrict);\n    int      setvbuf (FILE * restrict, char * restrict,\n                      int, size_t);\n      int      sprintf (char * restrict,\n                         const char * restrict, ...);\n    int      sscanf (const char * restrict,\n                     const char * restrict, ...);\n    FILE    *tmpfile (void);\n    char    *tmpnam (char *);\n    int      ungetc (int, FILE *);\n    int      vfprintf (FILE * restrict,\n                        const char * restrict, ___valist);\n    int      vprintf (const char * restrict, ___valist);\n    int      vsprintf (char * restrict,\n                        const char * restrict, ___valist);\n\n\n         off_t ftello(FILE *);\n         int fseeko(FILE *, off_t, int);\n\n\n\n\n\n\n\n\n      struct __S99struc\n        \u00e4\n             unsigned char __S99RBLN;\n             unsigned char __S99VERB;\n             unsigned short __S99FLAG1;\n             unsigned short __S99ERROR;\n             unsigned short __S99INFO;\n             void *__S99TXTPP;\n             void *__S99S99X;\n             unsigned int   __S99FLAG2;\n        \u00fc;\n\n      typedef struct __S99struc __S99parms;\n\n\n    struct __S99rbx\n          \u00e4\n        char           __S99EID\u00c46\u00dc;\n        unsigned char  __S99EVER;\n        unsigned char  __S99EOPTS;\n        unsigned char  __S99ESUBP;\n        unsigned char  __S99EKEY;\n        unsigned char  __S99EMGSV;\n        unsigned char  __S99ENMSG;\n        void *__S99ECPPL;\n        char           __reserved;\n        char           __S99ERES;\n        unsigned char  __S99ERCO;\n        unsigned char  __S99ERCF;\n        int            __S99EWRC;\n        void *__S99EMSGP;\n        unsigned short __S99EERR;\n        unsigned short __S99EINFO;\n        int            __reserv2;\n        \u00fc;\n\n     typedef struct __S99rbx  __S99rbx_t;\n\n     struct  __S99emparms \u00e4\n        unsigned char  __EMFUNCT;\n        unsigned char  __EMIDNUM;\n        unsigned char  __EMNMSGBK;\n        unsigned char  __filler1;\n        void *__EMS99RBP;\n        int            __EMRETCOD;\n        void *__EMCPPLP;\n        void *__EMBUFP;\n        int            __reserv1;\n        int            __reserv2;\n        \u00fc;\n\n       typedef struct __S99emparms  __S99emparms_t;\n\n\n\n    typedef enum \u00e4\n       __disk       =  0,\n       __terminal   =  1,\n       __printer    =  2,\n       __tape       =  3,\n       __tdq        =  5,\n       __dummy      =  6,\n\n       __msgfile    =  7,\n\n       __memory     =  8,\n       __hfs        =  9,\n       __hiperspace = 10,\n\n       __msgrtn     = 11,\n\n       __other      = 0xff\n    \u00fc __device_t;\n\n\n\n\n\n\n\n\n    struct __fileData \u00e4\n         unsigned int   __recfmF   :    1,\n                        __recfmV   :    1,\n                        __recfmU   :    1,\n                        __recfmS   :    1,\n                        __recfmBlk :    1,\n                        __recfmASA :    1,\n                        __recfmM   :    1,\n                        __dsorgPO  :    1,\n                        __dsorgPDSmem : 1,\n                        __dsorgPDSdir : 1,\n                        __dsorgPS  :    1,\n                        __dsorgConcat : 1,\n                        __dsorgMem :    1,\n                        __dsorgHiper  : 1,\n                        __dsorgTemp:    1,\n                        __dsorgVSAM:    1,\n\n                        __dsorgHFS :    1,\n\n                        __openmode :    2,\n                        __modeflag :    4,\n                        __dsorgPDSE :   1,\n\n                        __vsamRLS :     3,\n                        __vsamEA  :     1,\n                        __recfmB  :     1,\n                        __reserve2 :    3;\n\n         __device_t     __device;\n         unsigned long  __blksize,\n                        __maxreclen;\n         union \u00e4\n           struct \u00e4\n             unsigned short __vsam_type;\n             unsigned long  __vsam_keylen;\n             unsigned long  __vsam_RKP;\n           \u00fc __vsam;\n           struct \u00e4\n             unsigned short __disk_vsam_type;\n             unsigned char  __disk_access_method;\n             unsigned char  __disk_noseek_to_seek;\n             long           __disk_reserve\u00c42\u00dc;\n           \u00fc __disk;\n         \u00fc __device_specific;\n         char *         __dsname;\n         void *         __reserve4;\n    \u00fc;\n\n    typedef struct __fileData fldata_t;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int    svc99 (__S99parms *);\n      int    flocate (FILE *, const void *, size_t, int);\n      int    fdelrec (FILE *);\n      size_t fupdate (const void *, size_t, FILE *);\n      int    clrmemf (int);\n      int    fldata (FILE *, char *, fldata_t *);\n\n\n\n\n\n\n\n\n    typedef struct \u00e4\n              unsigned int  __fill,\n                            __recnum;\n    \u00fc __rrds_key_type;\n\n\n      typedef struct __amrctype \u00e4\n\n       union \u00e4\n               int __error;\n          struct \u00e4\n            unsigned short __syscode,\n                           __rc;\n          \u00fc __abend;\n          struct \u00e4\n             unsigned char __fdbk_fill,\n                           __rc,\n                           __ftncd,\n                           __fdbk;\n          \u00fc __feedback;\n          struct \u00e4\n             unsigned short __svc99_info,\n                            __svc99_error;\n          \u00fc __alloc;\n       \u00fc __code;\n       unsigned int  __RBA;\n       unsigned int      __last_op;\n       struct \u00e4\n        unsigned int   __len_fill;\n        unsigned int   __len;\n        char           __str\u00c4120\u00dc;\n        unsigned int   __parmr0;\n        unsigned int   __parmr1;\n        unsigned int   __fill2\u00c42\u00dc;\n        char           __str2\u00c464\u00dc;\n\n       \u00fc __msg;\n\n       unsigned char        __rplfdbwd\u00c44\u00dc;\n       unsigned long long   __XRBA;\n\n       unsigned char        __amrc_noseek_to_seek;\n\n       char                 __amrc_pad\u00c423\u00dc;\n\n    \u00fc __amrc_type;\n\n\n    typedef __amrc_type *__amrc_ptr;\n\n\n    typedef struct __amrc2type \u00e4\n             int       __error2;\n\n        FILE          *__fileptr;\n             int       __reserved\u00c46\u00dc;\n    \u00fc __amrc2_type;\n\n\n    typedef __amrc2_type *__amrc2_ptr;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        FILE *fdopen(int, const char *);\n        int fileno(FILE *);\n        char *ctermid(char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         char *cuserid(char *);\n\n\n          int          getopt(int, char * const \u00c4\u00dc, const char *);\n\n\n         int getw(FILE *);\n         int putw(int, FILE *);\n\n       extern char *optarg;\n       extern int optind, opterr, optopt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n       int pclose(FILE *);\n       FILE *popen(const char *, const char *);\n       char  *tempnam(const char *, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n     #pragma map (__snprtf,  \"\u00d6174\u00d6174SNPRTF\")\n\n   int __snprtf(char *restrict, size_t, const char *restrict, ...);\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n  extern \"C\" \u00e4\n\n\n  void  __abort(void);\n  void  assert(int);\n\n\n\n\n  \u00fc\n\n\n\nextern \"C\" \u00e4\n\n\n\n\n\n\n      inline __FILEP* const * __gtab_filep(int e)       \u00e4 return (__FIL\u00d6\nEP* const *)_Gtab(e); \u00fc\n\n\n\n\n\u00fc\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\nenum genOpenNameType\n\u00e4  sas_hfs,\n   ibm_hfs,\n   sas_ddn,\n   ibm_ddn,\n   sas_dsn,\n   ibm_dsn,\n   ont_dsn,\n   ont_ddn,\n   ont_mem,\n   ont_unknown,\n   genOpenNameType_int = -1\n\u00fc;\n\ngenOpenNameType genOpenType(const char *);\nchar * stripMemberName(const char *name, char* nm);\nchar * onlyMemberName(const char *name, char* nm);\n\n\n\nunsigned short  Ushort(int i);\nunsigned short  Ushort(short s);\nunsigned short  Ushort(char c);\n\n\n\n\n\n\nvoid * memcpyp(void * target , const void * source, size_t tsize, size_\u00d6\nt ssize, int pad);\n\n\n\n\n\n\n\n\n\n\nenum ALIGNTYPE\u00e4aLEFT=1, aRIGHT=3, aCENTER=2, aASIS=0, ALINGNTYPE_int = \u00d6\n-1 \u00fc;\nenum CAPSTYPE\u00e4cUPPER=3, cLOWER=4, cWORD=2, cASIS=0, CAPSTYPE_int = -1\u00fc;\nenum FIELDTYPE\u00e4\n                      fCHAR =0,\n                      fALPHANUMERIC=1,\n                      fALPHABETIC=2,\n                      fNUMERIC= 3,\n                      fSLLTAG = 20,\n                      fLOGICAL=4 ,fHEXA=16,\n                      fBINARY=17 ,fDATE=5 ,fFTIME=6, fLISTBOX = 19,\n                      FIELDTYPE_int = -1\u00fc;\n\n\n\n\nclass FORMAT\n\u00e4\n   protected:\n   public:\n   ALIGNTYPE falign;\n   CAPSTYPE fcaps;\n  FORMAT() :  fcaps(cUPPER),\n    falign(aLEFT)\u00e4\u00fc\n\n  FORMAT(ALIGNTYPE a ,CAPSTYPE c=cASIS )\n  \u00e4\n\n    falign = a;\n      fcaps = c;\n  \u00fc\n  \u00dfFORMAT()\u00e4\u00fc\n\u00fc;\n\n\n\n\n\nextern FORMAT F_alcu;\nextern FORMAT F_alcw;\nextern FORMAT F_arcu;\n\n\n\nstruct str \u00e4\nenum status \u00e4 _VALID, _INVALID, status_int = -1 \u00fc;\nenum length \u00e4 FIX, VARIABLE \u00fc;\nchar  * c;\nchar  * lls;\nlong int     l;\nstatus type;\nlength ltype;\nstr()\u00e4 c = lls = 0; l = 0; type = _VALID; ltype = VARIABLE; \u00fc\n      \u00fc;\n\n\n\n\nclass sLL;\n\nclass mvsSTRING \u00e4\n   protected:\n   str st;\n   public:\n   static char parseSepCh;\n   mvsSTRING();\n   mvsSTRING(const char *);\n   mvsSTRING(const mvsSTRING &);\n   mvsSTRING(const char *,long int l );\n   mvsSTRING(const char , const long int l);\n\n\t\tvirtual \u00dfmvsSTRING();\n\n  virtual mvsSTRING& operator=(const char * );\n  virtual mvsSTRING& operator=(const mvsSTRING &);\n\t\tvirtual mvsSTRING& operator=(const sLL &);\n\n  virtual operator char *() const\n  \u00e4\n  if ( st.type == str::_VALID )\n      return st.c;\n\n   return st.c;\n   \u00fc\n   virtual operator unsigned char *() const\n  \u00e4\n  if ( st.type == str::_VALID )\n      return (unsigned char *)st.c;\n\n   return (unsigned char *)st.c;\n   \u00fc\n   virtual operator const char *() const\n   \u00e4\n    return (const char *)st.c;\n   \u00fc\n   virtual operator const unsigned char *() const\n   \u00e4\n    return (const unsigned char *)st.c;\n   \u00fc\n   friend long int operator==(const mvsSTRING & , const mvsSTRING &);\n   friend long int operator|=(const mvsSTRING & , const mvsSTRING &);\n   friend mvsSTRING operator+(const mvsSTRING & , const mvsSTRING &);\n\n   mvsSTRING& operator+=(const mvsSTRING&);\n   void operator<<(long int );\n   void operator>>(long int );\n\n   virtual char& operator\u00c4\u00dc(int);\n   virtual char& byte(int);\n   mvsSTRING operator()(const long int , long int );\n\n   long int hashcode();\n  char * nameOf();\n   long int  lengthOf() const\u00e4return st.l;\u00fc\n   long int toint()\n          \u00e4 long int ret = 0;\n             if ( st.l >= sizeof(long int) )\n                     ret = * (long int *)(st.c);\n           else if ( st.l == sizeof(short) )\n              ret = * (short *)(st.c);\n           else if ( st.l == 1)\n              ret = *st.c;\n         return ret ;\n       \u00fc\n   void fromint(long int i)\n       \u00e4\n             if ( st.l >= sizeof(long int) )\n                      *(long int *)(st.c) = i;\n           else if ( st.l == sizeof(short) )\n              *(short *)(st.c) = (short )i;\n           else if ( st.l == 1)\n          *st.c =(char) i;\n       \u00fc\n  void changeAll(char ,char );\n  void align(ALIGNTYPE );\n  void caps(CAPSTYPE);\n  mvsSTRING & strip();\n  int  isEmpty();\n  mvsSTRING& stripmvsSTRING();\n    mvsSTRING& format(FORMAT *);\n  void parse(mvsSTRING&, char, mvsSTRING&);\n  void parse(mvsSTRING&, char, mvsSTRING&, char ,mvsSTRING &);\n  void parse(mvsSTRING&, char *,mvsSTRING&);\n  void parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &);\n  void split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &);\n\tvoid split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mv\u00d6\nsSTRING &);\n\tvoid split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mv\u00d6\nsSTRING &,char *,mvsSTRING&);\n\tvoid parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &,char *,m\u00d6\nvsSTRING &);\n\tvoid dump(const char * ,int);\n  char * getLlmvsSTRING();\n\u00fc;\n\n\textern mvsSTRING nullstring;\n\n\n\nextern mvsSTRING nullmvsSTRING;\n\n\n\nclass LLC_mvsSTRING : public mvsSTRING\n\u00e4\n   short codev;\n  public:\n  LLC_mvsSTRING():mvsSTRING(), codev(0)\u00e4\u00fc\n  LLC_mvsSTRING(char * s):mvsSTRING(),codev(0)\n    \u00e4\n     short l = *(short*) s;\n     if ( l >= 4 )\n\n\t\t\t\t\u00e4\n\t\t\t\tmvsSTRING x = mvsSTRING(s+4,l-4);\n\t\t\t\tmvsSTRING::operator=(x);\n\t\t\t\tcodev = *(short *)(s+2);\n\t\t\t\t\u00fc\n    \u00fc\n   LLC_mvsSTRING(long int c):mvsSTRING() , codev(c)\u00e4\u00fc\n  \u00dfLLC_mvsSTRING()\u00e4\u00fc\n   long int   code(void)\u00e4return codev;\u00fc\n operator long int()\n       \u00e4 long int ret = 0;\n          if ( st.l == sizeof(long int) )\n                  ret = * (long int *)(st.c);\n         else if ( st.l == sizeof(short) )\n            ret = * (short *)(st.c);\n       else if ( st.l == 1)\n            ret = *st.c;\n       return ret ;\n    \u00fc\n\u00fc;\n\n\n\n\nmvsSTRING patternchng(mvsSTRING input , mvsSTRING mask,\n  mvsSTRING (*function)(mvsSTRING));\n\n\n\n\n\n\n\nclass mvsSTRING;\nclass mERROR;\n\n\n\n\n\n\n\n\nclass mvsSTRING;\nclass mERROR;\n\nclass INT3\n\u00e4\nprivate :\n   long v;\npublic:\n   INT3(long u)\u00e4 v = u;\u00fc\n   operator long()\u00e4return v;\u00fc\n   INT3 & operator=(long u)\u00e4 v = u;return *this;\u00fc\n\n\u00fc;\n\n\n\n\n\n\n\n\n\nenum sLLUsage \u00e4 sLLinput , sLLoutput , sLLoutputVar\u00fc ;\n\n\n\n\n\nenum sLLType   \u00e4sLLt0 = 0, sLLt1 = 1  ,sLLt2 = 2 , sLLt3 = 3 , sLLt4 = \u00d6\n4 \u00fc;\nenum sLLStatus \u00e4sLLOk = 0, sLLUf = 1  ,sLLOf = 2\u00fc;\n\nclass sLL;\n\n\nclass sLLskip\u00e4\nprivate:\n   int i;\npublic:\n   sLLskip(int v):i(v)\u00e4\u00fc\n   operator int()\u00e4return i;\u00fc\n\u00fc;\n\nclass sLL:public  mERROR\n\u00e4\n\nprotected:\n\n      int length;\n      int offset;\n      int llength;\n      int allocl;\n      int storedl;\n\n      sLL * base;\n      sLL * child;\n\n\n      char * start;\n      char * cursor;\n      sLLType type;\n      sLLStatus status;\n      char   dummy;\n\t\t\tmvsSTRING  string;\nprotected:\n      sLLUsage usage;\n\nprotected:\n\n    void init(sLL *,int,sLLType);\n    int storeOk(int);\n\npublic:\n\n\n\n\n\n    sLL (sLLType = sLLt2,\n            sLLUsage = sLLoutput,int=1024 );\n    sLL (sLL * , int ,\n            sLLType = sLLt2);\n    sLL (sLL * ,char *,\n            sLLType = sLLt2);\n    sLL (char *,\n            sLLType = sLLt2);\n      sLL (char *,\n                   int );\n\n\n    sLL (const sLL &);\n\n    virtual \u00dfsLL ();\n\n    virtual sLL & operator=(sLL &);\n\n\n\n\n\n      operator int();\n\n\n    char & operator\u00c4\u00dc(int);\n\n\t\t\tint   getLength() const\n\t\t\t\t\u00e4\n\t\t\t\tif ( usage == sLLinput ) return length;\n\t\t\t\telse return storedl;\n\t\t\t\t\u00fc\n\n\t\t\tchar * getStart() const\n\t\t\t\t\u00e4 return start; \u00fc\n\n    sLL * getBase();\n    int   getOffset();\n    sLL * getChild();\n\n\n    int   getFullLength();\n    int   getRemainderLength();\n    int   getStoredLength();\n\n    char * getCursor();\n\t\t\tmvsSTRING  getString();\n    void  setChild(sLL*);\n    void  setBase(sLL *);\n\n\n    void   setLength();\n    virtual void resetCursor();\n\n    char * goCursor(int);\n    void   setUsage(sLLUsage);\n\n\n\n\n\n    sLL * next();\n    sLL * iterate(sLLType,int = 0);\n    void remove(sLL& );\n\n\n\n\n\n\n    sLL& operator>>(int&);\n    sLL& operator>>(short&);\n    sLL& operator>>(unsigned short&);\n    sLL& operator>>(char &);\n    sLL& operator>>(char * &);\n    sLL& operator>>(mvsSTRING &);\n    sLL& operator>>(sLL &);\n    sLL& operator>>(INT3 &);\n    sLL& operator>>(sLLskip &);\n\n\n\n\n    sLL& operator<<(int);\n    sLL& operator<<(short);\n    sLL& operator<<(unsigned short);\n    sLL& operator<<(char );\n    sLL& operator<<(char *);\n    sLL& operator<<(mvsSTRING &);\n    sLL& operator<<(sLL& );\n    sLL& operator<<(INT3 &);\n    sLL& operator<<(sLLskip &);\n    sLL& store(char *,int);\n\n\n\n\n\n\n   int write(void *);\n   friend sLL * readsLL(void *,sLLType);\n\t\t\tvirtual void dump(const char *,int);\n\n\u00fc;\n\nclass sLLTag: public sLL\n\u00e4\nprivate:\n   short      code;\n   char       * name;\n   short      searchcode;\n   void       init(short);\npublic:\n   sLLTag();\n   sLLTag(short);\n\n   sLLTag(char *);\n   sLLTag(sLL * , char *);\n   sLLTag(const sLLTag &);\n\n   \u00dfsLLTag()\u00e4\u00fc\n\t\tsLLTag& operator=(sLLTag&);\n\n   short      getCode()\u00e4 return code;\u00fc\n   char *     getName()\u00e4 return name ;\u00fc\n   sLLTag *   search(short=0);\n   void       resetCursor();\n   void       remove(sLLTag &);\n   sLLTag *   update(sLLTag& );\n   sLLTag *   next();\n   sLLTag *   iterate();\n\t virtual void dump(const char *,int);\n\u00fc;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n        struct timespec\n            \u00e4\n            time_t tv_sec;\n            long   tv_nsec;\n            \u00fc;\n\n\n\n\n\n\n  struct tm\n     \u00e4\n     int tm_sec;\n     int tm_min;\n     int tm_hour;\n     int tm_mday;\n     int tm_mon;\n     int tm_year;\n     int tm_wday;\n     int tm_yday;\n     int tm_isdst;\n     \u00fc;\n\n    #pragma map(clock,\"\u00d6174\u00d6174OCLCK\")\n\n\n\n\n\n\n\n\n\n     clock_t     clock (void);\n     double      difftime (time_t, time_t);\n     time_t      mktime (struct tm *);\n     time_t      time (time_t *);\n     char       *asctime (const struct tm *);\n     char       *ctime (const time_t *);\n     struct tm  *gmtime (const time_t *);\n     struct tm  *localtime (const time_t *);\n     size_t      strftime (char * restrict, size_t,\n                           const char * restrict,\n                           const struct tm * restrict);\n     void        __tzset(void);\n\n\n      char    *strptime(const char *restrict, const char *restrict,\n                        struct tm *restrict);\n\n\n    inline char *ctime(const time_t *t) \u00e4return(asctime(localtime(t)));\u00fc\n       inline double difftime (time_t t1, time_t t0)\n                              \u00e4return((double)((t1) - (t0)));\u00fc\n\n\n\n\n\n\n\n\n\n         void tzset(void);\n\n      extern char *tzname\u00c42\u00dc;\n\n\n\n      #pragma map(__TzznA, \"\u00d6174\u00d6174TZZNA\")\n\n      char  *(*__TzznA(void))\u00c42\u00dc;\n      char  *(*__Tzzn(void))\u00c42\u00dc;\n\n\n\n\n\n\n\n\n\n\n      extern int daylight;\n      extern long int timezone;\n\n\n\n\n        long int *__tzone(void);\n        int *__dlght(void);\n\n\n\n      extern int   getdate_err;\n\n\n        struct tm *getdate(const char *);\n\n        int *__gderr(void);\n\n\n\n    char * asctime_r(const struct tm *restrict, char *restrict);\n    char * ctime_r(const time_t *, char*);\n    struct tm * gmtime_r(const time_t *restrict, struct tm *restrict);\n    struct tm * localtime_r(const time_t *restrict, struct tm *restrict\u00d6\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             \u00fc\n\n\n                   #pragma checkout(resume)\n\n\n\n\nunsigned long cvb(unsigned long,unsigned long = 8);\nunsigned long cvd(unsigned long);\nvoid    formatTime(char *,int,char *);\n\nint dump(FILE *,char *, char *,  int );\nint dump(FILE *,char *, void * , int );\nint dump(char *,int, char *, int);\n\nint  fromInt(char *,long ,int  = sizeof(long));\nlong toInt(char *,int);\nlong toInt(unsigned char *,int);\nint  roundToInt(double);\n\nint   Char2Hex(char *);\nchar * Hex2Char(char );\nint   isnull(char *,int = 0 );\n\n\n\nchar*   getTimeStemp();\nint     DatetoTm(tm&,char *);\nchar *  DatetoString(tm, char *);\n\nvoid  getUniqueKEY(char *);\nvoid  getUniqueLongKEY(char *);\nchar*   DatetoString();\nchar *\tDatetoIBM(char * from);\n\n\n\n\n\n\n\nint   strcmpiList(const char *,const char *\u00c4\u00dc,int &);\n\nchar *strrev(char *s);\n\nmvsSTRING makemvsSTRING(char *,int);\n\n  int stcpma(char * ,const char * );\n  void * memcpyp(void *,const void*,size_t,size_t,int);\n\n\n\nchar * Astrupr(char *, int);\nchar * ConvertmvsSTRINGToAscii( char *, int);\nchar aup(char);\n\nvoid  swab( char *,char *, int);\nchar *  StrDup(char *);\n\nchar   bit_rotate(unsigned char);\nmvsSTRING makemvsSTRING(char *,int);\nextern char __test__ ;\n\nextern unsigned char ETOA\u00c4256\u00dc;\nextern unsigned char ATOE\u00c4256\u00dc;\n\ninline int ffixed(FILE * f)\n\u00e4\n      fldata_t ft;\n      char fn\u00c4256\u00dc;\n      if (fldata(f,fn,&ft) == 0)\n         return (ft.__recfmF);\n      else\n\t\t\t\treturn 0;\n\u00fc\n\ninline void  strerror_r(int err, char *errmsg, int size)\n\u00e4\n    const char* msg=strerror(err);\n    if(strlen(msg)>size-1)\n    \u00e4\n        strncpy(errmsg,msg,size-1);\n        errmsg\u00c4size-1\u00dc='\u00d60';\n    \u00fc\n    else\n    \u00e4\n        strcpy(errmsg,msg);\n    \u00fc\n\u00fc\n\n\n\nnamespace isis_ns_mvs\n\t\u00e4\n\n\n\n\n\tenum MSGETypes\u00e4msgundef = 0, msgint    = 1,\n\t\tmsgshort = 2, msgcharp  = 3,\n\t\tmsgchar  = 4,  msgmvsSTRING = 5\u00fc;\n\n\n\tenum MSGEForm\u00e4msgfundef = 0, msgfd = 1, msgfs = 2, msgfx =3 , msgfc = \u00d6\n4\u00fc;\n\tclass MSGE\n\t\t\u00e4\n\t\tprivate:\n\t\t\tint         length;\n\t\t\tMSGEForm    form;\n\t\t\tMSGETypes   type;\n\t\t\tchar *      to;\n\t\t\tunion\u00e4\n\t\t\t\tchar     mchar;\n\t\t\t\tint      mint;\n\t\t\t\tshort    mshort;\n\t\t\t\tchar   * mcharp;\n\t\t\t\tmvsSTRING * mmvsSTRING;\n\t\t\t\t\u00fc;\n\t\tpublic:\n\t\t\tMSGE();\n\t\t\tMSGE(int i,int l=sizeof(int), MSGEForm f = msgfd);\n\t\t\tMSGE(short s,int l = sizeof(short), MSGEForm f= msgfd);\n\t\t\tMSGE(char * c,int l = 0, MSGEForm f = msgfs);\n\t\t\tMSGE(const mvsSTRING &s,int l = 0,MSGEForm f = msgfs );\n\t\t\tMSGE(char c);\n\n\t\t\t\u00dfMSGE()\n\t\t\t\t\u00e4\n\t\t\t\tif ( type == msgmvsSTRING) delete mmvsSTRING;\n\t\t\t\tif ( to ) delete \u00c4\u00dc to;\n\t\t\t\t\u00fc\n\t\t\tchar * format();\n\t\t\u00fc;\n\n\n\tclass EOL\u00e4\n\t\t\u00fc;\n\tconst EOL eol=EOL();\n\n\tMSGE * tCHARp(char * ,int  = 0);\n\n\tMSGE * tINT(int ,int = sizeof(int));\n\n\tMSGE * tSHORT(int ,int  = sizeof(short));\n\n\tMSGE * tmvsSTRING(mvsSTRING & ,int  = 0);\n\n\tMSGE * tHEX(int  ,int = (sizeof(int)*2) );\n\n\tMSGE * tHEX(char * , int);\n\n\n\n\n\tenum FLAG_VALUE\u00e4 FLAG_TEXT = 5, FLAG_IO = 4\u00fc;\n\n\ttypedef   struct  ENTRY\n\t\t\u00e4\n\t\tchar * name     ;\n\t\tchar flag       ;\n\t\tint  xcoord     ;\n\t\tint  ycoord     ;\n\t\tint  length     ;\n\t\tchar attrib     ;\n\t\tint  access     ;\n\t\tchar fieldtype  ;\n\t\tchar align      ;\n\t\tchar caps       ;\n\t\tchar * defvalue ;\n\t\t\u00fc\n\tentry               ;\n\n\n\n\n\n\ttypedef   struct  SELECTION\n\t\t\u00e4\n\t\tchar * line     ;\n\t\tint  access     ;\n\t\t\u00fc\n\tselection           ;\n\tstruct et\n\t\t\u00e4\n\t\tchar *   cid ;\n\t\tchar * * ett;\n\t\t\u00fc ;\n\n\n\n\n\n\tstruct TEXTENTRY\n\t\t\u00e4\n\t\tint i;\n\t\tchar * t;\n\t\t\u00fc;\n\n\n\tclass  MessageTEXT\n\t\t\u00e4\n\t\tprivate:\n\t\t\tchar timestemp;\n\t\t\tint (*printfv)(char *);\n\t\t\tchar * msgfilename;\n\t\t\tbool   logger;\n\t\t\tbool   onlylogger;\n\t\t\tFILE  * msgfile;\n\t\t\tTEXTENTRY *  vector;\n\t\t\tMSGE * v\u00c48\u00dc;\n\t\t\tint    vi;\n\t\t\tint    number;\n\t\t\tchar   deflt\u00c4256\u00dc;\n\n\t\tpublic:\n\t\t\tMessageTEXT(char * = 0,char * = 0);\n\t\t\t\u00dfMessageTEXT();\n\t\t\tMessageTEXT& operator<<(char *);\n\t\t\tMessageTEXT& operator<<(const mvsSTRING &);\n\n\t\t\tMessageTEXT& operator<<(int );\n\t\t\tchar *       operator<<(const EOL);\n\t\t\tMessageTEXT& operator<<(void *);\n\t\t\tchar * getText(int);\n\t\t\tint    copyText(int, char *, int);\n\t\t\tchar * print(char *);\n\t\t\tvoid   resetPrintFv()\u00e4 printfv = 0;\u00fc\n\t\tvoid   setPrintFv(int (*pfv)(char *))\u00e4 printfv= pfv;\u00fc\n\tvoid   setLogger(const char *);\n\tvoid   setOnlyLogger(const char * l)\n\t\t\u00e4\n\t\tsetLogger(l);\n\t\tonlylogger = logger;\n\t\t\u00fc\n\tvoid   setFILE(FILE *);\n\tFILE*  getFILE()\u00e4return msgfile;\u00fc\nvoid   setFileName(char *);\nvoid   setTimeStempFlag(char c = 1)\u00e4timestemp = c;\u00fc\nchar   getTimeStempFlag()\u00e4 return timestemp;\u00fc\nvoid   setNumber(int n);\n\t\t\u00fc;\n\n\textern \"C\" typedef void * (*EXT_C_fp)();\n\n\n\tclass ExternalTEXT\n\t\t\u00e4\n\t\tprivate:\n\t\t\tEXT_C_fp fp;\n\t\t\tchar   language;\n\t\t\tchar   modulname\u00c48\u00dc;\n\t\t\tvoid * text ;\n\t\t\tvoid init(char * name);\n\t\tpublic:\n\t\t\tExternalTEXT(char * name,char lang);\n\t\t\tExternalTEXT(char * name);\n\n\n\t\t\tint         MSGTEXT(int id, char * buff,int len);\n\t\t\tchar      * HelpText(char * hid);\n\t\t\tentry     * EntryText(char * hid);\n\t\t\tselection * SelectionText(char * hid);\n\t\t\u00fc;\n\n\textern ExternalTEXT * externaltext;\n\n\n\n\textern  MessageTEXT * messagetext;\n\tint initMessageText();\n\n\tint     Error(int , ...);\n\tchar *  Message(int , ...);\n\tchar *  getErrorText();\n\tchar *  getMessageText();\n\tMessageTEXT& Err(int);\n\tMessageTEXT& Msg(int);\n\n\t\u00fc\n\nusing namespace isis_ns_mvs;\n\n\n\n\n\n\n\n\nextern \"OS\" int  SQLASM(void);\n\nextern \"OS\" int  DSNALI(...);\nextern \"OS\" int  DSNTIAR(...);\nextern \"OS\" void DSNHLI(void *);\n\nconst int data_dim = 30;\nconst int data_len = 72;\n\n\ntypedef struct varchar\n\u00e4\n  short len;\n  char  value\u00c44096\u00dc;\n\u00fc VARCHAR;\n\ntypedef struct\n \u00e4\n  short error_len;\n  char error_text\u00c4data_dim\u00dc\u00c4data_len\u00dc;\n \u00fc ERROR_MESSAGE;\n\nenum  CallType\u00e4Connect,\n       Disconnect,\n       Commit,\n       Rollback,\n       Prepare,\n       Open,\n       Close,\n       Execute\u00fc;\n\n\n\n\n\n\n\n\n\n\n\n\nclass ARCHSQL:public mERROR\n\u00e4\nprivate:\n  int rc;\n  void * tecb,* secb,* ribptr,* eibptr;\n  long retcode , reasoncode;\n  char function\u00c413\u00dc;\n  char ssnm\u00c45\u00dc;\n  char plan\u00c49\u00dc;\n  char reuse\u00c49\u00dc;\n  char collection\u00c419\u00dc;\n  char correlation_id\u00c413\u00dc;\n  char accounting_token\u00c423\u00dc;\n  char accounting_interval\u00c47\u00dc;\n  int  rrs;\n  int status;\n  ERROR_MESSAGE error_message;\n  void * loadlist\u00c48\u00dc;\npublic:\n  ARCHSQL();\n  \u00dfARCHSQL();\n  int call(CallType);\n  void setDynamicSQL(char *);\n  void * getLoadlist()\u00e4 return loadlist\u00c40\u00dc;\u00fc\n  void setSubSystem(char *n)\u00e4memcpy(ssnm,n,4);ssnm\u00c44\u00dc = 0;\u00fc\n  void setPlan(char * p)\u00e4memcpyp(plan,p,8,strlen(p),' '); plan\u00c48\u00dc = 0;\u00fc\n  void setCollection(char * p)\u00e4memcpyp(collection,p,8,strlen(p),' '); c\u00d6\nollection\u00c48\u00dc = 0;\u00fc\n  void setPlanName(char *n)\u00e4memcpy(plan,n,8);plan\u00c48\u00dc = 0;\u00fc\n\u00fc;\n\nvoid  getUniqueKey(char *);\nvoid  getUniqueKEY(char *);\n\n\n\n\n\n\n\n\nstruct chainE \u00e4\n\n\tchainE * prev ;\n\tchainE * next ;\n\tchar * chainEid   ;\n\tint    chainEidl  ;\n\n\tchainE()\u00e4chainEid = 0; chainEidl = 0; prev = next = 0;\u00fc\n\n\tchainE(char * i,int l =0)\n\t\u00e4\n\t\tif (i)\n\t\t\u00e4\n\t\t\tif ( l ) chainEidl = l; else chainEidl =int(strlen(i));\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc; memcpy(chainEid,i,chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\n\tchainE(const char * i,int l =0)\n\t\u00e4\n\t\tif (i)\n\t\t\u00e4\n\t\t\tif ( l ) chainEidl = l; else chainEidl =int(strlen(i));\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc; memcpy(chainEid,i,chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\n\tchainE(const mvsSTRING * s)\n\t\u00e4\n\t\tif (s)\n\t\t\u00e4\n\t\t\tchainEidl = int((mvsSTRING *)s->lengthOf());\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc;\n\t\t\tmemcpy(chainEid,(char *)mvsSTRING(*s),chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\tvirtual \u00dfchainE()\n\t\u00e4\n\t\tdelete chainEid ;\n\t\u00fc\n\tvirtual void print()\u00e4\u00fc\n\u00fc;\n\n\nclass mCHAIN \u00e4\n\nprotected:\n\tchainE * first;\n\tchainE * last ;\n\n\tchainE * pgo;\n\tlong int    counter;\npublic:\n\tfriend class CHAINITER ;\n\n\tmCHAIN()\n\t\u00e4\n\n\t\tfirst = last = pgo = 0; counter = 0;\n\t\u00fc\n\n\tmCHAIN(chainE * nc)\n\t\u00e4\n\t\tpgo = 0;\n\t\tfirst = nc ; last = nc ;\n\t\tcounter = 1;\n\t\u00fc\n\n\tvirtual \u00dfmCHAIN();\n\tvirtual   long int    add(chainE * nc,chainE * c,long int code = 1);\n\tvirtual long int addfirst(chainE * nc )\n\t\u00e4 return add(nc,first,-1) ; \u00fc\n\tvirtual long int addlast(chainE * nc )\n\t\u00e4 return add(nc,last,+1) ; \u00fc\n\tvirtual long int before(chainE * nc , chainE * c)\n\t\u00e4return add(nc,c,-1);\u00fc\n\tvirtual long int after(chainE * nc , chainE * c)\n\t\u00e4return add(nc,c,+1);\u00fc\n\tvirtual long int del(chainE * c);\n\tvirtual void swap(chainE * a , chainE * b);\n\n\n\n\tvirtual chainE* goNext();\n\tvirtual chainE* goPrev();\n\tvirtual chainE* goFirst();\n\tvirtual chainE* goLast();\n\tvirtual chainE* go(int);\n\tvirtual chainE * searchEQ(const char * id,size_t =0);\n\tvirtual chainE * search(const char * id,size_t =0);\n\tvirtual chainE * search(const mvsSTRING &);\n\tvirtual chainE * search(char *id,size_t length =0)\u00e4 return search((con\u00d6\nst char *)id,length);\u00fc\n\tvirtual chainE * search(mvsSTRING &s)\u00e4 return search((const mvsSTRING&\u00d6\n)s);\u00fc\n\n\tvirtual void sort(long int direction);\n\tvirtual void print_all_ids();\n\tvirtual void print();\n\tfriend int idcmp(chainE* , chainE*);\n\u00fc;\n\nenum SORTEDTYPE\u00e4UNIQUE =0 ,NOUNIQUE =1 \u00fc;\n\nclass SORTEDmCHAIN:public mCHAIN\n\u00e4\nprivate:\n\tSORTEDTYPE unique;\npublic:\n\tSORTEDmCHAIN(SORTEDTYPE st = UNIQUE):\n\t\t\tmCHAIN(), unique(st)\u00e4\u00fc;\n\t\t\tSORTEDmCHAIN(chainE *nc, SORTEDTYPE st = UNIQUE)\n\t\t\t\t:mCHAIN(nc), unique(st)\u00e4\u00fc;\n\t\t\tlong int add(chainE * nc,chainE * = 0,long int = 0);\n\t\t\tvirtual \u00dfSORTEDmCHAIN()\u00e4\u00fc\n\u00fc;\n\nclass mSTACK:public mCHAIN\n\u00e4\nprivate:\npublic:\n\tmSTACK():mCHAIN()\u00e4\u00fc\n\tmSTACK(chainE * nc):mCHAIN(nc)\u00e4\u00fc\n\n\tvirtual long int push(chainE * nc)\u00e4return addlast(nc);\u00fc\n\tvirtual chainE * examine(int i = 0 )\n\t\u00e4\n\t\tif ( i >= 0 ) return last;\n\t\ti = -i;\n\t\tif ( counter-i < 0 ) return 0;\n\t\treturn go(counter-i);\n\n\t\u00fc\n\tvirtual chainE * pop()\u00e4chainE * r = last; if (last) del(last);return r\u00d6\n;\u00fc\n\u00fc;\n\nclass mHASH:public mCHAIN\n\u00e4\nprivate:\n\tchainE * * table;\n\tint    hash;\n\tint\t\tpi;\npublic:\n\tmHASH(int h = 1023);\n\t\u00dfmHASH();\n\tlong int add(chainE *);\n\tlong int del(chainE *);\n\tchainE * next();\n\tchainE * search(chainE *);\nprivate:\n\tsize_t  hashCode(chainE *c)\n\t\u00e4\n\t\tint r = 0;\n\t\tif (c->chainEid)\n\t\t\tfor (int i = c->chainEidl;i;i--)\n\t\t\t\tr = (r<<1) \u00ac (c->chainEid\u00c4i-1\u00dc) ;\n\t\treturn size_t(r<0 ? -r:r);\n\t\u00fc\n\u00fc;\n\nclass CHAINITER\u00e4\nprivate:\n\tmCHAIN * c;\n\tchainE * a;\npublic:\n\tCHAINITER(mCHAIN &ch) \u00e4c = &ch ; a = (c->first ? c->first:0) ; \u00fc\n\tCHAINITER(mCHAIN *ch) \u00e4c =  ch ; a = (c->first ? c->first:0) ; \u00fc\n\t\u00dfCHAINITER()\u00e4\u00fc\n\tchainE * next() \u00e4\n\n\t\tchainE * r = a ;\n\t\tif ( a == 0 ) a =c->first ;\n\t\telse a = a->next ;\n\t\treturn r;\n\t\u00fc\n\tchainE * operator()()\u00e4 return next(); \u00fc\n\tvoid reset() \u00e4 a = (c ? c->first:0);\u00fc\n\u00fc;\n\nint idcmp(chainE* , chainE*);\n\n\n\n\n\n\n\n\n\n\nclass JOBENV\n\u00e4\npublic:\nenum JOBENV_ACTION\n\u00e4\n\tAbort,\n   Continue\n\u00fc;\npublic:\n    mvsSTRING jobName;\n    mvsSTRING jobId;\n    mvsSTRING stepName;\n    mvsSTRING procStepName;\n    mvsSTRING program;\n\t\tmvsSTRING programRb;\n    static int  debug;\npublic:\n    JOBENV(char *);\n    \u00dfJOBENV()\u00e4\u00fc\n    void print();\n    void static Error(char *,JOBENV_ACTION);\n    int  static DEBUG(int,char*);\n    int  static DEBUG(int,char*,int);\n    int  static DEBUG(int,size_t);\n    int  static DEBUG(int,char*,char*);\n    int  static DEBUG(int,char*,char*,char*);\n    int  static DEBUG(int,char*,char*,char*,char*);\n    int  static DEBUG(int,char*,char *,int);\n\u00fc;\n\nextern JOBENV * jobEnv;\n\n\n\nconst short  eiop00  = 0;\nconst short  eiop01  = 1;\nconst short  eiop02  = 2;\nconst short  eiop03  = 3;\nconst short  eiop04  = 4;\nconst short  eiop05  = 5;\nconst short  eiop06  = 6;\nconst short  eiop07  = 7;\nconst short  eiop08  = 8;\nconst short  eiop09  = 9;\nconst short  eiop10  =10;\nconst short  eiop11  =11;\nconst short  eiop12  =12;\nconst short  eiop13  =13;\nconst short  eiop14  =14;\nconst short  eiop15  =15;\nconst short  eiop16  =16;\nconst short  eiop17  =17;\nconst short  eiop18  =18;\nconst short  eiop19  =19;\nconst short  eiop20  =20;\nconst short  eiop21  =21;\nconst short  eiop22  =22;\nconst short  eiop23  =23;\nconst short  eiop24  =24;\nconst short  eiop25  =25;\nconst short  eiop26  =26;\n\nconst int eirc_ok    = 0;\nconst int eirc_replace    = 4;\nconst int eirc_insert    = 8;\nconst int eirc_delete    = 12;\nconst int eirc_modified  = 16;\nconst int eirc_disconnect  = 20;\nconst int eirc_disconnect_after = 24;\nconst int eirc_wtor        = 28;\nconst int eirc_end_function= 32;\nconst int eirc_end_dataset = 36;\n\n\nextern const char * ADRDSSU;\nextern const char * KEYWORD_INCLUDE_MARK;\nextern const char * KEYWORD_DUMP;\nextern const char * KEYWORD_RESTORE;\nextern const char * KEYWORD_DB_PLAN;\nextern const char * KEYWORD_DB_SUBSYS;\nextern const char * KEYWORD_PREFIX;\nextern const char * KEYWORD_SYSIN;\nextern const char * KEYWORD_ADR012I;\nextern const char * KEYWORD_DEBUG;\nextern const char * KEYWORD_COMPR;\nextern const char * KEYWORD_REFDT;\nextern const char * KEYWORD_SQLFILE;\nextern const char * KEYWORD_DIRECT;\nextern const char * KEYWORD_MAXLENGTH;\nextern const char * KEYWORD_USEDB2;\nextern const char * KEYWORD_USEDB2_FILE;\n\n\n\n\n\n\nextern \"OS\" int UIMASM(...);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst  unsigned PSATOLD = 0x21c;\nconst  unsigned PSAAOLD = 0x224;\nconst  unsigned TCBFSA  = 0x70/4;\nconst  unsigned TCBUSER = 0xA8;\nconst  unsigned tcbuser = 0xa8;\nconst  unsigned SAVEr1  = 0x18/4;\nstatic unsigned POSTcode = 0x40000000;\nstatic unsigned WAITcode = 0x80000000;\n\nclass SUBTASK;\nclass JOBENV;\n\n\ntypedef void       (*SUBTASK_FUNCTION)(void*);\ntypedef void       * addressP;\ninline addressP getASCB()\u00e4return(*(addressP*)PSAAOLD);\u00fc\ninline addressP getTCB()\u00e4return (*(addressP *)PSATOLD);\u00fc\n\n\nenum SUBTASK_STATUS\n\u00e4\n    Reset,\n    Started,\n    WaitingForWork,\n    WaitingForMain,\n    Working,\n    Stopping\n\u00fc;\ntypedef struct PROGRAM_ARGUMENTS \u00e4\n  short  arg_l;\n  char   arg_v\u00c41024\u00dc;\n  \u00fc programArguments;\n\n class SUBTASK: public mERROR\n\u00e4\nprivate:\n  char * dll;\nprotected:\n  MessageTEXT * messageText;\n  JOBENV *      jobEnv;\n  void * TCB;\n  unsigned ECB;\n  unsigned StopECB;\n  unsigned WorkECB;\n  unsigned MainECB;\n  unsigned SuspendECB;\n  unsigned *  ecblist\u00c42\u00dc;\n   void(* address)(void);\n  void (*subrun)();\n  int R15 ;\n  SUBTASK_FUNCTION functions\u00c44\u00dc;\n  void  * arg\u00c44\u00dc;\n  int subtask_rc;\n  int suspendflag;\n  SUBTASK_STATUS status;\n  char   name\u00c49\u00dc;\n  char   subtaskposted;\n  char   first_start;\n  int    timeout;\npublic:\n  friend void run();\n  SUBTASK();\n  SUBTASK(char *);\n  SUBTASK(addressP,SUBTASK_FUNCTION,char*);\n  SUBTASK(int,char * *,char *,char *);\n  virtual \u00dfSUBTASK();\n  virtual int    attach();\n  virtual int    detach();\n  virtual int    callAsync(int);\n  virtual int    callSync(int);\n  virtual int    waitForSubtask();\n  virtual int    waitForEndOfSubtask();\n  virtual void   start();\n  virtual void   stop();\n  virtual void   chap(int);\n  virtual void   exit(int);\n  virtual int    isTerminated()\u00e4 return (ECB&0x7fffffff);\u00fc\n  SUBTASK_STATUS askStatus()\u00e4return status;\u00fc\n  MessageTEXT * getMessageText()\u00e4return messageText;\u00fc\n  JOBENV      * getJobEnv()\u00e4return jobEnv;\u00fc\n  addressP      getParam()\u00e4return(addressP(argV));\u00fc\n  addressP      getTCB()\u00e4return(addressP(TCB));\u00fc\n  int           getTimeout()\u00e4return timeout;\u00fc\n  char *        getDllName()\u00e4 return dll;\u00fc\n  void          setDllName(char *d)\u00e4 dll = d;\u00fc\n  char * *  argV;\n  int       argC;\n\nstatic addressP GetTCB()\u00e4return (*(addressP *)PSATOLD);\u00fc\nstatic addressP GetASCB()\u00e4return(*(addressP*)PSAAOLD);\u00fc\n\nprotected:\n  int    checkR15(char *);\n  void   init(char *);\n  void   error(char *);\n\u00fc;\n\n class DLL_SUBTASK\n\u00e4\nprivate:\npublic:\n  SUBTASK * subtask;\n  DLL_SUBTASK(int,char * *,char *,char * = \"SUBRUN \");\n  \u00dfDLL_SUBTASK();\n  void      start()\u00e4subtask->start();\u00fc\n  void      stop()\u00e4subtask->stop();\u00fc\n  int       detach()\u00e4return(subtask->detach());\u00fc\n  addressP  getTCB()\u00e4return(subtask->getTCB());\u00fc\n\u00fc;\n\n class MAIN_SUBTASK:public SUBTASK\n\u00e4\nprivate:\nmvsSTRING startmvsSTRING;\n void * plist\u00c41\u00dc;\nprogramArguments   argument;\nprogramArguments * argumentP;\npublic:\n MAIN_SUBTASK();\n MAIN_SUBTASK(int,char * *,char *);\n MAIN_SUBTASK(programArguments *,char * );\n virtual int  attach();\n\u00fc;\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      struct flock \u00e4\n            short l_type;\n            short l_whence;\n               int   l_rsrvd1;\n            off_t l_start;\n               int   l_rsrvd2;\n            off_t l_len;\n            pid_t l_pid;\n      \u00fc;\n\n\n\n\n        int creat(const char *, mode_t) ;\n        int fcntl(int, int, ... );\n        int open(const char *, int, ... );\n\n\n\n\n\n\n\n\n\n\n\n     \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n  extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n               #pragma map (getlogin, \"\u00d6174\u00d6174GETLG2\")\n\n\n         #pragma map (__getlogin1, \"\u00d6174\u00d6174GETLOG\")\n         #pragma map (__pid_affinity,\"\u00d6174\u00d6174PID\u00d6174AF\")\n\n          #pragma map(__login_applid,\"\u00d6174\u00d6174LOGNAP\")\n         #pragma map(__certificate,\"\u00d6174\u00d6174CERTIF\")\n\n           void _exit(int);\n           int   access(const char *, int );\n           int   __certificate(int, int, char *, ...);\n           unsigned int alarm(unsigned int);\n           int   chdir(const char *);\n           int   chown(const char *, uid_t, gid_t);\n           int   close(int);\n           char *ctermid(char *);\n           int   dup(int);\n           int   dup2(int, int);\n           int   execl(const char *, const char *, ... );\n           int   execle(const char *, const char *, ... );\n           int   execlp(const char *, const char *, ... );\n           int   execv(const char *, char *const \u00c4\u00dc);\n           int   execve(const char *, char *const \u00c4\u00dc, char * const \u00c4\u00dc);\n           int   execvp(const char *, char *const \u00c4\u00dc );\n           pid_t fork(void);\n           long  fpathconf(int, int);\n           char *getcwd(char *, size_t);\n           gid_t getegid(void);\n           uid_t geteuid(void);\n           gid_t getgid(void);\n           int   getgroups(int, gid_t \u00c4\u00dc);\n             int   getgroupsbyname(char \u00c4\u00dc, int, gid_t \u00c4\u00dc);\n             int   __osenv(int, int, __osenv_token *);\n           char *__getlogin1(void);\n           char *getlogin(void);\n           pid_t getpgrp(void);\n           pid_t getpid(void);\n           pid_t getppid(void);\n           uid_t getuid(void);\n           int   isatty(int);\n           int   link(const char *, const char *);\n           int __login(int, int, int, void *, int, char *,\n                         int, char *, int);\n           off_t lseek(int, off_t, int);\n           long  pathconf(const char *, int);\n           int   pause(void);\n           int   __pid_affinity(int, pid_t, pid_t, int);\n           int   pipe(int \u00c42\u00dc);\n           ssize_t read(int, void *, size_t);\n           int   rmdir(const char *);\n           int   setgid(gid_t);\n           int   setpgid(pid_t, pid_t);\n           pid_t setsid(void);\n           int   setuid(uid_t);\n           unsigned int sleep(unsigned int );\n           long  sysconf(int);\n           pid_t tcgetpgrp(int);\n           int   tcsetpgrp(int, pid_t);\n           char *ttyname(int);\n           int   unlink(const char *);\n           ssize_t write(int, const void *, size_t);\n\n         int __login_applid(int, int, int, void *, int, char *, int, ch\u00d6\nar *, int, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n           int   fchown(int , uid_t, gid_t);\n           int   fsync(int);\n           int   ftruncate(int, off_t);\n           int   readlink(const char *, char *, size_t );\n           int   setegid(gid_t);\n           int   seteuid(uid_t);\n           int   symlink(const char *, const char *);\n             int   extlink_np(const char *, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          extern char *optarg;\n          extern int optind, opterr, optopt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             void         __cnvblk(char \u00c4\u00dc, char \u00c4\u00dc, int);\n               int          chroot(const char *);\n             char        *crypt(const char *, const char *);\n             void         encrypt(char \u00c464\u00dc, int);\n             int          nice(int);\n           extern char **__opargf(void);\n           extern int  *__operrf(void);\n           extern int  *__opindf(void);\n           extern int  *__opoptf(void);\n           size_t       confstr(int, char *, size_t);\n             char        *cuserid(char *);\n           int          getopt(int, char * const \u00c4\u00dc, const char *);\n             char        *getpass(const char *);\n           void         swab(const void *restrict,\n                                   void *restrict, ssize_t);\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n       typedef    signed  char   int8_t;\n       typedef    signed  short  int16_t;\n       typedef    signed  int    int32_t;\n\n\n       typedef signed long long  int64_t;\n\n\n\n\n       typedef  unsigned  char  uint8_t;\n\n\n       typedef  unsigned  short uint16_t;\n\n\n       typedef  unsigned  int   uint32_t;\n\n       typedef unsigned long long uint64_t;\n\n       typedef    signed long    intptr_t;\n       typedef  unsigned long   uintptr_t;\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             int          fchdir(int);\n               int          getdtablesize(void);\n             pid_t        getpgid(pid_t);\n             pid_t        getsid(pid_t);\n             char        *getwd(char *);\n             int          lchown(const char *, uid_t, gid_t);\n             int          setregid(gid_t, gid_t);\n             int          setreuid(uid_t, uid_t);\n             void         sync(void);\n             int          truncate(const char *, off_t);\n             useconds_t    ualarm(useconds_t, useconds_t);\n             int          brk(void *);\n             int          getpagesize(void);\n               void        *sbrk(intptr_t);\n           int          lockf(int, int, off_t);\n           pid_t        setpgrp(void);\n           int          usleep(useconds_t);\n           pid_t        vfork(void);\n\n\n\n\n\n\n\n\n\n\n\n      int getlogin_r(char *, size_t );\n      int ttyname_r(int, char *, size_t );\n\n\n      ssize_t pread(int, void *, size_t, off_t);\n\n      ssize_t pwrite(int, const void *, size_t, off_t);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int          __atoe(char *);\n      int          __atoe_l(char *, int);\n      int          __check_resource_auth_np(char *, char *, char *,\n                                            char *, char *, int);\n      int          __convert_id_np( int, char *, char *, char *);\n      int          __etoa(char *);\n      int          __etoa_l(char *, int);\n      int          __isPosixOn(void);\n      int          __openMvsRel(void);\n      int          __openVmRel(void);\n      int          __smf_record(int, int, int, char *);\n      int          __wsinit(void (*)());\n\n    int __smf_record2(int, int, int, char *, unsigned int);\n\n\n\n\n\n\n\n\n          long         gethostid(void);\n          int          gethostname(char *, size_t);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int __must_stay_clean(int);\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n    int __errno2(void);\n    int *__err2ad(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n           extern int errno;\n           extern int *__errno(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n   extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          int  bcmp (const void *, const void *, size_t);\n          void bcopy (const void *, void *, size_t);\n          void bzero (void *, size_t);\n          int ffs (int);\n          char * index  (const char *, int);\n          char * rindex (const char *, int);\n          int  strcasecmp (const char *, const char *);\n          int  strncasecmp (const char *, const char *, size_t);\n\n\n\n\n\n         extern \"builtin\"  \u00e4\n\n         void * __memcpy (void *, const void *, size_t);\n         int    __memcmp (const void *, const void *, size_t);\n         void * __memset (void *, int, size_t);\n         char * __strchr (const char *, int);\n         char * __strrchr (const char *, int);\n\n         \u00fc\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\nstatic const char fullQuery\u00c4\u00dc =\n\" SELECT * FROM DSSDATASETS A \"\n\" WHERE ( %m% ) AND \"\n\" ( DATE(KEY) <= DATE('%d%') ) AND \"\n\" ( \"\n\" A.KEY =  \"\n\" (SELECT MAX(B.KEY) FROM DSSDATASETS B WHERE A.DATASET = B.DATASET  \"\n\" AND DATE(B.KEY) <= DATE('%d%') ) \"\n\" ) \" ;\n\n\nEXEC SQL BEGIN DECLARE SECTION;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntypedef struct _TIMESTAMP\n\u00e4\n  short len;\n  char  arr\u00c428\u00dc;\n\u00fc TIMESTAMP;\n\nstruct _DssDatasetRecord\n\u00e4\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc key;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc job;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc volumes;\n   long int type;\n   long int recordsize;\n\u00fc DssDatasetRecord;\n\nclass TcbARCHSQL:public chainE\n\u00e4\nprivate:\n   ARCHSQL * archsql;\npublic:\n   TcbARCHSQL(char * t,ARCHSQL * a):chainE(t),archsql(a)\n   \u00e4\u00fc\n   ARCHSQL * get()\u00e4return archsql;\u00fc\n\u00fc;\n\nstatic char * initDynamicSql();\n\nclass SQLINTERFACE:\n public  mERROR\n\u00e4\nprotected:\n static char * plan;\n static char * subsystem;\n static mCHAIN  tasks;\n static ERROR_MESSAGE * error_message;\nprotected:\n static char * dSql;\npublic:\n\tstatic bool useDB2;\n\tstatic FILE * fileDB2;\npublic:\n SQLINTERFACE();\n   \u00dfSQLINTERFACE();\n   void diag(char *);\n   int  commit();\n   enum Error_Action\u00e4 Abort, Continue\u00fc;\n   void Error(char *,Error_Action);\n   ARCHSQL * connectDB();\n   void tryToConnect();\n\u00fc;\n\nclass DssJob:\n public SQLINTERFACE,\n public mCHAIN,\n public CHAINITER,\n public chainE\n\u00e4\nprivate:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc t;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc record_key;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc record_job;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc record_dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc record_volumes;\n   long int record_type;\n   long int record_size;\npublic:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc timestamp;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc jobName;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc jobNumber;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc program;\n   struct \u00e4 short len; char arr \u00c4 255 \u00dc ; \u00fc dataset;\n   long int datasetcount;\n   struct \u00e4 short len; char arr \u00c4 30000 \u00dc ; \u00fc joblog;\n   struct \u00e4 short len; char arr \u00c4 32000 \u00dc ; \u00fc dynamicSql;\npublic:\n  static mCHAIN dssJobs;\n  static int    allOnline();\n  int    doWeNeed(const char *);\npublic:\n DssJob();\n DssJob(TIMESTAMP&);\n DssJob(const char *);\n virtual \u00dfDssJob();\n int insert();\n int query(mCHAIN*,char * =0);\n char * getDatasetName()\n\u00e4\n  return ((char *)dataset.arr);\n\u00fc\nprivate:\n void init();\n\u00fc;\n\nclass DssDataset:\n public SQLINTERFACE,\n public chainE\n\u00e4\nprivate:\n DssJob * job;\npublic:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc timestamp;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc volumes;\n   long int type;\n   long int recordsize;\npublic:\n DssDataset(DssJob *,char *,char *,int = 0,int =0);\n int compare(const char *n)\n   \u00e4\n   for(int i =0;i<45&&dataset.arr\u00c4i\u00dc&&dataset.arr\u00c4i\u00dc-' '&&n\u00c4i\u00dc&&n\u00c4i\u00dc-' \u00d6\n';i++)\n     if (dataset.arr\u00c4i\u00dc - n\u00c4i\u00dc) return 0;\n   return 1;\n   \u00fc\n   virtual \u00dfDssDataset();\n   int insert();\n\u00fc;\n\nEXEC SQL END DECLARE SECTION;\nEXEC SQL INCLUDE SQLDA;\nEXEC SQL INCLUDE SQLCA;\nstatic bool _useDB2()\n\u00e4\nif (getenv(KEYWORD_USEDB2) && strcasecmp(getenv(KEYWORD_USEDB2),\"NO\") =\u00d6\n= 0)\n\u00e4\n    char w\u00c4128\u00dc;\n    SQLINTERFACE::fileDB2 = fopen(genOpenName(KEYWORD_USEDB2_FILE,w),\"w\u00d6\n\");\n    Msg(10000+1003)<<eol;\n    return false;\n\u00fc\nelse\n    return true;\n\u00fc\n\nchar *      SQLINTERFACE::plan        = strdup(getenv(KEYWORD_DB_PLAN));\nchar *      SQLINTERFACE::subsystem   = strdup(getenv(KEYWORD_DB_SUBSYS\u00d6\n));\nchar *      SQLINTERFACE::dSql        = initDynamicSql();\nmCHAIN      DssJob::dssJobs;\nmCHAIN      SQLINTERFACE::tasks;\nbool        SQLINTERFACE::useDB2     = _useDB2();\nFILE *      SQLINTERFACE::fileDB2    =  0;\n\n\n\nERROR_MESSAGE * SQLINTERFACE::error_message = new ERROR_MESSAGE();\nSQLINTERFACE::SQLINTERFACE():mERROR()\n\u00e4\n  tryToConnect();\n\u00fc\n\nvoid SQLINTERFACE::tryToConnect()\n\u00e4\n\n\n  char t\u00c412\u00dc;\n  sprintf(t,\"%p\",getTCB());\n  if (tasks.search(t) == 0)\n      tasks.addlast(new TcbARCHSQL(t,connectDB()));\n      JOBENV::DEBUG(1,t);\n\u00fc\n\nARCHSQL * SQLINTERFACE::connectDB()\n\u00e4\n      ARCHSQL * archsql = new ARCHSQL();\n      if (useDB2)\n      \u00e4\n      if (subsystem==0) return 0;\n      ARCHSQL * archsql = new ARCHSQL();\n      archsql->setSubSystem(subsystem);\n      char _plan\u00c4\u00dc = \"        \";\n      memcpy(_plan,plan,strlen(plan));\n      archsql->setPlan(_plan);\n      if (| archsql->call(Connect))\n       markerror();\n      \u00fc\n      else\n      ARCHSQL * archsql = (ARCHSQL*)1;\n      error_message->error_len = short(data_dim*data_len);\n      if (useDB2)\n      Msg(10000+1000)<<subsystem<<plan<<tHEX(int(getTCB()))<<eol;\n      return archsql;\n\u00fc\n\nSQLINTERFACE::\u00dfSQLINTERFACE()\n\u00e4\n\u00fc\n\nvoid SQLINTERFACE::diag(char *t)\n\u00e4\n if (useDB2)\n \u00e4\n Msg(10000+1001)<<t<<SQLCODE<<(char *)(sqlca.sqlerrmc)<<eol;\n int rc = DSNTIAR(&sqlca,error_message,&data_len);\n if ( rc )\n  Msg(10000+9707)<<long(rc)<<eol;\n else\n \u00e4\n   for(int i = 0;i<data_dim;i++)\n   if (| mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len).isEmpty())\n      Msg(10000+9708)<<mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len)\u00d6\n<<eol;\n \u00fc\n \u00fc\n\n Msg(100000+9709)<<\"diag\"<<eol;\n\u00fc\n\nint SQLINTERFACE::commit()\n\u00e4\ntryToConnect();\nif (useDB2)\n\u00e4\n  EXEC SQL COMMIT;\n\u00fc\n  return 1;\n\u00fc\n\nvoid SQLINTERFACE::Error(char * t,Error_Action a)\n\u00e4\n\n\n Msg(100000+9709)<<\"error\"<<eol;\n\n\u00fc\n\nstatic char * initDynamicSql()\n\u00e4\n  char b\u00c432000\u00dc;\n  char _genFileName\u00c41024\u00dc;\n  size_t o = 0;\n  FILE * sqlFile = 0;\n  if (SQLINTERFACE::useDB2 && access(KEYWORD_SQLFILE,0x04)==0)\n  sqlFile=  fopen(genOpenName(KEYWORD_SQLFILE,_genFileName),\"r\");\n  if (sqlFile)\n  while(fgets(b+o,sizeof(b)-o,sqlFile))\n  \u00e4\n    o = strchr(b+o,'\u00d6n')-b;\n    if (o>0) *(b+o) = 0;\n      else\n    break;\n  \u00fc\n  if (sqlFile)\n    fclose(sqlFile);\n  else\n    strcpy(b,fullQuery);\n  JOBENV::DEBUG(1,(char *)b);\n  char * rb = new char\u00c4strlen(b)+1\u00dc;\n  strcpy(rb,b);\n  return (rb);\n\u00fc\n\n\n\n\n\nDssJob::DssJob():\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==0)\n\u00e4\n   init();\n\u00fc\nelse\n\t\t fclose(f);\n\n\u00fc\n\nDssJob::DssJob(const char * d):\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==0)\n\u00e4\n   init();\n\u00fc\nelse\n\t fclose(f);\n strcpy(dataset.arr,d);\n dataset.len = strlen(d);\n\u00fc\nDssJob::DssJob(TIMESTAMP& ts):\nSQLINTERFACE(),\nchainE(ts.arr),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\n init();\n memcpy(t.arr,ts.arr,ts.len);\n t.len = ts.len;\n if (useDB2)\n \u00e4\n EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n EXEC SQL SELECT KEY, JOBNAME, JOBNUMBER, DATASET\n INTO\n :timestamp,\n :jobName,\n :jobNumber,\n :dataset\n FROM DSSJOBS WHERE KEY = :t;\n if (SQLCODE == 100)\n    markerror();\n \u00fc\n char * c;\n dataset.arr\u00c4sizeof(dataset.arr)-1\u00dc = 0;\n if ((c = strchr(dataset.arr,' ')))\n     *c = 0;\n return;\nSQLERROR:\n  diag(\"SELECT\");\n  markerror();\n\u00fc\n\n\nDssJob::\u00dfDssJob()\n\u00e4\n\u00fc\n\nvoid DssJob::init()\n\u00e4\n   memset(&timestamp,0,sizeof(timestamp));\n   \u00e4 jobName.len = short((((sizeof(jobName.arr))>(strlen((char *)jobEnv\u00d6\n->jobName)))?(strlen((char *)jobEnv->jobName)):(sizeof(jobName.arr))));\u00d6\n strncpy(jobName.arr,(char *)jobEnv->jobName,jobName.len); \u00fc;\n   \u00e4 jobNumber.len = short((((sizeof(jobNumber.arr))>(strlen((char *)jo\u00d6\nbEnv->jobId)))?(strlen((char *)jobEnv->jobId)):(sizeof(jobNumber.arr)))\u00d6\n); strncpy(jobNumber.arr,(char *)jobEnv->jobId,jobNumber.len); \u00fc;\n   \u00e4 program.len = short((((sizeof(program.arr))>(strlen((char *)jobEnv\u00d6\n->program)))?(strlen((char *)jobEnv->program)):(sizeof(program.arr))));\u00d6\n strncpy(program.arr,(char *)jobEnv->program,program.len); \u00fc;\n   datasetcount = 0;\n   memset(&joblog,0,sizeof(joblog));\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n   EXEC SQL SET :timestamp = CURRENT TIMESTAMP;\n   SQLERROR:\n   if (SQLCODE) diag(\"SET\");\n   \u00fc\n   else\n   \u00e4\n   time_t temp;\n   struct tm *timeptr;\n   temp = time(0);\n   timeptr = localtime(&temp);\n   timestamp.len = strftime(timestamp.arr,sizeof(timestamp.arr)-1,\"%Y-%\u00d6\nm-%d-%H.%M.%S\", timeptr);\n   \u00fc\n   mvsSTRING _dataset;\n   _dataset = mvsSTRING(getenv(KEYWORD_PREFIX)) + \"/\" +\n             jobEnv->jobName + jobEnv->jobId +\n             mvsSTRING(timestamp.arr,timestamp.len);\n   dataset.len = short(_dataset.lengthOf());\n   JOBENV::DEBUG(1,(char *)_dataset);\n   memcpy(dataset.arr,(char *)_dataset,dataset.len+1);\n\u00fc\n\nint DssJob::insert()\n\u00e4\n   CHAINITER::reset();\n   DssDataset * ds;\n   DssDataset * dp;\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n   EXEC SQL INSERT INTO DSSJOBS\n    VALUES(:timestamp,\n           :jobName, :jobNumber, :program, :dataset, :joblog);\n   \u00fc\n   else\n   \u00e4\n     if (fileDB2)\n     fprintf(fileDB2,\"insert into DSSJOBS:\u00d6n\");\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"jobName\",jobName.len,j\u00d6\nobName.len,jobName.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"jobNumber\",jobNumber.l\u00d6\nen,jobNumber.len,jobNumber.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"program\",program.len,p\u00d6\nrogram.len,program.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"dataset\",dataset.len,d\u00d6\nataset.len,dataset.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"joblog\",joblog.len,job\u00d6\nlog.len,joblog.arr);;\n    \u00fc\n\n   ds = (DssDataset *)CHAINITER::next();\n   while(ds)\n   \u00e4\n    if(| ds->insert())\n     Error(Msg(10000+1002)<<ds->dataset.arr<<eol,Abort);\n     dp = ds;\n     ds = (DssDataset *)CHAINITER::next();\n     mCHAIN::del(dp);\n     delete dp;\n   \u00fc\n  commit();\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSJOBS\");\n  markerror();\n  return 0;\n\u00fc\n\nstatic char today\u00c412\u00dc;\n\nint DssJob::query(mCHAIN *m,char * date)\n\u00e4\n   if (useDB2==false)\n\treturn 0;\n   CHAINITER iter(*m);\n   mvsSTRING like(\" \");\n   chainE * mask = iter.next();\n   if ( date == 0 )\n   \u00e4\n     date = today;\n     formatTime(today,sizeof(today),\"%d.%m.%Y\");\n     JOBENV::DEBUG(1,(char *)date);\n   \u00fc\n   int likeFlag = 0;\n   while(mask)\n   \u00e4\n      int i, j;\n      for(i=0, j=0;mask->chainEid\u00c4i\u00dc;i++)\n      \u00e4\n         if(mask->chainEid\u00c4i\u00dc |= '*')\n            mask->chainEid\u00c4j++\u00dc = mask->chainEid\u00c4i\u00dc;\n         else if (mask->chainEid\u00c4i+1\u00dc |= '*')\n         \u00e4\n            mask->chainEid\u00c4j++\u00dc = '%';\n            likeFlag = 1;\n         \u00fc\n       \u00fc\n       if (mask->chainEid\u00c4j-1\u00dc |= '%')\n           mask->chainEid\u00c4j++\u00dc = '%';\n      mask->chainEid\u00c4j\u00dc = 0;\n      like = like + \"A.DATASET LIKE '\"+mvsSTRING(mask->chainEid)+\"' \";\n      if (mask->next)\n         like = like + \" OR \";\n      mask = iter.next();\n   \u00fc\n   JOBENV::DEBUG(1,(char *)like);\n     \u00e4\n     char * p\u00c48\u00dc;\n     Msg(10000+122)<<dSql<<eol;\n     size_t l = strlen(dSql);\n     int j = 0;\n     for(int i = 0;i<l&&j<8;i++)\n       if (dSql\u00c4i\u00dc=='%' && dSql\u00c4i+2\u00dc == '%')\n         \u00e4\n         switch (dSql\u00c4i+1\u00dc)\n           \u00e4\n           case 'M':\n           case 'm': p\u00c4j++\u00dc = like;\n             break;\n           case 'D':\n           case 'd': p\u00c4j++\u00dc = date;\n             break;\n           default :\n             JOBENV::Error(Msg(10000+121)<<dSql\u00c4i\u00dc<<eol,JOBENV::Abort);\n           \u00fc\n           dSql\u00c4i+1\u00dc = 's';\n         strcpy(dSql+i+2,dSql+i+3);\n         l -= 2;\n         \u00fc\n       switch(j)\n         \u00e4\n         default:\n         case 0:\n         strcpy(dynamicSql.arr,dSql);\n         break;\n         case 1:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc);\n         break;\n         case 2:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc);\n         break;\n         case 3:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc);\n         break;\n         case 4:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc);\n         break;\n         case 5:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc);\n         break;\n         case 6:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc);\n         break;\n         case 7:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc,p\u00c46\u00dc);\n         break;\n         \u00fc\n     \u00fc\n   JOBENV::DEBUG(1,(char *)dynamicSql.arr);\n   Msg(10000+123)<<dynamicSql.arr<<eol;\n   dynamicSql.len =short(strlen(dynamicSql.arr));\n   tryToConnect();\n\t DssJob * job = 0;\n   int fetchCount = 0;\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n   EXEC SQL PREPARE FULL_QUERY FROM :dynamicSql;\n   EXEC SQL DECLARE C_FULL_QUERY CURSOR FOR FULL_QUERY;\n   EXEC SQL OPEN C_FULL_QUERY;\n\n   for (;;)\n   \u00e4\n      EXEC SQL FETCH C_FULL_QUERY INTO\n      :record_key,\n      :record_job,\n      :record_dataset,\n      :record_volumes,\n      :record_size;\n      if (SQLCODE == 100) break;\n\n        if (job == 0 ]]\n         memcmp(job->timestamp.arr,record_job.arr,job->timestamp.len))\n    \u00e4\n         job = new DssJob((TIMESTAMP&)record_job);\n         dssJobs.addlast(job);\n         fetchCount++;\n        \u00fc\n        DssDataset * dataset = new DssDataset(job,\n                                        record_dataset.arr,\n                                        record_volumes.arr,\n                                        record_type,\n                                        record_size);\n   \u00fc\n   EXEC SQL CLOSE C_FULL_QUERY;\n   return fetchCount;\nSQLERROR:\n   diag(\"FULL QUERY\");\n   markerror();\n   return -1;\n\u00fc\n\nint DssJob::doWeNeed(const char * d)\n  \u00e4\n  CHAINITER iter(this);\n  DssDataset * ds =(DssDataset *)iter.next();\n  while (ds)\n    \u00e4\n    if (ds->compare(d))\n      return 1;\n    ds =(DssDataset *)iter.next();\n    \u00fc\n  return 0;\n  \u00fc\n\nint DssJob::allOnline()\n\u00e4\n char _genFileName\u00c41024\u00dc;\n  FILE *   restore = fopen(genOpenName(\"RESTORE\",_genFileName),\"wb\");\n  if (| restore)\n     JOBENV::Error(Msg(10000+110)<<\"RESTORE\"<<eol,JOBENV::Abort);\n  int rc = 1;\n  CHAINITER iter(dssJobs);\n  DssJob * job = (DssJob*)iter.next();\n  while (job)\n  \u00e4\n    int file = open(genOpenName(job->getDatasetName(),_genFileName),0x0\u00d6\n2+0);\n    if (file < 0)\n    \u00e4\n       rc = 0;\n       JOBENV::Error(Msg(10000+120)<<job->getDatasetName()<<strerror((*\u00d6\n__errno()))\n         <<eol,JOBENV::Continue);\n       fprintf(restore,\"%s\u00d6n\",job->getDatasetName());\n    \u00fc\n    else\n       close(file);\n    job = (DssJob*)iter.next();\n  \u00fc\n  fclose(restore);\n  return rc;\n\u00fc\n\n\n\n\n\n\nDssDataset::DssDataset(DssJob* j,char *n,char *v,int t,int s):\nSQLINTERFACE(),\nchainE(n),\njob(j)\n\u00e4\n   job->addlast(this);\n   dataset.len = (((strlen(n))>(sizeof(dataset.arr)))?(sizeof(dataset.a\u00d6\nrr)):(strlen(n)));\n   strncpy(dataset.arr,n,dataset.len);\n   dataset.arr\u00c4dataset.len\u00dc = 0;\n\n   volumes.len = (((strlen(v))>(sizeof(volumes.arr)-1))?(sizeof(volumes\u00d6\n.arr)-1):(strlen(v)));\n   strncpy(volumes.arr,v,volumes.len);\n   volumes.arr\u00c4volumes.len\u00dc = 0;\n   type = t;\n   recordsize = s;\n   JOBENV::DEBUG(1,\"Dataset construct\",n,v);\n\u00fc\n\nDssDataset::\u00dfDssDataset()\n\u00e4\n\u00fc\n\nint DssDataset::insert()\n\u00e4\n   tryToConnect();\n   memcpy(timestamp.arr,job->timestamp.arr,job->timestamp.len+1);\n   timestamp.len = job->timestamp.len;\n   JOBENV::DEBUG(1,\"Dataset insert:\",dataset.arr);\n   if (useDB2)\n   \u00e4\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR;\n   EXEC SQL INSERT INTO DSSDATASETS\n   VALUES(CURRENT TIMESTAMP,\n   :timestamp,\n   :dataset,\n   :volumes,\n   :type,\n   :recordsize);\n   \u00fc\n   else\n   \u00e4\n   if (SQLINTERFACE::fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\"insert into DSSDATASETS:\u00d6n\");\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"timestamp\",timestamp.len\u00d6\n,timestamp.len,timestamp.arr);;\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"dataset\",dataset.len,dat\u00d6\naset.len,dataset.arr);;\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"volumes\",volumes.len,vol\u00d6\numes.len,volumes.arr);;\n   if (fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\" type:%d\u00d6n size:%d\u00d6n\",type,recordsize\u00d6\n);\n   \u00fc\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSDATASETS\");\n  markerror();\n  return 0;\n\u00fc\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDSSDB": {"ttr": 169, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "??=pragma filetag(\"IBM-273\")\n??=pragma nomargins nosequence\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <string.h>\n#include <stddef.h>\nextern \"OS\" void DSNHLI(void *);\ntypedef struct\n              \u00e4 short   SQLPLLEN;\n                short   SQLFLAGS;\n                short   SQLCTYPE;\n                char    SQLPROGN??(8??);\n                unsigned short SQLTIMES??(4??);\n                short   SQLSECTN;\n                char   *SQLCODEP;\n                char   *SQLVPARM;\n                char   *SQLAPARM;\n                short   SQLSTNM7;\n                short   SQLSTYPE;\n                long    SQLSTNUM;\n                unsigned long SQLRSRVD??(5??);\n              \u00fc SQLPLIST;\ntypedef struct\n              \u00e4 short    SQLTYPE;\n                short    SQLLEN;\n                char    *SQLADDR;\n                char    *SQLIND;\n                short    SQLNAMLEN;\n                char     SQLNAMDATA??(30??);\n              \u00fc SQLELTS;\ntypedef SQLELTS     *SQLELTS_PTR;\ntypedef struct\n              \u00e4 long          SQLLONGLEN;\n                unsigned long RESERVED;\n                char         *SQLDATALEN;\n                short         SQLNAMLEN;\n                char          SQLNAMDATA??(30??);\n              \u00fc SQLELTS2;\ntypedef struct\n    \u00e4 char   SQLDAID??(8??);\n      long   SQLDABC;\n      short  SQLN;\n      short  SQLD;\n      char  SQLPVELT??( sizeof(SQLELTS) ??);\n    \u00fc SQLPVARS;\ntypedef SQLPVARS *SQLPVARS_PTR;\nchar    SQLTEMP??( 129 ??) ;\nlong    DSNTEMP ;\nlong    DSNNROWS ;\nchar    DSNPNM??( 387 ??) ;\n#define SQL_FILE_READ 2\n#define SQL_FILE_CREATE 8\n#define SQL_FILE_OVERWRITE 16\n#define SQL_FILE_APPEND 32\nclass mERROR;\n\nclass mERRORPSTACK \u00e4\nprivate:\n   long int ip;\n   long int max;\n   mERROR * * sp;\npublic:\n   mERRORPSTACK(long int size=256);\n   void push(mERROR * value);\n   mERROR * examine();\n   int    callNextHandler(int);\n   mERROR * pop();\n   void  reset();\n  \u00dfmERRORPSTACK();\n\n\u00fc;\n\n\nclass mERROR\n\u00e4\nprotected:\n   char err;\n   int (* handler)(int);\nenum ERROR_ACTION\u00e4Warning, Abort\u00fc;\npublic:\n\nstatic int max_rc;\n\nfriend class mERRORPSTACK;\n   mERROR();\n   mERROR(int (*)(int) );\n\t virtual \u00dfmERROR()\u00e4\u00fc;\n   long int iserror()\u00e4return err;\u00fc\n   int  markerror(int code = 1)\n   \u00e4\n    err = 1;\n    if (handler) return (handler(code));\n    else return 0;\n   \u00fc\n   void clearerror()\u00e4err = 0;\u00fc\n   void setmERRORHandler(int (*h)(int))\u00e4handler = h;\u00fc\n   int error(char *,ERROR_ACTION);\n\u00fc;\n\nextern mERRORPSTACK mErrorPStack;\n\n\n\n\n\n\n\n\n\n\n\n\nextern \"C\"\nchar * genOpenName(const char *name, char *nm);\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n  extern \"C\" \u00e4\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\nextern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n   extern \"C\" \u00e4\n\n   typedef  int ptrdiff_t;\n\n       typedef unsigned int size_t;\n\n\n\n\n\n   \u00fc\n\n                   #pragma checkout(resume)\n\n  extern \"C\" \u00e4\n\n\n\n\n\n        extern \"builtin\"\n\n        int     __clcl (void*, void*, unsigned int*,\n                        unsigned int*, unsigned char);\n\n\n\n\n        extern \"builtin\"\n\n        int     __stck (unsigned long long *);\n\n\n\n\n        extern \"builtin\"\n\n        int     __stcke (void *);\n\n\n\n\n        #pragma pack (1)\n\n          typedef struct __stcke_tod \u00e4\n            unsigned char      c;\n            unsigned long long slice;\n            unsigned int       i;\n          \u00fc __stcke_tod_t;\n\n          typedef struct __stcke_tag \u00e4\n            unsigned char  zeros;\n            __stcke_tod_t  tod;\n            unsigned short p_field;\n          \u00fc __stcke_t;\n        #pragma pack (reset)\n\n\n\n\n\n        extern \"builtin\" \u00e4\n\n        void  __tr (unsigned char*, const unsigned char*,              \u00d6\n       unsigned char);\n\n      \u00fc\n\n        extern \"builtin\" \u00e4\n\n        int  __ed (unsigned char*, unsigned char*, unsigned char);\n        int  __edmk (unsigned char*, unsigned char*,                   \u00d6\n   unsigned char, unsigned char**);\n        int  __trt (unsigned char*, const unsigned char*,              \u00d6\n       unsigned char, unsigned char*, unsigned char**);\n        int  __nc (unsigned char*, unsigned char*, unsigned char);\n        int  __oc (unsigned char*, unsigned char*, unsigned char);\n        int  __xc (unsigned char*, unsigned char*, unsigned char);\n        void __pack (unsigned char*, unsigned char,                    \u00d6\n  unsigned char*, unsigned char);\n        void __unpk (unsigned char*, unsigned char,                    \u00d6\n  unsigned char*, unsigned char);\n\n      \u00fc\n\n        long double  __fmaddl (long double, long double, long double);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int    __lper (float*, float);\n        int    __lpdr (double*, double);\n        int    __lner (float*, float);\n        int    __lndr (double*, double);\n        float  __sqer (float);\n        double __sqdr (double);\n\n      \u00fc\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        float       __fier (float);\n        double      __fidr (double);\n        long double __fixr (long double);\n        int         __cfer (int*, int, float);\n        int         __cfdr (int*, int, double);\n        int         __cfxr (int*, int, long double);\n        int         __lpxr (long double*, long double);\n        int         __lnxr (long double*, long double);\n        long double __sqxr (long double);\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int __thder (double*, float);\n        int __thdr  (double*, double);\n        int __tbedr (float*, int, double);\n        int __tbdr  (double*, int, double);\n\n      \u00fc\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        unsigned short __lrvh  (unsigned short*);\n        unsigned int   __lrv   (unsigned int*);\n        void  __strvh (unsigned short, unsigned short*);\n        void  __strv  (unsigned int, unsigned int*);\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n      extern \"builtin\" \u00e4\n\n        int  __cvb(char *op2);\n        void __cvd(int op1, char *op2);\n        int  __zap(unsigned char *op1, unsigned char len1,\n                   unsigned char *op2, unsigned char len2);\n\n\n\n\n\n          int __clcle(char *op1, unsigned long op1_len, unsigned char o\u00d6\np2,\n                      char *op3, unsigned long op3_len);\n          int __mvcle(char *op1, unsigned long op1_len, unsigned char o\u00d6\np2,\n                      char *op3, unsigned long op3_len);\n\n\n\n\n\n          int __tre(char *op1, unsigned long op1_len,\n                    char *op2, unsigned char test_char);\n\n\n            long long __cvbg(char *op2);\n            void      __cvdg(long long op1, char *op2);\n\n\n\n\n\n\n\n\n\n\n      \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        typedef union \u00e4\n            struct __dword \u00e4\n                unsigned int __high_word;\n                unsigned int __low_word;\n            \u00fc __s_dword;\n            unsigned long long __dword;\n        \u00fc __plo_entry_t;\n\n        typedef union \u00e4\n            unsigned long long   __val;\n            unsigned long long * __ptr;\n        \u00fc __plo_ull_ullptr_t;\n\n        typedef union \u00e4\n            unsigned int       * __uint_ptr;\n            unsigned long long * __ull_ptr;\n        \u00fc __plo_uintptr_ullptr_t;\n\n        typedef __plo_ull_ullptr_t __plo_plist\u00c418\u00dc;\n\n\n\n\n\n\n\n          extern \"builtin\" \u00e4\n\n          int __plo_CL     (void *lock,\n                            unsigned int *op1c, unsigned int *op2,\n                            unsigned int *op3, unsigned int *op4);\n          int __plo_CS     (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2);\n          int __plo_DCS    (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2,\n                            unsigned int *op3c, unsigned int op3r,\n                            unsigned int *op4);\n          int __plo_CSST   (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2,\n                            unsigned int op3, unsigned int *op4);\n          int __plo_CSDST  (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2, void *param_list);\n          int __plo_CSTST  (void *lock,\n                            unsigned int *op1c, unsigned int op1r,\n                            unsigned int *op2, void *param_list);\n\n        \u00fc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n    typedef struct __div_t\n      \u00e4\n      int quot;\n      int rem;\n      \u00fc div_t;\n\n    typedef struct __ldiv_t\n      \u00e4\n      long int quot;\n      long int rem;\n      \u00fc ldiv_t;\n\n   typedef struct \u00e4\n               long long quot;\n               long long rem;\n   \u00fc lldiv_t;\n\n       typedef struct \u00e4\n                 long  __uheap_size;\n                 long  __uheap_bytes_alloc;\n                 long  __uheap_bytes_free;\n       \u00fc hreport_t;\n\n\n\n\n\n      extern \"builtin\"\n      void **_Gtab(int);\n\n      extern \"builtin\"\n      const void *_gtca(void);\n\n\n\n\n\n\n\n\n      long long int strtoll(const char * restrict, char * * restrict, i\u00d6\nnt);\n      unsigned long long int strtoull(const char * restrict, char * * r\u00d6\nestrict, int);\n        #pragma map (strtoll,   \"\u00d6174\u00d6174STRLL\")\n        #pragma map (strtoull,  \"\u00d6174\u00d6174STRULL\")\n\n    double   atof (const char *);\n    int      atoi (const char *);\n    long int atol (const char *);\n    double   strtod (const char * restrict, char * * restrict);\n    long int strtol (const char * restrict, char * * restrict,\n                      int);\n    unsigned long int strtoul (const char * restrict,\n                                char * * restrict, int);\n    int      rand (void);\n    void     srand (unsigned int);\n        long long int strtoll (const char * restrict,\n                                char * * restrict, int);\n        unsigned long long int strtoull (const char * restrict,\n                                          char * * restrict, int);\n\n\n\n\n      void *   calloc (size_t, size_t);\n      void     free (void *);\n      void *   malloc (size_t);\n      void *   realloc (void *, size_t);\n\n\n\n    extern \"builtin\"\n    int       __abs (int);\n\n\n\n     #pragma map (__getenv,        \"\u00d6174\u00d6174GETENV\")\n\n\n\n    void     abort (void);\n    int      atexit (void (*)(void));\n    void     exit (int);\n    char *   getenv (const char *);\n    char *   __getenv (const char *);\n    int      system (const char *);\n    void *   bsearch (const void *, const void *,\n                      size_t, size_t,\n                      int (*)(const void *,\n                                    const void *));\n    void     qsort (void *, size_t, size_t,\n                    int (*)(const void *,\n                                  const void *));\n\n    int unatexit(void (*)(void));\n\n\n        int      __heaprpt(hreport_t *);\n\n    extern \"C++\" \u00e4\n      inline int abs (int x) \u00e4 return __abs(x); \u00fc\n    \u00fc\n\n\n\n\n\n\n    div_t    div (int, int);\n    long int labs (long int);\n    ldiv_t   ldiv (long int, long int);\n    int      mblen (const char *, size_t);\n    int      mbtowc (wchar_t * restrict,\n                      const char * restrict, size_t);\n    int      wctomb (char *, wchar_t);\n    size_t   mbstowcs (wchar_t * restrict,\n                        const char * restrict, size_t);\n    size_t   wcstombs (char * restrict,\n                        const wchar_t * restrict, size_t);\n\n\n      long long llabs(long long );\n      lldiv_t lldiv(long long , long long );\n\n\n\n\n\n\n\n\n\n\n\n      void (*  fetch (const char *))();\n      void (*  fetchep (void (*)()))();\n      int    release (void (*)());\n\n\n        inline int fortrc (void)\n          \u00e4  return (*( (int *)((char *)_gtca() + 568) ))/4; \u00fc\n\n\n\n      #pragma map (rpmatch, \"\u00d6174\u00d6174RPMTCH\")\n      #pragma map (csid,    \"\u00d6174\u00d6174CSID\")\n      #pragma map (wcsid,   \"\u00d6174\u00d6174WCSID\")\n\n      int __librel (void);\n        int clearenv (void);\n      int rpmatch(const char *);\n      int csid(const char *);\n      int wcsid(const wchar_t);\n\n\n      typedef unsigned int cs_t;\n\n      typedef union \u00e4\n        struct \u00e4\n          unsigned int first_word;\n          unsigned int second_word;\n        \u00fc double_word;\n        double alignment_dummy;\n      \u00fc cds_t;\n\n        extern \"builtin\"\n\n      int     __cs (cs_t *, cs_t *, cs_t);\n      int     (cs) (cs_t *, cs_t *, cs_t);\n\n        extern \"builtin\"\n\n        int     __cs1 (void *, void *, void *);\n\n\n\n\n        extern \"builtin\"\n\n      int     __cds (cds_t *, cds_t *, cds_t);\n      int     (cds) (cds_t *, cds_t *, cds_t);\n\n        extern \"builtin\"\n\n        int     __cds1 (void *, void *, void *);\n\n\n\n\n\n\n\n\n\n\n\n\n    #pragma map(__EnvnA, \"\u00d6174\u00d6174ENVNA\")\n\n    char *** __EnvnA(void);\n    char *** __Envn(void);\n\n\n\n\n\n\n\n\n            extern \"builtin\"\n            void *__alloca(unsigned int x);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        double       drand48(void);\n        double       erand48(unsigned short int \u00c43\u00dc);\n        long int     jrand48(unsigned short int \u00c43\u00dc);\n        void         lcong48(unsigned short int \u00c47\u00dc);\n        long int     lrand48(void);\n        long int     mrand48(void);\n        long int     nrand48(unsigned short int \u00c43\u00dc);\n          int          putenv(const char *);\n        unsigned short int  *seed48(unsigned short int \u00c43\u00dc);\n        void         srand48(long int);\n          void         setkey(const char *);\n\n\n\n\n\n\n\n\n\n\n        long         a64l(const char *);\n        char        *ecvt(double, int, int * restrict,\n                                       int * restrict);\n        char        *fcvt(double, int, int * restrict,\n                                       int * restrict);\n        char        *gcvt(double, int, char *);\n        int          getsubopt(char **, char *const *, char **);\n        char        *initstate(unsigned, char *, size_t);\n        char        *l64a(long);\n        int          mkstemp(char *);\n        char        *mktemp(char *);\n        long         random(void);\n        char        *realpath(const char * restrict,\n                                    char * restrict);\n        char        *setstate(const char *);\n        void         srandom(unsigned);\n           int          ttyslot(void);\n           void        *valloc(size_t);\n          int          grantpt(int);\n          char        *ptsname(int);\n          int          unlockpt(int);\n\n\n\n\n       int rand_r(unsigned int *);\n\n\n\n\n    int __discarddata(void *, size_t);\n\n\n\n          int setenv (const char *, const char *, int);\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n\n  extern \"C++\" \u00e4\n        inline long abs (long x) \u00e4 return labs(x); \u00fc\n        inline ldiv_t div (long x, long y)\n        \u00e4 return ldiv(x,y); \u00fc\n  \u00fc\n\n\n                   #pragma checkout(resume)\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n          typedef unsigned int dev_t ;\n\n\n\n\n             typedef int gid_t;\n\n\n\n\n          typedef unsigned int  ino_t ;\n\n\n\n          typedef int mode_t ;\n\n\n\n\n          typedef int nlink_t ;\n\n\n\n\n\n            typedef  int off_t ;\n\n\n           typedef long long off64_t;\n\n\n          typedef signed int pid_t ;\n\n\n\n\n            typedef signed int ssize_t ;\n\n\n\n\n             typedef int uid_t;\n\n\n\n\n\n\n\n          typedef long time_t ;\n\n\n\n          typedef unsigned long clock_t;\n\n\n\n          typedef struct \u00e4\n                     unsigned int   __sigs_0;\n                     unsigned int   __sigs_1;\n                  \u00fc sigset_t ;\n\n\n\n          typedef unsigned char cc_t;\n\n\n\n          typedef unsigned int speed_t ;\n\n\n\n          typedef unsigned int tcflag_t ;\n\n\n\n\n\n\n\n          typedef unsigned int mtm_t ;\n\n\n\n\n          typedef unsigned int rdev_t ;\n\n\n\n\n          typedef char tid_t\u00c48\u00dc;\n\n\n            typedef struct \u00e4\n                      char __\u00c40x08\u00dc;\n            \u00fc __osenv_token;\n\n\n\n\n\n\n\n          typedef struct \u00e4\n                     char __\u00c40x08\u00dc;\n          \u00fc pthread_t;\n\n          typedef  struct \u00e4\n                      char __\u00c40x58\u00dc;\n          \u00fc pthread_attr_t;\n\n             typedef struct \u00e4\n                        unsigned long __m;\n             \u00fc pthread_mutex_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_mutexattr_t;\n\n                typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n                \u00fc pthread_cond_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_condattr_t;\n\n          typedef struct \u00e4\n                     char __\u00c40x04\u00dc;\n          \u00fc pthread_key_t;\n\n          typedef int pthread_once_t;\n\n             typedef struct \u00e4\n                        char __\u00c40x04\u00dc;\n              \u00fc pthread_rwlockattr_t;\n\n             typedef struct \u00e4\n                        char __\u00c40x04\u00dc;\n              \u00fc pthread_rwlock_t;\n\n\n\n\n\n\n\n         typedef long key_t;\n\n\n\n\n\n\n\n         typedef int id_t;\n\n         typedef unsigned int  useconds_t;\n\n\n         typedef unsigned char sa_family_t;\n\n\n\n         typedef unsigned short in_port_t;\n\n\n            typedef long mcontext_t\u00c440\u00dc;\n\n\n\n\n\n          typedef  unsigned char  u_char;\n\n          typedef  unsigned int   u_int;\n\n          typedef  unsigned short ushort;\n\n          typedef  unsigned short u_short;\n\n          typedef  unsigned long  u_long;\n\n\n\n\n\n         typedef unsigned long in_addr_t;\n\n         typedef in_addr_t ip_addr_t;\n\n\n         typedef  char *    caddr_t;\n\n\n\n\n\n\n         typedef signed long blkcnt_t;\n\n         typedef signed int    blksize_t;\n\n         typedef unsigned long fsblkcnt_t;\n\n         typedef unsigned int  fsfilcnt_t;\n\n\n         typedef signed int    suseconds_t;\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n     struct __file;\n     typedef int _GETCFUNC(struct __file *);\n     typedef int _PUTCFUNC(int, struct __file *);\n     struct __file\n        \u00e4\n        unsigned char  *__bufPtr;\n        long int        __countIn;\n        long int        __countOut;\n        _GETCFUNC      *__fcbgetc;\n        _PUTCFUNC      *__fcbputc;\n        unsigned int    __cntlinterpret : 1;\n        unsigned int    __fcb_ascii : 1;\n        unsigned int    __fcb_orientation : 2;\n        \u00fc;\n\n     struct __ffile\n       \u00e4\n       struct __file *__fp;\n       \u00fc;\n\n     typedef struct __ffile *__FILEP;\n\n\n     typedef struct __ffile FILE;\n\n  struct __fpos_t \u00e4\n    long int __fpos_elem\u00c48\u00dc;\n    \u00fc;\n\n  typedef struct __fpos_t fpos_t;\n\n\n\n\n\n\n      typedef char  *___valist;\n    typedef ___valist  va_list;\n\n\n\n\n\n\n\n\n\n\n     typedef const unsigned short *__cusp;\n\n\n\n\n\n\n\n\n\n      #pragma map (vprintf, \"\u00d6174\u00d6174VPRNT\")\n      #pragma map (vfprintf, \"\u00d6174\u00d6174VFPRT\")\n        #pragma map (vsprintf, \"\u00d6174\u00d6174VSPRT\")\n\n\n\n\n    void     clearerr (FILE *);\n    int      fclose (FILE *);\n    int      feof (FILE *);\n    int      ferror (FILE *);\n    int      fflush (FILE *);\n    int      fgetc (FILE *);\n    int      fgetpos (FILE * restrict, fpos_t * restrict);\n    char    *fgets (char * restrict, int, FILE * restrict);\n    FILE    *fopen (const char * restrict,\n                    const char * restrict);\n    int      fprintf (FILE * restrict,\n                       const char * restrict, ...);\n    int      fputc (int, FILE *);\n    int      fputs (const char * restrict, FILE * restrict);\n    size_t   fread (void * restrict, size_t,\n                    size_t, FILE * restrict);\n    FILE    *freopen (const char * restrict,\n                      const char * restrict, FILE * restrict);\n    int      fscanf (FILE * restrict,\n                      const char * restrict, ...);\n    int      fseek (FILE *, long int, int);\n    int      fsetpos (FILE *, const fpos_t *);\n    long int ftell (FILE *);\n   size_t   fwrite (const void * restrict, size_t, size_t,\n                     FILE * restrict);\n    int      getc (FILE *);\n    int      getchar (void);\n    char    *gets (char *);\n    void     perror (const char *);\n    int      printf (const char * restrict, ...);\n    int      putc (int, FILE *);\n    int      putchar (int);\n    int      puts (const char *);\n    int      remove (const char *);\n    int      rename (const char *, const char *);\n    void     rewind (FILE *);\n    int      scanf (const char * restrict, ...);\n    void     setbuf (FILE * restrict, char * restrict);\n    int      setvbuf (FILE * restrict, char * restrict,\n                      int, size_t);\n      int      sprintf (char * restrict,\n                         const char * restrict, ...);\n    int      sscanf (const char * restrict,\n                     const char * restrict, ...);\n    FILE    *tmpfile (void);\n    char    *tmpnam (char *);\n    int      ungetc (int, FILE *);\n    int      vfprintf (FILE * restrict,\n                        const char * restrict, ___valist);\n    int      vprintf (const char * restrict, ___valist);\n    int      vsprintf (char * restrict,\n                        const char * restrict, ___valist);\n\n\n         off_t ftello(FILE *);\n         int fseeko(FILE *, off_t, int);\n\n\n\n\n\n\n\n\n      struct __S99struc\n        \u00e4\n             unsigned char __S99RBLN;\n             unsigned char __S99VERB;\n             unsigned short __S99FLAG1;\n             unsigned short __S99ERROR;\n             unsigned short __S99INFO;\n             void *__S99TXTPP;\n             void *__S99S99X;\n             unsigned int   __S99FLAG2;\n        \u00fc;\n\n      typedef struct __S99struc __S99parms;\n\n\n    struct __S99rbx\n          \u00e4\n        char           __S99EID\u00c46\u00dc;\n        unsigned char  __S99EVER;\n        unsigned char  __S99EOPTS;\n        unsigned char  __S99ESUBP;\n        unsigned char  __S99EKEY;\n        unsigned char  __S99EMGSV;\n        unsigned char  __S99ENMSG;\n        void *__S99ECPPL;\n        char           __reserved;\n        char           __S99ERES;\n        unsigned char  __S99ERCO;\n        unsigned char  __S99ERCF;\n        int            __S99EWRC;\n        void *__S99EMSGP;\n        unsigned short __S99EERR;\n        unsigned short __S99EINFO;\n        int            __reserv2;\n        \u00fc;\n\n     typedef struct __S99rbx  __S99rbx_t;\n\n     struct  __S99emparms \u00e4\n        unsigned char  __EMFUNCT;\n        unsigned char  __EMIDNUM;\n        unsigned char  __EMNMSGBK;\n        unsigned char  __filler1;\n        void *__EMS99RBP;\n        int            __EMRETCOD;\n        void *__EMCPPLP;\n        void *__EMBUFP;\n        int            __reserv1;\n        int            __reserv2;\n        \u00fc;\n\n       typedef struct __S99emparms  __S99emparms_t;\n\n\n\n    typedef enum \u00e4\n       __disk       =  0,\n       __terminal   =  1,\n       __printer    =  2,\n       __tape       =  3,\n       __tdq        =  5,\n       __dummy      =  6,\n\n       __msgfile    =  7,\n\n       __memory     =  8,\n       __hfs        =  9,\n       __hiperspace = 10,\n\n       __msgrtn     = 11,\n\n       __other      = 0xff\n    \u00fc __device_t;\n\n\n\n\n\n\n\n\n    struct __fileData \u00e4\n         unsigned int   __recfmF   :    1,\n                        __recfmV   :    1,\n                        __recfmU   :    1,\n                        __recfmS   :    1,\n                        __recfmBlk :    1,\n                        __recfmASA :    1,\n                        __recfmM   :    1,\n                        __dsorgPO  :    1,\n                        __dsorgPDSmem : 1,\n                        __dsorgPDSdir : 1,\n                        __dsorgPS  :    1,\n                        __dsorgConcat : 1,\n                        __dsorgMem :    1,\n                        __dsorgHiper  : 1,\n                        __dsorgTemp:    1,\n                        __dsorgVSAM:    1,\n\n                        __dsorgHFS :    1,\n\n                        __openmode :    2,\n                        __modeflag :    4,\n                        __dsorgPDSE :   1,\n\n                        __vsamRLS :     3,\n                        __vsamEA  :     1,\n                        __recfmB  :     1,\n                        __reserve2 :    3;\n\n         __device_t     __device;\n         unsigned long  __blksize,\n                        __maxreclen;\n         union \u00e4\n           struct \u00e4\n             unsigned short __vsam_type;\n             unsigned long  __vsam_keylen;\n             unsigned long  __vsam_RKP;\n           \u00fc __vsam;\n           struct \u00e4\n             unsigned short __disk_vsam_type;\n             unsigned char  __disk_access_method;\n             unsigned char  __disk_noseek_to_seek;\n             long           __disk_reserve\u00c42\u00dc;\n           \u00fc __disk;\n         \u00fc __device_specific;\n         char *         __dsname;\n         void *         __reserve4;\n    \u00fc;\n\n    typedef struct __fileData fldata_t;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int    svc99 (__S99parms *);\n      int    flocate (FILE *, const void *, size_t, int);\n      int    fdelrec (FILE *);\n      size_t fupdate (const void *, size_t, FILE *);\n      int    clrmemf (int);\n      int    fldata (FILE *, char *, fldata_t *);\n\n\n\n\n\n\n\n\n    typedef struct \u00e4\n              unsigned int  __fill,\n                            __recnum;\n    \u00fc __rrds_key_type;\n\n\n      typedef struct __amrctype \u00e4\n\n       union \u00e4\n               int __error;\n          struct \u00e4\n            unsigned short __syscode,\n                           __rc;\n          \u00fc __abend;\n          struct \u00e4\n             unsigned char __fdbk_fill,\n                           __rc,\n                           __ftncd,\n                           __fdbk;\n          \u00fc __feedback;\n          struct \u00e4\n             unsigned short __svc99_info,\n                            __svc99_error;\n          \u00fc __alloc;\n       \u00fc __code;\n       unsigned int  __RBA;\n       unsigned int      __last_op;\n       struct \u00e4\n        unsigned int   __len_fill;\n        unsigned int   __len;\n        char           __str\u00c4120\u00dc;\n        unsigned int   __parmr0;\n        unsigned int   __parmr1;\n        unsigned int   __fill2\u00c42\u00dc;\n        char           __str2\u00c464\u00dc;\n\n       \u00fc __msg;\n\n       unsigned char        __rplfdbwd\u00c44\u00dc;\n       unsigned long long   __XRBA;\n\n       unsigned char        __amrc_noseek_to_seek;\n\n       char                 __amrc_pad\u00c423\u00dc;\n\n    \u00fc __amrc_type;\n\n\n    typedef __amrc_type *__amrc_ptr;\n\n\n    typedef struct __amrc2type \u00e4\n             int       __error2;\n\n        FILE          *__fileptr;\n             int       __reserved\u00c46\u00dc;\n    \u00fc __amrc2_type;\n\n\n    typedef __amrc2_type *__amrc2_ptr;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        FILE *fdopen(int, const char *);\n        int fileno(FILE *);\n        char *ctermid(char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n         char *cuserid(char *);\n\n\n          int          getopt(int, char * const \u00c4\u00dc, const char *);\n\n\n         int getw(FILE *);\n         int putw(int, FILE *);\n\n       extern char *optarg;\n       extern int optind, opterr, optopt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n       int pclose(FILE *);\n       FILE *popen(const char *, const char *);\n       char  *tempnam(const char *, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n     #pragma map (__snprtf,  \"\u00d6174\u00d6174SNPRTF\")\n\n   int __snprtf(char *restrict, size_t, const char *restrict, ...);\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n  extern \"C\" \u00e4\n\n\n  void  __abort(void);\n  void  assert(int);\n\n\n\n\n  \u00fc\n\n\n\nextern \"C\" \u00e4\n\n\n\n\n\n\n      inline __FILEP* const * __gtab_filep(int e)       \u00e4 return (__FIL\u00d6\nEP* const *)_Gtab(e); \u00fc\n\n\n\n\n\u00fc\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\nenum genOpenNameType\n\u00e4  sas_hfs,\n   ibm_hfs,\n   sas_ddn,\n   ibm_ddn,\n   sas_dsn,\n   ibm_dsn,\n   ont_dsn,\n   ont_ddn,\n   ont_mem,\n   ont_unknown,\n   genOpenNameType_int = -1\n\u00fc;\n\ngenOpenNameType genOpenType(const char *);\nchar * stripMemberName(const char *name, char* nm);\nchar * onlyMemberName(const char *name, char* nm);\n\n\n\nunsigned short  Ushort(int i);\nunsigned short  Ushort(short s);\nunsigned short  Ushort(char c);\n\n\n\n\n\n\nvoid * memcpyp(void * target , const void * source, size_t tsize, size_\u00d6\nt ssize, int pad);\n\n\n\n\n\n\n\n\n\n\nenum ALIGNTYPE\u00e4aLEFT=1, aRIGHT=3, aCENTER=2, aASIS=0, ALINGNTYPE_int = \u00d6\n-1 \u00fc;\nenum CAPSTYPE\u00e4cUPPER=3, cLOWER=4, cWORD=2, cASIS=0, CAPSTYPE_int = -1\u00fc;\nenum FIELDTYPE\u00e4\n                      fCHAR =0,\n                      fALPHANUMERIC=1,\n                      fALPHABETIC=2,\n                      fNUMERIC= 3,\n                      fSLLTAG = 20,\n                      fLOGICAL=4 ,fHEXA=16,\n                      fBINARY=17 ,fDATE=5 ,fFTIME=6, fLISTBOX = 19,\n                      FIELDTYPE_int = -1\u00fc;\n\n\n\n\nclass FORMAT\n\u00e4\n   protected:\n   public:\n   ALIGNTYPE falign;\n   CAPSTYPE fcaps;\n  FORMAT() :  fcaps(cUPPER),\n    falign(aLEFT)\u00e4\u00fc\n\n  FORMAT(ALIGNTYPE a ,CAPSTYPE c=cASIS )\n  \u00e4\n\n    falign = a;\n      fcaps = c;\n  \u00fc\n  \u00dfFORMAT()\u00e4\u00fc\n\u00fc;\n\n\n\n\n\nextern FORMAT F_alcu;\nextern FORMAT F_alcw;\nextern FORMAT F_arcu;\n\n\n\nstruct str \u00e4\nenum status \u00e4 _VALID, _INVALID, status_int = -1 \u00fc;\nenum length \u00e4 FIX, VARIABLE \u00fc;\nchar  * c;\nchar  * lls;\nlong int     l;\nstatus type;\nlength ltype;\nstr()\u00e4 c = lls = 0; l = 0; type = _VALID; ltype = VARIABLE; \u00fc\n      \u00fc;\n\n\n\n\nclass sLL;\n\nclass mvsSTRING \u00e4\n   protected:\n   str st;\n   public:\n   static char parseSepCh;\n   mvsSTRING();\n   mvsSTRING(const char *);\n   mvsSTRING(const mvsSTRING &);\n   mvsSTRING(const char *,long int l );\n   mvsSTRING(const char , const long int l);\n\n\t\tvirtual \u00dfmvsSTRING();\n\n  virtual mvsSTRING& operator=(const char * );\n  virtual mvsSTRING& operator=(const mvsSTRING &);\n\t\tvirtual mvsSTRING& operator=(const sLL &);\n\n  virtual operator char *() const\n  \u00e4\n  if ( st.type == str::_VALID )\n      return st.c;\n\n   return st.c;\n   \u00fc\n   virtual operator unsigned char *() const\n  \u00e4\n  if ( st.type == str::_VALID )\n      return (unsigned char *)st.c;\n\n   return (unsigned char *)st.c;\n   \u00fc\n   virtual operator const char *() const\n   \u00e4\n    return (const char *)st.c;\n   \u00fc\n   virtual operator const unsigned char *() const\n   \u00e4\n    return (const unsigned char *)st.c;\n   \u00fc\n   friend long int operator==(const mvsSTRING & , const mvsSTRING &);\n   friend long int operator|=(const mvsSTRING & , const mvsSTRING &);\n   friend mvsSTRING operator+(const mvsSTRING & , const mvsSTRING &);\n\n   mvsSTRING& operator+=(const mvsSTRING&);\n   void operator<<(long int );\n   void operator>>(long int );\n\n   virtual char& operator\u00c4\u00dc(int);\n   virtual char& byte(int);\n   mvsSTRING operator()(const long int , long int );\n\n   long int hashcode();\n  char * nameOf();\n   long int  lengthOf() const\u00e4return st.l;\u00fc\n   long int toint()\n          \u00e4 long int ret = 0;\n             if ( st.l >= sizeof(long int) )\n                     ret = * (long int *)(st.c);\n           else if ( st.l == sizeof(short) )\n              ret = * (short *)(st.c);\n           else if ( st.l == 1)\n              ret = *st.c;\n         return ret ;\n       \u00fc\n   void fromint(long int i)\n       \u00e4\n             if ( st.l >= sizeof(long int) )\n                      *(long int *)(st.c) = i;\n           else if ( st.l == sizeof(short) )\n              *(short *)(st.c) = (short )i;\n           else if ( st.l == 1)\n          *st.c =(char) i;\n       \u00fc\n  void changeAll(char ,char );\n  void align(ALIGNTYPE );\n  void caps(CAPSTYPE);\n  mvsSTRING & strip();\n  int  isEmpty();\n  mvsSTRING& stripmvsSTRING();\n    mvsSTRING& format(FORMAT *);\n  void parse(mvsSTRING&, char, mvsSTRING&);\n  void parse(mvsSTRING&, char, mvsSTRING&, char ,mvsSTRING &);\n  void parse(mvsSTRING&, char *,mvsSTRING&);\n  void parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &);\n  void split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &);\n\tvoid split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mv\u00d6\nsSTRING &);\n\tvoid split(mvsSTRING&, char *, mvsSTRING&,char *,mvsSTRING &,char *,mv\u00d6\nsSTRING &,char *,mvsSTRING&);\n\tvoid parse(mvsSTRING&, char *, mvsSTRING&, char *,mvsSTRING &,char *,m\u00d6\nvsSTRING &);\n\tvoid dump(const char * ,int);\n  char * getLlmvsSTRING();\n\u00fc;\n\n\textern mvsSTRING nullstring;\n\n\n\nextern mvsSTRING nullmvsSTRING;\n\n\n\nclass LLC_mvsSTRING : public mvsSTRING\n\u00e4\n   short codev;\n  public:\n  LLC_mvsSTRING():mvsSTRING(), codev(0)\u00e4\u00fc\n  LLC_mvsSTRING(char * s):mvsSTRING(),codev(0)\n    \u00e4\n     short l = *(short*) s;\n     if ( l >= 4 )\n\n\t\t\t\t\u00e4\n\t\t\t\tmvsSTRING x = mvsSTRING(s+4,l-4);\n\t\t\t\tmvsSTRING::operator=(x);\n\t\t\t\tcodev = *(short *)(s+2);\n\t\t\t\t\u00fc\n    \u00fc\n   LLC_mvsSTRING(long int c):mvsSTRING() , codev(c)\u00e4\u00fc\n  \u00dfLLC_mvsSTRING()\u00e4\u00fc\n   long int   code(void)\u00e4return codev;\u00fc\n operator long int()\n       \u00e4 long int ret = 0;\n          if ( st.l == sizeof(long int) )\n                  ret = * (long int *)(st.c);\n         else if ( st.l == sizeof(short) )\n            ret = * (short *)(st.c);\n       else if ( st.l == 1)\n            ret = *st.c;\n       return ret ;\n    \u00fc\n\u00fc;\n\n\n\n\nmvsSTRING patternchng(mvsSTRING input , mvsSTRING mask,\n  mvsSTRING (*function)(mvsSTRING));\n\n\n\n\n\n\n\nclass mvsSTRING;\nclass mERROR;\n\n\n\n\n\n\n\n\nclass mvsSTRING;\nclass mERROR;\n\nclass INT3\n\u00e4\nprivate :\n   long v;\npublic:\n   INT3(long u)\u00e4 v = u;\u00fc\n   operator long()\u00e4return v;\u00fc\n   INT3 & operator=(long u)\u00e4 v = u;return *this;\u00fc\n\n\u00fc;\n\n\n\n\n\n\n\n\n\nenum sLLUsage \u00e4 sLLinput , sLLoutput , sLLoutputVar\u00fc ;\n\n\n\n\n\nenum sLLType   \u00e4sLLt0 = 0, sLLt1 = 1  ,sLLt2 = 2 , sLLt3 = 3 , sLLt4 = \u00d6\n4 \u00fc;\nenum sLLStatus \u00e4sLLOk = 0, sLLUf = 1  ,sLLOf = 2\u00fc;\n\nclass sLL;\n\n\nclass sLLskip\u00e4\nprivate:\n   int i;\npublic:\n   sLLskip(int v):i(v)\u00e4\u00fc\n   operator int()\u00e4return i;\u00fc\n\u00fc;\n\nclass sLL:public  mERROR\n\u00e4\n\nprotected:\n\n      int length;\n      int offset;\n      int llength;\n      int allocl;\n      int storedl;\n\n      sLL * base;\n      sLL * child;\n\n\n      char * start;\n      char * cursor;\n      sLLType type;\n      sLLStatus status;\n      char   dummy;\n\t\t\tmvsSTRING  string;\nprotected:\n      sLLUsage usage;\n\nprotected:\n\n    void init(sLL *,int,sLLType);\n    int storeOk(int);\n\npublic:\n\n\n\n\n\n    sLL (sLLType = sLLt2,\n            sLLUsage = sLLoutput,int=1024 );\n    sLL (sLL * , int ,\n            sLLType = sLLt2);\n    sLL (sLL * ,char *,\n            sLLType = sLLt2);\n    sLL (char *,\n            sLLType = sLLt2);\n      sLL (char *,\n                   int );\n\n\n    sLL (const sLL &);\n\n    virtual \u00dfsLL ();\n\n    virtual sLL & operator=(sLL &);\n\n\n\n\n\n      operator int();\n\n\n    char & operator\u00c4\u00dc(int);\n\n\t\t\tint   getLength() const\n\t\t\t\t\u00e4\n\t\t\t\tif ( usage == sLLinput ) return length;\n\t\t\t\telse return storedl;\n\t\t\t\t\u00fc\n\n\t\t\tchar * getStart() const\n\t\t\t\t\u00e4 return start; \u00fc\n\n    sLL * getBase();\n    int   getOffset();\n    sLL * getChild();\n\n\n    int   getFullLength();\n    int   getRemainderLength();\n    int   getStoredLength();\n\n    char * getCursor();\n\t\t\tmvsSTRING  getString();\n    void  setChild(sLL*);\n    void  setBase(sLL *);\n\n\n    void   setLength();\n    virtual void resetCursor();\n\n    char * goCursor(int);\n    void   setUsage(sLLUsage);\n\n\n\n\n\n    sLL * next();\n    sLL * iterate(sLLType,int = 0);\n    void remove(sLL& );\n\n\n\n\n\n\n    sLL& operator>>(int&);\n    sLL& operator>>(short&);\n    sLL& operator>>(unsigned short&);\n    sLL& operator>>(char &);\n    sLL& operator>>(char * &);\n    sLL& operator>>(mvsSTRING &);\n    sLL& operator>>(sLL &);\n    sLL& operator>>(INT3 &);\n    sLL& operator>>(sLLskip &);\n\n\n\n\n    sLL& operator<<(int);\n    sLL& operator<<(short);\n    sLL& operator<<(unsigned short);\n    sLL& operator<<(char );\n    sLL& operator<<(char *);\n    sLL& operator<<(mvsSTRING &);\n    sLL& operator<<(sLL& );\n    sLL& operator<<(INT3 &);\n    sLL& operator<<(sLLskip &);\n    sLL& store(char *,int);\n\n\n\n\n\n\n   int write(void *);\n   friend sLL * readsLL(void *,sLLType);\n\t\t\tvirtual void dump(const char *,int);\n\n\u00fc;\n\nclass sLLTag: public sLL\n\u00e4\nprivate:\n   short      code;\n   char       * name;\n   short      searchcode;\n   void       init(short);\npublic:\n   sLLTag();\n   sLLTag(short);\n\n   sLLTag(char *);\n   sLLTag(sLL * , char *);\n   sLLTag(const sLLTag &);\n\n   \u00dfsLLTag()\u00e4\u00fc\n\t\tsLLTag& operator=(sLLTag&);\n\n   short      getCode()\u00e4 return code;\u00fc\n   char *     getName()\u00e4 return name ;\u00fc\n   sLLTag *   search(short=0);\n   void       resetCursor();\n   void       remove(sLLTag &);\n   sLLTag *   update(sLLTag& );\n   sLLTag *   next();\n   sLLTag *   iterate();\n\t virtual void dump(const char *,int);\n\u00fc;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n        struct timespec\n            \u00e4\n            time_t tv_sec;\n            long   tv_nsec;\n            \u00fc;\n\n\n\n\n\n\n  struct tm\n     \u00e4\n     int tm_sec;\n     int tm_min;\n     int tm_hour;\n     int tm_mday;\n     int tm_mon;\n     int tm_year;\n     int tm_wday;\n     int tm_yday;\n     int tm_isdst;\n     \u00fc;\n\n    #pragma map(clock,\"\u00d6174\u00d6174OCLCK\")\n\n\n\n\n\n\n\n\n\n     clock_t     clock (void);\n     double      difftime (time_t, time_t);\n     time_t      mktime (struct tm *);\n     time_t      time (time_t *);\n     char       *asctime (const struct tm *);\n     char       *ctime (const time_t *);\n     struct tm  *gmtime (const time_t *);\n     struct tm  *localtime (const time_t *);\n     size_t      strftime (char * restrict, size_t,\n                           const char * restrict,\n                           const struct tm * restrict);\n     void        __tzset(void);\n\n\n      char    *strptime(const char *restrict, const char *restrict,\n                        struct tm *restrict);\n\n\n    inline char *ctime(const time_t *t) \u00e4return(asctime(localtime(t)));\u00fc\n       inline double difftime (time_t t1, time_t t0)\n                              \u00e4return((double)((t1) - (t0)));\u00fc\n\n\n\n\n\n\n\n\n\n         void tzset(void);\n\n      extern char *tzname\u00c42\u00dc;\n\n\n\n      #pragma map(__TzznA, \"\u00d6174\u00d6174TZZNA\")\n\n      char  *(*__TzznA(void))\u00c42\u00dc;\n      char  *(*__Tzzn(void))\u00c42\u00dc;\n\n\n\n\n\n\n\n\n\n\n      extern int daylight;\n      extern long int timezone;\n\n\n\n\n        long int *__tzone(void);\n        int *__dlght(void);\n\n\n\n      extern int   getdate_err;\n\n\n        struct tm *getdate(const char *);\n\n        int *__gderr(void);\n\n\n\n    char * asctime_r(const struct tm *restrict, char *restrict);\n    char * ctime_r(const time_t *, char*);\n    struct tm * gmtime_r(const time_t *restrict, struct tm *restrict);\n    struct tm * localtime_r(const time_t *restrict, struct tm *restrict\u00d6\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             \u00fc\n\n\n                   #pragma checkout(resume)\n\n\n\n\nunsigned long cvb(unsigned long,unsigned long = 8);\nunsigned long cvd(unsigned long);\nvoid    formatTime(char *,int,char *);\n\nint dump(FILE *,char *, char *,  int );\nint dump(FILE *,char *, void * , int );\nint dump(char *,int, char *, int);\n\nint  fromInt(char *,long ,int  = sizeof(long));\nlong toInt(char *,int);\nlong toInt(unsigned char *,int);\nint  roundToInt(double);\n\nint   Char2Hex(char *);\nchar * Hex2Char(char );\nint   isnull(char *,int = 0 );\n\n\n\nchar*   getTimeStemp();\nint     DatetoTm(tm&,char *);\nchar *  DatetoString(tm, char *);\n\nvoid  getUniqueKEY(char *);\nvoid  getUniqueLongKEY(char *);\nchar*   DatetoString();\nchar *\tDatetoIBM(char * from);\n\n\n\n\n\n\n\nint   strcmpiList(const char *,const char *\u00c4\u00dc,int &);\n\nchar *strrev(char *s);\n\nmvsSTRING makemvsSTRING(char *,int);\n\n  int stcpma(char * ,const char * );\n  void * memcpyp(void *,const void*,size_t,size_t,int);\n\n\n\nchar * Astrupr(char *, int);\nchar * ConvertmvsSTRINGToAscii( char *, int);\nchar aup(char);\n\nvoid  swab( char *,char *, int);\nchar *  StrDup(char *);\n\nchar   bit_rotate(unsigned char);\nmvsSTRING makemvsSTRING(char *,int);\nextern char __test__ ;\n\nextern unsigned char ETOA\u00c4256\u00dc;\nextern unsigned char ATOE\u00c4256\u00dc;\n\ninline int ffixed(FILE * f)\n\u00e4\n      fldata_t ft;\n      char fn\u00c4256\u00dc;\n      if (fldata(f,fn,&ft) == 0)\n         return (ft.__recfmF);\n      else\n\t\t\t\treturn 0;\n\u00fc\n\ninline void  strerror_r(int err, char *errmsg, int size)\n\u00e4\n    const char* msg=strerror(err);\n    if(strlen(msg)>size-1)\n    \u00e4\n        strncpy(errmsg,msg,size-1);\n        errmsg\u00c4size-1\u00dc='\u00d60';\n    \u00fc\n    else\n    \u00e4\n        strcpy(errmsg,msg);\n    \u00fc\n\u00fc\n\n\n\nnamespace isis_ns_mvs\n\t\u00e4\n\n\n\n\n\tenum MSGETypes\u00e4msgundef = 0, msgint    = 1,\n\t\tmsgshort = 2, msgcharp  = 3,\n\t\tmsgchar  = 4,  msgmvsSTRING = 5\u00fc;\n\n\n\tenum MSGEForm\u00e4msgfundef = 0, msgfd = 1, msgfs = 2, msgfx =3 , msgfc = \u00d6\n4\u00fc;\n\tclass MSGE\n\t\t\u00e4\n\t\tprivate:\n\t\t\tint         length;\n\t\t\tMSGEForm    form;\n\t\t\tMSGETypes   type;\n\t\t\tchar *      to;\n\t\t\tunion\u00e4\n\t\t\t\tchar     mchar;\n\t\t\t\tint      mint;\n\t\t\t\tshort    mshort;\n\t\t\t\tchar   * mcharp;\n\t\t\t\tmvsSTRING * mmvsSTRING;\n\t\t\t\t\u00fc;\n\t\tpublic:\n\t\t\tMSGE();\n\t\t\tMSGE(int i,int l=sizeof(int), MSGEForm f = msgfd);\n\t\t\tMSGE(short s,int l = sizeof(short), MSGEForm f= msgfd);\n\t\t\tMSGE(char * c,int l = 0, MSGEForm f = msgfs);\n\t\t\tMSGE(const mvsSTRING &s,int l = 0,MSGEForm f = msgfs );\n\t\t\tMSGE(char c);\n\n\t\t\t\u00dfMSGE()\n\t\t\t\t\u00e4\n\t\t\t\tif ( type == msgmvsSTRING) delete mmvsSTRING;\n\t\t\t\tif ( to ) delete \u00c4\u00dc to;\n\t\t\t\t\u00fc\n\t\t\tchar * format();\n\t\t\u00fc;\n\n\n\tclass EOL\u00e4\n\t\t\u00fc;\n\tconst EOL eol=EOL();\n\n\tMSGE * tCHARp(char * ,int  = 0);\n\n\tMSGE * tINT(int ,int = sizeof(int));\n\n\tMSGE * tSHORT(int ,int  = sizeof(short));\n\n\tMSGE * tmvsSTRING(mvsSTRING & ,int  = 0);\n\n\tMSGE * tHEX(int  ,int = (sizeof(int)*2) );\n\n\tMSGE * tHEX(char * , int);\n\n\n\n\n\tenum FLAG_VALUE\u00e4 FLAG_TEXT = 5, FLAG_IO = 4\u00fc;\n\n\ttypedef   struct  ENTRY\n\t\t\u00e4\n\t\tchar * name     ;\n\t\tchar flag       ;\n\t\tint  xcoord     ;\n\t\tint  ycoord     ;\n\t\tint  length     ;\n\t\tchar attrib     ;\n\t\tint  access     ;\n\t\tchar fieldtype  ;\n\t\tchar align      ;\n\t\tchar caps       ;\n\t\tchar * defvalue ;\n\t\t\u00fc\n\tentry               ;\n\n\n\n\n\n\ttypedef   struct  SELECTION\n\t\t\u00e4\n\t\tchar * line     ;\n\t\tint  access     ;\n\t\t\u00fc\n\tselection           ;\n\tstruct et\n\t\t\u00e4\n\t\tchar *   cid ;\n\t\tchar * * ett;\n\t\t\u00fc ;\n\n\n\n\n\n\tstruct TEXTENTRY\n\t\t\u00e4\n\t\tint i;\n\t\tchar * t;\n\t\t\u00fc;\n\n\n\tclass  MessageTEXT\n\t\t\u00e4\n\t\tprivate:\n\t\t\tchar timestemp;\n\t\t\tint (*printfv)(char *);\n\t\t\tchar * msgfilename;\n\t\t\tbool   logger;\n\t\t\tbool   onlylogger;\n\t\t\tFILE  * msgfile;\n\t\t\tTEXTENTRY *  vector;\n\t\t\tMSGE * v\u00c48\u00dc;\n\t\t\tint    vi;\n\t\t\tint    number;\n\t\t\tchar   deflt\u00c4256\u00dc;\n\n\t\tpublic:\n\t\t\tMessageTEXT(char * = 0,char * = 0);\n\t\t\t\u00dfMessageTEXT();\n\t\t\tMessageTEXT& operator<<(char *);\n\t\t\tMessageTEXT& operator<<(const mvsSTRING &);\n\n\t\t\tMessageTEXT& operator<<(int );\n\t\t\tchar *       operator<<(const EOL);\n\t\t\tMessageTEXT& operator<<(void *);\n\t\t\tchar * getText(int);\n\t\t\tint    copyText(int, char *, int);\n\t\t\tchar * print(char *);\n\t\t\tvoid   resetPrintFv()\u00e4 printfv = 0;\u00fc\n\t\tvoid   setPrintFv(int (*pfv)(char *))\u00e4 printfv= pfv;\u00fc\n\tvoid   setLogger(const char *);\n\tvoid   setOnlyLogger(const char * l)\n\t\t\u00e4\n\t\tsetLogger(l);\n\t\tonlylogger = logger;\n\t\t\u00fc\n\tvoid   setFILE(FILE *);\n\tFILE*  getFILE()\u00e4return msgfile;\u00fc\nvoid   setFileName(char *);\nvoid   setTimeStempFlag(char c = 1)\u00e4timestemp = c;\u00fc\nchar   getTimeStempFlag()\u00e4 return timestemp;\u00fc\nvoid   setNumber(int n);\n\t\t\u00fc;\n\n\textern \"C\" typedef void * (*EXT_C_fp)();\n\n\n\tclass ExternalTEXT\n\t\t\u00e4\n\t\tprivate:\n\t\t\tEXT_C_fp fp;\n\t\t\tchar   language;\n\t\t\tchar   modulname\u00c48\u00dc;\n\t\t\tvoid * text ;\n\t\t\tvoid init(char * name);\n\t\tpublic:\n\t\t\tExternalTEXT(char * name,char lang);\n\t\t\tExternalTEXT(char * name);\n\n\n\t\t\tint         MSGTEXT(int id, char * buff,int len);\n\t\t\tchar      * HelpText(char * hid);\n\t\t\tentry     * EntryText(char * hid);\n\t\t\tselection * SelectionText(char * hid);\n\t\t\u00fc;\n\n\textern ExternalTEXT * externaltext;\n\n\n\n\textern  MessageTEXT * messagetext;\n\tint initMessageText();\n\n\tint     Error(int , ...);\n\tchar *  Message(int , ...);\n\tchar *  getErrorText();\n\tchar *  getMessageText();\n\tMessageTEXT& Err(int);\n\tMessageTEXT& Msg(int);\n\n\t\u00fc\n\nusing namespace isis_ns_mvs;\n\n\n\n\n\n\n\n\nextern \"OS\" int  SQLASM(void);\n\nextern \"OS\" int  DSNALI(...);\nextern \"OS\" int  DSNTIAR(...);\nextern \"OS\" void DSNHLI(void *);\n\nconst int data_dim = 30;\nconst int data_len = 72;\n\n\ntypedef struct varchar\n\u00e4\n  short len;\n  char  value\u00c44096\u00dc;\n\u00fc VARCHAR;\n\ntypedef struct\n \u00e4\n  short error_len;\n  char error_text\u00c4data_dim\u00dc\u00c4data_len\u00dc;\n \u00fc ERROR_MESSAGE;\n\nenum  CallType\u00e4Connect,\n       Disconnect,\n       Commit,\n       Rollback,\n       Prepare,\n       Open,\n       Close,\n       Execute\u00fc;\n\n\n\n\n\n\n\n\n\n\n\n\nclass ARCHSQL:public mERROR\n\u00e4\nprivate:\n  int rc;\n  void * tecb,* secb,* ribptr,* eibptr;\n  long retcode , reasoncode;\n  char function\u00c413\u00dc;\n  char ssnm\u00c45\u00dc;\n  char plan\u00c49\u00dc;\n  char reuse\u00c49\u00dc;\n  char collection\u00c419\u00dc;\n  char correlation_id\u00c413\u00dc;\n  char accounting_token\u00c423\u00dc;\n  char accounting_interval\u00c47\u00dc;\n  int  rrs;\n  int status;\n  ERROR_MESSAGE error_message;\n  void * loadlist\u00c48\u00dc;\npublic:\n  ARCHSQL();\n  \u00dfARCHSQL();\n  int call(CallType);\n  void setDynamicSQL(char *);\n  void * getLoadlist()\u00e4 return loadlist\u00c40\u00dc;\u00fc\n  void setSubSystem(char *n)\u00e4memcpy(ssnm,n,4);ssnm\u00c44\u00dc = 0;\u00fc\n  void setPlan(char * p)\u00e4memcpyp(plan,p,8,strlen(p),' '); plan\u00c48\u00dc = 0;\u00fc\n  void setCollection(char * p)\u00e4memcpyp(collection,p,8,strlen(p),' '); c\u00d6\nollection\u00c48\u00dc = 0;\u00fc\n  void setPlanName(char *n)\u00e4memcpy(plan,n,8);plan\u00c48\u00dc = 0;\u00fc\n\u00fc;\n\nvoid  getUniqueKey(char *);\nvoid  getUniqueKEY(char *);\n\n\n\n\n\n\n\n\nstruct chainE \u00e4\n\n\tchainE * prev ;\n\tchainE * next ;\n\tchar * chainEid   ;\n\tint    chainEidl  ;\n\n\tchainE()\u00e4chainEid = 0; chainEidl = 0; prev = next = 0;\u00fc\n\n\tchainE(char * i,int l =0)\n\t\u00e4\n\t\tif (i)\n\t\t\u00e4\n\t\t\tif ( l ) chainEidl = l; else chainEidl =int(strlen(i));\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc; memcpy(chainEid,i,chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\n\tchainE(const char * i,int l =0)\n\t\u00e4\n\t\tif (i)\n\t\t\u00e4\n\t\t\tif ( l ) chainEidl = l; else chainEidl =int(strlen(i));\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc; memcpy(chainEid,i,chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\n\tchainE(const mvsSTRING * s)\n\t\u00e4\n\t\tif (s)\n\t\t\u00e4\n\t\t\tchainEidl = int((mvsSTRING *)s->lengthOf());\n\t\t\tchainEid = new char\u00c4chainEidl+1\u00dc;\n\t\t\tmemcpy(chainEid,(char *)mvsSTRING(*s),chainEidl+1);\n\t\t\u00fc\n\t\telse chainEid =0;\n\t\tprev=next=0;\n\t\u00fc\n\tvirtual \u00dfchainE()\n\t\u00e4\n\t\tdelete chainEid ;\n\t\u00fc\n\tvirtual void print()\u00e4\u00fc\n\u00fc;\n\n\nclass mCHAIN \u00e4\n\nprotected:\n\tchainE * first;\n\tchainE * last ;\n\n\tchainE * pgo;\n\tlong int    counter;\npublic:\n\tfriend class CHAINITER ;\n\n\tmCHAIN()\n\t\u00e4\n\n\t\tfirst = last = pgo = 0; counter = 0;\n\t\u00fc\n\n\tmCHAIN(chainE * nc)\n\t\u00e4\n\t\tpgo = 0;\n\t\tfirst = nc ; last = nc ;\n\t\tcounter = 1;\n\t\u00fc\n\n\tvirtual \u00dfmCHAIN();\n\tvirtual   long int    add(chainE * nc,chainE * c,long int code = 1);\n\tvirtual long int addfirst(chainE * nc )\n\t\u00e4 return add(nc,first,-1) ; \u00fc\n\tvirtual long int addlast(chainE * nc )\n\t\u00e4 return add(nc,last,+1) ; \u00fc\n\tvirtual long int before(chainE * nc , chainE * c)\n\t\u00e4return add(nc,c,-1);\u00fc\n\tvirtual long int after(chainE * nc , chainE * c)\n\t\u00e4return add(nc,c,+1);\u00fc\n\tvirtual long int del(chainE * c);\n\tvirtual void swap(chainE * a , chainE * b);\n\n\n\n\tvirtual chainE* goNext();\n\tvirtual chainE* goPrev();\n\tvirtual chainE* goFirst();\n\tvirtual chainE* goLast();\n\tvirtual chainE* go(int);\n\tvirtual chainE * searchEQ(const char * id,size_t =0);\n\tvirtual chainE * search(const char * id,size_t =0);\n\tvirtual chainE * search(const mvsSTRING &);\n\tvirtual chainE * search(char *id,size_t length =0)\u00e4 return search((con\u00d6\nst char *)id,length);\u00fc\n\tvirtual chainE * search(mvsSTRING &s)\u00e4 return search((const mvsSTRING&\u00d6\n)s);\u00fc\n\n\tvirtual void sort(long int direction);\n\tvirtual void print_all_ids();\n\tvirtual void print();\n\tfriend int idcmp(chainE* , chainE*);\n\u00fc;\n\nenum SORTEDTYPE\u00e4UNIQUE =0 ,NOUNIQUE =1 \u00fc;\n\nclass SORTEDmCHAIN:public mCHAIN\n\u00e4\nprivate:\n\tSORTEDTYPE unique;\npublic:\n\tSORTEDmCHAIN(SORTEDTYPE st = UNIQUE):\n\t\t\tmCHAIN(), unique(st)\u00e4\u00fc;\n\t\t\tSORTEDmCHAIN(chainE *nc, SORTEDTYPE st = UNIQUE)\n\t\t\t\t:mCHAIN(nc), unique(st)\u00e4\u00fc;\n\t\t\tlong int add(chainE * nc,chainE * = 0,long int = 0);\n\t\t\tvirtual \u00dfSORTEDmCHAIN()\u00e4\u00fc\n\u00fc;\n\nclass mSTACK:public mCHAIN\n\u00e4\nprivate:\npublic:\n\tmSTACK():mCHAIN()\u00e4\u00fc\n\tmSTACK(chainE * nc):mCHAIN(nc)\u00e4\u00fc\n\n\tvirtual long int push(chainE * nc)\u00e4return addlast(nc);\u00fc\n\tvirtual chainE * examine(int i = 0 )\n\t\u00e4\n\t\tif ( i >= 0 ) return last;\n\t\ti = -i;\n\t\tif ( counter-i < 0 ) return 0;\n\t\treturn go(counter-i);\n\n\t\u00fc\n\tvirtual chainE * pop()\u00e4chainE * r = last; if (last) del(last);return r\u00d6\n;\u00fc\n\u00fc;\n\nclass mHASH:public mCHAIN\n\u00e4\nprivate:\n\tchainE * * table;\n\tint    hash;\n\tint\t\tpi;\npublic:\n\tmHASH(int h = 1023);\n\t\u00dfmHASH();\n\tlong int add(chainE *);\n\tlong int del(chainE *);\n\tchainE * next();\n\tchainE * search(chainE *);\nprivate:\n\tsize_t  hashCode(chainE *c)\n\t\u00e4\n\t\tint r = 0;\n\t\tif (c->chainEid)\n\t\t\tfor (int i = c->chainEidl;i;i--)\n\t\t\t\tr = (r<<1) \u00ac (c->chainEid\u00c4i-1\u00dc) ;\n\t\treturn size_t(r<0 ? -r:r);\n\t\u00fc\n\u00fc;\n\nclass CHAINITER\u00e4\nprivate:\n\tmCHAIN * c;\n\tchainE * a;\npublic:\n\tCHAINITER(mCHAIN &ch) \u00e4c = &ch ; a = (c->first ? c->first:0) ; \u00fc\n\tCHAINITER(mCHAIN *ch) \u00e4c =  ch ; a = (c->first ? c->first:0) ; \u00fc\n\t\u00dfCHAINITER()\u00e4\u00fc\n\tchainE * next() \u00e4\n\n\t\tchainE * r = a ;\n\t\tif ( a == 0 ) a =c->first ;\n\t\telse a = a->next ;\n\t\treturn r;\n\t\u00fc\n\tchainE * operator()()\u00e4 return next(); \u00fc\n\tvoid reset() \u00e4 a = (c ? c->first:0);\u00fc\n\u00fc;\n\nint idcmp(chainE* , chainE*);\n\n\n\n\n\n\n\n\n\n\nclass JOBENV\n\u00e4\npublic:\nenum JOBENV_ACTION\n\u00e4\n\tAbort,\n   Continue\n\u00fc;\npublic:\n    mvsSTRING jobName;\n    mvsSTRING jobId;\n    mvsSTRING stepName;\n    mvsSTRING procStepName;\n    mvsSTRING program;\n\t\tmvsSTRING programRb;\n    static int  debug;\npublic:\n    JOBENV(char *);\n    \u00dfJOBENV()\u00e4\u00fc\n    void print();\n    void static Error(char *,JOBENV_ACTION);\n    int  static DEBUG(int,char*);\n    int  static DEBUG(int,char*,int);\n    int  static DEBUG(int,size_t);\n    int  static DEBUG(int,char*,char*);\n    int  static DEBUG(int,char*,char*,char*);\n    int  static DEBUG(int,char*,char*,char*,char*);\n    int  static DEBUG(int,char*,char *,int);\n\u00fc;\n\nextern JOBENV * jobEnv;\n\n\n\nconst short  eiop00  = 0;\nconst short  eiop01  = 1;\nconst short  eiop02  = 2;\nconst short  eiop03  = 3;\nconst short  eiop04  = 4;\nconst short  eiop05  = 5;\nconst short  eiop06  = 6;\nconst short  eiop07  = 7;\nconst short  eiop08  = 8;\nconst short  eiop09  = 9;\nconst short  eiop10  =10;\nconst short  eiop11  =11;\nconst short  eiop12  =12;\nconst short  eiop13  =13;\nconst short  eiop14  =14;\nconst short  eiop15  =15;\nconst short  eiop16  =16;\nconst short  eiop17  =17;\nconst short  eiop18  =18;\nconst short  eiop19  =19;\nconst short  eiop20  =20;\nconst short  eiop21  =21;\nconst short  eiop22  =22;\nconst short  eiop23  =23;\nconst short  eiop24  =24;\nconst short  eiop25  =25;\nconst short  eiop26  =26;\n\nconst int eirc_ok    = 0;\nconst int eirc_replace    = 4;\nconst int eirc_insert    = 8;\nconst int eirc_delete    = 12;\nconst int eirc_modified  = 16;\nconst int eirc_disconnect  = 20;\nconst int eirc_disconnect_after = 24;\nconst int eirc_wtor        = 28;\nconst int eirc_end_function= 32;\nconst int eirc_end_dataset = 36;\n\n\nextern const char * ADRDSSU;\nextern const char * KEYWORD_INCLUDE_MARK;\nextern const char * KEYWORD_DUMP;\nextern const char * KEYWORD_RESTORE;\nextern const char * KEYWORD_DB_PLAN;\nextern const char * KEYWORD_DB_SUBSYS;\nextern const char * KEYWORD_PREFIX;\nextern const char * KEYWORD_SYSIN;\nextern const char * KEYWORD_ADR012I;\nextern const char * KEYWORD_DEBUG;\nextern const char * KEYWORD_COMPR;\nextern const char * KEYWORD_REFDT;\nextern const char * KEYWORD_SQLFILE;\nextern const char * KEYWORD_DIRECT;\nextern const char * KEYWORD_MAXLENGTH;\nextern const char * KEYWORD_USEDB2;\nextern const char * KEYWORD_USEDB2_FILE;\n\n\n\n\n\n\nextern \"OS\" int UIMASM(...);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst  unsigned PSATOLD = 0x21c;\nconst  unsigned PSAAOLD = 0x224;\nconst  unsigned TCBFSA  = 0x70/4;\nconst  unsigned TCBUSER = 0xA8;\nconst  unsigned tcbuser = 0xa8;\nconst  unsigned SAVEr1  = 0x18/4;\nstatic unsigned POSTcode = 0x40000000;\nstatic unsigned WAITcode = 0x80000000;\n\nclass SUBTASK;\nclass JOBENV;\n\n\ntypedef void       (*SUBTASK_FUNCTION)(void*);\ntypedef void       * addressP;\ninline addressP getASCB()\u00e4return(*(addressP*)PSAAOLD);\u00fc\ninline addressP getTCB()\u00e4return (*(addressP *)PSATOLD);\u00fc\n\n\nenum SUBTASK_STATUS\n\u00e4\n    Reset,\n    Started,\n    WaitingForWork,\n    WaitingForMain,\n    Working,\n    Stopping\n\u00fc;\ntypedef struct PROGRAM_ARGUMENTS \u00e4\n  short  arg_l;\n  char   arg_v\u00c41024\u00dc;\n  \u00fc programArguments;\n\n class SUBTASK: public mERROR\n\u00e4\nprivate:\n  char * dll;\nprotected:\n  MessageTEXT * messageText;\n  JOBENV *      jobEnv;\n  void * TCB;\n  unsigned ECB;\n  unsigned StopECB;\n  unsigned WorkECB;\n  unsigned MainECB;\n  unsigned SuspendECB;\n  unsigned *  ecblist\u00c42\u00dc;\n   void(* address)(void);\n  void (*subrun)();\n  int R15 ;\n  SUBTASK_FUNCTION functions\u00c44\u00dc;\n  void  * arg\u00c44\u00dc;\n  int subtask_rc;\n  int suspendflag;\n  SUBTASK_STATUS status;\n  char   name\u00c49\u00dc;\n  char   subtaskposted;\n  char   first_start;\n  int    timeout;\npublic:\n  friend void run();\n  SUBTASK();\n  SUBTASK(char *);\n  SUBTASK(addressP,SUBTASK_FUNCTION,char*);\n  SUBTASK(int,char * *,char *,char *);\n  virtual \u00dfSUBTASK();\n  virtual int    attach();\n  virtual int    detach();\n  virtual int    callAsync(int);\n  virtual int    callSync(int);\n  virtual int    waitForSubtask();\n  virtual int    waitForEndOfSubtask();\n  virtual void   start();\n  virtual void   stop();\n  virtual void   chap(int);\n  virtual void   exit(int);\n  virtual int    isTerminated()\u00e4 return (ECB&0x7fffffff);\u00fc\n  SUBTASK_STATUS askStatus()\u00e4return status;\u00fc\n  MessageTEXT * getMessageText()\u00e4return messageText;\u00fc\n  JOBENV      * getJobEnv()\u00e4return jobEnv;\u00fc\n  addressP      getParam()\u00e4return(addressP(argV));\u00fc\n  addressP      getTCB()\u00e4return(addressP(TCB));\u00fc\n  int           getTimeout()\u00e4return timeout;\u00fc\n  char *        getDllName()\u00e4 return dll;\u00fc\n  void          setDllName(char *d)\u00e4 dll = d;\u00fc\n  char * *  argV;\n  int       argC;\n\nstatic addressP GetTCB()\u00e4return (*(addressP *)PSATOLD);\u00fc\nstatic addressP GetASCB()\u00e4return(*(addressP*)PSAAOLD);\u00fc\n\nprotected:\n  int    checkR15(char *);\n  void   init(char *);\n  void   error(char *);\n\u00fc;\n\n class DLL_SUBTASK\n\u00e4\nprivate:\npublic:\n  SUBTASK * subtask;\n  DLL_SUBTASK(int,char * *,char *,char * = \"SUBRUN \");\n  \u00dfDLL_SUBTASK();\n  void      start()\u00e4subtask->start();\u00fc\n  void      stop()\u00e4subtask->stop();\u00fc\n  int       detach()\u00e4return(subtask->detach());\u00fc\n  addressP  getTCB()\u00e4return(subtask->getTCB());\u00fc\n\u00fc;\n\n class MAIN_SUBTASK:public SUBTASK\n\u00e4\nprivate:\nmvsSTRING startmvsSTRING;\n void * plist\u00c41\u00dc;\nprogramArguments   argument;\nprogramArguments * argumentP;\npublic:\n MAIN_SUBTASK();\n MAIN_SUBTASK(int,char * *,char *);\n MAIN_SUBTASK(programArguments *,char * );\n virtual int  attach();\n\u00fc;\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      struct flock \u00e4\n            short l_type;\n            short l_whence;\n               int   l_rsrvd1;\n            off_t l_start;\n               int   l_rsrvd2;\n            off_t l_len;\n            pid_t l_pid;\n      \u00fc;\n\n\n\n\n        int creat(const char *, mode_t) ;\n        int fcntl(int, int, ... );\n        int open(const char *, int, ... );\n\n\n\n\n\n\n\n\n\n\n\n     \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n  extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n               #pragma map (getlogin, \"\u00d6174\u00d6174GETLG2\")\n\n\n         #pragma map (__getlogin1, \"\u00d6174\u00d6174GETLOG\")\n         #pragma map (__pid_affinity,\"\u00d6174\u00d6174PID\u00d6174AF\")\n\n          #pragma map(__login_applid,\"\u00d6174\u00d6174LOGNAP\")\n         #pragma map(__certificate,\"\u00d6174\u00d6174CERTIF\")\n\n           void _exit(int);\n           int   access(const char *, int );\n           int   __certificate(int, int, char *, ...);\n           unsigned int alarm(unsigned int);\n           int   chdir(const char *);\n           int   chown(const char *, uid_t, gid_t);\n           int   close(int);\n           char *ctermid(char *);\n           int   dup(int);\n           int   dup2(int, int);\n           int   execl(const char *, const char *, ... );\n           int   execle(const char *, const char *, ... );\n           int   execlp(const char *, const char *, ... );\n           int   execv(const char *, char *const \u00c4\u00dc);\n           int   execve(const char *, char *const \u00c4\u00dc, char * const \u00c4\u00dc);\n           int   execvp(const char *, char *const \u00c4\u00dc );\n           pid_t fork(void);\n           long  fpathconf(int, int);\n           char *getcwd(char *, size_t);\n           gid_t getegid(void);\n           uid_t geteuid(void);\n           gid_t getgid(void);\n           int   getgroups(int, gid_t \u00c4\u00dc);\n             int   getgroupsbyname(char \u00c4\u00dc, int, gid_t \u00c4\u00dc);\n             int   __osenv(int, int, __osenv_token *);\n           char *__getlogin1(void);\n           char *getlogin(void);\n           pid_t getpgrp(void);\n           pid_t getpid(void);\n           pid_t getppid(void);\n           uid_t getuid(void);\n           int   isatty(int);\n           int   link(const char *, const char *);\n           int __login(int, int, int, void *, int, char *,\n                         int, char *, int);\n           off_t lseek(int, off_t, int);\n           long  pathconf(const char *, int);\n           int   pause(void);\n           int   __pid_affinity(int, pid_t, pid_t, int);\n           int   pipe(int \u00c42\u00dc);\n           ssize_t read(int, void *, size_t);\n           int   rmdir(const char *);\n           int   setgid(gid_t);\n           int   setpgid(pid_t, pid_t);\n           pid_t setsid(void);\n           int   setuid(uid_t);\n           unsigned int sleep(unsigned int );\n           long  sysconf(int);\n           pid_t tcgetpgrp(int);\n           int   tcsetpgrp(int, pid_t);\n           char *ttyname(int);\n           int   unlink(const char *);\n           ssize_t write(int, const void *, size_t);\n\n         int __login_applid(int, int, int, void *, int, char *, int, ch\u00d6\nar *, int, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n           int   fchown(int , uid_t, gid_t);\n           int   fsync(int);\n           int   ftruncate(int, off_t);\n           int   readlink(const char *, char *, size_t );\n           int   setegid(gid_t);\n           int   seteuid(uid_t);\n           int   symlink(const char *, const char *);\n             int   extlink_np(const char *, const char *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          extern char *optarg;\n          extern int optind, opterr, optopt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             void         __cnvblk(char \u00c4\u00dc, char \u00c4\u00dc, int);\n               int          chroot(const char *);\n             char        *crypt(const char *, const char *);\n             void         encrypt(char \u00c464\u00dc, int);\n             int          nice(int);\n           extern char **__opargf(void);\n           extern int  *__operrf(void);\n           extern int  *__opindf(void);\n           extern int  *__opoptf(void);\n           size_t       confstr(int, char *, size_t);\n             char        *cuserid(char *);\n           int          getopt(int, char * const \u00c4\u00dc, const char *);\n             char        *getpass(const char *);\n           void         swab(const void *restrict,\n                                   void *restrict, ssize_t);\n\n\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n       typedef    signed  char   int8_t;\n       typedef    signed  short  int16_t;\n       typedef    signed  int    int32_t;\n\n\n       typedef signed long long  int64_t;\n\n\n\n\n       typedef  unsigned  char  uint8_t;\n\n\n       typedef  unsigned  short uint16_t;\n\n\n       typedef  unsigned  int   uint32_t;\n\n       typedef unsigned long long uint64_t;\n\n       typedef    signed long    intptr_t;\n       typedef  unsigned long   uintptr_t;\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n    \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n             int          fchdir(int);\n               int          getdtablesize(void);\n             pid_t        getpgid(pid_t);\n             pid_t        getsid(pid_t);\n             char        *getwd(char *);\n             int          lchown(const char *, uid_t, gid_t);\n             int          setregid(gid_t, gid_t);\n             int          setreuid(uid_t, uid_t);\n             void         sync(void);\n             int          truncate(const char *, off_t);\n             useconds_t    ualarm(useconds_t, useconds_t);\n             int          brk(void *);\n             int          getpagesize(void);\n               void        *sbrk(intptr_t);\n           int          lockf(int, int, off_t);\n           pid_t        setpgrp(void);\n           int          usleep(useconds_t);\n           pid_t        vfork(void);\n\n\n\n\n\n\n\n\n\n\n\n      int getlogin_r(char *, size_t );\n      int ttyname_r(int, char *, size_t );\n\n\n      ssize_t pread(int, void *, size_t, off_t);\n\n      ssize_t pwrite(int, const void *, size_t, off_t);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int          __atoe(char *);\n      int          __atoe_l(char *, int);\n      int          __check_resource_auth_np(char *, char *, char *,\n                                            char *, char *, int);\n      int          __convert_id_np( int, char *, char *, char *);\n      int          __etoa(char *);\n      int          __etoa_l(char *, int);\n      int          __isPosixOn(void);\n      int          __openMvsRel(void);\n      int          __openVmRel(void);\n      int          __smf_record(int, int, int, char *);\n      int          __wsinit(void (*)());\n\n    int __smf_record2(int, int, int, char *, unsigned int);\n\n\n\n\n\n\n\n\n          long         gethostid(void);\n          int          gethostname(char *, size_t);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      int __must_stay_clean(int);\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n    extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n    int __errno2(void);\n    int *__err2ad(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n           extern int errno;\n           extern int *__errno(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n                   #pragma nomargins nosequence\n                   #pragma checkout(suspend)\n\n\n\n   extern \"C\" \u00e4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          int  bcmp (const void *, const void *, size_t);\n          void bcopy (const void *, void *, size_t);\n          void bzero (void *, size_t);\n          int ffs (int);\n          char * index  (const char *, int);\n          char * rindex (const char *, int);\n          int  strcasecmp (const char *, const char *);\n          int  strncasecmp (const char *, const char *, size_t);\n\n\n\n\n\n         extern \"builtin\"  \u00e4\n\n         void * __memcpy (void *, const void *, size_t);\n         int    __memcmp (const void *, const void *, size_t);\n         void * __memset (void *, int, size_t);\n         char * __strchr (const char *, int);\n         char * __strrchr (const char *, int);\n\n         \u00fc\n\n\n\n\n\n\n  \u00fc\n\n                   #pragma checkout(resume)\n\n\n\n\n\n\n\n\n\nstatic const char fullQuery\u00c4\u00dc =\n\" SELECT * FROM DSSDATASETS A \"\n\" WHERE ( %m% ) AND \"\n\" ( DATE(KEY) <= DATE('%d%') ) AND \"\n\" ( \"\n\" A.KEY =  \"\n\" (SELECT MAX(B.KEY) FROM DSSDATASETS B WHERE A.DATASET = B.DATASET  \"\n\" AND DATE(B.KEY) <= DATE('%d%') ) \"\n\" ) \" ;\n\n\n/***$$$\nEXEC SQL BEGIN DECLARE SECTION\n$$$***/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntypedef struct _TIMESTAMP\n\u00e4\n  short len;\n  char  arr\u00c428\u00dc;\n\u00fc TIMESTAMP;\n\nstruct _DssDatasetRecord\n\u00e4\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc key;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc job;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc volumes;\n   long int type;\n   long int recordsize;\n\u00fc DssDatasetRecord;\n\nclass TcbARCHSQL:public chainE\n\u00e4\nprivate:\n   ARCHSQL * archsql;\npublic:\n   TcbARCHSQL(char * t,ARCHSQL * a):chainE(t),archsql(a)\n   \u00e4\u00fc\n   ARCHSQL * get()\u00e4return archsql;\u00fc\n\u00fc;\n\nstatic char * initDynamicSql();\n\nclass SQLINTERFACE:\n public  mERROR\n\u00e4\nprotected:\n static char * plan;\n static char * subsystem;\n static mCHAIN  tasks;\n static ERROR_MESSAGE * error_message;\nprotected:\n static char * dSql;\npublic:\n\tstatic bool useDB2;\n\tstatic FILE * fileDB2;\npublic:\n SQLINTERFACE();\n   \u00dfSQLINTERFACE();\n   void diag(char *);\n   int  commit();\n   enum Error_Action\u00e4 Abort, Continue\u00fc;\n   void Error(char *,Error_Action);\n   ARCHSQL * connectDB();\n   void tryToConnect();\n\u00fc;\n\nclass DssJob:\n public SQLINTERFACE,\n public mCHAIN,\n public CHAINITER,\n public chainE\n\u00e4\nprivate:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc t;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc record_key;\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc record_job;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc record_dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc record_volumes;\n   long int record_type;\n   long int record_size;\npublic:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc timestamp;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc jobName;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc jobNumber;\n   struct \u00e4 short len; char arr \u00c4 9 \u00dc ; \u00fc program;\n   struct \u00e4 short len; char arr \u00c4 255 \u00dc ; \u00fc dataset;\n   long int datasetcount;\n   struct \u00e4 short len; char arr \u00c4 30000 \u00dc ; \u00fc joblog;\n   struct \u00e4 short len; char arr \u00c4 32000 \u00dc ; \u00fc dynamicSql;\npublic:\n  static mCHAIN dssJobs;\n  static int    allOnline();\n  int    doWeNeed(const char *);\npublic:\n DssJob();\n DssJob(TIMESTAMP&);\n DssJob(const char *);\n virtual \u00dfDssJob();\n int insert();\n int query(mCHAIN*,char * =0);\n char * getDatasetName()\n\u00e4\n  return ((char *)dataset.arr);\n\u00fc\nprivate:\n void init();\n\u00fc;\n\nclass DssDataset:\n public SQLINTERFACE,\n public chainE\n\u00e4\nprivate:\n DssJob * job;\npublic:\n   struct \u00e4 short len; char arr \u00c4 28 \u00dc ; \u00fc timestamp;\n   struct \u00e4 short len; char arr \u00c4 45 \u00dc ; \u00fc dataset;\n   struct \u00e4 short len; char arr \u00c4 37 \u00dc ; \u00fc volumes;\n   long int type;\n   long int recordsize;\npublic:\n DssDataset(DssJob *,char *,char *,int = 0,int =0);\n int compare(const char *n)\n   \u00e4\n   for(int i =0;i<45&&dataset.arr\u00c4i\u00dc&&dataset.arr\u00c4i\u00dc-' '&&n\u00c4i\u00dc&&n\u00c4i\u00dc-' \u00d6\n';i++)\n     if (dataset.arr\u00c4i\u00dc - n\u00c4i\u00dc) return 0;\n   return 1;\n   \u00fc\n   virtual \u00dfDssDataset();\n   int insert();\n\u00fc;\n\n/***$$$\nEXEC SQL END DECLARE SECTION\n$$$***/\n\n/***$$$\nEXEC SQL INCLUDE SQLDA\n$$$***/\n#ifndef  SQLDASIZE                 /* Permit duplicate Includes      */\n /**/\n struct sqlvar\n        \u00e4 short  sqltype;\n          short  sqllen;\n          char  *sqldata;\n          short *sqlind;\n          struct sqlname\n                \u00e4 short  length;\n                  char   data??(30??);\n                \u00fc sqlname;\n        \u00fc;\n /**/\n struct sqlvar2\n        \u00e4 struct\n                \u00e4 long   sqllonglen;\n         unsigned long   reserved;\n                \u00fc len;\n          char  *sqldatalen;\n          struct sqldistinct_type\n                \u00e4 short  length;\n                  char   data??(30??);\n                \u00fc sqldatatype_name;\n        \u00fc;\n /**/\n struct sqlda\n        \u00e4 char   sqldaid??(8??);\n          long   sqldabc;\n          short  sqln;\n          short  sqld;\n          struct sqlvar sqlvar??(1??);\n    \u00fc;\n /**/\n/*********************************************************************/\n/* Macros for using the sqlvar2 fields.                              */\n/*********************************************************************/\n /**/\n/*********************************************************************/\n/*   '2' in the 7th byte of sqldaid indicates a doubled number of    */\n/*       sqlvar entries.                                             */\n/*   '3' in the 7th byte of sqldaid indicates a tripled number of    */\n/*       sqlvar entries.                                             */\n/*********************************************************************/\n#define   SQLDOUBLED  '2'\n#define   SQLTRIPLED  '3'\n#define   SQLSINGLED  ' '\n /**/\n/*********************************************************************/\n/* GETSQLDOUBLED(daptr) returns 1 if the SQLDA pointed to by         */\n/* daptr has been doubled, or 0 if it has not been doubled.          */\n/*********************************************************************/\n#define GETSQLDOUBLED(daptr) \u00d6\n    (((daptr)->sqldaid??(6??) == ( char) SQLDOUBLED) ? \u00d6\n    (1)         : \u00d6\n    (0)           )\n /**/\n/*********************************************************************/\n/* GETSQLTRIPLED(daptr) returns 1 if the SQLDA pointed to by         */\n/* daptr has been tripled, or 0 if it has not been tripled.          */\n/*********************************************************************/\n#define GETSQLTRIPLED(daptr) \u00d6\n    (((daptr)->sqldaid??(6??) == ( char) SQLTRIPLED) ? \u00d6\n    (1)         : \u00d6\n    (0)           )\n /**/\n/*********************************************************************/\n/* SETSQLDOUBLED(daptr, SQLDOUBLED) sets the 7th byte of sqldaid     */\n/* to '2'.                                                         */\n/* SETSQLDOUBLED(daptr, SQLSINGLED) sets the 7th byte of sqldaid     */\n/* to be a ' '.                                                    */\n/*********************************************************************/\n#define SETSQLDOUBLED(daptr, newvalue) \u00d6\n    (((daptr)->sqldaid??(6??) = (newvalue)))\n /**/\n/*********************************************************************/\n/* SETSQLTRIPLED(daptr) sets the 7th byte of sqldaid                 */\n/* to '3'.                                                         */\n/*********************************************************************/\n#define SETSQLTRIPLED(daptr) \u00d6\n    (((daptr)->sqldaid??(6??) = (SQLTRIPLED)))\n /**/\n/*********************************************************************/\n/* GETSQLDALONGLEN(daptr,n) returns the data length of the nth       */\n/* entry in the sqlda pointed to by daptr. Use this only if the      */\n/* sqlda was doubled or tripled and the nth SQLVAR entry has a       */\n/* LOB datatype.                                                     */\n/*********************************************************************/\n#define GETSQLDALONGLEN(daptr,n)    (    \u00d6\n    (long) (((struct sqlvar2 *) &((daptr)->sqlvar??((n) + \u00d6\n           ((daptr)->sqld)??))) \u00d6\n            ->len.sqllonglen))\n /**/\n/*********************************************************************/\n/* SETSQLDALONGLEN(daptr,n,len) sets the sqllonglen field of the     */\n/* sqlda pointed to by daptr to len for the nth entry. Use this only */\n/* if the sqlda was doubled or tripled and the nth SQLVAR entry has  */\n/* a LOB datatype.                                                   */\n/*********************************************************************/\n#define SETSQLDALONGLEN(daptr,n,length)  \u00e4 \u00d6\n    struct sqlvar2     *var2ptr; \u00d6\n    var2ptr = (struct sqlvar2 *) \u00d6\n        &((daptr)->sqlvar??((n) + ((daptr)->sqld)??)); \u00d6\n    var2ptr->len.sqllonglen  =  (long ) (length); \u00d6\n    \u00fc\n /**/\n/*********************************************************************/\n/* GETSQLDALENPTR(daptr,n) returns a pointer to the data length for  */\n/* the nth entry in the sqlda pointed to by daptr. Unlike the inline */\n/* value (union sql8bytelen len), which is 8 bytes, the sqldatalen   */\n/* pointer field returns a pointer to a long (4 byte) integer.       */\n/* If the SQLDATALEN pointer is zero, a NULL pointer is be returned. */\n/*                                                                   */\n/* NOTE: Use this only if the sqlda has been doubled or tripled.     */\n/*********************************************************************/\n#define GETSQLDALENPTR(daptr,n) (   \u00d6\n    (((struct sqlvar2 *) &(daptr)->sqlvar??((n) + (daptr)->sqld??)) \u00d6\n                           ->sqldatalen == NULL) ? \u00d6\n    ((long *) NULL ) : \u00d6\n    ((long *) ((struct sqlvar2 *) \u00d6\n        &(daptr)->sqlvar??((n) + (daptr)->sqld??)) \u00d6\n                                    ->sqldatalen ) )\n /**/\n/*********************************************************************/\n/* SETSQLDALENPTR(daptr,n,ptr) sets a pointer to the data length for */\n/* the nth entry in the sqlda pointed to by daptr.                   */\n/* Use this only if the sqlda has been doubled or tripled.           */\n/*********************************************************************/\n#define SETSQLDALENPTR(daptr,n,ptr)  \u00e4  \u00d6\n    struct sqlvar2 *var2ptr;    \u00d6\n    var2ptr = (struct sqlvar2 *) \u00d6\n        &((daptr)->sqlvar??((n) + ((daptr)->sqld)??)); \u00d6\n    var2ptr->sqldatalen  = (char *) ptr; \u00d6\n    \u00fc\n /**/\n#define SQLDASIZE(n) \u00d6\n   ( sizeof(struct sqlda) + ((n)-1) * sizeof(struct sqlvar) )\n#endif /* SQLDASIZE */\n\n/***$$$\nEXEC SQL INCLUDE SQLCA\n$$$***/\n#ifndef SQLCODE\nstruct sqlca\n  \u00e4 unsigned  char     sqlcaid??(8??);\n              long     sqlcabc;\n              long     sqlcode;\n              short    sqlerrml;\n    unsigned  char     sqlerrmc??(70??);\n    unsigned  char     sqlerrp??(8??);\n              long     sqlerrd??(6??);\n    unsigned  char     sqlwarn??(11??);\n    unsigned  char     sqlstate??(5??);\n            \u00fc ;\n#define SQLCODE  sqlca.sqlcode\n#define SQLWARN0 sqlca.sqlwarn??(0??)\n#define SQLWARN1 sqlca.sqlwarn??(1??)\n#define SQLWARN2 sqlca.sqlwarn??(2??)\n#define SQLWARN3 sqlca.sqlwarn??(3??)\n#define SQLWARN4 sqlca.sqlwarn??(4??)\n#define SQLWARN5 sqlca.sqlwarn??(5??)\n#define SQLWARN6 sqlca.sqlwarn??(6??)\n#define SQLWARN7 sqlca.sqlwarn??(7??)\n#define SQLWARN8 sqlca.sqlwarn??(8??)\n#define SQLWARN9 sqlca.sqlwarn??(9??)\n#define SQLWARNA sqlca.sqlwarn??(10??)\n#define SQLSTATE sqlca.sqlstate\n#endif\nstruct sqlca sqlca;\n\nstatic bool _useDB2()\n\u00e4\nif (getenv(KEYWORD_USEDB2) && strcasecmp(getenv(KEYWORD_USEDB2),\"NO\") =\u00d6\n= 0)\n\u00e4\n    char w\u00c4128\u00dc;\n    SQLINTERFACE::fileDB2 = fopen(genOpenName(KEYWORD_USEDB2_FILE,w),\"w\u00d6\n\");\n    Msg(10000+1003)<<eol;\n    return false;\n\u00fc\nelse\n    return true;\n\u00fc\n\nchar *      SQLINTERFACE::plan        = strdup(getenv(KEYWORD_DB_PLAN));\nchar *      SQLINTERFACE::subsystem   = strdup(getenv(KEYWORD_DB_SUBSYS\u00d6\n));\nchar *      SQLINTERFACE::dSql        = initDynamicSql();\nmCHAIN      DssJob::dssJobs;\nmCHAIN      SQLINTERFACE::tasks;\nbool        SQLINTERFACE::useDB2     = _useDB2();\nFILE *      SQLINTERFACE::fileDB2    =  0;\n\n\n\nERROR_MESSAGE * SQLINTERFACE::error_message = new ERROR_MESSAGE();\nSQLINTERFACE::SQLINTERFACE():mERROR()\n\u00e4\n  tryToConnect();\n\u00fc\n\nvoid SQLINTERFACE::tryToConnect()\n\u00e4\n\n\n  char t\u00c412\u00dc;\n  sprintf(t,\"%p\",getTCB());\n  if (tasks.search(t) == 0)\n      tasks.addlast(new TcbARCHSQL(t,connectDB()));\n      JOBENV::DEBUG(1,t);\n\u00fc\n\nARCHSQL * SQLINTERFACE::connectDB()\n\u00e4\n      ARCHSQL * archsql = new ARCHSQL();\n      if (useDB2)\n      \u00e4\n      if (subsystem==0) return 0;\n      ARCHSQL * archsql = new ARCHSQL();\n      archsql->setSubSystem(subsystem);\n      char _plan\u00c4\u00dc = \"        \";\n      memcpy(_plan,plan,strlen(plan));\n      archsql->setPlan(_plan);\n      if (| archsql->call(Connect))\n       markerror();\n      \u00fc\n      else\n      ARCHSQL * archsql = (ARCHSQL*)1;\n      error_message->error_len = short(data_dim*data_len);\n      if (useDB2)\n      Msg(10000+1000)<<subsystem<<plan<<tHEX(int(getTCB()))<<eol;\n      return archsql;\n\u00fc\n\nSQLINTERFACE::\u00dfSQLINTERFACE()\n\u00e4\n\u00fc\n\nvoid SQLINTERFACE::diag(char *t)\n\u00e4\n if (useDB2)\n \u00e4\n Msg(10000+1001)<<t<<SQLCODE<<(char *)(sqlca.sqlerrmc)<<eol;\n int rc = DSNTIAR(&sqlca,error_message,&data_len);\n if ( rc )\n  Msg(10000+9707)<<long(rc)<<eol;\n else\n \u00e4\n   for(int i = 0;i<data_dim;i++)\n   if (| mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len).isEmpty())\n      Msg(10000+9708)<<mvsSTRING(error_message->error_text\u00c4i\u00dc,data_len)\u00d6\n<<eol;\n \u00fc\n \u00fc\n\n Msg(100000+9709)<<\"diag\"<<eol;\n\u00fc\n\nint SQLINTERFACE::commit()\n\u00e4\ntryToConnect();\nif (useDB2)\n\u00e4\n\n/***$$$\n  EXEC SQL COMMIT\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST1 =\n  \u00e464, 4, 150,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 0, 0, 0, 0, 1208, 310, 4239, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR1;\n  SQLPLIST1.SQLCODEP = (char *) &sqlca;\n  SQLPLIST1.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST1.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST1.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST1.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST1);\n  \u00fc\n\n\u00fc\n  return 1;\n\u00fc\n\nvoid SQLINTERFACE::Error(char * t,Error_Action a)\n\u00e4\n\n\n Msg(100000+9709)<<\"error\"<<eol;\n\n\u00fc\n\nstatic char * initDynamicSql()\n\u00e4\n  char b\u00c432000\u00dc;\n  char _genFileName\u00c41024\u00dc;\n  size_t o = 0;\n  FILE * sqlFile = 0;\n  if (SQLINTERFACE::useDB2 && access(KEYWORD_SQLFILE,0x04)==0)\n  sqlFile=  fopen(genOpenName(KEYWORD_SQLFILE,_genFileName),\"r\");\n  if (sqlFile)\n  while(fgets(b+o,sizeof(b)-o,sqlFile))\n  \u00e4\n    o = strchr(b+o,'\u00d6n')-b;\n    if (o>0) *(b+o) = 0;\n      else\n    break;\n  \u00fc\n  if (sqlFile)\n    fclose(sqlFile);\n  else\n    strcpy(b,fullQuery);\n  JOBENV::DEBUG(1,(char *)b);\n  char * rb = new char\u00c4strlen(b)+1\u00dc;\n  strcpy(rb,b);\n  return (rb);\n\u00fc\n\n\n\n\n\nDssJob::DssJob():\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==0)\n\u00e4\n   init();\n\u00fc\nelse\n\t\t fclose(f);\n\n\u00fc\n\nDssJob::DssJob(const char * d):\nSQLINTERFACE(),\nchainE(\"\"),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\nchar _genFileName\u00c41024\u00dc;\nFILE * f = fopen(genOpenName(KEYWORD_DIRECT,_genFileName),\"r\");\nif (f==0)\n\u00e4\n   init();\n\u00fc\nelse\n\t fclose(f);\n strcpy(dataset.arr,d);\n dataset.len = strlen(d);\n\u00fc\nDssJob::DssJob(TIMESTAMP& ts):\nSQLINTERFACE(),\nchainE(ts.arr),\nmCHAIN(),\nCHAINITER(this)\n\u00e4\n init();\n memcpy(t.arr,ts.arr,ts.len);\n t.len = ts.len;\n if (useDB2)\n \u00e4\n\n/***$$$\n EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n EXEC SQL SELECT KEY, JOBNAME, JOBNUMBER, DATASET\n INTO\n :timestamp,\n :jobName,\n :jobNumber,\n :dataset\n FROM DSSJOBS WHERE KEY = :t\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST3 =\n  \u00e464, 17412, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 2, 0, 0, 0, 1208, 231, 4328, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR3;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 1) ??);\n     \u00fc SQLPVARS3;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLAVELT??( (sizeof(SQLELTS) * 4) ??);\n     \u00fc SQLAVARS3;\n  SQLELTS_PTR3 = (SQLELTS *) &SQLPVARS3.SQLPVELT;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 28;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( t );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS3.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS3.SQLDABC = 60;\n  SQLPVARS3.SQLN    = 1;\n  SQLPVARS3.SQLD    = 1;\n  SQLPLIST3.SQLVPARM = (char *) &SQLPVARS3.SQLDAID;\n  SQLELTS_PTR3 = (SQLELTS *) &SQLAVARS3.SQLAVELT;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 28;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  SQLELTS_PTR3 = SQLELTS_PTR3 + 1;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 9;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( jobName );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  SQLELTS_PTR3 = SQLELTS_PTR3 + 1;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 9;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( jobNumber );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  SQLELTS_PTR3 = SQLELTS_PTR3 + 1;\n  SQLELTS_PTR3->SQLTYPE = 448;\n  SQLELTS_PTR3->SQLLEN  = 255;\n  SQLELTS_PTR3->SQLADDR = (char *)\n  &( dataset );\n  SQLELTS_PTR3->SQLIND  = NULL;\n  SQLELTS_PTR3->SQLNAMLEN  = 0;\n  strcpy(SQLAVARS3.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLAVARS3.SQLDABC = 192;\n  SQLAVARS3.SQLN    = 4;\n  SQLAVARS3.SQLD    = 4;\n  SQLPLIST3.SQLAPARM = (char *) &SQLAVARS3.SQLDAID;\n  SQLPLIST3.SQLCODEP = (char *) &sqlca;\n  SQLPLIST3.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST3.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST3.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST3.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST3);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n if (SQLCODE == 100)\n    markerror();\n \u00fc\n char * c;\n dataset.arr\u00c4sizeof(dataset.arr)-1\u00dc = 0;\n if ((c = strchr(dataset.arr,' ')))\n     *c = 0;\n return;\nSQLERROR:\n  diag(\"SELECT\");\n  markerror();\n\u00fc\n\n\nDssJob::\u00dfDssJob()\n\u00e4\n\u00fc\n\nvoid DssJob::init()\n\u00e4\n   memset(&timestamp,0,sizeof(timestamp));\n   \u00e4 jobName.len = short((((sizeof(jobName.arr))>(strlen((char *)jobEnv\u00d6\n->jobName)))?(strlen((char *)jobEnv->jobName)):(sizeof(jobName.arr))));\u00d6\n strncpy(jobName.arr,(char *)jobEnv->jobName,jobName.len); \u00fc;\n   \u00e4 jobNumber.len = short((((sizeof(jobNumber.arr))>(strlen((char *)jo\u00d6\nbEnv->jobId)))?(strlen((char *)jobEnv->jobId)):(sizeof(jobNumber.arr)))\u00d6\n); strncpy(jobNumber.arr,(char *)jobEnv->jobId,jobNumber.len); \u00fc;\n   \u00e4 program.len = short((((sizeof(program.arr))>(strlen((char *)jobEnv\u00d6\n->program)))?(strlen((char *)jobEnv->program)):(sizeof(program.arr))));\u00d6\n strncpy(program.arr,(char *)jobEnv->program,program.len); \u00fc;\n   datasetcount = 0;\n   memset(&joblog,0,sizeof(joblog));\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n\n/***$$$\n   EXEC SQL SET :timestamp = CURRENT TIMESTAMP\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST4 =\n  \u00e464, 1028, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 3, 0, 0, 0, 1208, 746, 4370, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR4;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLAVELT??( (sizeof(SQLELTS) * 1) ??);\n     \u00fc SQLAVARS4;\n  SQLELTS_PTR4 = (SQLELTS *) &SQLAVARS4.SQLAVELT;\n  SQLELTS_PTR4->SQLTYPE = 448;\n  SQLELTS_PTR4->SQLLEN  = 28;\n  SQLELTS_PTR4->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR4->SQLIND  = NULL;\n  SQLELTS_PTR4->SQLNAMLEN  = 0;\n  strcpy(SQLAVARS4.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLAVARS4.SQLDABC = 60;\n  SQLAVARS4.SQLN    = 1;\n  SQLAVARS4.SQLD    = 1;\n  SQLPLIST4.SQLAPARM = (char *) &SQLAVARS4.SQLDAID;\n  SQLPLIST4.SQLCODEP = (char *) &sqlca;\n  SQLPLIST4.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST4.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST4.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST4.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST4);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   SQLERROR:\n   if (SQLCODE) diag(\"SET\");\n   \u00fc\n   else\n   \u00e4\n   time_t temp;\n   struct tm *timeptr;\n   temp = time(0);\n   timeptr = localtime(&temp);\n   timestamp.len = strftime(timestamp.arr,sizeof(timestamp.arr)-1,\"%Y-%\u00d6\nm-%d-%H.%M.%S\", timeptr);\n   \u00fc\n   mvsSTRING _dataset;\n   _dataset = mvsSTRING(getenv(KEYWORD_PREFIX)) + \"/\" +\n             jobEnv->jobName + jobEnv->jobId +\n             mvsSTRING(timestamp.arr,timestamp.len);\n   dataset.len = short(_dataset.lengthOf());\n   JOBENV::DEBUG(1,(char *)_dataset);\n   memcpy(dataset.arr,(char *)_dataset,dataset.len+1);\n\u00fc\n\nint DssJob::insert()\n\u00e4\n   CHAINITER::reset();\n   DssDataset * ds;\n   DssDataset * dp;\n   tryToConnect();\n   if (useDB2)\n   \u00e4\n\n/***$$$\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n   EXEC SQL INSERT INTO DSSJOBS\n    VALUES(:timestamp,\n           :jobName, :jobNumber, :program, :dataset, :joblog)\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST6 =\n  \u00e464, 16388, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 4, 0, 0, 0, 1208, 232, 4401, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR6;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 6) ??);\n     \u00fc SQLPVARS6;\n  SQLELTS_PTR6 = (SQLELTS *) &SQLPVARS6.SQLPVELT;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 28;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 9;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( jobName );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 9;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( jobNumber );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 9;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( program );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 255;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( dataset );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  SQLELTS_PTR6 = SQLELTS_PTR6 + 1;\n  SQLELTS_PTR6->SQLTYPE = 448;\n  SQLELTS_PTR6->SQLLEN  = 30000;\n  SQLELTS_PTR6->SQLADDR = (char *)\n  &( joblog );\n  SQLELTS_PTR6->SQLIND  = NULL;\n  SQLELTS_PTR6->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS6.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS6.SQLDABC = 280;\n  SQLPVARS6.SQLN    = 6;\n  SQLPVARS6.SQLD    = 6;\n  SQLPLIST6.SQLVPARM = (char *) &SQLPVARS6.SQLDAID;\n  SQLPLIST6.SQLCODEP = (char *) &sqlca;\n  SQLPLIST6.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST6.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST6.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST6.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST6);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   \u00fc\n   else\n   \u00e4\n     if (fileDB2)\n     fprintf(fileDB2,\"insert into DSSJOBS:\u00d6n\");\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"jobName\",jobName.len,j\u00d6\nobName.len,jobName.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"jobNumber\",jobNumber.l\u00d6\nen,jobNumber.len,jobNumber.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"program\",program.len,p\u00d6\nrogram.len,program.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"dataset\",dataset.len,d\u00d6\nataset.len,dataset.arr);;\n     if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"joblog\",joblog.len,job\u00d6\nlog.len,joblog.arr);;\n    \u00fc\n\n   ds = (DssDataset *)CHAINITER::next();\n   while(ds)\n   \u00e4\n    if(| ds->insert())\n     Error(Msg(10000+1002)<<ds->dataset.arr<<eol,Abort);\n     dp = ds;\n     ds = (DssDataset *)CHAINITER::next();\n     mCHAIN::del(dp);\n     delete dp;\n   \u00fc\n  commit();\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSJOBS\");\n  markerror();\n  return 0;\n\u00fc\n\nstatic char today\u00c412\u00dc;\n\nint DssJob::query(mCHAIN *m,char * date)\n\u00e4\n   if (useDB2==false)\n\treturn 0;\n   CHAINITER iter(*m);\n   mvsSTRING like(\" \");\n   chainE * mask = iter.next();\n   if ( date == 0 )\n   \u00e4\n     date = today;\n     formatTime(today,sizeof(today),\"%d.%m.%Y\");\n     JOBENV::DEBUG(1,(char *)date);\n   \u00fc\n   int likeFlag = 0;\n   while(mask)\n   \u00e4\n      int i, j;\n      for(i=0, j=0;mask->chainEid\u00c4i\u00dc;i++)\n      \u00e4\n         if(mask->chainEid\u00c4i\u00dc |= '*')\n            mask->chainEid\u00c4j++\u00dc = mask->chainEid\u00c4i\u00dc;\n         else if (mask->chainEid\u00c4i+1\u00dc |= '*')\n         \u00e4\n            mask->chainEid\u00c4j++\u00dc = '%';\n            likeFlag = 1;\n         \u00fc\n       \u00fc\n       if (mask->chainEid\u00c4j-1\u00dc |= '%')\n           mask->chainEid\u00c4j++\u00dc = '%';\n      mask->chainEid\u00c4j\u00dc = 0;\n      like = like + \"A.DATASET LIKE '\"+mvsSTRING(mask->chainEid)+\"' \";\n      if (mask->next)\n         like = like + \" OR \";\n      mask = iter.next();\n   \u00fc\n   JOBENV::DEBUG(1,(char *)like);\n     \u00e4\n     char * p\u00c48\u00dc;\n     Msg(10000+122)<<dSql<<eol;\n     size_t l = strlen(dSql);\n     int j = 0;\n     for(int i = 0;i<l&&j<8;i++)\n       if (dSql\u00c4i\u00dc=='%' && dSql\u00c4i+2\u00dc == '%')\n         \u00e4\n         switch (dSql\u00c4i+1\u00dc)\n           \u00e4\n           case 'M':\n           case 'm': p\u00c4j++\u00dc = like;\n             break;\n           case 'D':\n           case 'd': p\u00c4j++\u00dc = date;\n             break;\n           default :\n             JOBENV::Error(Msg(10000+121)<<dSql\u00c4i\u00dc<<eol,JOBENV::Abort);\n           \u00fc\n           dSql\u00c4i+1\u00dc = 's';\n         strcpy(dSql+i+2,dSql+i+3);\n         l -= 2;\n         \u00fc\n       switch(j)\n         \u00e4\n         default:\n         case 0:\n         strcpy(dynamicSql.arr,dSql);\n         break;\n         case 1:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc);\n         break;\n         case 2:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc);\n         break;\n         case 3:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc);\n         break;\n         case 4:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc);\n         break;\n         case 5:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc);\n         break;\n         case 6:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc);\n         break;\n         case 7:\n         sprintf(dynamicSql.arr,dSql,p\u00c40\u00dc,p\u00c41\u00dc,p\u00c42\u00dc,p\u00c43\u00dc,p\u00c44\u00dc,\n           p\u00c45\u00dc,p\u00c46\u00dc);\n         break;\n         \u00fc\n     \u00fc\n   JOBENV::DEBUG(1,(char *)dynamicSql.arr);\n   Msg(10000+123)<<dynamicSql.arr<<eol;\n   dynamicSql.len =short(strlen(dynamicSql.arr));\n   tryToConnect();\n\t DssJob * job = 0;\n   int fetchCount = 0;\n\n/***$$$\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n   EXEC SQL PREPARE FULL_QUERY FROM :dynamicSql\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST8 =\n  \u00e464, 16388, 35,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 14, 4538, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR8;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 2) ??);\n     \u00fc SQLPVARS8;\n  SQLELTS_PTR8 = (SQLELTS *) &SQLPVARS8.SQLPVELT;\n  SQLELTS_PTR8->SQLTYPE = 452;\n  SQLELTS_PTR8->SQLLEN  = 0;\n  SQLELTS_PTR8->SQLADDR = 0;\n  SQLELTS_PTR8->SQLNAMLEN  = 0;\n  SQLELTS_PTR8 = SQLELTS_PTR8 + 1;\n  SQLELTS_PTR8->SQLTYPE = 448;\n  SQLELTS_PTR8->SQLLEN  = 32000;\n  SQLELTS_PTR8->SQLADDR = (char *)\n  &( dynamicSql );\n  SQLELTS_PTR8->SQLIND  = NULL;\n  SQLELTS_PTR8->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS8.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS8.SQLDABC = 104;\n  SQLPVARS8.SQLN    = 2;\n  SQLPVARS8.SQLD    = 2;\n  SQLPLIST8.SQLVPARM = (char *) &SQLPVARS8.SQLDAID;\n  SQLPLIST8.SQLCODEP = (char *) &sqlca;\n  SQLPLIST8.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST8.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST8.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST8.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST8);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n\n/***$$$\n   EXEC SQL DECLARE C_FULL_QUERY CURSOR FOR FULL_QUERY\n$$$***/\n\n\n/***$$$\n   EXEC SQL OPEN C_FULL_QUERY\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST10 =\n  \u00e464, 4, 50,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 3, 4540, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR10;\n  SQLPLIST10.SQLCODEP = (char *) &sqlca;\n  SQLPLIST10.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST10.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST10.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST10.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST10);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n\n   for (;;)\n   \u00e4\n\n/***$$$\n      EXEC SQL FETCH C_FULL_QUERY INTO\n      :record_key,\n      :record_job,\n      :record_dataset,\n      :record_volumes,\n      :record_size\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST11 =\n  \u00e464, 1028, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 4, 4544, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR11;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLAVELT??( (sizeof(SQLELTS) * 5) ??);\n     \u00fc SQLAVARS11;\n  SQLELTS_PTR11 = (SQLELTS *) &SQLAVARS11.SQLAVELT;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 28;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_key );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 28;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_job );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 45;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_dataset );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 448;\n  SQLELTS_PTR11->SQLLEN  = 37;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_volumes );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  SQLELTS_PTR11 = SQLELTS_PTR11 + 1;\n  SQLELTS_PTR11->SQLTYPE = 496;\n  SQLELTS_PTR11->SQLLEN  = 4;\n  SQLELTS_PTR11->SQLADDR = (char *)\n  &( record_size );\n  SQLELTS_PTR11->SQLIND  = NULL;\n  SQLELTS_PTR11->SQLNAMLEN  = 0;\n  strcpy(SQLAVARS11.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLAVARS11.SQLDABC = 236;\n  SQLAVARS11.SQLN    = 5;\n  SQLAVARS11.SQLD    = 5;\n  SQLPLIST11.SQLAPARM = (char *) &SQLAVARS11.SQLDAID;\n  SQLPLIST11.SQLCODEP = (char *) &sqlca;\n  SQLPLIST11.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST11.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST11.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST11.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST11);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n      if (SQLCODE == 100) break;\n\n        if (job == 0 ]]\n         memcmp(job->timestamp.arr,record_job.arr,job->timestamp.len))\n    \u00e4\n         job = new DssJob((TIMESTAMP&)record_job);\n         dssJobs.addlast(job);\n         fetchCount++;\n        \u00fc\n        DssDataset * dataset = new DssDataset(job,\n                                        record_dataset.arr,\n                                        record_volumes.arr,\n                                        record_type,\n                                        record_size);\n   \u00fc\n\n/***$$$\n   EXEC SQL CLOSE C_FULL_QUERY\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST12 =\n  \u00e464, 4, 45,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 1, 0, 0, 0, 1208, 5, 4565, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR12;\n  SQLPLIST12.SQLCODEP = (char *) &sqlca;\n  SQLPLIST12.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST12.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST12.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST12.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST12);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   return fetchCount;\nSQLERROR:\n   diag(\"FULL QUERY\");\n   markerror();\n   return -1;\n\u00fc\n\nint DssJob::doWeNeed(const char * d)\n  \u00e4\n  CHAINITER iter(this);\n  DssDataset * ds =(DssDataset *)iter.next();\n  while (ds)\n    \u00e4\n    if (ds->compare(d))\n      return 1;\n    ds =(DssDataset *)iter.next();\n    \u00fc\n  return 0;\n  \u00fc\n\nint DssJob::allOnline()\n\u00e4\n char _genFileName\u00c41024\u00dc;\n  FILE *   restore = fopen(genOpenName(\"RESTORE\",_genFileName),\"wb\");\n  if (| restore)\n     JOBENV::Error(Msg(10000+110)<<\"RESTORE\"<<eol,JOBENV::Abort);\n  int rc = 1;\n  CHAINITER iter(dssJobs);\n  DssJob * job = (DssJob*)iter.next();\n  while (job)\n  \u00e4\n    int file = open(genOpenName(job->getDatasetName(),_genFileName),0x0\u00d6\n2+0);\n    if (file < 0)\n    \u00e4\n       rc = 0;\n       JOBENV::Error(Msg(10000+120)<<job->getDatasetName()<<strerror((*\u00d6\n__errno()))\n         <<eol,JOBENV::Continue);\n       fprintf(restore,\"%s\u00d6n\",job->getDatasetName());\n    \u00fc\n    else\n       close(file);\n    job = (DssJob*)iter.next();\n  \u00fc\n  fclose(restore);\n  return rc;\n\u00fc\n\n\n\n\n\n\nDssDataset::DssDataset(DssJob* j,char *n,char *v,int t,int s):\nSQLINTERFACE(),\nchainE(n),\njob(j)\n\u00e4\n   job->addlast(this);\n   dataset.len = (((strlen(n))>(sizeof(dataset.arr)))?(sizeof(dataset.a\u00d6\nrr)):(strlen(n)));\n   strncpy(dataset.arr,n,dataset.len);\n   dataset.arr\u00c4dataset.len\u00dc = 0;\n\n   volumes.len = (((strlen(v))>(sizeof(volumes.arr)-1))?(sizeof(volumes\u00d6\n.arr)-1):(strlen(v)));\n   strncpy(volumes.arr,v,volumes.len);\n   volumes.arr\u00c4volumes.len\u00dc = 0;\n   type = t;\n   recordsize = s;\n   JOBENV::DEBUG(1,\"Dataset construct\",n,v);\n\u00fc\n\nDssDataset::\u00dfDssDataset()\n\u00e4\n\u00fc\n\nint DssDataset::insert()\n\u00e4\n   tryToConnect();\n   memcpy(timestamp.arr,job->timestamp.arr,job->timestamp.len+1);\n   timestamp.len = job->timestamp.len;\n   JOBENV::DEBUG(1,\"Dataset insert:\",dataset.arr);\n   if (useDB2)\n   \u00e4\n\n/***$$$\n   EXEC SQL WHENEVER SQLERROR GOTO SQLERROR\n$$$***/\n\n\n/***$$$\n   EXEC SQL INSERT INTO DSSDATASETS\n   VALUES(CURRENT TIMESTAMP,\n   :timestamp,\n   :dataset,\n   :volumes,\n   :type,\n   :recordsize)\n$$$***/\n  \u00e4\n  SQLPLIST SQLPLIST14 =\n  \u00e464, 16388, 30,\n   \u00e4'\u00d6x44','\u00d6x53','\u00d6x53','\u00d6x44','\u00d6x42','\u00d6x20','\u00d6x20','\u00d6x20'\u00fc,\n   0, 0, 0, 0, 5, 0, 0, 0, 1208, 232, 4653, 0, 0, 0, 0, 0\u00fc;\n  SQLELTS_PTR SQLELTS_PTR14;\n  struct\n     \u00e4 char   SQLDAID??(8??);\n       long   SQLDABC;\n       short  SQLN;\n       short  SQLD;\n       char  SQLPVELT??( (sizeof(SQLELTS) * 5) ??);\n     \u00fc SQLPVARS14;\n  SQLELTS_PTR14 = (SQLELTS *) &SQLPVARS14.SQLPVELT;\n  SQLELTS_PTR14->SQLTYPE = 448;\n  SQLELTS_PTR14->SQLLEN  = 28;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( timestamp );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 448;\n  SQLELTS_PTR14->SQLLEN  = 255;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( dataset );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 448;\n  SQLELTS_PTR14->SQLLEN  = 37;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( volumes );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 496;\n  SQLELTS_PTR14->SQLLEN  = 4;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( type );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  SQLELTS_PTR14 = SQLELTS_PTR14 + 1;\n  SQLELTS_PTR14->SQLTYPE = 496;\n  SQLELTS_PTR14->SQLLEN  = 4;\n  SQLELTS_PTR14->SQLADDR = (char *)\n  &( DssDatasetRecord.recordsize );\n  SQLELTS_PTR14->SQLIND  = NULL;\n  SQLELTS_PTR14->SQLNAMLEN  = 0;\n  strcpy(SQLPVARS14.SQLDAID, \"\u00d6xE2\u00d6xD8\u00d6xD3\u00d6xC4\u00d6xC1\u00d6x40\u00d6x40\u00d6x08\");\n  SQLPVARS14.SQLDABC = 236;\n  SQLPVARS14.SQLN    = 5;\n  SQLPVARS14.SQLD    = 5;\n  SQLPLIST14.SQLVPARM = (char *) &SQLPVARS14.SQLDAID;\n  SQLPLIST14.SQLCODEP = (char *) &sqlca;\n  SQLPLIST14.SQLTIMES??( 0 ??) = 0x1951;\n  SQLPLIST14.SQLTIMES??( 1 ??) = 0x8331;\n  SQLPLIST14.SQLTIMES??( 2 ??) = 0x0BFC;\n  SQLPLIST14.SQLTIMES??( 3 ??) = 0x4B14;\n  DSNHLI ( (unsigned int * ) &SQLPLIST14);\n  \u00fc\n  if (SQLCODE < 0) goto  SQLERROR;\n\n   \u00fc\n   else\n   \u00e4\n   if (SQLINTERFACE::fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\"insert into DSSDATASETS:\u00d6n\");\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"timestamp\",timestamp.len\u00d6\n,timestamp.len,timestamp.arr);;\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"dataset\",dataset.len,dat\u00d6\naset.len,dataset.arr);;\n   if (fileDB2) fprintf(fileDB2,\" %s:%*.*s\u00d6n\",\"volumes\",volumes.len,vol\u00d6\numes.len,volumes.arr);;\n   if (fileDB2)\n   fprintf(SQLINTERFACE::fileDB2,\" type:%d\u00d6n size:%d\u00d6n\",type,recordsize\u00d6\n);\n   \u00fc\n  return 1;\nSQLERROR:\n  diag(\"INSERT INTO DSSDATASETS\");\n  markerror();\n  return 0;\n\u00fc\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT880/CBT.V500.FILE880.PDS/PPONLY.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT880/CBT.V500.FILE880.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}