{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "ESA", "INMTNODE": "JES2P390", "INMTUID": "ESA", "INMFTIME": "20121130073623000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 559104, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "ESA.PRJ.CBTDSSN.ASM", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 559104, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 559104, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"ESA.PRJ.CBTDSSN.ASM": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\x03\\xb0p\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$": {"ttr": 33, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* 05/09/06 baseless code\n         MACRO\n&LABEL   $$    &FUNCTION,&START=,&END=,&STRIPCH=' ',                   *\n               &CALL=,&R0=,&R1=,&R2=,&R3=,&R4=,&R5=,&R6=,&R7=,         *\n               &R8=,&R9=,&R10=,&R11=,&R12=,&R13=,&R14=,&R15=,          *\n               &REG=R14,&INCR=,&DECR=,                                 *\n               &SWITCH=,&CASE=,                                        *\n               &FROMCH=,&TOCH=,                                        *\n               &CH=,&CHA=,                                             *\n               &TO=,&POINTER=,&LENGTH=,                                *\n               &PARM=,                                                 *\n               &TYPE=MACRO,                                            *\n               &SWTYPE=,                                               *\n               &DSECT=NO,                                              *\n               &MF=\n         COPY  $$SYSVAR\n         SPACE 1\n         AIF   ('&TYPE' EQ 'MACRO').MACRO\n         AIF   ('&TYPE' EQ 'LOCAL' OR '&MF' EQ 'L').LOCAL\n         AIF   ('&TYPE' EQ 'PROGRAM').PROGRAM\n         AIF   ('&TYPE' EQ 'MSG').MSG\n         AIF   ('&MF(1)' EQ 'E').MFE\n.LOCAL   ANOP\n&LABEL   $$DSECT DSECT=&DSECT\n&LABEL._8A DC    8A(0)              eight words\n&LABEL._FUNCTION DC CL16' '         function name\n         MEXIT\n.MFE     ANOP\n         LCLA  &N,&I\n         LCLC  &TOSTR\n&N       SETA  N'&PARM\n&I       SETA  0\n.MFELOOP ANOP\n&I       SETA  &I+1\n         AIF   (&I GT &N).MFECALL\n&TOSTR   SETC '&MF(2)'\n         AIF   ('&PARM(&I)'(1,1) EQ '(').MFEREG\n         LA    R0,&PARM(&I)        + get addr\n         ST    R0,&TOSTR+(&I-1)*4  + store into parm list\n         AGO  .MFELOOP\n.MFEREG  ST    &PARM(&I),&TOSTR+(&I-1)*4 + store into parm list\n         AGO  .MFELOOP\n.MFECALL ANOP\n         MVC   &MF(2).+32(16),=CL16'&FUNCTION' copy code\n         LA    R1,&MF(2)           get addr\n         $$LINK &PROJECT.$$        call it\n         LM    R15,R1,&MF(2)       back it\n         LTR   R15,R15             test code\n         MEXIT\n.MACRO   ANOP\n.*\n.* GLOBAL SERVICES macro\n.*\n         AIF   ('&LABEL' EQ '').NOLABEL\n&LABEL   DS    0H\n.NOLABEL ANOP\n         AIF   ('&SWITCH' NE '').SWITCH\n         AIF   ('&CALL' NE '').CALL\n         AIF   ('&INCR' NE '').INCR\n         AIF   ('&DECR' NE '').DECR\n         AIF   ('&FUNCTION' EQ 'STRIP').STRIP\n         AIF   ('&FUNCTION' EQ 'COPYPTR').COPYPTR\n         AIF   ('&FUNCTION' EQ 'CHANGECH').CHANGECH\n         AIF   ('&FUNCTION' EQ 'ISPRINT').ISPRINT\n         AIF   ('&FUNCTION' EQ 'SEARCH').SEARCH\n         AIF   ('&MF' NE '').MFE\n         MNOTE 8,'INVALID FUNCTION CALL FOR $$'\n         MEXIT\n.STRIP   LA    R0,&START           + get start\n         LA    R1,&END             + get end addr\n         SR    R1,R0               + get length\n         SR    R15,R15             + null length\n         ICM   R15,15,=C&STRIPCH   + get strip char\n         CLCL  R0,R14              + search for first\n         JE    STRIPN&SYSNDX       + branch if all zero\n         LA    R14,&END            + last byte\n         BCTR  R14,0               + decr it\nSTRIP&SYSNDX CLI   0(R14),C&STRIPCH + check from the back\n         JNE   *+10                + branch if not\n         BCTR  R14,0               + decr it\n         BRCT  R1,STRIP&SYSNDX     + try the next one\n         LA    R1,1(,R14)          + get last byte addr +1\n         J     STRIPR&SYSNDX       + branch out\nSTRIPN&SYSNDX LR R0,R1             + same in r0\nSTRIPR&SYSNDX LR R15,R1            + get end addr\n         SR    R15,R0              + get length\n         MEXIT\n.COPYPTR ICM   R14,15,&POINTER     + get pointer\n         JZ    $$R&SYSNDX          + branch if zero\n         CLC   0(&LENGTH,R14),BLANKS + blank all\n         JE    $$R&SYSNDX          + branch if zero\n         OC    0(&LENGTH,R14),0(R14) + zero all\n         JZ    $$R&SYSNDX          + branch if zero\n         LA    R0,&TO              + get to addr\n         LA    R1,L'&TO            + GET LENGTH\n         LA    15,&LENGTH          + get from\n         ICM   R15,8,BLANKS        get pad\n         MVCL  R0,R14              + copy it\n$$R&SYSNDX DS 0H\n         MEXIT\n.CHANGECH SR    R0,R0              + clear flag\n         LA    R14,&START          + get start\n         LA    R15,&LENGTH         + length\n$$L&SYSNDX CLI 0(R14),&FROMCH      + get from character\n         JNE   *+8                 + branch if not\n         MVI   0(R14),&TOCH        + set new\n         CLI   0(R14),&TOCH        + check for char\n         JNE   $$N&SYSNDX          + branch if not\n         LA    R0,1                + set flag\n$$N&SYSNDX LA  R14,1(,R14)         + incr pointer\n         BRCT  R15,$$L&SYSNDX      + go to the next one\n         MEXIT\n.SEARCH   SR    R0,R0              + clear flag\n         LA    R14,&START          + get start\n         LA    R15,&LENGTH         + length\n$$L&SYSNDX DS  0H\n         AIF   ('&CHA' NE '').SRCHL1 + if address\n         CLI   0(R14),&CH          + is it the requested\n         AGO   .SRCHLS             + branch over\n.SRCHL1  CLC   0(1,R14),&CHA       + compare it\n.SRCHLS  ANOP\n         JNE   $$N&SYSNDX          + branch if not\n         LA    R0,1                + set flag\n         J     $$Z&SYSNDX          + branch out\n$$N&SYSNDX LA  R14,1(,R14)         + incr pointer\n         BRCT  R15,$$L&SYSNDX      + go to the next one\n$$Z&SYSNDX LTR R15,R0              + get result\n         MEXIT\n.SWITCH  ANOP\n         AIF   ('&SWTYPE' EQ 'BINARY').SWBIN\n&I       SETA  1\n&N       SETA  N'&CASE\n.SWITCHL AIF   (&I GE &N).SWITCHE\n         AIF   ('&CASE(&I)'(1,1) EQ '''').CASEC\n         AIF   ('&CASE(&I)'(1,1) EQ '\"').CASEX\n         AIF   ('&CASE(&I)'(1,1) EQ '=').CASEL\n         AGO   .CASEL\n         CLC   =AL(L'&CASE(&I))(&CASE(&I)),&SWITCH + CHECK COND NUMBER\n         AGO   .CASEBR\n.CASEX   ANOP\n&HEX     SETC  '&CASE(&I)'(2,K'&CASE(&I)-2)\n         CLC   =X'&HEX',&SWITCH    + check cond HEX\n         AGO   .CASEBR\n.CASEL   CLC   &CASE(&I),&SWITCH   + check cond\n         AGO   .CASEBR\n.CASEC   CLC   =C&CASE(&I),&SWITCH + check cond\n.CASEBR  JE    &CASE(&I+1)         + branch if equal\n&I       SETA  &I+2\n         AGO   .SWITCHL\n.SWITCHE MEXIT\n.SWBIN   ANOP\n&I       SETA  1\n&N       SETA  N'&CASE\n         AIF   ('&DSECT' EQ 'YES').SWBINL\n         LLGC  R15,&SWITCH       + get code\n         SLL   R15,2             + by four\n         A     R15,=A(BR&SYSNDX) + table addrerss\n         BR    R15               + jump into table\nBR&SYSNDX DS 0F\n.SWBINL  AIF   (&I GT &N).SWBINE\n         AIF   ('&DSECT' EQ 'YES').SWBD\n         J     &CASE(&I)         +if &I*4 branch to &CASE(&I)\n         AGO   .SWBN\n.SWBD    ANOP\nSYM_&CASE(&I) EQU &I-1        + symb equ\n.SWBN    ANOP\n&I       SETA  &I+1\n         AGO   .SWBINL\n.SWBINE  MEXIT\n.CALL    ANOP\n         AIF   ('&R0' EQ '').NOR0\n         LA    R0,&R0              + get r0\n.NOR0    ANOP\n         AIF   ('&R1' EQ '').NOR1\n         LA    R1,&R1              + get r1\n.NOR1    ANOP\n         AIF   ('&R2' EQ '').NOR2\n         LA    R2,&R2              + get r2\n.NOR2    ANOP\n         AIF   ('&R3' EQ '').NOR3\n         LA    R3,&R3              + get r3\n.NOR3    ANOP\n         AIF   ('&R4' EQ '').NOR4\n         LA    R4,&R4              + get r4\n.NOR4    ANOP\n         AIF   ('&R5' EQ '').NOR5\n         LA    R5,&R5              + get r5\n.NOR5    ANOP\n         AIF   ('&R6' EQ '').NOR6\n         LA    R6,&R6              + get r6\n.NOR6    ANOP\n         AIF   ('&R7' EQ '').NOR7\n         LA    R7,&R7              + get r7\n.NOR7    ANOP\n         AIF   ('&R8' EQ '').NOR8\n         LA    R8,&R8              + get r8\n.NOR8    ANOP\n         AIF   ('&R9' EQ '').NOR9\n         LA    R9,&R9              + get r9\n.NOR9    ANOP\n         AIF   ('&R10' EQ '').NOR10\n         LA    R10,&R10            + get r10\n.NOR10   ANOP\n         AIF   ('&R11' EQ '').NOR11\n         LA    R11,&R11            + get r11\n.NOR11   ANOP\n         AIF   ('&R12' EQ '').NOR12\n         LA    R12,&R12            + get r12\n.NOR12   ANOP\n         AIF   ('&R13' EQ '').NOR13\n         LA    R13,&R13            + get r13\n.NOR13   ANOP\n         AIF   ('&R14' EQ '').NOR14\n         LA    R14,&R14            + get r14\n.NOR14   ANOP\n         AIF   ('&R15' EQ '').NOR15\n         LA    R15,&R15            + get r15\n.NOR15   ANOP\n*        L     R14,=A(&CALL)       + get call address\n         BRASL R14,&CALL           + call the module\n         LTR   R15,R15             + test code\n         MEXIT\n.INCR    L     &REG,&INCR          + get value\n         AHI   &REG,1              + incr it\n         ST    &REG,&INCR          + save it\n         MEXIT\n.DECR    L     &REG,&DECR          + get value\n         AHI   &REG,-1             + decr it\n         ST    &REG,&DECR          + save it\n         MEXIT\n.ISPRINT ANOP\n         GBLB &ISPRINT\n         L    R15,=A(ISPRINT)       +get addr\n         TRT  &START,0(R15)          +tarnslate it\n         AIF  (&ISPRINT).ISTBOK\n&ISPRINT SETB 1\n&SECT    SETC '&SYSECT'\nISPRINT  CSECT\nISPRINT_TBL DC 256X'01'\n         ORG ISPRINT_TBL+X'40'\n         DC   X'00'\n         ORG ISPRINT_TBL+C'#'\n         DC   X'00'\n         ORG ISPRINT_TBL+C'$'\n         DC   X'00'\n         ORG ISPRINT_TBL+C'@'\n         DC   X'00'\n         ORG ISPRINT_TBL+C'\u00a7'\n         DC   X'00'\n         ORG ISPRINT_TBL+C'A'\n         DC   X'000000000000000000'\n         ORG ISPRINT_TBL+C'J'\n         DC   X'000000000000000000'\n         ORG ISPRINT_TBL+C'S'\n         DC   X'0000000000000000'\n         ORG ISPRINT_TBL+C'0'\n         DC   X'00000000000000000000'\n         ORG\n&SECT    CSECT\n.ISTBOK  ANOP\n         MEXIT\n.PROGRAM ANOP\n         TITLE ' $$ MODULE'\n***********************************************************************\n*                                                                     *\n* $$                                                                  *\n*                                                                     *\n* Function:                                                           *\n*  ...                                                                *\n*                                                                     *\n*  Register assignment :                                              *\n*                                                                     *\n* Amode(31) , Rmode(ANY)                                              *\n*                                                                     *\n***********************************************************************\n$$DSECT  $$ TYPE=LOCAL,DSECT=YES\n*PROJECT.$$  $$ENTRY TYPE=STACK,                                       *\n               BASE=BASELESS,                                          *\n               AMODE=31,                                               *\n               RMODE=ANY,                                              *\n               USING=(&PROJECT.CVT,R10,$$DSECT,R9,PSA,R0,              *\n               $$_WORK,R13),                                           *\n               TITLE='$$ ROUTINE '\n&PROJECT.$$  $$ENTRY TYPE=STACK,                                       *\n               BASE=BASELESS,                                          *\n               AMODE=31,                                               *\n               RMODE=ANY,                                              *\n               USING=(&PROJECT.CVT,R10,$$DSECT,R9,PSA,R0,              *\n               $$_WORK,R13),                                           *\n               TITLE='$$ ROUTINE '\n*        $$GETCVT CVTREG=R10       get CVT addr\n         $$GETCVT CVTREG=R10       get CVT addr\n*        $$DEBUG ID=$$_entry_parms,ADDR=($$DSECT_FUNCTION,32)\n         $$DEBUG ID=$$_ENTRY_PARMS,ADDR=($$DSECT_FUNCTION,32)\n         LM    R0,R7,$$DSECT_8A    get PARM\n         L     R14,=A(RETURN+X'80000000') return addr\n         $$    SWITCH=$$DSECT_FUNCTION,                                *\n               CASE=('COPYTILL',COPYTILL,                              *\n               'STRINSTR',STRINSTR,                                    *\n               'NEXTTU',NEXTTU)\n*        $$MSG S$10,INSERT=(16,$$DSECT_FUNCTION) msg\n         $$MSG S$10,INSERT=(16,$$DSECT_FUNCTION) msg\n         J     RETURN04            branch back\n         TITLE ' copytill'\n*---------------------------------------------------------------------*\n* r0 - from address                                                   *\n* r1 - from length pointer                                            *\n* r2 - to addr                                                        *\n* r3 - to total length  pointer                                       *\n* r4 - term char addr pointer                                         *\n*---------------------------------------------------------------------*\nCOPYTILL BAKR  R14,0               all in stack\n         L     R15,0(,R1)          get length\n         LTR   R15,R15             test it\n         JNP   COPYTILL_TERM       if in error\n         LR    R1,R0               from address\n         LA    R5,0(R1,R15)        after the last\n         LR    R0,R15              from length\n         ICM   R3,15,0(R3)         to total length\n         JZ    ERR_PARM_4          if in error\n         LR    R15,R4              char addr\n         SR    R4,R4               clear it\n         IC    R4,0(R15)           get it\n         SR    R15,R15             clear from addr\n         ICM   R15,8,BLANKS        get pad\n         MVCL  R2,R14              blank all\n         EREG  R2,R3               back regs\n         L     R3,0(,R3)           to total length\n         LA    R14,1               set apost flag\n         LA    R15,1               get one\nCOPYTILL_LOOP DS 0H                test apost flag\n         CLI   0(R1),C''''         apost\n         JNE   *+6                 branch if not\n         LCR   R14,R14             change sign\n         LTR   R14,R14             test sign\n         JM    COPYTILL_MVC        branch if in\n         EX    R4,COPYTILL_EX      exec compare\n         JE    COPYTILL_TERM       term found\nCOPYTILL_MVC DS 0H\n         MVC   0(1,R2),0(R1)       copy a byte\n         AR    R2,R15              incr to\n         AR    R1,R15              incr from\n         SR    R0,R15              decr it\n         JNP   COPYTILL_TERM       if no more\n         SR    R3,R15              decr it\n         JNP   COPYTILL_TERM       if no more\n         J     COPYTILL_LOOP       try next\nCOPYTILL_TERM DS 0H\n         LA    R1,1(,R1)           past term\n         SR    R5,R1               get length\n         LTR   R5,R5               test remainder\n         BP    *+6                 if ok\n         SR    R5,R5               clear it\n         LR    R0,R1               in r0 back end address\n         LR    R1,R5               rest length in r1\n         PR    ,                   return back\n         TITLE ' nexttu'\n*---------------------------------------------------------------------*\n* r0 - actual start address                                           *\n* r1 - end address                                                    *\n* return                                                              *\n* r1 - next tu start address or zero                                  *\n* r0 - tu length                                                      *\n* r15- tu key length                                                  *\n*---------------------------------------------------------------------*\nNEXTTU   BAKR  R14,0               all in stack\n         LR    R5,R0               save actual start addr\n         LR    R6,R0               start here also\n         LR    R0,R1               get end addr\n         LR    R1,R5               pointer\n         LA    R14,1               clear apost flag\nNEXTTU_LOOP DS 0H\n         CLI   0(R1),C''''         is it apost\n         JNE   *+6                 branch if not\n         LCR   R14,R14             change sign\n         LTR   R14,R14             testflag\n         JNP   NEXTTU_NEXT         branch if in\n         CLI   0(R1),C'='          is it the key\n         JNE   NEXTTU_NOKEY        if no key\n         SR    R5,R1               get negative length\n         J     NEXTTU_NEXT         next char\nNEXTTU_NOKEY DS 0H\n         CLI   0(R1),C','          is it term comma\n         JNE   NEXTTU_NOTERM       branch if not\n         SR    R6,R1               length of key\n         LA    R1,1(,R1)           step over term\n         J     NEXTTU_END_00       branch back\nNEXTTU_NOTERM DS 0H\n         CLI   0(R1),C' '          end of stream\n         JNE   NEXTTU_NEXT         branch if not\nNEXTTU_TERM DS 0H\n         SR    R6,R1               length of key\n         SR    R1,R1               nomore\n         J     NEXTTU_END_00       branch back\nNEXTTU_NEXT  CR R1,R0              check end\n         BNL   NEXTTU_TERM         branch if no more\n         LA    R1,1(,R1)           incr addr\n         J     NEXTTU_LOOP         try it\nNEXTTU_END_00 DS 0H\n         LPR   R0,R6               tu length\n         LTR   R0,R0               test it\n         BP    *+6                 if ok\n         SR    R0,R0               clear it\n         LPR   R15,R5              key length\n         LTR   R15,R15             test it\n         BP    *+6                 if ok\n         SR    R15,R15             clear it\n         PR    ,                   return bcak\n         TITLE 'string in string '\n*---------------------------------------------------------------------*\n* r0 - start address                                                  *\n* r1 - end address +1                                                 *\n* r2 - target start                                                   *\n* r3 - target length pointer                                          *\n*---------------------------------------------------------------------*\nSTRINSTR BAKR  R14,0               all in stack\n         LA    R14,1               apost flag\n         LTR   R0,R0               test parm 1\n         JNP   ERR_PARM_1          parm error\n         LTR   R1,R1               test parm 2\n         JNP   ERR_PARM_2          parm error\n         LTR   R2,R2               test parm 3\n         JNP   ERR_PARM_3          parm error\n         ICM   R3,15,0(R3)         get length\n         JNP   ERR_PARM_4          if no length\n         CH    R3,=Y(255)          max length\n         JH    STRINSTR_END_04     invalid parm\n         BCTR  R3,0                in machine form\n         LR    R4,R1               after the last byte\n         BCTR  R4,0                to the last byte\n         LR    R1,R0               pointer\nSTRINSTR_LOOP DS 0H\n         CLI   0(R1),C''''         is it apost\n         JNE   *+6                 if not\n         LCR   R14,R14             change sign\n         LTR   R14,R14             check sign\n         JNP   STRINSTR_NEXT       if not\nSTRINSTR_COMP DS 0H\n         LR    R15,R4              get end addr\n         SR    R15,R1              get diff\n         CR    R15,R3              check with target\n         JL    STRINSTR_END_04     no place\n         EX    R3,STRINSTR_CLC     check it\n         JE    STRINSTR_END_00     check ok\nSTRINSTR_NEXT DS 0H\n         LA    R1,1(,R1)           incr addr\n         CR    R1,R4               check addr\n         JH    STRINSTR_END_04     branch back\n         J     STRINSTR_LOOP       next byte\nSTRINSTR_END_04 LA  R15,4          get code\n         SR    R1,R1               clear pointer\n         J     STRINSTR_END        branch out\nSTRINSTR_END_00 SR R15,R15         clear return\nSTRINSTR_END    PR ,               return back\n         SPACE 1\n* error messages and return points\n         SPACE 1\n*RR_PARM_1 $$MSG S$01,INSERT=(16,$$DSECT_FUNCTION)\nERR_PARM_1 $$MSG S$01,INSERT=(16,$$DSECT_FUNCTION)\n         J     RETURN04            branch back\n*RR_PARM_2 $$MSG S$02,INSERT=(16,$$DSECT_FUNCTION)\nERR_PARM_2 $$MSG S$02,INSERT=(16,$$DSECT_FUNCTION)\n         J     RETURN04            branch back\n*RR_PARM_3 $$MSG S$03,INSERT=(16,$$DSECT_FUNCTION)\nERR_PARM_3 $$MSG S$03,INSERT=(16,$$DSECT_FUNCTION)\n         J     RETURN04            branch back\n*RR_PARM_4 $$MSG S$04,INSERT=(16,$$DSECT_FUNCTION)\nERR_PARM_4 $$MSG S$04,INSERT=(16,$$DSECT_FUNCTION)\n         J     RETURN04            branch back\nRETURN04 LA     R15,4              get code\nRETURN   DS     0H\n         STM   R15,R1,$$DSECT_8A   back result\n*        $$DEBUG ID=$$_EXIT_parms,addr=($$DSECT_FUNCTION%,12)\n         $$DEBUG ID=$$_EXIT_PARMS,ADDR=($$DSECT_FUNCTION%,12)\n*        $$RETURN TYPE=STACK\n         $$RETURN TYPE=STACK\n*        $$dbase\n         $$DBASE\n$$BASE   LOCTR\nCOPYTILL_EX CLI 0(R1),0            ** exec only **\nSTRINSTR_CLC CLC 0(*-*,R1),0(R2)   ** exec only **\n         LTORG\nBLANKS   DC    CL80' '             blank\n         TITLE 'MODULE $$_WORK AREA '\n$$_WORK  DSECT\n$$_WORKSAVE DS 18A                 save area\n$$_WORKR0R1 DC 2A(0)               SAVE FOR r0 r1\n         $$MSG TYPE=LOCAL,DSECT=NO\n$$_WORKLGTH EQU *-$$_WORK           length of the dsect\n*        GBLB &PRINT\n*&PRINT   SETB 1\n         $$GLOBAL\n         PRINT NOGEN\n         MEXIT\n.MSG     ANOP\n         MNOTE 0,'S$ for $$ '\n         IKJTSMSG ('QFSS$01E internal error - 1 ',),S$01\n         IKJTSMSG ('QFSS$02E internal error - 2 ',),S$02\n         IKJTSMSG ('QFSS$03E internal error - 3 ',),S$03\n         IKJTSMSG ('QFSS$04E internal error - 4 ',),S$04\n         IKJTSMSG ('QFSS$10E invalid request',),S$10\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$ASMIF": {"ttr": 113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0e\\x00F\\x01\\x12%O\\x01\\x122o\\x14P\\t'\\nX\\x00\\x00\\xc5\\xe2\\xc1@@@@@@@\"", "ispf": {"version": "01.14", "flags": 0, "createdate": "2012-09-10T00:00:00", "modifydate": "2012-11-21T14:50:46", "lines": 2343, "newlines": 2648, "modlines": 0, "user": "ESA"}, "text": "* 25/08/04 enq/deq around wait\n* 25/03/05 TDUMP\n* 18/11/05 LOGGER support\n* 21/11/05 VTOC access\n* 13/01/06 Browse Logger\n* 16/11/06 RMODE warning from binder\n* 05/10/07 store IEATDUMP reason code\n* 21/04/08 name/token service in user/problem state\n* 19/11/08 SRB callback\n* 21/11/08 baseless code\n* 24/11/08 WLM enclave\n* 04/03/10 OBTAIN DSCB\n* 16/07/10 LOGGER browse TIME search\n* 16/08/11 OBTAIN EADSCB=OK for EAV volumes\n* 17/11/11 GetToken in SYSTEM_LEVEL\n* 19/12/11 IEATDUMP with DDNAME\n* 10/01/12 cleanup register\n* 06/03/12 TESTAUTH DIAGNOSE extension\n* 10/09/12 CAMLST SEEK for OBTAIN\n         MACRO\n&LABEL   $$ASMIF &TYPE=PROGRAM\n         AIF ('&TYPE' EQ 'PROGRAM').PROGRAM\n         AIF ('&TYPE' EQ 'MSG').MSG\n         AIF ('&TYPE' EQ 'DOC').DOC\n.DOC     ANOP\n***********************************************************************\n*                                                                     *\n* asmif                                                               *\n*                                                                     *\n* function:                                                           *\n*  asm interfcae routines                                             *\n*  called from the c++ mvsif module                                   *\n* processing:                                                         *\n*  the function code defines the  functions to execute                *\n*                                                                     *\n*                                                                     *\n* register assignment :                                               *\n* r13 , temp save from asm_save                                       *\n*                                                                     *\n*                                                                     *\n* the routine is getting the control in problem state,  user key      *\n*                                                                     *\n* the module is reentrant                                             *\n*                                                                     *\n* amode(31) , rmode(any)                                              *\n*                                                                     *\n* change :                                                            *\n*                                                                     *\n***********************************************************************\n         MEXIT\n.PROGRAM TITLE ' asmif asm interfcae module'\n         PUSH PRINT\n         PRINT OFF\n         COPY  IEABRC\n         COPY  $$SYSVAR\n         COPY  ASMMSP\n&BASELESS SETB 1\n         POP  PRINT\n* 16/11/06 RMODE warning from binder\nASMIF    CSECT\nASMIF    AMODE 31\nASMIF    RMODE ANY\n* 16/11/06 RMODE warning from binder\n***********************************************************************\n*                                                                     *\n* asmif                                                               *\n*                                                                     *\n* function:                                                           *\n*  asm     interfcae routines                                         *\n*  called from the c++ mvsif module                                   *\n* processing:                                                         *\n*  the function code defines the  functions to execute                *\n*                                                                     *\n*                                                                     *\n* register assignment :                                               *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* the routine is getting the control in problem state,  user key      *\n*                                                                     *\n* the module is reentrant                                             *\n*                                                                     *\n* amode(31) , rmode(any)                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMAX_ECBS  EQU   128*20             max ecb\nMAX_ASM_BUFFER  EQU 4080           page - prefix size\nMAX_ASM_SOCKETS EQU 1024           max sockets\nMAX_ASM_MUTEX   EQU 1024           max mutex\nVRL_LEN         EQU   28           VRL len\n*        iarvrl   ,                VRL map\n         IARVRL   ,                VRL map\nFRRAREA  DSECT\nFRRSAVE  DC    18A(0)\nFRRSDUMPX_L SDUMPX MF=L\nFRRAREA_L   EQU *-FRRAREA\n         SPACE 1\nASMDSECT DSECT\nASM_SAVE DC    18A(0)              save in asm\nASM_MVS      DC A(0)               mvs object pointer\nASM_BASEREGS DC 4A(0)              base regs\nASM_CRAB     DC A(0)               crab pointer\nASM_RC       DC F'0'               function return\nASM_REASON   DC F'0'               function reason code\nASM_IEANTCR  DC A(0)               ieantcr address\nASM_IEANTRT  DC A(0)               ieantrt address\nASM_IEANTDL  DC A(0)               ieantdl address\nASM_TIMX     DC  16A(0)            timer exit area\nASM_TIMER_ECBP  DC A(0)            timer ecb pointer\nASM_EVENT0_ECBP DC A(0)            event0 ecb\nASM_EVENT1_ECBP DC A(0)            event1 ecb\nASM_EVENT2_ECBP DC A(0)            event2 ecb\nASM_EVENT3_ECBP DC A(0)            event3 ecb\nASM_TIMER_ECB  DC A(0)             timer ecb\nASM_FUNCTION_CODE DC AL1(0)        function code\nASM_KEY      DC AL1(0)             psw key save\n* 19/11/08 SRB callback\nASM_SRB_MODE DC AL1(0)             srb mode flag\nASM_SRB_SAVE DC 16A(0)             srb register save area\nASM_SRB_RETURN DC F'0'             srb return address\n* 19/11/08 SRB callback\n             DC 0F'0'              align it\nASM_PARMS    DC 8A(0)              parameters\n             SPACE  3\nASM_CALLLIST DC 8A(0)              call parameters\nASM_WORK     DC CL128' '           work area\nASM_JOBNAME  DC CL8' '             jobname\nASM_PROGRAMNAME DC CL8' '          actual programname\nASM_WORKECBS DC A(0)               start of work ecb pool\nASM_WORKECBP DC A(0)               work ecb pointer\nASM_WORKECBE DC A(0)               work ecb end address\n*ms_iarvservl iarvserv mf=(l,asm_iarv)  iarvserv list form\nASM_IARVSERVL IARVSERV MF=(L,ASM_IARV)  iarvserv list form\n*ms_aleservl  aleserv  mf=l             aleserv  list form\nASM_ALESERVL  ALESERV  MF=L             aleserv  list form\n*ms_enql     enq (0,0,e,0,step),mf=l   list enq\nASM_ENQL     ENQ (0,0,E,0,STEP),MF=L   list enq\nASM_OPTION   DC 4A(0)              option fields\nASM_SLEEP    DC D'0'               double word for timer\nASM_IARVRL   DC (VRL_LEN)X'00'     iarvrl area\nASM_IARVRLA  DC A(0)               iarvrl area address\n*ms_extract_l extract mf=l         extract list form\nASM_EXTRACT_L EXTRACT MF=L         extract list form\n*ms_post_l    post ascb=0,ecbkey=yes,mf=l list form\nASM_POST_L    POST ASCB=0,ECBKEY=YES,MF=L list form\nASM_COMPTR   DC A(0)               comm area pointer\nASM_COMTOKEN DC A(0)               comm token\nASM_COMECBPT DC A(0)               stop/modify ecb pointer\nASM_WTOL WTO  '01234567890123456789012345678901234567890123456789012345*\n               678901234567890123456789012345678901234567890123456789',*\n               ROUTCDE=(21),DESC=(6),MF=L\nASM_WTOL_TEXT_LENGTH EQU 110       text length\nASM_BPX1    DC  32A(0)             BPX1 parm list\nASM_BPX1_RETVAL  DC F'0'           return value\nASM_BPX1_RETCODE DC F'0'           return code\nASM_BPX1_RSNCODE DC F'0'           reason code\nASM_BPX1_LIST_LENGTH_R DC A(0)     list length read\nASM_BPX1_LIST_LENGTH_W DC A(0)     list length write\nASM_BPX1_LIST_LENGTH_E DC A(0)     list length exception\nASM_BPX1_NUMFDS      DC A(0)       number of FD's\nASM_BPX1_TIMEOUT     DC A(0)       timeout pointer\nASM_BPX1_OPTION      DC A(0)       option value\nASM_STCK    DC D'0'                stck area\n*           ieatdump mf=(l,asm_ieatdump)\n            IEATDUMP MF=(L,ASM_IEATDUMP)\nASM_TDUMP_NAME DC    AL1(0)        name length\n               DC    CL100' '      name\nASM_TDUMP_DESC DC    AL1(0)        desc length\n               DC    CL100' '      desc\n* 18/11/05 LOGGER support\nASM_STREAMNAME       DC CL26' '    stream name\nASM_STREAMTOKEN      DC XL16'00'   stream token\nASM_LOGGER_LENGTH    DC A(0)\nASM_LOGGER_BUFFER    DC A(0)      logger buffer pointer\nASM_LOGGER_BUFFLEN   DC A(0)      buffer length\nASM_LOGGER_BUFFER_OFFSET DC A(0)  actual buffer offset\nASM_LOGGER_BROWSE_TOKEN  DC  A(0) browse token\nASM_LOGGER_DIRECTION     DC  A(0) browse direction 2-3\n*       ixgconn  mf=(l,asm_ixgconn)\n        IXGCONN  MF=(L,ASM_IXGCONN)\n*       ixgwrite mf=(l,asm_ixgwrite)\n        IXGWRITE MF=(L,ASM_IXGWRITE)\n*       ixgbrwse mf=(l,asm_ixgbrwse)\n        IXGBRWSE MF=(L,ASM_IXGBRWSE)\n* 16/07/10 LOGGER browse TIME search\nASM_LOGGER_CONVVAL DC 16X'00'\nASM_LOGGER_STCK    DC 16X'00'\n*sm_logger_convtod convtod mf=l\nASM_LOGGER_CONVTOD CONVTOD MF=L\n* 16/07/10 LOGGER browse TIME search\n* 19/11/08 SRB callback\n*       IEAMSCHD MF=(L,ASM_IEAMSCHD)\n        IEAMSCHD MF=(L,ASM_IEAMSCHD)\nASM_IEAMSCHD_COMP DC F'0'        IEAMSCHD comp\nASM_IEAMSCHD_CODE DC F'0'        IEAMSCHD code\nASM_IEAMSCHD_RSN  DC F'0'        IEAMSCHD reason\n* 19/11/08 SRB callback\nASM_ANSAREA DC          XL(ANSAA_LEN)'00'\n* 18/11/05 LOGGER support\n* 21/11/05 VTOC access\nASM_VTOC   DC   0D'0'              vtoc access\nASM_VTOC_DCB    DC A(0)            DCB address below the line\nASM_VTOC_DDNAME DC CL8' '          DDNAME\nASM_VTOC_FILTER DC CL44' '         name filter\n*SM_VTOC_OPENLIST OPEN (0,INPUT),MF=L list form for open\nASM_VTOC_OPENLIST OPEN (0,INPUT),MF=L list form for open\nASM_VTOC_FCL     DC       XL(FCLHDLEN+FCLDSNEL)'00'\nASM_VTOC_BFL     DC       XL(BFLHLN+BFLELN)'00'\n*SM_VTOC_CVAFFILT CVAFFILT MF=L,BRANCH=NO,FLTAREA=KEEP\nASM_VTOC_CVAFFILT CVAFFILT MF=L,BRANCH=NO,FLTAREA=KEEP\nASM_VTOC_BUFFER  DC       XL(F1DSCB_SIZE)'00'\n* 04/03/10 OBTAIN DSCB\nASM_CAMLST DC    4A(0)\n* 04/03/10 OBTAIN DSCB\n* 21/11/05 VTOC access\n* 06/03/12 TESTAUTH DIAGNOSE extension\nASM_TESTAUTH DC A(0)\nASM_DIAGNOSE_FLAG DC A(0)\nASM_DIAGNOSE_ADDR DC A(0)\nASM_DIAGNOSE_LENGTH EQU 4095\nASM_DIAGNOSE_FIX    EQU 1\nASM_DIAGNOSE_DONTSWAP EQU 2\nASM_DIAGNOSE_KEEP   EQU   4\nASM_DIAGNOSE_ALL    EQU   7\nASM_VSMLIST_ASCBADDR DC A(0)       address of the ascb\nASM_VSMLIST_MYASCBID DC H'0'       my own ASCB id\nASM_VSMLIST_MYASCB DC F'0'         address of my ASCB\nASM_VSMLIST_MYTCB DC F'0'          my own TCB addr\nASM_VSMLIST_STORAGE DC A(0)        SRB work area address\n         SPACE 1\n*\n* eq symbols for the branch table\n*\n         $$    SWITCH=ASM_FUNCTION_CODE,SWTYPE=BINARY,DSECT=YES,       *\n               CASE=(CLEANUP,                                          *\n               GETTOKEN,                                               *\n               CREATETOKEN,                                            *\n               DELETETOKEN,                                            *\n               ALLOCATEPAGES,                                          *\n               FREEPAGES,                                              *\n               ENQ,                                                    *\n               DEQ,                                                    *\n               SLEEP,                                                  *\n               GETECB,                                                 *\n               WAIT,                                                   *\n               POST,                                                   *\n               RESET,                                                  *\n               SELECT,                                                 *\n               CONNECTSHMEM,                                           *\n               DISCONNECTSHMEM,                                        *\n               OPER,                                                   *\n               WTO,                                                    *\n               MALLOC,                                                 *\n               FREE,                                                   *\n               SVC,                                                    *\n               ATTACHMVS,                                              *\n               CLOCK,                                                  *\n               TIMEUSED,                                               *\n               TDUMP,                                                  *\n               LOGGER,                                                 *\n               VTOC,                                                   *\n               SRB,                                                    *\n               WLM,                                                    *\n               OBTAIN,                                                 *\n               TESTAUTH,                                               *\n               DIAGNOSE,                                               *\n               VSMLIST)\nASM_MUTEX_VECTOR  DC (MAX_ASM_MUTEX/32)A(0)\nASM_LENGTH   EQU *-ASMDSECT        dsect length\n*        cregs\n         CREGS\n         USING PSA,R0              base on psa\n         SPACE 5\n* SRB work area in sp 245 address passed in parm\n         SPACE 1\nSRBWORK  DSECT\nSRBWORK_SAVESYS DS 18F              secondary save in the SRB\nSRBWORK_ECB DC A(0)     SRB complete srbwork_ecb\nSRBWORK_STOKEN DS D                 stoken value\nSRBWORK_ALET   DS A                 alet value\n*rbworK_LALESERV ALESERV MF=L       list form\nSRBWORK_LALESERV ALESERV MF=L       list form\nSRBWORK_RETCODE DS F                return code from aleserv\nSRBWORK_MYASCB DS F                 my own ASCB addr\nSRBWORK_REPLY_ADDRESS DC A(0)\nSRBWORK_REPLY_LENGTH  DC A(0)\n                DC     0D'0'\nSRBWORK_VSMLIST_REPLY  DC 8192X'00'\nSRBWORK_VSMLIST_REPLY_LENGTH EQU *-SRBWORK_VSMLIST_REPLY\nSRBWORKL EQU   *-SRBWORK           length of the work area\n         SPACE 1\nDDDUMM       DSECT\n             SPACE 1\nASM_BUFFER   DSECT                 SOCKET dynamic dsect\nASM_BUFFER_SOCKET    DC A(0)       socket number\nASM_BUFFER_OFFSET    DC A(0)       offset in the buffer\nASM_BUFFER_REMAINDER DC A(0)       remainder length\nASM_BUFFER_          DC A(0)       buffer received length\nASM_BUFFER_BUFFER    DC (MAX_ASM_BUFFER)X'00'\nASM_BUFFER_LENGTH    EQU *-ASM_BUFFER\n             SPACE 1\nPAGE_SIZE    EQU 4096              page size\n*        BPXYSEL  ,\n         BPXYSEL  ,\n***      USING CRAB,R12            base on crab\n         USING ASMDSECT,R7         base on asm\n* 19/11/08 SRB callback\nASMIF    CSECT\n         LR    R0,R1               save r1\n         L     R1,0(,R1)           back asm base\n         LA    R1,0(,R1)           off high order byte\n         LTR   R1,R1               test it\n         JZ    ASMIF_PROLOG        if not created yet\n         CLI   ASM_SRB_MODE-ASM_SAVE(R1),1 SRB mode\n         JNE   ASMIF_PROLOG        if not created yet\n         ST    R14,12(,R13)        return address save\n         STM   R2,R12,28(R13)      registers\n         L     R14,ASM_SRB_RETURN-ASM_SAVE(,R1)\n         ST    R13,4(,R1)          backchain LE DSA\n         BR    R14\nASMIF_PROLOG LR R1,R0\n         STM   R14,12,12(R13)      save all in higher save\n         LARL  R11,DATAASMIF       base on data\n         USING (DATAASMIF,DATAASMIFEND),R11 assign base\n         L     R7,0(,R1)           back asm base\n         LA    R7,0(,R7)           off high order byte\n         LTR   R7,R7               test it\n         BZ    ASMIF_INIT          if not created yet\n* 10/01/12 cleanup register\n         SR    R8,R8\n         IC    R8,ASM_FUNCTION_CODE\n         BRASL R14,ASMIF_PROCESS   call process\n         LTR   R8,R8\n         BNZ   ASMIF_RETURN_NOCLEANUP\n         L     R14,12(,R13)\n         LM    R2,R12,28(R13)     back regs\n         BALR  R1,R14\nASMIF_RETURN_NOCLEANUP DS 0H\n* 10/01/12 cleanup register\n         LR    R13,R7              save area adress\n         B     ASMIF_EXIT          branch out\n         LTORG\nASMIF_INIT DS 0H\n*        storage obtain,length=asm_length,checkzero=yes\n         STORAGE OBTAIN,LENGTH=ASM_LENGTH,CHECKZERO=YES\n         LR    R7,R1               set addr\n         LR    R0,R1               same in 0\n         CHI   R15,X'14'           already cleared\n         JE    ASMIF_CLEARED       jump if cleared\n         L     R1,=A(ASM_LENGTH)   length here\n         MVCL  R0,R14              clear storage\nASMIF_CLEARED DS 0H\n         ST    R7,8(,R13)          chain new save\n         ST    R12,ASM_CRAB        save crab\n         ST    R13,4(,R7)          save higher save area\n         LA    R13,ASM_SAVE        get temp save\n         DROP  R7                  drop asm base\n         USING ASM_SAVE,R13        base on asm area\n         MVC   ASM_TIMX(MDL_TIMXL),MDL_TIMX copy timer exit\n         MVC   ASM_ENQL(MDL_ENQLL),MDL_ENQL copy enq list\n         LOAD  EP=IEANTCR          load token create\n         ST    R0,ASM_IEANTCR      save address\n         LOAD  EP=IEANTRT          load token retrieve\n         ST    R0,ASM_IEANTRT      save address\n         LOAD  EP=IEANTDL          load token delete\n         ST    R0,ASM_IEANTDL      save address\n         L     R2,PSATOLD          tcb address\n         USING TCB,R2              get tcb addr\n         L     R14,TCBTIO          get tiot add\n         USING TIOT1,R14           base on tiot1\n         MVC   ASM_JOBNAME,TIOCNJOB copy jobname\n         MVC   ASM_PROGRAMNAME,=CL8' ' init it\n* 06/03/12 TESTAUTH DIAGNOSE extension\n         MVC   ASM_TESTAUTH,=F'-1' init TESTAUTH\n         BRASL R14,TESTAUTH_INTERN  call TESTAUTH\n* 06/03/12 TESTAUTH DIAGNOSE extension\n         L     R14,TCBRBP          get highest rb pointer\n         DROP  R14                 drop reg\n         USING RBBASIC,R14         base on rb\nASMIF_RBLOOP TM RBSTAB1,B'11000000' check rb type\n         BZ    ASMIF_PRB           branch  if it is a prb\nASMIF_RBNEXT TM RBSTAB2,RBTCBNXT   test link tcb pointer\n         BO    ASMIF_PRBOK         branch if it is the last\n         L     R14,RBLINK          get rb link\n         LTR   R14,R14             test it\n         BNZ   ASMIF_RBLOOP        branch if more\n         B     ASMIF_PRBOK         branch out if none\nASMIF_PRB L    R15,RBCDE           get cde addr\n         LTR   R15,R15             test it\n         BZ    ASMIF_RBNEXT        branch if zero\n         USING CDENTRY,R15         base on cde\n         MVC   ASM_PROGRAMNAME,CDNAME move program name\n         DROP  R14,R15             drop temp regs\nASMIF_PRBOK DS 0H\n         LR    R15,R7              back asm address\nASMIF_EXIT DS   0H                 back from here\n         L     R13,4(,R13)         higher save address\n         L     R14,12(,R13)\n         LM    R2,R12,28(R13)     back regs\n         BALR  R1,R14\n         DROP  R13\n.EPLOG   ANOP\nASMIF_PROCESS BAKR     R14,0       all in stack\n         USING ASMDSECT,R7         base on asm\n         ST    R7,8(,R13)          chain new save\n         ST    R12,ASM_CRAB        save crab\n         ST    R13,4(,R7)          save higher save area\n         LA    R13,ASM_SAVE        get temp save\n         XC    ASM_RC(8),ASM_RC    clear rc\n         DROP  R7                drop asm base\n         USING ASM_SAVE,R13      base on asm area\n         $$    SWITCH=ASM_FUNCTION_CODE,SWTYPE=BINARY, SECT=ASMDSECT,  *\n               CASE=(CLEANUP,                                          *\n               GETTOKEN,                                               *\n               CREATETOKEN,                                            *\n               DELETETOKEN,                                            *\n               ALLOCATEPAGES,                                          *\n               FREEPAGES,                                              *\n               ENQ,                                                    *\n               DEQ,                                                    *\n               SLEEP,                                                  *\n               GETECB,                                                 *\n               WAIT,                                                   *\n               POST,                                                   *\n               RESET,                                                  *\n               SELECT,                                                 *\n               CONNECTSHMEM,                                           *\n               DISCONNECTSHMEM,                                        *\n               OPER,                                                   *\n               WTO,                                                    *\n               MALLOC,                                                 *\n               FREESTOR,                                               *\n               SVC,                                                    *\n               ATTACHMVS,                                              *\n               CLOCK,                                                  *\n               TIMEUSED,                                               *\n               TDUMP,                                                  *\n               LOGGER,                                                 *\n               VTOC,                                                   *\n               SRB_,                                                   *\n               WLM,                                                    *\n               OBTAIN,                                                 *\n               TESTAUTH,                                               *\n               DIAGNOSE,                                               *\n               VSMLIST)\n         MVC   ASM_RC,=A(128)      get code\n         DC    A(0)\n         PR    ,                   return back\n         USING ASM_SAVE,R13      base on asm area\n*---------------------------------------------------------------------*\n* gettoken - ask for the name/token pair                              *\n* +0     name pointer                                                 *\n* +4     retrieved token address                                      *\n* back : r15 = ieantrt return code                                    *\n*---------------------------------------------------------------------*\nGETTOKEN_CALLED BAKR R14,0\nGETTOKEN DS    0H\n         LM    R2,R3,ASM_PARMS     name/token pointers\n         LR    R1,R2               same in r1\n         BRASL R14,COPYSTR         copy it\n         LA    R2,ASM_WORK         addr in work\n* 17/11/11 GetToken in SYSTEM_LEVEL\n         MVC   ASM_OPTION,=A(IEANT_SYSTEM_LEVEL)\n*        MVC   ASM_OPTION,=A(IEANT_HOME_LEVEL)\n* 17/11/11 GetToken in SYSTEM_LEVEL\n         L     R15,ASM_IEANTRT     get retrieve addr\n*        call  (15),(asm_option,(r2),(r3),asm_rc),   call              *\n               MF=(E,ASM_CALLLIST),                                    *\n               ID=0001\n         CALL  (15),(ASM_OPTION,(R2),(R3),ASM_RC), call                *\n               MF=(E,ASM_CALLLIST),                                    *\n               ID=0001\n         STM   R15,R0,ASM_RC       save return/reason\n         PR    ,                   return back\n*---------------------------------------------------------------------*\n* createtoken - create a system level name/token pair                 *\n* +0     name pointer                                                 *\n* +4     retrieved token address                                      *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nCREATETOKEN_CALLED BAKR R14,0\nCREATETOKEN DS 0H\n* 21/04/08 name/token service in user/problem state\n***      MVC   ASM_OPTION(8),=A(IEANT_SYSTEM_LEVEL,IEANT_NOPERSIST)\n         MVC   ASM_OPTION(8),=A(IEANT_HOME_LEVEL,IEANT_NOPERSIST)\n         L     R15,ASM_IEANTCR     create address\n         LM    R2,R3,ASM_PARMS     nam/token pointers\n         LR    R1,R2               same in r1\n         BRASL R14,COPYSTR         copy it\n         LA    R2,ASM_WORK         addr in work\n*        call  (15),(asm_option,(r2),(r3),asm_option+4,asm_rc),        *\n               MF=(E,ASM_CALLLIST),                                    *\n               ID=0002\n         CALL  (15),(ASM_OPTION,(R2),(R3),ASM_OPTION+4,ASM_RC),        *\n               MF=(E,ASM_CALLLIST),                                    *\n               ID=0002\n         STM   R15,R0,ASM_RC       save return/reason\n         PR    ,                   return back\n*---------------------------------------------------------------------*\n* deletetoken - delete a system level name/token pair                 *\n* +0     name pointer                                                 *\n* back : r15 = ieantdl return code                                    *\n*---------------------------------------------------------------------*\nDELETETOKEN DS 0H\n*        modeset mode=sup        supervisor state\n         MODESET MODE=SUP        supervisor state\n         MVC   ASM_OPTION,=A(IEANT_HOME_LEVEL)\n         L     R15,ASM_IEANTDL     delete address\n*        $$setkey key=zero,save=asm_key key key=zero and save it\n***      $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero and save it\n         L     R2,ASM_PARMS        name pointer\n         LR    R1,R2               same in r1\n         BRASL R14,COPYSTR         copy it\n         LA    R2,ASM_WORK         addr in work\n*        call  (15),(asm_option,(r2),asm_rc), call                     *\n               MF=(E,ASM_CALLLIST),                                    *\n               ID=0003\n         CALL  (15),(ASM_OPTION,(R2),ASM_RC), call                     *\n               MF=(E,ASM_CALLLIST),                                    *\n               ID=0003\n         STM   R15,R0,ASM_RC       save return/reason\n*        $$setkey back,save=asm_key key key=zero and save it\n***      $$SETKEY BACK,SAVE=ASM_KEY key key=zero and save it\n*        modeset mode=prob       supervisor state\n         MODESET MODE=PROB       supervisor state\n         PR    ,                   return back\n* 21/04/08 name/token service in user/problem state\n*---------------------------------------------------------------------*\n* allocatepages - allocate pages on page bndry for shmem serv         *\n* +0     size required                                                *\n* back : r15 = storage return code                                    *\n*---------------------------------------------------------------------*\nALLOCATEPAGES DS    0H\n         LM    R2,R3,ASM_PARMS     requested size and address\n         A     R2,=A(PAGE_SIZE-1)  add page size\n         N     R2,=X'0FFFF000'     and round\n*        storage obtain,                                               *\n               LENGTH=(R2),                                            *\n               ADDR=0(,R3),                                            *\n               BNDRY=PAGE,                                             *\n               LOC=(ANY,ANY)\n         STORAGE OBTAIN,                                               *\n               LENGTH=(R2),                                            *\n               ADDR=0(,R3),                                            *\n               BNDRY=PAGE,                                             *\n               LOC=(ANY,ANY)\n         ST    R15,ASM_RC          save return/reason\n         PR    ,                   return back\n*---------------------------------------------------------------------*\n* freepages - free pages on page bndry for shmem serv                 *\n* +0     size  to free                                                *\n* +4     address                                                      *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nFREEPAGES DS   0H\n         LM    R2,R3,ASM_PARMS     requested size and address\n         A     R2,=A(PAGE_SIZE-1)  add page size\n         N     R2,=X'0FFFF000'     and round\n*        storage release,                                              *\n               LENGTH=(R2),                                            *\n               ADDR=(R3)\n         STORAGE RELEASE,                                              *\n               LENGTH=(R2),                                            *\n               ADDR=(R3)\n         ST    R15,ASM_RC          save return/reason\n         PR    ,                   return back\n*---------------------------------------------------------------------*\n* enq -  enq exclusive for reource                                    *\n* +0     major name                                                   *\n* +4     minor name                                                   *\n* +8     minor name length                                            *\n* +c     max wait in milli sec                                        *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nENQ      DS    0H\n         LM    R2,R5,ASM_PARMS    requested size and address\n         AGO   .UNCOND\n*\n*  onyl uncond wait here\n*\n         LTR   R5,R5              test wait time\n*only    bz    enq_uncond         if infinite wait uncond\n         B     ENQ_UNCOND         if infinite wait uncond\n         SR    R0,R0              clear r0\n         LR    R1,R5              here the max time\n         D     R0,=A(10)          divide it\n         ST    R1,ASM_PARMS       save it\nENQ_LOOP DS 0H\n*        enq   ((r2),(r3),e,(r4),systems),ret=use,                     *\n               MF=(E,ASM_ENQL)\n         ENQ   ((R2),(R3),E,(R4),SYSTEMS),RET=USE,                     *\n               MF=(E,ASM_ENQL)\n         LTR   R15,R15            test return\n         BZ    ENQ_XX             branch if ok\n         SR    R14,R14            clear reg\n         IC    R14,3(15)          get code\n         LR    R15,R14            here also\n         CH    R14,=Y(4)          test return code\n         BH    ENQ_XX             branc if error\n         BL    ENQ_00             here also ok\n         LTR   R5,R5              test time left\n         BNP   ENQ_FF             if no more time\n         BRASL R14,SLEEP_INTERN   to sleep\n         S     R5,ASM_PARMS       decr it\n         B     ENQ_LOOP          try again\n.UNCOND  DS    0H\nENQ_UNCOND DS 0H\n*        enq   ((r2),(r3),e,(r4),systems),ret=none,                    *\n               MF=(E,ASM_ENQL)\n         ENQ   ((R2),(R3),E,(R4),SYSTEMS),RET=NONE,                    *\n               MF=(E,ASM_ENQL)\n         LTR   R15,R15           test rc\n         BZ    ENQ_00            branch if ok\n         ICM   R15,15,0(R15)     get code\n         N     R15,=X'000000FF'  get it proper\n         B     ENQ_XX            branch out\nENQ_00   SR    R15,R15           clear reg\n         B     ENQ_XX            branch out\nENQ_08   LA    R15,8             get code\n         B     ENQ_XX            branch out\nENQ_FF   L     R15,=F'-1'        get code\nENQ_XX   ST    R15,ASM_RC       back code\n         PR    ,                   branch back\n*---------------------------------------------------------------------*\n* deq -  deq resource                                                 *\n* +0     major name                                                   *\n* +4     minor name                                                   *\n* +8     minor name length                                            *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nDEQ      LM    R2,R4,ASM_PARMS     get parms\n*        deq   ((r2),(r3),(r4),systems),ret=none,                      *\n               MF=(E,ASM_ENQL)     deq resoure\n         DEQ   ((R2),(R3),(R4),SYSTEMS),RET=NONE,                      *\n               MF=(E,ASM_ENQL)     deq resoure\n         LTR   R15,R15           test rc\n         BZ    DEQ_XX            branch if ok\n         ICM   R15,15,0(R15)     get code\n         N     R15,=X'000000FF'  get it proper\nDEQ_XX   ST    R15,ASM_RC        save code\n         PR    ,                   return back\n*---------------------------------------------------------------------*\n* SVC -  SVC call                                                     *\n* +0     SVC number                                                   *\n* +4     parm list                                                    *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nSVC      LM    R0,R1,ASM_PARMS     get parms\n         LR    R2,R0              get SVC\n         EX    R2,SVC_EXE         exec SVC\nSVC_XX   ST    R15,ASM_RC        save code\n         PR    ,                 return back\n*---------------------------------------------------------------------*\n* attachmvs - ATTACH an MVS subtask as processs                       *\n* +0     program name length                                          *\n* +4     program name                                                 *\n* +8     parm length                                                  *\n* +12    parm                                                         *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nATTACHMVS LM   R2,R5,ASM_PARMS     get parms\n*        call  bpx1atm,                                                *\n               ((R2),                                                  *\n               (R3),                                                   *\n               (R4),                                                   *\n               (R5),                                                   *\n               =A(0),                                                  *\n               =A(0),                                                  *\n               ASM_BPX1_RETVAL,                                        *\n               ASM_BPX1_RETCODE,                                       *\n               ASM_BPX1_RSNCODE),                                      *\n               VL,MF=(E,ASM_BPX1)\n         CALL  BPX1ATM,                                                *\n               ((R2),                                                  *\n               (R3),                                                   *\n               (R4),                                                   *\n               (R5),                                                   *\n               =A(0),                                                  *\n               =A(0),                                                  *\n               ASM_BPX1_RETVAL,                                        *\n               ASM_BPX1_RETCODE,                                       *\n               ASM_BPX1_RSNCODE),                                      *\n               VL,MF=(E,ASM_BPX1)\n         L     R15,ASM_BPX1_RETCODE get reason\n         ST    R15,ASM_REASON    save it\n         L     R15,ASM_BPX1_RETVAL  get code\n         ST    R15,ASM_RC        save it\n         PR    ,                 return back\n         PR    ,                 return back\n*---------------------------------------------------------------------*\n* clock - ask for STCK                                                *\n* +0     stck reply addres                                            *\n*---------------------------------------------------------------------*\nCLOCK    L     R2,ASM_PARMS       get parms\n         STCK  0(R2)              get clock\n         SR    R15,R15\n         PR    ,\n*---------------------------------------------------------------------*\n* timeused return the used CPU time in long long MIC                  *\n* +0     timeused reply address                                       *\n*---------------------------------------------------------------------*\nTIMEUSED L     R2,ASM_PARMS       get parms\n*        timeused storadr=(r2),cpu=TOD,LINKAGE=SYSTEM\n         TIMEUSED STORADR=(R2),CPU=TOD,LINKAGE=SYSTEM\n         LM   R0,R1,0(R2)          get tod\n         SRDL R0,12                proper pos\n         STM  R0,R1,0(R2)          back in MIC\n         SR    R15,R15\n         PR    ,\n*---------------------------------------------------------------------*\n* issue an IEATDUMP                                                   *\n* +0     name pattern                                                 *\n* +4     dump title\n* +8     DDNAME flag\n*---------------------------------------------------------------------*\nTDUMP    MVC   ASM_TDUMP_NAME(L'TDUMP_DEF_NAMEL+1),TDUMP_DEF_NAME\n         MVC   ASM_TDUMP_DESC(L'TDUMP_DEF_DESCL+1),TDUMP_DEF_DESC\n         L     R1,ASM_PARMS       get parms\n         LTR   R1,R1              test\n         JZ    TDUMP_NAME_OK      if o.k.\n         LA    R3,ASM_TDUMP_NAME  target\n         BRASL R14,STRLEN         length\n         LTR   R15,R15            test length\n         JNP   TDUMP_NAME_OK      if default\n         CHI   R15,100            o.k ?\n         JL    TDUMP_NAME         jump if o.k\n         LHI   R15,100            set def\nTDUMP_NAME STC R15,ASM_TDUMP_NAME store\n         BCTR  R15,0              decr\n         EX    R15,TDUMP_COPY     copy\nTDUMP_NAME_OK DS 0H\n         L     R1,ASM_PARMS+4     get parms\n         LTR   R1,R1              test length\n         JZ    TDUMP_DESC_OK      if ok\n         LA    R3,ASM_TDUMP_DESC  target\n         BRASL R14,STRLEN         length\n         LTR   R15,R15            test length\n         JNP   TDUMP_DESC_OK      if default\n         CHI   R15,100            o.k ?\n         JL    TDUMP_DESC         jump if o.k\n         LHI   R15,100            set def\nTDUMP_DESC STC R15,ASM_TDUMP_DESC store\n         BCTR  R15,0              decr\n         EX    R15,TDUMP_COPY     copy\n* 19/12/11 IEATDUMP with DDNAME\nTDUMP_DESC_OK DS 0H\n  If  (CLC,ASM_PARMS+8,NE,ZERO)\n*        IEATDUMP DDNAME=ASM_TDUMP_NAME+1,                             *\n               HDR=ASM_TDUMP_DESC,                                     *\n               MF=(E,ASM_IEATDUMP,COMPLETE)\n         IEATDUMP DDNAME=ASM_TDUMP_NAME+1,                             *\n               HDR=ASM_TDUMP_DESC,                                     *\n               MF=(E,ASM_IEATDUMP,COMPLETE)\n  Else\n* 05/10/07 STORE IEATDUMP REASON CODE\n*        IEATDUMP dsn=ASM_TDUMP_NAME,                                  *\n               HDR=ASM_TDUMP_DESC,                                     *\n               MF=(E,ASM_IEATDUMP,COMPLETE)\n         IEATDUMP DSN=ASM_TDUMP_NAME,                                  *\n               HDR=ASM_TDUMP_DESC,                                     *\n               MF=(E,ASM_IEATDUMP,COMPLETE)\n  Endif\n* 19/12/11 IEATDUMP with DDNAME\n         ST    R15,ASM_RC\n         ST    R0,ASM_REASON\n         LTR   R15,R15\n         BZ    TDUMP_NODUMP\nTDUMP_NODUMP DS 0H\n* 05/10/07 store IEATDUMP reason code\n         PR    ,                 return back\n* 18/11/05 LOGGER support\n* 13/01/06 browse logger\n*---------------------------------------------------------------------*\n* LOGGER support                                                      *\n* +0 0 connect to logger stream                                       *\n*   -1 discoonect                                                     *\n*    1 log a request                                                  *\n*    2 read logger from oldtoyoung                                    *\n*    3 read log from youngtoold (parm+8 contain addr , length)        *\n*    a stream to log                                                  *\n* +4 stream or logger name address                                    *\n* +8 length of the stream                                             *\n* +c time stemp field pointer                                         *\n*    +0 binary time value in .01 sec                                  *\n*    +4 DATE in YYYYDDD    char format                                *\n*---------------------------------------------------------------------*\nLOGGER   LM    R2,R4,ASM_PARMS     get parms\n         L     R5,ASM_PARMS+16     get time\n         SR    R15,R15             clear return\n         LTR   R2,R2               test code\n         JM    LOGGER_DISCO        disconnect\n         JP    LOGGER_LOG          log\n         LTR   R4,R4               test length\n         JNP   LOGGER_08           return if not o.k.\n         MVC   ASM_STREAMNAME,BLANKS init stream name\n         CHI   R4,L'ASM_STREAMNAME TEST LENGTH\n         JL    *+8                  jump if ok.k\n         LHI   R4,L'ASM_STREAMNAME GET LENGTH\n         AHI   R4,-1               decr it\n         EX    R4,LOGGER_SETSTREAM set stream\n         CLC   ASM_STREAMNAME,BLANKS active\n         JE    LOGGER_08           if no stream name\n         XC    ASM_STREAMTOKEN,ASM_STREAMTOKEN\n*        ixgconn request=connect,                                      *\n               STREAMNAME=ASM_STREAMNAME,                              *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               AUTH=WRITE,                                             *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               RETCODE=ASM_RC,                                         *\n               MF=(E,ASM_IXGCONN)\n         IXGCONN REQUEST=CONNECT,                                      *\n               STREAMNAME=ASM_STREAMNAME,                              *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               AUTH=WRITE,                                             *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               RETCODE=ASM_RC,                                         *\n               MF=(E,ASM_IXGCONN)\n         LTR   R15,R15             test code\n         JNZ   LOGGER_ERROR\n*        stimer wait,bintvl=logger_onesec wait a sec\n***      STIMER WAIT,BINTVL=LOGGER_ONESEC wait a sec\n         J     LOGGER_00           jump out\nLOGGER_DISCO DS 0H\n         NC    ASM_STREAMTOKEN,ASM_STREAMTOKEN\n         JZ    LOGGER_XX           jump if no\n*        ixgconn request=disconnect,                                   *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               RETCODE=ASM_RC,                                         *\n               MF=(E,ASM_IXGCONN)\n         IXGCONN REQUEST=DISCONNECT,                                   *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               RETCODE=ASM_RC,                                         *\n               MF=(E,ASM_IXGCONN)\n         LTR   R15,R15             test code\n         JNZ   LOGGER_ERROR        jump out\n         J     LOGGER_00           jump back\nLOGGER_LOG DS 0H\n         NC    ASM_STREAMTOKEN,ASM_STREAMTOKEN\n         JZ    LOGGER_XX           return if not\n         CHI   R2,1                check if log\n         JH    LOGGER_BROWSE       jump if browse\n         LTR   R4,R4               test length\n         JNP   LOGGER_08           jump if not positive\n         LTR   R3,R3               test data\n         JZ    LOGGER_08           jump if not data\n         ST    R4,ASM_LOGGER_LENGTH save length\n*        ixgwrite buffer=(r3),                                         *\n               BLOCKLEN=ASM_LOGGER_LENGTH,                             *\n               MODE=ASYNCNORESPONSE,                                   *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               MF=(E,ASM_IXGWRITE)\n         IXGWRITE BUFFER=(R3),                                         *\n               BLOCKLEN=ASM_LOGGER_LENGTH,                             *\n               MODE=ASYNCNORESPONSE,                                   *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               MF=(E,ASM_IXGWRITE)\n         J     LOGGER_XX           jump if ok\n* 13/01/06 Logger Browse\nLOGGER_BROWSE DS  0H\n         LTR  R3,R3                test addr pointer\n         JZ    LOGGER_08           jump if zero\n         LTR   R4,R4               test length addr\n         JZ    LOGGER_08           jump if zero\n         XC    0(4,R3),0(R3)       no addr\n         XC    0(4,R4),0(R4)       no length\n         CLC   ASM_LOGGER_BUFFER,ZERO check buff\n         JNZ   LOGGER_BROWSE_STARTED jump if alaredy got\n         MVC   ASM_LOGGER_BUFFLEN,LOGGER_MAX_BUFFER\n         L     R4,ASM_LOGGER_BUFFLEN get length\n*        storage obtain,length=(r4)\n         STORAGE OBTAIN,LENGTH=(R4)\n         LTR   R15,R15             test return\n         JNZ   LOGGER_08           if no storage\n         ST    R1,ASM_LOGGER_BUFFER save buffer address\n         MVC   ASM_LOGGER_BUFFER_OFFSET,=A(0)\n         CHI   R2,2                oldest requested\n         JNE   LOGGER_BROWSE_START_YOUNGEST start youngest\n         CLC   ZERO,ASM_PARMS+12   active\n         JNE   LOGGER_BROWSE_START_OLDEST_ALL jump if not\n*        IXGBRWSE REQUEST=START,                                       *\n               OLDEST,                                                 *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ACTIVE,                                            *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=START,                                       *\n               OLDEST,                                                 *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ACTIVE,                                            *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         J     LOGGER_BROWSE_START_CHECK check start\nLOGGER_BROWSE_START_OLDEST_ALL DS 0H\n*        IXGBRWSE REQUEST=START,                                       *\n               OLDEST,                                                 *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ALL,                                               *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=START,                                       *\n               OLDEST,                                                 *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ALL,                                               *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         J     LOGGER_BROWSE_START_CHECK check start\nLOGGER_BROWSE_START_YOUNGEST DS 0H\n         CHI   R2,3                oldest requested\n         JNE   LOGGER_BROWSE_START_SEARCH   start search\n         CLC   ZERO,ASM_PARMS+12   active\n         JNE   LOGGER_BROWSE_START_YOUNGEST_ALL jump if not\n*        IXGBRWSE REQUEST=START,                                       *\n               YOUNGEST,                                               *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ACTIVE,                                            *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=START,                                       *\n               YOUNGEST,                                               *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ACTIVE,                                            *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         J     LOGGER_BROWSE_START_CHECK check start\nLOGGER_BROWSE_START_YOUNGEST_ALL  DS 0H\n*        IXGBRWSE REQUEST=START,                                       *\n               YOUNGEST,                                               *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ALL,                                               *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=START,                                       *\n               YOUNGEST,                                               *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ALL,                                               *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         J     LOGGER_BROWSE_START_CHECK check start\n* 16/07/10 LOGGER browse TIME search\nLOGGER_BROWSE_START_SEARCH DS 0H\n         LHI   R2,2                oldest requested\n         LTR  R5,R5\n         JZ   LOGGER_BROWSE\n         XC    ASM_LOGGER_CONVVAL,ASM_LOGGER_CONVVAL\n         MVC   ASM_LOGGER_CONVVAL(4),0(R5)\n         PACK  ASM_LOGGER_CONVVAL+8(5),4(9,R5)\n         XC    ASM_LOGGER_CONVVAL+12,ASM_LOGGER_CONVVAL+12\n*        convtod TIMETYPE=bin,datetype=yyyyddd,todval=asm_logger_stck, *\n               CONVVAL=ASM_LOGGER_CONVVAL,MF=(E,ASM_LOGGER_CONVTOD)\n         CONVTOD TIMETYPE=BIN,DATETYPE=YYYYDDD,TODVAL=ASM_LOGGER_STCK, *\n               CONVVAL=ASM_LOGGER_CONVVAL,MF=(E,ASM_LOGGER_CONVTOD)\n**       CLC   ZERO,ASM_PARMS+12   active\n**       JNE   LOGGER_BROWSE_START_SEARCH_ALL  jump if not\n*        IXGBRWSE REQUEST=START,                                       *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ACTIVE,                                            *\n               SEARCH=ASM_LOGGER_STCK,                                 *\n               GMT=NO,                                                 *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=START,                                       *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ACTIVE,                                            *\n               SEARCH=ASM_LOGGER_STCK,                                 *\n               GMT=NO,                                                 *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         J     LOGGER_BROWSE_START_CHECK check start\nLOGGER_BROWSE_START_SEARCH_ALL  DS 0H\n*        IXGBRWSE REQUEST=START,                                       *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ALL,                                               *\n               SEARCH=ASM_LOGGER_STCK,                                 *\n               GMT=NO,                                                 *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=START,                                       *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               MODE=SYNC,                                              *\n               VIEW=ALL,                                               *\n               SEARCH=ASM_LOGGER_STCK,                                 *\n               GMT=NO,                                                 *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n* 16/07/10 LOGGER browse TIME search\nLOGGER_BROWSE_START_CHECK DS 0H\n         CHI   R15,4               maybe o\n         JH    LOGGER_ERROR        error\n         SR    R15,R15             clear reg\n         ST    R2,ASM_LOGGER_DIRECTION savedirection\nLOGGER_BROWSE_STARTED DS 0H\n         CLC   ASM_LOGGER_BUFFER_OFFSET,ZERO  check offset\n         JNE   LOGGER_READCURSOR_INBLOCK jump if in the block\n         MVC   ASM_LOGGER_BUFFER_OFFSET,=A(8) init offset\n         ICM   R3,15,ASM_LOGGER_BUFFER   get buffer addr\n         CLI   ASM_LOGGER_DIRECTION+3,2  oldtoyoung requested\n         JNE   LOGGER_READCURSOR_YOUNGEST start youngest\n*        IXGBRWSE REQUEST=READCURSOR,                                  *\n               DIRECTION=OLDTOYOUNG,                                   *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               BUFFER=(R3),                                            *\n               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *\n               MULTIBLOCK=YES,                                         *\n               RETBLOCKINFO=YES,                                       *\n               MODE=SYNC,                                              *\n               RETCODE=ASM_RC,                                         *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               RSNCODE=ASM_REASON,                                     *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=READCURSOR,                                  *\n               DIRECTION=OLDTOYOUNG,                                   *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               BUFFER=(R3),                                            *\n               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *\n               MULTIBLOCK=YES,                                         *\n               RETBLOCKINFO=YES,                                       *\n               MODE=SYNC,                                              *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         J     LOGGER_READCURSOR_CHECK check start\nLOGGER_READCURSOR_YOUNGEST DS 0H\n*        IXGBRWSE REQUEST=READCURSOR,                                  *\n               DIRECTION=YOUNGTOOLD,                                   *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               BUFFER=(R3),                                            *\n               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *\n               MULTIBLOCK=YES,                                         *\n               RETBLOCKINFO=YES,                                       *\n               MODE=SYNC,                                              *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=READCURSOR,                                  *\n               DIRECTION=YOUNGTOOLD,                                   *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               BUFFER=(R3),                                            *\n               BUFFLEN=ASM_LOGGER_BUFFLEN,                             *\n               MULTIBLOCK=YES,                                         *\n               RETBLOCKINFO=YES,                                       *\n               MODE=SYNC,                                              *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\nLOGGER_READCURSOR_CHECK DS 0H\n         CHI   R15,8               maybe o\n         JL    LOGGER_READCURSOR_OK if acceptable\n         JH    LOGGER_ERROR        error\n         CHI   R0,X'0848'          check r0\n         JNE   LOGGER_ERROR        if not, error\nLOGGER_READCURSOR_NOMORE DS 0H\n         ICM   R3,15,ASM_LOGGER_BUFFER get buffer address\n         JZ    LOGGER_READCURSOR_END_NOFREE\n         L     R4,ASM_LOGGER_BUFFLEN get length\n*        storage release,addr=(r3),length=(r4)\n         STORAGE RELEASE,ADDR=(R3),LENGTH=(R4)\n         XC    ASM_LOGGER_BUFFER,ASM_LOGGER_BUFFER clear\nLOGGER_READCURSOR_END_NOFREE DS 0H\n*        IXGBRWSE REQUEST=END,                                         *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n         IXGBRWSE REQUEST=END,                                         *\n               STREAMTOKEN=ASM_STREAMTOKEN,                            *\n               BROWSETOKEN=ASM_LOGGER_BROWSE_TOKEN,                    *\n               RETCODE=ASM_RC,                                         *\n               RSNCODE=ASM_REASON,                                     *\n               ANSAREA=ASM_ANSAREA,                                    *\n               ANSLEN==A(L'ASM_ANSAREA),                               *\n               MF=(E,ASM_IXGBRWSE)\n        CHI    R15,4               test code\n        JH     LOGGER_ERROR        jump if in error\n        LA     R15,4               set code\n        ST     R15,ASM_RC          set code\n        J      LOGGER_XX           jump back\nLOGGER_READCURSOR_OK      DS 0H\nLOGGER_READCURSOR_INBLOCK DS 0H\n        L      R4,ASM_LOGGER_BUFFER_OFFSET get offset\n        ICM    R3,15,ASM_LOGGER_BUFFER block address\n        JZ     LOGGER_08           if no addr\n        USING  IXGBRMHD,R3         base on header\n        LA     R4,0(R3,R4)         actual block address\n        USING  IXGBRMLT,R4         base on log block\n        MVC    ASM_LOGGER_BUFFER_OFFSET,IXGBRMLT_NEXTOFFSET next off\n        TM     IXGBRMLT_FLAGS,IXGBRMLT_DATARETURNED data returned\n        JO     LOGGER_READCURSOR_DATA   no more data\n***LOOP*J      LOGGER_READCURSOR_INBLOCK try it\n        J      LOGGER_READCURSOR_NOMORE  it\nLOGGER_READCURSOR_DATA DS 0H\n        TM     IXGBRMLT_FLAGS,IXGBRMLT_RETBLOCKINFO info returned\n        JZ     LOGGER_READCURSOR_NOINFO\n        LA     R5,IXGBRMLT_RETINFOEND  start of data\n        J      LOGGER_READCURSOR_DO jump to nextoffset\nLOGGER_READCURSOR_NOINFO DS 0H\n        LA     R5,IXGBRMLT_COMMONEND adress of the block\nLOGGER_READCURSOR_DO DS 0H\n       CLC     ASM_LOGGER_BUFFER_OFFSET,IXGBRMHD_LASTBRMLTOFFSET\n       JNE     LOGGER_READCURSOR_NOTLAST\n***    MVC     IXGBRMLT_NEXTOFFSET,ZERO\nLOGGER_READCURSOR_NOTLAST DS 0H\n        L      R6,IXGBRMLT_NEXTOFFSET length of block\n        AR     R6,R3               next addr\n        SR     R6,R5               length of block\n        LM     R1,R2,ASM_PARMS+4   get addr buff\n        ST     R5,0(R1)            save addr\n        ST     R6,0(R2)            save length\n        J     LOGGER_00           jump out\nLOGGER_ERROR DS 0H\n*       DC     A(0)\nLOGGER_08 LA   R15,8               get code\n         J     LOGGER_XX           jump out\nLOGGER_00 SR   R15,R15             set code\nLOGGER_XX DS 0H\n         ST    R15,ASM_RC       back code\n         ST    R0,ASM_REASON    back reason\n         PR     ,\n         DROP  R3,R4               drop regs\n* 21/11/05 VTOC access\n*---------------------------------------------------------------------*\n* VTOC access                                                         *\n* +0 request type                                                     *\n*    0 connect , open                                                 *\n*    1 next , gives back the next entry                               *\n* +4 address of the DDNAME allocated to the volume                    *\n* +8 address of the dataset mask to retrieve  , +0 length (1 byte)    *\n* +c address of are to return the DSCB                                *\n* return : 0 DSCB returned , and more exist                           *\n*          4 last DSCB returned, no more                              *\n*          8 no DSCB found                                            *\n*         12 error occured                                            *\n*---------------------------------------------------------------------*\n         USING IHADCB,R6           base on DCB\n         USING IEFJFCBN,R5         base on JFCB\n         USING FCL_MAP,ASM_VTOC_FCL  base on FCL\n         USING BFL_MAP,ASM_VTOC_BFL  base on bfl\n         USING CVAFFILT_MAP,ASM_VTOC_CVAFFILT base on CVAFFILT\nVTOC     LM    R2,R5,ASM_PARMS     get parms\n         XC    ASM_REASON,ASM_REASON  clear resaon\n         LTR   R2,R2               test request\n         JP    VTOC_NEXT           if next request\n         JM    VTOC_GOT_LAST       if the last entry\n         LA    R0,1                first parm\n         LTR   R3,R3               test DDNAME addr\n         JZ    VTOC_ERR_PARM       jump if no DDNAME\n         LA    R0,2                second parm\n         LTR   R4,R4               test name\n         JZ    VTOC_ERR_PARM       jump if invalid\n         LA    R0,3                third parm\n         LTR   R5,R5               test DSCB return address\n         JZ    VTOC_ERR_PARM       jump if invalid\n         MVC   ASM_VTOC_DDNAME,0(3) copy DDNAME\n         MVC   ASM_VTOC_FILTER,0(R4) copy filter\n*        storgae obtain,LENGTH=VTOC_MODEL_DCB_LENGTH+184,LOC=BELOW\n         STORAGE OBTAIN,LENGTH=VTOC_MODEL_DCB_LENGTH+184,LOC=BELOW\n         ST    R1,ASM_VTOC_DCB     save\n         LTR   R6,R1               test storage\n         JZ    VTOC_ERR_STORAGE    if no storage\n         LHI   R2,VTOC_MODEL_DCB_LENGTH-1 get length\n         EX    R2,VTOC_COPY_DCB    copy dcb\n         MVC   DCBDDNAM,ASM_VTOC_DDNAME copy DDNAME\n         LA    R5,VTOC_MODEL_DCB_LENGTH(,R6) after DCB\n         OI    ASM_VTOC_OPENLIST,X'80' indicate end of list\n         LA    R4,(VTOC_MODEL_DCB_LENGTH+176)(,R6) open list\n         LA    R1,4(,R4)           exit list addr\n         STCM  R1,7,DCBEXLSA       save exit list addr\n         ST    R5,0(R1)            save exit addr\n         MVI   0(R1),X'87'         indicate JFCB exit\n         MVI   0(R4),X'80'         open list\n*        rdjfcb ((r6)),mf=(e,(r4))\n         RDJFCB ((R6)),MF=(E,(R4))\n         LTR   R15,R15             test code\n         JNZ   VTOC_ERR_RDJFCB     jump if RDJFCB error\n         MVI   JFCBDSNM,X'04'      init first byte\n         MVC   JFCBDSNM+1(43),JFCBDSNM copy rest\n*        open  ((r6),input),mf=(e,(r4)),type=j\n         OPEN  ((R6),INPUT),MF=(E,(R4)),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN   test open flag\n         JZ    VTOC_ERR_OPEN       jump if open error\n         MVC   ASM_VTOC_CVAFFILT(VTOC_MODEL_CVAFFL),VTOC_MODEL_CVAFFILT\n         XC    ASM_VTOC_FCL(FCLHDLEN+FCLDSNEL),ASM_VTOC_FCL   init fcl\n         MVC   FCLID,=CL4'FCL'       set fcl id\n         MVC   FCLCOUNT,=H'1'        set number of fcl elements\n         LA    R2,FCLHDEND           r2 addr of fcl elemnent\n         USING FCLDSN,R2             establish addressability\n         MVC   FCLDSNLG,ASM_VTOC_FILTER set length\n         LA    R1,ASM_VTOC_FILTER+1  filter address\n         ST    R1,FCLDSNA            set addr(dsn pattern)\n         MVC   FCLDSNLG,ASM_VTOC_FILTER set length\n         DROP  R2\n         XC    ASM_VTOC_BFL(BFLHLN+BFLELN),ASM_VTOC_BFL clear\n         MVI   BFLHNOE,1             one buffe\n         OI    BFLHFL,BFLHDSCB       identify as dscb bufr elemnt\n         LA    R2,ASM_VTOC_BFL+BFLHLN first buffer\n         USING BFLE,R2               establish addressability\n         OI    BFLEFL,BFLECHR        request cchhr on return\n         MVI   BFLELTH,F1DSCB_SIZE   set bufr lngth to full dscb\n         LA    R1,ASM_VTOC_BUFFER    get buffer address\n         ST    R1,BFLEBUF            set addr(dscb buffer)\n         DROP  R2\n         SR    R1,R1               clear r1\n         ICM   R1,7,DCBDEBA        get deb addr\n         ST    R1,CVDEB            save in CVAF parm list\n*        cvaffilt access=read,                                         *\n               FCL=ASM_VTOC_FCL,                                       *\n               BUFLIST=ASM_VTOC_BFL,                                   *\n               MF=(E,ASM_VTOC_CVAFFILT)\n         CVAFFILT ACCESS=READ,                                         *\n               FCL=ASM_VTOC_FCL,                                       *\n               BUFLIST=ASM_VTOC_BFL,                                   *\n               MF=(E,ASM_VTOC_CVAFFILT)\nVTOC_CHECK  LTR R15,R15            test return\n         JZ    VTOC_GOT_LAST       jump if the last one\n         CHI   R15,4               check if rc4\n         JNE   VTOC_CVAFFILT_ERR   jump if filter error\n         CLI   CVSTAT,STAT001      nothing found\n         JE    VTOC_08             jump if it is\n         CLI   CVSTAT,STAT064      more\n         JNE   VTOC_CVAFFILT_ERR   jump if any other error\n         J     VTOC_COPY_DSCB      jump to copy DSCB\nVTOC_NEXT      DS                  0H\n*        cvaffilt access=resume,                                       *\n               MF=(E,ASM_VTOC_CVAFFILT)\n         CVAFFILT ACCESS=RESUME,                                       *\n               MF=(E,ASM_VTOC_CVAFFILT)\n         J     VTOC_CHECK          jump to check\nVTOC_GOT_LAST DS 0H\n         NC    ASM_VTOC_DCB,ASM_VTOC_DCB already closed\n         JZ    VTOC_00             jump if so\n*        cvaffilt accESS=RLSE,fcl=0,BUFLIST=0,FLTAREA=NOKEEP,          *\n               MF=(E,ASM_VTOC_CVAFFILT)\n         CVAFFILT ACCESS=RLSE,FCL=0,BUFLIST=0,FLTAREA=NOKEEP,          *\n               MF=(E,ASM_VTOC_CVAFFILT)\n*        close ((r6)),mf=(e,asm_vtoc_openlist),mode=31\n         CLOSE ((R6)),MF=(E,ASM_VTOC_OPENLIST),MODE=31\n*        storage release,addr=asm_vtoc_dcb,                            *\n               LENGTH=VTOC_MODEL_DCB_LENGTH+184\n         STORAGE RELEASE,ADDR=ASM_VTOC_DCB,                            *\n               LENGTH=VTOC_MODEL_DCB_LENGTH+184\n         XC    ASM_VTOC_DCB,ASM_VTOC_DCB release DCB arae\n         LA    R15,4               get return code\n         J     VTOC_COPY_DSCB+2    jump to copy\nVTOC_COPY_DSCB SR R15,R15          clear rc\n         ICM   R0,15,ASM_PARMS+12  target address\n         LHI   R1,F1DSCB_SIZE      get DSCB size\n         LA    R2,ASM_VTOC_BUFFER  from address\n         LR    R3,R1               same length\n         MVCL  R0,R2               copy DSCB\n         J     VTOC_XX             jump out\nVTOC_ERR_RDJFCB    MVI ASM_REASON+2,6 JFCB error\n         J     VTOC_12             jump out\nVTOC_ERR_OPEN    MVI ASM_REASON+2,5 open error\n         J     VTOC_12             jump out\nVTOC_ERR_STORAGE MVI ASM_REASON+2,4 no storage\n         J     VTOC_12             jump out\nVTOC_CVAFFILT_ERR DS 0H\n         MVC   ASM_REASON+3(1),CVSTAT copy status code\n         J     VTOC_12             jump out\nVTOC_ERR_PARM STC R0,ASM_REASON+2 set reason\n         J     VTOC_12             jump out\nVTOC_12  LA    R15,12              get code\n         J     VTOC_XX             jump out\nVTOC_08  LA    R15,8               get code\n         J     VTOC_XX             jump out\nVTOC_00  SR    R15,R15             get code\nVTOC_XX  DS    0H                  return back\n         ST    R15,ASM_RC          back code\n         PR    ,                   return back\n* 19/11/08 SRB callback\n*---------------------------------------------------------------------*\n* SRB call                                                            *\n* call an SRB routine and from the SRB call back a C function         *\n* +0 function addres to call                                          *\n* +4 paramter area address                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\nSRB_     DS   0H\n         PR    ,\n* 24/11/08 WLM enclave\n*---------------------------------------------------------------------*\n* WLM service create/delete enclave                                   *\n* +0     SUBSYSTEM name                                               *\n* back : r15 = return code                                            *\n*----------------- ---------------------------------------------------*\nWLM      PR    ,\n* 24/11/08 WLM enclave\n* 04/03/10 OBTAIN DSCB\n*---------------------------------------------------------------------*\n* OBTAIN routine                                                      *\n* +0 dataset name                                                     *\n* +4 volser                                                           *\n* +8 F1DSCB area                                                      *\n*---------------------------------------------------------------------*\n         SPACE 1\nOBTAIN   DS    0H\n         LM    R1,R2,ASM_PARMS\n         LHI   R15,-1\n         ICM   R1,15,ASM_PARMS\n         JZ    OBTAIN_XX\n  If  (CLI,0(R1),GE,C' ')\n         OC    0(44,R1),BLANKS\n         ICM   R1,15,ASM_PARMS+4\n         JZ    OBTAIN_XX\n         OC    0(6,R1),BLANKS\n         MVC   ASM_CAMLST(CAMLST_L),CAMLST copy camlst\n         MVC   ASM_CAMLST+4(12),ASM_PARMS\n* 16/08/11 OBTAIN EADSCB=OK for EAV volumes\n*        OBTAIN asm_camlst,EADSCB=OK ISSUE OBTAIN\n         OBTAIN ASM_CAMLST,EADSCB=OK ISSUE OBTAIN\n* 16/08/11 OBTAIN EADSCB=OK for EAV volumes\n  Else\n* 10/09/12 CAMLST SEEK for OBTAIN\n         ICM   R1,15,ASM_PARMS+4\n         JZ    OBTAIN_XX\n         OC    0(6,R1),BLANKS\n         MVC   ASM_CAMLST(CAMLST_L),CAMLST_SEEK copy camlst\n         MVC   ASM_CAMLST+4(12),ASM_PARMS\n* 16/08/11 OBTAIN EADSCB=OK for EAV volumes\n*        OBTAIN asm_camlst,EADSCB=OK ISSUE OBTAIN\n         OBTAIN ASM_CAMLST,EADSCB=OK ISSUE OBTAIN\n  Endif\n* 10/09/12 CAMLST SEEK for OBTAIN\nOBTAIN_XX DS 0H\n         ST    R15,ASM_RC          back code\n         PR    ,\n         SPACE 1\n* 04/03/10 OBTAIN DSCB\n*---------------------------------------------------------------------*\n* sleep  wait for n ms                                                *\n* +0     wait time in ms                                              *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nSLEEP_INTERN BAKR R14,0          all in linkage stack\nSLEEP    L     R1,ASM_PARMS      get in msec\n         LTR   R1,R1             test it\n         BZ    SLEEP_00          if no time\n         BNP   SLEEP_08          if invalid parm\n         BRASL R14,MILLSEC       call mill sec conv\n*        stimer wait,micvl=asm_sleep     wait here\n         STIMER WAIT,MICVL=ASM_SLEEP     wait here\nSLEEP_00 SR    R15,R15           clear return\n         B     SLEEP_XX          branch out\nSLEEP_08 LA    R15,8             get code\nSLEEP_XX ST    R15,ASM_RC        set rc\n         PR    ,                 return back\n*---------------------------------------------------------------------*\n* getecb get a work ecb address                                       *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nGETECB   L     R2,ASM_PARMS      get in msec\n         L     R3,ASM_WORKECBP   get pointer\n         CLC   0(4,R2),ZERO      init or free\n         BNE   GETECB_FREE       if free\n         L     R3,ASM_WORKECBS   get start\nGETECB_FIND_LOOP DS 0H\n         CLC   0(4,R3),ZERO      empty\n         BE    GETECB_FIND       branch if yes\n         LA    R3,20(,R3)        inr addr\n         C     R3,ASM_WORKECBE   check imit\n         BNL   GETECB_08         if in error\n         B     GETECB_FIND_LOOP try next\nGETECB_FIND DS 0H\n         MVC   0(4,R3),=F'-1'    reserved flag\n         LA    R3,4(,R3)         proper start\n         ST    R3,0(R2)          store it\n         B     GETECB_00         branch out\nGETECB_FREE L  R3,0(,R2)         get addr\n         SH    R3,=Y(4)          decr it\n         C     R3,ASM_WORKECBS   if lower\n         BL    GETECB_08         error\n         C     R3,ASM_WORKECBE   if lower\n         BH    GETECB_08         error\n         XC    0(20,R3),0(R3)    clean slot\nGETECB_00 SR   R15,R15           clear reg\n         B     GETECB_XX         branch out\nGETECB_08 LA   R15,8             get code\nGETECB_XX ST   R15,ASM_RC        save rc\n         PR    ,                 return back\n*---------------------------------------------------------------------*\n* wait for an event or give up after n ms                             *\n* +0     wait time in ms                                              *\n* +4     ecb pointer's                                                *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nWAIT     L     R2,ASM_PARMS      get parms\n         LTR   R2,R2             test time\n         BZ    WAIT_TIME_VALID   if zero valid\n         BM    WAIT_TIME_INVALID if infinite\n         C     R2,ADAY           check it\n         BL    WAIT_TIME_VALID   if o.k.\nWAIT_TIME_INVALID DS 0H\n         L     R2,ADAY           get it\nWAIT_TIME_VALID DS 0H\n         ST    R2,ASM_PARMS      save time value\n         LA    R2,ASM_PARMS+4    next ECB\n         LA    R3,ASM_EVENT0_ECBP-4 next pointer\n         LA    R4,4              max count\n         LA    R5,ASM_CALLLIST   temp addr\n         XC    ASM_CALLLIST(32),ASM_CALLLIST\nWAIT_ECBP_LOOP CLC 0(4,R2),ZERO  end of list\n         BE    WAIT_ECBP_LOOP_END branch if it is\n         LA    R3,4(,R3)         next ECBP\n         L     R1,0(R2)          get ECB addr\n         TM    0(R1),X'40'       is it posted\n         BO    WAIT_COMPLETED    if complete\n*26/04/04\n         NC    0(4,R1),=X'7FFFFFFF' off wait flag\n         ST    R1,0(,R3)          store in the list\n*25/08/04\n*        enq   (wait_maj,0(r3),e,4,step),mf=(e,asm_enql)\n         ENQ   (WAIT_MAJ,0(R3),E,4,STEP),MF=(E,ASM_ENQL)\n         ST    R3,0(,R5)         save it\n         LA    R5,4(,R5)         next\n*25/08/04\n         LA    R2,4(,R2)         next ECBP\n         BCT   R4,WAIT_ECBP_LOOP try it\nWAIT_ECBP_LOOP_END DS 0H\n         OI    0(R3),X'80'       high order on\n         LA    R4,ASM_TIMER_ECB  get timer ecb\n         ST    R4,ASM_TIMER_ECBP set it\n         XC    ASM_TIMER_ECB,ASM_TIMER_ECB cear ecb\n         LA    R5,ASM_TIMX       get timx addr\n         L     R1,ASM_PARMS      time here\n         BRASL R14,MILLSEC       call millsec routine\n*        stimer real,(r5),micvl=asm_sleep get address\n         STIMER REAL,(R5),MICVL=ASM_SLEEP get address\n*        wait  ecblist=asm_timer_ecbp,linkage=system\n         WAIT  ECBLIST=ASM_TIMER_ECBP,LINKAGE=SYSTEM\n*        ttimer cancel           cancel timer\n         TTIMER CANCEL           cancel timer\n*25/08/04\n         LA    R15,ASM_EVENT0_ECBP get ecb pointer\n         LA    R14,4             max ecb\nWAIT_POSTED_LOOP ICM R1,15,0(R15) get next\n         LA    R1,0(,R1)         get rid of high order\n         LTR   R1,R1             test it\n         BZ    WAIT_POSTED_TIME  if no more\n         TM    0(R1),X'40'       is it posted\n         BO    WAIT_COMPLETED    if complete\n         LA    R15,4(,R15)       next ecbp\n         BCT   R14,WAIT_POSTED_LOOP try it\nWAIT_POSTED_TIME DS 0H\n         TM    ASM_TIMER_ECB,X'40' timer occured\n         BO    WAIT_08           if timer expired\nWAIT_COMPLETED DS 0H\n         LTR   R1,R1             test r1\n         BZ    WAIT_00           branch over\n         NC    0(4,R1),=X'3FFFFFFF' clear wait and post flags\nWAIT_00  SR    R15,R15           clear code\n         ICM   R15,15,0(R1)      get code\n         B     WAIT_XX           branch back\nWAIT_08  L     R15,=F'-1'        get code\nWAIT_XX  ST    R15,ASM_RC        back code\n*25/08/04\n         LA    R5,ASM_CALLLIST    get ecb pointer\n         LA    R4,4              max ecb\nWAIT_DEQ_LOOP ICM R3,15,0(R5) get next\n         BZ    WAIT_DEQ_DONE     if no more\n         NC    0(4,R3),=X'7FFFFFFF' off high bit\n*        deq   (wait_maj,0(r3),4,step),mf=(e,asm_enql)\n         DEQ   (WAIT_MAJ,0(R3),4,STEP),MF=(E,ASM_ENQL)\n         LA    R5,4(,R5)       next ecbp\n         BCT   R4,WAIT_DEQ_LOOP try it\nWAIT_DEQ_DONE DS 0H\n*        LR    R15,R5            back rc\n         PR    ,                 return back\n*        DROP  R2\n*---------------------------------------------------------------------*\n* post for an event                                                   *\n* +0     ECB pointer                                                  *\n* +4     post code                                                    *\n* back : r15 = returrn code                                           *\n*---------------------------------------------------------------------*\n         USING EVENT_TOKEN,R4    base on even token\nPOST     LM    R4,R5,ASM_PARMS   get parms\n         L     R6,0(R4)            get ecb\n         LTR   R6,R6               test ECB\n         BM    POSTBR_X            if already in wait\n         N     R6,=X'3FFFFFFF'     off wait post bit\n         L     R1,=X'40000000'     get posted\n         OR    R1,R5               get code\n         CS    R6,R1,0(R4)         check it\n         BZ    POSTED_X            branch if ok\n         LTR   R6,R6               test wait bit\n         BM    POSTBR_X            branch if in wait\n         N     R6,=X'40000000'     test if already posted\n         BZ    POSTBR_X            branch to post if not\n         STCM  R5,7,1(R4)          set new code\n         B     POSTED_X            branch out\nPOSTBR_X DS 0H\n*        post  (r4),(r5)           issue POST\n         POST  (R4),(R5)           issue POST\nPOSTED_X MVC   ASM_RC,ZERO         clear rc\n         B     POST_XX             branch out\nPOSTERR_X MVC  ASM_RC,=A(8)        set code\nPOST_XX  L     R15,ASM_RC          get code\n         PR    ,                   return\n         DROP  R4\n*---------------------------------------------------------------------*\n* reset reset event  ecb                                              *\n* +0     event token pointer                                          *\n* back : r15 = returrn code                                           *\n*---------------------------------------------------------------------*\n         USING EVENT_TOKEN,R4    base on even token\nRESET    LM    R4,R5,ASM_PARMS   get parms\n         L     R3,EVENT_TOKEN_ECBP   get ecb pointer\n****     xc    0(4,r3),0(r3)      leave as it is\n         SR    R15,R15            clear ret\n         L     R15,ASM_RC          get code\n         PR    ,                   return\n         DROP  R4\n* 06/03/12 TESTAUTH DIAGNOSE extension\n*---------------------------------------------------------------------*\n* TESTAUTH test if APF authorized                                     *\n* back : r15 = returrn code                                           *\n*---------------------------------------------------------------------*\nTESTAUTH_INTERN BAKR R14,0\nTESTAUTH  DS  0H\n  If  (ICM,R15,15,ASM_TESTAUTH,M)\n*         testauth fctn=1\n          TESTAUTH FCTN=1\n          ST  R15,ASM_TESTAUTH\n  Else\n          ICM  R15,15,ASM_TESTAUTH\n  Endif\n          PR   ,\n* 06/03/12 TESTAUTH DIAGNOSE extension\n*---------------------------------------------------------------------*\n* DIAGNOSE test if APF authorized                                     *\n* +0     diag x'0204' code                                            *\n* +4     reply area address\n* back : r15 = returrn code                                           *\n*---------------------------------------------------------------------*\nDIAGNOSE LM    R2,R3,ASM_PARMS     get parms\n  Do  LABEL=DIAGNOSE_LEAVE\n    If  (ICM,R15,15,ASM_TESTAUTH,Z)\n*        modeset mode=sup,key=zero supervisor state\n         MODESET MODE=SUP,KEY=ZERO supervisor state\n      If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_FIX),Z)\n        If  (ICM,R4,15,ASM_DIAGNOSE_ADDR,Z)\n*        storage obtain,length=asm_diagnose_length,bndry=page\n         STORAGE OBTAIN,LENGTH=ASM_DIAGNOSE_LENGTH,BNDRY=PAGE\n          If  (LTR,R15,R15,NZ)\n            Asmleave  DIAGNOSE_LEAVE\n          Endif\n  ST  R1,ASM_DIAGNOSE_ADDR\n  LR  R4,R1\n        Endif\n* PGSER R,FIX,A=(R4),EA=4095(,R4),ECB=0\n  PGSER R,FIX,A=(R4),EA=4095(,R4),ECB=0\n        If  (LTR,R15,R15,NZ)\n          Asmleave  DIAGNOSE_LEAVE\n        Endif\n  OC  ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_FIX)\n      Endif\n      If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_DONTSWAP),Z)\n* sysevent dontswap\n  SYSEVENT DONTSWAP\n        If  (LTR,R15,R15,NZ)\n          Asmleave  DIAGNOSE_LEAVE\n        Endif\n  OC  ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_DONTSWAP)\n      Endif\n  LR  R3,R2\n  LRA R2,0(,R4)\n  DIAG R2,R3,X'0204'\n  L    R0,ASM_PARMS+4\n  LHI  R1,4095\n  LR  R5,R1\n  LR   R2,R4\n  MVCL R0,R4\n      If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_KEEP),Z)\n* SYSEVENT OKSWAP\n  SYSEVENT OKSWAP\n  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_DONTSWAP)\n* PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0\n  PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0\n  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_FIX)\n*        storage release,length=asm_diagnose_length,addr=(r2)\n         STORAGE RELEASE,LENGTH=ASM_DIAGNOSE_LENGTH,ADDR=(R2)\n  XC    ASM_DIAGNOSE_ADDR,ASM_DIAGNOSE_ADDR\n      Endif\n* modeset mode=prob,key=nzero\n  MODESET MODE=PROB,KEY=NZERO\n  SR   R15,R15\n    Endif\n  Enddo\n PR ,\n***********************************************************************\n* VSMLIST                                                             *\n*  function : the routine  builds an SRB and schedules it             *\n*             issue a VSMLIST commandinthe traget address space       *\n*             XM communication                                        *\n* parms :                                                             *\n* +0 target ascb address                                              *\n* +4 reply area                                                       *\n* +8 reply area  length                                               *\n***********************************************************************\nVSMLIST  L     R2,ASM_PARMS       gett parms\n         ST    R2,ASM_VSMLIST_ASCBADDR save ASCB addr\n         L     R1,X'10'            get cvt addr\n         L     R1,CVTTCBP-CVT(R1)  get TCB list addr\n         MVC   ASM_VSMLIST_MYTCB,4(R1) save the TCB addr\n         L     R1,12(R1)           get my ASCB addr\n         ST    R1,ASM_VSMLIST_MYASCB save ascb addr\n         MVC   ASM_VSMLIST_MYASCBID,ASCBASID-ASCB(R1)\n  Do\n*        MODESET MODE=SUP,KEY=ZERO  into key0 sup state\n         MODESET MODE=SUP,KEY=ZERO  into key0 sup state\n*        GETMAIN RU,LV=SRBSIZE+SRBWORKL,SP=245 from SQA\n         GETMAIN RU,LV=SRBSIZE+SRBWORKL,SP=245 from SQA\n         ST    R1,ASM_VSMLIST_STORAGE\n         LR    R9,R1               base on SRB area\n         USING SRBSECT,R9          assign base\n         LA    R8,SRBSIZE(,R9)     base on srb work area\n         USING SRBWORK,R8          assign base on srb work area\n         XC    SRBSECT(SRBSIZE),SRBSECT clear area\n         MVC   SRBID,=CL4'SRB'     set id\n         MVC   SRBASCB,ASM_VSMLIST_ASCBADDR  save ascb addr\n         MVC   SRBPASID,ASM_VSMLIST_MYASCBID set my ascb id\n         MVC   SRBPTCB,ASM_VSMLIST_MYTCB set TCB addr for PURGEDQ\n         LARL  R2,XMSRB            get SRB addr\n         BSM   R2,0                set mode\n         ST    R2,SRBEP            move entry\n         LARL  R2,XMFRR            get FRR addr\n         BSM   R2,0                set mode\n         ST    R2,SRBRMTR          set it resoure manager\n         ST    R2,SRBFRRA           and FRR\n         ST    R8,SRBPARM          same as work area\n         MVC   SRBWORK_REPLY_ADDRESS(8),ASM_PARMS+4 set addr/length\n*        ALESERV EXTRACTH,STOKEN=srbwork_stoken,                       *\n               MF=(E,SRBWORK_LALESERV)\n         ALESERV EXTRACTH,STOKEN=SRBWORK_STOKEN,                       *\n               MF=(E,SRBWORK_LALESERV)\n    If  (LTR,R15,R15,NZ)\n      Asmleave\n    Endif\n         XC    SRBWORK_ECB,SRBWORK_ECB clear srbwork_ecb\n         MVC   SRBWORK_MYASCB,ASM_VSMLIST_MYASCB move ascb addr\n*        SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,VSMLIST_LOCK)\n         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,VSMLIST_LOCK)\n*        SETLOCK OBTAIN,TYPE=LOCAL,REGS=USE,MODE=UNCOND\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=USE,MODE=UNCOND\nVSMLIST_LOCK    DS 0H\n*        SCHEDULE SRB=(R9),SCOPE=GLOBAL schedule the SRB\n         SCHEDULE SRB=(R9),SCOPE=GLOBAL schedule the SRB\n*        SETLOCK RELEASE,TYPE=LOCAL,REGS=USE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE\n*        WAIT  ECB=srbwork_ecb wait for SRB completion\n         WAIT  ECB=SRBWORK_ECB wait for SRB completion\n         MVC   ASM_RC,SRBWORK_RETCODE\n         MVC   ASM_REASON,SRBWORK_REPLY_ADDRESS+4\n  Enddo\n  If  (ICM,R9,15,ASM_VSMLIST_STORAGE,NZ)\n*        FREEMAIN RU,A=(R9),LV=SRBSIZE+SRBWORKL,SP=245 free the SRB\n         FREEMAIN RU,A=(R9),LV=SRBSIZE+SRBWORKL,SP=245 free the SRB\n         XC     ASM_VSMLIST_STORAGE,ASM_VSMLIST_STORAGE\n  Endif\n*        MODESET MODE=PROB,KEY=NZERO back to user key problem state\n         MODESET MODE=PROB,KEY=NZERO back to user key problem state\n         PR ,\n         TITLE 'XMSRB SRB routine to get back the primary STOKEN'\n         SPACE 5\n* at entry the SRB routine is in supervisor state , primary ASC\n* the regsisters area :\n* r0 address of the SRB\n* r1 same as SRB parm\n* r14 return address\n* r15 entry address\n         SPACE 1\n         USING ASCB,R12\nXMSRB    LARL  R11,DATAASMIF       base on data\n         LR    R9,R14              save the return addr\n         LR    R8,R1               base on the work area\n         USING SRBWORK,R8          assign on parm area\n         L     R12,PSAAOLD\n         LA    R13,SRBWORK_SAVESYS\n  Do  LABEL=VSMLOOP\n*        ALESERV ADD,STOKEN=SRBWORK_STOKEN,                            *\n               ALET=SRBWORK_ALET,CHKEAX=NO,ACCESS=PUBLIC,              *\n               AL=PASN,                                                *\n               MF=(E,SRBWORK_LALESERV)\n         ALESERV ADD,STOKEN=SRBWORK_STOKEN,                            *\n               ALET=SRBWORK_ALET,CHKEAX=NO,ACCESS=PUBLIC,              *\n               AL=PASN,                                                *\n               MF=(E,SRBWORK_LALESERV)\n    If  (LTR,R15,R15,NZ)\n      Asmleave\n    Endif  BRANCH if not ok\n         XC   SRBWORK_VSMLIST_REPLY(4),SRBWORK_VSMLIST_REPLY\n         SETLOCK TEST,TYPE=LOCAL,BRANCH=(HELD,XMSRB_LOCKHELD)\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=USE,MODE=UNCOND\nXMSRB_LOCKHELD  DS 0H\n         LHI  R15,4\n         LM   R6,R7,SRBWORK_REPLY_ADDRESS\n        L   R12,ASCBRCTP\n        DROP R12\n    Do  WHILE=(CHI,R15,EQ,4)\n*        VSMLIST SP=PVT,tcb=((r12),all),space=free,                    *\n               LOC=31,LINKAGE=BRANCH,                                  *\n               PVTSP=ALL,                                              *\n               WKAREA=(SRBWORK_VSMLIST_REPLY,                          *\n               SRBWORK_VSMLIST_REPLY_LENGTH)\n         VSMLIST SP=PVT,TCB=((R12),ALL),SPACE=FREE,                    *\n               LOC=31,LINKAGE=BRANCH,                                  *\n               PVTSP=ALL,                                              *\n               WKAREA=(SRBWORK_VSMLIST_REPLY,                          *\n               SRBWORK_VSMLIST_REPLY_LENGTH)\n      If  (CHI,R15,LE,4)\n        SAC 512\n         SYSSTATE ASCENV=AR indicate for macro's\n         LM    R0,R1,SRBWORK_VSMLIST_REPLY+4\n         LAM   R0,R0,ZERO\n         LAM   R6,R6,SRBWORK_ALET\n         MVCL  R6,R0\n         SYSSTATE ASCENV=P  indicate for macro's\n         SAC 0\n      Else\n        Asmleave  VSMLOOP\n      Endif\n    Enddo\n         ST     R15,SRBWORK_RETCODE\n    STM   R6,R7,SRBWORK_REPLY_ADDRESS\n  Enddo\n*        SETLOCK RELEASE,TYPE=LOCAL,REGS=USE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE\n*        ALESERV delete,alet=srbwork_alet,                             *\n               CHKEAX=NO,                                              *\n               MF=(E,SRBWORK_LALESERV)\n         ALESERV DELETE,ALET=SRBWORK_ALET,                             *\n               CHKEAX=NO,                                              *\n               MF=(E,SRBWORK_LALESERV)\n    If  (LTR,R15,R15,NZ)\n          DC A(0)\n    Endif\n            LA    R1,SRBWORK_ECB      get srbwork_ecb addr\n            L     R2,SRBWORK_ECB      get srbwork_ecb contents\n            L     R15,=X'40000000'    get post code\n  If  (LTR,R2,R2,NM)\n    Do  WHILE=(CS,R2,R15,NZ,SRBWORK_ECB)\n    Enddo\n  Else\n         LR     R10,R15            get post code\n         SR    R0,R0               CLEAR srbwork_ecb KEY REG\n         ICM   R10,8,=X'80'        indicate XM post\n         L     R7,=X'80000000'     indicate XMPOST\n         L     R12,=X'80000000'    indicate XM post\n         LA    R11,SRBWORK_ECB     get the srbwork_ecb addr\n         OR    R11,R7\n         L     R13,SRBWORK_MYASCB  address of the ascb\n         L     R15,CVTPTR          get cvt addr\n         L     R15,CVT0PT01-CVT(,R15) get post addr\n         BALR  R14,R15\n         LARL  R11,DATAASMIF       base on data\n  Endif\n         BR    R9                  branch back to the control program\n*\n* SRB FRR error routine\n*\nXMFRR    DC    0D'0'\n         BR    R14                back to the control program\n*---------------------------------------------------------------------*\n* bselect   determines the number of ready file descriptors           *\n* int        select(int nfds, fd_set *readfds, fd_set *writefds,      *\n*            fd_set *exceptfds, const struct timeval *timeout);       *\n* back : r15 = return code        0                                   *\n*---------------------------------------------------------------------*\n         SPACE 1\nSELECT  DS    0H                 CALL TO CHECK\n         LM    R2,R6,ASM_PARMS     get parms\n         ST    R2,ASM_BPX1_NUMFDS  store num of FDs\n         LR    R0,R2               number of fd's\n         SRL   R0,3                divide by 8\n         ST    R0,ASM_BPX1_LIST_LENGTH_R store into list\n         ST    R0,ASM_BPX1_LIST_LENGTH_W store into list\n         ST    R0,ASM_BPX1_LIST_LENGTH_E store into list\n         LTR   R3,R3               test first addr\n         BNZ   *+14                if o.k.\n         LA    R3,ZERO             get zero addr\n         XC    ASM_BPX1_LIST_LENGTH_R,ASM_BPX1_LIST_LENGTH_R no r\n         LTR   R4,R4               test first addr\n         BNZ   *+14                if o.k.\n         LA    R4,ZERO             get zero addr\n         XC    ASM_BPX1_LIST_LENGTH_W,ASM_BPX1_LIST_LENGTH_E no w\n         LTR   R5,R5               test first addr\n         BNZ   *+14                if o.k.\n         LA    R5,ZERO             get zero addr\n         XC    ASM_BPX1_LIST_LENGTH_E,ASM_BPX1_LIST_LENGTH_E no e\n         ST    R6,ASM_BPX1_TIMEOUT set timeout\n         MVC   ASM_BPX1_OPTION,=A(SEL#BITSBACKWARD) copy option\n         XC    ASM_BPX1_RETVAL(12),ASM_BPX1_RETVAL clear return\n*        call  bpx1sel,                                                *\n               (ASM_BPX1_NUMFDS,                                       *\n               ASM_BPX1_LIST_LENGTH_R,                                 *\n               (R3),                                                   *\n               ASM_BPX1_LIST_LENGTH_W,                                 *\n               (R4),                                                   *\n               ASM_BPX1_LIST_LENGTH_E,                                 *\n               (R5),                                                   *\n               ASM_BPX1_TIMEOUT,                                       *\n               =A(0),                                                  *\n               ASM_BPX1_OPTION,                                        *\n               ASM_BPX1_RETVAL,                                        *\n               ASM_BPX1_RETCODE,                                       *\n               ASM_BPX1_RSNCODE),                                      *\n               VL,MF=(E,ASM_BPX1)\n         CALL  BPX1SEL,                                                *\n               (ASM_BPX1_NUMFDS,                                       *\n               ASM_BPX1_LIST_LENGTH_R,                                 *\n               (R3),                                                   *\n               ASM_BPX1_LIST_LENGTH_W,                                 *\n               (R4),                                                   *\n               ASM_BPX1_LIST_LENGTH_E,                                 *\n               (R5),                                                   *\n               ASM_BPX1_TIMEOUT,                                       *\n               =A(0),                                                  *\n               ASM_BPX1_OPTION,                                        *\n               ASM_BPX1_RETVAL,                                        *\n               ASM_BPX1_RETCODE,                                       *\n               ASM_BPX1_RSNCODE),                                      *\n               VL,MF=(E,ASM_BPX1)\n         L     R15,ASM_BPX1_RETCODE get reason\n         ST    R15,ASM_REASON    save it\n         L     R15,ASM_BPX1_RETVAL  get code\n         ST    R15,ASM_RC        save it\n         PR    ,                 return back\n        SPACE 1\n*---------------------------------------------------------------------*\n* connectshmem connect a target to a share group                      *\n* +0     shmem token pointer                                          *\n* +4     area address                                                 *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\n         USING SHMEM_TOKEN,R2    base on shmem token\n         USING  VRL,R4           base on iarvrl\nCONNECTSHMEM DS 0H\n*        modeset mode=sup        supervisor state\n         MODESET MODE=SUP        supervisor state\n*        $$setkey key=zero,save=asm_key key key=zero\n         $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero\n         LM    R2,R3,ASM_PARMS   get parms\n         LA    R4,ASM_IARVRL     base on iarvrl area\n         XC    0(VRLLEN,R4),0(R4) clear iarvrl dsect\n         MVC   VRLSVSA,SHMEM_TOKEN_ADDR copy sourece addr\n         L     R5,SHMEM_TOKEN_ASCB get ascb\n         USING ASCB,R5           base on ascb\n         L     R5,ASCBASSB       get assb addr\n         USING ASSB,R5           base on assb\n*        aleserv add,stoken=assbstkn,alet=vrlsstkn+4,chkeax=no,        *\n               MF=(E,ASM_ALESERVL)\n         ALESERV ADD,STOKEN=ASSBSTKN,ALET=VRLSSTKN+4,CHKEAX=NO,        *\n               MF=(E,ASM_ALESERVL)\n         L     R0,SHMEM_TOKEN_LGTH get length\n         A     R0,=A(PAGE_SIZE-1)  add page size\n         N     R0,=X'0FFFF000'     and round\n         SRL   R0,12             in pages\n         ST    R0,VRLNUMPG       number of pages\n         L     R5,PSAAOLD        get target ascb\n         USING ASCB,R5           base on ascb\n         L     R5,ASCBASSB       get assb addr\n         USING ASSB,R5           base on assb\n*        aleserv add,stoken=assbstkn,alet=vrltstkn+4,chkeax=no,        *\n               MF=(E,ASM_ALESERVL)\n         ALESERV ADD,STOKEN=ASSBSTKN,ALET=VRLTSTKN+4,CHKEAX=NO,        *\n               MF=(E,ASM_ALESERVL)\n         ST    R3,VRLTVSA        copy taget address\n         ST    R4,ASM_IARVRLA    set addr\n         LA    R4,ASM_IARVRLA    set pointer to it\n*        iarvserv share,ranglist=(r4),                                 *\n               TARGET_VIEW=SHAREDWRITE,                                *\n               MF=(E,ASM_IARVSERVL)\n         IARVSERV SHARE,RANGLIST=(R4),                                 *\n               TARGET_VIEW=SHAREDWRITE,                                *\n               MF=(E,ASM_IARVSERVL)\n         STM   R15,R0,ASM_RC     save return/reason code\n*        $$setkey back,save=asm_key back to user\n         $$SETKEY BACK,SAVE=ASM_KEY back to user\n*        modeset mode=prob       supervisor state\n         MODESET MODE=PROB       supervisor state\n         PR\n         DROP  R4,R5             drop work regs\n*---------------------------------------------------------------------*\n* disconnectshmem disconnect from a shared group                      *\n* +0     shmem token pointer                                          *\n* +4     area address                                                 *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\n         USING SHMEM_TOKEN,R2    base on shmem token\n         USING  VRL,R4           base on iarvrl\nDISCONNECTSHMEM LM R2,R3,ASM_PARMS get parms\n         LA    R4,ASM_IARVRLA    set pointer to it\n*        modeset mode=sup        supervisor state\n         MODESET MODE=SUP        supervisor state\n*        $$setkey key=zero,save=asm_key key key=zero\n         $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero\n*        aleserv delete,alet=vrlsstkn+4,                               *\n               MF=(E,ASM_ALESERVL)\n         ALESERV DELETE,ALET=VRLSSTKN+4,                               *\n               MF=(E,ASM_ALESERVL)\n*        aleserv delete,alet=vrltstkn+4,                               *\n               MF=(E,ASM_ALESERVL)\n         ALESERV DELETE,ALET=VRLTSTKN+4,                               *\n               MF=(E,ASM_ALESERVL)\n*        iarvserv unshare,ranglist=(r4),                               *\n               RETAIN=NO,                                              *\n               MF=(E,ASM_IARVSERVL)\n         IARVSERV UNSHARE,RANGLIST=(R4),                               *\n               RETAIN=NO,                                              *\n               MF=(E,ASM_IARVSERVL)\n         STM   R15,R0,ASM_RC     save return/reason code\n*        $$setkey back,save=asm_key back to user\n         $$SETKEY BACK,SAVE=ASM_KEY back to user\n*        modeset mode=prob       supervisor state\n         MODESET MODE=PROB       supervisor state\n         PR\n         DROP R4\n*---------------------------------------------------------------------*\n* cleanup free asm area , delete modules                              *\n* back : r15 = ieantcr return code                                    *\n*---------------------------------------------------------------------*\nCLEANUP  DS    0H\n         CLC   ASM_IEANTCR,ZERO    is there ieantcr\n         BE    CLEANUP_NOCR        branch if no\n         DELETE EP=IEANTCR         delete it\nCLEANUP_NOCR DS 0H\n         CLC   ASM_IEANTRT,ZERO    is there ieantcr\n         BE    CLEANUP_NORT        branch if no\n         DELETE EP=IEANTRT         delete it\nCLEANUP_NORT DS 0H\n         CLC   ASM_IEANTDL,ZERO    is there ieantcr\n         BE    CLEANUP_NODL        branch if no\n         DELETE EP=IEANTDL         delete it\nCLEANUP_NODL DS 0H\nCLEANUP_NOTCPIP DS 0H\n         SR    R3,R3              clear reg\n         ICM   R3,15,ASM_WORKECBS get start\n         BZ    CLEANUP_NOCSA     if no csa allocated\n*        modeset mode=sup        supervisor state\n         MODESET MODE=SUP        supervisor state\n*        $$setkey key=zero,save=asm_key key key=zero and save it\n         $$SETKEY KEY=ZERO,SAVE=ASM_KEY key key=zero and save it\n*        storage release,length=max_ecbs,addr=(r3),key=8,sp=231\n         STORAGE RELEASE,LENGTH=MAX_ECBS,ADDR=(R3),KEY=8,SP=231\n*        $$setkey back,save=asm_key key key=zero and save it\n         $$SETKEY BACK,SAVE=ASM_KEY key key=zero and save it\n*        modeset mode=prob       supervisor state\n         MODESET MODE=PROB       supervisor state\nCLEANUP_NOCSA DS 0H\n  If  (NC,ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_KEEP),O),AND,              *\n               (CLC,ASM_TESTAUTH,EQ,ZERO)\n* modeset mode=sup,key=zero\n  MODESET MODE=SUP,KEY=ZERO\n* SYSEVENT OKSWAP\n  SYSEVENT OKSWAP\n  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_DONTSWAP)\n    If  (ICM,R4,15,ASM_DIAGNOSE_ADDR,NZ)\n* PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0\n  PGSER R,FREE,A=(R4),EA=4095(,R4),ECB=0\n  NC   ASM_DIAGNOSE_FLAG,=A(ASM_DIAGNOSE_ALL-ASM_DIAGNOSE_FIX)\n*        storage release,length=asm_diagnose_length,addr=(r2)\n         STORAGE RELEASE,LENGTH=ASM_DIAGNOSE_LENGTH,ADDR=(R2)\n  XC    ASM_DIAGNOSE_ADDR,ASM_DIAGNOSE_ADDR\n    Endif\n* modeset mode=prob,key=nzero\n  MODESET MODE=PROB,KEY=NZERO\n  Endif\n*        storage release,length=asm_length,addr=(r7) release\n         STORAGE RELEASE,LENGTH=ASM_LENGTH,ADDR=(R7) release\n         SR     R15,R15           clear all\n         PR\n*---------------------------------------------------------------------*\n* oper operator communication                                         *\n* +0     area pointer                                                 *\n* +4     area length                                                  *\n* back : r15 = return code        0 start/modify command              *\n*                                 4 stop command                      *\n*---------------------------------------------------------------------*\n         USING COMLIST,R4        base on comlist\n         USING CIBNEXT,R5        base on cib\nOPER     DS    0H\n         CLC   ASM_COMPTR,ZERO   already init\n         BNE   OPER_COMMAND      if already done\n         LA    R2,ASM_EXTRACT_L  get list form address\n         LA    R3,ASM_COMPTR     comand pointer\n*        extract (r3),'S',mf=(e,(r2)),fields=comm extract comm\n         EXTRACT (R3),'S',MF=(E,(R2)),FIELDS=COMM extarct comm\n         SR    R4,R4             clear r4\n         ICM   R4,15,ASM_COMPTR get com ptr\n         BZ    OPER_RET_08       if in error\n         L     R5,COMCIBPT       get cib pointer\n         BRASL R14,OPER_CIB      process data\n*        qedit origin=comcibpt,cibctr=9  prepare for comand\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=9  prepare for comand\n         B     OPER_RET_00       branch out\nOPER_COMMAND DS 0H\n         SR    R4,R4             clear r4\n         ICM   R4,15,ASM_COMPTR get com ptr\n         SR    R5,R5             clear it\n         ICM   R5,15,COMCIBPT       get cib pointer\n         BZ    OPER_COMMAND_WAIT wait if nothing\n         CLI   CIBVERB,CIBSTOP   stop commad\n         BE    OPER_RET_04       branch if it is\nOPER_COMMAND_WAIT DS 0H\n         L     R2,COMECBPT       get ecb pointer\n         TM    0(R2),X'40'       if posted\n         BO    OPER_COMMAND_PROCESS branch if yes\n*        wait ecb=(r2)           issue wait\n         WAIT ECB=(R2)           issue wait\nOPER_COMMAND_PROCESS DS  0H\n         L     R5,COMCIBPT       get cib pointer\n         CLI   CIBVERB,CIBSTOP   stop commad\n         BE    OPER_RET_04       branch if it is\n         BRASL R14,OPER_CIB      process it\n         B     OPER_RET_XX       branch out\nOPER_RET_00 SR R15,R15           clear reg\n         B     OPER_RET_XX       branch back\nOPER_RET_04 LA R15,4             get code\n         B     OPER_RET_XX       branch back\nOPER_RET_08 LA R15,8             get code\nOPER_RET_XX DS 0H                branch back\n         STM   R15,R0,ASM_RC       save return/reason\n         PR    ,                 back\nOPER_CIB BAKR  R14,0             all in stack\n         SR    R15,R15           clear ret\nOPER_CIB_DO LTR   R5,R5             test cib\n         BZ    OPER_CIB_RET      back if no\n         LA    R15,4             get code\n         CLI   CIBVERB,CIBSTOP   modify commad\n         BE    OPER_CIB_RET      branch if stop\n         CLI   CIBVERB,CIBMODFY  modify commad\n         BNE   OPER_CIB_FREE     branch if not\n         LM    R2,R3,ASM_PARMS   get data length\n         LTR   R2,R2             test addr\n         BZ    OPER_CIB_FREE     if no data\n         LA    R14,CIBDATA       get data\n         LH    R15,CIBDATLN      get length\n         CR    R3,R15            check length\n         BL    *+6               if lower\n         LR    R3,R15            set data length\n         MVCL  R2,R14            copy text\n         MVI   0(R2),X'00'       keep hapy c++\nOPER_CIB_FREE DS 0H\n*        qedit origin=comcibpt,block=(r5) prepare for comand\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R5) prepare for comand\n         ICM   R5,15,0(R5)     next\n         BNZ   OPER_CIB_DO       try it\n         SR    R15,R15           now ok\nOPER_CIB_RET PR ,                back\n         DROP  R4                drop it\n         DROP  R5                drop cib\n*---------------------------------------------------------------------*\n* wto  operator communication                                         *\n* +0     area pointer                                                 *\n* +4     area length                                                  *\n* +8     descriptor code                                              *\n* back : r15 = return code        0                                   *\n*---------------------------------------------------------------------*\nWTO      DS    0H\n         MVC   ASM_WTOL(MDL_WTOL_L),MDL_WTOL copy wtol\n         LM    R2,R4,ASM_PARMS     get parms\n         SR    R15,R15             get code\n         L     R14,=X'00010000'    code\n         SRDL  R14,0(R4)           shit it\n         STH   R14,ASM_WTOL+138  higher part\n         ST    R15,ASM_WTOL+140  lower part\n         LA    R4,ASM_WTOL+4       to addr\n         LA    R5,ASM_WTOL_TEXT_LENGTH max text length\n         ICM   R3,8,BLANKS         get pad\n         MVCL  R4,R2               copy text\n*        wto   mf=(e,asm_wtol)     issue wto\n         WTO   MF=(E,ASM_WTOL)     issue wto\n         SR    R15,R15             test return\n         PR    ,                   branch back\n*---------------------------------------------------------------------*\n* malloc allocate the storage under the jstcb                         *\n* +0     area length                                                  *\n* +4     rely addr                                                    *\n* back : r15 = return code        0                                   *\n*---------------------------------------------------------------------*\nMALLOC   DS    0H\n*        modeset mode=sup        supervisor state\n         MODESET MODE=SUP        supervisor state\n         USING   TCB,R2          base on tcb\n         L     R2,PSATOLD        get tcb\n         L     R2,TCBJSTCB       get jstcb addr\n         LM    R3,R4,ASM_PARMS   get size reply\n         LA    R3,8(,R3)         add head\n*        storage obtain,tcbaddr=(r2),length=(r3)\n         STORAGE OBTAIN,TCBADDR=(R2),LENGTH=(R3)\n         ST    R3,0(R1)          save length\n         MVC   4(4,R1),=C'stor'  add id\n         LA    R1,8(,R1)         proper addr\n         ST    R1,0(,R4)         set back\n         LR    R5,R15            save rc\n*        modeset mode=prob       supervisor state\n         MODESET MODE=PROB       supervisor state\n         LR    R15,R5            save rc\n         ST    R15,ASM_RC        set result\n         PR    ,                 return back\n*---------------------------------------------------------------------*\n* free   free allocated storage under the jstcb                       *\n* +0     area address                                                 *\n* back : r15 = return code        0                                   *\n*---------------------------------------------------------------------*\nFREESTOR DS    0H\n*        modeset mode=sup        supervisor state\n         MODESET MODE=SUP        supervisor state\n         USING   TCB,R2          base on tcb\n         L     R2,PSATOLD        get tcb\n         L     R2,TCBJSTCB       get jstcb addr\n         L     R3,ASM_PARMS      get addr\n         SR    R15,R15           clear ret\n         LTR   R3,R3             test it\n         BNP   FREESTOR_OUT      if nothing to freestor\n         SH    R3,=Y(8)          proper addr\n         L     R4,0(,R3)         get length\n         CLC   4(4,R3),=C'stor'  check it\n         BNE   FREESTOR_OUT      if not\n*        storage release,tcbaddr=(r2),addr=(r3),length=(r4)\n         STORAGE RELEASE,TCBADDR=(R2),ADDR=(R3),LENGTH=(R4)\nFREESTOR_OUT LR R5,R15           save rc\n*        modeset mode=prob       supervisor state\n         MODESET MODE=PROB       supervisor state\n         LR    R15,R5            save rc\n         ST    R15,ASM_RC        set result\nFREESTOR_RET PR ,                return back\nFREESTOR_ABEND DC A(0)           abend here\n*---------------------------------------------------------------------*\n* millsec  convert microsec to millsec and store                      *\n*---------------------------------------------------------------------*\nMILLSEC  BAKR   R14,0            save in stack\n         SR    R2,R2             clear r0\n         LR    R3,R1             get it\n         M     R2,=A(1000)       in micro sec\n         LA    R3,1(,R3)         add one ( no zero time )\n         SLDL  R2,12             into mic form\n         STM   R2,R3,ASM_SLEEP   save it\n         PR    ,                 return back\n*---------------------------------------------------------------------*\n* copystr  - copy string routine                                      *\n*---------------------------------------------------------------------*\nCOPYSTR  BAKR  R14,0               all in satck\n         MVC   ASM_WORK,BLANKS     blank out\n         LA    R2,ASM_WORK         output addr\n         LA    R3,64               max length\nCOPYSTR_LOOP CLI 0(R1),0           end of string\n         BE    COPYSTR_00          back if yes\n         MVC   0(1,R2),0(R1)       copy a byte\n         LA    R1,1(,R1)           incr from\n         LA    R2,1(,R2)           incr to\n         BCT   R3,COPYSTR_LOOP     in loop\nCOPYSTR_00 PR ,                    back\n*---------------------------------------------------------------------*\n* strlen  - he length of the null term string                         *\n*---------------------------------------------------------------------*\nSTRLEN   BAKR  R14,0              all in satck\n         LA    R2,256             max length\nSTRLEN_LOOP CLI 0(R1),0           string term\n         BE    STRLEN_BREAK       if it is\n         LA    R1,1(,R1)          next char\n         BCT   R2,STRLEN_LOOP     try if more\nSTRLEN_BREAK LA R15,256           here also\n         EREG  R1,R1             back from stack\n         SR    R15,R2            get length\n         PR    .                 back to caller\n         TITLE 'data areas '\n*---------------------------------------------------------------------*\n* DATA area                                                           *\n*---------------------------------------------------------------------*\n*        $$DBASE\n         $$DBASE\n         LTORG\n*dl_enql     enq (0,0,e,0,step),mf=l   list enq\nMDL_ENQL     ENQ (0,0,E,0,STEP),MF=L   list enq\nMDL_ENQLL EQU *-MDL_ENQL            enq length\n         SPACE 3\nBLANKS   DC    CL128' '            long blank\nZERO     DC    A(0)                zero\nNULLS    DC    XL8'00'\nKEY8     EQU   8                   key 8 user key\n         LTORG\n*dl_wtol wto  '01234567890123456789012345678901234567890123456789012345*\n               678901234567890123456789012345678901234567890123456789',*\n               ROUTCDE=(21),DESC=(6),MF=L\nMDL_WTOL WTO  '01234567890123456789012345678901234567890123456789012345*\n               678901234567890123456789012345678901234567890123456789',*\n               ROUTCDE=(21),DESC=(6),MF=L\nMDL_WTOL_L EQU *-MDL_WTOL           text length\nSVC_EXE  SVC   *-*               exec only\nTDUMP_COPY MVC 1(*-*,R3),0(R1)    copy text\nTDUMP_DEF_NAME   DC AL1(L'TDUMP_DEF_NAMEL)\nTDUMP_DEF_NAMEL  DC C'ISIS.TDUMP.D&&YYMMDD..T&&HHMMSS..&&SYSNAME..&&JOB*\n               NAME.'\nTDUMP_DEF_DESC   DC AL1(L'TDUMP_DEF_DESCL)\nTDUMP_DEF_DESCL  DC C'ISIS default '\nVTOC_COPY_DCB MVC 0(*-*,R6),VTOC_MODEL_DCB copy model DCB\n*TOC_MODEL_DCB DCB DSORG=PS,MACRF=(R)\nVTOC_MODEL_DCB DCB DSORG=PS,MACRF=(R)\nVTOC_MODEL_DCB_LENGTH EQU *-VTOC_MODEL_DCB\n*TOC_MODEL_CVAFFILT CVAFFILT MF=L,FLTAREA=KEEP\nVTOC_MODEL_CVAFFILT CVAFFILT MF=L,FLTAREA=KEEP\nVTOC_MODEL_CVAFFL EQU *-VTOC_MODEL_CVAFFILT\nLOGGER_ONESEC      DC A(100*1)            one sec\nLOGGER_SETSTREAM   MVC ASM_STREAMNAME(*-*),0(R3) copy straem\n*OGGER_MAX_BUFFER  DC  A(1024*128) max logger buffer\nLOGGER_MAX_BUFFER  DC  A(1024*1024*8) max logger buffer\nWLM_CONNTKN_KEY  DC X'00'         connection token key\nWLM_ENCLAVE_TOKENNAME DC C'WLM_ENCLAVE'\nADAY     DC    A(24*60*60*1000)  a day in milli sec\nWAIT_MAJ DC    CL8'WAITMAJOR'    ENQ/DEQ MAJOR NAME\n* 04/03/10 OBTAIN DSCB\n*AMLST   CAMLST SEARCH,0,0,0\nCAMLST   CAMLST SEARCH,0,0,0\nCAMLST_L EQU    *-CAMLST\n* 04/03/10 OBTAIN DSCB\n* 10/09/12 CAMLST SEEK for OBTAIN\n*amlst_seek CAMLST SEEK,0,0,0\nCAMLST_SEEK CAMLST SEEK,0,0,0\nCAMLST_SEEK_L EQU *-CAMLST_SEEK\n* 10/09/12 CAMLST SEEK for OBTAIN\n         SPACE 1\n         SPACE 1\n* timer exit modell\n         SPACE 1\n         PUSH USING\n         DROP R13\nMDL_TIMX BALR R15,0               timer exit area\n         USING ASM_TIMX+2,R15     temp base  base\n         STM   R14,R12,12(R13)     save regs\n         LA    R2,ASM_TIMER_ECB   get ecb addr\n         POST  (R2)                post ecb\n         LM    R14,R12,12(R13)     save regs\n         BSM   0,R14                 return back\n         DROP  R15\nMDL_TIMXL EQU *-MDL_TIMX   routine length\n         POP   USING\n         TITLE  ' refrenced dsects '\n         GBLB &PRINT\n&PRINT   SETB 1\n         $$GLOBAL IARVRL=NO\n         PRINT GEN\n         SPACE 1\n* event token dsect\nEVENT_TOKEN  DSECT\nEVENT_TOKEN_ASCB DC A(0)         ascb pointer\nEVENT_TOKEN_TCB  DC A(0)         tcb pointer\nEVENT_TOKEN_ECBP DC A(0)         ecb pointer\nEVENT_TOKEN_ECB  DC A(0)         event ecb\n         SPACE 1\n* event token dsect\nSHMEM_TOKEN  DSECT\nSHMEM_TOKEN_ASCB DC A(0)         ascb pointer\nSHMEM_TOKEN_ADDR DC A(0)         source address\nSHMEM_TOKEN_LGTH DC A(0)         source length\nSHMEM_TOKEN_     DC A(0)         reserved\n         PRINT NOGEN\n         MEXIT\n.MSG     TITLE ' messages for qnetasm '\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$DBASE": {"ttr": 35, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "          MACRO\n          $$DBASE\n          GBLB  &BASELESS\n          GBLC  &QFSSTIT\n          GBLC  &VERSION\n          AIF    (&BASELESS).BL\n          MEXIT\n.BL       ANOP\n&NAME     SETC  '&SYSECT'\nDATA&NAME      DC  0D'0'\n         DC    AL2(START&SYSNDX-*),C'SRC:&NAME '\n         AIF   ('&QFSSTIT' EQ '').NOTIT\n         MNOTE 0,&QFSSTIT\n         DC    C&QFSSTIT\n.NOTIT   DC    C' &SYSDATE '\n         DC    C'&VERSION'\n         DC    X'00'\nSTART&SYSNDX EQU *\n         DC    0D'0'\n$$BASE         LOCTR\n               LTORG\nDATA&NAME.END  EQU DATA&NAME+4095\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$GLOBAL": {"ttr": 199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x004\\x01\\x12%O\\x01\\x122\\x8f\\x109\\x011\\x01\\xbe\\x00\\x00\\xc5\\xe2\\xc1@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2012-09-10T00:00:00", "modifydate": "2012-11-23T10:39:34", "lines": 305, "newlines": 446, "modlines": 0, "user": "ESA"}, "text": "* 04/01/04 ARM SUPPORT\n* 12/07/04 SAPI SUPPORT\n* 21/07/04 EXCI SUPPORT\n* 19/01/05 WLM SUPPORT\n* 18/11/05 LOGGER AND ARCXX MAP'S\n* 21/11/05 CVAF VTOC ACCESS\n* 13/01/06 BROWSE LOGGER MULTIBLOCK\n* 12/05/06 IKJ CONTROL BLOCKS\n* 20/06/07 SMF RECORDS\n* 30/05/08  call REXX at SELECT\n* 09/12/09 TRACEONMSG\n         MACRO\n         $$GLOBAL &NOGEN=,&IARVRL=\n         COPY  $$SYSVAR\n         GBLB  &INCLUDE\n         GBLB  &PRINT\n         PUSH PRINT\n         AIF   (&PRINT).PRINT\n         PRINT OFF,NOGEN\n         AGO   .PRINTOK\n.PRINT   PRINT ON\n.PRINTOK ANOP\n          AIF   (&INCLUDE).INCLOK\n&INCLUDE  SETB  1\n         SPACE 1\n* SYSTEM CONTROL BLOCKS\n         SPACE 1\n         PRINT    OFF,NOGEN\n         CVT      DSECT=YES        CVT\n         IHASCVT  ,                SCVT MAP\n         IHAASCB ,        ASCB\n         IHAASXB ,        ASXB\n         IHAASSB ,        ASSB\n         IHALDA  ,        LDA\n         IHAECVT ,        ECVT\n         IHAEPIE ,        PIE\n         IHALLT  ,        LLT MAP\n         IHAPCCA ,\n         IHAPCCAT ,\n* SYSTEM trace\n         IHATRVT\n         IHATBVT\n         IHATTE\n* SYSTEM trace\n         IEFJSCVT ,                SUBSYSTEM CONTROL VECTOR TABLE\n         IEFJESCT ,                JES CONTROL TABLE\n         IEFJSSWA ,                SSWA AREA\n         IEFSSARB ,                SSARB MAP\n         IEFJSBVT ,                JSBVT MAP\n         IEFJSIPL ,                JSIPL MAP\n         IHAASVT  ,                MAP ASVT\n         IHAPSA   ,                PREFIXED STORAGE AREA\n         IKJRB    ,                RB MAP\n         IHASRB   ,                SRB map\n         IHACDE   ,                CDE MAP\n         IHALLE   ,                LLE MAP\n         IHAXTLST ,                EXTENT LIST\n         IHADCBE  ,                DCBE MAP\n         IHASDWA  ,                SDWA\n         IHAACEE  ,                ACEE\n         IRARMCT  ,                RMCT\n         IRACCT   ,                CCT\n         IRACMCT  ,                CMCT\n         IRAICT   ,                CCT\n         IRAMCT   ,                CCT\n         IRACPMB  ,                Channel Path Mesuerment Block\n         IHACSD   ,                CSD\n         IKJECT   ,                MAPPING FOR ECT\n         IKJPSCB  ,                MAPPING FOR PSCB\n         IKJUPT   ,                MAPPING FOR UPT\n         IAZJSAB  ,                JSAB\n         IEZJSCB  ,                MAP JSCB\n         IEFZB505 LOCEPAX=YES SWA REQ PARM LIST\n         AIF   (&ARM EQ 0).NOARM0\n         IXCYARM  ,\n         IXCYARAA ,\n.NOARM0  ANOP\n        AIF (&WLM EQ 0).NOWLM1\n        IWMYCON  ,\n        IWMQCXIT MF=(L,IWMQCXIT)\n.NOWLM1 ANOP\n         SPACE 1\n* TCB AND CONNECTED\n         SPACE 1\n         IKJTCB   ,                TCB MAP\n         IHASTCB  ,                SECONDRAY TCB CONTROL BLOCK\n         IEFTIOT1 ,                TIOT DD ENTRY\n         IRXSHVB  ,                REXX VAR ACCESS\n         SPACE 1\n* VSAM , VTAM CONTROL BLOCKS\n         SPACE 1\n         IFGEXLST ,                MAP VSAM EXIT LIST\n         IFGRPL   ,                MAP RPL\n         ISTRPLEX ,                RPL VTAM EXTENSION\n         IFGACB   ,                MAP ACB\n         IDARMRCD ,                RPL RETURN CODE\nISTFMH5  ISTFM5 ,\n         ISTDNIB  ,\n         ISTDBIND ,                 BIND IMAGE\n         ISTSLD   ,\n         ISTSLCNS ,\n         SPACE 1\n* DATA MANAGEMENT CONTROL BLOCKS\n         SPACE 1\n         DCBD     DSORG=PS,DEVD=DA MAP DCB\n         IEZDEB   ,                MAP FOR THE DEB\n         IHADECB  ,                MAP FOR THE DECB\n         SPACE 1\n* TSO SERVICES\n         SPACE 1\n* 12/05/06 IKJ CONTROL BLOCKS\n         IKJTSVT\n         IKJEFTSJ  TJDSECT=YES\n         IKJEFTSV  TVDSECT=YES\n* 12/05/06 IKJ CONTROL BLOCKS\nIEFJFCBN DSECT JFCB DSECT\n         IEFJFCBN ,                JFCB MAP\nDSCB     DSECT\n*SCBF1   IECSDSL1 (1) F1 DSCB\nDSCBF1   IECSDSL1 (1) F1 DSCB\n* 21/11/05 CVAF VTOC ACCESS\nF1DSCB_SIZE EQU *-DSCB\nF2DSCB   DSECT\n*SCBF2   IECSDSL1 (2) F2 DSCB\nF2DSCB_  IECSDSL1 (2) F2 DSCB\nF2DSCB_SIZE EQU *-F2DSCB\nF3DSCB   DSECT\n*SCBF2   IECSDSL1 (3) F3 DSCB\nF3DSCB_  IECSDSL1 (3) F3 DSCB\nF3DSCB_SIZE EQU *-F3DSCB\n*CL_MAP  ICVFCL\nFCL_MAP  ICVFCL\n*FL_MAP  ICVAFBFL\nBFL_MAP  ICVAFBFL\n*VAFFILT_MAP CVAFFILT MF=D\nCVAFFILT_MAP CVAFFILT MF=D\n* 21/11/05 CVAF VTOC ACCESS\n         SPACE 1\n* COMMUNICATION\n         SPACE 1\nIEZCIB   DSECT\n         IEZCIB ,                  MAPPING FOR CIB\nIEZCOM   DSECT\n         IEZCOM ,                  COMMUNICATION AREA MAPPING\n         SPACE 1\n* NAME/TOKEN SERVICES\n         SPACE 1\n         IEANTASM ,               NAME TOKEN\n         SPACE 1\n* SHARED MEMORY\n         SPACE 1\n         AIF      ('&IARVRL' EQ 'NO').NOIAR\n         IARVRL   ,               SHARED MEMORY\n.NOIAR   ANOP\n*        PRINT ON,GEN\n         SPACE 1\n* TCP/IP CONTROL BLOCKS\n         SPACE 1\n         SPACE 1\n* FSS CONTROL BLOCKS\n         SPACE 1\n         IEFSJRC ,        RETURN CODES\n         IEFSJREP ,       SJRE AREA\n         IAZCHK ,         CHECKPOINT RECORD\n         IAZJSPA ,        JSPA DSECT\n         IAZIDX ,         INDEX ENTRY MAP\n         IAZFSIP          FSIP PARMS AREA\n         IEFSJMRP ,       SCHEDULER JCL FACILITY MERGE\n         IEFJMR   ,       JOB MANAGER RECORD\n         IAZRESPA ,       FSI RESPONSE AREA\n         IAZFSCT  ,       FSCT AREA\n         IAZFSVT ,        FSS VECTOR TABLE\n         IHASVT ,         ASVT\n         CSVDLCB ,        CSVDLCB\n         IEESMCA ,        SMCA\n         IGVVSMD ,        VSMD VSMLIST reply arae\n         IGWDES  ,        MAP DES\n         IGWSMDE ,        SMDE\n         IEFJSSIB ,                SSIB\n         IEFJSSOB (SO,AL,EN,VS,DA,AG,CI,CS),CONTIG=NO\n*        IEFSSOBH ,\n*        IAZSSS2 DSECT=YES\n         IAZSSS2 DSECT=YES\n*        IAZCTKN DSECT=YES\n         IAZCTKN DSECT=YES\n         IEFSSTS  ,\n*        IEFSSSO SOEXT=YES\n         PUSH    PRINT\n         PRINT   GEN\n         IEFZB610\n         POP     PRINT\n*        IEFZB4D0 ,\n*        IEFZB4D2 ,\n         EZASMI TYPE=GLOBAL,STORAGE=DSECT\nEZATASK  EZASMI TYPE=TASK,STORAGE=DSECT\n         SPACE 1\n         EZBCTHDR\n         COPY  EZBYPTHA\n         SPACE 1\n         IDCDOUT DSECT=YES\n***      ARCUTILP\n         SPACE 1\n* BPX CONTROL BLOCKS\n         SPACE 1\n*        BPXYCID  ,\n         BPXYCID  ,\n*        BPXYAIO  ,\n         BPXYAIO  ,\n*        BPXYSEL  ,\n         BPXYSEL  ,\n*        BPXZOTCB\n         BPXZOTCB\n*        BPXZOCVT\n         BPXZOCVT\n*        BPXZOCVE\n         BPXZOCVE\n*        BPXZOPNT\n         BPXZOPNT\n*        BPXYPGPS\n         BPXYPGPS\n*        BPXYPGTH\n         BPXYPGTH\n*        BPXYTHLI\n         BPXYTHLI\n*        BPXYPRLI\n         BPXYPRLI\n*        BPXYSIGH\n         BPXYSIGH\n*        BPXYPGTH\n         BPXYPGTH\n*        BPXYOPNF\n         BPXYOPNF\n*        BPXYOSMF\n         BPXYSTAT\n*        BPXYSTAT\n         BPXYOSMF\n*        BPXYMNTE MNTE2=YES\n         BPXYMNTE MNTE2=YES\n*        BPXYRFIS\n         BPXYRFIS\n*        ASMAXITP ,  ASMA90 EXIT AREAS\n         ASMAXITP ,ASMA90 EXIT AREAS\n*        ICHRUTKN\n         ICHRUTKN\nIXGANSAA DSECT\n*        IXGANSAA LIST=YES\n         IXGANSAA LIST=YES\n* 13/01/06 BROWSE LOGGER MULTIBLOCK\n* BRWOSE LOGGER MULTIBLOCK MAP\n*        IXGBRMLT\n         IXGBRMLT\n*        adreid0\n         ADREID0\n*        adrUFO\n         ADRUFO\n* 13/01/06 BROWSE LOGGER MULTIBLOCK\n         SPACE 1\n         PRINT ON,GEN\nIOCC     DSECT\nIOCC_DUMMY DC A(0)\n*        BPXYIOCC\n         BPXYIOCC\n* SMF RECORDS\nSMF14    DSECT\n*        IFASMFR 14\n         IFASMFR 14\n*        IFASMFR 30\n         IFASMFR 30\n*        IGWSMF SMF42_01=YES,SMF42_02=YES,SMF42_03=YES,SMF42_04=YES,   *\n               SMF42_05=YES,SMF42_06=YES,SMF42_09=YES,SMF42_0A=YES,    *\n               SMF42_0B=YES,SMF42_0F=YES,SMF42_0G=YES,SMF42_0H=YES,    *\n               SMF42_0I=YES,SMF42_0J=YES,SMF42_0K=YES,SMF42_0L=YES,    *\n               SMF42_0M=YES,SMF42_0N=YES,SMF42_0P=YES,SMF42_0Q=YES,    *\n               DSECT=YES\n         IGWSMF SMF42_01=YES,SMF42_02=YES,SMF42_03=YES,SMF42_04=YES,   *\n               SMF42_05=YES,SMF42_06=YES,SMF42_09=YES,SMF42_0A=YES,    *\n               SMF42_0B=YES,SMF42_0F=YES,SMF42_0G=YES,SMF42_0H=YES,    *\n               SMF42_0I=YES,SMF42_0J=YES,SMF42_0K=YES,SMF42_0L=YES,    *\n               SMF42_0M=YES,SMF42_0N=YES,SMF42_0P=YES,SMF42_0Q=YES,    *\n               DSECT=YES\n*        IFASMFR 04\nSMF4     DSECT\n         IFASMFR 04\n*        IFASMFR 05\nSMF5     DSECT\n         IFASMFR 05\n*        IFASMFR 92\n         IFASMFR 92\n*        ERBSMFR 79\n         ERBSMFR 79\n*        ERBSMF70\n         ERBSMF70\n*        ASASYMBP\n         ASASYMBP\nDIR      DSECT                     DIRECTORY DSECT\nDIRMEM   DS    CL8                 MEMBER NAME\nDIRTTR   DS    XL3                 TTR VALUE\nDIRC     DS    C                   COMBINED FLAG BYTE\nDIRCA    EQU   X'80'               ALIAS FLAG\nDIRCN    EQU   X'60'               TTRN MASK\nDIRCU    EQU   X'1F'               USER DATA MASK\nDIRUSER  DS    CL62                USER DATA FIELD\n.INCLOK   ANOP\n         POP  PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$SETKEY": {"ttr": 89, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x122o\\x01\\x122o\\x14'\\x00-\\x00-\\x00\\x00\\xc5\\xe2\\xc1@@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-11-21T00:00:00", "modifydate": "2012-11-21T14:27:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "ESA"}, "text": "         MACRO\n&LABEL   $$SETKEY &OPTION,&SAVE=(R2),&KEY=8,&DIRECT=NO\n         COPY  $$SYSVAR\n         LCLA    &KV\n         AIF     ('&KEY' EQ 'USER').S8\n         AIF     ('&KEY' EQ 'ZERO').S0\n         AIF     ('&KEY' EQ 'JES').S1\n&KV      SETA    &KEY\n         AGO    .KEYSET\n.S0      ANOP\n&KV      SETA   0\n         AGO    .KEYSET\n.S1      ANOP\n&KV      SETA   1\n         AGO    .KEYSET\n.S8      ANOP\n&KV      SETA   8\n.KEYSET  ANOP\n&LABEL   DS     0H\n         AIF    ('&DIRECT' EQ 'YES').DIRECT\n         AIF    ('&OPTION' EQ 'BACK').BACK\n         AIF    ('&OPTION' EQ '').USER\n         MNOTE  8,'invalid option'\n.USER    IPK    ,                  + get actual key in r2\n         MNOTE  0,' KEY in R2'\n         AIF    (('&SAVE' EQ '') OR ('&SAVE' EQ '(R2)')).SAVED\n         AIF    ('&SAVE'(1,1) EQ '(').USERSR\n         STC    R2,&SAVE           + save key\n         AGO    .SAVED\n.USERSR  LR     &SAVE(2,K'&SAVE-2),R2 + SAVE IT\n.SAVED   LA     R1,X'&KV.0'(0,0)  + get value\n         MODESET KEYREG=R1         + set key\n.TOR2    MEXIT\n.BACK    AIF    (('&SAVE' EQ '') OR ('&SAVE' EQ '(R2)')).SET\n         AIF    ('&SAVE'(1,1) EQ '(').USERBK\n         SR      R2,R2             + clear reg\n         IC      R2,&SAVE          + back key\n         AGO     .SET\n.USERBK  LR      R2,&SAVE(2,K'&SAVE-2) + BACK KEY\n.SET     MODESET KEYREG=(R2)        + set back\n         AGO     .END\n         MNOTE 0,'in &key key'\n.DIRECT  SPKA &KV*16\n.END     ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$SYSTEM": {"ttr": 29, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* 04/01/04 ARM SUPPORT\n* 20/04/04 VERSION NAME TO 609\n* 10/07/04 SAPI MODIFICATION\n* 23/07/04 EXCI MODIFICATION\n* 23/07/04 DB2\n* 19/01/05 WLM\n* 15/02/05 MS\n* 30/09/05 VERSION NAME TO 620\n* 12/12/05 WEB CONTROL\n* 27/93/09 VERSION NAME TO 700\n         GBLC &SYSTEM\n         GBLA &SYSTEMC\n         GBLC &PROJECT\n         GBLC &VERSION\n         GBLC &VERSION_SHORT\n         GBLC &MSGPREF\n         GBLC &CVTYPE\n         GBLC &PRODUCT\n         GBLB &MQS\n         GBLB &SAPI\n         GBLB &EXCI\n         GBLB &DB2\n         GBLB &TLIB\n         GBLB &HTTP\n         GBLB &ARM\n         GBLB &WLM\n         GBLB &WLMAE\n         GBLB &MS\n         AIF   (&SYSTEMC GT 1).NO\n&SYSTEMC SETA &SYSTEMC+1\n&MSGPREF SETC 'QSF'\n         AIF  ('&SYSTEM' NE '').SYSOK\n&SYSTEM  SETC 'MVS/ESA'\n.SYSOK   ANOP\n&PROJECT SETC 'QFSS'\n&VERSION SETC 'V7R0M0'\n&VERSION_SHORT SETC 'V700'\n&CVTYPE  SETC 'TCBUSER'\n&PRODUCT SETC 'PAPYRUS HOST'\n&MQS     SETB  1\n&SAPI    SETB  1\n&EXCI    SETB  1\n&DB2     SETB  0\n&TLIB    SETB  0\n&HTTP    SETB  1\n&ARM     SETB  1\n&WLM     SETB  1\n&WLMAE   SETB  1\n&MS      SETB  1\n&SYSCVTR SETC  ''\n         MNOTE 0,'*******************************************'\n         MNOTE 0,'*                                          '\n         MNOTE 0,'* &SYSTEM                                  '\n         MNOTE 0,'* &PROJECT                                 '\n         MNOTE 0,'* &VERSION                                 '\n         MNOTE 0,'* &MSGPREF                                 '\n         MNOTE 0,'* &CVTYPE                                  '\n         MNOTE 0,'* &PRODUCT                                 '\n         MNOTE 0,'* MQS = &MQS                               '\n         MNOTE 0,'* HTTP = &HTTP                             '\n         MNOTE 0,'* ARM = &ARM                               '\n         MNOTE 0,'* SAPI = &SAPI                             '\n         MNOTE 0,'* EXCI = &EXCI                             '\n         MNOTE 0,'* DB2 = &DB2                               '\n         MNOTE 0,'* WLM = &WLM                               '\n         MNOTE 0,'* WLMAE = &WLMAE                           '\n         MNOTE 0,'* MS = &MS                                 '\n         MNOTE 0,'****************************************** '\n.NO      ANOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$SYSVAR": {"ttr": 37, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* 29/11/07 struct asm include\n         GBLC &SYSTEM\n         GBLA &SYSTEMC\n         GBLC &PROJECT\n         GBLC &VERSION\n         GBLC &VERSION_SHORT\n         GBLC &MSGPREF\n         GBLC &CVTYPE\n         GBLC &PRODUCT\n         GBLC &QFSSTIT\n         GBLB &MQS\n         GBLB &HTTP\n         GBLB &TLIB\n         GBLB &ARM\n         GBLB &SAPI\n         GBLB &EXCI\n         GBLB &DB2\n         GBLB &WLM\n         GBLB &WLMAE\n         GBLB &MS\n         GBLB &BASELESS\n         GBLB &QFSSSETA\n         GBLC &SYSCVTR\n         AIF  (&QFSSSETA).ARCHOK\n* 29/11/07 struct asm include\n         PUSH PRINT\n         PRINT OFF\n         PRINT NOGEN\n         COPY    ASMMSP\n         POP   PRINT\n         ASMMREL ON\n* 29/11/07 struct asm include\n         SYSSTATE ARCHLVL=2\n&QFSSSETA SETB 1\n.ARCHOK  ANOP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMIF": {"ttr": 189, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         COPY $$SYSTEM\nASMIF    $$ASMIF TYPE=PROGRAM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BPXZOCVE": {"ttr": 67, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         BPXZOCVE\nOCVE     DSECT                                                   RS1199\nOCVEEYEC DS    CL4                     eyecatcher 'OCVE'         RS1199\n         DS    CL2                                               RS1199\nOCVE_LENGTH  DS  H                     length OCVE               RS1199\n         DS    CL4                                               RS1199\nOCVEOPNT DS    F                                                 RS1199\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BPXZOCVT": {"ttr": 69, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         BPXZOCVT\nOCVT         DSECT                                               RS1199\nOCVTEYEC     DS  CL4                   eyecatcher 'OCVT'         RS1199\n             DS  CL2                                             RS1199\nOCVT_LENGTH  DS  H                     length OCVT               RS1199\nOCVTOCVE     DS  F                     OCVE-Pointer              RS1199\nOCVTOEXT     DS  F                     OEXT-Pointer              RS1199\n             DS  F                                               RS1199\nOCVTASCB1    DS  F                     ASCB-Pointer for USS      RS1199\nOCVTASID     DS  H                     ASID for USS              RS1199\n             DS  CL2                                             RS1199\n             DS  F                                               RS1199\nOCVTSTOKEN   DS  D                     Kernel-Token              RS1199\n             DS  6F                                              RS1199\nOCVTASCB2    DS  F                     ASCB-Pointer for VTAM     RS1199\n             DS  CL248                 ??                        RS1199\nOCVT_STCNAME DS  CL8                                             RS1199\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BPXZOPNT": {"ttr": 71, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         BPXZOPNT\nOPNT                     DSECT                                   RS1199\nOPNTEYEC                 DS CL4     eyecatcher 'OPNT'            RS1199\n                         DS CL52                                 RS1199\nOPNT_MAXPROCSYSTEM       DS F                                    RS1199\nOPNT_MAXPROCUSER         DS F                                    RS1199\nOPNT_MAXUIDS             DS F                                    RS1199\nOPNT_MAXFILEPROC         DS F                                    RS1199\nOPNT_MAXPTYS             DS F                                    RS1199\nOPNT_TRACEPARM           DS CL8                                  RS1199\nOPNT_MAXTHREADTASKS      DS F                                    RS1199\n                         DS F                                    RS1199\nOPNT_BPXPRM              DS CL8                                  RS1199\nOPNT_MAXTHREADS          DS F                                    RS1199\nOPNT_FORKCOPY_FLAG       DS XL1                                  RS1199\n                         DS CL3                                  RS1199\nOPNT_STEPLIBLIST_LENGTH  DS X                                    RS1199\nOPNT_STEPLIBLIST         DS CL60                                 RS1199\nOPNT_STEPLIBLIST_UNKNOWN DS CL195                                RS1199\nOPNT_PRIORITYGOALS       DS F                                    RS1199\nOPNT_IPCMSGNIDS          DS F                                    RS1199\nOPNT_IPCMSGQBYTES        DS F                                    RS1199\nOPNT_IPCMSGQMNUM         DS F                                    RS1199\nOPNT_IPCSHMNIDS          DS F                                    RS1199\nOPNT_IPCSHMSPAGES        DS F                                    RS1199\nOPNT_IPCSHMMPAGES        DS F                                    RS1199\nOPNT_IPCSHMNSEGS         DS F                                    RS1199\nOPNT_IPCSEMNIDS          DS F                                    RS0301\nOPNT_IPCSEMNSEMS         DS F                                    RS0301\nOPNT_IPCSEMNOPS          DS F                                    RS1199\nOPNT_MAXMMAPAREA         DS F                                    RS1199\nOPNT_MAXRTYS             DS F                                    RS1199\nOPNT_MAXFILESIZE         DS F    HIGHVALUE = Unlimited           RS1199\nOPNT_MAXCORESIZE         DS F                                    RS1199\nOPNT_MAXASSIZE           DS F                                    RS1199\nOPNT_MAXCPUTIME          DS F                                    RS1199\n                         DS 2F                                   RS1199\nOPNT_SUPERUSER           DS CL8                                  RS1199\n                         DS F                                    RS1199\nOPNT_MAXSHAREPAGES       DS F                                    RS1199\nOPNT_TTYGROUP            DS CL8                                  RS1199\n                         DS F                                    RS0800\nOPNT_MAXQUEUEDSIGS       DS F                                    RS0800\n                         DS F                                    RS0800\n                         DS CL8                                  RS1199\n                         DS 14F                                  RS1199\n                         DS CL3                                  RS1199\nOPNT_USERIDALIAS_LENGTH  DS X                                    RS1199\nOPNT_USERIDALIAS         DS CL60                                 RS1199\nOPNT_USERIDALIAS_UNKNOWN DS CL195                                RS1199\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BPX1EQUS": {"ttr": 73, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "          MACRO\n          BPX1EQUS\nBPX1ACC   EQU             52  access\nBPX1ACK   EQU            972  auth_check_rsrc_np\nBPX1ACP   EQU            508  accept\nBPX1AIO   EQU            988  asyncio\nBPX1ALR   EQU            224  alarm\nBPX1ANR   EQU           1060  accept_and_recv\nBPX1ASP   EQU           1088  aio_suspend\nBPX1ATM   EQU            668  attach_execmvs\nBPX1ATX   EQU            664  attach_exec\nBPX1BND   EQU            512  bind\nBPX1CCA   EQU            480  cond_cancel\nBPX1CCS   EQU           1012  console_np\nBPX1CHA   EQU             84  chaudit\nBPX1CHD   EQU             56  chdir\nBPX1CHM   EQU             60  chmod\nBPX1CHO   EQU             64  chown\nBPX1CHP   EQU            764  chpriority\nBPX1CHR   EQU            500  chattr\nBPX1CID   EQU            968  convert_id_np\nBPX1CLD   EQU             68  closedir\nBPX1CLO   EQU             72  close\nBPX1CON   EQU            516  connect\nBPX1CPO   EQU            484  cond_post\nBPX1CRT   EQU            872  chroot\nBPX1CSE   EQU            488  cond_setup\nBPX1CTW   EQU            492  cond_timed_wait\nBPX1CWA   EQU            496  cond_wait\nBPX1DEL   EQU            888  deletehfs\nBPX1ENV   EQU            960  oe_env_np\nBPX1EXC   EQU            228  exec\nBPX1EXI   EQU            232  _exit\nBPX1EXM   EQU            236  execmvs\nBPX1EXT   EQU            200  extlink_np\nBPX1FCA   EQU            140  fchaudit\nBPX1FCD   EQU            852  fchdir\nBPX1FCM   EQU             88  fchmod\nBPX1FCO   EQU             92  fchown\nBPX1FCR   EQU            504  fchattr\nBPX1FCT   EQU             96  fcntl\nBPX1FPC   EQU            100  fpathconf\nBPX1FRK   EQU            240  fork\nBPX1FST   EQU            104  fstat\nBPX1FSY   EQU            108  fsync\nBPX1FTR   EQU            112  ftruncate\nBPX1FTV   EQU            848  FstatVfs\nBPX1GCL   EQU          1024  getclientid\nBPX1GCW   EQU            116  getcwd\nBPX1GEG   EQU            244  getegid\nBPX1GEP   EQU            860  getpgid\nBPX1GES   EQU            864  getsid\nBPX1GET   EQU            736  w_getipc\nBPX1GEU   EQU            248  geteuid\nBPX1GGE   EQU            772  getgrent\nBPX1GGI   EQU            252  getgrgid\nBPX1GGN   EQU            256  getgrnam\nBPX1GGR   EQU            260  getgroups\nBPX1GID   EQU            264  getgid\nBPX1GIV   EQU           1028  givesocket\nBPX1GLG   EQU            268  getlogin\nBPX1GMN   EQU             76  w_getmntent\nBPX1GNM   EQU            524  getpeername\nBPX1GPE   EQU            776  getpwent\nBPX1GPG   EQU            272  getpgrp\nBPX1GPI   EQU            276  getpid\nBPX1GPN   EQU            280  getpwnam\nBPX1GPP   EQU            284  getppid\nBPX1GPS   EQU            428  w_getpsent\nBPX1GPT   EQU            916  grantpt\nBPX1GPU   EQU            288  getpwuid\nBPX1GPY   EQU            744  getpriority\nBPX1GRL   EQU            820  getrlimit\nBPX1GRU   EQU            824  getrusage\nBPX1GTH   EQU           1056  __getthent\nBPX1GTR   EQU            752  getitimer\nBPX1GUG   EQU            292  getugrps\nBPX1GUI   EQU            296  getuid\nBPX1GWD   EQU            936  getwd\nBPX1HST   EQU            520  gethostid\nBPX1IOC   EQU            120  w_ioctl\nBPX1IPT   EQU            396  MvsIptAffinity\nBPX1ITY   EQU             12  isatty\nBPX1KIL   EQU            308  kill\nBPX1LCO   EQU            832  lchown\nBPX1LNK   EQU            124  link\nBPX1LOD   EQU            880  loadhfs\nBPX1LSK   EQU            128  lseek\nBPX1LSN   EQU            532  listen\nBPX1LST   EQU            132  lstat\nBPX1MAT   EQU            720  shmat\nBPX1MCT   EQU            724  shmctl\nBPX1MDT   EQU            728  shmdt\nBPX1MGT   EQU            732  shmget\nBPX1MKD   EQU            136  mkdir\nBPX1MKN   EQU            144  mknod\nBPX1MMP   EQU            796  mmap\nBPX1MNT   EQU            148  mount\nBPX1MP    EQU            688  MVSpause\nBPX1MPC   EQU            408  mvsprocclp\nBPX1MPI   EQU            680  MVSpauseInit\nBPX1MPR   EQU            800  mprotect\nBPX1MSD   EQU            336  mvsunsigsetup\nBPX1MSS   EQU            312  mvssigsetup\nBPX1MSY   EQU            804  msync\nBPX1MUN   EQU            808  munmap\nBPX1NIC   EQU            748  nice\nBPX1OPD   EQU            152  opendir\nBPX1OPN   EQU            156  open\nBPX1OPT   EQU            528  getsockopt\nBPX1PAF   EQU           1072  __pid_affinity\nBPX1PAS   EQU            316  pause\nBPX1PCF   EQU            160  pathconf\nBPX1PCT   EQU            768  pfsctl\nBPX1PIO   EQU            984  w_pioctl\nBPX1PIP   EQU            164  pipe\nBPX1POL   EQU            932  poll\nBPX1PSI   EQU            460  pthread_setintr\nBPX1PST   EQU            472  pthread_setintrtype\nBPX1PTB   EQU            448  pthread_cancel\nBPX1PTC   EQU            432  pthread_create\nBPX1PTD   EQU            444  pthread_detach\nBPX1PTI   EQU            476  pthread_testintr\nBPX1PTJ   EQU            440  pthread_join\nBPX1PTK   EQU            464  pthread_kill\nBPX1PTQ   EQU            412  pthread_quiesc\nBPX1PTR   EQU            320  ptrace\nBPX1PTS   EQU            452  pthread_self\nBPX1PTT   EQU           1016  pthread_tag_np\nBPX1PTX   EQU            436  pthread_xandg\nBPX1PWD   EQU            788  __passwd\nBPX1QCT   EQU            692  msgctl\nBPX1QDB   EQU            948  querydub\nBPX1QGT   EQU            696  msgget\nBPX1QRC   EQU            700  msgrcv\nBPX1QSE   EQU            388  quiesce\nBPX1QSN   EQU            704  msgsnd\nBPX1RCV   EQU            540  recv\nBPX1RDD   EQU            168  readdir\nBPX1RDL   EQU            172  readlink\nBPX1RDV   EQU            536  readv\nBPX1RDX   EQU            940  read_extlink\nBPX1RD2   EQU            856  readdir2\nBPX1RED   EQU            176  read\nBPXB1REL  EQU            600  v_rel\nBPX1REN   EQU            180  rename\nBPX1RFM   EQU            544  recvfrom\nBPX1RMD   EQU            188  rmdir\nBPX1RMG   EQU              8  resource\nBPX1RMS   EQU            548  recvmsg\nBPX1RPH   EQU            884  realpath\nBPX1RWD   EQU            184  rewinddir\nBPX1SA2   EQU           1084  __sigactionset\nBPX1SCT   EQU            708  semctl\nBPX1SDD   EQU            300  set_dub_default\nBPX1SEC   EQU           1044  __security\nBPX1SEG   EQU            424  setegid\nBPX1SEL   EQU            552  select\nBPX1SEU   EQU            420  seteuid\nBPX1SF    EQU           1064  send_file PConly\nBPX1SGE   EQU            780  setgrent\nBPX1SGI   EQU            328  setgid\nBPX1SGR   EQU            792  setgroups\nBPX1SGT   EQU            712  semget\nBPX1SHT   EQU            572  shutdown\nBPX1SIA   EQU            324  sigaction\nBPX1SIN   EQU           1004  server_init\nBPX1SIP   EQU            340  sigpending\nBPX1SLK   EQU           1068  __shm_lock\nBPX1SLP   EQU            344  sleep\nBPX1SMF   EQU           1036  __smf_record\nBPX1SMS   EQU            560  sendmsg\nBPX1SND   EQU            556  send\nBPX1SOC   EQU            576  socket_pair\nBPX1SOP   EQU            716  semop\nBPX1SPB   EQU            416  sigputback\nBPX1SPE   EQU            784  setpwent\nBPX1SPG   EQU            348  setpgid\nBPX1SPM   EQU            352  sigprocmask\nBPX1SPN   EQU            760  spawn\nBPX1SPR   EQU            568  setpeer\nBPX1SPW   EQU           1008  server_pwu\nBPX1SPY   EQU            740  setpriority\nBPX1SRG   EQU            896  setregid\nBPX1SRL   EQU            816  setrlimit\nBPX1SRU   EQU            892  setreuid\nBPX1SRX   EQU           1080  srx_np\nBPX1SSI   EQU            356  setsid\nBPX1SSU   EQU            360  sigsuspend\nBPX1STA   EQU            192  stat\nBPX1STE   EQU           1076  set_timer_event\nBPX1STF   EQU             80  w_statfs\nBPX1STL   EQU            684  set_limits\nBPX1STO   EQU            564  sendto\nBPX1STR   EQU            756  setitimer\nBPX1STV   EQU            844  StatVfs\nBPX1STW   EQU           1096  sigtimedwait\nBPX1SUI   EQU            364  setuid\nBPX1SWT   EQU            468  sigwait\nBPX1SYC   EQU            368  sysconf\nBPX1SYM   EQU            196  symlink\nBPX1SYN   EQU            868  sync\nBPX1TAK   EQU           1032  takesocket\nBPX1TDR   EQU             24  tcdrain\nBPX1TFH   EQU             20  tcflush\nBPX1TFW   EQU             28  tcflow\nBPX1TGA   EQU             32  tcgetattr\nBPX1TGC   EQU            900  tcgetcp\nBPX1TGP   EQU             36  tcgetpgrp\nBPX1TGS   EQU            912  tcgetsid\nBPX1TIM   EQU            372  times\nBPX1TLS   EQU            964  tsk_lvl_sec_np\nBPX1TRU   EQU            828  truncate\nBPX1TSA   EQU             40  tcsetattr\nBPX1TSB   EQU             44  tcsendbreak\nBPX1TSC   EQU            904  tcsetcp\nBPX1TSP   EQU             48  tcsetpgrp\nBPX1TST   EQU            908  tcsettables\n          MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CREGS": {"ttr": 115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x009\\x01\\x122o\\x01\\x122o\\x14S\\x00\\x1b\\x00\\x1f\\x00\\x00\\xc5\\xe2\\xc1@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-11-21T00:00:00", "modifydate": "2012-11-21T14:53:39", "lines": 27, "newlines": 31, "modlines": 0, "user": "ESA"}, "text": "         MACRO\n         CREGS &USING\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nRDSA     EQU   R13                DSA POINTER\n         AIF  ('&USING' NE 'USING').NOUSING\n         USING DSA,R13\n.NOUSING ANOP\nR14      EQU   14\nR15      EQU   15\nFR0      EQU   0\nFR2      EQU   2\nFR4      EQU   4\nFR6      EQU   6\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHALLT": {"ttr": 65, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         IHALLT &DSECT=YES             LNKLST/LPALST tables\nLLT      DSECT\nLLTID    DS    C'LLT '                 BLOCK ACRONYM\nLLTCOUNT DS    F                       NUMBER OF ENTRIES\nLLTENTRY DS    0CL45                   DSNAME ENTRY\nLLTDSLTH DS    FL1                     DSNAME LENGTH AFTER TRUNCATION\nLLTDSN   DS    CL44                    DATA SET NAME\nLLTNEXT  EQU   *                       NEXT ENTRY\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSQLASM": {"ttr": 191, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*30/03/06 addr in r5\n*30/03/06 load RRS or CAF module\n         PRINT    GEN\n         TITLE 'SQLASM SQL IBM interface module '\n*        CREGS USING\n         CREGS USING\n*        IEANTASM\n         IEANTASM\n         MACRO\n&LABEL   STUB &INDEX=0,&LOAD=\n         LCLC &LNAME,&LRRS\n         AIF  ('&LOAD' EQ '').SETDEF\n&LNAME   SETC '&LOAD'\n         AGO  .SETOK\n.SETDEF  ANOP\n&LNAME   SETC '&LABEL'\n.SETOK   AIF   ('&LNAME' NE 'DSNALI').NALI\n&LRRS    SETC  'DSNRLI'\n         AGO   .RRSOK\n.NALI    AIF   ('&LNAME' NE 'DSNHLI2').NHLI\n&LRRS    SETC  'DSNHLIR'\n         AGO   .RRSOK\n.NHLI    ANOP\n&LRRS    SETC  'DSNTIAR'\n.RRSOK   ANOP\n&LABEL   CSECT\n&LABEL   AMODE 31\n&LABEL   RMODE ANY\n*label.E edcprlg basereg=r9,dsalen=dsalen\n&LABEL.E EDCPRLG BASEREG=R9,DSALEN=DSALEN\n.LOK     ANOP\n         L     R7,=A(LEVEL)       get const darr\n         USING LEVEL,R7           base on const\n         LR    R2,R1              save pointer\n         L     R15,X'10'           CVT\n         L     R15,X'220'(,R15)     CSR table address\n         L     R15,X'14'(,R15)      offset\n         L     R15,X'08'(,R15)      IEANTRNT\n*        CALL  (15),(LEVEL,tokenname,TOKENDATA,RETCODE),               *\n               MF=(E,CALLLIST)\n         CALL  (15),(LEVEL,TOKENNAME,TOKENDATA,RETCODE),               *\n               MF=(E,CALLLIST)\n         CHI   R15,4               check code\n         JL    OK&SYSNDX           if retrieve ok\n         XC    LOADLIST(LOADLISTL),LOADLIST clear list\n*        load  ep=userrs,erret=norrs&sysndx,sf=(e,loadlist)\n         LOAD  EP=USERRS,ERRET=NORRS&SYSNDX,SF=(E,LOADLIST)\n*        load  ep=&LRRS\n         LOAD  EP=&LRRS\n         LR    R5,R0               get addr\n         J     DOC&SYSNDX\nNORRS&SYSNDX DS 0H\n*30/03/06 addr in r5\n*        load  ep=&LNAME\n         LOAD  EP=&LNAME\n         LR    R5,R0               into r5\n         J     DOC&SYSNDX          jump to call\nOK&SYSNDX DS   0H\n          L   R15,TOKENDATA+&INDEX get proper addr\n          LR  R5,R15               save here\nDOC&SYSNDX DS  0H\n         AIF   ('&LABEL' NE 'DSNALI').NODSNALI\n         ICM   R3,15,0(R2)         get fists parm\n         JZ    NOPARM&SYSNDX       jump if no parm\n         MVC   CALLCODE,0(R3)      save call code\n         CLC   =C'IDENTIFY',0(R3)  RRS IDENTIFY (i.e connect)\n         JE    CONN&SYSNDX         connect request\n         CLC   =C'CONNECT',0(R3)   CAF connect request\n         JNE   GOON&SYSNDX         if not CAF connect\nCONN&SYSNDX  DS 0H\n         BAS   R14,RETR&SYSNDX     call to retrieve token\n         LTR   R15,R15             test code\n         JZ    ALREADY&SYSNDX      jump if already\n* start to connect\n         LR    R1,R2               back pointer\n         LR    R15,R5              back module addr\n         BASR  R14,R15             call it to connect\n         LTR   R15,R15             test rc\n         JNZ   RET&SYSNDX          jump if not o.k.\n* connection was o.k, so create token\n         BAS   R14,CREA&SYSNDX     create token\n         LTR   R15,R15             check code\n         JNZ   ERRTKN&SYSNDX       name token error\n         J     RET&SYSNDX\nNOPARM&SYSNDX DS 0H\n         L     R15,=F'-2'         parm error\n         J     RET&SYSNDX         jump out\nERRTKN&SYSNDX DS 0H\n         L     R15,=F'-3'         token error\n         J     RET&SYSNDX         jump out\nALREADY&SYSNDX L R15,=F'-1'       already connectedo\n         J     RET&SYSNDX         jump out\n.NODSNALI  ANOP\nGOON&SYSNDX DS 0H\n         LR    R1,R2               back pointer\n         LR    R15,R5              back module addr\n         BASR  R14,R15             call it\n         AIF   ('&LABEL' NE 'DSNALI').NODSNAL1\n         LR    R5,R15              save rc\n         CLC   =C'TERMINATE',CALLCODE terminate RRS\n         JE    DELDO&SYSNDX        jump if it is\n         CLC   =C'DISCONN',CALLCODE terminate CAF\n         JNE   RET&SYSNDX\nDELDO&SYSNDX DS 0H\n         BAS   R14,DELTK&SYSNDX    call to delete\n         CHI   R15,4               check code\n         JH    ERRT&SYSNDX         name/token error\n         LR    R15,R5              back\n.NODSNAL1 ANOP\nRET&SYSNDX DS  0H\n*        edcepil\n         EDCEPIL\n         AIF   ('&LABEL' NE 'DSNALI').NODSNAL2\nRETR&SYSNDX BAKR R14,0\n         L     R15,X'10'           CVT\n         L     R15,X'220'(,R15)    CSR table address\n         L     R15,X'14'(,R15)     offset\n         L     R15,X'08'(,R15)     IEANTRNT\n*        CALL  (15),(CONN_LEVEL,CONN_TOKENNAME,TOKENDATA,RETCODE),     *\n               MF=(E,CALLLIST)\n         CALL  (15),(CONN_LEVEL,CONN_TOKENNAME,TOKENDATA,RETCODE),     *\n               MF=(E,CALLLIST)\n         PR    ,\nDELTK&SYSNDX BAKR R14,0\n         L     R15,X'10'           CVT\n         L     R15,X'220'(,R15)     CSR table address\n         L     R15,X'14'(,R15)       offset\n         L     R15,X'0C'(,R15)       IEANTDL delete token\n*        CALL  (15),(conn_LEVEL,conn_tokenname,RETCODE),MF=(E,CALLLIST)\n         CALL  (15),(CONN_LEVEL,CONN_TOKENNAME,RETCODE),MF=(E,CALLLIST)\n         PR    ,\nCREA&SYSNDX BAKR R14,0             in stack\n         L     R15,X'10'           CVT\n         L     R15,X'220'(,R15)    CSR table address\n         L     R15,X'14'(,R15)     offset\n         L     R15,X'04'(,R15)     IEANTCR\n*        CALL  (15),(conn_level,conn_tokenname,tokendata,              *\n               NOPERSIST,RETCODE),MF=(E,CALLLIST)\n         CALL  (15),(CONN_LEVEL,CONN_TOKENNAME,TOKENDATA,              *\n               NOPERSIST,RETCODE),MF=(E,CALLLIST)\n         PR    ,\nERRT&SYSNDX LR R5,R15              get code\n*        ABEND (R5),DUMP,,SYSTEM,REASON=(R3)\n         ABEND (R5),DUMP,,SYSTEM,REASON=(R3)\n.NODSNAL2 ANOP\n         LTORG\n         MEND\n         MACRO\n&LABEL   RSQL\n*        EDCPRLG BASEREG=R9,DSALEN=DSALEN\n         EDCPRLG BASEREG=R9,DSALEN=DSALEN\n.RLOK    ANOP\n         L     R7,=A(LEVEL)       get const darr\n         L     R15,X'10'           CVT\n         L     R15,X'220'(,R15)    CSR table address\n         L     R15,X'14'(,R15)     offset\n         L     R15,X'08'(,R15)     IEANTRNT\n*        CALL  (15),(LEVEL,tokenname,TOKENDATA,RETCODE),MF=(E,CALLLIST)\n         CALL  (15),(LEVEL,TOKENNAME,TOKENDATA,RETCODE),MF=(E,CALLLIST)\n         CHI   R15,4               check code\n         JE    LOAD                if new token\n*        JL    DELETE              if already exits, delete\n         JH    ERRTKN              name/token err\n* already exists, check if rrs was\n         SR    R15,R15             no rrs\n         OC    TOKENDATA+12(4),TOKENDATA+12 test for RRS\n         JZ    RETRN               no rrs\n         LA    R15,4               indicate rrs\n         J     RETRN               if already exits, o.k.\nDELETE   OC    TOKENDATA+12(4),TOKENDATA+12 test for RRS\n         BZ    DNORRS              DELETE NORRS\n*        delete ep=userrs          delete userrs\n         DELETE EP=USERRS          delete userrs\n*        delete ep=dsnhlir         delete dsnhlir\n         DELETE EP=DSNHLIR         delete dsnhlir\n*        delete ep=dsnrli          delete dsnrli\n         DELETE EP=DSNRLI          delete dsnrli\n         B     DCLEAR\nDNORRS   DS    0H\n*        delete ep=dsnhli2\n         DELETE EP=DSNHLI2\n*        delete ep=dsnali\n         DELETE EP=DSNALI\nDCLEAR   DS    0H                  clear addresses\n         L     R15,X'10'           CVT\n         L     R15,X'220'(,R15)     CSR table address\n         L     R15,X'14'(,R15)       offset\n         L     R15,X'0C'(,R15)       IEANTDL delete token\n*        CALL  (15),(LEVEL,tokenname,RETCODE),MF=(E,CALLLIST)\n         CALL  (15),(LEVEL,TOKENNAME,RETCODE),MF=(E,CALLLIST)\n         CHI   R15,4               check code\n         BH    ERRTKN              name/token error\n         B     RETRN\nLOAD     DS    0H\n*        LOAD  EP=DSNTIAR          get addr\n         LOAD  EP=DSNTIAR          get addr\n         ST    R0,TOKENDATA+8      save addr\n         MVI   TOKENDATA+12,1      assume RRS\n         XC    LOADLIST(LOADLISTL),LOADLIST clear list\n*        load  ep=userrs,erret=norrs,sf=(e,loadlist)\n         LOAD  EP=USERRS,ERRET=NORRS,SF=(E,LOADLIST)\n*        load  ep=dsnrli\n         LOAD  EP=DSNRLI\n         ST    R0,TOKENDATA        save addr\n         LOAD  EP=DSNHLIR          get addr\n         ST    R0,TOKENDATA+4      save addr\n         LA    R15,4               indicate rrs\n         B     CTOKEN              branch to create token\nNORRS    XC    TOKENDATA+12(4),TOKENDATA+12 use CAF\n         LOAD  EP=DSNALI           get addr\n         ST    R0,TOKENDATA        save addr\n*        LOAD  EP=DSNHLI2          get addr\n         LOAD  EP=DSNHLI2          get addr\n         ST    R0,TOKENDATA+4      save addr\n         SR    R15,R15             no RRS\nCTOKEN   LR    R5,R15              save rc\n         L     R15,X'10'           CVT\n         L     R15,X'220'(,R15)    CSR table address\n         L     R15,X'14'(,R15)     offset\n         L     R15,X'04'(,R15)     IEANTCR\n*        CALL  (15),(LEVEL,tokenname,tokendata,nopersist,RETCODE),     *\n               MF=(E,CALLLIST)\n         CALL  (15),(LEVEL,TOKENNAME,TOKENDATA,NOPERSIST,RETCODE),     *\n               MF=(E,CALLLIST)\n         LTR   R15,R15             check code\n         JNZ   ERRTKN              name token error\n         LR    R15,R5              back rc\n         J     RETRN               jump out\n         LTORG\nLEVEL    DC    A(IEANT_TASK_LEVEL)      Task level\n*LEVEL    DC    A(IEANT_HOME_LEVEL)     Home level\nNOPERSIST DC   A(IEANT_NOPERSIST)      nopersist option\nTOKENNAME DC   CL16'ISIS_DB2CAF_TOKEN' Token name\nCONN_LEVEL DC  A(IEANT_TASK_LEVEL)      task level\nCONN_TOKENNAME DC   CL16'ISIS_DBCONN_TOKEN' Token name\nERRTKN   LR    R5,R15              get code\n*        ABEND (R5),DUMP,,SYSTEM,REASON=(R3)\n         ABEND (R5),DUMP,,SYSTEM,REASON=(R3)\n         SPACE 1\n*--------------------------------------------------------------------*\n* RETURN point                                                       *\n*--------------------------------------------------------------------*\nRETRN    DS    0H\n*exit    edcepil\nEXIT     EDCEPIL\n.RRLOK   ANOP\n         MEND\n\n*--------------------------------------------------------------------*\n*RSQLASM : ASM stub routine to provide access to the SQL functions   *\n*          from the SASC/C modules with CAF and RRS                  *\n*                                                                    *\n* Entry points :                                                     *\n*         SQLASM standard init entry point                           *\n*         if the address =0 then                                     *\n*         load the DSN.. modules and store the address list          *\n*         in the C address list                                      *\n*         if the address <>0 then                                    *\n*         delete the DSN.. modules and set the address list to zero  *\n*         in the C address list                                      *\n* The program tries to load the DSNRL interface, andif it can        *\n*     set a flag to indicate the use of the RRS                      *\n* RRS entry points:                                                  *\n*         DSNRLI  standard SQL entry point to call the DSNRLI module *\n*         DSNHLIR SQL call entry point                               *\n* CAF entry points:                                                  *\n*         DSNHLI2 standard SQL entry point to call the DSNHLI module *\n*         DSNALI standard SQL entry to call the DSNALI module        *\n* Common :                                                           *\n*         DSNTIAR to call the standard SQL message edit nodule       *\n*                                                                    *\n*                                                                    *\n* Calling: The module is called via the standard MVS convention :    *\n*          R1 points to the parameters list :                        *\n*          +0  address list pointer                                  *\n*            +0 DSNALI or DSNRLI address                             *\n*            +4 DSNHLI2 or DSNHLIR address                           *\n*            +8 DSNTIAR address                                      *\n*            +c RRS or CAF flag                                      *\n* Processing:                                                        *\n* Return : The module returns the primary return code in R15         *\n*                                                                    *\n* AMODE  : 31                                                        *\n* RMODE  : ANY                                                       *\n* rent/reus                                                          *\n*--------------------------------------------------------------------*\nDSNALI   STUB  INDEX=0            stub DSNALI\nDSNHLI   STUB  INDEX=4,LOAD=DSNHLI2 stub DSNHLI2\nDSNTIAR  STUB  INDEX=8            stub dsntiar\nSQLASM   CSECT\nSQLASM   AMODE 31\nSQLASM   RMODE ANY\n         RSQL\n         LTORG\nDSA      CEEDSA SECTYPE=OS         DSA\n*oadlist load sf=l                 load list form\nLOADLIST LOAD SF=L                 load list form\nLOADLISTL EQU *-LOADLIST           list length\nCALLLIST  DC   8A(0)               call list form\nCALLLISTL EQU  *-CALLLIST          cal list length\nTOKENDATA DC   4A(0)               token data\nRETCODE  DC    A(0)                    Return code\nCALLCODE DC    CL16' '             save callcode here\nDSALEN   EQU   *-DSA               DSECT length\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UIMASM": {"ttr": 193, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE ' UIMASM DFDSS OMVS exit'\n***********************************************************************\n*                                                                     *\n* UIMASM exit  dump/restore to HFS drives                             *\n*                                                                     *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n        PRINT ON,GEN\n        BPX1EQUS\n        BPXYCONS\n        BPXYSIGH\n***********************************************************************\n* UIMASM exit  IBM part                                               *\n*                                                                     *\n* Called from the DSSOMVS module wit UIM style parm list              *\n* The module loads/start the ADRDSSU and gets back the control via    *\n* UIM exit and call further the UIM function in C                     *\n***********************************************************************\n*IMASM   ceeentry ppa=ceeppa,nab=yes,main=no,base=(r11),               *\n               AUTO=WORKSIZE\nUIMASM   XATTR LINKAGE(OS)\n*UIM      XATTR LINKAGE(OS)\n*UIMASM    XATTR LINKAGE(XPLINK)\nUIMASM   CEEENTRY PPA=CEEPPA,NAB=YES,MAIN=NO,BASE=(R11),               *\n               AUTO=WORKSIZE\n         USING WORK,R13           base on work area\n         USING PSA,R0             base on PSA\n         STM   R0,R15,ENTRYREGS   back entry regs\n         ST    R1,EPARM           save entry parm list\n         MVC   PARMLIST(20),0(R1) copy parm list\n* set default dub to DUBTASKACEE\n         L     R14,FLCCVT         get CVT common vector table\n         L     R14,544(R14)       get CSRTABLE\n         L     R14,24(R14)        CSR slot list\n         L     R15,BPX1SDD(,R14)  get BPX1SDD address\n*        CALL  (15),(=A(DUBTASKACEE),                                  *\n               RETURN_VALUE,RETURN_CODE,REASON_CODE),VL,               *\n               MF=(E,CALL_S1DD)\n         CALL  (15),(=A(DUBTASKACEE),                                  *\n               RETURN_VALUE,RETURN_CODE,REASON_CODE),VL,               *\n               MF=(E,CALL_S1DD)\n         ICM   R0,15,RETURN_VALUE    get reurn value\n         JZ    DUBOK                 jump if it was o.k\n         DC    A(0)                  dump from here\nDUBOK    DS    0H\n*        load  eploc=epadrdssu       load adrdssu\n         LOAD  EPLOC=EPADRDSSU       load adrdssu\n         LTR   R15,R15            test return\n         JNZ   ERR_LOAD           if not o.k.\n         ST    R0,ADRDSSU         save addr\n         SPACE 1\n         MVC   DSSCUIM,=AL2(DSSCUIML) set length\n         LA    R1,UIMEXIT         get uim exit address\n         ST    R1,DSSCUIMA        save exit address\n         OI    DSSCUIMA,X'80'     indicate 31 bit mode\n         LA    R1,DSSCUIM         get UIM exit address pointer\n         ST    R1,PARMLIST+12     set in parmlist\n         SPACE 1\n         L     R1,PARMLIST+16     get user area address\n         MVC   USERAREA,2(R1)     save userarea\n         MVC   DSSCDATA,=AL2(DSSCDATAL) set length\n         LA    R1,DSSCDATA        get exit parm pointer\n         ST    R1,PARMLIST+16     save in parmlist\n         OI    PARMLIST+16,X'80'  high order bit in parmlist\n         ST    R13,DSSCDATAA      save work area address\n         BAS   R14,CALLDSS        call DSS\n         J     RET                call return\n         SPACE 1\nCALLDSS  BAKR  R14,0              all in stack\n         LA    R1,PARMLIST        get parmlist address\n         L     R15,ADRDSSU        get module address\n         LA    R13,CALLSAVE       new save are\n         BASR  R14,R15            call adrdssu module\n         PR    ,                  return back\nERR_LOAD DS 0H\n*rr_load  CALL  CEEMOUT,(unable,ceedest),VL,MF=(E,CALLMOUT)\n*ERR_LOAD  CALL  CEEMOUT,(UNABLE,CEEDEST),VL,MF=(E,CALLMOUT)\n         ABEND 001,DUMP,,SYSTEM,REASON=0001\n         LA    R15,8              get code\n*ET      ceeterm rc=(r15)         epilog\nRET      CEETERM RC=(R15)         epilog\n         USING ADREIB,R10         base on UIM exit parm list\nUIMEXIT  STM   R14,R12,12(R13)     save regs\n         L     R11,UIMASMA-UIMEXIT(R15) back base\n         L     R10,0(,R1)         get UIM parm address\n         LR    R0,R13             new save area address here\n         ICM   R13,15,EIUSEPTR    back r13 from\n         ST    R0,NEWSAVE         save new save address\n         ST    R1,UIMPARM         save UIM parm\n         MVC   EIUSEPTR,USERAREA  set user area\n         LR    R2,R10             save UFO base\n         LR    R3,R13             save save area\n         BAS   R14,CALLBACK       callback routinr\n         LR    R10,R2             back UFO\n         LR    R13,R3             back save\n         STCM  R13,R15,EIUSEPTR   set back our pointer\n         L     R13,NEWSAVE        save new save address\n         ST    R15,16(R13)         store code\n         LM    R14,R12,12(R13)     back regs\n         BSM   0,R14              back from the routine\nCALLBACK STM   R14,R12,CALLREGS   all in save area\n         LM    R4,R15,ENTRYREGS+4*4   back entry regs\n         L     R15,UIM            get UIM address\n         L     R1,UIMPARM         get UIM address\n         BALR  R14,R15            call it\n         LM    R14,R12,CALLREGS   back all\n         BSM   0,R14              back all\n*eeppa   ceeppa  ,                prolog area\nCEEPPA   CEEPPA  ,                prolog area\nEPADRDSSU DC   CL8'ADRDSSU'       module address\nUIM      DC    V(UIM)             UIM function pointer\nCEEDEST  DC    A(2)               message dest code\nUIMASMA  DC    A(UIMASM)          module start address\nUNABLE   DC    Y(UNABLEME-UNABLEME) length\nUNABLEM  DC    C' unable to load ADRDSSU'\nUNABLEME EQU  *\n         LTORG\nWORK     DSECT\n         ORG  *+CEEDSASZ         space for fix part of DSA\nCALLSAVE  DC  18A(0)             call save area\nPARMLIST DC    5A(0)             parmlist with 5 entries\nEPARM    DC    A(0)              entry parm\n         CNOP  2,4               align half word\nDSSCUIM  DC    AL2(DSSCUIML)     length\nDSSCUIMA DC    AL4(0)            MODULE address\nDSSCUIML EQU   *-DSSCUIMA        length def\n         CNOP  2,4               align half word\nDSSCDATA  DC   AL2(DSSCDATAL)    length\nDSSCDATAA DC   AL4(0)            address\nDSSCDATAL EQU  *-DSSCDATAA       length\nADRDSSU  DC    A(0)              adrdssu address\n*ALLMOUT CALL  ,(,,),VL,MF=L     3-argument parameter list\nCALLMOUT CALL  ,(,,),VL,MF=L     3-argument parameter list\nUSERAREA  DC  A(0)               user area pointer\nNEWSAVE   DC  A(0)               secondary save\nENTRYREGS DC  16A(0)             entry regs from C/C++\nUIMPARM  DC    A(0)              UIM parm\nCALLREGS  DC  18A(0)             call save area\nRETURN_VALUE DC A(0)             return value\nRETURN_CODE  DC A(0)             return code\nREASON_CODE  DC A(0)             reason code\nCALL_S1DD CALL ,(,,,,),VL,MF=L\nWORKSIZE EQU  *-WORK             work area size\n*        ceecaa ,\n         CEECAA ,\n*        ceedsa ,\n         CEEDSA ,\n*        ADREID0\n         ADREID0\n         PRINT OFF,NOGEN\n         CVT   DSECT=YES\n         IHAPSA\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT880/CBT.V500.FILE880.PDS/ASM.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT880/CBT.V500.FILE880.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}