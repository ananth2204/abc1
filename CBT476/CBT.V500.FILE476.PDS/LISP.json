{"INMR01": {"INMLRECL": 80, "INMFNODE": "CSDLMVS", "INMFUID": "SEB1525", "INMTNODE": "MVS", "INMTUID": "CSDL", "INMFTIME": "20001019092545000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2292654, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 6233, "INMRECFM": "VB", "INMDIR": 75, "INMDSNAM": "PROGLIB.ZILCBT.LISP", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2292654, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2292654, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"PROGLIB.ZILCBT.LISP": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6233, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "000293", "DS1SCEXT": "b'\\x80\\x18Y'", "DS1SCALO": "b'P\\x00\\x002'", "DS1LSTAR": "b'\\x00*\\x05'", "DS1TRBAL": "b'~\\xb4'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xfd\\x00\\x00\\x00\\x8f\\x19 \\x00\\x04\\x9e\\xe00'", "extents": ["b'\\x02\\x00\\x00\\x00\\xfd\\x00\\x00\\x00\\x8f\\x19 \\x00\\x04\\x9e\\xe00'", "b'X\\xf3T\\x18\\x00\\x00\\x01\\x18\\x00\\n\\x01\\x1b\\x00\\x06\\x00*'", "b'X\\xf3T\\x18\\x00\\x00\\x01\\x1b\\x00\\x07\\x01\\x1b\\x00\\r\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"APPEND": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t)\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:29:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"APPEND\"\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; APPEND as a macro that expands into the requisite number of calls\n;;; to APPEND2.\n;;;\n\n(defun append (&rest x) (append-list x))\n\n(defun append-list (x)\n (cond\n  ((null x)        nil)\n  ((null (cdr x))  (append2 (zcar x) nil))\n  ((null (cddr x)) (append2 (zcar x) (zcadr x)))\n  (t               (append2 (zcar x) (append-list (cdr x)))))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "APPLY": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t)\\x00'\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:29:00", "lines": 39, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; APPLY\n;;;\n\n; No capability exists of specifying an environment.\n; If you need one, use ZILAPPLY.\n\n(defun apply (f &rest l)\n (cond\n  ((null l)               ; (apply #'foo)\n   (zerror \"Too few arguments - APPLY\"))\n  ((null (cdr l))         ; (apply #'foo list1)\n   (and (atom (zcar l))\n        (not (null (zcar l)))\n        (zerror \"Last arg to APPLY not a list\" (zcar l)))\n   (zilapply f (zcar l)))\n  (t                      ; (apply #'foo list1 ... listn)\n   (do ((l l (cdr l))\n        (y)\n        (z nil\n           (if z\n               (setf (cdr z) (ncons (zcar l)))\n               (setf y (ncons (zcar l)))))\n       )\n       ((null (cdr l))\n        (and (atom (zcar l))\n             (not (null (zcar l)))\n             (zerror \"Last arg to APPLY not a list\" (zcar l)))\n        (rplacd z (zcar l))\n        (zilapply f y))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "APROPOS": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t)\\x00(\\x00\\x0b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:29:00", "lines": 40, "newlines": 11, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; Actually, this is not Common LISP APROPOS, but APROPOS-LIST.\n;;; APROPOS is supposed to print out information about each symbol.\n\n;;; Reference: CLtL (Steele, 1984), p. 443.\n\n\n(defun apropos (symbol-or-string)\n (or (stringp symbol-or-string)\n     (symbolp symbol-or-string)\n     (zerror \"Arg to APROPOS not a string or symbol\" symbol-or-string))\n\n (do ((symbols (oblist) (cdr symbols))\n      (argument-string (string-upcase symbol-or-string))\n      (z nil)\n     )\n     ((null symbols) (nreverse z))\n     (and\n          (string-index (string-upcase (zcar symbols)) argument-string)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;       ; ; The following weeds out TWA's.\n; Don't ; ; FBOUNDP is commented out because currently all function\n;  do   ; ; definitions are global, and (more important) there is a\n; this, ; ; serious bug in ZIL such that doing FBOUNDP on an atom\n; since ; ; like ZILIN crashes the ZIL system.\n;  CL   ; ;\n; does  ; (or (symbol-plist (zcar symbols))\n;  not  ;     (boundp (zcar symbols))\n;  say  ;     (featurep (zcar symbols))\n;  so.  ;  ;;;(fboundp (zcar symbols)))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n          (push (zcar symbols) z))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ARGS": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t0\\x00@\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 64, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ARGS\n;\n; This is a Maclisp function defined as follows:\n;\n; (ARGS funname) returns:\n; (NIL . n) if funname takes n required args and no &optional args\n; (m . n)   if funname takes m required args and (n-m) &optional args\n; (m . #o776) if funname takes m required args and any &rest args\n;             (the #o776 is a hack used in Maclisp - don't question it)\n;\n; (ARGS funname data) is not supported, but returns funname.\n;\n; Only compiled code funname's are supported at this time.\n;\n; This function exists only because of Macsyma.  Therefore, it also\n; performs the function of assigning the LOADFILE property, since it\n; is generated in translated Macsyma code.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/28/88 - Corrected bug in specification of *loadfile* variable.   *\n;*                                                                     *\n;***********************************************************************\n;\n\n (declare (special *loadfile*))\n\n (defun args (f &optional (d nil d?) &aux x)\n  (cond\n   ((symbolp f)\n    (fboundp f))  ; Invoke function autoloading process.\n   ((not (codep f))\n    (zerror \"Argument to ARGS not a valid function name\" f))\n  )\n  (cond\n   (d?\n    (and d (warn \"Number of args cannot be updated\" f d))\n    (when *loadfile* (putprop f *loadfile* 'loadfile))\n    f)\n   ((setq x (if (codep f) f (get f 'subr)))\n    (let (\n          (minargs (minargs x))\n          (maxargs (maxargs x))\n          (restarg (restarg x))\n         )\n         (cond\n          (restarg                (cons minargs #o776))\n          ((eql minargs maxargs)  (cons nil minargs))\n          (t                      (cons minargs maxargs)))))\n   (t\n    (warn \"ARGS not supported, not a compiled function\" f)\n    nil)))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ASSOC": {"ttr": 537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\t/\\x00\\x89\\x15o\\t0\\x00J\\x00<\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-04-01T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 74, "newlines": 60, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;---------------------- Common LISP ASSOC ----------------------------\n\n;======================================================================\n\n(defmacro assoc-loop (test key testnotp)\n (let ((comparison (let ((x\n                           ;\n                           ; OK, which is it?\n                     ;;;   ;\n                     ;;;   ; (1) No :key?\n                     ;;;   ;\n                     ;;;  `(,@test item (zcar elt))\n                     ;;;   ;\n                     ;;;   ; (2) :key applied instead of the CAR?\n                     ;;;   ;\n                     ;;;  `(,@test item ,(if key `(zcar elt)\n                     ;;;                         `(,@key elt)))\n                           ;\n                           ; (3) :key applied to the CAR of the element?\n                           ;\n                          `(,@test item ,(if key `(,@key (zcar elt))\n                                                 `(zcar elt)))\n                           ;\n                           ; I'm going with (3) - seems to be correct.\n                           ;\n                          ))\n                        (if testnotp `(not ,x) x))))\n  `(and alist\n    (prog (elt)\n      loop\n          (cond\n           ((and (setq elt (zcar alist))\n                 ,comparison)\n            (go true))\n           ((setq alist (cdr alist))\n            (go loop))\n           (t\n            (return nil)))\n      true\n         (return elt)))))\n\n;======================================================================\n\n (defun assoc (item alist &key (test nil test?)\n                              (test-not nil test-not?)\n                              (key nil key?)  ; what does :key do???\n              )\n\n  (cond\n   ((and test? test-not?)\n    (zerror \"Both :TEST and :TEST-NOT keywords given to ASSOC\"))\n   ((not (listp alist))\n    (zerror \"Argument 2 to ASSOC not a list\" alist))\n   (test-not?\n    (if key?\n        (assoc-loop (funcall test-not) (funcall key) t)\n        (assoc-loop (funcall test-not) nil           t)))\n   (test?\n    (if key?\n        (assoc-loop (funcall test)     (funcall key) nil)\n        (assoc-loop (funcall test)     nil           nil)))\n   (t\n    (if key?\n        (assoc-loop (eql)              (funcall key) nil)\n        (assoc-loop (eql)              nil           nil)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ASSQL": {"ttr": 539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t0\\x00\\x17\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 23, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ASSQL\n;\n; This is equivalent to Common LISP (ASSOC A B :TEST #'EQL)\n;\n\n(defun assql (x y)\n (prog (a)\n  loop (when y\n             (unless (and (setq a (zcar y))\n                          (eql x (zcar a)))\n                     (setq y (cdr y))\n                     (go loop))\n             (return a))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASSQUAL": {"ttr": 541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t0\\x00&\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 38, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ASSQUAL\n;\n; This is equivalent to Common LISP (ASSOC A B :TEST #'EQUAL)\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/11/88 - Recoded to compile into faster (?) code.                 *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun assqual (item alist)\n (and alist\n  (prog (elt)\n    loop\n        (cond\n         ((and (setq elt (zcar alist))\n               (equal item (zcar elt)))\n          (go true))\n         ((setq alist (cdr alist))\n          (go loop))\n         (t\n          (return nil)))\n    true\n        (return elt))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BIGNUM": {"ttr": 543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x15?\\x00\\x89\\x15o\\t0\\x00\\x0c\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-01T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 12, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun bignum (&rest z)\n (mkbignum z)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BOOLE": {"ttr": 545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t0\\x001\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 49, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun boole (op &rest ints)\n (cond\n  ((or (null ints) (null (cdr ints)))\n   (zerror \"Too few arguments\" 'boole))\n  ((null (cddr ints))\n   (zilbool op (zcar ints) (zcadr ints)))\n  (t\n   (prog (v)\n         (setq v (zcar ints))\n     loop\n         (or (setq ints (cdr ints))\n             (return v))\n         (setq v (zilbool op v (zcar ints)))\n         (go loop)))))\n\n; ZILBOOL is assembler code that corresponds to the following...\n\n;;; (defun zilbool (op int1 int2)\n;;;  (case op\n;;;        (#B0000   #X00000000)\n;;;        (#B0001   (logand int1 int2))\n;;;        (#B0010   (logand (lognot int1) int2))\n;;;        (#B0011   int2)\n;;;        (#B0100   (logand int1 (lognot int2)))\n;;;        (#B0101   int1)\n;;;        (#B0110   (logxor int1 int2))\n;;;        (#B0111   (logior int1 int2))\n;;;        (#B1000   (lognot (logior int1 int2)))\n;;;        (#B1001   (lognot (logxor int1 int2)))\n;;;        (#B1010   (lognot int1))\n;;;        (#B1011   (logior (lognot int1) int2))\n;;;        (#B1100   (lognot int2))\n;;;        (#B1101   (logior int1 (lognot int2)))\n;;;        (#B1110   (lognot (logand int1 int2)))\n;;;        (#B1111   -1)\n;;;        (t (error \"Invalid BOOLE operator\" op))))\n;;;\n;;; (defmacro lognot (i)\n;;;  `(logxor ,i -1)\n;;; )\n;;;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "BOUNDP": {"ttr": 547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t0\\x009\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 57, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; BOUNDP returns true if the specified symbol currently has a\n;;; SPECIAL (dynamically bound) value (in other words, there is\n;;; a current special binding or global binding, and the value of\n;;; this binding is not the \"unbound\" marker).\n;;;\n;;; Notes:\n;;;\n;;;   Since BOUNDP calls ZEVSYM, it has the capability\n;;;   of invoking the symbol-autoloading process.  Compare FBOUNDP.\n;;;\n;;; When shallow binding is implemented, this version of the function\n;;; will disappear, to be replaced by an assembler-coded function\n;;; (and an inline-coded compiler-generated code sequence as well)\n;;; which will load the value cell of the symbol and test it for\n;;; unboundedness.  Something like this:\n;;;\n;;;  L    14,=A(symbol)\n;;;  ICM  reg,15,##PVALUE(14)\n;;;  BNM  true\n;;;  BM   false\n;;;\n;;; or, if symbol-autoloading is to be supported by BOUNDP:\n;;;\n;;;  L    14,=A(symbol)\n;;;  ICM  reg,15,##PVALUE(14)\n;;;  BALR 0,0      ... so the handler knows where to return to\n;;;  BM   4(,reg)  ... or whatever, to branch to unbound-variable\n;;;                ... handling in non-error-signalling mode\n;;;                ... which will reissue the ICM to set condition code\n;;;  BNM  true\n;;;  BM   false\n;;;\n;;;  If BOUNDP is not autoloading, there will have to be a different\n;;;  means of causing symbol-autoload to take place.  Obviously, if\n;;;  it exists at all, it will be triggered by simple reference to\n;;;  the value of a symbol (or SYMEVAL).  Whether BOUNDP will be\n;;;  capable of it is debatable.\n;;;\n\n(defun boundp (a &aux b)\n (cond\n  ((not (symbolp a))\n   (warn \"Argument to BOUNDP not a symbol\" a)\n   nil)\n  ((atom (setq b (zevsym a)))          ; Search \"special\" bindings only\n   nil)\n  (t t)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "CEILING": {"ttr": 549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87(\\x7f\\x00\\x89\\x15o\\t0\\x00\\x13\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1989-06-05T09:30:00", "lines": 19, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun ceiling (x &optional (y nil y?))\n (if y?\n     (let ((q (zilfix (/ (if (and (integerp x) (integerp y))\n                             (float x)\n                             x)\n                         y)\n                      8)))\n          (values q (- x (* q y))))\n     (let ((q (zilfix x 8)))\n          (values q (- x q)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CLOSE": {"ttr": 551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x06\\x9f\\x00\\x89\\x15o\\t1\\x00\\x1c\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-03-10T00:00:00", "modifydate": "1989-06-05T09:31:00", "lines": 28, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; CLOSE accepts the same file types as OPEN.\n;;; Modes are passed as a fixnum with the following bit settings:\n;;;\n;;; Bit 31:     0 = input, 1 = output\n;;; Bit 30:     1 = append\n;;; Bits 0-29:  reserved\n;;;\n\n(defargs zilclose 2 2 nil)\n\n(defun close (file &optional (mode 'in))\n (zilclose file (case (if (atom mode) mode (car mode))\n                      ((nil in input)         #b  00)\n                      ((out output)           #b  01)\n                      ((append :append)       #b  11)\n                      ((:in :input)           #b  00)\n                      ((:out :output)         #b  01)\n                      (t (zerror \"CLOSE: Undefined type\" mode)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "CLRSCRN": {"ttr": 553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x880\\x7f\\x00\\x89\\x15o\\t1\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-02T00:00:00", "modifydate": "1989-06-05T09:31:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun clrscrn ()\n (zcprint nil t #.%%%clrscrn)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONCAT": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t1\\x00\\x12\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:31:00", "lines": 18, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; CONCAT\n;\n; This definition is the same as Franz LISP CONCAT, created for OPS5.\n;\n; It takes any number of atoms (not lists, vectors or funargs)\n; and makes an interned symbol out of them.\n;\n\n(defun concat (&rest a) (concatl a))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONCATL": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87$o\\x00\\x89\\x15o\\t1\\x00\\x0b\\x00\\x05\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-03T00:00:00", "modifydate": "1989-06-05T09:31:00", "lines": 11, "newlines": 5, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun concatl (a)\n (zilimpl a t nil))    ; list to interned symbol\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COPYENV": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x12\\x0f\\x00\\x89\\x15o\\t1\\x00 \\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-04-30T00:00:00", "modifydate": "1989-06-05T09:31:00", "lines": 32, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; COPY-ENVIRONMENT\n;;;\n;;; This function builds an evaluation environment which contains the\n;;; same components as another evaluation environment.\n;;;\n;;; All ZIL 1.3 code that needs to copy an environment should\n;;; call this function.\n;;;\n;;; It takes 1 required arg - the environment to be copied.\n;;;\n\n(defmacro copy-environment-by-type (x)\n (let ((typical-env (funenv #'foo)))\n      (cond\n       ((listp typical-env)\n        `(append ,x nil))\n       (t (zerror \"Environment is not a list, can't generate COPYENV.\")\n  ))))\n\n(defun copyenv (env)\n (copy-environment-by-type env)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "COPYSYM": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t1\\x00?\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:31:00", "lines": 63, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; Note: MACSYMA uses a function COPYSYMBOL.  There will have to be\n;;;       a DEFLOAD of COPYSYMBOL to COPYSYM in the Macsyma\n;;;       compatibility macro file.\n\n(defun copy-symbol (a b)\n (unless (symbolp a) (zerror \"Arg 1 to COPY-SYMBOL not a symbol\" a))\n (let ((z (make-symbol a)))\n      (when b\n            (setf (symbol-plist z) (copy-list (symbol-plist a)))\n      ;;;;;\n      ;;;;; Implement the following line for deep binding.\n      ;;;;;\n            (if (boundp a)\n                (set z (symeval a))\n                ;; else leave z unbound\n            )\n      ;;;;;\n      ;;;;; Implement the following line for current deep binding.\n      ;;;;;\n            (setpbind z (pbind a))\n      ;;;;;\n      ;;;;; Implement the following line for shallow binding.\n      ;;;;;\n      ;;;;; (setf (symbol-value z) (symbol-value a))\n      ;;;;;\n      ;;;;; Copy the function definition... this code stinks, I know.\n      ;;;;;\n            (let (f)\n                 (cond\n                  ((setq f (get a 'subr))\n                   (setf (get z 'subr) f))\n                  ((setq f (get a 'expr))\n                   (setf (get z 'expr) f))\n                  ((setq f (get a 'macro))\n                   (setf (get z 'macro) f))\n                  ((setq f (get a 'fexpr))\n                   (setf (get z 'fexpr) f))\n                 ))\n      ;;;;;\n      ;;;;; Implement the following line only if using function cells.\n      ;;;;;\n      ;;;;; (setf (symbol-function z) (symbol-function a))\n      )\n      z)\n)\n\n(defload copy-symbol copysym)\n\n;\n; The following macros will not be necessary with a full Common Lisp.\n;\n\n(defmacro copy-list   (x) `(append ,x nil))\n(defmacro make-symbol (x) `(make-atom (symbol-name ,x) nil nil))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "COPYTREE": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t2\\x00\\x16\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 22, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This function is used to make a complete copy of a LISP list.  This\n; may be necessary in some compiled functions in order to prevent\n; lossage due to updating compiled-code constant lists.\n;\n\n(defun copy-tree (x)\n (if (atom x)\n     x\n     (cons (copy-tree (zcar x))\n           (copy-tree (cdr x)))))\n\n(defload copy-tree copytree)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CTERPRI": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x18\\x8f\\x00\\x89\\x15o\\t2\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-07-07T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun cterpri (&optional f)\n (zcprint nil f #.%%%cterpri)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFINE": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t2\\x00\\x12\\x00\\x0c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 18, "newlines": 12, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;\n;; (DEFINE  '(...DEF1... ...DEF2... ...DEF3...))\n;;\n\n\n(defargs deflist 2 2 nil)\n\n(defun define (funs)\n (deflist funs 'expr)\n)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFLIST": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t2\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;\n;; (DEFLIST '(...DEF1... ...DEF2... ...DEF3...) PROPERTY)\n;;\n;; This and DEFINE exist only for compatibility with 1.5-style LISPs.\n;;\n\n(defun deflist (funlist prop)\n (loop for (f-name f-lambda-exp) in funlist\n       collect f-name\n       do (putprop f-name f-lambda-exp prop)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFRDMAC": {"ttr": 785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t2\\x003\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 51, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;\"DEFRDMAC\"\n;\n; This EXPR defines a reader macro, which may be a function name or\n; a LAMBDA-expression.\n;\n; It uses the underlying low-level routine RDRMACRO to define the\n; character specified as associated with the ZRMAPPLY SUBR, which\n; applies the (possibly interpretive) function specified.\n;\n; The character must be an interned symbol with a one-character\n; print name.\n;\n; The function must take one argument, which will be bound to the\n; file name currently in use by READ when the macro is executed.\n;\n; Example:\n;\n; (defrdmac '|?| '(lambda (f) (cons 'questionmark (read f))))\n;\n; A FEXPR to permit quoteless defining of reader macros could be:\n;\n; (defun defrdrmacro fexpr (x)\n;  (cond\n;       ((and x (cdr x) (null (cddr x))) (defrdmac (car x) (cadr x)))\n;       (t (error \"Wrong number of arguments - DEFRDRMACRO\"))))\n;\n;\n\n(defargs zrmapply 1 1 nil)\n\n(defun defrdmac (c f)\n (rdrmacro c (subr zrmapply))\n (putprop '*readermacro* f (rdmac-symbol c))\n c\n)\n\n(defun rdmac-symbol (c)\n (cond\n  ((symbolp c) c)\n  ((stringp c) (intern c))\n  ((fixnump c) (ebcdic c t))\n  (t (zerror \"DEFRDMAC: Invalid reader macro character\" c))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "DELQL": {"ttr": 787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t2\\x000\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 48, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; Destructive REMQL.\n;\n; This is equivalent to Common LISP (DELETE A B :TEST #'EQL)\n;\n\n(defun delql (a b &optional c)\n\n ; a = the object to be searched for.\n ; b = the list to delete it from.\n ; c = a count of occurrences, default = delete all occurrences.\n\n (prog (m n z)\n       (setq m nil\n             n b\n             z b)\n       (when c\n             (or (fixnump c)\n                 (zerror \"Invalid DELQL count argument\" c))\n             (or (plusp c) (return z)))\n  loop (or n (return z))\n\n;\n; ... warning - no check for atomic n (sublist of b) ...\n;\n\n       (if   (eql a (zcar n))\n        then\n             (setq n (cdr n))\n             (if m (rplacd m n)\n                   (setq z n))\n             (when c\n                   (if (zerop (setq c (1- c)))\n                       (return z)))\n        else\n             (setq m n\n                   n (cdr n))\n       )\n       (go loop)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "DELQUAL": {"ttr": 789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t2\\x000\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 48, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; Destructive REMQUAL.\n;\n; This is equivalent to Common LISP (DELETE A B :TEST #'EQUAL)\n;\n\n(defun delqual (a b &optional c)\n\n ; a = the object to be searched for.\n ; b = the list to delete it from.\n ; c = a count of occurrences, default = delete all occurrences.\n\n (prog (m n z)\n       (setq m nil\n             n b\n             z b)\n       (when c\n             (or (fixnump c)\n                 (zerror \"Invalid DELQUAL count argument\" c))\n             (or (plusp c) (return z)))\n  loop (or n (return z))\n\n;\n; ... warning - no check for atomic n (sublist of b) ...\n;\n\n       (if   (equal a (zcar n))\n        then\n             (setq n (cdr n))\n             (if m (rplacd m n)\n                   (setq z n))\n             (when c\n                   (if (zerop (setq c (1- c)))\n                       (return z)))\n        else\n             (setq m n\n                   n (cdr n))\n       )\n       (go loop)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ED": {"ttr": 791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t2\\x00;\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 59, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n\n(declare (special *version*))\n\n(defun ed (&optional a &aux (edds \"SPFTEMPZ.ZILEDIT.LISP\"))\n (unless (ispfp)\n  (zerror \"ED not available - enter ZIL under ISPF to use ED.\"))\n (cond\n  ((null a)     (ed-nil edds))\n  ((symbolp a)  (ed-fun-def a edds))\n  ((stringp a)  (clrscrn)\n                (ziledit a)\n                a)\n  (t (zerror \"Arg to ED not a string (dsname) or symbol (function)\" a))\n )\n)\n\n(defun ed-nil (edds)\n (unless (open edds 'probe)              ; If dataset doesn't exist\n         (close (open edds 'out) 'out))  ; then create a new one\n (clrscrn)\n (when (ziledit edds)                    ; Edit the data set.\n       (load edds))                      ; If changed, load it.\n t\n)\n\n(defun ed-fun-def (def edds)\n      (with-open-file (file edds 'out)\n       (terpri file)\n       (princ \";\" file)\n       (terpri file)\n       (princ \"; ZIL \" file)\n       (princ *version* file)\n       (princ \" - definition of function \" file)\n       (princ def file)\n       (terpri file)\n       (princ \";\" file)\n       (terpri file)\n       (terpri file)\n       (unless (ok (zilpp def file))\n        (princ \"; Function definition not found\" file)\n        (terpri file)\n        (princ \"; (undefined, compiled or internal subroutine)\" file)\n        (terpri file))\n       (terpri file)\n      )\n      (clrscrn)\n      (when (ziledit edds)\n            (load edds))\n      def\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ENDREAD": {"ttr": 793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\t2\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:32:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun endread (&optional file)\n (zcread file #.%%endread nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EOF": {"ttr": 795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\t3\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun eof (&optional file)\n (zcread file #.%%eof nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EQUAL": {"ttr": 797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00\\x14\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 20, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; Note: Two atoms are EQUAL only if they are EQL.\n;;;\n\n(defun equal (a b)\n (or\n  (eql a b)\n  (and (consp a)\n       (consp b)\n       (equal (zcar a) (zcar b))\n       (equal (cdr a) (cdr b)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EQUALP": {"ttr": 799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\"\\x9f\\x00\\x89\\x15o\\t3\\x00\"\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-08-17T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 34, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This is as close to Common Lisp EQUALP as I can get right now.\n;;;\n\n(eval-when (compile)\n (deftrans car (x) `(zcar . ,(cdr x)))\n)\n\n(defun equalp (a b)\n (or\n  (and (numberp a)\n       (numberp b)\n       (zilequal a b))\n  (and (consp a)\n       (consp b)\n       (equalp (car a) (car b))\n       (equalp (cdr a) (cdr b)))\n  (and (stringp a)\n       (stringp b)\n       (eql (string-upcase a) (string-upcase b)))\n  (and (vecp a)\n       (vecp b)\n       (equalp (vlist a) (vlist b)))\n  (eql a b)\n ))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ERROR": {"ttr": 801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00:\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 58, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; ERROR\n;;;\n;;; This is the Common Lisp compatible ERROR function.  It uses FORMAT\n;;; to process the error message string.  However, it also attempts to\n;;; be compatible with earlier ZIL (and Maclisp) calls to ERROR by\n;;; passing control to ZERROR if the input is not in what appears to\n;;; be Common LISP ERROR format.\n;;;\n;;; Reference: CLtL, 1st ed., pp. 429-430.\n;;;\n\n(defmacro apply-format (dest format-string args)\n `(zfmexec ,dest (zfmpars ,format-string) ,args))\n\n(defmacro nl () #.(string #\\nl))\n\n(defun error (&optional (format-string nil fs?) &rest args)\n (cond\n  ((not fs?)\n   (zerror))\n  ((or (consp format-string)\n       (and args (null (string-index format-string \"~\"))))\n   (apply #'zerror format-string args))\n  (t\n   (if (ok (error-do-it format-string args))\n       (zerror)\n       (zerror \"Error while formatting error string\"\n                format-string args)))))\n\n(defun error-do-it (format-string args)\n (when (< (msglevel) 3)\n  (error-princ-indented-string (apply-format nil format-string args))))\n\n(defun error-princ-indented-string (string &aux (prefix \";Error: \"))\n (cterpri)\n (cond\n  ((null (string-index string (nl)))\n   (cterpri)\n   (princ prefix)\n   (princ string))\n (t\n  (princ prefix)\n  (dotimes (i (string-length string))\n           (let ((c (char string i)))\n                (tyo c)\n                (when (eql c #\\nl)\n                      (princ \";       \"))\n                )))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "EVAL": {"ttr": 803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00/\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 47, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; EVAL\n;\n; Notes:\n;\n; EVAL used to use a first-time-switch in the form of the property list\n; of the atom *EVAL*.  If this was the first invocation of EVAL, ZEVINIT\n; would be called to establish the standard macro and function\n; definitions used by the evaluator.\n;\n; The check for a null PLIST was used instead of calling GET because\n; it was faster than the subroutine call generated by GET.\n;\n; This has been removed.  It will be the responsibility of every\n; ZIL toplevel to invoke ZEVINIT to get things going.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;(eval-when ()\n; #.(defvar evsym\n;                 #+ZILCO '*eval*\n;                 #-ZILCO '*interpretive-eval*\n;  \"The symbol used to keep track of EVAL initialization.\"\n;   )\n;)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;(unless (symbol-plist '#.evsym)      ; If *eval* has no properties,\n;        (zevinit)                    ; define standard functions, etc.\n;        (defprop #.evsym t t))       ; set \"t\" property true\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun eval (x &optional a)\n\n (zileval x (mknewenv a) t) ; Always evaluate at \"top level\".\n\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "EVERY": {"ttr": 805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00/\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 47, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"EVERY\" - an iterator a la NIL, viz.\n;\n; (EVERY #'foo-p list1 list2 ...) returns t if foo-p is true of all\n;                                 of the element(s).\n;\n; The compiler really ought to transform this into inline code,\n; a la the mapping functions.\n;\n\n(defun every1 (fun lis) ; case of 1 list.\n (cond\n  ((null lis) t)\n  ((atom lis) (zerror \"Argument 2 to EVERY not a list\" lis))\n  (t\n   (prog ()\n    loop (when (funcall fun (car lis))\n               (when (setq lis (cdr lis))\n                     (go loop))\n               (return t))\n         (return nil)))))\n\n(defun every (fun &rest lists) ; case of multiple lists.\n (cond\n  ((null lists)       t)\n  ((null (cdr lists)) (every1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to EVERY\" list)))\n   (prog ()\n    loop (when (mapor #'null lists) (return t))\n         (unless (zilapply fun (mapcar #'car lists))\n                 (return nil))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "EXPLODE": {"ttr": 807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00\\r\\x00\\n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 13, "newlines": 10, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun explode (x)    ;PRIN1-style interned symbols\n (cond\n  ((or (consp x) (vecp x)) (zilexpl (prin1-to-string x) t nil))\n  (t                       (zilexpl x t t))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXPLODEC": {"ttr": 809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00\\x11\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 17, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun explodec (x)    ;PRINC-style interned symbols\n (zilexpl\n          (cond\n           ((or (consp x) (vecp x))  (princ-to-string x))\n           (t                        x))\n          t            ; type is interned symbol\n          nil          ; style is PRINC\n ))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXPLODEN": {"ttr": 811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00\\x11\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 17, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun exploden (x)    ;PRINC-style fixnum characters\n (zilexpl\n          (cond\n           ((or (consp x) (vecp x))  (princ-to-string x))\n           (t                        x))\n          0            ; type is fixnum\n          nil          ; style is PRINC\n ))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXPT": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t3\\x00=\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:33:00", "lines": 61, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/29/88 - New integer exponentiation algorithm due to K. Hvatum.   *\n;*                                                                     *\n;***********************************************************************\n;\n;;; Thanks to Maclisp manual, p. 116, for X**Y = E**(Y*LOG(X)) equality.\n\n(defmacro 1-like (x)\n    `(cond\n      ((sfloatp ,x) 1.0f0)\n      ((dfloatp ,x) 1.0d0)\n      (t            1)))\n\n(defun expt (x y)\n (unless (numberp x)\n         (zerror \"EXPT base not a number\" x))\n (cond\n  ((floatp y)\n                     (cond\n                      ((zerop y)\n                       ;\n                       ; Actually, if (zerop x), it's supposed to be\n                       ; an error at this point.\n                       ;\n                       (1-like x))\n                      ((or (dfloatp y) (dfloatp x))\n                       (exp (* y (log x))))\n                      (t\n                       (exp (* y (log (float x y))))) ; force sfloat\n                     ))\n  ((not (fixnump y)) (zerror \"EXPT exponent not a fixnum or flonum\" y))\n  ((plusp y)         (if (or (zerop x) (= x 1))\n                         x\n                         (do* ((k (1- (haulong y)) (1- k))\n                               (n x (if (logbitp k y)\n                                        (* n n x)\n                                        (* n n))))\n                              ((zerop k) n))))\n  ((zerop y)         (1-like x))\n  (t\n                     ;\n                     ; y is a negative fixnum.\n                     ; Note that this is supposed to return a\n                     ; rational in Common LISP, but under the\n                     ; current ZIL it returns a truncated integer.\n                     ;\n\n                     (/ 1 (expt x (minus y))))\n ))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "FBOUNDP": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t4\\x00%\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 37, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; FBOUNDP\n;\n; This function returns T if the symbol has some kind of\n; function definition (even a special form or macro).\n;\n; Note that if the symbol has no current function definition,\n; the autoload process will be invoked to attempt to find one.\n;\n; Use of function cells not implemented yet, since I haven't even\n; determined what (if anything) will go in there.\n;\n\n(defun fboundp (a)\n (cond\n  ((not (symbolp a))         (warn \"Argument to FBOUNDP not a symbol\" a)\n                             nil)\n  ((get-function-property a) t)\n  ((progn\n    (zevauto a)                 ; Try autoloading it.\n    (get-function-property a)\n   )                         t)\n  (t                         nil)\n )\n)\n\n(defmacro get-function-property (a)\n  `(getl ,a '(|SPECIAL FORM| macro expr fexpr subr)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "FEATUREP": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t4\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(declare (special *features*))\n\n(defun featurep (x)\n (if (memq x *features*) t nil)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FEXPAND": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t4\\x00\\xf9\\x00\\xe9\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 249, "newlines": 233, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; \"FEXPAND\"\n\n; This is the \"full macro expander\".  It takes a LISP form and does a\n; complete codewalk, expanding any and all macros that it finds in it.\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/02/88 - New special forms BLOCK, TAGBODY, RETURN-FROM,           *\n;*            MULTIPLE-VALUE-BIND, MULTIPLE-VALUE-LIST, THROW.         *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;***********************************************************************\n;\n   ;;\n   ;; Steps in adding a new special form:\n   ;;\n   ;; (1) Add it to the list in ZEVINIT.\n   ;; (2) Add it to ZILEVAL.\n   ;; (3) Add it to FEXPAND.\n   ;; (4) Add it to ZILCOTRN.\n   ;; (4) Add it to ZILCOINT.\n   ;; (5) Figure out how to compile it.\n   ;;\n\n(defun fexpand (x)\n (cond\n  ((atom x)                           x                              )\n  ((consp (car x))                    (cons (fexpand-lambda (car x))\n                                            (fexpand-args (cdr x)))  )\n  ((not (symbolp (car x)))\n   (zerror \"FEXPAND: Invalid object in functional position\" x))\n  ((or (get (car x) 'cmacro)\n       (get (car x) 'macro))          (fexpand (fmexpand x))         )\n  ((get (car x) '|SPECIAL FORM|)      (fexpand-special-form x)       )\n  ((get (car x) 'fexpr)               x                              )\n  (t                                  (cons (car x)\n                                            (fexpand-args (cdr x)))  )\n )\n)\n\n(defun fexpand-lambda (x)\n (if (or (atom x) (atom (cdr x)))\n     x\n     (case (car x)\n      (lambda   (list* (car x)\n                       (fexpand-arglist (cadr x))\n                       (fexpand-args (cddr x))))\n;;;\n;;; This (\"LABEL\") will have to be deleted in favor of Common LISP\n;;; LABELS/FLET/MACROLET, which are probably going to be new\n;;; special forms.\n;;;\n      (label    (list (car x) (cadr x) (fexpand-lambda (caddr x))))\n\n      (t        (warn \"FEXPAND: Invalid form in functional position\" x)\n                (warn \"FEXPAND assuming it is to be macroexpanded.\")\n                (fexpand x)))))\n\n(defun fexpand-arglist (x)\n (prog (mode a z)\n  loop\n       (or x (go end))\n       (when (atom x)\n             (return (nreconc z x)))\n       (setq a (car x))\n       (when (llkeywdp a)\n        (case a\n         ((&optional &aux &rest &body &key)\n          (push (setq mode a) z)\n          (go cont))\n         (t\n         (zerror \"FEXPAND: Unknown lambda list keyword\" a))\n        )\n       )\n       (case mode\n        (&optional (cond\n                    ((atom a)       (push a z))\n                    ((null (cdr a))\n                     (push (list (fexpand-arglist (car a))) z))\n                    ((null (cddr a))\n                     (push (list (fexpand-arglist (car a))\n                                 (fexpand (cadr a))) z))\n                    (t\n                     (push (list* (fexpand-arglist (car a))\n                                  (fexpand (cadr a))\n                                  (cddr a)) z))))\n        (&aux      (cond\n                    ((atom a)       (push a z))\n                    ((null (cdr a))\n                     (push (list (fexpand-arglist (car a))) z))\n                    (t\n                     (push (list* (fexpand-arglist (car a))\n                                  (fexpand (cadr a))\n                                  (cddr a)) z))))\n        (&key      (cond\n                    ((atom a)       (push a z))\n                    ((null (cdr a))\n                     (push (list (fexpand-key (car a))) z))\n                    ((null (cddr a))\n                     (push (list (fexpand-key (car a))\n                                 (fexpand (cadr a))) z))\n                    (t\n                     (push (list* (fexpand-key (car a))\n                                  (fexpand (cadr a))\n                                  (cddr a)) z))))\n        (t         (push (fexpand-arglist a) z))\n       )\n  cont\n       (setq x (cdr x))\n       (go loop)\n   end\n       (return (nreverse z))\n )\n)\n\n(defun fexpand-key (a)\n (cond\n  ((atom a) a)\n  ((atom (cdr a)) a)\n  (t (list* (car a) (fexpand-arglist (cadr a)) (cddr a)))))\n\n(defun fexpand-special-form (x)\n (case (car x)\n  ((quote go defload declare)\n   x)\n  ((function subr)\n   (list (car x) (fexpand-lambda (cadr x))))\n  ((and or progn catch throw unwind-protect\n    arg setarg listify multiple-value-list)\n   (cons (car x) (fexpand-args (cdr x))))\n  ((defvar eval-when block return-from)\n   (list* (car x) (cadr x) (fexpand-args (cddr x))))\n  (cond                (cons (car x)\n                             (fexpand-cond        (cdr x))))\n  (setq                (cons (car x)\n                             (fexpand-setq        (cdr x))))\n  (defun               (cons (car x)\n                             (fexpand-defun       (cdr x))))\n  (tagbody             (cons (car x)\n                             (fexpand-tagbody     (cdr x))))\n  (multiple-value-bind (cons (car x)\n                             (fexpand-m-v-bind    (cdr x))))\n  (t (zerror \"Special form unknown to FEXPAND\" (car x)))))\n\n(defun fexpand-args (x)\n (fmapcar #'fexpand x))\n\n(defun fexpand-cond (x)    ; x = ((a1) (b1 b2) (c1 c2 c3) ...)\n (fmapcar #'fexpand-args x))\n\n(defun fexpand-tags (x &aux y)\n (cond\n  ((atom x); GO tag?\n   x)\n  ((atom (setq y (fexpand x))) ; If macro form expands to an atom,\n   `(progn ,y))                ; then consify to prevent from being tag\n  (t y)))\n\n(defun fexpand-setq (x)    ; x = (arg1 val1 arg2 val2 ...)\n (prog (z)\n  loop (or x (go end))\n       (when (atom x)\n             (warn \"FEXPAND found improper list ending in\" x)\n             (return (nreconc z x)))\n       (push (car x) z)\n       (setq x (cdr x))\n       (or x (go end))\n       (when (atom x)\n             (warn \"FEXPAND found improper list ending in\" x)\n             (return (nreconc z x)))\n       (push (fexpand (car x)) z)\n       (setq x (cdr x))\n       (go loop)\n  end  (return (nreverse z))\n )\n)\n\n(defun fexpand-defun (x)   ; x = (foo (arglist) . body)\n                           ;  or (foo macro (arglist) . body)\n                           ;  or (foo fexpr (arglist) . body)\n\n (if (memq (cadr x) '(expr fexpr macro))\n     (list* (car x)\n            (cadr x)\n            (fexpand-arglist (caddr x))\n            (fexpand-args (cdddr x)))\n     (list* (car x)\n            (fexpand-arglist (cadr x))\n            (fexpand-args (cddr x)))))\n\n(defun fexpand-tagbody (x)\n (fmapcar #'fexpand-tags x))\n\n(defun fexpand-m-v-bind (x)    ; x = (<arglist> form . body)\n ;\n ; Even though &optional, etc. aren't permitted in the arglist of\n ; MULTIPLE-VALUE-BIND, we still expand it as if it was, to allow\n ; the maximum possible amount of destructuring.  It isn't even\n ; certain that destructuring will be allowed in the arglist here.\n ;\n (list* (fexpand-arglist (car x))\n        (fexpand-args (cdr x))))\n\n(defun fmexpand (form &aux m prop)\n ;\n ; This is identical to MACROEXPAND except that it takes both\n ; MACRO's and CMACRO's (for compiler macros).\n ;\n  (cond\n   ((not (and (consp form)\n              (symbolp (car form))\n              (setq m (or (get (car form) (setq prop 'macro))\n                          (get (car form) (setq prop 'cmacro))))))\n    form)\n   (t (zevmapp m form prop))))\n\n\n(defmacro fmapcar (fun list)\n\n  (or (symbolp list)\n      (zerror \"FEXPAND wants arg2 to FMAPCAR to be a symbol, not\" list))\n\n  (if (eq (car fun) 'function)\n      (setq fun (cadr fun))\n      (zerror \"FEXPAND wants arg1 to FMAPCAR to be #'xxx, not\" fun))\n\n `(if (atom ,list)  ; Just in case a bad form gets passed.\n      ,list\n      (prog (z)\n        loop\n            (or ,list (return (nreverse z)))\n            (when (atom ,list)\n                  (warn \"FEXPAND found improper list ending in\" ,list)\n                  (return (nreconc z ,list)))\n            (push (,fun (zcar ,list)) z)\n            (setq ,list (zcdr ,list))\n            (go loop))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "FIX": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87(\\x7f\\x00\\x89\\x15o\\t4\\x00\\x17\\x00\\n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 23, "newlines": 10, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; FIX is identical to FLOOR, except that it always takes\n;;; only 1 argument.\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/16/88 - Forced to return only one value, no matter what we       *\n;*            end up doing with ZILFIX.                                *\n;*                                                                     *\n;***********************************************************************\n;\n(defun fix (x) (values (zilfix x 4)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLATC": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87$\\x9f\\x00\\x89\\x15o\\t4\\x00\\n\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-06T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 10, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun flatc (x) (zilflat x nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLATSIZE": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87$\\x9f\\x00\\x89\\x15o\\t4\\x00\\n\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-06T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 10, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun flatsize (x) (zilflat x t))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLAVORS": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t4\\x00B\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 66, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZIL flavor system.\n;\n\n(eval-when (eval)\n (defmacro zlflavor ()\n  '(load (zil-source-member ZLFLAVOR)))\n (defmacro zlvanlla ()\n  '(load (zil-source-member ZLVANLLA)))\n (defmacro zlflvaux ()\n  '(load (zil-source-member ZLFLVAUX)))\n)\n\n(eval-when (compile load eval)\n (defmacro flavor-system-loaded ()\n  `(get '*flavors* 'flavor-system-loaded)))\n\n(defargs zlflavor 0 0 nil)\n(defargs zlflvaux 0 0 nil)\n(defargs zlvanlla 0 0 nil)\n\n(defun flavors ()\n\n (cond\n  ((flavor-system-loaded)\n   (warn \"A FLAVORS system is already loaded.\")\n   nil)\n (t\n\n    ; Herald.\n\n    (when (< (msglevel) 2)\n          (cterpri)\n          (princ \"Loading ZIL's FLAVORS system.\")\n          (terpri))\n\n    ; Definitions of flavor functions/macros.\n\n    (zlflavor)\n\n    ; More flavor functions.\n\n    (zlflvaux)\n\n    ; Initialization of VANILLA-FLAVOR and its methods.\n\n    (zlvanlla)\n\n    (setf (flavor-system-loaded) t)\n\n    t\n\n  )))\n\n(eval-when (eval)\n (flavors)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "FLOOR": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87(\\x7f\\x00\\x89\\x15o\\t4\\x00\\x13\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 19, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun floor (x &optional (y nil y?))\n (if y?\n     (let ((q (zilfix (/ (if (and (integerp x) (integerp y))\n                             (float x)\n                             x)\n                         y)\n                      4)))\n          (values q (- x (* q y))))\n     (let ((q (zilfix x 4)))\n          (values q (- x q)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FMAKUNBO": {"ttr": 1044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t4\\x00\\x1e\\x00\\x17\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:34:00", "lines": 30, "newlines": 23, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"FMAKUNBOUND\"\n;\n; Note that FMAKUNBOUND, in ZIL, does NOT remove special form defs.\n;\n; Note: Function cells not used yet (see FBOUNDP for more ruminations).\n;\n\n(defun fmakunbound (x)\n (unless (symbolp x)\n         (zerror \"Argument to FMAKUNBOUND is not a symbol\" x))\n (when (get x '|SPECIAL FORM|)\n       (zerror \"Attempt to FMAKUNBOUND special form\" x))\n (remprop x 'macro)\n (remprop x 'expr)\n (remprop x 'fexpr)\n (remprop x 'subr)\n x\n)\n\n(defload fmakunbound fmakunbo)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "FORMAT": {"ttr": 1046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10Y\\x00Z\\x03\\x0c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:59:00", "lines": 90, "newlines": 780, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; Reference:  Steele, pp. 385-407.\n\n;;;\n;;; This is the new implementation of FORMAT.  There are several\n;;; functions that comprise it - all their names begin by convention\n;;; with the characters ZFM.\n;;;\n;;; ZFMPARS - takes a FORMAT string and parses it into the form that\n;;;           is used by the FORMAT executor.  This may be invoked\n;;;           by the FORMAT compiler transform, if and when it is\n;;;           written.\n;;;\n;;; ZFMEXEC - the FORMAT executor.  Unlike FORMAT, this function\n;;;           takes a fixed number of args and the output of the\n;;;           FORMAT string parser.\n;;;\n;;; ZFMNENG - converts an integer to English word form.\n;;;\n;;; ZFMNROM - converts an integer to Roman numeral form.\n;;;\n;;; See the source code for the above functions, and possibly others,\n;;; for more information.\n;;;\n;;; Note: We may also decide to write a function FORMATL as follows:\n;;;\n;;; (defun formatl (dest string args)\n;;;  (zfmexec dest (zfmpars string) args))\n;;;\n;;; such that FORMAT could be defined as:\n;;;\n;;; (defun format (dest string &rest args)\n;;;  (formatl dest string args))\n;;;\n;;; In this way, functions like ERROR and Y-OR-N-P could be defined\n;;; such that they invoked FORMAT as follows:\n;;;\n;;; (defun y-or-n-p (string &rest args)\n;;;  ...\n;;;  (formatl t string args)\n;;;  ...\n;;; )\n;;;\n;;; instead of the standard\n;;;\n;;;  ...\n;;;  (apply #'format t string args)\n;;;  ...\n;;;\n;;; ... unless we have a compiler transform for APPLY that can\n;;;     handle that.  But probably we will have\n;;;\n;;; (defun y-or-n-p (string &rest args)\n;;;  ...\n;;;  (zfmexec t (zfmpars string) args)\n;;;  ...\n;;; )\n;;;\n;;; ... assuming that we don't optimize the arg to Y-OR-N-P for\n;;;     efficiency (only if optimizing speed over space, of course).\n;;;\n\n(defun format (dest string &rest args)\n (zfmexec dest (zfmpars string) args)\n)\n\n;\n; The following insures that when you load the source version of\n; FORMAT from this file, the other files get loaded automatically\n; from the same file.  Not applicable to compilation.\n;\n\n(eval-when (eval)\n (declare (special *loadfile*))\n (let* ((loadfile (with-open-file (l *loadfile*) (zildsni l)))\n        (loadpds\n         (substr loadfile 1 (1- (index loadfile \"(\" #|)|#))))\n       )\n  (load (string-append \"'\" loadpds \"(zfmpars)'\"))\n  (load (string-append \"'\" loadpds \"(zfmexec)'\"))\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "FSZIL": {"ttr": 1048, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x00&?\\x01\\x00&?\\t$\\x00X\\x00X\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-19T00:00:00", "modifydate": "2000-09-19T09:24:58", "lines": 88, "newlines": 88, "modlines": 0, "user": "SEB1525"}, "text": "\n;;;\n;;; ZIL version 1.3 - November 1988\n;;;\n\n;;;\n;;; Full screen ZIL.  This function starts up\n;;; an ISPF-based Lisp interpreter.\n;;;\n\n(declare (special *version* * ** *** - -- --- + ++ +++ / // ///))\n\n(declare (special *fsinput* *fsrefresh* *fsfunctions*))\n\n(defun fszil ()\n (zfsexec :panel-name           \"FSZIL\"\n          :panel-library        nil\n          :short-appl           \"Lisp\"\n          :long-appl            (string-append \"ZIL Lisp \" *version*)\n;;;;;;;;  :terpri-exit-function nil\n          :initialize-function  #'fszil-user-initialize\n;;;;;;;;  :terminate-function   nil\n;;;;;;;;  :panel-init-function  nil\n;;;;;;;;  :echo-input-function  nil\n          :expr-list-function   #'fszil-user-get-expression-list\n          :refreshp-function    #'fszil-user-refreshp\n          :eval-expr-function   #'fszil-user-eval-expr\n          :good-eval-function   #'fszil-user-good-eval\n;;;;;;;;  :bad-eval-function    nil\n;;;;;;;;  :post-eval-function   nil\n          :display-function     #'fszil-user-display-value\n;;;;;;;;  :output-row-function  nil\n )\n t\n)\n\n(defun fszil-user-initialize (depth)\n (setq *fsinput* \"\")\n (setq *fsrefresh* t)\n (setq *fsfunctions* nil)\n)\n\n(defun fszil-user-get-expression-list (input trapper)\n (prog (sexpr (z nil) (index 0) (eofval (ncons nil)))\n  loop\n   (unless\n    (ok\n     (multiple-value-setq (sexpr index)\n      (funcall trapper\n        #'(lambda ()\n           (read-from-string input nil eofval :start index))))\n     (when (eq sexpr eofval)\n           (return (nreverse z)))\n     (setq +++ ++)\n     (setq ++ +)\n     (setq + -)\n     (setq - sexpr)\n    )\n    (return (nreverse z))\n   )\n   (push `(nil ,sexpr t) z)\n   (go loop)))\n\n(defun fszil-user-refreshp () *fsrefresh*)\n\n(defun fszil-user-eval-expr (expr fsdisplayp trapper\n                             &aux winp vals tempfun)\n;;;; check *fsfunctions*???\n (funcall trapper\n  #'(lambda ()\n      (setq vals (multiple-value-list (eval expr)))))\n vals)\n\n(defun fszil-user-good-eval (vals fsdisplayp)\n (setq /// //)\n (setq // /)\n (setq / vals)\n (setq *** **)\n (setq ** *)\n (setq * (car vals))\n)\n\n(defun fszil-user-display-value (vals)\n (cterpri)\n (dolist (val vals)\n         (prin1 val)\n         (terpri)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "FUNCALL": {"ttr": 1050, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t5\\x00\\x0f\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:35:00", "lines": 15, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; FUNCALL\n;;;\n\n(defun funcall (f &rest z)\n (zilapply f z))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCD2": {"ttr": 1052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t5\\x00$\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:35:00", "lines": 36, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This is the 2-argument version of GCD2.  It calls ZILGCD to do\n;;; fixnum-by-fixnum GCD efficiently.\n;;;\n;;; The GCD function, which takes any number of arguments, is expanded\n;;; by the compiler into the requisite calls to GCD2.  See ZMGCD.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/13/88 - Optimized by postponing calls to ABS.                    *\n;*                                                                     *\n;***********************************************************************\n;\n(defargs zilgcd 2 2 nil)\n\n(defun gcd2 (a b)\n (cond\n  ((and (fixnump a) (fixnump b))\n   (zilgcd a b))                 ; Fixnum-only assembler-coded GCD.\n  ((zerop a) (abs b))\n  ((zerop b) (abs a))\n  ((or (eql a 1) (eql b 1) (eql a -1) (eql b -1)) 1)\n  (t\n   (setq a (abs a))\n   (gcd2 (remainder (abs b) a) a))))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GENTEMP": {"ttr": 1054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t5\\x00,\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:35:00", "lines": 44, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"GENTEMP\"\n;\n\n(declare (special *gentemp-counter*))\n\n(defun gentemp (&optional (prefix \"T\")\n                          (package nil package?)\n                &aux      (counter *gentemp-counter*))\n\n (when package?\n       (warn \"Package arg to GENTEMP ignored in ZIL\" package))\n\n (or (stringp prefix)\n     (symbolp prefix)\n     (zerror \"Invalid GENTEMP prefix\" prefix))\n\n;\n; Increment GENTEMP counter and make a new symbol\n; until one changes the oblist\n; (if the oblist is unchanged, the symbol was already interned).\n;\n; Note: This code depends on the fact the new symbols are consed onto\n;       the front of the oblist.\n;\n (do ((c (1+ counter) (1+ c))\n      (o (oblist))\n      a\n     )\n     ((progn\n       (setq a (intern (string-append prefix (tostring c))))\n       (neq (oblist) o)\n      )\n      (setf *gentemp-counter* c)\n      a\n     )))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "I": {"ttr": 1056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x89\\x13_\\x00\\x89\\x13_\\x190\\x00\\x07\\x00\\x05\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-05-15T00:00:00", "modifydate": "1989-05-15T19:30:00", "lines": 7, "newlines": 5, "modlines": 0, "user": "SEB1525"}, "text": "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IMPLODE": {"ttr": 1058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t5\\x00\\x18\\x00\\x15\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:35:00", "lines": 24, "newlines": 21, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun implode (x)\n (cond\n  ((listp x) (concatl (mapcar #'implode-character-frob x)))\n  (t         (zerror \"Argument to IMPLODE not a list\" x))\n )\n)\n\n(defun implode-character-frob (x)\n (cond\n  ((fixnump x)       (ebcdic x))\n  ((or (stringp x)\n       (symbolp x))  (getchar x 1))\n  (t                 (zerror \"Invalid object to IMPLODE\" x))\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "INTERN": {"ttr": 1060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87&\\x1f\\x00\\x89\\x15o\\t5\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1989-06-05T09:35:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun intern (x &optional (package nil package?))\n (when package?\n       (warn \"Package argument to INTERN ignored in ZIL.\" package))\n (make-atom x t nil)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "INTERSEC": {"ttr": 1062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t5\\x00\\x14\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:35:00", "lines": 20, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (INTERSECTION A B :TEST #'EQL).\n;\n\n(defun intersection (a b)\n (cond\n  ((null a)            nil)\n  ((member (zcar a) b) (cons (zcar a) (intersection (cdr a) b)))\n  (t                   (intersection (cdr a) b))))\n\n(defload intersection intersec)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INTRPRET": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t5\\x00\\x8c\\x00{\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:35:00", "lines": 140, "newlines": 123, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; READ-EVAL-PRINT loop.\n;;;\n;;; Optional first argument - the source of input forms.\n;;;            Used by LOAD.\n;;;\n;;; Optional second argument - this is the output file\n;;;            to which printing is to be done.  If the unique value\n;;;            NOPRINT is specified for this, printing is bypassed.\n;;;\n;;; Thus (READ-EVAL-PRINT (open \"foo(bar)\") 'NOPRINT) is \"silent\".\n;;;\n;;; Optional third argument - a prompting string.\n;;;\n\n;;;\n;;; For the ZIL 1.1 version, the current compiled-environment ALIST\n;;; was passed to EVAL so that \"special\" variables in the top-level\n;;; program which invokes INTRPRET would be available in the compiled\n;;; environment, both for access and for updating.\n;;;\n;;; This is now done by default, since EVAL with no second argument\n;;; (or a second argument of NIL) uses the current alist.\n;;;\n\n;\n; Note that EOF has to be tested twice; both the READ and the EVAL\n; may cause EOF to be set.  Also note that, since the EOF test is\n; not within a CATCH, an invalid file would cause the interpreter to\n; die naturally (generally the first time through) with a normal\n; file error being signalled.\n;\n; Note also that (END) is an end-of-input indicator.\n;\n\n;\n;            Catch frame added to trap attention interrupts at\n;            \"top level\".  This traps attentions only if the\n;            input file is NIL (hence, the tag is T if the input\n;            file is NIL, NIL otherwise).\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/13/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun read-eval-print (&optional f o p)   ; READ-EVAL-PRINT loop.\n\n (prog (r\n        v\n        +              ; As defined in Common LISP guide, Chapter 20\n        ++             ; As defined in Common LISP guide, Chapter 20\n        +++            ; As defined in Common LISP guide, Chapter 20\n        -              ; As defined in Common LISP guide, Chapter 20\n        *              ; As defined in Common LISP guide, Chapter 20\n        **             ; As defined in Common LISP guide, Chapter 20\n        ***            ; As defined in Common LISP guide, Chapter 20\n        /              ; As defined in Common LISP guide, Chapter 20\n        //             ; As defined in Common LISP guide, Chapter 20\n        ///            ; As defined in Common LISP guide, Chapter 20\n       )\n       (declare (special + ++ +++ - * ** *** / // ///))\n\n      (unless (eq o 'noprint)              ; If output file not NOPRINT,\n              (cterpri o))                 ; let this function die.\n\n   loop                                    ; We must check for EOF after\n                                           ; eval in case QUIT issued\n      (when (eof f)                        ; Check for end of file\n            (return t))                    ; If EOF, end the interpreter\n\n      (catch (not f)                       ; Catch attention interrupts.\n       (if   (ok                           ; Catch LISP errors.\n                 (unless (eq o 'noprint)   ; If NOPRINT specified\n                         (cterpri o)       ; Insure a new line.\n                         (when p           ; If a prompt was specified\n                             (princ p o))) ; then display the prompt.\n                 (setq r (read f))         ; Read S-expression.\n                 (setq +++ ++)             ; Set +++.\n                 (setq ++ +)               ; Set ++.\n                 (setq + -)                ; Set + to last read form.\n                 (setq - r)                ; Set - to just-read form.\n             )                             ;\n        then                               ; If READ successful...\n             (if   (eof f)                 ; If end of file on input\n              then (return \"\")             ; then return.\n              else                         ; If user typed (END)\n              if   (and (consp r)          ;  (note that the test is\n                        (null (cdr r))     ;    all inline code rather\n                        (eq (zcar r) 'end));     than calling EQUAL)\n              then                         ; then finish\n                   (return t)              ;\n              else                         ;\n              if                           ;\n                   (not (ok                ; Catch EVAL/PRINT errors.\n                         (setq v           ; Evaluate form.\n                          (multiple-value-list\n                           (eval r)))      ; Get all values therefrom.\n                         (setq /// //)     ; Set ///.\n                         (setq // /)       ; Set //.\n                         (setq / v)        ; Set / to last eval'd forms\n                         (setq *** **)     ; Set ***.\n                         (setq ** *)       ; Set **.\n                         (setq * (car v))  ; Set * to last eval'd form.\n                         (unless           ; If NOPRINT specified,\n                          (eq o 'noprint)  ; then don't print form.\n                          (dolist (x v)    ; Else for each value ret'd,\n                           (cterpri o)     ; insure new output line\n                           (prin1 x o)     ; and print form.\n                           (terpri o))     ;\n                          )                ;\n                   ))                      ; If error before PRINT,\n              then                         ; then do cleanup stuff...\n                   nil                     ; (there is no cleanup stuff)\n              endif                        ;\n             )                             ;\n        endif                              ;\n       )                                   ;\n      ) ; end catch                        ;\n       (go loop)                           ; Repeat until (END) or EOF.\n )                                         ;\n)                                          ;\n\n(eval-when (load)\n (defload read-eval-print intrpret)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "INTRQ": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t6\\x00\\x12\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:36:00", "lines": 18, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (INTERSECTION A B :TEST #'EQ).\n;\n\n(defun intrq (a b)\n (cond\n  ((null a)          nil)\n  ((memq (zcar a) b) (cons (zcar a) (intrq (cdr a) b)))\n  (t                 (intrq (cdr a) b))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "KWDIFY": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x14\\x8f\\x00\\x89\\x15o\\t6\\x00\\x13\\x00\\x06\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-05-28T00:00:00", "modifydate": "1989-06-05T09:36:00", "lines": 19, "newlines": 6, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun keywordify (x)\n ;;\n ;;(intern (symbol-name x) (find-package 'keyword))\n ;;\n (cond\n  ((keywordp x) x)\n  ((symbolp x)  (concat \":\" x))\n  (t            (zerror \"Argument to KEYWORDIFY not a symbol\" x))))\n\n(defload keywordify kwdify)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "LDIFF": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x881\\x9f\\x00\\x89\\x15o\\t6\\x00\\x19\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-14T00:00:00", "modifydate": "1989-06-05T09:36:00", "lines": 25, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; LDIFF\n;;;\n;;; See CLtL, p. 272.\n;;;\n\n(defun ldiff (list sublist)\n (do ((list list (cdr list))\n      (z nil (cons (zcar list) z))\n     )\n     (nil)\n     (cond\n      ((eq list sublist)\n       (return (nreverse z)))\n      ((atom list)\n       (return (nreconc z list))))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LIST": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x15?\\x00\\x89\\x15o\\t6\\x00\\x0c\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-01T00:00:00", "modifydate": "1989-06-05T09:36:00", "lines": 12, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun list (&rest z)\n (append z nil)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LLVARS": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x14\\x9f\\x00\\x89\\x15o\\t6\\x00\\x80\\x00}\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-05-29T00:00:00", "modifydate": "1989-06-05T09:36:00", "lines": 128, "newlines": 125, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; LAMBDA-LIST-VARIABLES\n;;;\n;;; This function takes a lambda list and extracts all the variable\n;;; names from it.\n;;;\n;;; Errors are signalled for bad lambda list keyword usage.\n;;;\n;;; Example:\n;;;\n;;; (llvars '(a (b . c) &optional (d z d?) &rest x)) ==> (a b c d d? x)\n;;;\n\n(eval-when ()\n#.(defvar lambda-list-keywords\n          '(&optional &rest &body &aux &key &allow-other-keys))\n)\n\n(defun llvars (bvl)\n (prog (z mode c c1 c3)\n  loop\n       (or bvl (return z))\n       (cond ((atom bvl)         ; CDR of a dotted pair.\n              (push bvl z)\n              (return z)))\n       (setq c (zcar bvl))    ; An argument spec from the lambda-list.\n       (cond\n        ((llkeywdp c)       ; If it's a lambda list keyword\n         (setq mode\n               (car (or (memq c '#.lambda-list-keywords)\n                        (zerror \"Unrecognized lambda list keyword\" c))))\n         (setq bvl (cdr bvl))\n         (go loop)\n        )\n        (t\n         (case mode\n               ((nil)          (go required-arg))\n               ((&optional)    (go optional-arg))\n               ((&rest &body)  (go rest-arg))\n               ((&aux)         (go aux-arg))\n               ((&key)         (go key-arg))\n               (t (zerror \"Lambda list args following keyword\" mode)))\n        )\n       )\n\n required-arg\n\n       (setq z (nconc (llvars c) z))\n       (setq bvl (cdr bvl))\n       (go loop)\n\n optional-arg\n\n       (cond\n            ((atom c) (setq c1 c\n                            c3 nil))\n            (t        (setq c1 (car c)\n                            c3 (caddr c))))\n       (setq z (nconc (llvars c1) z))\n       (when c3\n             (setq z (nconc (llvars c3) z)))\n       (setq bvl (cdr bvl))\n       (go loop)\n\n aux-arg\n\n       (cond\n            ((atom c) (setq c1 c))\n            (t        (setq c1 (car c))))\n       (setq z (nconc (llvars c1) z))\n       (setq bvl (cdr bvl))\n       (go loop)\n\n rest-arg\n\n       (setq z (nconc (llvars c) z))\n       (setq bvl (cdr bvl))\n       (go loop)\n\n key-arg\n\n ;\n ; Format of a &key entry:\n ;\n ; var\n ; (var)\n ; (var initform)\n ; (var initform suppliedp)\n ; ((:var var))\n ; ((:var var) initform)\n ; ((:var var) initform suppliedp)\n ;\n\n       (let (\n             (var)\n             (variable)\n             (suppliedp)\n            )\n            (cond\n             ((atom c)\n              (setq variable c\n                    suppliedp nil))\n             ((atom (setq var (car c)))\n              (setq variable var\n                    suppliedp (caddr c)))\n             ((or (null (cdr var))\n                  (cddr var))\n              (return nil))\n             (t\n              (setq variable (cadr var)\n                    suppliedp (caddr c)))\n            )\n            (setq z (nconc (llvars variable)\n                           (llvars suppliedp) z))\n       )\n       (setq bvl (cdr bvl))\n       (go loop)\n\n ))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "LOAD": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t6\\x00/\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:36:00", "lines": 47, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; LOAD used to have an optional second argument, which is the file\n;;;        to print the results of evaluations on - this can be\n;;;        specified as the symbol NOPRINT to suppress such printing.\n;;;\n;;;            Thus (LOAD \"foo(bar)\" 'NOPRINT) did \"silent\" loading\n;;;            (well, almost silent, since the \"Loading\" message\n;;;            still appears).\n;;;\n;;; Now, LOAD is Common-LISP-compatible, so you can't use 'NOPRINT.\n;;;\n\n(declare (special *load-verbose* *loadfile*))\n\n(defun load (d &key (verbose            *load-verbose*)\n                    (print              nil)\n                    (if-does-not-exist  t))\n\n (if (and (null if-does-not-exist)\n          (null (probe-file d)))\n     nil\n     (let ((ud (string-upcase d)))\n      (with-open-file (f d :input)\n       (when verbose\n;;;;;;;;(format t \"~%;Loading ~A.~&\" ud)\n        (cterpri)\n        (princ \";Loading \")\n        (princ ud)\n        (princ \".\")\n        (terpri)\n       )\n       (let ((*loadfile* ud))\n        (read-eval-print f (if print nil 'noprint))\n       )\n      )\n      t\n     )\n     ))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "LOG": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x19\\x7f\\x00\\x89\\x15o\\t6\\x00\\x1b\\x00\\n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-07-16T00:00:00", "modifydate": "1989-06-05T09:36:00", "lines": 27, "newlines": 10, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun log (x &optional (base nil base?))\n\n (if base?\n\n     ; LOG     X  =  LOG X / LOG BASE\n     ;    BASE          E       E\n\n     (cond\n      ((and (sfloatp x) (integerp base))\n       (/ (ziflog x) (ziflog (float base x))))\n      ((and (integerp x) (sfloatp base))\n       (/ (ziflog (float x base)) (ziflog base)))\n      (t\n       (/ (ziflog x) (ziflog base))))\n\n    ; else base not specified - take natural logarithm to base e\n\n     (ziflog x)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGAND": {"ttr": 1298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x19_\\x00\\x89\\x15o\\t7\\x00\\x1a\\x00\\x17\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1989-06-05T09:37:00", "lines": 26, "newlines": 23, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"LOGAND\"\n;;;\n;;; This is for use under the interpreter only.  The compiler transforms\n;;; LOGAND into the requisite number of calls to LAND.\n;;;\n\n(defun logand (&rest x)\n (if (null x)\n     -\n     (prog (v)\n           (setq v (zcar x))\n       loop\n           (when (setq x (cdr x))\n                 (setq v (land v (zcar x)))\n                 (go loop))\n           (return v))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "LOGIOR": {"ttr": 1300, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x19_\\x00\\x89\\x15o\\t7\\x00\\x1a\\x00\\x17\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1989-06-05T09:37:00", "lines": 26, "newlines": 23, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"LOGIOR\"\n;;;\n;;; This is for use under the interpreter only.  The compiler transforms\n;;; LOGIOR into the requisite number of calls to LOR.\n;;;\n\n(defun logior (&rest x)\n (if (null x)\n     0\n     (prog (v)\n           (setq v (zcar x))\n       loop\n           (when (setq x (cdr x))\n                 (setq v (lor v (zcar x)))\n                 (go loop))\n           (return v))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "LOGXOR": {"ttr": 1302, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x19_\\x00\\x89\\x15o\\t7\\x00\\x1a\\x00\\x17\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1989-06-05T09:37:00", "lines": 26, "newlines": 23, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"LOGXOR\"\n;;;\n;;; This is for use under the interpreter only.  The compiler transforms\n;;; LOGXOR into the requisite number of calls to LXOR.\n;;;\n\n(defun logxor (&rest x)\n (if (null x)\n     0\n     (prog (v)\n           (setq v (zcar x))\n       loop\n           (when (setq x (cdr x))\n                 (setq v (lxor v (zcar x)))\n                 (go loop))\n           (return v))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAKNAM": {"ttr": 1304, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t7\\x00\\x1a\\x00\\x15\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:37:00", "lines": 26, "newlines": 21, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This is a Maclisp function.\n\n(defun maknam (x)\n (cond\n  ((listp x) (uconcatl (mapcar #'maknam-character-frob x)))\n  (t         (zerror \"Argument to MAKNAM not a list\" x))\n )\n)\n\n(defun maknam-character-frob (x)\n (cond\n  ((fixnump x)       (ebcdic x))\n  ((or (stringp x)\n       (symbolp x))  (getchar x 1))\n  (t                 (zerror \"Invalid object to MAKNAM\" x))\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAKUNBOU": {"ttr": 1306, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t7\\x00K\\x00;\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:37:00", "lines": 75, "newlines": 59, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;   In ZIL 1.2, MAKUNBOUND deleted one occurrence of a\n;;;   variable from the alist, or removed current variable\n;;;   binding if there was no binding on the alist.\n;;;\n;;;   With deep binding, MAKUNBOUND changes the current binding cell\n;;;   of a variable to be \"valueless\".\n;;;\n;;;            Deep binding scheme implements fake value cells\n;;;            (actually binding cells) for global variables.\n;;;            This consists of a BINDING property on the property\n;;;            list of the symbol.\n;;;\n;;; Note: Shallow binding implementation will replace this function\n;;;       with a simple (usually compiled inline) operation to bash\n;;;       the symbol's value cell with a different UNBOUND marker.\n;;;\n\n(defun makunbound (x)\n (unless (symbolp x)\n         (zerror \"Argument to MAKUNBOUND is not a symbol\" x))\n (let ((binding (zevsym x)))\n      (when (consp binding)              ; Constants cannot be unbound.\n            (rplacd binding (zilunbnd))))\n x\n)\n\n(defload makunbound makunbou)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Old code, no longer in use.\n;\n;(let ((z (get '*defvar* 'defvar))) ; Look at DEFVAR'd variables.\n;     (when (memq x z)              ; If variable is on DEFVAR list\n;           (putprop '*defvar* (delq x z) 'defvar)))\n;                                   ; then remove it from DEFVAR list.\n;(prog (a b c)\n;      (setq a (special-alist) b nil)\n; loop (or a (go tryglobal))        ; When alist exhausted, try global.\n;      (if (eq x (caar a))          ; When variable ASSQ-located,\n;       then                        ; we have to remove it...\n;        (rplacd (car a) (zilunbnd)); clobber this pair\n;        (if b                      ; Check pointer to previous alist\n;         then                      ;  cell; if we have one, then...\n;          (rplacd b (cdr a))       ; splice pair out of alist\n;         else                      ; otherwise...\n;          (setf (special-alist)    ; nothing to bash, so set new alist\n;                (cdr a))\n;        )\n;        (return x)                 ; That's it, we're through\n;       else                        ;\n;        (setq b a a (cdr a))       ; Otherwise bump down the alist\n;        (go loop))                 ; keeping a pointer to last cell.\n;tryglobal                          ; Here if no dynamic value.\n;  (when (setq c (get x 'binding))  ; If variable has a global value,\n;        (unless (consp c)\n;                (zerror \"Bad BINDING property found by MAKUNBOUND\" x c))\n;        (remprop x 'binding)       ; then remove it\n;        (rplacd c (zilunbnd))      ; and clobber the binding cell.\n;  )                                ;\n;  (return x)                       ; Return the variable itself.\n;))\n;\n; (defload car zcar)\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPAND": {"ttr": 1308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t7\\x00&\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:37:00", "lines": 38, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun mapand1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) t)\n  ((atom lis) (zerror \"Argument 2 to MAPAND not a list\" lis))\n  (t\n   (prog (v)\n    loop (when (setq v (funcall fun (car lis)))\n               (when (setq lis (cdr lis))\n                     (go loop))\n               (return v))\n         (return nil)))))\n\n(defun mapand (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       t)\n  ((null (cdr lists)) (mapand1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPAND\" list)))\n   (prog (v)\n         (setq v t)\n    loop (when (mapor #'null lists) (return v))\n         (unless (setq v (zilapply fun (mapcar #'car lists)))\n                 (return nil))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPATOMS": {"ttr": 1310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x19o\\x00\\x89\\x15o\\t8\\x00\\x0c\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-07-15T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 12, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun mapatoms (f)\n (dolist (x (oblist) nil)\n         (funcall f x)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPC": {"ttr": 1312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x00'\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 39, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun mapc1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to MAPC not a list\" lis))\n  (t\n   (prog (v)\n         (setq v lis)\n    loop\n         (funcall fun (car lis))\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (go loop)\n   ))))\n\n(defun mapc (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (mapc1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPC\" list)))\n   (prog (v)\n         (setq v (car lists))\n    loop (when (mapor #'null lists) (return v))\n         (zilapply fun (mapcar #'car lists))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPCAN": {"ttr": 1314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x00'\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 39, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun mapcan1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to MAPCAN not a list\" lis))\n  (t\n   (prog (v)\n         (setq v nil)\n    loop\n         (setq v (nconc v (funcall fun (car lis))))\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (go loop)\n   ))))\n\n(defun mapcan (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (mapcan1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPCAN\" list)))\n   (prog (v)\n         (setq v nil)\n    loop (when (mapor #'null lists) (return v))\n         (setq v (nconc v (zilapply fun (mapcar #'car lists))))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPCAR": {"ttr": 1316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x00<\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 60, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n ;;\n ;; Insure that built-in inline MAPCAR definition is saved.\n ;;\n\n(eval-when (compile)\n (deftrans !mapcar (x y z) (zxmap (cons 'mapcar (cdr x)) y z))\n)\n(eval-when (eval)\n (setf (get '!mapcar 'subr) (zilload 'mapcar))\n)\n\n(defun mapcar1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to MAPCAR not a list\" lis))\n  (t\n   (prog (v w)\n         (setq v (ncons (funcall fun (car lis))))\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (setq w v)\n    loop\n         (setq w (setf (cdr w)\n                       (ncons (funcall fun (car lis)))))\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (go loop)\n   ))))\n\n(defun mapcar (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (mapcar1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPCAR\" list)))\n   (prog (v w)\n         (setq v nil)\n         (when (mapor #'null lists) (return v))\n         (setq v (ncons (zilapply fun (!mapcar #'car lists))))\n         (setq lists (!mapcar #'cdr lists))\n         (setq w v)\n    loop (when (mapor #'null lists) (return v))\n         (setq w (setf (cdr w)\n                       (ncons (zilapply fun (!mapcar #'car lists)))))\n         (setq lists (!mapcar #'cdr lists))\n         (go loop)\n   ))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPCON": {"ttr": 1318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x00'\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 39, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun mapcon1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to MAPCON not a list\" lis))\n  (t\n   (prog (v)\n         (setq v nil)\n    loop\n         (setq v (nconc v (funcall fun lis)))\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (go loop)\n   ))))\n\n(defun mapcon (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (mapcon1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPCON\" list)))\n   (prog (v)\n         (setq v nil)\n    loop (when (mapor #'null lists) (return v))\n         (setq v (nconc v (zilapply fun lists)))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPL": {"ttr": 1538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x00'\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 39, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun mapl1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to MAPL not a list\" lis))\n  (t\n   (prog (v)\n         (setq v lis)\n    loop\n         (funcall fun lis)\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (go loop)\n   ))))\n\n(defun mapl (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (mapl1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPL\" list)))\n   (prog (v)\n         (setq v (car lists))\n    loop (when (mapor #'null lists) (return v))\n         (zilapply fun lists)\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPLIST": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x001\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 49, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun maplist1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to MAPLIST not a list\" lis))\n  (t\n   (prog (v w)\n         (setq v (ncons (funcall fun lis)))\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (setq w v)\n    loop\n         (setq w (setf (cdr w)\n                       (ncons (funcall fun lis))))\n         (unless (setq lis (cdr lis))\n                 (return v))\n         (go loop)\n   ))))\n\n(defun maplist (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (maplist1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPLIST\" list)))\n   (prog (v w)\n         (setq v nil)\n         (when (mapor #'null lists) (return v))\n         (setq v (ncons (zilapply fun lists)))\n         (setq lists (mapcar #'cdr lists))\n         (setq w v)\n    loop (when (mapor #'null lists) (return v))\n         (setq w (setf (cdr w)\n                       (ncons (zilapply fun lists))))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)\n   ))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPOR": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x00A\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 65, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; Note:  This is identical to SOME.  Should take advantage of this.\n;;;\n\n ;;\n ;; Insure that built-in inline MAPOR definition is saved.\n ;;\n\n(eval-when (compile)\n (deftrans !mapor (x y z) (zxmap (cons 'mapor (cdr x)) y z))\n)\n(eval-when (eval)\n (setf (get '!mapor 'subr) (zilload 'mapor))\n)\n\n(defun mapor1 (fun lis) ; Case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to MAPOR not a list\" lis))\n  (t\n   (prog (v)\n    loop\n         (return (or (funcall fun (car lis))\n                     (when (setq lis (cdr lis))\n                           (go loop))))))))\n\n;;; loop (unless (setq v (funcall fun (car lis)))\n;;;              (when (setq lis (cdr lis))\n;;;                    (go loop))\n;;;              (return nil))\n;;;      (return v)))))\n\n(defun mapor (fun &rest lists) ; Case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (mapor1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to MAPOR\" list)))\n   (prog (v)\n    loop (when (!mapor #'null lists) (return nil))\n         (when (setq v (zilapply fun (mapcar #'car lists)))\n               (return v))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n;(defun zmapor1 (fn x a) ; Case of 1 list.\n; (prog (v w z)\n;  loop (or x (return v))\n;       (setq v (apply fn (cons (car x) nil) a))\n;       (and v (return v))\n;       (setq x (cdr x))\n;       (go loop)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAX2": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t8\\x00\\x13\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:38:00", "lines": 19, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"MAX2\"\n;;;\n;;; This is the two-argument version of MAX.  MAX is implemented as\n;;; a macro that expands into the requisite number of calls to MAX2.\n;;;\n\n(defun max2 (a b)\n (if (> a b) a b)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MEMBER": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x86\\t\\x0f\\x00\\x89\\x15o\\t9\\x002\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1986-03-31T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 50, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;---------------------- Common LISP MEMBER ----------------------------\n\n;======================================================================\n\n(defmacro member-loop (test key testnotp)\n (let ((comparison (let ((x `(,@test item ,(if key `(,@key (zcar list))\n                                                   `(zcar list)))))\n                        (if testnotp `(not ,x) x))))\n      `(and list\n            (prog ()\n              loop\n                  (cond\n                   (,comparison\n                    (go true))\n                   ((setq list (cdr list))\n                    (go loop)))\n              true\n                  (return list)))))\n\n;======================================================================\n\n (defun member (item list &key (test nil test?)\n                               (test-not nil test-not?)\n                               (key nil key?))\n  (cond\n   ((and test? test-not?)\n    (zerror \"Both :TEST and :TEST-NOT keywords given to MEMBER\"))\n   ((not (listp list))\n    (zerror \"Argument 2 to MEMBER not a list\" list))\n   (test-not?\n    (if key?\n        (member-loop (funcall test-not) (funcall key) t)\n        (member-loop (funcall test-not) nil           t)))\n   (test?\n    (if key?\n        (member-loop (funcall test)     (funcall key) nil)\n        (member-loop (funcall test)     nil           nil)))\n   (t\n    (if key?\n        (member-loop (eql)              (funcall key) nil)\n        (member-loop (eql)              nil           nil)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MEMQL": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t9\\x00\\x14\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 20, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (MEMBER A B :TEST #'EQL)\n;\n\n (defun memql (x y)\n  (prog ()\n   loop (when y\n              (unless (eql x (zcar y))\n                      (setq y (cdr y))\n                      (go loop)))\n        (return y)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEMQUAL": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t9\\x00\"\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 34, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (MEMBER A B :TEST #'EQUAL)\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/11/88 - Recoded to compile into faster (?) code.                 *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun memqual (item list)\n (and list\n  (prog ()\n    loop\n        (cond\n         ((equal item (zcar list))\n          (go true))\n         ((setq list (cdr list))\n          (go loop))\n        )\n    true\n        (return list))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEXPAND": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t9\\x00,\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 44, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; MACROEXPAND - macro expander.\n;\n\n;\n; MACROEXPAND repeatedly expands a macro form until the resultant\n; form is not a macro.\n;\n; See MACROEXPAND-1 (MEXPAND1) for the expand-once-only version.\n;\n\n;;;\n;;; (SET-MACRO-FORM M FORM) sets variable M to the macroexpansion\n;;;                         function of FORM if FORM is a macro form,\n;;;                         otherwise returns NIL.\n;;;\n\n(defmacro set-macro-form (m form)\n (let* ((g (if (atom form) form (gensym)))\n        (b `(and (consp ,g)\n                 (symbolp (zcar ,g))\n                 (setq ,m (get (zcar ,g) 'macro)))))\n       (if (atom form)\n           b\n           `(let ((,g ,form)) ,b))))\n\n(defun macroexpand (form)\n (prog (m)\n   loop\n       (when (set-macro-form m form)\n             (setq form (zevmapp m form 'macro))\n             (go loop))\n       (return form)))\n\n(defload macroexpand mexpand)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEXPAND1": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x87\\x10_\\x00\\x89\\x15o\\t9\\x00'\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-04-15T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 39, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; MACROEXPAND-1 - one-time macro expander.\n;\n\n;\n; Compare MACROEXPAND (MEXPAND), which expands a macro form until\n; the resultant form is not a macro.\n;\n\n;;;\n;;; (SET-MACRO-FORM M FORM) sets variable M to the macroexpansion\n;;;                         function of FORM if FORM is a macro form,\n;;;                         otherwise returns NIL.\n;;;\n\n(defmacro set-macro-form (m form)\n (let* ((g (if (atom form) form (gensym)))\n        (b `(and (consp ,g)\n                 (symbolp (zcar ,g))\n                 (setq ,m (get (zcar ,g) 'macro)))))\n       (if (atom form)\n           b\n           `(let ((,g ,form)) ,b))))\n\n(defun macroexpand-1 (form &aux m)\n  (if (not (set-macro-form m form))\n      form\n      (zevmapp m form 'macro)))\n\n(defload macroexpand-1 mexpand1)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MIN2": {"ttr": 1556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\t9\\x00\\x13\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 19, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"MIN2\"\n;;;\n;;; This is the two-argument version of MIN.  MIN is implemented as\n;;; a macro that expands into the requisite number of calls to MIN2.\n;;;\n\n(defun min2 (a b)\n (if (> a b) b a)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MKNEWENV": {"ttr": 1558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x12\\x0f\\x00\\x89\\x15o\\t9\\x00@\\x00\\x16\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-04-30T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 64, "newlines": 22, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; MAKE-NEW-ENVIRONMENT\n;;;\n;;; This function builds a fresh evaluation environment,\n;;; lexically speaking.\n;;;\n;;; All ZIL 1.3 code that needs to construct a new environment should\n;;; call this function.\n;;;\n;;; It takes 1 optional arg - the lexical alist.\n;;; Default is a fresh lexical environment with no variables in it.\n;;;\n\n;\n; The \"environment\" is currently a LIST that looks like this:\n;\n; (alistenv           - the interpreter's lexical variable bindings\n;  progenv            - chain of PROG environments\n;  argenv             - chain of LEXPR environments\n;  specenv            - Pervasive SPECIAL variables\n;  fletenv            - Locally defined functions (a la FLET)\n;  mletenv            - Locally defined functions (a la MACROLET)\n;  ...other stuff might be added as time goes on...\n; )\n;\n; where progenv is a list of environments described in ZEVMACS.\n; See ZEVMACS for details.\n;\n; SPECIAL variables are not part of the environment; being dynamic,\n; they are found on the globally accessible \"SPECIAL-ALIST\".\n;\n; Macro definitions\n;\n; Note: These depend on the structure of the \"environment\" as\n;       defined in ZEVMACS.\n;\n; To change the structure of the environment, it is necessary to\n; change the definition of the structure in ZEVMACS, and to\n; recompile ZILAPPLY and ZILEVAL to use this new definition.\n;\n; In sum:\n;\n; Check COPYENV, MKNEWENV, ZEVMACS, ZILAPPLY, and ZILEVAL\n; when making changes to the structure of an ENVIRONMENT.\n;\n\n(defun mknewenv (&optional (alistenv nil))\n (list\n   alistenv           ; the interpreter's lexical variable bindings\n   nil                ; chain of PROG environments\n   nil                ; chain of LEXPR environments\n   nil                ; Pervasive SPECIAL variables\n   nil                ; Locally defined functions (a la FLET)\n   nil                ; Locally defined functions (a la MACROLET)\n))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MKNUMBER": {"ttr": 1560, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x1f\\x00\\x89\\x15o\\t9\\x00\\x0e\\x00\\x0b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1989-06-05T09:39:00", "lines": 14, "newlines": 11, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun make-number (x)\n (make-atom x nil t)\n)\n\n(defload make-number mknumber)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXADJOIN": {"ttr": 1562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87(\\x8f\\x00\\x89\\x15o\\tA\\x00>\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-10-15T00:00:00", "modifydate": "1989-06-05T09:41:00", "lines": 62, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The expander for the ADJOIN macro.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/16/88 - Always generates MEMBER with :TEST keyword.              *\n;*            No longer will it generate function of the ASSOC family, *\n;*            which is probably more correct since such functions do   *\n;*            something different if NIL is a member of the list.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (eval)\n (defmacro adjoin (a b &key ((:test c)) ((:key d)))\n           (mxadjoin a b c d))\n)\n\n(defun mxadjoin (item list test key\n                 &aux bindings itemvar listvar kwds itemtest)\n\n (setq listvar (gensym))\n (push `(,listvar ,list) bindings)\n\n (cond\n  ((or (atom item) (eq (car item) 'quote))\n   (setq itemvar item))\n  (t\n   (setq itemvar (gensym))\n   (push `(,itemvar ,item) bindings)))\n\n (setq itemtest\n       (cond\n        ((null key)\n         itemvar)\n        ((and (consp key)\n              (memq (car key) '(quote function)))\n         `(,(cadr key) ,itemvar))\n        (t\n         `(funcall ,key ,itemvar))))\n\n (when key  (setq kwds `(:key  ,key  . ,kwds)))\n (when test (setq kwds `(:test ,test . ,kwds)))\n\n `(let ,bindings\n       (cond\n        ((member ,itemtest ,listvar . ,kwds)\n         ,listvar)\n        (t\n         (cons ,itemvar ,listvar)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXATOFF": {"ttr": 1564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x880\\x9f\\x00\\x89\\x15o\\tC\\x00a\\x00^\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-04T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 97, "newlines": 94, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(eval-when (eval)\n (defun at  macro (x) (mxatoff x))\n (defun off macro (x) (mxatoff x))\n)\n\n(defun mxatoff (x)\n (let (((macro . arglist) x))\n      (case macro\n            (at  (mxatoff-at arglist))\n            (off (mxatoff-off arglist))\n            (t (zerror \"Invalid caller of MXATOFF\" macro)))))\n\n;\n; (at foo)\n; (at (foo :entry))\n; (at (foo :exit))\n;\n; (at foo           (arg1 arg2)      . body)\n; (at (foo entry)   (&rest arglist)  . body)\n; (at (foo exit)    (value-list)     . body)\n; (at (foo entry t) ...) <== don't display \"Entering\" message\n; (at (foo exit t) ...)  <== don't display \"Exiting\" message\n;\n\n(defun mxatoff-at\n       ((&optional (funspec (zerror \"Missing function name\" 'at))\n                   (arglist nil arglist?)\n         &body body)\n       &aux fun where quietp)\n (cond\n  ((symbolp funspec)\n   (setq fun funspec where :entry))\n  ((not (consp funspec))\n   (zerror \"Invalid AT function spec\" funspec))\n  ((eql (length funspec) 1)\n   (setq fun (car funspec) where :entry))\n  ((eql (length funspec) 2)\n   (setq fun (car funspec) where (cadr funspec)))\n  ((eql (length funspec) 3)\n   (setq fun (car funspec) where (cadr funspec) quietp (caddr funspec)))\n  (t\n   (zerror \"Invalid AT function spec\" funspec)))\n (cond\n  ((not arglist?) ; in which case there's no body either\n   (setq body '(nil)))\n  ((null body)    ; but arglist without body is not valid\n   (zerror \"Missing body\" 'at)))\n `(ziltrace\n   (list ',fun #'(lambda (,(gensym) ,arglist) . ,body) ',quietp)\n   ',(case where\n           ((entry :entry)\n            'entry)\n           ((exit :exit)\n            'exit)\n           (t (zerror \"Invalid AT entry/exit spec\" where)))))\n\n;\n; (off foo)\n; (off (foo entry))\n; (off (foo exit))\n;\n\n(defun mxatoff-off\n       ((&optional\n                   (funspec (zerror \"Missing function name\" 'off))\n         &rest junk)\n       &aux fun where)\n (cond\n  (junk\n   (zerror \"Too many arguments\" 'off))\n  ((symbolp funspec)\n   (setq fun funspec where :entry))\n  ((not (consp funspec))\n   (zerror \"Invalid OFF function spec\" funspec))\n  ((eql (length funspec) 1)\n   (setq fun (car funspec) where :entry))\n  ((eql (length funspec) 2)\n   (setq fun (car funspec) where (cadr funspec)))\n  (t\n   (zerror \"Invalid OFF function spec\" funspec)))\n `(ziltrace\n   '(,fun nil nil)\n   ',(case where\n           ((entry :entry)\n            'entry)\n           ((exit :exit)\n            'exit)\n           (t (zerror \"Invalid OFF entry/exit spec\" where)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXBQ": {"ttr": 1566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tC\\x00y\\x00w\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 121, "newlines": 119, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the back quote.\n;\n; (rdrmacro '|`| 'zrmbq)\n; (defmacro |`| (a) (mxbq a))\n;\n; 06/27/86 - Support for backquoted vectors.\n;\n\n(defload car zcar)\n\n(defmacro backquote () ''|`| )\n(defmacro comma     () ''|,| )\n(defmacro comma-at  () ''|,@|)\n(defmacro comma-dot () ''|,.|)\n\n(defmacro is-a-splicer (x) ; Determine which kind of expansion we need.\n `(and (consp ,x)\n       (or (eq (car ,x) (comma-at))\n           (eq (car ,x) (comma-dot)))))\n\n(defun mxbq (x)\n (cond\n  ((vectorp x)                    `(zmvector ,(mxbq (vlist x))))\n  ((atom x)                       (mxbq-atom x))\n  ((eq (car x) (comma))           (cadr x))\n  ((eq (car x) (comma-at))\n   (zerror \"Syntax error: ,@ not in backquoted list\"))\n  ((eq (car x) (comma-dot))\n   (zerror \"Syntax error: ,. not in backquoted list\"))\n  ((eq (car x) (backquote))       (mxbq (mxbq (cadr x))))\n  ((null (cdr x))                 (if   (is-a-splicer (car x))\n                                      (mxbq-nconc x)\n                                      (mxbq-list  x)))\n  ((or (atom (cdr x))\n       (eq (cadr x) (comma))\n       (eq (cadr x) (comma-at))\n       (eq (cadr x) (comma-dot))) `(cons ,(mxbq (car x))\n                                         ,(mxbq (cdr x))))\n  ((any-splicers x)               (mxbq-nconc x))\n  (t                              (mxbq-list  x))))\n\n(defun mxbq-atom (x)\n (cond\n  ((or (null x) (eq x t))  x)\n  ((symbolp x)             `(quote ,x))\n  (t                       x)))\n\n(defun any-splicers (x) ; See if there are any ,@'s or ,.'s present.\n (prog (a)\n  loop (or x (return nil))\n       (and (atom x) (return nil))\n       (setq a (car x))\n       (and (eq a (comma)) (return nil))\n       (and (eq a (comma-at))\n        (zerror \"Syntax error: ,@ cannot follow dot in backquoted list\"))\n       (and (eq a (comma-dot))\n        (zerror \"Syntax error: ,. cannot follow dot in backquoted list\"))\n       (and (is-a-splicer a) (return t))\n       (setq x (cdr x))\n       (go loop)))\n\n(defun mxbq-list (x)\n (let ((a (mapbq (subr mxbq-list1) x)))\n      (if   (car a)\n            `(list* . ,(nreverse a))\n            `(list  . ,(nreverse (cdr a))))))\n\n(defun mxbq-list1 (x)\n (cond\n  ((vectorp x)            ; Embedded vectors are implicitly backquoted.\n                            `(zmvector ,(mxbq (vlist x))))\n  ((atom x)                 (mxbq-atom x))\n  ((eq (car x) (comma))     (cadr x))\n  ((eq (car x) (backquote)) (mxbq (mxbq (cadr x))))\n  (t                        ; Embedded lists are implicitly backquoted.\n                            (mxbq x))))\n\n(defun mxbq-nconc (x)\n (let ((a (mapbq (subr mxbq-nconc1) x)))\n      (if (car a)     ; ends in dotted pair, extract from (LIST xxx)\n          `(nconc ,.(nreverse (cdr a)) ,(cadar a))\n          `(nconc . ,(nreverse (cdr a))))))\n\n(defun mxbq-nconc1 (x)\n (cond\n  ((vectorp x)           ; Embedded vectors are implicitly backquoted.\n                        `(list `(zmvector ,(mxbq (vlist x)))))\n  ((atom x)                 `(list ,(mxbq-atom x)))\n  ((eq (car x) (comma))     `(list ,(cadr x)))\n  ((eq (car x) (comma-at))  `(append ,(cadr x))) ; Must copy list.      .\n  ((eq (car x) (comma-dot)) (cadr x))          ; OK to destroy the list.\n  ((eq (car x) (backquote)) `(list ,(mxbq (mxbq (cadr x)))))\n  (t                        ; Embedded lists are implicitly backquoted.\n                            `(list ,(mxbq x)))))\n\n(defun mapbq (f x)\n (prog (a z w)\n  loop (or x (go finish))\n       (when (or (atom x)\n                 (eq (setq a (car x)) (comma)))\n             (setq w (funcall f x))\n             (go finish))\n       (when (eq a (comma-at))\n        (zerror \"Syntax error: ,@ cannot follow dot in backquoted list\"))\n       (when (eq a (comma-dot))\n        (zerror \"Syntax error: ,. cannot follow dot in backquoted list\"))\n       (push (funcall f a) z)\n       (setq x (cdr x))\n       (go loop)\n finish\n       (return (cons w z))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXCASE": {"ttr": 1568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tC\\x00X\\x00O\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 88, "newlines": 79, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the CASE and CASEQ macros.\n;\n; (DEFUN CASE  MACRO (X) (MXCASE X))\n; (DEFUN CASEQ MACRO (X) (MXCASE X))\n;\n\n(defun mxcase (x)\n (let (((macroname thing . cases) x)\n       (a (gensym)))\n      (or (cdr x)\n          (zerror \"Missing argument\" macroname))\n      (or (eq macroname 'case)\n          (eq macroname 'caseq)\n          (zerror \"Invalid caller of MXCASE\" macroname))\n      (or cases\n          (zerror \"Missing cases\" macroname thing))\n      `(let ((,a ,thing))\n        (cond . ,(do (\n                      (cases cases (cdr cases))\n                      (z nil\n                         (cons (case-clause a (car cases) macroname) z))\n                      (previous-cond nil (caar cases))\n                      )\n                      ((null cases)\n                       (or (eq previous-cond 't)\n                           (eq previous-cond 'otherwise)\n                           (push '(t nil) z))\n                       (nreverse z))\n                     )))))\n\n(defun case-clause (a case macroname)\n (when (atom case)\n       (zerror \"Invalid case\" macroname case))\n (let (((d . s) case) e1 e2 e3 m)\n  (cond\n   ((atom d)\n    (setq e1 (case-equality d)))\n   ((null (cdr d))\n    (setq e1 (case-equality (car d))))\n   ((null (cddr d))\n    (setq e1 (case-equality (car d))\n          e2 (case-equality (cadr d))))\n   ((null (cdddr d))\n    (setq e1 (case-equality (car d))\n          e2 (case-equality (cadr d))\n          e3 (case-equality (caddr d))))\n   ((mapand #'symbolp d)\n    (setq m 'memq))\n   ((mapand #'(lambda (x) (or (symbolp x) (numberp x) (stringp x))) d)\n    (setq m 'memql))\n   (t\n    (setq m 'memqual)))\n  (cond\n   ((null d)                 nil)\n   ((or (eq d 't)\n        (eq d 'otherwise))   `(t                          . ,s))\n   ((atom d)                 `((,e1 ,a ',d)               . ,s))\n   ((null (cdr d))           `((,e1 ,a ',(car d))         . ,s))\n   ((null (cddr d))          `((or (,e1 ,a ',(car d))\n                                   (,e2 ,a ',(cadr d)))   . ,s))\n   ((null (cdddr d))         `((or (,e1 ,a ',(car d))\n                                   (,e2 ,a ',(cadr d))\n                                   (,e3 ,a ',(caddr d)))  . ,s))\n   (t                        `((,m ,a ',d)                . ,s))\n  )\n )\n)\n\n(defun case-equality (d)\n (cond\n  ((symbolp d) 'eq)\n  ((numberp d) 'eql)\n#-Common-Lisp\n  ((stringp d) 'eql)\n#+Common-Lisp\n  ((stringp d) 'string-equal)\n\n  (t           'equal)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXDECF": {"ttr": 1570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tC\\x00\\x16\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 22, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the DECF macro.\n;\n\n(eval-when (eval)\n (defmacro decf (a &optional (b 1)) (mxdecf a b))\n)\n\n(defun mxdecf (place increment)\n `(setf ,place ,(case increment\n                      ((1)  `(sub1 ,place))\n                      ((-1) `(add1 ,place))\n                      (t    `(zilsub ,place ,increment)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXDEFARG": {"ttr": 1572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tC\\x00#\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 35, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; (DEFMACRO DEFARGS (FUN MIN &OPTIONAL MAX RST)\n;  (MXDEFARG FUN MIN MAX RST)\n; )\n;\n; e.g.  (DEFARGS 'FOO 1)\n;       (DEFARGS 'BAR 1 2)\n;       (DEFARGS 'BAZ 1 2 T)\n;       (DEFARGS 'FROB NIL)   ... makes FROB totally undefined.\n;\n\n(defun mxdefarg (fun min max rst)\n (if min\n  `(eval-when (compile)\n    (defprop ,fun ,min          minargs)\n    (defprop ,fun ,(or max min) maxargs)\n    (defprop ,fun ,rst          restarg)\n;;;;(defprop ,fun user          defined-by)\n   )\n  `(eval-when (compile)\n    (dolist (x '(minargs maxargs restarg inline predicate\n                 cautoload compiler-transform defined-by))\n               (remprop ',fun x))\n   )\n )\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXDEFFLI": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tC\\x00s\\x00k\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 115, "newlines": 107, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the DEFFLIC macro.\n;\n\n;\n; This generates \"Fast Loading Interpreted Code\", i.e. a compiled file\n; of interpreted forms.\n; For example...\n;\n;\n; (defflic zffoo \"my.lisp(foo)\")\n;\n; takes \"my.lisp(foo)\" and builds a compilable function out of it that,\n; when executed by typing (zffoo) under the interpreter, does the\n; following:\n;\n;     evaluates all forms in file \"my.lisp(foo)\" (they get stored in\n;     compiled form so READ of \"my.lisp(foo)\" doesn't get involved)\n;\n; The function looks something like this:\n;\n;   (defun zffoo (&optional f-print-out f-print-in)\n;    (when (lessp (msglevel) 2)\n;          (terpri)\n;          (princ \"Loading FLIC module ZFFOO.\")\n;          (terpri))\n;    (dolist (i '(list of all the forms in my.lisp(foo)))\n;            (and f-print-in (print i))\n;            (cond\n;             (f-print-out (catch nil (print (eval i))))\n;             (t           (catch nil (eval i)))\n;\n;   )))\n;\n\n(eval-when (eval)\n (defmacro defflic (a b &optional c d) (mxdeffli a b c d))\n)\n\n(defun mxdeffli   (flicname  ; the name of the module to be compiled.\n                   flicload  ; the name of the file to be flicified.\n                   &optional\n                   preexpand-macros? ; T if macros are to be expanded\n                                     ; at compile time, else NIL.\n                   debug?            ; see what the FLIC'er is reading\n                  )\n  `(progn\n    (defun ,flicname (&optional f-print-out f-print-in)\n     (when (lessp (msglevel) 2)\n           (terpri)\n           (princ ,(string-append \"Loading FLIC module \" flicname \".\"))\n           (terpri))\n     (dolist (i ',(defflic-forms-list flicload\n                                      preexpand-macros? debug?))\n             (cond\n              (f-print-in  (prin1 i) (terpri)))\n             (cond\n              (f-print-out (catch nil (prin1 (eval i))) (terpri))\n              (t           (catch nil (eval i)))\n\n ;;\n ;; ... might have to change that \"catch nil\" for Common Lisp someday??\n ;;\n\n    )))))\n\n (defun defflic-forms-list (flicload preexpand-macros? debug?)\n  (prog (form file z)\n        (setq file (open flicload 'input))\n   loop\n        (setq form (catch nil (read file)))\n        (cond ((eof file) (close file 'input) (return (nreverse z))))\n        (cond (debug? (terpri) (print form) (terpri)))\n        (cond (preexpand-macros? (setq form (macroexpand form))))\n        (cond\n         ((atom form) (princ \"Atom \") (princ form)\n                      (princ \" ignored.\") (terpri))\n         ((eq (car form) 'eval-when)\n          (and (setq form (defflic-eval-when (cdr form)))\n               (push form z)))\n         (t (push form z)))\n        (go loop)))\n\n;\n; EVAL-WHEN is interpreted as follows:\n;\n; COMPILE - evaluate them NOW.\n;\n; EVAL    - these forms are being evaluated, so include them.\n;\n; LOAD    - make them executed at load time, so include them.\n;\n\n (defun defflic-eval-when (a)\n  (unless a (zerror \"No args on eval-when\"))\n  (let (\n        ((times . forms) a)\n        z\n       )\n       (when (memq 'compile times)\n             (eval `(progn . ,forms))\n             (setq z nil))\n       (when (or (memq 'eval times)\n                 (memq 'load times))\n             (setq  z `(progn . ,forms)))\n       z))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXDEFMAC": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tC\\x00.\\x00K\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 46, "newlines": 75, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; DEFMACRO expander.\n;\n; Model:  (DEFMACRO FOO (A B) (LIST 'SOMETHING 'WITH A 'AND B))\n;\n; yields: (DEFUN FOO MACRO (NIL A B) (LIST 'SOMETHING 'WITH A 'AND B))\n;\n; This expander handles both DEFMACRO (for top-level macro definition)\n; and XDEFMACRO (for run-time macro definition).\n;\n; The macro definitions must read as follows:\n;\n;   (DEFUN DEFMACRO  MACRO (X) (MXDEFMAC X))\n;   (DEFUN XDEFMACRO MACRO (X) (MXDEFMAC X))\n;\n; This implementation of DEFMACRO is dependent on the\n; extended macro arglist syntax.  Probably this will change for\n; full Common Lisp.\n;\n\n(defun mxdefmac (x)\n (prog (dmmac dmname dmargs dmbody)\n       (setq dmmac (zcar x))           ; DEFMACRO or XDEFMACRO.\n       (or (cdr x) (go error1))\n       (setq dmname (zcadr x))         ; Macro name.\n       (or (cddr x) (go error1))\n       (setq dmargs (zcaddr x))        ; Argument list.\n       (or (setq dmbody (cdddr x))     ; Everything else is the body.\n           (zerror \"Missing DEFMACRO body\" dmname))\n\n       (return `(,(if (eq dmmac 'xdefmacro) 'xdefun 'defun)\n                 ,dmname macro (nil . ,dmargs) . ,dmbody))\n\n      error1\n       (zerror \"Too few arguments\" 'defmacro)\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXDEFMOD": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tC\\x01a\\x01m\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 353, "newlines": 365, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the DEFMODULE macro.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This is probably obsolete.  Supplanted by ZILCOMOD in the compiler, *\n;* which handles \"real\" module compiles.                               *\n;*                                                                     *\n;***********************************************************************\n;\n;\n; This generates a load module that loads in compiled forms and defs.\n;\n; (DEFMACRO DEFMODULE (A B &OPTIONAL C) (MXDEFMOD A B C))\n;\n; For example...\n;\n;\n; (defmodule zmfoo \"my.lisp(foo)\")\n;\n; takes foo and builds a compilable function out of it that, when\n; executed by typing (zmfoo) under the interpreter, does the operations\n; generally expected by implementations of compiled modules created\n; by COMPILE-FILE.  In other words,\n;\n; if the form is a macro form, process the macro expansion.  Note:\n; this somehow has to include stuff defined by DEFMACRO's, so any\n; DEFMACRO encountered in the module has to be made to generate both\n; a MACRO (for evaluation) and CMACRO (for compilation) property.\n;\n; if a form is a DEFUN, assigns the compiled definition to the\n; appropriate property of the symbol.  Exception: if the DEFUN is of\n; a macro, the macro is made known to the compiler only.\n;\n; if a form is a DEFMACRO, this expands to a DEFUN for a macro, so\n; see above.\n;\n; if a form is a DEFVAR, is made known as a \"special\" variable to the\n; compiler; also set up to be executed at load time.\n;\n; if a form is a DECLARE, is passed to the compiler as is.\n;\n; if a form is a COMMENT, is ignored.\n;\n; if a form is an EVAL-WHEN, processed as follows:\n;\n;  EVAL-WHEN (COMPILE) - evaluated by the compiler itself only.\n;  EVAL-WHEN (LOAD)    - processed as above.\n;  EVAL-WHEN (EVAL)    - ignored.\n;\n; if the form is anything else, is set up to be executed at load time.\n;\n; Example:\n;\n; If we encounter the form:\n;\n; (defmodule zmfoo \"my.lisp(foo)\")\n;\n; and the file looks like this...\n;\n; (defun foo1 (x) (blah1))        ;    1\n; (defun (baz frob) (y) (hair))   ;    2\n; (defmacro mac (x) `(frob ,x))   ;    3\n; (mac \"junk\")                    ;    4\n; (some random form)              ;    5\n; (defvar pi 3.1415926)           ;    6\n; (defload frobnicate frobozz)    ;    7\n; (eval-when (compile)\n;  (print \"hello world\"))         ;    8\n; (eval-when (load)\n;  (frob))                        ;    9\n; (eval-when (eval)\n;  (eccch))                       ;   10\n;\n; then the resulting form will be (more or less):\n;\n; (progn\n;  (defun zmfoo ()\n;    (zdef foo1)                                 ; 1\n;    (putprop 'baz (subr |BAZ FROB|) 'frob)      ; 2\n;    (frob \"junk\")                               ; 4 - expanded MAC\n;    (some random form)                          ; 5\n;    (xdefvar pi 3.1415926)                      ; 6\n;    (xdefload frobnicate frobozz)               ; 7\n;    (frob)                                      ; 9\n;    'zmfoo\n;  )\n;  (defun foo1 (x) (blah1))                      ; 1\n;  (defun |BAZ FROB| (y) (hair))                 ; 2\n;  (defun mac macro (nil x) `(frob ,x))          ; 3 - expanded DEFMACRO\n;  (defvar pi 3.1415926)                         ; 6\n;  (defload frobnicate frobozz)                  ; 7\n;  (eval-when (compile)\n;   (print \"hello world\"))                       ; 8\n; )\n;\n; This is what the compiler sees after macro expansion, and will\n; deal with.\n;\n;\n; Note that (9) is ignored - (eval-when (eval)) forms are always\n; ignored at compile time.\n;\n; As things are set up right now, this generates dynamically scoped\n; function definitions.  This may change.\n;\n\n(defload member memqual) ; We use an EQUAL test for MEMBER when\n                         ; searching for (FOO BAR) on NOCOMPILE list.\n\n(defun mxdefmod   (modname  ; the name of the module to be created.\n                   modload  ; the name of the file to be compiled.\n                   &optional\n                   debug    ; T if debugging requested\n                  )\n (let (((flist1 . flist2) (module-get-forms modname modload)))\n  (when debug\n   (terpri)\n   (princ \"Begin debugging output.\")\n   (terpri)\n   (terpri)\n   (princ \"Main (loadable) function code follows:\")\n   (terpri)\n   (terpri)\n   (pprint flist1)\n   (terpri)\n   (terpri)\n   (princ \"Other (compilable) forms follow:\")\n   (terpri)\n   (terpri)\n   (pprint flist2)\n   (terpri)\n   (terpri)\n   (princ \"End debugging output.\")\n   (terpri)\n  )\n  `(progn\n    (defun ,modname ()\n     (terpri)\n     (princ ,(string-append \"Loading module \"\n                            modname\n                            \", \"))\n     (princ ,(string-append \"created from file \"\n                            modload\n                            \".\"))\n     (terpri)\n     ,.flist1  ; Forms executed at load time.\n     ',modname ; Return the name of function itself as the value.\n    )\n    . ,flist2   ; Forms processed by the compiler.\n   )))\n\n; MODULE-GET-FORMS returns a CONS of 2 lists...\n;\n; (1) forms to be executed at load time which make up the main function\n; (2) DEFUN's, etc. to be processed by the compiler.\n;\n\n(declare (special complist loadlist))\n\n(defun module-get-forms (modname modload)\n  (prog (form file complist loadlist)\n        (setq file (open modload 'input))\n   loop\n        (setq form (catch nil (read file)))\n        (when (eof file)\n              (close file 'input)\n              (return (cons (nreverse loadlist) (nreverse complist))))\n        (module-process-form form)\n        (go loop)))\n\n(declare (basereg (module-process-form 2)))\n\n(defun module-process-form (form)\n (prog (defun-func defun-prop arglist defun-rest defun-name)\n   nexp (cond\n         ((atom form)                 (push form loadlist))\n         ((eq (zcar form) 'comment)   nil)\n         ((eq (zcar form) 'declare)   (go process-declare))\n         ((eq (zcar form) 'defload)   (go process-defload))\n         ((eq (zcar form) 'defun)     (go process-defun))\n         ((eq (zcar form) 'defvar)    (go process-defvar))\n         ((eq (zcar form) 'eval-when) (go process-eval-when))\n         ((eq (zcar form) 'progn)     (go process-progn))\n         ((and (symbolp (zcar form))\n               (get (zcar form) 'macro))\n          (setq form (macroexpand form))\n          (go nexp))\n         (t                           (push form loadlist)))\n        (return)\n\n  process-defun     ; form = (defun ...)\n\n; Place either the compiled or the interpreted function definition\n; on the appropriate property of the symbol that names the function.\n; If (DECLARE (NOCOMPILE FOO)) or (DECLARE (NOCOMPILE (FOO BAR)))\n; was specified, then the function will be on the \"NOCOMPILE\" list,\n; so don't compile the definition.\n\n        (unless (cdr form) (go defun-error))\n        (if (symbolp (cadr form))\n         then\n            (desetq (nil defun-func . defun-rest) form)\n            (or defun-rest (go defun-error))\n            ;\n            ; Check type of DEFUN\n            ;\n            (case (car defun-rest)\n             ((expr fexpr macro) (setq defun-prop (car defun-rest)\n                                       defun-rest (cdr defun-rest)))\n             (t                  (setq defun-prop 'expr))\n            )\n            ;\n            ; Figure out what to do with DEFUN\n            ;\n            (setq arglist (car defun-rest))\n            (case defun-prop\n             (expr   (if  (memq defun-func (get '*zilco* 'nocompile))\n                      then\n                          (princ\n          \"NOCOMPILE requested, will load interpretive definition of \")\n                          (princ defun-func)\n                          (terpri)\n                          (push `(xdefun . ,(cdr form)) loadlist)\n                      else\n                          (push\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;`(zevdsub ',defun-func (subr ,defun-func))\n                                `(zdef ,defun-func)\n                                loadlist)\n                          (push form complist)\n                      endif\n                     ))\n             (macro  (setq defun-rest (cdr defun-rest))\n                     (push form complist)\n                     (eval form)  ; Also make macro def available.\n                     )\n             (fexpr  (princ\n\"FEXPR definition not compilable, will load interpretive definition of \"\n                     )\n                     (princ defun-func)\n                     (princ\n\" and transform it internally into a macro.\"\n                     )\n                     (terpri)\n                     (push `(xdefun . ,(cdr form)) loadlist)\n                     (let ((fexpr-subr (concat defun-func \" FEXPR\"))\n                          )\n                          (push `(defun ,fexpr-subr\n                                        ,(car defun-rest)\n                                        . ,(cdr defun-rest))\n                                complist)\n                          (push `(defmacro ,defun-func\n                                           (&rest x)\n                                           `(,',fexpr-subr `,',x))\n                                complist)\n                     ))\n             )\n         else\n         if (consp (cadr form))\n         then\n            (desetq (nil (defun-func defun-prop) . defun-rest) form)\n            (or defun-rest (go defun-error))\n            (if  (member (cadr form) (get '*zilco* 'nocompile))\n             then\n                 (princ\n          \"NOCOMPILE requested, will load interpretive definition of \")\n                 (princ (cadr form))\n                 (terpri)\n                 (push `(putprop ',defun-func\n                                 '(lambda . ,defun-rest) ; Note, no #'.\n                                 ',defun-prop)\n                       loadlist)\n             else                             ; ZILCO will compile #'s.\n                 (setq defun-name (concat defun-func \" \" defun-prop))\n                 (push `(putprop ',defun-func\n#+lexical-scoping                #',defun-name\n#-lexical-scoping                (subr ,defun-name)\n                                 ',defun-prop)\n                        loadlist)\n                 (push `(defun ,defun-name . ,(cddr form)) complist)\n             endif\n            )\n         else (go defun-error)\n         endif\n        )\n        (return)\n\n  defun-error\n\n        (terpri)\n        (princ \"Invalid DEFUN syntax: \")\n        (prin1 form)\n        (terpri)\n        (return)\n\n  process-declare\n\n        (push form complist)\n        (return)\n\n  process-defload\n\n        (push `(xdefload . ,(cdr form)) loadlist)\n        (push form complist)\n        (return)\n\n  process-defvar\n\n        (push `(xdefvar . ,(cdr form)) loadlist)\n        (push form complist)\n        (return)\n\n  process-progn\n\n        (mapc #'module-process-form (cdr form))\n        (return)\n\n  process-eval-when\n;\n; EVAL-WHEN is interpreted as follows:\n;\n; COMPILE - pass to the compiler as is.\n;\n; EVAL    - ignore.\n;\n; LOAD    - process like all the rest.\n;\n\n        (let* (\n               ((nil times . forms) form)\n               (compilep            (memq 'compile times))\n               (loadp               (memq 'load    times))\n              )\n              (loop for f in forms\n                    when compilep do (eval f)\n                    when loadp    do (module-process-form f)\n                    finally       (return nil)))\n\n        (return)\n\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXDEFSTR": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00\\x00\\x00\\x88\\x00o\\x00\\x89\\x15o\\tC\\x03\\x99\\x01\\x8a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "1988-01-06T00:00:00", "modifydate": "1989-06-05T09:43:00", "lines": 921, "newlines": 394, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for DEFSTRUCT.\n;\n; 12/16/88 - Fixed bug wrt not returning structure name in evaluator.\n;\n;\n; Example: (defstruct kons kar kdr) produces...\n;\n; (defmacro make-kons ... ) well, see below.\n;\n;          (defmacro kons-kar (x) `(vref ,x 1))\n;          (defmacro kons-kdr (x) `(vref ,x 2))\n;          (defmacro kons-p   (x) `(let ((y ,x))\n;                                       (and (structp y)\n;                                            (eq (vref y 0) 'kons))))\n;\n; As of 01/06/88, the following syntax is supported:\n;\n; Minimal: (defstruct struct-name slot1 slot2 slot3 ...)\n;\n; Maximal: (defstruct (struct-name (conc-name ...)\n;                                  (constructor ...)\n;                                  (copier ...)\n;                                  (eval-when ...)\n;                                  {array|tree})\n;                     (slot1 default-value)\n;                     (slot2 default-value)\n;                     (slot3 default-value)\n;                     ...)\n;\n; Note: All default values are evaluated at MAKE-foo time.\n;\n; Note: The value of the EVAL-WHEN attribute defaults to (COMPILE EVAL).\n;       This is so that DEFSTRUCT can be used within compiled FUNCTIONS\n;       without generating load-time code to initialize the DEFSTRUCT\n;       properties of the structure type name.  If you want to include\n;       a DEFSTRUCT in a MODULE, so that one will be able to type in\n;       structures, print them out, access them, etc., with the full\n;       functionality of DEFSTRUCT, you must specify\n;\n;     (defstruct (<name> ... (:eval-when (compile load eval)) ...) ...)\n;\n;       Otherwise the structure is for internal compile-time use only,\n;       and structures will be built, but they cannot be processed by\n;       run-time hacking.\n;\n;       This includes the establishment of a default print function,\n;       which can be done alternatively by assigning a function to\n;       the DEFSTRUCT-PRINT-METHOD property of the symbol.\n;       Similarly for DEFSTRUCT-FUNCALL-METHOD, etc.\n\n;;;\n;;; This might change somewhat, especially when structures are changed\n;;; so that the zeroth element is not a symbol naming the structure type\n;;; but a structure called a \"structure descriptor\".\n;;;\n;;; A \"structure descriptor\" is an object of type STRUCTURE-DESCRIPTOR.\n;;; It is a structure whose type is STRUCTURE-DESCRIPTOR (in other words\n;;; a \"structure descriptor\" whose name field contains the symbol\n;;; STRUCTURE-DESCRIPTOR - somewhat of an infinitely recursive def'n)\n;;; and has a name field (the symbol naming the type) and fields that\n;;; define the slots for structures of that type.\n;;;\n;;; The LISP system will have exactly N structure-descriptors, one for\n;;; each DEFSTRUCT-defined type, including one for STRUCTURE-DESCRIPTOR\n;;; itself.\n;;;\n;;; ... but like I said, not for a while yet ...\n;;;\n;;; Instead, all structure info is stored (for now) on the property list\n;;; of the name of the structure.  All the property names shall begin\n;;; with the characters \"DEFSTRUCT\", which are documented as \"reserved\"\n;;; (i.e. please don't use) in member $PROP of 'PROGLIB.ZIL.TEXT'.\n;;;\n;;; Also, the following properties are used by DEFSTRUCT:\n;;;\n;;; DEFSTRUCT-PROPERTIES     - holds all that DEFSTRUCT info.\n;;;\n;;; DEFSTRUCT-MACROS         - a list of all the macros defined.\n;;;\n;;; DEFSTRUCT-DOCUMENTATION  - the documentation string, if present.\n;;;\n;;; DEFSTRUCT-FUNCALL-METHOD - a function invoked when one tries to\n;;;                            FUNCALL/APPLY a structure.  Used most\n;;;                            notably by FLAVORS, for SEND.\n;;;\n;;; DEFSTRUCT-EVAL-METHOD    - a function invoked when one tries to\n;;;                            EVAL a structure.\n;;;\n;;; DEFSTRUCT-PRINT-METHOD   - a function invoked when one tries to\n;;;                            PRINT a structure.\n;;;\n;;; DEFSTRUCT-TYPEP-METHOD   - a function invoked by TYPEP when one\n;;;                            asks if the type of the structure is\n;;;                            so-and-so (i.e. 2-argument TYPEP).\n;;;\n;;;\n;;; MXDEFSTR is not only the macro expander for DEFSTRUCT, but also the\n;;; macro expander for the various macros generated by DEFSTRUCT, viz:\n;;;\n;;; (defun defstruct macro (x) (mxdefstr x))  ... Note, one arg, a list.\n;;;\n;;; (defmacro make-foo (&rest g00001)\n;;;  (mxdefstr 'constructor 'foo nil g00001)) ... Note, 5 args.\n;;;\n;;; (defmacro copy-foo (g00001 &rest g00002)\n;;;  (mxdefstr 'copier 'foo g00001 g00002))   ... Note, 5 args.\n;;;\n;;; (defmacro foo-p (g00001)\n;;;  (mxdefstr 'predicate 'foo nil g00001))   ... Note, 5 args.\n;;;\n;;; (defmacro foo-bar (g00001)\n;;;  (mxdefstr 'accessor 'foo 1 g00001))      ... Note, 5 args.\n;;;\n;;; (defmacro foo-baz (g00001)\n;;;  (mxdefstr 'accessor 'foo 2 g00001))      ... Note, 5 args.\n;;;\n\n(eval-when (eval)\n (defun defstruct macro (x) (mxdefstr x))\n)\n\n(defmacro isetq (var val)\n `(if (null ,var)\n      (setq ,var ,val)\n      (zerror \"Conflicting DEFSTRUCT arg specified\" ,val)))\n\n(defmacro set-defstruct-property (name prop value)\n (or (symbolp value) (zerror \"I want arg 3 to be a symbol. Sorry.\"))\n `(progn\n   (remprop ,name ,prop)\n   (when ,value\n         (putprop name ,value ,prop))))\n\n;======================================================================\n\n(defun mxdefstr (mkind &optional (sname () sname?) sparm sargs)\n (if (not sname?) ; If only 1 arg\n     (mxdefstr-original mkind)\n     (case mkind\n           ((constructor) (mxdefstr-constructor sname sparm sargs))\n           ((copier)      (mxdefstr-copier      sname sparm sargs))\n           ((predicate)   (mxdefstr-predicate   sname sparm sargs))\n           ((accessor)    (mxdefstr-accessor    sname sparm sargs))\n           (t\n            (zerror \"Invalid call to MXDEFSTR\" mkind)))))\n\n(defun mxdefstr-original (original-args)\n (let (((nil type . stuff) original-args)\n       (documentation))\n  (and stuff (stringp (car stuff))\n       (setq documentation (pop stuff)))\n  (let ((name (if (atom type) type (car type)))\n        (attrs (if (atom type)\n                   nil\n                   (mapcar #'mxdefstr-consify (cdr type))))\n        (slots (mapcar #'mxdefstr-slotify stuff))\n        (conc-name nil)\n        (implementation nil)\n        (constructor)\n        (constructor? 'default)\n        (boa-constructor nil)\n        (boa-constructor-arglist nil)\n        (copier)\n        (copier? 'default)\n        (predicate)\n        (predicate? 'default)\n        (eval-when '(compile eval)) ; <== Note the default!!!!\n       )\n       ;\n       ; Validate the structure name.\n       ;\n       (cond\n        ((or (not (symbolp name))\n             (null name)\n             (eq name t))\n         (zerror \"Invalid DEFSTRUCT type name\" name))\n        ((memq name '(\n                    ;\n                    ; Following list taken from TYPEP.  If you add new\n                    ; built-in types to TYPEP, be sure to add them here.\n                    ;\n                      atom bignum character closure code\n                      compiled-function cons defstruct double-float\n                      fixnum float flonum funarg integer list\n                      short-float single-float string struct structure\n                      subr symbol vector\n                     ))\n         (zerror \"Cannot use built-in type as DEFSTRUCT type name\" name))\n       )\n\n       (loop for (attr . value) in attrs\n        (case attr\n         ((:conc-name conc-name)\n          (cond\n            ((null value)                 ; (CONC-NAME) specified\n             nil)\n            ((null (cdr value))           ; (CONC-NAME arg1)\n             (setq conc-name\n                   (case (car value)\n                         ((nil \"\")   \"\") ; (CONC-NAME NIL) or\n                                         ; (CONC-NAME \"\") specified\n                         (t (concat (car value) \"-\")))))\n            (t\n             (mxdefstr-attr-error attr value))))\n         ((:constructor constructor)\n          (cond\n           ((null value)                  ; (CONSTRUCTOR) specified\n            (setq constructor? 'default))\n           ((null (cdr value))\n            (if (null (car value))        ; (CONSTRUCTOR NIL) specified\n                (setq constructor? nil)\n                (setq constructor? t      ; (CONSTRUCTOR anything)\n                      constructor (car value))))\n           ((null (cddr value))           ; (CONSTRUCTOR name (arglist))\n            (setq constructor? t\n                  constructor (car value)\n                  boa-constructor t\n                  boa-constructor-arglist (cadr value)))\n           (t                             ; (CONSTRUCTOR arg1 arg2 ...)\n            (mxdefstr-attr-error attr value))))\n         ((:copier copier)\n          (cond\n           ((null value)                  ; (COPIER) specified\n            (setq copier? 'default))\n           ((not (null (cdr value)))      ; (COPIER arg1 arg2 ...)\n            (mxdefstr-attr-error attr value))\n           ((null (car value))            ; (COPIER NIL) specified\n            (setq copier? nil))\n           (t                             ; (COPIER anything)\n            (setq copier? t\n                  copier (car value)))))\n         ((:predicate predicate)\n          (cond\n           ((null value)                  ; (PREDICATE) specified\n            (setq predicate? 'default))\n           ((not (null (cdr value)))      ; (PREDICATE arg1 arg2 ...)\n            (mxdefstr-attr-error attr value))\n           ((null (car value))            ; (PREDICATE NIL) specified\n            (setq predicate? nil))\n           (t                             ; (PREDICATE anything)\n            (setq predicate? t\n                  predicate (car value)))))\n         ((:eval-when eval-when)\n          (cond\n           ((null value)                  ; (EVAL-WHEN) specified\n            nil)\n           ((not (null (cdr value)))      ; (EVAL-WHEN arg1 arg2 ...)\n            (mxdefstr-attr-error attr value))\n           (t                             ; (EVAL-WHEN anything)\n            (setq eval-when (car value)))))\n         ((:array array)\n          (isetq implementation 'array))  ; (ARRAY anything) specified\n         ((:tree tree)\n          (isetq implementation 'tree))   ; (TREE anything) specified\n         (t\n          (warn \"Unsupported DEFSTRUCT option, ignored\" attr value))))\n       ;;;\n       ;;; Defaults for CONC-NAME, CONSTRUCTOR, COPIER, etc.\n       ;;; if the corresponding keyword attributes not specified.\n       ;;;\n       (unless conc-name\n               (setq conc-name (concat name \"-\")))\n       (when (eq constructor? 'default)\n             (setq constructor (concat \"MAKE-\" name)))\n       (when (eq copier? 'default)\n             (setq copier (concat \"COPY-\" name)))\n       (when (eq predicate? 'default)\n             (setq predicate (concat name \"-P\")))\n       ;;;\n       ;;; More checks.\n       ;;;\n\n       (and (eq implementation 'tree)\n            (not (eql (length slots) 2))\n            (zerror\n              \"DEFSTRUCT TREE implementation requires exactly 2 slots\"\n                   name))\n\n       ;;;\n       ;;; Build information defining the structure and hang it off\n       ;;; the property list of the structure name, under the\n       ;;; property name DEFSTRUCT-PROPERTIES.\n       ;;;\n       ;;; The value of DEFSTRUCT-PROPERTIES is an association list\n       ;;; something like this:\n       ;;;\n       ;;; (defstruct foo bar (baz 1) (frob (make-a-frob)))\n       ;;;\n       ;;; results in FOO having the DEFSTRUCT-PROPERTIES property of:\n       ;;;\n       ;;; ((conc-name        . \"FOO-\")\n       ;;;  (implementation   . nil)\n       ;;;  (constructor      . MAKE-FOO)\n       ;;;  (copier           . COPY-FOO)\n       ;;;  (predicate        . FOO-P)\n       ;;;  (slots            . ((:BAR BAR NIL)\n       ;;;                       (:BAZ BAZ 1)\n       ;;;                       (:FROB FROB (MAKE-A-FROB))))\n       ;;; )\n       ;;;\n       ;;; etc.\n       ;;;\n\n  ;;; DEFSTRUCT-PROPERTIES\n\n  (setf (get name 'defstruct-properties)\n        `((conc-name        . ,conc-name)\n          (implementation   . ,implementation)\n          (constructor      . ,constructor)\n          (copier           . ,copier)\n          (predicate        . ,predicate)\n          (slots            . ,slots)\n         ))\n\n  ;;; Remove existing macro properties, which will be reset by\n  ;;; the macro definers.\n\n  (let ((macros (remprop name 'defstruct-macros)))\n       (when macros\n        (warn \"Redefining DEFSTRUCT for this type\" name)\n        (dolist (m macros)\n         (remprop m 'macro))))\n\n  (remprop name 'defstruct-constructor-macro)\n\n  ;;; If there is no print-function defined, then set up the\n  ;;; default print method.  Note that the print method is\n  ;;; used only if the default (structure) type is specified.\n  ;;; Otherwise there's no way for the system to know that the\n  ;;; object is a \"foo\" made by MAKE-FOO, so what can you do?\n\n  (setf (get name 'defstruct-print-method)\n        #'mxdefstr-default-print-method)\n\n  ;;; Set up the rest of the properties.\n\n  (set-defstruct-property name 'defstruct-documentation  documentation)\n;;(set-defstruct-property name 'defstruct-funcall-method <nothing>)\n;;(set-defstruct-property name 'defstruct-eval-method    <nothing>)\n;;(set-defstruct-property name 'defstruct-print-method   <nothing>)\n;;(set-defstruct-property name 'defstruct-typep-method   <nothing>)\n\n `(progn\n   (eval-when ,eval-when\n    ,(when constructor?\n           (mxdefstr-define-constructor name constructor\n                boa-constructor boa-constructor-arglist))\n    ,(when copier?\n           (mxdefstr-define-copier name copier))\n    ,(when predicate?\n           (mxdefstr-define-predicate name predicate))\n    ,.(do* ((slots slots (cdr slots))\n            (index 1 (1+ index))\n            z)\n           ((null slots) (nreverse z))\n           (push (mxdefstr-define-accessor name\n                                           conc-name\n                                           (car slots)\n                                           index)\n                 z))\n   )\n   ,(if (memq 'load eval-when)\n        `(eval-when (load) (eval ',original-args))\n        '(progn))\n   (eval-when (eval) ',name)\n))))\n\n(defun mxdefstr-get (sname sprop)\n (cdr (or (assq sprop (get sname 'defstruct-properties))\n          (zerror \"No DEFSTRUCT properties found\" sname))))\n\n(defun mxdefstr-consify (x)\n (cond\n  ((atom x) (ncons x))\n  (t x)))\n\n;\n; Slots are   ((:name name value) (:name name value) ...)\n;\n\n(defun mxdefstr-slotify (x)\n (cond\n  ((keywordp x)       (list x              (unkeywordify x) nil))\n  ((symbolp x)        (list (keywordify x) x                nil))\n  ((atom x)\n   (zerror \"Illegal DEFSTRUCT slot identifier\" x))\n  ((keywordp (car x)) (list (car x)              (unkeywordify (car x))\n                                                 (cadr x)))\n  ((symbolp (car x))  (list (keywordify (car x)) (car x) (cadr x)))\n  (t\n   (zerror \"Illegal DEFSTRUCT slot identifier\" x))))\n\n(defun mxdefstr-define-constructor (name constructor\n                                boa-constructor boa-constructor-arglist)\n (mxdefstr-herald name constructor)\n (setf (get name 'defstruct-constructor-macro) constructor)\n ;\n ; The constructor macro must also be made the value of the\n ; DEFSTRUCT-CONSTRUCTOR-MACRO property, used by the #S reader macro.\n ;\n (let* ((g (gensym))\n        (h g)\n       )\n       (cond\n        (boa-constructor\n         (catch nil\n          (setq boa-constructor-arglist\n                (mxdefstr-boa-hack boa-constructor-arglist name))\n          (setq h\n           `(list . ,(nreverse\n                       (mapcan #'(lambda (x) `(',x ,(keywordify x)))\n                                  (llvars boa-constructor-arglist))))))\n         (when (eq h g)\n               (zerror \"Error in BOA constructor argument list\"\n                      name constructor boa-constructor-arglist))\n         `(defmacro ,constructor (&rest ,g)\n           `((lambda ,',boa-constructor-arglist\n                     ,(mxdefstr 'constructor ',name nil ,h))\n             . ,,g))\n        )\n        (t\n         `(defmacro ,constructor (&rest ,g)\n           (mxdefstr 'constructor ',name nil ,h))))))\n\n(defun mxdefstr-define-copier (name copier)\n (mxdefstr-herald name copier)\n (let ((g1 (gensym)) (g2 (gensym)))\n      `(defmacro ,copier (,g1 &rest ,g2)\n        (mxdefstr 'copier ',name ,g1 ,g2))))\n\n(defun mxdefstr-constructor (sname sparm sargs)\n (mxdefstr-constructor-or-copier 'constructor sname sparm sargs))\n\n(defun mxdefstr-copier (sname sparm sargs)\n (mxdefstr-constructor-or-copier 'copier sname sparm sargs))\n\n(defun mxdefstr-constructor-or-copier (kind name sparm sargs\n  &aux (maker           (mxdefstr-get name kind))\n       (slots           (mxdefstr-get name 'slots))\n       (implementation  (mxdefstr-get name 'implementation))\n       (used-slots      nil)\n       (letbinds        nil)\n  )\n\n (do ((x sargs (cddr x))\n      (z nil)\n      (slot)\n      (slotsym)\n     )\n     ((null x))\n     (unless (cdr x)\n             (zerror \"Odd number of arguments\" maker))\n     (setq slot (or (assq (keywordify (car x)) slots)\n                    (zerror \"Undefined slot name\" maker (car x))))\n     ;\n     ; For structure-implementation constructors, skip initializations\n     ; to NIL for efficiency.\n     ;\n     (cond\n      ((and (eq kind 'constructor)\n            (null implementation)\n            (null (cadr x)))\n       (push (cons (car slot) nil) used-slots))\n      (t\n       (setq slotsym (gensym))\n       (push (cons (car slot) slotsym) used-slots)\n       (push (list slotsym (cadr x)) letbinds)))\n )\n\n (setq letbinds (nreverse letbinds))\n\n `(let ,letbinds\n\n   ,(case implementation\n     (array\n      ;;;\n      ;;; Constructor:\n      ;;;\n      ;;; (make-foo :bar \"1\" :baz \"2\")\n      ;;; -->\n      ;;; (let ((bar \"1\") (baz \"2\"))\n      ;;;      (fillarray (array nil t 3)\n      ;;;                 (list 'foo bar baz)))\n      ;;;\n      ;;; Copier:\n      ;;;\n      ;;; (copy-foo old-foo :bar \"1\" :baz \"2\")\n      ;;; -->\n      ;;; (let ((bar \"1\") (baz \"2\"))\n      ;;;      (let ((g00001 (array nil t 3)))\n      ;;;           (fillarray g00001 old-foo)\n      ;;;           (arraycall t g00001 1 \"1\")\n      ;;;           (arraycall t g00001 2 \"2\")\n      ;;;           g00001))\n      ;;;\n      (case kind\n       (constructor\n        `(fillarray\n          (array nil t ,(1+ (length slots)))\n          (list ',name . ,(loop for x in slots\n                            with temp\n                            if (setq temp (assq (car x) used-slots))\n                            collect (cdr temp)\n                            else\n                            collect (caddr x)))))\n       (copier\n        (let ((g (gensym)))\n         `(let ((,g (array nil t ,(1+ (length slots)))))\n               (fillarray ,g ,sparm)\n               ,.(do ((x slots (cdr x))\n                      (y 1 (1+ y))\n                      (z nil)\n                      (temp)\n                     )\n                     ((null x) (nreverse z))\n                     ;;; Skip unspecified slots.\n                     (when (setq temp (assq (caar x) used-slots))\n                           (push `(arraycall t ,g ,y ,(cdr temp)) z))\n                 )\n               ,g)))\n       (t nil)))\n\n     (tree\n      ;;;\n      ;;; Constructor:\n      ;;;\n      ;;; (make-foo :bar 1 :baz 2)\n      ;;; -->\n      ;;; (let ((bar 1) (baz 2))\n      ;;;      (cons bar baz))\n      ;;;\n      ;;; Copier:\n      ;;;\n      ;;; (copy-foo oldfoo)\n      ;;; -->\n      ;;; (cons (zcar oldfoo) (cdr oldfoo))\n      ;;;\n      ;;; (copy-foo oldfoo :bar 1 :baz 2)\n      ;;; -->\n      ;;; (cons 1 2)\n      ;;;\n      (case kind\n       (constructor\n        `(cons . ,(loop for x in slots\n                        with temp\n                        if (setq temp (assq (car x) used-slots))\n                        collect (cdr temp)\n                        else\n                        collect (caddr x))))\n       (copier\n        (let* ((g nil)\n               (code\n               `(cons . ,(do ((x slots (cdr x))\n                              (y 1 (1+ y))\n                              (z nil)\n                              (temp)\n                             )\n                             ((null x) (nreverse z))\n                             (push\n                              (if (setq temp (assq (caar x) used-slots))\n                               (cdr temp)\n                               `(,(mxdefstr-tree-access-function name y)\n                                 ,(or g (setq g (gensym)))))\n                              z)))))\n              (if g `(let ((,g ,sparm)) ,code) code)))\n\n       (t nil)))\n\n     (otherwise\n      ;;;\n      ;;; Constructor:\n      ;;;\n      ;;; (make-foo :bar 1 :baz 2)\n      ;;; -->\n      ;;; (let ((bar 1) (baz 2))\n      ;;;      (let ((g00001 (mkstruct 3 'foo)))\n      ;;;            (vset g00001 1 bar)\n      ;;;            (vset g00001 2 baz)\n      ;;;            g00001))\n      ;;;\n      ;;;\n      ;;; Copier:\n      ;;;\n      ;;; (copy-foo old-foo :bar 1 :baz 2)\n      ;;; -->\n      ;;; (let ((bar 1) (baz 2))\n      ;;;      (let ((g00001 (vcopy old-foo)))\n      ;;;            (vset g00001 1 bar)\n      ;;;            (vset g00001 2 baz)\n      ;;;            g00001))\n      ;;;\n      (case kind\n            (constructor\n             (let ((g (gensym)))\n               `(let ((,g (mkstruct ,(1+ (length slots)) ',name)))\n                     ,.(do ((x slots (cdr x))\n                            (y 1 (1+ y))\n                            (z nil)\n                            (val)\n                            (temp)\n                           )\n                           ((null x) (nreverse z))\n                           (setq val\n                            (if (setq temp (assq (caar x) used-slots))\n                                (cdr temp)\n                                (caddar x)))\n                           ;;; Skip vsets to NIL: MKSTRUCT puts NIL in.\n                           (unless (null val)\n                                   (push `(vset ,g ,y ,val) z))\n                       )\n                       ,g)))\n            (copier\n             (let ((g (gensym)))\n               `(let ((,g (vcopy ,sparm)))\n                     ,.(do ((x slots (cdr x))\n                            (y 1 (1+ y))\n                            (z nil)\n                            (temp)\n                           )\n                           ((null x) (nreverse z))\n                           ;;; Skip unspecified slots.\n                           (when (setq temp (assq (caar x) used-slots))\n                                 (push `(vset ,g ,y ,(cdr temp)) z))\n                       )\n                       ,g)))\n            (t nil))))))\n\n\n(defun mxdefstr-define-accessor (name conc-name slot index)\n (let ((accessor (concat conc-name (cadr slot)))\n       (g (gensym)))\n      (mxdefstr-herald name accessor)\n      `(defmacro ,accessor (,g)\n        (mxdefstr 'accessor ',name ',index ,g))))\n\n(defun mxdefstr-accessor (name index sarg)\n (let ((implementation (mxdefstr-get name 'implementation)))\n  (case implementation\n\n   (array\n    `(arraycall t ,sarg ,index))\n\n   (tree\n    `(,(mxdefstr-tree-access-function name index) ,sarg))\n\n   (t\n    `(vref ,sarg ,index)))))\n\n\n(defun mxdefstr-tree-access-function (name i)\n (case i\n       (1 'zcar)\n       (2 'cdr)\n       (t (zerror \"Invalid index for DEFSTRUCT tree accessor\" name i))))\n\n(defun mxdefstr-define-predicate (name predicate)\n (let ((g (gensym)))\n      (mxdefstr-herald name predicate)\n      `(defmacro ,predicate (,g)\n        (mxdefstr 'predicate ',name nil ,g))))\n\n(defun mxdefstr-predicate (name ignore sarg)\n (let ((implementation (mxdefstr-get name 'implementation)))\n  (case implementation\n\n   (array\n    (let ((y (gensym)))\n         `(let ((,y ,sarg))\n               (and (arrayp ,y)\n                    (eql (array-\\#-dims ,y) 1)\n                    (not (zerop (array-dimension-n 1 ,y)))\n                    (eq (arraycall t ,y 0) ',name)))))\n\n   (tree\n    `(consp ,sarg))\n\n   (t\n;;;;`(typep ,sarg ',name) ; Sorry, may have to do it this way to\n;;;;;;;;;;;;;;;;;;;;;;;;;;; support INCLUDE option some day.\n    (let ((y (gensym)))\n         `(let ((y ,sarg))\n               (and (structp y) (eq (vref y 0) ',name))))\n))))\n\n\n(defun mxdefstr-herald (name x)\n (if (memq x (get name 'defstruct-macros))\n     (zerror \"Duplicate DEFSTRUCT definition generated\" x)\n     (push x (get name 'defstruct-macros)))\n (when (< (msglevel) 1)\n  (cterpri)\n  (princ \"DEFSTRUCT: Defining macro \")\n  (princ x)\n  (terpri)\n )\n)\n\n(declare (special *print-escape* *print-level* *print-length*))\n\n(defmacro low-level-print (a &key stream escape level)\n;;;\n;`(write ,a :stream ,stream :escape ,escape :level ,level)\n;;;\n (let ((ga (gensym))\n       (gs (gensym))\n      )\n      `(let (\n             (,ga ,a)\n             (,gs ,stream)\n             (*print-level* ,level)\n            )\n            (declare (special *print-level*))\n            (if ,escape\n                (prin1 ,ga ,gs)\n                (princ ,ga ,gs)))))\n\n(defun mxdefstr-default-print-method\n (a                     ; The object to be printed.\n  &optional\n  (f nil)               ; The file to print it on.\n;                         Should really default to *standard-output*.\n  (d 0)                 ; The current print depth.\n  (s *print-escape*)    ; Slashification?\n  &aux\n  (level *print-level*)\n )\n (princ \"#S\" f)\n (low-level-print (mxdefstr-default-print-structure-list a)\n                  :stream f\n                  :escape s\n                  :level (if level (- (1+ level) d)))\n a\n)\n\n(defun mxdefstr-default-print-structure-list (a)\n (let* ((name (vref a 0))\n        (slots (mxdefstr-get name 'slots))\n       )\n       (cons name (do ((slot slots (cdr slot))\n                       (i 1 (1+ i))\n                       (z nil)\n                      )\n                      ((null slot) (nreverse z))\n                      (push (caar slot) z)\n                      (push (vref a i) z)))))\n\n(defun mxdefstr-attr-error (attr value)\n (zerror \"Too many operands specified for this attribute\"\n        (cons attr value)))\n\n(eval-when ()\n#.(defvar lambda-list-keywords\n          '(&optional &rest &body &aux &key &allow-other-keys))\n)\n\n(defun mxdefstr-boa-hack (bvl name)\n (prog (z mode c c1 c2 c3 c3?)\n  loop\n       (when (atom bvl)\n             (when bvl\n                   (mxdefstr-get-initializer bvl name)) ; Check validity\n             (return (nreconc z bvl)))\n       (setq c (zcar bvl))    ; An argument spec from the lambda-list.\n       (cond\n        ((llkeywdp c)       ; If it's a lambda list keyword\n         (setq mode\n               (car (or (memq c '#.lambda-list-keywords)\n                        (zerror \"Unrecognized lambda list keyword\" c))))\n         (push mode z)\n         (setq bvl (cdr bvl))\n         (go loop)\n        )\n        (t\n         (case mode\n               ((nil)          (go required-arg))\n               ((&optional)    (go optional-arg))\n               ((&rest &body)  (go rest-arg))\n               ((&aux)         (go aux-arg))\n               ((&key)         (go key-arg))\n               (t (zerror \"Lambda list args following keyword\" mode)))\n        )\n       )\n\n required-arg\n\n       (push (mxdefstr-boa-hack c name) z)\n       (setq bvl (cdr bvl))\n       (go loop)\n\n optional-arg\n\n       (cond\n        ((atom c)\n         (setq c1 c\n               c2 (mxdefstr-get-initializer c1 name)\n               c3? nil\n               c3 nil))\n        ((null (cdr c))\n         (setq c1 (car c)\n               c2 (mxdefstr-get-initializer c1 name)\n               c3? nil\n               c3 nil))\n        (t\n         (setq c1 (car c)\n               c2 (cadr c)\n               c3? (cddr c)\n               c3 (caddr c))))\n       (if c3?\n           (setq c `(,(mxdefstr-boa-hack c1 name)\n                     ,c2\n                     ,(mxdefstr-boa-hack c3 name)\n                    ))\n           (setq c `(,(mxdefstr-boa-hack c1 name)\n                     ,c2\n                    ))\n       )\n       (push c z)\n       (setq bvl (cdr bvl))\n       (go loop)\n\n aux-arg\n\n       (cond\n        ((atom c)\n         (setq c1 c\n        ;;;;;; c2 (mxdefstr-get-initializer c1 name)\n               c2 nil))\n        ((null (cdr c))\n         (setq c1 (car c)\n        ;;;;;; c2 (mxdefstr-get-initializer c1 name)\n               c2 nil))\n        (t\n         (setq c1 (car c)\n               c2 (cadr c))))\n       (push `(,(mxdefstr-boa-hack c1 name) ,c2) z)\n       (setq bvl (cdr bvl))\n       (go loop)\n\n rest-arg\n\n       (push (mxdefstr-boa-hack c name) z)\n       (setq bvl (cdr bvl))\n       (go loop)\n\n key-arg\n\n ;\n ; Format of a &key entry:\n ;\n ; var\n ; (var)\n ; (var initform)\n ; (var initform suppliedp)\n ; ((:var var))\n ; ((:var var) initform)\n ; ((:var var) initform suppliedp)\n ;\n\n       (let (\n             (var)\n             (variable)\n             (keyword)\n             (initform)\n             (suppliedp)\n             (suppliedp?)\n            )\n            (cond\n             ((atom c)\n              (setq variable c\n                    keyword (keywordify variable)\n                    initform (mxdefstr-get-initializer variable name)\n                    suppliedp? nil\n                    suppliedp nil))\n             ((atom (setq var (car c)))\n              (setq variable var\n                    keyword (keywordify variable)\n                    initform (mxdefstr-get-initializer variable name)\n                    suppliedp? nil\n                    suppliedp (caddr c)))\n             ((or (null (cdr var))\n                  (cddr var))\n              (zerror \"Invalid &KEY keyword syntax\" c))\n             (t\n              (setq variable (cadr var)\n                    keyword (car var)\n                    initform (if (cdr c)\n                              (cadr c)\n                              (mxdefstr-get-initializer variable name))\n                    suppliedp? (cddr c)\n                    suppliedp (caddr c)))\n            )\n            (push `((,keyword ,(mxdefstr-boa-hack variable name))\n                    ,initform\n                    ,.(if suppliedp?\n                          (list (mxdefstr-boa-hack suppliedp name))\n                          nil))\n                   z)\n       )\n       (setq bvl (cdr bvl))\n       (go loop)\n\n ))\n\n(defun mxdefstr-get-initializer (key name)\n (unless (atom key)\n         (zerror \"Destructuring not permitted in this BOA argument slot\"\n                name key))\n (loop for slot in (mxdefstr-get name 'slots)\n       when (eq (cadr slot) key)\n       return (caddr slot)\n       finally (zerror \"Argument does not match any slot name\" name key)\n ))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MXDEFTRA": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x19O\\x00\\x89\\x15o\\tD\\x00\\x18\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-13T00:00:00", "modifydate": "1989-06-05T09:44:00", "lines": 24, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the DEFTRANS macro.\n;\n\n(eval-when (eval)\n (defmacro deftrans (a b &rest c)\n  (mxdeftra a b c)))\n\n(defun mxdeftra (a b c)\n (when (consp b)\n       (case (length b)\n             (1 (setq b `(,(car b) ,(gensym) ,(gensym))))\n             (3 nil)\n             (t (zerror \"Bad argument list for DEFTRANS\" b))))\n `(putprop ',a ,(if c `#'(lambda ,b . ,c) `',b) 'compiler-transform))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXDEFVAR": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x12\\x7f\\x00\\x89\\x15o\\tD\\x001\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-05-07T00:00:00", "modifydate": "1989-06-05T09:44:00", "lines": 49, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; The macro expander for the XDEFVAR macro.\n;;;\n;;;  (XDEFVAR variable &optional value documentation)\n;;;\n\n(eval-when (eval)\n (defun xdefvar macro (x) (mxdefvar x))\n)\n\n(defmacro d-var () `(car y))\n(defmacro d-val () `(cadr y))\n(defmacro d-doc () `(caddr y))\n\n(defmacro d-var-p  () `y)\n(defmacro d-val-p  () `(cdr y))\n(defmacro d-doc-p  () `(cddr y))\n(defmacro d-junk-p () `(cdddr y))\n\n(defun mxdefvar (x)\n (let ((y (cdr x)))\n  (unless (d-var-p) (zerror \"Too few arguments\" x))\n  (when (d-junk-p)  (zerror \"Too many arguments\" x))\n  (mxdefvar1 (d-var) (d-val) (d-val-p) (d-doc) (d-doc-p))))\n\n(defun mxdefvar1 (var val val? doc doc?)\n\n  (cond\n         ((not val?)\n          `(zevxvar ',var))\n         ((not doc?)\n          `(zevxvar ',var . ,(mxdefvar-maybe-thunk val)))\n         (t\n          `(zevxvar ',var ,@(mxdefvar-maybe-thunk val) ,doc))))\n\n(defun mxdefvar-maybe-thunk (x)\n (if (or (null x) (eq x t) (numberp x) (stringp x)\n         (and (consp x) (eq (car x) 'quote)))\n     `(nil ,x)\n     `(t #'(lambda () ,x))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXDESETQ": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tD\\x00\\\\\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:44:00", "lines": 92, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(eval-when (eval)\n (defun desetq macro (x) (mxdesetq x))\n)\n\n;\n; The macro expander for the DESETQ macro.\n;\n; This version of DESETQ does not do argument checking or use &-forms;\n; it provides basic destructuring capability only.\n;\n; Changes from ZIL 1.2:\n;\n; DESETQ takes any even number of arguments, and returns the last.\n;\n; Note: This macro expands into calls to CAR and CDR.  If you want\n;       to expand into ZCAR for efficiency, you must include\n;       (DEFLOAD CAR ZCAR) in your source.  This decision was made\n;       because it is very likely that someone will wish to\n;       destructure an argument into pieces that happens to be NIL.\n;\n; Some day, you will be able to do...\n;\n; (locally (defload car zcar)\n;          (desetq ...))\n;\n; but you'll have to wait until ZIL is a full Common LISP for that.\n;\n\n;;;\n;;; Sample macroexpansion:\n;;;\n;;; (DESETQ (A (B C) D . E) (FOO BAR)) -->\n;;;\n;;;  (LET ((G00001 (FOO BAR)))\n;;;        (SETQ A      (CAR G00001)\n;;;              B (CAR (CAR (CDR G00001)))\n;;;              C (CDR (CAR (CDR G00001)))\n;;;              D      (CAR (CDR (CDR G00001)))\n;;;              E      (CDR (CDR (CDR G00001)))))\n;;;\n\n(defun mxdesetq (x)\n (do ((args (cdr x) (cddr args))\n      (z nil)\n     )\n     ((null args) `(progn . ,(nreverse z)))\n     (when (null (cdr args))\n           (zerror \"Odd number of args to DESETQ\" x))\n     (push (mxdesetq1 (car args) (cadr args)) z)))\n\n(defun mxdesetq1 (a b)\n (cond\n  ((atom a)                `(setq ,a ,b))\n  ((simple-expression-p b) `(progn ,(destructuring-setq a b) ,b))\n  (t\n   (let ((x (gensym)))\n        `(let ((,x ,b))\n              ,(destructuring-setq a x)\n              ,x)))))\n\n(defmacro destructuring-setq (a b)\n ``(setq . ,(nreverse (expand-destructuring ,a ,b))))\n\n(defun expand-destructuring (a b)\n (prog (z)\n  loop (unless a (return z))\n       (when (atom a)\n             (push a z)\n             (push b z)\n             (return z))\n       (setq z (nconc (expand-destructuring (car a) `(car ,b)) z)\n             a (cdr a)\n             b `(cdr ,b))\n       (go loop)))\n\n(defun simple-expression-p (a)\n (let ((a (macroexpand a)))\n      (or (atom a)\n          (eq (car a) 'quote)\n          (and (memq (car a) '(car cdr zcar zcdr))\n               (consp (cdr a))\n               (simple-expression-p (cadr a))))))\n\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXDO": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tD\\x01z\\x01C\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:44:00", "lines": 378, "newlines": 323, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The DO macro expander.\n;\n; E.G.: (these are sort-of expansions, not always exactly this way)\n;\n;  (DO ((I1 A1 (CDR I1))\n;       (I2 A2 (ADD1 I2))\n;       (I3 A3 (SUB1 I3))\n;      )\n;      ((ATOM I1) (SOME STUFF) (SOME VALUE))\n;      (DO SOMETHING)\n;      (DO SOMETHING ELSE)\n;  )\n;       -->\n;\n; ((LAMBDA (I1 I2 I3)\n;    (PROG ()\n;      LOOP\n;       (COND (ATOM I1)\n;             (RETURN (PROGN (SOME STUFF) (SOME VALUE))))\n;       (DO SOMETHING)\n;       (DO SOMETHING ELSE)\n;       (PSETQ I1 (CDR I1) I2 (ADD1 I2) I3 (SUB1 I3))\n;       (GO LOOP)))\n;  (A1 A2 A3)\n; )\n;\n; The DO* macro expander.\n;\n; E.G.:\n;\n;  (DO* ((I1 A1 (CDR I1))\n;        (I2 A2 (ADD1 I2))\n;        (I3 A3 (SUB1 I3))\n;       )\n;       ((ATOM I1) (SOME STUFF) (SOME VALUE))\n;       (DO SOMETHING)\n;       (DO SOMETHING ELSE)\n;   )\n;       -->\n;\n; ((LAMBDA (I1)\n;   ((LAMBDA (I2)\n;     ((LAMBDA (I3)\n;       (PROG ()\n;         LOOP\n;          (COND (ATOM I1)\n;                (RETURN (PROGN (SOME STUFF) (SOME VALUE))))\n;          (DO SOMETHING)\n;          (DO SOMETHING ELSE)\n;          (PSETQ I1 (CDR I1) I2 (ADD1 I2) I3 (SUB1 I3))\n;          (GO LOOP)))\n;        A3))\n;    A2))\n;  A1)\n;\n\n\n(eval-when (eval)\n (defun do macro (x) (mxdo x))\n (defun do* macro (x) (mxdo x))\n (defun dolist macro (x) (mxdo x))\n (defun dotimes macro (x) (mxdo x))\n)\n\n(defun mxdo (x)\n (case (car x)\n       (dotimes   (mxdotimes (cdr x)))\n       (dolist    (mxdolist  (cdr x)))\n       ((do do*)  (mxdo-ijk  x))\n       (t (zerror \"Unknown caller of MXDO\" (car x)))))\n\n(defun mxdo-ijk (arg &aux\n                          (macroname (car arg))\n                          (x (cdr arg))\n                )\n (unless x (zerror \"Missing args\" macroname))\n (cond\n  ((listp (car x))\n   (unless (cdr x) (zerror \"Invalid syntax\" arg))\n   (let (((i j . k) x))\n                          i ; the list of iteration constructs\n                          j ; the termination construct\n                          k ; the body\n        (case macroname\n              (do      (mxdo1 i j k i 'psetq))\n              (do*     (mxdo* i j k i)))))\n  (t\n   (mxdo-old x))))\n\n;\n; MXDO1 - operates on 4 arguments:\n;\n;   I - the list of iteration triples for initialization\n;   J - the termination pair\n;   K - the body (rest of the form) in form (declarations . body)\n;   L - the list of iteration triples for incrementing\n;\n(defun mxdo1 (i j k l setq-or-psetq)\n (let (((dcls . body) (do-split-body k))\n       (loop (gensym)) (cond nil) (term nil))\n  (if j\n      (if (atom j)\n          (zerror \"Invalid DO termination form\" j)\n          (setq cond (car j)\n                term `((return (progn . ,(cdr j)))))))\n\n  `((lambda ,(mapcar #'do-var i)            ; Local variable list.\n            ,.dcls                          ; Declarations.\n            (prog ()\n                  ,loop                     ; Iteration tag.\n                  . ,(mxdo-body cond                ; Termination test.\n                                term                ; Return forms.\n                                `(\n                                  ,@body            ; Body.\n                                  ,(do-incr l setq-or-psetq);\n                                                    ; Step DO variables.\n                                  ,(and j `(go ,loop)) ; Iterate.\n                                 )\n                  )))\n    ,.(mapcar #'do-bind i))))               ; Initial binding of locals.\n\n(defun do-var (x)\n (cond ((atom x) x) (t (car x)))\n)\n\n(defun do-bind (x)\n (and (consp x) (cdr x) (cadr x))\n)\n\n(defun do-cond (x)\n (if x\n     (if (atom x)\n         (zerror \"Invalid DO termination form\" x)\n         `(cond (,(car x) (return (progn . ,(cdr x))))))\n     nil))\n\n(defun do-incr (x setq-or-psetq)\n (prog (y v)\n  loop (or x (return `(,setq-or-psetq . ,(nreverse v))))\n       (setq y (car x))\n       (when (and (consp y) (cdr y) (cddr y))\n             (and (cdddr y) (zerror \"Invalid DO initialization form\" y))\n             (push (car y) v)\n             (push (caddr y) v))\n       (setq x (cdr x))\n       (go loop)))\n\n(defun mxdo-old (x) ; The old-style Maclisp DO.\n (unless (and (cdr x)\n              (cddr x)\n              (cdddr x))\n         (zerror \"Invalid DO syntax\" x))\n (let*(\n       ((var init repeat endtest . rest) x)\n       ((dcls . body) (do-split-body rest))\n       (loop (gensym))\n       (g (gensym))\n      )\n      `(let ((,var ,init))\n            ,.dcls\n            (prog ()\n                  ,loop\n                  . ,(mxdo-body endtest\n                                '(\n                                  (return nil)\n                                 )\n                                `(\n                                  ,@body\n                                  (setq ,var ,repeat)\n                                  (go ,loop)))))))\n\n\n;\n; The DO* macro expander.\n;\n;\n; MXDO* - operates on 4 arguments:\n;\n;   I - the list of iteration triples for initialization\n;   J - the termination pair\n;   K - the body (rest of the form)\n;   L - the list of iteration triples for incrementing\n;\n\n(defun mxdo* (i j k l)\n (cond\n  ((null i)        (mxdo1 () j k l 'setq))\n  ((null (cdr i))  (mxdo1  i j k l 'setq))\n  (t\n   (let* ((var (do-var (car i)))\n         )\n    (multiple-value-bind (d b)\n                         (mxdo*-extract-declarations var k)\n     `((lambda (,var)\n               ,.d\n               ,(mxdo* (cdr i) j b l))\n       ,(do-bind (car i))))))))\n\n(defun mxdo*-extract-declarations (a b)\n\n;;; This function returns two values:\n;;;\n;;; (1) NIL or a DECLARE SPECIAL form for args in A that are special\n;;;     (that is, a list of one such form for nconcability)\n;;; (2) a copy of the body B with possibly macroexpanded forms in it\n;;;\n;;; First, locate any declarations in the body.  We won't take them\n;;; out of there, but we do want to know which variables are\n;;; declared special therein.  Any variables that are declared\n;;; special and also occur in the local DO* variables must have\n;;; SPECIAL declarations inserted in the appropriate places between\n;;; the inner DOs.\n;;;\n;;; Note that we can get away with leaving the original special\n;;; declarations where they were found, because SPECIAL declarations\n;;; are defined to be pervasive wrt REFERENCES, and we assume that\n;;; either no BINDINGS of those variables are duplicated further in\n;;; or (if they are, which is probably an error anyway, though this\n;;; has been hotly debated) they're SPECIAL too!\n;;;\n\n (multiple-value-bind (nil declarations body pmxform pmxvalid)\n                      (parse-body b)\n\n  (when pmxvalid (setq body (cons pmxform (cdr body))))\n\n  (let (\n        (d nil)\n       )\n   (mapc #'(lambda (declaration)\n                   (and (consp declaration)\n                        (eq (car declaration) 'special)\n                        (memq a (cdr declaration))\n                        (not (memq a d))\n                        (push a d)))\n         declarations)\n\n;;; \"d\" is now a list of the variables that need to be declared\n;;; special in the currently enclosing DO.\n\n   (when d (setq d `((declare (special . ,d))))) ; To be NCONCed in.\n\n   (when declarations\n         (setq body `((declare . ,declarations) . ,body)))\n\n   (values d body))))\n\n\n;\n;***********************************************************************\n;*                                                                     *\n;* The DOLIST macro expander.                                          *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun mxdolist (x)\n (unless (and x (cdr x))\n         (zerror \"Invalid DOLIST syntax\"))\n (let (((a . b) x))        ; a = iteration spec, b = body\n      (when (or (atom a) (atom (cdr a)))\n            (zerror \"Invalid DOLIST variable definition\" a))\n      (let (((v w r) a)    ; v = the step variable\n                           ; w = the list\n                           ; r = the result, defaulting to NIL.\n            ((dcls . body) (do-split-body b))\n                           ; dcls = declarations, body = body\n            (g (gensym))   ; a variable to hold the list.\n            (l (gensym)))  ; a variable to hold the loop tag.\n           `((lambda (,g)\n                     (prog (,v)\n                           ,.dcls\n                           ,l\n                           . ,(mxdo-body `(not ,g)\n                                         `(\n                                           (setq ,v nil)\n                                           (return ,r)\n                                          )\n                                         `(\n                                           (setq ,v (zcar ,g))\n                                           ,@body\n                                           (setq ,g (cdr ,g))\n                                           (go ,l)\n                                          )\n                      )))\n             ,w))))\n\n\n;\n;***********************************************************************\n;*                                                                     *\n;* The DOTIMES macro expander.                                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun mxdotimes (x)\n (unless (and x (cdr x))\n         (zerror \"Invalid DOTIMES syntax\"))\n (let (((a . b) x))        ; a = iteration spec, b = body\n      (when (or (atom a) (atom (cdr a)))\n            (zerror \"Invalid DOTIMES variable definition\" a))\n      (let (((v w r) a)    ; v = the step variable\n                           ; w = the limit\n                           ; r = the result, defaulting to NIL.\n            ((dcls . body) (do-split-body b))\n                           ; dcls = declarations, body = body\n            (g (gensym))   ; a variable to hold the limit.\n            (l (gensym)))  ; a variable to hold the loop tag.\n            (let ((prog `(prog (,v)\n                           ,.dcls\n                           (setq ,v 0)\n                           ,l\n                           . ,(mxdo-body\n                                `(not (lessp ,v ,(if (integerp w) w g)))\n                                `(\n                                  (return ,r)\n                                 )\n                                `(\n                                  ,@body\n                                  (setq ,v (add1 ,v))\n                                  (go ,l)\n                                 )\n                              ))))\n\n                (if (integerp w)\n                    prog\n                    `((lambda (,g) ,prog) ,w))))))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This function processes a condition/termination/body group.         *\n;*                                                                     *\n;***********************************************************************\n;\n(defun mxdo-body (cond term body)\n (cond\n  ((null cond)\n   body)         ; Old body, declarations and all\n  ((mapor #'(lambda (x) (and x (atom x))) body) ; Any GO tags in body?\n   `((cond (,cond . ,term)) . ,body))  ; If so, must branch around body\n  (t                                   ; Else branch out to return...\n   `((cond (,(mxdo-negate cond) . ,body)) . ,term)))) ; compiles better\n\n(defun mxdo-negate (cond)\n (if (and (consp cond)\n          (cdr cond)\n          (or (eq (car cond) 'not)\n              (eq (car cond) 'null)))\n     (cadr cond)\n     `(not ,cond)))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This function extracts declarations from a body.                    *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun do-split-body (body)\n (multiple-value-bind (nil pdecls pbody pmxform pmxvalid)\n                      (parse-body body)\n  (when pmxvalid\n        (setq pbody (cons pmxform (cdr pbody))))\n  (when pdecls (setq pdecls `((declare . ,pdecls))))\n  (cons pdecls pbody)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXIF": {"ttr": 2062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tD\\x00l\\x00q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:44:00", "lines": 108, "newlines": 113, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This SUBR performs the macro expansion for the \"IF\" macro.\n;\n;\n; Non-Common-Lisp features:\n;\n; *  THEN, ELSE, ELSEIF, ENDIF keywords (actually not \"keywords\")\n;\n; *  Multiple ELSE forms (mandated by Macsyma source code)\n;\n; *  Missing consequent form on WHEN/UNLESS (ditto)\n;\n\n (defun mxif (x)\n  (case (car x)\n   (if                   (mxif-if     (cdr x)))\n   (when                 (mxif-when   (cdr x)))\n   (unless               (mxif-unless (cdr x)))\n   (t                    (zerror \"Unknown caller of MXIF\" (car x)))))\n\n (defun mxif-if (q)\n  (cond\n   ((or (null q)\n        (null (cdr q)))      (zerror \"Invalid IF syntax\" `(if . ,q)))\n   ((eq (cadr q) 'then)      `(cond . ,(mxif1 q)))\n   (t                        (mx-cl-if (car q) (cadr q) (cddr q)))))\n\n (defun mx-cl-if (if then else)\n  (cond\n   ((null else)  `(cond (,if ,then)))\n   (t            `(cond (,if ,then) (t . ,else)))))\n\n (defun mxif-when (x)\n  (cond\n   ((null x)       (warn \"Null WHEN form\")\n                   nil)\n   ((null (cdr x)) (warn \"Missing WHEN consequent\" `(when . ,x))\n                   `(cond (,(car x) nil)))\n   (t              `(cond (,(car x) . ,(cdr x))))))\n\n (defun mxif-unless (x)\n  (cond\n   ((null x)       (warn \"Null UNLESS form\")\n                   nil)\n   ((null (cdr x)) (warn \"Missing UNLESS consequent\" `(unless . ,x))\n                   `(cond ((null ,(car x)) nil)))\n   (t              `(cond ((null ,(car x)) . ,(cdr x))))))\n\n ;;;\n ;;; Q should be: (condition THEN truepath whatnext...)\n ;;;              where (whatnext...) is passed to MXIF2 and\n ;;;                    should begin with ENDIF/ELSE/ELSEIF or be null.\n ;;;\n\n (defun mxif1 (q)\n  (cond\n   ((not (and q (cdr q) (cddr q)))\n    (zerror \"Incomplete IF form\" q))\n   ((neq (cadr q) 'then)\n    (zerror \"Missing \\\"THEN\\\" in IF form\" q))\n   (t\n    (let (((truepath . whatnext)\n          (ifbreak (cddr q) '(then else elseif endif))))\n         (cons (cons (car q) truepath) (mxif2 whatnext))))))\n ;;;\n ;;; Q may be:\n ;;; ENDIF\n ;;; ELSE xxx ENDIF\n ;;; ELSEIF xxx THEN yyy ...\n ;;; ELSE IF xxx THEN yyy ...\n ;;;\n (defun mxif2 (q)\n  (cond\n   ((null q)                ; If a then b\n    nil)\n   ((null (cdr q))          ; If a then b endif\n    (cond\n     ((eq (car q) 'endif) nil)\n     (t   (zerror \"IF form ends with token other than \\\"ENDIF\\\"\" q))))\n   ((eq (car q) 'elseif)    ; If a then b elseif ...\n    (mxif1 (cdr q)))\n   ((eq (car q) 'else)      ; If a then b else ...\n    (prog (stuff)\n     (and (eq (cadr q) 'if) (return (mxif1 (cddr q))))\n     (setq stuff (ifbreak (cdr q) '(then else elseif endif)))\n     (or (null (cdr stuff))\n         (eq (cadr stuff) 'endif)\n         (zerror \"Invalid syntax following \\\"ELSE\\\" in IF form\" q))\n     (return `((t . ,(car stuff))))))\n   (t\n   (zerror \"Missing \\\"ELSE\\\", \\\"ELSEIF\\\", or \\\"ENDIF\\\" in IF statement\"))\n  )\n )\n\n(defun ifbreak (l m)\n (loop for subl on l\n       until (memq (car subl) m)\n       collect (car subl) into z\n       finally (return (cons z subl))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXINCF": {"ttr": 2064, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tD\\x00\\x16\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:44:00", "lines": 22, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the INCF macro.\n;\n\n(eval-when (eval)\n (defmacro incf (a &optional (b 1)) (mxincf a b))\n)\n\n(defun mxincf (place increment)\n `(setf ,place ,(case increment\n                      ((1)  `(add1 ,place))\n                      ((-1) `(sub1 ,place))\n                      (t    `(ziladd ,place ,increment)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXLET": {"ttr": 2066, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tE\\x00\\xe8\\x00\\xcd\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:45:00", "lines": 232, "newlines": 205, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This SUBR performs the macro expansion for the \"LET\" macro.\n;;;\n;;; e.g.\n;;;\n;;; (LET ((A VALUE-OF-A)\n;;;       (B VALUE-OF-B)\n;;;       (C VALUE-OF-C))\n;;;      (FORM 1)\n;;;      (FORM 2)\n;;;      (FORM 3)\n;;; )\n;;;\n;;; gives:\n;;;\n;;; ((LAMBDA (A B C) (FORM 1) (FORM 2) (FORM 3))\n;;;  VALUE-OF-A VALUE-OF-B VALUE-OF-C)\n;;;\n;;;\n;;; (LET* ((A VALUE-OF-A)\n;;;        (B VALUE-OF-B)\n;;;        (C VALUE-OF-C))\n;;;       (FORM 1)\n;;;       (FORM 2)\n;;;       (FORM 3)\n;;; )\n;;;\n;;; gives:\n;;;\n;;; ((LAMBDA (A)\n;;;   ((LAMBDA (B)\n;;;     ((LAMBDA (C) (FORM 1) (FORM 2) (FORM 3))\n;;;     VALUE-OF-C))\n;;;    VALUE-OF-B))\n;;;  VALUE-OF-A)\n;;;\n;;; assuming:\n;;;\n;;; (DEFUN LET  MACRO (X) (MXLET X))\n;;; (DEFUN LET* MACRO (X) (MXLET X))\n;;;\n;;; Destructuring is also supported.\n;;;\n\n(defun mxlet (x)\n ((lambda ((macname . macbody))\n;\n; (CAR MACBODY) = list of variable-value pairs\n; (CDR MACBODY) = list of forms\n;\n   (when (or (null macbody)\n             (and (car macbody) (atom (car macbody))))\n         (zerror \"Invalid syntax\" x))\n   (mapc #'let-check (car macbody))\n   (let-or-let*-expand\n            (mapcar #'let-local (car macbody)) ; List of local vars\n            (cdr macbody)                      ; The body\n            (mapcar #'let-value (car macbody)) ; List of values\n            macname))                          ; LET or LET*\n x))\n\n(defun let-or-let*-expand (a b c macname)\n;\n; a - the list of local variables\n; b - the body\n; c - the list of values\n;\n (cond\n  ((eq macname 'let)    `((lambda ,a . ,b) . ,c))\n  ((eq macname 'let*)   (let*-expand a b c))\n  (t      (zerror \"Unknown caller of MXLET\" macname))))\n\n\n(defun let*-expand (a b c)\n;\n; a - the list of local variables\n; b - the body\n; c - the list of values\n;\n\n (mxlet\n  (cond\n   ((null a)        `(let () . ,b))\n   ((null (cdr a))  `(let ((,(car a) ,(car c))) . ,b))\n   (t\n    (multiple-value-bind (decl newbody)\n                         (let*-extract-declarations (car a) b)\n     `(let ((,(car a) ,(car c)))\n            ,.decl\n            ,(let*-expand (cdr a) newbody (cdr c))))))))\n\n(defun let-local (x)\n (cond ((atom x) x) (t (car x))))\n\n(defun let-value (x)\n (and (consp x) (cdr x) (cadr x)))\n\n(defun let-check (x)\n (and (consp x)\n      (cdr x)\n      (cddr x)\n      (warn \"Invalid LET bind spec\" x))) ; changed from ERROR 04/28/86\n                                         ; to get around Macsyma bug\n\n(defun let*-extract-declarations (a b)\n\n;;; This function returns two values:\n;;;\n;;; (1) NIL or a DECLARE SPECIAL form for args in A that are special\n;;;     (that is, a list of one such form for nconcability)\n;;; (2) a copy of the body B with possibly macroexpanded forms in it\n;;;\n;;; First, locate any declarations in the body.  We won't take them\n;;; out of there, but we do want to know which variables are\n;;; declared special therein.  Any variables that are declared\n;;; special and also occur in the local LET* variables must have\n;;; SPECIAL declarations inserted in the appropriate places between\n;;; the inner LETs.\n;;;\n;;; Note that we can get away with leaving the original special\n;;; declarations where they were found, because SPECIAL declarations\n;;; are defined to be pervasive wrt REFERENCES, and we assume that\n;;; either no BINDINGS of those variables are duplicated further in\n;;; or (if they are, which is probably an error anyway, though this\n;;; has been hotly debated) they're SPECIAL too!\n;;;\n\n (multiple-value-bind (nil declarations body pmxform pmxvalid)\n                      (parse-body b)\n\n  (when pmxvalid (setq body (cons pmxform (cdr body))))\n\n  (let (\n        (d nil)\n        (locals (llvars a)) ; Get lambda list vars from\n                            ; possible destructuring-form arg.\n       )\n       (dolist (declaration declarations)\n               (and (consp declaration)\n                    (eq (car declaration) 'special)\n                    (dolist (variable (cdr declaration))\n                            (and (memq variable locals)\n                                 (not (memq variable d))\n                                 (push variable d)))))\n\n;;; \"d\" is now a list of the variables that need to be declared\n;;; special in the currently enclosing LET.\n\n   (when d (setq d `((declare (special . ,d))))) ; To be NCONCed in.\n\n   (when declarations\n         (setq body `((declare . ,declarations) . ,body)))\n\n   (values d body))))\n\n\n;;;;; Obsolete code fragments start here. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; This used to be used by LET* when it expanded into nested PROGs.\n; Now that it expands into nested lambdas, we don't need it.\n;\n;(defun inner-let* (a b c g)\n; (prog (v h)\n;  (setq v (car a))\n;  (return\n;   (if c\n;    then\n;     `(prog (,.(let-locals v) ,(setq h (gensym)))\n;            ,(let-build-setq v g)\n;            (setq ,h ,(car c))\n;            (return ,(inner-let* (cdr a) b (cdr c) h)))\n;    else\n;     `(prog ,(let-locals v)\n;            ,(let-build-setq v g)\n;            (return (progn . ,b)))))))\n;\n;(defun let-variable-list (x)\n; (mapcan #'let-locals x)\n;)\n;\n;(defun let-locals (x)\n; (cond\n;  ((null x)        nil)\n;  ((atom x)        (list x))\n;  ((null (cdr x))  (let-locals (car x)))\n;  (t               (nconc (let-locals (car x))\n;                          (let-locals (cdr x))))))\n;\n;\n; This hack is no longer needed now that full destructuring DEFUN\n; is supported in the ZIL compiler and interpreter.\n;\n;;; (defun let-destructure-hack (a)\n;;;  (prog (auxforms z g de-vars de-forms)\n;;;   loop (or a (go finish))\n;;;        (if (atom (car a))\n;;;         then\n;;;            (push (car a) z)\n;;;         else\n;;;            (setq auxforms (let-add-args (car a) auxforms))\n;;;            (push (setq g (gensym)) z)\n;;;            (push `(desetq ,(car a) ,g) de-forms)\n;;;        )\n;;;        (setq a (cdr a))\n;;;        (go loop)\n;;;   finish\n;;;        (setq de-vars\n;;;         (if  auxforms\n;;;          then\n;;;              `(,.(nreverse z) &aux . ,(nreverse auxforms))\n;;;          else\n;;;              (nreverse z)\n;;;          endif\n;;;         )\n;;;        )\n;;;        (return (cons de-vars (nreverse de-forms)))))\n;;;\n;;; (defun let-add-args (var arglist)\n;;;  (cond\n;;;   ((null var)       arglist)\n;;;   ((atom var)       (list* var arglist))\n;;;   (t (let-add-args (car var)\n;;;                    (let-add-args (cdr var) arglist)))))\n;;;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXLIST": {"ttr": 2069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tE\\x00\"\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:45:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This SUBR performs the macro expansion for the LIST and LIST*\n;;; macros (the LIST macro used only by the compiler).\n\n;;;\n;;; (DEFUN LIST MACRO (X) (MXLIST X))\n;;; (DEFUN LIST* MACRO (X) (MXLIST X))\n;;;\n\n(defun mxlist (l)\n (case (car l)\n  (list              (mxlist1 (cdr l)))\n  (list*             (mxlist* (cdr l)))\n  (t                 (zerror \"Unknown caller of MXLIST\" (car l)))))\n\n(defun mxlist1 (l)\n (cond\n  ((null l) nil)\n  (t        `(cons ,(car l) ,(mxlist1 (cdr l))))))\n\n(defun mxlist* (l)\n (cond\n  ((null l)       (zerror \"Missing argument\" 'list*))\n  ((null (cdr l)) `,(car l))\n  (t              `(cons ,(car l) ,(mxlist* (cdr l))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXLOOP": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tI\\x02\\xe4\\x02\\xc7\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:49:00", "lines": 740, "newlines": 711, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the LOOP macro.\n;\n; e.g. (DEFUN LOOP MACRO (X) (MXLOOP X))\n;\n\n(eval-when (eval)\n (defload the-real-mxloop mxloop)\n (defun loop macro (x) (the-real-mxloop x))\n (defun loop13 macro (x) (mxloop x))\n (format t \"~2%Test with LOOP13 macro.  LOOP macro unaffected.~2%\")\n)\n\n(defmacro rest-op ()\n '(lpstr-x s))\n\n(defmacro this-op ()\n `(car (lpstr-x s)))\n\n(defmacro more-op ()\n `(cdr (lpstr-x s)))\n\n(defmacro next-x (&optional tag)\n (cond\n  (tag\n   `(or (and (lpstr-x s) (setf (lpstr-x s) (cdr (lpstr-x s))))\n        (go ,tag)))\n  (t\n   `(cond ((lpstr-x s) (setf (lpstr-x s) (cdr (lpstr-x s))))))))\n\n(defmacro add-args (var)\n `(setf (lpstr-arglist s) (loop-add-args ,var (lpstr-arglist s)))\n)\n\n(defstruct lpstr      ; LOOP structure, passed around.\n           x          ; the LOOP arguments (from the LOOP form)\n           arglist    ; the list of local variables\n           initforms  ; the initialization forms\n           testforms  ; the termination-test forms\n           auxforms   ; the auxiliary forms\n           bodyforms  ; the body forms\n           incrforms  ; the step forms\n           termforms  ; the termination forms\n           boolean    ; on if \"always\" or \"never\" specified\n           exit       ; Tag to exit from loop\n           initially  ; \"Initially\" forms\n           finally    ; \"Finally\"   forms\n)\n\n(defun mxloop (x)\n (prog (\n         s                ; holds the LOOP structure\n         a                ; holds each LOOP argument\n         z                ; holds the return value\n         loop             ; Tag to loop back to\n        )\n  (setq z    (gensym)\n        loop (gensym))\n\n  (setq s (make-lpstr :x         (or (cdr x)\n                                     (zerror \"No LOOP operands\"))\n                      :arglist   (list z)\n                    ; :initforms\n                    ; :testforms\n                    ; :auxforms\n                    ; :bodyforms\n                    ; :incrforms\n                    ; :termforms\n                    ; :boolean\n                      :exit      (gensym)\n                    ; :initially\n                    ; :finally\n          ))\n\n process-loop-binders\n\n  (when (loop-binder-stuff s)\n        (go process-loop-binders))\n\n main-loop\n\n  (or (rest-op) (go finished))\n\n process-body-clause\n\n  (when (setq a (loop-action z nil s))\n        (push a (lpstr-bodyforms s)))\n\n  (go main-loop)\n\n finished\n\n  (if (lpstr-boolean s) (setq z (car (lpstr-boolean s))))\n\n  (push `(go ,loop)   (lpstr-incrforms s))\n  (setq a (last (lpstr-finally s)))\n  (unless (and (consp a)\n               (consp (car a))\n               (eq (caar a) 'return))\n          (push `(return ,z)  (lpstr-termforms s)))\n\n\n\n (return\n `(prog ,(lpstr-arglist s)               ; Local variable list.\n\n        ,.(nreverse (lpstr-initforms s)) ; Initialization forms.\n\n        ,(lpstr-initially s)             ; \"Initially\" forms.\n\n        ,loop                            ; Loop label.\n\n        ,.(nreverse (lpstr-testforms s)) ; Termination-test forms.\n\n        ,.(nreverse (lpstr-auxforms s))  ; Auxiliary forms.\n\n        ,.(nreverse (lpstr-bodyforms s)) ; Body forms.\n\n        ,.(nreverse (lpstr-incrforms s)) ; Increment forms.\n\n        ,(lpstr-exit s)                  ; Exit label.\n\n        ,(lpstr-finally s)               ; \"Finally\" forms.\n\n        ,.(nreverse (lpstr-termforms s)) ; Termination forms.\n\n   )\n  )\n )\n)\n\n; This section processes LOOP INITIALLY and FINALLY clauses.\n\n(defun loop-process-initially (s)\n (when (lpstr-initially s)\n       (zerror \"LOOP: More than one INITIALLY form\"))\n (next-x)\n (setf (lpstr-initially s) (loop-do-stuff s)))\n\n(defun loop-process-finally (s)\n (when (lpstr-finally s)\n       (zerror \"LOOP: More than one FINALLY form\"))\n (next-x)\n (setf (lpstr-finally s) (loop-do-stuff s)))\n\n; This section processes LOOP binder clauses.\n\n(defun loop-binder-stuff (s)\n (case (this-op)\n       ((for as)           (loop-for-stuff s)\n                           t)\n       (with               (loop-with-stuff s)\n                           t)\n       (initially          (loop-process-initially s)\n                           (loop-binder-stuff s))\n       (finally            (loop-process-finally s)\n                           (loop-binder-stuff s))\n       (t                  nil)))\n\n; This section processes LOOP action clauses.\n\n(defun loop-action (z nestedp s)\n (let (\n       (a (this-op))\n      )\n  (cond\n   ((listp a)\n    (loop-do-stuff s))\n   ((and (not nestedp) (eq a 'initially))\n    (loop-process-initially s)\n    nil)\n   ((and (not nestedp) (eq a 'finally))\n    (loop-process-finally s)\n    nil)\n   (t\n    (case a\n      ((do\n        doing)       (next-x)\n                     (loop-do-stuff s))\n      ((collect\n        collecting)  (loop-collect-stuff z s))\n      ((nconc\n        nconcing)    (loop-nconc-stuff z s))\n      ((append\n        appending)   (loop-append-stuff z s))\n      ((push\n        pushing)     (loop-push-stuff z s))\n      ((return\n        returning)   (loop-return-stuff z s))\n      ((sum\n        summing)     (loop-sum-stuff z s))\n      ((count\n        counting)    (loop-count-stuff z s))\n      ((maximize\n        maximizing)  (loop-maximize-stuff z s))\n      ((minimize\n        minimizing)  (loop-minimize-stuff z s))\n\n      ((while)       (loop-while-stuff s))\n      ((until)       (loop-until-stuff s))\n\n      ((always)      (setf (lpstr-boolean s) '(t))\n                          (loop-always-stuff s))\n      ((never)       (setf (lpstr-boolean s) '(t))\n                          (loop-never-stuff s))\n      ((thereis)     (setf (lpstr-boolean s) '(nil))\n                          (loop-thereis-stuff s))\n\n      ((if\n        when)        (loop-when-stuff z s))\n      ((unless)      (loop-unless-stuff z s))\n\n      (t             (zerror \"Invalid or misplaced LOOP form\" a)))))))\n\n;\n; This section processes DO clauses.\n;\n\n(defun loop-do-stuff (s)\n (prog (z)\n  (setq z (list 'progn))\n do-loop\n  (cond\n   ((null (rest-op))\n    (go do-return))\n   ((null (this-op))\n    (next-x do-return) ; Skip NIL if found after DO\n    (go do-loop))\n   ((atom (this-op))\n    (go do-return))\n   (t\n   (push (this-op) z)\n   (next-x do-return)\n   (go do-loop)))\n do-return\n  (return (nreverse z))))\n\n;\n; This section processes FOR clauses.\n;\n\n(defun loop-for-stuff (s)\n (prog (var for type inval by by? byfun bycond fromtype fromto\n        byvar tovar thendo)\nfor-loop\n (cond\n  ((atom (more-op)) (zerror \"LOOP: FOR syntax error\" (more-op)))\n )\n (setq for (car (next-x syntax-error)))\n (next-x for-error)\n (when (loop-data-type-p (this-op))\n       (next-x for-error))\n (case (this-op)\n  (in           (setq type 'in   byfun 'cdr))\n  (on           (setq type 'on   byfun 'cdr))\n  (from         (setq type 'from byfun 'add1))\n  (=            (setq type '=    byfun nil  ))\n  (t            (go for-error))\n )\n (setq inval (car (next-x syntax-error)))\n (next-x generate-for-code)\n\n;\n; If FROM, look for TO or DOWNTO.\n;\n\n (if (eq type 'from)\n\n  then\n\n   (case (this-op)\n    (to                    (setq fromtype 'to\n                                 byfun    'add1\n                                 bycond   '>\n                                 tovar    (gensym)\n                                 fromto   (car (next-x syntax-error)))\n                           (next-x generate-for-code))\n    (downto                (setq fromtype 'downto\n                                 byfun    'sub1\n                                 bycond   '<\n                                 tovar    (gensym)\n                                 fromto   (car (next-x syntax-error)))\n                           (next-x generate-for-code))\n    (above                 (setq fromtype 'above\n                                 byfun    'sub1\n                                 bycond   '<=\n                                 tovar    (gensym)\n                                 fromto   (car (next-x syntax-error)))\n                           (next-x generate-for-code))\n    (below                 (setq fromtype 'below\n                                 byfun    'add1\n                                 bycond   '>=\n                                 tovar    (gensym)\n                                 fromto   (car (next-x syntax-error)))\n                           (next-x generate-for-code))\n   )\n\n   ;\n   ; Look for BY.  (FROM x TO/DOWNTO y BY z ...)\n   ;\n\n   (cond\n    ((eq (this-op) 'by)\n     (setq by (car (next-x syntax-error)))\n     (next-x)\n     (setq byvar (gensym) byfun (if (eq fromtype 'downto) '- '+)))\n   )\n\n  else\n\n ;\n ; If =, look for THEN.\n ;\n\n  if (eq type '=)\n  then\n\n   (cond\n    ((eq (this-op) 'then)\n     (setq fromtype 'then thendo (car (next-x syntax-error)))\n     (next-x generate-for-code))\n   )\n\n  else\n\n  ;\n  ; Look for BY. (IN/ON x BY y)\n  ;\n\n   (cond\n    ((eq (this-op) 'by)\n     (setq by (car (next-x syntax-error)))\n     (next-x)\n     (setq by? t)\n     (cond\n      ((and (consp by)\n            (or (eq (car by) 'quote)\n                (eq (car by) 'function)))\n       (setq byfun (cadr by)\n             by? nil))\n      (t\n       (setq byfun by\n             byvar (gensym)\n             by? t))\n     )))\n\n  endif\n )\n\ngenerate-for-code\n\n;\n;                  initforms  auxforms                  incrforms\n;\n; FOR I IN L     : (SETQ G L) (SETQ I (CAR G))       ...(SETQ G (CDR G))\n; FOR (I J) IN L : (SETQ G L) (DESETQ (I J) (CAR G)) ...(SETQ G (CDR G))\n; FOR I ON L     : (SETQ I L)                        ...(SETQ I (CDR I))\n; FOR (I J) ON L : (SETQ G L) (DESETQ (I J) G)       ...(SETQ G (CDR G))\n; FOR I FROM L   : (SETQ I L)                       ...(SETQ I (ADD1 I))\n;\n;                        initforms  auxforms            incrforms\n;\n; FOR I = L            : ---------- (SETQ I L)\n; FOR (I J) = L        : ---------- (SETQ G L)\n;                                   (DESETQ (I J) G)\n; FOR I = L THEN M     : (SETQ I L)                  ...(SETQ I M)\n; FOR (I J) = L THEN M : (SETQ G L) (DESETQ (I J) G) ...(SETQ G M)\n;\n\n (add-args for)\n\n (cond\n  ((or (eq type 'in) (consp for))   (add-args (setq var (gensym))))\n  (t                                (setq var for))\n )\n\n (if   (eq type '=)\n  then\n       (if   thendo\n        then\n             (push `(setq ,var ,inval) (lpstr-initforms s))\n        else\n             (push `(setq ,var ,inval) (lpstr-auxforms s))\n       )\n  else\n       (push `(setq ,var ,inval) (lpstr-initforms s))\n )\n\n (when byvar\n       (add-args byvar)\n       (push `(setq ,byvar ,by) (lpstr-initforms s)))\n\n (when tovar\n       (add-args tovar)\n       (push `(setq ,tovar ,fromto) (lpstr-initforms s)))\n\n (cond\n  ((eq type 'in)\n   (push `(,(if (atom for) 'setq 'desetq) ,for (zcar ,var))\n         (lpstr-auxforms s)))\n  ((not (eq var for))\n   (push `(,(if (atom for) 'setq 'desetq) ,for ,var)\n         (lpstr-auxforms s)))\n )\n\n (cond\n  (thendo        (push `(setq ,var ,thendo) (lpstr-incrforms s)))\n  ((neq type '=)\n                 (push `(setq ,var\n                         ,(cond\n                           (by?            `(funcall ,byvar ,var))\n                           ((eq byfun '+)  `(+ ,var ,byvar))\n                           ((eq byfun '-)  `(- ,var ,byvar))\n                           (t              `(,byfun ,var))\n                          ))\n                        (lpstr-incrforms s))))\n\n;\n; FOR I IN L --> (COND ((NULL G) (GO EXIT)))\n; FOR I ON L --> (COND ((NULL G) (GO EXIT)))\n; FOR I FROM L TO M --> (COND ((> G M) (GO EXIT)))\n; FOR I FROM L DOWNTO M --> (COND ((< G M) (GO EXIT)))\n; FOR I FROM L BELOW M --> (COND ((>= G M) (GO EXIT)))\n; FOR I FROM L ABOVE M --> (COND ((<= G M) (GO EXIT)))\n;\n\n (cond\n  ((or (eq type 'in)\n       (eq type 'on))\n   (push `(cond ((null ,var) (go ,(lpstr-exit s))))\n         (lpstr-testforms s)))\n  (bycond\n   (push `(cond ((,bycond ,var ,tovar) (go ,(lpstr-exit s))))\n         (lpstr-testforms s)))\n )\n\n (return nil)\n\nsyntax-error\n\n (zerror \"LOOP: Ran out of args following keyword\")\n\nfor-error\n\n (zerror \"LOOP: FOR specified without initializer\")\n\n )\n)\n\n;\n; This section processes WITH clauses.\n;\n\n(defun loop-with-stuff (s)\n (prog (var with = =?)\n  (cond\n   ((atom (more-op)) (zerror \"LOOP: WITH syntax error\" (more-op)))\n  )\n  (setq with (car (next-x syntax-error)))\n  (next-x generate-with-code)\n\n  (when (loop-data-type-p (this-op))\n        (next-x generate-with-code))\n\n  (when (eq (this-op) '=)\n        (setq = (car (next-x syntax-error)))\n        (setq =? t)\n        (next-x generate-with-code)\n  )\n\n;\n; If AND, generate another one.\n;\n\n  ;;;;; (if (eq (this-op) 'and) ... ) ... not implemented yet.\n\n\ngenerate-with-code\n\n;\n; WITH I = A     : (SETQ I A) ; no auxforms or incrforms.\n;\n\n  (add-args with)\n\n  (when =?\n        (push `(,(if (atom with) 'setq 'desetq) ,with ,=)\n              (lpstr-initforms s)))\n\n  (return)\n\nsyntax-error\n\n  (zerror \"LOOP: Ran out of args following keyword\")\n\nwith-error\n\n  (zerror \"LOOP: WITH specified without initializer\")\n\n )\n)\n\n;=======================================================================\n\n(defun loop-data-type-p (x)\n (cond\n  ((atom x)\n   (memq x '(fixnum flonum small-flonum short-float single-float\n             double-float long-float integer number notype)))\n  ((null (cdr x))\n   (loop-data-type-p (car x)))\n  (t\n   (and (loop-data-type-p (car x))\n        (loop-data-type-p (cdr x))))))\n\n;=======================================================================\n\n(defun loop-add-args (var arglist)\n (cond\n  ((null var)       arglist)\n  ((atom var)       (if (memq var arglist)\n                        arglist\n                        (cons var arglist)))\n  (t (loop-add-args (car var)\n                    (loop-add-args (cdr var) arglist)))))\n\n;=======================================================================\n\n(defun loop-nconc-stuff (z s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x return)\n  (when (loop-data-type-p (this-op)) (next-x return))\n  (cond\n   ((eq (this-op) 'into) (setq z (car (next-x syntax-error)))\n                         (next-x)\n                         (add-args z))\n  )\n  (and (rest-op) (loop-data-type-p (this-op)) (next-x))\nreturn\n  (return `(setq ,z (nconc2 ,z ,i)))\nsyntax-error\n  (zerror \"LOOP: NCONC syntax error\")))\n\n(defun loop-append-stuff (z s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x return)\n  (when (loop-data-type-p (this-op)) (next-x return))\n  (cond\n   ((eq (this-op) 'into) (setq z (car (next-x syntax-error)))\n                         (next-x)\n                         (add-args z))\n  )\n  (and (rest-op) (loop-data-type-p (this-op)) (next-x))\nreturn\n  (return `(setq ,z (append2 ,z ,i)))\nsyntax-error\n  (zerror \"LOOP: APPEND syntax error\")))\n\n(defun loop-collect-stuff (z s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x return)\n  (when (loop-data-type-p (this-op)) (next-x return))\n  (cond\n   ((eq (this-op) 'into) (setq z (car (next-x syntax-error)))\n                         (next-x)\n                         (add-args z))\n  )\n  (and (rest-op) (loop-data-type-p (this-op)) (next-x))\nreturn\n  (return `(setq ,z (nconc2 ,z (cons ,i nil))))\nsyntax-error\n  (zerror \"LOOP: COLLECT syntax error\")))\n\n(defun loop-push-stuff (z s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x return)\n  (when (loop-data-type-p (this-op)) (next-x return))\n  (cond\n   ((eq (this-op) 'into) (setq z (car (next-x syntax-error)))\n                         (next-x)\n                         (add-args z))\n  )\n  (and (rest-op) (loop-data-type-p (this-op)) (next-x))\nreturn\n  (return `(setq ,z (cons ,i ,z)))\nsyntax-error\n  (zerror \"LOOP: PUSH syntax error\")))\n\n(defun loop-sum-stuff (z s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x return)\n  (when (loop-data-type-p (this-op)) (next-x return))\n  (cond\n   ((eq (this-op) 'into) (setq z (car (next-x syntax-error)))\n                         (next-x)\n                         (add-args z))\n  )\n  (and (rest-op) (loop-data-type-p (this-op)) (next-x))\nreturn\n  (push `(setq ,z 0) (lpstr-initforms s))\n  (return `(setq ,z (+ ,z ,i)))\nsyntax-error\n  (zerror \"LOOP: SUM syntax error\")))\n\n(defun loop-count-stuff (z s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x return)\n  (when (loop-data-type-p (this-op)) (next-x return))\n  (cond\n   ((eq (this-op) 'into) (setq z (car (next-x syntax-error)))\n                         (next-x)\n                         (add-args z))\n  )\n  (and (rest-op) (loop-data-type-p (this-op)) (next-x))\nreturn\n  (push `(setq ,z 0) (lpstr-initforms s))\n  (return (if (eq i t)\n              `(setq ,z (add1 ,z))\n              `(cond (,i (setq ,z (add1 ,z))))))\nsyntax-error\n  (zerror \"LOOP: COUNT syntax error\")))\n\n(defmacro loop-maximize-stuff (z s) `(loop-maxmin-stuff ,z '> ,s))\n(defmacro loop-minimize-stuff (z s) `(loop-maxmin-stuff ,z '< ,s))\n\n(defun loop-maxmin-stuff (z comp s)\n (prog (i aux let stuff)\n  (setq i (car (next-x syntax-error)))\n  (add-args (setq aux (gensym)))\n  (if (atom i)\n      (setq let i)\n      (add-args (setq let (gensym))))\n\n  (next-x return)\n  (when (loop-data-type-p (this-op)) (next-x return))\n  (cond\n   ((eq (this-op) 'into) (setq z (car (next-x syntax-error)))\n                         (next-x)\n                         (add-args z))\n  )\n  (and (rest-op) (loop-data-type-p (this-op)) (next-x))\nreturn\n  (setq stuff `(cond\n                    (,aux (cond\n                               ((,comp ,let ,z) (setq ,z ,let))))\n                    (t    (setq ,aux t ,z ,let))))\n  (unless (eq let i)\n          (setq stuff `(progn (setq ,let ,i) ,stuff)))\n  (return stuff)\nsyntax-error\n  (zerror \"LOOP: MAXIMIZE or MINIMIZE syntax error\")))\n\n(defun loop-return-stuff (z s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x)\n  (return `(return ,i))\nsyntax-error\n  (zerror \"LOOP: RETURN syntax error\")))\n\n(defun loop-while-stuff (s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x)\n  (return `(cond ((not ,i) (go ,(lpstr-exit s)))))\nsyntax-error\n  (zerror \"LOOP: WHILE syntax error\")))\n\n(defun loop-until-stuff (s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x)\n  (return `(cond (,i (go ,(lpstr-exit s)))))\nsyntax-error\n  (zerror \"LOOP: UNTIL syntax error\")))\n\n(defun loop-when-stuff (z s)\n (prog (i j k)\n  (setq i (car (next-x syntax-error)))\n  (next-x syntax-error)\n  (setq j (loop-action z t s))\n  (when (and (rest-op) (eq (this-op) 'else))\n        (next-x syntax-error)\n        (setq k (loop-action z t s)))\nreturn\n  (return (if k `(cond (,i ,j) (t ,k)) `(cond (,i ,j))))\nsyntax-error\n  (zerror \"LOOP: WHEN syntax error\")))\n\n(defun loop-unless-stuff (z s)\n (prog (i j k)\n  (setq i (car (next-x syntax-error)))\n  (next-x syntax-error)\n  (setq j (loop-action z t s))\n  (when (and (rest-op) (eq (this-op) 'else))\n        (next-x syntax-error)\n        (setq k (loop-action z t s)))\nreturn\n  (return (if k `(cond ((not ,i) ,j) (t ,k)) `(cond ((not ,i) ,j))))\nsyntax-error\n  (zerror \"LOOP: UNLESS syntax error\")))\n\n(defun loop-always-stuff (s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x)\n  (return `(cond ((not ,i) (return nil))))\nsyntax-error\n  (zerror \"LOOP: ALWAYS syntax error\")))\n\n(defun loop-never-stuff (s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x)\n  (return `(cond (,i (return nil))))\nsyntax-error\n  (zerror \"LOOP: NEVER syntax error\")))\n\n(defun loop-thereis-stuff (s)\n (prog (i)\n  (setq i (car (next-x syntax-error)))\n  (next-x)\n  (return `(cond (,i (return t))))\nsyntax-error\n  (zerror \"LOOP: THEREIS syntax error\")))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXMVCALL": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x16_\\x00\\x89\\x15o\\tP\\x00,\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-13T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 44, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* The macro expander for the MULTIPLE-VALUE-CALL macro.               *\n;*                                                                     *\n;* Yeah, I know this is supposed to be a special form in CL, but due   *\n;* to the way the stack is handled in ZIL it doesn't pay.  It works    *\n;* out much better to do it this way.                                  *\n;*                                                                     *\n;***********************************************************************\n;\n; Example:\n;\n; (MULTIPLE-VALUE-CALL #'FOO (BAR) (BAZ) (FROB))  -->\n;\n; (APPLY #'FOO (NCONC (MULTIPLE-VALUE-LIST (BAR))\n;                     (MULTIPLE-VALUE-LIST (BAZ))\n;                     (MULTIPLE-VALUE-LIST (FROB))))\n;\n\n(eval-when (eval)\n (defun multiple-value-call macro (x) (mxmvcall x))\n)\n\n(defun mxmvcall (x &aux (y (cdr x)))\n (cond\n  ((null y)\n   (zerror \"Too few arguments\" x))\n  (t\n   (let (((func . args) y)\n        )\n        `(apply ,func\n                (nconc . ,(mapcar #'(lambda (x)\n                                            `(multiple-value-list ,x))\n                                  args)))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXMVPRG1": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x16_\\x00\\x89\\x15o\\tP\\x00&\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-13T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 38, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* The macro expander for the MULTIPLE-VALUE-PROG1 macro.              *\n;*                                                                     *\n;***********************************************************************\n;\n; Example:\n;\n; (MULTIPLE-VALUE-PROG1 (A) (B) (C))  -->\n;\n; ((LAMBDA (G00001) (B) (C) (VALUES-LIST G00001))\n;  (MULTIPLE-VALUE-LIST (A)))\n;\n;\n\n(eval-when (eval)\n (defun multiple-value-prog1 macro (x) (mxmvprg1 x))\n)\n\n(defun mxmvprg1 (x &aux (y (cdr x)))\n (setq x (cdr x))\n (cond\n  ((null x)       (zerror \"Too few arguments\" 'multiple-value-prog1))\n  ((null (cdr x)) `(progn ,(car x)))\n  (t\n   (let ((z (gensym)))\n        `((lambda (,z) ,@(cdr x) (values-list ,z))\n          (multiple-value-list ,(car x)))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXMVSETQ": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x16_\\x00\\x89\\x15o\\tP\\x00;\\x008\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-13T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 59, "newlines": 56, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* The macro expander for the MULTIPLE-VALUE-SETQ macro.               *\n;*                                                                     *\n;***********************************************************************\n;\n; Example:\n;\n; (MULTIPLE-VALUE-SETQ (A B C) (FOOBAR))  -->\n;\n; (MULTIPLE-VALUE-BIND (G00001 G00002 G00003) (FOOBAR)\n;                      (SETQ A G00001 B G00002 C G00003)\n;                      G00001)\n;\n\n(eval-when (eval)\n (defun multiple-value-setq macro (x) (mxmvsetq x))\n)\n\n(defun mxmvsetq (x &aux (y (cdr x)))\n (cond\n  ((or (null y) (null (cdr y)))\n   (zerror \"Too few arguments\" x))\n  ((not (null (cddr y)))\n   (zerror \"Too many arguments\" x))\n  (t\n   (let* (((vars form) y)\n          (mvvars)\n         )\n         (do ((vars vars (cdr vars))\n             )\n             ((null vars))\n             (when (atom vars)\n                   (zerror \"Improper variable list\" x))\n             (unless (symbolp (car vars))\n                     (zerror \"Invalid MULTIPLE-VALUE-SETQ variable\"\n                            (car vars)))\n             (push (gensym) mvvars)\n         )\n        `(multiple-value-bind ,mvvars ,form\n                              (setq . ,(do ((vars vars (cdr vars))\n                                            (mvvars mvvars (cdr mvvars))\n                                            (z nil)\n                                           )\n                                           ((null vars) (nreverse z))\n                                           (push (car vars) z)\n                                           (push (car mvvars) z)\n                                       ))\n                              ,(car mvvars))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXPOP": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tP\\x00%\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 37, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the POP macro.\n;\n\n (eval-when (eval)\n  (defmacro pop (a &optional b) (mxpop a b))\n )\n\n (defun mxpop (stack into)\n  (let (pop1 g1 g2)\n       (setq pop1\n             (if   (symbolp stack)\n              then\n                   `(prog1 (car ,stack) (setf ,stack (cdr ,stack)))\n              else\n                   (setq g1 (gensym))\n                   `(let ((,g1 ,stack))\n                         (prog1 (car ,g1) (setf ,stack (cdr ,g1))))\n             ))\n\n       (if   into\n        then\n             (setq g2 (gensym))\n             `(let ((,g2 ,pop1)) (setf ,into ,g2))\n        else\n             pop1)))\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXPP": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x11\\x9f\\x00\\x89\\x15o\\tP\\x00\\x1d\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-04-29T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 29, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; The macro expander for the PP macro.\n;;;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/17/88 - Now returns no values.                                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (eval)\n (defun pp macro (x) (mxpp x))\n)\n\n(defun mxpp (x)\n `(progn ,.(mapcar #'(lambda (x) `(catch nil (zilpp ',x))) (cdr x))\n         (values)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXPROG": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x88\\x17O\\x00\\x89\\x15o\\tP\\x00+\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-06-22T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 43, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the PROG and PROG* macros.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Created 06/22/88.  Remember when PROG was a special form?           *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (eval)\n (remprop 'prog '|SPECIAL FORM|)\n (defun prog  macro (x) (mxprog x))\n (defun prog* macro (x) (mxprog x))\n)\n\n(defun mxprog (x)\n (let ((let (case (car x)\n                  (prog  'let)\n                  (prog* 'let*)\n                  (t (zerror \"Invalid caller of MXPROG\" (car x)))))\n       (arglist (car (or (cdr x) (zerror \"Missing arglist\" x))))\n       (body    (or (cddr x)     (zerror \"Missing body\" x)))\n      )\n\n  (multiple-value-bind (nil decls body mxform mxvalidp)\n                       (parse-body body)\n   (when mxvalidp (setq body (cons mxform (cdr body))))\n   (when decls (setq decls `((declare . ,decls))))\n   `(block nil\n           (,let ,arglist\n                 ,.decls\n                 (tagbody . ,body))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXPROG1": {"ttr": 2322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tP\\x00!\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 33, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the PROG1 macro.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/13/88 - Support for multiple values.  The definition for PROG1   *\n;*            with 1 argument had to be changed to insure that one     *\n;*            value is always returned.                                *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun mxprog1 (x)\n (setq x (cdr x))\n (cond\n  ((null x)       (zerror \"Too few arguments\" 'prog1))\n  ((null (cdr x)) `(values ,(car x)))\n  (t\n   (let ((z (gensym)))\n        `((lambda (,z) ,@(cdr x) ,z)\n          ,(car x))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXPROG2": {"ttr": 2324, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tP\\x00#\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 35, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; Macro expander for the PROG2 macro.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/13/88 - Support for multiple values.  The definition for PROG2   *\n;*            with 2 arguments had to be changed to insure that one    *\n;*            value is always returned.                                *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun mxprog2 (x)\n (setq x (cdr x))\n (cond\n  ((or (null x) (null (cdr x)))\n   (zerror \"PROG2 requires at least 2 arguments.\"))\n  ((null (cddr x))\n   `(progn ,(car x) (values ,(cadr x))))\n  (t\n   (let ((a (gensym)))\n        `((lambda (,a) ,@(cddr x) ,a)\n          (progn ,(car x) ,(cadr x)))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXPSETQ": {"ttr": 2326, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tP\\x002\\x00:\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:50:00", "lines": 50, "newlines": 58, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the PSETQ macro.\n;\n; (DEFMACRO PSETQ (X) (MXPSETQ X))\n;\n; e.g.\n;\n; (PSETQ A 1 B 2 C 3)\n;\n; -->\n;\n; ((LAMBDA (G00001 G00002 G00003)\n;          (SETQ A G00001\n;                B G00002\n;                C G00003))\n;  1 2 3)\n;\n\n(defun mxpsetq (x)\n (setq x (cdr x))\n (cond\n  ((null x)\n   nil)\n  ((and x (cdr x) (null (cddr x)))\n   `(setq . ,x))\n  (t\n   (prog (y v templist setqsets setqvals)\n         (setq y x)\n     loop\n         (or y (return\n                       `((lambda ,(nreverse templist)\n                                 (setq ,.(nreverse setqsets)))\n                                       . ,(nreverse setqvals))))\n         (or (cdr y) (zerror \"Odd number of args to PSETQ\" x))\n         (setq v (gensym))\n         (push v templist)\n         (push (car y) setqsets)\n         (push v setqsets)\n         (push (cadr y) setqvals)\n         (setq y (cddr y))\n         (go loop)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXPSHNEW": {"ttr": 2328, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tQ\\x00D\\x00C\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 68, "newlines": 67, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The expander for the PUSHNEW macro,\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/16/88 - Always generates MEMBER with :TEST keyword.              *\n;*            No longer will it generate function of the ASSOC family, *\n;*            which is probably more correct since such functions do   *\n;*            something different if NIL is a member of the list.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (eval)\n (defmacro pushnew (a b &key ((:test c)) ((:key d)))\n           (mxpshnew a b c d))\n)\n\n(defun mxpshnew (item place test key\n                 &aux bindings itemvar placevar itemtest kwds)\n\n (cond\n  ((atom place)           ; PLACE should never be (QUOTE anything)!\n   (setq placevar place))\n  (t\n   (setq placevar (gensym))\n   (push `(,placevar ,place) bindings)))\n\n (cond\n  ((or (atom item) (eq (car item) 'quote))\n   (setq itemvar item))\n  (t\n   (setq itemvar (gensym))\n   (push `(,itemvar ,item) bindings)))\n\n (setq itemtest\n       (cond\n        ((null key)\n         itemvar)\n        ((and (consp key)\n              (memq (car key) '(quote function)))\n         `(,(cadr key) ,itemvar))\n        (t\n         `(funcall ,key ,itemvar))))\n\n (when key  (setq kwds `(:key  ,key  . ,kwds)))\n (when test (setq kwds `(:test ,test . ,kwds)))\n\n `(let ,bindings\n       (cond\n        ((member ,itemtest ,placevar . ,kwds)\n         ,placevar)\n        (t\n         (setf ,place                    ; Note - place not placevar\n               (cons ,itemvar ,placevar))))))\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXPUSH": {"ttr": 2330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tQ\\x00\\x11\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 17, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the PUSH macro.\n;\n; (DEFMACRO PUSH (THING STACK) (MXPUSH THING STACK))\n;\n\n (defun mxpush (thing stack)\n  `(setf ,stack (cons ,thing ,stack))\n )\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXPUTDAT": {"ttr": 2562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x10/\\x00\\x89\\x15o\\tQ\\x00.\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-04-11T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 46, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the PUTDATA macro.\n;\n; (PUTDATA form) --> (PROGN\n;                     (CTERPRI)\n;                     (PRINC \"form=\")\n;                     (CATCH NIL (PRIN1 form))\n;                     (TERPRI)\n;                    )\n;\n; (PUTDATA form1 form2) --> (PROGN\n;                            (CTERPRI)\n;                            (PRINC \"form1=\")\n;                            (CATCH NIL (PRIN1 form1))\n;                            (PRINC \",form2=\")\n;                            (CATCH NIL (PRIN1 form2))\n;                            (TERPRI)\n;\n\n(eval-when (eval)\n (defun putdata macro (x) (mxputdat x))\n)\n\n(defun mxputdat (x)\n `(progn\n   (cterpri)\n   ,.(do ((forms (cdr x) (cdr forms))\n          (sep \"\" \",\")\n          (z nil)\n         )\n      ((null forms) (nreverse z))\n      (push `(princ ,(string-append sep\n                                    (prin1-to-string (car forms))\n                                    \"=\"))\n            z)\n      (push `(catch nil (prin1 ,(car forms))) z))\n   (terpri)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXRELOP": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x06\\x1f\\x00\\x89\\x15o\\tQ\\x00S\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-03-02T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 83, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is a general-purpose macro expander for relational operator\n; functions that take multiple arguments.  For example...\n;\n; (< 1 2 3 4) --> (AND (LESSP 1 2) (LESSP 2 3) (LESSP 3 4))\n;\n; There are 4 arguments:  (1) the macro form\n;                         (2) the name of the primitive binary function\n;\n; If 1 arg is specified, the result is defined to be T.\n;\n; e.g. (defun < macro (x) (mxrelop x 'lessp))\n;\n\n(defun mxrelop (x func)\n (let (((macroname . args) x))\n  (cond\n   ((null args)\n    (zerror \"Too few arguments\" macroname))\n   ((null (cdr args))   `t)\n   ((null (cddr args)) `(,func . ,args))\n   (t (mxrelop-let args func)))))\n\n(defun mxrelop-let (args func)\n (let* (\n        (llist   (mxrelop-llist args))\n        (letlist (mxrelop-letlist llist))\n        (newargs (mapcar #'(lambda (x) (or (car x) (cadr x))) llist))\n       )\n\n;;; For example:\n;;;\n;;;  (MXRELOP '(< A B (C) (D) E) 'LESSP)\n;;;\n;;; ARGS    = (A B C D E)\n;;; FUNC    = LESSP\n;;; LLIST   = ((NIL A) (NIL B) (G1 (C)) (G2 (D)) (NIL E))\n;;; LETLIST = (G1 G2)\n;;; NEWARGS = (A B G1 G2 E)\n;;;\n;;; which would result in the following expansion:\n;;;\n;;; (LET ((G1 (C))\n;;;       (G2 (D)))\n;;;      (AND (LESSP A B)\n;;;           (LESSP B G1)\n;;;           (LESSP G1 G2)\n;;;           (LESSP G2 E)))\n;;;\n\n `(let ,letlist\n       (and . ,(loop for subargs on newargs while (cdr subargs)\n                     collect\n                     `(,func ,(car subargs) ,(cadr subargs)))))))\n\n(defun mxrelop-llist (args)\n (loop for subargs on (cdr args) while (cdr subargs)\n       collect (mxrelop-varpair (car subargs)) into z\n       finally (return (nconc (list (mxrelop-varpair (car args)))\n                              z\n                              (list (mxrelop-varpair (car subargs)))\n                       ))))\n\n(defun mxrelop-letlist (llist)\n (loop for i in llist\n       when (car i) collect i))\n\n(defun mxrelop-varpair (form)\n (list\n       (if (or (atom form)\n               (eq (car form) 'quote))\n           nil\n           (gensym))\n       form))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXRETURN": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x17O\\x00\\x89\\x15o\\tQ\\x00\\x1a\\x00\\x17\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-22T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 26, "newlines": 23, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the RETURN macro.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Created 06/22/88.  Remember when RETURN was a special form?         *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (eval)\n (remprop 'return '|SPECIAL FORM|)\n (defun return macro (x) (mxreturn x))\n)\n\n(defun mxreturn (x)\n `(return-from nil . ,(cdr x)))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXSASSOC": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tQ\\x00)\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 41, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; The macro expander for the SASSOC and SASSQ macros.\n\n(eval-when (eval)\n (defun sassoc macro (x) (mxsassoc x))\n (defun sassq  macro (x) (mxsassoc x))\n)\n\n(defun mxsassoc (x)\n (unless (eql (length x) 4)\n         (zerror \"Three arguments required\" (car x)))\n (let* (\n        ((macroname a b c) x)\n        (assfun (case macroname\n                 (sassoc 'assoc)\n                 (sassq  'assq)\n                 (t (zerror \"Unknown caller of MXSASSOC\" macroname))))\n       )\n       `(or (,assfun ,a ,b) ,(mxsassoc-funcall c))))\n\n(defun mxsassoc-funcall (x)\n (cond\n  ((null x) 'nil)\n  ((atom x) `(funcall ,x))\n  ((or (eq (car x) 'quote)\n       (eq (car x) 'function))\n   (let ((f (cadr x)))\n        (if (and (consp f) (eq (car f) 'lambda))\n            (if (cadr f)\n                (zerror \"Arg 3 to SASSOC/SASSQ cannot take arguments.\")\n                `(progn . ,(cddr f)))\n            `(,f))))\n  (t        `(funcall ,x))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXSETF": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tQ\\x01\\r\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 269, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; Macro expander for the SETF macro.\n;\n; Note: Additional SETF forms will be added as time goes by.\n;\n; Note: The ZIL 1.2 \"MXSETFI\" module has been incorporated herein and\n;       is therefore no longer in the system.\n;\n\n(eval-when (eval)\n (defun setf macro (x) (mxsetf x))\n)\n\n(defun mxsetf (form &aux (x (cdr form)))\n (cond\n  ;;\n  ;; Just a hack to keep the PROGN off the 2-arg SETF.  Esthetic only.\n  ;;\n  ((null x)          'nil)\n  ((null (cdr x))    (zerror \"Missing second arg to SETF\" x))\n  ((null (cddr x))   (mxsetf1 (car x) (cadr x)))\n  (t\n   (do ((args x (cddr args))\n        (z nil)\n       )\n       ((null args) `(progn . ,(nreverse z)))\n       (when (null (cdr args))\n             (zerror \"Odd number of args to SETF\" form))\n       (push (mxsetf1 (car args) (cadr args)) z)))))\n\n(defun mxsetf1 (a b)\n (cond\n      ((atom a)\n                                `(setq ,a ,b))\n      ((not (symbolp (car a)))\n                                (zerror \"Invalid SETF place form\" a))\n      ((get (car a) 'macro)\n                                (mxsetf1 (macroexpand a) b))\n      (t\n         (funcall (or (get (car a) 'setfmethod) ; Look for SETF method.\n                      (progn                    ; If not found,\n                       (mxsetf-initialize)      ; maybe initialize SETF\n                       (get (car a) 'setfmethod); methods and retry.\n                      )\n                      (zerror \"No SETF method defined\" (car a)))\n                  a b))))\n\n;\n; This routine does only the following:\n;\n;   Defines the SETF methods of the standard SETF-able functions.\n;\n\n(defmacro mxsetf-initialized ()\n '*mxsetf-initialized*)\n\n(defmacro set-mxsetf-initialized (x) ; Try not to use SETF here!\n '(setq *mxsetf-initialized* t))\n\n(declare (special *mxsetf-initialized*))\n\n(defun mxsetf-initialize ()\n (cond\n  ((mxsetf-initialized)\n   nil)\n  (t\n   (putprop 'car           #'setf-car      'setfmethod)\n   (putprop 'cdr           #'setf-cdr      'setfmethod)\n   (putprop 'zcar          #'setf-car      'setfmethod)\n   (putprop 'zcdr          #'setf-cdr      'setfmethod)\n   (putprop 'plist         #'setf-plist    'setfmethod)\n   (putprop 'symbol-plist  #'setf-plist    'setfmethod)\n   (putprop 'symeval       #'setf-symeval  'setfmethod)\n   (putprop 'nth           #'setf-nth      'setfmethod)\n   (putprop 'nthcdr        #'setf-nthcdr   'setfmethod)\n   (putprop 'vref          #'setf-vref     'setfmethod)\n   (putprop 'arg           #'setf-arg      'setfmethod)\n   (putprop 'get           #'setf-get      'setfmethod)\n   (putprop 'salist        #'setf-salist   'setfmethod)\n   (putprop 'special-alist #'setf-salist   'setfmethod)\n   (putprop 'caar          #'setf-caar     'setfmethod)\n   (putprop 'cadr          #'setf-cadr     'setfmethod)\n   (putprop 'cdar          #'setf-cdar     'setfmethod)\n   (putprop 'cddr          #'setf-cddr     'setfmethod)\n   (putprop 'caaar         #'setf-caaar    'setfmethod)\n   (putprop 'caadr         #'setf-caadr    'setfmethod)\n   (putprop 'cadar         #'setf-cadar    'setfmethod)\n   (putprop 'caddr         #'setf-caddr    'setfmethod)\n   (putprop 'cdaar         #'setf-cdaar    'setfmethod)\n   (putprop 'cdadr         #'setf-cdadr    'setfmethod)\n   (putprop 'cddar         #'setf-cddar    'setfmethod)\n   (putprop 'cdddr         #'setf-cdddr    'setfmethod)\n   (putprop 'cadddr        #'setf-cadddr   'setfmethod)\n   (putprop 'cddddr        #'setf-cddddr   'setfmethod)\n   (set-mxsetf-initialized t))))\n\n;;;\n;;; For each SETF method:\n;;; arg1 is arg1 to SETF, i.e. the form whose CAR is the place function\n;;; arg2 is arg2 to SETF, i.e. the value to insert in the place.\n;;;\n;;; Example:  (SETF (GET 'FOO 'BAR) 'BAZ))\n;;;           calls SETF-CAR with\n;;;                              arg1: (GET 'FOO 'BAR)\n;;;                              arg2: BAZ\n;;;\n\n(defun setf-car (a b)\n (if (or (null (cdr a)) (cddr a))\n     (zerror \"Invalid SETF CAR syntax\" a)\n     `(zcar (rplaca ,(cadr a) ,b))   ; Return B but evaluate it last.\n ))\n\n(defun setf-cdr (a b)\n (if (or (null (cdr a)) (cddr a))\n     (zerror \"Invalid SETF CDR syntax\" a)\n     `(zcdr (rplacd ,(cadr a) ,b))   ; Return B but evaluate it last.\n ))\n\n(defun setf-plist (a b)\n (if (or (null (cdr a)) (cddr a))\n     (zerror \"Invalid SETF SYMBOL-PLIST syntax\" a)\n     `(symbol-plist (setplist ,(cadr a) ,b))\n ))\n\n(defun setf-symeval (a b)\n (if (or (null (cdr a)) (cddr a))\n     (zerror \"Invalid SETF SYMEVAL syntax\" a)\n     `(set ,(cadr a) ,b)\n ))\n\n(defun setf-salist (a b)\n (if (cdr a)\n     (zerror \"Invalid SETF SPECIAL-ALIST syntax\" a)\n     `(setsalst ,b)\n ))\n\n(defun setf-nth (a b)\n (if (or (null (cdr a)) (null (cddr a)) (cdddr a))\n     (zerror \"Invalid SETF NTH syntax\" a)\n     `(zcar (rplaca (nthcdr ,(cadr a) ,(caddr a)) ,b))\n ))\n\n(defun setf-nthcdr (a b)\n (if (or (null (cdr a)) (null (cddr a)) (cdddr a))\n     (zerror \"Invalid SETF NTHCDR syntax\" a)\n;\n; else...\n;\n; Expansion varies depending on whether a constant fixnum is specified.\n; Furthermore, the special case of (NTHCDR 0 xxx) must be taken into\n; account.  If (SETF (NTHCDR N L) C) is specified where N is equal to\n; zero, either at macro expansion time (i.e. a constant) or at run time,\n; then we let it proceed at run time, since it will generate a call to\n; NTHCDR with the argument -1, which signals an error.  We can check\n; the value of the index at macroexpansion time if it is an integer.\n;\n     (let ((n (macroexpand (cadr a)))\n           (l (caddr a))\n           (g))\n          (if (integerp n)\n              (if (not (plusp n))\n                  (zerror \"Invalid NTHCDR index found by SETF expansion\"\n                         n)\n                  `(cdr (rplacd (nthcdr ,(sub1 n) ,l) ,b))\n              )\n              `(cdr (rplacd (nthcdr (sub1 ,n) ,l) ,b))))))\n\n\n(defun setf-vref (a b)\n (if (or (null (cdr a)) (null (cddr a)) (cdddr a))\n     (zerror \"Invalid SETF VREF syntax\" a)\n     `(vset ,(cadr a) ,(caddr a) ,b)\n ))\n\n(defun setf-arg (a b)\n (if (or (null (cdr a)) (cddr a))\n     (zerror \"Invalid SETF ARG syntax\" a)\n     `(setarg ,(cadr a) ,b)\n ))\n\n(defun setf-get (a b)\n (if (or (null (cdr a)) (null (cddr a)) (cddddr a))\n  then\n     (zerror \"Invalid SETF GET syntax\" a)\n  else\n     (let ((a1 (macroexpand (cadr a)))\n           (a2 (macroexpand (caddr a)))\n           (a3 (macroexpand (cadddr a))) ; Arg 3 to GET, default NIL\n           (b1 (macroexpand b)))\n      (if   (and (null b) (null a3))\n       then\n            `(progn (remprop ,a1 ,a2) nil)\n       else\n       if   (or (setf-constantp b1) (setf-constantp a2))\n       then\n            `(putprop ,a1 ,b1 ,a2)\n       else\n       if   (and (setf-simplep b1) (setf-simplep a2))\n       then\n            `(putprop ,a1 ,b1 ,a2)\n       else                                  ; e.g. (SETF (GET S I) B)...\n            (let ((s (gensym))\n                  (i (gensym)))\n            `(let ((,s ,a1)                  ; must evaluate S first\n                   (,i ,a2))                 ; must evaluate I next\n                   (putprop ,s ,b ,i)))))))  ; and B last\n\n(defun setf-constantp (x) ; X is already macroexpanded.\n (or (null x)\n     (eq x t)\n     (if (atom x) (not (symbolp x)) (eq (car x) 'quote))))\n\n(defun setf-simplep (x)   ; X is already macroexpanded.\n (or (symbolp x)\n     (and (consp x)\n          (memq (car x) '(car cdr zcar zcdr))\n          (cdr x)\n          (setf-simplep (macroexpand (cadr x))))))\n\n(defun setf-caar (a b)\n (setf-car `(car (car . ,(cdr a))) b)\n)\n(defun setf-cadr (a b)\n (setf-car `(car (cdr . ,(cdr a))) b)\n)\n(defun setf-cdar (a b)\n (setf-cdr `(cdr (car . ,(cdr a))) b)\n)\n(defun setf-cddr (a b)\n (setf-cdr `(cdr (cdr . ,(cdr a))) b)\n)\n(defun setf-caaar (a b)\n (setf-car `(car (caar . ,(cdr a))) b)\n)\n(defun setf-caadr (a b)\n (setf-car `(car (cadr . ,(cdr a))) b)\n)\n(defun setf-cadar (a b)\n (setf-car `(car (cdar . ,(cdr a))) b)\n)\n(defun setf-caddr (a b)\n (setf-car `(car (cddr . ,(cdr a))) b)\n)\n(defun setf-cdaar (a b)\n (setf-cdr `(cdr (caar . ,(cdr a))) b)\n)\n(defun setf-cdadr (a b)\n (setf-cdr `(cdr (cadr . ,(cdr a))) b)\n)\n(defun setf-cddar (a b)\n (setf-cdr `(cdr (cdar . ,(cdr a))) b)\n)\n(defun setf-cdddr (a b)\n (setf-cdr `(cdr (cddr . ,(cdr a))) b)\n)\n(defun setf-cadddr (a b)\n (setf-car `(car (cdddr . ,(cdr a))) b)\n)\n(defun setf-cddddr (a b)\n (setf-cdr `(cdr (cdddr . ,(cdr a))) b)\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXSIGNP": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tQ\\x00\\x1b\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 27, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; The macro expander for the SIGNP macro, as in Maclisp.\n\n(eval-when (eval)\n (defmacro signp (a b) (mxsignp a b))\n)\n\n(defun mxsignp (a b &aux (c (gensym)))\n `(let ((,c ,b))\n   (and (numberp ,c)\n        ,(case a\n          (L   `(minusp ,c))\n          (LE  `(not (plusp ,c)))\n          (E   `(zerop ,c))\n          (N   `(not (zerop ,c)))\n          (GE  `(not (minusp ,c)))\n          (G   `(plusp ,c))\n          (t   (zerror \"Unrecognized argument to SIGNP\" a))\n         ))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXTIME": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x12\\x7f\\x00\\x89\\x15o\\tQ\\x00E\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-05-07T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 69, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the TIME macro.\n;\n; Example:\n;\n; (time (fib 10))\n;\n;  Time=30 msec.\n;  89\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/16/88 - Support for multiple values.  Also displays time even    *\n;*            if the form errors out.                                  *\n;*                                                                     *\n;***********************************************************************\n;\n;\n\n(eval-when (eval)\n (defun time macro (x) (mxtime x))\n)\n\n(defun mxtime (x)\n (let ((g1 (gensym))\n       (r1 (gensym))\n       (it (gensym))\n       (r2 (gensym))\n       (g2 (gensym))\n      )\n  `(let (,r1 ,g1 ,r2 ,g2)\n    (unwind-protect\n     (progn\n      (setq ,g1 (gctime)\n            ,r1 (runtime))\n      (progn . ,(cdr x))\n     )\n     (setq ,r2 (runtime)\n           ,g2 (gctime))\n     (setq ,g2 (- ,g2 ,g1)\n           ,r2 (- ,r2 ,r1 ,g2))\n\n;;;;;(format t \"~&Time=~D msec.  GC time=~D msec.~%\" ,r2 ,g2)\n\n     (cterpri)\n     (princ \"Time=\")\n     (princ ,r2)\n     (princ \" msec.\")\n     (unless (zerop ,g2)\n             (princ \"  GC time=\")\n             (princ ,g2)\n             (princ \" msec.\"))\n     (terpri)\n    )\n   )\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MXTTAB": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tQ\\x00\\x15\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:51:00", "lines": 21, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; The macro expander for the TTAB macro.\n;\n; This is a Waterloo LISP 1.5 function.\n;\n\n(eval-when (eval)\n (defmacro ttab (val &optional fil) (mxttab val fil))\n)\n\n(defun mxttab (xval xfil)\n (let ((xval (macroexpand xval)))\n  `(zputfpo ,(if (integerp xval) (add1 xval) `(add1 ,xval)) ,xfil)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXWOF": {"ttr": 2579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tR\\x006\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:52:00", "lines": 54, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; The macro expander for WITH-OPEN-FILE.\n;\n; e.g.\n;\n;  (WITH-OPEN-FILE (FILEVAR FILENAME FILEOPT1 FILEOPT2)\n;   (DO STUFF)\n;   (DO MORE STUFF)\n;   (DO EVEN MORE STUFF)\n;  )\n;\n;  -->\n;\n;  (LET ((FILEVAR (OPEN FILENAME '<appropriate option>)))\n;       (UNWIND-PROTECT (PROGN (DO STUFF)\n;                              (DO MORE STUFF)\n;                              (DO EVEN MORE STUFF)\n;                       )\n;                       (CLOSE FILENAME '<option>)\n;       )\n;  )\n;\n; Note that only the first of any OPEN options is used.\n;\n\n(eval-when (eval)\n (defmacro with-open-file ((filevar filename &rest fileopts) . body)\n           (mxwof filevar filename fileopts body)\n )\n)\n\n(defun mxwof (filevar filename fileopts body\n              &aux\n              (openopt (car fileopts))\n              (closeopt openopt)\n              (gfn (gensym)))\n (multiple-value-bind (nil declarations newbody mxform mxvalidp)\n                      (parse-body body)\n  (when mxvalidp (setq newbody (cons mxform (cdr newbody))))\n  (when declarations (setq declarations `((declare . ,declarations))))\n  `(let* ((,gfn (open ,filename ,openopt))\n          (,filevar ,gfn)  ; to keep user from altering filename var\n         )\n         ,.declarations\n         (unwind-protect (progn . ,newbody)\n                         (close ,gfn ,closeopt)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXXTAB": {"ttr": 2581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tR\\x00\\x17\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:52:00", "lines": 23, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The macro expander for the XTAB macro.\n;\n; This is a Waterloo LISP 1.5 function.\n;\n\n(eval-when (eval)\n (defmacro xtab (val &optional fil) (mxxtab val fil))\n)\n\n(defun mxxtab (val fil)\n (let ((a (gensym)))\n      `(let ((,a ,fil))\n            (zputfpo (+ (zgetfpo ,a) ,val) ,a))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NCONC": {"ttr": 2583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tR\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:52:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"NCONC\"\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; NCONC as a macro that expands into the requisite number of calls\n;;; to NCONC2.\n;;;\n\n(defun nconc (&rest x) (nconc-list x))\n\n(defun nconc-list (x)\n (cond\n  ((null x)        nil)\n  ((null (cdr x))  (zcar x))\n  ((null (cddr x)) (nconc2 (zcar x) (zcadr x)))\n  (t               (nconc2 (zcar x) (nconc-list (cdr x))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "NEWLINEP": {"ttr": 2585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\tR\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:52:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun newlinep (&optional file)\n (zcread file #.%%newlinep nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NOMACS": {"ttr": 2587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x05O\\x00\\x87\\x05O\\x14\\x15\\x00\\x01\\x00\\x01\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1987-02-23T14:15:00", "lines": 1, "newlines": 1, "modlines": 0, "user": "SEB1525"}, "text": "; Empty member for XZILCO proc when \"MACROS\" not specified.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTANY": {"ttr": 2589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tR\\x001\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:52:00", "lines": 49, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"NOTANY\" - an iterator a la NIL, viz.\n;\n; (NOTANY #'foo-p list1 list2 ...) returns t if foo-p is true of none\n;                                  of the element(s).\n;\n; The compiler really ought to transform this into inline code,\n; a la the mapping functions.\n;\n\n\n(defun notany1 (fun lis) ; case of 1 list.\n (cond\n  ((null lis) t)\n  ((atom lis) (zerror \"Argument 2 to NOTANY not a list\" lis))\n  (t\n   (prog ()\n    loop\n         (unless (funcall fun (car lis))\n                 (when (setq lis (cdr lis))\n                       (go loop))\n                 (return t))\n         (return nil)))))\n\n(defun notany (fun &rest lists) ; case of multiple lists.\n (cond\n  ((null lists)       t)\n  ((null (cdr lists)) (notany1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to NOTANY\" list)))\n   (prog ()\n    loop (when (mapor #'null lists) (return t))\n         (when (zilapply fun (mapcar #'car lists))\n               (return nil))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "NOTEVERY": {"ttr": 2591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tR\\x001\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:52:00", "lines": 49, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"NOTEVERY\" - an iterator a la NIL, viz.\n;\n; (NOTEVERY #'foo-p list1 list2 ...) returns t if foo-p is false of at\n;                                    least one of the element(s).\n;\n;\n; The compiler really ought to transform this into inline code,\n; a la the mapping functions.\n;\n\n(defun notevery1 (fun lis) ; case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to NOTEVERY not a list\" lis))\n  (t\n   (prog ()\n    loop\n         (when (funcall fun (car lis))\n               (when (setq lis (cdr lis))\n                     (go loop))\n               (return nil))\n         (return t)))))\n\n(defun notevery (fun &rest lists) ; case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (notevery1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to NOTEVERY\" list)))\n   (prog ()\n    loop (when (mapor #'null lists) (return nil))\n         (unless (zilapply fun (mapcar #'car lists))\n                 (return t))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "OPEN": {"ttr": 2593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x06\\x9f\\x00\\x89\\x15o\\tR\\x00\\x1d\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-03-10T00:00:00", "modifydate": "1989-06-05T09:52:00", "lines": 29, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; Modes are passed as a fixnum with the following bit settings:\n;;;\n;;; Bit 31:      0 = input, 1 = output\n;;; Bit 30:      1 = append\n;;; Bit 29:      1 = probe\n;;; Other bits:  reserved\n;;;\n\n(defargs zilopen 2 2 nil)\n\n(defun open (dsn &optional mode)\n (zilopen dsn (case (if (atom mode) mode (car mode))\n                    ((nil in input)         #b   0)\n                    ((out output)           #b   1)\n                    ((append :append)       #b  11)\n                    ((probe :probe)         #b 100)\n                    ((:in :input)           #b   0)\n                    ((:out :output)         #b   1)\n                    (t (zerror \"OPEN: Undefined type\" mode)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PAIRLIS": {"ttr": 2595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87(o\\x00\\x89\\x15o\\tS\\x00\\x1e\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-10-13T00:00:00", "modifydate": "1989-06-05T09:53:00", "lines": 30, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; PAIRLIS\n;;;\n;;; Reference:  CLtL, p. 280.\n\n(defun pairlis (keys data &optional (a-list nil))\n (do ((keylist keys (cdr keylist))\n      (datlist data (cdr datlist))\n      (z a-list (cons (cons (zcar keylist) (zcar datlist)) z))\n     )\n     ((null keylist)\n      (unless (null datlist)\n       (zerror \"Arg 1 to PAIRLIS is shorter than arg 2\" keys data))\n      z)\n     (cond\n      ((null datlist)\n       (zerror \"Arg 1 to PAIRLIS is longer than arg 2\" keys data))\n      ((atom keylist)\n       (zerror \"Arg 1 to PAIRLIS is not a proper list\" keys))\n      ((atom datlist)\n       (zerror \"Arg 2 to PAIRLIS is not a proper list\" data))\n     )\n ))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PARSBODY": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x17?\\x00\\x89\\x15o\\tS\\x00L\\x00C\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-21T00:00:00", "modifydate": "1989-06-05T09:53:00", "lines": 76, "newlines": 67, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* PARSE-BODY                                                          *\n;*                                                                     *\n;* This function, not yet in Common Lisp, will probably end up in CL   *\n;* soon.  It is used to process the body of a LAMBDA or a macro that   *\n;* expands into a LAMBDA or LAMBDA-like entity.  It returns 5 values.  *\n;*                                                                     *\n;* This follows the tentative specification as of the end of 1987.     *\n;* See 'PROGLIB.CL1987.TEXT' for details.                              *\n;*                                                                     *\n;* Note:  Currently there is no macroexpansion environment, and the    *\n;*        macroexpansion done by PARSE-BODY is not aware of any        *\n;*        \"CMACROS\".  This restriction will exist until we clean up    *\n;*        the macroexpansion environment situation.                    *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun parse-body (body                     ; a body of a LAMBDA et al.\n                   &optional\n                   environment              ; for macroexpansions\n                   documentation-allowed-p) ; T for DEFUN, NIL for other\n\n (let (\n       (documentation      nil)\n       (decls              nil)\n       (form               nil)\n       (valid-expansion-p  nil)\n      )\n\n  (tagbody\n   loop\n    (when body\n          (when (and documentation-allowed-p\n;;;;;;;???;;;;;;;;;;;(null documentation)\n                     (not (null (cdr body)))\n                     (stringp (car body)))\n                (unless documentation\n                        (setq documentation (car body)))\n                (setq body (cdr body))\n                (go loop))\n          ;\n          ; assert form = nil\n          ; assert valid-expansion-p = nil\n          ;\n          (catch nil (setq form\n                           (macroexpand (car body) #| environment |#))\n                     (setq valid-expansion-p t))\n          (when (and (consp form) (eq (car form) 'declare))\n                (dolist (x (cdr form)) (push x decls))\n                (setq form nil)\n                (setq valid-expansion-p nil)\n                (setq body (cdr body))\n                (go loop))))\n\n  (values\n          documentation     ; Documentation string (only one) or NIL\n          (nreverse decls)  ; List of decl-specs without DECLARE\n          body              ; body without declarations, no macroexpan's\n          form              ; macroexpanded first form of body (maybe)\n          valid-expansion-p ; T if form is macroexpansiosn of (car body)\n  )))\n\n(eval-when (load)\n (defload parse-body parsbody)\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PEEKC": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tS\\x00\\x11\\x00\\x0b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:53:00", "lines": 17, "newlines": 11, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; PEEKC - returns 1-byte character at location pointed to by argument\n;\n\n(defargs peekb 1 1 nil)\n\n(defun peekc (p &optional internp)\n (ebcdic (peekb p) internp)\n)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PEEKCH": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\tS\\x00\\x11\\x00\\x0c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:53:00", "lines": 17, "newlines": 12, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(eval-when ()\n #.(defvar crsymbol (ebcdic #/cr t))\n)\n\n(defun peekch (&optional file (eofval nil) (newlineval '#.crsymbol))\n (zcread file #.%%peekch nil nil eofval newlineval))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PEEKL": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tS\\x00\\x14\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:53:00", "lines": 20, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; PEEKL - returns list of 1-character atoms at location pointed to by\n;         first argument.  Second argument is number of characters.\n;         Use \"IMPLODE\" to turn it into an atom.\n;\n\n(defargs peekc 1 2 nil)\n\n(defun peekl (p n &optional internp)\n (loop for i from 0 to (1- n)\n       collect (peekc (+ p i) internp)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PM": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tS\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:53:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun pm (a &optional f)\n (pprint (macroexpand a) f)\n (cterpri f)\n (values)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PM1": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x11?\\x00\\x89\\x15o\\tS\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-04-23T00:00:00", "modifydate": "1989-06-05T09:53:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun pm1 (a &optional f)\n (pprint (macroexpand-1 a) f)\n (cterpri f)\n (values)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PPDATE": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00R\\x00\\x87\\x05O\\x01\\x00\\x10O\\x147\\x008\\x00\\x16\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "2000-04-13T14:37:52", "lines": 56, "newlines": 22, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; (PPDATE (1 2 3))   ==>   \"February 3, 1901\"\n;;;\n;;; Changed 04/13/2000 for Y2K support:\n;;;\n;;; (PPDATE (1 2 3))    ==>   \"February 3, 2001\" if this is 2000\n;;; (PPDATE (99 2 3))   ==>   \"February 3, 1999\" if this is 2000\n;;; (PPDATE (100 2 3))  ==>   \"February 3, 2000\" any time\n;;; (PPDATE (1901 2 3)) ==>   \"February 3, 1901\" any time\n;;;\n\n(defun ppdate (&optional (date (current-date)) &aux answer)\n (if (ok (setq answer\n               (let (((year month day) date))\n                    (string-append\n                     (or (nth month\n                              '(nil\n                                \"January \" \"February \" \"March \"\n                                \"April \"   \"May \"      \"June \"\n                                \"July \"    \"August \"   \"September \"\n                                \"October \" \"November \" \"December \"))\n                         (zerror \"Invalid month\" month))\n                     (tostring day)\n                     \", \"\n                     (tostring (fulfill-year year))))))\n     answer\n     (zerror \"Invalid date passed to PPDATE\" date)))\n\n(defun fulfill-year (year)\n (cond\n  ((lessp year 100)\n   (let\n    ((thisyear (car (current-date))))\n    (if (lessp thisyear 100)\n        (zerror \"CURRENT-DATE is still not Y2K compliant\"\n                (current-date)))\n    (let*\n     ((thiscentury (* (/ thisyear 100) 100))\n      (thatyear    (+ thiscentury year))\n      (windowyear  (+ thisyear 50))\n     )\n     (if (lessp thatyear windowyear)\n         thatyear\n         (- thatyear 100)))))\n  ((greaterp year 999)\n   year)\n  (t (zerror \"Unsupported year for PPDATE\" year))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PPRINT": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tT\\x00\\x8d\\x00]\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:54:00", "lines": 141, "newlines": 93, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; A lousy pretty-printer.  Hopefully I'll make a better one soon.\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/17/88 - Now returns no values.                                   *\n;*                                                                     *\n;***********************************************************************\n;\n(defun pretty-print (a &optional o)\n (pretty-print-internal a o)\n;(cterpri o) ; No, the callers of PPRINT must take care of this.\n (values)    ; Return no values, so nothing else prints.\n)\n\n(defun pretty-print-internal (a o)\n (cond\n  ((atom a)\n                       (prin1 a o))\n  ((null (cdr a))\n                       (princ \"(\" o)\n                       (pretty-print-internal (zcar a) o)\n                       (princ \")\" o))\n  ((atom (cdr a))\n                       (princ \"(\" o)\n                       (pretty-print-internal (zcar a) o)\n                       (princ \" . \" o)\n                       (prin1 (cdr a) o)\n                       (princ \")\" o))\n  ((and (eq (zcar a) 'quote)\n        (null (cddr a)))\n                       (princ \"'\" o)\n                       (pretty-print-internal (zcadr a) o))\n  ((and (eq (zcar a) 'function)\n        (null (cddr a)))\n                       (princ \"#'\" o)\n                       (pretty-print-internal (zcadr a) o))\n  (t\n                       (princ \"(\" o)\n                       (pp-flat a o)\n                       (princ \")\" o)))\n nil      ; Return value is irrelevant.\n)\n\n(defun pp-flat (a o)\n (prog (b c m flag oldpos)\n       (setq b a\n             m (zgetfpo o))\n  loop\n       (setq c (zcar b))\n       (when flag          ; a list was detected, print under each other\n             (cterpri o)\n             (zputfpo m o)\n       )\n\n       (setq oldpos (zgetfpo o))\n\n       (pretty-print-internal c o)\n\n       (if  flag\n        then\n        else\n        if  (not (pp-atom-p c)) ; when we find a list, set flag on\n        then\n            (if\n                 (and\n                      (neq (zcar c) 'lambda)\n                      (consp (cdr b))\n                      (pp-atom-p (zcadr b))\n                      (null (cddr b)))\n             then\n                 ; list followed by single atom, e.g. ((FOO BAR) BAZ)\n             else\n                 (setq m oldpos\n                       flag t)\n             endif\n            )\n        endif\n       )\n        ;\n        ; If any of the remaining elements of the form are lists,\n        ; then set flag to print them under each other.\n        ;\n       (when (and (null flag)\n                  (neq b a)\n                  ;\n                  ; The following loop is equivalent to\n                  ; (mapor #'(lambda (x) (not (pp-atom-p x))) b)\n                  ; except that it terminates on an ATOM test.\n                  ;\n                  (do ((b b (cdr b))\n                      )\n                      ((atom b) (not (pp-atom-p b)))\n                      (when (not (pp-atom-p (car b)))\n                            (return t))))\n             (setq m oldpos\n                   flag t)\n       )\n       (when (setq b (cdr b))\n             (if  (atom b)\n              then\n                  (princ \" . \" o)\n                  (prin1 b o)\n              else\n                  (princ \" \" o)\n                  (go loop)\n              endif\n             ))\n       (return flag)))\n\n;\n; The following predicate returns true if an object is either an atom\n; or of the form (QUOTE atom), i.e. 'atom.\n;\n\n(defun pp-atom-p (a)\n (or (atom a)\n     (and (eq (zcar a) 'quote)\n          (consp (cdr a))\n          (atom (zcadr a)) ; This makes it false for (QUOTE '(list...))\n          (null (cddr a))\n     )))\n\n(eval-when (load)\n (defload pretty-print pprint)\n)\n\n(eval-when (eval)\n (defun pprint (a &optional o) (pretty-print a o))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PPTIME": {"ttr": 2833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tT\\x00\\x1f\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:54:00", "lines": 31, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defmacro 2-digit-string (n)\n `(string-substr (tostring (+ ,n 100)) 2))\n\n(defun pptime (&optional (time (current-time)) &aux answer)\n (if (ok (setq answer\n               (let (((hour minute second) time))\n                    (cond\n                     ((and (eql hour 0) (eql minute 0))\n                      \"12:00 Mid.\")\n                     ((and (eql hour 12) (eql minute 0))\n                      \"12:00 Noon\")\n                     (t\n                      (string-append\n                       (tostring (cond\n                                  ((zerop hour) 12)\n                                  ((> hour 12) (- hour 12))\n                                  (t hour)))\n                       \":\"\n                       (2-digit-string minute)\n                       (if (> hour 11) \" P.M.\" \" A.M.\")))))))\n     answer\n     (zerror \"Invalid time passed to PPTIME\" time)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PRINC": {"ttr": 2835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tT\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:54:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun princ (a &optional f)\n (zcprint a f #.%%%princ)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRINT": {"ttr": 2837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tT\\x00\\x13\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:54:00", "lines": 19, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; CL PRINT is defined as newline (TERPRI) + PRIN1 + space.\n;\n\n(defun print (x &optional f)\n (terpri f)\n (prin1 x f)\n (tyo #/SP f)\n x\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRINTC": {"ttr": 2839, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tU\\x00\\x13\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:55:00", "lines": 19, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is like ZIL PRINT, but uses PRINC rather than PRIN1.\n;\n\n(defun printc (x &optional f)\n (terpri f)\n (princ x f)\n (tyo #/SP f)\n x\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRINTS": {"ttr": 2841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tU\\x00i\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:55:00", "lines": 105, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"PRINT-TO-STRING\"\n;;;\n\n;\n; (PRINTS object NIL) - creates a string like PRINC.\n;\n; (PRINTS object T  ) - creates a string like PRIN1.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This is a complete replacement for the old PRINx-TO-STRING,         *\n;* using streams.                                                      *\n;*                                                                     *\n;***********************************************************************\n;\n\n(include #.(zil-source-member zcsdfstr)) ; Stream structures.\n\n(defun prints (object &optional escape)\n\n (unless (boundp '*print-case*)\n  (zcpexec nil nil #.%%%charpos) ; Force setting of *print-...* vars\n )\n\n (let ((stringlist nil)\n       (stream (make-stream :identifier \"Print String\" :type 'string))\n      )\n      (setf (stream-output-function stream)\n            #'(lambda (char) (push (string char) stringlist)))\n      (setf (stream-princ-function stream)\n            #'(lambda (string) (push string stringlist)))\n      ;;;(write object :stream stream :escape escape)\n      (zcpexec object stream (if escape #.%%%prin1 #.%%%princ))\n      (string-appendl (nreverse stringlist))))\n\n;;; Old code, no longer in use. ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; (eval-when (compile eval)\n;  (defvar lp  \"(\"               \"left  list      parenthesis\")\n;  (defvar rp  \")\"               \"right list      parenthesis\")\n;  (defvar lvp \"#(\"              \"left  vector    parenthesis\")\n;  (defvar rvp \")\"               \"right vector    parenthesis\")\n;  (defvar lsp \"#<STRUCT \"       \"left  structure parenthesis\")\n;  (defvar rsp \">\"               \"right structure parenthesis\")\n;  (defvar lfp \"#<FUNARG \"       \"left  funarg    parenthesis\")\n;  (defvar rfp \">\"               \"right funarg    parenthesis\")\n; )\n;\n; (declare (special *prints-list*))\n;\n; (defmacro prout (a)\n;  `(push ,a *prints-list*)\n; )\n;\n; (defun prints (a &optional s)\n;  (let ((*prints-list* nil))\n;       (prins a s)\n;       (string-appendl (nreverse *prints-list*))))\n;\n; (defun prins (a s)\n;  (cond\n;   ((or (and (atom a) (not (vecp a)))\n;        (eq a (zilunbnd))\n;        (eq a (rmnil))\n;    )               (prout (tostring a s)))\n;   ((vectorp a)     (prout #.lvp)\n;                    (prins-flat (vlist a) s)\n;                    (prout #.rvp))\n;   ((structp a)     (prout #.lsp)\n;                    (prins-flat (vlist a) s)\n;                    (prout #.rsp))\n;   ((funargp a)     (prout #.lfp)\n;                    (prins (funfun a) s)\n;                    ;;;;;; (funenv a) does not get printed.\n;                    (prout #.rfp))\n;   (t               (prout #.lp)\n;                    (prins-flat a s)\n;                    (prout #.rp))))\n;\n; (defun prins-flat (a s)\n;  (when a\n;   (prog ()\n;    loop\n;        (prins (zcar a) s)\n;        (setq a (cdr a))\n;        (cond\n;         ((null a)\n;          (return nil))\n;         ((atom a)\n;          (prout \" . \")\n;          (prins a s))\n;         (t\n;          (prout \" \")\n;          (go loop))))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PRIN1": {"ttr": 2843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tU\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:55:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun prin1 (a &optional f)\n (zcprint a f #.%%%prin1)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PROBEF": {"ttr": 2845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tU\\x00*\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:55:00", "lines": 42, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; PROBEF returns the file name if it exists, and NIL if it doesn't.\n;\n\n (defun probef (file)\n  (or (stringp file)\n      (and file (symbolp file))\n      (zerror \"PROBEF: Invalid data set name\" file))\n\n  (let* ((upcase-file (string-upcase file))\n         (result (open upcase-file 'probe)))\n        (when (null result)\n              (when (< (msglevel) 3)\n                    (cterpri)\n                    (princ \"Data set \")\n                    (princ upcase-file)\n                    (princ \" not found.\")\n                    (terpri)))\n        result))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Old kludgey definition.\n;\n;  (unwind-protect\n;   (catch nil\n;    (msglevel 3)\n;    (setq file (string-upcase file))\n;    (setq a (open file))\n;    file\n;   )\n;   (msglevel save-msglevel)\n;   (if a (close a))\n;  )\n;)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "QUIT": {"ttr": 2847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\tW\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:57:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun quit (&optional file)\n (zcread file #.%%quit nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RDRMACRO": {"ttr": 2849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\tY\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:59:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun rdrmacro (character subr)\n (zcread nil #.%%rdrmacro character subr nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "READ": {"ttr": 2851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\tY\\x00\\x19\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:59:00", "lines": 25, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; Note that this is the Maclisp READ, not the Common Lisp READ.\n;;; The CL READ would be...\n;;;\n;;;   (defun read      (&optional file eof-error-p eofval recursive-p)\n;;;    (zcread file #.%%read nil eof-error-p eofval recursive-p))\n;;;\n;;;   (defun read-preserving-whitespace\n;;;          (&optional file eof-error-p eofval recursive-p)\n;;;    (zcread file #.%%read t eof-error-p eofval recursive-p))\n;;;\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun read (&optional file eofval)\n (zcread file #.%%read nil nil eofval nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "READCH": {"ttr": 2853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\tY\\x00\\x11\\x00\\x0c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:59:00", "lines": 17, "newlines": 12, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(eval-when ()\n #.(defvar crsymbol (ebcdic #/cr t))\n)\n\n(defun readch (&optional file (eofval nil) (newlineval '#.crsymbol))\n (zcread file #.%%readch nil nil eofval newlineval))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "READLINE": {"ttr": 2855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\tY\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T09:59:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun readline (&optional file)\n (zcread file #.%%readline nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMDUPQ": {"ttr": 2857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tY\\x00\\x13\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:59:00", "lines": 19, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun remdupq (a)\n (when a\n       (prog (z x)\n        loop\n             (setq x (zcar a))\n             (unless (memq x z)\n                     (push x z))\n             (when (setq a (cdr a))\n                   (go loop))\n             (return (nreverse z)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMDUPQL": {"ttr": 2859, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tY\\x00\\x13\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:59:00", "lines": 19, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun remdupql (a)\n (when a\n       (prog (z x)\n        loop\n             (setq x (zcar a))\n             (unless (memql x z)\n                     (push x z))\n             (when (setq a (cdr a))\n                   (go loop))\n             (return (nreverse z)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMDUPQU": {"ttr": 3074, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\tY\\x00\\x13\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T09:59:00", "lines": 19, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun remdupqu (a)\n (when a\n       (prog (z x)\n        loop\n             (setq x (zcar a))\n             (unless (memqual x z)\n                     (push x z))\n             (when (setq a (cdr a))\n                   (go loop))\n             (return (nreverse z)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMQL": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x00\\x00.\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 46, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (REMOVE A B :TEST #'EQL)\n;\n\n(defun remql (a b &optional c)\n\n ; a = the object to be searched for.\n ; b = the list to delete it from.\n ; c = a count of occurrences, default = delete all occurrences.\n\n (prog (d x z)\n       (setq d nil\n             z nil)\n       (when c\n             (unless (fixnump c)\n                     (zerror \"Invalid REMQL count argument\" c))\n             (unless (plusp c) (return b)))\n  loop (unless b (return z))\n  ;\n  ; Warning - no check for atomic b (sublist of arg2)\n  ;\n       (if   (eql a (zcar b))\n        then\n             (when c\n                   (when (zerop (setq c (1- c)))\n                         (if z (rplacd d (cdr b))\n                               (setq z (cdr b)))\n                         (return z)))\n        else\n             (setq x (ncons (zcar b)))\n             (if d (rplacd d x)\n                   (setq z x))\n             (setq d x)\n        endif\n       )\n       (setq b (cdr b))\n       (go loop)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "REMQUAL": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x00\\x00.\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 46, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (REMOVE A B :TEST #'EQUAL)\n;\n\n(defun remqual (a b &optional c)\n\n ; a = the object to be searched for.\n ; b = the list to delete it from.\n ; c = a count of occurrences, default = delete all occurrences.\n\n (prog (d x z)\n       (setq d nil\n             z nil)\n       (when c\n             (unless (fixnump c)\n                     (zerror \"Invalid REMQUAL count argument\" c))\n             (unless (plusp c) (return b)))\n  loop (unless b (return z))\n  ;\n  ; Warning - no check for atomic b (sublist of arg2)\n  ;\n       (if   (equal a (zcar b))\n        then\n             (when c\n                   (when (zerop (setq c (1- c)))\n                         (if z (rplacd d (cdr b))\n                               (setq z (cdr b)))\n                         (return z)))\n        else\n             (setq x (ncons (zcar b)))\n             (if d (rplacd d x)\n                   (setq z x))\n             (setq d x)\n        endif\n       )\n       (setq b (cdr b))\n       (go loop)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "REVERSAL": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x00\\x00\\x19\\x00\\x15\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 25, "newlines": 21, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; REVERSALL\n;\n\n(defun reversall (l)\n (if (atom l)\n     l\n     (do ((l l (cdr l))\n          (r nil\n             (cons (if (atom (zcar l)) (zcar l) (reversall (zcar l)))\n                   r)))\n         ((null l) r))))\n\n(eval-when (load)\n (defload reversall reversal)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMCHAR": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x10\\x00\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun rmchar ()\n (zcread nil #.%%rmchar nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMINIT": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x10\\x00\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun rminit ()\n (zcread nil #.%%rminit nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMMAC": {"ttr": 3086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x10\\x00\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun rmmac ()\n (zcread nil #.%%rmmac nil nil nil nil))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ROUND": {"ttr": 3088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x00\\x00\\x13\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 19, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun round (x &optional (y nil y?))\n (if y?\n     (let ((q (zilfix (/ (if (and (integerp x) (integerp y))\n                             (float x)\n                             x)\n                         y)\n                      12)))\n          (values q (- x (* q y))))\n     (let ((q (zilfix x 12)))\n          (values q (- x q)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SET": {"ttr": 3090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x00\\x000\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 48, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; SET\n;\n;;;\n;;; When shallow binding is implemented, this version of the function\n;;; will disappear, to be replaced by an assembler-coded function\n;;; (and an inline-coded compiler-generated code sequence as well)\n;;; which will store into the value cell of the symbol.\n;;; Something like this:\n;;;\n;;;  L    r1,<symbol-arg>\n;;;  ST   15,##PVALUE(,r1)\n;;;\n;;; or, if the warning on setting unbound symbols is to be supported:\n;;;\n;;;  L    r1,<symbol-arg>\n;;;  ICM  reg,15,##PVALUE(r1)\n;;;  BALR 0,0\n;;;  BM   4(,reg)  ... or whatever, to branch to unbound-warning\n;;;  ST   15,##PVALUE(,r1)\n;;;\n;;; The code pointed to by the unbound-variable-marker will have to\n;;; determine if it was called to signal an unbound-variable error\n;;; (not before trying to autoload the symbol value) or to issue\n;;; an unbound-variable-setting warning.  Probably it will have to\n;;; examine the ICM to see if it was using register 14 or not.\n;;;\n;;; Question:  Is this worth doing?  Even if we retain symbol autoload,\n;;; it is probably not worth doing for the SET warnings.\n;;;\n;;; Remember, a symbol evaluates to itself if its PBIND cell\n;;; points to itself.  This includes T, NIL, and keywords by default.\n;;;\n\n(defun set (var val)\n (unless (and var (symbolp var) (neq (pbind var) var))\n         (zerror \"Invalid SET variable\" var))\n (cdr (zevset var val))                 ; Access only SPECIAL bindings\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SETFEAT": {"ttr": 3092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x00\\x00\\x15\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 21, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"SET-FEATURE\"\n;;;\n\n(declare (special *features*))\n\n(defun set-feature (x)\n (if (not (symbolp x))\n     (zerror \"Not a valid feature (must be a symbol)\" x)\n     (pushnew x *features* :test #'eq)))\n\n(defload set-feature setfeat)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SETNFEAT": {"ttr": 3094, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x00\\x00\\x14\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 20, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"SET-NOFEATURE\"\n;;;\n\n(declare (special *features*))\n\n(defun set-nofeature (x)\n (setq *features* (delq x *features*))\n)\n\n(defload set-nofeature setnfeat)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SETPRT": {"ttr": 3096, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x18\\x8f\\x00\\x89\\x15o\\x10\\x00\\x00\\x1d\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-07-07T00:00:00", "modifydate": "1989-06-05T10:00:00", "lines": 29, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"SETPRT\"\n;;;\n;;; This function takes 1 argument, a function spec, and makes the\n;;; function spec the current ZIL printer.  It interfaces to the\n;;; low-level ZILSPRT routine to change the current printer function.\n;;;\n;;; NOTE: This function only works compiled.\n;;;\n\n(declare (special *setprt-function*))\n\n(defun setprt (f)\n (setq *setprt-function* f)\n (zilsprt (subr setprt-wrapper))\n)\n\n(defun setprt-wrapper (a b c)\n (funcall *setprt-function* a b c)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SETREAD": {"ttr": 3098, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x10\\x01\\x00\\x1d\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T10:01:00", "lines": 29, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"SETREAD\"\n;;;\n;;; This function takes 1 argument, a function spec, and makes the\n;;; function spec the current ZIL reader.  It interfaces to the\n;;; low-level ZILSRD routine to change the current reader function.\n;;;\n;;; NOTE: This function only works compiled.\n;;;\n\n(declare (special *setread-function*))\n\n(defun setread (f)\n (setq *setread-function* f)\n (zilsrd (subr setread-wrapper))\n)\n\n(defun setread-wrapper (a b c d e f)\n (funcall *setread-function* a b c d e f)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SETSYNTA": {"ttr": 3100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x01\\x00&\\x00\\x16\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:01:00", "lines": 38, "newlines": 22, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; Minimal compatibility with Maclisp and Franz.  Not Common LISP.\n;;;\n\n(eval-when (compile)\n (defmacro selfmacro () '(subr zrmself))\n)\n\n(eval-when (eval)\n (defmacro selfmacro () '(zilload 'zrmself))\n)\n\n(defargs zrmself 1 1 nil)\n\n(defun setsyntax (a b c)\n (case b\n  (macro\n   (if c\n       (defrdmac a c)     ; (SETSYNTAX '|?| 'MACRO #'(LAMBDA (X) ...))\n       (rdrmacro a nil))) ; (SETSYNTAX '|?| 'MACRO NIL)\n  (single                 ; (SETSYNTAX '|?| 'SINGLE NIL)\n   (if c\n       (zerror \"Not allowed with SETSYNTAX SINGLE\" c)\n       (rdrmacro a (selfmacro))))\n  (t (zerror \"Unknown SETSYNTAX type\" b))))\n\n(eval-when (load)\n (defload setsyntax setsynta)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SLTRIM": {"ttr": 3102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x01\\x00\\x11\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:01:00", "lines": 17, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; STRING-LEFT-TRIM\n;\n\n(defun string-left-trim (bag str)\n (string-substr str (string-verify str bag)))\n\n(defload string-left-trim sltrim)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SOME": {"ttr": 3104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x01\\x00.\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:01:00", "lines": 46, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"SOME\"  - an iterator a la NIL, viz.\n;\n; (some #'foo-p list1 list2 ...) if foo-p is true of at least one of the\n;                                element(s), returns foo-p thereof.\n;\n; The compiler really ought to transform this into inline code,\n; a la the mapping functions.\n;\n\n(defun some1 (fun lis) ; case of 1 list.\n (cond\n  ((null lis) nil)\n  ((atom lis) (zerror \"Argument 2 to SOME not a list\" lis))\n  (t\n   (prog ()\n      loop\n           (return (or (funcall fun (car lis))\n                       (when (setq lis (cdr lis))\n                             (go loop))))))))\n\n(defun some (fun &rest lists) ; case of multiple lists.\n (cond\n  ((null lists)       nil)\n  ((null (cdr lists)) (some1 fun (car lists)))\n  (t\n   (dolist (list lists)\n           (unless (listp list)\n                   (zerror \"Non-list passed to SOME\" list)))\n   (prog (v)\n    loop (when (mapor #'null lists) (return nil))\n         (when (setq v (zilapply fun (mapcar #'car lists)))\n               (return v))\n         (setq lists (mapcar #'cdr lists))\n         (go loop)))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SORT": {"ttr": 3106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x01\\x00+\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:01:00", "lines": 43, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; SORT\n;\n; Note: This sort does NOT destructively modify its argument.\n;       I hope this doesn't upset anyone.\n;\n\n(defun sort (l &optional f)\n (when l\n       (when (atom l)\n             (zerror \"Argument to SORT not a list\" l))\n       ;;;\n       ;;; I'd check for proper-list-ness in the loop, but that would\n       ;;; slow the sort down too much.  However, I felt that at least\n       ;;; a non-cons arg to SORT should be flagged.\n       ;;;\n       (prog (a z)\n        loop\n             (setq a (zcar l))\n             (setq z\n                   (prog (m v)\n                         (setq m nil v z)\n                    loop (when (or (null z)\n                                   (if f (funcall f a (zcar z))\n                                         (lessp a (zcar z))))\n                               (if m (rplacd m (cons a z))\n                                     (setq v (cons a z)))\n                               (return v)\n                         )\n                         (setq z (cdr (setq m z)))\n                         (go loop)))\n             (when (setq l (cdr l))\n                   (go loop))\n             (return z))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SORTCAR": {"ttr": 3108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x01\\x00\\x0c\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:01:00", "lines": 12, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun sortcar (a &optional f)\n (if f\n     (sort a #'(lambda (x y) (funcall f (car x) (car y))))\n     (sort a #'(lambda (x y) (lessp (car x) (car y))))))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SREMOVE": {"ttr": 3110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x01\\x00\\x14\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:01:00", "lines": 20, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; STRING-REMOVE\n;\n\n(defun string-remove (bag str)\n (loop for char in (zilexpl str nil nil)\n       unless (string-index bag char)\n       push (symbol-name char) into z\n       finally (return (string-appendl (nreverse z)))))\n\n(defload string-remove sremove)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SRTRIM": {"ttr": 3112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x13\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 19, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; STRING-RIGHT-TRIM\n;\n\n(defun string-right-trim (bag str)\n (string-reverse\n  (string-left-trim bag (string-reverse str))))\n\n\n(defload string-right-trim srtrim)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRIM": {"ttr": 3114, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x12\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 18, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; STRING-TRIM\n;\n\n(defun string-trim (bag str)\n (string-right-trim bag\n  (string-left-trim bag str)))\n\n(defload string-trim strim)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRUCTUR": {"ttr": 3116, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x15?\\x00\\x89\\x15o\\x10\\x02\\x00\\x0e\\x00\\x0b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-01T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 14, "newlines": 11, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun structure (&rest z)\n (zmstruct z)\n)\n\n(defload structure structur)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBLIS": {"ttr": 3118, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x11\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 17, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun sublis  (a y)\n               (cond ((atom y) (sublis2 a y))\n                     (t        (cons (sublis a (zcar y))\n                                     (sublis a (cdr y)) ))))\n(defun sublis2 (a z)\n               (cond ((null a)           z)\n                     ((eql (caar a) z)   (cdar a))\n                     (t                  (sublis2 (cdr a) z) )))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBLISQ": {"ttr": 3120, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x14\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 20, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (SUBLIS A B :TEST #'EQ).\n;\n\n(defun sublisq (a y)\n               (cond ((atom y) (sublisq2 a y))\n                     (t        (cons (sublisq a (zcar y))\n                                     (sublisq a (cdr y)) ))))\n(defun sublisq2 (a z)\n               (cond ((null a)           z)\n                     ((eq (caar a) z)    (cdar a))\n                     (t                  (sublisq2 (cdr a) z) )))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSTQ": {"ttr": 3122, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x1f\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 31, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (SUBST NEW OLD X :TEST #'EQ).\n;\n; This definition has been rewritten to be more similar to\n; Guy Steele's definition - see CLtL, p. 274.\n;\n; Note that the \"satisfies-the-test\" part is conditional based on\n; the \"atom\" test, since non-atomic elements can never be EQL.\n; We can do this for SUBSTQ and SUBSTQL, but not SUBSTQUA.\n;\n\n(defun substq (new old x)\n (cond\n  ((atom x) (if (eq old x) new x))\n  (t        (let ((kar (substq new old (car x)))\n                  (kdr (substq new old (cdr x))))\n                 (if (and (eq kar (car x))\n                          (eq kdr (cdr x)))\n                     x\n                     (cons kar kdr))))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SUBSTQL": {"ttr": 3330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x1f\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 31, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (SUBST NEW OLD X :TEST #'EQL).\n;\n; This definition has been rewritten to be more similar to\n; Guy Steele's definition - see CLtL, p. 274.\n;\n; Note that the \"satisfies-the-test\" part is conditional based on\n; the \"atom\" test, since non-atomic elements can never be EQL.\n; We can do this for SUBSTQ and SUBSTQL, but not SUBSTQUA.\n;\n\n(defun substql (new old x)\n (cond\n  ((atom x) (if (eql old x) new x))\n  (t        (let ((kar (substql new old (car x)))\n                  (kdr (substql new old (cdr x))))\n                 (if (and (eq kar (car x))\n                          (eq kdr (cdr x)))\n                     x\n                     (cons kar kdr))))))\n\n(defload car zcar)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SUBSTQUA": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x1d\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 29, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is equivalent to Common LISP (SUBST NEW OLD X :TEST #'EQUAL).\n;\n; This definition has been rewritten to be more similar to\n; Guy Steele's definition - see CLtL, p. 274.\n;\n\n(defun substqual (new old x)\n (cond\n  ((equal old x) new)\n  ((atom x)      x)\n  (t             (let ((kar (substqual new old (car x)))\n                       (kdr (substqual new old (cdr x))))\n                      (if (and (eq kar (car x))\n                               (eq kdr (cdr x)))\n                          x\n                          (cons kar kdr))))))\n\n(defload substqual substqua)\n(defload car zcar)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SXHASH": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x02\\x00\\x1d\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:02:00", "lines": 29, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; SXHASH\n;;;\n;;; Note: This function calls ZILHASH, which is the primitive\n;;;       (assembler) atom-hashing function.\n;;;\n\n(defun sxhash (a)\n (cond\n  ((consp a)   (do ((a a (cdr a))\n                    (z 0))\n                   ((atom a) (if a (logxor (sxhash a) z) z))\n                   (setq z (logxor (sxhash (zcar a)) z))))\n  ((vecp a)    (do ((i (1- (vlength a)) (1- i))\n                    (z 0 (logxor (sxhash (vref a i)) z))\n                   )\n                   ((minusp i) z)))\n  (t           (zilhash a))))\n\n(defargs zilhash 1 1 nil)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYMEVAL": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x03\\x00P\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 80, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; SYMEVAL\n;;;\n;;; Argument 1 (required) - the symbol to be evaluated.\n;;;\n;;; Note:\n;;;\n;;; Arg 1 is expected to be a symbol other than T or NIL.\n;;;\n;;; Features no longer supported by SYMEVAL:\n;;;\n;;;\n;;; (A) Optional alist argument (was used only by EVAL, who no longer\n;;;     calls SYMEVAL).\n;;;\n;;; (B)        If the variable is unbound, before we signal an error\n;;;            we do the following:\n;;;              (1) If the variable is a keyword, we return the\n;;;                  variable itself as the value.  Since ZIL does not\n;;;                  have a package system, a symbol is considered to\n;;;                  be a keyword if its first character is a colon.\n;;;                  Kludge, but necessary.\n;;;              (2) If the variable has an AUTOVALUE property, we\n;;;                  process it much like the AUTOLOAD property of\n;;;                  function names... if it is a string, the file\n;;;                  of that name is loaded; if it is a list, the\n;;;                  list is evaluated as a form.  The AUTOVALUE\n;;;                  property cannot be a symbol.\n;;;\n;;; END of unsupported features.\n;;;\n;;;            Completely recoded to use the new ZEVSYM function,\n;;;            which we need to support the new autobinding feature\n;;;            under the compiler.\n;;;\n;;;            Also, no extra features are supported.  If the\n;;;            variable does not have a current binding, it is\n;;;            considered unbound.  Only the evaluator itself is\n;;;            allowed to assume other values (CSETQ, OBLIST, ALIST,\n;;;            keywords, etc.).\n;;;\n;;;\n;;; When shallow binding is implemented, this version of the function\n;;; will disappear, to be replaced by an assembler-coded function\n;;; (and an inline-coded compiler-generated code sequence as well)\n;;; which will load the value cell of the symbol and test it for\n;;; unboundedness.  Something like this:\n;;;\n;;;  L    14,=A(symbol)\n;;;  ICM  reg,15,##PVALUE(14)\n;;;  BMR  reg\n;;;\n;;; or, if symbol-autoloading is to be supported by BOUNDP:\n;;;\n;;;  L    14,=A(symbol)\n;;;  ICM  reg,15,##PVALUE(14)\n;;;  BALR 0,0      ... so the handler knows where to return to\n;;;  BMR  reg      ... or whatever, to branch to unbound-variable\n;;;                ... handling in error-signalling mode\n;;;                ... which will reissue the ICM to set condition code\n;;;\n;;; Also see SET and BOUNDP.\n;;;\n;;; We should also ditch that optional second operand.\n;;;\n\n(defun symeval (x)\n (let ((binding (zevsym x)))\n      (if (consp binding)\n          (cdr binding)\n          (zerror \"Variable has no value\" x))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "TERPRI": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x18\\x8f\\x00\\x89\\x15o\\x10\\x03\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-07T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun terpri (&optional f)\n (zcprint nil f #.%%%terpri)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRUNCATE": {"ttr": 3340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87(\\x7f\\x00\\x89\\x15o\\x10\\x03\\x00\\x17\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 23, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; Note that since integer division already truncates, it is not\n; necessary to convert the arguments to float before dividing.\n; However, we do it anyhow, just to check the conversion algorithms.\n\n(defun truncate (x &optional (y nil y?))\n (if y?\n     (let ((q (zilfix (/ (if (and (integerp x) (integerp y))\n                             (float x)\n                             x)\n                         y)\n                      0)))\n          (values q (- x (* q y))))\n     (let ((q (zilfix x 0)))\n          (values q (- x q)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYI": {"ttr": 3342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x10\\x03\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun tyi (&optional file (eofval -1) (newlineval #/cr))\n (zcread file #.%%tyi nil nil eofval newlineval))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYIPEEK": {"ttr": 3344, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x10\\x03\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun tyipeek (&optional arg file (eofval -1) (newlineval #/cr))\n (zcread file #.%%tyipeek arg nil eofval newlineval))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYO": {"ttr": 3346, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x03\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun tyo (char &optional file)\n (zcprint char file #.%%%tyo)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYPEP": {"ttr": 3348, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x03\\x00p\\x00\\\\\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 112, "newlines": 92, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; 12/16/88 - (typep x 'character) --> (characterp x)\n\n(include #.(zil-source-member zlflvstr)) ; FLAVOR defstruct.\n\n(defun typep (a &optional (b nil b?))\n (cond\n  ((not b?)         (typep-1 a))\n  (t                (typep-2 a b))\n )\n)\n\n;\n; TYPEP with one argument.\n;\n\n(defun typep-1 (a)\n (cond\n  ((consp a)    'list)\n  ((symbolp a)  'symbol)\n  ((fixnump a)  'fixnum)\n  ((bigp a)     'bignum)\n  ((sfloatp a)  'single-float)\n  ((dfloatp a)  'double-float)\n  ((stringp a)  'string)\n  ((vectorp a)  'vector)\n  ((subrp a)    'subr)\n  ((closurep a) 'closure)\n  ((funargp a)  'funarg)\n  ((structp a)  (let ((x (vref a 0)))\n                     (cond\n                      ((eq x 'zil-flavor-instance)\n                       (zil-flavor-instance-flavor-name a))\n                      ((symbolp x)\n                       x)\n                      (t\n                       'structure))))\n  (t            'atom)\n )\n)\n\n;\n; TYPEP with two arguments.\n;\n\n(defun typep-2 (a b)\n (cond\n  ((null b)     nil)\n  ((eq b t)     t)\n  ((consp b)    (typep-2-list a b))\n  ((symbolp b)  (typep-2-atom a b))\n  (t            (zerror \"Unknown second arg to TYPEP\" b))))\n\n(defun typep-2-atom (a b)\n (case b\n       ((atom)       (atom     a))\n       ((list)       (listp    a))\n       ((cons)       (consp    a))\n       ((symbol)     (symbolp  a))\n       ((fixnum)     (fixnump  a))\n       ((float\n         flonum)     (floatp   a))\n       ((\n         short-float\n         single-float\n        )            (sfloatp  a))\n       ((\n         double-float\n        )            (dfloatp  a))\n       ((bignum)     (bigp     a))\n       ((integer)    (integerp a))\n       ((string)     (stringp  a))\n       ((vector)     (vectorp  a))\n       ((compiled-function\n         code)       (codep    a))\n       ((subr)       (subrp    a))\n       ((closure)    (closurep a))\n       ((funarg)     (funargp  a))\n       ((struct\n         defstruct\n         structure)  (structp  a))\n       ((character)  (characterp a))\n       (t\n        (and (structp a)\n             (or (eq (vref a 0) b)\n                 (and (eq (vref a 0) 'zil-flavor-instance)\n                      (eq (zil-flavor-instance-flavor-name a) b)))))))\n\n\n(defun typep-2-list (a b)\n (case (car b)\n  ((or)\n   (some   #'(lambda (x) (typep-2 a x)) (cdr b)))\n  ((and)\n   (every  #'(lambda (x) (typep-2 a x)) (cdr b)))\n  ((not)\n   (not (typep-2 a (cadr b))))\n  ((member)\n   (if (member a (cdr b)) t nil))\n  ((satisfies)\n   (if (funcall (cadr b) a) t nil))\n  (t\n   (warn \"Unknown second arg to TYPEP\" b)\n   nil)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "UCONCAT": {"ttr": 3350, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x03\\x00\\x12\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 18, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; UCONCAT\n;\n; This definition is the same as Franz LISP UCONCAT.\n;\n; It takes any number of atoms (not lists, vectors or funargs)\n; and makes an UNinterned symbol out of them.\n;\n\n(defun uconcat (&rest a) (uconcatl a))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UCONCATL": {"ttr": 3352, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87$o\\x00\\x89\\x15o\\x10\\x03\\x00\\x0b\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-03T00:00:00", "modifydate": "1989-06-05T10:03:00", "lines": 11, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun uconcatl (a)\n (zilimpl a nil nil))    ; list to uninterned symbol\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNION": {"ttr": 3354, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x05\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:05:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; UNION - this uses the EQL test.\n;\n\n(defun union   (x y)\n               (cond ((null x)           y)\n                     ((memql (zcar x) y) (union (cdr x) y))\n                     (t                  (cons (zcar x)\n                                               (union (cdr x) y)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNIONQ": {"ttr": 3356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x05\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:05:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is UNION using the EQ test.\n;\n\n(defun unionq  (x y)\n               (cond ((null x)          y)\n                     ((memq (zcar x) y) (unionq (cdr x) y))\n                     (t                 (cons (zcar x)\n                                              (unionq (cdr x) y)))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNKWDIFY": {"ttr": 3358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x14\\x8f\\x00\\x89\\x15o\\x10\\x05\\x00\\x17\\x00\\x06\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-05-28T00:00:00", "modifydate": "1989-06-05T10:05:00", "lines": 23, "newlines": 6, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; Some day this will have to intern x in the current package.\n;;; But for now...\n\n(defun unkeywordify (x)\n ;;\n ;;(intern (symbol-name x) *package*)\n ;;\n (cond\n  ((keywordp x)\n   (intern (string-substr (symbol-name x) 2)))\n  ((symbolp x) x)\n  (t (zerror \"Argument to UNKEYWORDIFY not a symbol\" x))))\n\n(defload unkeywordify unkwdify)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "UNTYI": {"ttr": 3360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x882\\x8f\\x00\\x89\\x15o\\x10\\x05\\x00\\r\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1989-06-05T10:05:00", "lines": 13, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun untyi (char &optional file (eofval -1) (newlineval #/cr))\n (zcread file #.%%untyi char nil eofval newlineval))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VECTOR": {"ttr": 3362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x15?\\x00\\x89\\x15o\\x10\\x05\\x00\\x0c\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-01T00:00:00", "modifydate": "1989-06-05T10:05:00", "lines": 12, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun vector (&rest z)\n (zmvector z)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WARN": {"ttr": 3364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x05\\x00)\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:05:00", "lines": 41, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; WARN\n;;;\n;;; The first arg is assumed to be a message, and is therefore PRINC'd.\n;;; The second arg is assumed to be a random value, and is therefore\n;;; PRIN1'd.\n;;; The &rest arg is assumed to be a list of random values, and is\n;;; therefore PRIN1'd.\n;;;\n;;; Enhancement:  If the first arg is a list, all the elements in the\n;;;               list are printed in succession.\n;;;\n;;;\n;;; Note: This will change to Common LISP, such that it will take the\n;;;       args in the format of a format string, eventually.\n;;;       But not right now.\n;;;\n\n(defun warn (a &optional (b nil b?) &rest c)\n (when (< (msglevel) 2)\n       (cterpri)\n       (princ \"Warning: \")\n       (if (atom a)\n           (princ a)\n           (dolist (i a) (princ i)))\n       (when b?\n             (princ \" - \")\n             (prin1 b))\n       (dolist (i c) (princ \" \") (prin1 i))\n       (terpri))\n nil\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "XINCLUDE": {"ttr": 3366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x05\\x00*\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:05:00", "lines": 42, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; XINCLUDE\n;\n; This function performs the work of the macros INCLUDE and INCLUDEF.\n;\n; Remember...\n;\n;  (INCLUDE   FOO)  ==> (PROGN (contents of file FOO) ...)\n;\n;  (INCLUDEF 'FOO)  ==> (PROGN (contents of file FOO) ...)\n;\n; XINCLUDE is a function that takes a file name and returns a PROGN\n; containing the forms therein.\n;\n; 12/16/88 - Changed return value from NIL to (PROGN) to avoid the\n;            warning when the compiler sees it at top level.\n;\n\n(eval-when ()\n #.(defvar include-return-value '(progn)\n    \"The value defined as being returned by evaluating or compiling\n     the INCLUDE form.\"\n   ))\n\n(defun xinclude (file)\n (with-open-file (f file)\n  (do ((z nil (cons (catch nil (read f '#.include-return-value)) z)))\n      ((eof f) `(progn . ,(nreverse z))))))\n\n(eval-when (eval)\n (defmacro includef (file) (xinclude (eval file)))\n (defmacro include  (file) (xinclude file))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "Z": {"ttr": 3368, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x87\\x05o\\x00\\x89\\x15o\\t(\\x00\\x08\\x00\\x05\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1987-02-25T00:00:00", "modifydate": "1989-06-05T09:28:00", "lines": 8, "newlines": 5, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCCAND": {"ttr": 3370, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x06\\x00l\\x00M\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:06:00", "lines": 108, "newlines": 77, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This compiles the \"AND\" function.\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccand (b v s e) ; B = body, V = variable, S = target, E = environment\n (prog (a xf exitlabel setnillabel wayout save-tempcond)\n  (setq a b)\n  (setq wayout (if (and (null v) (consp s) (zilcovta s))\n                   (car s)\n                   nil))\n  (setq exitlabel (gensym))\n  (putprop exitlabel v 'vartarg)\n  (putprop exitlabel s 'rettarg)\n\n;;(putprop exitlabel e 'envtarg) ; ?? Probably not useful for anything.\n\n  (or a        (return (modq body `(sett ,t ,v ,s))))   ; (AND)   -> T\n  (or (cdr a)  (return (zccevcom (car a) v s e)))       ; (AND x) -> x\n\n  (setq save-tempcond (zilcec-tempcond (car e)))\n\n loop\n\n  (setq xf (zccpred (car a)))\n\n  (if   (notp xf)                              ; (AND ... (NOT x) ...)\n   then\n        (zccevcom (cadr xf)\n                  nil\n                  (if   (eq wayout 'gonil)\n                   then `(gonotnil ,(cadr s))  ; predicative AND NOT\n                   else `(gonotnil ,(or setnillabel\n                                        (setq setnillabel (gensym))))\n                   endif)\n                  e)\n        (or (eq wayout 'gonil)                 ; if non-predicative\n            (cdr a)                            ; and (AND ... (NOT x))\n                                               ; then generate a T\n            (modq body `(sett t nil (goto ,exitlabel))))\n   else                                        ; (AND ... x ...)\n                                               ;\n                                               ; If non-predicative\n                                               ; and (AND ... x), then\n                                               ; generate code for x,\n                                               ; not for what ZCCPRED\n                                               ; did to it.  Otherwise\n                                               ; use what ZCCPRED ret'd.\n                                               ;\n        (zccevcom (if (or (eq wayout 'gonil) (cdr a)) xf (car a))\n                  nil\n                  (if   (eq wayout 'gonil)\n                   then `(gonil ,(cadr s))     ; predicative AND\n                   else\n                   if   (null (cdr a))\n                   then                        ; (AND ... x)\n                        (putprop exitlabel t 'forceniltest)\n                        `(goto ,exitlabel)\n                   else\n                   if   (predp xf)             ; (AND .. (foo-p x) y ..)\n                   then `(gonil ,(or setnillabel\n                                     (setq setnillabel (gensym))))\n                   else\n                        `(gonil ,exitlabel)    ; (AND ... x y ...)\n                   endif)\n                  e)\n   endif\n  )\n  (when (setq a (cdr a))\n        (setf (zilcec-tempcond (car e)) t) ; All forms other than first\n        (go loop))                         ; are conditionally executed\n\n  (when setnillabel\n        (modq body `(label ,setnillabel nil nil))\n        (modq body `(setnil nil nil (goto ,exitlabel))))\n  (setf (zilcec-tempcond (car e)) save-tempcond)\n  (return (modq body `(label ,exitlabel ,v ,s)))\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCATOM": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x07\\x00L\\x00L\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:07:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This compiles code to retrieve the value of an (unquoted) atom.\n\n;;; If the variable is self-evaluating, then it is a constant.\n;;; If the variable is a \"keyword\", then it is a constant.\n;;; Else if it is a local variable, then use that.\n;;; Otherwise it is a kind of unbound variable, unless it's a\n;;; keyword, in which case it's self-evaluating.\n\n;;; If it's an unbound variable, it may still be lexically known\n;;; if this is an internal function (funarg).  We must scan the\n;;; lexical environment to see if this is the case.  Note that\n;;; if the variable is SPECIAL, no lexical enclosing is applicable.\n\n; \"b\" is the atom in question.\n; Note that NIL can never be passed to this routine.\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccatom (b v s e &aux a)\n (cond\n  ((and (null v) (null s))                 ; See if atom is not used\n   (modq body `(setnil nil ,v ,s))         ; If not, gen dummy code\n  )\n  ((or (eq b t) (not (symbolp b)))         ; See if self-evaluating\n   (zccconst b v s e)                      ; If it is, get constant\n  )\n  ((eq (pbind b) b)                        ; If it's a keyword (:FOO) or\n                                           ; otherwise self-evaluating\n   (zccconst b v s e)                      ; compile as a constant atom\n  )\n\n  ;\n  ; If variable found in list of local bindings, then compile it as\n  ; a local reference.\n  ;\n  ; Even if the variable is declared SPECIAL, we do it the same way\n  ; at this point.  The code generator will tell if the binding has\n  ; to be SPECIAL.\n  ;\n  ; This does not apply to lexically scoped variables inside a FUNARG.\n  ; Those must be compiled as if they were unbound, but the associated\n  ; bindings are marked... see ZILCOAUV.\n  ;\n\n  ((setq a (assq b (zilcec-bindings (car e)))) ; If a bound variable\n   (modq body `(getlocal ,a ,v ,s))\n   (putprop (cdr a) t 'used)               ; Mark it referenced\n   (unless (get (cdr a) 'set)              ; If not set, force init'n\n           (putprop (cdr a) t 'mustinit))\n  )\n\n  ;\n  ; If not locally bound, generate a kind of \"unbound variable\"\n  ; reference.  It may be a truly lexical one, but it will be\n  ; compiled as an unbound one.  ZILCOAUV handles those details.\n  ;\n\n  (t\n   (let ((a (zilcoauv b e)))               ; Create atom & binding 4 it\n        (modq body `(getvar ,b ,v ,s))     ; Generate pseudocode for it\n        (putprop (cdr a) t 'used)          ; Mark it referenced\n        (putprop (cdr a) t 'mustinit)      ; Force initialization\n   ))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCBIND": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x16/\\x00\\x89\\x15o\\x10\\x08\\x00/\\x00\\x03\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-06-11T00:00:00", "modifydate": "1989-06-05T10:08:00", "lines": 47, "newlines": 3, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCCBIND\"\n;;;\n;;; This takes a binding and makes it SPECIAL, FLUID or whatever.\n;;;\n;;; It also creates an atom for the variable, so code can be\n;;; generated to reference the variable by name.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccbind (x type)\n\n (when debug\n       (cterpri)\n       (princ \"ZCCBIND called to bind \")\n       (prin1 x)\n       (princ \" as \") (prin1 type) (terpri)\n )\n\n (let ((a (zilcoadd (car x) nil)))  ; Make an atom for the variable\n\n  (putprop (cdr x) t 'mustinit) ; If PROG var, must be initialized.\n  (putprop (cdr a) t 'real)   ; Show atom will really be referenced.\n  (putprop (cdr x) (cons type a) 'bindingtype)\n\n ) ; end LET\n\n (when debug\n       (princ \"Bindingtype property: \")\n       (prin1 (get (cdr x) 'bindingtype))\n       (terpri)\n )\n\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCBLOCK": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x88\\x15\\x8f\\x00\\x89\\x15o\\x10\\t\\x00E\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1988-06-06T00:00:00", "modifydate": "1989-06-05T10:09:00", "lines": 69, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This processes BLOCK.                                               *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccblock (b v s e)\n (let (\n       (e (cons (zccmkcec 'block e) e)) ; new environment contour\n       (blkexit (gensym))  ; dummy label to which the BLOCK can refer\n       (blkname)           ; the name of the block\n       (blkbody)           ; the body of the block\n      )\n\n  (cond\n   ((null b)\n    (modq body '(error \"Missing block name\" 'block)))\n   ((progn\n     (setq blkname (car b) blkbody (cdr b))\n     (not (symbolp blkname))\n    )\n    (modq body `(error \"Invalid block name\" ,blkname)))\n   (t\n\n  ; Set the name of the block for this contour.\n\n    (setf (zilcec-block-name (car e)) blkname)\n    (push (cons blkname blkexit) (zilcec-return-tags (car e)))\n\n  ; Set label properties.\n\n    (putprop blkexit v 'vartarg)\n    (putprop blkexit s 'rettarg)\n    (putprop blkexit (car e) 'contour)\n\n  ; Start to generate P-code.\n\n    (modq body `(beginblock ,blkexit ,v ,s))\n\n  ; Compile the body of the BLOCK as an implicit PROGN.\n\n    (zccprogn blkbody nil `(goto ,blkexit) e)\n\n  ; Finish up code generation.\n\n    (modq body `(endblock ,blkexit ,v ,s))\n\n  ; Generate return label code.\n\n    (modq body `(label ,blkexit ,v ,s))\n\n ))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCCALL": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\t\\x00\\x1d\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:09:00", "lines": 29, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This compiles a call to a function, adding to the list of atoms\n; and functions.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n (defun zcccall (f n v s e)\n        (let ((dottedpair (assq f subrs)))   ; Find F if it is in list\n          (unless dottedpair                 ; If so, return that subr\n           (setq dottedpair                  ; Else create a new subr\n                 (zilcosym f 'subrs))        ; Add pair to symbol table\n           (or (eq (car name) f)             ; If not a recursive call\n               (modq subrs dottedpair)))     ; then add it to the list\n\n          `(call ,dottedpair ,n ,v ,s)))     ; Generate code to call it\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCCCATCH": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x10\\x00g\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:10:00", "lines": 103, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles the \"CATCH\" function inline.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/06/88 - Support for GO tag optimization.                         *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;* 11/01/88 - Bug fix for tags that never return.                      *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcccatch (b v s e)\n (prog (tag                  ; Arg 1 to CATCH = a tag (should be atom)\n        forms                ; Arg 2 to CATCH = form to be evaluated\n        label1               ; a label to be used by the generated code\n        label2               ; a label to be used by the generated code\n       )\n\n;;; Syntax check and set locals.\n\n  (or b       (return (modq body '(error \"Missing tag\" catch))))\n  (or (cdr b) (return (modq body '(error \"Missing body\" catch))))\n\n  (desetq (tag . forms) b)\n\n;;; Create a CATCH/THROW label.\n\n  (setq label1 (gensym))\n  (putprop label1 v 'vartarg)     ; Establish SETQ target.\n  (putprop label1 s 'rettarg)     ; Establish returned-value target.\n  (putprop label1 t 'catch)       ; Identify it as a CATCH/THROW label.\n  (putprop label1 '\\15 'register) ; THROW will return value in reg 15.\n\n  (setq label2 (gensym))\n\n;;; Generate P-code.\n\n; 11/01/88 bug fix...\n\n;;(zccevcom tag nil `(catch ,label1)e);Evaluate tag, build catch frame.\n  (zccevcom tag nil `(goto ,label2) e)             ; Evaluate tag.\n  (modq body `(label ,label2 nil (catch ,label1))) ; Build catch frame.\n  (putprop label2 t 'referenced)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Put a contour around the forms to be evaluated within the CATCH\n; ONLY if there's some need to do so.  Since you can't have\n; declarations in a CATCH, no contour would normally be required,\n; BUT it is needed in order to control optimization of GO's.\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (let ((e (cons (zccmkcec 'catch e) e)))\n\n   ; Forms within a CATCH are considered conditional because a THROW\n   ; may occur at any point, causing execution to continue beyond the\n   ; scope of the CATCH without any of the code inside being executed.\n\n   (setf (zilcec-permcond (car e)) t)\n\n   (zccprogn forms nil `(goto ,label1) e)\n                                    ; Evaluate forms with\n                                    ; implicit branch to label\n                                    ; (the GOTO will be removed anyhow)\n\n  ) ; end contour\n\n\n  (modq body `(label ,label1 ,v ,s));Generate label for THROW to go to.\n\n;;; The CATCH property on the label will tell the code generator\n;;; to emit code to unstack the catch frame.\n\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCCOND": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x10\\x015\\x00N\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:10:00", "lines": 309, "newlines": 78, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles the \"COND\" function inline.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/06/88 - Support for GO tag optimization.                         *\n;* 04/12/88 - Miscellaneous optimizations.                             *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;* 05/02/88 - Now that ZCGSTTRG has been upgraded to handle GONIL and  *\n;*            GONOTNIL to GO tags et al., ZCCCOND no longer has to     *\n;*            check the contour structure to see if a (COND ... GO) or *\n;*            (COND ... RETURN) optimization is valid.  However, it    *\n;*            must check for MEMQ, since MEMQ is weird.                *\n;* 06/07/88 - Support for BLOCK and TAGBODY.                           *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcccond (b v s e)\n (prog (a branchlabel exitlabel f1 f2 tconstant valuep\n        save-tempcond f1pred)\n  (setq a b)\n  (setq exitlabel (gensym))\n  (putprop exitlabel v 'vartarg)\n  (putprop exitlabel s 'rettarg)\n  (putprop exitlabel t 'forceniltest)\n  (setq valuep (or v (not (zilcovta s))))\n  (setq save-tempcond (zilcec-tempcond (car e)))\n loop\n  (when (null a) ; No more COND clauses...\n        (setf (zilcec-tempcond (car e)) save-tempcond)\n         ;\n         ; Generate a value of NIL only if a value is required\n         ; (it is SETQ'd or the COND is being evaluated for a value)\n         ;\n        (and valuep (modq body `(setnil nil nil (goto ,exitlabel))))\n        (modq body `(label ,exitlabel ,v ,s))\n        (return nil))\n\n  ; Create a new branching label.\n  ; F1 is the IF-clause.\n  ; F2 is the list of THEN-clauses.\n\n  (setq branchlabel (if (or (cdr a) valuep) (gensym) exitlabel))\n\n  (desetq (f1 . f2) (car a))\n  (setq tconstant\n        (or (eq f1 t)                  ; T is a true constant.\n            (if (atom f1)\n             then (not (symbolp f1))   ; Number, string, etc.\n             else (and (eq (car f1) 'quote)\n                       (consp (cdr f1))\n                       (cadr f1)))))   ; (QUOTE anything-except-NIL)\n\n  (cond\n   ;\n   ; If no THEN-clause, return value of IF-clause.\n   ;\n   ((null f2)\n    (zccevcom f1 nil `(gonotnil ,exitlabel) e))\n   ;\n   ; If there is exactly one THEN-clause, a number of optimizations\n   ; are possible.  Try them.\n   ;\n   ((progn (setq f1pred (if tconstant t (zccpred f1)))\n           (and (not tconstant)\n                (null (cdr f2))\n                (not (zcccond-weirdp f1pred)))\n    )\n    (zcccond-maybe-optimize f1pred (car f2)\n                            branchlabel exitlabel a v s e))\n   (t\n   ;\n   ; Otherwise, do normal compilation of multiple THEN clauses.\n   ;\n    (zcccond-punt f1pred f2 branchlabel exitlabel a v s e)))\n\n (when tconstant\n       (setf (zilcec-tempcond (car e)) save-tempcond)\n       (return (modq body `(label ,exitlabel ,v ,s))))\n\n (if (eq branchlabel exitlabel)\n  ;then\n     (when (and (null v) (null s))\n           (remprop exitlabel 'forceniltest))\n  ;else\n     (modq body `(label ,branchlabel nil nil))\n )\n (setq a (cdr a))\n (setf (zilcec-tempcond (car e)) t) ; All if-clauses other than first\n (go loop)))                        ; are conditionally executed\n\n\n(defun zcccond-maybe-optimize (s1 s2 branchlabel exitlabel a v s e\n                              &aux weirdp p tag progexit retval blkname)\n ;\n ; (COND ... (s1 s2) ...), where s1 has already been processed by\n ;                         ZCCPRED to remove nested NULL/NOT.\n ;\n (setq weirdp (zcccond-weirdp s1))\n (cond\n  ;\n  ; Optimize (COND ... (something (GO tag)) ...) with a\n  ; conditional branch to the GO tag rather than a conditional\n  ; branch around code that would go to the GO tag.\n  ;\n  ; Don't do it for ((AND ...) (GO ...)) - it generates worse code.\n  ;\n  ; Also don't do it if the IF-clause is \"weird\".\n  ; \"Weird\" in this context usually means a call to MEMQ, since\n  ; MEMQ has strange code generation.\n  ;\n  ((and (not weirdp)\n        (eq-car s2 'go)\n        (not (eq-car s1 'and))\n   )\n   (setq p (zccvalgo (cdr s2) e))  ; Get the GO tag pair\n   (setq tag (cdr p))              ; Get the tag\n   (if (notp s1)\n       (zccevcom (cadr s1) nil (if p `(gonil    ,tag)) e)\n       (zccevcom s1        nil (if p `(gonotnil ,tag)) e))\n   ;\n   ; Since we just ate a GO, we must do the same processing as is done\n   ; when a GO is seen.  All contours up to AND INCLUDING the contour\n   ; associated with the GO tag are marked permanently conditional.\n   ;\n   (zcccond-mark-perm-uncond tag e)\n  )\n  ;\n  ; Optimize (COND ... ((NULL form) NIL) ...)\n  ;        {same as ... ((NOT form) NIL) ...}\n  ;\n  ; Don't do it if form is a predicate, e.g. ((NOT (ATOM X)) NIL).\n  ;\n  ; Also don't do it if the IF-clause is \"weird\".\n  ; \"Weird\" in this context usually means a call to MEMQ, since\n  ; MEMQ has strange code generation.\n  ;\n  ((and (not weirdp)\n        (notp s1)\n        (eq s2 'nil)\n        (not (predp (cadr s1)))\n   )\n   (zccevcom (cadr s1) nil `(gonil ,exitlabel) e))\n  ;\n  ; Optimize (COND ... (variable variable) ...)\n  ;       or (COND ... ((SETQ ... variable form) variable) ...)\n  ;\n  ((symbolp s2)\n   (zcccond-optimize-variable-reference s1 s2 exitlabel nil\n                                  s1 s2 branchlabel exitlabel a v s e))\n  ;\n  ; If s2 is (RETURN-FROM blockname {something}),\n  ; try some more optimizations.\n  ;\n  ((and (eq-car s2 'return-from)\n        (cdr s2)            ; Skip if (RETURN-FROM) - syntax error\n        (null (cdddr s2))   ; Skip unless (RETURN-FROM blockname {x})\n        (progn\n         (setq blkname (cadr s2))\n         (setq retval (caddr s2))\n         (setq progexit (cdr (assq blkname\n                                   (zilcec-return-tags (car e)))))))\n   (cond\n    ;\n    ; Optimize (COND ... ((NULL form) (RETURN-FROM somewhere NIL)) ...)\n    ;        {same as ... ((NOT form) (RETURN-FROM somewhere NIL)) ...}\n    ;\n    ; Note that (RETURN-FROM x) and (RETURN-FROM x NIL) both work here.\n    ;\n    ; Don't do it if form is a predicate,\n    ; e.g. ((NOT (ATOM X)) (RETURN-FROM FOO NIL)).\n    ;\n    ; Also don't do it if the IF-clause is \"weird\".\n    ; \"Weird\" in this context usually means a call to MEMQ, since\n    ; MEMQ has strange code generation.\n    ;\n    ((and (not weirdp)\n          (notp s1)\n          (eq retval 'nil)\n          (not (predp (cadr s1)))\n     )\n     (zccevcom (cadr s1) nil `(gonil ,progexit) e)\n     ;\n     ; Since we just ate a RETURN-FROM, we must do the same processing\n     ; as is done when a RETURN-FROM is seen.  All contours up to AND\n     ; INCLUDING the contour associated with the RETURN-FROM are marked\n     ; permanently conditional.\n     ;\n     (zcccond-mark-perm-uncond progexit e)\n    )\n    ;\n    ; Optimize (COND ... (variable (RETURN-FROM somewhere variable))...)\n    ;       or (COND ...((SETQ ... variable form)\n    ;                    (RETURN-FROM somewhere variable))...)\n    ;\n    ((symbolp retval)\n     (zcccond-optimize-variable-reference s1 retval progexit t\n                                  s1 s2 branchlabel exitlabel a v s e))\n    ;\n    ; No special optimizations possible - generate normal code.\n    ;\n    (t\n     (zcccond-punt s1 `(,s2) branchlabel exitlabel a v s e))))\n  ;\n  ; No special optimizations possible - generate normal code.\n  ;\n  (t\n   (zcccond-punt s1 `(,s2) branchlabel exitlabel a v s e))))\n\n(defun zcccond-optimize-variable-reference (form var label returnp\n                                  s1 s2 branchlabel exitlabel a v s e\n                                        &aux l)\n (cond\n  ;\n  ; Must be (COND ... (variable ...) ...)\n  ;      or (COND ... ((SETQ ... variable form) ...) ...)\n  ;\n  ((or (eq form var)\n       (and (eq-car form 'setq)\n            (evenp (setq l (length (cdr form))))\n            (not (zerop l))\n            (eq (nth (- l 2) (cdr form)) var)))\n   (zccevcom form nil `(gonotnil ,label) e)\n   ;\n   ; If we just ate a RETURN-FROM, we must do the same processing as is\n   ; done when a RETURN-FROM is seen.  All contours up to AND INCLUDING\n   ; the contour associated with the RETURN-FROM are marked permanently\n   ; conditional.\n   ;\n   (when returnp\n        (zcccond-mark-perm-uncond label e))\n  )\n  ;\n  ; No special optimizations possible - generate normal code.\n  ;\n  (t\n   (zcccond-punt s1 `(,s2) branchlabel exitlabel a v s e))))\n\n(defun zcccond-punt (s1 f2 branchlabel exitlabel a v s e)\n ;\n ; If the first form in the \"pair\" is a constant like \"T\", skip\n ; compilation of the first form.  Otherwise, compile first form\n ; in the \"pair\" with target of predicate only.\n ;\n (unless (eq s1 t) ; true if set by ZCCCOND from TCONSTANT only\n  (if (notp s1)\n      (zccevcom (cadr s1) nil `(gonotnil ,branchlabel) e)\n      (zccevcom s1        nil `(gonil    ,branchlabel) e)))\n ;\n ; If multiple THEN-clauses, compile them as an implicit PROGN.\n ;\n ; Note that all THEN-clauses, as well as any subsequent IF-clauses,\n ; are conditionally executed.\n ;\n (setf (zilcec-tempcond (car e)) t)\n (zccprogn f2 nil (if (or v s (cdr a)) `(goto ,exitlabel) nil) e))\n\n(defun zcccond-mark-perm-uncond (tag e)\n ;\n ; When we just ate a GO or RETURN-FROM, we must do the same processing\n ; as is done when a GO or RETURN-FROM is seen.  All contours up to AND\n ; INCLUDING the contour associated with the GO or RETURN-FROM are\n ; marked permanently conditional.\n ;\n (loop with c = (get tag 'contour)\n       for cec in e\n       do (setf (zilcec-permcond cec) t)\n       until (eq cec c)                    ; Note placement of UNTIL!!!\n )\n)\n\n(defun zcccond-weirdp (x)\n (and (consp x)\n      (or (eq (car x) 'memq)\n          (and (memq (car x) '(not null))\n               (zcccond-weirdp (cadr x))))))\n\n(defmacro eq-car (x y)\n (if (symbolp x)\n     `(and (consp ,x) (eq (zcar ,x) ,y))\n     (zerror \"I want arg 1 to EQ-CAR to be a variable, OK?\")))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCCONST": {"ttr": 3598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x10\\x00/\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:10:00", "lines": 47, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This compiles code to load constant atomic or list values.\n;\n; If A is NIL or T, handle that case.\n; If A is a \"small fixnum\", handle that case.\n; If A is an atom (other than one of the above)...\n;  if A is not in the atom list, add A to the list of atoms.\n; If A is a list...\n;  if A is not in the list list, add A to the list of lists.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccconst (a v s e) ; A is the atom, V the variable, S the target,\n                          ; E the environment\n (modq body\n  (cond\n   ((and (null v) (null s)) ; Nothing to SETQ, no use for value...\n    `(setnil nil ,v ,s))  ; Code generator will neutralize this anyhow.\n   ((null a)         `(setnil nil ,v ,s))\n   ((eq a t)         `(sett t ,v ,s))\n   ((and (fixnump a)\n         (>= a -1)\n         (<= a 255))\n                     `(setsmall ,a ,v ,s))\n   ((or (symbolp a)\n        (numberp a)\n        (stringp a)) `(setatom ,(let ((q (zilcoadd a nil)))\n                                         (putprop (cdr q) t 'real)\n                                       q) ,v ,s))\n   ((consp a)        `(setlist ,(zilcoadd a t) ,v ,s))\n   (t                `(error \"Cannot compile object of this type\" ,a))\n  )\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCDCL": {"ttr": 3600, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x10\\x00y\\x00G\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:10:00", "lines": 121, "newlines": 71, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This functions handles the DECLARE special form, when it occurs     *\n;* within a function (not at top-level).                               *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccdcl (b    ;  the (headless) body of the DECLARE form\n               v    ;  any variables to be SETQ'd by the form (illegal)\n               s    ;  the target of the value (must be NIL)\n               e    ;  the environment\n              )\n\n;\n; All non-top-level declarations are handled by ZCCLAMA\n; (and ZCCPROG) when they process bodies\n; that are supposed to contain them.\n;\n; If a DECLARE occurs elsewhere, it is an error.\n;\n\n (modq body `(error\n              \"DECLARE positioned illegally within form\" ,b))\n\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; The following piece of code is the old ZIL 1.2 non-top-level-declare\n; processor.  I am keeping it around so it can be scavenged for\n; useful processing.\n;\n;\n;(defun zccdcl-process (a e)  ; a is a subform within the DECLARE,\n;                             ; e.g. (SPECIAL FOO BAR)\n; (cond\n;  ((null a) nil)\n;  ((atom a) (modq body `(error \"Illegal DECLARE subform\" ,a)))\n;  (t (case (car a)\n;           ((special fluid)\n;                       (dolist (x (cdr a))\n;                               (zccdcl-process-vardecl x (car a) e)))\n;           (t          (cterpri)\n;                       (princ \"DECLARE (\") (prin1 (car a))\n;                       (princ \") not handled by the ZIL compiler.\")\n;                       (terpri)\n;                       nil)))))\n;\n;(defun zccdcl-process-vardecl (a d e) ; process symbol declaration\n; ;\n; ; The only variable declarations recognized are SPECIAL and FLUID.\n; ;\n; ; SPECIAL means the variable is a Common LISP dynamically scoped\n; ; variable, which does not get captured by closures.  A SPECIAL\n; ; variable may be unbound in a function that references it, which\n; ; is not an error unless an attempt is made to access its value.\n; ;\n; ; FLUID means the variable is \"pseudolexical\"; it may be dynamically\n; ; scoped in reality, but it is intended to emulate Common LISP\n; ; lexical scoping, and gets captured by closures.  It is an error\n; ; for a FLUID variable to be unbound ON ENTRY to a function that\n; ; references it (either for access or update).\n; ;\n; (cond\n;  ((not (symbolp a))\n;   (modq body `(error \"Invalid DECLARE SPECIAL/FLUID variable\" ,a)))\n;  (t\n;   ;\n;   ; Eventually, replace with search of contours in \"e\" for variable.\n;   ;\n;   (let ((p (or (assq a palist) (assq a parms)))\n;         (q))\n;    (cond\n;     (p\n;\n;        (setq q (zilcoadd a nil));Add the variable to the list of atoms.\n;        (putprop (cdr q) t 'real) ; We know it'll be really used.\n;\n;        ; This being a locally-declared-special variable,\n;        ; we do NOT add it to either \"freevars\" list.\n;\n;        ; Mark the function as having special/fluid variables\n;        ; declared - ZCGBEGIN uses this minimal information.\n;\n;        (putprop (cdr name) t 'specialdeclare) ; Mark this function.\n;\n;        ; Trying to declare (SPECIAL FOO) when FOO has already been\n;        ; declared FLUID (or vice versa) is an error.\n;\n;        (when (get (cdr p) (if (eq d 'special) 'fluid 'special))\n;              (modq body\n;                `(error \"Conflicting SPECIAL/FLUID declarations\" ,a)))\n;\n;        (putprop (cdr p) t d)) ; Mark this occurrence special or fluid.\n;\n;     (t (cterpri)\n;        (princ \"DECLARE \")\n;        (princ d)\n;        (princ \" variable \")\n;        (prin1 a)\n;        (princ \" not locally bound; declaration ignored.\")\n;        (terpri)\n;        nil))))))\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCDEF": {"ttr": 3602, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x11\\x006\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:11:00", "lines": 54, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCCDEF\"\n;;;\n;;; This routine compiles (#.ZDEF foo) things.\n;;;\n;;; Note that the function name is a unique object which is the\n;;; value of the global compiler variable ZDEF.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccdef (b v s e) ;\n (prog (fsym fsub)\n  (or b (go error1))\n  (and (cdr b) (go error1))\n  (setq fsym (car b))       ; Function name.\n  (unless (and fsym (symbolp fsym)) (go error2))\n\n  (zccevcom `',fsym nil `(arg (1 ,zdef)) e)\n\n  (setq fsub (assq fsym subrs))\n  (unless fsub\n   (setq fsub (zilcosym fsym 'subrs))\n   (modq subrs fsub)\n  )\n\n  (unless (assq 'zilxdef subrs)\n   (modq subrs (zilcosym 'zilxdef 'subrs)))\n\n  (modq body `(def ,fsub ,v ,s))\n  (return)\n\nerror1\n   (modq body '(error \"Invalid syntax\" |#.ZDEF|))\n   (return)\nerror2\n   (modq body `(error \"Invalid function name\" ,fsym))\n   (return)\n\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCEVAL": {"ttr": 3604, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x11\\x01t\\x01a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:11:00", "lines": 372, "newlines": 353, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This function compiles function calls.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;\n; Set up so that the compiler knows what's really inline even though\n; the user may have declared something inline or notinline.  E.G.\n;\n; (defload floating-point-p floatp)\n; (declare (notinline floating-point-p))\n;\n; means that floatp has the BUILTIN property\n; but floating-point-p has the NOTINLINE property.\n;\n; (declare (notinline floatp))\n;\n; has no effect on floating-point-p.\n;\n; Note:  The above isn't implemented yet....\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcceval (func args v s e)\n (prog (a c n tail-recursive inline minargs maxargs restarg lexprarg)\n  (cond\n   ((symbolp func)\n          (setq a args\n                c (let ((x (get func 'cautoload)))\n                        (if (symbolp x) x nil))\n                n (length args)\n                ;\n                ; Eventually, the setting of \"inline-ness\" will be done\n                ; by retrieving it from the current contour.  Then,\n                ; (declare (notinline ...)) will work.\n                ;\n                inline (and (get (or c func) 'builtin)\n                            (get func 'inline))\n                tail-recursive (and (eq func (car name))\n                                    (null v)\n                                    (eq (ultimate-target s e) t)))\n\n;\n; If the function has a CAUTOLOAD property (via DEFLOAD), then\n; use the CAUTOLOAD name's defaults.  If these aren't defined,\n; or if there's no CAUTOLOAD property, then use the function's\n; own defaults.  If these don't exist, then punt.\n;\n          (setq minargs  (or (if c (get c 'minargs))\n                             (get func 'minargs)))\n          (setq maxargs  (or (if c (get c 'maxargs))\n                             (get func 'maxargs)))\n          (setq restarg  (or (if c (get c 'restarg))\n                             (get func 'restarg)))\n          (setq lexprarg (or (if c (get c 'lexprarg))\n                             (get func 'lexprarg)))\n\n          (if lexprarg (setq tail-recursive nil)) ; Can't optimize it!\n\n          (if minargs\n           then\n            (if (< n minargs)\n             then\n              (modq body\n                  `(error \"Too few arguments passed to function\" ,func))\n             else\n             if (and (null restarg) (null lexprarg) (> n maxargs))\n             then\n              (modq body\n                 `(error \"Too many arguments passed to function\" ,func))\n             endif\n            )\n           else\n           if (get '*zilco* 'autofuncall)\n           then\n             (unless (get func 'funcalled)\n              (princ \" Function \\\"\")\n              (prin1 func)\n              (princ \"\\\" unknown.  Will be invoked via FUNCALL.\")\n              (terpri)\n              (putprop func t 'funcalled))\n             (return (zccevcom `(funcall ',func . ,args) v s e))\n           else\n             (princ \" Undeclared function name \\\"\")\n             (prin1 func)\n             (princ \"\\\". Assumed to be a SUBR with \")\n             (princ n)\n             (princ (if (eql n 1) \" argument.\" \" arguments.\"))\n             (terpri)\n             (setq maxargs n)\n             (putprop func n 'minargs)  ; Set minimum number of args.\n             (putprop func n 'maxargs)  ; Set maximum number of args.\n             (remprop func 'restarg)    ; Set no &REST arg.\n           endif\n          )\n\n;\n; If this is an inline call because the CAUTOLOAD property is an\n; inline function, then set the function name to the inline name.\n;\n          (and inline c (setq func c))\n\n          (modq body `(,(cond\n                         (tail-recursive 'begintail)\n                         (inline         'begininline)\n                         (t              'begincall)) ,func ,n ,v ,s))\n\n;\n; Generate code to evaluate the arguments to the function.\n;\n          (zcceval-pass-args a nil minargs maxargs restarg lexprarg e)\n;\n; Generate code to invoke the function.\n;\n          (modq body\n           (cond\n            (tail-recursive (compile-tailrecur)); See macro definition.\n            (inline         `(inline ,func ,n ,v ,s))\n            (t              (zcccall func n v s e)))))\n\n  ((atom func) ; If function is not a symbol...\n   (modq body `(error \"Function name not a symbol\" ,func)))\n\n  ((eq (car func) 'lambda)\n\n  ;--- do lambda stuff - get attributes of lambda expression ---\n\n   (if (null (cdr func))\n    then\n       (modq body `(error \"Missing arglist in LAMBDA expression\"\n                          (,func . ,args)))\n    else\n    if (not (listp (cadr func)))  ; If the arg list is non-NIL atom\n    then                          ; it's a LEXPR-style LAMBDA expr.\n                                  ; in which case we have no choice\n                                  ; but to compile it like a\n                                  ; separate function\n       (zcceval (zcclamb func t e) args v s e)\n    else\n       (zcceval-call-lambda func args v s e)\n   endif\n  ))\n\n  (t\n   (modq body `(error \"Function name not a symbol\" ,func)))\n   )))\n\n;\n; This generates code to perform tail recursion.\n; The local variables known at the time of the tail recursion must\n; be saved in pseudoglobal TAILRECUR so that the code generator can\n; determine if special variable bindings are to be maintained over\n; the tail-recursive branch-back.\n;\n; This subroutine has been implemented as a macro to save stack usage\n; in the compiler.\n;\n\n(defmacro compile-tailrecur ()\n '(loop for p in (zilcec-bindings (car e)) ; Add local vars to list\n    do (push p tailrecur)              ; of tail-recursive variables.\n    finally                            ; Update list, then emit P-code.\n      (return `(tailrecur ,func ,n ,v ,s))))\n\n(defun zcceval-call-lambda (func args v s e)\n (let* (\n        (n (length args))\n        ((lambda-args . lambda-body) (cdr func))\n        (temp-lambda-name     (gensym))\n        (temp-lambda-valid-p  (zilcoarg temp-lambda-name lambda-args))\n        (temp-lambda-parms    (get temp-lambda-name 'parms))\n        (temp-lambda-minargs  (get temp-lambda-name 'minargs))\n        (temp-lambda-maxargs  (get temp-lambda-name 'maxargs))\n        (temp-lambda-restarg  (get temp-lambda-name 'restarg))\n        (temp-lambda-lexprarg (get temp-lambda-name 'lexprarg))\n        (lambda-exitlabel     (gensym))\n        (e                    (cons (zccmkcec 'lambda e) e))\n       )\n\n       (putprop lambda-exitlabel v 'vartarg)\n       (putprop lambda-exitlabel s 'rettarg)\n\n       (if temp-lambda-valid-p\n        then\n         ; ... do stuff for a valid lambda-expression ...\n         (if (< n temp-lambda-minargs)\n          then\n             (modq body\n               `(error \"Too few arguments passed to LAMBDA-expression\"\n                       ((lambda ,lambda-args etc.) . ,args)))\n          else\n          if (and (null temp-lambda-restarg)\n                  (null temp-lambda-lexprarg)\n                  (> n temp-lambda-maxargs))\n          then\n             (modq body\n              `(error \"Too many arguments passed to LAMBDA-expression\"\n                       ((lambda ,lambda-args etc.) . ,args)))\n          endif\n         )\n\n;\n; Start up a call sequence.\n;\n        (modq body `(begincall ,func ,n ,v ,s))\n;\n; Generate code to evaluate the arguments to the function.\n; Note that the environment is the one outside the lambda's env.\n;\n        (zcceval-pass-args args\n                           temp-lambda-parms\n                           temp-lambda-minargs\n                           temp-lambda-maxargs\n                           temp-lambda-restarg\n                           temp-lambda-lexprarg\n                           (cdr e))\n;\n; Generate code to invoke the LAMBDA code inline.\n;\n\n;;;;\n;;;; We are not suppressing GO/RETURN stuff any more, because now the\n;;;; compiler can handle it.\n;;;;\n\n         (modq body `(beginlam ,temp-lambda-name\n                               ,temp-lambda-parms ,v ,s))\n\n;\n; Identify args as belonging to the current function.\n;\n\n         (dolist (x temp-lambda-parms)\n                 (putprop (cdr x) name 'owner))\n\n;\n; Generate code to initialize and bind all args, including\n; &optional, &aux, and supplied-p arguments.\n;\n\n         (setq lambda-body\n          (zcclama temp-lambda-name lambda-exitlabel lambda-body e))\n\n         ; Evaluate the body of the lambda.\n\n         (zccprogn lambda-body nil `(goto ,lambda-exitlabel) e)\n\n         (modq body `(endlam ,lambda-exitlabel\n                             ,temp-lambda-parms ,v ,s))\n\n         (modq body `(label    ,lambda-exitlabel ,v ,s))\n\n        else\n\n         (princ \"Warning: Uncompilable LAMBDA-expression arglist: \")\n         (print lambda-args)\n         (princ \"Converting to FUNCALL of interpretive LAMBDA list.\")\n         (terpri)\n         ;\n         ; Note use of outer environment...\n         ;\n         (zccevcom `(funcall ',func . ,args) v s (cdr e))\n\n        endif\n\n       ) ; end if temp-lambda-valid-p\n\n ) ; end LET*\n)\n\n(defun zcceval-pass-args (a lparms minargs maxargs restarg lexprarg e)\n\n ;\n ; Generate code to evaluate the arguments to the function.\n ;\n ; If the function we're calling has &OPTIONAL arguments\n ; (i.e. MAXARGS > MINARGS), pass in the arguments until\n ; we run out of arguments, and then pass in the \"not-supplied\"\n ; indicator for each omitted argument.\n ;\n ; If the function we're calling has a &REST argument,\n ; take the remaining arguments, CONS up a list out of\n ; them, and pass the list as the final argument.\n ;\n ; If the function we're calling is a LEXPR,\n ; make a fixnum out of the one arg, making it arg 1,\n ; and pass the other args on the stack following it.\n ;\n\n (if   lexprarg\n  then\n       (zccatom (length a) nil '(arg 1) e)\n       (loop for i from 2\n             for x in a\n             do (zccevcom x nil `(arg ,i) e)\n       )\n  else\n       (loop for i from 1 to maxargs\n             do\n               (cond\n                ((null a)\n                 (modq body `(setopt nil nil (arg ,i))))\n                (t\n                 (cond\n                  ((and lparms (null (car a)))\n                   (let ((pair (car lparms)))\n                        (remprop (cdr pair) 'set)\n                        (remprop (cdr pair) 'used)\n                        (remprop (cdr pair) 'mustinit)\n                        (modq body `(csetnil ,pair nil (arg ,i)))))\n                  (t\n                   (zccevcom (car a) nil `(arg ,i) e)))\n                 (setq lparms (cdr lparms))\n                 (setq a (cdr a))))\n             finally\n               (if restarg\n                   (zccevcom (zilcotrn `(list . ,a) debug)\n                             nil `(arg ,i) e))\n       )\n  endif\n )\n)\n\n;\n; This determines whether the ultimate target of a form to be compiled\n; is the final return value (or some other thing).  Used to determine\n; if tail recursion is valid.\n;\n\n; Somehow, contours will be interrogated eventually here.\n\n(defun ultimate-target (s e) ; The ultimate value target of a target\n (if (and (eq (car s) 'goto)               ; If unconditional GOTO\n          (null (get (cadr s) 'vartarg))   ; and there's no SETQ or\n          (null (get (cadr s) 'popsalist)) ; special-alist restor'n or\n          (null (get (cadr s) 'popfalist)) ; fluid-alist restoration or\n          (null (get (cadr s) 'catch))     ; catch frame to worry about\n       )                                   ; then you can go right thru\n  then\n       (ultimate-target (get (cadr s) 'rettarg) e)\n  else s\n endif))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCEVCOM": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x88\\x08/\\x00\\x89\\x15o\\x10\\x12\\x00\\xc6\\x00\\xb2\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1988-03-22T00:00:00", "modifydate": "1989-06-05T10:12:00", "lines": 198, "newlines": 178, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"COMPILE-EVAL\"\n;;;\n\n;;; This workhorse compiles any form.  It outputs chunks of pseudocode.\n;;; At the highest level, this is sandwiched between two layers of\n;;;  prologue and epilogue code (see COMPILE-BODY).\n;;; The first operand is the form to be evaluated - er, compiled.\n;;; The second operand is a variable (either argument or local)\n;;;  in which the result is to be placed (e.g. for a SETQ).\n;;; The third operand is a \"target\" to which the result of the\n;;;  evaluated code is to be assigned (typically an argument spec as\n;;;  input to another function).\n\n;;; If the form is a macro call, then it should not appear, since all\n;;; macros should have been expanded in the transformation stage.\n;;; Note - a \"CMACRO\" is a macro definition known only to the compiler.\n\n;;; If (CAR form) is a LAMBDA-expression, then...\n;;; Give the LAMBDA-function a name,\n;;; compile it and put it on the list of internal procedures.\n;;; Then evaluate the form using the newly created LAMBDA-function.\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/22/88 - Support for inline ASSQ and MEMQ.                        *\n;* 06/06/88 - Support for VALUES and new special forms.                *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defmacro comma      () ''|,| )\n(defmacro comma-at   () ''|,@|)\n(defmacro comma-dot  () ''|,.|)\n\n(defmacro zccclos (b v s e)\n `(zccfarg 'closure ,b ,v ,s ,e))\n\n(defmacro zccsubr (b v s e)\n `(zccfarg 'subr ,b ,v ,s ,e))\n\n(defun zccevcom (b v s e &aux p carb)\n (cond\n     ;\n     ; If form is NIL, compile a reference to NIL.\n     ;\n      ((null b)                   (modq body `(setnil nil ,v ,s)))\n     ;\n     ; If form is an atom, compile a reference to the value of the atom\n     ;\n      ((atom b)                   (zccatom b v s e))\n     ;\n     ; Otherwise, check if form is a special object inserted by the\n     ; compiler.  If it the unique object ZDEF, it's an internally\n     ; optimized non-lexical DEFUN.\n     ;\n      ((progn (setq carb (car b))\n              (eq carb zdef)\n       )                          (zccdef   (cdr b) v s e))\n\n     ;\n     ; Otherwise, assume form is a list.  Determine what kind of\n     ; function.  If function name is not an atom, assume it is a\n     ; LAMBDA-expression and compile accordingly\n     ; (ZCCFUNC'll flag it as an error if it's not a LAMBDA-expression).\n     ;\n      ((not (symbolp carb))       (zccevcom-maybe-lambda b v s e))\n     ;\n     ; If function is a macro, compile the macro expansion.\n     ;\n      ((and (or (get carb 'macro)\n                (get carb 'cmacro))\n            (not (get carb 'cexpr))\n       )                          (zccevcom (zilcomex b nil) v s e))\n      ;\n      ; If the function is not defined by the ZIL system, or if it\n      ; was defined but the definition was overridden, compile as\n      ; a function call.\n      ;\n      ((neq (get carb 'defined-by) 'system)\n                                  (zcceval carb (cdr b) v s e))\n     ;\n     ; Check for all special forms.\n     ;\n      ((eq carb 'quote)           (zccquote (cdr b) v s e))\n      ((eq carb 'cond)            (zcccond  (cdr b) v s e))\n      ((eq carb 'progn)           (zccprogn (cdr b) v s e))\n      ((eq carb 'block)           (zccblock (cdr b) v s e))\n      ((eq carb 'return-from)     (zccretf  (cdr b)     e))\n      ((eq carb 'tagbody)         (zcctbody (cdr b) v s e))\n      ((eq carb 'go)              (zccgo    (cdr b)     e))\n      ((eq carb 'setq)            (zccsetq  (cdr b) v s e))\n      ((eq carb 'and)             (zccand   (cdr b) v s e))\n      ((eq carb 'or)              (zccor    (cdr b) v s e))\n      ((eq carb 'not)             (zccnot   (cdr b) v s e))\n      ((eq carb 'null)            (zccnot   (cdr b) v s e))\n      ((eq carb 'catch)           (zcccatch (cdr b) v s e))\n      ((eq carb 'throw)           (zccthrow (cdr b) v s e))\n      ((eq carb 'unwind-protect)  (zccuwp   (cdr b) v s e))\n      ((eq carb 'function)        (zccclos  (cdr b) v s e))\n      ((eq carb 'subr)            (zccsubr  (cdr b) v s e))\n      ((eq carb 'declare)         (zccdcl   (cdr b) v s e))\n      ((eq carb 'multiple-value-list)\n                                  (zccmvlst (cdr b) v s e))\n      ((eq carb 'multiple-value-bind)\n                                  (zccmvbnd (cdr b) v s e))\n\n      ((eq carb 'funcall)         (zccfcall (cdr b) v s e))\n\n      ((eq carb 'values )         (zccvals  (cdr b) v s e))\n\n      ((or (eq carb 'arg)\n           (eq carb 'setarg)\n           (eq carb 'listify))    (zcclexfn carb (cdr b) v s e))\n\n      ((or (eq carb 'eq)\n           (eq carb 'eql)\n           (eq carb 'cons)\n           (eq carb 'rplaca)\n           (eq carb 'rplacd)\n           (eq carb 'assq)\n           (eq carb 'memq)\n           (eq carb 'vref)\n           (eq carb 'vset))       (zccfast  carb (cdr b) v s e))\n\n      ((or (eq carb (comma))\n           (eq carb (comma-at))\n           (eq carb (comma-dot)))\n       (zerror \"Syntax error - comma not inside backquote\"))\n\n      ((or (eq carb 'defun)\n           (eq carb 'defload)\n           (eq carb 'defvar)\n           (eq carb 'eval-when))\n       (modq body\n     `(error \"Form cannot be compiled, valid only at top level\" ,carb)))\n     ;\n     ; Otherwise, compile as a function call.\n     ;\n      (t                          (zcceval carb (cdr b) v s e))\n  ))\n\n;\n; This function compiles a form whose CAR is not a symbol.\n; The CAR of the form may be a LAMBDA- or LABEL-expression;\n; otherwise it is not compilable.\n;\n\n(defun zccevcom-maybe-lambda (b v s e)\n\n ; This is what ZILCO used to do all the time with these things.\n ; (zcceval (zcclamb (car b) e) (cdr b) v s e)\n ; It would call ZCCLAMB to turn the CAR of the form into another\n ; function and then generate code to call it (ZCCLAMB would flag\n ; an error if the form were not a valid LAMBDA-expression).\n ;\n ; Now we try to compile the LAMBDA inline if possible.  Here's how:\n ;\n ; If the CAR of the form is a LABEL-expression, do as before - we\n ; have to generate another function.\n ;\n ; If the CAR of the form is a LAMBDA-expression, see if it is a\n ; compilable one.  If it is, generate the code inline.  If it is\n ; not, generate an APPLY of an interpretive LAMBDA expression.\n ;\n\n (let (((formcar . formcdr) b))\n  (cond\n   ((atom formcar)\n    (modq body\n          `(error \"Function name not a symbol or LAMBDA-expression\"\n                  ,formcar)))\n   (t\n    (case (car formcar)\n     (lambda (zcceval formcar formcdr v s e)) ;ZCCEVAL knows what to do\n     (label  (zcceval (zcclamb formcar t e) formcdr v s e))\n     (t      (modq body\n              `(error \"Bad expression in CAR of form, can't compile\"\n                      ,formcar))))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCEXPR": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x12\\x00\\xb0\\x00\\xb9\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:12:00", "lines": 176, "newlines": 185, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"COMPILE-EXPR\"\n;;;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/10/88 - Removed PROGVARS, GOLIST and PROGEXIT.                   *\n;* 06/23/88 - Removed PALIST (no more PROG or RETURN).                 *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;\n;; ALONE = T:    function (toplevel = no)\n;;\n;; ALONE = NIL:  program  (toplevel = yes)\n;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccexpr (f          ; F is the name of the function\n                l          ; L is a LAMBDA-expression\n                           ; (CAR L) is \"LAMBDA\"\n                           ; (CADR L) is the list of argument variables\n                           ; (CDDR L) is the function body\n                main       ; if not NIL, this is a main-line program\n                alone      ; if not NIL, this is a standalone function\n                e          ; environment (list of contours)\n               )\n\n (cond\n  ((eq (car l) 'lambda)\n   ;\n   ; If the function identified by F is to be \"segmented\", as requested\n   ; by a (DECLARE (SEGMENT ...)), then compile a segmented version of\n   ; the function body.\n   ;\n   (let ((segcount (and f (get f 'segment))))\n        (when segcount\n              (let ((newbody (zilcoseg f l segcount)))\n                   (when debug\n                         (cterpri)\n                         (princ \"Segmented version of function \")\n                         (prin1 f)\n                         (princ \" being compiled:\")\n                         (terpri)\n                         (terpri)\n                         (pprint newbody)\n                         (terpri)\n                         (terpri))\n                   (setq l newbody))))\n   (compile-body (or f (gensym)) (cadr l) (cddr l) e))\n  ((eq (car l) 'label)\n   (zccexpr (cadr l) (caddr l) main alone e))\n  (t\n   (princ \"Function name not a symbol, LABEL- or LAMBDA-expression - \")\n   (print l)\n   nil\n  )\n )\n)\n\n;;; This function returns all the pseudocode for a function body.\n;;; Note that all objects used by the compiler are local to here.\n\n(defun compile-body (f v b e) ; Compile the body of the function\n (prog\n  (thing     ; the object to be returned as the result of the compile\n   body      ; the main body of the procedure\n   name      ; the name of the procedure currently being compiled\n   tparms    ; parameter arguments used by the program\n   special-unbounds ; unbound special variables referenced by the fn\n   fluid-unbounds   ; unbound lexical variables referenced by the fn\n   lists     ; constant lists referenced by the program\n   atoms     ; constant atoms referenced by the program\n   subrs     ; external subroutines invoked by the program\n   procs     ; internal LAMBDA-procedures compiled along with the rest\n   tailrecur ; a list of local variables active during tail recursion\n  )\n\n  ;\n  ; Eventually, push new \"defun\" contour onto \"e\" when doing this.\n  ;\n\n  (setq body      (list nil)\n        name      (zilcosym f 'subrs)  ; Add name to SUBRS list.\n        tparms    (get f 'parms)       ; NIL if not a DEFUN function.\n        special-unbounds  (list nil)\n        fluid-unbounds    (list nil)\n        lists     (list nil)\n        atoms     (list nil)\n        subrs     (list nil)\n        procs     (list nil)\n        tailrecur nil\n  )\n;\n; If PARMS not set, then set all arglist-relevant properties now.\n;\n  (or tparms\n   (if  (zilcoarg f v)                  ; Process the argument list.\n    then\n        (setq tparms (get f 'parms))    ; Get list of function args.\n    else\n        (modq body `(error \"Invalid LAMBDA argument list\" ,f))\n        (go compile-return)\n    endif\n   )\n  )\n\n  (when (> (get (car name) 'maxargs 0) 255)\n        (modq body `(error \"More than 255 required + optional args\"\n                           ,(car name))))\n\n  (modq body `(begin ,name ,tparms ,main ,alone))\n\n;\n; Identify who owns these variables.\n;\n\n  (dolist (x tparms)\n          (putprop (cdr x) name 'owner))\n\n;\n; Bind each variable on the arglist.\n;\n\n  (setq b (zcclama f nil b e))\n\n;\n; Evaluate forms in the body as an implicit PROGN.\n;\n\n  (zccprogn b nil t e)  ; Note \"T\" means generate the return value.\n\n  (modq body `(end ,name ,tparms ,main ,alone))\n\n compile-return\n\n;\n; In case any non-local lexical bindings were uncovered, add the atoms\n; for those bindings the \"right\" way by calling ZILCOADD on them.\n;\n  (dolist (x (get (car name) 'newatoms))\n          (zilcoadd x nil))\n\n  (return                ; Build property list to hang off the new thing\n   (setplist (setq thing (gensym))\n             (list\n                   'body              body\n                   'name              name\n                   'parms             tparms\n                   'special-unbounds  special-unbounds\n                   'fluid-unbounds    fluid-unbounds\n                   'atoms             atoms\n                   'lists             lists\n                   'subrs             subrs\n                   'procs             procs\n                   'tailrecur         tailrecur\n              )))))\n\n; Special declarations moved to ZILMACS.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCFARG": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x12\\x00\\x9a\\x00\\x92\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:12:00", "lines": 154, "newlines": 146, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCCFARG\"\n;;;\n;;; This routine compiles closures, i.e. (FUNCTION ...),\n;;; and subrs, i.e. (SUBR ...).\n;;;\n;;; The argument to (FUNCTION ...) or (SUBR ...) must be a symbol\n;;; or a valid LAMBDA-expression or LABEL-expression.\n;;;\n;;;  If (DECLARE (AUTOFUNCALL T)) was specified, and something\n;;;  like #'FOO is coded where FOO is unknown, a call to\n;;;  ZILXCLO is generated to build a compiled or interpreted\n;;;  lexical closure, as the case may be.\n\n;\n;  U is either CLOSURE or SUBR.\n;  B must be a list of 1 element - the function name.\n;  V, S and E have their usual P-code-phase meanings.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccfarg (u b v s e)\n (prog (n f c p)\n  (or b (go error1))\n  (and (cdr b) (go error1))\n  (setq n (car b))          ; Function name or LAMBDA, etc. expression.\n\n  (setq p (eq u 'closure))  ; True if a closure is being built.\n\n  (cond\n   ((null n)       (go error2))         ; #'NIL - error\n   ((consp n)      (go close-lambda))   ; #'(...) - must be LAMBDA-exp\n   ((symbolp n)    (go close-symbol))   ; #'FOO - see if we know FOO\n   (t              (go error2))         ; #'#<other> - error\n  )\n\nclose-lambda\n\n  (if (valid-lambda-p n)  ; If LAMBDA expression is valid and usable\n   then\n      (setq f (zcclamb n p e)) ;Try to compile the LAMBDA expression\n      (go close-normal)        ; and generate a compiled closure for it\n   else\n      (return)               ; else not a valid LAMBDA, do nothing.\n   endif\n  )\n\nclose-symbol\n\n  (if\n      (memq n (get '*zilco* 'special-forms))\n   then\n      (go error3)\n   else\n   if\n      (known-function-p n)   ; If it's a function known to compiler\n   then\n      (setq f n)             ; Use the function itself\n      (go close-normal)      ; and generate a compiled closure for it\n   else\n      (go close-unknown)     ; otherwise make interpreted closure\n   endif\n  )\n\nclose-normal\n\n  (modq body              ; Code similar to ZCCCALL to make a SUBR.\n         (let ((dottedpair (assq f subrs)))  ; Find F if it is in list\n           (unless dottedpair                ; If so, return that subr\n            (setq dottedpair                 ; Else create a new subr\n                 (zilcosym f 'subrs))        ; Add pair to symbol table\n           (or (eq (car name) f)             ; If not a recursive call\n               (modq subrs dottedpair)))     ; then add it to the list\n          `(,u      ,dottedpair ,v ,s)))     ; Generate CLOSURE or SUBR\n  (return)\n\nclose-unknown\n\n  (unless (get n 'zilxclosed)\n   (princ \" Function \\\"\")\n   (prin1 n)\n   (princ \"\\\" unknown.  Funcallable \")\n   (princ (if p \"closure\" \"subr\"))\n   (princ \" may be built at run time.\")\n   (terpri)\n   (putprop n t 'zilxclosed))\n\n  (zccevcom `(zilxclo ',n ,p) v s e) ; Compile call to closure maker.\n  (return)\n\nerror1\n  (modq body `(error \"Invalid FUNCTION syntax\" ,(cons u b)))\n  (return)\n\nerror2\n  (modq body `(error \"Invalid FUNCTION name\" ,n))\n  (return)\n\nerror3\n  (modq body `(error \"Function cannot be passed as argument\" ,n))\n  (return)\n\n )\n)\n\n(defun valid-lambda-p (x) ; X is a CONS.\n (prog ()\n  (if (eq (car x) 'lambda)\n   then\n      (or (cdr x)  (go not-valid))\n      (or (cddr x) (go not-valid))\n      (return t)  ; LAMBDA valid and compilable.\n   else\n   if (eq (car x) 'label)\n   then\n      (or (cdr x) (go not-valid))\n      (or (cddr x) (go not-valid))\n      (return (valid-lambda-p (caddr x)))\n   else (go not-valid)\n   endif\n  )\n not-valid\n  (modq body\n   `(error \"Functional arg not a symbol or valid LAMBDA-expression\"\n           ,x))\n  (return nil)\n )\n)\n\n(defun known-function-p (x)    ; X is a symbol.\n (if (get '*zilco* 'autofuncall)\n  then\n     (let* (\n            (c (get x 'cautoload))\n            (minargs (or (if (and c (symbolp c)) (get c 'minargs))\n                         (get x 'minargs)))\n           )\n           (if minargs t nil)\n     )\n  else t))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCFAST": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x88\\x08/\\x00\\x89\\x15o\\x10\\x13\\x01\\xca\\x01\\xa9\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1988-03-22T00:00:00", "modifydate": "1989-06-05T10:13:00", "lines": 458, "newlines": 425, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCCFAST\"\n;;;\n;;; This routine compiles functions which may be coded inline in\n;;; certain cases (or even in all cases).\n;;;\n;;;  F is the function name.\n;;;  A is the list of args to the function.\n;;;  V, S and E have their usual P-code-phase meanings.\n;;;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/22/88 - Support for fast inline ASSQ and MEMQ.                   *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(declare (special *unbound-thing*))\n\n(defun zccfast (f a v s e &aux (l (length a))\n                               (*unbound-thing* (gensym)))\n (case f\n  (eq     (if (eql l 2) (zccfast-eq     a v s e) (zccfastbug f)))\n  (eql    (if (eql l 2) (zccfast-eql    a v s e) (zccfastbug f)))\n  (cons   (if (eql l 2) (zccfast-cons   a v s e) (zccfastbug f)))\n  (rplaca (if (eql l 2) (zccfast-rplaca a v s e) (zccfastbug f)))\n  (rplacd (if (eql l 2) (zccfast-rplacd a v s e) (zccfastbug f)))\n  (assq   (if (eql l 2) (zccfast-assq   a v s e) (zccfastbug f)))\n  (memq   (if (eql l 2) (zccfast-memq   a v s e) (zccfastbug f)))\n  (vref   (if (eql l 2) (zccfast-vref   a v s e) (zccfastbug f)))\n  (vset   (if (eql l 3) (zccfast-vset   a v s e) (zccfastbug f)))\n  (t      (zerror \"Invalid caller of ZCCFAST\" f))))\n\n;=======================================================================\n\n(defun zccfast-eq (a v s e)\n\n (let* ((arg1 (zilcomex (car a) nil))\n        (arg2 (zilcomex (cadr a) nil))\n        (con1 (zilcocon arg1 e))\n        (con2 (zilcocon arg2 e))\n       )\n\n  (cond\n   ;\n   ; At least one of the args to EQ is a constant.\n   ; Without worrying about the case where both are constant for now,\n   ; try to get the constant one to be arg2.\n   ;\n   ((and con1 (not con2))\n    ;\n    ; (EQ 'foo (form)) ---> (EQ (form) 'foo)\n    ;\n    (or (zccfast-eq-doit arg2 (car con1) v s e)\n        (zcceval 'eq (list arg1 arg2) v s e)))\n   ;\n   ; Arg 2 to EQ is the form (ZILUNBND), which represents the\n   ; \"unbound\" marker.\n   ;\n   ((and (equal arg2 '(zilunbnd))\n         (get 'zilunbnd 'inline)) ; Only if it's being compiled inline\n    (or (zccfast-eq-doit arg1 *unbound-thing* v s e)\n        (zcceval 'eq (list arg1 arg2) v s e)))\n   ;\n   ; If neither argument to EQ is a constant, can't do a fast compile.\n   ; Therefore, in that case do a normal compile.\n   ;\n   ((and (not con1) (not con2))\n    (zcceval 'eq (list arg1 arg2) v s e))\n   (t\n   ;\n   ; Arg 2 must be a constant.\n   ;\n    (or (zccfast-eq-doit arg1 (car con2) v s e)\n        (zcceval 'eq (list arg1 arg2) v s e))))))\n\n;;;\n;;; Fast compile of EQ is supported for:\n;;;\n;;; self-evaluating and quoted symbols\n;;;\n\n(defun zccfast-eq-doit (arg con v s e)\n (cond\n  ((not (symbolp con)) ; This is why *unbound-thing* must be a gensym.\n   (warn \"Probably incorrect use of EQ. Maybe you mean EQL or EQUAL?\"\n         `(eq ,arg ',con))\n   nil)\n  (t\n   (modq body `(begininline eq 1 ,v ,s))\n   (zccevcom arg nil '(arg (1 eq)) e)\n   (modq body `(inline (eq ,(zccfast-thing con)) 1 ,v ,s))\n   t\n  )))\n\n;=======================================================================\n\n(defun zccfast-eql (a v s e)\n\n (let* ((arg1 (zilcomex (car a) nil))\n        (arg2 (zilcomex (cadr a) nil))\n        (con1 (zilcocon arg1 e))\n        (con2 (zilcocon arg2 e))\n       )\n\n  (cond\n   ;\n   ; If neither argument to EQL is a constant, can't do a fast compile.\n   ; Therefore, in that case do a normal compile.\n   ;\n   ((and (not con1) (not con2))\n    (zcceval 'eql (list arg1 arg2) v s e))\n   ;\n   ; At least one of the args to EQL is a constant.\n   ; Without worrying about the case where both are constant for now,\n   ; try to get the constant one to be arg2.\n   ;\n   ((and con1 (not con2))\n    ;\n    ; (EQL 'foo (form)) ---> (EQL (form) 'foo)\n    ;\n    (or (zccfast-eql-doit arg2 (car con1) v s e)\n        (zcceval 'eql (list arg1 arg2) v s e)))\n   (t\n    (or (zccfast-eql-doit arg1 (car con2) v s e)\n        (zcceval 'eql (list arg1 arg2) v s e))))))\n\n;;;\n;;; Fast compile of EQL is supported for:\n;;;\n;;; fixnums and single-floats\n;;;\n;;; Note that for self-evaluating and quoted symbols, the EQL is\n;;; converted to EQ, since that's equivalent.\n;;;\n\n(defun zccfast-eql-doit (arg con v s e)\n (cond\n  ((symbolp con)\n   (warn \"EQL used with constant symbol.  Converting to equivalent EQ\"\n         `(eql ,arg ',con))\n   (zccfast-eq-doit arg con v s e) ; Compile as fast (EQ arg1 arg2)\n  )\n  ((or (bigp con) (stringp con) (dfloatp con))\n   ; Have to do \"slow\" compile for these types\n   nil)\n  ((or (fixnump con) (sfloatp con))\n   (modq body `(begininline eql 1 ,v ,s))\n   (zccevcom arg nil '(arg (1 eql)) e)\n   (modq body `(inline (eql ,(zccfast-thing con)) 1 ,v ,s))\n   t)\n  (t\n   (warn \"Probably incorrect use of EQL. Maybe you mean EQUAL?\"\n         `(eql ,arg ',con))\n   nil)))\n\n;=======================================================================\n\n(defmacro zccfast-cons   (a v s e) `(zccfast-c-r-r 'cons   ,a ,v ,s ,e))\n(defmacro zccfast-rplaca (a v s e) `(zccfast-c-r-r 'rplaca ,a ,v ,s ,e))\n(defmacro zccfast-rplacd (a v s e) `(zccfast-c-r-r 'rplacd ,a ,v ,s ,e))\n\n(defun zccfast-c-r-r (f a v s e)\n\n ;\n ; We can do a \"fast\" compile for CONS/RPLACA/RPLACD\n ; if the second argument is a\n ; constant or a locally bound variable.\n ;\n ; It doesn't matter what the first argument is.\n ;\n\n (let ((arg1 (car a))  ; Don't have to macroexpand, we don't care\n       (arg2 (zilcomex (cadr a) nil))\n       (temp)\n      )\n\n  (cond\n   ;\n   ; If arg 2 to C/R/R is a constant, we can do the \"fast\" compile.\n   ;\n   ((setq temp (zilcocon arg2 e))\n    (zccfast-c-r-r-doit f arg1 (car temp) nil v s e))\n   ;\n   ; If arg 2 to C/R/R is a locally bound variable, we can also do\n   ; a \"fast\" compile.\n   ;\n   ((setq temp (zccfast-locally-bound-variable arg2 e))\n    (zccfast-c-r-r-doit f arg1 temp t v s e))\n   ;\n   ; Otherwise we have to go with a \"normal\" compile.\n   ;\n   (t\n    (zcceval f (list arg1 arg2) v s e)))))\n\n(defun zccfast-c-r-r-doit (f arg con variablep v s e)\n (let ((thing (if variablep con (zccfast-thing con))))\n  (modq body `(begininline ,f 1 ,v ,s))\n  (zccevcom arg nil `(arg (1 ,f)) e)\n  (when variablep (zccfast-mark-used thing))\n  (modq body `(inline (,f ,thing) 1 ,v ,s))\n )\n)\n\n;=======================================================================\n\n(defun zccfast-assq (a v s e &aux temp)\n (let* ((arg1 (zilcomex (car a) nil))\n        (arg2 (zilcomex (cadr a) nil))\n        (con2 (zilcocon arg2 e)))\n  (cond\n    ;\n    ; ASSQ something NIL?\n    ;\n   ((null arg2)\n    (warn \"Argument 2 to ASSQ is nil, suppressing call to ASSQ\"\n          `(assq ,arg1 ,arg2))\n    (zccevcom (zilcotrn `(progn ,arg1 nil) debug) v s e)\n   )\n   ((not con2)\n    ;\n    ; Arg 2 to ASSQ not a constant, but might be a local variable\n    ;\n    (cond\n     ;\n     ; ASSQ something variablename?\n     ;\n     ((setq temp (zccfast-locally-bound-variable arg2 e))\n      (zccfast-assq-doit arg1 temp t v s e))\n     ;\n     ; ASSQ something (SALIST) / (SPECIAL-ALIST)?\n     ;\n     ((and (consp arg2)\n           (null (cdr arg2))\n           (or (eq (car arg2) 'salist)\n               (eq (car arg2) 'special-alist))\n           (get 'salist 'inline)) ; Only if it's being compiled inline\n      (zccfast-assq-doit arg1 'salist nil v s e))\n     (t\n      ;\n      ; ASSQ something (not-a-variablename)\n      ;\n      (zccfast-assq-punt arg1 arg2 v s e))))\n   ;\n   ; Arg 2 to ASSQ is a constant.  Now is it a valid association list?\n   ;\n   ((not (do ((l (car con2) (cdr l)))\n             ((null l) t)\n             (when (atom l) (return nil))\n             (unless (or (null (car l))\n                         (and (consp (car l))\n                              (symbolp (caar l))))\n                     (return nil))))\n    (warn \"Argument 2 to ASSQ not a proper association list for ASSQ\"\n          `(assq ,arg1 ,arg2))\n    (zccfast-assq-punt arg1 arg2 v s e))\n   ;\n   ; Otherwise fast call OK.\n   ;\n   (t\n    (zccfast-assq-doit arg1 (zccfast-thing (car con2)) nil v s e)))))\n\n(defun zccfast-assq-doit (arg1 thing variablep v s e)\n (modq body `(begininline assq 1 ,v ,s))\n (zccevcom arg1 nil '(arg (1 assq)) e)\n (when variablep (zccfast-mark-used thing))\n (modq body `(inline (assq ,thing) 1 ,v ,s))\n)\n\n(defun zccfast-assq-punt (arg1 arg2 v s e)\n (zcceval 'assq (list arg1 arg2) v s e))\n\n;=======================================================================\n\n(defun zccfast-memq (a v s e &aux temp)\n (let* ((arg1 (zilcomex (car a) nil))\n        (arg2 (zilcomex (cadr a) nil))\n        (con2 (zilcocon arg2 e)))\n  (cond\n    ;\n    ; MEMQ something NIL?\n    ;\n   ((null arg2)\n    (warn \"Argument 2 to MEMQ is nil, suppressing call to MEMQ\"\n          `(memq ,arg1 ,arg2))\n    (zccevcom (zilcotrn `(progn ,arg1 nil) debug) v s e)\n   )\n   ((not con2)\n    ;\n    ; Arg 2 to MEMQ not a constant, but might be a local variable\n    ;\n    (cond\n     ;\n     ; MEMQ something variablename?\n     ;\n     ((setq temp (zccfast-locally-bound-variable arg2 e))\n      (zccfast-memq-doit arg1 temp t v s e))\n     (t\n      ;\n      ; MEMQ something (not-a-variablename)\n      ;\n      (zccfast-memq-punt arg1 arg2 v s e))))\n   ;\n   ; Arg 2 to MEMQ is a constant.  Now is it a valid list of symbols?\n   ;\n   ((not (do ((l (car con2) (cdr l)))\n             ((null l) t)\n             (when (atom l) (return nil))\n             (unless (symbolp (car l))\n                     (return nil))))\n    (warn \"Argument 2 to MEMQ not a proper list of symbols\"\n          `(memq ,arg1 ,arg2))\n    (zccfast-memq-punt arg1 arg2 v s e))\n   ;\n   ; Otherwise fast call OK.\n   ;\n   (t\n    (zccfast-memq-doit arg1 (zccfast-thing (car con2)) nil v s e)))))\n\n(defun zccfast-memq-doit (arg1 thing variablep v s e)\n (modq body `(begininline memq 1 ,v ,s))\n (zccevcom arg1 nil '(arg (1 memq)) e)\n (when variablep (zccfast-mark-used thing))\n (modq body `(inline (memq ,thing) 1 ,v ,s))\n)\n\n(defun zccfast-memq-punt (arg1 arg2 v s e)\n (zcceval 'memq (list arg1 arg2) v s e))\n\n;=======================================================================\n\n(defun zccfast-vref (a v s e)\n\n (let ((arg1 (zilcomex (car a) nil))\n       (arg2 (zilcomex (cadr a) nil))\n      )\n\n  (if (and (fixnump arg2) (< arg2 1024))\n   then\n      (if (minusp arg2)\n       then\n          (modq body `(error \"Invalid second arg to VREF\" ,arg2))\n       else\n          (modq body `(begininline vref 1 ,v ,s))\n          (zccevcom arg1 nil '(arg (1 vref)) e)\n          (modq body `(inline (vref ,arg2) 1 ,v ,s))\n       endif\n      )\n   else\n    (modq body `(begininline vref 2 ,v ,s)) ; compile as inline call\n    (zccevcom arg1 nil '(arg (1 vref)) e)   ; compile load of argument\n    (zccevcom arg2 nil '(arg (2 vref)) e)   ; compile load of argument\n    (modq body `(inline vref 2 ,v ,s))      ; compile inline code\n   endif\n  )\n )\n)\n\n;=======================================================================\n\n(defun zccfast-vset (a v s e)\n\n (let ((arg1 (zilcomex (car a) nil))\n       (arg2 (zilcomex (cadr a) nil))\n       (arg3 (zilcomex (caddr a) nil))\n      )\n\n  (if (and (fixnump arg2) (< arg2 1024))\n   then\n      (if (minusp arg2)\n       then\n          (modq body `(error \"Invalid second arg to VSET\" ,arg2))\n       else\n          (modq body `(begininline vset 2 ,v ,s))\n          (zccevcom arg1 nil '(arg (1 vset)) e)\n          (zccevcom arg3 nil '(arg (2 vset)) e)\n          (modq body `(inline (vset ,arg2) 2 ,v ,s))\n       endif\n      )\n   else\n    (modq body `(begininline vset 3 ,v ,s)) ; compile as inline call\n    (zccevcom arg1 nil '(arg (1 vset)) e)   ; compile load of argument\n    (zccevcom arg2 nil '(arg (2 vset)) e)   ; compile load of argument\n    (zccevcom arg3 nil '(arg (3 vset)) e)   ; compile load of argument\n    (modq body `(inline vset 3 ,v ,s))      ; compile inline code\n   endif\n  )\n )\n)\n\n;======================================================================\n\n(defun zccfast-thing (x)\n (cond\n  ((or (null x)\n       (eq x t)\n       (and (fixnump x) (>= x -1) (<= x 255))\n   )\n   x)\n  ((eq x *unbound-thing*)\n   'unbound)\n  (t\n   (let ((q (zilcoadd x (consp x))))\n        (putprop (cdr q) t 'real)\n        q))))\n\n;======================================================================\n\n; This function tells whether a given argument is a locally bound\n; variable (a lexically bound one, not a dynamically bound one)\n; for the purpose of seeing if fast code can be generated, based\n; on the fact that a one-or-two-instruction sequence will be\n; generated to load it that doesn't clobber any important registers.\n;\n; Note that we have to assign properties to the binding the same\n; way that ZCCATOM would have done.\n;\n\n(defun zccfast-locally-bound-variable (arg e)\n (when (symbolp arg)\n       (assq arg (zilcec-bindings (car e)))))\n\n(defun zccfast-mark-used (z)\n (putprop (cdr z) t 'used)\n (unless (get (cdr z) 'set)\n         (putprop (cdr z) t 'mustinit)))\n\n;======================================================================\n\n(defun zccfastbug (f)\n (modq body `(error \"Wrong number of args to function\" ,f)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCFCALL": {"ttr": 3856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x13\\x00(\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:13:00", "lines": 40, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This routine compiles FUNCALL invocations.  It is similar to\n;;; ZCCEVAL, except that the number of args is not checked, and\n;;; the name of the compiled function to be called is ZILXFUN,\n;;; which the code generator checks for specially.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccfcall (args v s e)\n (let ((n (+ (length args) 4)))    ; Gotta allow 4 extra stack slots.\n      (if  (< n 5)\n       then\n           (modq body `(error \"No function arg to FUNCALL\" nil))\n       else\n           (modq body `(begincall zilxfun ,n ,v ,s))\n           (modq body '(setnil nil nil (arg (1 zilxfun))))\n           (modq body '(setnil nil nil (arg (2 zilxfun))))\n           (modq body '(setnil nil nil (arg (3 zilxfun))))\n           (modq body '(setnil nil nil (arg (4 zilxfun))))\n           (loop for i from 5 to n\n                 do\n                    (zccevcom (car args) nil `(arg (,i zilxfun)) e)\n                    (setq args (cdr args))\n           )\n           (modq body (zcccall 'zilxfun n v s e))\n       endif)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCFUNC": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x14\\x000\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:14:00", "lines": 48, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"COMPILE-FUNCTION\"\n;\n; This function is called from ZILCOCOM to process a top-level DEFUN.\n;\n\n;;\n;; ALONE = T:    function (toplevel = no)\n;;\n;; ALONE = NIL:  program  (toplevel = yes)\n;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccfunc (f main alone e &aux x) ; Compile a function definition\n (let ((e (cons (zccmkcec 'defun e) e)))\n  (cond\n   ((consp f)                     ; A LAMBDA-expression\n    (zccexpr nil f main alone e))\n   ((not (symbolp f))             ; Not a LAMBDA-expression or fn name\n     (princ \"Invalid function name (not a symbol) - \")\n     (prin1 f)\n     (terpri)\n     nil)\n   ((setq x (get f 'cexpr))       ; A \"CEXPR\" is a function definition\n                                  ; known only to the compiler.\n                                  ; Apply full code expansion\n  ; (including macroexpansion and compiler transforms)\n                                  ; to the function definition.\n;;;; (zccexpr f (zilcotrn x debug) main alone e))\n     (zccexpr f x main alone e))\n   (t\n     (prin1 f)\n     (princ \" has no valid function definition, cannot be compiled.\")\n     (terpri)\n     nil))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCGO": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x15\\x003\\x00\\x16\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:15:00", "lines": 51, "newlines": 22, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles the \"GO\" function.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/06/88 - Support for GO tag optimization.                         *\n;*            Now calls ZCCVALGO, which was broken out in order to     *\n;*            enable ZCCCOND to check GO's as well.                    *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccgo (b e) ; B = body, E = environment\n (let ((p (zccvalgo b e))) ; Get the pair that identifies the GO tag\n      (when p\n            (modq body `(label nil nil (goto ,(cdr p))))\n            ;\n            ; All contours up to AND INCLUDING the contour associated\n            ; with the GO tag are marked permanently conditional.\n            ;\n            (loop with c = (get (cdr p) 'contour)\n                  for cec in e\n                  do (setf (zilcec-permcond cec) t)\n                  until (eq cec c)))))      ; Note placement of UNTIL!!!\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCLAMA": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x15\\x01\\x96\\x00\\xa1\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:15:00", "lines": 406, "newlines": 161, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This function is called by ZCCEXPR to process a DEFUN arglist,\n;;;                     and by ZCCEVAL to process a LAMBDA arglist.\n;;;\n;;; Arguments:\n;;;\n;;;   FUN - the symbol naming the function or lambda expression\n;;;         being compiled.  The list of LAMBDA args generated by\n;;;         ZILCOARG is on this symbol's property list.\n;;;\n;;;   LABEL - a generated label where unbindings will be done.\n;;;\n;;;   FORMS - the body of the function or lambda expression, which\n;;;           must be scanned for declarations.\n;;;\n;;;   E     - the environment (this will eventually be being modified\n;;;           in ZCCLAMA-BIND-IT to effect bindings)\n;;;\n;;; Returns:\n;;;\n;;;   The body with any declarations stripped off.\n;;;\n;;; The BINDINGS slot of the contour passed to this function will be\n;;; augmented by this function to provide the correct scope for the\n;;; bindings in the various INIT forms.  On entry it has no entries\n;;; for any of the arguments in the lambda list; on exit it will\n;;; have all of them.  Furthermore, SPECIAL declarations will be\n;;; dealt with entirely in this function.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcclama (fun label forms e\n                &aux (decls ())\n                     (newbody ())\n                     (llvars (get fun 'parms))\n                     (cec (car e))\n                     (save-tempcond (zilcec-tempcond cec))\n               )\n\n\n;\n; Set up fields in the current contour as copies so that they can be\n; modified without affecting other contours.\n;\n\n (setf (zilcec-bindings cec)\n       (append (zilcec-bindings cec) nil))\n (setf (zilcec-specials cec)\n       (append (zilcec-specials cec) nil))\n\n;\n; Extract declarations from the body forms and modify forms accordingly.\n; If the first form is a documentation string, skip it.\n;\n\n (do ((b (if (and (stringp (car forms)) (cdr forms)) (cdr forms) forms)\n         (cdr b))\n      (form)\n     )\n     ((null b))\n     (setq form (zilcomex (car b) nil))\n     (cond\n      ((or (atom form); If not a declaration, finished w/body.\n           (neq (car form) 'declare))\n       (setq newbody (cons form (cdr b)))\n       (return))\n      (t              ; If it's a declaration...\n       (dolist (declaration (cdr form))\n               (if (consp declaration)\n                   (push declaration decls)\n                   (modq body\n                    `(error \"Illegal DECLARE subform\" ,declaration))\n               )))))\n\n;\n; At this point DECLS is a list of all DECLARE subforms and\n; NEWBODY is the body without the declarations, with the first\n; form (probably) macroexpanded already.\n;\n\n ;\n ; ZCCLAMA-HACK-SPECIALS is being executed BEFORE the calls to\n ; ZCCLAMA-BIND-IT, in accordance with CLtL'84, so that SPECIAL\n ; declarations that are not attached to local bindings pertain to\n ; references in INIT forms contained in the lambda list.\n ;\n ; If the proposed modification to the CL standard is adopted, and\n ; all SPECIAL declarations have variable-like scope regardless of\n ; whether they are attached to local bindings, then the call to\n ; ZCCLAMA-HACK-SPECIALS must be moved to AFTER the calls to\n ; ZCCLAMA-BIND-IT.  In this case, for correct operation,\n ; we should save a pointer to ZILCEC-BINDINGS as it existed before\n ; the calls to ZCCLAMA-BIND-IT (although that may not be strictly\n ; necessary, as this code processes, by definition, variables that\n ; are not present in the lambda list).\n ;\n\n;\n;.......................................................................\n;.                                                                     .\n;. DECLARATION SUPPORT...NOT IMPLEMENTED YET                           .\n;.                                                                     .\n;. Process pervasive declarations here                                 .\n;. (i.e. go through all declarations and process all of them one way   .\n;.  or another except for SPECIALs, done by ZCCLAMA-HACK-SPECIALS).    .\n;. Collect binding-related declarations to prepare to attach them      .\n;. to bindings.                                                        .\n;.                                                                     .\n;.......................................................................\n;\n\n (zcclama-hack-specials llvars decls cec)\n\n;\n; Bind each variable on the arglist.\n;\n; Note that initializations of &OPTIONAL and &AUX variables are done\n; before their respective bindings, to follow Common LISP scoping rules.\n;\n\n (loop for x in llvars\n       with s = nil\n       with l = nil\n;\n;.......................................................................\n;.                                                                     .\n;. DECLARATION SUPPORT...NOT IMPLEMENTED YET                           .\n;.                                                                     .\n;. Attach binding-related declarations (other than SPECIAL decls)      .\n;. to bindings for each \"x\" here.                                      .\n;. Don't forget to check global (top-level) declarations.              .\n;.                                                                     .\n;.......................................................................\n;\n      ;\n      ; If this is an &OPTIONAL variable:\n      ; if it has an associated \"supplied-p\" variable,\n      ; generate code to set it to T or NIL depending on whether\n      ; the optional value was supplied;\n      ; evaluate the initialization form, setting the variable,\n      ; and bind the &OPTIONAL variable and (if present)\n      ; the \"supplied-p\" variable.\n      ;\n       when (get (cdr x) 'optional)\n         do (setq s (get (cdr x) 'suppliedp)\n                  l (gensym))\n            (when s (modq body `(sett t ,(list s) nil)))\n            (modq body `(optional ,x ,l nil nil))\n            (setf (zilcec-tempcond cec) t)\n            (when s (modq body `(setnil nil ,(list s) nil)))\n            (zccevcom (get (cdr x) 'init) (list x) nil e)\n            (putprop l t 'referenced)\n            (setf (zilcec-tempcond cec) save-tempcond)\n            (modq body `(label ,l nil nil))\n            (zcclama-bind-it x label decls e)\n            (when s (zcclama-bind-it s label decls e))\n       else\n      ;\n      ; If this is a &KEY variable:\n      ; save it for later use\n      ;\n       when (get (cdr x) 'key)\n       collect x into keyvars\n       else\n      ;\n      ; If this is an &AUX variable,\n      ; save it for later use\n      ;\n       when (get (cdr x) 'aux)\n       collect x into auxvars\n       else\n      ;\n      ; If we encounter a variable which is some other variable's\n      ; \"supplied-p\" or destructured variable, ignore it on this\n      ; go-round since we handled it when we processed its \"owner\".\n      ;\n       when (get (cdr x) 'owned)\n         do nil\n       else\n       ;\n       ; Other (\"normal\") variables are just bound.  There is no\n       ; code generated for them since their values will be on the\n       ; stack at function/lambda invocation time.\n       ;\n         do (zcclama-bind-it x label decls e)\n\n       finally\n      ;\n      ; Go through all &KEY variables, doing the following:\n      ; if it has an associated \"supplied-p\" variable,\n      ; generate code to set it to T or NIL depending on whether\n      ; the key value was supplied;\n      ; evaluate the initialization form, setting the variable,\n      ; and bind the &KEY variable and (if present)\n      ; the \"supplied-p\" variable.\n      ;\n      ; Before the first &KEY variable, generate code to initialize\n      ; the variables to \"unbound\" and then search the &REST list for\n      ; key values, filling the slots in.\n      ;\n        (when keyvars\n\n              (let ((aok (zilcoadd ':allow-other-keys nil)))\n                   (putprop (cdr aok) t 'real)\n                   (modq body `(keys ,keyvars ,fun ,aok nil nil)))\n\n              (loop for k in keyvars do\n\n                  (let* ((keyword (get (cdr k) 'keyword))\n                         (keysymbol (zilcoadd keyword nil)))\n                        (putprop (cdr keysymbol) t 'real)\n                        (putprop (cdr k) keysymbol 'keysymbol))\n\n                  (setq s (get (cdr k) 'suppliedp)\n                        l (gensym))\n                  (when s (modq body `(sett t ,(list s) nil)))\n                  (modq body `(optional ,k ,l nil nil))\n                  (setf (zilcec-tempcond cec) t)\n                  (when s (modq body `(setnil nil ,(list s) nil)))\n                  (zccevcom (get (cdr k) 'init) (list k) nil e)\n                  (putprop l t 'referenced)\n                  (setf (zilcec-tempcond cec) save-tempcond)\n                  (modq body `(label ,l nil nil))\n                  (zcclama-bind-it k label decls e)\n                  (when s (zcclama-bind-it s label decls e))))\n\n      ;\n      ; Go through all &AUX variables, doing the following:\n      ; evaluate its initialization form, setting the variable,\n      ; and bind the &AUX variable.\n      ;\n        (when auxvars\n              (loop for a in auxvars do\n                    (let ((init (get (cdr a) 'init)))\n                         (cond\n                          ((null init)\n                           (remprop (cdr a) 'set)\n                           (remprop (cdr a) 'used)\n                           (remprop (cdr a) 'mustinit)\n                           (modq body `(csetnil ,a ,(list a) nil))\n                          )\n                          (t\n                           (zccevcom init (list a) nil e))))\n                    (zcclama-bind-it a label decls e)))\n\n )\n\n ;\n ; Here's where to move the call to ZCCLAMA-HACK-SPECIALS if the CL\n ; standard changes.\n ;\n\n;;; (zcclama-hack-specials llvars decls cec)\n\n\n ;\n ; Return the body without the declarations.\n ;\n\n newbody\n\n)\n\n(defun zcclama-bind-it (x label decls e\n                        &aux (v (car x))\n                             (cec (car e))\n                             (sp (assq v special-freevars))\n                       )\n ;\n ; Identify this variable with this contour.\n ;\n (putprop (cdr x) cec 'contour)\n ;\n ; Add binding to contour's list of bindings.\n ;\n (push x (zilcec-bindings cec))\n ;\n ; If the variable named by x is named in a (DECLARE (SPECIAL ...))\n ;  found in this LAMBDA expression,\n ; then add it to the contour's list of locally declared specials.\n ; Else delete it from that list.\n ;\n ; But ignore the SPECIAL declaration if the variable is globally\n ; proclaimed SPECIAL, because it's superfluous in that case.\n ;\n\n (unless sp\n         (cond\n          ((loop for d in decls\n             thereis (and (eq (car d) 'special)\n                          (memq v (cdr d))))\n           (pushnew v (zilcec-specials cec) :test #'eq)\n           (zccbind x 'special)\n          )\n          (t\n           (setf (zilcec-specials cec)\n                 (delq v (zilcec-specials cec)))))\n )\n ;\n ; If the binding is globally proclaimed SPECIAL, indicate so.\n ;\n ; If globally proclaimed special, also show that this\n ; variable is really being used, so that it will get generated.\n ;\n\n (when sp (zccbind x 'special))\n\n ;\n ; Tell the code generator about the binding.\n ;\n (modq body `(bind ,x ,label nil nil))\n ;\n   ;\n   ; If the variable is really a generated variable which represents a\n   ; destructuring form in the lambda list, generate the code to\n   ; initialize the individual destructured variables and bind them\n   ; in sequence.\n   ;\n (loop for dvar in (get (cdr x) 'destrvars)\n       do (let ((init (get (cdr dvar) 'init)))\n               (cond\n                ((null init)\n                 (remprop (cdr dvar) 'set)\n                 (remprop (cdr dvar) 'used)\n                 (remprop (cdr dvar) 'mustinit)\n                 (modq body `(csetnil ,dvar ,(list dvar) nil))\n                )\n                (t\n                 (zccevcom init (list dvar) nil e))))\n          (zcclama-bind-it dvar label decls e)\n )\n)\n\n\n(defun zcclama-hack-specials (llvars decls cec)\n ;\n ; For each variable Z which appears in a SPECIAL declaration local\n ; to this form, where Z is NOT in the current lambda list:\n ;\n ; If Z is already in the contour's list of specials, or if Z is\n ; globally proclaimed SPECIAL, do nothing.  The SPECIAL declaration\n ; may be considered superfluous.\n ;\n ; Otherwise, add Z to the contour's list of specials, and also\n ; delete Z from the contour's list of bindings (which encompasses\n ; the bindings from contours up till now, and does not include\n ; anything from the current lambda list yet).\n ;\n ; In other words, insure that in the form\n ;\n ; (let ((a \"local-value-of-a\"))\n ;      (let ((b \"some-other-junk\"))\n ;           (declare (special a))\n ;           (foobar a)))\n ;\n ; the \"a\" passed to foobar is the SPECIAL a, not the LET-bound one.\n ;\n (dolist (d decls)\n         (when (eq (car d) 'special)\n               (dolist (x (cdr d))\n                (when (and (not (assq x llvars))\n                           (not (memq x (zilcec-specials cec)))\n                           (not (assq x special-freevars))\n                      )\n                      (push x (zilcec-specials cec))\n        ;\n        ; (setf (zilcec-bindings cec)\n        ;       (delete x (zilcec-bindings cec) :test #'eq :key #'car))\n        ;\n                      (when (assq x (zilcec-bindings cec))\n                            (setf (zilcec-bindings cec)\n                                  (loop for b in (zilcec-bindings cec)\n                                        unless (eq (car b) x)\n                                        collect b))))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCLAMB": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x16\\x00\\x80\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:16:00", "lines": 128, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCCLAMB\"\n;;;\n;;; This subroutine takes a form (which was previously determined not\n;;; to be a symbol) and attempts to compile it as a LAMBDA-expression,\n;;; returning the generated name of the function after it has been\n;;; added to the list of (compiled) internal procedures.\n;;;\n;;; If the argument is not a valid LAMBDA- or LABEL-expression, then\n;;; ZCCFUNC (compile-subroutine) will flag it as an error.\n;;;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/10/88 - As promised, setting of contour slots to suppress the    *\n;*            use of GO and RETURN out of FUNARGS into the FUNARG-     *\n;*            enclosing PROG is now implemented here instead of in     *\n;*            ZCCMKCEC.  Also, this is done for SUBR's as well as      *\n;*            FUNARG's, since the same issues apply.  Some day,        *\n;*            when we figure out how to GO/RETURN out of a funarg,     *\n;*            we will lift this restriction.  However, we will         *\n;*            continue to reset some slots, like the bindings,         *\n;*            since that is designed to handle a specific technique    *\n;*            of lexical pass-through, as it were.                     *\n;* 06/23/88 - Support for DECLARE (BASEREG) removed.                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;\n;; ALONE = T:    function (toplevel = no)\n;;\n;; ALONE = NIL:  program  (toplevel = yes)\n;;\n\n;\n; Note:      Support for multiple base registers mandates that we\n;            must propagate the enclosing function's BASEREG property\n;            to the lambda function.  Sadly, there is no other way\n;            to indicate that we may need this to be compiled with\n;            extra base registers, since lambdas don't have names.\n;\n; Note: Above note is not relevant in ZIL 1.3.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcclamb (x p e)\n                     ; X is, or should be, a LAMBDA or LABEL expression.\n                     ; P is true if the lexical environment must be\n                     ; passed through (funarg or pseudo-inline lambda),\n                     ; false if not (i.e. SUBR, like DEFUN).\n (prog (lamb lname)\n      ;\n      ; Give the LAMBDA-function a name.\n      ;\n       (setq lname (if (eq (car x) 'label)\n                       (cadr x)\n                       (gentemp (concat (car name) \" LAMBDA \"))))\n      ;\n      ; Take the LAMBDA-expression and compile it as a subroutine.\n      ;\n      ; Do this inside a new contour.\n      ;\n\n       (let ((e (cons (zccmkcec (if p 'funarg 'subr) e) e)))\n        ;\n        ; The particular initialization requirements of a\n        ; FUNARG or SUBR contour are handled here.\n        ;\n        ; The \"creator\" is used to separate locally bound variables.\n        ; Note that the variable list is not inherited across\n        ; FUNARG or SUBR type contours.  The compiler needs to access\n        ; the \"creator chain\" to track down variables that are\n        ; referenced lexically but must be \"heap-allocated\".\n        ;\n        ; If this is a FUNARG contour, the \"creator\" is the\n        ; lexically enclosing contour.  If this is a SUBR\n        ; contour, the creator is null.  Otherwise the \"creator\"\n        ; is the same as the creator of the current contour.\n        ;\n        ; Because the compiler currently does not support the use\n        ; of GO and RETURN from inside funargs to outer PROGs,\n        ; we suppress it here.  (The interpreter supports it.)\n        ;\n            (let ((new-cec (car e))\n                  (creator (if p (cadr e) nil)))\n                 (setf (zilcec-creator     new-cec) creator)\n                 (setf (zilcec-bindings    new-cec) nil)\n                 (setf (zilcec-go-tags     new-cec) nil)\n                 (setf (zilcec-return-tags new-cec) nil)\n            )\n            (setq lamb (zccexpr lname x nil alone e))\n       )\n      ;\n      ; If it wasn't a LAMBDA-expression, return NIL.\n      ;\n       (unless lamb\n               (modq body `(error \"Invalid function form\" ,x))\n               (return nil))\n      ;\n      ; Put it on the list of internal procedures.\n      ;\n       (modq procs lamb)\n      ;\n      ; Add its name to the list of function names.\n      ;\n       (modq intfuncs lname)\n      ;\n      ; Return the name as the value.\n      ;\n       (return lname)\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCLEXFN": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x16\\x00|\\x00n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:16:00", "lines": 124, "newlines": 110, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCCLEXFN\"\n;;;\n;;; This routine compiles the special forms ARG, SETARG and LISTIFY.\n;;;\n;;; The arguments are checked and code is generated to compile the\n;;; functions inline.\n;;;\n\n;\n;  F is ARG, SETARG or LISTIFY.\n;  A is the list of args to the function.\n;  V, S and E have their usual P-code-phase meanings.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcclexfn (f a v s e)\n (cond\n\n; First check that the lexically current function is a LEXPR.\n\n  ;; Eventually, check contour for validity of LEXPRness?\n\n  ((null (get (car name) 'lexprarg))\n   (modq body `(error \"Function call invalid in non-LEXPR\" ,f)))\n\n;\n; If no args are passed, assume first argument is NIL.\n; Otherwise, pre-macroexpand the first arg so it can be analyzed here.\n;\n\n  (t\n   (if (null a)\n       (setq a '(nil))\n       (setq a (cons (zilcomex (car a) nil) (cdr a))))\n\n;\n; Note that a null arglist will never be passed to one of the\n; internal processing functions here.\n;\n\n   (case f\n    (arg      (zcclexfn-process-arg a v s e))\n    (setarg   (zcclexfn-process-setarg a v s e))\n    (listify  (zcclexfn-process-listify a v s e))\n    (t        (zerror \"Invalid caller of ZCCLEXFN\" f)))\n\n  )))\n\n;=======================================================================\n\n (defun zcclexfn-process-arg (a v s e)\n  (cond\n   ((cdr a)\n    (modq body `(error \"Too many arguments\" 'arg)))\n   ((eq (car a) t)                            ; (ARG T)\n    (zcclexfn-process-listify '(nil) v s e))  ; compile as (LISTIFY)\n   ((null (car a))                            ; (ARG) or (ARG NIL)\n    (modq body `(begininline arg 0 ,v ,s))\n    (modq body `(inline (arg nil) 0 ,v ,s))\n   )\n   ((and (fixnump (car a))                ; (ARG n) where n is constant\n         (plusp (car a))\n         (< (car a) 1024))\n    (modq body `(begininline arg 0 ,v ,s))\n    (modq body `(inline (arg ,(car a)) 0 ,v ,s))\n   )\n   (t                                      ; (ARG anything-else)\n    (modq body `(begininline arg 1 ,v ,s)) ; compile as inline call\n    (zccevcom (car a) nil '(arg (1 arg)) e); compile load of argument\n    (modq body `(inline arg 1 ,v ,s))      ; compile as inline (ARG ...)\n   )))\n\n\n;=======================================================================\n\n (defun zcclexfn-process-setarg (a v s e)\n  (cond\n   ((null (cdr a))\n    (modq body `(error \"Too few arguments\" 'setarg)))\n   ((cddr a)\n    (modq body `(error \"Too many arguments\" 'setarg)))\n   ((and (fixnump (car a))            ; (SETARG n) where n is constant\n         (plusp (car a))\n         (< (car a) 1024))\n    (modq body `(begininline setarg 1 ,v ,s))\n    (zccevcom (cadr a) nil '(arg (1 setarg)) e);compile load of argument\n    (modq body `(inline (setarg ,(car a)) 1 ,v ,s))\n   )\n   (t                                     ; (SETARG anything-else)\n    (modq body `(begininline setarg 2 ,v ,s))  ;compile as inline call\n    (zccevcom (car a)  nil '(arg (1 setarg)) e);compile load of argument\n    (zccevcom (cadr a) nil '(arg (2 setarg)) e);compile load of argument\n    (modq body `(inline setarg 2 ,v ,s)); compile as inline (SETARG ...)\n   )))\n\n;=======================================================================\n\n (defun zcclexfn-process-listify (a v s e)\n  (cond\n   ((cdr a)\n    (modq body `(error \"Too many arguments\" 'listify)))\n   (t                                      ; (LISTIFY anything)\n    (unless (assq 'zilxlfy subrs)\n            (modq subrs (zilcosym 'zilxlfy 'subrs)))\n    (modq body `(begininline listify 1 ,v ,s)) ; compile as inline call\n    (zccevcom (car a) nil '(arg (1 listify)) e); load of argument\n    (modq body `(inline listify 1 ,v ,s)) ; compile as inline (ARG ...)\n   )))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCMKCEC": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x87\\x15\\x9f\\x00\\x89\\x15o\\x10\\x16\\x00I\\x00g\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1987-06-08T00:00:00", "modifydate": "1989-06-05T10:16:00", "lines": 73, "newlines": 103, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCCMKCEC\"\n;;;\n;;; This function is called to create a new compilation environment\n;;; contour (CEC).  The slots are defined by the DEFSTRUCT for ZILCEC\n;;; in the ZILMACS member.\n;;;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/08/88 - Support for nested GO tags.                              *\n;*                                                                     *\n;* 04/10/88 - As promised, setting of contour slots to suppress the    *\n;*            use of GO and RETURN out of FUNARGS into the FUNARG-     *\n;*            enclosing PROG has been moved from here to ZCCLAMB.      *\n;*            See ZCCLAMB for more details.                            *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;* 06/06/88 - Support for BLOCK and TAGBODY.  ZILCEC structure has     *\n;*            been extended (see ZILMACS).                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccmkcec (type e)\n\n ;;;\n ;;; E is the current list of contours (i.e. the environment).\n ;;; TYPE is the type of contour being built.\n ;;;\n ;;; Many of the fields in the current contour will be copied\n ;;; into the new one - but not all.\n ;;;\n ;;; By default, old slots are copied to the new.\n ;;; Most routines that call this function to create a new contour\n ;;; will replace these with copied lists or other stuff anyhow.\n ;;;\n\n (let* ((old-cec (if e (car e)))\n        (new-cec (if old-cec (copy-zilcec old-cec) (make-zilcec)))\n       )\n\n       (setf (zilcec-type     new-cec) type) ; Assign requested type.\n       (setf (zilcec-tempcond new-cec) nil)  ; Always starts off as\n       (setf (zilcec-permcond new-cec) nil)  ; unconditional by default.\n       (setf (zilcec-block-name new-cec) nil); No block name by default.\n\n  new-cec))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCMVBND": {"ttr": 4111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x88\\x15\\x8f\\x00\\x89\\x15o\\x10\\x17\\x00m\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1988-06-06T00:00:00", "modifydate": "1989-06-05T10:17:00", "lines": 109, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This processes MULTIPLE-VALUE-BIND.                                 *\n;*                                                                     *\n;***********************************************************************\n;\n; The key to understanding MULTIPLE-VALUE-BIND is that it is really\n; a variation on LAMBDA.  You could think of\n;\n;  (MULTIPLE-VALUE-BIND (A B C) (VALUES-FORM) (DECL1) (BODY2) (BODY3))\n;\n; as being putatively restatable as\n;\n;  ((MULTIPLE-VALUE-LAMBDA (A B C) (DECL1) (BODY2) (BODY3))\n;   (VALUES-FORM))\n;\n; The differences between this and true LAMBDA are:\n;\n;  (1)  Exactly one argument is always received by the \"procedure\".\n;  (2)  No lambda list keywords are allowed in the argument list.\n;\n; Note that this allows for ZIL's full destructuring support in the\n; argument list to MULTIPLE-VALUE-BIND, even though Common LISP does\n; not mandate this.\n;\n; Thus, this code is very similar to ZCCEVAL-CALL-LAMBDA.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccmvbnd (b v s e)\n (cond\n  ((or (null b)            ; (mvbind)\n       (null (cdr b))      ; (mvbind (a b c))\n   )\n   (modq body `(error \"Invalid syntax\" (multiple-value-bind . ,b))))\n  (t\n   (let (((mvargs mvform . mvbody) b))\n    (case (do ((args mvargs (cdr args)))\n              ((null args) nil)\n              (cond\n               ((atom args) (return 'error2))\n               ((llkeywdp (car args)) (return 'error1))))\n     ((error1)\n      (modq body `(error \"Lambda list keywords not allowed in arglist\"\n                         (multiple-value-bind . ,b))))\n     ((error2)\n      (modq body `(error \"LEXPR or REST args not allowed in arglist\"\n                         (multiple-value-bind . ,b))))\n     (t\n      (let* (\n             (mvbind-name           (gensym))\n             (mvbind-valid-p        (zilcoarg mvbind-name mvargs))\n             (mvbind-parms          (get mvbind-name 'parms))\n             (mvbind-exitlabel      (gensym))\n            )\n\n       (cond\n        ((not mvbind-valid-p)\n         (modq body `(error \"Invalid argument list\"\n                            (multiple-value-bind . ,b))))\n        (t\n\n         (putprop mvbind-exitlabel v 'vartarg)\n         (putprop mvbind-exitlabel s 'rettarg)\n\n         (unless (null mvargs)\n                 (modq body `(mvinit ,(length mvargs) nil nil)))\n\n         (zccevcom mvform\n                   nil\n                   `(mvbind (,(length mvargs) . ,(length mvbind-parms)))\n                   e)\n\n         (let ((e (cons (zccmkcec 'multiple-value-bind e) e)))\n\n          (modq body `(beginlam ,mvbind-name ,mvbind-parms ,v ,s))\n\n          ; Identify current function as owner of variables.\n\n          (dolist (x mvbind-parms)\n                  (putprop (cdr x) name 'owner))\n\n          ; Bind variables and strip declarations off body.\n\n          (setq mvbody (zcclama mvbind-name mvbind-exitlabel mvbody e))\n\n          ; Evaluate the body.\n\n          (zccprogn mvbody nil `(goto ,mvbind-exitlabel) e)\n\n          (modq body `(endlam ,mvbind-exitlabel ,mvbind-parms ,v ,s))\n\n          (modq body `(label ,mvbind-exitlabel ,v ,s))\n\n      ))))))))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCMVLST": {"ttr": 4113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x15\\x8f\\x00\\x89\\x15o\\x10\\x18\\x00-\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-06-06T00:00:00", "modifydate": "1989-06-05T10:18:00", "lines": 45, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This processes MULTIPLE-VALUE-LIST.                                 *\n;*                                                                     *\n;* (multiple-value-list <form>)   ... CLtL, p. 135                     *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccmvlst (b v s e)\n (cond\n  ((null b)\n   (modq body '(error \"Missing argument\" multiple-value-list)))\n  ((not (null (cdr b)))\n   (modq body `(error \"Too many arguments\" (multiple-value-list . ,b))))\n  (t\n   (let ((form (car b))\n         (l (gensym))\n        )\n    (putprop l v 'vartarg)     ; Establish SETQ target.\n    (putprop l s 'rettarg)     ; Establish returned-value target.\n    (putprop l t 'mvlist)      ; Identify it as MULTIPLE-VALUE-LIST\n    (putprop l '\\15 'register) ; Return value must be in register 15.\n\n    (modq body `(mvinit nil nil nil))\n    (zccevcom form nil `(mvlist ,l) e)\n    (modq body `(label ,l ,v ,s))\n\n   ))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCNOT": {"ttr": 4115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x18\\x00\\x1e\\x00\\x15\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:18:00", "lines": 30, "newlines": 21, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This compiles the \"NOT\" or \"NULL\" function.\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccnot (b v s e) ; B = body, V = variable, S = target, E = environment\n\n ;\n ; B is the headless body of the NOT/NULL form.\n ;\n ; e.g. for (NOT X), B = (X)\n ;      for (NOT (NULL X)), B = ((NULL X))\n ;\n\n (cond\n  ((null b) (modq body '(error \"Missing argument\" not/null)))\n  ((cdr b)  (modq body `(error \"Too many arguments\" (not/null . ,b))))\n  (t        (zccevcom `(cond (,(car b) nil) (t t)) v s e))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCOR": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x18\\x00\\x85\\x00e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:18:00", "lines": 133, "newlines": 101, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This compiles the \"OR\" function.\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccor  (b v s e) ; B = body, V = variable, S = target, E = environment\n (prog (a xf exitlabel settlabel fallthrulabel wayout save-tempcond)\n  (setq a b)\n  (setq wayout (if (and (null v) (consp s) (zilcovta s))\n                   (car s)\n                   nil))\n\n  (or a       (return (modq body `(setnil nil ,v ,s)))) ; (OR)   -> NIL\n  (or (cdr a) (return (zccevcom (car a) v s e)))        ; (OR x) -> x\n\n  (if   (eq wayout 'gonil)\n   then\n        (setq fallthrulabel (gensym))\n   else\n   if   (eq wayout 'gonotnil)\n   then\n        ; nothing\n   else\n        (setq exitlabel (gensym))\n        (putprop exitlabel v 'vartarg)\n        (putprop exitlabel s 'rettarg)\n   endif\n  )\n\n  (setq save-tempcond (zilcec-tempcond (car e)))\n\n loop\n\n  (setq xf (zccpred (car a)))\n\n  (if (notp xf)\n   then\n    (zccevcom (cadr xf)\n              nil\n              (if   (eq wayout 'gonotnil)\n               then `(gonil ,(cadr s))\n               else\n               if   (eq wayout 'gonil)\n               then (if (null (cdr a))\n                     then `(gonotnil ,(cadr s))\n                     else\n                          `(gonil ,fallthrulabel)\n                     endif\n                    )\n               else `(gonil ,(or settlabel\n                                 (setq settlabel (gensym))))\n               endif)\n              e)\n    (or (eq wayout 'gonil)                 ; if non-predicative\n        (cdr a)                            ; and (OR ... (NOT x))\n                                           ; then generate a NIL\n        (modq body `(setnil nil nil (goto ,exitlabel))))\n   else\n    (zccevcom (if (eq wayout 'gonil) xf (car a))\n              nil\n              (if   (eq wayout 'gonotnil)\n               then `(gonotnil ,(cadr s))\n               else\n               if   (eq wayout 'gonil)\n               then (if (null (cdr a))\n                     then `(gonil ,(cadr s))\n                     else\n                          `(gonotnil ,fallthrulabel)\n                     endif\n                    )\n               else (if (null (cdr a))\n                     then (putprop exitlabel t 'forceniltest)\n                          `(goto ,exitlabel)\n                     else\n                     if   (predp xf)\n                     then `(gonotnil ,(or settlabel\n                                          (setq settlabel (gensym))))\n                     else\n                          `(gonotnil ,exitlabel)\n                     endif\n                    )\n               endif)\n              e)\n   endif\n  )\n\n  (when (setq a (cdr a))\n        (setf (zilcec-tempcond (car e)) t) ; All forms other than first\n        (go loop))                         ; are conditionally executed\n\n  (when settlabel\n        (modq body `(label ,settlabel nil nil))\n        (modq body `(sett t nil (goto ,exitlabel))))\n  (setf (zilcec-tempcond (car e)) save-tempcond)\n  ;\n  ; The code below must be unconditional (at least as unconditional as\n  ; things were on entry to the OR form) - after all, it does the\n  ; V and S stuff, which can be skipped only under certain circumstances\n  ;\n  (when exitlabel\n        (modq body `(label ,exitlabel ,v ,s)))\n  (when fallthrulabel\n        (modq body `(label ,fallthrulabel nil nil)))\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCPRED": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10\\x19\\x00>\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:19:00", "lines": 62, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; ZCCPRED\n;;;\n\n;\n; This function takes a predicate (as occurring in a COND, AND or OR)\n; and returns an equivalent form by doing the following to it:\n;\n; (1) macroexpanding it\n; (2) converting NULL to NOT\n; (3) eliminating nested negations (NOT/NULL)\n;\n; so that, for example, (NOT (NULL X)) is transformed to X\n; (NULL (FOO)) --> (NOT (FOO))\n; and (NOT (CONSP X)) --> (NOT (NOT (ATOM X))) --> (ATOM X)\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccpred (form)\n (cond\n  ((atom form) form)\n  ((not (symbolp (car form))) form)\n  ((and (or (get (car form) 'cmacro)\n            (get (car form) 'macro))\n        (not (get (car form) 'cexpr)))\n   (zccpred (zilcomex form nil)))\n  ((eq (car form) 'null)    (zccpred `(not . ,(cdr form))))\n  ((eq (car form) 'not)\n   (let (\n         (notargs (cdr form))\n        )\n    (cond\n     ((null notargs)\n      (modq body '(error \"Missing argument\" not/null))\n      form)\n     ((cdr notargs)\n      (modq body `(error \"Too many arguments\" (not/null . ,notargs)))\n      form)\n     (t\n      (let (\n            (newarg (zccpred (car notargs)))\n           )\n           (if (and (consp newarg)\n                    (eq (car newarg) 'not)\n                    (cdr newarg))\n               (cadr newarg)\n               (list (car form) newarg)))))))\n  (t form)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCPROGN": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10 \\x00\\x19\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:20:00", "lines": 25, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles the \"PROGN\" function inline.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccprogn (b v s e) ; B = body\n (cond\n  ((null b)        (modq body `(setnil nil ,v ,s)))\n  ((null (cdr b))  (zccevcom (car b) v s e))\n  (t               (zccevcom (car b) nil nil e)\n                   (zccprogn (cdr b) v s e))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCQUOTE": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10 \\x00\\x1b\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:20:00", "lines": 27, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles code to create and access constant values.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccquote (b v s e) ; B is the body...\n (cond\n  ((null b)\n             (modq body '(error \"Missing argument\" quote)))\n  ((cdr b)\n             (modq body '(error \"Too many arguments\" quote)))\n  (t\n             (zccconst (car b) v s e))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCRETF": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x88\\x15\\x8f\\x00\\x89\\x15o\\x10!\\x001\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1988-06-06T00:00:00", "modifydate": "1989-06-05T10:21:00", "lines": 49, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This processes RETURN-FROM.                                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccretf (b e)  ; B = body, E = environment\n (cond\n  ((null b)\n   (modq body '(error \"Missing block name\" return-from)))\n  ((null (cdr b))\n   (process-return-from (car b) nil e))\n  ((null (cddr b))\n   (process-return-from (car b) (cadr b) e))\n  (t\n   (modq body `(error \"Too many arguments\" (return-from . ,b))))))\n\n(defun process-return-from (rfname rfform e &aux p)\n (setq p (cdr (assq rfname (zilcec-return-tags (car e)))))\n (cond\n  ((null p)\n   (modq body `(error \"No BLOCK by this name to RETURN-FROM\" ,rfname)))\n  (t\n   (zccevcom rfform nil `(goto ,p) e)\n   ;\n   ; All contours up to AND INCLUDING the contour associated with the\n   ; RETURN-FROM are marked permanently conditional.\n   ;\n   (loop with c = (get p 'contour)\n         for cec in e\n         do (setf (zilcec-permcond cec) t)\n         until (eq cec c)))))              ; Note placement of UNTIL!!!\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCSETQ": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10!\\x00o\\x00V\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:21:00", "lines": 111, "newlines": 86, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles the \"SETQ\" function.\n;;; It is implemented as a call to the \"ZCCEVCOM\" pseudocode\n;;; which will ultimately generate code to assign the return value\n;;; (generally by doing just a store operation, retaining the value\n;;; in the register in which it was found).\n;;; The third argument of the pseudocode will be a list of one or more\n;;; of the following:\n;;;  1. A dotted pair consisting of a variable name and a symbol\n;;;     (typically a GENSYM symbol), representing a local binding.\n;;;  2. A single atom, representing an unbound variable.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccsetq (b v s e)\n (prog (var val)\n       (if   (null b)\n        then (return (modq body `(setnil nil ,v ,s))))\n  loop (or (cdr b)\n           (return (modq body '(error \"Odd number of arguments\" setq))))\n       (desetq (var val . b) b)\n       (if   b\n        then\n             (compile-setq var val nil nil e) ; Not the last pair\n             (go loop)\n        else\n             (compile-setq var val v s e)     ; Last pair\n             (return nil)\n        endif\n       )))\n\n(defun compile-setq (var val v s e)\n (cond\n  ((or (null var)\n       (not (symbolp var))\n       ; otherwise-self-evaluating-or-constant-p var...\n       (eq (pbind var) var))\n   (modq body `(error \"SETQ variable invalid\" ,var)))\n  (t\n   (let (binding newsetq)\n    (if (setq binding (assq var (zilcec-bindings (car e))))\n     then\n        (setq newsetq binding)\n     else\n        (setq binding (zilcoauv var e))\n        (putprop (cdr binding) t 'mustinit)\n        (setq newsetq var)\n     endif\n    )\n\n    ; Make a list of SETQ vars in case of nested SETQ assignments,\n    ; and evaluate the form that SETQ's them.\n\n    (zccevcom val (cons newsetq v) s e)\n\n    ; If the variable is local, and it has been set UNCONDITIONALLY\n    ; possibly before being referenced, then mark it as such.  For\n    ; this to be the case, all contours from the current one down to\n    ; AND INCLUDING the binding's contour must be in an \"unconditional\"\n    ; state, and the variable must not have the status of requiring\n    ; initialization.\n\n    (when debug\n          (putdata newsetq (plist (cdr newsetq)))\n    )\n\n    (when (and (consp newsetq)\n               (not (get (cdr newsetq) 'mustinit)))\n          (let ((c (get (cdr newsetq) 'contour)))\n               (loop for cec in e\n                     (when debug (putdata cec))\n                     when (or (zilcec-tempcond cec)\n                              (zilcec-permcond cec))\n                     do   (return)\n                     when (eq cec c)\n                     do   (putprop (cdr newsetq) t 'set)\n                          (return)\n               )))\n\n   ))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCTBODY": {"ttr": 4365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x88\\x15\\x8f\\x00\\x89\\x15o\\x10\"\\x00s\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1988-06-06T00:00:00", "modifydate": "1989-06-05T10:22:00", "lines": 115, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This processes TAGBODY.                                             *\n;*                                                                     *\n;***********************************************************************\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcctbody (b v s e)\n\n (let (\n       (e (cons (zccmkcec 'tagbody e) e)) ; new environment contour\n       (tagexit (gensym))  ; dummy label to which the TABBODY can refer\n       (golist)            ; the list of tags, in ALIST format\n       (lastform)          ; the last form in the TAGBODY\n      )\n\n ; Set label properties.\n\n   (putprop tagexit v 'vartarg)\n   (putprop tagexit s 'rettarg)\n   (putprop tagexit (car e) 'contour)\n\n ; Tell the generator to reserve stack space.\n\n   (modq body `(begintag ,tagexit ,v ,s))\n\n ; Build the GO list.\n\n   (setq golist\n         (loop for x in b\n               with z = nil\n               when (and x (or (symbolp x) (integerp x)))\n                 when (assoc x z)\n                 do   (modq body `(error \"Duplicate GO tag\" ,x))\n                 else collect (cons x (gensym)) into z\n               finally (return z)))\n\n ; Assign properties to all GO tags,\n ; including pointers to the dummy exit label.\n\n   (loop for (tag . label) in golist do\n    (putprop label tagexit  'progexit)\n    (putprop label tag      'gotag)\n    (putprop label (car e)  'contour)\n   )\n\n ;\n ; Add the GO tags to the current contour.\n ;\n   (setf (zilcec-go-tags (car e))\n         (append golist (zilcec-go-tags (car e))))\n\n ; Loop until end of forms.  For each form in the TAGBODY body...\n ; If form is an atom, then it is a label, so generate a label whose\n ; name is the one specified on the GO list.\n ; Otherwise, generate code to evaluate the form.\n\n   (dolist (form b)\n    (cond\n     ((null form) nil)      ; Ignore NIL's in a TAGBODY body.\n     ((or (symbolp form)    ; Compile symbols as tags\n          (integerp form))  ; Compile integers as tags\n      (setq lastform form)\n      (let ((l (cdr (assoc lastform golist))))\n           (putprop l t 'referenced)\n           (modq body `(label ,l nil nil))))\n     ((atom form)           ; Atomic but not a symbol or integer - error\n      (modq body `(error \"Invalid tag found in TAGBODY\" ,form)))\n     (t                     ; Otherwise compile it as is\n      (setq lastform (zilcomex form nil))\n                           ; Compile code without using the return value\n      (zccevcom lastform nil nil e))))\n\n ; If the TAGBODY doesn't end with a GO or RETURN-FROM, then\n ; make it return NIL.  Note that this is very simple-minded and doesn't\n ; deal with things like all paths of a COND returning or going, etc.\n\n   (unless (and (consp lastform)\n                (memq (car lastform) '(return-from go)))\n           (modq body `(setnil nil nil (goto ,tagexit))))\n\n ; Balance out the BEGINTAG above for the code generator.\n\n   (modq body `(endtag ,tagexit ,v ,s))\n\n ; Generate return label code.\n\n   (modq body `(label ,tagexit ,v ,s))\n\n ))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCTHROW": {"ttr": 4367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x16_\\x00\\x89\\x15o\\x10\"\\x00\\x1e\\x00\\x16\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-13T00:00:00", "modifydate": "1989-06-05T10:22:00", "lines": 30, "newlines": 22, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles the \"THROW\" special form inline.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccthrow (b v s e)\n (cond\n  ((or (null b)\n       (null (cdr b))\n       (cddr b))\n   (modq body `(error \"Invalid syntax\" `(throw . ,b))))\n  (t\n   (let (((tag form) b))\n        (zccevcom tag  nil '(throw tag) e)\n        (zccevcom form nil '(throw form) e)\n   ))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCUWP": {"ttr": 4369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10#\\x00\\xa2\\x00Z\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:23:00", "lines": 162, "newlines": 90, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This compiles the \"UNWIND-PROTECT\" special form inline.\n;;;\n;;; The code works something like this:\n;;;\n;;;\n ; (unwind-protect (protected-form) (cleanup-form1) (cleanup-form2))\n ;\n ; generates:\n\n#|--------------------------------------------------------------------|\n         L     14,ZLCCATCH         Address of current catch frame     |\n         ST    14,frame+0(,11)     Store into new frame               |\n         L     14,ZLCSALST         Save special ALIST                 |\n         L     15,ZLCFALST         Save fluid ALIST                   |\n         XR    0,0                 Tag slot = hex zeroes              |\n         LA    1,label1            Address of cleanup forms code      |\n         STM   11,1,frame+4(11)    Save stack, base, etc. into frame  |\n         LA    14,label2           Address to return to after cleanup |\n         ST    14,frame+12(,11)    Store into new frame               |\n         LA    14,frame+0(,11)     Address of new frame               |\n         ST    14,ZLCCATCH         Make it the active catch frame     |\n ... code to evaluate protected-form ...                              |\n ... which returns a value in register r1 ...                         |\n         NOP   label2              (for future multiple value support)|\n         ST    r1,frame+32(,11)    Save return value in frame         |\nlabel1   DS    0H                  Fall thru or branch from THROW     |\n         L     14,frame+0(,11)     Get previous catch frame address   |\n         ST    14,ZLCCATCH         Unhook this, make previous active  |\n ... code to evaluate cleanup-form1 ...                               |\n ... code to evaluate cleanup-form2 ...                               |\n         LA    14,frame+0(,11)     Set address of this frame          |\n         L     15,frame+12(,11)    Load return address                |\n         BR    15                  Fall through or return to THROW    |\nlabel2   DS    0H                  Continue here if no THROW          |\n         L     r2,frame+32(,11)    Load value from protected-form     |\n----------------------------------------------------------------------|#\n\n; The structure of the unwind-protect frame is as follows.\n;\n; frame+0  (+x'00')  Address of previous CATCH/UWP frame (zero if none)\n; frame+4  (+x'04')  Saved register 11 (stack pointer from catcher)\n; frame+8  (+x'08')  Saved register 12 (base register from catcher)\n; frame+12 (+x'0C')  Return address (to branch to following catch)\n; frame+16 (+x'10')  Saved special alist (variable binding stack)\n; frame+20 (+x'14')  Saved fluid alist (variable binding stack)\n;\n; frame+24 (+x'18')  Zero for UNWIND-PROTECT; the tag for CATCH\n;\n; The following fields are present only in UNWIND-PROTECT frames:\n;\n; frame+28 (+x'1C')  Address of the cleanup forms code to invoke\n;                    (during unwind, contains the tag being thrown to)\n; frame+32 (+x'20')  Return value stored from evaluating protected form\n;                    (during unwind, contains return value from THROW)\n; End of frame.\n;\n\n;\n; For more information, see ZILTHROW.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/06/88 - Support for GO tag optimization.                         *\n;* 04/08/88 - Support for GO and RETURN out of UNWIND-PROTECT.         *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;* 06/16/88 - Support for multiple values, in that information is put  *\n;*            on the label to record the use of the return value.      *\n;* 11/01/88 - Bug fix - if the protected form never returns.           *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccuwp (b v s e)\n (prog (protected-form       ; Arg 1 to UNWIND-PROTECT\n        cleanup-forms        ; Arg 2 to UNWIND-PROTECT\n        label1               ; a label to be used by the generated code\n        label2               ; a label to be used by the generated code\n        label3               ; a label to be used by the generated code\n       )\n\n;;; Syntax check and set locals.\n\n  (or b\n      (return (modq body\n                    '(error \"Missing protected form\" unwind-protect))))\n  (or (cdr b)\n      (return (modq body\n                    '(error \"Missing cleanup forms\" unwind-protect))))\n\n  (desetq (protected-form . cleanup-forms) b)\n\n;;; Create labels to be used in code generation.\n;;; Note:  No properties need be set for the labels, for they are not\n;;;        processed by the normal ZILCO label handling.\n\n  (setq label1 (gensym)\n        label2 (gensym)\n        label3 (gensym))\n\n  (putprop label1 label2 'uwplabel)\n\n  (putprop label1 v 'vartarg) ; Info used when compiling VALUES.\n  (putprop label1 s 'rettarg) ; Info used when compiling VALUES.\n\n;;; Generate P-code.\n\n  (modq body `(beginuwp ,label1 ,label2 ,v ,s)) ; Initialize UWP frame.\n  ;\n  ; Set up a contour to prevent overoptimizing GO's (see ZCCCOND).\n  ; This needs to surround only the protected form.\n  ;\n  ; Protected forms within an UNWIND-PROTECT are considered conditional\n  ; because a non-local exit may occur at any point, causing execution\n  ; to continue beyond the scope of the protected forms without any of\n  ; the code inside being executed.  This does not apply to cleanup\n  ; forms, however.\n  ;\n  (let ((e (cons (zccmkcec 'unwind-protect e) e)))\n   (setf (zilcec-permcond (car e)) t)\n\n; 11/01/88 bug fix...\n\n;;;(zccevcom protected-form nil `(uwp ,label1) e)  ; Protected form.\n   (zccevcom protected-form nil `(goto ,label3) e) ; Protected form.\n  )\n\n; 11/01/88 bug fix...\n  (putprop label3 t 'referenced) ; Force generation.\n  (modq body `(label ,label3 nil (uwp ,label1))) ; Process returns.\n\n  (zccprogn cleanup-forms nil nil e)        ; Evaluate cleanup forms.\n\n  (modq body `(enduwp ,label2 ,v ,s))       ; Finish up UWP processing.\n\n ) ; end PROG\n) ; end DEFUN ZCCUWP\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZCCVALGO": {"ttr": 4372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x89\\x15o\\x10#\\x00?\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1989-06-05T10:23:00", "lines": 63, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* ZCCVALGO                                                            *\n;*                                                                     *\n;* Created 04/06/88.                                                   *\n;*                                                                     *\n;* This function is called by ZCCGO and ZCCCOND to validate and        *\n;* return a GO tag found in a GO special form.  If the GO tag is       *\n;* missing or invalid, an error is generated into the P-code and       *\n;* NIL is returned.  Otherwise, the pair identifying the GO tag        *\n;* is returned for the caller to use in generating P-code.             *\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/08/88 - Support for nested GO's.                                 *\n;* 04/10/88 - Uses contour to validate PROG env. instead of PROGEXIT.  *\n;* 06/07/88 - Support for TAGBODY.                                     *\n;*                                                                     *\n;***********************************************************************\n;\n; Check for existing PROG removed, so no more \"GO outside of PROG\"\n; error message.  Instead, you just get \"GO tag undefined\", because\n; either PROG or TAGBODY should be present, but there's no direct\n; indication of the absence of both in the contour chain, and it's\n; not worth searching for if we only have to look at the current\n; list of GO tags.  Am I being too windy?\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccvalgo (b e) ; B = (tag) body of GO, E = environment\n (let ((x) (p))       ; X = label name, P = GO tag pair\n  (cond\n   ((null b)\n    (zccvalgo-error \"Missing argument\" 'go))\n   ((cdr b)\n    (zccvalgo-error \"Too many arguments\" 'go))\n   ((not (or (symbolp (setq x (car b)))\n           (integerp x)))\n    (zccvalgo-error \"GO tag not a symbol or integer\" x))\n   ((not (setq p (assoc x (zilcec-go-tags (car e)))))\n    (zccvalgo-error \"GO tag undefined\" x))\n   (t\n    p))))\n\n(defun zccvalgo-error (msg &optional info)\n ; Codify an error and return NIL\n (modq body `(error ,msg ,info))\n nil)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCCVALS": {"ttr": 4374, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x15\\x8f\\x00\\x89\\x15o\\x10$\\x00;\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-06-06T00:00:00", "modifydate": "1989-06-05T10:24:00", "lines": 59, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This routine compiles VALUES invocations.  It is similar to\n;;; ZCCEVAL, except that the number of args is not checked.\n;;;\n;;; VALUES is considered to be an \"inline\" function, since the\n;;; generated code consists of a call to the ZILSUBS routine\n;;; ZILVALS, with appropriate registers set.  Examples:\n;;;\n;;; (VALUES a b c)\n;;;\n;;;          L     #0,a\n;;;          ST    #0,xxx+0(,#11)\n;;;          L     #0,b\n;;;          ST    #0,xxx+4(,#11)\n;;;          L     #0,c\n;;;          ST    #0,xxx+8(,#11)\n;;;          XR    #0,#0               tells VALUES to scan & return\n;;;          LA    #1,xxx(,#11)        stack location of values\n;;;          LA    #2,3                number of values\n;;;          L     #15,ZLCVALS\n;;;          BALR  #14,#15             Call ZILVALS\n;;;\n;;; In the case of (VALUES <form>), where exactly one value is\n;;; being returned, the call to ZILVALS can be optimized out,\n;;; since this behavior is essentially the same as a form returning\n;;; one value \"normally\".  However, in case such a call occurs in\n;;; tail-recursive position, we must force single-value-returning.\n;;; This is done as follows:\n;;;\n;;; (VALUES form)\n;;;\n;;;          L     #15,form            Evaluate the form\n;;;          LR    #15,#15             Force single-value return\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zccvals (args v s e &aux (l (length args)))\n (modq body `(begininline values ,l ,v ,s))\n (do ((args args (cdr args))\n      (i 1 (1+ i))\n     )\n     ((null args))\n     (zccevcom (car args) nil `(arg (,i values)) e)\n )\n (modq body `(inline values ,l ,v ,s)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGAVAIL": {"ttr": 4376, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10%\\x00\\x10\\x00\\x07\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:25:00", "lines": 16, "newlines": 7, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgavail (r) (zerop (get r 'usecount)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGBASE": {"ttr": 4378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10%\\x00a\\x00M\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:25:00", "lines": 97, "newlines": 77, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This function generates code to (re)load additional base registers. *\n;* It is invoked only when a function has a BASEREG property.          *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgbase (naym usingp)\n (case usingp\n       ((nil) (push nil codelist))\n       (t     (zerror \"ZCGBASE called with USINGP. No longer valid.\"))\n )\n)\n\n;\n; Old code, no longer in use.\n;\n;(defun zcgbase (naym usingp &aux b g)\n;(setq b (get (car naym) 'basereg))\n;(case b\n; ((nil 1)) ; do nothing\n; (2\n;    (zcgenout nil \"LA\"   \"7,4095(,12)\"    \"Load second base register.\")\n;    (if usingp\n;        (zcgenout nil \"USING\" `(,(cdr naym) \"+4095,7\")            nil))\n; )\n; (3\n;    (setq g (zcgbase-label b naym usingp))\n;    (zcgenout nil \"LM\" `(\"6,7,\" ,g)  \"Load additional base registers.\")\n;    (if usingp\n;        (zcgenout nil \"USING\" `(,(cdr naym) \"+4096,7,6\")          nil))\n; )\n; (4\n;    (setq g (zcgbase-label b naym usingp))\n;    (zcgenout nil \"LM\" `(\"5,7,\" ,g)  \"Load additional base registers.\")\n;    (if usingp\n;        (zcgenout nil \"USING\" `(,(cdr naym) \"+4096,7,6,5\")        nil))\n; )\n; (t (error \"Invalid base register specification\" b))\n;))\n;\n;\n;(defun zcgbase-label (b naym usingp &aux lbl1 lbl2 adcons)\n;(when usingp\n; (putprop (cdr naym) (setq lbl1 (gensym)) 'baselabel)\n; (zcgenout nil \"B\" (setq lbl2 (gensym)) \"Branch around base adcons.\")\n; (setq adcons\n;       (case b\n;             (3 (string-append \"A(\" (cdr naym) \"+8192,\"\n;                                    (cdr naym) \"+4096)\"))\n;             (4 (string-append \"A(\" (cdr naym) \"+12288,\"\n;                                    (cdr naym) \"+8192,\"\n;                                    (cdr naym) \"+4096)\"))\n;       ))\n; (zcgenout lbl1 \"DC\" adcons nil)\n; (zcgenout lbl2 \"DS\" \"0H\"   nil)\n;)\n;(get (cdr naym) 'baselabel)\n;)\n;\n;\n;\n; Even older code, no longer in use.\n;\n;;(when (integerp b)\n;;\n;; (when (> b 1)\n;;  (zcgenout nil \"LA\"    \"7,4095(,12)\"    \"Load second base register.\")\n;;  (if usingp\n;;   (zcgenout nil \"USING\" `(,(cdr naym) \"+4095,7\")                nil))\n;;  (when (> b 2)\n;;   (zcgenout nil \"LA\"    \"6,4095(,7)\"     \"Load third base register.\")\n;;   (if usingp\n;;    (zcgenout nil \"USING\" `(,(cdr naym) \"+8190,6\")               nil))\n;;   (when (> b 3)\n;;    (zcgenout nil \"LA\"   \"5,4095(,6)\"    \"Load fourth base register.\")\n;;    (if usingp\n;;     (zcgenout nil \"USING\" `(,(cdr naym) \"+12285,5\")             nil))\n;;\n;;  ))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGBCALL": {"ttr": 4610, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10%\\x00*\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:25:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-BEGINCALL                                                      *\n;*                                                                    *\n;* Note: Also used for BEGININLINE and BEGINTAIL at this time, but... *\n;*                                                                    *\n;**********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgbcall (a) ;\n (prog\n       (\n;;;;    b   ; the name of the subroutine or inline code being called\n;;;;    n   ; the number of arguments passed to the function\n;;;;    v   ; an item to receive the value if SETQ is involved\n;;;;    s   ; the target of the value to be set\n       )\n\n;;;;   (desetq (nil b n v s) a)\n\n       ; New code generation contour with...\n\n       (push (car pdmax) argbase)  ; Base for function call arguments\n       (push (car pdmax) pdmax)    ; Height of stack used\n\n       ; ... initialized to current top-of-stack.\n\n ))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGBEGIN": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x005\\x00\\x87\\x05O\\x01\\x00\\x10_\\t\\x07\\x01\\xf8\\x01\\xe2\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "2000-04-14T09:07:35", "lines": 504, "newlines": 482, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-BEGIN                                                          *\n;*                                                                    *\n;**********************************************************************\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;* 04/14/2000 - Support for HLASM USING checking.                      *\n;*                                                                     *\n;***********************************************************************\n;\n;\n; Notes:\n;\n;   MAIN and ALONE are \"special\" variables (see ZILMACS).\n;\n;   To support correct processing for tail recursion out of an\n;   environment with its own special variable bindings, we use two\n;   labels for tail recursion to branch to:  one for normal tail\n;   recursion where no variable bindings need be changed, and one\n;   for tail recursion where variable bindings must be\n;   reestablished.  In order to do this, we had to separate the\n;   saving of the current alists from the building of the new\n;   alists.  Also, saving the current alists must be done in some\n;   cases even if the function's own arguments are not \"special\"\n;   or \"pseudolexical\".\n;\n;***********************************************************************\n;*\n;* NOTE!!! The code generated for LEXPR's is tested for by the garbage\n;* collector in ZILCONS.  IF YOU CHANGE ONE YOU MUST CHANGE THE OTHER!!\n;*\n;***********************************************************************\n;\n;***********************************************************************\n;*\n;* NOTE!!! The initial value for CODELEN is based on the size of the\n;* code generated by the #ZBEG macro.  IF YOU CHANGE THE #ZBEG MACRO\n;* YOU MUST CHANGE THIS HERE TOO!!!\n;*\n;***********************************************************************\n;\n;=======================================================================\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgbegin (a)\n (prog (name args nargs adconp)\n  (desetq (name args main alone) a)\n  (setq nargs (length args))\n  (setq pdbas\n        (if (get (car name) 'lexprarg)\n            4\n            (* nargs 4)))           ; top of passed argument list\n  (setq stack (+ pdbas 12))         ; top of standard interface save\n\n  (setq adconp                      ; True if ZILSINT needs to be called\n   (if main\n    then\n       (and alone\n            (or\n             (cdr lists) (cdr alfatoms) (cdr numatoms) (cdr alllists)\n            ))\n    else\n       (or (cdr lists) (cdr atoms))\n    endif\n   ))\n\n  (when (or adconp (and main (not alone)))\n        (setf (get (cdr name) 'zzzptrs ) (if main \"ZLBPTRS\" (gensym)))\n        (setf (get (cdr name) 'zzzatoms) (if main \"ZILATOM\" nil     ))\n        (setf (get (cdr name) 'zzzlists) (if main \"ZILLIST\" (gensym)))\n  )\n;\n; Assign offsets to all args.\n;\n  (loop for arg in args\n   (setf (get (cdr arg) 'offset)\n         (* (1- (get (cdr arg) 'position)) 4)))\n\n;\n; Assign location names to all subrs.\n;\n  (mapc #'assign-location (cdr subrs))\n;\n; Assign location names to all atoms.\n;\n  (if main\n   then     ; Every atom has to have a location known to the main proc.\n    (mapc #'assign-location (cdr numatoms))\n    (mapc #'assign-location (cdr alfatoms))\n   else     ; Internal subfunction. Assign new locations to atoms.\n    (mapc #'assign-location (cdr atoms))\n   endif\n  )\n;\n; If subroutines are known,\n;  or if there are unbound specials (which will cause either ZILVSYM\n;  or ZILVSET to be called, in this deep-binding implementation),\n;  then it is probable that one of the special subroutines will have to\n;  be included.\n; Even if we're wrong, set up a label for the subroutine addresses so\n;  we're ok for loading of the special subroutines by ZILLOAD.\n;\n\n  (setf (get (cdr name) 'zzzsubrs)\n        (if (or (cdr subrs) (cdr special-unbounds)) (gensym) nil))\n;\n; Begin code generation.\n;\n  (zcgbegin1 nargs)\n;\n; Generate code to intern and initialize constants if required,\n; and to save the current alist pointers if required.\n;\n  (zcgbegin2 adconp)\n;\n; Generate code to retrieve values of free variables.\n;\n  (zcgbegin3)\n\n;\n; End variable setting code.\n;\n; Establish a label to which tail recursion can branch.\n;\n  (zcgemit 0 zzzcont \"DS\" \"0H\" nil)\n;\n; Reset stack offsets.\n;\n  (setq stackmax  (if (or (car special-asaved)\n                          (car fluid-asaved))\n                      (+ stack 8)\n                      stack)\n        pdmax     (ncons stack)\n        argbase   (ncons stack))\n\n ) ; end PROG\n) ; end DEFUN ZCGBEGIN\n\n;=======================================================================\n\n; NOTE! Use of '* (the symbol with a print name of *) means that an\n; asterisk is to be inserted in column 72 as a continuation character\n; by ZCGENOUT.  Do not use a string there!\n\n(defun zcgbegin1 (nargs)\n (prog (mina maxa rest zzzsubrs zzzptrs zzzatoms zzzlists\n                       pdsize vssize cssize acsize)\n  (setq mina     (or (get (car name) 'minargs) nargs)\n        maxa     (or (get (car name) 'maxargs) nargs)\n        rest     (get (car name) 'restarg)\n        zzzsubrs (get (cdr name) 'zzzsubrs)\n        zzzptrs  (get (cdr name) 'zzzptrs )\n        zzzatoms (get (cdr name) 'zzzatoms)\n        zzzlists (get (cdr name) 'zzzlists)\n        pdsize   (get '*zilco*   'pdsize)\n        vssize   (get '*zilco*   'vssize)\n        cssize   (get '*zilco*   'cssize)\n        acsize   (get '*zilco*   'acsize))\n\n  (setq codelen\n   (cond\n    ((and main (not alone))\n     44)\n    (t\n     (* 4 (quotient (+ #.(+ 25 3) (string-length (car name))) 4)))))\n\n  (zcgenout nil \"TITLE\"\n               `(\"'\" ,(cdr name) \" - source generated by ZIL 1.3'\") nil)\n\n  (and alone (go aloneyes))\n\n  (and main (go mainyes))\n\n mainno ; MAIN = NO, ALONE = NO: Subrte internal to executable program\n\n  (zcgenout (cdr name) \"#ZBEG\" \"MAIN=NO,TYPE=PROGRAM,\"              '* )\n\n  (go gen-minargs-and-maxargs)\n\n mainyes ; MAIN = YES, ALONE = NO: Main procedure of executable program\n\n  (zcgenout (cdr name) \"#ZBEG\" \"MAIN=YES,TYPE=PROGRAM,\"             '* )\n  #+XA (zcgenout nil nil \"RMODE=24,AMODE=31,\"                       '* )\n  (when pdsize\n        (zcgenout nil nil `(\"PDSIZE=\" ,pdsize \",\") '* ))\n  (when vssize\n        (zcgenout nil nil `(\"VSSIZE=\" ,vssize \",\") '* ))\n  (when cssize\n        (zcgenout nil nil `(\"CSSIZE=\" ,cssize \",\") '* ))\n  (when acsize\n        (zcgenout nil nil `(\"ACSIZE=\" ,acsize \",\") '* ))\n\n  (go nameonly)\n\n aloneyes\n\n  ; MAIN = YES, ALONE = YES: Eponymous loadable function\n  ; MAIN = NO, ALONE = YES: Subrte internal to loadable function\n\n  (zcgenout (cdr name) \"#ZBEG\" (if main \"MAIN=YES,TYPE=FUNCTION,\"\n                                        \"MAIN=NO,TYPE=FUNCTION,\")   '* )\n\n  (when zzzsubrs\n   (zcgenout nil nil `(\"SUBRS=\" ,zzzsubrs \",\")                      '* )\n   (incf codelen 8)\n  )\n\n gen-minargs-and-maxargs\n\n  (when zzzptrs\n   (zcgenout nil nil `(\"PTRS=\" ,zzzptrs \",\")                        '* )\n   (incf codelen 16)\n  )\n\n  (when (or zzzatoms zzzlists)\n    (zcgenout nil nil `(\"ATOMS=\" ,zzzatoms \",LISTS=\" ,zzzlists \",\") '* )\n  )\n\n  (if (get (car name) 'lexprarg)\n   then\n        (zcgenout nil nil \"LEXPR=T,\"                                '* )\n   else\n        (zcgenout nil nil `(\"MINARGS=\" ,mina \",\")                   '* )\n        (zcgenout nil nil `(\"MAXARGS=\" ,maxa \",\")                   '* )\n        (zcgenout nil nil `(\"RESTARG=\" ,(if rest t nil) \",\")        '* )\n   endif\n  )\n\n nameonly\n\n  (zcgenout nil      nil `(\"NAME=\" ,(quoted (car name)))            nil)\n\n  (if (get (car name) 'lexprarg)\n\n   then\n\n    (zcgenout nil  \"L\"     \"2,0(,1)\"        \"Get pointer to LEXPR arg.\")\n    (zcgenout nil  \"L\"     \"2,##CDR(,2)\"    \"Get fixnum value thereof.\")\n    (zcgenout nil  \"SLA\"   \"2,2\"                    \"Multiply it by 4.\")\n    (zcgenout nil  \"LA\"    `(\"0,\" ,zzzstksz \"+4(2,1)\")\n                                            \"Determine max stack size.\")\n    (zcgenout nil  \"#ZPDS\" \"(0)\"             \"Signal error if no room.\")\n    (zcgenout nil  \"LR\"    \"0,1\" \"Get pointer to original stack frame.\")\n    (zcgenout nil  \"LA\"    \"1,4(2,1)\" \"Get pointer to new stack frame.\")\n    (zcgenout nil  \"ST\"    \"0,0(,1)\"    \"Store indirect stack pointer.\")\n\n    ; Sorry, but we have to make it come out to a fullword boundary\n    ; because if several base register adcons have to be inserted\n    ; later on, we can't have an additional 2 bytes inserted because\n    ; of inline adcons.  Thus, the 2-byte no-operation instruction.\n\n    (zcgenout nil  \"NOPR\"  \"0\"              \"Insure fullword boundary.\")\n\n    (incf codelen 32)\n\n   else\n\n    (zcgenout nil   \"#ZPDS\" zzzstksz       \"Define maximum stack size.\")\n\n    (incf codelen 8)\n\n   endif\n  )\n\n  (zcgenout nil     \"STM\"   `(\"11,12,\" ,pdbas \"(1)\")\n                                       \"Save stack and base registers.\")\n  (zcgenout nil     \"ST\"    `(\"14,\" ,(+ pdbas 8) \"(,1)\")\n                                                \"Save return register.\")\n  (zcgenout nil     \"LR\"    \"12,15\"             \"Set up base register.\")\n;;;\n;;; DROP must precede USING, else HLASM will report a warning/error.\n;;;\n  (zcgenout nil     \"DROP\"  \"15\"                                    nil)\n  (zcgenout nil     \"USING\" `(,(cdr name) \",12\")\n                                            \"Establish addressability.\")\n  (zcgenout nil     \"LR\"    \"11,1\"                 \"Set up stack base.\")\n\n  (incf codelen 12)\n\n;;;\n;;;(zcgbase name t) ; Assign additional base registers if applicable.\n;;;\n;;;\n;;;  (zcgenout (gensym) \"EQU\" `(,(cdr name) \"+\" ,codelen)\n;;;                           \"Estimated code offset so far.\")\n;;;\n\n  (zcgcodck (cdr name) codelen) ; Check estimated code offset.\n\n )\n)\n\n;=======================================================================\n\n;\n; If this is a stand-alone function and there are any constant atoms\n; or lists (usually via QUOTE) contained within, a call to intern them\n; on the object list must be executed, one time only, on entry to the\n; function.  For main-line programs, this is handled by ZILINIT, so we\n; don't need to include code for it here.  In most cases stand-alone\n; functions don't need their own atoms other than T or NIL, so this\n; won't happen that often.\n;\n\n(defun zcgbegin2 (adconp &aux sasaved1 fasaved1)\n\n (when adconp                    ; If lists or atoms must be initialized\n  (let ((l1 (gensym)) (l2 (gensym)))\n   (zcgemit 0 \"*\" \" \"  \" \"       \"Code to initialize atoms and lists.\")\n   (zcgemit 4 l1 \"NOP\" l2       \"Execute once, then branch around it.\")\n   (zcgemit 4 () \"L\"   \"15,ZLCSINT\"          \"Get address of ZILSINT.\")\n   (zcgemit 4 () \"LA\" `(\"1,\" ,(get (cdr name) 'zzzptrs))\n                                       \"Address the list of pointers.\")\n   (zcgemit 2 () \"BALR\" \"14,15\"                        \"Call ZILSINT.\")\n\n   (zcgbase name nil) ; Reload base registers if necessary.\n\n   (zcgemit 4 () \"OI\"   `(,l1 \"+1,X'F0'\")\n                                     \"Change NOP to branch next time.\")\n   (zcgemit 0 l2 \"DS\"  \"0H\"                                        nil)\n   (zcgemit 0 \"*\" \" \"  \" \"         \"End code to init atoms and lists.\")\n  )\n )\n ;\n ; If necessary, before any other stuff, save the current alists.\n ; This must be done if:\n ;  (1) any function arguments are used as free variables elsewhere,\n ;  (2) any tail-recursive back-branches to the beginning of this\n ;      code come from binding environments with local variables used\n ;      as free variables elsewhere.\n ; In either of the above cases, the original alists on first entry\n ; to this function must be restored upon final exit therefrom.\n ; (I.e. save special-alist if any of these are declared \"special\",\n ;   and save fluid-alist if any of these are declared \"lexical\".)\n ;\n\n (let (\n       (free-specials (zcgbegin-any-free 'special tailrecur))\n       (free-lexicals (zcgbegin-any-free 'fluid tailrecur))\n      )\n      (when free-specials\n       (zcgemit 4 () \"L\"  \"0,ZLCSALST\"  \"Get address of special ALIST.\")\n       (zcgemit 4 () \"ST\" `(\"0,\" ,stack \"(,11)\")      \"Store on stack.\")\n       (setq sasaved1 (cons 'salist stack))\n       (incf stack 4)\n      )\n      (when free-lexicals\n       (zcgemit 4 () \"L\"  \"0,ZLCFALST\"  \"Get address of lexical ALIST.\")\n       (zcgemit 4 () \"ST\" `(\"0,\" ,stack \"(,11)\")      \"Store on stack.\")\n       (setq fasaved1 (cons 'falist stack))\n       (incf stack 4)\n      )\n      (when (or free-specials free-lexicals)\n            (zcgemit 0 (setq zzzconp (gensym)) \"DS\" \"0H\" nil)\n      )\n )\n\n (push sasaved1 special-asaved)\n (push fasaved1 fluid-asaved)\n\n)\n\n;=======================================================================\n\n;\n;\n; For each unbound variable referenced by the function,\n; generate code to retrieve the value from the appropriate alist and\n; place the pointer to the value on the stack.\n;\n\n(defun zcgbegin3 (&aux ubl (off stack))\n\n (when (setq ubl (cdr special-unbounds))\n                              ; If any unbound SPECIAL variables\n                              ; are referenced in this code\n\n  ;\n  ; Begin unbound-variable-stack-slot-initialization code.\n  ;\n  (zcgemit 4 () \"L\" \"0,ZLCUNBND\" \"Load pointer to unbound object.\")\n\n  (dolist (var ubl)\n   (putprop (cdr var) off 'pointer)\n   (zcgemit 4 () \"ST\" `(\"0,\" ,off \"(,11)\")\n               `(\"Mark unbound \" ,(if (> (string-length (car var)) 24)\n                                      (cdr var)\n                                      (car var))))\n   (setq off (+ off 4))\n  )\n\n )\n\n (when (setq ubl (cdr fluid-unbounds)) ; If any unbound lexical vars\n                                       ; are referenced in this code\n  ;\n  ; Begin unbound-variable-retrieval code.\n  ;\n  (zcgemit 0 \"*\" \" \" \" \"         \"Code to retrieve lexical variables.\")\n\n  (prog (lng lnf lbl lb1 lb2 var ptr)\n   (setq lng (length ubl)\n         lnf (gensym)\n         lbl (gensym)\n         lb2 (gensym))\n\n   (do ((l (* lng 4) (- l 256))\n        (m off       (+ m 256))\n       )\n       ((< l 257)\n        (zcgemit 6 () \"XC\" `(,m \"(\" ,l \",11),\" ,m \"(11)\")\n                                        \"Set unbound pointers to zero.\")\n       )\n       (zcgemit 6 () \"XC\" `(,m \"(256,11),\" ,m \"(11)\")\n                                        \"Set unbound pointers to zero.\")\n   )\n\n   (when (> lng 1)\n    (zcgemit 4 () \"LA\" `(\"0,\" ,lng) \"Load number of unbound variables.\")\n   )\n   (zcgemit 4 ()  \"L\"   \"1,ZLCFALST\"    \"Get address of lexical alist.\")\n   (zcgemit 2 lbl \"CR\"  \"1,10\"            \"If not all variables bound,\")\n   (zcgemit 2 ()  \"BER\" \"13\"              \"then signal error.\")\n   (zcgemit 4 ()  \"L\"   \"2,##CAR(,1)\"     \"Get this alist pair.\")\n   (zcgemit 4 ()  \"L\"   \"3,##CAR(,2)\"     \"Get CAR of the pair = atom.\")\n srchloop\n   (setq var (car ubl))\n   (setq ptr (putprop (cdr var) off 'pointer))\n\n   (let ((loc (or (get (cdr var) 'location)\n                  (putprop (cdr var) (gensym) 'location)))\n        )\n        (zcgemit 4 () \"C\" `(\"3,\" ,loc)\n                 `(\"If variable \" ,(if (> (string-length (car var)) 24)\n                                       (cdr var)\n                                       (car var))))\n   )\n   (and (eql lng 1) (go onlyone))\n   (zcgemit 4 () \"BNE\" (setq lb1 (if (cdr ubl) (gensym) lb2)) \"then...\")\n   (zcgemit 4 () \"ICM\" `(\"3,15,\" ,ptr \"(11)\")   \"check value on stack.\")\n   (zcgemit 4 () \"BNZ\" lb2              \"If already set, ignore value.\")\n   (zcgemit 4 () \"ST\" `(\"2,\" ,ptr \"(,11)\") \"Else store value on stack.\")\n   (zcgemit 4 () \"BCT\" `(\"0,\" ,lb2)          \"Continue searching alist\")\n   (zcgemit 4 () \"B\"  lnf                \"unless no more vars to find.\")\n   (setq off (+ off 4))\n   (when (setq ubl (cdr ubl))\n         (zcgemit 0 lb1 \"DS\" \"0H\" nil)\n         (go srchloop))\n   (go aftonly)\n onlyone\n   (zcgemit 4 () \"BNE\" lb2                                    \"then...\")\n   (zcgemit 4 () \"ST\" `(\"2,\" ,ptr \"(,11)\")      \"Store value on stack.\")\n   (zcgemit 4 () \"B\"   lnf                \"Exit, no more vars to find.\")\n   (setq off (+ off 4))\n aftonly\n   (zcgemit 4 lb2 \"L\"  \"1,##CDR(,1)\"          \"Get next pair in alist.\")\n   (zcgemit 4  () \"B\"  lbl                  \"Continue searching alist.\")\n   (zcgemit 0 lnf \"DS\" \"0H\"       \"Unfound symbols have zero pointers.\")\n   (zcgemit 0 \"*\" \" \"  \" \"         \"End code to retrieve lexical vars.\")\n\n  )\n\n )\n\n (setq stack off) ; At end, reset top of stack.\n\n ;\n ; End of unbound-variable-retrieval code\n ;\n)\n;=======================================================================\n\n(defun assign-location (x)\n (putprop (cdr x) (gensym) 'location)\n)\n;=======================================================================\n\n(defun quoted (a)\n (string-appendl (zilcoquo (explodec a)))\n)\n;=======================================================================\n\n(defun zcgbegin-any-free (type varlist)\n (mapor #'(lambda (x) (eq (car (get (cdr x) 'bindingtype)) type))\n        varlist))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGBIND": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10'\\x00\\xbc\\x00\\x98\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:27:00", "lines": 188, "newlines": 152, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This generates code to push variables on the alist if they are\n; \"declared special\" or otherwise found to be used as free variables\n; elsewhere.  One variable at a time is handled.\n;\n; Note: ASAVED is RPLACA'd instead of reconsing.  This is required\n;       because ASAVED itself is made the value of the CURALIST\n;       property by ZCGBPROG, and ZCGSTTRG checks this via EQ.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgbind (a)\n (prog\n       (var  ; the local variable being bound\n        lbl  ; the exit label which may need a POPALIST property\n        v    ; an item to receive the value if SETQ is involved\n        s    ; the target of the value to be set\n        m    ; the new stack location if an ALIST must be saved\n        p    ; a stack location used by ALIST processing\n        dec  ; the variable's SPECIAL declaration if present\n        o    ; the variable's stack offset\n        pair ; the dotted pair representing the variable symbol\n        binder ; the dotted pair representing the binding fun to call\n        nam  ; the name of the variable being processed\n        bindingtype ; the value of the BINDINGTYPE property of binding\n        type ; SPECIAL or FLUID\n       )\n\n  (desetq (var lbl v s) a)\n;\n; Code to set our variable if it is a free variable in another subr.\n; This code places pointers to such variables on one of the ALISTs.\n; This code performs the function previously handled by ZCGADDVA.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Do for variables declared \"special\" or for \"free\" variables         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;\n; Remember - \"top-level\" DECLARE SPECIAL adds the variable to\n;            the corresponding FREEVARS list, even if it's never\n;            really used.\n;            \"Local\" DECLARE SPECIAL doesn't add the variable to\n;            any FREEVARS list, though it does mark the local variable.\n;\n; Note that at this point, if the variable was not locally declared\n; SPECIAL but was globally declared so, we make it look as if\n; it had been locally declared the same way, for convenience.\n;\n\n (setq bindingtype (get (cdr var) 'bindingtype))\n\n  (case (car bindingtype)\n   ((nil)    (return)) ; Do no more if not a \"free\" variable.\n   (special\n\n    ;; Code to put variable on special ALIST.\n    ;; If ALIST has not been saved, do it and tell where it was done.\n\n    (unless (car special-asaved)\n     (setq p (car pdmax))             ; Get saved-alist stack offset.\n     (setq m (+ p 4))                 ; Get new top-of-stack offset.\n                               ; Replace top of special-ALIST stack.\n     (rplaca special-asaved (cons 'salist p))\n     (setq pdmax (cons m (cdr pdmax)))  ; Replace top of STACK stack.\n     (if (> m stackmax)\n         (setq stackmax m))          ; Set new high water mark.\n\n     (putprop lbl p 'popsalist)      ; Make exit label restore ALIST.\n\n     (zcgemit 4 () \"L\" \"0,ZLCSALST\"    \"Get address of special ALIST.\")\n     (zcgemit 4 () \"ST\" `(\"0,\" ,p \"(,11)\")           \"Store on stack.\")\n\n    )\n    (setq binder '(\"ZLCSBND\" . \"ZILSBND\"))\n   )\n\n   (fluid\n\n    ;; Code to put variable on fluid ALIST.\n    ;; If ALIST has not been saved, do it and tell where it was done.\n\n    (unless (car fluid-asaved)\n     (setq p (car pdmax))             ; Get saved-alist stack offset.\n     (setq m (+ p 4))                 ; Get new top-of-stack offset.\n                               ; Replace top of fluid-ALIST stack.\n     (rplaca fluid-asaved (cons 'falist p))\n     (setq pdmax (cons m (cdr pdmax)))  ; Replace top of STACK stack.\n     (if (> m stackmax)\n         (setq stackmax m))          ; Set new high water mark.\n\n     (putprop lbl p 'popfalist)      ; Make exit label restore ALIST.\n\n     (zcgemit 4 () \"L\" \"0,ZLCFALST\"    \"Get address of lexical ALIST.\")\n     (zcgemit 4 () \"ST\" `(\"0,\" ,p \"(,11)\")           \"Store on stack.\")\n    )\n    (setq binder '(\"ZLCFBND\" . \"ZILFBND\"))\n   )\n  )\n\n; Note that the code generator will not consider a variable to be\n; SPECIAL or FLUID until the CDR of the binding type is T.\n; In this way, INIT forms that set variables before they are scoped\n; can work properly.\n\n   (setq type (car bindingtype))       ; SPECIAL or FLUID\n   (setq pair (cdr bindingtype))       ; Get the atom for the variable.\n   (rplacd bindingtype t)              ; Activate specialness/fluidity.\n\n  (cond\n   ((get (cdr pair) 'implicitly-free)\n    (princ \"Warning - \")\n    (prin1 (car var))\n    (princ \" is a local variable in use as a free \")\n    (princ type)\n    (princ \" variable.\")\n    (terpri))\n   ((eq type 'fluid)\n    (princ \"Note - \")\n    (prin1 (car var))\n    (princ \" is a local variable captured by a lexical closure.\")\n    (terpri))\n   (t\n    (princ \"Note - \")\n    (prin1 (car var))\n    (princ \" is a local variable that has been declared SPECIAL.\")\n    (terpri)))\n\n   ; Set the LOCATION property, to insure that\n   ; the atom is addressable by the code.\n\n  (or main\n      (get (cdr pair) 'location)\n      (putprop (cdr pair) (gensym) 'location))\n\n; Since this locally bound variable is be made available as a \"free\"\n; (special or fluid) variable, generate code to replace the value on\n; the stack with a pointer to an ALIST cell which contains the variable\n; name and its value.\n\n  (setq nam (if (> (string-length (car pair)) 20)\n            (cdr pair) (car pair))\n        o   (get (cdr var) 'offset))\n\n  (if (get (cdr var) 'lexprarg)\n   then\n    (zcgemit 4 () \"L\" \"2,0(,11)\"            \"Get LEXPR stack pointer.\")\n    (zcgemit 4 () \"L\" \"2,0(,2)\"               `(\"Load value of \" ,nam))\n   else\n    (zcgemit 4 () \"L\" `(\"2,\" ,o \"(,11)\")      `(\"Load value of \" ,nam))\n   endif\n  )\n  (zcgemit 4 () \"L\" `(\"15,\" ,(car binder))\n                                `(\"Get address of \" ,(cdr binder) \".\"))\n  (zcgemit 4 () \"L\" `(\"1,\" ,(get (cdr pair) 'location))\n                                            `(\"Load address of \" ,nam))\n  (zcgemit 2 () \"BALR\" \"3,15\"             `(\"Call \" ,(cdr binder) \".\"))\n  (if (get (cdr var) 'lexprarg)\n   then\n    (zcgemit 4 () \"L\"  \"14,0(,11)\"          \"Get LEXPR stack pointer.\")\n    (zcgemit 4 () \"ST\" \"1,0(,14)\"       \"Store pointer to ALIST cell.\")\n   else\n    (zcgemit 4 () \"ST\" `(\"1,\" ,o \"(,11)\")\n                                        \"Store pointer to ALIST cell.\")\n   endif\n  )\n )\n)\n\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGBLAM": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10(\\x00G\\x00:\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:28:00", "lines": 71, "newlines": 58, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This generates code for BEGINLAM, which marks the start of an\n; inline LAMBDA expression in the function position of a form.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgblam  (a)\n (prog\n       (naym  ; a GENSYM that holds info about the lambda\n        parmz ; the arguments from the arglist\n        v     ; an item to receive the value if SETQ is involved\n        s     ; the target of the value to be set\n        m     ; the new stack height\n        b     ; the argument base used to compute offsets of args\n       )\n  (desetq (naym parmz v s) a)\n  (setq b (car argbase))\n;\n; Code to assign offsets to the args.\n;\n  (loop for arg in parmz\n   (setf (get (cdr arg) 'offset)\n         (+ b (* (1- (get (cdr arg) 'position)) 4)))\n   (setf (get (cdr arg) 'position) nil)\n  )\n;\n; If there are &AUX args or supplied-p args defined for the lambda,\n; or destructured args,\n; we have to bump the top-of-stack pointer more, because no args\n; have been passed for these guys (ZCGSTTRG was bumping (CAR PDMAX)\n; for each arg stored).\n;\n\n (setq m (loop for arg in parmz\n               count (or (get (cdr arg) 'aux)\n                         (get (cdr arg) 'owned))))\n\n (unless (zerop m)\n         (setq pdmax\n               (cons (setq m (+ (* m 4) (car pdmax)))\n                     (cdr pdmax)))\n                        ; Increment the top element of stack PDMAX\n         (if (> m stackmax)\n             (setq stackmax m))) ; and reset the high water mark.\n;\n; Stack alist pointers.\n;\n; The CAR of the top slot of each will be filled in by BIND requests\n; subsequently, if any non-local bindings are required.  Otherwise\n; the top slot will remain null-carred, indicating that nothing\n; special (n.p.i.) is to be done with this pseudocontour.\n;\n\n  (push nil special-asaved) ; Will be filled in by BIND requests later.\n  (push nil fluid-asaved)   ; Will be filled in by BIND requests later.\n\n )\n)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGBTAG": {"ttr": 4622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x89\\x15o\\x10(\\x00&\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1989-06-05T10:28:00", "lines": 38, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* ZCGBTAG - generates code for the \"BEGINTAG\" order.                 *\n;*                                                                    *\n;**********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgbtag (a)\n (let (\n       (l (car a)) ; the dummy exit label\n    ;;; v          ; not used\n    ;;; s          ; not used\n      )\n\n; Record current environment stacks on the exit label, so that code\n; that exits this contour will know what unbinding/unwinding it has\n; to do if it needs to jump out in an unusual way.\n\n  (putprop l (cons special-asaved fluid-asaved) 'curalist)\n\n; Note!  The above requires that ZCGBIND do RPLACA's on xxx-ASAVED to\n;        maintain EQness, which ZCGSTTRG checks for.\n\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGBUWP": {"ttr": 4624, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10)\\x00S\\x006\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:29:00", "lines": 83, "newlines": 54, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* This module generates code to initialize an UNWIND-PROTECT frame.  *\n;*                                                                    *\n;* An UNWIND-PROTECT frame looks just like a CATCH frame, except that *\n;* it is two fullwords longer and the tag slot contains hex zeroes.   *\n;*                                                                    *\n;* See ZCCUWP or ZILTHROW for details on the contents of this frame.  *\n;*                                                                    *\n;**********************************************************************\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/08/88 - Support for GO and RETURN out of UNWIND-PROTECT.         *\n;* 06/23/88 - Support for PROG and RETURN removed.  Support for        *\n;*            GO and RETURN-FROM out of UNWIND-PROTECT remains,        *\n;*            of course.                                               *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgbuwp (a)\n (prog\n       (\n        l1  ; the label of the cleanup forms code\n        l2  ; the label of the cleanup forms return location\n      ; v   ; not used\n      ; s   ; not used\n        c   ; the current stack location where the UWP frame will go\n        n   ; the new stack location following the UWP frame\n       )\n\n       (desetq (l1 l2 () ()) a)    ; Get labels.\n\n;\n; Push UNWIND-PROTECT frame space on the stack.\n;\n       (setq c (car pdmax))    ; UWP frame goes here on stack.\n       (setq n (+ c 36))       ; Bump stack past UWP frame.\n       (push n pdmax)          ; Stack height.\n       (if (> n stackmax)\n           (setq stackmax n))  ; High water mark.\n;\n; Push an UNWIND-PROTECT contour on the saved-things-to-unstack lists.\n;\n       (let ((x (cons 'uwp c)))\n            (push x special-asaved)\n            (push x fluid-asaved))\n;\n; Generate code to build the UNWIND-PROTECT frame.\n;\n       (zcgemit 4 () \"L\"  \"14,ZLCCATCH\"       \"Get active catch frame.\")\n       (zcgemit 4 () \"ST\" `(\"14,\" ,c \"(,11)\") \"Store into UWP frame.\")\n       (zcgemit 4 () \"L\"  \"14,ZLCSALST\"       \"Get special ALIST.\")\n       (zcgemit 4 () \"L\"  \"15,ZLCFALST\"       \"Get lexical ALIST.\")\n       (zcgemit 2 () \"XR\" \"0,0\"               \"Set tag slot = zeroes.\")\n       (zcgemit 4 () \"LA\" `(\"1,\" ,l1)  \"Address of cleanup forms code.\")\n       (zcgemit 4 () \"STM\" `(\"11,1,\" ,(+ c 4) \"(11)\")\n                                            \"Store all into UWP frame.\")\n       (zcgemit 4 () \"LA\" `(\"14,\" ,l2) \"Where to return after cleanup.\")\n       (zcgemit 4 () \"ST\" `(\"14,\" ,(+ c 12) \"(,11)\")\n                                                \"Store into UWP frame.\")\n       (zcgemit 4 () \"LA\" `(\"14,\" ,c \"(,11)\")   \"Address of UWP frame.\")\n       (zcgemit 4 () \"ST\" \"14,ZLCCATCH\"      \"Make active catch frame.\")\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGCALL": {"ttr": 4626, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10)\\x00\\x8f\\x00\\x82\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:29:00", "lines": 143, "newlines": 130, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-CALL                                                           *\n;*                                                                    *\n;**********************************************************************\n\n;\n; Note: Support for FUNCALL.\n;       The number of function arguments (which is the number\n;       of args to ZILXFUN minus 1 for the function itself and\n;       4 for reserved stack slots) is multiplied by 4 to give\n;       the size of the stack frame occupied by arguments to\n;       the function being FUNCALLed, and this value is placed\n;       in register 2.  Then ZILXFUN is BALR'ed to.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgcall (a) ;\n (prog\n       (b   ; the name of the function to be called or invoked\n        n   ; the number of arguments passed to the function\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        r   ; a register to be used\n        o   ; an offset to be generated\n        l   ; a location label for the V-con associated with the subr\n       )\n  (desetq (b n v s) a)\n  (setq o (car argbase))\n  (setq r (zcgresv '\\15))\n  (zcgresv '\\1)\n  (zcgresv '\\14)\n;\n; Note that B is a dotted pair with the function name and a symbol.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Certain system subroutines, such as CONS, accept arguments in\n; registers 1 and 2 rather than using the stack.  Generate code\n; accordingly.\n;\n; Since CONS is compiled as an inline routine, this does not apply.\n; However, the code is retained because someday it will be needed for\n; \"fast path\" function calls.\n;\n;      (IF (EQ (CAR B) 'CONS) ; This will be extended to other fns soon\n;       THEN\n;            (ZCGRESV '\\2)\n;            (ZCGENOUT NIL 'LM (LIST '|1,2,| O '|(11)|)\n;                                         '|Load arguments from stack.|)\n;       ELSE\n;            (ZCGENOUT NIL 'LA (LIST '|1,| O '|(,11)|)\n;                                 '|Set pointer to arguments in stack.|)\n;       ENDIF)\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (if (eq (car b) (car name))\n   then\n    (zcgemit 2 () \"LR\" \"15,12\"     \"Get address for recursive call.\")\n   else\n    (setq l (or (get (cdr b) 'location)\n                (putprop (cdr b) (gensym) 'location)))\n    (zcgemit 4 () \"L\" `(\"15,\" ,l)      `(\"Get address of \" ,(cdr b)))\n\n    (if (eq (car b) 'zilxfun) ; Special case for FUNCALL hacking.\n     then\n      (if (eql n 5)\n          (zcgemit 2 () \"XR\" \"2,2\"           \"Load zero argument count\")\n          (zcgemit 4 () \"LA\" `(\"2,\" ,(* (- n 5) 4))\n                                              \"Load argument count * 4\")\n      )\n\n;;;;;else\n;;;;;;(zcgenout nil \"LA\" `(\"2,\" ,(* n 4))     \"Load argument count * 4\")\n;;;;;;;Not unless we decide to implement this some day...\n\n     endif\n    )\n   endif\n  )\n\n;\n; \"LA 1\" moved after \"L 15\" for pipeline turbulence optimization per SKH\n;\n  (zcgemit 4 () \"LA\" `(\"1,\" ,o \"(,11)\")\n                                    \"Set pointer to stacked arguments.\")\n\n  (zcgemit 2 () \"BALR\" \"14,15\"                      `(\"Call \" ,(car b)))\n;\n; At this point the return value will be in register 15.\n;\n\n  (zcgbase name nil) ; Reload additional base registers if necessary.\n\n;\n; Pop call stack contour.\n;\n; Note that stack popping has to be done before ZCGSTTRG, so that\n; references to arguments as the target are resolved correctly.\n;\n\n       (setq argbase (cdr argbase))   ; Pop argument base stack\n       (setq pdmax (cdr pdmax))       ; Pop stack height\n\n       (zcgstvrs r v s t)    ; Store reg into SETQ variables if any.\n       (zcgsttrg r s)        ; Set target to register if any.\n       (zcgrels '\\1)         ; Free the register.\n       (zcgrels '\\14)        ; Free the register.\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; More unused code, but save it for future reference.\n;\n;      (IF (EQ (CAR B) 'CONS) THEN (ZCGRELS '\\2))\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n ) ; end PROG\n) ; end DEFUN ZCGCALL\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGCLOS": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x100\\x00G\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:30:00", "lines": 71, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* \"ZCGCLOS\"                                                          *\n;*                                                                    *\n;**********************************************************************\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgclos (a) ;\n (prog\n       (b   ; the name of the function to make a closure out of\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        r   ; a register to be used\n        l   ; a location label for the V-con associated with the subr\n        c   ; comments string\n       )\n       (desetq (b v s) a)\n       (setq r (zcgresv '\\15) ) ; Value is always in this register.\n       (zcgresv '\\1)\n       (zcgresv '\\2)\n       (zcgresv '\\14)\n       (setq c `(\"Load address of \" ,(cdr b)))\n;\n; Note that B is a dotted pair with the function name and a symbol.\n;\n       (if (eq (car b) (car name))\n        then\n         (zcgemit 2 () \"LR\" \"1,12\"                                    c)\n        else\n         (setq l (or (get (cdr b) 'location)\n                     (putprop (cdr b) (gensym) 'location)))\n         (zcgemit 4 () \"L\" `(\"1,\" ,l)                                 c)\n        endif\n       )\n       (zcgemit 4 () \"L\"    \"15,ZLCCONS\"         \"Get address of CONS.\")\n       (zcgemit 4 () \"L\"    \"2,ZLCFALST\"           \"Get lexical ALIST.\")\n       (zcgemit 2 () \"BALR\" \"14,15\"      \"Call CONS to make a closure.\")\n       (zcgemit 4 () \"MVI\"  \"##TYPE(15),##CLOSUR\"\n                         `(\"Closure of \" ,(string-substr (car b) 1 24)))\n;\n; At this point the return value will be in register 15.\n;\n       (zcgstvrs r v s nil)  ; Store reg into SETQ variables if any.\n       (zcgsttrg r s)        ; Set target to register if any.\n       (zcgrels '\\1)         ; Free the register.\n       (zcgrels '\\2)         ; Free the register.\n       (zcgrels '\\14)        ; Free the register.\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGCODCK": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x18/\\x00\\x89\\x15o\\x100\\x00\\x17\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-07-01T00:00:00", "modifydate": "1989-06-05T10:30:00", "lines": 23, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgcodck (csect offset)\n\n ; CSECT is actually (cdr name).\n ; OFFSET is actually codelen.\n\n (zcgenout nil \"DS\" `(\"(*-(\" ,csect \"+\" ,offset \"))X\")\" Check estimate\")\n (zcgenout nil \"DS\" `(\"((\" ,csect \"+\" ,offset \")-*)X\")\" of code length\")\n\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGCSNIL": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x88\\x11o\\x00\\x89\\x15o\\x101\\x006\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-04-25T00:00:00", "modifydate": "1989-06-05T10:31:00", "lines": 54, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* ZCGCSNIL processes the CSETNIL order.                              *\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Created 04/25/88.                                                   *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgcsnil (a) ;\n (prog (\n        b   ; the dotted pair describing the conditionally set variable\n        v   ; the usual\n        s   ; the usual\n       )\n       (desetq (b v s) a)\n\n       (when debug\n             (putdata b v s)\n             (putdata (plist (cdr b)))\n       )\n       (if (get (cdr b) 'mustinit)            ; If used before SETQ\n           (zcggetit (list nil v s))          ; then do set to NIL\n           (zcgsttrg nil s)                   ; else just push stack ptr\n       )))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGDEF": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x101\\x00O\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:31:00", "lines": 79, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n\n;**********************************************************************\n;*                                                                    *\n;* \"ZCGDEF\"                                                           *\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgdef  (a) ;\n (prog\n       (b   ; the function (dotted pair)\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        r   ; a register to be used\n        l   ; a location label for the V-con associated with the subr\n        sub ;\n       )\n       (desetq (b v s) a)\n       (setq r (zcgresv '\\15) ) ; Value is always in this register.\n       (zcgresv '\\0)\n       (zcgresv '\\2)\n       (zcgresv '\\14)\n;\n; Note that B is a dotted pair with the function name and a symbol.\n;\n       (setq l (or (get (cdr b) 'location)\n                   (putprop (cdr b) (gensym) 'location)))\n\n; Get subr ZILXDEF.\n\n       (setq sub (or (assq 'zilxdef subrs)\n                     (zerror \"No SUBR for ZILXDEF!\" b)))\n\n       (zcgemit 4 () \"L\" `(\"2,\" ,l) `(\"Load address of \" ,(cdr b)))\n\n       (zcgemit 4 () \"L\"    `(\"15,\" ,(or (get (cdr sub) 'location)\n(putprop (cdr sub) (gensym) 'location))) \"Get address of ZILXDEF.\")\n\n       (zcgemit 4 () \"LA\" `(\"0,\" ,(car pdmax) \"(,11)\")\n                                           \"Load top-of-stack pointer.\")\n\n       (zcgemit 2 () \"BALR\" \"14,15\" \"Call ZILXDEF to define function.\")\n\n       ;;; ZCGBASE does not need to be called - ZILXDEF will save regs\n\n;\n; At this point the return value will be in register 15.\n;\n       (zcgstvrs r v s t)    ; Store reg into SETQ variables if any.\n       (zcgsttrg r s)        ; Set target to register if any.\n       (zcgrels '\\0)         ; Free the register.\n       (zcgrels '\\1)         ; Free the register.\n       (zcgrels '\\2)         ; Free the register.\n       (zcgrels '\\14)        ; Free the register.\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGELAM": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x102\\x00)\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:32:00", "lines": 41, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This generates code for ENDLAM, which marks the end of an inline\n; lambda expression in the function position of a form.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgelam  (a) ;\n (prog\n       (\n;;;;    name  ; a GENSYM used to hold info about the lambda\n;;;;    parms ; the arguments from the arglist\n;;;;    v     ; an item to receive the value if SETQ is involved\n;;;;    s     ; the target of the value to be set\n       )\n;;;;   (desetq (name parms v s) a)\n\n       ; Pop the ALIST-saved-address stacks.\n\n       (setq special-asaved (cdr special-asaved))\n       (setq fluid-asaved (cdr fluid-asaved))\n\n       ; Pop the stack frame contour.\n\n       (setq pdmax (cdr pdmax))     ; Pop stack height.\n       (setq argbase (cdr argbase)) ; Pop argument base stack.\n\n )\n)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGEMIT": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x17\\x9f\\x00\\x89\\x15o\\x103\\x002\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-06-28T00:00:00", "modifydate": "1989-06-05T10:33:00", "lines": 50, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCGEMIT\"\n;;;\n;;; This function replaces the use of ZCGENOUT for the emission of\n;;; code in the \"addressability range\".  It collects lines of output\n;;; code, keeping track of the size of the code as it goes.\n;;;\n;;; When addressability ends (in ZCGEND), additional code is inserted\n;;; if necessary to handle addressability beyond 4K, and the code is\n;;; output via ZCGENOUT.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgemit (ilen label opcode operands comments)\n\n (setq codelen\n       (case ilen\n             ((f)    (* 4 (quotient (+ codelen 3) 4)))\n             ((h)    (* 2 (quotient (+ codelen 1) 2)))\n             ((d)    (* 8 (quotient (+ codelen 7) 8)))\n             (t      (+ codelen ilen))))\n\n (push (list label opcode operands comments) codelist)\n\n;(when debug\n;      (cterpri)\n;      (princ \"Codelen = \") (princ codelen) (terpri)\n;      (princ label) (princ \" \") (princ opcode) (princ \" \")\n;      (princ operands)\n;      (terpri)\n;)\n;\n\n\n\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGEND": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x103\\x024\\x01U\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:33:00", "lines": 564, "newlines": 341, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-END                                                            *\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/22/89 - Added setting of \"uninterned\" bit for symbols.           *\n;*                                                                     *\n;***********************************************************************\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcgend (a)\n (prog (name args zzzsubrs zzzatoms zzzlists)\n  (desetq (name args) a)\n  (setq zzzsubrs (get (cdr name) 'zzzsubrs)\n        zzzatoms (get (cdr name) 'zzzatoms)\n        zzzlists (get (cdr name) 'zzzlists))\n\n  (zcgemit 0 \"*\" \" \" \" \" \"Return value is in register 15.\")\n\n  ; If ALIST pointers were saved, restore them before exiting.\n\n  (when (car fluid-asaved)\n\n        (unless (eq (caar fluid-asaved) 'falist)\n         (zerror \"Bottom of binding stack not FALIST in ZCGEND\"\n                fluid-asaved))\n\n        (zcgemit 4 () \"L\"  `(\"14,\" ,(cdar fluid-asaved) \"(,11)\")\n                                      \"Load stacked lexical ALIST ptr.\")\n        (zcgemit 4 () \"ST\" \"14,ZLCFALST\"       \"Restore lexical ALIST.\")\n  )\n;;(setq fluid-asaved (cdr fluid-asaved)) ; Who cares?\n\n  (when (car special-asaved)\n\n        (unless (eq (caar special-asaved) 'salist)\n         (zerror \"Bottom of binding stack not SALIST in ZCGEND\"\n                special-asaved))\n\n        (zcgemit 4 () \"L\"  `(\"14,\" ,(cdar special-asaved) \"(,11)\")\n                                      \"Load stacked special ALIST ptr.\")\n        (zcgemit 4 () \"ST\" \"14,ZLCSALST\"       \"Restore special ALIST.\")\n  )\n;;(setq special-asaved (cdr special-asaved)) ; Who cares?\n\n  (zcgemit 2 ()      \"LR\"    \"1,11\"              \"Reset stack pointer.\")\n  (zcgemit 4 ()      \"L\"     `(\"14,\" ,(+ pdbas 8) \"(,1)\")\n                                              \"Restore return address.\")\n  (zcgemit 4 ()      \"LM\"    `(\"11,12,\" ,pdbas \"(1)\")\n                                    \"Restore stack and base registers.\")\n  (zcgemit 2 ()      \"BR\"    \"14\"                   \"Return to caller.\")\n  (zcgemit 0 ()      \"SPACE\" 3                                      nil)\n  (zcgemit 0 zzzstksz \"EQU\"  stackmax        \"Maximum stack size used.\")\n  (zcgemit 0 ()      \"DROP\"  12                                     nil)\n  (zcgend-drop-more-baseregs)\n  (zcgemit 0 ()      \"SPACE\" 3                                      nil)\n;\n; Generate pointers to external subroutines.\n;\n (if (cdr subrs)\n  then\n   (zcgemit 'f `(,zzzsubrs \"S\") \"DS\" \"0A\"  \"Subroutine pointers.\")\n   (mapc #'(lambda (x)\n            (if (memq (car x) intfuncs)\n             then\n              (zcgemit 4 (get (cdr x) 'location)\n                         \"DC\"\n                         `(\"A(\" ,(cdr x) \")\")\n                         `(\"Address of \" ,(substr (car x) 1 24)))\n             else ; External function call - check name.\n              (let*\n               ((a (car x))\n                (c (or (get a 'cautoload) a)))\n               (unless (eq c (cdr x))\n                       (princ \"Error - invalid function name \\\"\")\n                       (princ C)\n                       (princ \"\\\"; \\\"\")\n                       (princ (cdr x))\n                       (princ \"\\\" substituted.\")\n                       (terpri)))\n              (zcgemit 4 (get (cdr x) 'location)\n                         \"DC\"\n                         `(\"V(\" ,(cdr x) \")\")\n                         `(\"Entry point for \" ,(substr (car x) 1 19)))\n             endif\n            )\n            (zcgemit 8 () \"DC\" `(\"CL8'\" ,(cdr x) \"'\") nil)\n            (remprop (cdr x) 'location))\n        (cdr subrs))\n\n   (zcgemit 0 `(,zzzsubrs \"E\") \"EQU\" \"*\"    \"End of subroutines.\")\n  else\n  if zzzsubrs\n  then\n   (zcgemit 'f `(,zzzsubrs \"S\") \"DS\"  \"0A\"   \"Subroutine pointers.\")\n   (zcgemit 0  `(,zzzsubrs \"E\") \"EQU\" \"*\"    \"End of subroutines.\")\n  endif\n )\n;\n; Relocatable object pointers begin here.\n;\n  (if zzzatoms\n   then\n      (zcgemit 'f `(,zzzatoms \"S\") \"DS\" \"0A\" \"Atom pointers.\")\n   else\n   if (and (not main) zzzlists)\n   then\n      (zcgemit 'f `(,zzzlists \"S\") \"DS\" \"0A\" \"Object pointers.\")\n   endif\n  )\n;\n; Generate pointers to lists.\n; Only those lists with the \"REFERENCED\" property (i.e. those which\n; have been defined directly in the executable code rather than just\n; being a sublist of another list) will be processed.\n;\n  (loop for x in (cdr lists)\n        when (get (cdr x) 'referenced)\n          do (zcgend-output-offset x main))\n;\n; Generate pointers to atoms.  These will be used by ZILSINT to do\n; load-time relocation and symbol interning.\n;\n; Note that symbols which are unbound lexical variables are placed\n; before other symbols, in order, so that code that handles unbound\n; variables may analyze them properly.\n;\n  (if main\n   then\n     (loop for x in (cdr numatoms) do (zcgend-output-offset x t))\n     (loop for x in (cdr fluid-unbounds) do (zcgend-output-offset x t))\n     (loop for x in (cdr alfatoms)\n           when (get (cdr x) 'real)\n           unless (assq (car x) (cdr fluid-unbounds))\n               do (zcgend-output-offset x t))\n     (if zzzatoms\n         (zcgemit 0 `(,zzzatoms \"E\") \"EQU\" \"*\"  \"End of atoms.\"))\n\n     (zcgend-do-base-stuff) ; End ZCGEMIT's, adjust for base registers.\n\n    ;\n    ; Generate constant lists here.\n    ;\n     (if zzzlists\n         (zcgenout `(,zzzlists \"S\") \"DS\" \"0A\" \"Lists.\"))\n     (dolist (x (cdr alllists))\n             (zcgend-gen-list x (cdr name)))\n     (if zzzlists\n         (zcgenout `(,zzzlists \"E\") \"EQU\" \"*\" \"End of lists.\"))\n   else              ; MAIN=NO - atoms referenced by location pointers\n                     ;           into the main function/program code...\n                     ;           these are relocated by ZILSINT\n\n    (loop for x in (cdr fluid-unbounds) do(zcgend-output-offset x nil))\n    (loop for x in (cdr atoms)\n          unless (assq (car x) (cdr fluid-unbounds))\n              do (zcgend-output-offset x nil))\n    (if zzzlists\n        (zcgemit 0 `(,zzzlists \"E\") \"EQU\" \"*\"  \"End of pointers.\"))\n\n    (zcgend-do-base-stuff) ; End ZCGEMIT's, adjust for base registers.\n\n   endif\n  )\n\n;\n; Generate the constant atoms here.\n;\n  (if main\n   then\n ;\n ; Generate constant numeric atoms.\n ;\n    (mapc #'(lambda (x) (zcgend-gen-number (car x) (cdr x)))\n          (cdr numatoms))\n;\n; Generate constant bignums.\n;\n    (mapc #'(lambda (x) (zcgend-gen-bignum (car x) (cdr x)))\n          (cdr numatoms))\n;\n; Generate constant strings.\n;\n    (mapc #'(lambda (x) (zcgend-gen-string (car x) (cdr x)))\n          (cdr numatoms))\n;\n; Generate constant symbols.\n;\n    (loop for x in (cdr alfatoms)\n          when (get (cdr x) 'real)\n            do (zcgend-gen-symbol (car x) (cdr x)))\n\n  ) ; end IF\n ) ; end PROG\n) ; end DEFUN ZCGEND\n\n;**********************************************************************\n\n;;; (defun zcgend-drop-more-baseregs ()\n;;;  (let ((b (get (car name) 'basereg)))\n;;;       (when (integerp b)\n;;;             (when (> b 1)\n;;;                   (zcgenout nil \"DROP\" 7 nil)\n;;;                   (when (> b 2)\n;;;                         (zcgenout nil \"DROP\" 6 nil)\n;;;                         (when (> b 3)\n;;;                               (zcgenout nil \"DROP\" 5 nil)\n;;; ))))))\n\n(defun zcgend-drop-more-baseregs ()\n (push 'drop codelist)\n)\n\n;**********************************************************************\n\n(defun zcgend-do-base-stuff ()\n\n;;;\n;;; At this point we take all the code collected by calls to ZCGEMIT\n;;; and generate it.  We must check to see if the addressability\n;;; exceeds 4K.\n;;;\n;;; Possible code length ranges (note this include the \"DS 0D\" above,\n;;; which itself is not addressable):\n;;;\n;;;   Code size          Number of base registers\n;;;\n;;;     0  -  4096                    1  (12)\n;;;  4097  -  8192                    2  (12,7)\n;;;  8193  - 12288                    3  (12,7,6)\n;;; 12289  - 16384                    4  (12,7,6,5)\n;;;\n;;; If the code size exceeds 16384, we cannot compile the function.\n;;;\n;;; Note, however, than when the code size exceeds 4096 we are\n;;; forced to add an overhead amount for insertion of instructions\n;;; to load additional base registers.  Let N be the number of NIL's\n;;; inserted into the code list by ZCGBASE.  Then...\n;;;\n;;; If code size is between 0 and 4096, no change required.\n;;; If code size is between 4097 and 8192,\n;;;   add 4*(N+1) to allow for the \"LA 7,4095(,12)\" instructions.\n;;;   If the result exceeds 8192, add another 12, because we have to\n;;;   switch to \"LM 6,7,xxx\" and have 2 adcons and a brancharound.\n;;; If code size is between 8193 and 12288,\n;;;   add 4*(N+4) to allow for the \"LM 6,7,xxx\", 2 adcons & branch.\n;;;   If the result exceeds 12288, add another 4, because we have to\n;;;   switch to \"LM 5,7,xxx\" and have one more adcons.\n;;; If code size is between 12289 and 16384,\n;;;   add 4*(N+5) to allow for the \"LM 5,7,xxx\", 3 adcons & branch.\n;;;   If the result exceeds 16384, we've blown it.  Can't compile.\n;;;\n\n (let ((f (cdr name))\n       (n (loop for x in codelist count (null x)))\n       (baseno)\n       (basecode)\n       (lbl1)\n       (lbl2)\n      )\n   (cond\n    ((<= codelen 4096)\n     (setq baseno 1))\n    ((<= codelen 8192)\n     (setq baseno 2)\n     (incf codelen (* 4 (1+ n)))\n     (when (> codelen 8192)\n           (setq baseno 3)\n           (incf codelen 12)\n           (when (> codelen 12288)\n                 (setq baseno 4))))\n    ((<= codelen 12288)\n     (setq baseno 3)\n     (incf codelen (* 4 (+ n 4)))\n     (when (> codelen 12288)\n           (setq baseno 4)\n           (incf codelen 4)\n           (when (> codelen 16384)\n                 (setq baseno 5))))\n    ((<= codelen 16384)\n     (setq baseno 4)\n     (incf codelen (* 4 (+ n 5)))\n     (when (> codelen 16384)\n           (setq baseno 5))))\n\n;;;\n;;; Now that we have determined the number of base registers,\n;;; before we start outputting the code in CODELIST, generate\n;;; code to initialize the base registers.\n;;;\n\n (case baseno\n  ((3 4)\n   (setq lbl1 (gensym) lbl2 (gensym))\n   (zcgenout nil \"B\" lbl2 \"Branch around base adcons.\")\n   (let ((adcons\n           (case baseno\n                (3 (string-append \"A(\" f \"+8192,\"\n                                       f \"+4096)\"))\n                (4 (string-append \"A(\" f \"+12288,\"\n                                       f \"+8192,\"\n                                       f \"+4096)\"))\n         )))\n    (zcgenout lbl1 \"DC\" adcons nil)\n    (zcgenout lbl2 \"DS\" \"0H\"   nil)\n   )\n  )\n )\n\n (setq basecode\n  (case baseno\n   (1 nil)\n   (2 (list nil \"LA\" \"7,4095(,12)\"   \"Load second base register.\"))\n   (3 (list nil \"LM\" `(\"6,7,\" ,lbl1) \"Load additional base registers.\"))\n   (4 (list nil \"LM\" `(\"5,7,\" ,lbl1) \"Load additional base registers.\"))\n   (t (zerror \"Can't compile function, code would exceed 16K bytes\"\n             (car name)))))\n\n (when basecode\n  (zcgenout (car basecode) (cadr basecode)\n            (caddr basecode) (cadddr basecode))\n  (case baseno\n   (2 (zcgenout nil \"USING \" `(,f \"+4095,7\") nil))\n   (3 (zcgenout nil \"USING \" `(,f \"+4096,7,6\") nil))\n   (4 (zcgenout nil \"USING \" `(,f \"+4096,7,6,5\") nil))\n  )\n  (loop for c on codelist\n    when (null (car c))\n      do (rplaca c basecode)\n    when (eq (car c) 'drop)\n      do (rplaca c (case baseno\n                         (2 `(nil \"DROP\" \"7\" nil))\n                         (3 `(nil \"DROP\" \"7,6\" nil))\n                         (4 `(nil \"DROP\" \"7,6,5\" nil)))))\n )\n\n (loop for x in (nreverse codelist)\n   unless (atom x)\n   do (zcgenout (car x) (cadr x) (caddr x) (cadddr x)))\n\n;\n; The following is inserted for documentation, to aid in locating the\n; end of code that must be directly addressable, and to provide a\n; check that we are computing the code size correctly.\n;\n  (zcgenout nil      \"SPACE\"  1     nil)\n;;(zcgenout (gensym) \"EQU\" `(,f \"+\" ,codelen) \"Estimated code offset.\")\n\n  (zcgcodck f codelen) ; Check estimated code length.\n\n;\n; Align rest of code to doubleword boundary.\n;\n  (zcgenout nil      \"DS\"     \"0D\"  nil)\n  (zcgenout nil      \"SPACE\"  1     nil)\n )\n)\n\n;**********************************************************************\n\n(defun zcgend-gen-list (l naym) ; Generate code for constant lists.\n (prog (lcar lcdr)\n       (or (car l)\n           (zerror \"Null list found embedded in list of lists\"))\n       (setq lcar (genlist-elem (caar l) naym))\n       (if   (null (cdar l))\n        then\n             (zcgenout (cdr l) \"DC\" `(,.lcar \",A(0)\") nil)\n        else\n        if   (atom (cdar l))\n        then\n             (setq lcdr (genlist-elem (cdar l) naym)) ; dotted pair\n             (zcgenout (cdr l) \"DC\" `(,.lcar \",\" . ,lcdr) nil)\n        else\n             (zcgenout (cdr l) \"DC\" `(,.lcar \",A(*-\" ,naym \"+4)\") nil)\n             (zcgend-gen-list (cons (cdar l) nil) naym)\n        endif\n       )))\n\n(defun genlist-elem (e naym)\n (cond\n  ((null e) (ncons \"A(0)\"))\n  ((eq e t) (ncons \"A(1)\"))\n  (t `(\"A(\" ,(cdr (cond\n                   ((symbolp e) (assq     e alfatoms))\n                   ((atom e)    (assoc    e numatoms))\n                   (t           (assq     e alllists))\n                  ))                                   \"-\" ,naym \")\"))\n )\n)\n\n;**********************************************************************\n\n(defun zcgend-gen-number (x1 x2)\n (cond\n  ((fixnump x1)\n   (zcgenout x2  \"DS\" \"0A\" `(\"Fixnum \" ,x1))\n   (zcgenout nil \"DC\" `(\"YL1(##FIXNUM),AL3(0),F'\" ,x1 \"'\")      nil)\n  )\n  ((sfloatp x1)\n   (zcgenout x2  \"DS\" \"0A\" `(\"Flonum \" ,x1))\n   (zcgenout nil \"DC\" `(\"YL1(##SFLOAT),AL3(0),F'\" ,(mkfixnum x1) \"'\")\n             nil)\n  )\n  ((dfloatp x1)\n   (let (((a . b) (mkfixnum x1)))\n    (zcgenout x2  \"DS\" \"0A\" `(\"Flonum \" ,x1))\n    (zcgenout nil \"DC\" `(\"YL1(##DFLOAT),AL3(0),F'\" ,a \"'\") nil)\n    (zcgenout nil \"DC\" `(\"F'\" ,a \",\" ,b \"'\")               nil)\n   )\n  )\n  (t nil)))\n\n;**********************************************************************\n\n(defun zcgend-gen-bignum (x1 x2)\n (prog (numlen numlist biglen)\n     (cond\n      ((bigp x1)\n       (setq numlen  (flatc x1)\n             numlist (biglist x1)\n             biglen  (* 4 (length numlist)))\n       (zcgenout x2  \"DS\" \"0A\" (if (< numlen 18)\n                                  `(\"Bignum \" ,x1)\n                                  \"Bignum\"))\n       (zcgenout nil \"DC\" `(\"YL1(##BIGNUM),AL3(\" ,biglen \")\")       nil)\n       (loop for n in numlist do\n        (zcgenout nil \"DC\" `(\"F'\" ,n \"'\") \"Bignum digit\")\n       )\n      )\n      (t nil)\n     )))\n\n;**********************************************************************\n\n; This subroutine generates pointers to atoms.  Note that these pointers\n; are actually offsets that get resolved by ZILSINT.\n\n(defun zcgend-output-offset (x mainp)\n (zcgemit 4\n           (where-it-is x)\n           \"DC\"\n           (if mainp\n               `(\"A(\" ,(cdr x) \"-\" ,(cdr name) \")\")\n               `(\"A(\" ,(cdr name) \"-\" ,(cdr x) \")\")\n           )\n           (cond\n            ((consp   (car x))      \"Offset of list\")\n            ((stringp (car x))      \"Offset of string\")\n            ((fixnump (car x))      `(\"Offset of fixnum \" ,(car x)))\n            ((bigp    (car x))      \"Offset of bignum\")\n            ((sfloatp (car x))      `(\"Offset of flonum \" ,(car x)))\n            ((dfloatp (car x))      \"Offset of flonum\")\n            ((< (get (cdr x) 'length) 14)\n                                    `(\"Offset of symbol \" ,(car x)))\n            (t                      \"Offset of symbol...\")))\n (remprop (cdr x) 'location)\n)\n\n;**********************************************************************\n\n; This subroutine generates constant symbols.\n; Each member of the list ALFATOMS is passed to this routine.\n\n(defun zcgend-gen-symbol (x1 x2)\n (let ((q (get x2 'quoted)))\n  (zcgenout x2 \"DS\" \"0A\" (if (< (length q) 19) `(\"Symbol \" ,x1)    nil))\n\n  ; The following if we are NOT generating the hash code of the\n  ; symbol into the module at compile time.\n;;;\n;;(zcgenout nil \"DC\" \"YL1(##SYMBOL),7X'00'\"                         nil)\n;;;\n  ; The following if we ARE generating the hash code of the\n  ; symbol into the module at compile time.\n\n  ; But what about the version number of the hash code?\n  ; We need to correlate this with the code in ZILINTN if we do it.\n\n  (zcgenout nil \"DC\"\n                (if (zilspkg x1) ; If \"interned\"\n                    \"YL1(##SYMBOL,0,0,##FWHASH)\"\n                    ; else \"uninterned\" (e.g. a gensym)\n                    \"YL1(##SYMBOL,0,0,##FWGSYM)\")\n                nil)\n\n  (zcgenout nil \"DC\" `(\"F'\" ,(sxhash x1) \"'\")        \"Symbol hash code\")\n\n  (zcgend-build-string nil q (string-length (symbol-name x1)))\n )\n)\n\n;**********************************************************************\n\n; This subroutine generates constant strings.\n; Each member of the list NUMATOMS is passed to this routine.\n\n(defun zcgend-gen-string (x1 x2)\n (if (stringp x1)\n     (zcgend-build-string x2 (get x2 'quoted) (string-length x1)))\n)\n\n;**********************************************************************\n\n; This subroutine builds string text.  If the string text\n; is too long to fit on one assembler statement, a special routine\n; is executed to build the output.  This is an exception to the rule\n; that all code generation uses zcgenout to build assembler code.\n\n(defun zcgend-build-string (g q s)\n  (prog (l)\n   (setq l (length q))\n   (zcgenout g       \"DS\" \"0A\"               \"Align string to fullword\")\n   (zcgenout nil     \"DC\" \"YL1(##STRING)\"            \"String type bits\")\n   (zcgenout nil     \"DC\" `(\"AL3(\" ,s \")\")              \"String length\")\n\n   (and (zerop s) (return (zcgenout nil \"DC\" \"X'00'\" \"(Null string)\")))\n   (and (< l 55)  (return (zcgenout nil \"DC\" (cons \"C\" q) nil)))\n\n                                 ; Process all characters in quoted rep.\n   (setq q (cdr q))              ; Strip off initial quote mark.\n  start-new-card\n   (princ \"         DC    C'\" 'code) ; Generate opcode\n                                     ; and begin character string\n  loop\n   (cond\n        ((null (cdr q))  ; Final quote mark - can't move to next line\n         (princ (car q) 'code)\n         (terpri 'code)\n         (return nil))\n        ((> (zgetfpo 'code) 69) ; Near the end of the card image?\n         (princ \"'\" 'code)      ; End this piece of the string\n         (terpri 'code)         ; Go to next card\n         (go start-new-card))\n        ((or (eq (car q) '|'|) (eq (car q) '|&|)) ; Doubled character.\n         (princ (car q) 'code)     ; Print it.\n         (princ (cadr q) 'code)    ; The next must be another ' or &.\n         (setq q (cddr q))\n         (go loop))\n        (t\n         (princ (car q) 'code)    ; Generate a character of the name.\n         (setq q (cdr q))\n         (go loop)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGENOUT": {"ttr": 4882, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x104\\x00.\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:34:00", "lines": 46, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This routine constructs source statements.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgenout (label opcode operands comments)\n (ttab 0 'code)\n (if label    then (genout-princ-list label))\n (ttab 9 'code)\n (if opcode   then (genout-princ-list opcode))\n (ttab 15 'code)\n (if operands then (genout-princ-list operands)\n  else\n  if comments then (princ \",\" 'code))\n (if   (eq comments '*) ; Special request denoting continuation.\n  then\n       (ttab 71 'code)\n       (princ \"*\" 'code)\n  else\n       (ttab 36 'code)\n       (if comments (genout-princ-list comments))\n       (ttab 71 'code)\n       (princ \" \" 'code)\n  endif\n )\n (terpri 'code)\n)\n\n(defun genout-princ-list (thing)\n (cond\n  ((atom thing) (princ thing 'code))\n  (t  (dolist (x thing) (princ x 'code)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGERROR": {"ttr": 4884, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x104\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:34:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-ERROR                                                          *\n;*                                                                    *\n;**********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgerror (a)\n (let (((msg dta) a))\n  (princ \"*** Error... \")\n  (princ msg)\n  (princ \" - \")\n  (prin1 dta)\n  (terpri)\n  (zcgemit 0 () \"*****\" `(\"Error: \" ,msg \" - \" ,dta) nil)\n  (zilcoerr 8)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGETAG": {"ttr": 4886, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x15\\x9f\\x00\\x89\\x15o\\x105\\x00\\x19\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-07T00:00:00", "modifydate": "1989-06-05T10:35:00", "lines": 25, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* ZCGETAG - processes the end of a TAGBODY.                          *\n;*                                                                    *\n;**********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgetag (a) ;\n\n  nil ; Actually, this does absolutely nothing.\n\n)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGEUWP": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x106\\x00F\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:36:00", "lines": 70, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* This module generates code that finishes up UNWIND-PROTECT forms.  *\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;* 08/25/88 - Fix \"Register 1 not available for CONS\" compiler bug.    *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgeuwp (a) ;\n (prog\n       (\n        l2 ; the label to which UNWIND-PROTECT cleanup forms return\n        v  ; an item to receive the value if SETQ is involved\n        s  ; the target of the value to be set\n        c  ; the offset of the UNWIND-PROTECT stack frame\n        r  ; a register to hold the return value from the protected form\n       )\n\n  (desetq (l2 v s) a)\n;\n; Pop the UNWIND-PROTECT frame off the stack.\n;\n  (setq pdmax (cdr pdmax)      ; Pop stack height.\n        c     (car pdmax))     ; Current stack height is frame.\n;\n; Get a register, preferably \\15 if target is T.\n;\n  (setq r (zcggtbst s))\n;\n; Generate the code.\n;\n  (zcgemit 4 () \"L\"  `(\"15,\" ,(+ c 12) \"(,11)\")  \"Load return address.\")\n  (zcgemit 4 () \"LA\" `(\"14,\" ,c \"(,11)\")   \"Set address of this frame.\")\n  (zcgemit 2 () \"BR\" \"15\"                   \"Branch to return address.\")\n  (zcgemit 0 l2  \"DS\"  \"0H\"          \"Continue if not called by THROW.\")\n  (zcgemit 4 () \"L\"  `(,r \",\" ,(+ c 32) \"(,11)\")\n                                      \"Load value from protected form.\")\n\n;;; Code deleted to insure that register r gets released\n;;(or v s (return nil)) ; No side effects, so do nothing if no V/S\n\n  (zcgstvrs r v s t)    ; Store reg into SETQ variables if any.\n  (zcgsttrg r s)        ; Set target to register if any.\n\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGGETIT": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x17\\x7f\\x00\\x89\\x15o\\x106\\x00[\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-06-26T00:00:00", "modifydate": "1989-06-05T10:36:00", "lines": 91, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* This function replaces the following old functions:                *\n;*                                                                    *\n;* ZCGSTNIL (GEN-SETNIL)                                              *\n;* ZCGSETT  (GEN-SETT)                                                *\n;* ZCGSTATM (GEN-SETATOM)                                             *\n;* ZCGSTLST (GEN-SETLIST)                                             *\n;* ZCGGTPRM (GEN-GETPARM)                                             *\n;* ZCGGTLOC (GEN-GETLOCAL)                                            *\n;* ZCGSMALL (GEN-GETSMALL)                                            *\n;*                                                                    *\n;* (Note that ZCGGTVAR (GEN-GETVAR) still needs to be a separate      *\n;*  function, since it involves more complex code generation.)        *\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcggetit (a) ;\n\n     ;  b  -  the main argument of the code generator function\n     ;  v  -  an item to receive the value if SETQ is involved\n     ;  s  -  the target of the value to be set\n     ;  r  -  a register to be used\n     ;  p  -  set to special register for NIL and T\n\n (let* (((b v s) a)\n        (p (case b\n                 ((nil) '\\10)\n                 ((t)   '\\8)\n                 (t nil)))\n        (r)\n       )\n\n      (when (or v s)        ; Do nothing if no SETQ vars and no target.\n\n       (cond\n        (p                    ; If NIL or T...\n         (zcgstvrs p v s nil) ; Set SETQ variables first.\n         (when s              ; If for effect only, skip the rest.\n                              ; If being used as an argument to a\n                              ; function, just store the NIL or T\n                              ; register.  Otherwise, get a different\n                              ; register and load the NIL or T register\n                              ; into that register.\n          (setq r\n                (if (and (consp s)\n                         (eq (car s) 'arg))\n                     p\n                     (zcggtbst s)))\n\n          (unless (eq r p)    ; If register is different,\n           (zcgload r b)      ; then load register from NIL or T.\n          )\n          (zcgsttrg r s)      ; Set target, if any, to register.\n         )\n        )\n        (t                     ; Otherwise...\n         (setq r (zcggtbst s)) ; Get a register to hold the result.\n         (zcgload r b)         ; Load address of object into register.\n         (zcgstvrs r v s nil)  ; Store reg into SETQ variables if any.\n         (zcgsttrg r s)        ; Set target, if any, to register.\n        )\n       )\n      )\n )\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGGTARG": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x107\\x00\\x1a\\x00\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:37:00", "lines": 26, "newlines": 17, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"GET-ARG\"\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcggtarg (\n                 r  ; register number\n                 n  ; argument number\n                )\n\n (let ((o (+ (* (1- n) 4) (car argbase))))\n      (zcgemit 4 () \"L\" `(,r \",\" ,o \"(,11)\") `(\"Load argument \" ,n))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGGTBST": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x109\\x00s\\x003\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:39:00", "lines": 115, "newlines": 51, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"GET-BEST-REG\"\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/28/88 - Support for better register allocation for ASSQ and CAR. *\n;* 06/06/88 - Support for VALUES.                                      *\n;* 06/10/88 - Support MULTIPLE-VALUE-LIST, MULTIPLE-VALUE-BIND, THROW. *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defmacro arg-number (x) `(cadr ,x))\n\n(defun zcggtbst (s &aux (nextpcode       (car restofit))\n                        (inline-function (second nextpcode))\n                        (valuesp (and (eq inline-function 'values)\n                                      (not (eql (third nextpcode) 1)))))\n (let (\n       (last-arg-for-inline-p    (and (consp s)\n                                      (eq (car s) 'arg)\n                                      (eq (car nextpcode) 'inline)\n                                      (not valuesp)))\n       (zdefp                    (and (consp s)\n                                      (eq (car s) 'arg)\n                                      (consp (arg-number s))\n                                      (eq (cadr (arg-number s)) zdef)))\n       (r)\n      )\n\n  (when debug\n   (putdata nextpcode\n            inline-function\n            valuesp\n            last-arg-for-inline-p\n            zdefp\n            lastarg))\n\n  (when last-arg-for-inline-p\n        (zcgresv '\\0)\n        (case inline-function\n              ((cons)\n               (or (eql (arg-number s) 1) (zcgresv '\\1))\n               (or (eql (arg-number s) 2) (zcgresv '\\2)))\n        ))\n  (setq r (cond\n           (zdefp\n            (zcgresv '\\1))\n           ((and\n             (or\n              (and last-arg-for-inline-p\n                   (or\n                       (and (eq inline-function 'car)\n                            (eq (probably-use15p (fifth nextpcode)) t))\n                       (and (eq inline-function 'values)\n                            (eq (probably-use15p (fifth nextpcode)) t))\n                       (eq inline-function 'assq)\n                       (and (consp inline-function)\n                            (or (eq (car inline-function) 'rplaca)\n                                (eq (car inline-function) 'rplacd))\n                            (eq (probably-use15p (fifth nextpcode)) t))\n                   )\n              )\n              (eq (probably-use15p s) t))\n             (zcgavail '\\15))\n            (zcgresv '\\15))\n           (t\n            (zcggtreg))))\n  (when last-arg-for-inline-p\n        (when (eq lastarg 'values)\n              (setq lastarg r))\n        (or lastarg (setq lastarg r))\n        (zcgrels '\\0)\n        (case inline-function\n              ((cons)\n               (or (eql (arg-number s) 1) (zcgrels '\\1))\n               (or (eql (arg-number s) 2) (zcgrels '\\2)))\n        ))\n;;(when valuesp (setq lastarg 'values))\n  (and valuesp (null lastarg) (setq lastarg 'values))\n  r))\n\n;\n; This function is used to determine whether it's a good idea to try\n; to use register 15 (the return value register) to hold a value.\n;\n\n(defun probably-use15p (s) ; the probable value target of a target\n (case (if (consp s) (car s))\n        ((goto gonotnil gonil)\n         (probably-use15p (get (cadr s) 'rettarg)))\n        ((mvlist mvbind)\n         t)\n        ((throw)\n         (eq (cadr s) 'form))\n       (otherwise s)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGGTREG": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10B\\x00\\x19\\x00\\x0f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:42:00", "lines": 25, "newlines": 15, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"GETREG\"\n;\n; This routine allocates a register.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcggtreg ()\n (loop for r in regs\n       when (zcgavail r) return (zcgresv r)\n       finally (zerror \"No registers available, all are in use.\")))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGGTVAR": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10B\\x00j\\x00H\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:42:00", "lines": 106, "newlines": 72, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-GETVAR                                                         *\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcggtvar (z) ; Get the value of a free variable from \"ALIST\"\n (prog\n       (b   ; the main argument of the code generator function\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        sp  ; the atom pair representing the variable if SPECIAL\n        fp  ; the atom pair representing the variable if FLUID\n        a   ; the atom pair representing the variable\n        r   ; a register to be used\n        o   ; an offset to be generated\n        lbl ; a label to be branched to\n        sub ; if subroutine ZILVSYM is needed\n        var ; the variable name to be generated for comments\n       )\n\n  ; B is the ATOMIC name of the unbound variable to get.\n\n  (desetq (b v s) z)\n  (or v s (return nil)) ; No side effects, so do nothing if no V/S\n  (setq sp (assq b (cdr special-unbounds))\n        fp (assq b (cdr fluid-unbounds)))\n  (if (and sp fp)\n      (zerror\n      \"Compiler error - free variable to access both special and fluid\"\n             v))\n  (setq a (or sp fp\n       (zerror \"Compiler error - free variable to access not found\" b)))\n  (setq r (zcggtbst s)) ; Get a register, preferably \\15 if target is T.\n  (setq o (get (cdr a) 'pointer))\n  (princ \"Note - reference to non-local \")\n  (princ (cond\n          (sp 'special)\n          (fp 'lexical)\n          (t \"(and undeclared)\")))\n  (princ \" variable \")\n  (prin1 b)\n  (terpri)\n\n  (setq var (if (> (string-length (car a)) 23) (cdr a) (car a)))\n\n  (zcgemit 4 () \"L\" `(\"14,\" ,o \"(,11)\")   \"Get pointer to alist cell.\")\n  (zcgemit 4 () \"L\" `(,r \",##CDR(,14)\")        `(\"Get value of \" ,var))\n\n  (when sp                       ; If variable declared SPECIAL...\n\n  ; If subr ZILVSYM doesn't already exist, create it.\n\n   (or (setq sub (assq 'zilvsym subrs))\n       (modq subrs (setq sub (zilcosym 'zilvsym 'subrs))))\n\n   (zcgemit 4 () \"C\" `(,r \",ZLCUNBND\")     \"If variable not bound\")\n   (zcgemit 4 () \"BNE\" (setq lbl (gensym)) \"then...\")\n   (zcgemit 4 () \"L\" `(\"2,\" ,(or (get (cdr a) 'location)\n                                 (putprop (cdr a) (gensym) 'location)\n                             ))                \" get address of symbol\")\n   (zcgemit 4 () \"L\" `(\"15,\" ,(or (get (cdr sub) 'location)\n                                  (putprop (cdr sub) (gensym) 'location)\n                              ))             \" get address of ZILVSYM\")\n   (zcgemit 4 () \"LA\" `(\"1,\" ,(car pdmax) \"(,11)\") \" get stack pointer\")\n   (zcgemit 2 () \"BALR\" \"14,15\"  \" call ZILVSYM\")\n\n   (zcgbase name nil) ; Reload additional base registers if necessary.\n\n   (zcgemit 4 () \"ST\"  `(\"15,\" ,o \"(,11)\")\n                                         \" store binding cell on stack\")\n   (zcgemit 4 () \"L\"   `(,r \",##CDR(,15)\")      `(\"Get value of \" ,var))\n   (zcgemit 0 lbl \"DS\"  \"0H\"                                        nil)\n\n  )\n\n  (zcgstvrs r v s nil)  ; Store reg into SETQ variables if any.\n  (zcgsttrg r s)        ; Set target to register if any.\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGIASSQ": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x88\\x08_\\x00\\x89\\x15o\\x10B\\x00?\\x00:\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1988-03-25T00:00:00", "modifydate": "1989-06-05T10:42:00", "lines": 63, "newlines": 58, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCGIASSQ\"\n;;;\n;;; This routine generates the inline code for ASSQ.\n;;;\n;;; The registers on input were selected according to the principle\n;;; that R3 is to be the return value register, and R2 and R3 cannot\n;;; be register 0 (although R1 could conceivably be).\n;;;\n;;; Actually, R3 is selected by this routine, based on the \"s\" argument.\n;;;\n;;; This function must release registers R1 and R2, and return R3.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgiassq (r1 r2 v s com &aux r3\n                                    (newr1 r1)\n                                    (lb (gensym))\n                                    (lf (gensym))\n                                    (lx (gensym)))\n (zcgrels r1)\n (zcgrels r2)\n\n (when (eq r1 '\\15)\n  (setq newr1 (zcgresv '\\0))\n  (zcgemit 2 () \"LR\" `(\"0,\" ,r1)                             com)\n )\n (setq r3 (zcggtbst s))\n\n (zcgresv '\\14)\n\n (unless (eq r2 '\\15)\n  (zcgemit 2 () \"LR\" `(\"15,\" ,r2)                            com)\n )\n (zcgemit 2 lb \"CR\"  \"15,10\"                                 com)\n (zcgemit 4 () \"LM\"  \"14,15,##CAR(15)\"                       com)\n (zcgemit 4 () \"BE\"  lf                                      com)\n (zcgemit 4 () \"C\"   `(,newr1 \",##CAR(,14)\")                 com)\n (zcgemit 4 () \"BNE\" lb                                      com)\n (zcgemit 2 () \"LR\"  `(,r3 \",14\")                            com)\n (zcgemit 4 () \"B\"   lx                                      com)\n (zcgemit 2 lf \"LR\"  `(,r3 \",10\")                            com)\n (zcgemit 0 lx \"DS\"  \"0H\"                                    com)\n\n (zcgrels '\\14)\n (when (eq r1 '\\15) (zcgrels '\\0))\n\n r3\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGIMEMQ": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x88\\x08_\\x00\\x89\\x15o\\x10B\\x00p\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1988-03-25T00:00:00", "modifydate": "1989-06-05T10:42:00", "lines": 112, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZCGIMEMQ\"\n;;;\n;;; This routine generates the inline code for MEMQ.\n;;;\n;;; The registers on input were selected according to the principle\n;;; that R2 is to be the return value register, and R2 cannot\n;;; be register 0 (although R1 could conceivably be).\n;;;\n;;; This function must release register R1, and return R2.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcgimemq (r1 r2 v s com &aux (lb (gensym))\n                                    (lc (gensym)))\n\n (zcgrels r1)\n\n ;\n ; If MEMQ is being called predicatively, generate code to do the\n ; branch directly.  Otherwise, generate code to return the sublist\n ; or NIL as the value.\n ;\n ; Note that, because the MEMQ code does not end in a NIL test like\n ; other predicates, we can handle only very basic cases.\n ;\n\n (cond\n  ((and (null v) ; See if value unused and predicate call without GOTO\n        (consp s)\n        (or (eq (car s) 'gonil)\n            (eq (car s) 'gonotnil))\n     ;;                                     ;; ???\n     ;; (null (get (cadr s) 'gotag))        ;; ???\n     ;; (null (get (cadr s) 'progexit))     ;; ???\n     ;;                                     ;; ???\n        (zilcovta s))\n\n   (let* (((g lo) (zcgsgoto s))\n          (lx (case g\n                    (gonil    (gensym))\n                    (gonotnil lo)\n                    (t        (zerror \"ZGCSGOTO lossage\" s g lo)))))\n\n    (when debug\n          (cterpri)\n          (princ \"S=\") (prin1 s) (terpri)\n          (princ \"Property list of \") (prin1 (cadr s)) (princ \" is: \")\n          (terpri)\n          (prin1 (plist (cadr s)))\n          (terpri)\n          (let ((x (get (cadr s) 'rettarg)))\n           (when (consp x)\n            (let ((x (cadr x)))\n             (princ \"Property list of \") (prin1 x) (princ \" is: \")\n             (terpri)\n             (prin1 (plist x))\n             (terpri)\n          )))\n          (princ \"(ZCGSGOTO S)=\") (prin1 `(,g ,lo)) (terpri)\n          (princ \"Property list of \") (prin1 lo) (princ \" is: \")\n          (terpri)\n          (prin1 (plist lo))\n          (terpri)\n    )\n\n    (putprop lo t 'referenced)\n    (zcgemit 4 () \"B\" lc                                     com)\n    (zcgemit 4 lb \"C\" `(,r1 \",##CAR(,\" ,r2 \")\")              com)\n    (zcgemit 4 () \"BE\" lx                                    com)\n    (zcgemit 4 () \"L\" `(,r2 \",##CDR(,\" ,r2 \")\")              com)\n    (zcgemit 2 lc \"CR\" `(,r2 \",10\")                          com)\n    (zcgemit 4 () \"BNE\" lb                                   com)\n    (when (eq g 'gonil)\n     (zcgemit 4 () \"B\" lo                                    com)\n     (zcgemit 0 lx \"DS\" \"0H\"                                 com)\n    )\n    (zcgrels r2)    ; Return register will not be used.\n    (setq cc 'memq) ; Tell ZCGSTTRG not to generate anything.\n   )\n  )\n  (t                            ; Value is used...\n   (let ((lx (gensym)))\n    (zcgemit 4 () \"B\" lc                                     com)\n    (zcgemit 4 lb \"C\" `(,r1 \",##CAR(,\" ,r2 \")\")              com)\n    (zcgemit 4 () \"BE\" lx                                    com)\n    (zcgemit 4 () \"L\" `(,r2 \",##CDR(,\" ,r2 \")\")              com)\n    (zcgemit 2 lc \"CR\" `(,r2 \",10\")                          com)\n    (zcgemit 4 () \"BNE\" lb                                   com)\n    (zcgemit 0 lx \"DS\" \"0H\"                                  com)\n   )\n  )\n )\n\n r2\n\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGINEXT": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x88\\x08/\\x00\\x89\\x15o\\x10F\\x01u\\x01]\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1988-03-22T00:00:00", "modifydate": "1989-06-05T10:46:00", "lines": 373, "newlines": 349, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"ZCGINEXT\"\n;\n; This compiles \"extended inline code\" P-code requests.  These look\n; similar to inline code requests passed to ZCGINLIN, except that\n; the function name is a list.\n;\n; The register \"R\" to be used as return register is returned as the\n; value of this function.\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/22/88 - Support for fast inline ASSQ and MEMQ.                   *\n;*                                                                     *\n;***********************************************************************\n;\n; The following are currently supported:\n;\n; (INLINE (ARG n) 0 v s)    - compiles (ARG n) where n is a fixnum.\n; (INLINE (SETARG n) 1 v s) - compiles (SETARG n arg1) , n fixnum.\n; (INLINE (VREF n) 1 v s)   - compiles (VREF arg1 n), n fixnum.\n; (INLINE (VSET n) 2 v s)   - compiles (VSET arg1 n arg2), n fixnum.\n; (INLINE (EQ n) 1 v s)     - compiles (EQ arg1 n), n constant.\n; (INLINE (EQL n) 1 v s)    - compiles (EQL arg1 n), n a number.\n; (INLINE (CONS n) 1 v s)   - compiles (CONS arg1 n), n simple.\n; (INLINE (RPLACA n) 1 v s) - compiles (RPLACA arg1 n), n simple.\n; (INLINE (RPLACD n) 1 v s) - compiles (RPLACD arg1 n), n simple.\n; (INLINE (ASSQ n) 1 v s)   - compiles (ASSQ arg1 n), n simple.\n; (INLINE (MEMQ n) 1 v s)   - compiles (MEMQ arg1 n), n simple.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcginext (b n v s c)\n\n ;      b   ; the list (function qualifier) telling what to compile\n ;      n   ; the number of other arguments passed to the function\n ;      v   ; an item to receive the value if SETQ is involved\n ;      s   ; the target of the value to be set\n ;      c   ; comment identifying inline code\n\n (prog (\n        f   ; the name of the function to be coded inline\n        q   ; a qualifier object used when inline-compiling the function\n       )\n       (desetq (f q) b)\n       (if (and (not (zerop n))\n                (null lastarg))\n           (return nil)) ; Let ZCGINLIN handle null LASTARG problem.\n       (return\n        (case f\n         (eq     (or (eql n 1) (go wna-error)) (zcgineq     q v s c))\n         (eql    (or (eql n 1) (go wna-error)) (zcgineql    q v s c))\n         (cons   (or (eql n 1) (go wna-error)) (zcgincons   q v s c))\n         (rplaca (or (eql n 1) (go wna-error)) (zcginrplaca q v s c))\n         (rplacd (or (eql n 1) (go wna-error)) (zcginrplacd q v s c))\n         (assq   (or (eql n 1) (go wna-error)) (zcginassq   q v s c))\n         (memq   (or (eql n 1) (go wna-error)) (zcginmemq   q v s c))\n         (arg    (or (eql n 0) (go wna-error)) (zcginarg    q v s c))\n         (setarg (or (eql n 1) (go wna-error)) (zcginsetarg q v s c))\n         (vref   (or (eql n 1) (go wna-error)) (zcginvref   q v s c))\n         (vset   (or (eql n 2) (go wna-error)) (zcginvset   q v s c))\n         (t      (zerror \"No inline code generator for\" b))\n        ))\nwna-error\n  (when lastarg (zcgrels lastarg))\n  (cterpri 'code)\n  (princ \"*** Wrong number of inline args\" 'code) ; Force bad assembly\n  (terpri 'code)\n  (return nil) ; Return some random dumb register\n))\n\n;======================================================================\n\n;\n; Inline code generator for (EQ arg1 n)\n;\n; Possible forms of (f q) are:\n;\n; (EQ NIL)           - quick compare to NIL\n; (EQ T)             - quick compare to T\n; (EQ UNBOUND)       - quick compare to (ZILUNBND)\n; (EQ (xxx . yyy)    - quick compare to constant object represented\n;                      by the dotted pair (xxx . yyy)\n;\n\n(defun zcgineq (q v s c\n                &aux\n                (opcode    (case q\n                                ((nil t) \"CR\")\n                                (t       \"C\")))\n                (ilen      (case q\n                                ((nil t) 2   )\n                                (t       4  )))\n                (comparand (case q\n                                ((nil)     \"10\")\n                                ((t)       \"8\")\n                                ((unbound) \"ZLCUNBND\")\n                                (t         (where-it-is q))))\n                (onam      (cond\n                            ((eq q 'unbound)        \"#<UNBOUND>\")\n                            ((atom q)               q)\n                            ((< (flatc (car q)) 16) (car q))\n                            (t                      (cdr q))))\n               )\n\n (zcgemit ilen () opcode `(,lastarg \",\" ,comparand)\n                                                  `(\"Inline EQ \" ,onam))\n (zcgipred '(be bne) v s \"Inline code for EQ\")\n)\n\n;======================================================================\n\n;\n; Inline code generator for (EQL arg1 n)\n;\n; Possible forms of (f q) are:\n;\n; (EQL n)             - quick compare to small fixnum n\n; (EQL (xxx . yyy)    - quick compare to constant fixnum or flonum\n;                       represented by the dotted pair (xxx . yyy)\n;\n; Sample code sequences:\n;\n; (EQL X 1)     --> L   R1,X\n;                   CLC 0(8,R1),#SFT+8\n;\n; (EQL X 10.0)  --> L   R1,X\n;                   L   R14,G12345\n;                   CLC 0(8,R1),0(R14)\n;\n\n(defun zcgineql (q v s c)\n\n (cond\n  ((fixnump q)\n   (zcgemit 6 () \"CLC\" `(\"0(8,\"     ; )\n                         ,lastarg   ; ((\n                         ,(if (minusp q) \"),#SFT\" \"),#SFT+\") ,(* q 8))\n                                                    `(\"Inline EQL \" ,q))\n  )\n  (t\n   (zcgemit 4 () \"L\"   `(\"14,\" ,(where-it-is q))\n                                              `(\"Get number \" ,(car q)))\n   (zcgemit 6 () \"CLC\" `(\"0(8,\" ,lastarg \"),0(14)\")\n                                                  \"Inline code for EQL\")\n  )\n )\n (zcgipred '(be bne) v s \"Inline code for EQL\")\n)\n\n;======================================================================\n\n;\n; Inline code generator for (CONS arg1 n)\n;\n;\n; Sample code sequences:\n;\n; (CONS X NIL)  --> L    R1,X\n;                   LR   R2,R10\n;                   L    R15,ZLCCONS\n;                   BALR R14,R15\n;\n; (CONS X Y)    --> L    R1,X\n;                   L    R2,G12345 (address of Y)\n;                   L    R15,ZLCCONS\n;                   BALR R14,R15\n;\n\n(defun zcgincons (q v s c &aux r)\n (zcgrels lastarg)\n (unless (zcgavail '\\1)\n     (zcgemit 0 () \"!\" \"Register 1 not available for CONS\" \"ZCGINEXT\")\n     (warn \"Register 1 not available to code generator for CONS\")\n )\n (unless (zcgavail '\\2)\n     (zcgemit 0 () \"!\" \"Register 2 not available for CONS\" \"ZCGINEXT\")\n     (warn \"Register 2 not available to code generator for CONS\")\n )\n (unless (eq lastarg (zcgresv '\\1))\n         (zcgemit 2 () \"LR\" `(\"1,\" ,lastarg) \"Inline code for CONS\"))\n (zcgemit 4 () \"L\" \"15,ZLCCONS\" \"Get address of ZILCONS.\")\n (zcgload (zcgresv '\\2) q)           ; Done here for pipelining opt.\n (zcgemit 2 () \"BALR\" \"14,15\"   \"Call ZILCONS.\")\n (setq r (zcgresv '\\15))\n (zcgrels '\\1)\n (zcgrels '\\2)\n r\n)\n\n;======================================================================\n\n;\n; Inline code generator for (RPLACA arg1 n) and (RPLACD arg1 n)\n;\n;\n; Sample code sequences:\n;\n; (RPLACA X NIL)  --> L    R1,X\n;                     ST   R10,##CAR(,R1)\n;\n; (RPLACD X Y)    --> L    R1,X\n;                     L    R2,Y\n;                     ST   R2,##CDR(,R1)\n;\n\n(defmacro zcginrplaca (q v s c)\n `(zcginrplacx ,q ,v ,s ,c t))\n\n(defmacro zcginrplacd (q v s c)\n `(zcginrplacx ,q ,v ,s ,c nil))\n\n(defun zcginrplacx (q v s c carp &aux r)\n (case q\n  ((nil)\n   (setq r '\\10))      ; If NIL, store reg 10\n  ((t)\n   (setq r '\\8))       ; If T, store reg 8\n  (t\n   (setq r (zcggtreg)) ; Otherwise, get any register\n   (zcgload r q)))     ; Get arg2 into register\n (zcgemit 4 ()\n           \"ST\"\n           `(,r ,(if carp \",##CAR(,\" #|)|# \",##CDR(,\") ,lastarg \")\")\n           `(\"Inline code for \" ,(if carp \"RPLACA\" \"RPLACD\")))\n (zcgrels r)\n lastarg\n)\n\n;======================================================================\n\n;\n; Inline code generator for (ASSQ arg1 n)\n;\n; Possible forms of (f q) are:\n;\n; (ASSQ SALIST)      - quick compare to (SALIST)\n; (ASSQ (xxx . yyy)) - quick compare to constant object represented\n;                      by the dotted pair (xxx . yyy)\n;\n; See ZCGIASSQ module for details of code generation.\n;\n; LASTARG contains arg 1 to ASSQ.\n;\n\n(defun zcginassq (q v s c &aux r2)\n (zcgresv '\\0)          ; Can't use register 0 for arg 2.\n (setq r2 (zcggtbst t)) ; Set arg2 register (try to get register 15).\n (zcgrels '\\0)\n (cond\n  ((consp q)\n   (zcgload r2 q))        ; Load fast arg2.\n  ((eq q 'salist)\n   (zcgemit 4 () \"L\" `(,r2 \",ZLCSALST\") \"Load special ALIST.\"))\n  (t\n   (zerror \"Bad thing passed to ASSQ as fast arg2\" q)))\n (zcgiassq lastarg r2 v s \"Inline code for ASSQ\") ; Returns return reg.\n)\n\n;======================================================================\n\n;\n; Inline code generator for (MEMQ arg1 n)\n;\n; See ZCGIMEMQ module for details of code generation.\n;\n; LASTARG contains arg 1 to MEMQ.\n;\n\n(defun zcginmemq (q v s c &aux r2)\n (unless (consp q) (zerror \"Bad thing passed to MEMQ as fast arg2\" q))\n (zcgresv '\\0)\n (setq r2 (zcggtbst s)) ; Set arg2/return reg (can't use register 0).\n (zcgrels '\\0)\n (zcgload r2 q)         ; Load fast arg2.\n (zcgimemq lastarg r2 v s \"Inline code for MEMQ\") ; Returns return reg.\n)\n\n;======================================================================\n\n;\n; Inline code generator for (ARG n)\n;\n\n(defun zcginarg (q v s c &aux r)\n (if (null q)\n  then\n   (setq r (zcgresv '\\15))\n   (zcgresv '\\1)\n   (zcgresv '\\2)\n   (zcgresv '\\14)\n   (zcgemit 2 () \"LR\"    \"2,11\"                            c)\n   (zcgemit 4 () \"S\"     \"2,0(,2)\"                         c)\n   (zcgemit 4 () \"SRA\"   \"2,2\"                             c)\n   (zcgemit 2 () \"BCTR\"  \"2,0\"                             c)\n   (zcgemit 4 () \"L\"     \"15,ZLCCONS Cons\"                 c)\n   (zcgemit 4 () \"L\"     \"1,#SFT     up a\"                 c)\n   (zcgemit 2 () \"BALR\"  \"14,15    fixnum\"                 c)\n   (zcgrels '\\1)\n   (zcgrels '\\2)\n   (zcgrels '\\14)\n  else\n  if (fixnump q)\n  then\n   (setq r (zcggtbst s))\n   (zcgemit 4 () \"L\"    \"14,0(,11)\"                        c)\n   (zcgemit 4 () \"L\"    `(,r \",\" ,(* q 4) \"(,14)\")         c)\n  else\n   (zerror \"Bad inline form\" (list 'arg q))\n  endif\n )\n r\n)\n\n;======================================================================\n\n;\n; Inline code generator for SETARG\n;\n\n(defun zcginsetarg (q v s c &aux r)\n (setq r lastarg)\n (zcgemit 4 () \"L\"    \"14,0(,11)\"                        c)\n (zcgemit 4 () \"ST\"   `(,r \",\" ,(* q 4) \"(,14)\")         c)\n r\n)\n\n;======================================================================\n\n;\n; Inline code generator for VREF\n;\n\n(defun zcginvref (q v s c &aux r)\n (zcgrels lastarg)\n (setq r (zcggtbst s))\n (zcgemit 4 () \"L\"    `(,r \",##VECDAT+\" ,(* q 4) \"(,\" ,lastarg \")\") c)\n r\n)\n\n;======================================================================\n\n;\n; Inline code generator for VSET\n;\n\n(defun zcginvset (q v s c &aux r r1)\n (setq r lastarg)\n (zcgresv '\\0)\n (setq r1 (zcggtbst s))\n (zcgrels '\\0)\n (zcggtarg r1 1)\n (zcgrels r1)\n (zcgemit 4 () \"ST\"   `(,r \",##VECDAT+\" ,(* q 4) \"(,\" ,r1 \")\") c)\n r\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGINLIN": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x88\\x08/\\x00\\x89\\x15o\\x10F\\x03\\x16\\x02\\xcb\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1988-03-22T00:00:00", "modifydate": "1989-06-05T10:46:00", "lines": 790, "newlines": 715, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-INLINE\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/22/88 - Support for inline ASSQ and MEMQ.                        *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;* 06/06/88 - Support for VALUES.                                      *\n;* 12/16/88 - Support for CHARP (CHARACTERP).                          *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(include #.(zil-source-member zilmacs)) ; ZILCO macros.\n\n(defmacro inline-call (argcount fun)\n `(cond\n   ,@(unless (zerop argcount)\n             `(((null lastarg) nil)))\n   (,(if (zerop argcount)\n         `(zerop n)\n         `(eql n ,argcount))\n                               (,fun b v s com))\n   (t                          (go badargs))))\n\n\n(defun zcginlin (a) ;\n (prog\n       (b   ; the name of the function to be invoked inline\n        n   ; the number of arguments passed to the function\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        r   ; a return register to be used\n        com ; comment identifying inline code\n       )\n       (desetq (b n v s) a)\n       (setq com `(\"Inline code for \" ,b))\n\n\n       (setq r\n        (cond\n\n        ; Check for \"extended\" inline-code form\n\n         ( (consp b) (zcginext b n v s com))\n\n         ( (eq b 'car)        (inline-call 1 zcggicar))\n         ( (eq b 'cdr)        (inline-call 1 zcggicdr))\n         ( (eq b 'zcar)       (inline-call 1 zcggizcar))\n         ( (eq b 'zcdr)       (inline-call 1 zcggizcdr))\n         ( (eq b 'pname)      (inline-call 1 zcggipname))\n         ( (eq b 'plist)      (inline-call 1 zcggiplist))\n         ( (eq b 'funfun)     (inline-call 1 zcggifunfun))\n         ( (eq b 'funenv)     (inline-call 1 zcggifunenv))\n         ( (eq b 'rplaca)     (inline-call 2 zcggirplaca))\n         ( (eq b 'rplacd)     (inline-call 2 zcggirplacd))\n         ( (eq b 'setplist)   (inline-call 2 zcggistplst))\n         ( (eq b 'cons)       (inline-call 2 zcggicons))\n         ( (eq b 'eq)         (inline-call 2 zcggieq))\n         ( (eq b 'atom)       (inline-call 1 zcggiatom))\n         ( (eq b 'numberp)    (inline-call 1 zcgginump))\n         ( (eq b 'integerp)   (inline-call 1 zcggiintp))\n         ( (eq b 'fixp)       (inline-call 1 zcggiintp))\n         ( (eq b 'floatp)     (inline-call 1 zcggiflop))\n         ( (eq b 'codep)      (inline-call 1 zcggicodep))\n         ( (eq b 'vecp)       (inline-call 1 zcggivecp))\n\n         ( (memq b '(symbolp fixnump sfloatp dfloatp bigp\n                     subrp closurep stringp vectorp funargp structp))\n                              (inline-call 1 zcggitype))\n\n         ( (eq b 'zerop   )   (inline-call 1 zcggizerop      ))\n         ( (eq b 'minusp  )   (inline-call 1 zcggiminusp     ))\n         ( (eq b 'evenp   )   (inline-call 1 zcggievenp      ))\n         ( (eq b 'oddp    )   (inline-call 1 zcggioddp       ))\n\n         ( (eq b 'consp   )   (inline-call 1 zcggiconsp      ))\n         ( (eq b 'listp   )   (inline-call 1 zcggilistp      ))\n         ( (eq b 'plusp   )   (inline-call 1 zcggiplusp      ))\n\n         ( (eq b 'charp   )   (inline-call 1 zcggicharp      ))\n\n         ( (eq b 'vref)       (inline-call 2 zcggivref))\n         ( (eq b 'vset)       (inline-call 3 zcggivset))\n         ( (eq b 'assq)       (inline-call 2 zcggiassq))\n         ( (eq b 'memq)       (inline-call 2 zcggimemq))\n\n         ( (eq b 'values)     (zcggivalues b n v s com))\n\n         ( (eq b 'oblist)     (inline-call 0 zcggioblist))\n         ( (eq b 'salist)     (inline-call 0 zcggisalist))\n         ( (eq b 'setsalst)   (inline-call 1 zcggisetsal))\n         ( (eq b 'zilunbnd)   (inline-call 0 zcggiunbound))\n         ( (eq b 'rmnil)      (inline-call 0 zcggirmnil))\n         ( (eq b 'pbind)      (inline-call 1 zcggipbind))\n         ( (eq b 'setpbind)   (inline-call 2 zcggistpbnd))\n\n         ( (eq b 'arg)        (inline-call 1 zcggiarg))\n         ( (eq b 'setarg)     (inline-call 2 zcggisetarg))\n         ( (eq b 'listify)    (inline-call 1 zcggilistify))\n\n         ( t (zerror \"No inline code generator for\" b))\n        ))\n\n;\n; Note that stack popping has to be done before ZCGSTTRG, so that\n; references to arguments as the target are resolved correctly.\n;\n\n       (setq argbase (cdr argbase))   ; Pop argument base stack\n       (setq pdmax (cdr pdmax))       ; Pop stack height\n\n;\n; R was set to the register containing the return value.\n;\n       (setq lastarg nil)    ; Clear \"last argument\" register indication\n       (cond\n        (r\n           ; The \"NIL\" below assumes that no inline forms return\n           ; multiple values.  If this should change, you know what\n           ; to do.\n           (zcgstvrs r v s nil); Store reg into SETQ variables if any.\n           (zcgsttrg r s)      ; Set target to register if any.\n        )\n        (t\n           (go nolastarg)\n        )\n       )\n\n  (return nil)\n\nbadargs\n\n  (when lastarg (zcgrels lastarg))\n  (cterpri 'code)\n  (princ \"*** Wrong number of inline args\" 'code) ; Force bad assembly\n  (terpri 'code)\n  (return)\n\nnolastarg\n\n  (terpri)\n  (terpri)\n  (princ \"Compiler warning:\")\n  (terpri)\n  (princ \"Code did not set last argument to function \")\n  (prin1 b)\n  (terpri)\n  (princ \"Possible cause:\")\n  (terpri)\n  (princ \"Unconditional branch (call to GO or RETURN)\")\n  (princ \"used in code to pass argument to function.\")\n  (terpri)\n  (princ \"Action taken by compiler:\")\n  (terpri)\n  (princ \"The code to perform the \")\n  (prin1 b)\n  (princ \" operation is not generated.\")\n  (terpri)\n  (terpri)\n  (return)\n\n))\n\n(defmacro zcggiplist  (&rest z) `(zcggiplist/pname 'plist . ,z))\n(defmacro zcggipname  (&rest z) `(zcggiplist/pname 'pname . ,z))\n(defmacro zcggipbind  (&rest z) `(zcggiplist/pname 'pbind . ,z))\n(defmacro zcggizcar   (&rest z) `(zcggizcar/zcdr 'zcar . ,z))\n(defmacro zcggizcdr   (&rest z) `(zcggizcar/zcdr 'zcdr . ,z))\n(defmacro zcggicdr    (&rest z) `(zcggizcar/zcdr 'cdr . ,z))\n\n;\n; Inline code generator for CAR\n;\n(defun zcggicar (b v s com &aux r)\n (setq r (zcginlin-set-reg-from lastarg s com))\n (zcgemit 2 () \"CR\" `(,r \",10\")             com)  ; If NIL,\n (zcgemit 4 () \"BE\" \"*+8\"                   com)  ; return self.\n (zcgemit 4 ()\n           \"L\"\n           `(,r \",##CAR(,\" ,lastarg \")\")\n           com)\n r\n)\n\n;\n; Inline code generator for ZCAR/ZCDR\n;\n(defun zcggizcar/zcdr (f b v s com &aux r)\n  (zcgrels lastarg)\n  (setq r (zcggtbst s))\n  (zcgemit 4 ()\n            \"L\"\n            `(,r ,(if (eq f 'zcar) \",##CAR(,\" \",##CDR(,\") ,lastarg \")\")\n            com)\n r\n)\n\n;\n; Inline code generator for PLIST/PNAME\n;\n(defun zcggiplist/pname (f b v s com &aux r)\n  (zcgrels lastarg)\n  (setq r (zcggtbst s))\n  (zcgemit 4 ()\n            \"L\"\n            `(,r ,(case f\n                        (plist \",##PLIST(,\")   ; )\n                        (pname \",##PNAME(,\")   ; )\n                        (pbind \",##PVALUE(,\")  ; )\n                                               ; (\n                  ) ,lastarg \")\")\n            com)\n r\n)\n\n;\n; Inline code generator for RPLACA/RPLACD\n;\n(defmacro zcggirplaca (&rest z) `(zcggirpl t   . ,z))\n(defmacro zcggirplacd (&rest z) `(zcggirpl nil . ,z))\n\n(defun zcggirpl (carp b v s com &aux r)\n  (zcgresv '\\0) ; Cannot use register 0 for CAR/CDR/etc.\n  (setq r (zcggtbst s))\n  (zcgrels '\\0)\n  (zcggtarg r 1)  ; Pick up argument 1\n  (zcgemit 4 ()\n            \"ST\"\n            `(,lastarg ,(if carp \",##CAR(,\" \",##CDR(,\") ,r \")\")\n            com)\n  (zcgrels lastarg)\n r\n)\n\n;\n; Inline code generator for SETPLIST\n;\n(defun zcggistplst (b v s com &aux r)\n  (zcgresv '\\0) ; Cannot use register 0 for CAR/CDR/etc.\n  (setq r (zcggtbst s))\n  (zcgrels '\\0)\n  (zcggtarg r 1)  ; Pick up argument 1\n  (zcgemit 4 ()\n            \"ST\"\n            `(,lastarg \",##PLIST(,\" ,r \")\")\n            com)\n  (zcgrels lastarg)\n r\n)\n\n;\n; Inline code generator for SETPBIND\n;\n(defun zcggistpbnd (b v s com &aux r)\n  (zcgresv '\\0) ; Cannot use register 0 for CAR/CDR/etc.\n  (setq r (zcggtbst s))\n  (zcgrels '\\0)\n  (zcggtarg r 1)  ; Pick up argument 1\n  (zcgemit 4 ()\n            \"ST\"\n            `(,lastarg \",##PVALUE(,\" ,r \")\")\n            com)\n  (zcgrels lastarg)\n r\n)\n\n;\n; Inline code generator for FUNFUN/FUNENV\n;\n(defmacro zcggifunfun (&rest z) `(zcggifunref 0 . ,z))\n(defmacro zcggifunenv (&rest z) `(zcggifunref 4 . ,z))\n\n(defun zcggifunref (offset b v s com &aux r)\n  (zcgrels lastarg)\n  (setq r (zcggtbst s))\n  (zcgemit 4 ()\n            \"L\"\n            `(,r \",##VECDAT+\" ,offset \"(,\" ,lastarg \")\")\n            com)\n r\n)\n\n;\n; Inline code generator for OBLIST\n;\n(defun zcggioblist (b v s com &aux r)\n  (setq r (zcggtbst s))\n  (zcgemit 4 () \"L\" `(,r \",ZLCOBLST\") com)\n r\n)\n;\n; Inline code generator for SALIST\n;\n(defun zcggisalist (b v s com &aux r)\n  (setq r (zcggtbst s))\n  (zcgemit 4 () \"L\" `(,r \",ZLCSALST\") com)\n r\n)\n;\n; Inline code generator for ZILUNBND\n;\n(defun zcggiunbound (b v s com &aux r)\n  (setq r (zcggtbst s))\n  (zcgemit 4 () \"L\" `(,r \",ZLCUNBND\") com)\n r\n)\n;\n; Inline code generator for RMNIL\n;\n(defun zcggirmnil (b v s com &aux r)\n  (setq r (zcggtbst s))\n  (zcgemit 4 () \"L\" `(,r \",ZLCRMNIL\") com)\n r\n)\n;\n; Inline code generator for FALIST - suppressed\n;\n;(defun zcggifalist (b v s com &aux r)\n;  (setq r (zcggtbst s))\n;  (zcgemit 4 () \"L\" `(,r \",ZLCFALST\") com)\n; r\n;)\n;\n; Inline code generator for SETSALST\n;\n(defun zcggisetsal (b v s com &aux r)\n  (setq r lastarg)\n  (zcgemit 4 () \"ST\" `(,r \",ZLCSALST\") com)\n r\n)\n;\n; Inline code generator for SETFALST - suppressed\n;\n;(defun zcggisetfal (b v s com &aux r)\n;  (setq r lastarg)\n;  (zcgemit 4 () \"ST\" `(,r \",ZLCFALST\") com)\n; r\n;)\n;\n; Inline code generator for CONS\n;\n(defun zcggicons (b v s com &aux r)\n  (zcgrels lastarg)\n  (unless (zcgavail '\\1)\n      (warn \"Register 1 not available to code generator for CONS\")\n      (zcgemit 0 () \"!\" \"Register 1 not available for CONS\" \"ZCGINLIN\")\n  )\n  (unless (zcgavail '\\2)\n      (warn \"Register 2 not available to code generator for CONS\")\n      (zcgemit 0 () \"!\" \"Register 2 not available for CONS\" \"ZCGINLIN\")\n  )\n  (when (eq lastarg '\\1)\n        (setq lastarg '\\2)\n        (zcgemit 2 () \"LR\" \"2,1\" com)\n  )\n  (zcggtarg (zcgresv '\\1) 1) ; Pick up argument 1\n  (unless (eq lastarg (zcgresv '\\2))\n          (zcgemit 2 () \"LR\" `(\"2,\" ,lastarg) com)\n  )\n  (zcgemit 4 () \"L\" \"15,ZLCCONS\" com)\n  (zcgemit 2 () \"BALR\" \"14,15\"   com)\n  (setq r (zcgresv '\\15))\n  (zcgrels '\\1)\n  (zcgrels '\\2)\n r\n)\n;\n; Inline code generator for ASSQ\n;\n(defun zcggiassq (b v s com &aux r1 r2)\n (setq r2 (zcginlin-set-reg-from lastarg s com)) ; Get arg2 reg (\u00ac 0)\n (setq r1 (zcggtreg))   ; Get arg1 register (can be anything at all)\n (zcggtarg r1 1)        ; Pick up stacked argument 1\n (zcgiassq r1 r2 v s com)\n)\n;\n; Inline code generator for MEMQ\n;\n(defun zcggimemq (b v s com &aux r1 r2)\n (setq r2 (zcginlin-set-reg-from lastarg s com)) ; Get arg2/ret (\u00ac 0)\n (setq r1 (zcggtreg))   ; Get arg1 register (can be anything at all)\n (zcggtarg r1 1)        ; Pick up stacked argument 1\n (zcgimemq r1 r2 v s com)\n)\n;\n; Inline code generator for EQ\n;\n(defun zcggieq (b v s com &aux r)\n  (setq r (zcggtreg))\n  (zcggtarg r 1) ; Pick up argument 1\n  (zcgemit 2 () \"CR\" `(,r \",\" ,lastarg) com)\n  (zcgrels r)\n  (zcgipred '(be bne) v s com)\n)\n;\n; Inline code generator for ATOM\n;\n(defun zcggiatom (b v s com)\n  (zcgemit 4 () \"TM\" `(\"##TYPE(\" ,lastarg \"),##ATOM\") com)\n  (zcgipred '(bo bno) v s com)\n)\n;\n; Inline code generator for CONSP\n;\n(defun zcggiconsp (b v s com)\n  (zcgemit 4 () \"TM\" `(\"##TYPE(\" ,lastarg \"),##ATOM\") com)\n  (zcgipred '(bz bnz) v s com)\n)\n;\n; Inline code generator for NUMBERP\n;\n(defun zcgginump (b v s com)\n  (zcgemit 4 () \"CLI\" `(\"##TYPE(\" ,lastarg \"),##FLONUM\") com)\n  (zcgipred '(bnl bl) v s com)\n)\n;\n; Inline code generator for INTEGERP\n;\n(defun zcggiintp (b v s com)\n  (zcgemit 4 () \"TM\" `(\"##TYPE(\" ,lastarg \"),##INT\") com)\n  (zcgipred '(bo bno) v s com)\n)\n;\n; Inline code generator for FLOATP\n;\n(defun zcggiflop (b v s com)\n  (zcgemit 4 () \"TM\" `(\"##TYPE(\" ,lastarg \"),##FLONUM\") com)\n  (zcgipred '(bo bno) v s com)\n)\n;\n; Inline code generator for CODEP\n;\n(defun zcggicodep (b v s com)\n  (zcgemit 4 () \"TM\" `(\"##TYPE(\" ,lastarg \"),##CODE\") com)\n  (zcgipred '(bo bno) v s com)\n)\n;\n; Inline code generator for VECP\n;\n(defun zcggivecp (b v s com)\n  (zcgemit 4 () \"TM\" `(\"##TYPE(\" ,lastarg \"),##VEC\") com)\n  (zcgipred '(bo bno) v s com)\n)\n;\n; Inline code generator for miscellaneous predicates\n;\n(defun zcggitype (b v s com)\n  (zcgemit 4 () \"CLI\" `(\"##TYPE(\"\n                          ,lastarg\n                          \"),\"\n                          ,(cond\n                            ((eq b 'symbolp)  \"##SYMBOL\")\n                            ((eq b 'fixnump)  \"##FIXNUM\")\n                            ((eq b 'sfloatp)  \"##SFLOAT\")\n                            ((eq b 'dfloatp)  \"##DFLOAT\")\n                            ((eq b 'bigp)     \"##BIGNUM\")\n                            ((eq b 'subrp)    \"##SUBR\"  )\n                            ((eq b 'closurep) \"##CLOSUR\")\n                            ((eq b 'stringp)  \"##STRING\")\n                            ((eq b 'vectorp)  \"##VECTOR\")\n                            ((eq b 'funargp)  \"##FUNARG\")\n                            ((eq b 'structp)  \"##STRUCT\")\n                                                                 )) com)\n  (zcgipred '(be bne) v s com)\n)\n\n;;;\n;;; LEXPR predicates.  These are compiled inline with the\n;;; assumption that it \"is an error\" for any argument to be\n;;; a non-fixnum.  The code assumes that any argument is a\n;;; fixnum.  The cases in this module are for a non-constant\n;;; argument to ARG/SETARG, which is assumed to be a fixnum,\n;;; since it \"is an error\" for it to be otherwise.\n;;;\n;;; ARG/SETARG with a constant argument is handled by ZCGINEXT.\n;;;\n;;; LISTIFY does not run into this problem, since the argument\n;;; thereto is passed to the ZILXLFY routine as is.\n;;;\n\n(defun zcggiarg (b v s com &aux r)\n (zcgrels lastarg)\n (zcgresv '\\0)\n (setq r (zcggtbst s))\n (zcgrels '\\0)\n (zcgemit 4 () \"L\"    `(,r \",##CDR(,\" ,lastarg \")\")        com)\n (zcgemit 4 () \"SLA\"  `(,r \",2\")                           com)\n (zcgemit 4 () \"L\"    \"14,0(,11)\"                          com)\n (zcgemit 4 () \"L\"    `(,r \",0(\" ,r \",14)\")                com)\n r\n)\n\n(defun zcggisetarg (b v s com &aux r r1)\n (zcgresv '\\0)\n (setq r1 (zcggtbst s))\n (zcgrels '\\0)\n (setq r lastarg)\n (zcggtarg r1 1)  ; Get argument 1.\n (zcgrels r1)\n (zcgemit 4 () \"L\"    `(,r1 \",##CDR(,\" ,r1 \")\")            com)\n (zcgemit 4 () \"SLA\"  `(,r1 \",2\")                          com)\n (zcgemit 4 () \"L\"    \"14,0(,11)\"                          com)\n (zcgemit 4 () \"ST\"   `(,r \",0(\" ,r1 \",14)\")               com)\n r\n)\n\n(defun zcggilistify (b v s com &aux r sub)\n  (zcgrels lastarg)\n  (or (zcgavail '\\0)\n      (zerror \"Register 0 not available to code generator for LISTIFY\"))\n  (or (zcgavail '\\1)\n      (zerror \"Register 1 not available to code generator for LISTIFY\"))\n  (zcgresv '\\0)\n  (zcgresv '\\1)\n  (unless (eq lastarg '\\1)\n          (zcgemit 2 () \"LR\" `(\"1,\" ,lastarg) com)\n  )\n\n; Get subr ZILXLFY.\n\n  (setq sub (or (assq 'zilxlfy subrs)\n                (zerror \"No SUBR for ZILXLFY!\")))\n\n  (zcgemit 4 () \"L\" `(\"15,\" ,(or (get (cdr sub) 'location)\n                                 (putprop (cdr sub) (gensym) 'location))\n                     ) \"Get address of ZILXLFY.\")\n  (zcgemit 4 () \"LA\" `(\"0,\" ,(car argbase) \"(,11)\") com)\n  (zcgemit 2 () \"BALR\" \"14,15\" \"Call ZILXLFY to execute LISTIFY.\")\n  (zcgbase name nil) ; Reload additional base registers if necessary.\n  (setq r (zcgresv '\\15))\n  (zcgrels '\\0)\n  (zcgrels '\\1)\n r\n)\n\n;;; Vector predicates.  These are compiled inline with the\n;;; assumption that it \"is an error\" for the argument to be\n;;; a non-vector.  The code assumes that the argument is a\n;;; vector.  The cases in this module are for a non-constant\n;;; index argument, which is assumed to be a fixnum, since\n;;; it \"is an error\" for it to be otherwise.\n;;;\n;;; Cases with a constant index are handled by ZCGINEXT.\n;;;\n\n;\n; Inline code generator for VREF\n;\n(defun zcggivref (b v s com &aux r r1 r2)\n  (zcgresv '\\0)\n  (setq r1 (zcggtbst s)) ; Arg 1 - pointer to vector\n  (setq r2 (zcggtbst s)) ; Arg 2 - pointer to index\n  (zcgrels '\\0)\n  (zcggtarg r1 1)  ; Pick up argument 1\n  (zcgrels lastarg)\n  (zcgrels r1)\n  (zcgrels r2)\n  (setq r (zcggtbst s)) ; Return value\n  (zcgemit 4 () \"L\"   `(,r2 \",##CDR(,\" ,lastarg \")\") com)\n  (zcgemit 4 () \"SLA\" `(,r2 \",2\") com)\n  (zcgemit 4 () \"L\"   `(,r \",##VECDAT(\" ,r2 \",\" ,r1 \")\") com)\n r\n)\n;\n; Inline code generator for VSET\n;\n(defun zcggivset (b v s com &aux r r1 r2)\n  (setq r lastarg)\n  (zcgresv '\\0)\n  (setq r1 (zcggtbst s)) ; Arg 1 - pointer to vector\n  (setq r2 (zcggtbst s)) ; Arg 2 - pointer to index\n  (zcgrels '\\0)\n  (zcggtarg r1 1)  ; Pick up argument 1\n  (zcggtarg r2 2)  ; Pick up argument 2\n  (zcgrels r1)\n  (zcgrels r2)\n  (zcgemit 4 () \"L\"   `(,r2 \",##CDR(,\" ,r2 \")\") com)\n  (zcgemit 4 () \"SLA\" `(,r2 \",2\") com)\n  (zcgemit 4 () \"ST\"  `(,r \",##VECDAT(\" ,r2 \",\" ,r1 \")\") com)\n r\n)\n\n;\n; Inline code generator for VALUES\n;\n(defun zcggivalues (b n v s com &aux r)\n (cond\n  ((eql n 1)                              ; If (VALUES oneform)\n   (setq r lastarg)                       ; then\n   (and (eq r '\\15)                       ; if register is 15 and\n        (zilcomvp v s)                    ; multiple values might be\n        (zcgemit 2 () \"LR\" \"15,15\" com))  ; returned, suppress them.\n   r\n  )\n  (t\n   (setq r (zcgresv '\\15))\n   (zcgresv '\\0)\n   (zcgresv '\\1)\n   (zcgresv '\\2)\n   (zcgresv '\\14)\n   (setq lastarg nil)\n   (zcgemit 4 () \"LA\"  `(\"1,\" ,(car argbase) \"(,11)\") com)\n   (if (zerop n)\n       (zcgemit 2 () \"XR\" \"2,2\"       com)\n       (zcgemit 4 () \"LA\" `(\"2,\" ,n)  com)\n   )\n   (zcgemit 4 () \"L\"     \"15,ZLCVALS\" com)\n   (zcgemit 2 () \"XR\"    \"0,0\"        com)\n   (zcgemit 2 () \"BALR\"  \"14,15\"      com)\n\n   (zcgbase name nil)  ;  Reload additional base register if necessary.\n\n   (zcgrels '\\0)\n   (zcgrels '\\1)\n   (zcgrels '\\2)\n   (zcgrels '\\14)\n   r)))\n\n;\n; Inline code generator for CHARP\n;\n; (charp x) --> CLC 0(7,#reg),#SFT0 <-- YL1(##FIXNUM),AL3(0),AL3(0)\n;               BE  true\n;               BNE false\n;\n\n(defun zcggicharp (b v s com)\n  (zcgemit 6 () \"CLC\" `(\"0(7,\" ,lastarg \"),#SFT0\") com)\n  (zcgipred '(be bne) v s com)\n)\n\n;;; Numeric predicates.  These are compiled inline with the\n;;; assumption that it \"is an error\" for the argument to be\n;;; non-numeric.  The code assumes that the argument is a\n;;; number.  The tests are set up to work for fixnums,bignums,\n;;; single-floats and double-floats.\n\n;;; For EVENP and ODDP, it \"is an error\" for the argument to\n;;; be other than an integer.  Caveat compilator.\n\n;;; The PLUSP test cannot be done in a single instruction like\n;;; the others.  Therefore, it is handled in the \"compound test\"\n;;; section below.\n\n;\n; Inline code generator for ZEROP\n;\n; (zerop x) --> CLC 1(7,#reg),#SFT0+1 <-- 7 bytes of hex zeroes\n;               BE  true\n;               BNE false\n;\n\n(defun zcggizerop (b v s com)\n  (zcgemit 6 () \"CLC\" `(\"1(7,\" ,lastarg \"),#SFT0+1\") com)\n  (zcgipred '(be bne) v s com)\n)\n\n;\n; Inline code generator for MINUSP\n;\n; (minusp x) --> TM  4(#reg),X'80'\n;                BO  true\n;                BNO false\n;\n\n(defun zcggiminusp (b v s com)\n  (zcgemit 4 () \"TM\" `(\"4(\" ,lastarg \"),X'80'\") com)\n  (zcgipred '(bo bno) v s com)\n)\n\n;\n; Inline code generator for EVENP\n;\n; (evenp x) --> TM  7(#reg),X'01'\n;               BZ  true\n;               BNZ false\n;\n\n(defun zcggievenp (b v s com)\n  (zcgemit 4 () \"TM\" `(\"7(\" ,lastarg \"),X'01'\") com)\n  (zcgipred '(bz bnz) v s com)\n)\n\n;\n; Inline code generator for ODDP\n;\n; (oddp x) --> TM  7(#reg),X'01'\n;              BO  true\n;              BNO false\n;\n\n(defun zcggioddp (b v s com)\n  (zcgemit 4 () \"TM\" `(\"7(\" ,lastarg \"),X'01'\") com)\n  (zcgipred '(bo bno) v s com)\n)\n\n;;;\n;;; Compound condition testers.\n;;;\n\n;\n; Inline code generator for LISTP\n;\n; (listp x) --> CR  #reg,10\n;               BE  true\n;               TM  ##TYPE(#reg),##ATOM\n;               BNZ false\n;          true DS  0H\n;\n;   or\n;\n; (listp x) --> CR  #reg,10\n;               BE  true\n;               TM  ##TYPE(#reg),##ATOM\n;               BZ  true\n;         false.........\n;\n\n(defun zcggilistp (b v s com)\n  (zcgemit 2 () \"CR\" `(,lastarg \",10\") com)\n  (zcgipred `(bz bnz be gonotnil\n                     (4 () \"TM\" (\"##TYPE(\" ,lastarg \"),##ATOM\") ,com))\n            v s com)\n)\n\n;\n; Inline code generator for PLUSP\n;\n; (plusp x) --> TM  4(#reg),X'80'\n;               BO  false\n;               CLC 1(7,#reg),#SFT0+1\n;               BE  false\n;          true...........\n;\n;   or\n;\n; (plusp x) --> TM  4(#reg),X'80'\n;               BO  false\n;               CLC 1(7,#reg),#SFT0+1\n;               BNE true\n;         false DS  0H\n;\n;\n\n(defun zcggiplusp (b v s com)\n  (zcgemit 4 () \"TM\" `(\"4(\" ,lastarg \"),X'80'\") com)\n  (zcgipred `(bne be bo gonil\n                     (6 () \"CLC\" (\"1(7,\" ,lastarg \"),#SFT0+1\") ,com))\n             v s com)\n)\n\n;======================================================================\n\n(defun zcginlin-set-reg-from (inreg s com &aux outreg)\n (cond\n  ((memq inreg regs)\n   (setq outreg inreg))\n  (t\n   (zcgrels inreg)\n   (zcgresv '\\0)\n   (setq outreg (if s (zcggtbst s) (zcggtreg)))\n   (zcgrels '\\0)\n   (zcgemit 2 () \"LR\" `(,outreg \",\" ,inreg) com)\n  )\n )\n outreg\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGIPRED": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x17o\\x00\\x89\\x15o\\x10G\\x00<\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-06-25T00:00:00", "modifydate": "1989-06-05T10:47:00", "lines": 60, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"GEN-PREDICATE\"\n;;;\n;;; This function, formerly part of ZCGINLIN, has been made a separate\n;;; function so that it can be called from ZCGINEXT as well.\n;;;\n;;; It returns the register which contains the result value of the\n;;; comparison, used if the form being compiled is for value.\n;;; However, code may be compiled to do a test and branch only.\n;;;\n;;; Arguments:\n;;;\n;;;  branch-list  -  a list of two symbols representing the op codes\n;;;                  used for the result of a comparison operation,\n;;;                  such that the CAR branches on TRUE and the CADR\n;;;                  branches on FALSE.\n;;;\n;;;  V            -  the usual meaning of the \"V\" argument.\n;;;  S            -  the usual meaning of the \"S\" argument.\n;;;  COM          -  the comment field of the assembler instruction.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgipred (branch-list v s com &aux r)\n  (zcgrels lastarg)\n  (setq r (zcggtbst s))\n  (if (and (null v) (zilcovta s))\n   then\n    (setq cc branch-list)\n   else\n    (let ((lt nil) (lf (gensym)) (lx (gensym)))\n     (when (cc-extendedp branch-list)\n           (when (eq (cc-out-logic branch-list) 'gonotnil)\n                 (setq lt (gensym)))\n           (zcgemit 4 () (cc-out-op branch-list) (or lt lf)         com)\n           (apply #'zcgemit (cc-emit-code branch-list))\n     )\n     (zcgemit 4 () (cc-false-op branch-list) lf                     com)\n     (zcgemit 2 lt \"LR\" `(,r \",8    T\")                             com)\n     (zcgemit 4 () \"B\" lx                                           com)\n     (zcgemit 2 lf \"LR\" `(,r \",10   NIL\")                           com)\n     (zcgemit 0 lx \"DS\" \"0H\"                                        com)\n    )\n   endif)\n  r\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGKEY": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10H\\x00\\x97\\x00\\x99\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:48:00", "lines": 151, "newlines": 153, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"ZCGKEY\"\n;\n; This subroutine generates code for the P-code \"KEY\" form.\n;\n; The input is of the form:  (KEY <keyvars> <funname> <aoksym> NIL NIL)\n;\n; where aoksym is the :allow-other-keys symbol.\n;\n; An example of the code that gets generated:\n;\n;  For a function FOO with lambda list\n;  (&KEY ((:KEY1 KEY1) <init1> <suppliedp1>)\n;        ((:KEY2 KEY2) <init2> <suppliedp2>)\n;        ((:KEY3 KEY3) <init3> <suppliedp3>)\n;  )\n;\n;\n;  the code looks something like this:\n;\n;             ST   13,offset-of-key1(,11)\n;             ST   13,offset-of-key2(,11)\n;             ST   13,offset-of-key3(,11)\n;             L    1,offset-of-restarg(,11)\n; label-loop  DS   0H\n;             CR   1,10\n;             BE   label-done\n;             LM   2,3,##CAR(1)\n;             CR   3,10\n;             BE   label-error\n;             LM   0,1,##CAR(3)\n;             C    2,address-of-symbol-:KEY1\n;             BE   label-1\n;             C    2,address-of-symbol-:KEY2\n;             BE   label-2\n;             C    2,address-of-symbol-:KEY3\n;             BE   label-3\n;             L    0,address-of-symbol-:ALLOW-OTHER-KEYS\n;             CR   2,0\n;             BE   label-loop\n;             L    3,offset-of-restarg(,11)\n;             L    15,ZLCKERR\n;             BALR 14,15       ;  key passed but not in lambda list\n;             B    label-loop  ;  in case it's ok because of allow-other\n; label-1     DS   0H\n;             C    13,offset-of-key1(,11)\n;             BNE  label-loop\n;             ST   0,offset-of-key1(,11)\n;             B    label-loop\n; label-2     DS   0H\n;             C    13,offset-of-key2(,11)\n;             BNE  label-loop\n;             ST   0,offset-of-key2(,11)\n;             B    label-loop\n; label-3     DS   0H\n;             C    13,offset-of-key3(,11)\n;             BNE  label-loop\n;             ST   0,offset-of-key3(,11)\n;             B    label-loop\n; label-error DS   0H\n;             XR   0,0\n;             L    15,ZLCKERR\n;             BALR 14,15       ;  odd number of args in &rest list\n; label-done  DS   0H\n;\n; Note:  The init and suppliedp forms are processed by the SETOPT form,\n;        generated subsequently to this form in the P-code.\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defmacro chop (&rest args)\n `(string-substr (string-append . ,args) 1 36))\n\n(defun zcgkey (a) ;\n (let* (\n        ((keyvars funname aoksym nil nil) a)  ; \"V\" and \"S\" not used.\n        (restarg      (get funname 'restarg))\n        (label-loop   (gensym))\n        (label-done   (gensym))\n        (label-error  (gensym))\n       )\n\n (loop for k in keyvars do\n  (zcgemit 4 () \"ST\" `(\"13,\" ,(get (cdr k) 'offset) \"(,11)\")\n                     (chop \"Set unbound \" (car k)))\n )\n (zcgload '\\1 restarg)\n (zcgemit 0 label-loop \"DS\" \"0H\" nil)\n (zcgemit 2 () \"CR\" \"1,10\" \"Loop until end of keylist.\")\n (zcgemit 4 () \"BE\" label-done nil)\n (zcgemit 4 () \"LM\" \"2,3,##CAR(1)\"   \"2=keyword, 3=rest of list.\")\n (zcgemit 2 () \"CR\" \"3,10\"           \"If rest of list is empty,\")\n (zcgemit 4 () \"BE\" label-error      \"then missing keyword value.\")\n (zcgemit 4 () \"LM\" \"0,1,##CAR(3)\"   \"0=value, 1=rest of list.\")\n (loop for k in keyvars do\n  (let* ((kl (putprop (cdr k) (gensym) 'keylabel))\n         (ks (get (cdr k) 'keysymbol))\n         (kt (or (get (cdr ks) 'location)\n                 (putprop (cdr ks) (gensym) 'location))))\n   (zcgemit 4 () \"C\" `(\"2,\" ,kt) (chop \"If keyword \" (car ks)))\n   (zcgemit 4 () \"BE\" kl \"then go to set value.\")\n  )\n )\n\n (if (get funname 'allow-other-keys-p)\n  then\n   (zcgemit 4 () \"B\" label-loop \"Else ignore, other keys allowed.\")\n  else\n   (zcgemit 4 () \"L\" `(\"0,\" ,(or (get (cdr aoksym) 'location)\n                             (putprop (cdr aoksym) (gensym) 'location)))\n                                         \"Get symbol :ALLOW-OTHER-KEYS\")\n   (zcgemit 2 () \"CR\" \"2,0\" \"If keyword :ALLOW-OTHER-KEYS\")\n   (zcgemit 4 () \"BE\" label-loop \"then ignore bad keyword.\")\n   (zcgload '\\3 restarg)\n   (zcgemit 4 () \"L\" \"15,ZLCKERR\" \"Get address of ZILKERR.\")\n   (zcgemit 2 () \"BALR\" \"14,15\" \"Call ZILKERR to handle key error.\")\n   (zcgemit 4 () \"B\" label-loop \"If other keys allowed, continue.\")\n\n  endif\n )\n\n (loop for k in keyvars do\n  (let ((o (get (cdr k) 'offset)))\n   (zcgemit 0 (get (cdr k) 'keylabel) \"DS\" \"0H\"\n             (chop \"Found keyword \" (get (cdr k) 'keyword)))\n   (zcgemit 4 () \"C\" `(\"13,\" ,o \"(,11)\") \"If keyword value already set\")\n   (zcgemit 4 () \"BNE\" label-loop \"then ignore this value.\")\n   (zcgemit 4 () \"ST\" `(\"0,\" ,o \"(,11)\") (chop \"Set value of \" (car k)))\n   (zcgemit 4 () \"B\" label-loop \"Continue with next keyword.\")\n  )\n )\n (zcgemit 0 label-error \"DS\" \"0H\" \"Invalid keyword list passed.\")\n (zcgemit 2 ()         \"XR\" \"0,0\" \"Show bad keyword list error.\")\n (zcgemit 4 ()         \"L\"  \"15,ZLCKERR\" \"Get address of ZILKERR.\")\n (zcgemit 2 ()      \"BALR\"  \"14,15\" \"Call ZILKERR to handle key error.\")\n (zcgemit 0 label-done  \"DS\" \"0H\" \"End of keyword processing.\")\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGLABEL": {"ttr": 5387, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10H\\x00\\x85\\x00]\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:48:00", "lines": 133, "newlines": 93, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-LABEL                                                          *\n;*                                                                    *\n;**********************************************************************\n\n;;;\n;;; This generates code for labels.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/06/88 - Support for GO tag optimization.                         *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcglabel (a) ; Label (Gxxxxx)\n (prog\n       (b   ; the label in question\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        z   ; a label to be generated for fall-through\n        ys  ; a stack location from which the SALIST may be restored\n        yf  ; a stack location from which the FALIST may be restored\n        x   ; whether or not the label is referenced explicitly\n        c   ; indicates that this is a CATCH/THROW label\n        tag ; the name of the original GO tag if any\n        r   ; a register to be used\n       )\n  (desetq (b v s) a)\n  (if b\n     ;then\n      (setq z   (get b 'fallthru)\n            ys  (get b 'popsalist)\n            yf  (get b 'popfalist)\n            x   (get b 'referenced)\n            c   (get b 'catch)\n            tag (get b 'gotag)\n      )\n     ;else\n      (setq x t) ; A null label is used to create an explicit goto.\n     ;endif\n  )\n;\n; Generate a label if it is non-NIL and one of the following is true:\n;  A SETQ will be done here (V is non-NIL)\n;  An ALIST must be restored (Y is non-NIL)\n;  A CATCH frame must be unstacked (C is non-NIL)\n;  The label is referenced (i.e. a hard-coded branch exists for it)\n;\n  (if   (or v ys yf x c)\n   ;then                      ; Generate label unless name is null.\n        (when b\n         (zcgemit 0 b \"DS\" \"0H\"\n                           (when tag\n                            `(\"Tag \" ,(substr (tostring tag) 1 32)))))\n   ;else\n        (return nil)          ; Otherwise quit now, don't go on.\n   ;endif\n  )\n;\n; If this label is from a PROG's RETURN, a stacked ALIST pointer or two\n; may have to be restored.\n;\n  (when yf\n   (zcgemit 4 () \"L\" `(\"14,\" ,yf \"(,11)\") \"Load stacked alist pointer.\")\n   (zcgemit 4 () \"ST\" \"14,ZLCFALST\"            \"Restore lexical alist.\")\n  )\n  (when ys\n   (zcgemit 4 () \"L\" `(\"14,\" ,ys \"(,11)\") \"Load stacked alist pointer.\")\n   (zcgemit 4 () \"ST\" \"14,ZLCSALST\"            \"Restore special alist.\")\n  )\n;\n; If this label is from a CATCH, a CATCH/THROW frame must be unstacked.\n; This process includes popping the argument stack.\n;\n; Additionally, extra base registers must be restored if necessary.\n;\n  (when c\n        (setq pdmax (cdr pdmax))     ; Pop stack height.\n        (let ((xs (car special-asaved))\n              (xf (car fluid-asaved)))\n             (unless (and xs (eq (car xs) 'catch))\n              (putdata b (plist b) v s)\n              (putdata special-asaved)\n              (zerror \"ZCGLABEL found non-CATCH thing on SPECIAL-ASAVED\"\n                     xs))\n             (unless (and xf (eq (car xf) 'catch))\n              (putdata b (plist b) v s)\n              (putdata fluid-asaved)\n              (zerror \"ZCGLABEL found non-CATCH thing on FLUID-ASAVED\"\n                     xf))\n             (setq special-asaved (cdr special-asaved)\n                   fluid-asaved (cdr fluid-asaved))\n        )\n        (zcgemit 4 () \"L\" `(\"14,\" ,(car pdmax) \"(,11)\")\n                                            \"Get previous catch frame.\")\n        (zcgemit 4 () \"ST\" \"14,ZLCCATCH\"   \"Restore catch environment.\")\n        (zcgbase name nil)\n  )\n\n  (or v s z (return nil))\n\n  ; If the label has a REGISTER property, use that register.\n  ; Otherwise, pick a register and use it.\n\n  (setq r (or (zcgresv (get b 'register)) (zcggtreg)))\n  (zcgstvrs r v s t)    ; Store reg into SETQ variables if any.\n  (zcgsttrg r s)        ; Set target to register if any.\n  (and z (zcgemit 0 z \"DS\" \"0H\" nil)) ; Gen fallthru label if any.\n\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGLOAD": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x17\\x7f\\x00\\x89\\x15o\\x10H\\x00\\x8f\\x00u\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-06-26T00:00:00", "modifydate": "1989-06-05T10:48:00", "lines": 143, "newlines": 117, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"ZCGLOAD\"\n;\n\n;\n; This function generates the code to load the address of the object\n; represented by Q into the register indicated by R.\n;\n; R = a register to contain the address of an object\n;\n; Q = an object, which can be one of the following:\n;\n;   NIL  -  the atom NIL\n;   T    -  the atom T\n;   n    -  where n is a fixnum, being a small fixnum from the table\n;   (xxx . yyy)  -  a dotted pair representing a constant atom,\n;                   a constant list, or a locally bound variable\n;\n; In the case where a fixnum is passed,\n; this generates code to load a small fixnum (i.e. a fixnum which\n; lives in the \"small fixnum table\").  A direct pointer into the\n; table is generated.\n;\n; Examples:\n;\n;  Fixnum     Generated code\n;  ------     --------------\n;   -1         LA  reg,#SFT-1*8   (this might not be implemented)\n;    0         LA  reg,#SFT+0*8\n;    1         LA  reg,#SFT+1*8\n;    2         LA  reg,#SFT+2*8\n;\n; Get the picture?\n;\n; In the case where a dotted pair is passed, the object represented\n; by the dotted pair may be a constant or a variable binding.\n; If it has any of the following properties, it must be the latter:\n;\n; OFFSET, POSITION, BINDINGTYPE, LEXPRARG\n;\n; If it doesn't have any of these properties, it must be a constant.\n;\n; Note: similar code in ZCGGTLOC and ZCGSTATM, unless they've already\n;       been modified to call this routine.\n;\n; The implicit contract in this routine is that no other registers\n; can be used while loading the object in question (with the exception\n; of register 14, which is specifically omitted from the list of\n; eligible registers so it can be used for this purpose).\n;\n; For the above reason, unbound variables cannot be loaded by this\n; function, since the code sequence may involve execution of\n; instructions that use other registers if the variable's binding\n; cannot be located quickly.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgload (r q)\n (cond\n  ((eq q nil)\n   (zcgemit 2 () \"LR\" `(,r \",10\") \"Load atom NIL.\")\n  )\n  ((eq q t)\n   (zcgemit 2 () \"LR\" `(,r \",8\")  \"Load atom T.\")\n  )\n  ((fixnump q)\n   (zcgemit 4 () \"LA\" `(,r ,(if (minusp q) \",#SFT\" \",#SFT+\") ,(* q 8))\n                                                   `(\"Load fixnum \" ,q))\n  )\n  (t\n   (let ((o (get (cdr q) 'offset)))\n        (if o (zcgload-variable r q o)\n              (zcgload-constant r q (where-it-is q)))))))\n\n(defun zcgload-variable (r q o\n                         &aux\n                         (m (if (> (string-length (car q)) 17)\n                                (or (get (cdr q) 'position) (cdr q))\n                                (car q)))\n                         (c (cond\n                             ((get (cdr q) 'lexprarg)\n                              `(\"Get LEXPR argument \" ,m))\n                             ((get (cdr q) 'position)\n                              `(\"Get function's arg \" ,m))\n                             (t\n                              `(\"Get local variable \" ,m))))\n                        )\n (if (get (cdr q) 'lexprarg)\n  then\n   (if (alistboundp q)\n    then\n       (zcgemit 4 () \"L\" \"14,0(,11)\"   \"Get LEXPR stack pointer.\")\n       (zcgemit 4 () \"L\" \"14,0(,14)\" \"Get pointer to alist cell.\")\n       (zcgemit 4 () \"L\" `(,r \",##CDR(,14)\")                    c)\n    else\n       (zcgemit 4 () \"L\" \"14,0(,11)\"   \"Get LEXPR stack pointer.\")\n       (zcgemit 4 () \"L\" `(,r \",0(,14)\")                        c)\n    endif\n   )\n  else\n  if (alistboundp q)\n  then\n     (zcgemit 4 () \"L\" `(\"14,\" ,o \"(,11)\")\n                                     \"Get pointer to alist cell.\")\n     (zcgemit 4 () \"L\" `(,r \",##CDR(,14)\")                      c)\n  else\n     (zcgemit 4 () \"L\" `(,r \",\" ,o \"(,11)\")                     c)\n  endif\n )\n)\n\n(defun zcgload-constant (r q l\n                         &aux\n                         (c1 (cond\n                              ((consp   (car q)) \"Get address of list.\")\n                              ((symbolp (car q)) \"Get symbol \")\n                              ((stringp (car q)) \"Get string \")\n                              ((fixnump (car q)) \"Get fixnum \")\n                              ((bigp    (car q)) \"Get bignum \")\n                              ((floatp  (car q)) \"Get flonum \")\n                              (t                 \"Get atom \")\n                             ))\n                         (c (if (and (atom (car q))\n                                     (< (flatc (car q)) 15))\n                                `(,c1 ,(car q))\n                                c1))\n                        )\n (zcgemit 4 () \"L\" `(,r \",\" ,l) c)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGMVINI": {"ttr": 5391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x16/\\x00\\x89\\x15o\\x10I\\x00)\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-10T00:00:00", "modifydate": "1989-06-05T10:49:00", "lines": 41, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* ZCGMVINI                                                           *\n;*                                                                    *\n;* This routine generates the code sequence required to prime a       *\n;* special form that asks for multiple values.  It does this by       *\n;* dedicating stack location(s) to the place(s) where the values      *\n;* will be returned, and initializing the bottommost to the contents  *\n;* of the stack pointer (register 11) so that if nobody returns       *\n;* multiple values, this situation can be detected.                   *\n;*                                                                    *\n;**********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgmvini (a &aux b c m)\n\n (setq b (or (car a) 1))               ; Arg is # of stack slots.\n\n (setq c (car pdmax))                  ; Current stack top.\n\n (setq m (+ (* 4 b) c))                ; New stack top.\n (push m pdmax)\n (if (> m stackmax) (setq stackmax m)) ; Set high-water-mark.\n\n (zcgemit 4 () \"ST\" `(\"11,\" ,c \"(,11)\") \"Prime multiple value slot.\")\n\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGOPT": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10I\\x00@\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:49:00", "lines": 64, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"ZCGOPT\"\n;\n; This subroutine generates code for the P-code \"OPTIONAL\" form.\n;\n; This code merely checks an &optional arg to see if it has been\n; supplied and, if so, branches to the specified label (the code\n; that initializes the variable follows and is what gets branched\n; around).\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/23/88 - Now does the same check as ZCGSTVRS does to see if the   *\n;*            &OPTIONAL variable in question, as well as any           *\n;*            associated SUPPLIED-P variable, is never referenced.     *\n;*            If this is the case, no code is generated at all for     *\n;*            the whole mess unless there is an initialization form.   *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgopt (a) ;\n (prog\n       (b   ; the &optional variable in question\n        l   ; the label to branch to\n        o   ; a stack offset to be computed\n        m   ; a name ot be inserted in the comment field\n        s   ; a SUPPLIED-P variable associated with the &optional var\n       )\n       (desetq (b l nil nil) a)  ; \"V\" and \"S\" not used.\n       (when (or (not (memq (get (cdr b) 'init) '(t nil)))\n                 (zcgopt-setq-needed b)\n                 (and (setq s (get (cdr b) 'suppliedp))\n                      (zcgopt-setq-needed s)))\n         (setq o (get (cdr b) 'offset)\n               m (if (> (string-length (car b)) 17) \"arg\" (car b)))\n\n         (zcgemit 4 () \"C\" `(\"13,\" ,o \"(,11)\")\n                                              `(\"If caller supplied \" ,m))\n         (zcgemit 4 () \"BNE\" l             \"then bypass optional init.\")\n       )\n )\n)\n\n(defun zcgopt-setq-needed (v)\n (or (get (cdr v) 'used)\n     (get (cdr v) 'mustinit)))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGRECUR": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10P\\x00\\x9f\\x00\\x87\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:50:00", "lines": 159, "newlines": 135, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;*                                                                    *\n;* GEN-TAILRECUR\n;*                                                                    *\n;**********************************************************************\n\n;\n; 10/84 - Modified to correct variable binding environments on tail\n;         recursion from within a PROG environment where locals are\n;         \"special\" (i.e. they occur as free variables elsewhere).\n;         The previous approach of restoring the alist prior to\n;         branching back caused the wrong binding environment to be\n;         in effect for the tail-recurring function.  Therefore, we\n;         now keep the alist as is but branch back to the part of\n;         the code that reestablishes the binding environment from\n;         the alist at the point of execution.  To do this, a new\n;         pseudoglobal \"ZZZCONP\" was created to hold the alternate\n;         label to branch to for this type of tail recursion.\n;\n; 05/86 - The above solution was not enough; it did not take into\n;         account the fact that when you tail-recur and there are\n;         \"special\" (i.e. they occur as free variables elsewhere)\n;         variables around, you can't just come back reusing the same\n;         bindings.  Where you lose with this strategy is when the\n;         function builds a FUNARG (compiled lexical closure).  Y'see,\n;         branching back caused the wrong binding environment to be\n;         in effect for the tail-recurring function; even though the\n;         VALUES of the variables were correct, the BINDINGS were not.\n;         A separate set of bindings MUST be created.  Therefore, we\n;         now keep the alist as is but branch back to the part of\n;         the code that reestablishes the binding environment from\n;         the alist at the point of execution, even when the only\n;         \"special\" variables are in the bottom level itself.  We use\n;         the \"ZZZCONP\" label, as described above, for this.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcgrecur (a) ;\n (prog\n       (\n;;;;;;; b   ; not used (should be the name of the function)\n        n   ; the number of arguments passed to the function\n;;;;;;; v   ; not used (should be NIL)\n;;;;;;; s   ; not used (should be T)\n        r   ; a return register to be used\n        p   ; last saved ALIST pointer\n        cf  ; last saved catch frame pointer\n       )\n;;;;;; (setq b (car a)         )\n       (setq n (cadr a)        )\n;;;;;; (setq v (caddr a)       )\n;;;;;; (setq s (cadddr a)      )\n       (setq r (zcggtreg)      )\n\n; If tail-recursion is done out of an environment which\n; has its own additions to the alist, the \"alternate\" branch-back\n; must be taken.\n;\n; This situation can be detected by checking the stacks of\n; saved alist pointers.  If there are any non-null entries, INCLUDING\n; the last one, then we have a situation which requires the alternate\n; branch-back.\n;\n; Also in this case, the storing back of function arguments will be\n; different.  If we use the alternate branch-back, which involves\n; reestablishing ALIST entries, then we must store argument values\n; directly onto the stack as they would be passed by a caller.\n; Otherwise, we must do the standard function argument storing,\n; updating the alist cell rather than the stack slot.\n;\n       ; Find non-null element of lists of saved ALIST pointers.\n       (setq p (or (loop for x in special-asaved\n                         thereis (and x (eq (car x) 'salist)))\n                   (loop for x in fluid-asaved\n                         thereis (and x (eq (car x) 'falist)))))\n\n       (if (get (car name) 'lexprarg)\n        then\n         (zerror \"ZIL can't optimize tail recursion for LEXPR's!\")\n        else\n;;;;;;;  (loop for k in parms\n;;;;;;;   unless (or (get (cdr k) 'aux) (get (cdr k) 'owned))\n;;;;;;;   (zcggtarg r (get (cdr k) 'position)) ; Pick up argument \"n\"\n;;;;;;;   (zcgstprm r k p))                    ; Set input parameter \"n\"\n\n         (let\n          ((k\n            (loop for q in parms\n              count\n               (not (or (get (cdr q) 'aux) (get (cdr q) 'owned))))))\n\n          (unless (zerop n)\n           (zcgemit 6 () \"MVC\"\n                         `(\"0(\" ,(* k 4) \",11),\" ,(car argbase) \"(11)\")\n                                         \"Set function args to values.\")\n         )\n        )\n       )\n\n;\n; If a CATCH frame must be unstacked, do so.\n;\n; Note: We could search either SPECIAL-ASAVED or FLUID-ASAVED;\n;       the CATCH thing gets saved on both for consistency.\n;\n\n       (loop for x in special-asaved\n             when (and x (eq (car x) 'catch))\n                  (setq cf (cdr x)))\n\n       (when cf\n     (zcgemit 4 () \"L\" `(\"14,\" ,cf \"(,11)\") \"Get previous catch frame.\")\n     (zcgemit 4 () \"ST\" \"14,ZLCCATCH\"      \"Restore catch environment.\")\n       )\n\n;\n; Do it to it.\n;\n\n       (zcgemit 4 () \"B\" (if p zzzconp zzzcont)\n                                  \"Branch to implement tail recursion.\")\n;\n; Note that stack popping has to be done before ZCGSTTRG, so that\n; references to arguments as the target are resolved correctly.\n;\n\n       (setq argbase (cdr argbase)) ; Pop argument base stack.\n       (setq pdmax (cdr pdmax))     ; Pop stack height.\n\n\n;;;;;; (zcgstvrs r v s t)    ; Not done for tail recursion.\n;;;;;; (zcgsttrg r s)        ; Not done for tail recursion.\n       (zcgrels r)           ; Free the register.\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGRELS": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10P\\x00\\x19\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:50:00", "lines": 25, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgrels (r) ; This releases a register, i.e. makes it available.\n (cond\n  ((or (eq r '\\8)\n       (eq r '\\10)\n       (eq r '\\13))\n   nil)  ; NIL, T and \"non-supplied optional arg\" need not be released.\n  (t (let ((u (get r 'usecount)))\n          (if (zerop u)\n              (zerror \"Code generator invalidly released register \" r)\n              (putprop r (1- u) 'usecount))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGRESV": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10P\\x00\\x14\\x00\\x0b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:50:00", "lines": 20, "newlines": 11, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgresv (r) ; This reserves a register, i.e. makes it in use.\n (when r\n       (putprop r (1+ (get r 'usecount)) 'usecount)\n       r ; Return the register you reserved\n )\n)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCGSGOTO": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x08\\x8f\\x00\\x89\\x15o\\x10Q\\x00H\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-03-28T00:00:00", "modifydate": "1989-06-05T10:51:00", "lines": 72, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"SUBSUMED-GOTO\"\n;;;\n;\n; This routine, given a target of the form (goto/gonil/gonotnil label),\n; figures out the ultimate label to branch to.  This is done by means\n; of \"GOTO subsumption\", in which (provided the V-target is nil)\n; GOTO'S are subsumed as follows:\n;\n; GOTO A ---> A: GOTO B            yields... GOTO B\n; GONIL A ---> A: GOTO B           yields... GONIL B\n; GONIL A ---> A: GONIL B          yields... GONIL B\n; GONOTNIL A ---> A: GOTO B        yields... GONOTNIL B\n; GONOTNIL A ---> A: GONOTNIL B    yields... GONOTNIL B\n; GONIL A ---> A: GONOTNIL B       yields... GONIL (GET B 'FALLTHRU)\n; GONOTNIL A ---> A: GONIL B       yields... GONOTNIL (GET B 'FALLTHRU)\n;\n; Note that:\n;\n; GOTO A ---> A: GONIL B      does not yield GONIL B\n; GOTO A ---> A: GONOTNIL B   does not yield GONOTNIL B\n;\n; because such a conversion would cause a fallthrough to occur if the\n; test had the wrong result.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgsgoto (s)           ; S is target of label, i.e. (GOxxx lll)\n (prog (c g s2 c2 g2)\n  (desetq (c g) s)            ; C = original GOTO/GONIL/GONOTNIL\n                              ; G = original target label\n  (setq s2 (get g 'rettarg))  ; \"S\" of above, should be (GOxxx lll)\n  (when (atom s2) (return s)) ;\n  (desetq (c2 g2) s2)         ; GOTO/GONIL/GONOTNIL of above\n                              ; target label of above\n\n; The target label must also do a branch.\n\n  (unless (memq c2 '(goto gonil gonotnil)) (return s))\n\n; If SETQ, ALIST or CATCH processing involved, can't reduce GOTO.\n\n  (when (or (get g 'vartarg)\n            (get g 'popsalist)\n            (get g 'popfalist)\n            (get g 'catch))\n        (return s))\n;\n; If branch types are compatible, the GOTO can be subsumed.\n;\n  (return\n   (cond\n    ((eq c c2)      (zcgsgoto s2)                                )\n    ((eq c 'goto)   s                                            )\n    ((eq c2 'goto)  (list c (cadr (zcgsgoto (list c g2))))       )\n    (t              (list c (or (get g 'fallthru)\n                                (putprop g (gensym) 'fallthru))) )\n   ))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGSTOPT": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10R\\x00)\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:52:00", "lines": 41, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;\n; \"ZCGSTOPT\"\n;\n; This processes the (SETOPT ...) specification by storing the\n; \"not-supplied\" indicator (#13) into the argument stack.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcgstopt (a) ;\n (prog\n       (\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        r   ; a register to be used\n       )\n      (desetq (nil v s) a)\n      (when v (zerror \"SETOPT should not specify a SETQ value!\"))\n      (or s (return nil))      ; Do nothing is S is NIL.\n      (if (and (consp s) (eq (car s) 'arg))\n          (setq r '\\13)\n          (zerror \"SETOPT should be used only to store a function arg!\")\n      )\n      (zcgsttrg r s)        ; Set target to register if any.\n\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGSTTRG": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01>\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10R\\x02\\xec\\x01\\x97\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.62", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:52:00", "lines": 748, "newlines": 407, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"SET-TARGET\"\n;\n; This handles values returned by function calls or evaluations.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/28/88 - SUBSUMED-GOTO broken off into separately compiled        *\n;*            function ZCGSGOTO, so that ZCGIMEMQ can call it too.     *\n;* 04/01/88 - Bug in GOTOSAMELABEL fixed that caused erroneously       *\n;*            dropped code in things like (RETURN (AND P (GO L))).     *\n;* 04/06/88 - Support for GO tag optimization.                         *\n;* 04/07/88 - Support for GO and RETURN out of UNWIND-PROTECT.         *\n;* 04/29/88 - Support for CSETNIL conditional lambda arg initializing. *\n;* 05/02/88 - Support for (GONIL tag) and (GONOTNIL tag) where tag is  *\n;*            a GO tag or RETURN target.                               *\n;* 06/07/88 - Support for VALUES and TAGBODY.                          *\n;* 06/10/88 - Support MULTIPLE-VALUE-LIST, MULTIPLE-VALUE-BIND, THROW. *\n;* 06/23/88 - Support for PROG and RETURN removed.  Of course, there   *\n;*            is still support for GO and RETURN-FROM out of contours. *\n;* 10/20/88 - Fix failure to release registers in THROW code gen.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcgsttrg (r s)\n (cond\n  ((null s)       (when r (zcgrels r))); Throw value away if NIL\n  ((eq s 't)      (set-t r)           ); Return with value in \\15\n  ((atom s)       (zerror \"Unknown target type passed to ZCGSTTRG\" s))\n  (t\n   (let (((s1 s2) s))\n    (case s1\n          (arg    (set-arg r s2))    ; Store into arg cell on stack\n          (catch  (set-catch r s2))  ; Build catch frame and store\n          (uwp    (set-uwp r s2))    ; Store in UNWIND-PROTECT frame\n          ((gonil gonotnil goto)\n                  (set-p r s))       ; Test CC, branch on cond to label\n          (mvlist (set-mvlist r s2)) ; Generate list of multiple values\n          (mvbind (set-mvbind r s2)) ; Generate bind of multiple values\n          (throw  (set-throw  r s2)) ; Do stuff for THROW\n          (t\n           (zerror \"Unknown target type passed to ZCGSTTRG\" s)))))))\n\n;**********************************************************************\n;*  This loads the value into register 15 to return it to the caller. *\n;**********************************************************************\n\n(defun set-t (r)\n (or (eq r '\\15)\n     (zcgemit 2 () \"LR\" `(\"15,\" ,r) \"Set return value.\"))\n (zcgrels r)\n)\n\n;**********************************************************************\n;*  This stores the value into the current UNWIND-PROTECT frame to be *\n;*  held across the execution of the cleanup forms.                   *\n;*  Note that the frame is unhooked but NOT unstacked.                *\n;**********************************************************************\n\n(defun set-uwp (r l1)\n;\n; As part of the process of unstacking the UNWIND/PROTECT frame,\n; pop the argument stack.\n;\n (let ((c (cadr pdmax))\n       (xs (car special-asaved))\n       (xf (car fluid-asaved)))\n  (unless (and xs (eq (car xs) 'uwp) (eql (cdr xs) c))\n          (cterpri) (princ \"PDMAX=\") (prin1 pdmax) (terpri)\n          (zerror \"ZCGSTTRG found non-UWP thing on SPECIAL-ASAVED\" xs))\n  (unless (and xf (eq (car xf) 'uwp) (eql (cdr xs) c))\n          (zerror \"ZCGSTTRG found non-UWP thing on FLUID-ASAVED\" xf))\n  (setq special-asaved (cdr special-asaved)\n       fluid-asaved (cdr fluid-asaved))\n;\n; The following NOP is purely for support of multiple values,\n; as an indicator to the multiple value support code that the value\n; being returned might be being requested by someone that is expecting\n; multiple values.\n\n  (zcgemit 4 () \"NOP\" (get l1 'uwplabel) \"(For multiple value support)\")\n\n  (zcgemit 4 () \"ST\" `(,r \",\" ,(+ c 32) \"(,11)\")\n                                      \"Save return value in UWP frame.\")\n  (zcgemit 0 l1 \"DS\" \"0H\"                     \"Start of cleanup forms.\")\n  (zcgemit 4 () \"L\" `(\"14,\" ,c \"(,11)\")\n                                            \"Get previous catch frame.\")\n  (zcgemit 4 () \"ST\" \"14,ZLCCATCH\"         \"Restore catch environment.\")\n\n  (zcgbase name nil) ; Reload extra base registers if required.\n\n  (zcgrels r)\n )\n)\n\n;***********************************************************************\n;*                                                                     *\n;*     This stores the value into the stack as a function argument.    *\n;*                                                                     *\n;* New support for FUNCALL hacking:  The value of n is normally a      *\n;* plain and simple argument number.  However, with this new support   *\n;* it may be a list.  For example:                                     *\n;*                                                                     *\n;* (arg 5) - the old way, store value into argument 5 of a call frame  *\n;*                                                                     *\n;* (arg (5 zilxfun)) - the new way, store value into argument 5 of a   *\n;*                     call frame being built for function ZILXFUN.    *\n;*                                                                     *\n;* (arg (1 #.zdef))  - the new way, load register 1 with the arg.      *\n;*                                                                     *\n;***********************************************************************\n\n(defun set-arg (r x)\n (prog (o m n f nextpcode)\n       (if (consp x)\n           (desetq (n f) x)       ; (arg (n funcname))\n           (setq n x f nil))      ; (arg n)\n  (setq nextpcode (car restofit))\n  (if (and (eq (car nextpcode) 'inline)\n           (not (and (eq (cadr nextpcode) 'values)\n                     (not (eql (caddr nextpcode) 1)))))\n   then\n    (or lastarg\n        (setq lastarg (if (eq r '\\0) (zcggtreg) r)))\n    (unless (eq r lastarg)\n            (zcgemit 2() \"LR\" `(,lastarg \",\" ,r) `(\"Set argument \" ,n))\n            (zcgrels r))\n   else\n   if   (eq f zdef)\n   then\n        (unless (eq r '\\1)\n                (zcgresv '\\1)\n                (zcgemit 4 () \"L\" `(\"1,\" ,r) \"Load into register 1.\")\n                (zcgrels r)\n        )\n   else\n    (setq lastarg nil)\n    (setq o (+ (* (1- n) 4) (car argbase)))\n                          ; Determine the stack offset of this argument.\n    (setq pdmax (cons (setq m (+ (car pdmax) 4)) (cdr pdmax)))\n                        ; Increment the top element of stack PDMAX by 4\n    (if (> m stackmax)\n        (setq stackmax m))  ; and reset the high water mark accordingly.\n\n    (unless (or (null r) (and (eq f 'zilxfun) (< n 5)))\n            ; If R is null, skip store.  Also,\n            ; skip store for fake FUNCALL args 1-4.\n            (zcgemit 4() \"ST\" `(,r \",\" ,o \"(,11)\")\n                                          `(\"Store into argument \" ,n)))\n\n    (when r (zcgrels r))\n   endif)))\n\n;**********************************************************************\n;*     This creates a catch frame and stores the value therein.       *\n;**********************************************************************\n\n(defun set-catch (r l) ; L is the CATCH/THROW label.\n (prog (\n        c   ; the current stack location where the CATCH frame will go\n        n   ; the new stack location following the CATCH frame\n       )\n\n       (setq c (car pdmax))        ; Catch frame goes here on stack.\n       (setq n (+ c 28))           ; Bump stack past catch frame.\n;\n; Generate code to build the catch frame.\n;\n       (zcgemit 4 () \"L\"  \"14,ZLCCATCH\"       \"Get active catch frame.\")\n       (zcgemit 4 () \"ST\" `(\"14,\" ,c \"(,11)\") \"Store into catch frame.\")\n       (zcgemit 4 () \"ST\" `(,r \",\" ,(+ c 24) \"(,11)\")\n                                          \"Store tag into catch frame.\")\n       (zcgrels r)\n\n       (zcgemit 4 () \"L\"  \"14,ZLCSALST\"            \"Get special ALIST.\")\n       (zcgemit 4 () \"L\"  \"15,ZLCFALST\"            \"Get lexical ALIST.\")\n       (zcgemit 4 () \"STM\" `(\"11,15,\" ,(+ c 4) \"(11)\")\n                                              \"Store into catch frame.\")\n       (zcgemit 4 () \"LA\" `(\"14,\" ,l)         \"Get throw target label.\")\n       (zcgemit 4 () \"ST\" `(\"14,\" ,(+ c 12) \"(,11)\")\n                                              \"Store into catch frame.\")\n       (zcgemit 4 () \"LA\" `(\"14,\" ,c \"(,11)\")\n                                         \"Load address of catch frame.\")\n       (zcgemit 4 () \"ST\" \"14,ZLCCATCH\"      \"Make active catch frame.\")\n;\n; Push catch frame space on the stack.\n;\n       (push n pdmax)          ; Stack height.\n       (if (> n stackmax)\n           (setq stackmax n))  ; High water mark.\n;\n; Add a catch identifier to the saved-bindings-to-undo stacks.\n;\n       (let ((x (cons 'catch c)))\n            (push x special-asaved)\n            (push x fluid-asaved))    ; Push catch frame location.\n )\n)\n\n;**********************************************************************\n;*     This generates a list of multiple values.                      *\n;**********************************************************************\n\n(defun set-mvlist (r l &aux (tl (gensym)) c l2)\n\n (setq pdmax (cdr pdmax))    ; Pop the stack slot pushed by MVINIT.\n (setq c (car pdmax))        ; Stack location of m.v. slot.\n\n (setq l2 (cadr (zcgsgoto `(goto ,l)))) ; Subsume the exit label.\n (putprop l t 'referenced)              ; Insure it gets generated.\n (putprop l2 t 'referenced)             ; Insure it gets generated.\n\n;\n; Generate code to check for multiple values and build them if not.\n;\n (unless (eq r '\\15)\n  (zcgrels r)\n  (zcgresv '\\15)\n  (zcgemit 2 () \"LR\" `(\"15,\" ,r)          \"Load value into register.\" ))\n\n (zcgemit 4 () \"C\" `(\"11,\" ,c \"(,11)\")    \"If multiple values returned\")\n (zcgemit 4 () \"BE\" tl                    \"then...\"                    )\n (zcgemit 4 () \"L\"  `(\"15,\" ,c \"(,11)\")  \"load pointer to values list\")\n (zcgemit 4 () \"B\"  l2                    \"Else no multiple values...\" )\n (zcgresv '\\1)\n (zcgresv '\\2)\n (zcgresv '\\14)\n (zcgemit 2 tl \"LR\" \"1,15\"                \"Arg 1 to CONS = the value\"  )\n (zcgemit 4 () \"L\"  \"15,ZLCCONS\"          \"Get address of ZILCONS\"     )\n (zcgemit 2 () \"LR\" \"2,10\"                \"Arg 2 to CONS = NIL\"        )\n (zcgemit 2 () \"BALR\" \"14,15\"             \"Call ZILCONS for list of 1\" )\n (zcgrels '\\1)\n (zcgrels '\\2)\n (zcgrels '\\14)\n (zcgrels '\\15)\n\n)\n\n;**********************************************************************\n;*     This stores multiple values on the stack for M-V-BIND.         *\n;**********************************************************************\n\n(defun set-mvbind (r (n1 . n2) &aux c m (tl (gensym)))\n ; n1 is the number of multiple values being requested.\n ; n2 is the number of stack slots to be used, which may be greater\n ;    if destructuring is involved.\n (cond\n  ((zerop n2)\n   (setq c (car pdmax))        ; Stack location of m.v. slot.\n   (push c argbase)            ; Base for arguments\n   (push c pdmax)              ; Base for stack control\n  )\n  (t\n   (setq pdmax (cdr pdmax))    ; Pop the stack slot pushed by MVINIT.\n   (setq c (car pdmax))        ; Bottom of multiple value stack slots.\n   (setq m (+ c (* 4 n2)))     ; Top of multiple value stack slots.\n   (push c argbase)            ; Base for arguments\n   (push m pdmax)              ; Base for stack control\n   (if (> m stackmax)\n       (setq stackmax m))      ; Reset high water mark\n\n\n   (zcgemit 4 () \"NOP\" `(,n1 \"(11,0)\")    \"Show MULTIPLE-VALUE-BIND.\"  )\n   (zcgemit 4 () \"C\" `(\"11,\" ,c \"(,11)\")  \"If multiple values returned\")\n   (zcgemit 4 () \"BNE\" tl                 \"then values set. Else...\"   )\n   (zcgemit 4 () \"ST\" `(,r \",\" ,c \"(,11)\") \"Ret = first multiple value\")\n   (do ((i 2 (1+ i))\n        (o (+ c 4) (+ o 4))\n       )\n       ((> i n1))\n     (zcgemit 4 () \"ST\" `(\"10,\" ,o \"(,11)\") `(\"NIL = multiple value \",i))\n   )\n   (zcgemit 0 tl \"DS\" \"0H\"                nil                          )\n   (zcgrels r)\n  )))\n\n\n;**********************************************************************\n;*     This processes the THROW special form.                         *\n;**********************************************************************\n\n(defun set-throw (r s)\n (case s\n       ((tag)    (set-throw-tag  r))\n       ((form)   (set-throw-form r))\n       (t        (zerror \"Bad thing passed to ZCGSTTRG\" `(throw ,s)))))\n\n(defun set-throw-tag (r)\n (let* ((c (car pdmax))\n        (m (+ 4 c))\n       )\n  (push m pdmax)              ; Base for stack control\n  (if (> m stackmax)\n      (setq stackmax m))      ; Reset high water mark\n  (zcgemit 4 () \"ST\" `(,r \",\" ,c \"(,11)\")        \"Store THROW tag.\")\n  (zcgrels r)\n )\n)\n\n(defun set-throw-form (r)\n (unless (eq r '\\15)\n  (zcgemit 2 () \"LR\" `(\"15,\" ,r) \"Load into register.\")\n  (zcgrels r)\n  (setq r (zcgresv '\\15))\n )\n (setq pdmax (cdr pdmax))    ; Pop stack.\n (zcgresv '\\1)\n (zcgresv '\\2)\n (zcgresv '\\14)\n (zcgemit 4 () \"NOP\" \"0(11,8)\"          \"(for multiple value support)\")\n (zcgemit 4 () \"L\"   `(\"1,\" ,(car pdmax) \"(,11)\")\n                                        \"Load THROW tag.\")\n (zcgemit 2 () \"LR\"  \"2,15\"             \"Load THROW form.\")\n (zcgemit 4 () \"L\"   \"15,ZLCTHROW\"      \"Get address of ZILTHROW.\")\n (zcgemit 2 () \"BR\"  \"15\"               \"Branch to ZILTHROW to throw.\")\n (zcgrels '\\1)\n (zcgrels '\\2)\n (zcgrels '\\14)\n (zcgrels r)\n)\n\n;**********************************************************************\n;*     Functions related to generating branching code                 *\n;**********************************************************************\n\n(defun set-p (r s) ; R = register, S = (condition label)\n;\n; Generate code for conditional or unconditional branching.\n; This handles both predicative and non-predicative cases.\n;\n (prog (c g rr z szz fzz cur cf tl tag temp)\n;\n; Special handling for predicative MEMQ - branching was done previously\n;\n  (when (eq cc 'memq)\n        (setq cc nil)\n        (return nil))\n;\n; Make a copy of the (condition label) so that it can be updated\n; destructively in case it has to be, and to include a third field\n; to hold a possible temporary label.\n;\n  (setq s (list (car s) (cadr s) nil))\n;\n; The following code determines if we are branching outside of a\n; binding environment (e.g. GO or RETURN-FROM out of a LAMBDA).  If so,\n; we generate code to restore the alist to its previous state before\n; doing any branching.  Note that if the label to which we are\n; branching does its own alist restoration, we don't need to do this.\n;\n; If the label is a RETURN-FROM label, it will have a CURALIST property\n; of its own.  If it is a GO label, it will have a PROGEXIT property\n; pointing to the RETURN-FROM label which has the CURALIST property.\n;\n  (setq g (cadr s)\n        cur         ; a dotted pair.\n          (cond\n           ((get g 'curalist))\n           ((setq cur (get g 'progexit)) (get cur 'curalist))))\n;\n; If CUR is non-NIL, that means that we are branching to a point\n; outside of the current contour.  This may involve one or more of\n; the following:\n;\n;  *  Unstacking a CATCH frame\n;  *  Restoring a special ALIST\n;  *  Restoring a lexical ALIST\n;  *  Processing an UNWIND-PROTECT cleanup form\n;      (which includes unstacking the UNWIND-PROTECT frame)\n;\n; To do this properly, we CDR through SPECIAL-ASAVED and FLUID-ASAVED\n; (in parallel) until we hit the sublist EQ to CUR.  Each entry along\n; the way tells us what we have to do:\n;\n; SPECIAL-ASAVED: (SALIST ___)  ===> restore a special ALIST pointer\n; FLUID-ASAVED:   (FALIST ___)  ===> restore a lexical ALIST pointer\n;\n; SPECIAL-ASAVED: (CATCH  ___)  ===> unstack a CATCH frame\n; FLUID-ASAVED must be the same.\n;\n; SPECIAL-ASAVED: (UWP    ___)  ===> process an UNWIND-PROTECT cleanup\n; FLUID-ASAVED must be the same.\n;\n; As it turns out, we don't have to perform the indicated activity\n; at each layer.  We can unstack/restore the last pointer or frame\n; with the same results.  HOWEVER, if we encounter a UWP, we must\n; cash in all our chips and unstack/restore everything so far, so\n; that the cleanup code can execute properly.\n;\n  (when cur\n   (do (\n        (sal special-asaved  (cdr sal))\n        (fal fluid-asaved    (cdr fal))\n        (x)\n       )\n       ((eq sal (car cur))\n        (unless (eq fal (cdr cur))\n                (zerror \"SPECIAL-ASAVED and FLUID-ASAVED mismatch\" cur))\n       )\n        (when (eq fal (cdr cur))\n              (zerror \"FLUID-ASAVED and SPECIAL-ASAVED mismatch\" cur))\n        (when (setq x (car sal))\n              (case (car x)\n                    (salist (setq szz (cdr x)))\n                    (catch  (setq cf  (cdr x)))\n                    (uwp    (when cf  (unstack-catch-stuff  cf  r s))\n                            (when fzz (unstack-falist-stuff fzz r s))\n                            (when szz (unstack-salist-stuff szz r s))\n                            (unstack-uwp-stuff (cdr x) r s)\n                            (setq szz nil fzz nil cf nil))\n                    (t (zerror \"Bad thing on SPECIAL-ASAVED\" x))))\n        (when (setq x (car fal))\n              (case (car x)\n                    (falist (setq fzz (cdr x)))\n                    (catch  (comment do nothing - handled by sal))\n                    (uwp    (comment do nothing - handled by sal))\n                    (t (zerror \"Bad thing on FLUID-ASAVED\" x))))\n   )\n  )\n\n;\n; If variable bindings need to be unstacked, and this is not a branch\n; to a label that already does its own unbinding, generate code to\n; restore variable bindings to the state they are in at the destination.\n;\n  (when (and fzz (null (get g 'popfalist)))\n   (unstack-falist-stuff fzz r s))\n  (when (and szz (null (get g 'popsalist)))\n   (unstack-salist-stuff szz r s))\n;\n; If catch frames need to be unstacked, and this is not a branch\n; to a label that already does its own unwinding, generate code to\n; restore the catch environment to the state it was in at destination.\n;\n  (when (and cf (null (get g 'catch)))\n   (unstack-catch-stuff cf r s))\n;\n; At this point, if the original S was (GONIL tag) or (GONOTNIL tag),\n; and tag was a label for which any unstacking stuff was done, S has\n; been altered to be (GOTO tag <gensym>), where <gensym> is the\n; temporary label needed to effect the conversion to GOTO.\n;\n  (setq temp (caddr s))\n;\n; Extract the \"subsumed\" GOTO - i.e. try to optimize out chained GOTO's.\n;\n; C is the condition:  GOTO, GONIL, GONOTNIL\n; G is the goto-label\n;\n  (desetq (c g) (zcgsgoto s))     ; Get the \"subsumed-goto\" target.\n\n  (when debug\n        (cterpri)\n        (princ \"Dump of original branch label \")\n        (prin1 (cadr s))\n        (terpri)\n        (prin1 (plist (cadr s)))\n        (terpri)\n        (prin1 s)\n        (princ \" subsumed to: \") (prin1 c) (princ \" \") (princ g)\n        (terpri)\n        (princ \"Dump of subsumed branch label \")\n        (prin1 g)\n        (terpri)\n        (prin1 (plist g))\n        (terpri)\n        (terpri)\n  )\n\n  (setq rr (get g 'register))     ; Get register associated with label.\n  (putprop g t 'referenced)       ; Insure that the label code exists.\n\n;\n; Insure that the current value is in the proper register.\n; It should already be there in most cases.  However...\n;\n  (when r\n     (if rr\n      then\n       (and (neq rr r)             ; If different paths put value in\n            (or                    ; different registers, and the value\n                (get g 'rettarg)   ; is going to be used by the code\n                (get g 'vartarg))  ; (not just test for NIL) - then...\n            (zcgemit 2 () \"LR\" `(,rr \",\" ,r) \"Load into register.\"))\n      else (setq rr (putprop g r 'register))\n      endif\n     )\n     (zcgrels r))\n\n;\n; If the place we'd fall thru to if we deleted the GOTO is the same\n; as the place we're going to (as determined by GOTOSAMELABEL),\n; then we can suppress the superfluous branch instruction.\n;\n\n (setq z (gotosamelabel g restofit))\n (when debug\n       (cterpri)\n       (prin1 g) (princ \" gotosamelabel as: \") (prin1 z) (terpri)\n       (princ \"CC=\") (prin1 cc) (terpri)\n       (terpri)\n )\n (when (eq z g)\n       (putprop g t 'referenced) ; mark so its own code gets gen'd\n       (return nil))             ; quit without doing any more\n;\n; Otherwise you need the GOTO.\n;\n (setq tag (get g 'gotag))\n;\n; Generate unconditional or conditional branch.\n;\n (case c\n  ((goto)\n   (zcgemit 4 () \"B\" g (if tag\n                           `(\"Go to \" ,(substr (tostring tag) 1 30))\n                           \"Branch.\")))\n  (otherwise\n   (gen-branch-on-condition c g r tag)))\n;\n; If a temporary label was generated, process it.\n;\n (when temp (zcgemit 0 temp \"DS\" \"0H\" nil))\n )\n)\n\n;======================================================================\n\n(defun unstack-catch-stuff (f r s)\n (maybe-conditional-go r s)\n (zcgemit 4 () \"L\" `(\"14,\" ,f \"(,11)\")    \"Get previous catch frame.\")\n (zcgemit 4 () \"ST\" \"14,ZLCCATCH\"        \"Restore catch environment.\")\n)\n\n(defun unstack-falist-stuff (f r s)\n (maybe-conditional-go r s)\n (zcgemit 4 () \"L\" `(\"14,\" ,f \"(,11)\")  \"Load stacked alist pointer.\")\n (zcgemit 4 () \"ST\" \"14,ZLCFALST\"            \"Restore lexical alist.\")\n)\n\n(defun unstack-salist-stuff (f r s)\n (maybe-conditional-go r s)\n (zcgemit 4 () \"L\" `(\"14,\" ,f \"(,11)\")  \"Load stacked alist pointer.\")\n (zcgemit 4 () \"ST\" \"14,ZLCSALST\"            \"Restore special alist.\")\n)\n\n(defun unstack-uwp-stuff (f r s)\n (maybe-conditional-go r s)\n (let ((l (gensym)))\n  (when r\n   (zcgemit 4 () \"NOP\" l                 \"(for multiple value support)\")\n   (zcgemit 4 () \"ST\" `(,r \",\" ,(+ f 32) \"(,11)\") \"Store passed value.\")\n  )\n  (zcgemit 4 () \"LA\"  `(\"14,\" ,l)     \"Address to return from cleanup.\")\n  (zcgemit 4 () \"L\"   `(\"15,\" ,(+ f 28) \"(,11)\")  \"Address of cleanup.\")\n  (zcgemit 4 () \"ST\"  `(\"14,\" ,(+ f 12) \"(,11)\")\"Store return address.\")\n  (zcgemit 2 () \"BR\"  \"15\"                   \"Go execute cleanup code.\")\n  (zcgemit 0 l  \"DS\"  \"0H\"                                          nil)\n  (when r\n   (zcgemit 4 () \"L\"  `(,r \",\" ,(+ f 32) \"(,11)\")      \"Restore value.\")\n  )\n )\n)\n\n;======================================================================\n\n;\n; In the case of (GONIL tag) or (GONOTNIL tag), where tag is a label\n; that has stuff that needs to be unstacked, the code needs to be\n; compiled somewhat differently.  Like this:\n;\n; In the case of (GONIL tag), it is compiled as if it were\n;\n;  (GONOTNIL temp)\n;  -do unstack stuff-\n;  (GOTO tag)\n;  (LABEL temp)\n;\n; In the case of (GONOTNIL tag), it is compiled as if it were\n;\n;  (GONIL temp)\n;  -do unstack stuff-\n;  (GOTO tag)\n;  (LABEL temp)\n;\n; This function implements this by being called the first time\n; something needs to be unstacked, altering the contents of\n; S from (GONIL/GONOTNIL something NIL) to (GOTO something <gensym>),\n; and generating the code that would normally be generated for a\n; GONOTNIL or GONIL using that temporary gensym label.\n;\n(defun maybe-conditional-go (r s &aux c g newgo newtag)\n (setq newgo (cdr (assq (car s) '((gonil . gonotnil)\n                                  (gonotnil . gonil)))))\n (cond\n  (newgo\n   (setf (car s) 'goto)\n   (setq newtag (setf (caddr s) (gensym)))\n   ;;; Subsume the GOTO to the temporary label (won't do much).\n   (desetq (c g) (zcgsgoto (list newgo newtag)))\n   (gen-branch-on-condition c g r nil)\n  )\n )\n)\n\n;======================================================================\n\n(defun gen-branch-on-condition (c g r tag &aux tl)\n ;\n ; If non-predicative code, generate condition code test.\n ; (If predicative code, the test was generated in the inline code.)\n ;\n (when (null cc)\n       (zcgemit 2 () \"CR\" `(,r \",10\") \"Test value for NIL.\"))\n ;\n ; Process the back end of a condition test.\n ;\n (when (cc-extendedp cc)\n  (unless (eq (cc-out-logic cc) c)\n          (setq tl (gensym)))\n  (zcgemit 4 () (cc-out-op cc) (or tl g)     \"Partial condition test.\")\n  (apply #'zcgemit (cc-emit-code cc))\n )\n (if (eq c 'gonotnil)\n     (zcgemit 4 () (or (cc-true-op cc) \"BNE\") g\n                                    (if tag\n                                        `(\"If true (not NIL), go to \"\n                                          ,(substr (tostring tag) 1 11))\n                                        \"If true (not NIL), branch.\"))\n     (zcgemit 4 () (or (cc-false-op cc) \"BE\") g\n                                    (if tag\n                                        `(\"If false (NIL), go to \"\n                                          ,(substr (tostring tag) 1 14))\n                                        \"If false (NIL), branch.\"))\n )\n\n (when tl (zcgemit 0 tl \"DS\" \"0H\" nil))\n\n (setq cc nil)        ; Reset in case mutated by inline code generator\n)\n\n;======================================================================\n\n;**********************************************************************\n;\n; \"SUBSUMED-GOTO\" has been moved to ZCGSGOTO.\n;\n;**********************************************************************\n;\n; \"GOTOSAMELABEL\"\n;\n; This determines whether a situation exists where a GOTO is followed\n; immediately by the label to which it refers.\n; This might take the following form (let L = the GOTO label):\n;\n;    (... (GOTO L))\n;    (LABEL X NIL (GOTO Y))\n;    (LABEL Y NIL (GOTO L))\n;    (LABEL L ...)\n;\n;  with no intervening code between the labels.\n;\n;  G is the GOTO label to be checked.\n;  R represents the remainder of the compiled code body.\n;\n;  Note that the label involved must be marked referenced since it\n;  will be \"fallen through\" to, even though it may not get used as\n;  a label per se.\n;\n;**********************************************************************\n\n(defun gotosamelabel (g r)\n (prog (a)\n  (or g (return nil))                ; If null \"label\" passed, then ().\n  (when (get '*zilco* 'nogotosamelabel)\n        (return nil))                ; If suppressing this optimization,\n                                     ; then ().\n  (setq a (car r))                   ; The statement we're looking at\n  (or a (return nil))                ; (if there is one) must be...\n                                     ; a label - we skip over things\n                                     ; that don't generate any code\n  (when (memq (car a) '(endprog endlam endtag endblock))\n        (return (gotosamelabel g (cdr r))))\n  (or (eq (car a) 'label) (return nil))\n    ;\n    ; If (GOTO X; LABEL X...), then if (LABEL X) goes to some Y and that\n    ; is a \"clean\" GOTO (no intervening code), then we can continue\n    ; analysis with Y - otherwise just say that X is the return value.\n    ;\n    ; If (GOTO X; LABEL Y...), then if the GOTO were deleted we'd fall\n    ; thru to wherever (LABEL Y) fell thru to, which may be NIL but\n    ; might just possibly also be X, so we have to check it out.\n    ;\n    ; Continue tracking down the GOTO/LABEL statements as long as they\n    ; follow one another, until NIL is returned.  Then, if we have a\n    ; situation at the current level like (GOTO X) / (LABEL X ...),\n    ; we can say that the first statement would fall thru to X if the\n    ; second statement went nowhere, else would fall thru to the same\n    ; place the second statement falls thru to.  If we have something\n    ; like (GOTO X) / (LABEL Y ...) then the first statement would\n    ; fall thru to wherever the second one falls thru to, which may\n    ; be NIL.\n    ;\n    ; 04/01/88 - Bug fix:  (LABEL NIL ...) must be checked for, since\n    ;            its presence means that an unconditional GO throws\n    ;            everything off, so NIL must be returned.\n    ;\n\n  (return\n          (or (gotosamelabel (nothing-but-goto a) (cdr r))\n              (if (eq (cadr a) g) g nil)))))\n\n(defun nothing-but-goto (x)         ; Returns a GOTO label if...\n (let* (((l v s) (cdr x)))\n  (if (and l                        ; the label has a name (not NIL) and\n           (null v)                 ; there's nothing that forces\n           (null (get l 'popsalist)); code to be generated for it\n           (null (get l 'popfalist)); (either specially or lexically)\n           (null (get l 'catch))    ; (e.g. SETQ, ALIST, CATCH) and\n           (not (atom s))           ; if it itself GOTO's some following\n           (eq (car s) 'goto)       ; label in a similar manner and\n           (null (get (cadr s) 'gotag)) ; that label isn't a GO tag.\n      )\n   then (cadr s)                    ; then return that GOTO label\n   else nil                         ; else return nil\n  )\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGSTVRS": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10R\\x00\\xc4\\x00c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:52:00", "lines": 196, "newlines": 99, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"SET-VARIABLES\"\n;\n; This handles assignments to SETQ variables.\n;\n; Note: We used to search special-freevars and fluid-freevars to find\n;       the atom pair associated with the argument if it's atomic.\n;       Now we search special-unbounds and fluid-unbounds instead.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/30/88 - Fixed bug that caused T or NIL register to be loaded     *\n;*            after a call to ZILVSET.                                 *\n;* 04/28/88 - If a variable to be set has never been referenced and    *\n;*            is local (not SPECIAL or closed over), then suppress     *\n;*            the storing of the value.  Unfortunately, we can't       *\n;*            eliminate the stack slot allocation that easily.         *\n;*            ZCGSTPRM has been incorporated into this function and    *\n;*            is now obsolete.                                         *\n;* 05/01/88 - Above not done when the value is being returned in       *\n;*            register 15, since multiple values could end up          *\n;*            being invalidly returned if the SETQ were eliminated.    *\n;*            To handle this, we now pass 4 arguments to ZCGSTVRS.     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zcgstvrs (rr v s mvp)\n (and rr (dolist (x v) (set-variable rr x s mvp))))\n\n(defun set-variable (r v s mvp)\n (prog (sp fp o m a sub lb1 lb2 p)\n  (if (atom v)\n   then\n   (setq sp (assq v (cdr special-unbounds))\n         fp (assq v (cdr fluid-unbounds)))\n   (if (and sp fp)\n       (zerror\n       \"Compiler error - free variable to be set both special and fluid\"\n              v))\n    (setq a (or sp fp\n       (zerror \"Compiler error - free variable to be set not found\" v)))\n    (setq o (get (cdr a) 'pointer))\n    (setq m (if (> (string-length v) 16) (cdr a) v))\n    (princ \"Note - assigning to non-local \")\n    (princ (cond (sp 'special)\n                 (fp 'lexical)\n                 (t \"(and undeclared)\")))\n    (princ \" variable \")\n    (prin1 v)\n    (terpri)\n\n    (if sp                       ; If variable declared SPECIAL...\n\n     then\n\n  ; If subr ZILVSET doesn't already exist, create it.\n\n   (or (setq sub (assq 'zilvset subrs))\n       (modq subrs (setq sub (zilcosym 'zilvset 'subrs))))\n\n\n   (zcgemit 4 () \"L\" `(\"14,\" ,o \"(,11)\")       `(\"Get binding of \" ,m))\n   (zcgemit 4 () \"L\" \"3,##CDR(,14)\"             \"Check if it is bound.\")\n   (zcgemit 4 () \"C\" \"3,ZLCUNBND\"               \"If variable bound\")\n   (zcgemit 4 () \"BE\" (setq lb1 (gensym))       \"then...\")\n   (zcgemit 4 () \"ST\" `(,r \",##CDR(,14)\")  `(\"store into variable \" ,m))\n   (zcgemit 4 () \"B \" (setq lb2 (gensym))       \"else...\")\n   (zcgemit 0 lb1 \"DS\" \"0H\"                      nil)\n   (zcgemit 2 () \"LR\" `(\"3,\" ,r)                \" get address of value\")\n   (zcgemit 4 () \"L\" `(\"2,\" ,(or (get (cdr a) 'location)\n                                 (putprop (cdr a) (gensym) 'location)\n                             ))                \" get address of symbol\")\n   (zcgemit 4 () \"L\" `(\"15,\" ,(or (get (cdr sub) 'location)\n                                  (putprop (cdr sub) (gensym) 'location)\n                              ))             \" get address of ZILVSET\")\n   (zcgemit 4 () \"LA\" `(\"1,\" ,(car pdmax) \"(,11)\") \" get stack pointer\")\n   (zcgemit 2 () \"BALR\" \"14,15\"  \" call ZILVSET\")\n\n   (zcgbase name nil) ; Reload additional base registers if necessary.\n\n   (zcgemit 4 () \"ST\"  `(\"15,\" ,o \"(,11)\")\n                                         \" store binding cell on stack\")\n   ; Don't reload #8 or #10!!!\n   (when (memq r regs)\n    (zcgemit 4 () \"L\" `(,r \",##CDR(,15)\")      `(\"Reload value of \" ,m))\n   )\n   (zcgemit 0 lb2 \"DS\" \"0H\"                 nil)\n\n     else   ; SETQ of unbound variable which is \"pseudolexical\"\n\n   (zcgemit 4 () \"L\" `(\"14,\" ,o \"(,11)\")  `(\"Get binding of \" ,m))\n   (zcgemit 4 () \"ST\" `(,r \",##CDR(,14)\")  `(\"Store into variable \" ,m))\n\n     endif\n\n    )\n\n  else\n;\n; At this point we have a dotted pair, meaning a local assignment.\n;\n  (setq o (get (cdr v) 'offset))\n  (setq p (get (cdr v) 'position))\n  (setq m (if (> (string-length (car v)) 16)\n              (or p (cdr v))\n              (car v)))\n  (cond\n   (p                       ; A function argument.\n    (set-function-argument r v o m s mvp))\n   ((alistboundp v)\n    (zcgemit 4 () \"L\" `(\"14,\" ,o \"(,11)\")  \"Get pointer to alist cell.\")\n    (zcgemit 4 () \"ST\" `(,r \",##CDR(,14)\") `(\"Store into variable \" ,m))\n   )\n   ((zcgstvrs-setq-needed r v s mvp)\n    (zcgemit 4 () \"ST\" `(,r \",\" ,o \"(,11)\")`(\"Store into variable \" ,m))\n   )\n   (t\n    (zcgstvrs-warn-unreferenced v)))\n  endif)))\n\n;;;\n;;; This routine generates code for a SETQ to a function argument.\n;;; Formerly ZCGSTPRM.\n;;;\n\n(defun set-function-argument (r v o m s mvp) ;\n (cond\n  ((get (cdr v) 'lexprarg)\n   ;\n   ; Store LEXPR argument\n   ;\n   (zcgemit     4 () \"L\" \"14,0(,11)\"       \"Get pointer to LEXPR arg.\")\n   (cond\n    ((alistboundp v)\n     (zcgemit 4 () \"L\" \"14,0(,14)\"        \"Get pointer to alist cell.\")\n     (zcgemit 4 () \"ST\" `(,r \",##CDR(,14)\")  `(\"Store LEXPR arg. \" ,m))\n    )\n    (t\n     (zcgemit 4 () \"ST\" `(,r \",0(,14)\")      `(\"Store LEXPR arg. \" ,m))\n    )))\n\n  ((alistboundp v)\n   ;\n   ; Store local variable captured by lexical closure\n   ;\n   (zcgemit 4 () \"L\" `(\"14,\" ,o \"(,11)\")   \"Get pointer to alist cell.\")\n   (zcgemit 4 () \"ST\" `(,r \",##CDR(,14)\")  `(\"Store function arg. \" ,m))\n  )\n  ((zcgstvrs-setq-needed r v s mvp)\n   ;\n   ; Store local variable\n   ;\n   (zcgemit 4 () \"ST\" `(,r \",\" ,o \"(,11)\")  `(\"Store function arg \" ,m))\n  )\n  (t\n   (zcgstvrs-warn-unreferenced v))))\n\n(defun zcgstvrs-setq-needed (r v s mvp)\n (or (get (cdr v) 'used)\n     (get (cdr v) 'mustinit)\n     (and mvp\n          (eq r '\\15)\n          (zilcomvp nil s))))\n\n(defun zcgstvrs-warn-unreferenced (v)\n ;\n ; Local variable never referenced - skip store\n ;\n ; We don't put out a warning because various optimizations\n ; may have resulted in this situation, so the programmer may\n ; not even be aware that a variable has become unreferenced.\n ;\n (when debug\n       (cterpri)\n       (princ \"Skipping store of unreferenced local variable \")\n       (princ v)\n       (terpri))\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCGSUBR": {"ttr": 5895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10S\\x00M\\x008\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:53:00", "lines": 77, "newlines": 56, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; Note:  This looks awfully similar to ZCGCLOS, doesn't it?\n;;;\n\n\n;**********************************************************************\n;*                                                                    *\n;* \"ZCGSUBR\"\n;*                                                                    *\n;**********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/01/88 - More arguments to ZCGSTVRS.                              *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcgsubr (a) ;\n (prog\n       (b   ; the name of the function to make a SUBR out of\n        v   ; an item to receive the value if SETQ is involved\n        s   ; the target of the value to be set\n        r   ; a register to be used\n        l   ; a location label for the V-con associated with the subr\n        c   ; comments string\n       )\n       (desetq (b v s) a)\n       (setq r (zcgresv '\\15) ) ; Value is always in this register.\n       (zcgresv '\\1)\n       (zcgresv '\\2)\n       (zcgresv '\\14)\n       (setq c `(\"Load address of \" ,(cdr b)))\n;\n; Note that B is a dotted pair with the function name and a symbol.\n;\n       (if (eq (car b) (car name))\n        then\n         (zcgemit 2 () \"LR\" \"1,12\"                                    c)\n        else\n         (setq l (or (get (cdr b) 'location)\n                     (putprop (cdr b) (gensym) 'location)))\n         (zcgemit 4 () \"L\" `(\"1,\" ,l)                                 c)\n        endif\n       )\n       (zcgemit 4 () \"L\"    \"15,ZLCCONS\"         \"Get address of CONS.\")\n       (zcgemit 2 () \"XR\"   \"2,2\"   \"Alist component is zero for SUBR.\")\n       (zcgemit 2 () \"BALR\" \"14,15\"         \"Call CONS to make a SUBR.\")\n       (zcgemit 4 () \"MVI\"  \"##TYPE(15),##SUBR\"\n                            `(\"SUBR of \" ,(string-substr (car b) 1 27)))\n;\n; At this point the return value will be in register 15.\n;\n       (zcgstvrs r v s nil)  ; Store reg into SETQ variables if any.\n       (zcgsttrg r s)        ; Set target to register if any.\n       (zcgrels '\\1)         ; Free the register.\n       (zcgrels '\\2)         ; Free the register.\n       (zcgrels '\\14)        ; Free the register.\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCPEXEC": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x00\\x885_\\x00\\x89\\x15o\\x10U\\x01\\xcb\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "1988-12-20T00:00:00", "modifydate": "1989-06-05T10:55:00", "lines": 459, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZCPEXEC is the function called by the \"default ZIL printer\", ZDPRINT,\n; when the file argument is not a symbol.  The file argument is assumed\n; to be a stream (which is why we call it \"stream\" in this code).\n;\n; ZCPEXEC, like ZDPRINT, takes three required arguments:\n;\n; arg 1 = the object to be printed, if applicable.\n; arg 2 = the file to print it on.\n; arg 3 = a fixnum built from the following boolean values:\n;\n;    ....00  =  print a character object (TYO)\n;    ....01  =  print a LISP object (PRINC/PRIN1)\n;    ....10  =  control, not print (CTERPRI/TERPRI)\n;    ...x..  =  0 = don't slashify, 1 = slashify\n;    ..x...  =  0 = unconditional, 1 = conditional\n;    .1....  =  CHARPOS request (ZGETFPO/ZPUTFPO)\n;    1.....  =  CLRSCRN request\n;\n\n(include #.(zil-source-member zcsdfstr));\n\n(eval-when ()\n #.(progn\n    (defvar lp  \"(\"               \"left  list      parenthesis\")\n    (defvar rp  \")\"               \"right list      parenthesis\")\n    (defvar lvp \"#(\"              \"left  vector    parenthesis\")\n    (defvar rvp \")\"               \"right vector    parenthesis\")\n    (defvar lsp \"#<STRUCT \"       \"left  structure parenthesis\")\n    (defvar rsp \">\"               \"right structure parenthesis\")\n    (defvar lfp \"#<FUNARG \"       \"left  funarg    parenthesis\")\n    (defvar rfp \">\"               \"right funarg    parenthesis\")\n   )\n)\n\n;-----------------------------------------------------------------------\n;\n; temporary temporary temporary temporary temporary temporary temporary\n\n(defmacro upper-case-p (char)\n `(string-index \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" (string ,char)))\n\n; temporary temporary temporary temporary temporary temporary temporary\n;\n;-----------------------------------------------------------------------\n\n(defmacro write-char (char &optional stream)\n ;(tyo char stream)\n `(zcprint ,char ,stream #.%%%tyo))\n\n(defmacro princ-string (string &optional stream)\n ;(princ string stream)\n `(zdprint ,string ,stream #.%%%princ))\n\n(defmacro %tyo (char stream)\n `(zcpexec-tyo ,char ,stream))\n\n(defmacro %princ (object stream)\n `(zcpprint-low-level ,object ,stream nil))\n\n(defmacro %prin1 (object stream)\n `(zcpprint-low-level ,object ,stream t))\n\n;=====================================================================\n\n(defun zcpexec (object stream bits)\n (cond\n  (;(streamp stream)\n   (and (structp stream) (eq (vref stream 0) 'stream))\n   (case bits\n    (#.%%%tyo      (zcpexec-tyo      object stream))\n    (#.%%%princ    (zcpexec-princ    object stream))\n    (#.%%%prin1    (zcpexec-prin1    object stream))\n    (#.%%%terpri   (zcpexec-terpri   object stream))\n    (#.%%%cterpri  (zcpexec-cterpri  object stream))\n    (#.%%%charpos  (zcpexec-charpos  object stream))\n    (#.%%%clrscrn  (zcpexec-clrscrn  object stream))\n    (t (zcpexec-error stream (zcpexec-bits-operation bits)\n                             \"Unknown operation passed to ZCPEXEC\"\n                             (zcpexec-bits-operation bits)))))\n  ((symbolp stream)\n   (case bits\n    (#.%%%tyo\n             (zcpexec-tyo      object (zcpexec-prepare-stream stream)))\n    (#.%%%princ\n             (zcpexec-princ    object (zcpexec-prepare-stream stream)))\n    (#.%%%prin1\n             (zcpexec-prin1    object (zcpexec-prepare-stream stream)))\n    (#.%%%terpri\n             (zcpexec-terpri   object (zcpexec-prepare-stream stream)))\n    (#.%%%cterpri\n             (zcpexec-cterpri  object (zcpexec-prepare-stream stream)))\n    (#.%%%charpos\n             (zcpexec-charpos  object (zcpexec-prepare-stream stream)))\n    (#.%%%clrscrn\n             (zcpexec-clrscrn  object (zcpexec-prepare-stream stream)))\n    (t\n     (zerror `(\"Unsupported ZCPEXEC operation for output file \"\n               ,(prin1-to-string stream))\n             (zcpexec-bits-operation bits)))))\n  (t\n   (zerror `(\"Invalid output file argument to \"\n             ,(zcpexec-bits-operation bits)\n             \" (not symbol or stream)\")\n           (prin1-to-string stream)))))\n\n(defun zcpexec-bits-operation (bits)\n (case bits\n       (#.%%%tyo      \"TYO\"        )\n       (#.%%%princ    \"PRINC\"      )\n       (#.%%%prin1    \"PRIN1\"      )\n       (#.%%%terpri   \"TERPRI\"     )\n       (#.%%%cterpri  \"CTERPRI\"    )\n       (#.%%%charpos  \"CHARPOS\"    )\n       (#.%%%clrscrn  \"CLRSCRN\"    )\n       (t             (string-append \"unknown (\" (tostring bits) \")\"))))\n\n(declare (special *zcpexec-stream-table*))\n\n(defun zcpexec-prepare-stream (stream)\n (when (symbolp stream)\n       (unless (boundp '*zcpexec-stream-table*)\n        (setq *zcpexec-stream-table* nil)\n        (unless (boundp '*print-case*)   (setq *print-case*   nil))\n        (unless (boundp '*print-escape*) (setq *print-escape* nil))\n        (unless (boundp '*print-length*) (setq *print-length* nil))\n        (unless (boundp '*print-level*)  (setq *print-level*  nil))\n       )\n       (let* ((fileid stream)\n              (p (assq fileid *zcpexec-stream-table*))\n             )\n             (cond\n              (p\n               (setq stream (cdr p)))\n              (t\n               (setq stream (make-stream\n                                 :identifier\n                                 (list 'file fileid (zildsno fileid))\n                                 :type 'file\n                                 :output-function\n                                 #'(lambda (char)\n                                           (write-char char fileid))\n                                 :princ-function\n                                 #'(lambda (string)\n                                           (princ-string string fileid))\n                            ))\n               (push (cons fileid stream) *zcpexec-stream-table*)))))\n stream\n)\n\n(defun zcpexec-error (stream fun message &optional (arg1 () arg1?)\n                                                   (arg2 () arg2?)\n                                                   (arg3 () arg3?))\n (cterpri)\n (princ \";Error detected for stream \")\n (princ (stream-identifier stream))\n (princ \":\")\n (terpri)\n (princ \";\")\n (princ message)\n (when arg1? (princ \" - \") (prin1 arg1))\n (when arg2? (princ \" \")   (prin1 arg2))\n (when arg3? (princ \" \")   (prin1 arg3))\n (terpri)\n (zerror (string-append fun \" failure\"))\n)\n\n(defmacro punt (&rest operations)\n `(progn\n   ,.(mapcar\n      #'(lambda (o)\n         `(defun ,(concat \"ZCPEXEC-\" o) (object stream)\n           (zcpexec-error stream ,(string o) \"Unsupported operation\")))\n   operations)\n   ))\n\n;\n; TYO - the basic output operation, outputs a character\n;\n\n(defun zcpexec-tyo (object stream)\n (unless (characterp object)\n  (zcpexec-error stream \"TYO\" \"Argument not a character\" object))\n (funcall (or (stream-output-function stream)\n           (zcpexec-error stream \"TYO\"\n                          \"No output operations possible on stream\"))\n          object\n )\n (setf (stream-last-char stream) object)\n (if (eql object #.eol)\n     (setf (stream-charpos stream) 1)\n     (incf (stream-charpos stream)))\n object\n)\n\n;\n; PRINC\n;\n\n(defun zcpexec-princ (object stream)\n (zcpexec-prin object stream 0 nil))\n\n;\n; PRIN\n;\n\n(defun zcpexec-prin1 (object stream)\n (zcpexec-prin object stream 0 t))\n\n;\n; TERPRI\n;\n\n(defun zcpexec-terpri (object stream)\n (zcpexec-tyo #.eol stream)\n ; set newlinep true - actually, tyo does this implicitly when eol\n nil\n)\n\n;\n; CTERPRI\n;\n\n(defun zcpexec-cterpri (object stream)\n (cond\n  ((eql (stream-last-char stream) #.eol)\n   nil)\n  (t\n   (zcpexec-terpri object stream)\n   t)))\n\n;\n; CHARPOS\n;\n\n(defun zcpexec-charpos (object stream)\n (cond\n  ((null object)\n   (stream-charpos stream))\n  ((or (not (fixnump object))\n       (minusp object))\n   (zcpexec-error stream \"CHARPOS\" \"Invalid value for CHARPOS\" object))\n  ((< object (stream-charpos stream))\n   (zcpexec-error stream \"CHARPOS\" \"Cannot set CHARPOS to this\" object))\n  (t\n   (dotimes (i (- object (stream-charpos stream)))\n            (zcpexec-tyo #\\sp stream))\n   (setf (stream-charpos stream) object)\n  )))\n;\n; CLRSCRN\n;\n\n(punt clrscrn)\n\n;=======================================================================\n\n(declare (special\n                  *print-case*\n                  *print-escape*\n                  *print-length*\n                  *print-level*\n         ))\n\n(defun zcpexec-prin (object stream level escape)\n (let (\n       (*print-escape* escape)\n      )\n      (zcpprint-1 object stream level escape)))\n\n(defun zcpprint-1 (object stream level escape)\n (cond\n  ((symbolp object)\n   (zcpprint-symbol object stream level escape))\n  ((or (and (atom object) (not (vecp object)))\n       (eq object (zilunbnd))\n       (eq object (rmnil)))\n   (zcpprint-low-level object stream escape))\n  (t\n   (zcpprint-with-components object stream level escape)))\n object\n)\n\n(defun zcpprint-low-level (object stream escape)\n (let ((string    (tostring object escape))\n       (princfun  (stream-princ-function stream))\n      )\n      (cond\n       (princfun ; If a low-level PRINC function is defined, use it.\n        (funcall princfun string))\n       (t\n        (let ((outputfun\n               (or (stream-output-function stream)\n                   (zcpexec-error stream \"PRINC\"\n                          \"No output operations possible on stream\")))\n              (stringlen (string-length string))\n              (lastchar  nil)\n             )\n         ;\n         ; check for room on current line if appropriate ........\n         ;\n         (dotimes (i stringlen)\n                  (funcall outputfun (setq lastchar (char string i))))\n         (setf (stream-last-char stream) lastchar)\n         (incf (stream-charpos stream)   stringlen)\n        )))\n )\n object\n)\n\n(defun zcpprint-symbol (object stream level escape)\n (if escape (zcpprint-symbol-prin1 object stream)\n            (zcpprint-symbol-princ object stream)))\n\n(defun zcpprint-symbol-princ (object stream)\n (let* ((case *print-case*)\n        (prrep (symbol-name object))\n        (cased-string\n         (case case\n          ((nil)       nil)\n          (:upcase     (string-upcase prrep))\n          (:downcase   (string-downcase prrep))\n          (:capitalize (string-capitalize prrep))\n          (t\n           (setq *print-case* nil)\n           (warn \"Invalid value for *PRINT-CASE*, resetting to NIL\"\n                 case)\n           nil)))\n       )\n  (cond\n   ((null cased-string)\n    (zcpprint-low-level prrep stream nil))\n   (t\n    (do ((i 0 (1+ i))\n         (s nil)\n         (l (string-length prrep))\n         (pchar nil)\n         (cchar nil)\n        )\n        ((eql i l)\n         (setq s (if s (string-appendl (nreverse s)) prrep))\n         (zcpprint-low-level s stream nil))\n        (setq pchar (char prrep i)\n              cchar (char cased-string i))\n        (cond\n         ((upper-case-p pchar)\n          (unless s (push (string-substr prrep 1 i) s))\n          (push (string cchar) s))\n         (t\n          (when s (push (string pchar) s))))\n    )))))\n\n(defun zcpprint-symbol-prin1 (object stream)\n (let ((case *print-case*))\n  (cond\n   ((null case)\n    (zcpprint-low-level object stream t))\n   (t\n    (let ((prrep (tostring object t)))\n     ;\n     ; Note:  This code assumes that ZIL slashification always\n     ;        does its thing by surrounding the data with\n     ;        vertical bars, and never just inserts backslashes\n     ;        in front of the funny characters.  (This is a good\n     ;        assumption, since such a slashifier is guaranteed\n     ;        to be independent of maclispification of the readtable.)\n     ;\n     ;        Anyhow, this is what ZILADMP does, and therefore\n     ;        nobody should ever change ZILADMP to slashify by\n     ;        means of backslashes.\n     ;\n     (%princ (if (eql (char prrep 0) #\\|)\n                 prrep\n                 (case case\n                  (:upcase     (string-upcase prrep))\n                  (:downcase   (string-downcase prrep))\n                  (:capitalize (string-capitalize prrep))\n                  (t\n                   (setq *print-case* nil)\n                   (warn\n                     \"Invalid value for *PRINT-CASE*, resetting to NIL\"\n                         case)\n                   prrep)))\n             stream))))))\n\n(defun zcpprint-with-components (object stream level escape)\n (cond\n  ((and *print-level* (>= level *print-level*))\n   (%tyo #\\# stream))\n  ((consp object)\n   (zcpprint-list object stream (1+ level) escape #.lp #.rp))\n  ((vectorp object)\n   (zcpprint-vector object stream (1+ level) escape #.lvp #.rvp))\n  ((funargp object)\n   (%princ #.lfp stream)\n   (zcpprint-1 (funfun object) stream (1+ level) escape)\n   ;;;;;;;;;;; (funenv object) does not get printed.\n   (%princ #.rfp stream)\n  )\n  (t\n   (zcpprint-structure object stream (1+ level) escape))))\n\n(defun zcpprint-list (object stream level escape lp rp)\n (%tyo (lp) stream)\n (when object\n  (prog ((count 1) (length *print-length*))\n   loop\n       (when (and length (> count length))\n             (%princ \"...\" stream)\n             (return))\n       (zcpprint-1 (zcar object) stream level escape)\n       (setq object (cdr object))\n       (when (null object) (return))\n       (incf count)\n       (cond\n        ((atom object)\n         (%princ \" . \" stream)\n         (zcpprint-1 object stream level escape))\n        (t\n         (%tyo #\\sp stream)\n         (go loop)))))\n (%tyo (rp) stream)\n)\n\n(defun zcpprint-vector (object stream level escape ldlm rdlm)\n (let ((vl (vlength object))\n       (pl *print-length*)\n      )\n  (%princ ldlm stream)\n  (unless (zerop vl)\n   (prog ((count 0))\n    loop\n        (when (and pl (>= count pl))\n              (%princ \"...\" stream)\n              (return))\n        (zcpprint-1 (vref object count) stream level escape)\n        (incf count)\n        (when (eql count vl) (return))\n        (%tyo #\\sp stream)\n        (go loop)))\n  (%princ rdlm stream)\n )\n)\n\n(defun zcpprint-structure (object stream level escape)\n (let ((print-method (get (vref object 0) 'defstruct-print-method)))\n  (if print-method\n   (let ((*print-escape* escape)) ; escape not CL, use *print-escape*\n        (funcall print-method object stream level))\n   (zcpprint-vector object stream (1+ level) escape #.lsp #.rsp))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCREXEC": {"ttr": 5901, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x00\\x00\\x883_\\x00\\x905_\\x162\\x06\\x0f\\x00~\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "1988-11-30T00:00:00", "modifydate": "1990-12-21T16:32:00", "lines": 1551, "newlines": 126, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; Bug fix 12/21/90 - CHARPOS should not be incremented when TYI calls\n;                    the stream-input-function and gets back NIL.\n;                    This was causing READ-FROM-STRING to return an\n;                    incorrect second value.\n\n; ZCREXEC is the function called by the \"default ZIL reader\", ZDREAD,\n; when the file argument is not a symbol.  The file argument is assumed\n; to be a stream (which is why we call it \"stream\" in this code).\n;\n; ZCREXEC, like ZDREAD, takes six required arguments:\n;\n;  arg 1 = the stream to perform input operations on.\n;  arg 2 = a fixnum built from the boolean values listed below.\n;  arg 3 = miscellaneous function-dependent data (e.g. char operand).\n;  arg 4 = eof-error-p.\n;  arg 5 = eofval.\n;  arg 6 = recursive-p.\n;\n; Arg 2 values are made up from the following bit settings:\n;\n; 00000000  =  Read an S-expression (READ)\n; .....001  =  Read a character (TYI)\n; .....010  =  Unread a character (UNTYI)\n; .....011  =  Peek a character (TYIPEEK)\n; .....100  =  Intern a character (READCH)\n; .....110  =  Intern a character (PEEKCH)\n; ....1...  =  EOF request\n; ...1....  =  EOL (newline) request\n; ..1.....  =  1 = set EOF/EOL, 0 = test EOF/EOL\n; .1......  =  Read a line of data (READLINE)\n; 1.......  =  Readtable functions\n; 1......1  =  Set reader macro\n; 1.....1.  =  Set MACLISP readtable\n; 1....1..  =  Return reader macro character\n;\n\n;=======================================================================\n\n(include #.(zil-source-member zcsdfstr))  ; Stream type defstruct.\n\n;=======================================================================\n\n(defmacro read-char (&optional stream eoferp eofval recursive-p)\n;(tyi stream eoferp eofval nil))\n `(zcread ,stream #.%%tyi nil ,eoferp ,eofval #.eol))\n\n(defmacro peek-char (&optional arg stream eoferp eofval recursive-p)\n;(tyipeek arg stream eoferp eofval nil))\n `(zcread ,stream #.%%tyipeek ,arg ,eoferp ,eofval #.eol))\n\n(defmacro unread-char (arg &optional stream eofval)\n;(untyi arg stream eoferp eofval nil))\n `(zcread ,stream #.%%untyi ,arg nil #.eof #.eol))\n\n(defmacro zcrread-character-macro-function (char)\n `(vref (readtable-character-macro-table *readtable*) ,char))\n\n(defmacro zcrread-dispatch-macro-function (char)\n `(vref (readtable-dispatch-macro-table *readtable*) ,char))\n\n(defmacro the-character (i)\n `(vref (readvector-characters readvector) ,i))\n(defmacro the-syntax    (i)\n `(vref (readvector-syntaxes   readvector) ,i))\n(defmacro the-attribute (i)\n `(vref (readvector-attributes readvector) ,i))\n\n(defargs mxbq 1 1 nil)\n\n;=======================================================================\n\n(defun zcrexec (stream bits misc eoferp eofval recurp)\n (cond\n  (;(streamp stream)\n   (and (structp stream) (eq (vref stream 0) 'stream))\n   (case bits\n    (#.%%tyi      (zcrexec-tyi      stream misc eoferp eofval recurp))\n    (#.%%untyi    (zcrexec-untyi    stream misc eoferp eofval recurp))\n    (#.%%tyipeek  (zcrexec-tyipeek  stream misc eoferp eofval recurp))\n    (#.%%read     (zcrexec-read     (zcrexec-prepare-stream stream t)\n                                    misc eoferp eofval recurp))\n    (#.%%readline (zcrexec-readline (zcrexec-prepare-stream stream t)\n                                    misc eoferp eofval recurp))\n    (#.%%charpos  (zcrexec-charpos  stream misc eoferp eofval recurp))\n    (#.%%readch   (zcrexec-readch   stream misc eoferp eofval recurp))\n    (#.%%peekch   (zcrexec-peekch   stream misc eoferp eofval recurp))\n    (#.%%eof      (zcrexec-eof      stream misc eoferp eofval recurp))\n    (#.%%quit     (zcrexec-quit     stream misc eoferp eofval recurp))\n    (#.%%newlinep (zcrexec-newlinep stream misc eoferp eofval recurp))\n    (#.%%endread  (zcrexec-endread  stream misc eoferp eofval recurp))\n    (#.%%rminit   (zcrexec-rminit   stream misc eoferp eofval recurp))\n    (#.%%rdrmacro (zcrexec-rdrmacro stream misc eoferp eofval recurp))\n    (#.%%rmmac    (zcrexec-rmmac    stream misc eoferp eofval recurp))\n    (#.%%rmchar   (zcrexec-rmchar   stream misc eoferp eofval recurp))\n    (#.%%read-delimited-list\n                  (zcrexec-readdl   (zcrexec-prepare-stream stream t)\n                                    misc eoferp eofval recurp))\n    (t\n     (zcrexec-error stream (zcrexec-bits-operation bits)\n                           \"Unknown operation passed to ZCREXEC\"\n                           (zcrexec-bits-operation bits)))))\n  ((symbolp stream)\n   (case bits\n    (#.%%read     (zcrexec-read     (zcrexec-prepare-stream stream t)\n                                    misc eoferp eofval recurp))\n    (#.%%readline (zcrexec-readline (zcrexec-prepare-stream stream t)\n                                    misc eoferp eofval recurp))\n;;;;(#.%%tyipeek  (zcrexec-tyipeek  (zcrexec-prepare-stream stream nil)\n;;;;                                misc eoferp eofval recurp))\n    (#.%%tyipeek  (zcrexec-tyipeek  stream\n                                    misc eoferp eofval recurp))\n    (#.%%rminit   (zcrexec-rminit   stream misc eoferp eofval recurp))\n    (#.%%rdrmacro (zcrexec-rdrmacro stream misc eoferp eofval recurp))\n    (#.%%rmmac    (zcrexec-rmmac    stream misc eoferp eofval recurp))\n    (#.%%rmchar   (zcrexec-rmchar   stream misc eoferp eofval recurp))\n    (#.%%read-delimited-list\n                  (zcrexec-readdl   (zcrexec-prepare-stream stream t)\n                                    misc eoferp eofval recurp))\n    (t\n     (zerror `(\"Unsupported ZCREXEC operation for input file \"\n               ,(prin1-to-string stream))\n             (zcrexec-bits-operation bits)))))\n  (t\n   (zerror `(\"Invalid input file argument to \"\n             ,(zcrexec-bits-operation bits)\n             \" (not symbol or stream)\")\n           (prin1-to-string stream)))))\n\n(defun zcrexec-bits-operation (bits)\n (case bits\n       (#.%%read     \"READ\"       )\n       (#.%%tyi      \"TYI\"        )\n       (#.%%untyi    \"UNTYI\"      )\n       (#.%%tyipeek  \"TYIPEEK\"    )\n       (#.%%readch   \"READCH\"     )\n       (#.%%peekch   \"PEEKCH\"     )\n       (#.%%eof      \"EOF\"        )\n       (#.%%quit     \"QUIT\"       )\n       (#.%%newlinep \"NEWLINEP\"   )\n       (#.%%endread  \"ENDREAD\"    )\n       (#.%%readline \"READLINE\"   )\n       (#.%%rminit   \"RMINIT\"     )\n       (#.%%rdrmacro \"RDRMACRO\"   )\n       (#.%%rmmac    \"RMMAC\"      )\n       (#.%%rmchar   \"RMCHAR\"     )\n       (#.%%charpos  \"CHARPOS\"    )\n       (#.%%read-delimited-list \"READ-DELIMITED-LIST\")\n       (t            (string-append \"unknown (\" (tostring bits) \")\"))))\n\n(defun zcrexec-tyi (stream misc eoferp eofval recurp)\n (let ((char (stream-unread-char stream))) ; See if UNTYI was done\n  (cond\n   (char                            ; If a char was \"unread\"\n    (setf (stream-unread-char stream) nil) ; clear it\n   )\n   (t                               ; otherwise no unread char\n    (setq char\n     (funcall (or (stream-input-function stream)\n                  (zcrexec-error stream \"TYI\"\n                          \"No input operations possible on stream\"))\n              ))\n    (when (null char)   ; If end of file encountered\n          (setf (stream-eofp stream) t)\n          (if eoferp\n              (zcrexec-eof-error stream \"TYI\")\n              (setq char eofval)))))\n  (setf (stream-last-char stream) char)  ; Save for possible UNTYI\n  (unless (stream-eofp stream)\n          (incf (stream-charpos stream)))\n  char))\n\n(defun zcrexec-tyipeek (stream arg eoferp eofval recurp)\n (cond\n  ((null arg)\n   (let ((c (zcrexec-tyi stream nil eoferp eofval recurp)))\n        (zcrexec-untyi stream c eoferp eofval recurp)\n        c))\n  ((eq arg t)\n   (zcrexec-insure-readtable)\n   (let ((syntaxes (readtable-syntaxes *readtable*)))\n    (if (symbolp stream)\n        (do ((c (peek-char nil stream eoferp #.eof recurp)\n                (peek-char nil stream eoferp #.eof recurp)))\n            ((or (eql c #.eof)\n                 (not (eq (vref syntaxes c) :whitespace)))\n             (if (eql c #.eof) eofval c))\n            (read-char stream eoferp #.eof recurp))\n        (do ((c (zcrexec-tyipeek stream nil eoferp #.eof recurp)\n                (zcrexec-tyipeek stream nil eoferp #.eof recurp)))\n            ((or (eql c #.eof)\n                 (not (eq (vref syntaxes c) :whitespace)))\n             (if (eql c #.eof) eofval c))\n            (zcrexec-tyi stream nil eoferp #.eof recurp)))))\n  ((characterp arg)\n   (do ((c (zcrexec-tyipeek stream nil eoferp #.eof recurp)\n           (zcrexec-tyipeek stream nil eoferp #.eof recurp)))\n       ((or (eql c #.eof)\n            (eql c arg))\n        (if (eql c #.eof) eofval c))\n       (zcrexec-tyi stream nil eoferp #.eof recurp)))\n  (t (zcrexec-error stream \"TYIPEEK\"\n                    \"Invalid first arg to TYIPEEK\" arg))))\n\n(defun zcrexec-untyi (stream char eoferp eofval recurp)\n (let ((rchar (stream-last-char stream)))\n  (cond\n   ((null rchar)\n    (zcrexec-error stream \"UNTYI\"\n                   \"UNTYI issued without intervening TYI\" char))\n   ((not (eql rchar char))\n    (zcrexec-error stream \"UNTYI\"\n                   \"UNTYI character does not match\" rchar char))\n   (t\n    (setf (stream-unread-char stream) rchar)\n    (decf (stream-charpos stream))\n    nil))))\n\n(defun zcrexec-readch (stream misc eoferp eofval recurp)\n (let ((c (zcrexec-tyi stream misc nil #.eof recurp)))\n      (if (eql c #.eof)\n          (if eoferp\n              (zcrexec-eof-error stream \"READCH\")\n              eofval)\n          (ebcdic c t))))\n\n(defun zcrexec-peekch   (stream misc eoferp eofval recurp)\n (let ((c (zcrexec-tyipeek stream misc nil #.eof recurp)))\n      (if (eql c #.eof)\n          (if eoferp\n              (zcrexec-eof-error stream \"PEEKCH\")\n              eofval)\n          (ebcdic c t))))\n\n(defun zcrexec-eof      (stream misc eoferp eofval recurp)\n (stream-eofp stream))\n\n(defun zcrexec-quit     (stream misc eoferp eofval recurp)\n (setf (stream-eofp stream) t))\n\n(defun zcrexec-newlinep (stream misc eoferp eofval recurp)\n (eql (stream-last-char stream) #.eol))\n\n(defun zcrexec-endread  (stream misc eoferp eofval recurp)\n (and (not (zcrexec-newlinep stream misc eoferp eofval recurp))\n      (not (zerop (stream-charpos stream)))\n      (zcrexec-tyipeek stream #.eol nil nil nil))\n nil)\n\n(defun zcrexec-readline (stream misc eoferp eofval recurp)\n (cond\n  ((stream-eofp stream)\n   (if eoferp\n       (zcrexec-eof-error stream \"READLINE\")\n       eofval))\n  (t\n   (zcrread-begin-token stream)\n   (zcrexec-endread stream nil nil nil nil)\n   (zcrexec-tyi stream nil nil #.eol recurp)\n   (do ((c (zcrexec-tyi stream nil nil #.eol recurp)\n           (zcrexec-tyi stream nil nil #.eol recurp))\n       )\n       ((eql c #.eol)\n        (zcrexec-untyi stream c nil #.eol recurp)\n        (zcrread-make-string stream))\n       (zcrread-add-to-token stream c nil nil)))))\n\n(defun zcrexec-eof-error (stream fun)\n (zcrexec-error stream fun \"End of file encountered\"))\n\n(defun zcrexec-charpos (stream misc eoferp eofval recurp)\n (stream-charpos stream))\n\n(defun zcrexec-rminit (stream misc eoferp eofval recurp)\n (zcrexec-create-readtable))\n\n;;; The Common LISP reader.\n\n;;; Maclisp-compatible definition of READ would be:\n;\n; (defun read (&optional stream eofval)\n;   (zcrexec-read stream nil nil eofval nil))\n;\n;;; Common Lisp-compatible definition of READ would be:\n;\n; (defun read (&optional stream eoferp eofval recursive-p)\n;   (zcrexec-read stream nil eoferp eofval recursive-p))\n;\n; (defun read-reserving-whitespace\n;       (&optional stream eoferp eofval recursive-p)\n;   (zcrexec-read stream t eoferp eofval recursive-p))\n;\n\n(defun zcrexec-read\n       (stream preserve-whitespace-p eoferp eofval recursive-p)\n (let ((*zcrexec-preserving-whitespace-p*\n        (if recursive-p *zcrexec-preserving-whitespace-p*\n                        preserve-whitespace-p)))\n  (multiple-value-bind (object dotp)\n                       (zcrread-1 stream eoferp eofval recursive-p)\n   (when dotp\n    (zcrexec-error stream \"READ\"\n                   \"Dot illegal outside of dotted pair context\"))\n   object)))\n\n(defun zcrread-1 (stream eoferp eofval recurp)\n\n (prog (x y z syntax attribute terminating)\n\n   step1   (setq x (read-char stream nil #.eof t))\n           (when (eql x #.eof)\n                 (if eoferp\n                     (zcrexec-error stream \"READ\"\n                                    \"End of file encountered\")\n                     (return (values eofval nil))))\n           (setq syntax (syntax-of x))\n           (case syntax\n                 (:whitespace          #| (go step3) |# (go step1))\n                 (:constituent            (go step7))\n                 (:terminating-macro      (go step4-terminating))\n                 (:non-terminating-macro  (go step4-non-terminating))\n                 (:single-escape          (go step5))\n                 (:multiple-escape        (go step6))\n                 (:illegal                (go step2))\n           #+ZIL (:continuation-character (go stepz))\n                 (t\n                  (zcrread-bad-readtable-syntax x syntax stream)))\n\n   step2 ; x is an illegal character\n\n         (zcrread-illegal-character-error x stream)\n\n;;;step3 ; x is a whitespace character\n\n;;;;;;;;;(go step1)\n\n   step4-non-terminating ; x is a non-terminating macro character\n\n         (setq terminating nil)\n         (go step4)\n\n   step4-terminating ; x is a terminating macro character\n\n         (setq terminating t)\n;;;;;;;;;(go step4)\n\n   step4 ; x is a macro character (terminating or non-terminating)\n\n         (let ((macro-values (zcrread-macro-values x stream)))\n              (cond\n               ((null macro-values)\n                (go step1))\n              (t\n               (return (values (car macro-values) nil)))))\n\n   step5 ; x is a single-escape character\n\n         (setq y (read-char stream nil #.eof t))\n         (when (eql y #.eof)\n               (zcrexec-error stream \"READ\" x))\n         (zcrread-begin-token stream)\n         (zcrread-add-to-token stream y :constituent :alphabetic)\n         (go step8)\n\n  step6 ; x is a multiple-escape character\n\n         (zcrread-begin-token stream)\n         (go step9)\n\n  stepz  ; ZIL only ... x is a continuation character\n\n        (setq y (read-char stream nil #.eof t))\n        (when (eql y #.eof) ; Continuation followed by EOF - ignore it\n              (zcrread-begin-token stream)\n              (go step10))\n        (when (eql y #.eol) ; Continuation followed by newline - yes\n              (zcrread-begin-token stream)\n              (go step8))\n        (unread-char y stream)\n;;;;;;;;(go step7)          ; Otherwise treat like constituent\n\n  step7 ; x is a constituent character\n\n        (zcrread-begin-token stream)\n        (setq x (char-upcase x))\n        (zcrread-add-to-token stream x)\n;;;;;;;;(go step8)\n\n  step8 ; At this point a token is being accumulated, and an even number\n        ; of multiple escape characters have been encountered.\n\n        (setq y (read-char stream nil #.eof t))\n        (when (eql y #.eof)\n              (go step10))\n        (setq syntax (syntax-of y))\n        (case syntax\n              (:whitespace             (go step8f))\n              (:constituent            (go step8a))\n              (:terminating-macro      (go step8e))\n              (:non-terminating-macro  (go step8a))\n              (:single-escape          (go step8b))\n              (:multiple-escape     #| (go step8c) |# (go step9))\n              (:illegal                (go step8d))\n        #+ZIL (:continuation-character (go step8z))\n              (t\n               (zcrread-bad-readtable-syntax y syntax stream)))\n\n  step8a ; y is a constituent or non-terminating-macro character\n\n         (setq y (char-upcase y))\n         (zcrread-add-to-token stream y)\n         (go step8)\n\n  step8b ; y is a single-escape character\n\n         (setq z (read-char stream nil #.eof t))\n         (when (eql z #.eof)\n               (zcrexec-error stream \"READ\" y))\n         (zcrread-add-to-token stream z :constituent :alphabetic)\n         (go step8)\n\n;;step8c ; y is a multiple-escape character\n\n;;;;;;;;;(go step9)\n\n  step8d ; y is an illegal character\n\n         (zcrread-illegal-character-error y stream)\n\n  step8e ; y is a terminating macro character\n\n         (unread-char y stream)\n         (go step10)\n\n  step8f ; y is a whitespace character\n\n         (unless *zcrexec-preserving-whitespace-p*\n          (unread-char y stream)\n         )\n         (go step10)\n\n  step8z ; ZIL only ... y is a continuation character\n\n         (setq z (read-char stream nil #.eof t))\n         (when (eql z #.eof) ; Continuation followed by EOF - ignore it\n               (go step10))\n         (when (eql z #.eol) ; Continuation followed by newline - yes\n               (go step8))\n         (unread-char z stream)\n         (go step8a)         ; Otherwise treat like constituent\n\n  step9  ; At this point a token is being accumulated, and an odd number\n         ; of multiple escape characters have been encountered.\n\n        (setq y (read-char stream nil #.eof t))\n        (when (eql y #.eof)\n              (zcrexec-error stream \"READ\" x))\n        (setq syntax (syntax-of y))\n        (case syntax\n              (:whitespace             (go step9a))\n              (:constituent            (go step9a))\n              (:terminating-macro      (go step9a))\n              (:non-terminating-macro  (go step9a))\n              (:single-escape          (go step9b))\n              (:multiple-escape     #| (go step9c) |# (go step8))\n              (:illegal                (go step9d))\n        #+ZIL (:continuation-character (go step9z))\n              (t\n               (zcrread-bad-readtable-syntax y syntax stream)))\n\n  step9a ; y is a constituent, macro or whitespace character\n\n         (zcrread-add-to-token stream y :constituent :alphabetic)\n         (go step9)\n\n  step9b ; y is a single-escape character\n\n         (setq z (read-char stream nil #.eof t))\n         (when (eql z #.eof)\n               (zcrexec-error stream \"READ\" y))\n         (zcrread-add-to-token stream z :constituent :alphabetic)\n         (go step9)\n\n;;step9c ; y is a multiple-escape character\n\n;;;;;;;;;(go step8)\n\n  step9d ; y is an illegal character\n\n         (zcrread-illegal-character-error y stream)\n\n  step9z ; ZIL only ... y is a continuation character\n\n         (setq z (read-char stream nil #.eof t))\n         (when (eql z #.eof) ; Continuation followed by EOF - ignore it\n               (go step10))\n         (when (eql z #.eol) ; Continuation followed by newline - yes\n               (go step9))\n         (unread-char z stream)\n         (go step9a)         ; Otherwise treat like constituent\n\n  step10 ; An entire token has been accumulated.\n\n         (return (zcrread-lisp-object stream))))\n\n(defun zcrread-macro-values (char stream)\n (multiple-value-list\n  (funcall (or (zcrread-character-macro-function char)\n               (zcrexec-error stream \"READ\"\n                              \"No reader macro function for character\"\n                              (string char)))\n           stream char)))\n\n(defun zcrread-lisp-object (stream)\n (let ((readvector (stream-readvector stream)))\n  (let ((index      (readvector-index readvector))\n        (attributes (readvector-attributes readvector))\n        (internp t)\n        (numericp t)\n        (alldotp t)\n       )\n  (do ((i (1- index) (1- i)))\n      ((minusp i)\n       (let ((s (zilvtos (readvector-characters readvector) index)))\n            (when alldotp\n             (case index\n                   (0 (setq alldotp nil))\n                   (1)\n                   (t\n              (zcrexec-error stream \"READ\"\n                             \"Token of all dots illegal\" s))))\n             (values (make-atom s internp numericp) alldotp)))\n      (case (vref attributes i)\n            (:alphabetic\n             (setq numericp nil)\n             (setq alldotp nil)\n            )\n            (:alphadigit\n             (setq alldotp nil)\n            )\n            (:dot\n            )\n            (:illegal\n             (zcrread-illegal-character-error (the-character i) stream))\n            (t\n             (zcrexec-error stream \"READ\"\n                            \"Can't deal with this character attribute\"\n                            (zcrread-hex (the-character i))\n                            (the-attribute i))))))))\n\n\n(defun zcrread-begin-token (stream)\n (let ((readvector (stream-readvector stream)))\n      (setf (readvector-index readvector) 0)\n      nil))\n\n(defun zcrread-add-to-token (stream char &optional\n                                       (syntax (syntax-of char))\n                                       (attribute (attribute-of char))\n                            )\n (let ((readvector (stream-readvector stream)))\n  (let ((index  (readvector-index  readvector))\n        (length (readvector-length readvector))\n       )\n       (when (>= index length)\n        (let* ((new-length (+ length 256))\n               (new-readvector (make-readvector new-length))\n              )\n         (setf (readvector-index new-readvector) index)\n         (dotimes (i length)\n          (setf (vref (readvector-characters new-readvector) i)\n                (vref (readvector-characters readvector) i))\n          (setf (vref (readvector-syntaxes new-readvector) i)\n                (vref (readvector-syntaxes readvector) i))\n          (setf (vref (readvector-attributes new-readvector) i)\n                (vref (readvector-attributes readvector) i))\n         )\n         (setq readvector new-readvector)\n         (setf (stream-readvector stream) readvector)\n        )\n       )\n       (setf (vref (readvector-characters readvector) index) char)\n       (setf (vref (readvector-syntaxes   readvector) index) syntax)\n       (setf (vref (readvector-attributes readvector) index) attribute)\n       (incf (readvector-index readvector))\n       char\n )))\n\n(defun zcrread-illegal-character-error (x stream)\n (zcrexec-error stream \"READ\" \"Illegal character found in input: \"\n                (string x) (zcrread-hex x)))\n\n(defun zcrread-bad-readtable-syntax (x syntax stream)\n (zcrexec-error stream \"READ\"\n                \"Invalid readtable syntax entry for \"\n                 (string x)\n                 (zcrread-hex x)\n                 syntax))\n\n(defun zcrread-hex (x)\n (funcall 'format nil \"X'~2,'0x'\" x) ; Load FORMAT only when needed.\n)\n\n;\n; ' (quote) reader macro\n;\n\n(defun zcrread-\\'-macro (stream mchar)\n (list 'quote (zcrexec-read stream nil t nil t)))\n\n;\n; ` (backquote) reader macro\n;\n\n(defun zcrread-\\`-macro (stream mchar)\n (mxbq (zcrexec-read stream nil t nil t)))\n\n;\n; ( (left parenthesis) reader macro              ;)\n;\n\n(defun zcrread-\\(-macro (stream mchar)    ;)\n;(read-delimited-list (rp) stream t)\n;(zcrexec #.%%read-delimited-list stream (rp) t t t)\n (zcrexec-readdl                  stream (rp) t t t)\n)\n\n;                                                ;(\n; ) (right parenthesis) reader macro\n;\n\n(defun zcrread-\\)-macro (stream mchar)\n (zcrexec-error stream \"READ\" \"Unmatched right parenthesis \\\")\\\"\"))\n\n;\n; ; (semicolon) reader macro\n;\n\n(defun zcrread-\\;-macro (stream mchar)\n (peek-char #.eol stream nil #.eof t)\n (values))\n\n;\n; , (comma) dispatching reader macro\n;\n\n(defun zcrread-\\,-macro (stream mchar)\n `(,(case (peek-char t stream t nil t)\n          (#\\@         (read-char stream) ; Throw away the character.\n                       '|,@|)\n          (#\\.         (read-char stream) ; Throw away the character.\n                       '|,.|)\n          (t           '|,|))\n   ,(zcrexec-read stream nil t nil t)))\n\n\n;\n; \" (double quote) reader macro\n;\n\n(defun zcrread-\\\"-macro (stream mchar)\n (zcrread-begin-token stream)\n (prog (c d e)\n    loop\n       (setq c (read-char stream nil #.eof t))\n       (cond\n        ((eql c #.eof)\n         (go eof-error))\n        ((eql c #\\\")\n         (return (zcrread-make-string stream)))\n        (t\n         (case (syntax-of c)\n               (:single-escape\n                (setq c (read-char stream nil #.eof t))\n                (cond\n                 ((eql c #.eof)\n                  (go eof-esc-error))\n                 (t\n                  (zcrread-add-to-token stream c nil nil))))\n         #+ZIL (:continuation-character\n                (setq e (read-char stream nil #.eof t))\n                (cond\n                 ((eql e #.eof)\n                  (go eof-error))\n                 ((eql e #.eol)\n                  ())\n                 (t\n                  (unread-char e stream)\n                  (zcrread-add-to-token stream c nil nil))))\n               (t\n                (zcrread-add-to-token stream c nil nil)))))\n       (go loop)\n    eof-error\n       (zcrexec-error stream \"READ\"\n\"End of file encountered while reading string before finding closing \\\"\"\n       )\n    eof-esc-error\n       (zcrexec-error stream \"READ\"\n\"End of file encountered while reading string following single escape\"\n       )))\n\n(defun zcrread-make-string (stream)\n ; Since this is called only in 1 place, readvector will never be null.\n (let ((readvector (stream-readvector stream)))\n      (zilvtos (readvector-characters readvector)\n               (readvector-index readvector))))\n\n;\n; READ-DELIMITED-LIST processor\n;\n\n(defun zcrexec-readdl (stream char ignore dottedp recurp)\n (unless (characterp char)\n         (zcrexec-error stream \"READ-DELIMITED-LIST\"\n                               \"Not a character\" char))\n (prog (z c thing needatom gotatom (eofval (ncons nil)))\n    loop\n       (setq c (peek-char t stream nil #.eof t))\n       (cond\n        ((eql c #.eof)\n         (go eof-error))\n        ((eql c char)\n         (read-char stream) ; Consume the character.\n         (cond\n          (needatom\n           (zcrexec-error stream \"READ-DELIMITED-LIST\"\n                  \"Dotted pair error - no object read following \\\".\\\"\"))\n          (gotatom\n           (return z))\n          (t\n           (return (nreverse z)))))\n        (t\n         (case (syntax-of c)\n          ((:terminating-macro\n            :non-terminating-macro)\n           (read-char stream) ; Consume the character.\n           (let ((macro-values (zcrread-macro-values c stream)))\n                (cond\n                 ((null macro-values)\n                  (go loop))\n                 (t\n                  (setq thing (car macro-values))\n                  (go push-it)))))\n          (t\n           (multiple-value-bind (object dotp)\n                                (zcrread-1 stream nil eofval t)\n            (when (eq object eofval) (go eof-error))\n            (cond\n             (dotp\n              (unless dottedp\n                      (zcrexec-error stream \"READ-DELIMITED-LIST\"\n                             \"Dot illegal outside dotted pair context\"))\n              (unless z\n                      (zcrexec-error stream \"READ-DELIMITED-LIST\"\n                  \"Dotted pair error - no object read preceding \\\".\\\"\"))\n              (setq needatom t gotatom nil dottedp nil)\n              (go loop)\n             )\n             (t\n              (setq thing object)\n              (go push-it))))))))\n    push-it\n       (cond\n        (gotatom\n         (zcrexec-error stream \"READ-DELIMITED-LIST\"\n       \"Dotted pair error - more than one object read following \\\".\\\"\"))\n        (needatom\n         (setq z (nreconc z thing))\n         (setq needatom nil gotatom t)\n        )\n        (t\n         (push thing z)))\n       (go loop)\n    eof-error\n       (zcrexec-error stream \"READ-DELIMITED-LIST\"\n\"End of file encountered while reading list before finding delimiter\"\n                       (string char))\n ))\n\n;\n; # (sharp) dispatching reader macro\n;\n\n;\n; This function is used to implement the reader macro # in conjunction\n; with the Common LISP reader (CLREAD).\n;\n; Currently the only syntax supported is:\n;\n;   #'FOO   --> (FUNCTION FOO)\n;   #+FOO BAR  --> BAR, only if feature FOO exists\n;   #-FOO BAR  --> BAR, only if feature FOO doesn't exist\n;   #.FOO   --> evaluated value of FOO.\n;   #/FOO   --> the fixnum corresponding to the character FOO.\n;   #\\FOO   --> same as #/FOO.\n;   #\u00acY     --> the fixnum correspinding to \"CONTROL Y\" if it existed.\n;   #o777   --> integer expressed in octal.\n;   #O777   --> integer expressed in octal.\n;   #x7F0   --> integer expressed in hex.\n;   #X7F0   --> integer expressed in hex.\n;   #b101   --> integer expressed in binary.\n;   #B101   --> integer expressed in binary.\n;   #nnRnnn --> integer expressed in radix nn.\n;   #|...|# --> comments.\n;   #(...)  --> vector.\n;   #S(...) --> structure (added 1/88).\n;\n;   #,FOO   --> load-time evaluation of FOO.  Currently this is\n;               identical to #.FOO, which it's supposed to be\n;               under the interpreter anyhow.\n;\n; ZIL-only extensions...\n;\n;   #z7F0   --> FIXNUM expressed in hex.\n;   #Z7F0   --> FIXNUM expressed in hex.\n;\n; and...\n;\n;   # followed by a character, if set-dispatch-macro-character has been\n;     done for that character.\n;\n\n(eval-when ()  ; Processed by nobody but READ.\n #.(progn\n    (defvar character-types\n     '(\n           (NULL      .   #X00)\n           (HT        .   #X05)\n           (TAB       .   #X05)\n           (DEL       .   #X07)\n           (RUBOUT    .   #X07)\n           (VT        .   #X0B)\n           (CR        .   #X0D)\n           (RETURN    .   #X0D)\n           (NL        .   #X15)\n           (NEWLINE   .   #X15)\n           (BS        .   #X16)\n           (BACKSPACE .   #X16)\n           (LF        .   #X25)\n           (LINEFEED  .   #X25)\n           (FF        .   #X2C)\n           (FORM      .   #X2C)\n           (PAGE      .   #X2C)\n           (SP        .   #X40)\n           (SPACE     .   #X40)\n           (ALT       .   #X100) ; \"Invalid\".\n           (ALTMODE   .   #X100) ; \"Invalid\".\n     ))\n  )\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zcrread-\\#-macro (f mchar)\n (let* ((c) ; Will be set to first non-numeric character read.\n        (n (prog (d z)\n             loop\n                 (setq c (or (read-char f nil nil t)\n                             (zcrexec-error f \"READ\"\n                                \"No dispatch character for #\")))\n                 (setq d (digit-char-p c 10))\n                 (when (null d)\n                       (return z))\n                 (setq z (+ (* 10 (or z 0)) d))\n                 (go loop)\n          ))\n       )\n       (funcall (or (zcrread-dispatch-macro-function (char-upcase c))\n                    (zcrexec-error f \"READ\"\n             \"No dispatching function defined for character following #\"\n                                   (string c) (zcrread-hex c)))\n                f c n)))\n\n;=======================================================================\n\n(defun zcrsharp-n-error (f c n)\n (zcrexec-error f \"READ\"\n   \"Numeric modifier not allowed for dispatcher\"\n   (symbol-name (concat \"#\" n (string c)))))\n\n;=======================================================================\n\n;\n; #'foo --> (FUNCTION foo)\n;\n\n(defun zcrsharp-quote (f c n)\n (when n (zcrsharp-n-error f c n))\n `(function ,(zcrexec-read f nil t nil t))\n)\n\n;=======================================================================\n\n;\n; #.(foo) --> ...whatever the value of (foo) is...\n;\n\n(defun zcrsharp-period (f c n)\n (when n (zcrsharp-n-error f c n))\n (catch nil (eval (zcrexec-read f nil t nil t)))\n; Return NIL if error evaluating form.\n)\n\n;=======================================================================\n\n;\n; #,(foo) --> ...whatever the value of (foo) is at load time ...\n;\n\n(defun zcrsharp-comma (f c n)\n (when n (zcrsharp-n-error f c n))\n (when (featurep 'zilco) ; If being read by the compiler\n  (cterpri)\n  (princ \"Load-time evaluation (#,) not supported by ZIL compiler.\")\n  (terpri)\n  (princ \"Processing as read-time evaluation (#.).\")\n  (terpri)\n )\n (zcrsharp-period f c n) ; Process like #.\n)\n\n;=======================================================================\n\n;\n; #+foo --> if foo is a feature, then whatever follows\n;\n\n(defun zcrsharp-plus (f c n)\n (when n (zcrsharp-n-error f c n))\n (cond\n       ((zcrsharp-eval-features (zcrexec-read f nil t nil t) f)\n        (zcrexec-read f nil t nil t))\n       (t\n        (let ((*read-suppress* t))\n             (zcrexec-read f nil t nil t))\n        (values))))\n\n;\n; #-foo --> if foo is NOT a feature, then whatever follows\n;\n\n(defun zcrsharp-minus (f c n)\n (when n (zcrsharp-n-error f c n))\n (cond\n       ((zcrsharp-eval-features (zcrexec-read f nil t nil t) f)\n        (let ((*read-suppress* t))\n             (zcrexec-read f nil t nil t))\n        (values))\n       (t\n        (zcrexec-read f nil t nil t))))\n\n(defun zcrsharp-eval-features (x f)\n (cond\n  ((atom x)\n   (featurep x))\n  ((eq (zcar x) 'or)\n   (some #'(lambda (x) (zcrsharp-eval-features x f)) (cdr x)))\n  ((eq (zcar x) 'and)\n   (every #'(lambda (x) (zcrsharp-eval-features x f)) (cdr x)))\n  ((eq (zcar x) 'not)\n   (if (and (cdr x) (null (cddr x)))\n       (not (zcrsharp-eval-features (zcadr x) f))\n       (zcrsharp-feature-error x f)))\n  (t\n   (zcrsharp-feature-error x f))))\n\n(defun zcrsharp-feature-error (x f)\n (zcrexec-error f \"READ\" \"Invalid feature specification form\" x))\n\n;\n; #/foo --> returns a character object (actually a fixnum)\n; #\\foo --> same as #/foo\n;\n\n(defun zcrsharp-escape (f c n)\n (when n (zcrsharp-n-error f c n))\n (zcrsharp-character-representation f))\n\n;\n; #\u00acfoo --> returns an impossible character object fixnum for CNTL-foo\n;\n\n(defun zcrsharp-control (f c n)\n (when n (zcrsharp-n-error f c n))\n (+ 256 (zcrsharp-character-representation f))\n)\n\n(defun zcrsharp-character-representation (f)\n (let ((a (peek-char nil f t nil t)))\n  (if (alpha-char-p a)\n      (let* ((r (zcrexec-read f nil t nil t))\n             (c (assq r '#.character-types)))\n            (if c (cdr c)\n                  (if (eql (string-length r) 1) ; If it read 1 character\n                      a\n                      (zcrexec-error f \"READ\"\n                                \"Unknown character representation\" r))))\n      (read-char f t nil t))))\n\n;\n; #o777 ...\n;\n(defun zcrsharp-octal (f c n)\n (when n (zcrsharp-n-error f c n))\n (zcrsharp-radix f 8))\n\n;\n; #x1AC8 ...\n;\n(defun zcrsharp-hex (f c n)\n (when n (zcrsharp-n-error f c n))\n (zcrsharp-radix f 16))\n\n;\n; #b1011 ...\n;\n(defun zcrsharp-binary (f c n)\n (when n (zcrsharp-n-error f c n))\n (zcrsharp-radix f 2))\n\n;\n; #36rfoobar ...\n;\n(defun zcrsharp-radix-n (f c n)\n (unless n (zcrexec-error f \"READ\" \"Numeric modifier required for #R\"))\n (when (or (< n 2) (> n 36))\n       (zcrexec-error f \"READ\" \"Invalid radix modifier for #R\" n))\n (zcrsharp-radix f n))\n\n(defun zcrsharp-radix (f radix)\n (prog (a z neg? err)\n       (setq z 0)\n  get1\n       (setq a\n             (or (peek-char nil f nil nil t)\n                 (zcrexec-error f \"READ\"\n                                  \"No digits following # with radix\"\n                                  radix)))\n       (when (eql a #\\SP)\n             (read-char f) ; Throw away the peeked character.\n             (go get1))\n       (case a\n             ((#\\-) (setq neg? t)\n                    (go next))\n             ((#\\+) (setq neg? nil)\n                    (go next))\n       )\n  loop\n       (let ((weight (or (digit-char-p a 36) (go ret))))\n            (if (not (< weight radix))\n                (push (string a) err)\n                (setq z (+ weight (* z radix)))))\n  next\n       (read-char f) ; Throw away the peeked character.\n       (setq a (peek-char nil f nil #.eof t))\n       (if (eql a #.eof)\n           (go ret)\n           (go loop)\n       )\n  ret\n       (when err\n             (zcrexec-error f \"READ\"\n                            \"Invalid digit(s) for radix\"\n                            radix (nreverse err)))\n       (return (if neg? (minus z) z))\n )\n)\n\n;;;\n;;; #Znnn is like #Xnnn except that it always produces a fixnum,\n;;; which can be two's complement, and therefore cannot have more\n;;; than 8 hex characters.\n;;;\n;;; For example...\n;;;\n;;; #XFFFFFFFF  =  42\n;;; #ZFFFFFFFF  =  -1\n;;;\n\n(defun zcrsharp-hex370 (f c n)\n (when n (zcrsharp-n-error f c n))\n (prog (a z count err)\n       (setq z 0 count 0)\n  get1\n       (setq a (or (peek-char nil f nil nil t)\n                   (zcrexec-error f \"READ\" \"No digits following #Z\")))\n       (when (eql a #\\SP)\n             (read-char f) ; Throw away the peeked character.\n             (go get1))\n  loop\n       (when (> count 8)\n             (zcrexec-error f \"READ\"\n                              \"Too many hex digits in #Z constant\"))\n       (setq count (1+ count))\n       (let ((weight (or (digit-char-p a 36) (go ret))))\n            (if (not (< weight 16))\n                (push (string a) err)\n                (setq z (+ weight (lsh z 4)))))\n  next\n       (read-char f) ; Throw away the peeked character.\n       (setq a (peek-char nil f nil #.eof t))\n       (if (eql a #.eof)\n           (go ret)\n           (go loop)\n       )\n  ret\n       (when err (zcrexec-error f \"READ\" \"Invalid hex digit(s)\"\n                                (nreverse err)))\n       (return z)\n )\n)\n\n;\n; #| comment ... |#\n;\n(defun zcrsharp-comment (f c n)\n (when n (zcrsharp-n-error f c n))\n (zcrsharp-comment-search f)\n)\n\n(defun zcrsharp-comment-search (f)\n (prog (k)\n  loop                            ; Search for other comment characters.\n       (setq k (read-char f nil #.eof t))\n  chk1 (cond                      ; See what we got.\n        ((eql k #.eof)              ; If end of file, terminate\n         (return (values)))         ; with nothing read.\n        ((eql k #\\|)                ; If we got |, we might have |#.\n         (setq k (read-char f nil #.eof t))  ; Get next character.\n         (or (eql k #\\#) (go chk1)) ; If not #, check as usual.\n         (return (values)))         ; If |# found, return to reader.\n        ((eql k #\\#)                ; If we got #, may be nested #|.\n         (setq k (read-char f nil #.eof t))  ; Get next character.\n         (or (eql k #\\|) (go chk1)) ; If not #|, keep checking.\n         (zcrsharp-comment-search f); Process nested comment group.\n         (go loop))                 ; and then keep going.\n        (t (go loop)))))\n\n;\n; #(foo bar baz)\n;\n(defun zcrsharp-vector (f c n)\n ; Get back the left parenthesis - we need it to read the list\n (unread-char c f)\n (cond\n  (n\n   (prog (z l i y)\n         (setq z (make-vector n))\n         (setq l (zcrexec-read f nil t nil t))\n         (setq i 0)\n         (setq y nil)\n    loop\n         (cond\n          ((eql i n)\n           (when l (warn \"Too many objects for #(, ignored\" l)) ; )\n           (return z))\n          ((null l)\n           (vset z i y))\n          ((atom l)\n           (zcrexec-error f \"READ\" \"Improper syntax for #(\" l))     ; )\n          (t\n           (setq y (zcar l))\n           (vset z i y)))\n         (setq l (cdr l))\n         (setq i (1+ i))\n         (go loop)))\n\n  (t\n   (zmvector (zcrexec-read f nil t nil t)))))\n\n;\n; #S(foo :bar 1 :baz frob)\n;\n(defun zcrsharp-struct (f c n)\n (when n (zcrsharp-n-error f c n))\n (unless (eql (peek-char nil f nil nil t) (lp))\n         (zcrexec-error f \"READ\" \"#S must be followed by (.\")) ; )\n (let ((list (zcrexec-read f nil t nil t)))\n       (unless (and list (symbolp (car list)))\n        (zcrexec-error f \"READ\" \"Invalid structure name in list\" list))\n       (unless (get (car list) 'defstruct-properties)\n        (zcrexec-error f \"READ\" \"Type not defined as structure\" list))\n       (eval `(,(or (get (car list) 'defstruct-constructor-macro)\n                    (zcrexec-error f \"READ\"\n                      \"No constructor defined for this structure type\"\n                           list))\n               . ,(do ((x (cdr list) (cddr x))\n                       (z nil)\n                      )\n                      ((null x) (nreverse z))\n                      (push (car x) z)\n                      (when (null (cdr x))\n                            (zcrexec-error f \"READ\"\n                  \"Odd number of arguments following type in #S syntax\"\n                                   list))\n                      (push `',(cadr x) z))))))\n\n;;;\n;;; Just a random repository of code that would be inserted into\n;;; ZRMSHARP if we wanted to make #\u00acfoo do something.\n;;;\n;;; We have NOT activated it.  #\u00ac exists only because of Macsyma,\n;;; and we don't want to cause any \"real\" EBCDIC characters to\n;;; start behaving like ASCII control characters.  So we let #\u00ac\n;;; generate an \"impossible\" character instead.\n;;;\n;;; (defvar control-fakeouts\n;;;  (let ((cflist (make-list 256)))\n;;;        ;\n;;;        ; Since it's not clear whether #\u00aca is supposed to be the\n;;;        ; same as #\u00acA or not, and #\u00ac is not even defined as part\n;;;        ; of CL, the lower-case letters are left undefined.\n;;;        ;\n;;;        (setf (nth #\\@  cflist) #X00) ; NUL\n;;;        (setf (nth #\\A  cflist) #X01) ; SOH\n;;;        (setf (nth #\\B  cflist) #X02) ; STX\n;;;        (setf (nth #\\C  cflist) #X03) ; ETX\n;;;        (setf (nth #\\D  cflist) #X37) ; EOT\n;;;        (setf (nth #\\E  cflist) #X2D) ; ENQ\n;;;        (setf (nth #\\F  cflist) #X2E) ; ACK\n;;;        (setf (nth #\\G  cflist) #X2F) ; BEL\n;;;        (setf (nth #\\H  cflist) #X16) ; BS\n;;;        (setf (nth #\\I  cflist) #X05) ; HT\n;;;        (setf (nth #\\J  cflist) #X25) ; LF\n;;;        (setf (nth #\\K  cflist) #X0B) ; VT\n;;;        (setf (nth #\\L  cflist) #X0C) ; FF\n;;;        (setf (nth #\\M  cflist) #X0D) ; CR\n;;;        (setf (nth #\\N  cflist) #X0E) ; SO\n;;;        (setf (nth #\\O  cflist) #X0F) ; SI\n;;;        (setf (nth #\\P  cflist) #X10) ; DLE\n;;;        (setf (nth #\\Q  cflist) #X11) ; DC1\n;;;        (setf (nth #\\R  cflist) #X12) ; DC2\n;;;        (setf (nth #\\S  cflist) #X13) ; DC3\n;;;        (setf (nth #\\T  cflist) #X3C) ; DC4\n;;;        (setf (nth #\\U  cflist) #X3D) ; NAK\n;;;        (setf (nth #\\V  cflist) #X32) ; SYN\n;;;        (setf (nth #\\W  cflist) #X26) ; ETB\n;;;        (setf (nth #\\X  cflist) #X18) ; CAN\n;;;        (setf (nth #\\Y  cflist) #X19) ; EM\n;;;        (setf (nth #\\Z  cflist) #X3F) ; SUB\n;;;        (setf (nth #XAD cflist) #X27) ; ESC   (cntl-left-bracket)\n;;;        (setf (nth #\\\\  cflist) #X1C) ; {I}FS\n;;;        (setf (nth #XBD cflist) #X1D) ; {I}GS (cntl-right-bracket)\n;;;        (setf (nth #\\\u00ac  cflist) #X1E) ; {I}RS\n;;;        (setf (nth #\\_  cflist) #X1F) ; {I}US\n;;;        (setf (nth #\\`  cflist) #X40) ; SP\n;;;        (setf (nth #\\{  cflist) #\\; ) ; ;\n;;;        (setf (nth #\\|  cflist) #\\< ) ; <\n;;;        (setf (nth #\\}  cflist) #\\= ) ; =\n;;;        (setf (nth #\\~  cflist) #\\> ) ; >\n;;;        (setf (nth #X07 cflist) #\\? ) ; ?    (cntl-rubout)\n;;;        cflist\n;;;  ))\n;;;  (defun zcrsharp-control (f)\n;;;   (read-char f) ; Throw away the character following the #.\n;;;   (let ((c (character-representation f)))\n;;;        (or (nth c '#.control-fakeouts)\n;;;            (zcrexec-error f \"READ\"\n;;;                         \"Unknown ASCII control spec\"\n;;;                         (string c) (zcrread-hex c)))))\n\n(declare (special *zcrexec-stream-table*))\n\n(defun zcrexec-prepare-stream (stream for-reading-p)\n (when (symbolp stream)\n       (unless (boundp '*zcrexec-stream-table*)\n               (setq *zcrexec-stream-table* nil))\n       (let* ((fileid stream)\n              (p (assq fileid *zcrexec-stream-table*))\n             )\n             (cond\n              (p\n               (setq stream (cdr p)))\n              (t\n               (setq stream (make-stream\n                                 :identifier\n                                 (list 'file fileid (zildsni fileid))\n                                 :type 'file\n                                 :input-function\n                                 #'(lambda ()\n                                    (read-char fileid nil nil))))\n               (push (cons fileid stream) *zcrexec-stream-table*)))))\n (cond\n  (for-reading-p\n   (unless (stream-readvector stream)\n           (setf (stream-readvector stream) (make-readvector 256))\n           (zcrexec-insure-readtable)))\n  (t\n   (zcrexec-insure-readtable)))\n stream\n)\n\n(defun zcrexec-insure-readtable ()\n (unless (boundp '*readtable*)\n         (zcrexec-create-readtable)))\n\n(defun zcrexec-create-readtable ()\n\n (setq *zcrexec-readtable* (make-readtable :name 'default))\n (setf (readtable-character-macro-table *zcrexec-readtable*)\n       (make-vector 256 nil))\n (setf (readtable-dispatch-macro-table  *zcrexec-readtable*)\n       (make-vector 256 nil))\n (setq *zcrexec-preserving-whitespace-p* nil)\n (setq *read-suppress*                   nil)\n\n; ff. from page 336 of CLtL\n\n (let ((a (readtable-syntaxes *zcrexec-readtable*)))\n      (vset a #/linefeed  :whitespace)\n      (vset a #/newline   :whitespace)\n      (vset a #/page      :whitespace)\n      (vset a #/return    :whitespace)\n      (vset a #/space     :whitespace)\n      (vset a #/tab       :whitespace)\n      (vset a #/\\         :single-escape)\n      (vset a #/|         :multiple-escape)\n      (vset a #/#         :terminating-macro) ; :non-terminating-macro\n      (vset a #/(  #|)|#  :terminating-macro)\n      (vset a #/)  #|(|#  :terminating-macro)\n      (vset a #/;         :terminating-macro)\n      (vset a #/,         :terminating-macro)\n      (vset a #/`         :terminating-macro)\n      (vset a #/'         :terminating-macro)\n      (vset a #/\"         :terminating-macro)\n #+ZIL(vset a #x4A        :continuation-character) ; cent sign\n )\n\n ; ff. from page 340 of CLtL\n\n (let ((a (readtable-attributes *zcrexec-readtable*)))\n      (vset a #/!         :alphadigit)\n      (vset a #/\"         :alphadigit)\n      (vset a #/#         :alphadigit)\n      (vset a #/$         :alphadigit)\n      (vset a #/%         :alphadigit)\n      (vset a #/&         :alphadigit)\n      (vset a #/'         :alphadigit)\n      (vset a #/(  #|)|#  :alphadigit)\n      (vset a #/)  #|(|#  :alphadigit)\n      (vset a #/*         :alphadigit)\n      (vset a #/,         :alphadigit)\n      (vset a #/0         :alphadigit)\n      (vset a #/1         :alphadigit)\n      (vset a #/2         :alphadigit)\n      (vset a #/3         :alphadigit)\n      (vset a #/4         :alphadigit)\n      (vset a #/5         :alphadigit)\n      (vset a #/6         :alphadigit)\n      (vset a #/7         :alphadigit)\n      (vset a #/8         :alphadigit)\n      (vset a #/9         :alphadigit)\n      (vset a #/:         :alphadigit) ;(not 'package-marker)\n      (vset a #/;         :alphadigit)\n      (vset a #/<         :alphadigit)\n      (vset a #/=         :alphadigit)\n      (vset a #/>         :alphadigit)\n      (vset a #/?         :alphadigit)\n      (vset a #/@         :alphadigit)\n      (vset a #xad        :alphadigit)\n      (vset a #/\\         :alphadigit)\n      (vset a #xbd        :alphadigit)\n      (vset a #/\u00ac         :alphadigit)\n      (vset a #/_         :alphadigit)\n      (vset a #/`         :alphadigit)\n      (vset a #/{         :alphadigit)\n      (vset a #/|         :alphadigit)\n      (vset a #/}         :alphadigit)\n      (vset a #/~         :alphadigit)\n      (vset a #/+         :alphadigit)\n      (vset a #/-         :alphadigit)\n      (vset a #/.         :dot)\n      (vset a #//         :alphadigit) ;(not 'ratio)\n      (vset a #/a         :alphadigit)\n      (vset a #/b         :alphadigit)\n      (vset a #/c         :alphadigit)\n      (vset a #/d         :alphadigit)\n      (vset a #/e         :alphadigit)\n      (vset a #/f         :alphadigit)\n      (vset a #/g         :alphadigit)\n      (vset a #/h         :alphadigit)\n      (vset a #/i         :alphadigit)\n      (vset a #/j         :alphadigit)\n      (vset a #/k         :alphadigit)\n      (vset a #/l         :alphadigit)\n      (vset a #/m         :alphadigit)\n      (vset a #/n         :alphadigit)\n      (vset a #/o         :alphadigit)\n      (vset a #/p         :alphadigit)\n      (vset a #/q         :alphadigit)\n      (vset a #/r         :alphadigit)\n      (vset a #/s         :alphadigit)\n      (vset a #/t         :alphadigit)\n      (vset a #/u         :alphadigit)\n      (vset a #/v         :alphadigit)\n      (vset a #/w         :alphadigit)\n      (vset a #/x         :alphadigit)\n      (vset a #/y         :alphadigit)\n      (vset a #/z         :alphadigit)\n      (vset a #/A         :alphadigit)\n      (vset a #/B         :alphadigit)\n      (vset a #/C         :alphadigit)\n      (vset a #/D         :alphadigit)\n      (vset a #/E         :alphadigit)\n      (vset a #/F         :alphadigit)\n      (vset a #/G         :alphadigit)\n      (vset a #/H         :alphadigit)\n      (vset a #/I         :alphadigit)\n      (vset a #/J         :alphadigit)\n      (vset a #/K         :alphadigit)\n      (vset a #/L         :alphadigit)\n      (vset a #/M         :alphadigit)\n      (vset a #/N         :alphadigit)\n      (vset a #/O         :alphadigit)\n      (vset a #/P         :alphadigit)\n      (vset a #/Q         :alphadigit)\n      (vset a #/R         :alphadigit)\n      (vset a #/S         :alphadigit)\n      (vset a #/T         :alphadigit)\n      (vset a #/U         :alphadigit)\n      (vset a #/V         :alphadigit)\n      (vset a #/W         :alphadigit)\n      (vset a #/X         :alphadigit)\n      (vset a #/Y         :alphadigit)\n      (vset a #/Z         :alphadigit)\n\n #+ZIL(vset a #x4a        :alphadigit) ; not illegal\n\n )\n\n (let ((a (readtable-character-macro-table *zcrexec-readtable*)))\n      (vset a #/#         #'zcrread-\\#-macro)\n      (vset a (lp)        #'zcrread-\\(-macro)\n      (vset a (rp)        #'zcrread-\\)-macro)\n      (vset a #/;         #'zcrread-\\;-macro)\n      (vset a #/,         #'zcrread-\\,-macro)\n      (vset a #/`         #'zcrread-\\`-macro)\n      (vset a #/'         #'zcrread-\\'-macro)\n      (vset a #/\"         #'zcrread-\\\"-macro)\n )\n\n (let ((a (readtable-dispatch-macro-table *zcrexec-readtable*)))\n      (vset a #\\.                  #'zcrsharp-period)\n      (vset a (lp)                 #'zcrsharp-vector)\n      (vset a #\\+                  #'zcrsharp-plus)\n      (vset a #\\|                  #'zcrsharp-comment)\n      (vset a #\\\u00ac                  #'zcrsharp-control)\n      (vset a #\\-                  #'zcrsharp-minus)\n      (vset a #\\/                  #'zcrsharp-escape)\n      (vset a #\\,                  #'zcrsharp-comma)\n      (vset a #\\'                  #'zcrsharp-quote)\n      (vset a #\\B                  #'zcrsharp-binary)\n      (vset a #\\O                  #'zcrsharp-octal)\n      (vset a #\\R                  #'zcrsharp-radix-n)\n      (vset a #\\\\                  #'zcrsharp-escape)\n      (vset a #\\S                  #'zcrsharp-struct)\n      (vset a #\\X                  #'zcrsharp-hex)\n      (vset a #\\Z                  #'zcrsharp-hex370)\n )\n\n (setq *readtable*\n       (copy-readtable *zcrexec-readtable*\n         :syntaxes   (vcopy (readtable-syntaxes   *zcrexec-readtable*))\n         :attributes (vcopy (readtable-attributes *zcrexec-readtable*))\n         :character-macro-table\n          (vcopy (readtable-character-macro-table *zcrexec-readtable*))\n         :dispatch-macro-table\n          (vcopy (readtable-dispatch-macro-table *zcrexec-readtable*))\n       ))\n\n nil\n)\n\n(defun zcrexec-rdrmacro (stream misc eoferp eofval recurp)\n ; MISC   is the reader macro character (symbol, string or fixnum)\n ; EOFERP is the reader macro SUBR, or NIL\n (zcrexec-insure-readtable)\n (let ((cmtable      (readtable-character-macro-table *readtable*))\n       (syntaxes     (readtable-syntaxes   *readtable*))\n       (old-cmtable  (readtable-character-macro-table\n                                           *zcrexec-readtable*))\n       (old-syntaxes (readtable-syntaxes   *zcrexec-readtable*))\n       (character (cond\n                   ((characterp misc)\n                    misc)\n                   ((and (or (stringp misc) (symbolp misc))\n                         (eql (string-length misc) 1))\n                    (char misc 0))\n                   (t\n                    (zcrexec-error stream \"RDRMACRO\"\n                                   \"Invalid reader macro character\"\n                                   misc))))\n      )\n      (cond\n       ((null eoferp)\n        (vset cmtable  character nil)\n        (vset syntaxes character (vref old-syntaxes character))\n       )\n       (t\n        (vset cmtable  character\n              #'(lambda (s c &aux (*zcrexec-rmchar* (ebcdic c t)))\n                        (declare (special *zcrexec-rmchar*))\n                        (funcall eoferp s)))\n        (vset syntaxes character :terminating-macro)\n       )\n      )\n\n )\n nil\n)\n\n(defun zcrexec-rmmac    (stream misc eoferp eofval recurp)\n (zcrexec-insure-readtable)\n (let ((syntaxes   (readtable-syntaxes   *readtable*))\n       (attributes (readtable-attributes *readtable*))\n      )\n      (vset syntaxes    #//   :single-escape)\n      (vset syntaxes    #/\\   :constituent)\n )\n nil\n)\n\n(defun zcrexec-rmchar   (stream misc eoferp eofval recurp)\n (declare (special *zcrexec-rmchar*))\n *zcrexec-rmchar*\n)\n\n(defun zcrexec-error (stream fun message &optional (arg1 () arg1?)\n                                                   (arg2 () arg2?)\n                                                   (arg3 () arg3?))\n (cterpri)\n (princ \"Error detected for stream \")\n (princ (stream-identifier stream))\n (princ \":\")\n (terpri)\n (princ message)\n (when arg1? (princ \" - \") (prin1 arg1))\n (when arg2? (princ \" \")   (prin1 arg2))\n (when arg3? (princ \" \")   (prin1 arg3))\n (terpri)\n (zerror `(,fun \" failure\"))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCSDFSTR": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00\\x00\\x00\\x883o\\x00\\x89\\x15o\\x10U\\x00f\\x00\\n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1988-12-01T00:00:00", "modifydate": "1989-06-05T10:55:00", "lines": 102, "newlines": 10, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(eval-when ()\n #.(progn\n    ;\n    ; #.%%xxx   -  bits for input stream functions\n    ; #.%%%xxx  -  bits for output stream functions\n    ;\n    (defvar %%read      #b   00000000)\n    (defvar %%tyi       #b   00000001)\n    (defvar %%untyi     #b   00000010)\n    (defvar %%tyipeek   #b   00000011)\n    (defvar %%readch    #b   00000100)\n    (defvar %%peekch    #b   00000110)\n    (defvar %%eof       #b   00001000)\n    (defvar %%quit      #b   00101000)\n    (defvar %%newlinep  #b   00010000)\n    (defvar %%endread   #b   00110000)\n    (defvar %%readline  #b   01000000)\n    (defvar %%rminit    #b   10000000)\n    (defvar %%rdrmacro  #b   10000001)\n    (defvar %%rmmac     #b   10000010)\n    (defvar %%rmchar    #b   10000100)\n    (defvar %%charpos   #b  100000000)\n    (defvar %%read-delimited-list\n                        #b 1000000000)\n\n    (defvar %%%tyo      #b   00000000)\n    (defvar %%%princ    #b   00000001)\n    (defvar %%%prin1    #b   00000101)\n    (defvar %%%terpri   #b   00000010)\n    (defvar %%%cterpri  #b   00001010)\n    (defvar %%%charpos  #b   00010000)\n    (defvar %%%clrscrn  #b   00101010)\n\n    (defvar eof -1)\n    (defvar eol #\\cr)\n))\n\n(defmacro lp () #| |# #\\( #|)|# )\n(defmacro rp () #|(|# #\\) #| |# )\n\n(defargs zcpexec 3 3 nil)\n(defargs zcrexec 6 6 nil)\n\n(declare (special *zcrexec-readtable*\n                  *zcrexec-preserving-whitespace-p*\n                  *read-suppress*\n                  *readtable*\n         ))\n\n;\n; This defines the structure of the STREAM data type.\n;\n\n(defstruct stream\n           identifier         ; Something to call the stream by.\n           type               ; Type of stream.\n           input-function     ; Function called to get a character.\n           output-function    ; Function called to put a character.\n           readvector         ; Used by READ to build objects in.\n           (charpos    0)     ; Character position.\n           last-char          ; Used by TYI and UNTYI.\n           unread-char        ; Used by TYI and UNTYI.\n           eofp               ; End-of-file indicator.\n           princ-function     ; Function called to PRINC a string.\n)\n\n(defstruct (readvector\n            (:constructor\n              make-readvector\n               (length &aux (characters (make-vector length))\n                            (syntaxes   (make-vector length))\n                            (attributes (make-vector length))))\n           )\n           (length)\n           (index 0)\n           (characters)\n           (syntaxes)\n           (attributes)\n)\n\n(defstruct (readtable)\n           (name)\n           (syntaxes   (make-vector 256 :constituent))\n           (attributes (make-vector 256 :illegal    ))\n           (character-macro-table)\n           (dispatch-macro-table)\n)\n\n(defmacro syntax-of (c)\n `(vref (readtable-syntaxes *readtable*) ,c))\n\n(defmacro attribute-of (c)\n `(vref (readtable-attributes *readtable*) ,c))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCSRDL": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x884/\\x00\\x89\\x15o\\x10U\\x00\\x13\\x00\\x10\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-12-07T00:00:00", "modifydate": "1989-06-05T10:55:00", "lines": 19, "newlines": 16, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; READ-DELIMITED-LIST\n;\n\n(include #.(zil-source-member zcsdfstr)) ; Stream structures.\n\n(defload read-delimited-list zcsrdl)\n\n(defun read-delimited-list (char &optional stream recurp &aux savesyn)\n (zcrexec stream #.%%read-delimited-list char t nil recurp))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCSRFS": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x883\\x9f\\x00\\x89\\x15o\\x10V\\x000\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1988-12-04T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 48, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; READ-FROM-STRING\n;\n\n(include #.(zil-source-member zcsdfstr)) ; Stream structures.\n\n(defload read-from-string zcsrfs)\n\n(defun read-from-string (string &optional eoferp eofval\n                                &key (start 0)\n                                     (end (string-length string))\n                                     (preserve-whitespace nil)\n                        )\n (let ((local-charpos start)\n       (stream (make-stream :identifier string :type 'string))\n      )\n      (setf (stream-input-function stream)\n            #'(lambda (&aux char)\n                      (cond\n                       ((>= local-charpos end)\n                        (setq char nil))\n                       (t\n                        (setq char (char string local-charpos))\n                        (incf local-charpos)))\n                       char))\n      (values\n       ;\n       ; (read stream eoferp eofval t)\n       ; or\n       ; (read-preserving-whitespace stream eoferp eofval t)\n       ;\n       (zcrexec stream #.%%read preserve-whitespace eoferp eofval t)\n       ;\n       ; (+ start (charpos stream))\n       ;\n       (+ start (zcrexec stream #.%%charpos nil nil nil nil))\n      )\n )\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZERROR": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x89\\x13_\\x00\\x89\\x15o\\x10V\\x00(\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-05-15T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 40, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; ZERROR\n;;;\n;;; This is the original ZIL \"ERROR\" function, renamed ZERROR so as\n;;; not to conflict with Common Lisp ERROR.\n;;;\n;;; The first arg is assumed to be a message, and is therefore PRINC'd.\n;;; The second arg is assumed to be a random value, and is therefore\n;;; PRIN1'd.\n;;; The &rest arg is assumed to be a list of random values, and is\n;;; therefore PRIN1'd.\n;;;\n;;; Enhancement:  If the first arg is a list, all the elements in the\n;;;               list are printed in succession.\n;;;\n\n(defun zerror (&optional (a nil a?) (b nil b?) &rest c)\n (when a?\n       (when (< (msglevel) 3)\n             (cterpri)\n             (princ \"Error: \")\n             (if (atom a)\n                 (princ a)\n                 (dolist (i a) (princ i)))\n             (when b?\n                   (princ \" - \")\n                   (prin1 b))\n             (dolist (i c) (princ \" \") (prin1 i))\n             (terpri)))\n (throw nil nil)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVAUTO": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10V\\x00\\x8c\\x00\\x81\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 140, "newlines": 129, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZEVAUTO\n;\n; This function resolves a symbol being used as a function name\n; when it currently has no function property.  Resolution is based\n; on the value of the AUTOLOAD property, as follows:\n;\n;   If the AUTOLOAD property is a string, then it is the name of a\n;   data set (file) to be loaded.\n;\n;   If the AUTOLOAD property is a non-null list, then it is a form\n;   to be evaluated.\n;\n; In both of the above cases, it is presumed that the file or form,\n; when loaded or evaluated, will cause the function name in question\n; to become defined.\n;\n;   If the AUTOLOAD property is a symbol, then an attempt is made to\n;   load the compiled function definition from the system ZIL library.\n;   The name under which the function is searched for is the value of\n;   the AUTOLOAD property if non-NIL, or the function symbol itself if\n;   the value of the AUTOLOAD property is NIL.\n;\n; To prevent infinite looping in the evaluator, this function removes\n; the AUTOLOAD property from the function name if it is a string or\n; a list.  If it is a symbol, the AUTOLOAD property is retained;\n; however, if the attempt to load the compiled function fails, either\n; NIL is returned from this function or an \"undefined function\" error\n; is signalled, depending upon the value of the optional second arg.\n;\n; The removal of the AUTOLOAD property is skipped if an error occurs\n; processing the AUTOLOAD property.\n;\n; NOTE: If a form is the value of the AUTOLOAD property, it is\n;       evaluated in the default environment, NOT in the environment\n;       active at the time of execution.\n;\n; NOTE: Currently it is expected that ZILLOAD will return a SUBR.\n;       Support for FSUBR's and MSUBRS's has always been in the works\n;       but has not yet been implemented.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* 12/08/86 - Changed to set a flag while autoloading so that if       *\n;*            FBOUNDP is issued on the function while it is being      *\n;*            loaded, the autoload process will return NIL instead     *\n;*            of doing a recursive autoload.                           *\n;*                                                                     *\n;***********************************************************************\n;*                                                                     *\n;* 01/07/87 - Changed to set a flag after an unsuccessful search of    *\n;*            the ZIL load module library so that more than one        *\n;*            library search doesn't take place.                       *\n;*                                                                     *\n;* Note that the autoload property is removed during autoloading       *\n;* (except when the autoload property is a symbol) and restored        *\n;* afterwards (in case, say, an attention interrupt occurred during    *\n;* the loading of a file).  If the autoload process went to completion *\n;* the autoload property is removed anyhow.                            *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (compile load eval)\n (defmacro no-autoload-p (f) `(get ,f 'zil-no-autoload))\n)\n\n;;;\n;;; Note: The technique above has one minor drawback:\n;;;       Putting a property on a symbol's property list can have\n;;;       the effect of making the LISP system think that the symbol\n;;;       is not \"worthless\".  This means that functions like\n;;;       APROPOS and GCTWA, depending on their implementation, may\n;;;       undesirably treat these symbols as meaningful, when in\n;;;       fact the ZIL-NO-AUTOLOAD property only reinforces the\n;;;       worthlessness of the symbol (if it doesn't have any other\n;;;       features, that is).\n;;;\n\n(defun zevauto (f &optional e)\n (prog (p s a)\n  (setq p (get f 'autoload))\n\n  (cond\n\n   ((symbolp p)                    ; NIL or symbol, load compiled code.\n\n    (cond                          ; Try to find a SUBR on the library.\n     ((no-autoload-p f)            ; If function not to be autoloaded\n      (go fail))                   ; then treat as undefined function\n     ((setq s (zilload (or p f)))  ; If found,\n      (return (putprop f s 'subr))); make it SUBR property of function\n     (t                            ; If not found,\n      (setf (no-autoload-p f) t)   ; then mark not found on lib\n      (go fail))))                 ; and it's an undefined function\n\n   ((stringp p)                    ; If string, file to be loaded.\n    (in-autoload-environment (load p))) ; Load autoload file.\n\n   ((consp p)                      ; If list, form to be evaluated.\n    (in-autoload-environment (eval p))) ; Evaluate form.\n\n   (t           (zerror \"Invalid AUTOLOAD property on function \" f p)))\n\n  (remprop f 'autoload)            ; Other than symbol, remove it.\n\n  (return t)                       ; Indicate autoload didn't fail.\n\n fail\n\n  (if e                               ; If function name is not found,\n      (zerror \"Undefined function\" f) ; then if an error is desired\n      (return nil)                    ; signal one, otherwise return.\n  )\n )\n)\n\n(defmacro in-autoload-environment (&body body)\n `(unwind-protect\n   (progn (setf (no-autoload-p f) t)  ; Suppress recursive\n          (remprop f 'autoload)       ; autoload attempts.\n          (setf a (special-alist))    ; Save dynamic SPECIALs.\n          (setf (special-alist) nil)  ; Suppress dynamic SPECIALs.\n          ,@body                      ; Execute autoload body\n   )\n   (progn\n          (setf (special-alist) a)    ; Restore dynamic SPECIALs.\n          (setf (no-autoload-p f) nil); Restore autoload\n          (setf (get f 'autoload) p)  ; capability.\n   )\n  ))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVDEFLD": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10V\\x00-\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 45, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZEVDEFLD\"\n;;;\n;;; This function processes run-time DEFLOAD.\n;;;\n;;; It assumes the following definition:\n;;;\n;;;  (DEFUN DEFLOAD FEXPR (X) (ZEVDEFLD X))\n;;;\n;;; It also resets the \"no-autoload\" flag set by ZEVAUTO.\n;;;\n\n(defun zevdefld (x toplevelp)\n (cond\n  ((not toplevelp)              (zerror \"Not at top level\" 'defload))\n  ((or (null x) (null (cdr x))) (zerror \"Too few arguments\" 'defload))\n  ((cddr x)                     (zerror \"Too many arguments\" 'defload))\n  (t\n   (let ((arg1 (zcar x))\n         (arg2 (zcadr x)))\n    (unless (symbolp arg1)\n            (zerror \"Argument 1 to DEFLOAD not a symbol\" arg1))\n    (unless (symbolp arg2)\n            (zerror \"Argument 2 to DEFLOAD not a symbol\" arg2))\n  ;\n  ; When DEFLOADing, delete all function definitions.\n  ; If an initial DEFLOAD, it's easy to skip REMPROP's when no PLIST.\n  ;\n    (when (not (null (symbol-plist arg1)))\n          (remprop arg1 'macro)\n          (remprop arg1 'expr)\n          (remprop arg1 'fexpr)\n          (remprop arg1 'subr)\n          (remprop arg1 'zil-no-autoload))\n    (putprop arg1 arg2 'autoload)\n  ;;; returns arg2, as per PUTPROP.\n   ))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVDEFUN": {"ttr": 6412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10V\\x00}\\x00s\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 125, "newlines": 115, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; ZEVDEFUN - DEFUN function definer\n;\n; This function is invoked by EVAL to process the DEFUN special form.\n; Parameter is the list of operands.  E.G.:\n;\n; (DEFUN FOO (X) (PRINT X) (CONS X NIL))\n;\n; results in ZEVDEFUN being invoked with an argument of the list:\n;\n; (FOO (X) (PRINT X) (CONS X NIL))\n;\n\n(defload car zcar)\n\n(declare (special *loadfile*))\n\n(defun zevdefun (r toplevelp)\n (unless toplevelp\n         (zerror \"Not at top level\" 'defun))\n (prog (f            ; Function name - non-NIL symbol or (name type).\n        e            ; Expression following function name.\n        a            ; Argument list.\n        b            ; Function body.\n        z            ; Temp to hold body while we figure out what to do.\n       )\n  (or r (go error))\n  (or (cdr r) (go error))\n  (desetq (f e . z) r)\n  (or f (zerror \"NIL is an illegal function name\"))\n  (if    (and (symbolp f) (memq e '(expr fexpr macro)))\n   then\n         (or z (go error))\n         (desetq (a . b) z) ; Argument list and function body.\n   else\n         (setq a e         ; Argument list.\n               b z         ; Function body.\n               e 'expr)    ; Default function type.\n   endif\n  )\n  (or b (zerror \"Missing DEFUN function body\" f))\n  ;;\n  ;; Check function type and verify argument list if required,\n  ;; then delete conflicting function types.\n  ;;\n  ;; If an FEXPR with one argument was specified, then give it\n  ;; a second arg of NIL.  This is OK because binding NIL to\n  ;; something has no effect, NIL being handled specially by the\n  ;; evaluator.  I like this better than GENSYM because it\n  ;; preserves predictable behavior of GENSYM in the interpreter.\n  ;;\n  (cond\n   ((consp f)             ; (defun (foo bar) ... )\n    (or  (cdr f)   (zerror \"Invalid function name\" f))\n    (and (cddr f)  (zerror \"Invalid function name\" f))\n    (setq e (cadr f)      ; Property to be assigned\n          f (car f))      ; The actual function name\n    (go skip-loadfile)    ; Don't record LOADFILE.\n   )\n   ((not (symbolp f))     ; If not a list, must be a symbol.\n    (zerror \"Invalid function name\" f))\n   ;\n   ; Otherwise check standard types...\n   ;\n   ((eq e 'expr)          ; EXPR: Arg list is used as is.\n    (remprop f 'macro)    ;       Delete MACRO def if any.\n    (remprop f 'subr)     ;       Delete SUBR def if any.\n   )\n   ((eq e 'fexpr)         ; FEXPR: Must be 2 arguments.\n    (if  (atom a)         ;        Null argument list is invalid.\n     then\n         (zerror \"Invalid argument list for FEXPR\" a)\n     else\n     if  (null (cdr a))   ;        If 1 argument, make 2-arg list.\n     then\n         (setq a (list (car a) nil))\n     else\n     if  (or (atom (cdr a)) ;      More than 2 arguments invalid\n             (cddr a))\n     then\n         (zerror \"Invalid argument list for FEXPR\" a)\n     endif                ;        If 2 arguments, leave as is.\n    )\n    (remprop f 'macro)    ;       Delete MACRO def if any.\n    (remprop f 'expr)     ;       Delete EXPR def if any.\n    (remprop f 'subr)     ;       Delete SUBR def if any.\n   )\n   ((eq e 'macro)         ; MACRO: It is erroneous if...\n    (if                             ;  a null or atomic arglist, or\n         (or (atom a)               ;  first arg is non-NIL and there's\n             (and (car a) (cdr a))) ;  more than 1 argument,\n     then                           ;  but OK if 1st arg is NIL.\n         (zerror \"Invalid argument list for MACRO\" a)\n     endif                ;        Otherwise, leave as is.\n    )\n    (remprop f 'subr)     ;       Delete SUBR def if any.\n   )\n   (t (zerror \"Unknown DEFUN function type\" e))\n  )\n  ;\n  ; Record where the function came from.\n  ;\n  (if *loadfile*\n      (putprop f *loadfile* 'loadfile)\n      (remprop f 'loadfile))\n\n skip-loadfile\n\n  ;\n  ; Store the function definition.  We do this last to insure that\n  ; the function property ends up at the beginning of the PLIST.\n  ;\n  (putprop f `(lambda ,a . ,b) e)\n  (return f)\n error\n  (zerror \"Too few arguments - DEFUN\")\n )\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVDSUB": {"ttr": 6414, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10V\\x00%\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 37, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This function is generated by DEFMODULE; it assigns a SUBR property\n; to a function.  Syntax is:\n;\n; (ZEVDSUB 'functionsymbol 'subrobject)\n;\n; Compiled \"module\" code passes a SUBR to this, providing for\n; dynamic scoping (at least with respect to fluid variables).\n; If lexical scoping is desired instead, then compiling of \"modules\"\n; should pass a compiled lexical closure to this function instead.\n;\n\n(declare (special *loadfile*))\n\n(defun zevdsub (f s)\n (when (symbol-plist f)\n       (remprop f 'macro)\n       (remprop f 'expr )\n       (remprop f 'fexpr)\n;;;;;;;(remprop f 'fsubr)    ;  No!\n       (remprop f 'loadfile)\n )\n\n (when *loadfile*\n       (putprop f *loadfile* 'loadfile))\n\n (putprop f s 'subr)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVDVAR": {"ttr": 6416, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10V\\x007\\x00[\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 55, "newlines": 91, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZEVDVAR\"\n;;;\n;;; This function processes run-time DEFVAR.\n;;;\n;;; The syntax of DEFVAR is:\n;;;\n;;;  (DEFVAR variable &optional value documentation)\n;;;\n;\n; Processing:\n;\n;    See ZEVXVAR for description.\n;\n; Since ZEVDVAR is used only by interpretive DEFVAR, and\n; compiled DEFVAR used ZEVXVAR, ZEVDVAR merely calls ZEVXVAR,\n; passing it a dynamically constructed LAMBDA expression as an\n; initialization \"thunk\".  Since there should be a null lexical\n; environment associated with the \"thunk\", it can be passed as\n; a raw LAMBDA expression - no need to use FUNCTION to make a\n; closure out of it.\n;\n\n\n(defmacro d-var () `(zcar x))\n(defmacro d-val () `(zcadr x))\n(defmacro d-doc () `(zcaddr x))\n\n(defmacro d-var-p  () `x)\n(defmacro d-val-p  () `(cdr x))\n(defmacro d-doc-p  () `(cddr x))\n(defmacro d-junk-p () `(cdddr x))\n\n(defun zevdvar (x toplevelp)\n  (unless toplevelp (zerror \"Not at top level\" 'defvar))\n  (unless (d-var-p) (zerror \"Too few arguments\" 'defvar))\n  (cond\n   ((d-val-p)\n    (cond\n     ((d-doc-p)\n      (when (d-junk-p) (zerror \"Too many arguments\" `(defvar . ,x)))\n      (zevxvar (d-var) t `(lambda () ,(d-val)) (d-doc)))\n     (t\n      (zevxvar (d-var) t `(lambda () ,(d-val))))))\n   (t\n    (zevxvar (d-var)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVINIT": {"ttr": 6418, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01D\\x00C\\x00\\x87\\x05O\\x01\\x00&_\\tD\\x02U\\x01\\xeb\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.68", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "2000-09-21T09:44:43", "lines": 597, "newlines": 491, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; This function is run when the ZIL system starts up.\n; It sets up all the initial macro and function definitions needed\n; in a standard ZIL system.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/07/88 - DEFLOAD's for ASSOC and MEMBER removed to support the    *\n;*            full Common LISP implementations of ASSOC and MEMBER.    *\n;* 04/11/88 - Macro PUTDATA added.                                     *\n;* 06/01/88 - VALUES-LIST added.  EXPR's for LIST, etc. removed.       *\n;* 06/03/88 - INTEGER-LENGTH added.                                    *\n;* 06/06/88 - New special forms added:                                 *\n;*            BLOCK, RETURN-FROM, TAGBODY, MULTIPLE-VALUE-LIST,        *\n;*                                  THROW, MULTIPLE-VALUE-BIND.        *\n;* 06/17/88 - Miscellaneous additions to feature list, fixup of        *\n;*            ADJOIN and PUSHNEW macros.                               *\n;* 06/22/88 - Removed special forms PROG and RETURN;                   *\n;*            added macros PROG, PROG*, RETURN.                        *\n;* 11/01/88 - Added STRING-TRANSLATE (XLATE), AT and OFF.              *\n;* 12/14/88 - Added READ-FROM-STRING, READ-DELIMITED-LIST, CHARACTERP. *\n;*                                                                     *\n;***********************************************************************\n;\n   ;;\n   ;; Steps in adding a new special form:\n   ;;\n   ;; (1) Add it to the list in ZEVINIT.\n   ;; (2) Add it to ZILEVAL.\n   ;; (3) Add it to FEXPAND.\n   ;; (4) Add it to ZILCOTRN.\n   ;; (5) Add it to ZILCOINT.\n   ;; (6) Figure out how to compile it.\n   ;;\n;\n; Note - the names of function arguments, etc., are deliberately\n;        constrained to reduce oblist size.\n;\n\n(eval-when (compile)\n #.(defvar special-form-list\n   '(quote cond and or progn setq go\n     ;;; PROG and RETURN are macros now, not special forms....\n     defun defload defvar catch throw unwind-protect\n     function arg setarg listify eval-when subr declare\n     block return-from tagbody multiple-value-list multiple-value-bind)\n   \"The special forms that must be known to ZILEVAL.\"\n   )\n)\n\n(eval-when (compile eval)\n (defmacro def-comma-error (char)\n  `(xdefun ,char macro (x)\n    (zerror \"Syntax error: comma not inside backquoted list structure\"\n           x)\n   )))\n\n; This read-time function builds default ZIL library names based on\n; the dsname of what is currently being compiled.  Note that this\n; has to default to something else if ZEVINIT is loaded interpretively.\n\n(eval-when ()\n #.(defun libname (qual)\n    (let\n     ((z\n      (if (not (ifilep 'src))\n       (string-append \"PROGLIB.ZIL.\" qual)\n       (let*\n        ((srcname (zildsni 'src))\n         (srcdsn (string-substr srcname\n                                1\n                                (1- (or (string-index srcname \"(\"\n                                        ; not \")\"\n                                        )\n                                        (zerror\n                                  \"Source for ZEVINIT not a PDS member\"\n                                              srcname)))))\n         (srclast5 (string-substr srcdsn -5))\n         (srcbutl5 (string-substr srcdsn 1 (- (string-length srcdsn) 5)))\n        )\n        (cond\n         ((eql srclast5 \".LISP\")\n          (string-append srcbutl5 \".\" qual))\n         ((eql srclast5 \"NLISP\")\n          (string-append srcbutl5 \"N\" qual))\n         ((eql srclast5 \"OLISP\")\n          (string-append srcbutl5 \"O\" qual))\n         (t\n          (zerror \"Bad source for ZEVINIT\" srcname)))))))\n     (format t \"~&...Generating source name of ~S~%\" z)\n     z))\n)\n\n;\n; Fast global-variable-initializing hack.\n;\n\n(defmacro ydefvar (var val)\n          `(setpbind ',var (cons ',var ,val)))\n\n(defun zevinit ()\n\n ;\n ; Define globally special variables.\n ;\n\n (ydefvar *version*  \"1.3\")\n (ydefvar *features* (list    ; Must be consed - users may add features.\n                      'ZIL     ; Of course.\n                      'ZIL13   ; Set 1.3 feature.\n            #+CSDL    'CSDL    ; Charles Stark Draper Laboratory.\n            #+DRAPER  'DRAPER  ; Ditto.\n                      'TSO     ; TSO command execution feature.\n                      'MVS     ; Operating system.\n                      'XA      ; Extended architecture.\n                      'VF      ; Vector facility.\n                      'GC      ; Garbage collector.\n                      'BIGNUM  ; Arbitrary-precision integers.\n                      'MULTIPLE-VALUES ; Multiple values.\n                      'DESTRUCTURING   ; Everywhere, not just DEFMACRO.\n                      'FLAVORS         ; Object-oriented system.\n                      'LOOP            ; LOOP macro (not 100% complete).\n                     ))\n (ydefvar *load-verbose*       t   ) ; ZIL likes to load verbosely.\n (ydefvar *trace*              nil ) ; Used by TRACE.\n (ydefvar *trace-indent*       0   ) ; Used by TRACE.\n (ydefvar *gentemp-counter*    0   ) ; Used by GENTEMP.\n (ydefvar *mxsetf-initialized* nil ) ; Used by SETF.\n (ydefvar *loadfile*           nil ) ; What file a function came from.\n\n (ydefvar *zil-source-library* #.(libname \"LISP\"))\n (ydefvar *zil-help-library*   #.(libname \"TEXT\"))\n (ydefvar *zil-panel-library*  #.(libname \"PANEL\"))\n\n ;\n ; Add others as time goes on.\n ;\n\n (loop for f in '#.special-form-list do\n          (setf (get f '|SPECIAL FORM|) t))\n\n ;\n ; XDEF's and straightforward macros...\n ;\n\n (xdefmacro xdefun    (&rest z)  `(zevdefun ',z t))\n (xdefmacro xdefload  (&rest z)  `(zevdefld ',z t))\n\n (xdefun xdefvar   macro (x)  (mxdefvar x))\n\n (xdefun defmacro  macro (x)  (mxdefmac x) )  ;  Generates DEFUN.\n (xdefun xdefmacro macro (x)  (mxdefmac x) )  ;  Generates XDEFUN.\n\n (xdefun defstruct macro (x)  (mxdefstr x) )\n\n (xdefun case      macro (x)  (mxcase   x) )\n (xdefun caseq     macro (x)  (mxcase   x) )\n (xdefun desetq    macro (x)  (mxdesetq x) )\n (xdefun do        macro (x)  (mxdo     x) )\n (xdefun do*       macro (x)  (mxdo     x) )\n (xdefun dolist    macro (x)  (mxdo     x) )\n (xdefun dotimes   macro (x)  (mxdo     x) )\n (xdefun if        macro (x)  (mxif     x) )\n (xdefun let       macro (x)  (mxlet    x) )\n (xdefun let*      macro (x)  (mxlet    x) )\n (xdefun list*     macro (x)  (mxlist   x) )\n (xdefun loop      macro (x)  (mxloop   x) )\n (xdefun pp        macro (x)  (mxpp     x) )\n (xdefun prog      macro (x)  (mxprog   x) )\n (xdefun prog*     macro (x)  (mxprog   x) )\n (xdefun prog1     macro (x)  (mxprog1  x) )\n (xdefun prog2     macro (x)  (mxprog2  x) )\n (xdefun psetq     macro (x)  (mxpsetq  x) )\n (xdefun return    macro (x)  (mxreturn x) )\n (xdefun setf      macro (x)  (mxsetf   x) )\n (xdefun unless    macro (x)  (mxif     x) )\n (xdefun when      macro (x)  (mxif     x) )\n\n (xdefun multiple-value-call  macro (x) (mxmvcall x))\n (xdefun multiple-value-prog1 macro (x) (mxmvprg1 x))\n (xdefun multiple-value-setq  macro (x) (mxmvsetq x))\n\n (xdefmacro push     (a b)               (mxpush   a b))\n (xdefmacro pop      (a &optional b)     (mxpop    a b))\n (xdefmacro incf     (a &optional (b 1)) (mxincf   a b))\n (xdefmacro decf     (a &optional (b 1)) (mxdecf   a b))\n (xdefmacro ttab     (a &optional b)     (mxttab   a b))\n (xdefmacro xtab     (a &optional b)     (mxxtab   a b))\n\n (xdefmacro neq      (a b)         `(not (eq ,a ,b))        )\n\n (xdefmacro ok       (&rest z)     `(catch nil ,@z t)       )\n\n (xdefmacro progv          (a b &rest z)\n                           `(zilprogv ,a ,b #'(lambda () . ,z)))\n\n (xdefmacro with-open-file ((a b &rest c) . z)\n                           (mxwof a b c z))\n\n (xdefmacro princ-to-string (a) `(prints ,a nil))\n (xdefmacro prin1-to-string (a) `(prints ,a t  ))\n\n;\n; Arithmetic functions.\n;\n\n (xdefun +          (&rest x) (zmadd x))\n (xdefun plus       (&rest x) (zmadd x))\n (xdefun -          (&rest x) (zmsub x t))\n (xdefun difference (&rest x) (zmsub x nil))\n (xdefun *          (&rest x) (zmmul x))\n (xdefun times      (&rest x) (zmmul x))\n (xdefun /          (&rest x) (zmdiv x t))\n (xdefun quotient   (&rest x) (zmdiv x nil))\n (xdefun //         (&rest x) (zmrem x))\n (xdefun \\\\         (&rest x) (zmrem x))\n (xdefun remainder  (&rest x) (zmrem x))\n (xdefun gcd        (&rest x) (zmgcd x))\n (xdefun min        (&rest x) (zmmin x))\n (xdefun max        (&rest x) (zmmax x))\n\n;\n; Some autoloads for function names that don't meet IBM's exacting\n; standards (eccch).\n;\n\n (xdefload **                  expt    )\n (xdefload \u00ac                   expt    )\n (xdefload alpha-char-p        alphacp )\n (xdefload char-downcase       chardown)\n (xdefload char-upcase         charup  )\n (xdefload characterp          charp   )\n (xdefload copy-symbol         copysym )\n (xdefload copy-tree           copytree)\n (xdefload copysymbol          copysym )\n (xdefload current-date        curdate )\n (xdefload current-jdate       curjdate)\n (xdefload current-time        curtime )\n (xdefload digit-char-p        digitcp )\n (xdefload double-float-p      dfloatp )\n (xdefload fmakunbound         fmakunbo)\n (xdefload integer-length      zilintln)\n (xdefload intersection        intersec)\n (xdefload keywordify          kwdify  )\n (xdefload unkeywordify        unkwdify)\n (xdefload macroexpand         mexpand )\n (xdefload macroexpand-1       mexpand1)\n (xdefload make-atom           mkatom  )\n (xdefload make-bignum         mkbignum)\n (xdefload make-fixnum         mkfixnum)\n (xdefload make-flonum         mkflonum)\n (xdefload make-funarg         mkfunarg)\n (xdefload make-list           mklist  )\n (xdefload make-number         mknumber)\n (xdefload make-struct         mkstruct)\n (xdefload make-vector         mkvector)\n (xdefload makunbound          makunbou)\n (xdefload parse-body          parsbody)\n (xdefload pretty-print        pprint  )\n (xdefload probe-file          probef  )\n (xdefload read-delimited-list zcsrdl  )\n (xdefload read-eval-print     intrpret)\n (xdefload read-from-string    zcsrfs  )\n (xdefload remove-duplicates   remdupql) ; (    ... :TEST #'EQL)\n (xdefload revappend           revappen)\n (xdefload reversall           reversal)\n (xdefload set-feature         setfeat )\n (xdefload set-nofeature       setnfeat)\n (xdefload setsyntax           setsynta)\n (xdefload single-float-p      sfloatp )\n (xdefload special-alist       salist  )\n (xdefload string-append       sappend )\n (xdefload string-appendl      sappendl)\n (xdefload string-capitalize   scapital)\n (xdefload string-downcase     downcase)\n (xdefload string-index        index   )\n (xdefload string-left-trim    sltrim  )\n (xdefload string-length       slength )\n (xdefload string-remove       sremove )\n (xdefload string-reverse      sreverse)\n (xdefload string-right-trim   srtrim  )\n (xdefload string-scan         sscan   )\n (xdefload string-substr       substr  )\n (xdefload string-translate    xlate   )\n (xdefload string-trim         strim   )\n (xdefload string-upcase       upcase  )\n (xdefload string-verify       verify  )\n (xdefload structure           structur)\n (xdefload substqual           substqua)\n (xdefload symbol-name         pname   )\n (xdefload symbol-plist        plist   )\n (xdefload symbolconc          concat  )\n (xdefload values-list         valuesl )\n (xdefload 1+                  add1    )\n (xdefload 1-                  sub1    )\n\n;\n; Compatibility hacks with \"stupider\" releases of ZIL.\n;\n\n (xdefload cputime            runtime )\n (xdefload fixp               integerp)  ; FIXP == (OR FIXNUMP BIGP)\n (xdefload lastcdr            last    )\n (xdefload vdim               vlength )\n\n;\n; The following are implemented to be compatible with Common LISP.\n; To be compatible with Maclisp or Franz LISP, you must use the\n; functions xxxQUAL instead.\n;\n\n (xdefload delete        delql   )  ; (DELETE ... :TEST #'EQL)\n (xdefload remove        remql   )  ; (REMOVE ... :TEST #'EQL)\n (xdefload subst         substql )  ; (REMOVE ... :TEST #'EQL)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; For Maclisp compatibility, use the following...\n;\n;(xdefload assoc         assqual )  ; (ASSOC  ... :TEST #'EQUAL)\n;(xdefload delete        delqual )  ; (DELETE ... :TEST #'EQUAL)\n;(xdefload member        memqual )  ; (MEMBER ... :TEST #'EQUAL)\n;(xdefload remove        remqual )  ; (REMOVE ... :TEST #'EQUAL)\n;(xdefload subst         substqua)  ; (REMOVE ... :TEST #'EQL)\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(xdefun comment   macro (x) ''comment)\n\n;\n; Reader macro support functions...\n;\n\n(xdefmacro |`| (x)\n (mxbq x)           ; Process the backquote.\n)\n\n(def-comma-error |,|  )\n(def-comma-error |,@| )\n(def-comma-error |,.| )\n\n; C---R functions.\n; These are defined as EXPR's to allow CAR/CDR checking to be in effect\n; as well as possible redefining of CAR/CDR as ZCAR/ZCDR.\n\n (xdefun caar     (x) (car (car x)))\n (xdefun cadr     (x) (car (cdr x)))\n (xdefun cdar     (x) (cdr (car x)))\n (xdefun cddr     (x) (cdr (cdr x)))\n (xdefun caaar    (x) (car (car (car x))))\n (xdefun caadr    (x) (car (car (cdr x))))\n (xdefun cadar    (x) (car (cdr (car x))))\n (xdefun caddr    (x) (car (cdr (cdr x))))\n (xdefun cdaar    (x) (cdr (car (car x))))\n (xdefun cdadr    (x) (cdr (car (cdr x))))\n (xdefun cddar    (x) (cdr (cdr (car x))))\n (xdefun cdddr    (x) (cdr (cdr (cdr x))))\n\n (xdefun caaaar   (x) (car (car (car (car x)))))\n (xdefun caaadr   (x) (car (car (car (cdr x)))))\n (xdefun caadar   (x) (car (car (cdr (car x)))))\n (xdefun caaddr   (x) (car (car (cdr (cdr x)))))\n (xdefun cadaar   (x) (car (cdr (car (car x)))))\n (xdefun cadadr   (x) (car (cdr (car (cdr x)))))\n (xdefun caddar   (x) (car (cdr (cdr (car x)))))\n (xdefun cadddr   (x) (car (cdr (cdr (cdr x)))))\n\n (xdefun cdaaar   (x) (cdr (car (car (car x)))))\n (xdefun cdaadr   (x) (cdr (car (car (cdr x)))))\n (xdefun cdadar   (x) (cdr (car (cdr (car x)))))\n (xdefun cdaddr   (x) (cdr (car (cdr (cdr x)))))\n (xdefun cddaar   (x) (cdr (cdr (car (car x)))))\n (xdefun cddadr   (x) (cdr (cdr (car (cdr x)))))\n (xdefun cdddar   (x) (cdr (cdr (cdr (car x)))))\n (xdefun cddddr   (x) (cdr (cdr (cdr (cdr x)))))\n\n (xdefun zcadr     (x) (zcar (cdr x)))\n (xdefun zcaddr    (x) (zcar (cdr (cdr x))))\n (xdefun zcadddr   (x) (zcar (cdr (cdr (cdr x)))))\n\n;\n; Following unnecessary, retained for compatibility only...\n;\n\n (xdefun zcddr     (x) (cdr (cdr x)))\n (xdefun zcdddr    (x) (cdr (cdr (cdr x))))\n\n;;;\n;;; These are now compiled - no need to define them as EXPR's.\n;;;\n;;;(xdefun list      (&rest z) z)\n;;;(xdefun vector    (&rest z) (zmvector z))\n;;;(xdefun bignum    (&rest z) (mkbignum z))\n;;;(xdefun structure (&rest z) (zmstruct z))\n\n;\n; Arithmetic functions that take multiple arguments...\n;\n; Note: /= cannot be implemented like =, >, <, >=, <=.\n;\n; Those functions expand into a series of 2-operand tests connected\n; by AND.\n; But /= wouldn't work the same way as =, >, <, >=, <=.\n; Consider that (/= 1 2 1) should be NIL, but\n; (AND (/= 1 2) (/= 2 1)) would be T.  Need some other way to do it.\n\n (xdefmacro /=        (a b) `(not (zilequal ,a ,b)))\n (xdefmacro nlessp    (a b) `(not (lessp    ,a ,b)))\n (xdefmacro ngreaterp (a b) `(not (greaterp ,a ,b)))\n\n (xdefun =  (&rest x) (zmeq  x))\n (xdefun >  (&rest x) (zmgt  x))\n (xdefun <  (&rest x) (zmlt  x))\n (xdefun >= (&rest x) (zmnlt x))\n (xdefun <= (&rest x) (zmngt x))\n\n ;\n ; User-friendly productivity aids.\n ;\n\n (xdefmacro help     (&optional a b)  `(zilhelp ',a ,b))\n (xdefmacro news     (&optional b)    `(zilhelp '$news ,b))\n (xdefmacro trace    (&rest x)        `(ziltrace ',x 'trace))\n (xdefmacro untrace  (&rest x)        `(ziltrace ',x 'untrace))\n\n (xdefun    at       macro (x)  (mxatoff  x))\n (xdefun    off      macro (x)  (mxatoff  x))\n (xdefun    putdata  macro (x)  (mxputdat x))\n\n ;\n ; Support for compile-time stuff.\n ;\n ; Should we purge this?\n ;\n\n (xdefmacro % (&rest z) `(eval-when (compile) ,z))\n\n ;\n ; Other DEF's...\n ;\n\n (xdefmacro defprop   (a b c)             `(putprop ',a ',b ',c) )\n\n (xdefmacro defargs   (a b &optional c d) (mxdefarg a b c d)     )\n (xdefmacro defflic   (a b &optional c d) (mxdeffli a b c d)     )\n (xdefmacro defmodule (a b &optional c)   (mxdefmod a b c)       )\n\n (xdefmacro includef (file) (xinclude (eval file)))\n (xdefmacro include  (file) (xinclude file))\n\n ;\n ; FORTRAN interface...\n ;\n\n (xdefload acos     zifacos )\n (xdefload asin     zifasin )\n (xdefload atan     zifatan )\n (xdefload cos      zifcos  )\n (xdefload exp      zifexp  )\n;(xdefload log      ziflog  ) ;; Not any more, we have 2-argument LOG\n (xdefload sin      zifsin  )\n (xdefload sqrt     zifsqrt )\n (xdefload tan      ziftan  )\n\n ;\n ; Common LISP compatibility...\n ;\n\n (xdefmacro the (a b) b)\n\n (xdefmacro first   (x) `(car ,x))\n (xdefmacro rest    (x) `(cdr ,x))\n (xdefmacro second  (x) `(cadr ,x))\n (xdefmacro third   (x) `(caddr ,x))\n (xdefmacro fourth  (x) `(cadddr ,x))\n (xdefmacro fifth   (x) `(car (cddddr ,x)))\n (xdefmacro sixth   (x) `(cadr (cddddr ,x)))\n (xdefmacro seventh (x) `(caddr (cddddr ,x)))\n (xdefmacro eighth  (x) `(cadddr (cddddr ,x)))\n\n\n ;\n ; Maclisp-compatible arrays...\n ;\n\n (mapc #'(lambda (x) (putprop x '(zlarray) 'autoload))\n       '(\n         arrayp\n         *array\n         array\n         store\n         arraycall\n         arraydims\n         fillarray\n         *rearray\n         zil-array\n        ))\n\n ;\n ; FLAVORS\n ;\n\n (mapc #'(lambda (x) (putprop x '(flavors) 'autoload))\n       '(\n         compile-flavor-methods\n         declare-flavor-instance-variables\n         defflavor\n         defmethod\n         defwrapper\n         describe\n         describe-flavor\n         funcall-self\n         get-handler-for\n         instantiate-flavor\n         make-instance\n         recompile-flavor\n         send\n         send-self\n         set-in-instance\n         symeval-in-instance\n        ))\n\n ;\n ; More Maclisp-compatible stuff...\n ;\n\n (xdefmacro *catch  (a . b) `(catch ,a . ,b))\n (xdefmacro *throw  (a b)   `(throw ,a ,b))\n (xdefmacro signp   (a b)   (mxsignp a b))\n\n (xdefun sassoc macro (x)   (mxsassoc x))\n (xdefun sassq  macro (x)   (mxsassoc x))\n\n ;\n ; Newer stuff ...\n ;\n\n (xdefmacro pushnew (a b &key ((:test c)) ((:key d)))\n            (mxpshnew a b c d))\n\n (xdefmacro adjoin  (a b &key ((:test c)) ((:key d)))\n            (mxadjoin a b c d))\n\n (xdefmacro locally (&body body)\n  `((lambda () . ,body)))\n\n (xdefun time macro (x) (mxtime x))\n\n ;\n ; This is the form used to define compiler transforms.\n ;\n ; (DEFTRANS FOO (FORM ENV CON) ....body...)\n ;\n ; -->\n ;\n ; (DEFUN (FOO COMPILER-TRANSFORM) (FORM ENV CON) ... body)\n ;\n ; or..\n ;\n ; (SETF (GET 'FOO 'COMPILER-TRANSFORM)\n ;       #'(LAMBDA (FORM ENV CON) ... body))\n ;\n ;\n ; Alternatively...\n ;\n ; (DEFTRANS FOO BAR)\n ;\n ; -->\n ;\n ; (SETF (GET 'FOO 'COMPILER-TRANSFORM) 'BAR)\n ;\n\n (xdefmacro deftrans (a b &rest c)\n  (mxdeftra a b c))\n\n (xdefmacro zil-source-member (member)\n  (string-append \"'\" *zil-source-library* \"(\" member \")'\"))\n\n ;\n ; The return value from ZEVINIT (for what it's worth)...\n ;\n\n nil\n\n)\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVLIST": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10V\\x00\\x1e\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:56:00", "lines": 30, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; ZEVLIST\n;;;\n;;; This routine is used by EVAL and APPLY.\n;;;\n;;; Argument 1 (required) - a list of unevaluated arguments.\n;;; Argument 2 (optional) - the evaluation environment.\n;;;\n\n(defun zevlist (l a)\n (when l\n  (prog (v w)\n        (setq v (ncons (zileval (zcar l) a nil)))\n        (unless (setq l (cdr l))\n                (return v))\n        (setq w v)\n   loop\n        (setq w (setf (cdr w)\n                      (ncons (zileval (zcar l) a nil))))\n        (unless (setq l (cdr l))\n                (return v))\n        (go loop))))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZEVMACS": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x00\\x00\\x87\\x12o\\x00\\x89\\x15o\\x10W\\x007\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1987-05-06T00:00:00", "modifydate": "1989-06-05T10:57:00", "lines": 55, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; Macro definitions used by the evaluator (ZILEVAL and ZILAPPLY).\n;\n; Note: These depend on the structure of the \"environment\" as\n;       defined by the MKNEWENV function.\n;\n; To change the structure of the environment, see comments in MKNEWENV.\n;\n;\n; To include...\n;\n; (include #.(zil-source-member zevmacs)) ; Include evaluator macros.\n;\n; Change activity:\n;\n; 06/01/88 - PROGTAG replaced by BLOCKTAG and TAGBODYTAG.  See ZILEVAL.\n;\n\n(eval-when (compile load eval)   ; ... must be available to SETF too...\n\n (defmacro bindenv (a) `(zcar ,a))         ; interpreter variables\n (defmacro progenv (a) `(zcar (cdr ,a)))   ; chain of PROG environments\n (defmacro argenv  (a) `(zcar (cddr ,a)))  ; chain of LEXPR environments\n (defmacro specenv (a) `(zcar (cdddr ,a))) ; pervasive SPECIAL variables\n (defmacro fletenv (a) `(zcar (cdr (cdddr ,a))))  ; FLET functions\n (defmacro mletenv (a) `(zcar (cddr (cdddr ,a)))) ; MACROLET macros\n\n (defmacro progbody   (p) ; the body of the current PROG\n  `(zcar ,p))\n (defmacro progrest   (p) ; the part of the body next to be executed\n  `(zcar (cdr ,p)))\n (defmacro progvalue  (p) ; the return value\n  `(zcar (cddr ,p)))\n (defmacro blocktag   (p) ; a tag that RETURN/RETURN-FROM will throw to\n  `(zcar (cdddr ,p)))\n (defmacro tagbodytag (p) ; a tag that GO will throw to\n  `(zcar (cddddr ,p)))\n\n (defmacro make-progenv ()\n  `(list nil nil nil nil nil))  ; Same length as progthings above!\n\n (defmacro specialp (var)  ;  Boy, will THIS ever change.\n   `(get ,var 'special)\n )\n\n)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVMAPP": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x10?\\x00\\x89\\x15o\\x10W\\x003\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-04-13T00:00:00", "modifydate": "1989-06-05T10:57:00", "lines": 51, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This function applies a macro definition.\n;;;\n;;; Syntax:\n;;;\n;;;  (zevmapp <macroexp> <formarg> <property>)\n;;;\n;;; where  <macroexp> is the value of the MACRO or CMACRO property\n;;;                   to be applied\n;;;\n;;;        <formarg>  is the entire form, which is the argument to\n;;;                   the macro expansion function <macroexp>\n;;;\n;;;        <property> is the macro property name - MACRO or CMACRO\n;;;\n\n;;\n;; <macroexp> must be (LAMBDA arglist ...)\n;; where...\n;;  If arglist is a cons whose CAR is NIL, then this is an extended\n;;   macro arglist generated by DEFMACRO.  Apply it accordingly.\n;;  Otherwise, this is a standard MACRO arglist.  Apply it the old way.\n;;\n;; (we'll have to chuck this hack for total CL eventually...)\n;;\n\n(defload car zcar)\n\n(defun zevmapp (m form prop)\n (cond\n  ((or (atom m) (atom (cdr m)))\n   (warn \"Invalid macro property found\" (car form) prop)\n   (zilapply m (list form) nil (car form)))\n  (t\n   (zilapply m\n             (if (or (atom (cadr m))    ; if (lambda x ...)\n                     (null (caadr m)))  ; or (lambda (nil ...) ...)\n                 form                   ; then apply like a defmacro\n                 (list form)            ; else (lambda (x) ...)\n             )                          ;      apply like a macro\n             nil\n             (car form)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVSET": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10W\\x00A\\x006\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:57:00", "lines": 65, "newlines": 54, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZEVSET\n;\n; This function takes 2 args - (1) a variable, (2) a value\n; - and\n; returns a binding cell holding the new value, i.e. a CONS whose\n; CAR is the variable and whose CDR is the value.\n;\n; Notes: Arg 1 must be a symbol - no error checking is done.\n;\n\n;;;\n;;; The current deep binding scheme implements fake value cells\n;;; (actually binding cells) for global variables.\n;;; This consists of a BINDING property on the property\n;;; list of the symbol.\n;;;\n;;; When we implement shallow binding, this function will probably\n;;; go away entirely.  Only the evaluator's implementation of SETQ\n;;; will do \"alist-searching\", and probably doesn't even call ZEVSET\n;;; to do the job anyhow for lexically scoped variables.\n;;;\n\n\n(eval-when (compile load eval)\n (defmacro specialp (var)\n  `(get ,var 'special)\n )\n)\n\n(defun zevset (var val &aux p)\n (if (setq p (assq var (special-alist)))\n  then\n     (rplacd p val)         ; If found on alist, bash the alist binding\n  else\n  if                        ; Else look for global binding \"cell\"\n     (neq (setq p (pbind var)) (zilunbnd))\n  then\n     (rplacd p val)         ; If found, bash it\n  else\n\n;;; The automatic proclaiming of a previously unbound variable as\n;;; SPECIAL when it is set is not done here.  Such is done only for\n;;; interpretive SETQ.  This is for consistency with VAX NIL and\n;;; other LISPs that run Macsyma, which is sensitive to the setting\n;;; of the SPECIAL property.\n\n;;;; (unless (specialp var)               ; No warn if declared special.\n;;;;  (warn \"Assigning value to assumed new SPECIAL variable\" var)\n;;;;  (setf (specialp var) t)\n;;;; )\n     (setpbind var (setq p (cons var val)))\n     p\n  endif\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVSYM": {"ttr": 6665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10W\\x00\\x8b\\x00t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:57:00", "lines": 139, "newlines": 116, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZEVSYM\n;\n; This is the function that underlies evaluation of symbols in\n; the interpreter, as well as SYMEVAL.\n; It attempts to locate the binding of a symbol, and returns that\n; binding in the form of a CONS cell, the CAR of which is that\n; symbol and the CDR of which is that value.\n;\n; If the variable has an AUTOVALUE property, we process it much like\n; the AUTOLOAD property of function names... if it is a string, the\n; file of that name is loaded; if it is a list, the list is evaluated\n; as a form.  The AUTOVALUE property cannot be a symbol.\n;\n; If there is no current binding of the symbol in question, NIL is\n; returned.  It is the responsibility of the caller to signal an\n; error if required in this case for an unbound variable.\n;\n; Note: If the CDR of the binding cell contains the \"unbound marker\",\n;       NIL is also returned, since the binding is valueless.\n;\n\n;\n; Argument 1 (required) - the symbol to be evaluated.\n;\n\n;;;\n;;; Notes:\n;;;\n;;; Arg 1 is expected to be a symbol other than T or NIL.\n;;;\n;;; Although argument 1 must be a symbol, no error check is done in\n;;; this function since it is expected primarily to be called by EVAL\n;;; and exists as a separate function to permit efficiency.  Use EVAL\n;;; if you're not sure whether something to be evaluated is a symbol.\n;;;\n;;; This code SHOULD NOT SETQ arg 1, since ZILVSYM may use arg 1 from\n;;; the stack to display an \"unbound variable\" error message.\n;;;\n\n;;;\n;;; The current deep binding scheme implements fake value cells\n;;; (actually binding cells) for global variables.  This consists of a\n;;; BINDING property on the property list of the symbol.\n;;;\n;;; When we implement shallow binding, this function will probably\n;;; go away entirely.  Only the evaluator's processing of symbols\n;;; will do \"alist-searching\", and probably doesn't even call ZEVSYM\n;;; to do the job anyhow for lexically scoped variables.\n;;;\n\n\n(eval-when (compile load eval)\n (defmacro specialp (var)\n  `(get ,var 'special)))\n\n;;; Actually, ZEVSYM doesn't check to see if a variable is SPECIALP.\n;;; Its caller (e.g. the evaluator) should do that to see if it\n;;; ought to call ZEVSYM in the first place.\n\n(defun zevsym (x &aux b)\n (cond\n  ((setq b (assq x (special-alist)))  ; If binding found on alist,\n   (if (eq (cdr b) (zilunbnd)) ; then if binding is valueless\n       nil                     ;      then return without a binding\n       b))                     ;      else return the binding\n  ((neq (setq b (pbind x)) (zilunbnd)) ; Else if there's global binding\n   (if (eq (cdr b) (zilunbnd)) ; then if binding is valueless\n       nil                     ;      then return without a binding\n       b))                     ;      else return the binding\n  ((zevsym-autoload x)     ; If an \"autoloading symbol\", then\n   (zevsym x))             ;  perform autoloading and retry.\n  (t nil)                  ; Otherwise variable is unbound.\n )\n)\n\n;\n; This subfunction resolves a symbol being used as a variable\n; when it currently has no value.  Resolution is based\n; on the value of the AUTOVALUE property, as follows:\n;\n;   If the AUTOVALUE property is a string, then it is the name of a\n;   data set (file) to be loaded.\n;\n;   If the AUTOVALUE property is a non-null list, then it is a form\n;   to be evaluated.\n;\n; In both of the above cases, it is presumed that the file or form,\n; when loaded or evaluated, will cause the variable name in question\n; to become defined.\n;\n; To prevent infinite looping in the evaluator, this function removes\n; the AUTOVALUE property from the variable name if it is a string or\n; a list.\n;\n; The removal of the AUTOVALUE property is skipped if an error occurs\n; processing the AUTOVALUE property.\n;\n; NOTE: If a form is the value of the AUTOVALUE property, it is\n;       evaluated in the default environment, NOT in the environment\n;       active at the time of execution.\n;\n; Code very similar to that in ZEVAUTO.\n;\n\n(defun zevsym-autoload (x)\n (prog (v s a)\n  (setq v (or (get x 'autovalue) (return nil)))\n  (cond\n   ((stringp v)                    ; If string, file to be loaded.\n    (in-autoload-environment (load v)))\n   ((consp v)                      ; If list, form to be evaluated.\n    (in-autoload-environment (eval v)))\n   (t           (zerror \"Invalid AUTOVALUE property on variable \" x)))\n\n  (remprop x 'autovalue)           ; Remove it.\n  (return t)\n )\n)\n\n(defmacro in-autoload-environment (&body body)\n `(unwind-protect\n   (progn\n          (setf a (special-alist))    ; Save dynamic SPECIALs.\n          (setf (special-alist) nil)  ; Suppress dynamic SPECIALs.\n          ,@body                      ; Execute autoload body\n   )\n   (progn\n          (setf (special-alist) a)    ; Restore dynamic SPECIALs.\n   )\n  ))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEVXVAR": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x10W\\x00\\x9f\\x00\\x7f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T10:57:00", "lines": 159, "newlines": 127, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZEVXVAR\"\n;;;\n;;; This function processes run-time DEFVAR.\n;;;\n;;; It receives 4 arguments: (1) the variable symbol (arg 1 to DEFVAR)\n;;;                          (2) either a constant initial value, or\n;;;                              a function of no arguments which can\n;;;                              be called to establish an initial value\n;;;                          (3) a boolean which specifies whether the\n;;;                              second argument is a constant or a\n;;;                              \"thunk\" (function of no arguments).\n;;;                          (4) the documentation string.\n;;;\n;;; The syntax of DEFVAR is:\n;;;\n;;;  (DEFVAR variable &optional value documentation)\n;;;\n;\n; Processing:\n;\n;  When (DEFVAR variable) is specified, with no value...\n;\n;              If the variable already has a SPECIAL binding,\n;              no action is taken.\n;\n;              Otherwise, the variable is proclaimed to be SPECIAL\n;              (whatever form that takes).\n;\n;              If the variable is not already SPECIALly bound,\n;              its binding cell is filled in with a binding, consisting\n;              of a CONS of the symbol with its new value.\n;\n;  When (DEFVAR variable value ...) is specified...\n;\n;              If the variable already has a SPECIAL binding,\n;              no action is taken.\n;\n;              Otherwise, the variable is proclaimed to be SPECIAL\n;              (whatever form that takes).\n;\n;              If the variable is not already SPECIALly bound,\n;              its binding cell is filled in with a binding, consisting\n;              of a CONS of the symbol with its new value.\n;\n;              If there is a documentation string, it is made the\n;              value of the variable's DOCUMENTATION property.\n;\n;              (The documentation is not added if the variable is\n;              already present in the environment.)\n;\n\n;;;\n;;; The current deep binding scheme implements fake value cells\n;;; (actually binding cells) for global variables.  This consists of a\n;;; BINDING property on the property list of the symbol.\n;;;\n;;; When shallow binding is implemented, processing will probably be\n;;; along these lines:\n;;;\n;;; (defvar var) ... only proclaims var to be special.\n;;;\n;;; (defvar var val) ... if var's value cell contains \"unbound\",\n;;;                      then store val into var's value cell,\n;;;                      else do nothing (except possibly for\n;;;                      issuing a warning).\n;;;\n;;; None of this (get '*defvar* 'defvar) nonsense will be done.\n;;;\n\n\n(eval-when (compile eval load)\n (defmacro specialp (var)\n  `(get ,var 'special))\n\n (defmacro documentation (var)\n  `(get ,var 'documentation))\n\n)\n\n(defun zevxvar (var &optional (thunkp nil thunkp?)\n                              (valfun nil valfun?)\n                              (doc nil doc?)\n                    &aux cell)\n  (when (or (not (symbolp var))    ; Must be a symbol\n            (eq (pbind var) var))  ; that doesn't self-evaluate\n        (zerror \"Invalid DEFVAR variable\" var))\n  (or (null doc?)\n      (stringp doc)\n      (zerror `(\"Invalid DEFVAR documentation string for \" ,var) doc))\n;\n; For shallow binding, we could just use BOUNDP, except that we don't\n; want BOUNDP to be autoloading in that case.  A good reason not to\n; let BOUNDP be autoloading (makes code generation simpler anyhow).\n; Otherwise, maybe we can have a non-autoloading BOUNDP especially\n; for this purpose?\n;\n; After all, autoload avoidance seems to be the main reason I didn't\n; just call ZEVSYM here.  But another reason is that if there is\n; already a \"valueless\" binding, I want to know that.\n;\n  (setq cell (or (assq var (special-alist))   ; Variable already bound\n                 (pbind var)))                ; (locally or globally)\n  (if (or (null cell) (eq cell (zilunbnd)))\n   then                               ; Not bound yet - assign it now.\n        ;\n        ; (proclaim `(special ,var))\n        ;\n        (setf (specialp var) t)\n\n        (setpbind var\n                  (cons var (if valfun?\n                                (if thunkp (funcall valfun) valfun)\n                                (zilunbnd))))\n\n        (when doc?\n              (setf (documentation var) doc))\n\n   else\n   if   (eq (cdr cell) (zilunbnd))  ; Assume that it's...\n   then                             ; Already DEFVAR'd without a value.\n\n        (when valfun?\n              (rplacd cell (if thunkp (funcall valfun) valfun)))\n\n        (when doc?\n              (setf (documentation var) doc))\n\n   else\n        (when (lessp (msglevel) 2)\n              (princ \"Warning: The variable \")\n              (prin1 var)\n              (princ \" already has a value of \")\n              ;\n              ; For shallow binding, (prin1 (symbol-value var))\n              ;\n              (prin1 (cdr cell))\n              (princ \".\")\n              (terpri)\n              (when valfun?\n                    (princ \"The new value \")\n                    (princ\n                     (if doc?\n                         \"and the documentation are ignored.\"\n                         \"is ignored.\"))\n                    (terpri)))\n   endif\n  )\n var\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZFMEXEC": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x88\\x05\\x7f\\x00\\x896?\\x16\\x16\\x07\\x1b\\x06@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1988-02-26T00:00:00", "modifydate": "1989-12-29T16:16:00", "lines": 1819, "newlines": 1600, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; Reference: Steele, pp. 385-407.\n\n;;;\n;;; The FORMAT executor, part of the new implementation of FORMAT.\n;;; This routine receives a FORMAT specification, output of the\n;;; ZFMPARS function (i.e. a parsed form of the FORMAT string),\n;;; and processes it, dispatching on the various directives.\n;;;\n\n(defstruct format\n  (dest             nil)\n  (stream           nil)\n  (spec             nil)\n  (subspec          nil)\n  (args             nil)\n  (subargs          nil)\n  (modifiers        nil)\n  (colon            nil)\n  (atsign           nil)\n  (suppress         nil)\n  (abort            nil)\n)\n\n(eval-when (compile load eval)\n (defmacro |:| (&optional (f 'f)) `(format-colon ,f))\n (defmacro |@| (&optional (f 'f)) `(format-atsign ,f))\n)\n\n(eval-when (compile) ; But will be READ in all cases.\n #.(defvar format-radix-string \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n #.(defvar format-char-reps\n           '(\n             (#X00 NULL   NULL     )\n             (#X05 HT     TAB      )\n             (#X07 DEL    RUBOUT   )\n             (#X0B VT     VT       )\n             (#X0D CR     RETURN   )\n             (#X15 NL     NEWLINE  )\n             (#X16 BS     BACKSPACE)\n             (#X25 LF     LINEFEED )\n             (#X2C FF     FORM     )\n             (#X40 SP     SPACE    )\n            ))\n #.(defvar format-non-alphabetics\n           (loop for i from 0 to 255\n                 unless (alpha-char-p i)\n                 collect i into z\n                 finally (return (tostring (implode z)))))\n)\n\n(defmacro nl () (string #\\nl))\n(defmacro cr () (string #\\cr))\n(defmacro ff () (string #\\ff))\n\n(defmacro format-call (char)\n `(,(concat \"FORMAT-%-\" char) f))\n\n(defmacro spec-char (x) `(car ,x))\n(defmacro spec-colon (x) `(cadr ,x))\n(defmacro spec-atsign (x) `(caddr ,x))\n(defmacro spec-modifiers (x) `(cadddr ,x))\n\n(eval-when (compile load eval)\n (defmacro format-stream-offset (f) `(car (format-stream ,f)))\n (defmacro format-stream-string (f) `(cdr (format-stream ,f)))\n)\n\n(defmacro stream-to-string (f)\n `(string-appendl (nreverse (format-stream-string ,f))))\n\n(defun zfmexec (dest spec args)\n (let ((f (make-format :dest     (if (stringp dest) nil dest)\n                       :stream   (cond\n                                  ((null dest)    (cons 0 nil))\n                                  ((stringp dest) (cons 0 (list dest)))\n                                  (t              nil))\n                       :spec     spec\n                       :subspec  spec\n                       :args     args\n                       :subargs  args)))\n      (zfmexec1 f)\n\n;;;;;; CL says it is \"not an error\" to have leftover args.\n;;;;;; (when (format-subargs f)\n;;;;;;  (warn \"Leftover FORMAT args\" (format-string f) (format-args f)))\n\n      (format-return f)))\n\n(defun zfmexec1 (f)                   ; Process each element of spec.\n (do ()\n     ((or (null (format-subspec f))   ; until we hit end of specs\n          (format-abort f)))          ; or ~\u00ac has been processed\n     (format-process f)\n     (setf (format-subspec f)\n           (cdr (format-subspec f)))))\n\n(defun format-process (f)\n (let ((s (car (format-subspec f))))         ; Get each element of spec.\n       (if (stringp s)                       ; If it is a string\n           (unless (format-suppress f)       ; and not suppressing\n                   (format-princ s f))       ; then process it.\n           (format-dispatch f s))))          ; Else process directive.\n\n(defun format-dispatch (f s) ; Process directive S\n (setf (format-colon f) (spec-colon s))\n (setf (format-atsign f) (spec-atsign s))\n (setf (format-modifiers f)\n       (mapcar #'(lambda (x)\n                         (case x\n                               (v   (unless (format-suppress f)\n                                            (format-read-arg f)))\n                               (|#| (length (format-subargs f)))\n                               (t   x)))\n               (spec-modifiers s)))\n\n (case (spec-char s)\n;;;;;;;((#\\nl #\\cr)  (format-call newline)) Optimized out by ZFMPARS.\n       ((#\\&)        (format-call &))\n       ((#\\%)        (format-call %))\n       ((#\\A)        (format-call a))\n       ((#\\B)        (format-call b))\n       ((#\\C)        (format-call c))\n       ((#\\D)        (format-call d))\n       ((#\\E)        (format-call e))\n       ((#\\F)        (format-call f))\n       ((#\\G)        (format-call g))\n       ((#\\O)        (format-call o))\n       ((#\\P)        (format-call p))\n       ((#\\R)        (format-call r))\n       ((#\\S)        (format-call s))\n       ((#\\T)        (format-call t))\n       ((#\\X)        (format-call x))\n\n       ((#\\~)        (format-call ~))\n       ((#\\|)        (format-call formfeed))\n\n       ((#\\$)        (format-call $))\n       ((#\\*)        (format-call *))\n       ((#\\?)        (format-call ?))\n       ((#\\\u00ac)        (format-call \u00ac))\n\n       ((#\\()  #|)|# (format-call left-paren))\n       ((#\\{)        (format-call left-brace))\n       ((#\\<)        (format-call <))\n\n       ((#xAD        ; left bracket\n         #x4A        ; cent sign\n        )            (format-call left-bracket))\n\n       ((#\\Z)        (format-call z)) ; For ZIL debugging only.\n\n       ((#xBD        ; right bracket\n         #x6A        ; broken vertical bar\n        )            (format-call right-bracket))\n\n       ((#\\})        (format-call right-brace))\n       ((#\\;)        (format-call semicolon))\n       ((#\\>)        (format-call >))\n ((#|(|# #\\))        (format-call right-parenthesis))\n\n       (t            (zerror \"Unsupported FORMAT directive\"\n                             (format-string f)\n                             (string (spec-char s))))))\n\n;======================================================================\n\n(defun format-string (f)\n (do ((s (format-spec f) (cdr s))\n      (z \"\" (string-append z (format-string-from (car s))))\n     )\n     ((null s) z)))\n\n(defun format-string-from (x)\n (cond\n  ((stringp x) x)\n  (t\n   (string-append \"~\" (reconstruct-format-modifiers (spec-modifiers x))\n                      (if (spec-colon x)  \":\" \"\")\n                      (if (spec-atsign x) \"@\" \"\")\n                      (string (spec-char x))))))\n\n(defun reconstruct-format-modifiers (x)\n (do ((x x (cdr x))\n      (z \"\")\n     )\n     ((null x) z)\n     (cond\n      ((null (car x)) nil)\n      ((stringp (car x))\n       (setq z (reconstruct-append z (string-append \"'\" (car x)))))\n      (t\n       (setq z (reconstruct-append z (tostring (car x))))))))\n\n(defun reconstruct-append (a b)\n (cond\n  ((zerop (string-length a)) b)\n  (t (string-append a \",\" b))))\n\n;======================================================================\n\n(defun format-read-arg (f)\n (or (format-subargs f)\n     (zerror \"Too few FORMAT args\" (format-string f) (format-args f)))\n (pop (format-subargs f))\n)\n\n(defun format-peek-arg (f)\n (or (format-subargs f)\n     (zerror \"Too few FORMAT args\" (format-string f) (format-args f)))\n (car (format-subargs f))\n)\n\n(defun format-back-arg (f)\n (loop for a on (format-args f)\n       until (eq (cdr a) (format-subargs f))\n       unless a do (zerror \"Unable to back up in FORMAT args\"\n                           (format-string f) (format-args f))\n       finally (setf (format-subargs f) a)\n               (return (car a)))\n)\n\n;======================================================================\n\n(defun format-ouch (times char f) ; Output a char some number of times.\n                                  ; Note: char is a 1-character string.\n (let ((dest (format-dest f)))\n  (cond\n   ((null dest)  (push (zilspad char (if (minusp times) 0 times)\n                                     char t 1)\n                       (format-stream-string f)))\n   ((eq dest t)  (dotimes (i times) (princ char nil)))\n   (t            (dotimes (i times) (princ char dest))))))\n\n(defun format-princ (object f)\n (let ((dest (format-dest f)))\n  (cond\n   ((null dest)  (push (prints object nil) (format-stream-string f)))\n   ((eq dest t)  (princ object nil))\n   (t            (princ object dest)))))\n\n(defun format-prin1 (object f)\n (let ((dest (format-dest f)))\n  (cond\n   ((null dest)  (push (prints object t) (format-stream-string f)))\n   ((eq dest t)  (prin1 object nil))\n   (t            (prin1 object dest)))))\n\n(defun format-terpri (f)\n (let ((dest (format-dest f)))\n  (cond\n   ((null dest)  (push (nl) (format-stream-string f)))\n   ((eq dest t)  (terpri nil))\n   (t            (terpri dest)))))\n\n(defun format-cterpri (f)\n (let ((dest (format-dest f)))\n  (cond\n   ((null dest)  (unless (and (fixnump (format-stream-offset f))\n                              (eql 1 (format-compute-column f)))\n                         (push (nl) (format-stream-string f))))\n   ((eq dest t)  (cterpri nil))\n   (t            (cterpri dest)))))\n\n(defun format-return (f)\n (let ((dest (format-dest f)))\n  (cond\n   ((null dest)  (stream-to-string f))\n   (t            nil))))\n\n;======================================================================\n\n(defun format-compute-column (f)\n (let ((dest (format-dest f)))\n  (cond\n   ((null dest) (format-compute-column-from-stream f))\n   ((eq dest t) (zgetfpo nil))\n   (t           (zgetfpo dest)))))\n\n(defun format-compute-column-from-stream (f)\n (let ((s (stream-to-string f)))\n      ;;; Memoize stream string for efficiency\n      (setf (format-stream-string f) (list s))\n      (unless (fixnump (format-stream-offset f))\n              (zerror\n\"FORMAT column position cannot be determined inside this directive\"\n               (format-string f) (format-stream-offset f)))\n      (let ((s1 (string-append (string-reverse s) (nl) (cr))))\n           (+  (min (string-index s1 (nl))\n                    (string-index s1 (cr)))\n              (format-stream-offset f)))))\n\n;======================================================================\n\n;\n; OK, here are the FORMAT directives.\n;\n\n(defmacro format-%-a (f)\n `(format-a-or-s nil ,f))\n\n(defmacro format-%-s (f)\n `(format-a-or-s t ,f))\n\n;\n; This processes the A and S directives, the only difference between\n; which is that A does a PRINC and S does a PRIN1.\n;\n; Modifiers:\n;\n; : - if the arg is NIL, will be printed as (); otherwise as NIL.\n;     This is not recursive, so the (w)implementor need not sweat it.\n;\n; @ - causes spaces to be inserted on the left; otherwise on the right.\n;\n; (mincol,colinc,minpad,padchar) ...\n;\n; mincol - inserts spaces on the right, if necessary, to make the\n;          width at least MINCOL columns.  The @ modifier causes the\n;          spaces to be inserted on the left rather than the right.\n;\n;          Default is 0.\n;\n; colinc - padding characters are inserted COLINC characters at a time\n;          until the total width is at least MINCOL.  This applies only\n;          after padding has been done up to MINPAD.\n;\n;          Default is 1.\n;\n; minpad - the string is padded on the right (or on the left if the @\n;          modifier is used) with at least MINPAD copies of PADCHAR.\n;\n;          Default is 0.\n;\n; padchar - the padding character (must be a string).\n;\n;          Default is space \" \".\n;\n(defun format-a-or-s (slashifyp f)\n (unless (format-suppress f)\n  (let ((arg (format-read-arg f)))\n       (if  (format-modifiers f)\n            (let* (\n                   ((mincol colinc minpad padchar) (format-modifiers f))\n                  )\n                  (format-a-or-s-full arg f (|@|) (|:|) slashifyp\n                                      mincol colinc minpad padchar))\n            (format-a-or-s-simple arg f (|:|) slashifyp)))))\n\n(defun format-a-or-s-full (arg f atsignp colonp slashifyp\n                           mincol colinc minpad padchar)\n (let* (\n        (string     (if (and (null arg) colonp)\n                        \"()\"\n                        (prints arg slashifyp)))\n        (size       (string-length string))\n        (fmincol    (if (fixnump mincol)  mincol  0))\n        (fcolinc    (if (fixnump colinc)  colinc  1))\n        (fminpad    (if (fixnump minpad)  minpad  0))\n        (fpadchar   (if (stringp padchar) padchar \" \"))\n       )\n       (unless atsignp (format-princ string f))\n       (format-ouch fminpad fpadchar f)\n       (setq size (+ size fminpad))\n       (loop while (< size fmincol) do\n             (format-ouch fcolinc fpadchar f)\n             (setq size (+ size fcolinc)))\n       (when atsignp (format-princ string f))))\n\n(defun format-a-or-s-simple (arg f colonp slashifyp)\n (cond\n  ((and (null arg) colonp)                (format-princ \"()\" f))\n  (slashifyp                              (format-prin1 arg f))\n  (t                                      (format-princ arg f))))\n\n;\n; This processes the D, B, O and X directives, which format integers.\n;\n; Modifiers:\n;\n; : - causes commas to be printed between groups of 3 digits.\n;\n; @ - causes the sign to always be printed.\n;\n; (mincol,padchar,commachar) ...\n;\n; mincol - inserts spaces on the left, if necessary, to make the\n;          width at least MINCOL columns.  If the number doesn't fit\n;          in MINCOL columns, additional columns are used as needed.\n;\n;          Default is 0.\n;\n; padchar - the padding character (must be a string).\n;\n;          Default is space \" \".\n;\n; commachar - the character to be used as a comma (must be a string).\n;\n;          Default is comma \",\".\n;\n\n(defmacro format-%-d (f) `(format-integer 10 ,f))\n(defmacro format-%-b (f) `(format-integer 2  ,f))\n(defmacro format-%-o (f) `(format-integer 8  ,f))\n(defmacro format-%-x (f) `(format-integer 16 ,f))\n\n(defun format-integer (radix f)\n (unless (format-suppress f)\n  (let ((arg (format-read-arg f))\n        ((mincol padchar commachar) (format-modifiers f))\n       )\n       (cond\n        ((not (integerp arg))\n         (format-a-or-s-full arg f nil nil nil mincol nil nil padchar))\n        (t\n         (let* (\n                (string     (format-integer-string (abs arg) radix f))\n                (fmincol    (if (fixnump mincol)    mincol    0  ))\n                (fpadchar   (if (stringp padchar)   padchar   \" \"))\n                (fcommachar (if (stringp commachar) commachar \",\"))\n               )\n               (when (|:|)\n                (setq string\n                     (prog (e z)\n                           (setq e (nreverse (zilexpl string t nil)))\n                      loop (or e (go end))\n                           (push (car e) z)\n                           (or (setq e (cdr e)) (go end))\n                           (push (car e) z)\n                           (or (setq e (cdr e)) (go end))\n                           (push (car e) z)\n                           (or (setq e (cdr e)) (go end))\n                           (push fcommachar z)\n                           (go loop)\n                      end  (return (string-appendl z)))))\n               (cond\n                ((minusp arg)\n                 (setq string (string-append \"-\" string)))\n                ((|@|)\n                 (setq string (string-append \"+\" string))))\n\n               (format-ouch (- fmincol (string-length string))\n                            fpadchar f)\n\n               (format-princ string f)))))))\n\n\n(defun format-integer-string (arg radix f)\n (if (zerop arg)\n  then\n     \"0\"\n  else\n  if (eql radix 10)\n  then\n     (tostring arg)\n  else\n  if (not (and (fixnump radix)\n               (> radix 1)\n               (< radix #.(1+ (string-length format-radix-string)))\n          ))\n  then\n     (zerror \"Invalid FORMAT radix value\" (format-string f) radix)\n  else\n     (do (\n          (z nil)\n          (quotient arg)\n          (remainder arg)\n         )\n         ((zerop quotient) (string-appendl z))\n         (psetq quotient (quotient quotient radix)\n                remainder (remainder quotient radix))\n         (push (substr #.format-radix-string (1+ remainder) 1) z)\n     )\n )\n)\n\n;\n; This processes the R directive, which formats integers.\n;\n; Modifiers:\n;\n; If there are no modifier arguments to the R directive, the modifier\n; flags are processed as follows:\n;\n; ~R    prints arg as a cardinal English number.\n; ~:R   prints arg as an ordinal English number.\n; ~@R   prints arg as a Roman numeral.\n; ~:@R  prints arg as an old Roman numeral.\n;\n; Otherwise...\n;\n; (radix,mincol,padchar,commachar) ...\n;\n; radix  - the radix (base) to be used.\n;\n; Everything else is as for the D, B, O and X formats.\n;\n\n(defun format-%-r (f)\n (unless (format-suppress f)\n  (if (format-modifiers f)\n      (format-integer (pop (format-modifiers f)) f)\n      (let ((arg (format-read-arg f)))\n           (format-princ (if (|@|)\n                             (zfmnrom arg (|:|))\n                             (zfmneng arg (|:|)))\n                         f)))))\n\n;\n; This processes the C directive, which formats characters.\n;\n; Modifiers:\n;\n; : - spells out the names of the control bits and represents\n;     non-printing characters by their names.  This is a \"pretty\"\n;     format for printing characters.\n;\n;     When : is present, @ specifies slightly more descriptive names.\n;\n;     (Otherwise, the character is printed as a single byte of data\n;     in this implementation.)\n;\n; @ - prints the character using #\\ syntax.\n;\n;\n; No modifier values are defined.\n;\n\n(defun format-%-c (f)\n (unless (format-suppress f)\n  (let ((arg (format-read-arg f)))\n       (if (|:|)\n        then\n             (let* ((a (assoc arg '#.format-char-reps))\n                    (b (if (|@|) (caddr a) (cadr a)))\n                   )\n                   (format-princ (or b (string arg)) f))\n        else\n             (when (|@|)\n                   (format-princ \"#\\\\\" f))\n             (format-princ (string arg) f)\n        endif))))\n\n;\n; This processes the P directive, which handles pluralization.\n;\n; ~P prints \"s\" if the arg is a fixnum 1, otherwise prints nothing,\n; subject to...\n;\n; Modifiers:\n;\n; : - backs up one argument and bases the output on the last arg.\n;\n; @ - prints \"y\" if the argument is 1, and \"ies\" if it isn't.\n;\n; No modifier values are defined.\n;\n\n(defun format-%-p (f)\n (unless (format-suppress f)\n  (let ((arg))\n       (when (|:|) (format-back-arg f))\n       (setq arg (format-read-arg f))\n       (cond\n        ((|@|)       (format-princ (if (eql arg 1) \"y\" \"ies\") f))\n        ((eql arg 1) nil)\n        (t           (format-princ \"s\" f))))))\n\n;\n; This processes the F directive, which prints flonums in\n; fixed-format floating-point format.\n;\n; Format:  ~w,d,k,overflowchar,padcharF\n;\n;  where   w is the width of the field to be printed\n;          d is the number of digits to print after the decimal point\n;          k is a scale factor that defaults to zero\n;\n; Exactly w characters will be output.\n;\n\n(defun format-%-f (f)\n (unless (format-suppress f)\n  (let ((arg (format-read-arg f))\n        ((w d k overflowchar padchar) (format-modifiers f))\n       )\n   (when (integerp arg)\n         (setq arg (catch nil (float arg))))\n   (cond\n    ((not (floatp arg))\n     (format-a-or-s-full arg f nil nil nil w nil nil padchar))\n    (t\n     (format-fixed arg f (|@|) w d k overflowchar padchar))))))\n\n(defun format-fixed (arg f atsignp w d k overflowchar padchar)\n (let* (\n        (fpadchar      (if (stringp padchar) padchar \" \"))\n        (abs           (abs arg))\n        (scaled-arg    (cond\n                        ((not (fixnump k))  abs)\n                        ((minusp k)     (/ abs (format-expt-10 (- k))))\n                        (t              (* abs (format-expt-10 k)))))\n        (trimzerop     (not (fixnump d)))\n        (supzerointp   (and (fixnump w) (fixnump d) (eql w (1+ d))))\n        ((istr . fstr) (format-float-pair scaled-arg\n                                          arg\n                                          atsignp\n                                          w\n                                          d\n                                          nil\n                                          trimzerop\n                                          supzerointp))\n        (ilength       (string-length istr))\n        (flength       (string-length fstr))\n        (width         (+ ilength flength 1))\n       )\n\n       (cond\n        ((and (fixnump w) (stringp overflowchar) (> width w))\n         (format-ouch w overflowchar f))\n        (t\n         (when (fixnump w)\n               (format-ouch (- w width) fpadchar f))\n         (format-princ (string-append istr \".\" fstr) f)))))\n\n; This takes a flonum and returns a dotted pair of strings,\n; representing the integer part and the fractional part.\n\n(defun format-float-pair (sarg arg signp w d\n                          lzlen trim-zeroes-p sup-zero-i-p)\n (let*\n  ((integer (truncate sarg))\n   (decprec (cond\n             ((fixnump d) d)\n             ((fixnump w) (format-guess-d integer arg signp w))\n             (t nil)))\n   (n       (cond\n             ((fixnump decprec) (format-expt-10 (1+ decprec)))\n             ((sfloatp sarg)    #.(expt 10 7))\n             (t                 #.(expt 10 16))))\n   (fraction (tostring (+ 5 n (abs (truncate (* (- sarg integer) n))))))\n   integerstring\n   fractionstring\n  )\n  ; Check to see if rounding overflowed into integer part\n  (when (>= fraction \"2\") ; Note: String comparison\n        (incf integer))\n  (if (and sup-zero-i-p (zerop integer))\n      (setq integerstring \"\")\n      (setq integerstring (format-pad-integer integer lzlen)))\n\n  (cond\n   ((minusp arg)\n    (setq integerstring (string-append \"-\" integerstring)))\n   (signp\n    (setq integerstring (string-append \"+\" integerstring)))\n  )\n  (setq fractionstring\n        (substr fraction 2 (- (string-length fraction) 2)))\n  (when trim-zeroes-p\n        (setq fractionstring (string-right-trim \"0\" fractionstring))\n        (when (zerop (string-length fractionstring))\n              (setq fractionstring \"0\")))\n  (cons integerstring fractionstring)))\n\n(defun format-guess-d (integer arg signp w)\n (let ((answer (- w 1 (string-length (tostring integer)))))\n      (cond\n       ((not (plusp answer)) 1)\n       ((or signp (minusp arg)) (1- answer))\n       (t answer))))\n\n; This is a quick and dirty hack for exponentiation.\n\n(defun format-expt-10 (k)\n (or (nth k '#.(do ((i 0 (1+ i))\n                    (n 1 (* n 10))\n                    (z nil (cons n z))\n                   )\n                   ((eql i 16) (nreverse z))))\n     (do ((i 16 (1+ i))\n          (n #.(** 10 16) (* 10 n)))\n         ((eql i k) n))))\n\n;\n; This processes the E directive, which prints flonums in\n; exponential floating-point format.\n;\n; Format:  ~w,d,e,k,overflowchar,padchar,exponentcharE\n;\n;  where   w is the width of the field to be printed\n;          d is the number of digits to print after the decimal point\n;          e is the number of digits to use when printing the exponent\n;          k is a scale factor that defaults to zero\n;\n; Exactly w characters will be output.\n;\n\n(defun format-%-e (f)\n (unless (format-suppress f)\n  (let ((arg (format-read-arg f))\n        ((w d e k overflowchar padchar exponentchar)\n         (format-modifiers f))\n       )\n   (when (integerp arg)\n         (setq arg (catch nil (float arg))))\n   (cond\n    ((not (floatp arg))\n     (format-a-or-s-full arg f nil nil nil w nil nil padchar))\n    (t\n     (format-exponential arg f (|@|) w d e k\n                         overflowchar padchar exponentchar))))))\n\n(defun format-exponential\n       (arg f atsignp w d e k overflowchar padchar exponentchar)\n (let* (\n        (fpadchar      (if (stringp padchar) padchar \" \"))\n        (abs           (abs arg))\n        (fk            (if (fixnump k) k 1))\n        (fd            (if (fixnump d)\n                           (if (plusp fk) (1+ (- d fk)) d)\n                           nil))\n        ((aarg . aexp) (format-adjust-for-exponent abs fk))\n        (estr          (format-pad-integer (abs aexp) e))\n        (elength       (string-length estr))\n        (trimzerop     (not (fixnump fd)))\n        (supzerointp   (and (fixnump w) (fixnump fd)\n                            (< w (+ fd\n                                    elength\n                                    (if (or (minusp arg) atsignp) 5 4)))\n                       ))\n        ((istr . fstr) (format-float-pair aarg\n                                          arg\n                                          atsignp\n                                          w\n                                          fd\n                                          nil\n                                          trimzerop\n                                          supzerointp))\n        (ilength       (string-length istr))\n        (flength       (string-length fstr))\n        (width         (+ ilength flength 3 elength))\n        (echar         (cond\n                        ((stringp exponentchar) exponentchar)\n                        ((sfloatp arg) \"F\")\n                        ((dfloatp arg) \"D\")\n                        (t \"?\")))\n       )\n\n       (cond\n        ((and (fixnump w) (stringp overflowchar) (> width w))\n         (format-ouch w overflowchar f))\n        ((and (fixnump e) (stringp overflowchar)\n              (> (string-length estr) e))\n         (format-ouch w overflowchar f))\n        (t\n         (when (fixnump w)\n               (format-ouch (- w width) fpadchar f))\n         (format-princ (string-append istr\n                                      \".\"\n                                      fstr\n                                      echar\n                                      (if (minusp aexp) \"-\" \"+\")\n                                      estr)\n                       f)))))\n\n(defun format-pad-integer (i l)\n ;\n ; This function takes an integer I and pads it with leading zeroes\n ; to the length specified by L.  It returns a string.\n ;\n (cond\n  ((not (fixnump l)) (tostring i))\n  ((minusp i)\n   (string-append \"-\" (format-pad-integer (- i) (1- l))))\n  (t\n   (zilspad (tostring i) l \"0\" nil -1))))\n\n(defun format-adjust-for-exponent (arg k)\n ;\n ; This function returns a flonum which is equivalent to arg scaled\n ; up or down until the number of digits to the left of the decimal\n ; point equals a given amount.  The return value is the flonum and\n ; the exponent required to get it into that shape.\n ;\n (prog (ll ul exponent)\n       (when (zerop arg) (return '(0.0 . 0)))\n       (setq ll 1.0)\n       (when (and (fixnump k) (not (eql k 1)))\n             (if (plusp k)\n                 (dotimes (i (1- k))\n                          (setq ll (* 10.0 ll)))\n                 (dotimes (i (- 1 k))\n                          (setq ll (* 0.1 ll)))))\n\n       (setq ul (* 10.0 ll))\n       (setq exponent 0)\n      loop\n       (cond\n        ((< arg ll)    (setq arg (* arg 10.0))\n                       (decf exponent)\n                       (go loop))\n        ((< arg ul)    (return (cons arg exponent)))\n        (t             (setq arg (* arg 0.1))\n                       (incf exponent)\n                       (go loop)))))\n\n;\n; This processes the G directive, which prints flonums in\n; either fixed-point or exponential floating-point format.\n;\n; Format:  ~w,d,e,k,overflowchar,padchar,exponentcharE\n;\n;  where   w is the width of the field to be printed\n;          d is the number of digits to print after the decimal point\n;          e is the number of digits to use when printing the exponent\n;          k is a scale factor that defaults to zero\n;\n; The format depends on the magnitude (absolute value) of the arg.\n; Let n be an integer such that 10\u00ac(n-1) <= arg < 10\u00acn.\n; Let ee equal e+2, or 4 if e is omitted.\n; Let ww equal w-ee, or nil if w is omitted.\n; If d is omitted, first let q be the number of digits needed to print\n; arg with no loss of information and without leading or trailing\n; zeroes; then let d equal (min q (min n 7)).\n; Let dd equal d-n.\n;\n; If 0 <= dd <= d, then arg is printed as if by the format directive\n;\n;   ~ww,dd,,overflowchar,padcharF~ee@T\n;\n; Note that the scale factor k is not passed to the ~F directive.\n; For all other values of dd, arg is printed as if by the directive\n;\n;  ~w,d,e,k,overflowchar,padchar,exponentcharE\n;\n; In either case, an @ modifier is specified to the ~F or ~E directive\n; if and only if one was specified to the ~G directive.\n;\n\n(defun format-%-g (f)\n (unless (format-suppress f)\n  (let ((arg (format-read-arg f))\n        ((w d e k overflowchar padchar exponentchar)\n         (format-modifiers f))\n       )\n   (when (integerp arg)\n         (setq arg (catch nil (float arg))))\n   (cond\n    ((not (floatp arg))\n     (format-a-or-s-full arg f nil nil nil w nil nil padchar))\n    (t\n     (let* (\n            (n  (format-find-n arg))\n            (ee (if (fixnump e) (+ e 2) 4))\n            (ww (if (fixnump w) (- w ee) nil))\n            (fd (if (fixnump d)\n                    d\n                    (max (format-find-q arg) (min n 7))))\n            (dd (- fd n))\n           )\n      (cond\n       ((and (not (minusp dd)) (<= dd fd))\n        (format-fixed arg f (|@|) ww dd nil overflowchar padchar)\n        (format-ouch ee \" \" f))\n       (t\n        (format-exponential arg f (|@|) w fd e k\n                            overflowchar padchar exponentchar)))))))))\n\n\n(defun format-find-n (arg)\n ;\n ;                          n-1            n\n ; An integer n such that 10    <= arg < 10 .\n ; If arg is 0, let n be 0.\n ;\n (cond\n  ((zerop arg) 0)\n  (t\n   (setq arg (abs arg))\n   (cond\n    ((< arg 1.0)\n     (do (\n          (x arg (* x 10.0))\n          (z 1 (1- z))\n         )\n         ((> x 1.0) z)))\n    (t\n     (do (\n          (x arg (/ x 10.0))\n          (z 0 (1+ z))\n         )\n         ((<= x 1.0) z)))))))\n\n(defun format-find-q (arg)\n ;\n ; The number of digits needed to print arg with no loss of\n ; information and without leading or trailing zeroes.\n ;\n (string-length (tostring arg)))\n\n;\n; This processes the $ directive, which prints flonums in\n; \"dollars\" floating-point format.\n;\n; Format:  ~d,n,w,padchar$\n;\n;  where   d is the number of digits to print after the decimal point\n;            (default value 2)\n;          n in the minimum number of digits to print before the\n;            decimal point (default value 1)\n;          w is the minimum total width of the field to be printed\n;            (default value 0)\n;\n\n(defun format-%-$ (f)\n (unless (format-suppress f)\n  (let ((arg (format-read-arg f))\n        ((d n w padchar) (format-modifiers f))\n       )\n   (when (integerp arg)\n         (setq arg (catch nil (float arg))))\n   (cond\n    ((not (floatp arg))\n     (format-a-or-s-full arg f nil nil nil w nil nil padchar))\n    (t\n     (format-dollar arg f (|@|) (|:|) d n w padchar))))))\n\n(defun format-dollar (arg f atsignp colonp d n w padchar)\n (let* (\n        (fd            (if (fixnump d) d 2))\n        (fn            (if (fixnump n) n 1))\n        (fw            (if (fixnump w) w 0))\n        (fpadchar      (if (stringp padchar) padchar \" \"))\n        (abs           (abs arg))\n        (supzerointp   (zerop fn))\n        ((istr . fstr) (format-float-pair abs\n                                          abs\n                                          nil\n                                          fw\n                                          fd\n                                          fn\n                                          nil\n                                          supzerointp))\n        (ilength       (string-length istr))\n        (flength       (string-length fstr))\n        (sign          (cond\n                        ((minusp arg) \"-\")\n                        (atsignp      \"+\")\n                        (t            nil)))\n        (width         (+ ilength flength (if sign 2 1)))\n        (m             (max fw 100))\n       )\n\n    (cond\n     ((> width m)\n      (let ((q (+ fd fn -1)))\n       (format-exponential arg f atsignp w q nil nil nil padchar nil)\n      )\n     )\n     (t\n      (and sign colonp (format-princ sign f))\n      (when (fixnump w)\n            (format-ouch (- w width) fpadchar f))\n      (and sign (not colonp) (format-princ sign f))\n      (format-princ (string-append istr \".\" fstr) f)))))\n\n;\n; This processes the % directive, which prints newlines.\n;\n; ~n% prints n newlines.\n;\n\n(defun format-%-% (f)\n (unless (format-suppress f)\n  (dotimes (i (or (car (format-modifiers f)) 1))\n           (format-terpri f))))\n\n;\n; This processes the & directive, which prints conditional newlines.\n;\n; ~n& prints n conditional newlines.\n;\n\n(defun format-%-& (f)\n (unless (format-suppress f)\n  (let ((k (or (car (format-modifiers f)) 1)))\n       (when (plusp k)\n             (format-cterpri f)\n             (dotimes (i (1- k))\n                      (format-terpri f))))))\n\n;\n; This processes the ~ directive, which prints tildes.\n;\n; ~n~ prints n tildes.\n;\n\n(defun format-%-~ (f)\n (unless (format-suppress f)\n  (format-ouch (or (car (format-modifiers f)) 1) \"~\" f)))\n\n;\n; This processes the | directive, which prints formfeeds.\n;\n; ~n| prints n formfeeds.\n;\n\n(defun format-%-formfeed (f)\n (unless (format-suppress f)\n  (format-ouch (or (car (format-modifiers f)) 1) (ff) f)))\n\n\n;\n; This processes the ? directive.\n;\n\n(defun format-%-? (f)\n (unless (format-suppress f)\n  (let* ((fspec   (zfmpars (format-read-arg f)))\n         (flist   (if (@) (format-subargs f) (format-read-arg f)))\n         (?f (copy-format f\n                          :spec     fspec\n                          :subspec  fspec\n                          :args     flist\n                          :subargs  flist))\n       )\n       (zfmexec1 ?f)\n       (when (@)\n        (setf (format-args f) (format-args ?f))\n        (setf (format-subargs f) (format-subargs ?f))\n       )\n  )))\n\n;\n; This processes the * directive.\n;\n\n(defun format-%-* (f)\n (unless (format-suppress f)\n  (if (|@|)\n      (setf (format-subargs f)\n            (nthcdr (or (car (format-modifiers f)) 0)\n                    (format-args f)))\n      (dotimes (i (or (car (format-modifiers f)) 1))\n               (if (|:|)\n                   (format-back-arg f)\n                   (format-read-arg f))))))\n\n;\n; This processes the \u00ac directive.\n;\n\n(defun format-%-\u00ac (f)\n (unless (format-suppress f)\n  (let* (\n         (modifiers (format-modifiers f))\n        )\n        (when (case (length modifiers)\n                    (0 (null (format-subargs f)))\n                    (1 (eql 0 (car modifiers)))\n                    (2 (eql (car modifiers) (cadr modifiers)))\n                    (t (and (<= (car modifiers) (cadr modifiers))\n                            (<= (cadr modifiers) (caddr modifiers)))))\n              (setf (format-abort f)\n                    (if (|:|) '|:| t))))))\n\n;\n; This processes the T directive, which does tabulation.\n;\n; ~colnum,colincT  - moves to column COLNUM.  If the \"cursor\" is\n;                    already at or beyond COLNUM, output spaces to\n; Default: ~1,1T     move it to column COLNUM + a multiple of COLINC\n;                    (unless COLINC is zero, in which case no spaces\n;                    are output in this case).\n;\n; @ - performs relative tabulation.\n;\n; ~colrel,colinc@T - outputs COLREL spaces and then outputs the\n;                    smallest non-negative number of additional\n; Default: ??????    spaces necessary to move to a multiple of COLINC.\n;\n; (Question:  What are the defaults for COLREL and COLINC?  It doesn't\n;             seem logical to make them 1,1 - should be 0,0?)\n;\n; (Question:  Is CLtL incorrect here?  Shouldn't it be a a column which\n;             is 1 plus a multiple of COLINC?)\n;\n\n(defun format-%-t (f)\n (let (((colnum colinc) (format-modifiers f)))\n      (if (|@|)\n          (format-tabulate-relative f colnum colinc)\n          (format-tabulate-absolute f colnum colinc))))\n\n(defun format-tabulate-absolute (f colnum colinc)\n (let* (\n        (fcolnum  (if (fixnump colnum) colnum 1))\n        (fcolinc  (if (fixnump colinc) colinc 1))\n        (num-cur  (- fcolnum (format-compute-column f)))\n       )\n  (if (plusp num-cur)\n      (format-ouch num-cur \" \" f)\n      (unless (zerop fcolinc)\n       (format-ouch (+ fcolinc (remainder num-cur fcolinc)) \" \" f)))))\n\n(defun format-tabulate-relative (f colrel colinc)\n (let* (\n        (fcolrel  (if (fixnump colrel) colrel 1)) ; My guesses\n        (fcolinc  (if (fixnump colinc) colinc 1)) ; for defaults\n       )\n       (format-ouch fcolrel \" \" f)\n       (when (> fcolinc 1)\n             (let* ((num-cur (+ fcolrel (format-compute-column f)))\n                    (r (remainder num-cur fcolinc)))\n                  (unless (zerop r)\n                          (format-ouch (- fcolinc r) \" \" f))))))\n\n;\n; This processes the ( directive.        )\n;\n\n(defun format-new-stream-for-lp (f &aux o)\n (cons (if (and (consp (format-stream f))\n                (not (fixnump (setq o (format-stream-offset f)))))\n           o\n           (1- (format-compute-column f)))\n       (list \"\")))\n\n(defun format-%-left-paren (f)\n (let* ((spec (cdr (format-subspec f)))\n        (what (cond\n               ((and (:) (@)) 'upcase)\n               ((:)           'capitalize-all)\n               ((@)           'capitalize-first)\n               (t             'downcase)))\n        (newf (copy-format f :dest nil\n                             :stream (format-new-stream-for-lp f)\n                             :spec spec\n                             :subspec spec))\n       )\n       (prog (u s)\n       loop\n        (setq u (car (or (format-subspec newf)\n                      (zerror \"FORMAT directive ~( specified without ~)\"\n                              (format-string f)))))\n        (when (and (consp u) (eql (car u) #|(|# #\\)))\n              (go finish))\n        (format-process newf)\n        (when (format-abort newf)\n              (setf (format-suppress newf) t))\n        (setf (format-subspec newf) (cdr (format-subspec newf)))\n        (go loop)\n       finish\n        (unless (format-suppress f)\n         (setq s (stream-to-string newf))\n         (setq s\n               (case what\n                (upcase\n                 (string-upcase s))\n                (downcase\n                 (string-downcase s))\n                (capitalize-all\n                 (string-capitalize s))\n                (capitalize-first\n                 (let ((i (string-verify s #.format-non-alphabetics)))\n                  (cond\n                   (i\n                    (string-append\n                     (string-substr s 1 (1- i))\n                     (string-upcase (string-substr s i 1))\n                     (string-downcase (string-substr s (1+ i)))\n                    ))\n                   (t s))))\n                (t s)))\n\n               (format-princ s f)\n               (setf (format-subargs f) (format-subargs newf))\n               (setf (format-abort f) (format-abort newf))\n        )\n        (setf (format-subspec f) (format-subspec newf)))))\n\n;\n; This processes the left bracket directive.\n;\n; Note: For EBCDIC terminal users, cent sign and broken vertical bar\n;       are permitted in place of left and right bracket.\n;\n\n(defmacro fselectif (condition)\n `(cond\n   (,condition\n    (setf (format-suppress newf) (format-suppress f))\n    (setq selected t))\n   (t\n    (setf (format-suppress newf) t))))\n\n(defun format-%-left-bracket (f)\n (let* (\n        (spec (cdr (format-subspec f)))\n        (newf (copy-format f :spec spec :subspec spec))\n       )\n       (prog (u select count selected)\n        (setq selected nil)\n        (cond\n         ((|:|)\n          (setq select (unless (format-suppress f)\n                               (format-read-arg newf)))\n          (fselectif (null select))\n         )\n         ((|@|)\n          (setq select (unless (format-suppress f)\n                               (format-peek-arg newf)))\n          (cond\n               ((not (null select))\n                (fselectif t)\n               )\n               (t\n                (format-read-arg newf) ; Use up the argument.\n                (fselectif nil))))\n         (t\n          (setq select (or (car (format-modifiers f))\n                           (unless (format-suppress f)\n                                   (format-read-arg newf))))\n          (setq count 0)\n          (fselectif (eql select 0))))\n       loop\n        (setq u (car (or (format-subspec newf)\n                      (zerror\n \"FORMAT directive ~LEFT_BRACKET specified without ~RIGHT_BRACKET\"\n                             (format-string f)))))\n        (when (and (consp u) (or (eql (car u) #xBD)   ; right bracket\n                                 (eql (car u) #x6A))) ; broken v. bar\n              (go finish))\n        (cond\n             ((and (consp u) (eql (car u) #\\;))\n              (cond\n               ((|@|)\n                (zerror\n                  \"~; not allowed in FORMAT ~@LEFT_BRACKET directive\"\n                  (format-string f)))\n               ((format-abort newf)\n                nil)\n               ((spec-colon u)\n                (setq count t)\n                (fselectif (not selected))\n               )\n               ((null count)\n                (setq count t)\n                (fselectif (not (null select)))\n               )\n               ((eq count t)\n                (if (|:|)\n                    (zerror \"Too many subforms in FORMAT ~:LEFT_BRACKET directive\"\n                            (format-string f))\n                    (zerror \"Misplaced ~:; in FORMAT ~LEFT_BRACKET directive\"\n                            (format-string f))))\n               (t\n                (incf count)\n                (fselectif (eql count select)))))\n             (t\n              (format-process newf)\n              (when (format-abort newf)\n                    (setf (format-suppress newf) t))\n             ))\n        (setf (format-subspec newf) (cdr (format-subspec newf)))\n        (go loop)\n       finish\n        (unless (format-suppress f)\n                (setf (format-subargs f) (format-subargs newf))\n        )\n        (setf (format-abort f) (format-abort newf))\n        (setf (format-subspec f) (format-subspec newf)))))\n\n\n;\n; This processes the { directive.\n;\n\n(defun format-%-left-brace (f)\n ;;;\n ;;; Check for case of ~{~}.  If so, suck up arg as format string\n ;;;\n (let ((s (cadr (format-subspec f))))\n      (if (and (consp s) (eql (car s) #\\}))\n          (format-braces-out-of-line f (spec-colon s))\n          (format-braces-in-line f))))\n\n(defun format-braces-out-of-line (f colon2p)\n (let ((spec (if (format-suppress f) () (zfmpars (format-read-arg f)))))\n      (format-them-braces f spec t colon2p)))\n\n(defun format-braces-in-line (f)\n (let ((spec (cdr (format-subspec f))))\n       (format-them-braces f spec nil nil)))\n\n(defun format-them-braces (f spec out-of-line-p colon2p)\n (let* ((arg (unless (format-suppress f)\n                     (if (@) (format-subargs f) (format-read-arg f))))\n        ((maxrep) (format-modifiers f))\n        (newf (copy-format f :args    arg\n                             :subargs arg\n                             :spec    (if out-of-line-p\n                                          spec\n                                          (format-spec f))\n                             :subspec spec\n              )))\n\n  ; begin PROG\n\n  (prog (k s)\n   (setq k 0)\n   (unless (|:|)\n           (setf (format-args newf) arg)\n           (setf (format-subargs newf) arg))\n\n  loop\n\n   (when (null (if (|:|) arg (format-subargs newf)))\n         (setf (format-suppress newf) t))\n   (unless (format-suppress newf)\n           (and maxrep (>= k maxrep) (setf (format-suppress newf) t))\n           (incf k))\n   (unless (format-suppress newf)\n      (unless (listp arg)\n              (zerror \"Arg to FORMAT ~{ directive not a list\" arg))\n      (and (|:|)\n           (not (listp (car arg)))\n           (zerror \"Arg to FORMAT ~:{ directive not a list\" (car arg)))\n      (when (|:|)\n            (setf (format-subargs newf)\n                  (setf (format-args newf) (pop arg)))))\n\n  loop-without-null-arg-check\n\n   (unless out-of-line-p\n    (setq s (car (or (format-subspec newf)\n                     (zerror \"FORMAT directive ~{ specified without ~}\"\n                             (format-string f))))))\n   (when (if out-of-line-p (null (format-subspec newf))\n                           (and (consp s) (eql (car s) #\\})))\n         (case (format-abort newf)\n               ((|:|)\n                (return))\n               ((t)\n                (setf (format-abort newf) nil)\n                (when (format-suppress newf)\n                      (return))\n                (setf (format-subspec newf) spec)\n                (go loop))\n               (otherwise\n                (when (and (if out-of-line-p colon2p (spec-colon s))\n                           (eql k 0)\n                           (not (eql maxrep 0))\n                           (null (if (|:|) arg (format-subargs newf))))\n                      (setf (format-suppress newf) (format-suppress f)\n                            (format-args newf)     nil\n                            (format-subargs newf)  nil\n                            (format-subspec newf)  spec)\n                      (setq k 1)\n                      (go loop-without-null-arg-check))\n                (when (format-suppress newf) (return))\n                (setf (format-subspec newf) spec)\n                (go loop))))\n   (let ((save-suppress (format-suppress newf)))\n        (unwind-protect\n         (progn\n          (unless (format-suppress newf)\n                  (setf (format-suppress newf) (format-abort newf)))\n          (format-process newf)\n         )\n         (setf (format-suppress newf) save-suppress)\n        )\n   )\n   (setf (format-subspec newf)\n         (cdr (format-subspec newf)))\n   (go loop-without-null-arg-check))\n\n  ; end PROG\n\n  (unless (format-suppress f)\n          (when (@)\n                (setf (format-subargs f)\n                      (format-subargs newf))))\n  (if out-of-line-p\n     (setf (format-subspec f)\n           (cdr (format-subspec f)))\n     (setf (format-subspec f)\n           (format-subspec newf)))))\n\n;\n; This processes the ~< directive.\n;\n; None of the LISP manuals available describe this directive\n; adequately.  However, it seems that the spacing must be\n; evenly divided among either n-1, n, or n+1 pads depending\n; on the @ and : specs.\n;\n\n(defun format-%-< (f)\n (let* (((mincol colinc minpad padchar) (format-modifiers f))\n        (fmincol  (if (fixnump mincol)  mincol  0))\n        (fcolinc  (if (fixnump colinc)  colinc  1))\n        (fminpad  (if (fixnump minpad)  minpad  0))\n        (fpadchar (if (stringp padchar) padchar \" \"))\n        (spec (cdr (format-subspec f)))\n        (newf (copy-format f :dest nil :stream nil\n                             :spec spec :subspec spec)))\n       (prog (u s k strings semiseen totstrlen spacing padlist padcount\n              leftpadp rightpadp spacing-between-segs spacing-left-over\n              fitstring fitmodifiers)\n        (setq totstrlen 0 k 0)\n        (unless (format-suppress newf)\n         (setf (format-stream newf) (cons \"~<\" (list \"\"))))\n         ; The \"~<\" is to tell ~T directives to error out.\n       process-loop\n        (setq u (car (or (format-subspec newf)\n                      (zerror \"FORMAT directive ~< specified without ~>\"\n                              (format-string f)))))\n        (setq s (if (consp u) (car u)))\n        (case s\n              ((#\\> #\\;)\n               (unless (format-suppress newf)\n                (cond\n                 ((and (eql s #\\;) (spec-colon u))\n                  (when semiseen\n                        (zerror \"Misplaced ~:; in FORMAT ~< directive\"\n                                (format-string f)))\n                  (setq fitstring    (stream-to-string newf))\n                  (setq fitmodifiers (spec-modifiers u))\n                 )\n                 (t\n                  (let ((string (stream-to-string newf)))\n                       (incf totstrlen (string-length string))\n                       (push string strings))))\n                (setf (format-stream-string newf) (list \"\"))\n               )\n               (when (eql s #\\;) (setq semiseen t))\n               (when (eql s #\\>) (go process-loop-end))\n              )\n              (otherwise\n               (format-process newf)\n               (when (format-abort newf)\n                     (setf (format-suppress newf) t))\n              ))\n\n        (setf (format-subspec newf) (cdr (format-subspec newf)))\n        (go process-loop)\n\n       process-loop-end\n\n        (cond\n         ((format-suppress f)\n          (go finish))\n         ((null strings)\n          (format-ouch fmincol fpadchar f)\n          (go finish))\n        )\n        (cond\n         ((and (|@|) (|:|))\n          (setq padcount (1+ (length strings)))\n          (setq leftpadp t)\n          (setq rightpadp t)\n         )\n         ((|@|)\n          (setq padcount (length strings))\n          (setq leftpadp nil)\n          (setq rightpadp t)\n         )\n         ((|:|)\n          (setq padcount (length strings))\n          (setq leftpadp t)\n          (setq rightpadp nil)\n         )\n         (t\n          (setq padcount (1- (length strings)))\n          (if (plusp padcount)\n              (setq leftpadp nil rightpadp nil)\n              (setq padcount 1 leftpadp t rightpadp nil))\n         )\n        )\n        (let ((minlen (+ totstrlen (* padcount fminpad))))\n             (loop while (< fmincol minlen)\n                   do (incf fmincol fcolinc)))\n\n        (setq spacing               (- fmincol totstrlen)\n              spacing-between-segs (quotient spacing padcount)\n              spacing-left-over   (remainder spacing padcount))\n\n        (setq strings (nreverse strings))\n\n        (do ((ss strings (cdr ss))\n             (s spacing-between-segs spacing-between-segs)\n             (r spacing-left-over)\n            )\n            ((null ss)\n             (when rightpadp\n                  (push (max fminpad s) padlist)\n                  (incf k s))\n            )\n            (unless (and (not leftpadp) (eq ss strings))\n             (when (plusp r)\n                   (incf s)\n                   (decf r))\n             (push (max fminpad s) padlist)\n             (incf k s)\n            )\n            (push (car ss) padlist)\n            (incf k (string-length (car ss)))\n        )\n\n        (unless (eql k fmincol)\n         (zerror\n          \"Internal FORMAT error processing ~< computing string length\"\n          (format-string f) fmincol k))\n\n        (setq padlist (nreverse padlist))\n\n        (when fitstring\n         (let* (\n                ((fitextra fitlinel) fitmodifiers)\n                (ffitextra (if (fixnump fitextra) fitextra 0))\n                (ffitlinel (if (fixnump fitlinel) fitlinel 72))\n                (roomleft (- ffitlinel (1- (format-compute-column f))))\n               )\n               (when (> (+ fmincol ffitextra) roomleft)\n                     (format-princ fitstring f))\n         )\n        )\n        (dolist (p padlist)\n                (if (fixnump p)\n                    (format-ouch p fpadchar f)\n                    (format-princ p f)))\n\n       finish\n\n        (unless (format-suppress f)\n         (setf (format-subargs f) (format-subargs newf)))\n        (setf (format-subspec f) (format-subspec newf)))))\n\n;\n; This processes the Z directive, which is for ZIL debugging only.\n;\n\n(defun format-%-z (f)\n (let ((arg (unless (format-suppress f) (format-read-arg f)))\n       (col (format-compute-column f))\n      )\n      (format t \"~%\")\n      (when (format-suppress f)\n       (format t\n            \"Note: This directive being processed in suppress mode.~%\"))\n      (format t \"~&Arg is ~S~%\" arg)\n      (format t \"~&Format modifiers are ~S~%\" (format-modifiers f))\n      (when (|:|) (format t \"~&\\\":\\\" flag is on~%\"))\n      (when (@) (format t \"~&\\\"@\\\" flag is on~%\"))\n      (format t \"~&Current column is ~S~%\" col)\n      (format t \"~%\")))\n\n;\n; The following exist only to signal errors when they are encountered\n; out of place.  They are handled correctly by code in the directive\n; handlers for (, <, etc.\n;\n\n(defun format-%-right-bracket (f)\n (zerror \"FORMAT directive error: ~RIGHT_BRACKET found but no ~LEFT_BRACKET active\"\n         (format-string f)))\n\n(defun format-%-right-brace (f)\n (zerror \"FORMAT directive error: ~} found but no ~{ active\"\n         (format-string f)))\n\n(defun format-%-> (f)\n (zerror \"FORMAT directive error: ~> found but no ~< active\"\n         (format-string f)))\n\n(defun format-%-right-parenthesis (f)\n (zerror \"FORMAT directive error: ~) found but no ~( active\"\n         (format-string f)))\n\n(defun format-%-semicolon (f)\n (zerror \"FORMAT directive error: ~; found but no ~LEFT_BRACKET or ~< active\"\n         (format-string f)))\n\n;======================================================================\n\n;;;\n;;; (ZFMNENG number ordinalp)\n;;;\n;;; This function, called by the FORMAT ~R directive processor,\n;;; takes an integer and returns the English-word form of the number.\n;;; If ordinalp is true, it returns the ordinal form; otherwise it\n;;; returns the cardinal form.\n;;;\n;;; Source of really-big-number names:\n;;;  Webster's Third New International Dictionary, 1986\n;;;\n\n(defun zfmneng (number ordinalp)\n (cond\n  ((not (integerp number))\n   (zfmneng-punt      number ordinalp))\n  ((zerop number)\n   (if ordinalp \"zeroth\" \"zero\"))\n  ((minusp number)\n   (string-append \"minus \" (zfmneng (minus number) ordinalp)))\n  (t\n   (zfmneng-number number ordinalp))))\n\n(defun zfmneng-number (number ordinalp)\n (cond\n  ((< number 20)           (zfmneng-basic             number ordinalp))\n  ((< number 100)          (zfmneng-..ty              number ordinalp))\n  ((< number 1000)         (zfmneng-hundred           number ordinalp))\n  ((< number 1000000)      (zfmneng-thousand          number ordinalp))\n  ((< number 1000000000)   (zfmneng-million           number ordinalp))\n  ((< number #.(** 10 12)) (zfmneng-billion           number ordinalp))\n  ((< number #.(** 10 15)) (zfmneng-trillion          number ordinalp))\n  ((< number #.(** 10 18)) (zfmneng-quadrillion       number ordinalp))\n  ((< number #.(** 10 21)) (zfmneng-quintillion       number ordinalp))\n  ((< number #.(** 10 24)) (zfmneng-sextillion        number ordinalp))\n  ((< number #.(** 10 27)) (zfmneng-septillion        number ordinalp))\n  ((< number #.(** 10 30)) (zfmneng-octillion         number ordinalp))\n  ((< number #.(** 10 33)) (zfmneng-nonillion         number ordinalp))\n  ((< number #.(** 10 36)) (zfmneng-decillion         number ordinalp))\n  ((< number #.(** 10 39)) (zfmneng-undecillion       number ordinalp))\n  ((< number #.(** 10 42)) (zfmneng-duodecillion      number ordinalp))\n  ((< number #.(** 10 45)) (zfmneng-tredecillion      number ordinalp))\n  ((< number #.(** 10 48)) (zfmneng-quattuordecillion number ordinalp))\n  ((< number #.(** 10 51)) (zfmneng-quindecillion     number ordinalp))\n  ((< number #.(** 10 54)) (zfmneng-sexdecillion      number ordinalp))\n  ((< number #.(** 10 57)) (zfmneng-septendecillion   number ordinalp))\n  ((< number #.(** 10 60)) (zfmneng-octodecillion     number ordinalp))\n  ((< number #.(** 10 63)) (zfmneng-novemdecillion    number ordinalp))\n  ((< number #.(** 10 66)) (zfmneng-vigintillion      number ordinalp))\n  (t                       (zfmneng-punt              number ordinalp))\n))\n\n(defun zfmneng-punt (number ordinalp)\n (let ((it (princ-to-string number)))\n      (if ordinalp (string-append it \"'th\") it)))\n\n(defun zfmneng-basic (number ordinalp)\n (nth number\n      (if ordinalp\n          '(nil \"first\" \"second\" \"third\" \"fourth\" \"fifth\" \"sixth\"\n            \"seventh\" \"eighth\" \"ninth\" \"tenth\" \"eleventh\" \"twelfth\"\n            \"thirteenth\" \"fourteenth\" \"fifteenth\" \"sixteenth\"\n            \"seventeenth\" \"eighteenth\" \"nineteenth\")\n          '(nil \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\"\n            \"eight\" \"nine\" \"ten\" \"eleven\" \"twelve\" \"thirteen\"\n            \"fourteen\" \"fifteen\" \"sixteen\" \"seventeen\"\n            \"eighteen\" \"nineteen\"))))\n\n(defun zfmneng-..ty (number ordinalp)\n (let* ((q (quotient  number 10))\n        (r (remainder number 10))\n        (s (nth q '(nil nil \"twent\" \"thirt\" \"fort\" \"fift\"\n                            \"sixt\" \"sevent\" \"eight\" \"ninet\")))\n       )\n       (if (zerop r)\n           (string-append s (if ordinalp \"ieth\" \"y\"))\n           (string-append s \"y-\" (zfmneng-basic r ordinalp)))))\n\n(defun zfmneng-process (number ordinalp powerof10 word)\n (let* ((q (quotient  number powerof10))\n        (r (remainder number powerof10))\n        (k (zfmneng-number q nil))\n       )\n   (if (zerop r)\n       (string-append k (if ordinalp (string-append word \"th\") word))\n       (string-append k word \" \" (zfmneng-number r ordinalp)))))\n\n(defmacro make-power-of-10-macro (power name)\n `(defmacro ,(concat \"ZFMNENG-\" (string-upcase name)) (number ordinalp)\n   `(zfmneng-process ,number ,ordinalp ,',(** 10 power)\n      ,,(string-append \" \" (string-downcase name)))))\n\n(make-power-of-10-macro  2 hundred)\n(make-power-of-10-macro  3 thousand)\n(make-power-of-10-macro  6 million)\n(make-power-of-10-macro  9 billion)\n(make-power-of-10-macro 12 trillion)\n(make-power-of-10-macro 15 quadrillion)\n(make-power-of-10-macro 18 quintillion)\n(make-power-of-10-macro 21 sextillion)\n(make-power-of-10-macro 24 septillion)\n(make-power-of-10-macro 27 octillion)\n(make-power-of-10-macro 30 nonillion)\n(make-power-of-10-macro 33 decillion)\n(make-power-of-10-macro 36 undecillion)\n(make-power-of-10-macro 39 duodecillion)\n(make-power-of-10-macro 42 tredecillion)\n(make-power-of-10-macro 45 quattuordecillion)\n(make-power-of-10-macro 48 quindecillion)\n(make-power-of-10-macro 51 sexdecillion)\n(make-power-of-10-macro 54 septendecillion)\n(make-power-of-10-macro 57 octodecillion)\n(make-power-of-10-macro 60 novemdecillion)\n(make-power-of-10-macro 63 vigintillion)\n\n;======================================================================\n\n;;;\n;;; (ZFMNROM number oldp)\n;;;\n;;; This function, called by the FORMAT ~R directive processor,\n;;; takes an integer and returns the Roman-numeral form of the number.\n;;; If oldp is true, it returns the \"old\" form\n;;; (e.g. IIII instead of IV); otherwise it returns the standard form.\n;;;\n\n(defun zfmnrom (number oldp)\n (cond\n  ((not (integerp number))\n   (zfmnrom-punt      number oldp))\n  ((minusp number)\n   (string-append \"-\" (zfmnrom (minus number) oldp)))\n  ((zerop number)\n   (zfmnrom-punt      number oldp))\n  (t\n   (zfmnrom-number number oldp))))\n\n(defun zfmnrom-number (number oldp)\n (cond\n  ((zerop number) ; Used for internal calls only\n   \"\")\n  ((< number 5)\n   (zfmnrom-i         number oldp))\n  ((< number 9)\n   (zfmnrom-v         number oldp))\n  ((< number 10)\n   (zfmnrom-ix        number oldp))\n  ((< number 50)\n   (zfmnrom-x         number oldp))\n  ((< number 90)\n   (zfmnrom-l         number oldp))\n  ((< number 100)\n   (zfmnrom-xc        number oldp))\n  ((< number 500)\n   (zfmnrom-c         number oldp))\n  ((< number 900)\n   (zfmnrom-d         number oldp))\n  ((< number 1000)\n   (zfmnrom-cm        number oldp))\n  ((< number 5000)\n   (zfmnrom-m         number oldp))\n  (t\n   (zfmnrom-punt      number oldp))))\n\n(defun zfmnrom-punt (number oldp)\n (princ-to-string number))\n\n(defun zfmnrom-generate (digit1 digit2 number oldp)\n (case number\n       (1  digit1)\n       (2  (string-append digit1 digit1))\n       (3  (string-append digit1 digit1 digit1))\n       (4  (if oldp\n               (string-append digit1 digit1 digit1 digit1)\n               (string-append digit1 digit2)))\n       (t  (zerror \"Bad args passed to ZFMNROM-GENERATE\"\n                   digit1 digit2 number oldp))))\n\n(defun zfmnrom-i (number oldp)\n (zfmnrom-generate \"I\" \"V\" number oldp))\n\n(defun zfmnrom-v (number oldp)\n (let ((r (- number 5)))\n      (string-append \"V\" (zfmnrom-number r oldp))))\n\n(defun zfmnrom-ix (number oldp)\n (if oldp \"VIIII\" \"IX\"))\n\n(defun zfmnrom-x (number oldp)\n (let ((q (quotient  number 10))\n       (r (remainder number 10))\n      )\n      (string-append (zfmnrom-generate \"X\" \"L\" q oldp)\n                     (zfmnrom-number r oldp))))\n\n(defun zfmnrom-l (number oldp)\n (let ((r (- number 50)))\n      (string-append \"L\" (zfmnrom-number r oldp))))\n\n(defun zfmnrom-xc (number oldp)\n (let ((r (- number 90)))\n      (string-append (if oldp \"LXXXX\" \"XC\") (zfmnrom-number r oldp))))\n\n(defun zfmnrom-c (number oldp)\n (let ((q (quotient  number 100))\n       (r (remainder number 100))\n      )\n      (string-append (zfmnrom-generate \"C\" \"D\" q oldp)\n                     (zfmnrom-number r oldp))))\n\n(defun zfmnrom-d (number oldp)\n (let ((r (- number 500)))\n      (string-append \"D\" (zfmnrom-number r oldp))))\n\n(defun zfmnrom-cm (number oldp)\n (let ((r (- number 900)))\n      (string-append (if oldp \"DCCCC\" \"CM\") (zfmnrom-number r oldp))))\n\n(defun zfmnrom-m (number oldp)\n (let ((q (quotient  number 1000))\n       (r (remainder number 1000))\n      )\n      (string-append (zfmnrom-generate \"M\" nil q t)\n                     (zfmnrom-number r oldp))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZFMPARS": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x05\\x7f\\x00\\x89\\x15o\\x11\\x05\\x00\\xe2\\x00\\xdf\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-02-26T00:00:00", "modifydate": "1989-06-05T11:05:00", "lines": 226, "newlines": 223, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; Reference: Steele, pp. 385-407.\n\n;;;\n;;; The FORMAT string parser (part of the new implementation of FORMAT).\n;;;\n;;; This function takes 1 arg, a FORMAT string, and returns a parsed\n;;; FORMAT spec.  Its format (n.p.i.) is a list of which each element\n;;; is either:\n;;;      a string, representing literal data\n;;; or:\n;;;      a list of the following, of which the first is always present\n;;;      but the rest may be omitted:\n;;;\n;;;      * a character fixnum representing the FORMAT directive\n;;;      * the \"colon\" (:) flag, T or NIL\n;;;      * the \"atsign\"(@) flag, T or NIL\n;;;      * a list of FORMAT modifiers.  Each modifier in the list\n;;;        is one of the following:\n;;;          - a fixnum\n;;;          - a one-character string, representing a \"quoted\" modifier\n;;;          - the symbol V, representing the presence of V or v\n;;;          - the symbol #, representing the presence of #\n;;;\n;;; In general, null strings are optimized out, though this shouldn't\n;;; be depended upon in general.\n;;;\n;;; For example:\n;;;\n;;; (zfmpars \"~2%foo ~a bar ~:S~10,v,'*@F\")\n;;;\n;;;  ===>\n;;;\n;;;  (\n;;;   (#\\% nil nil (2))\n;;;   \"foo \"\n;;;   (#\\A)\n;;;   \" bar \"\n;;;   (#\\S t nil)\n;;;   (#\\F nil t (10 V \"*\"))\n;;;  )\n;;;\n;;; This structure (well, list) is usually passed to ZFMEXEC for\n;;; execution.  Note that characters are uppercased no matter how\n;;; they appear in the original FORMAT string.\n;;;\n\n(defmacro substring (string start &optional end)\n `(substr ,string ,start ,(if end `(if ,end (- ,end ,start)))))\n\n(defmacro newline ()               ; Returns a one-character string.\n (symbol-name (ebcdic #\\newline)))\n\n(defmacro nullstringp (x)\n  ;;; (eql ,x \"\") ; We could do this in ZIL, but not in Common LISP.\n `(zerop (string-length ,x)))\n\n(defmacro spush (s z)\n (let ((g (gensym)))\n      `(let ((,g ,s))\n            (unless (nullstringp ,g)\n                    (if (stringp (car ,z))\n                        (setf (car ,z) (string-append (car ,z) ,g))\n                        (push ,g ,z))))))\n\n(defun zfmpars (string)\n (cond\n  ((symbolp string)\n   (setq string (symbol-name string)))\n  ((not (stringp string))\n   (zerror \"Invalid FORMAT string detected by ZFMPARS\" string)))\n (prog (c i l n s z modifiers colon atsign whitespace-eaten)\n       (setq l (string-length string)\n             n 1)\n  loop\n       (setf modifiers nil colon nil atsign nil)\n\n       (when whitespace-eaten\n             (setf whitespace-eaten nil)\n             (setq n\n              (or (verify string\n                          #.(tostring (implode\n                                   '(#/space #/cr #/newline #/null)))\n                          n)\n                  (1+ l))))\n\n       (setq i (index string \"~\" n))    ; Locate FORMAT directive.\n       (spush (substring string n i) z) ; Add string to format spec.\n       (or i (go finish))               ; End of string, return.\n\n       (setq n (1+ i))                  ; Point to stuff following ~.\n\n extract-format-modifiers\n\n        ; Scan for FORMAT modifiers if any.\n        ; i is the one-based index of the ~ introducer character.\n\n       (if (> n l)\n           (zerror \"Missing FORMAT directive character\" string))\n\n       (case (getcharn string n) ; char following ~ or ,\n             ((#\\')\n                    (push (substr string (1+ n) 1) modifiers)\n                    (setq n (+ n 2)))\n             ((#\\#)\n                    (push '|#| modifiers)\n                    (setq n (1+ n)))\n             ((#\\v\n               #\\V)\n                    (push 'v modifiers)\n                    (setq n (1+ n)))\n             (t\n                    (setq s (verify string \"-+0123456789\" n))\n                    (if (eql s n)\n                     (push nil modifiers)\n                     (let* (\n                            (snum (substring string n s))\n                            (num (make-number snum))\n                           )\n                           (unless (fixnump num)\n                                   (zerror \"Invalid FORMAT modifier\"\n                                           string snum))\n                           (push num modifiers)\n                           (setq n s)))))\n\n extract-format-flags\n\n       ; At this point, string(n) should begin with \",\" \":\" \"@\" or the\n       ; format directive character itself.\n\n       (if (or (null n) (> n l))\n           (zerror \"Missing FORMAT directive character\" string))\n\n       (case (getcharn string n)\n             ((#\\,)\n                    (if (or colon atsign)\n                        (zerror \"FORMAT syntax error\" string))\n                    (setq n (1+ n))\n                    (go extract-format-modifiers))\n             ((#\\:)\n                    (when colon (zerror \"Too many FORMAT :'s\" string))\n                    (setf colon t)\n                    (setq n (1+ n))\n                    (go extract-format-flags))\n             ((#\\@)\n                    (when atsign (zerror \"Too many FORMAT @'s\" string))\n                    (setf atsign t)\n                    (setq n (1+ n))\n                    (go extract-format-flags))\n       )\n\n;\n; If there is only one format modifier and it is NIL,\n; then there are no format modifiers.  Otherwise,\n; reverse the modifiers.\n;\n       (setf modifiers\n             (if  (and (null (car modifiers))\n                       (null (cdr modifiers)))\n                  nil\n                  (nreverse modifiers)))\n\n       (if (> n l)\n           (zerror \"Missing FORMAT directive character\" string))\n\n       ;;; Get the format directive character.\n\n       (setq c (char-upcase (getcharn string n))) ; The directive char.\n\n       ;;; Certain directives can be optimized at parse time.\n       ;;; Let's try to see if we can do it.\n\n       (case c\n ;\n ; This processes the <newline> directive.\n ;\n ; ~?, where ? is a newline, ignores the newline and any following\n ; non-newline whitespace characters.\n ;\n ; ~:?, where ? is a newline, ignores the newline, but any following\n ; whitespace is left in place.\n ;\n ; ~@?, where ? is a newline, leaves the newline in place, but any\n ; following whitespace is ignored.\n ;\n ; By my inference, ~@:? (where ? is a newline) leaves both the newline\n ; and the whitespace in place.\n ;\n             ((#\\cr #\\nl)   ; Newline following tilde?\n              (when atsign (spush (newline) z))\n              (unless colon (setf whitespace-eaten t))\n              (go continue)\n             )\n\n             ;;; No optimizations for the rest at this time.\n\n            )\n\n       ;;; Add the format directive spec to the format spec.\n\n       (push (if (null modifiers)\n                 (if (and (null colon) (null atsign))\n                     (list c)\n                     (list c colon atsign))\n                 (list c colon atsign modifiers))\n             z)\n\n continue\n\n       (setq n (1+ n))\n       (go loop)\n\n finish\n\n       (return (nreverse z))\n\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZFSEXEC": {"ttr": 10515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x00V\\x00\\x880_\\x01\\x00)?\\t\\x07\\x03\\xb5\\x03d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "1988-10-31T00:00:00", "modifydate": "2000-10-19T09:07:56", "lines": 949, "newlines": 868, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; ZIL-MVS only.  ISPF version 2 required.\n;;;\n;;; ZFSEXEC\n;;;\n;;; This is the underlying driver for ZIL-based interactive applications\n;;; that wish to use the full-screen interface.\n;;;\n;;; Syntax:\n;;;\n;;; (ZFSEXEC :panel-name           <string>\n;;;          :panel-library        <string>\n;;;          :long-appl            <string>\n;;;          :short-appl           <string>\n;;;          :terpri-exit-function <function>\n;;;          :initialize-function  <function>\n;;;          :terminate-function   <function>\n;;;          :panel-init-function  <function>\n;;;          :echo-input-function  <function>\n;;;          :expr-list-function   <function>\n;;;          :refreshp-function    <function>\n;;;          :eval-expr-function   <function>\n;;;          :good-eval-function   <function>\n;;;          :bad-eval-function    <function>\n;;;          :post-eval-function   <function>\n;;;          :display-function     <function>\n;;;          :output-row-function  <function>\n;;;;;;;;;;;;;:grind-form-function  <function>\n;;; )\n;;;\n;;; where:\n;;;\n;;; :panel-name            is the name of the ISPF display panel used.\n;;; :panel-library         is the panel data set where the panel lives.\n;;; :long-appl             describes the application, printed on SAVEs.\n;;; :short-appl            describes the application in error messages.\n;;; :terpri-exit-function  is called whenever a TERPRI is trapped.\n;;; :initialize-function   is called to initialize the FS environment.\n;;; :terminate-function    is called to terminate the FS environment.\n;;; :panel-init-function   is called each time prior to panel display.\n;;; :echo-input-function   is called to process input FS strings.\n;;; :expr-list-function    is called to return expressions from FS input\n;;; :refreshp-function     is called to see whether to refresh screen.\n;;; :eval-expr-function    is called to evaluate each expression.\n;;; :good-eval-function    is called for each value gotten from eval'ing\n;;; :bad-eval-function     is called for each failure to evaluate.\n;;; :post-eval-function    is called to do processing after evaluation.\n;;; :display-function      is called to generate the output to display.\n;;; :output-row-function   is called on each output row before adding.\n;;;;:grind-form-function   is called to convert a form to an FS string.\n;;;\n\n;======================================================================\n\n(eval-when ()\n #.(progn\n    (rminit)               ; Use Common Lisp syntax, not Maclisp syntax\n    (defvar ttyoff     '\u00acW); Maclisp printer variable\n    (defvar writefilep '\u00acR); Maclisp printer variable\n    (defvar pt%tyo       0)\n    (defvar pt%princ     1)\n    (defvar pt%prin1     5)\n    (defvar pt%terpri    2)\n    (defvar pt%cterpri  10)\n    (defvar pt%charpos  16)\n    (defvar pt%clrscrn  42)\n    (defvar *low-intensity*  (string #x05))\n    (defvar *high-intensity* (string #x0D))\n    (defvar *initial-array-size* 1000)\n   ))\n\n(defargs zmsprint 3 3 nil)\n\n(declare (special #.ttyoff #.writefilep))\n(declare (special *print-trap-string-list* *zfs-terpri-function*\n                  *zil-current-printer* *zil-previous-printer*\n                  *zil-override-printer*\n                  *zil-print-trap-hook-override*\n                  *zil-panel-library*))\n\n(defmacro ispnum      (x)   `(make-number (zisget ,x)))\n(defmacro nullstringp (x)   `(zerop (string-length ,x)))\n(defmacro string-eql  (x y) `(eql ,x ,y))\n(defmacro usymbol     (x)   `(intern (string-upcase ,x)))\n\n(defmacro yspexec (&rest args &aux (g (gensym)))\n  `(let ((,g (zisexec . ,args)))\n        (cond ((< ,g 12) ,g)\n              (t (zerror \"ISPF dialog service error\"\n                         (zisget \"zerrsm\") (zisget \"zerrlm\"))))))\n\n(defmacro fscall ((thing f &optional (retval nil))\n                   &rest args &aux (g (gensym)))\n `(let ((,g (,thing ,f)))\n       (if ,g (funcall ,g . ,args) ,retval)))\n\n(defmacro with-printer (f &body body)\n `(unwind-protect (let* ((*zil-previous-printer* *zil-current-printer*)\n                         (*zil-current-printer* ,f))\n                        (setprt *zil-current-printer*)\n                        . ,body)\n                  (setprt *zil-current-printer*)))\n\n(defstruct (fsstruct (:conc-name nil))\n (finger          nil)\n (fingerlist      nil)\n (expression      nil)\n (quitp           nil)\n (morep           nil)\n (array-size      #.*initial-array-size*)\n (line-array      (make-vector #.*initial-array-size* \"\"))\n (line-index      0)\n (current-row     0)\n (input-list      nil)\n (depth           0)\n (lvline          0)\n (cursor          \"IN\")\n (csrpos          0)\n (find-string     nil)\n (find-direction  nil)\n (find-row        nil)\n (find-pos        nil)\n (text-not-found  nil)\n (getinput        nil)\n (inputx          0)\n (print-trap      nil)\n (libdefp         nil)\n (interrupted     nil)\n (panel-name      nil)\n (panel-library   nil)\n (long-appl       nil)\n (short-appl      nil)\n (initialize-function    nil)\n (terminate-function     nil)\n (panel-init-function    nil)\n (echo-input-function    nil)\n (expr-list-function     nil)\n (refreshp-function      nil)\n (eval-expr-function     nil)\n (good-eval-function     nil)\n (bad-eval-function      nil)\n (post-eval-function     nil)\n (display-function       nil)\n (output-row-function    nil)\n;(grind-form-function    nil)\n)\n\n;======================================================================\n\n(defun zfsexec\n (&key\n  (panel-name           \"ZFSEXEC\")\n  (panel-library        (string-append \"'\" *zil-panel-library* \"'\"))\n  (long-appl            \"ZFSEXEC\")\n  (short-appl           \"ZFSEXEC\")\n  (terpri-exit-function nil)\n  (initialize-function  nil)\n  (terminate-function   nil)\n  (panel-init-function  nil)\n  (echo-input-function  nil)\n  (expr-list-function   nil)\n  (refreshp-function    nil)\n  (eval-expr-function   nil)\n  (good-eval-function   nil)\n  (bad-eval-function    nil)\n  (post-eval-function   nil)\n  (display-function     nil)\n  (output-row-function  nil)\n )\n (unless (ispfp)\n  (zerror\n   \"ISPF environment not active.  Full screen services not available.\"\n  ))\n (let (\n       (f (make-fsstruct))\n      )\n  (setf (panel-name f)           panel-name)\n  (setf (panel-library f)        panel-library)\n  (setf (long-appl f)            long-appl)\n  (setf (short-appl f)           short-appl)\n  (setq *zfs-terpri-function*    terpri-exit-function)\n  (setf (initialize-function f)  initialize-function)\n  (setf (terminate-function f)   terminate-function)\n  (setf (panel-init-function f)  panel-init-function)\n  (setf (echo-input-function f)  echo-input-function)\n  (setf (expr-list-function f)   expr-list-function)\n  (setf (refreshp-function f)    refreshp-function)\n  (setf (eval-expr-function f)   eval-expr-function)\n  (setf (good-eval-function f)   good-eval-function)\n  (setf (bad-eval-function f)    bad-eval-function)\n  (setf (post-eval-function f)   post-eval-function)\n  (setf (display-function f)     display-function)\n  (setf (output-row-function f)  output-row-function)\n  (zfsexec-initialize f)\n  (fscall (initialize-function f) (depth f))\n  (loop do (zisexec \"control display refresh\") ; Recover from attentions\n        until (catch t (zfsexec-read-eval-print f) t))\n  (zfsexec-terminate f)\n  (fscall (terminate-function f))\n  nil\n )\n)\n\n;======================================================================\n\n(defun zfsexec-read-eval-print (f)\n (block zfsexec-loop\n  (loop\n   (zfsexec-read f)\n   (when (quitp f) (return-from zfsexec-loop))\n   (zfsexec-tabexpand f\n                      (fscall (echo-input-function f (getinput f))\n                              (getinput f))\n                      t)\n   (zfsexec-eval-and-print f)\n  )))\n\n(defun zfsexec-read (f)\n (prog (zverb)\n\n regenerate-display\n\n   ;;;\n   ;;; Set up the data lines to be displayed.\n   ;;;\n\n  (loop for i from (current-row f)\n              to (min (+ (depth f) (current-row f) -1) (line-index f))\n        collect (vref (line-array f) i) into z\n        finally (zisput \"FSDATA\" (string-appendl z)))\n\n    (setf (current-row f) (min (current-row f) (line-index f)))\n\n    (zisput \"fsmsg\"\n     (cond\n      ((< (current-row f) (line-index f))\n       (string-append \"Row \" (tostring (1+ (current-row f)))\n                      \" of \" (tostring (line-index f))))\n      (t \"Bottom of data\")))\n\nbefore-display\n\n  ;;;\n  ;;; (Perform processing associated with )INIT section of panel.\n  ;;;\n\n  (fscall (panel-init-function f))\n\n  (cond\n   ((string-eql (cursor f) \"AMT\")\n    (setf (cursor f) \"ZCMD\")\n    (setf (csrpos f) 1))\n   ((string-eql (cursor f) \"ZCMD\")\n    (setf (csrpos f) 0)))\n  (zisput \"moremsg\"\n          (if (morep f) \"More data follows.  Scroll down to view.\"  \"\"))\n\n  ;;;\n  ;;; Display the screen and get input from the user.\n  ;;;\n\n  (case\n   (zisexec \"display cursor(\" (cursor f) \") csrpos(\" (csrpos f) \")\")\n   (0 nil)\n   (8 (setf (quitp f) t)\n      (return))\n   (t (format t\n              \"ISPF panel display error:~%~A - ~A\"\n              (zisget \"zerrsm\")\n              (zisget \"zerrlm\"))\n      (zerror \"zfsexec failure\")))\n\nafter-display\n\n  (setf (morep f) nil)\n  (setf (lvline f) (ispnum \"fslvlin\"))\n  (setf (cursor f) (zisget \"xcursor\"))\n  (setf (csrpos f) (ispnum \"xcsrpos\"))\n  (setq zverb (zisget \"zverb\"))\n  (case (char zverb 0)\n        ((NIL #\\SP) ; no scroll request\n         (go process))\n        (#\\U ; UP\n         (let ((fsa (zfsexec-scroll-amount f)))\n              (zfsexec-nullify-cursor f)\n              (if (minusp fsa) ; DOWN MAX?\n                  (setf (current-row f) 0)\n                  (decf (current-row f) fsa))))\n        (#\\D ; DOWN\n         (let ((fsa (zfsexec-scroll-amount f)))\n              (zfsexec-nullify-cursor f)\n              (if (minusp fsa) ; DOWN MAX?\n                  (zfsexec-down-max f)\n                  (incf (current-row f) fsa))))\n        (#\\L ; LEFT\n         (cond\n;;;;;;;;;;((string-eql (cursor f) \"FSDATA\")\n;;;;;;;;;;;(zfsexec-retrieve-form f))\n          ((eq (finger f) t)\n           (when (setf (finger f) (input-list f))\n                 (zfsexec-fetch-input f (car (finger f)) nil)))\n          ((cdr (finger f))\n           (push (pop (finger f)) (fingerlist f))\n           (zfsexec-fetch-input f (car (finger f)) nil))\n          ((finger f)\n           (zfsexec-fetch-input f (car (finger f)) nil))))\n        (#\\R ; RIGHT\n         (cond\n;;;;;;;;;;((string-eql (cursor f) \"FSDATA\")\n;;;;;;;;;;;(zfsexec-retrieve-form f))\n          ((eq (finger f) t)\n           (when (setf (finger f) (input-list f))\n                 (zfsexec-fetch-input f (car (finger f)) t)))\n          ((fingerlist f)\n           (push (pop (fingerlist f)) (finger f))\n           (zfsexec-fetch-input f (car (finger f)) nil))\n          ((finger f)\n           (zfsexec-fetch-input f (car (finger f)) t))))\n        (t (zerror \"Unknown ZVERB value\" zverb)))\n\n rescreen\n\n  (setf (current-row f) (max 0 (min (current-row f) (line-index f))))\n  (go regenerate-display)\n\n process\n\n  (setf (getinput f) (zisget \"IN\"))\n\n  (clear-ispf-message)\n\n;; Experimental ISPF-command-processing code would go here -\n;; see 'SEB1525.ZIL.LISP(XFSMAXC)'\n\n;; Non-experimental ISPF-command-processing\n\n  (let ((cmdlist\n         (catch nil (string-scan (zisget \"ZCMD\") \" ,\" \"\" \"\\\"\\\\\"))))\n   (when cmdlist\n    (when (string-eql (cursor f) \"IN\")\n          (setf (cursor f) \"ZCMD\"))\n    (let ((cmd (string-upcase (car cmdlist))))\n         (unless\n          (ok\n           (case cmd\n            ((\"L\" \"LOC\" \"LOCATE\") (zfsexec-locate f cmdlist))\n            ((\"F\" \"FIND\")         (zfsexec-find   f cmdlist))\n            ((\"RFIND\")            (zfsexec-rfind  f cmdlist))\n            ((\"SAVE\")             (zfsexec-save   f cmdlist))\n            (t (error-ispf-message \"Invalid command\"\n                (string-append \"Command \" cmd \" unknown.\"))))\n            t\n          )\n          (error-ispf-message (string-append cmd \" failed.\")\n  (string-append \"A severe error occurred during the \" cmd \" command.\")\n         )))\n    (go rescreen)))\n\n  (setf (finger f) t)\n  (setf (fingerlist f) nil)\n\n  (when (nullstringp (getinput f)) (go before-display))\n\n  (setf (inputx f) (line-index f))\n\n  (push (list (inputx f)\n              (getinput f)\n              (if (string-eql (cursor f) \"IN\") (csrpos f) 0))\n        (input-list f))\n\n ))\n\n(defun zfsexec-eval-and-print (f &aux (trapper\n                                       #'(lambda (x)\n                                          (with-printer (print-trap f)\n                                                        (funcall x)))))\n\n (let ((exprlist (fscall (expr-list-function f) (getinput f) trapper)))\n  (setf (getinput f) \"\")  ; Blank out for input next time\n  (when exprlist (zisput \"IN\" \"\"))\n  (loop for (nil expr fsdisplayp) in exprlist\n        do (setf (csrpos f) 0)\n           (setf (interrupted f) nil)\n           (zfsexec-evaluate-expression f expr fsdisplayp trapper)\n           (when (interrupted f)\n                 (zfsexec-dump-it f)\n                 (zfsexec-add-row f t \"*** ATTENTION INTERRUPT ***\"))\n  )\n )\n\n (zfsexec-dump-it f)\n\n (let ((lines-generated (- (line-index f) (inputx f)))\n       (lines-displayed (- (line-index f) (current-row f))))\n      (cond\n       ((>= lines-generated (lvline f))\n        (setf (current-row f) (inputx f))\n        (setf (morep f) t))\n       ((>= lines-displayed (lvline f))\n        (zfsexec-down-max f))))\n\n (when (fscall (refreshp-function f t))\n       (zisexec \"control display refresh\"))\n\n)\n\n(defun zfsexec-dump-it (f)\n (dolist (line (nreverse *print-trap-string-list*))\n         (zfsexec-tabexpand f line nil))\n (setq *print-trap-string-list* (list \"\"))\n)\n\n(defun zfsexec-evaluate-expression (f expr fsdisplayp trapper\n                                    &aux vals errorp attnp)\n (setq errorp t attnp t)\n (zisexec \"control display save\")\n (unwind-protect\n  (catch t\n   (catch nil\n    (setq vals\n     (fscall (eval-expr-function f (values nil nil))\n             expr fsdisplayp trapper))\n    (setq errorp nil))\n   (setq attnp nil))\n  (zisexec \"control display restore\"))\n (cond\n  (attnp\n   (setf (interrupted f) t)\n   (fscall (bad-eval-function f))\n   (error-ispf-message \"Attention interrupt.\"\n\"Expression evaluation was terminated because the PA1 key was pressed.\"\n   ))\n  (errorp\n   (fscall (bad-eval-function f))\n   (zfsexec-add-row f nil \"\")\n   (error-ispf-message \"Evaluation failed.\"\n    (string-append \"An error occurred while \"\n                   (short-appl f)\n                   \" was evaluating your expression.\")))\n  (t\n   (setf (csrpos f) 0)\n   (setf (cursor f) \"IN\")\n   (fscall (good-eval-function f) vals fsdisplayp)\n   (when fsdisplayp\n    (unless (ok (with-printer (print-trap f)\n                 (cterpri)\n                 (fscall (display-function f) vals)))\n            (zfsexec-add-row f nil \"\")\n            (error-ispf-message \"Display failed.\"\n             (string-append \"An error occurred during \"\n                            (short-appl f)\n                            \"'s display processing.\"))))\n  ))\n (fscall (post-eval-function f)))\n\n;======================================================================\n\n(defun error-ispf-message (smsg lmsg &key (alarm \"YES\") (help \"*\"))\n (zisput \"zerrsm\" smsg)\n (zisput \"zerrlm\" lmsg)\n (zisput \"zerralrm\" alarm)\n (zisput \"zerrhm\" help)\n (zisexec \"setmsg msg(isrz002)\")\n)\n\n(defun clear-ispf-message ()\n (zisput \"zerrsm\" \"\")\n (zisput \"zerrlm\" \"\")\n (zisput \"zerralrm\" \"no\")\n (zisput \"zerrhm\" \"*\")\n (zisexec \"setmsg msg(isrz002)\")\n)\n\n;======================================================================\n\n(defun macsyma-print-trap-hook (a f b)\n  (if (or (null f) (eq f t))\n      (let ((y #.ttyoff) (w #.writefilep))\n           (prog1 (unless y (print-trap-hook-dispatch a b))\n                  (when w (funcall *zil-previous-printer* a w b))))\n      (funcall *zil-previous-printer* a f b)))\n\n(defun zil-print-trap-hook (a f b)\n (if (or (null f) (eq f t))\n     (print-trap-hook-dispatch a b)\n     (funcall *zil-previous-printer* a f b)))\n\n(defun print-trap-hook-dispatch (a b)\n (if *zil-print-trap-hook-override*\n  (funcall *zil-override-printer* a t b)\n  (case b\n   (#.pt%tyo    (setf (car *print-trap-string-list*)\n                      (string-append (car *print-trap-string-list*)\n                                     (string a))))\n   (#.pt%princ  (setf (car *print-trap-string-list*)\n                      (string-append (car *print-trap-string-list*)\n                                     (princ-to-string a))))\n   (#.pt%prin1  (setf (car *print-trap-string-list*)\n                      (string-append (car *print-trap-string-list*)\n                                    (prin1-to-string a))))\n   (#.pt%terpri (when *zfs-terpri-function*\n                      (let ((*zil-print-trap-hook-override* t))\n                           (funcall *zfs-terpri-function*\n                                    (car *print-trap-string-list*))))\n                (push \"\" *print-trap-string-list*)\n                t)\n   ((#.pt%cterpri\n     #.pt%clrscrn) (unless (nullstringp (car *print-trap-string-list*))\n                           (push \"\" *print-trap-string-list*)\n                           t))\n   (#.pt%charpos ; a = new integer value or NIL to return current value\n                (let (\n                 (c (1+ (string-length (car *print-trap-string-list*))))\n                     )\n                  (cond\n                   ((null a)\n                    c)\n                   ((or (not (integerp a))\n                        (minusp a)\n;;;;;;;;;;;;;;;;;;;;;;;;(> a 79)\n                        (< a c))\n                    (zerror \"Invalid CHARPOS or ZGETFPO update value\" a)\n                   )\n                   (t\n                    (setf (car *print-trap-string-list*)\n                      ;;; (format nil \"~VA\" (1- a)\n                      ;;;;;;;;;;;;;;; (car *print-trap-string-list*))\n                          (zilspad (car *print-trap-string-list*)\n                                   (1- a) #\\sp nil 1)\n                    )))))\n\n   (t (zerror \"PRINT-TRAP-HOOK-DISPATCH got unknown value\" a b)))))\n\n;======================================================================\n\n(defun zfsexec-initialize (f)\n\n ;;;\n ;;; Set up the global variables.\n ;;;\n\n (setq *print-trap-string-list* (list \"\"))\n (setq *zil-print-trap-hook-override* nil)\n\n ;;;\n ;;; Set up the correct printer trapping.\n ;;;\n\n (cond\n  ((featurep 'macsyma)\n   (setf (print-trap f) #'macsyma-print-trap-hook)\n   (setq *zil-override-printer* #'zmsprint)\n   (setq *zil-current-printer* #'zmsprint)\n   (setq *zil-previous-printer* #'zmsprint))\n  (t\n   (setf (print-trap f) #'zil-print-trap-hook)\n   (setq *zil-override-printer* #'zdprint)\n   (setq *zil-current-printer* #'zdprint)\n   (setq *zil-previous-printer* #'zdprint)))\n\n ;;;\n ;;; Create the ISPF data structures to hold the display.\n ;;;\n\n (vfill (line-array f) \"\")\n (setf (line-index f)  0)\n (setf (current-row f) 0)\n\n\n ;;;\n ;;; See if the ISPF panel is available.   If not, make it available.\n ;;;\n\n (zisexec \"control errors return\")\n (zisexec \"control nondispl end\")\n (when (eql 12 (zisexec \"display panel(\" (panel-name f) \")\"))\n  (yspexec \"libdef ispplib dataset id(\" (panel-library f) \") uncond\")\n  (setf (libdefp f) t)\n  (yspexec \"display panel(\" (panel-name f) \")\"))\n\n ;;;\n ;;; Determine the initial number of rows to display.\n ;;;\n\n (when (eql 8 (yspexec \"pquery panel(\" (panel-name f)\n                       \") areaname(fsdata) depth(fslvlin)\"))\n       (zerror \"Bad ISPF panel definition for panel\" (panel-name f)))\n (setf (depth f) (ispnum \"fslvlin\"))\n (zisexec \"control errors cancel\")\n\n ;;;\n ;;; Trap the RFIND command.\n ;;;\n\n (zisput \"zctverb\" \"RFIND\")\n (zisexec \"tbtop ispcmds\")\n (case (zisexec \"tbscan ispcmds arglist(zctverb)\")\n       (0 (unless (string-eql (zisget \"zctact\") \"&YRFIND\")\n                  (zisexec \"tbtop ispcmds\")\n                  (zisput \"zctact\" \"&YRFIND\")\n                  (zisexec \"tbadd ispcmds\")))\n       (8         (zisexec \"tbtop ispcmds\")\n                  (zisput \"zctact\" \"&YRFIND\")\n                  (zisexec \"tbadd ispcmds\")))\n\n (zisput \"yrfind\" \"PASSTHRU\")          ; Make RFIND command a PASSTHRU.\n\n (zisexec \"vget (fsmamt) profile\")     ; Get remembered scroll amount.\n (let ((amt (zisget \"fsmamt\")))\n      (when (nullstringp amt)\n            (setq amt \"PAGE\")\n            (zisput \"fsmamt\" amt))     ; Set to PAGE if not in profile.\n      (zisput \"amt\" amt))              ; Put it on the panel.\n (zisput \"IN\" \"\")                      ; Clear input field.\n (zisput \"FSDATA\" \"\")                  ; Clear the dynamic area.\n)\n\n(defun zfsexec-terminate (f)\n (zisexec \"control display refresh\")\n (zisput \"fsmamt\" (zisget \"amt\"))\n (zisexec \"vput (fsmamt) profile\")\n (zisput \"yrfind\" \"\")\n (when (libdefp f)\n  (zisexec \"libdef ispplib dataset\"))\n t)\n\n;======================================================================\n\n(defun zfsexec-add-row\n       (f highp x &aux (new-index (1+ (line-index f))))\n (when (>= new-index (array-size f))\n       (let* ((new-array-size (+ (array-size f) #.*initial-array-size*))\n              (new-line-array (make-vector new-array-size \"\"))\n             )\n            (dotimes (i (array-size f))\n                     (setf (vref new-line-array i)\n                           (vref (line-array f) i))\n            )\n            (setf (line-array f) new-line-array\n                  (array-size f) new-array-size)))\n\n (setf (vref (line-array f) (line-index f))\n   ;;; (format nil \"~A~79A\"\n   ;;;             (if highp #.*high-intensity* #.*low-intensity*)\n   ;;;             (fscall (output-row-function f x) x))\n       (string-append (if highp #.*high-intensity* #.*low-intensity*)\n                      (zilspad (fscall (output-row-function f x) x)\n                               79 #\\sp nil 1))\n )\n\n (setf (vref (line-array f) new-index)\n       #.(format nil \"~A~79,,,'*:@<~A~>\"\n                     #.*low-intensity*\n                     \" Bottom of data \"))\n (setf (line-index f) new-index)\n)\n\n(defun zfsexec-nullify-cursor (f)\n (setf (text-not-found f) nil)\n (zisput \"IN\" \"\")\n (cond\n  ((string-eql (cursor f) \"IN\")\n   (setf (csrpos f) 1))\n  (t\n   (setf (cursor f) \"ZCMD\"))))\n\n(defun zfsexec-fetch-input (f entry cursorposp)\n (setf (current-row f) (car entry))\n (zisput \"IN\" (cadr entry))\n (setf (cursor f) \"IN\")\n (setf (csrpos f) (if cursorposp (caddr entry) 0)))\n\n;(defun zfsexec-retrieve-form (f &aux n)\n; (let ((q (quotient (1- (csrpos f)) 80)))\n;      (if (>= q (line-index f))\n;          (error-ispf-message \"Invalid cursor position.\"\n;           \"The cursor is outside of the output data area.\"))\n;      (setq n (+ (current-row f) q))\n;      (zisput \"IN\" (fscall (grind-form-function f) ...))\n;      (setf (cursor f) \"IN\")\n;      (setf (csrpos f) 0)\n;))\n\n(defun zfsexec-down-max (f)\n (setf (current-row f) (max 0 (- (line-index f) (lvline f) -1))))\n\n(defun zfsexec-scroll-amount (f)\n (case (char (zisget \"zscrolla\") 0)\n       (#\\M ; MAX\n        -1)\n       (t (ispnum \"zscrolln\"))))\n\n(defmacro !new-row! ()\n '(zfsexec-add-row f highp (string-appendl (nreverse z))))\n\n(defun zfsexec-tabexpand (f line highp)\n (do ((cl (exploden line) (cdr cl))\n      (n 0)\n      (z nil))\n     ((null cl)\n      (!new-row!))\n     (case (car cl)\n           ((#\\cr #\\nl)\n                  (!new-row!)\n                  (setq z nil n 0))\n           (#\\tab (loop do    (push \" \" z)\n                              (incf n)\n                        until (zerop (remainder n 8))))\n           (t     (push (string (car cl)) z)\n                  (incf n)))\n     (when (> n 78)\n           (!new-row!)\n           (setq z nil n 0))))\n\n;======================================================================\n\n(defun zfsexec-locate (f cmdlist &aux (c (cdr cmdlist)) n)\n (cond\n  ((null c)\n   (error-ispf-message \"Missing operand.\"\n                       \"The LOCATE command requires an operand.\"))\n  ((not (null (cdr c)))\n   (error-ispf-message \"Too many operands.\"\n                       \"The LOCATE command takes only one operand.\"))\n  ((not (fixnump (setq n (make-number (car c)))))\n   (error-ispf-message \"Invalid operand.\"\n                       \"A number must be specified with LOCATE.\"))\n  (t\n   (zisput \"ZCMD\" \"\")\n   (zisput \"IN\" \"\")\n   (setf (current-row f)\n         (max 0 (min (line-index f) (1- n)))))))\n\n(defun zfsexec-rfind (f cmdlist)\n (zisput \"ZCMD\" \"\")\n (if (find-string f)\n     (zfsexec-process-find f (find-string f) (find-direction f))\n     (error-ispf-message \"Enter a FIND command.\"\n                 \"A FIND command must precede an RFIND request.\")))\n\n(defun zfsexec-find (f cmdlist &aux (c (cdr cmdlist)))\n (cond\n  ((null c)\n   (if (find-string f)\n       (zfsexec-process-find f (find-string f) 'next)\n       (error-ispf-message \"Missing string.\"\n                       \"The FIND command requires a string.\")))\n  ((not (null (cddr c)))\n   (error-ispf-message \"Too many operands.\"\n                \"The FIND command takes no more than two operands.\"))\n  ((string-eql (car c) \"*\")\n   (if (find-string f)\n       (zfsexec-process-find f (find-string f)\n                               (if (cdr c) (cadr c) 'next))\n       (error-ispf-message \"No string defined.\"\n         \"* cannot be used until a FIND command has been executed.\")))\n  (t\n   (setf (find-string f) (zfsexec-hack-string (car c)))\n   (zfsexec-process-find f (find-string f)\n                           (if (cdr c) (cadr c) 'next)))))\n\n(defun zfsexec-hack-string (x &aux (y (string-upcase x)))\n (if (not (eql (char y 0) #\\\"))\n     y\n     (let ((l (exploden y)))\n          (loop for cl on (cdr l) with c\n                until (null (cdr cl))\n                do (setq c (car cl))\n                when (eql c #\\\\)\n                     collect (car (setq cl (cdr cl))) into z\n                else collect c into z\n                finally (return (tostring (implode z)))))))\n\n(defun zfsexec-process-find (f fstr fdir &aux (dir (usymbol fdir)))\n (if (nullstringp fstr)\n     (error-ispf-message \"Invalid string.\"\n                         \"A null string is not permitted.\")\n     (case dir\n       (next  (zfsexec-process-next  f fstr))\n       (prev  (zfsexec-process-prev  f fstr))\n       (first (zfsexec-process-first f fstr))\n       (last  (zfsexec-process-last  f fstr))\n       (t (error-ispf-message \"Invalid operand.\"\n            \"Specify NEXT, PREV, FIRST, or LAST (default is NEXT).\")))))\n\n(defun zfsexec-process-first (f fstr)\n (setf (text-not-found f) t)\n (zfsexec-process-next f fstr t))\n\n(defun zfsexec-process-last (f fstr)\n (setf (text-not-found f) t)\n (zfsexec-process-prev f fstr t))\n\n(defun zfsexec-process-next (f fstr &optional firstorlastp)\n (setf (find-direction f) 'next)\n (zisput \"ZCMD\" \"\")\n (zisput \"IN\" \"\")\n (cond\n  ((or firstorlastp (text-not-found f))\n   (setf (find-row f) 0)\n   (setf (find-pos f) 0))\n  (t (zfsexec-find-cursor-to-row-and-pos f)))\n (do ((row (find-row f) (1+ row))\n      (pos (1+ (find-pos f)) 1)\n      (i))\n     ((>= row (line-index f))\n      (zfsexec-dysreka f fstr \"Bottom of data reached.\" \"top.\"))\n     (setq i (string-index\n              (string-upcase (vref (line-array f) row))\n              fstr pos))\n     (when i\n           (zfsexec-eureka f fstr row i)\n           (return))))\n\n(defun zfsexec-process-prev (f fstr &optional firstorlastp)\n (setf (find-direction f) 'prev)\n (zisput \"ZCMD\" \"\")\n (zisput \"IN\" \"\")\n (cond\n  ((or firstorlastp (text-not-found f))\n   (setf (find-row f) (1- (line-index f)))\n   (setf (find-pos f) 80))\n  (t (zfsexec-find-cursor-to-row-and-pos f)))\n (do ((row (find-row f) (1- row))\n      (pos (1- (find-pos f)) 80)\n      (rtsf (string-reverse fstr))\n      (fl   (string-length fstr))\n      (rl)\n      (i)\n      (p))\n     ((minusp row)\n      (zfsexec-dysreka f fstr \"Top of data reached.\" \"bottom.\"))\n     (setq rl (string-length (vref (line-array f) row)))\n     (setq p (+ pos fl -1))\n     (setq i (string-index\n              (string-upcase\n               (string-reverse\n                (string-substr (vref (line-array f) row) 1 p)))\n              rtsf\n              1))\n     (when i\n           (setq i (- (min p rl) i fl -2))\n           (zfsexec-eureka f fstr row i)\n           (return))))\n\n(defun zfsexec-eureka (f fstr row i\n                       &aux (pstr (prin1-to-string fstr)))\n (setf (find-row f) row)\n (setf (find-pos f) i)\n (zfsexec-put-cursor f row i)\n (setf (text-not-found f) nil)\n (error-ispf-message\n  (string-append (if (> (string-length pstr) 16) \"Text\" pstr)\n                 \" found.\")\n  (string-append pstr \" was found on line \"\n                 (tostring (1+ row))\n                 \", column \"\n                 (tostring (1- i))\n                 \" of the output display.\") :alarm \"NO\"))\n\n(defun zfsexec-dysreka (f fstr word1 word2\n                        &aux (pstr (prin1-to-string fstr)))\n (cond\n  ((text-not-found f)\n  (setf (text-not-found f) nil)\n  (error-ispf-message\n   (string-append (if (> (string-length pstr) 12) \"Text\" pstr)\n                  \" not found.\")\n   \"The requested text was not found anywhere in the output.\"))\n  (t\n   (setf (text-not-found f) t)\n   (error-ispf-message word1\n     (string-append \"Text \" pstr\n                    \" not found.  RFIND to continue from \" word2)))))\n\n(defun zfsexec-find-cursor-to-row-and-pos (f &aux (n (csrpos f)))\n (if (string-eql (cursor f) \"FSDATA\")\n     (let ((q (quotient n 80))\n           (r (remainder n 80)))\n          (when (zerop r)\n                (setq q (1- q) r 80))\n          (setf (find-row f) (min (+ (current-row f) q)\n                                  (1- (line-index f)))\n                (find-pos f) r)\n     )\n     (setf (find-row f) (current-row f)\n           (find-pos f) 0)))\n\n(defun zfsexec-put-cursor (f row pos)\n ;\n ; row is absolute row.  To see if it's on the screen, we compute\n ; screen-row to be absolute-row minus *zfsexec-current-row*.\n ; If screen-row is negative, or\n ; screen-row is greater than *zfsexec-lvline*, then it's off the\n ; screen, and we have to scroll to bring it into view.\n ;\n (let ((srow (- row (current-row f))))\n      (cond\n       ((or (minusp srow) (>= srow (lvline f)))\n        (setf (current-row f) (max 0 (1- row))) ; up 1, like BROWSE FIND\n        (setq srow (if (zerop row) 0 1))))\n      (let ((off (+ (* 80 srow) pos)))\n           (setf (cursor f) \"FSDATA\")\n           (setf (csrpos f) off))))\n\n(defun zfsexec-save (f cmdlist &aux (c (cdr cmdlist)))\n ; Syntax: SAVE dsname {old/mod}\n (cond\n  ((null c)\n   (error-ispf-message \"Enter data set name.\"\n     \"The SAVE command requires a data set name to be specified.\"))\n  ((not (null (cddr c)))\n   (error-ispf-message \"Too many operands.\"\n                       \"Syntax:  SAVE datasetname {OLD / MOD }\"))\n  (t\n   (catch 'zfsexec-save\n    (zfsexec-process-save\n     f\n     (string-upcase (car c))              ; data set name\n     (if (cdr c) (usymbol (cadr c)) 'old) ; disposition\n    )))))\n\n(defun zfsexec-process-save (f dsn disp)\n (let ((option (case disp\n                     ((new shr old) :out)\n                     ((mod)         :append)\n                     (t (error-ispf-message \"Invalid disposition.\"\n                          \"Specify OLD or MOD (default is OLD).\")\n                        (throw 'zfsexec-save nil)))))\n      (with-open-file (file dsn option)\n       (format file \"~2%***  ~A - Output for ~A - ~A  ~A  ***~3%\"\n                    (long-appl f) (userid) (pptime) (ppdate))\n       (dotimes (i (line-index f))\n        (princ (string-substr (vref (line-array f) i) 2 80) file)\n        (terpri file)))\n      (zisput \"ZCMD\" \"\")\n      (zisput \"IN\" \"\")\n      (error-ispf-message \"Save successful.\"\n        (string-append \"Session data was saved in \" dsn)\n        :alarm \"NO\")))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZGETFPO": {"ttr": 7176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x880\\x7f\\x00\\x89\\x15o\\x11\\x05\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-02T00:00:00", "modifydate": "1989-06-05T11:05:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun zgetfpo (&optional f)\n (zcprint nil f #.%%%charpos)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILAPPLY": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x05\\x02\\xb2\\x02Q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:05:00", "lines": 690, "newlines": 593, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; ZILAPPLY\n;;;\n;;; The guts of APPLY.  This routine was separated from the APPLY\n;;; visible to the user in order to be able to specify the third and\n;;; fourth arguments listed below, as well as permitting the full\n;;; Common LISP syntax of APPLY.\n;;;\n;;; Argument 1 (required) - the function name or expression to apply.\n;;; Argument 2 (required) - the list of (evaluated) arguments.\n;;; Argument 3 (optional) - the lexical (fluid) evaluation environment.\n;;; Argument 4 (optional) - the name originally used on EVAL for errors.\n;;;\n;\n;         The pseudolexical \"environment\" arg that gets passed around\n;         is not merely an alist, but now a more complex object.\n;\n;         Implementation notes:\n;\n;         When a FEXPR is evaluated, the second arg is just the alist,\n;         not the entire environment.  However, ZILEVAL and ZILAPPLY\n;         take full environment objects.\n;\n;         Since the PROG and ARG environments are passed\n;         to interpretive lexical closures via FUNCTION, non-local\n;         GO's and ARG's are possible even across closures.\n;\n; See MKNEWENV for description of what the environment looks like.\n;\n; Note: This module contains code for processing &OPTIONAL and &KEY args\n;       that depends on the CAR of NIL being NIL.  ZCAR is used in\n;       other locations where fast CAR is desired and it is known that\n;       the argument won't be NIL.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/01/88 - Changes to support multiple values, BLOCK and TAGBODY    *\n;*            even before they're implemented.  ZEVMACS changed.       *\n;*                                                                     *\n;* 06/27/88 - Uses PARSE-BODY.                                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (compile)\n (let ((sample-env (funenv #'foo)))\n      (unless (listp sample-env)\n              (zerror \"Environment is not a list! Recode ZILAPPLY!!!\")\n      )))\n\n(include #.(zil-source-member zevmacs)) ; Include evaluator macros.\n\n(defstruct keychain\n     keyword         ; the keyword name (:foo)\n     variable        ; the keyword variable\n     initform        ; the keyword initial value\n     suppliedp       ; the keyword \"supplied-p\" argument\n     value           ; the keyword value to be assigned\n)\n\n\n;\n; Note that arg 3 may be specified as NIL, so that callers of\n; ZILAPPLY can tell it to make a new environment without having\n; to actually contain the call to MKNEWENV.\n;\n\n(defun zilapply (f ; the function to apply\n                 l ; the argument list\n        &optional\n                 (a nil)  ; the evaluation environment\n                 (q f)    ; function name for error messages\n             &aux\n                 m        ; Temporary local variable.\n                )\n\n;;; Start up the big dispatch.\n\n (cond\n\n;;;;(null f)              nil  ; What is this nonsense?  Deep-six it.\n\n;;; Assuming that subrs and closures are the only valid code objects...\n;;; e.g. (apply (subr foo) ...args...) - this is sort of irregular,\n;;; but placed up front in case of efficiency hacks in the interpreter\n;;; which replace symbols with their compiled functions or something.\n\n  ( (codep f)             (zilxsub f l)                               )\n\n;;; Interpreted lexical closures (funargs)...\n\n  ( (funargp f)           (zilapply (funfun f) l (funenv f) q)        )\n\n;;; Apply of a symbol - get the function associated with the name\n\n; (note - if dynamic scoping, we'd have had to do\n;         (unless a (setq a (mknewenv nil))) up here.)\n\n  ( (symbolp f)           (zilapply-symbol-function)                  )\n\n;;; Apply of a structure...\n;;; if the structure has a property that allows it to be invoked as a\n;;; function, then use that.  If that is the case, the associated\n;;; function gets invoked with arg1 being the instance of the structure\n;;; and the other args being the args passed to apply.\n;;;\n\n  ( (and (structp f)\n         (setq m (get (vref f 0) 'defstruct-funcall-method)))\n\n                          (zilapply m (cons f l) a q)                 )\n\n;;; All other kinds of atoms (numbers, etc.) cannot be functions.\n\n  ( (atom f)              (zerror \"Invalid form in functional position\"\n                                  f)                                  )\n\n;;; Lists - must be LAMBDA or LABEL expression...\n\n  ( t\n\n;;; If no environment specified, make a fresh one, lexically speaking.\n\n    (unless a (setq a (mknewenv nil)))\n\n    (case (zcar f)\n\n          ((lambda)       (unless (and (consp (cdr f))\n                                       (consp (cddr f)))\n                                  (zerror \"Invalid LAMBDA list\" f))\n                          (zilapply-lambda)                           )\n\n          ((label)        (unless (and (consp (cdr f))\n                                       (consp (cddr f)))\n                                  (zerror \"Invalid LABEL list\" f))\n                          (zilapply-label)                            )\n\n          (t              (zerror \"Invalid form in functional position\"\n                                  f))))))\n\n\n;\n; ZILAPPLY-SYMBOL-FUNCTION\n;\n; Defined as a macro to keep local variables all together.\n;\n;\n; MACRO, FEXPR, FSUBR and special forms are invalid - not functions.\n;\n\n(defun zilapply-symbol-function macro (x)\n'(let ((s (getl f '(expr subr))))\n   (cond\n    ((null s)\n     (if (setq s (getl f '(macro |SPECIAL FORM| fexpr)))\n      then\n         (zerror \"Invalid to APPLY\" (zcar s) f)\n      else\n         (zevauto f t)\n         (zilapply f l a q)\n      endif\n     ))\n    ((eq (zcar s) 'subr)      (zilxsub (zcadr s) l)                    )\n    ( t    #| expr |#         (zilapply (zcadr s)\n                                        l\n                                        (mknewenv nil) ; lexical scoping\n;;;;; if dynamic scoping, would be......(mknewenv (bindenv a))\n                                        f)                             )\n\n)))\n\n;\n; ZILAPPLY-LAMBDA\n;\n; Defined as a macro to keep local variables together.\n;\n; Note that since lambdas are assumed to exist lexically, as in\n; ((lambda ...) ...), the PROG and ARG environments are retained.\n;\n; Compare the way an EXPR is applied - the PROG and ARG environments\n; are reset to NIL.  Lexical closures pass the environments through,\n; creating the potential for strange Common-LISPy results.\n;\n\n(defun zilapply-lambda macro (x)\n'(let* (((nil lambvl . lambody) f)\n        (lexprp (and lambvl (atom lambvl)))\n       )\n       ;\n       ; If the bvl is a non-NIL atom, this is a \"lexpr\".\n       ; In which case we bind *ARG* to the list of args (for (ARG x))\n       ; and add it to the LEXPR arg environment\n       ; and bind bvl to the number of args.\n       ;\n       ; Otherwise, this is a normal \"expr\".\n       ; In which case we do normal binding.\n       ;\n       (prog (newenv savespec locspecs lamspecs)\n             (setq newenv (copyenv a))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Search the body of the LAMBDA for declarations, and extract the     *\n;* special variable declarations therefrom.                            *\n;*                                                                     *\n;***********************************************************************\n;\n  ;; Get current env's pervasive specials (copy lest local shadowing)\n             (setq lamspecs (append (specenv a) nil))\n\n  (multiple-value-bind (docstring decls nbody mxform mxvalidp)\n                       (parse-body lambody nil t)\n   (setq lambody (if mxvalidp (cons mxform (cdr nbody)) nbody))\n   ;;...process local declarations...\n   (dolist (dcl decls)\n           (if (atom dcl)\n               (warn \"Invalid declaration\" dcl)\n               (case (car dcl)\n                     ((special)\n                     (dolist (dclarg (cdr dcl))\n                             ;; Remember this when we bind...\n                             (push dclarg locspecs)\n                             ;; It's pervasively special for references\n                             (push dclarg lamspecs)))))))\n;;;\n;;; End of declaration hacking.\n;;;\n             (when lexprp (push l (argenv newenv)))\n             ;\n             ; Save current special binding environment before the\n             ; binding process adds new specials to it.\n             ;\n             (setq savespec (special-alist))\n\n             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n             ;\n             ; Establish pervasively special declarations here\n             ; rather than before bind.  In this way they don't\n             ; affect the initialization forms.  This is the way\n             ; CL will probably be modified by 1988, even though\n             ; CLtL (first edition) says otherwise.\n             ;\n             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n             ;\n             ; For each variable mentioned in a local SPECIAL\n             ; declaration, delete it from the list of local bindings.\n             ;\n             ; If it was also in the lambda list, we don't care,\n             ; because DESTRUCTURING-BIND would have done the same\n             ; thing and it won't be in the binding list.\n             ;\n             ; To avoid needless consing, we do this only if\n             ; there is a variable of the same name already there.\n             ;\n\n             (dolist (var locspecs)\n               (when (assq var (bindenv newenv))\n                     (setf (bindenv newenv)\n                           (loop for binding in (bindenv newenv)\n                                 unless (eq var (car binding))\n                                 collect binding))))\n\n             ;\n             ; Set the special variables for the environment.\n             ;\n\n             (setf (specenv newenv) lamspecs)\n\n             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n             ;\n             ; While binding, make LAMSPECS side-effectable so that\n             ; DESTRUCTURING-BIND can DELQ locally bound variables\n             ; out of the pervasively declared specials without\n             ; having to pass LAMSPECS non-locally.\n             ;\n             (push nil lamspecs)\n             (zilapply-bind lambvl (if lexprp (length l) l)\n                                   q newenv locspecs lamspecs nil)\n             (setq lamspecs (cdr lamspecs))\n\n        loop\n             (when (null lambody)\n                   (setf (special-alist) savespec)\n                   (return nil))\n             (when (null (cdr lambody))\n                   (return\n                    (multiple-value-prog1\n                     (zileval (zcar lambody) newenv nil)\n                     (setf (special-alist) savespec))))\n             (zileval (zcar lambody) newenv nil)\n             (setq lambody (cdr lambody))\n             (go loop))))\n\n;\n; ZILAPPLY-LABEL\n;\n; Defined as a macro to keep local variables together.\n;\n;;;         A temporary corruption of the label's property list is\n;;;         effected to enable the label.\n;;;         Note how the PLIST is restored in a way that preserves\n;;;         any changes to the \"real\" property list of the label.\n;;;\n;;; Yuk.  Can't wait until local function definitions a la FLET are\n;;;       added to the \"environment\" so we can use that instead of\n;;;       this cruft.\n;;;\n\n(defmacro zilapply-label ()\n '(let* (((nil lfun llam) f)\n         (save-expr (get lfun 'expr)))\n        (unwind-protect\n         (progn (putprop lfun llam 'expr)\n                (zilapply llam l a q)    ; This is what gets returned.\n         )\n         (if save-expr\n             (putprop lfun save-expr 'expr)\n             (remprop lfun 'expr))\n        )))\n\n;\n; BIND\n;\n; BIND takes an environment and updates its binding component with\n; the variable bindings stuck on the front of it from the lists\n; provided.  (Unless the variable is special, in which case the\n; run-time special binding alist is updated instead.)\n;\n\n(defun zilapply-bind (bvl l q a locspecs lamspecs destructuring-p)\n (prog (mode restarg c c1 c2 c3 aux-args-to-be-evaluated\n        keyspec allow-other-keys-p keylist)\n  loop\n       (or bvl (go cleanup))\n       (cond ((atom bvl)         ; CDR of a dotted pair.\n              (and restarg\n                   (bind-error q\n                    \"&REST arg conflicts with dotted pair syntax\"))\n              (setq restarg bvl)\n              (go cleanup)))\n       (setq c (zcar bvl))    ; An argument spec from the lambda-list.\n       (if (llkeywdp c)       ; If it's a lambda list keyword\n        then\n         (case c\n               ((&optional)    (go process-&optional))\n               ((&rest &body)  (go process-&rest))\n               ((&aux)         (go process-&aux))\n               ((&key)         (go process-&key))\n               ((&allow-other-keys)\n                               (go process-&allow-other-keys))\n               (t (bind-error q \"Unsupported lambda list keyword\" c)))\n        else\n         (case mode\n               ((nil)          (go required-arg))\n               ((&optional)    (go optional-arg))\n               ((&rest)        (go rest-arg))\n               ((&aux)         (go aux-arg))\n               ((&key)         (go key-arg))\n               (t (bind-error q \"Misplaced lambda list keyword\" mode)))\n       )\n\n required-arg\n       (when (null l)\n             (if destructuring-p\n              then\n                 (bindarg c nil)\n                 (setq bvl (cdr bvl))\n                 (go loop)\n              else\n                 (zerror \"Too few arguments\" q)\n             ))\n       (bindarg c (zcar l))\n       (setq l (cdr l))\n       (setq bvl (cdr bvl))\n       (go loop)\n optional-arg\n       (setq c2 nil c3 nil)\n       (cond\n            ((atom c) (setq c1 c))\n            (t        (setq c1 (car c)\n                            c2 (cadr c)\n                            c3 (caddr c))))\n;\n; Note: when binding ... &optional (foo bar ...) ...,\n; bar gets evaluated in the environment built SO FAR by the BINDARG\n; macro, and the evaluated value is bound to foo.\n;\n       (cond\n            ((null l) (bindarg c1 (zileval c2 a nil))\n                      (bindarg c3 nil))\n            (t        (bindarg c1 (zcar l))\n                      (bindarg c3 t)\n                      (setq l (cdr l))))\n       (setq bvl (cdr bvl))\n       (go loop)\n aux-arg\n       (cond\n            ((atom c) (setq c1 c\n                            c2 nil))\n            (t        (setq c1 (car c)\n                            c2 (cadr c))))\n       (push `(,c1 . ,c2) aux-args-to-be-evaluated)\n       (setq bvl (cdr bvl))\n       (go loop)\n rest-arg\n       (and restarg (bind-error q \"Too many &REST args\"))\n       (setq restarg c)\n       (setq bvl (cdr bvl))\n       (go loop)\n key-arg\n\n ;\n ; Format of a &key entry:\n ;\n ; var\n ; (var)\n ; (var initform)\n ; (var initform suppliedp)\n ; ((:var var))\n ; ((:var var) initform)\n ; ((:var var) initform suppliedp)\n ;\n\n       (let (\n             (var)\n             (variable)\n             (initform)\n             (suppliedp)\n             (keyword)\n            )\n            (cond\n             ((atom c)\n              (setq variable c\n                    initform nil\n                    suppliedp nil\n                    keyword (keywordify c)))\n             ((atom (setq var (car c)))\n              (setq variable var\n                    initform (cadr c)\n                    suppliedp (caddr c)\n                    keyword (keywordify var)))\n             ((or (null (cdr var))\n                  (cddr var))\n              (bind-error q \"Invalid &KEY arg syntax\" c))\n             (t\n              (setq variable (cadr var)\n                    initform (cadr c)\n                    suppliedp (caddr c)\n                    keyword (car var)))\n            )\n;;;\n;;; The following check removed to allow destructuring of &KEY vars.\n;;;\n;;;;;;;;;;;;(unless (and (symbolp variable)\n;;;;;;;;;;;;             (not (keywordp variable)))\n;;;;;;;;;;;; (bind-error q \"Invalid &KEY variable name\" variable))\n            (unless (and (symbolp suppliedp)\n                         (not (keywordp suppliedp)))\n             (bind-error q \"Invalid &KEY suppliedp name\" suppliedp))\n            (push (make-keychain\n                        keyword    keyword\n                        variable   variable\n                        initform   initform\n                        suppliedp  suppliedp\n                        value      keyspec\n                  ) keylist))\n       (setq bvl (cdr bvl))\n       (go loop)\n process-&optional\n       (setq mode '&optional)\n       (setq bvl (cdr bvl))\n       (go loop)\n process-&aux\n       (setq mode '&aux)\n       (setq bvl (cdr bvl))\n       (go loop)\n process-&rest\n       (and restarg (bind-error q \"Duplicate &REST arg\" q))\n       (setq mode '&rest)\n       (setq bvl (cdr bvl))\n       (go loop)\n process-&key\n       (setq mode '&key)\n       (setq keyspec (ncons nil)) ;Unique arg to represent \"unbound\" key\n       (setq bvl (cdr bvl))\n       (go loop)\n process-&allow-other-keys\n       (setq mode '&allow-other-keys)\n       (setq allow-other-keys-p t)\n       (setq bvl (cdr bvl))\n       (go loop)\n cleanup\n;\n; If neither &REST nor &KEY was specified, then if there are any\n; leftover args this may be an error.\n;\n       (and l\n            (null restarg)\n            (null keyspec)\n            (if destructuring-p\n             then\n                 ; nothing - just ignore the extra subargs\n             else\n                 (zerror \"Too many arguments\" q)))\n;\n; Bind the &REST arg if any.\n;\n       (when restarg\n             (bindarg restarg l))\n;\n; Bind the &KEY keywords if any.\n;\n       (when keyspec\n             (setq keylist (nreverse keylist))\n             ;\n             ; See if either &allow-other-keys was specified or\n             ; the :allow-other-keys keyword was passed and is not NIL.\n             ;\n             ; Note: This code depends on the CAR of NIL being NIL.\n             ;\n             (unless allow-other-keys-p\n                     (setq allow-other-keys-p\n                           (car (getk l ':allow-other-keys t))))\n             (prog (p k e f)\n                   (setq p l)\n               loop\n                   (or p (go done))\n                   (setq k (zcar p)\n                         p (cdr p))\n                   (unless p\n                         (zerror \"Odd number of keyword arguments\" q l))\n                   (when (eq k ':allow-other-keys)\n                         (setq p (cdr p))\n                         (go loop))\n                   (setq e (loop for x in keylist\n                                 when (eq k (keychain-keyword x))\n                                 return x))\n                   (unless e\n                           (if allow-other-keys-p\n                            then\n                               (setq p (cdr p))\n                               (go loop)\n                            else\n                               (zerror \"Key not defined\" q k)\n                            endif\n                           ))\n                   (when (eq (keychain-value e) keyspec)\n                         (setf (keychain-value e) (zcar p)))\n                   (setq p (cdr p))\n                   (go loop)\n               done\n                   (loop for x in keylist\n                         with sup\n                         when (eq (keychain-value x) keyspec)\n                              (setf (keychain-value x)\n                                    (zileval (keychain-initform x)\n                                             a nil))\n                              (setq sup nil)\n                         else\n                              (setq sup t)\n                         do\n                              (bindarg (keychain-variable x)\n                                       (keychain-value x))\n                         when (keychain-suppliedp x)\n                              (bindarg (keychain-suppliedp x) sup)\n                   )))\n\n;\n; Bind the &AUX args if any.\n;\n;\n; Note: when binding ... &aux (foo bar ...) ...,\n; bar gets evaluated in the environment built SO FAR by the BINDARG\n; macro (which includes all other bindings plus those established\n; for previously occurring &AUX args),\n; and the evaluated value is bound to foo.\n;\n       (loop for (c1 . c2) in (nreverse aux-args-to-be-evaluated)\n             (bindarg c1 (zileval c2 a nil)))\n       (return)))\n\n(defmacro bindarg (var val)\n `(destructuring-bind ,var ,val q a locspecs lamspecs)\n)\n\n(defun destructuring-bind (var val q a locspecs lamspecs)\n (cond\n  ((null var)     nil)\n  ((symbolp var)  (cond\n                   ;\n                   ; A symbol that is self-evaluating cannot be used\n                   ; as a lambda list variable.\n                   ; e.g. T, keywords\n                   ;\n                   ((eq (pbind var) var)\n                    (bind-error q \"Cannot use as lambda list arg\" var))\n                   ((or (memq var locspecs)      ; Locally special?\n                        (specialp var))          ; Globally special?\n                  ;\n                  ; If the variable is locally or globally declared\n                  ; SPECIAL, delete it from the list of local bindings\n                  ;\n                  ; (Note: If the variable is globally proclaimed\n                  ;        SPECIAL, it would never have ended up on\n                  ;        the list of local bindings, so we could\n                  ;        conceivably skip that, and do this only for\n                  ;        members of LOCSPECS.)\n                  ;\n                  ; To avoid needless consing, we do this only if\n                  ; there is a variable of the same name already there.\n                  ;\n                    (when (assq var (bindenv a))\n                          (setf (bindenv a)\n                                (loop for binding in (bindenv a)\n                                      unless (eq var (car binding))\n                                      collect binding)))\n                    (push (cons var val) (special-alist)))\n                   (t\n                    ;; Make \"unspecial\" by de-pervasive-specialing it.\n                    (delq var lamspecs) ; Must be side-effectable!!!\n                    (push (cons var val) (bindenv a)))))\n  ((atom var)     (bind-error q \"Arg not a list or symbol\" var))\n  ((and val (atom val))\n                  (when (< (msglevel) 3)\n                        (princ \"Destructuring error in function \")\n                        (prin1 q)\n                        (terpri)\n                        (princ \"Unable to destructure into arg(s) \")\n                        (prin1 var)\n                        (terpri))\n                  (zerror \"Cannot destructure value\" val))\n  (t\n                  (zilapply-bind var val q a locspecs lamspecs t))))\n\n(defun bind-error (q msg &optional (arg1 nil arg1?))\n (let ((msg\n            `(\"Syntax error in lambda list for \"\n              ,q\n              #.(tostring (ebcdic #\\nl))\n              ,msg)))\n      (cond\n       (arg1? (zerror msg arg1))\n       (t     (zerror msg)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Obsolete code...\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; If not a LAMBDA or LABEL expression, maybe the list is a macro\n;;; call that expands into one.  Let's try it out.\n;\n; ( (and (symbolp (zcar f))\n;        (get (zcar f) 'macro))\n;                         (zilapply-warning f)\n;                         (zilapply (macroexpand f) l a q)            )\n;\n;;; Otherwise, not recognized.  Do non-CL evaluation of CAR and try it.\n;\n; ( t                     (zilapply-warning f)\n;                         (zilapply (zileval f\n;                                            (list (bindenv a) nil nil))\n;                                            l a q)                   )\n;\n; ZILAPPLY-WARNING\n;\n;\n;(defun zilapply-warning (form)\n; (when (lessp (msglevel) 2)\n;       (cterpri)\n;       (princ \"Warning: Invalid function name \")\n;       (prin1 form)\n;       (princ \" in CAR of form.  \")\n;       (princ \"Evaluating it for value to reapply.\")\n;       (terpri)))\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCO": {"ttr": 7429, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x05\\x00\\x83\\x00\\x98\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:05:00", "lines": 131, "newlines": 152, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;\n; ZILCO\n;\n;**********************************************************************\n;\n;\n; This is the main-line module of the compiler.  Note use of PROG to\n; define pseudo-globals that can be accessed via the free variable\n; mechanism.\n;\n; The compiler is invoked as follows:\n;\n; //stepname EXEC PGM=ZILCO,PARM='abxxxxxxxx'\n;\n; where:\n;\n;    a is P (program), F (function) or M (module)\n;    (a can be Y (program) or N (function) for compatibility)\n;    b is Y (debug mode is active) or N (debug mode not active)\n;    xxxxxxxx is the name of the source program\n;\n; Required files:\n;\n;    SRC  (Input)   Contains the input LISP source program.\n;\n;    CODE (Output)  Contains the generated assembler source code.\n;\n;\n;**********************************************************************\n;\n; Change activity:\n;\n; 02/23/87 Bootstrapping compiler for ZIL 1.2 to ZIL 1.3.\n;\n; 06/12/87 The first version of the compiler to run in ZIL 1.3\n;          for the purpose of correct compilation of ZIL 1.3 code.\n;\n; 12/16/88 Cosmetic cleanup - removed old #-ZIL13 stuff, etc.\n;\n;**********************************************************************\n\n(include #.(zil-source-member zilmacs)) ; ZILCO macros.\n\n(declare (special *version*))\n\n(set-feature 'zilco)  ; This is ZILCO, the compiler.\n\n(terpri)\n(princ \"ZILCO: LISP compiler for MVS - Version \")\n(princ *version*)\n(princ #.(string-append \" - \" (ppdate)))\n(terpri)\n(princ\n \"       (c) Copyright 1988 Charles Stark Draper Laboratory, Inc.\"\n)\n(terpri)\n(terpri)\n\n\n#-zil13  ; During bootstrap phase only...\n\n(progn\n (terpri)\n (princ \"Target language........... ZIL 1.3\")\n (terpri)\n (princ \"Implementation language... ZIL 1.2\")\n (terpri)\n (terpri)\n)\n\n(setabend t)   ; Enable ABEND interception.\n\n(funcall 'zilcoint)     ; Perform compiler initialization.\n                        ; Done via FUNCALL to allow ZILCOINT to be\n                        ; frequently recompiled without having to\n                        ; relink the entire compiler each time.\n\n(let*\n      ((parmlist    (explodec (getparm nil)))\n       (debug?      (eq (cadr parmlist) 'y))\n       (source-name (concatl (cddr parmlist)))\n       (kind\n                    (case (car parmlist)\n                     ((P Y)  'program)\n                     ((F N)  'function)\n                     ((M)    'module)\n                     (t (zerror \"Bad parm passed to ZILCO\" parmlist))))\n       (comcode 0)\n      )\n      (princ  \"Compilation arguments:      Source.............\")\n      (princ  source-name)\n      (terpri)\n      (princ  \"                            Kind...............\")\n      (princ  kind)\n      (terpri)\n      (princ  \"                            Debug?.............\")\n      (princ  debug?)\n      (terpri)\n      (terpri)\n      (setq comcode\n            (catch 'zilcocom-error\n                   (unless (ok (zilcocom source-name kind debug?))\n                          (terpri)\n                          (princ \"*** Severe LISP error. ***\")\n                          (terpri)\n                          (princ \"*** ZIL compilation terminated. ***\")\n                          (terpri)\n                          (exit 16))\n                   0))\n      (unless (zerop comcode)\n              (terpri)\n              (princ \"ZIL compilation failed, error code \")\n              (prin1 comcode)\n              (terpri)\n              (exit comcode))\n)\n(terpri)\n(princ \"ZILCO: LISP compiler (Version \")\n(princ *version*)\n(princ \") ended.\")\n(terpri)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOADD": {"ttr": 7431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x05\\x00G\\x00C\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:05:00", "lines": 71, "newlines": 67, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"ADDCONSTANTS\"\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zilcoadd (a aa)   ; AA defaults to NIL; valid only for lists\n (cond\n  ((null a) nil)                              ; Never add NIL to list\n  ((eq a t) nil)                              ; Never add T to list\n  ((atom a) (addconstantatom a))              ; Add A to list of atoms\n  (t        (addconstantlist a aa)) ))        ; Add A to list of lists\n\n(defun addconstantatom (a)\n (prog (dottedpair atomlist)\n  (setq atomlist (if (symbolp a) alfatoms numatoms))\n  (if  (setq dottedpair (assoc a atomlist))   ; Find A in global list\n   then                                       ; If it's there, then\n       (or (assoc a atoms)                    ; if not in our list\n           (modq atoms dottedpair))           ; then add it to our list\n   else                                       ; Else not in global list\n       (modq atoms                            ; so add it to our list\n             (setq dottedpair                 ; (SYMBOLPAIR will also\n                   (zilcosym a 'atoms)))      ;  add it to global list)\n   endif\n  )\n  (return dottedpair)))\n\n(defun addconstantlist (a p &aux q)\n (prog (dottedpair)\n  (setq dottedpair (cons a (gensym)))         ; Always create a new list\n  (modq lists dottedpair)                     ; Then add it to the list\n  (modq alllists dottedpair)                  ; and also to global list\n  (putprop (cdr dottedpair) p 'referenced)    ; If directly referenced\n  (if   (atom (cdr a))                        ; then say so, else not\n   then                                       ; Add CAR of pair to list\n        (setq q (zilcoadd (car a) nil))       ; Add CAR of pair to list\n        (if q (putprop (cdr q) t 'real))      ; Show it's really used\n        (setq q (zilcoadd (cdr a) nil))       ; Add CDR of pair to list\n        (if q (putprop (cdr q) t 'real))      ; Show it's really used\n   else                                       ; Otherwise...\n        (mapaddconstants a)\n   endif                ; Add each atom in the list to the list of atoms\n  )                     ; Add each list in the list to the list of lists\n  (return dottedpair)))\n\n(defun mapaddconstants (l &aux q)\n (cond\n       ((null l) nil)\n       ((null (cdr l)) (setq q (zilcoadd (car l) nil))\n                       (if q (putprop (cdr q) t 'real)))\n       ((atom (cdr l)) (setq q (zilcoadd (car l) nil))\n                       (if q (putprop (cdr q) t 'real))\n                       (setq q (zilcoadd (cdr l) nil))\n                       (if q (putprop (cdr q) t 'real)))\n       (t (setq q (zilcoadd (car l) nil))\n          (if q (putprop (cdr q) t 'real))\n          (mapaddconstants (cdr l)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOARG": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x06\\x03\\x18\\x03\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:06:00", "lines": 792, "newlines": 798, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"ZILCOARG\"\n;\n; This function makes the PARMS list out of the argument list passed\n; to it.  For example...\n;\n;  (DEFUN FOO (A B C) ...)  results in call (ZILCOARG 'FOO '(A B C))\n;                            which builds the following list:\n;\n; ((A . G00001) (B . G00002) (C . G00003))\n;\n;   where:  (GET 'G00001 'POSITION) ==> 1\n;           (GET 'G00002 'POSITION) ==> 2\n;           (GET 'G00003 'POSITION) ==> 3\n;\n; The return value is:\n;\n;   T  - if the argument list is valid\n;   NIL - if there is an error in the argument list\n;\n; In addition, it also assigns properties to the named function:\n;\n; PARMS   - the list of dotted pairs constructed by this function\n; MINARGS - the minimum number of arguments\n; MAXARGS - the maximum number of arguments\n; RESTARG - the &REST argument if there is one, else NIL\n; LEXPRARG - the name of the single arg if the function is a LEXPR\n; ALLOW-OTHER-KEYS-P - if &ALLOW-OTHER-KEYS is in the lambda list.\n;\n;\n; NIL is allowed as a first-level lambda list arg.  It is\n; treated as a destructuring spec with no components.\n;\n;\n; Destructuring works something like this:\n;\n; Given a lambda list like the following...\n;\n; (LAMBDA ((A (B C) D . E) X Y &OPTIONAL (O 1 O?) &REST Z &AUX (U 2))\n;\n; a list is built as follows:\n;\n;\n;    The list           Plist of (CDR <--))\n;\n;  (\n;   (G01 . G02)      (POSITION 1 DESTRVARS ((A . G09)\n;                                           (B . G10)\n;                                           (C . G11)\n;                                           (D . G12)\n;                                           (E . G13)))\n;   (X   . G03)      (POSITION 2)\n;   (Y   . G04)      (POSITION 3)\n;   (O   . G05)      (POSITION 4 OPTIONAL T INIT 1\n;                                           SUPPLIEDP (O? . G08))\n;   (Z   . G06)      (POSITION 5)\n;   (U   . G07)      (POSITION 6 AUX T INIT 2)\n;   (O?  . G08)      (POSITION 7 OWNED T)\n;   (A   . G09)      (POSITION 8  OWNED T INIT (CAR G01))\n;   (B   . G10)      (POSITION 9  OWNED T INIT (CAADR G01))\n;   (C   . G11)      (POSITION 10 OWNED T INIT (CDADR G01))\n;   (D   . G12)      (POSITION 11 OWNED T INIT (CADDR G01))\n;   (E   . G13)      (POSITION 12 OWNED T INIT (CDDDR G01))\n;  )\n;\n;\n; &KEY variables work something like this:\n;\n; Given a lambda list like the following...\n;\n; (LAMBDA (&KEY ((:A A) \"a\" A?))\n;\n; a list is built as follows:\n;\n;\n;    The list           Plist of (CDR <--))\n;\n;  (\n;   (A   . G01)      (POSITION 1 KEY T KEYWORD :A INIT \"a\"\n;                                      SUPPLIEDP (A? . G02))\n;   (A?  . G02)      (POSITION 2 OWNED T)\n;  )\n;\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n#.(progn\n   (defvar ignore-list '(ignore ignored ignorable ignoreable\n                         *ignore* *ignored* *ignorable* *ignoreable*)\n    \"The possible lambda-list-arg names that are not to generate\n     an error when found more than once.\"\n   )\n   '(eval-when (compile) nil)\n  )\n\n(declare (special *destructuring-vars*))\n\n(defun zilcoarg (f x) ; F = the function name, X = the argument list\n (catch 'lambda-list-errors\n  (prog (l n argvars a min max mode opt aux auxvars restarg\n         init suppliedp supvars temp temp2 arglist-ok-p\n         allow-other-keys-p key keyword keyvars\n         *destructuring-vars*)\n\n       (setq n 1 l x)\n\n       (unless (listp x)\n\n ; If the arglist is not NIL or a list, this is a LEXPR.\n\n ;;; Note: There is no possible lossage by using the same property name\n ;;;       \"LEXPRARG\" because (cdar argvars) is always a fresh gensym.\n\n               (cond\n                ((or\n                     (not (symbolp x))\n                     (eq (pbind x) x)\n                 )\n                 (princ \"Error: \")\n                 (prin1 x)\n                 (princ \" is an invalid lambda list.\")\n                 (terpri)\n                 (return nil)))\n               (setq argvars (list (setq temp (zilcoarg1 x 1 nil))))\n               (putprop f 0 'minargs)\n               (putprop f 0 'maxargs)\n               (remprop f   'restarg)\n               (putprop f argvars 'parms) ; Singleton, needn't nreverse.\n               (putprop f x 'lexprarg)\n               (putprop (cdr temp) t 'lexprarg)\n               (return t)\n       )\n\n  loop (or l (go process-return))\n       (when (atom l)\n             (setq a l l '(nil)); to force processing thru to end\n             (go make-&rest-arg))\n       (setq a (car l))\n       (when (llkeywdp a) ; If it's a lambda list keyword\n             (case a\n                   (&optional         (go process-&optional))\n                   ((&rest &body)     (go process-&rest))\n                   (&aux              (go process-&aux))\n                   (&key              (go process-&key))\n                   (&allow-other-keys (go process-&allow-other-keys))\n                   (t\n                    (princ \"Error: Unsupported LAMBDA list keyword: \")\n                    (prin1 a)\n                    (terpri)\n                    (return nil))))\n\n  ; At this point, the mode should not be &REST.  If the mode was\n  ; set to &REST, control would have gone to CREATE-PARM.\n  ; (Let's hear it for structured programming!!!)\n\n  (when (eq mode '&rest)\n        (princ \"Error:  Too many &REST args in lambda list.\")\n        (terpri)\n        (return nil))\n\n  create-parm\n\n       (cond\n             ((consp a)                ; List in &optional or &aux mode.\n              (case mode\n                    (&aux\n                     (setq init (cdr a))\n                     (cond\n                      ((null init)\n                       (setq a (car a)))\n                      ((or (atom init) (cdr init))\n                       (go bad-argument))\n                      (t\n                       (setq a (car a))\n                       (setq init (car init)))))\n                    (&optional\n                     (setq init (cdr a) suppliedp nil)\n                     (cond\n                      ((null init)\n                       (setq a (car a)))\n                      ((atom init)\n                       (go bad-argument))\n                      ((null (cdr init))\n                       (setq a (car a) init (car init)))\n                      ((null (cddr init))\n                       (psetq a (car a) init (car init)\n                                        suppliedp (cadr init)))\n                      (t\n                       (go bad-argument))))\n                    (&key\n                     (setq init (cdr a) suppliedp nil)\n                     (cond\n                      ((null init)\n                       (setq a (car a)))\n                      ((atom init)\n                       (go bad-argument))\n                      ((null (cdr init))\n                       (setq a (car a) init (car init)))\n                      ((null (cddr init))\n                       (psetq a (car a) init (car init)\n                                        suppliedp (cadr init)))\n                      (t\n                       (go bad-argument))))\n                    (t ; Mode not optional or aux, just required arg\n                     (setq init nil suppliedp nil))))\n             (t   ; A is an atom.\n              (setq init nil suppliedp nil)))\n;\n; Now, A may be either an atom or still a cons.  If it is still a cons\n; it needs destructuring.\n;\n       (case mode\n        ((nil)\n              (push (zilcoarg1 a n nil) argvars)\n              (setq n (1+ n))\n        )\n        (&rest\n              (setq restarg (zilcoarg1 a nil nil))\n        )\n        (&aux\n              (push (cons a init) auxvars)\n        )\n        (&optional\n              (push (setq temp (zilcoarg1 a n '&optional init))\n                    argvars)\n              (setq n (1+ n))\n              (when suppliedp (setq temp2 (zilcoarg1 suppliedp nil nil))\n                              (push temp2 supvars)\n                              (putprop (cdr temp) temp2 'suppliedp))\n        )\n        (&key\n              (if (consp a)\n                  (if (consp (cdr a))\n                      (setq keyword (car a) a (cadr a))\n                      (setq keyword (keywordify (car a)) a (car a)))\n                  (setq keyword (keywordify a)))\n              (push (setq temp (zilcoarg1 a nil '&key init))\n                    keyvars)\n              (unless (keywordp keyword)\n               (princ \"Error: &KEY keyword is not a keyword: \")\n               (prin1 keyword)\n               (terpri)\n               (return nil))\n              (putprop (cdr temp) keyword 'keyword)\n              (when suppliedp (setq temp2 (zilcoarg1 suppliedp nil nil))\n                              (push temp2 supvars)\n                              (putprop (cdr temp) temp2 'suppliedp))\n        )\n        (t\n              (princ \"Error: Lambda list args not allowed after \")\n              (prin1 mode)\n              (terpri)\n              (return nil)\n        )\n       )\n       (setq l (cdr l))\n       (go loop)\n\n process-&optional\n\n       (when opt\n             (princ \"Error: Duplicate \\\"&OPTIONAL\\\" in lambda list.\")\n             (terpri)\n             (return nil))\n       (when restarg\n             (princ\n              \"Error: \\\"&REST\\\" precedes \\\"&OPTIONAL\\\" in lambda list.\")\n             (terpri)\n             (return nil))\n       (when aux\n             (princ\n             \"Warning: \\\"&AUX\\\" precedes \\\"&OPTIONAL\\\" in lambda list.\")\n             (terpri)\n             (princ \"Binding in INIT forms may be incorrect.\")\n             (terpri))\n       (when key\n             (princ\n             \"Warning: \\\"&KEY\\\" precedes \\\"&OPTIONAL\\\" in lambda list.\")\n             (terpri)\n             (princ \"Binding in INIT forms may be incorrect.\")\n             (terpri))\n       (setq mode '&optional\n             opt t)\n       (or min (setq min (1- n)))\n       (setq l (cdr l))\n       (go loop)\n\n process-&aux\n\n       (when aux\n             (princ \"Error: Duplicate \\\"&AUX\\\" in lambda list.\")\n             (terpri)\n             (return nil))\n       (setq mode '&aux\n             aux t)\n       (or max (setq max (1- n)))\n       (or min (setq min max))\n       (setq l (cdr l))\n       (go loop)\n\n process-&rest\n\n       (setq l (cdr l))\n       (unless (consp l)\n               (princ \"Warning: Missing &REST arg in lambda list.\")\n               (terpri)\n               (go loop))\n       (setq a (car l))\n\n make-&rest-arg\n\n       (when (llkeywdp a)\n             (princ \"Warning: Missing &REST arg in lambda list.\")\n             (terpri)\n             (go loop))\n       (when restarg\n             (princ \"Error: Too many &REST args in lambda list.\")\n             (terpri)\n             (return nil))\n       (when aux\n             (princ\n             \"Warning: \\\"&AUX\\\" precedes &REST arg in lambda list.\")\n             (terpri)\n             (princ \"Binding in INIT forms may be incorrect.\")\n             (terpri))\n       (when key\n             (princ\n             \"Warning: \\\"&KEY\\\" precedes &REST arg in lambda list.\")\n             (terpri)\n             (princ \"Binding in INIT forms may be incorrect.\")\n             (terpri))\n       (or max (setq max (1- n)))\n       (or min (setq min max))\n       (setq mode '&rest\n             restarg a)\n       (go create-parm)\n\n process-&key\n\n       (when key\n             (princ \"Error: Duplicate \\\"&KEY\\\" in lambda list.\")\n             (terpri)\n             (return nil))\n       (setq mode '&key\n             key t)\n       (or max (setq max (1- n)))\n       (or min (setq min max))\n       (setq l (cdr l))\n       (go loop)\n\n process-&allow-other-keys\n\n       (when allow-other-keys-p\n        (princ \"Error: Duplicate \\\"&ALLOW-OTHER-KEYS\\\" in lambda list.\")\n        (terpri)\n        (return nil))\n       (setq mode '&allow-other-keys\n             allow-other-keys-p t)\n       (setq l (cdr l))\n       (go loop)\n\n process-return\n\n       (and key\n            (null restarg)\n            (setq restarg (zilcoarg1 (gensym) nil nil)))\n\n       (or min (setq min (1- n)))\n       (or max (setq max (1- n)))\n       (putprop f min 'minargs)\n       (putprop f max 'maxargs)\n       (putprop f restarg 'restarg)\n       (putprop f allow-other-keys-p 'allow-other-keys-p)\n       (setq n max)\n       ;\n       ; Assign &REST variable.\n       ;\n       (when restarg\n             (setq n (1+ n))\n             (putprop (cdr restarg) n 'position)\n             (push restarg argvars)\n       )\n       ;\n       ; Assign &KEY variables.\n       ;\n       (when keyvars\n             (setq keyvars (nreverse keyvars))\n             (loop for p in keyvars do\n              (setq n (1+ n))\n              (putprop (cdr p) n 'position)\n              (push p argvars)\n             )\n       )\n       ;\n       ; Assign \"supplied-p\" variables.\n       ;\n       (when supvars\n             (setq supvars (nreverse supvars))\n             (loop for s in supvars do\n              (setq n (1+ n))\n              (putprop (cdr s) n 'position)\n              (putprop (cdr s) t 'owned)\n              (push s argvars)\n             )\n       )\n       ;\n       ; Assign &AUX variables.\n       ;\n       (when auxvars\n             (loop for (var . init) in (nreverse auxvars) do\n              (setq n (1+ n))\n              (push (zilcoarg1 var n '&aux init) argvars)\n             )\n       )\n       ;\n       ; Process destructured variables.\n       ;\n       (when *destructuring-vars*\n             (setq *destructuring-vars* (nreverse *destructuring-vars*))\n             (loop for p in *destructuring-vars* do\n              (setq n (1+ n))\n              (putprop (cdr p) n 'position)\n              (push p argvars)\n             )\n       )\n       (setq argvars (nreverse argvars))\n       (setq arglist-ok-p t)\n       (loop for l on argvars\n        (let (\n              ((a . b) (car l))\n             )\n         (when (or (not (symbolp a))\n                   (eq (pbind a) a))\n               (princ \"Error: \")\n               (prin1 a)\n               (princ \" is an invalid lambda list argument.\")\n               (terpri)\n               (setq arglist-ok-p nil)\n         )\n         (when (and (assq a (cdr l))\n                    (not (memq a '#.ignore-list)))\n               (princ \"Error: \")\n               (prin1 a)\n               (princ \" is a duplicate lambda list argument.\")\n               (terpri)\n               (setq arglist-ok-p nil)\n         )\n        )\n       )\n       (putprop f argvars 'parms)\n       (return arglist-ok-p)\n\n bad-argument\n\n       (princ \"Error: \")\n       (prin1 a)\n       (princ \" is an invalid lambda list element.\")\n       (terpri)\n       (return nil)\n\n  )\n )\n)\n\n(defun zilcoarg1 (v n mode &optional init)\n (let ((a (gensym)))\n      (putprop a n 'position)\n      (case mode\n       (&aux\n                  (putprop a t    'aux)\n                  (putprop a init 'init))\n       (&optional\n                  (putprop a t    'optional)\n                  (putprop a init 'init))\n       (&key\n                  (putprop a t    'key)\n                  (putprop a init 'init))\n       (destructuring\n                  (putprop a t    'owned)\n                  (putprop a init 'init))\n      )\n      (cond\n       ((and v (atom v))\n        (cons v a))\n       (t                        ; If var null or a list, destructure.\n        (let ((p (cons (gensym) a)))\n             (get-destructuring-stuff p v)\n             p)))))\n\n(defun get-destructuring-stuff (p v) ; p = the pair, v = the de-form\n (let (\n       (vars (build-destructure-list (car p) v nil))\n      )\n      (putprop (cdr p) (nreverse vars) 'destrvars)))\n\n(defun build-destructure-list (a b c)\n ;\n ; A - the generated variable name used to build initialization forms\n ;\n ; B - the destructuring form, e.g. (X (Y Z) W)\n ;\n ; C - the list so far\n ;\n (prog (d mode form init suppliedp opt aux rest key allow-other-keys-p\n        restform restarg keyword keyhacks)\n   loop\n       (when (null b)\n             (go cleanup))\n       (when (atom b)\n             (let (\n                   (x (zilcoarg1 b nil 'destructuring a))\n                  )\n                  (push x *destructuring-vars*)\n                  (push x c)\n             )\n             (go cleanup))\n       (setq d (car b))\n       (when (llkeywdp d)\n             (case d\n                  (&optional         (go destructure-&optional))\n                  ((&rest &body)     (go destructure-&rest))\n                  (&aux              (go destructure-&aux))\n                  (&key              (go destructure-&key))\n                  (&allow-other-keys (go destructure-&allow-other-keys))\n                  (t\n                   (princ \"Error: \")\n                   (prin1 d)\n                   (princ \" is an unsupported lambda list keyword.\")\n                   (terpri)\n                   (throw 'lambda-list-errors nil))))\n\n       (if (consp d)\n        then\n            (case mode\n                  (&aux\n                   (setq init (cdr d) suppliedp nil)\n                   (cond\n                    ((null init)\n                     (setq d (car d)))\n                    ((or (atom init) (cdr init))\n                     (go bad-argument))\n                    (t\n                     (setq d (car d))\n                     (setq init (car init)))))\n                  (&optional\n                   (setq init (cdr d) suppliedp nil)\n                   (cond\n                    ((null init)\n                     (setq d (car d)))\n                    ((atom init)\n                     (go bad-argument))\n                    ((null (cdr init))\n                     (setq d (car d) init (car init)))\n                    ((null (cddr init))\n                     (psetq d (car d) init (car init)\n                                      suppliedp (cadr init)))\n                    (t\n                     (go bad-argument))))\n                  (&key\n                   (setq init (cdr d) suppliedp nil)\n                   (cond\n                    ((null init)\n                     (setq d (car d)))\n                    ((atom init)\n                     (go bad-argument))\n                    ((null (cdr init))\n                     (setq d (car d) init (car init)))\n                    ((null (cddr init))\n                     (psetq d (car d) init (car init)\n                                      suppliedp (cadr init)))\n                    (t\n                       (go bad-argument))))\n                  (t ; Mode not optional or aux, just required arg\n                   (setq init nil suppliedp nil)))\n        else\n            (setq init nil suppliedp nil)\n        endif\n       )\n\n       (case mode\n             (&key\n              (if (consp d)\n                  (if (consp (cdr d))\n                      (setq keyword (car d) d (cadr d))\n                      (setq keyword (keywordify (car d)) d (car d)))\n                  (setq keyword (keywordify d)))\n              (unless (keywordp keyword)\n               (princ \"Error: &KEY keyword is not a keyword: \")\n               (prin1 keyword)\n               (terpri)\n               (throw 'lambda-list-errors nil))\n              (push `(,d ,keyword ,init ,suppliedp) keyhacks)\n              (go continue)\n             )\n       )\n\n\n       ;\n       ; Create initialization forms to be evaluated to set the\n       ; destructured variables.\n       ;\n       ; Yes, I know that the code will be horrible, especially for\n       ; recursively nested destructuring and particularly for\n       ; &optional (yeccch!), but why bother to come up with a\n       ; clever hack for something that will be used relatively\n       ; rarely?  Common LISP doesn't even require it except for\n       ; DEFMACRO anyhow.\n       ;\n       (setq form\n        (case mode\n              ((nil)     `(car ,a))\n              (&optional `(cond (,a (car ,a)) (t ,init)))\n              (&rest     a)\n              (&aux      init)\n              (t\n               (princ \"Error: Args not permitted in lambda list after \")\n               (prin1 mode)\n               (terpri)\n               (throw 'lambda-list-errors nil))))\n\n       (when (and (consp d) (memq mode '(&optional &aux &rest)))\n             (let* ((g (gensym))\n                    (x (zilcoarg1 g nil 'destructuring form)))\n                   (push x *destructuring-vars*)\n                   (push x c)\n                   (setq form g))\n       )\n\n       (setq c (build-destructure-list form d c))\n       (when suppliedp\n             (setq form `(cond (,a t) (t nil)))\n             (let ((x (zilcoarg1 suppliedp nil 'destructuring form)))\n                  (push x *destructuring-vars*)\n                  (push x c)))\n\n       (setq a `(cdr ,a))\n\n continue\n\n       (setq b (cdr b))\n       (go loop)\n\n destructure-&optional\n\n       (when opt\n             (princ\n\"Error: Duplicate \\\"&OPTIONAL\\\" in destructuring lambda list.\"\n             )\n             (terpri)\n             (throw 'lambda-list-errors nil))\n       (when rest\n             (princ\n\"Error: \\\"&REST\\\" precedes \\\"&OPTIONAL\\\" in destructuring lambda list.\"\n             )\n             (terpri)\n             (throw 'lambda-list-errors nil))\n       (when aux\n             (princ\n\"Warning: \\\"&AUX\\\" precedes \\\"&OPTIONAL\\\" in destructuring lambda list.\"\n             )\n             (terpri)\n             (princ \"Binding in INIT forms may be incorrect.\")\n             (terpri))\n       (setq mode '&optional\n             opt t)\n       (go continue)\n\n destructure-&aux\n\n       (when aux\n             (princ\n\"Error: Duplicate \\\"&AUX\\\" in destructuring lambda list.\"\n             )\n             (terpri)\n             (throw 'lambda-list-errors nil))\n       (setq mode '&aux\n             aux t)\n       (or restform (setq restform a))\n       (go continue)\n\n destructure-&rest\n\n       (when rest\n             (princ\n\"Error: Too many &REST args in destructuring lambda list.\"\n             )\n             (terpri)\n             (throw 'lambda-list-errors nil))\n       (when aux\n             (princ\n\"Warning: \\\"&AUX\\\" precedes \\\"&REST\\\" in destructuring lambda list.\"\n             )\n             (terpri)\n             (princ \"Binding in INIT forms may be incorrect.\")\n             (terpri))\n       (setq mode '&rest\n             rest t\n             restform a)\n       (unless (cdr b)\n             (princ\n\"Error: Invalid destructuring lambda list syntax with \\\"&REST\\\".\"\n             )\n             (terpri)\n             (throw 'lambda-list-errors nil))\n       (go continue)\n\n destructure-&key\n\n       (when key\n             (princ\n\"Error: Duplicate \\\"&KEY\\\" in destructuring lambda list.\"\n             )\n             (terpri)\n             (throw 'lambda-list-errors nil))\n       (setq mode '&key\n             key t)\n       (or restform (setq restform a))\n       (go continue)\n\n destructure-&allow-other-keys\n\n       (when allow-other-keys-p\n             (princ\n\"Error: Duplicate \\\"&ALLOW-OTHER-KEYS\\\" in destructuring lambda list.\"\n             )\n             (terpri)\n             (throw 'lambda-list-errors nil))\n       (setq mode '&allow-other-keys\n             allow-other-keys-p t)\n       (go continue)\n\n bad-argument\n\n       (princ \"Error: \")\n       (prin1 d)\n       (princ \" is an invalid destructuring lambda list element.\")\n       (terpri)\n       (throw 'lambda-list-errors nil)\n\n cleanup\n\n       (when keyhacks\n\n        (unless restarg\n         (setq restarg (gensym))\n         (let ((x (zilcoarg1 restarg nil 'destructuring restform)))\n              (push x *destructuring-vars*)\n              (push x c)\n              (setq restform restarg)))\n\n        (loop for (dd kk ii ss) in (nreverse keyhacks) do\n         (let ((ff (let ((g (gensym)))\n                        `(let ((,g (getk ,restarg ',kk)))\n                              (cond\n                               (,g (car ,g))\n                               (t ,ii))))))\n          (when (consp dd)\n                (let* ((g (gensym))\n                       (x (zilcoarg1 g nil 'destructuring ff)))\n                      (push x *destructuring-vars*)\n                      (push x c)\n                      (setq ff g))\n          )\n          (setq c (build-destructure-list ff dd c))\n          (when ss\n                (setq ff `(cond ((getk ,restarg ',kk) t) (t nil)))\n                (let ((x (zilcoarg1 ss nil 'destructuring ff)))\n                     (push x *destructuring-vars*)\n                     (push x c)))\n\n        )))\n\n       (return c)\n\n\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOAUV": {"ttr": 7683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x00\\x00\\x87\\x06/\\x00\\x89\\x15o\\x11\\x06\\x00\\x8b\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1987-03-03T00:00:00", "modifydate": "1989-06-05T11:06:00", "lines": 139, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* ZILCOAUV                                                            *\n;*                                                                     *\n;***********************************************************************\n;\n;;;\n;;; This function adds an unbound variable to the list of atoms and\n;;; to the appropriate lists of unbound variables.  Arguments:\n;;;\n;;; arg 1 - the symbol representing the variable to be added\n;;; arg 2 - the environment\n;;;\n;;; ZILCOAUV first of all creates an atom for the variable.\n;;; It then also builds a \"fake binding\" pair to return to the caller.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zilcoauv (varname e &aux atompair binding)\n\n (let ((atompair (zilcoadd varname nil))  ; Create an atom for it\n       (binding  nil)\n      )\n\n   (putprop (cdr atompair) t 'real)   ; Indicate it's really used\n\n   ;\n   ; Add this to the appropriate list of unbound variables and to the\n   ; appropriate list of free variables.\n   ;\n   ; Which list depends on whether the variable was declared to be\n   ; SPECIAL or not (if it was not declared, it attains one of these\n   ; by default - generally SPECIAL).\n   ;\n   ; If the variable is globally proclaimed SPECIAL\n   ; (i.e. it's in special-freevars),\n   ; or the variable is pervasively SPECIAL, then mark the\n   ; \"fake binding\" SPECIAL.\n   ;\n   ; If the variable is lexically bound across FUNARG boundaries,\n   ; then mark the associated binding FLUID so it'll get compiled\n   ; properly (closed over).  The name \"FLUID\" is a misnomer, but\n   ; dates back to the original design of ZIL in the bad old days.\n   ;\n   ; Otherwise, the variable is an undeclared and unbound variable.\n   ;\n   ; For now, if it hasn't been declared special or fluid, assign it\n   ; a default declaration of SPECIAL (or whatever the default-binding\n   ; property is defined to be at compiler initialization time).\n   ; This can be controlled (badly) by a\n   ; (declare (default-binding ...)) specification.\n   ;\n\n   (cond\n\n    ((or (memq atompair special-freevars) ; Globally or locally special?\n         (memq varname (zilcec-specials (car e))))\n     (setq binding (cons varname (gensym)))\n     (zccbind binding 'special))\n\n    ((do ((cec (zilcec-creator (car e))   ; Heap-consed lexical funarg?\n               (zilcec-creator cec)))\n         ((null cec) nil)\n         (when (setq binding (assq varname (zilcec-bindings cec)))\n               (return binding)))\n     (zccbind binding 'fluid)\n     (let ((owner (or (get (cdr binding) 'owner)\n                      (zerror \"Binding has no owner\" binding))))\n           (when debug\n                 (cterpri)\n                 (princ \"ZILCOAUV fluidizing binding \")\n                 (prin1 binding)\n                 (terpri)\n                 (princ \"Atompair: \")\n                 (prin1 atompair)\n                 (terpri)\n                 (princ \"Owner: \")\n                 (prin1 owner)\n                 (terpri)\n                 (princ \"Owner's atoms so far: \")\n                 (prin1 (get (car owner) 'newatoms))\n                 (terpri)\n           )\n           (pushnew (car atompair) (get (car owner) 'newatoms)\n                                   :test #'eq)))\n\n    (t                                       ; Undeclared?\n     (setq binding (cons varname (gensym)))\n     (putprop (cdr binding) t 'implicitly-free)\n     (let ((db (get '*zilco* 'default-binding)))\n          (when db\n           (cterpri)\n           (princ \"Warning:  Undeclared non-local variable, assuming \")\n           (princ db)\n           (princ \" - \")\n           (prin1 varname)\n           (terpri)\n          )\n          (case db\n                (special (zccbind binding 'special))\n                (t       (modq body\n              `(zerror \"Non-local variable not declared SPECIAL\"\n                                         ,varname)))))))\n\n   ;\n   ; If this is a special binding, add the atom to the list of\n   ; atoms that are unbound specials in this function.\n   ;\n   ; If this is a lexical binding, add the atom to the list of\n   ; atoms that are unbound lexicals in this function.\n   ;\n\n   (case (car (get (cdr binding) 'bindingtype))\n    ((special)\n     (or (memq atompair special-unbounds)\n         (modq special-unbounds atompair)))\n    ((fluid)\n     (or (memq atompair fluid-unbounds)\n         (modq fluid-unbounds atompair)))\n   )\n\n   binding ; Return the \"fake binding\" pair.\n\n ))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOCOM": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x06\\x02\\xcf\\x02{\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:06:00", "lines": 719, "newlines": 635, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"ZILCOCOM\"\n; The driver function and pseudocode builder for the compiler.\n;\n\n; Compile and generate source code for input program.\n; The input, in file \"SRC\", contains inline code and\n; function definitions (identified by \"DEFUN\").\n; Output, file \"CODE\", contains assembler source code.\n; Each \"DEFUN\" encountered at the top level causes\n; an internal subroutine to be compiled.\n; The argument \"EXEC\" specifies whether an executable\n; program or a stand-alone function is to be created.\n;\n;\n; Note:      MACRO properties are now recognized by the compiler at\n;            compile time, as well as CMACRO properties.  This means\n;            that DEFMACRO's evaluated at compile time create macro\n;            definitions that are used in compilation; there is no\n;            way to avoid this.  CMACRO's are still supported for\n;            compatibility and as a means of defining compiler-only\n;            optimizations of functions.  See ZILCOMEX.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/13/88 - Top-level PROGRAM transform now output to CTRN file.     *\n;* 06/23/88 - Support for PROG and RETURN removed.  ZCCFPRT absorbed.  *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(declare (special debug program allsubrs alfatoms numatoms alllists\n                  special-freevars intfuncs zdef codebody\n                  processing-macros))\n\n(defun zilcocom (fname kind debug)\n (prog (a c m e z\n        exec\n        processing-macros\n        codebody\n        defuns\n        program\n        allsubrs\n        alfatoms\n        numatoms\n        alllists\n        special-freevars\n        intfuncs\n        zdef\n        ctrnp\n       )\n\n   (setq c        (list nil)\n         ; Eventually, e will be set to the global contour,\n         ; whatever that is.\n         e        nil\n         exec     (eq kind 'program)\n         codebody (list 'progn)\n         defuns   (list nil)\n         program  (if exec fname nil)\n         allsubrs (list nil)\n         alfatoms (list nil)\n         numatoms (list nil)\n         alllists (list nil)\n         special-freevars (list nil)\n         intfuncs (list nil)\n         zdef (ncons nil)\n         ctrnp (ofilep 'ctrn)\n   )\n\n;\n; Establish some compilation settings.\n;\n; AUTOFUNCALL will never default to NIL, always T.\n;\n; In fact, AUTOFUNCALL will be phased out, as AUTOSPECIAL already has.\n;\n\n   (remprop '*zilco* 'error-code)\n   (defprop *zilco* t autofuncall)\n   (putprop '*zilco* fname 'fname)\n\n;\n; Read input from macro file CMAC, if present.  Note that any input\n; from this file other than DEFMACRO's and DEFLOAD's is assumed to\n; be eval-when (compile) stuff.\n;\n\n   (setq processing-macros t)\n\n   (unless (ifilep 'cmac)\n    (princ \"Compilation is not using any locally defined macros.\")\n    (terpri)\n    (go mnocmac))\n\n  mloop\n\n   (unless (ok (setq a (read 'cmac)))\n    (princ \"Syntax error in macro file.\")\n    (terpri)\n   )\n   (and (eof 'cmac) (go mfinish))\n   (catch nil (top-level-compile a c exec fname e))\n   (go mloop)\n\n  mfinish\n\n   (close 'cmac)\n\n  mnocmac\n\n   (setq processing-macros nil)\n\n;\n; If this compilation is of a module, build a function that loads all\n; the forms in the file, and also build definitions for compiled\n; functions within the file.\n;\n   (when (eq kind 'module)\n         (zilcocom-process-module c exec fname e)\n         (go finish)\n   )\n\n;\n; Otherwise, proceed with normal compilation processing.\n;\n; End of file on source input may be indicated by the top-level\n; function (END).  Top-level macros cannot generate this call.\n;\n\n  loop\n   (unless (ok (setq a (read 'src)))\n    (if (eof 'src)\n        (go finish)\n        (go loop)))\n   (and (eof 'src)       (go finish))\n   (and (equal a '(end)) (go finish))\n   (catch nil (top-level-compile a c exec fname e))\n   (go loop)\n\n  finish\n\n   (close 'src)\n\n   (if (get '*zilco* 'error-code) (go blowup))\n\n   (when ctrnp\n         (terpri 'ctrn)\n         (princ  \";;; *** Compiler transformations generated follow ***\"\n                 'ctrn)\n         (terpri 'ctrn)\n         (terpri 'ctrn)\n   )\n\n;;;\n;;; For all the DEFUN's collected, process their contents so that we\n;;; know that they exist and the number of args they take.\n;;;\n\n   (dolist (x (cdr c))\n    (let ((cexpr (get x 'cexpr)))\n     (when cexpr\n\n;;; Fully expand and transform the definition.\n\n      (putprop x (setq cexpr (zilcotrn cexpr debug)) 'cexpr)\n\n;;; If a transformation output file is present,\n;;; dump the transformation to the file.\n\n      (when ctrnp\n            (terpri 'ctrn)\n            (princ \";;; Transformed function definition of \" 'ctrn)\n            (prin1 x 'ctrn)\n            (terpri 'ctrn)\n            (terpri 'ctrn)\n            (pprint cexpr 'ctrn)\n            (terpri 'ctrn)\n       )\n\n;;; Analyze the parameter list and establish the number of arguments\n\n      (unless\n       (zilcoarg x (cadr cexpr)) ; Valid arg list for function\n       (princ \"Error: Bad argument list for function \")\n       (prin1 x)\n       (terpri)\n       (zilcoerr 12)\n      )\n     )))\n\n   (terpri)\n   (princ \"Initiating P-code phase of compilation.\")\n   (terpri)\n   (terpri)\n   (if exec       ; If a \"program\" is to be compiled\n    then\n     (if (cdr codebody) ; If top-level code was found\n      then              ; (it should have been), compile a \"program\".\n        (setq z (zilcotrn `(lambda () ,codebody) debug))\n        (setq m (zccexpr program\n                         z    ; transformed top-level program\n                         t    ; MAIN = YES\n                         nil  ; ALONE = NO\n                         (cons (zccmkcec 'defun e) e)))\n        (when ctrnp\n              (terpri 'ctrn)\n              (princ \";;; Transformed definition of program \" 'ctrn)\n              (prin1 program 'ctrn)\n              (terpri 'ctrn)\n              (terpri 'ctrn)\n              (pprint z 'ctrn)\n              (terpri 'ctrn)\n        )\n        (if debug (dump-compile m))\n      else\n        (princ\n \"Error: PROGRAM specified, but no top-level (non-DEFUN) source code.\")\n        (terpri)\n        (zilcoerr 12)\n        (go blowup)\n      endif\n     )\n    else          ; A \"function\" is to be compiled\n      (unless (and program (get program 'cexpr))\n           (princ \"Error: Missing or invalid function definition for \")\n           (prin1 fname)\n           (terpri)\n           (zilcoerr 12)\n           (go blowup))\n      (setq m (zccfunc program t t e)) ; Compile the main \"function\".\n      (if debug (dump-compile m))\n    endif\n   )\n   (princ (if exec \"Main program \" \"Main function \"))\n   (princ \"P-code compilation complete for \")\n   (prin1 (car (get m 'name)))\n   (terpri)\n   (dolist (x (cdr c))               ; Compile all subfunctions.\n           (or (get x 'cmacro)       ; Don't compile macros.\n               (eq x program)        ; Don't redo main function.\n               (let ((y (zccfunc x nil (not exec) e)))\n                    (modq defuns y)\n                    (if debug (dump-compile y))\n                    (princ \"P-code compilation complete for \")\n                    (prin1 x)\n                    (terpri))))\n   (terpri)\n   (if (get '*zilco* 'error-code) (go blowup))\n\n   (when ctrnp (close 'ctrn 'output))\n\n   (princ \"Initiating code generation phase.\")\n   (terpri)\n   (terpri)\n   (zilcogen m)                      ; Generate code for main fun/pgm.\n   (princ \"Code generated for main \")\n   (princ (if exec \"program \" \"function \"))\n   (prin1 (car (get m 'name)))\n   (terpri)\n\n;;;\n;;; Generate code for all functions which are not macros.\n;;;\n   (dolist (x (cdr defuns))\n           (zilcogen x)\n           (princ \"Code generated for function \")\n           (prin1 (car (get x 'name)))\n           (terpri))\n   (if (get '*zilco* 'error-code) (go blowup))\n   (princ \"         END\" 'code)  ; Generate assembler END statement.\n   (terpri 'code)\n   (close 'code 'output)\n   (terpri)\n   (return nil)\n\n  blowup\n\n   (princ \"Compilation terminated due to errors.\")\n   (terpri)\n   (throw 'zilcocom-error (get '*zilco* 'error-code))\n )\n)\n\n;**********************************************************************\n\n(declare (special loadlist complist)) ; for ZILCOMOD.\n\n(defun zilcocom-process-module (c exec fname e)\n (prog (loadlist complist form mainfunc)\n  loop (unless (ok (setq form (read 'src)))\n               (if (eof 'src)\n                   (go check-it-out)\n                   (go loop)))\n  check-it-out\n       (if   (or (eof 'src) (equal form '(end)))\n        then\n             (setq loadlist (nreverse loadlist)\n                   complist (nreverse complist)\n                   mainfunc\n                            `(defun ,fname ()\n\n#| This code has been removed.  If you want to herald your module,\n   do it yourself.\n\n                              (cterpri)\n                              (princ ,(string-append \"Loading module \"\n                                                     fname \".\"))\n                              (terpri)\n\n   End of suppressed heralding code.\n\n|#\n                              ,.loadlist  ; forms executed at load time\n                              ',fname ; return name of function as value\n                             )\n             )\n             (when debug\n                   (terpri)\n                   (princ \"Begin module debugging output.\")\n                   (terpri)\n                   (terpri)\n                   (princ \"Main (loadable) function follows:\")\n                   (terpri)\n                   (terpri)\n                   (pprint mainfunc)\n                   (terpri)\n                   (terpri)\n                   (princ \"Other (compilable) forms follow:\")\n                   (terpri)\n                   (terpri)\n                   (dolist (x complist) (pprint x) (cterpri))\n                   (terpri)\n                   (terpri)\n                   (princ \"End module debugging output.\")\n                   (terpri)\n             )\n             (top-level-compile mainfunc c exec fname e)\n             (dolist (x complist) (top-level-compile x c exec fname e))\n             (return)\n        else\n             (zilcomod form e)\n             (go loop)\n        endif\n       )\n )\n)\n\n;**********************************************************************\n\n;\n; This function handles anything (other than (END)) that can occur\n; at top level.  It is invoked recursively when a (PROGN ...)\n; form is encountered, which specifies that all forms within it are\n; to be treated as top-level (which enables DEFUN, etc.)\n;\n; % signifies something to be executed at compile time\n; e.g. (% PRINT \"Hi, I'm being compiled\")\n;\n; DEFUN signifies a function definition.\n;\n; (PROGN ...) signifies a list of top-level things.\n;\n\n(defun top-level-compile (f c exec fname e) ;\n (let ((a (zilcomex f t)))  ; top-level form after macro expansion\n  (cond\n   ((atom a)                (princ \"Ignoring atom \")\n                            (prin1 a)\n                            (princ \" found at top level.\")\n                            (terpri))\n   ((eq (car a) 'comment)   nil)\n   ((eq (car a) 'declare)   (zilcodcl (cdr a) exec e))\n   ((eq (car a) 'defload)   (zilcocom-defload (cdr a) fname e))\n   ((eq (car a) 'defun)     (zilcocom-defun a c exec fname e))\n   ((eq (car a) 'eval-when) (zilcocom-eval-when (cdr a) c exec fname e))\n   ((eq (car a) 'progn)     (dolist (x (cdr a))\n                             (top-level-compile x c exec fname e)))\n   (t                       (zilcocom-other a exec e)))))\n\n(defun zilcocom-eval-when (a c exec fname e)\n\n;\n; EVAL-WHEN is interpreted as follows:\n;\n; COMPILE - let the compiler evaluate it itself.\n;\n; EVAL    - ignore.\n;\n; LOAD    - process like usual top-level form.\n;\n\n (let* (\n        ((times . forms) a)\n        (compilep            (memq 'compile times))\n        (loadp               (memq 'load    times))\n       )\n       (loop for f in forms\n             when compilep do (catch nil (eval f))\n             when loadp    do (top-level-compile f c exec fname e)\n             finally       (return nil))))\n\n(defun zilcocom-defun (a c exec fname e)\n (prog (func args nargs body ftype)\n  (or (and (cdr a)\n           (cddr a)\n           (cdddr a))  (go bad-defun))\n  (setq func (cadr a))\n\n  ; Note: NIL is no longer a permissible function name for DEFUN.\n\n  (unless (and func (symbolp func))\n          (princ \"Error: Invalid DEFUN function name - \")\n          (prin1 func)\n          (terpri)\n          (zilcoerr 12) ; Set error switch on.\n          (return nil))\n\n  (when (and exec (eq func fname))\n        (princ \"Error: Internal function name \")\n        (prin1 func)\n        (princ \" conflicts with program name.\")\n        (terpri)\n        (zilcoerr 12) ; Set error switch on.\n        (return nil))\n\n  (setq args (caddr a))\n  (setq body (cdddr a))\n\n;\n; If the DEFUN was read from the macro file, assume it is a compile-time\n; DEFUN unless it is a DEFUN of a macro.\n;\n\n  (when (and processing-macros (neq args 'macro))\n        (catch nil (eval a))\n        (return)\n  )\n\n  (cond\n   ((eq args 'expr)  (setq ftype 'cexpr)  (desetq (args . body) body))\n   ((eq args 'macro) (setq ftype 'cmacro) (desetq (args . body) body))\n   ((eq args 'fexpr)\n    (princ \"Error: DEFUN of FEXPR cannot be compiled - \")\n    (prin1 func)\n    (terpri)\n    (zilcoerr 12)\n    (return nil))\n   ((or (consp args) (symbolp args))\n    (setq ftype 'cexpr))\n   (t\n    (princ \"Error: Bad DEFUN function type specified - \")\n    (prin1 ftype)\n    (terpri)\n    (zilcoerr 12)\n    (return nil))\n  )\n\n\n;;; If a macro, the argument list must be a list of 1 argument,\n;;; or a list of more than 1 argument where the first is NIL\n;;; (the latter being generated by DEFMACRO).\n\n  (when (and (eq ftype 'cmacro)         ; If a macro definition\n             (or (atom args) (and (car args) (cdr args))))\n        (princ \"Error: Bad argument list for macro \")\n        (prin1 func)\n        (terpri)\n        (zilcoerr 12)\n        (return nil))\n\n;;; Check to see if this function shadows an existing macro or defload.\n\n  (case (get func 'defined-by)\n        ((system)\n         (princ \"Warning: DEFUN overriding system definition for \")\n         (prin1 func)\n         (terpri)\n         (remprop func 'cmacro   )\n         (remprop func 'cautoload)\n         (remprop func 'compiler-transform)\n         (when (eq ftype 'cexpr)       ; Don't lose these properties if\n          (remprop func 'minargs)      ; a macro overrides a known ZIL\n          (remprop func 'maxargs)      ; function.  Someone may DEFLOAD\n          (remprop func 'restarg)      ; to the known function name.\n         )\n         (putprop func 'user 'defined-by) ; Say defined by user.\n        )\n        ((user)\n         (princ \"Error: Function \")\n         (prin1 func)\n         (princ \" is multiply defined in file.\")\n         (terpri)\n         (zilcoerr 12)\n         (return nil)\n        )\n  )\n\n;;; Simulate the DEFUN to define the function to the compiler.\n\n  (putprop func `(lambda ,args . ,body) ftype)\n\n;;; Some processing that used to be done here has been moved.\n\n  (modq intfuncs func)          ; Add to list of internal procedures\n\n  (when (eq func fname)         ; If DEFUN name matches source file\n        (if program             ; then if program name already set\n         then                   ; (may have been done by DEFLOAD)\n            (princ \"Error: Duplicate main function \")\n            (prin1 func)\n            (princ \" defined in input source.\")\n            (terpri)\n            (zilcoerr 12)\n            (return nil)\n         else\n            (setq program func)\n         endif\n        )\n  )\n  (modq c func)                ; Add function to list of functions\n  (when debug\n      (princ (if (eq ftype 'cmacro) \"Macro\" \"Function\"))\n      (princ \" definition found for \")\n      (prin1 func)\n      (terpri))\n  (return nil)\n\n bad-defun\n\n  (princ \"Invalid DEFUN syntax - definition ignored.\")\n  (terpri)\n  (zilcoerr 12)\n\n ) ; end PROG\n)\n\n;\n; This compiles the DEFLOAD special form.\n;\n\n(defun zilcocom-defload (x fname e)\n (if (or (null x)\n         (null (cdr x)))\n  then\n     (princ \"Too few arguments to DEFLOAD\")\n     (terpri)\n     (zilcoerr 12)\n  else\n  if (cddr x)\n  then\n     (princ \"Too many arguments to DEFLOAD\")\n     (terpri)\n     (zilcoerr 12)\n  else\n  if\n     (not (and (symbolp (car x))\n               (symbolp (cadr x))))\n  then\n     (princ \"Invalid argument(s) to DEFLOAD\")\n     (terpri)\n     (zilcoerr 12)\n  else\n     (when (eq (get (car x) 'defined-by) 'system)\n           (princ \"Warning: DEFLOAD overriding system definition for \")\n           (prin1 (car x))\n           (terpri)\n     )\n     ;\n     ; Don't change \"defined-by\" status.\n     ;\n     ; If it's \"defined-by system\", it won't hurt anything.\n     ;\n     ; If it's \"defined-by user\", don't reject it; it's legal to have\n     ;\n     ; (defload foobarbazfrob fbbf)\n     ; and\n     ; (defun foobarbazfrob (x) ...)\n     ;\n     ;\n     (putprop (car x) (cadr x) 'cautoload)\n     (putprop (car x) (get (cadr x) 'builtin) 'inline)\n     (putprop (car x) (get (cadr x) 'predicate) 'predicate)\n     (putprop (car x) (get (cadr x) 'compiler-transform)\n                      'compiler-transform)\n     (if   (eq (cadr x) fname)\n      then\n           (if (and program (neq program (car x)))\n            then\n             (princ \"Error: Main function \")\n             (prin1 fname)\n             (princ \" is multiply defined.\")\n             (terpri)\n             (zilcoerr 12)\n            else\n             (setq program (car x))  ; Indicate main program found.\n           )\n      else\n      if   (eq (car x) fname)\n      then\n       (princ \"Error: DEFLOAD not permitted for main function \")\n       (prin1 fname)\n       (terpri)\n       (zilcoerr 12)\n      )\n  endif\n )\n)\n\n;\n; This compiles non-function code found at top level, which is valid\n; only when the entity being compiled is a PROGRAM (EXEC = T).\n;\n(defun zilcocom-other (a exec e)\n (cond (exec (modq codebody a))\n       (t    (princ \"Input other than function definition found.\")\n             (terpri)\n             (princ \"Check your source for errors,\")\n             (terpri)\n             (princ \"or specify MODULE or PROGRAM instead of FUNCTION.\")\n             (terpri)\n             (throw 'zilcocom-error 12))))\n\n(defun dump-compile (m)\n (terpri)\n (princ \"Compilation dump for \")\n (prin1 (get m 'name))\n (terpri)\n (princ \"Property list:\")\n (terpri)\n (pprint (symbol-plist m))\n (terpri)\n (terpri)\n (fprint \"Dump of P-code follows:\"\n         (get m 'body)\n         '(begincall begintag beginblock begininline begintail beginlam)\n         '(call      endtag   endblock   inline      tailrecur endlam))\n (fprint \"Dump of \\\"TAILRECUR\\\" follows:\"\n         (get m 'tailrecur) nil nil)\n (fprint \"Dump of subroutine table follows:\"\n         (cdr allsubrs) nil nil)\n (fprint \"Dump of symbol table follows:\"\n         (cdr alfatoms) nil nil)\n (fprint \"Dump of number/string table follows:\"\n         (cdr numatoms) nil nil)\n (fprint \"Dump of list table follows:\"\n         (cdr alllists) nil nil)\n (fprint \"Dump of free SPECIAL variables follows:\"\n         (cdr special-freevars) nil nil)\n (fprint \"Dump of non-local SPECIAL variables follows:\"\n         (cdr (get m 'special-unbounds)) nil nil)\n (fprint \"Dump of non-local LEXICAL variables follows:\"\n         (cdr (get m 'fluid-unbounds)) nil nil)\n (fprint \"Dump of internal functions follows:\"\n         (cdr intfuncs) nil nil)\n)\n\n;\n; \"FPRINT\"\n;\n; This function prints out pseudocode in readable format.\n; In fact, it prints out any list in readable format.\n;\n\n(defun fprint (msg l in out)\n (princ msg)\n (terpri)\n (terpri)\n (fprint1 l in out 1)\n (terpri)\n)\n\n(defun fprint1 (l i o n)\n (cond\n  ((null l) nil)\n  ((atom l) (prin1 l) (terpri))\n  (t (prog (n2)\n      (setq n2 n)\n      (cond\n       ((null l)           nil)\n       ((atom (car l))     nil)\n       ((memq (caar l) i)  (setq n2 (add1 n)))\n       ((memq (caar l) o)  (setq n2 (setq n (sub1 n))))\n      )\n      (zputfpo n)\n      (prin1 (car l))\n      (terpri)\n      (return (fprint1 (cdr l) i o n2))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Obsolete code...\n;\n;\n;;; If null function name (DEFUN NIL ...), generate a new name and\n;;; add to list of null functions (for which code generation is\n;;; to be bypassed).  More than one null function can exist.\n;\n; (or func (push (setq func (gensym)) nilfuncs))\n;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOCON": {"ttr": 7690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x17o\\x00\\x89\\x15o\\x11\\x06\\x00/\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-06-25T00:00:00", "modifydate": "1989-06-05T11:06:00", "lines": 47, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; ZILCOCON\n;;;\n;;; This function is used to determine if a given form is \"constant\"\n;;; (i.e. self-evaluating).\n;;;\n;;; It returns NIL if not, and a CONS whose CAR is the value of the\n;;; constant if it is.\n;;;\n;;; Note:  The CDR of the form is currently not used, but in the\n;;;        future may be set to the type of the constant.\n;;;        For this reason, the environment E must be passed, in\n;;;        case it contains type declarations or other meaningful\n;;;        stuff, you never know.\n;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(eval-when ()\n #.(defvar zilcocon-type nil \"Eventually will be T or (TYPEP object)\")\n)\n\n(defun zilcocon (x e)\n (cond\n  ((or (null x)\n       (and (symbolp x) (eq (pbind x) x))\n       (and (atom x) (not (symbolp x))))\n   (cons x #.zilcocon-type))\n  ((and (consp x)\n        (eq (car x) 'quote)\n        (consp (cdr x))\n        (null (cddr x)))\n   (cons (cadr x) #.zilcocon-type))\n  (t nil)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCODCL": {"ttr": 7692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x07\\x01\\n\\x00\\xd8\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:07:00", "lines": 266, "newlines": 216, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This functions handles the DECLARE special form, when it occurs     *\n;* at top level (not within a function).  Called by ZILCOCOM.          *\n;*                                                                     *\n;***********************************************************************\n;\n; Note: Errors cannot be signalled from within here.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/31/88 - Fixed bug whereby (DECLARE (VSSIZE ...)) didn't work.    *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zilcodcl (b    ;  the (headless) body of the DECLARE form\n                 exec ;  T = program, NIL = function\n                 e    ;  the environment (list of contours)\n                )\n\n;\n; Note that E (the list of contours) is null when this module is\n; called from ZILCOCOM.  In the future it may be called from\n; other places, though, so beware.\n;\n; In addition, in the future it may prove to be wiser to have\n; ZILCOCOM create a global contour which would be passed to\n; ZILCODCL as well as other processors of top-level forms.\n;\n (dolist (x b) (declare-process x exec e)))\n\n(defun declare-process (a exec e) ; a is a subform within the DECLARE,\n                                  ; e.g. (SPECIAL FOO BAR)\n (cond\n  ((null a) nil)\n  ((atom a) (declare-error \"Illegal DECLARE subform \" a))\n  (t\n   (case (car a)\n\n         ((special)\n                          (dolist (x (cdr a))\n                           (declare-process-variable x (car a) e)))\n\n         ((pdsize\n           cssize\n           vssize\n           acsize)        (declare-process-size a exec))\n\n         ; AUTOSPECIAL is obsolete.\n         ; AUTOFUNCALL is obsolete.\n\n         ((default-binding)\n                          (declare-process-prop (car a) (cdr a) e))\n\n         ; BASEREG is obsolete.\n\n;;;;;;;;;((basereg)       (mapc #'declare-process-basereg (cdr a)))\n\n         ((segment)       (mapc #'declare-process-segment (cdr a)))\n\n         ((nocompile)     (mapc #'declare-process-nocompile (cdr a)))\n\n         (t\n          (unless (memq (car a) (get '*zilco* 'unknown-declarations))\n                  (push (car a) (get '*zilco* 'unknown-declarations))\n                  (cterpri)\n                  (princ \"DECLARE (\") (prin1 (car a))\n                  (princ \") not handled by the ZIL compiler.\")\n                  (terpri)\n                  nil))))))\n;\n;***********************************************************************\n;*                                                                     *\n;* This function processes SPECIAL declarations.  It used to process   *\n;* FLUID declarations until we decided they were too bogus.            *\n;*                                                                     *\n;***********************************************************************\n;\n\n(declare (special atoms subrs)) ; Needed by ZILCOADD/ZILCOSYM.\n\n(defun declare-process-variable (a type e)\n (let ((atoms (list nil))\n       (subrs (list nil))\n      )\n  (cond\n   ((not (symbolp a))\n    (declare-error (string-append \"Invalid DECLARE \" type \" variable\")\n                   a))\n   (t\n\n    ; Add the variable to the appropriate list of free variables.\n\n    ; eventually will modify global contour specified in e?\n\n    (let ((c (zilcoadd a nil)))\n         (case type\n               (special\n                (or (assq c special-freevars)\n                    (modq special-freevars c)))\n               ))))))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This function processes xxSIZE declarations.                        *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun declare-process-size (a exec)\n (let (((type . z) a) sizval)\n  (cond\n   ((null z)   (declare-error \"Missing declaration value\" type))\n   ((cdr z)    (declare-error \"Too many declaration values\" type))\n   ((not exec) (declare-error \"Declaration valid in PROGRAM only\" type))\n   (t          (setq sizval (declare-size-value (car z)))\n               (if sizval (putprop '*zilco* sizval type))))))\n\n; This function takes values like 4K and returns values like 4096.\n\n(defun declare-size-value (x)\n (cond\n  ((integerp x) x)\n  ((symbolp x)\n   (let* (\n          (xlen (string-length (symbol-name x)))\n          (xval (make-number (string-substr x 1 (1- xlen))))\n          (xsuf (string-substr x xlen 1))\n         )\n         (cond\n          ((not (integerp xval))\n           (declare-error \"Invalid size specification\" x))\n          ((eql xsuf \"K\") (* xval 1024))\n          ((eql xsuf \"M\") (* xval #.(* 1024 1024)))\n          (t (declare-error \"Invalid size specification\" x)))))\n  (t (declare-error \"Invalid size specification\" x))))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This function processes SEGMENT declarations.                       *\n;*                                                                     *\n;* e.g. (DECLARE (SEGMENT (FOO 2) (BAR 3) (BAZ 1)) ...)                *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun declare-process-segment (a) ; process function segment declares\n (cond\n  ((or (atom a)\n       (null (cdr a))\n       (cddr a))   (declare-error \"Invalid DECLARE SEGMENT spec\" a))\n  (t (let (((fun num) a))\n          (cond\n           ((not (symbolp fun))\n            (declare-error \"Invalid DECLARE SEGMENT spec\" a))\n           ((or (not (fixnump num))\n                (< num 1))\n            (declare-error \"Invalid DECLARE SEGMENT spec\" a))\n           (t\n            (putprop fun num 'segment)))))))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This function processes NOCOMPILE declarations.                     *\n;*                                                                     *\n;* e.g. (DECLARE (NOCOMPILE FOO BAR (BAZ SETFMETHOD) ... ) ... )       *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defload member memqual) ; We use MEMBER with an EQUAL test.\n\n(defun declare-process-nocompile (a) ;\n (let ((l (get '*zilco* 'nocompile)))\n      (or (member a l)\n          (putprop '*zilco* (cons a l) 'nocompile))))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This function processes miscellaneous properties of *ZILCO*.        *\n;* (e.g. (DECLARE (AUTOFUNCALL T)) == (DEFPROP *ZILCO* T AUTOFUNCALL)  *\n;*                                                                     *\n;***********************************************************************\n;\n(defun declare-process-prop (prop vals e)\n (cond\n  ((null vals) (declare-error \"Missing declaration value\" prop))\n  ((cdr vals)  (declare-error \"Too many declaration values\" prop))\n  (t           (putprop '*zilco* (car vals) prop))))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This macro reports on errors detected processing DECLARE subforms.  *\n;* Note that true errors cannot be signalled, because the compilation  *\n;* must continue in any case.                                          *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro declare-error (arg1 &optional arg2)\n (let ((message (cond\n                 ((stringp arg1)\n                  (string-append arg1 \" - \"))\n                 ((and (consp arg1)\n                       (eq (car arg1) 'string-append))\n                  (append arg1 (list \" - \")))\n                 (t\n                  (zerror \"Arg 1 to DECLARE-ERROR not a string\" arg1)))))\n `(progn (cterpri)\n         (princ ,message)\n         ,(if arg2 `(prin1 ,arg2))\n         (terpri)\n         nil)))\n\n;\n; Obsolete code follows...\n;\n;***********************************************************************\n;*                                                                     *\n;* This function processes BASEREG declarations.                       *\n;*                                                                     *\n;* e.g. (DECLARE (BASEREG (FOO 2) (BAR 3) (BAZ 1)) ...)                *\n;*                                                                     *\n;***********************************************************************\n;\n;\n;(defun declare-process-basereg (a) ; process function basereg declares\n; (cond\n;  ((or (atom a)\n;       (null (cdr a))\n;       (cddr a))   (declare-error \"Invalid DECLARE BASEREG spec\" a))\n;  (t (let (((fun num) a))\n;          (cond\n;           ((not (symbolp fun))\n;            (declare-error \"Invalid DECLARE BASEREG spec\" a))\n;           (t (case num\n;                   ((2 3 4) (putprop fun num 'basereg))\n;                   ((1)     (remprop fun 'basereg)) ; 1 is the default\n;                   (t (declare-error \"Invalid DECLARE BASEREG spec\" a)\n;                   ))))))))\n;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOERR": {"ttr": 7695, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05\\x8f\\x00\\x89\\x15o\\x11\\x07\\x00\\x17\\x00\\x06\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-27T00:00:00", "modifydate": "1989-06-05T11:07:00", "lines": 23, "newlines": 6, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"SIGNAL-ERROR\"\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zilcoerr (code)\n (let ((c (get '*zilco* 'error-code)))\n      (when (or (null c) (> code c))\n            (putprop '*zilco* code 'error-code))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOGEN": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x07\\x00\\xab\\x00\\xb9\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:07:00", "lines": 171, "newlines": 185, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"GENERATE\"\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;* 06/07/88 - Support for BLOCK and TAGBODY.                           *\n;* 06/10/88 - Support for MULTIPLE-VALUE-LIST and MULTIPLE-VALUE-BIND. *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zilcogen (p)      ; P is output of \"ZILCOCOM\" function.\n (prog\n  (body      ; the main body of the procedure\n   name      ; the name of the procedure currently being compiled\n   parms     ; parameters input to the program\n   special-unbounds  ; unbound special variables referenced by the pgm\n   fluid-unbounds    ; unbound lexical variables referenced by the pgm\n   atoms     ; constant atoms referenced by the program\n   lists     ; constant lists referenced by the program\n   subrs     ; external subroutines invoked by the program\n   procs     ; internal LAMBDA-procedures compiled along with the rest\n   tailrecur ; list of local variables active at tail-recursion time\n   zzzcont   ; label for normal tail recursion\n   zzzconp   ; label for tail recursion from a PROG with special vars\n   zzzstksz  ; label for maximum stack size\n   regs      ; the registers available to the code generator\n   cc        ; pair of branch mnemonics for condition code testing\n   main      ; T if program is the main procedure, NIL if internal func.\n   alone     ; T if program is a stand-alone function, NIL if executable\n   pdbas     ; offset into stack, past caller's args, of initial saves\n   stack     ; offset into stack, past initial saves, of locals & args\n   stackmax  ; maximum stack size used at any point\n   pdmax     ; push down stack of maximum stack levels\n   argbase   ; push down stack of bases for function arguments\n   special-asaved    ; stack of saved special ALIST pointers\n   fluid-asaved      ; stack of saved lexical ALIST pointers\n   lastarg   ; last argument register if applicable\n   codelist  ; list of code lines built by calls to ZCGEMIT\n   codelen   ; length of addressable portion of code\n  )\n      (setq body      (get p 'body)\n            name      (get p 'name)\n            parms     (get p 'parms)\n            special-unbounds  (get p 'special-unbounds)\n            fluid-unbounds    (get p 'fluid-unbounds)\n            atoms     (get p 'atoms)\n            lists     (get p 'lists)\n            subrs     (get p 'subrs)\n            procs     (get p 'procs)\n            tailrecur (get p 'tailrecur)\n            zzzcont   (gensym)\n            zzzstksz  (gensym)\n            regs '(\\0 \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\14 \\15)\n            cc nil\n            codelist nil\n      )\n      ;\n      ; Note that the following registers are never available...\n      ; \\8  - T\n      ; \\9  - the free list pointer\n      ; \\10 - NIL\n      ; \\11 - the current pointer into the stack\n      ; \\12 - the base register\n      ; \\13 - the common area pointer\n      ;\n      ; ZZZCONP   is set by ZCGBEGIN.\n      ; MAIN      is set by ZCGBEGIN.\n      ; ALONE     is set by ZCGBEGIN.\n      ; PDBAS     is initialized by ZCGBEGIN.\n      ; STACK     is initialized by ZCGBEGIN.\n      ; STACKMAX  is initialized by ZCGBEGIN.\n      ; PDMAX     is initialized by ZCGBEGIN.\n      ; ARGBASE   is initialized by ZCGBEGIN.\n      ; SPECIAL-ASAVED  is initialized by ZCGBEGIN.\n      ; FLUID-ASAVED    is initialized by ZCGBEGIN.\n      ; CODELEN         is initialized by ZCGBEGIN.\n;\n; Set use counts for all registers to zero.\n;\n  (dolist (x regs) (putprop x 0 'usecount))\n;\n; Generate code.\n;\n loop\n      (or body (go endup))\n      (gencode (car body) (cdr body))\n      (setq body (cdr body))\n      (go loop)\n endup\n;\n; When finished with generation, generate code for LAMBDA procs.\n;\n      (mapc #'zilcogen (cdr procs))\n )\n)\n\n(defun gencode (stmt restofit) ; Generate code for each thing in list.\n (when stmt\n  (let (((verb . args) stmt))\n   (case verb\n    (begin        (zcgbegin args))\n    (end          (zcgend   args))\n    (begincall    (zcgbcall args))\n    (begininline  (zcgbcall args))\n    (begintail    (zcgbcall args))\n    (beginlam     (zcgblam  args))\n    (endlam       (zcgelam  args))\n;;;;(endcall ;;;;;(zcgecall args))\n    (call         (zcgcall  args))\n    (inline       (zcginlin args))\n    (tailrecur    (zcgrecur args))\n    (bind         (zcgbind  args))\n    (begintag     (zcgbtag  args))\n    (endtag       (zcgetag  args))\n    (beginblock   (zcgbtag  args))\n    (endblock     (zcgetag  args))\n    (beginuwp     (zcgbuwp  args))\n    (enduwp       (zcgeuwp  args))\n    (error        (zcgerror args))\n    (getvar       (zcggtvar args))\n;;;;(getparm ;;;;;(zcggetit args)) ; formerly zcggtprm\n    (getlocal     (zcggetit args)) ; formerly zcggtloc\n    (setatom      (zcggetit args)) ; formerly zcgstatm\n    (setlist      (zcggetit args)) ; formerly zcgstlst\n    (setnil       (zcggetit args)) ; formerly zcgstnil\n    (sett         (zcggetit args)) ; formerly zcgsett\n    (setsmall     (zcggetit args)) ; formerly zcgsmall\n    (label        (zcglabel args))\n    (closure      (zcgclos  args))\n    (subr         (zcgsubr  args))\n    (def          (zcgdef   args))\n    (optional     (zcgopt   args))\n    (setopt       (zcgstopt args))\n    (keys         (zcgkey   args))\n    (csetnil      (zcgcsnil args))\n    (mvinit       (zcgmvini args))\n    (t\n     (zerror \"Unknown P-code statement type found by code generator\"\n             verb))))))\n\n; Special declarations moved to ZILMACS.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOINT": {"ttr": 7940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x00\\x00\\x88\\x08/\\x00\\x893o\\x118\\x03\\x8a\\x02\\xed\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "1988-03-22T00:00:00", "modifydate": "1989-12-02T11:38:00", "lines": 906, "newlines": 749, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;\n;   ZILCOINT is the compiler initialization routine, called to establish\n;   all global values and defaults used by the compiler, and to perform\n;   definition of all compile-time macros required by the compiler.\n;\n;**********************************************************************\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/22/88 - Added ASSQ and MEMQ as inline functions.                 *\n;* 04/07/88 - Added ASSOC and MEMBER to known functions list.          *\n;*            Added compiler transforms for ASSOC and MEMBER.          *\n;* 04/14/88 - Added LOGCOUNT as a built-in.                            *\n;* 04/27/88 - Added ZXSETQ compiler transform for SETQ.                *\n;* 04/28/88 - Added some more names to \"reserved\" list to fix bugs     *\n;*            in compiler when generating atoms and subrs for them.    *\n;* 04/28/88 - Added ZILTEST as a built-in.                             *\n;* 05/13/88 - Removed REALTIME; added ZILCOCON.                        *\n;* 06/01/88 - Added LIST, etc., which are no longer EXPR's in ZEVINIT, *\n;*            and added VALUES and VALUES-LIST.                        *\n;*            Added more compiler transforms.                          *\n;*            Removed THROW, which is now a special form.              *\n;* 11/01/88 - Added XLATE (a.k.a STRING-TRANSLATE) and ZFSEXEC.        *\n;* 11/88 - Added LDIFF, reader functions, STRING, UNTYI, ZILSPAD.      *\n;* 12/88 - Added more reader-related functions, CHARP.                 *\n;* 12/89 - Added SETASCII.                                             *\n;*                                                                     *\n;***********************************************************************\n\n   ;;\n   ;; Steps in adding a new built-in function:\n   ;;\n   ;; (1) Add it to ZILCOINT.\n   ;; (2) Add it to ZILMODS.\n   ;; (3) Create a new help member for it.\n   ;; (4) Add it to help member $HELP.\n   ;;\n   ;;\n   ;; Steps in adding a new special form:\n   ;;\n   ;; (1) Add it to the list in ZEVINIT.\n   ;; (2) Add it to ZILEVAL.\n   ;; (3) Add it to FEXPAND.\n   ;; (4) Add it to ZILCOTRN.\n   ;; (5) Add it to ZILCOINT.\n   ;; (6) Figure out how to compile it.\n   ;; (7) Create a new help member for it.\n   ;; (8) Add it to help member $HELP.\n   ;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n; First, some local macros.\n\n(defmacro def-1-arg-trans (function (arg) body\n                           &aux (y (gensym)) (z (gensym)))\n `(deftrans ,function (,z)\n   (let ((,y (cdr ,z)))\n    (cond\n     ((null ,y) (zerror \"Too few arguments\" ,z))\n     ((cdr ,y)  (zerror \"Too many arguments\" ,z))\n     (t         (let ((,arg (car ,y)))\n                     ,body))))))\n\n; Then, some read-time functionality.\n\n(eval-when ()\n#.(progn\n   ;\n   ; Reserved symbol names that cannot be generated as assembler labels.\n   ;\n   (defvar reserved\n                    '(zlbptrs\n                      zilopts zilpdsiz zilcssiz zilvssiz zilacsiz\n                      zilatoms zilatome zillists zilliste\n                      zilvset zilvsym zilxdef zilxlfy\n                     ))\n   ;\n   ; Special forms.\n   ;\n   (defvar special-forms\n           (let ((formlist nil))\n                (mapatoms #'(lambda (x)\n                                    (when (get x '|SPECIAL FORM|)\n                                          (push x formlist))))\n                formlist))\n\n   (format t \"~%The special forms that will be defined to the compiler ~\n                are:~%~S~2%\" special-forms)\n   ;\n   ; Functions that generate inline code, not subroutine calls.\n   ;\n   (defvar inline-funcs\n       '(car cdr pname plist pbind             ; Accessor functions\n         funfun funenv                         ; Accessor functions\n         zcar zcdr                             ; ZIL-only accessors\n         rplaca rplacd setplist setpbind       ; Updater functions\n         oblist                                ; The \"object list\"\n         salist setsalst                       ; \"ALIST\" stuff\n         zilunbnd                              ; The \"unbound marker\"\n         rmnil                                 ; The reader \"nothing\"\n         cons                                  ; Fast call to common\n         assq memq                             ; List loopers\n\n         ; NOTE: Code below depends on the predicates\n         ;       all following EQ in this list.  DO NOT CHANGE THIS!!!\n\n         eq                                    ; Basic predicates\n         zerop minusp evenp oddp plusp         ; Numeric predicates\n         atom numberp symbolp fixnump floatp   ; Type predicates...\n         consp listp\n         codep subrp closurep stringp vectorp\n         bigp fixp integerp funargp\n         vecp structp sfloatp dfloatp charp\n        ))\n  )\n)\n\n\n; Now, the actual function definition.\n\n(defun zilcoint (&aux (infuns '#.inline-funcs))\n\n;\n; Set up the function lists used by the compiler.\n;\n (putprop '*zilco* '#.reserved       'reserved)\n (putprop '*zilco* infuns            'inline-funcs)\n (putprop '*zilco* '#.special-forms  'special-forms)\n\n;\n; Declare the default binding technique to be SPECIAL.\n; Note: (declare (default-binding .......)) can override this.\n;\n\n (defprop *zilco* special default-binding)\n\n;(defprop *zilco* nil   default-binding) disallows undeclared unbounds\n\n;\n; Define built-in inline functions.\n;\n (loop for x in infuns\n       with pred = nil\n       (putprop x t 'builtin) ; True for all built-in in-line code.\n       (putprop x t 'inline)  ; True unless (DECLARE (NOTINLINE ...))\n       when (eq x 'eq)        ; Start of predicate functions\n            (setq pred t)\n       when pred\n            (putprop x t 'predicate)\n )\n;\n; Define additional predicate functions for those that are sometimes\n; inline and sometimes not.\n;\n (putprop 'eql t 'predicate)\n ;\n ; Eventually, LESSP/GREATERP/ZILEQUAL/etc. will also be defined\n ; as predicates, but only when some inline code is possible for them.\n ;\n; Invoke the \"DEFARGS\" facility to define minimum and maximum\n; arguments for standard LISP functions as shown below.\n;\n (mapc #'(lambda (x)\n                 (let (((fun min max rst) x))\n                      (putprop fun min 'minargs)\n                      (putprop fun max 'maxargs)\n                      (putprop fun rst 'restarg)))\n       '(\n           (abs      1 1 nil)\n           (acsize   0 0 nil)\n           (add1     1 1 nil)\n           (alphacp  1 1 nil)\n           (append2  2 2 nil)\n           (apply    1 1 t  )\n           (apropos  1 1 nil)\n           (args     1 2 nil)\n           (ash      2 2 nil)\n           (assq     2 2 nil)\n           (assql    2 2 nil)\n           (assqual  2 2 nil)\n           (atom     1 1 nil)\n           (biglist  1 1 nil)\n           (bigp     1 1 nil)\n           (boundp   1 1 nil)\n           (butlast  1 2 nil)\n           (car      1 1 nil)\n           (cdr      1 1 nil)\n           (ceiling  1 2 nil)\n           (char     2 2 nil)\n           (chardown 1 1 nil)\n           (charp    1 1 nil)\n           (charup   1 1 nil)\n           (close    1 2 nil)\n           (closurep 1 1 nil)\n           (clrscrn  0 0 nil)\n           (codep    1 1 nil)\n           (concat   0 0 t  )\n           (cons     2 2 nil)\n           (consp    1 1 nil)\n           (copyenv  1 1 nil)\n           (copysym  2 2 nil)\n           (copytree 1 1 nil)\n           (cssize   0 0 nil)\n           (cterpri  0 1 nil)\n           (curdate  0 0 nil)\n           (curjdate 0 0 nil)\n           (curtime  0 0 nil)\n           (defrdmac 2 2 nil)\n           (delq     2 3 nil)\n           (delql    2 3 nil)\n           (delqual  2 3 nil)\n           (dfloatp  1 1 nil)\n           (digitcp  1 2 nil)\n           (downcase 1 1 nil)\n           (ebcdic   1 2 nil)\n           (echo     1 3 nil)\n           (ed       0 1 nil)\n           (endread  0 1 nil)\n           (eof      0 1 nil)\n           (eq       2 2 nil)\n           (eql      2 2 nil)\n           (equal    2 2 nil)\n           (equalp   2 2 nil)\n           (error    0 1 t  ) ; 05/22/89\n           (eval     1 2 nil)\n           (evenp    1 1 nil)\n           (every    1 1 t  )\n           (exit     0 1 nil)\n           (explode  1 1 nil)\n           (explodec 1 1 nil)\n           (exploden 1 1 nil)\n           (expt     2 2 nil)\n           (fboundp  1 1 nil)\n           (featurep 1 1 nil)\n           (fexpand  1 1 nil)\n           (firstn   2 2 nil)\n           (fix      1 1 nil)\n           (fixnump  1 1 nil)\n           (fixp     1 1 nil)\n           (float    1 2 nil)\n           (floatp   1 1 nil)\n           (floor    1 2 nil)\n           (fmakunbo 1 1 nil)\n           (format   2 2 t  )\n           (funargp  1 1 nil)\n           (funcall  1 1 t  )\n           (funenv   1 1 nil)\n           (funfun   1 1 nil)\n           (gc       0 0 nil)\n           (gcd2     2 2 nil)\n           (gcmsg    0 1 nil)\n           (gctime   0 0 nil)\n           (gensym   0 1 nil)\n           (gentemp  0 2 nil)\n           (get      2 3 nil)\n           (getchar  2 2 nil)\n           (getcharn 2 2 nil)\n           (getk     2 3 nil)\n           (getl     2 2 nil)\n           (getparm  0 2 nil)\n           (greaterp 2 2 nil)\n           (haipart  2 2 nil)\n           (haulong  1 1 nil)\n           (ifilep   1 1 nil)\n           (implode  1 1 nil)\n           (index    2 3 nil)\n           (integerp 1 1 nil)\n           (intersec 2 2 nil)\n           (intrpret 0 3 nil)\n           (intrq    2 2 nil)\n           (invoke   1 2 nil)\n           (ispfp    0 0 nil)\n           (keywordp 1 1 nil)\n           (kwdify   1 1 nil)\n           (land     2 2 nil)\n           (last     1 1 nil)\n           (ldiff    2 2 nil)\n           (length   1 1 nil)\n           (lessp    2 2 nil)\n           (listp    1 1 nil)\n           (llkeywdp 1 1 nil)\n           (llvars   1 1 nil)\n           (load     1 1 t  )\n           (log      1 2 nil)\n           (logbitp  2 2 nil)\n           (logcount 1 1 nil)\n           (lognot   1 1 nil)\n           (logtest  2 2 nil)\n           (lor      2 2 nil)\n           (lsh      2 2 nil)\n           (lxor     2 2 nil)\n           (maknam   1 1 nil)\n           (maknum   1 1 nil)\n           (makunbou 1 1 nil)\n           (maxargs  1 1 nil)\n           (max2     2 2 nil)\n           (memq     2 2 nil)\n           (memql    2 2 nil)\n           (memqual  2 2 nil)\n           (mexpand  1 1 nil)\n           (mexpand1 1 1 nil)\n           (minargs  1 1 nil)\n           (minus    1 1 nil)\n           (minusp   1 1 nil)\n           (min2     2 2 nil)\n           (mkatom   1 3 nil)\n           (mkbignum 1 1 nil)\n           (mkfixnum 1 1 nil)\n           (mkflonum 1 2 nil)\n           (mkfunarg 2 2 nil)\n           (mklist   1 2 nil)\n           (mknewenv 0 1 nil)\n           (mkstruct 2 2 nil)\n           (mkvector 1 2 nil)\n           (msglevel 0 1 nil)\n           (nconc2   2 2 nil)\n           (newlinep 0 1 nil)\n           (not      1 1 nil)\n           (notany   1 1 t  )\n           (notevery 1 1 t  )\n           (nreconc  2 2 nil)\n           (nreverse 1 1 nil)\n           (nth      2 2 nil)\n           (nthcdr   2 2 nil)\n           (null     1 1 nil)\n           (numberp  1 1 nil)\n           (oblist   0 0 nil)\n           (oddp     1 1 nil)\n           (ofilep   1 1 nil)\n           (open     1 2 nil)\n           (pairlis  2 3 nil)\n           (parsbody 1 3 nil)\n           (pbind    1 1 nil)\n           (pdsize   0 0 nil)\n           (peekch   0 3 nil)\n           (plist    1 1 nil)\n           (plusp    1 1 nil)\n           (pm       1 2 nil)\n           (pm1      1 2 nil)\n           (pname    1 1 nil)\n           (ppdate   0 1 nil)\n           (pprint   1 2 nil)\n           (pptime   0 1 nil)\n           (prefix   0 0 nil)\n           (princ    1 2 nil)\n           (print    1 2 nil)\n           (printc   1 2 nil)\n           (prints   1 2 nil)\n           (prin1    1 2 nil)\n           (probef   1 1 nil)\n           (putprop  3 3 nil)\n           (quit     0 1 nil)\n           (random   0 2 nil)\n           (rdrmacro 2 2 nil)\n           (read     0 2 nil)\n           (readch   0 3 nil)\n           (readline 0 1 nil)\n           (remdupq  1 1 nil)\n           (remdupql 1 1 nil)\n           (remdupqu 1 1 nil)\n           (remprop  2 2 nil)\n           (remq     2 3 nil)\n           (remql    2 3 nil)\n           (remqual  2 3 nil)\n           (restarg  1 1 nil)\n           (revappen 2 2 nil)\n           (reversal 1 1 nil)\n           (reverse  1 1 nil)\n           (rmchar   0 0 nil)\n           (rminit   0 0 nil)\n           (rmmac    0 0 nil)\n           (rmnil    0 0 nil)\n           (rot      2 2 nil)\n           (round    1 2 nil)\n           (rplaca   2 2 nil)\n           (rplacd   2 2 nil)\n           (runtime  0 0 nil)\n           (salist   0 0 nil)\n           (sappend  0 0 t  )\n           (sappendl 1 1 nil)\n           (scapital 1 1 nil)\n           (scrsize  0 0 nil)\n           (set      2 2 nil)\n           (setabend 1 1 nil)\n           (setascii 0 1 nil)\n           (setattn  1 1 nil)\n           (setbrack 2 3 nil)\n           (setdebug 1 1 nil)\n           (setfeat  1 1 nil)\n           (setnfeat 1 1 nil)\n           (setpbind 2 2 nil)\n           (setplist 2 2 nil)\n           (setprt   1 1 nil)\n           (setread  1 1 nil)\n           (setsalst 1 1 nil)\n           (setsynta 3 3 nil)\n           (sfloatp  1 1 nil)\n           (sleep    1 1 nil)\n           (slength  1 1 nil)\n           (sltrim   2 2 nil)\n           (some     1 1 t  )\n           (sort     1 2 nil)\n           (sortcar  1 2 nil)\n           (sremove  2 2 nil)\n           (sreverse 1 1 nil)\n           (srtrim   2 2 nil)\n           (sscan    1 7 nil)\n           (strim    2 2 nil)\n           (string   1 1 nil)\n           (stringp  1 1 nil)\n           (structp  1 1 nil)\n           (sublis   2 2 nil)\n           (sublisq  2 2 nil)\n           (subrp    1 1 nil)\n           (substq   3 3 nil)\n           (substql  3 3 nil)\n           (substqua 3 3 nil)\n           (substr   1 3 nil)\n           (sub1     1 1 nil)\n           (sxhash   1 1 nil)\n           (symbolp  1 1 nil)\n           (symeval  1 1 nil)\n           (tabs     1 2 nil)\n           (terpri   0 1 nil)\n           (tostring 1 2 nil)\n           (truncate 1 2 nil)\n           (tso      0 0 t  )\n           (tyi      0 3 nil)\n           (tyipeek  0 4 nil)\n           (tyo      1 2 nil)\n           (typep    1 2 nil)\n           (uconcat  0 0 t  )\n           (unebcdic 1 1 nil)\n           (union    2 2 nil)\n           (unionq   2 2 nil)\n           (unkwdify 1 1 nil)\n           (untyi    1 4 nil)\n           (upcase   1 1 nil)\n           (userid   0 0 nil)\n           (values   0 0 t  )\n           (valuesl  1 1 nil)\n           (vcopy    1 1 nil)\n           (vecp     1 1 nil)\n           (vectorp  1 1 nil)\n           (verify   2 3 nil)\n           (vfill    2 2 nil)\n           (vlength  1 1 nil)\n           (vlist    1 1 nil)\n           (vref     2 2 nil)\n           (vset     3 3 nil)\n           (vssize   0 0 nil)\n           (warn     1 2 t  )\n           (xcons    2 2 nil)\n           (xlate    3 3 nil)\n           (zcar     1 1 nil)\n           (zcdr     1 1 nil)\n           (zcprint  3 3 nil)\n           (zcread   6 6 nil)\n           (zcsrdl   1 3 nil) ; READ-DELIMITED-LIST\n           (zcsrfs   1 3 t  ) ; READ-FROM-STRING\n           (zdprint  3 3 nil)\n           (zdread   6 6 nil)\n           (zerop    1 1 nil)\n           (zerror   0 2 t  ) ; 05/15/89\n           (zevauto  1 2 nil)\n           (zevdefld 2 2 nil)\n           (zevdefun 2 2 nil)\n           (zevdsub  2 2 nil)\n           (zevdvar  2 2 nil)\n           (zevinit  0 0 nil)\n           (zevlist  1 2 nil)\n           (zevmapp  3 3 nil)\n           (zevset   2 2 nil)\n           (zevsym   1 1 nil)\n           (zevxvar  1 4 nil)\n           (zfmexec  3 3 nil)\n           (zfmpars  1 1 nil)\n           (zfsexec  0 0 t  )\n           (zgetfpi  0 1 nil)\n           (zgetfpo  0 1 nil)\n           (zifacos  1 1 nil)\n           (zifasin  1 1 nil)\n           (zifatan  2 2 nil)\n           (zifcos   1 1 nil)\n           (zifexp   1 1 nil)\n           (ziflog   1 1 nil)\n           (zifsin   1 1 nil)\n           (zifsqrt  1 1 nil)\n           (ziftan   1 1 nil)\n           (ziladd   2 2 nil)\n           (zilapply 2 4 nil)\n           (zilbool  3 3 nil)\n           (zilclose 2 2 nil)\n           (zilcocon 2 2 nil)\n           (zildiv   2 2 nil)\n           (zildsni  1 1 nil)\n           (zildsno  1 1 nil)\n           (zildump  1 1 nil)\n           (ziledit  1 1 nil)\n           (zilequal 2 2 nil)\n           (zileval  3 3 nil)\n           (zilexpl  1 3 nil)\n           (zilfix   2 2 nil)\n           (zilflat  2 2 nil)\n           (zilhelp  0 2 nil)\n           (zilimpl  1 3 nil)\n           (zilload  1 1 nil)\n           (zilmul   2 2 nil)\n           (zilopen  2 2 nil)\n           (zilpp    1 2 nil)\n           (zilprogv 3 3 nil)\n           (zilrem   2 2 nil)\n           (zilspad  5 5 nil)\n           (zilspkg  1 1 nil)\n           (zilsprt  1 1 nil)\n           (zilsrd   1 1 nil)\n           (zilsub   2 2 nil)\n           (ziltest  1 1 nil)\n           (ziltrace 2 2 nil)\n           (zilunbnd 0 0 nil)\n           (zilvtos  2 2 nil)\n           (zilxclo  2 2 nil)\n           (zilxsub  2 2 nil)\n           (zisexec  0 0 t  )\n           (zisget   1 1 nil)\n           (zisput   2 2 nil)\n           (zmstruct 1 1 nil)\n           (zmvector 1 1 nil)\n           (zputfpi  1 2 nil)\n           (zputfpo  1 2 nil)\n\n           (peek     1 1 nil)\n           (peekb    1 1 nil)\n           (peekc    1 2 nil)\n           (peekl    2 3 nil)\n           (unword   1 1 nil)\n           (word     1 2 nil)\n\n;;; The following should never be compiled directly, since they will\n;;; always be compiler-transformed into other functions.  However,\n;;; they need to be made known to the compiler in case functional\n;;; closures are generated using them.\n\n           (append   0 0 t  )\n           (assoc    2 2 t  )\n           (bignum   0 0 t  )\n           (boole    1 1 t  )\n           (concatl  1 1 nil)\n           (endp     1 1 nil)\n           (flatc    1 1 nil)\n           (flatsize 1 1 nil)\n           (intern   1 2 nil)\n           (list     0 0 t  )\n           (mapand   1 1 t  )\n           (mapatoms 1 1 nil)\n           (mapc     1 1 t  )\n           (mapcan   1 1 t  )\n           (mapcar   1 1 t  )\n           (mapcon   1 1 t  )\n           (mapl     1 1 t  )\n           (maplist  1 1 t  )\n           (mapor    1 1 t  )\n           (member   2 2 t  )\n           (mknumber 1 1 nil)\n           (nconc    0 0 t  )\n           (ncons    1 1 nil)\n           (structur 0 0 t  )\n           (uconcatl 1 1 nil)\n           (vector   0 0 t  )\n ))\n\n;\n; Now, the compiler transforms.\n;\n\n (def-1-arg-trans concatl     (x) `(zilimpl ,x t nil))\n (def-1-arg-trans uconcatl    (x) `(zilimpl ,x nil nil))\n (def-1-arg-trans flatc       (x) `(zilflat ,x nil))\n (def-1-arg-trans flatsize    (x) `(zilflat ,x t))\n (def-1-arg-trans make-number (x) `(mkatom ,x nil t))\n (def-1-arg-trans mknumber    (x) `(mkatom ,x nil t))\n (def-1-arg-trans ncons       (x) `(cons ,x nil))\n (def-1-arg-trans endp        (x) `(null ,x))\n\n;\n; Standard map functions implemented as open code because they take\n; a function specification as an operand.\n;\n (deftrans mapl     zxmap)\n (deftrans maplist  zxmap)\n (deftrans mapc     zxmap)\n (deftrans mapcar   zxmap)\n (deftrans mapand   zxmap)\n (deftrans mapor    zxmap)\n (deftrans mapcan   zxmap)\n (deftrans mapcon   zxmap)\n (deftrans every    zxmap)\n (deftrans notany   zxmap)\n (deftrans notevery zxmap)\n (deftrans some     zxmap)\n;\n; The following functions are implemented under the compiler\n; as source transformations, often avoiding calls to functions\n; that take lists of arguments or keywords.\n;\n (deftrans append  zxappend)\n (deftrans assoc   zxassoc )\n (deftrans boole   zxboole )\n (deftrans intern  zxintern)\n (deftrans list    zxlist  )\n (deftrans member  zxmember)\n (deftrans nconc   zxnconc )\n\n (deftrans caar          (x) `(car (car . ,(cdr x))))\n (deftrans cadr          (x) `(car (cdr . ,(cdr x))))\n (deftrans cdar          (x) `(cdr (car . ,(cdr x))))\n (deftrans cddr          (x) `(cdr (cdr . ,(cdr x))))\n (deftrans caaar         (x) `(car (car (car . ,(cdr x)))))\n (deftrans caadr         (x) `(car (car (cdr . ,(cdr x)))))\n (deftrans cadar         (x) `(car (cdr (car . ,(cdr x)))))\n (deftrans caddr         (x) `(car (cdr (cdr . ,(cdr x)))))\n (deftrans cdaar         (x) `(cdr (car (car . ,(cdr x)))))\n (deftrans cdadr         (x) `(cdr (car (cdr . ,(cdr x)))))\n (deftrans cddar         (x) `(cdr (cdr (car . ,(cdr x)))))\n (deftrans cdddr         (x) `(cdr (cdr (cdr . ,(cdr x)))))\n\n (deftrans caaaar        (x) `(car (car (car (car . ,(cdr x))))))\n (deftrans caaadr        (x) `(car (car (car (cdr . ,(cdr x))))))\n (deftrans caadar        (x) `(car (car (cdr (car . ,(cdr x))))))\n (deftrans caaddr        (x) `(car (car (cdr (cdr . ,(cdr x))))))\n (deftrans cadaar        (x) `(car (cdr (car (car . ,(cdr x))))))\n (deftrans cadadr        (x) `(car (cdr (car (cdr . ,(cdr x))))))\n (deftrans caddar        (x) `(car (cdr (cdr (car . ,(cdr x))))))\n (deftrans cadddr        (x) `(car (cdr (cdr (cdr . ,(cdr x))))))\n (deftrans cdaaar        (x) `(cdr (car (car (car . ,(cdr x))))))\n (deftrans cdaadr        (x) `(cdr (car (car (cdr . ,(cdr x))))))\n (deftrans cdadar        (x) `(cdr (car (cdr (car . ,(cdr x))))))\n (deftrans cdaddr        (x) `(cdr (car (cdr (cdr . ,(cdr x))))))\n (deftrans cddaar        (x) `(cdr (cdr (car (car . ,(cdr x))))))\n (deftrans cddadr        (x) `(cdr (cdr (car (cdr . ,(cdr x))))))\n (deftrans cdddar        (x) `(cdr (cdr (cdr (car . ,(cdr x))))))\n (deftrans cddddr        (x) `(cdr (cdr (cdr (cdr . ,(cdr x))))))\n\n (deftrans zcadr         (x) `(zcar (zcdr . ,(cdr x))))\n (deftrans zcddr         (x) `(zcdr (zcdr . ,(cdr x))))\n (deftrans zcaddr        (x) `(zcar (zcdr (zcdr . ,(cdr x)))))\n (deftrans zcdddr        (x) `(zcdr (zcdr (zcdr . ,(cdr x)))))\n (deftrans zcadddr       (x) `(zcar (zcdr (zcdr (zcdr . ,(cdr x))))))\n\n (deftrans vector        (x) `(zmvector (list . ,(cdr x))))\n (deftrans bignum        (x) `(mkbignum (list . ,(cdr x))))\n (deftrans structur      (x) `(zmstruct (list . ,(cdr x))))\n (deftrans structure     (x) `(zmstruct (list . ,(cdr x))))\n\n ;\n ; Arithmetic functions implemented as macros.\n ;\n\n (deftrans plus          (x)   (zxarith (cdr x) 'ziladd   0))\n (deftrans difference    (x)   (zxarith (cdr x) 'zilsub   0))\n (deftrans times         (x)   (zxarith (cdr x) 'zilmul   1))\n (deftrans quotient      (x)   (zxarith (cdr x) 'zildiv   1))\n (deftrans remainder     (x)   (zxarith (cdr x) 'zilrem   1))\n\n (deftrans gcd           (x)   (zxarith (cdr x) 'gcd2     0))\n\n (deftrans +             (x)   (zxarith (cdr x) 'ziladd   0))\n (deftrans *             (x)   (zxarith (cdr x) 'zilmul   1))\n (deftrans //            (x)   (zxarith (cdr x) 'zilrem   1))\n (deftrans \\\\            (x)   (zxarith (cdr x) 'zilrem   1))\n\n (deftrans max           (x)   (zxarith (cdr x) 'max2 nil 'max))\n (deftrans min           (x)   (zxarith (cdr x) 'min2 nil 'min))\n\n (deftrans logand        (x)   (zxarith (cdr x) 'land    -1))\n (deftrans logior        (x)   (zxarith (cdr x) 'lor      0))\n (deftrans logxor        (x)   (zxarith (cdr x) 'lxor     0))\n\n (deftrans =             (x)   (zxrelop x 'zilequal ))\n (deftrans >             (x)   (zxrelop x 'greaterp ))\n (deftrans <             (x)   (zxrelop x 'lessp    ))\n (deftrans >=            (x)   (zxrelop x 'nlessp   ))\n (deftrans <=            (x)   (zxrelop x 'ngreaterp))\n\n (deftrans - (x)\n  (setq x (cdr x))\n  (cond\n   ((null x)       0)\n   ((null (cdr x)) `(minus ,(car x)))\n   (t              (zxarith x 'zilsub 0))))\n\n (deftrans / (x)\n  (setq x (cdr x))\n  (cond\n   ((null x)       1)\n   ((null (cdr x)) `(zildiv 1 ,(car x)))\n   (t              (zxarith x 'zildiv 1))))\n\n\n;=========== Compiler Transformations For Special Forms =============\n\n (deftrans and      zxand  )\n (deftrans cond     zxcond )\n (deftrans or       zxor   )\n (deftrans progn    zxprogn)\n (deftrans quote    zxquote)\n (deftrans setq     zxsetq )\n\n;============= Compiler Transformations For Accessors ===============\n\n (deftrans car          zxcarcdr)\n (deftrans cdr          zxcarcdr)\n (deftrans plist        zxcarcdr)\n (deftrans symbol-plist zxcarcdr)\n (deftrans zcar         zxcarcdr)\n (deftrans zcdr         zxcarcdr)\n\n;============= Compiler Transformations For Predicates ==============\n\n (deftrans equal    zxequal)\n (deftrans greaterp zxzilgt)\n (deftrans lessp    zxzillt)\n (deftrans typep    zxtypep)\n (deftrans zilequal zxzileq)\n\n;======== Compiler Transformations For Arithmetic Functions =========\n\n (deftrans ceiling  zxfix)\n (deftrans fix      zxfix)\n (deftrans floor    zxfix)\n (deftrans round    zxfix)\n (deftrans truncate zxfix)\n\n (deftrans ziladd   zxbinop)\n (deftrans zilsub   zxbinop)\n (deftrans zilmul   zxbinop)\n (deftrans zildiv   zxbinop)\n (deftrans zilrem   zxbinop)\n (deftrans lsh      zxbinop)\n (deftrans ash      zxbinop)\n (deftrans rot      zxbinop)\n\n (deftrans expt     zxexpt  )\n (deftrans gcd2     zxgcd2  )\n (deftrans log      zxlog   )\n (deftrans add1     zxadd1  )\n (deftrans sub1     zxsub1  )\n\n;========== Compiler Transformations For Other Functions ============\n\n (deftrans mapatoms zxmapat )\n (deftrans nth      zxnth   )\n (deftrans nthcdr   zxnthcdr)\n (deftrans values   zxvalues)\n\n;========== Compiler Transformations For Arithmetic Functions =======\n;========== and Similar Functions that Can Be Constant-Folded =======\n\n (mapc #'(lambda (x) (putprop x 'zxarfun 'compiler-transform))\n       '(abs\n         alphacp\n         atom\n         bigp\n         char\n         closurep\n         codep\n         consp\n         dfloatp\n         digitcp\n         evenp\n         fixnump\n         fixp\n         float\n         floatp\n         funargp\n         getchar\n         getcharn\n         haipart   ; at least until it has its own transform\n         haulong\n         index\n         integerp\n         land      ; at least until it has its own transform\n         length\n         listp\n         llkeywdp  ; yes, checks print name only\n         llvars    ; yes, syntactic-surface-scanner\n         logbitp   ; at least until it has its own transform\n         logcount\n         lognot\n         logtest   ; at least until it has its own transform\n         lor       ; at least until it has its own transform\n         lxor      ; at least until it has its own transform\n         max2\n         minus\n         minusp\n         min2\n         mkbignum\n         mkfixnum\n         mkflonum\n         not\n         null\n         numberp\n         oddp\n         plusp\n         sfloatp\n         slength\n         stringp\n         structp\n         subrp\n         symbolp\n         unebcdic\n         vecp\n         vectorp\n         verify\n         vlength\n         zerop\n         zilbool\n         zilfix\n         zilflat\n         zilintln\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;        ebcdic            ; No, may return an uninterned symbol\n;        sxhash            ; No, what if hashing algorithm changes?\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; The following create strings.  They probably shouldn't be\n;;; constant-folded, since some day strings will be mutable.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; chardown char-downcase charup char-upcase downcase string-downcase\n; sappend string-append sappendl string-appendl scapital\n; string-capitalize sltrim string-left-trim sremove string-remove\n; sreverse string-reverse srtrim string-right-trim strim string-trim\n; substr string-substr tostring upcase string-upcase\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        ))\n\n;========== Compiler Transformations For Other Functions ============\n\n\n\n;;; Do this after all compiler transforms have been defined.\n\n;\n; All the macros known to the evaluator are automatically known as\n; macros to the compiler.  This is NOT true for all DEFLOADed functions;\n; therefore, transfer the \"AUTOLOAD\" properties thereof.\n;\n; Although not all compiler macros are interpreter macros,\n; it is true that all interpreter macros are compiler macros.\n;\n; Similarly, all \"officially\" autoloaded functions are also\n; defined to the compiler with the analogous feature.\n;\n (mapatoms #'(lambda (x &aux y z)\n                  ;;;(when (setq y (get x 'macro))\n                  ;;;      (putprop x y 'cmacro)\n                  ;;;)\n                     (when (and (setq y (get x 'autoload))\n                                (symbolp y))\n                           (putprop x y 'cautoload)\n                           (putprop x (get y 'builtin) 'inline)\n                           (putprop x (get y 'predicate) 'predicate)\n                           ;;; Following done to avoid GETL lossage\n                           ;;; (see code below) - not needed for others\n                           (when (setq z (get y 'compiler-transform))\n                                 (putprop x z 'compiler-transform))\n                 )))\n\n;\n; All functions given compiler properties in this function are flagged\n; as being \"defined by the system\".\n;\n\n (mapatoms\n   #'(lambda (x)\n       (when (getl x '(minargs                ; True if system function\n                       macro                  ; True if system macro\n                       |SPECIAL FORM|         ; True if special form\n                       autoload               ; True if ARRAY/FLAVORS\n                       cautoload              ; True if \"equivalenced\"\n                       compiler-transform     ; True if transformable\n                      ))\n             (putprop x 'system 'defined-by))))\n\n nil ; return value from ZILCOINT\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOMEX": {"ttr": 7947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x07\\x00P\\x00e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:07:00", "lines": 80, "newlines": 101, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; ZILCOMEX is like MACROEXPAND except that it expands also CMACROs\n; (i.e. macros known only to the compiler).\n; In addition, it recurs until it returns something that is not\n; a macro.\n;\n; This function supersedes \"ZCCEXPAN\" and \"ZCCEXPUN\".\n;\n; With this function, ZILCOCOM will be able to expand top-level\n; function calls, enabling the use of macros that expand into\n; DEFUN's (e.g. DEFMACRO).\n;\n; Note:      MACRO properties are now recognized by the compiler at\n;            compile time, as well as CMACRO properties.  This means\n;            that DEFMACRO's evaluated at compile time create macro\n;            definitions that are used in compilation; there is no\n;            way to avoid this.  CMACRO's are still supported for\n;            compatibility and as a means of defining compiler-only\n;            optimizations of functions.  See ZCCEVAL.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zilcomex\n       (form    ; the form to be macro-expanded\n        tlvlp   ; if non-NIL, macro expansion called at top level\n        &aux\n        prop\n        m\n       )\n (cond\n  ((atom form)                           form) ; Not a list\n  ((not (symbolp (car form)))            form) ; Not a valid name\n  ((get (car form) 'cexpr)               form) ; Defined as function\n  ((setq m\n    (or (get (car form) (setq prop 'cmacro))  ; It's a compiler macro\n        (get (car form) (setq prop 'macro)))) ; It's a regular macro\n    ;\n    ; If \"tlvlp\" is true, we are expanding a form seen at top level,\n    ; which is OK.  Otherwise, this is a macro found inside code.\n    ; Since full macro expansion should already have been done by\n    ; ZILCOTRN prior to this point, we'll see a macro expansion\n    ; only if the expansion of the form had failed.  Therefore.\n    ; only signal an error in that case.\n    ;\n    (if tlvlp\n        (zilcomex (app-mac-lam m form prop tlvlp) tlvlp)\n        (app-mac-err form tlvlp)))\n  (t                                     form) ; Not a macro call\n ))\n\n(defun app-mac-lam (m form prop tlvlp &aux z)\n (if (ok (setq z (zevmapp m form prop)))\n     z\n     (app-mac-err form tlvlp)))\n\n; Error depends on whether top-level or not, since BODY will be bound\n; only if TLVLP is NIL.\n\n(defun app-mac-err (form tlvlp)\n (cond\n  (tlvlp\n   (zerror \"Macro expansion failed\" form))\n  (t\n   (modq body `(error \"Macro expansion failed\" ,form))\n   nil)))\n\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOMOD": {"ttr": 8193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x07\\x01N\\x01R\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:07:00", "lines": 334, "newlines": 338, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This function processes forms when compiling a MODULE.\n;\n\n; Compiling FOO as a \"module\"\n; takes foo and builds a compilable function out of it that, when\n; executed by typing (foo) under the interpreter, does the operations\n; generally expected by implementations of compiled modules created\n; by COMPILE-FILE.  In other words,\n;\n; if the form is a macro form, process the macro expansion.  Note:\n; this somehow has to include stuff defined by DEFMACRO's, so any\n; DEFMACRO encountered in the module has to be made to generate both\n; a MACRO (for evaluation) and CMACRO (for compilation) property.\n;\n; if a form is a DEFUN, assigns the compiled definition to the\n; appropriate property of the symbol.  Exception: if the DEFUN is of\n; a macro, the macro is made known to the compiler only.\n;\n; if a form is a DEFMACRO, this expands to a DEFUN for a macro, so\n; see above.\n;\n; if a form is a DEFVAR, is made known as a \"free\" variable to the\n; compiler; also set up to be executed at load time.\n;\n; if a form is a DECLARE, is passed to the compiler as is.\n;\n; if a form is a COMMENT, is ignored.\n;\n; if a form is an EVAL-WHEN, processed as follows:\n;\n;  EVAL-WHEN (COMPILE) - evaluated by the compiler itself only.\n;  EVAL-WHEN (LOAD)    - processed as above.\n;  EVAL-WHEN (EVAL)    - ignored.\n;\n; if the form is anything else, is set up to be executed at load time.\n;\n; Example:\n;\n; If the file looks like this...\n;\n; (defun foo1 (x) (blah1))        ;    1\n; (defun (baz frob) (y) (hair))   ;    2\n; (defmacro mac (x) `(frob ,x))   ;    3\n; (mac \"junk\")                    ;    4\n; (some random form)              ;    5\n; (defvar pi 3.1415926)           ;    6\n; (defload frobnicate frobozz)    ;    7\n; (eval-when (compile)\n;  (print \"hello world\"))         ;    8\n; (eval-when (load)\n;  (frob))                        ;    9\n; (eval-when (eval)\n;  (eccch))                       ;   10\n;\n; then the resulting main function form will be (more or less):\n;\n;  (defun zmfoo ()\n;    (#.zdef foo1)                               ; 1\n;    (putprop 'baz (subr |BAZ FROB|) 'frob)      ; 2\n;    (frob \"junk\")                               ; 4 - expanded MAC\n;    (some random form)                          ; 5\n;    (zevxvar 'pi 3.1415926)                               ...\n; or (zevxvar 'pi #'(lambda () 3.1415926))       ; 6\n;    (xdefload frobnicate frobozz)               ; 7\n;    (frob)                                      ; 9\n;    'zmfoo\n;  )\n;\n; and the additional forms to be compiled will be (more or less):\n;\n;  (defun foo1 (x) (blah1))                      ; 1\n;  (defun |BAZ FROB| (y) (hair))                 ; 2\n;  (defun mac macro (nil x) `(frob ,x))          ; 3 - expanded DEFMACRO\n;  (declare (special pi))                        ; 6\n;  (defload frobnicate frobozz)                  ; 7\n;  (eval-when (compile)\n;   (print \"hello world\"))                       ; 8\n; )\n;\n; Note that (9) is ignored - (eval-when (eval))forms are always ignored\n; at compile time.\n;\n; As things are set up right now, this generates\n; function definitions with null lexical environments.  This may change.\n;\n; Note:      MACRO properties are now recognized by the compiler at\n;            compile time, as well as CMACRO properties.  This means\n;            that DEFMACRO's evaluated at compile time create macro\n;            definitions that are used in compilation; there is no\n;            way to avoid this.  CMACRO's are still supported for\n;            compatibility and as a means of defining compiler-only\n;            optimizations of functions.  See ZILCOMEX.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defload member memqual) ; We use an EQUAL test for MEMBER when\n                         ; searching for (FOO BAR) on NOCOMPILE list.\n\n(declare (special loadlist complist))\n\n(defun zilcomod (form e)\n (prog (defun-func defun-prop arglist defun-rest defun-name)\n   nexp (cond\n         ((atom form)                (push form loadlist))\n         ((eq (car form) 'comment)   nil)\n         ((eq (car form) 'declare)   (go process-declare))\n         ((eq (car form) 'defload)   (go process-defload))\n         ((eq (car form) 'defun)     (go process-defun))\n         ((eq (car form) 'defvar)    (go process-defvar))\n         ((eq (car form) 'eval-when) (go process-eval-when))\n         ((eq (car form) 'progn)     (go process-progn))\n         ((and (symbolp (car form))\n               (not (get (car form) 'cexpr))\n               (or (get (car form) 'macro)\n                   (get (car form) 'cmacro)))\n          (setq form (zilcomex form t))\n          (go nexp))\n         (t                          (push form loadlist)))\n        (return)\n\n  process-defun     ; form = (defun ...)\n\n; Place either the compiled or the interpreted function definition\n; on the appropriate property of the symbol that names the function.\n; The function will have to be interpretive if its definition has\n; features that the ZIL compiler doesn't support yet.  Also,\n; if (DECLARE (NOCOMPILE FOO)) or (DECLARE (NOCOMPILE (FOO BAR)))\n; was specified, then the function will be on the \"NOCOMPILE\" list,\n; so don't compile the definition.\n\n        (unless (cdr form) (go defun-error))\n        (if (symbolp (cadr form))\n         then\n            (desetq (nil defun-func . defun-rest) form)\n            (or defun-rest (go defun-error))\n            ;\n            ; Check type of DEFUN\n            ;\n            (case (car defun-rest)\n             ((expr fexpr macro) (setq defun-prop (car defun-rest)\n                                       defun-rest (cdr defun-rest)))\n             (t                  (setq defun-prop 'expr))\n            )\n            ;\n            ; Figure out what to do with DEFUN\n            ;\n            (setq arglist (car defun-rest))\n            (case defun-prop\n             (expr   (if  (memq defun-func (get '*zilco* 'nocompile))\n                      then\n                          (princ\n          \"NOCOMPILE requested, will load interpretive definition of \")\n                          (princ defun-func)\n                          (terpri)\n                          (push `(xdefun . ,(cdr form)) loadlist)\n                      else\n;;;;;;;;;;;;;;;;;;;;;;if  (not (compilable-arglist defun-func arglist))\n;;;;;;;;;;;;;;;;;;;;;;then\n;;                        (princ\n;;     #.(string-append \"Definition contains non-compilable arglist, \"\n;;                      \"will load interpretive definition of \")\n;;                        )\n;;                        (princ defun-func)\n;;                        (terpri)\n;;;;;;;;;;;;;;;;;;;;;;;;;;(push `(xdefun . ,(cdr form)) loadlist)\n;;;;;;;;;;;;;;;;;;;;;;else\n                          (push\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;`(zevdsub ',defun-func (subr ,defun-func))\n                                `(,zdef ,defun-func)\n                                loadlist)\n                          (push form complist)\n                      endif\n                     ))\n             (macro  (setq defun-rest (cdr defun-rest))\n                     (push form complist)\n                     (eval form)  ; Also make macro def available.\n                     )\n             (fexpr  (princ\n\"FEXPR definition not compilable, will compile code to execute \"\n                     )\n                     (princ defun-func)\n                     (princ\n\" and transform it into a macro.\"\n                     )\n                     (terpri)\n;;;;;;;;;;;;;;;;;;;; (push `(xdefun . ,(cdr form)) loadlist)\n                     (let* ((fexpr-subr (concat defun-func \" FEXPR\"))\n                            (fexpr-macro\n                                 `(defmacro ,defun-func\n                                            (&rest x)\n                                            `(,',fexpr-subr `,',x)))\n                           )\n                           (push `(defun ,fexpr-subr\n                                         ,(car defun-rest)\n                                         . ,(cdr defun-rest))\n                                 complist)\n                           (push `(,zdef ,fexpr-subr) loadlist)\n                           (push fexpr-macro complist)\n                           (push `(xdefmacro . ,(cdr fexpr-macro))\n                                 loadlist)\n                           (eval fexpr-macro); Also make macro def avail\n                     ))\n             )\n         else\n         if (consp (cadr form))\n         then\n            (desetq (nil (defun-func defun-prop) . defun-rest) form)\n            (or defun-rest (go defun-error))\n            (if  (member (cadr form) (get '*zilco* 'nocompile))\n             then\n                 (princ\n          \"NOCOMPILE requested, will load interpretive definition of \")\n                 (princ (cadr form))\n                 (terpri)\n                 (push `(putprop ',defun-func\n                                 '(lambda . ,defun-rest) ; Note, no #'.\n                                 ',defun-prop)\n                       loadlist)\n             else                             ; ZILCO will compile #'s.\n                 (setq defun-name (concat defun-func \" \" defun-prop))\n                 (push `(putprop ',defun-func\n;;; lexically scoped DEFUN?? ;;; #',defun-name\n                                 (subr ,defun-name)\n                                 ',defun-prop)\n                        loadlist)\n                 (push `(defun ,defun-name . ,(cddr form)) complist)\n             endif\n            )\n         else (go defun-error)\n         endif\n        )\n        (return)\n\n  defun-error\n\n        (terpri)\n        (princ \"Invalid DEFUN syntax: \")\n        (prin1 form)\n        (terpri)\n        (return)\n\n  process-declare\n\n        (zilcodcl (cdr form) nil e) ; Process DECLARE right here & now.\n\n;;;;;;; (push form complist)      ; Don't wait for the compiler 2 C it.\n        (return)\n\n  process-defload\n\n        (push `(xdefload . ,(cdr form)) loadlist)\n        (push form complist)\n        (return)\n\n  process-defvar\n\n        (setq form (cdr form))\n\n        (cond\n         ((null form)\n          (princ \"Too few arguments - DEFVAR\")\n          (terpri)\n          (return))\n         ((null (cdr form))\n          (push `(zevxvar ',(car form))\n                loadlist))\n         ((null (cddr form))\n          (push `(zevxvar ',(car form)\n                          . ,(defvar-maybe-thunk (cadr form)))\n                loadlist))\n         ((null (cdddr form))\n          (push `(zevxvar ',(car form)\n                          ,@(defvar-maybe-thunk (cadr form))\n                          ,(caddr form))\n                loadlist))\n         (t (princ \"Too many arguments - \")\n            (prin1 (cons 'defvar form))\n            (terpri)\n            (return)))\n\n        (push `(declare (special ,(car form))) complist)\n        (return)\n\n  process-progn\n\n        (dolist (x (cdr form)) (zilcomod x e))\n        (return)\n\n  process-eval-when\n;\n; EVAL-WHEN is interpreted as follows:\n;\n; COMPILE - pass to the compiler as is.\n;\n; EVAL    - ignore.\n;\n; LOAD    - process like all the rest.\n;\n\n        (let* (\n               ((nil times . forms) form)\n               (compilep            (memq 'compile times))\n               (loadp               (memq 'load    times))\n              )\n              (loop for f in forms\n                    when compilep do (eval f)\n                    when loadp    do (zilcomod f e)\n                    finally       (return nil)))\n\n        (return)\n\n )\n)\n\n(defun defvar-maybe-thunk (x)\n (if (or (null x) (eq x t) (numberp x) (stringp x)\n         (and (consp x) (eq (car x) 'quote)))\n     `(nil ,x)\n     `(t #'(lambda () ,x))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOMVP": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x16\\x8f\\x00\\x89\\x15o\\x11\\x08\\x00)\\x00\\x06\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-16T00:00:00", "modifydate": "1989-06-05T11:08:00", "lines": 41, "newlines": 6, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* ZILCOMVP                                                            *\n;*                                                                     *\n;* This function determines whether it is possible that multiple       *\n;* values might get returned, based on the \"V\" and \"S\" arguments.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zilcomvp (v s)\n (cond\n  (v         nil) ; Not if a SETQ is being done.\n  ((null s)  nil) ; Not if evaluated for effect only.\n  ((eq s t)  t)   ; Maybe, if evaluated for return value.\n  (t\n   (let (((s1 s2) s))\n        (case s1\n              ((goto uwp)\n               (zilcomvp (get s2 'vartarg) (get s2 'rettarg)))\n              ((mvlist mvbind)\n               t)\n              ((throw)\n               (eq s2 'form))\n              (otherwise nil))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOQUO": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x08\\x00$\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:08:00", "lines": 36, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; This function creates a quoted string suitable for inclusion in an\n; assembler language program, i.e. quotes and ampersands are doubled.\n;\n; Input is an exploded atom name, i.e. a list of character symbols.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zilcoquo (a)\n (prog (x z)\n       (setq x (ncons '\\'))    ; Start with an opening quote mark.\n  loop\n       (or a (go finish))\n       (setq z (car a))           ; A character of the input atom.\n       (when (or (eq z '\\')       ; If it is a quote mark\n                 (eq z '\\&))      ; or it is an ampersand\n             (push z x))          ; then add it twice.\n       (push z x)                 ; Else add it once.\n       (setq a (cdr a))\n       (go loop)\n  finish\n       (push '\\' x)               ; Add the closing quote mark.\n       (return (nreverse x))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILCOSEG": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\t\\x00\\x8b\\x00z\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:09:00", "lines": 139, "newlines": 122, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; ZILCOSEG\n\n;;;\n;;; This function performs \"function segmentation\", which is a means\n;;; of splitting up the body of a function into a series of subfunctions\n;;; that are small enough to compile without exhausting the supply of\n;;; base registers.\n;;;\n;;; Segmentation proceeds as follows:\n;;;\n;;; (1) The body of the function is \"flattened out\":\n;;;\n;;;     (a) The body is fully macroexpanded.\n;;;\n;;;     (b) All PROGN's are replaced with their bodies, which are\n;;;         spliced into the main body (a list of forms).\n;;;\n;;;     (c) Each atom or \"constant\" form (i.e. (QUOTE something))\n;;;         is removed from the body unless it is the last form of\n;;;         the body (i.e. the return value).\n;;;\n;;;  Step (1) is no longer required, as the body has been\n;;;  fully macroexpanded, compiler-transformed, and PROGN-flattened\n;;;  by the time ZILCOSEG sees it.\n;;;\n;;; (2) The resultant \"flattened\" body is \"segmented\":\n;;;\n;;;     (a) The number of forms per segment is determined by taking\n;;;         the number of segments desired (specified in a DECLARE)\n;;;         and dividing the total number of forms by this value.\n;;;\n;;;     (b) The forms in the body are then used to build new functions\n;;;         named \"name segment 1\", \"name segment 2\", etc., which\n;;;         contain forms 1-n, n+1-2n, etc. of the flattened body.\n;;;\n;;;     (c) The original function definition is replaced with one\n;;;         that calls the functions built above in return.\n;;;\n;;; Caveats:\n;;;\n;;;  The function should take no arguments, otherwise a problem is\n;;;  created with variable bindings having to be referenced in the\n;;;  built functions.\n;;;\n;;; This function is called from ZCCFUNC with the following operands:\n;;;\n;;; (ZILCOSEG\n;;;          funname    -  the symbol naming the function to segment.\n;;;          lambdaexp  -  the lambda expression being the function def.\n;;;          segmentno  -  the number of segments desired.\n;;; )\n;;;\n;;; Note that it is permissible for the number of segments to be 1.\n;;; In this case the user may wish to separate the program code from\n;;; the data (LISP objects) for more addressability.\n;;;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/11/88 - Cleaned up code including \"Warning:\" prefix on warning.  *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zilcoseg (funname lambdaexp segmentno)\n (let (((nil arglist . bodd) lambdaexp))\n  (unless (null arglist)\n          (warn \"Segmenting a function with a non-null arglist\"\n                funname))\n  `(lambda ,arglist\n           . ,(segmentize funname bodd segmentno))))\n\n(defun segmentize (fun bod seg)\n (let* ((length (length bod))\n        (seglen (cond\n                 ((> seg length)\n                  (setq seg length)\n                  1)\n                 (t\n                  (+ (/ length seg) (if (zerop (\\\\ length seg)) 0 1)))))\n       )\n       (do ((bod bod (cdr bod))\n            (s 0)\n            (segcount 0)\n            (endflag nil)\n            z\n            segment\n           )\n           (endflag (nreverse z))\n           (cond\n            ((null bod)\n             (setq endflag t s seglen))\n            (t\n             (push (car bod) segment)\n             (setq s (1+ s))))\n           (when (and segment (>= s seglen))\n            (push `((label ,(concat fun \" SEGMENT \" (incf segcount))\n                           (lambda () . ,(nreverse segment))))\n                  z)\n            (setq segment nil s 0)))))\n\n;;; Obsolete code follows...\n\n;;; Arg 2 to SEGMENTIZE used to be...\n;;;;;;;;;;;;;;;;;;;;;;;;;;(flatten-body (mapcar #'fexpand bodd) t)\n;;;\n;\n;(defun flatten-body (bodd save-last-form-p)\n; (let ((lastform (if save-last-form-p (last bodd) nil)))\n;       (mapcon #'(lambda (l &aux (x (car l)))\n;                         (cond\n;                          ((and (or (atom x)\n;                                    (and (eq (car x) 'quote)\n;                                         (consp (cdr x))))\n;                                (or (not save-last-form-p)\n;                                    (neq l lastform)))\n;                           nil)\n;                          ((and (consp x) (eq (car x) 'progn))\n;                           (flatten-body (cdr x)\n;                                         (eq l lastform)))\n;                          (t\n;                           (ncons x))))\n;               bodd)))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOSYM": {"ttr": 8203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\t\\x00\\xa8\\x00\\xa6\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:09:00", "lines": 168, "newlines": 166, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;   \"SYMBOLPAIR\"\n;\n;\n; This generates a symbol appropriate for an IBM external name.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defun zilcosym (f k)\n (cond\n  ( (eq k 'atoms)   (sympair-atoms f k) )\n  ( (eq k 'subrs)   (sympair-subrs f k) )\n  ( t               (zerror \"Invalid arg 2 to ZILCOSYM\" K))))\n\n(defun sympair-atoms (f k)\n (cond\n  ( (null f)        (zerror \"Invalid use of NIL as symbol.\"))\n  ( (eq f t)        (zerror \"Invalid use of T as symbol.\"))\n  ( (symbolp f)     (sympair-alpha   f k))\n  ( t               (sympair-numeric f  ))))\n\n(defun sympair-alpha (f k)\n (prog (a)\n  (return\n   (if   (setq a (assq f alfatoms))  ; If it's already an atom\n    then\n         a                        ; then return existing pair\n    else\n    if   (or (assq f allsubrs)    ; if not an atom, but a subr\n             (rassq f allsubrs))  ; (could be found in either half)\n    then\n         (sympair-add f (gensym) atoms alfatoms) ; then create a symbol\n    else                                         ; else try to use name\n         (sympair-add f (sympair-name f k) atoms alfatoms)\n    endif))))\n\n(defun sympair-subrs (f k)\n (prog (a f1)\n  (setq f1 (or (get f 'cautoload) f)) ; Possibly DEFLOADed subr name.\n  (return\n   (if   (setq a (assq f allsubrs))   ; If it's already a subr\n    then\n         a                            ; then return existing pair\n    else\n    if   (and (setq a (assq f1 alfatoms))  ; If an atom currently exists\n              (eq f1 (cdr a)))             ; with the same name as our\n    then                                   ; (possibly defloaded) subr\n         (sympair-fix f f1)        ; then fix up names and pair them\n    else                   ; Else atom has GENSYM name or isn't an atom\n         (sympair-add f (sympair-name f1 k) subrs allsubrs)\n    endif))))\n\n(defun sympair-numeric (f)\n (prog (l m)\n  (setq l (cdr numatoms))   ; Get list of all atoms for this function.\n loop\n  (or l                     ; At end, must add a new entry\n      (return (sympair-add f (gensym) atoms numatoms)))\n  (setq m (car l))          ; Get each pair in list\n  (and (eql f (car m))      ; If the types match and values are equal\n       (return m))                       ; then return this pair\n  (setq l (cdr l))         ; Else try next pair\n  (go loop)))\n\n(defun sympair-add (f g l1 l2)\n (prog (p)\n  (setq p (cons f g))\n  (modq l2 p)\n  (if   (numberp f)\n   then (remprop g 'length)\n        (remprop g 'quoted)\n   else (prog (e l)\n         (and (get g 'length) (return nil))\n         (setq e (explodec f))\n         (setq l (length e))\n         (putprop g l 'length)\n         (putprop g (zilcoquo e) 'quoted)\n        )\n   endif\n  )\n  (remprop g 'location)\n  (remprop g 'indirect)\n  (when (eq l1 subrs)\n        (putprop g t 'real))\n  (if debug\n   then\n         (princ \"Added \")\n         (princ (if (eq l1 subrs) 'subr 'atom))\n         (princ \": \")\n         (princ p)\n         (terpri)\n  )\n  (return p)))\n\n(defun sympair-name (f k)\n;\n; Check if name is valid, IBM-style.\n;\n (prog (e l g)\n  (setq e (explodec f))\n  (setq l (length e))\n  (setq g\n   (if (and (eq k 'atoms)\n            (memq f (get '*zilco* 'reserved))\n       ) ; If not a subroutine but a reserved name, then can't use.\n    then (gensym)\n    else\n    if (and (plusp l)                       ; Length must not be zero\n            (< l 9)                         ; Length must be 1-8\n            (null (string-verify f          ; All valid characters\n                          \"@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"))\n            (< (car e) \"0\")                 ; First must be alpha or\n            (neq (car e) '\\#)               ;       national but not #.\n            (not (eql (substr f 1 3) \"ZLC\")); Name cannot begin with ZLC\n            (not (and (eq (car e) '\\G)      ;      or look like a GENSYM\n                      (null (string-verify (string-substr f 1 6)\n                                           \"0123456789\" 2))))\n       )\n    then f\n    else (gensym)\n    endif\n   )\n  )\n  (putprop g l 'length)\n  (putprop g (zilcoquo e) 'quoted)\n  (return g)))\n\n(defun sympair-fix (f f1)\n;\n; If there is a naming conflict between a subroutine name and an atom\n; name, the conflict must be resolved in favor of the subroutine.\n; F1 is both our prospective subr name and the existing atom name.\n;\n (prog (g z)\n  (setq g (gensym))   ; Create a new symbol for existing atom\n                      ; Copy properties to new symbol\n                      ; (Don't use SETPLIST!!!)\n  (putprop g (get f1 'length)   'length)\n  (putprop g (get f1 'quoted)   'quoted)\n  (putprop g (get f1 'location) 'location)\n  (putprop g (get f1 'indirect) 'indirect)\n  (putprop g (get f1 'real)     'real)\n  (and (setq z (assq f1 atoms))\n       (rplacd z g))\n  (and (setq z (assq f1 alfatoms))\n       (rplacd z g))\n  (return (sympair-add f f1 subrs allsubrs)))) ; Make a new subr\n\n(defun rassq (a b)\n (loop for x in b\n       when (eq a (cdr x))\n       return x\n       finally (return nil)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILCOTRN": {"ttr": 8205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x88\\to\\x00\\x89\\x15o\\x11\\t\\x02\\xcd\\x02\\xb8\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1989-06-05T11:09:00", "lines": 717, "newlines": 696, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n   ;;\n   ;; Steps in adding a new special form:\n   ;;\n   ;; (1) Add it to the list in ZEVINIT.\n   ;; (2) Add it to ZILEVAL.\n   ;; (3) Add it to FEXPAND.\n   ;; (4) Add it to ZILCOINT.\n   ;; (5) Add it to ZILCOTRN.\n   ;; (6) Figure out how to compile it.\n   ;;\n\n;;; This is the compiler transform implementer.  It takes a LISP form\n;;; and does a complete codewalk, transforming ecah form within it.\n;;;\n;;; Transforming a form consists of the following steps:\n;;;\n;;; (1) Fully macroexpand the form (using MACROEXPAND).\n;;; (2) If the result is an atom, do the appropriate processing\n;;;     on the atom (if any).\n;;;     If the result is a function call, transform each argument\n;;;     to the function call via ZILCOTRN.\n;;;     If the result is a special form, transform the arguments\n;;;     (where appropriate) via ZILCOTRN.\n;;; (3) If the CAR of the form is a LAMBDA expression,\n;;;     transform the contents of the LAMBDA expression and\n;;;     apply transformations associated with LAMBDA to the form.\n;;;     If the CAR of the form is a symbol, and it has an\n;;;     associated compiler transform function, apply that\n;;;     function to the result of (2).\n;;;    If the CAR of the form does not have an associated\n;;;    compiler transform function, we are finished.\n;;; (4) If the result of (3) is EQUAL to the result of (2),\n;;;     we are finished.  Otherwise, repeat the process\n;;;     from (1).\n;;;\n;;; A compiler transform function receives 3 arguments:\n;;;\n;;; (1) the complete form being transformed (the CAR being the\n;;;     function name)\n;;; (2) the \"environment\", which is currently a list of the\n;;;     locally bound variables (special or nonspecial) that\n;;;     are lexically available to the code\n;;; (3) a list of keywords describing the context in which the\n;;;     form is being evaluated.  If this list is null, the\n;;;     form is being evaluated for effect only.  Possible\n;;;     keywords that may be present include:\n;;;\n;;;       :value        will be used as a return value (or values)\n;;;       :argument     will be used as an argument to a function\n;;;       :setq         will be used to set a variable\n;;;       :predicate    will be used in a test for NIL\n;;;\n;;;     ...and others...\n;;;\n;;;     More than one of the above keywords may be present.\n;;;\n;;; Note: As a special hack for callers of ZILCOTRN that wish to\n;;;       pass a LAMBDA expression, ZILCOTRN (but not its lower-\n;;;       level functions) will transform a LAMBDA-expression\n;;;       as well as an evaluable form.\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 04/05/88 - The \"ENV\" environment is built, as a list of variables.  *\n;* 04/27/88 - Improvements to PROGN/PROG processing, including call to *\n;*            ZXSEQOPT to do optimizations on sequential forms.        *\n;* 06/02/88 - New special forms BLOCK, TAGBODY, RETURN-FROM,           *\n;*            MULTIPLE-VALUE-BIND, MULTIPLE-VALUE-LIST, THROW.         *\n;* 06/15/88 - Contexts improved to establish more reliably the times   *\n;*            when multiple values might be returned from a form.      *\n;*            Compiler transforms should assume that multiple values   *\n;*            are possible when the context is one of the following:   *\n;*             (:VALUE), (:RETURN), (:MVLIST), (:MVBIND)               *\n;* 06/23/88 - Support for PROG and RETURN removed.                     *\n;* 11/01/88 - Bug fix - not transforming THROW calls properly.         *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defargs zxseqopt 4 4 nil)\n\n(declare (special *ztran-debug*))\n\n(defun zilcotrn (x &optional (*ztran-debug* nil))\n (let ((dumcon '(:dummy)))\n  (if (and (consp x) (eq (car x) 'lambda))\n      (ztran-lambda x nil dumcon)\n      (ztran x nil dumcon))))\n\n(defun ztran (oldform env con)\n (prog (form xfun newform)\n       (setq form oldform)\n\n    restart\n\n;;; (1) Fully macroexpand the form (using MACROEXPAND).\n\n       (unless (ok (setq form (zilcomex form t)))\n               (return form))\n\n;;; (2) If the result is an atom, do the appropriate processing\n;;;     on the atom (if any).\n\n       (cond\n        ((atom form)\n         (setq newform (ztran-atom form env con))\n         (go test))\n\n;;;     If the result is a special form, transform the arguments\n;;;     (where appropriate) via ZILCOTRN.\n\n        ((and (symbolp (car form))\n              (get (car form) '|SPECIAL FORM|))\n         (setq form (ztran-special-form form env con)))\n\n;;;     If the result is a function call, transform each argument\n;;;     to the function call via ZILCOTRN.\n\n        ;;; Note: We know at this point that the CAR of the form\n        ;;;       cannot be a macro, since MACROEXPAND took care\n        ;;;       of that already.  Since FEXPR's don't exist as\n        ;;;       far as the compiler is concerned, this HAS to\n        ;;;       be a function call.\n\n        (t\n         (setq form (cons (car form)\n                    (ztran-args (cdr form) env '(:argument)))))\n\n      ) ; end COND\n\n;;; (3) If the CAR of the form is a LAMBDA expression,\n;;;     transform the contents of the LAMBDA expression and\n;;;     apply transformations associated with LAMBDA to the form.\n\n      (cond\n       ((consp (car form))\n        (setq form (cons (ztran-lambda (car form) env nil)\n                         (cdr form)))\n        (setq newform (lambda-transform form env con))\n       )\n\n        ;;;\n        ;;; Note:\n        ;;;\n        ;;; ZTRAN-LAMBDA takes a LAMBDA-expression (or other\n        ;;; form that can occur in functional position) and\n        ;;; fully transforms its contents.\n        ;;;\n        ;;; LAMBDA-TRANSFORM takes a form whose CAR is a\n        ;;; LAMBDA-expression (or other form that can occur\n        ;;; in functional position) and applies transformation\n        ;;; rules to it, much like a transformation function\n        ;;; associated with a symbol.\n        ;;;\n\n;;;     If the CAR of the form is a symbol, and it has an\n;;;     associated compiler transform function, apply that\n;;;     function to the result of (2).\n\n       ((and (symbolp (car form))\n             (setq xfun (get (car form) 'compiler-transform)))\n        (unless (ok (setq newform (funcall xfun form env con)))\n                (return form))\n       )\n\n;;;    If the CAR of the form does not have an associated\n;;;    compiler transform function, we are finished.\n\n       (t\n        (setq newform form)\n        (go return)))\n\n;;; (4) If the result of (3) is EQUAL to the result of (2),\n;;;     we are finished.  Otherwise, repeat the process\n;;;     from (1).\n\n   test\n\n       (cond\n        ((equal newform form)\n         (go return))\n        (t\n         (setq form newform)\n         (go restart)))\n\n   return\n\n       (when *ztran-debug*\n             (unless (equal newform oldform)\n              (cterpri)\n              (princ \"With ENV=\") (prin1 env)\n              (cterpri)\n              (princ \" and CON=\") (prin1 con)\n              (cterpri)\n              (prin1 oldform)\n              (princ \" transformed into \")\n              (unless (atom newform)\n                      (princ \"... \")\n                      (terpri))\n              (prin1 newform)\n              (terpri)\n              (terpri)\n        )\n       )\n\n       (return newform)\n\n))\n\n(defun ztran-atom (form env con)\n\n ;;;\n ;;; This function applies appropriate transformations to atoms.\n ;;;\n\n (cond\n\n ;;\n ;; If the atom is being evaluated for effect only, convert it to NIL.\n ;; ZTRAN-PROGN, which is the main processor of \"effect-only\" forms,\n ;; will excise all NILs from the form as it transforms it.\n ;;\n\n  ((null con) nil)\n\n   ;;\n   ;; No other transformations are applicable.\n   ;;\n\n  (t form)\n )\n)\n\n(defun ztran-special-form (form env con)\n\n ;;;\n ;;; This function applies appropriate transformations to\n ;;; special forms, by transforming the forms contained therein\n ;;; that are in evaluable positions.\n ;;;\n ;;; It does NOT apply transformation rules for the special forms.\n ;;; For example, a transformational rule for special form SETQ\n ;;; is applied to the result of this function if there is a\n ;;; compiler transform property associated with the symbol SETQ.\n ;;; This function merely prepares the form for the transformation.\n ;;;\n\n (case (car form)\n  ((quote go defload declare)\n   form)\n  ((function subr)\n   (list* (car form)\n          (ztran-lambda (cadr form) env nil)\n          (cddr form)))\n  ((throw arg setarg listify)\n   (cons (car form)\n         (ztran-args (cdr form) env '(:argument))))\n  ((and or)          (cons (car form)\n                           (ztran-and-or         (cdr form) env con)))\n  (catch             (cons (car form)\n                           (ztran-catch          (cdr form) env con)))\n  (block             (cons (car form)\n                           (ztran-block          (cdr form) env con)))\n  (return-from       (cons (car form)\n                           (ztran-return-from    (cdr form) env con)))\n  (tagbody           (cons (car form)\n                           (ztran-tagbody        (cdr form) env con)))\n  (progn             (cons (car form)\n                           (ztran-progn          (cdr form) env con)))\n  (cond              (cons (car form)\n                           (ztran-cond           (cdr form) env con)))\n  (setq              (cons (car form)\n                           (ztran-setq           (cdr form) env con)))\n  (unwind-protect    (cons (car form)\n                           (ztran-unwind-protect (cdr form) env con)))\n  (defun             (cons (car form)\n                           (ztran-defun          (cdr form) env con)))\n  (defvar            (cons (car form)\n                           (ztran-defvar         (cdr form) env con)))\n  (eval-when         (cons (car form)\n                           (ztran-eval-when      (cdr form) env con)))\n  (multiple-value-list\n                (cons (car form)\n                      (ztran-multiple-value-list (cdr form) env con)))\n  (multiple-value-bind\n                (cons (car form)\n                      (ztran-multiple-value-bind (cdr form) env con)))\n  (t (zerror \"Special form unknown to ZILCOTRN\" (car form)))))\n\n(defun ztran-cond (form env con) ; form = ((a1) (b1 b2) (c1 c2 c3) ...)\n (prog (z clause)\n   loop\n       (cond\n        ((atom form)  ; Again, just in case of bad form.\n         (return (nreconc z form)))\n        ((atom (setq clause (car form)))\n         (push clause z)) ; Erroneous but let it pass...\n        ((null (cdr clause))\n         (push (ncons (ztran (car clause) env (cons ':predicate con)))\n               z))\n        (t\n         (push (cons (ztran (car clause) env '(:predicate))\n                     (ztran-progn (cdr clause) env con))\n               z))\n       )\n       (setq form (cdr form))\n       (go loop)\n )\n)\n\n\n(defun ztran-setq (form env con) ; form = (arg1 val1 arg2 val2 ...)\n (prog (z)\n  loop\n       (when (atom form)\n             (return (nreconc z form)))\n       (push (car form) z) ; SETQ variable\n       (setq form (cdr form))\n       (when (atom form)\n             (return (nreconc z form)))\n       (if (null (cdr form))\n           (push (ztran (car form) env (cons :setq con)) z)\n           (push (ztran (car form) env '(:setq)) z))\n       (setq form (cdr form))\n       (go loop)))\n\n(defun ztran-defun (form env con)\n                           ;  form = (foo (arglist) . body)\n                           ;      or (foo macro (arglist) . body)\n                           ;      or (foo fexpr (arglist) . body)\n\n (if (memq (cadr form) '(expr fexpr macro))\n     (list* (car form)\n            (cadr form)\n            (ztran-arglist (caddr form) #'(lambda (new) (setq env new))\n                                        env nil)\n            ;;; Note how ENV is updated by lambda list processing.\n            (ztran-progn (cdddr form) env '(:value)))\n     (list* (car form)\n            (ztran-arglist (cadr form) #'(lambda (new) (setq env new))\n                                       env nil)\n            ;;; Note how ENV is updated by lambda list processing.\n            (ztran-progn (cddr form) env '(:value)))))\n\n(defun ztran-defvar (form env con);form = (varname value documentation)\n (if (null (cddr form))\n     form\n     (list* (car form)\n            (cadr form)\n            (ztran (caddr form) env '(:bind))\n            (cdddr form))))\n\n(defun ztran-eval-when (form env con)\n ; form = ((compile eval load) . body)\n (list* (car form) (ztran-progn (cdr form) env con)))\n\n(defun ztran-block (form env con)\n ; form = (<blockname> . body)\n (list* (car form) (ztran-progn (cdr form) env con)))\n\n(defun ztran-return-from (form env con)\n ; form = (<blockname> . body)\n (cond\n  ((null form) form)\n  (t (list* (car form) (ztran-args (cdr form) env '(:return))))))\n\n(defun ztran-tagbody (form env con)\n (ztran-some-kind-of-block form env nil t))\n\n(defun ztran-multiple-value-list (form env con)\n (ztran-args form env '(:mvlist)))\n\n(defun ztran-multiple-value-bind (form env con)\n ;\n ; Even though &optional, etc. aren't permitted in the arglist of\n ; MULTIPLE-VALUE-BIND, we still transform it as if it was, to allow\n ; the maximum possible amount of destructuring.  It isn't even\n ; certain that destructuring will be allowed in the arglist here.\n ;\n (if (consp form)\n     (let* (((arglist bindform . boddy) form)\n            (oldenv env)\n            (transformed-arglist\n             (ztran-arglist arglist #'(lambda (new) (setq env new))\n                                    env nil))\n            (transformed-bindform\n             (ztran bindform oldenv '(:mvbind)))\n            (transformed-boddy\n             (ztran-progn (cddr form) env con))\n           )\n           (list* transformed-arglist\n                  transformed-bindform\n                  transformed-boddy))\n     form))\n\n\n\n(defun ztran-args (form env con)\n\n ;;;\n ;;; This function applies appropriate transformations to\n ;;; functions, by transforming all the arguments.\n ;;;\n ;;; It does NOT apply transformation rules for the function.\n ;;; This function merely prepares the form for the transformation\n ;;; associated with the function name (or for LAMBDA transforms).\n ;;;\n\n (prog (z)\n   loop\n       (cond\n        ((null form)\n         (return (nreverse z)))\n        ((atom form)  ; Again, just in case of bad form.\n         (return (nreconc z form)))\n        (t\n         (push (ztran (car form) env con) z))\n       )\n       (setq form (cdr form))\n       (go loop)\n )\n)\n\n(defun ztran-lambda (form env con)\n\n ;;;\n ;;; This function applies appropriate transformations to\n ;;; LAMBDA-expressions, converting the LAMBDA expression\n ;;; (or LABEL or other non-atomic functional form)\n ;;; so that all evaluable components are fully transformed.\n ;;;\n ;;; It does NOT apply transformation rules for LAMBDA.\n ;;; This function merely prepares the form for the transformation\n ;;; that LAMBDA-TRANSFORM does on forms that start with a\n ;;; LAMBDA expression.\n ;;;\n ;;; \"form\" is a symbol, LAMBDA expression, LABEL expression, etc.\n ;;; Although ZTRAN doesn't call ZTRAN-LAMBDA directly for a form\n ;;; in the CAR of a form, this may get called from the FUNCTION\n ;;; special form processing.\n ;;;\n\n (if (or (atom form) (atom (cdr form)))\n     form\n     (case (car form)\n      (lambda\n       (list* (car form)\n              (ztran-arglist (cadr form) #'(lambda (new) (setq env new))\n                                         env nil)\n              (ztran-progn (cddr form) env '(:value))))\n;;;\n;;; This (\"LABEL\") will have to be deleted in favor of Common LISP\n;;; LABELS/FLET/MACROLET, which are probably going to be new\n;;; special forms.\n;;;\n      (label\n       (list (car form)\n             (cadr form)\n             (ztran-lambda (caddr form) env con)))\n\n      (t\n       form))))\n\n(defun ztran-arglist (form updater env con)\n\n ;;;\n ;;; This function applies appropriate transformations to\n ;;; a LAMBDA argument list, by transforming the evaluable forms\n ;;; contained therein.\n ;;;\n\n (prog (mode a z new-updater pusher)\n       (setq new-updater #'(lambda (new) (setq env new)))\n       (setq pusher      #'(lambda (x) (push x env)))\n  loop\n       (or form (go end))\n       (when (atom form)\n             (push form env)\n             (funcall updater env)\n             (return (nreconc z form)))\n       (setq a (car form))\n       (when (llkeywdp a)\n             (push (setq mode a) z)\n             (go cont)\n       )\n       (case mode\n        (&optional\n         (cond\n          ((atom a)\n           (push a env)\n           (push a z))\n          ((null (cdr a))\n           (push (list (ztran-arglist (car a) new-updater env con)) z))\n          ((atom (cddr a))\n           (let ((oldenv env))\n            (push (list* (ztran-arglist (car a) new-updater env con)\n                         (ztran (cadr a) oldenv '(:bind))\n                         (cddr a))\n                  z)))\n          (t\n           (let ((oldenv env))\n            (push (list* (ztran-arglist (car a) new-updater env con)\n                         (ztran (cadr a) oldenv '(:bind))\n                         (cddr a))\n                  z)\n            (when (atom (caddr a))\n                  (push (caddr a) env))))))\n        (&aux\n         (cond\n          ((atom a)\n           (push a env)\n           (push a z))\n          ((null (cdr a))\n           (push (list (ztran-arglist (car a) new-updater env con))\n                 z))\n          (t\n           (let ((oldenv env))\n            (push (list* (ztran-arglist (car a) new-updater env con)\n                         (ztran (cadr a) oldenv '(:bind))\n                         (cddr a))\n                  z)))))\n        (&key\n         (cond\n          ((atom a)\n           (push a env)\n           (push a z))\n          ((null (cdr a))\n           (push (list (ztran-key (car a) pusher new-updater env con))\n                 z))\n          ((atom (cddr a))\n           (let ((oldenv env))\n            (push (list* (ztran-key (car a) pusher new-updater env con)\n                         (ztran (cadr a) oldenv '(:bind))\n                         (cddr a))\n                  z)))\n          (t\n           (let ((oldenv env))\n            (push (list* (ztran-key (car a) pusher new-updater env con)\n                         (ztran (cadr a) oldenv '(:bind))\n                         (cddr a))\n                  z)\n            (when (atom (caddr a))\n                  (push (caddr a) env))))))\n        (t\n         (push (ztran-arglist a new-updater env con) z)))\n  cont\n       (setq form (cdr form))\n       (go loop)\n   end\n       (funcall updater env)\n       (return (nreverse z))\n )\n)\n\n(defun ztran-key (a pusher updater env con)\n (cond\n  ((atom a)\n   (funcall pusher a)\n   a)\n  ((atom (cdr a))\n   (funcall pusher (car a))\n   a)\n  (t\n   (list* (car a)\n          (ztran-arglist (cadr a) updater env con)\n          (cddr a)))))\n\n(defun ztran-progn (form env con)\n ;;;\n ;;; This function applies appropriate transformations to\n ;;; the CONTENTS of an implicit PROGN, by transforming the forms\n ;;; contained therein.\n ;;;\n ;;; It does NOT apply transformation rules for PROGN.\n ;;; This function merely prepares the form for the transformation\n ;;; associated with PROGN, if any.\n ;;;\n ;;; \"form\" is a list of forms, NOT including any PROGN function form.\n ;;;\n ;;; Note that ZTRAN-PROGN must NEVER return a null list.  In that way\n ;;; incorrect transformations for COND clauses are avoided.\n ;;;\n (or (ztran-some-kind-of-block form env con nil)\n     (list nil)))\n\n(defun ztran-and-or (form env con)\n (prog (z)\n   loop\n       (cond\n        ((atom form)\n         (return (nreconc z form)))\n        ((null (cdr form)) ; This is the last form...\n         (push (ztran (car form) env con) z))\n        (t\n         (push (ztran (car form) env (cons ':predicate con)) z))\n       )\n       (setq form (cdr form))\n       (go loop)\n )\n)\n\n(defun ztran-catch (form env con)\n (cons (ztran (car form) env '(:argument))\n       (ztran-progn (cdr form) env con)))\n\n(defun ztran-unwind-protect (form env con)\n (cons (ztran (car form) env con)\n       (ztran-progn (cdr form) env nil)))\n\n\n(defun lambda-transform (form env con)\n\n ;;;\n ;;; This is the transformation function for LAMBDA expressions.\n ;;; It takes a form whose CAR is a LAMBDA expression (or LABEL\n ;;; expression or other equivalent that can occur in functional\n ;;; position) and applies transformation rules to the entire form.\n ;;;\n ;;; \"form\" is the entire form whose CAR is the LAMBDA expression.\n ;;;\n ;;; For example, if a form looks like this:\n ;;;\n ;;; ((LAMBDA () .  anything))\n ;;;\n ;;; and \"anything\" does not contain any declarations,\n ;;; then it can be transformed to\n ;;;\n ;;; (PROGN . anything)\n ;;;\n ;;; (Note that transformation will proceed by applying transformation\n ;;; rules for PROGN if any, but not until after this function returns)\n ;;;\n\n (let (\n       (funn (car form))\n       (args (cdr form))\n      )\n  (cond\n   ;;\n   ;; ((LAMBDA () . x)) --> (PROGN . x)  if x contains no declarations\n   ;;\n   ((and (consp funn)\n         (eq (car funn) 'lambda)\n         (null args)\n         (null (cadr funn))\n         (null (assq 'declare (cddr funn))))\n    `(progn . ,(cddr funn)))\n   (t\n   ;;\n   ;; No other transformations are applicable.\n   ;;\n    form)\n  )\n )\n)\n\n;\n; ZTRAN-SOME-KIND-OF-BLOCK prepares a block of sequential code for\n; optimization.  It is used on explicit and implicit PROGN, PROG,\n; BLOCK and TAGBODY.\n;\n; The final result is passed to ZXSEQOPT, the \"sequential optimizer\",\n; for additional transformations (like SETQ collapsing), before being\n; returned to the caller.  Note that ZXSEQOPT is invoked only once at\n; this time, not repeatedly.\n;\n\n(defun ztran-some-kind-of-block (boddy env con tagp)\n (prog (z y thiscon)\n   loop\n       (cond\n        ((atom boddy)\n         (return (zxseqopt (nreconc z boddy) env con tagp)))\n        ((and tagp (atom (car boddy))) ; GO tag?\n         (push (car boddy) z))\n        ;\n        ; \"Evaluate\" the form (for effect if it's not the last form).\n        ; If form transforms to an atom and is for effect only,\n        ; it is useless, so discard it.\n        ;\n        ((progn (setq thiscon (if (null (cdr boddy)) con nil))\n                (setq y (ztran (car boddy) env thiscon))\n                (and (null thiscon) (atom y)))\n         nil)\n        ;\n        ; If the form is another PROGN, get the arguments\n        ; to the PROGN into this block (i.e. \"flatten out\" the\n        ; nested PROGN's).\n        ;\n        ((and (consp y) (eq (car y) 'progn))\n         (setq z (nreconc (cdr y) z)))  ;  \"Flatten in\" PROGN's.\n        ;\n        ; Otherwise, add the form.\n        ;\n        (t\n         (push y z))\n       )\n       (setq boddy (cdr boddy))\n       (go loop)))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILCOVTA": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\t\\x00!\\x00\\x17\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:09:00", "lines": 33, "newlines": 23, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"VALUE-THROWN-AWAY\"\n;\n; This function determines if the value produced by a predicate\n; function is used or not.  If the value is not used, better code\n; may be produced for the predicate function.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(include #.(zil-source-member zilmacs))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defun zilcovta (s)\n (cond\n  ((null s)       t)\n  ((memq (car s) '(goto gonil gonotnil))\n                  (and (null (get (cadr s) 'vartarg))\n                       (null (get (cadr s) 'popsalist))\n                       (null (get (cadr s) 'popfalist))\n                       (null (get (cadr s) 'forceniltest))\n                       (zilcovta (get (cadr s) 'rettarg))))\n  (t              nil)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILDUMP": {"ttr": 8454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87!\\x7f\\x00\\x89\\x15o\\x11\\x10\\x00\"\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-08-05T00:00:00", "modifydate": "1989-06-05T11:10:00", "lines": 34, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(defun zildump (x)\n (cond\n  ((fixnump x)\n   (format nil \"~8,'0x\" (zildump-asis x)))\n  ((sfloatp x)\n   (format nil \"~8,'0x\" (zildump-asis (make-fixnum x))))\n  ((dfloatp x)\n   (let (((lh . rh) (make-fixnum x)))\n    (format nil \"~8,'0x~8,'0x\" (zildump-asis lh) (zildump-asis rh))))\n  ((bigp x)\n   (mapcar #'zildump (biglist x)))\n  ((stringp x)\n   (do ((i (string-length x) (1- i))\n        (z ()\n           (cons (format nil \"~2,'0x\" (getcharn x i)) z))\n       )\n       ((zerop i)\n        (string-appendl z))))\n  (t\n   (zerror \"Argument to ZILDUMP cannot be dumped\" (typep x) x))))\n\n(defun zildump-asis (x)\n (if (minusp x)\n     (+ #.(** 2 32) x)\n     x))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILEVAL": {"ttr": 8456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x019\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x10\\x02\\xe2\\x02G\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.57", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:10:00", "lines": 738, "newlines": 583, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The guts of the EVALUATOR.\n;\n;         Implementation notes:\n;\n;         See ZILAPPLY for discussion of the \"environment\" arg and\n;         how it affects FEXPR's and the \"alist\" arg to functions.\n;\n;         See MKNEWENV for discussion of the \"environment\" arg and\n;         what to do if the format needs to be changed.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/01/88 - Changes to support multiple values, BLOCK and TAGBODY    *\n;*            even before they're implemented.  ZEVMACS changed.       *\n;*                                                                     *\n;* 06/13/88 - Support for THROW as a special form, required in order   *\n;*            to support multiple values.                              *\n;*                                                                     *\n;* 06/27/88 - Support for PROG and RETURN removed.                     *\n;*                                                                     *\n;* 12/14/88 - Fixed BLOCK processing by adding unwind-protection.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n;;;\n;;; The current deep binding scheme implements fake value cells\n;;; (actually binding cells) for global variables.  This consists of a\n;;; binding pair stored in the \"PBIND\" cell of the symbol.\n;;;\n;;; When shallow binding is implemented for specials, some changes\n;;; will take place to both ZILAPPLY and ZILEVAL, not to mention\n;;; many others.  In any case, support needs to be added to ZILAPPLY\n;;; for inline declarations.\n;;;\n\n   ;;\n   ;; Steps in adding a new special form:\n   ;;\n   ;; (1) Add it to the list in ZEVINIT.\n   ;; (2) Add it to ZILEVAL.\n   ;; (3) Add it to FEXPAND.\n   ;; (3) Add it to ZILCOTRN.\n   ;; (4) Add it to ZILCOINT.\n   ;; (5) Figure out how to compile it.\n   ;;\n\n(defload car zcar)\n\n;\n; Macro definitions\n;\n\n(include #.(zil-source-member zevmacs)) ; Include evaluator macros.\n\n(defun zileval (x a toplevelp)\n (let (q r s)\n  (cond\n    ( (null x)                nil                                    )\n    ( (symbolp x)\n                              (if (eq (pbind x) x) ; Self-evaluating?\n                                  x\n                                  (evsymbol x a))                    )\n\n;;; All other kinds of atoms (numbers, etc.) are self-defining.\n\n    ( (atom x)                x                                      )\n\n;;; If this is a dotted pair (CDR is a non-NIL atom), reject.\n\n    ( (progn\n       (desetq (q . r) x)\n       (and r (atom r)))\n                              (zerror  \"Invalid S-expression\" x)     )\n\n;;; The following two hacks are in case of evaluating (#.#'foo bar baz)\n;;; or (#.(subr foo) bar baz) hacks.  These are sort of irregular,\n;;; but placed up front in case of efficiency hacks in the interpreter\n;;; which replace symbols with their compiled functions or something.\n\n;;; If CAR of the form is subr or closure, process like a subr call.\n\n    ( (codep q)               (zilxsub q (zevlist r a))              )\n\n;;; If CAR of the form is an interpreted lexical closure, apply it.\n\n    ( (funargp q)             (zilapply (funfun q)\n                                        (zevlist r a)\n                                        (funenv q)\n                                        q)                           )\n\n;-----------------------------------------------------------------------\n;\n;\n;;; Add tests for FSUBRP, etc. here if they should ever exist.\n;\n;   ( (??????p q)             (zilxsub q r)                          )\n;\n;-----------------------------------------------------------------------\n\n;;; If CAR of the form is a list, pass it directly to APPLY, which\n;;; will signal an error unless the form is a LAMBDA or LABEL or such.\n;;; Pass the same environment through.\n\n    ( (consp q)               (zilapply q (zevlist r a) a q)         )\n\n;;; If CAR of the form is an atom, but not a compiled code object,\n;;; then it has to be a symbol, else no good (e.g. numbers are bad).\n\n    ( (not (symbolp q))\n      (zerror \"Invalid form in functional position\" q)               )\n\n;;; If CAR of the form is a symbol, it's some kind of function name.\n\n    ( (progn\n       (setq s (or (getl q '(macro |SPECIAL FORM| expr fexpr subr))\n                   '(nil)))\n\n       ;;; Macros override everything else.\n\n       (eq (car s) 'macro))\n                              (zileval (macroexpand x) a toplevelp)  )\n\n;;; Check all special forms.\n\n    ( (eq (car s) '|SPECIAL FORM|)\n      (case q\n             (quote               (car (or r\n                                           (zerror \"Missing argument\"\n                                                   'quote)))          )\n             (cond                (evcon r a)                         )\n             (setq                (evsetq r a)                        )\n             (and                 (evand r a)                         )\n             (or                  (evor r a)                          )\n             (progn               (evprogn r a toplevelp)             )\n             (block               (evblock r a)                       )\n             (return-from         (evretfrom r a)                     )\n             (tagbody             (evtagbody r a)                     )\n             (go                  (evgo r a)                          )\n             (function            (mkfunarg (car (or r\n                                                     (zerror\n                                                     \"Missing argument\"\n                                                     'function)))\n                                                  a)                  )\n\n             (defun               (zevdefun r toplevelp)              )\n             (defvar              (zevdvar r toplevelp)               )\n             (defload             (zevdefld r toplevelp)              )\n             (catch               (evcatch r a)                       )\n             (throw               (evthrow r a)                       )\n             (unwind-protect      (evuwp r a)                         )\n             (arg                 (evarg r a)                         )\n             (setarg              (evsetarg r a)                      )\n             (listify             (evlistify r a)                     )\n             (eval-when           (evevwhen r a toplevelp)            )\n             (subr                (car (or r\n                                           (zerror \"Missing argument\"\n                                                   'subr)))           )\n             (declare             (evdcl r a toplevelp)               )\n\n             (multiple-value-list (evmvlist r a)                      )\n             (multiple-value-bind (evmvbind r a)                      )\n\n             (t (zerror \"Special form unknown to EVAL\" q)))           )\n\n;;; Not a special form - look for functional property.\n;;;\n;;; Note: If dynamic scoping, pass \"a\" instead of \"nil\" to ZILAPPLY in\n;;;       the calls for EXPR and FEXPR below.\n;;;\n\n    ( (eq (car s) 'subr)      (zilxsub (cadr s) (zevlist r a))       )\n\n    ( (eq (car s) 'expr)      (zilapply (cadr s) (zevlist r a) nil q) )\n\n    ( (eq (car s) 'fexpr)     (zilapply (cadr s)\n                                        (list r (bindenv a)) nil q)   )\n\n;-----------------------------------------------------------------------\n;\n;   ( (eq (car s) 'fsubr)     (zilxsub (cadr s) (list r (bindenv a))))\n;\n;-----------------------------------------------------------------------\n\n;\n; Otherwise, resolve using AUTOLOAD property if any.\n;\n    ( t                       (zevauto q t)\n                              (zileval x a toplevelp)                )\n  )\n )\n)\n\n;\n; EVSYMBOL - evaluate symbol.\n;\n; Note - the hacks for the symbols OBLIST and ALIST have been deleted.\n;\n\n(defun evsymbol (x a)\n (let (v)\n  (cond\n\n;;;;;; Maybe \"self-evaluating\" or \"constant\" - no support for those yet.\n;;;\n;;; Self-evaluating symbols (those whose PBIND cells point to\n;;; themselves, like T or keywords) were handled in ZILEVAL and\n;;; not passed to this routine.\n;;;\n;;; ((self-evaluating-p x) x)\n;;; ((constant-symbol-p x) x)\n;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   ;; First, search local bindings in environment.\n\n   ;; Note that the CDR of this binding pair cannot be the \"unbound\"\n   ;; object, because that should be placed there only by MAKUNBOUND\n   ;; (which is defined to work on special bindings only).\n\n   ((setq v (assq x (bindenv a)))\n    (cdr v))\n\n   ;; If not locally bound, see if it is special.\n\n   ((or (memq x (specenv a))   ;  If it is in pervasive SPECIAL decls,\n        (specialp x))          ;  or globally proclaimed SPECIAL,\n    (cdr (or (zevsym x)                  ; find the SPECIAL binding.\n             (zerror \"Unbound SPECIAL variable\" x))))\n\n   ;; If not found there, search for a special binding.\n   ;; After all, this code might have been invoked by a compiled\n   ;; routine that declared the variable SPECIAL, either implicitly\n   ;; (e.g. a DEFMETHOD) or explicitly (e.g. the * ** *** - + ++ +++\n   ;; variables of READ-EVAL-PRINT).\n\n   ((consp (setq v (zevsym x)))\n    (cdr v))\n\n   ;; If not found there either, give up.\n\n   (t\n    (zerror \"Unbound variable\" X)))))\n\n\n\n;\n; EVCON - evaluate special form COND\n;\n(defun evcon (x a)\n (prog (v)\n   loop\n       (or x (return nil))\n       (and (atom (car x))\n            (zerror \"Invalid COND syntax\" (car x)))\n       (and (setq v (zileval (caar x) a nil))\n            (return (if (null (cdar x)) ; (COND ((FORM)) ...) ?\n                        v\n                        (evprogn (cdar x) a nil))))\n       (setq x (cdr x))\n       (go loop)))\n\n;\n; EVGO - evaluate special form GO\n;\n(defun evgo (l a &aux tag)\n (cond\n  ( (null l)                 (zerror  \"Missing argument\" 'go)          )\n  ( (cdr l)                  (zerror  \"Too many arguments\" 'go)        )\n  ( (not (or (symbolp (setq tag (car l)))\n             (integerp tag)))\n                             (zerror  \"Invalid GO tag\" tag)            )\n  ( (null (progenv a))       (zerror  \"GO outside of PROG\" l)          )\n  ( t\n    (let (prog-body-from-tag-onward)\n         (loop for env in (progenv a)\n               when    (setq prog-body-from-tag-onward\n                             (member tag (progbody env)))\n               do      (unless (cdr (tagbodytag env))\n                               (zerror \"GO to inactive PROG\" tag))\n                       (throw (tagbodytag env)\n                              (setf (progrest env)\n                                    (cdr prog-body-from-tag-onward)))\n               finally (zerror \"GO tag undefined\" tag))))))\n\n;\n; EVPROGN - evaluate special form PROGN\n;\n(defun evprogn (r a toplevelp)\n (cond\n  ((null r) nil)\n  (t\n   (prog ()\n    loop (cond\n          ((null (cdr r))\n           (return (zileval (car r) a toplevelp))) ; possible M.V.'s\n          (t\n           (zileval (car r) a toplevelp)           ; effect only\n           (setq r (cdr r))\n           (go loop)))))))\n\n;\n; EVSETQ - evaluate special form SETQ\n;\n(defun evsetq (r a)\n (prog (var val z)\n  loop (or r (return z))\n       (setq var (car r))\n       (or (cdr r) (zerror \"Odd number of arguments\" 'setq))\n       (setq val (cadr r))\n       (setq z (evsetq1 var val a))\n       (setq r (cddr r))\n       (go loop)))\n\n(defun evsetq1 (var val a &aux v)\n (unless (and var (symbolp var) (neq (pbind var) var))\n         (zerror \"Invalid SETQ variable\" var))\n\n (cond\n\n;;;;;; Maybe \"self-evaluating\" or \"constant\" - no support for those yet.\n;;;\n;;; The \"self-evaluating\" case was handled by the PBIND check above.\n;;;\n;;; ((self-evaluating-p x) (zerror \"Cannot assign to this variable\" x))\n;;; ((constant-symbol-p x) (zerror \"Cannot assign to this variable\" x))\n;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n ;; First, search for a current interpretive/lexical binding.\n ;; If one is found, RPLACD it.\n\n  ((setq v (assq var (bindenv a)))\n   (setf (cdr v) (zileval val a nil)))\n\n ;; If not locally bound, see if it is special.\n\n   ((or (memq var (specenv a)) ;  If it is in pervasive SPECIAL decls,\n        (specialp var))        ;  or globally proclaimed SPECIAL,\n                               ;  then call special-binding-modifier.\n         ;; ZEVSET will always return a binding, never NIL.\n    (cdr (zevset var (zileval val a nil))))\n\n ;; If not there, then assume a new SPECIAL variable.\n ;; ZEVSET will always return a binding, never NIL.\n\n  (t\n\n ;; If the variable is unknown, then assume it is a special variable,\n ;; and mark it special, like NIL does.  Note that this is not done\n ;; for SETQ's originating from compiled code.\n ;;\n ;; Do not force the variable to be SPECIAL if it is already\n ;; on the special-alist, as it may be put there by FLAVORS.\n ;;\n ;; Globally bound variables may be forced SPECIAL, since\n ;; they should have been to begin with.\n\n   (unless (or\n               (specialp var)            ; No warn if declared special\n               (assq var (special-alist)); No warn if dynamically bound\n           )                             ; (even if it has no value)\n    (warn \"SETQ assigning to assumed SPECIAL variable\" var)\n    (setf (specialp var) t)\n   )\n   (cdr (zevset var (zileval val a nil))))))\n\n;\n; EVAND - evaluate special form AND\n;\n(defun evand (r a)\n (if (null r)\n     t\n     (prog ()\n      loop (when (null (cdr r))\n                 (return (zileval (car r) a nil))) ; possible M.V.'s\n           (when (null (zileval (car r) a nil))    ; test only\n                 (return nil))\n           (setq r (cdr r))\n           (go loop))))\n\n;\n; EVOR - evaluate special form OR\n;\n(defun evor (r a)\n (if (null r)\n     nil\n     (prog ()\n      loop (when (null (cdr r))\n                 (return (zileval (car r) a nil))) ; possible M.V.'s\n           (return\n            (cond\n             ((zileval (car r) a nil))              ; test only\n             (t\n              (setq r (cdr r))\n              (go loop)))))))\n\n;\n; EVCATCH - evaluate special form CATCH\n;\n(defun evcatch (r a)\n (cond\n  ( (not (and r (cdr r)))  (zerror  \"Too few arguments\" 'catch)        )\n  ( t                      (let (((tag . form) r))\n                                (catch (zileval tag a nil)\n                                       (evprogn form a nil)))          )\n )\n)\n;\n; EVTHROW - evaluate special form THROW\n;\n(defun evthrow (r a)\n (cond\n  ( (not (and r (cdr r)))  (zerror  \"Too few arguments\" 'throw)        )\n  ( (not (null (cddr r)))  (zerror \"Too many arguments\" 'throw)        )\n  ( t                      (let (((tag form) r))\n                                (throw (zileval tag a nil)\n                                       (zileval form a nil)))          )\n )\n)\n;\n; EVUWP - evaluate special form UNWIND-PROTECT\n;\n(defun evuwp (r a)\n (cond\n  ( (not (and r (cdr r)))  (zerror  \"Too few arguments\" 'unwind-protect))\n  ( t                      (let (((pf . cf) r))\n                                (unwind-protect (zileval pf a nil)\n                                                (evprogn cf a nil))))))\n;\n; EVARG - evaluate special form ARG\n;\n; Note: only for ZIL, (ARG T) gives the list of args lexpr-bound.\n;       This allows, for example, Maclisp LISTIFY to be implemented\n;       using (ARG T).\n;\n(defun evarg (r a)\n (let* ((arg (argenv a))\n        (env (if (null arg) (zerror \"ARG outside of LEXPR\" r) (car arg)))\n       )\n  (if (null r)\n   then\n    (length env)\n   else\n   if (cdr r)\n   then\n    (zerror \"Too many arguments\" 'arg)\n   else\n    (let\n     ((n (zileval (car r) a nil)))\n     (cond\n      ((null n)    (length env))\n      ((eq n t)    env)\n      ((fixnump n) (evarg-nth (1- n) env n))\n      (t (zerror \"Argument to ARG not NIL, T, or fixnum\" n)))))))\n\n(defun evarg-nth (n arglist original-n)\n (prog ()\n  loop\n       (and (or (null arglist)\n                (minusp n))\n            (zerror \"ARG value does not exist\" original-n))\n       (and (zerop n)\n            (return (car arglist)))\n       (setq n (1- n))\n       (setq arglist (cdr arglist))\n       (go loop)))\n\n;\n; EVSETARG - evaluate special form SETARG\n;\n(defun evsetarg (r a)\n (or r         (zerror \"Too few arguments\" 'setarg))\n (or (cdr r)   (zerror \"Too few arguments\" 'setarg))\n (and (cddr r) (zerror \"Too many arguments\" 'setarg))\n (prog (n v arg env)\n  (setq arg (argenv a))\n  (setq env (if (null arg)\n                (zerror \"SETARG outside of LEXPR\" r)\n                (car arg)))\n  (setq n (zileval (car r) a nil))\n  (setq v (zileval (cadr r) a nil))\n  (cond\n   ((fixnump n) (evsetarg-rplacnth (1- n) env v n))\n   (t           (zerror \"Argument 1 to SETARG not a fixnum\" n))\n  )\n  (return v)))\n\n(defun evsetarg-rplacnth (n arglist v original-n)\n (prog ()\n  loop\n       (and (or (null arglist)\n                (minusp n))\n            (zerror \"SETARG value does not exist\" original-n))\n       (and (zerop n)\n            (return (rplaca arglist v)))\n       (setq n (1- n))\n       (setq arglist (cdr arglist))\n       (go loop)))\n\n;\n; EVLISTIFY - evaluate special form LISTIFY\n;\n\n(defun evlistify (r a)\n (and r (cdr r) (zerror \"Too many arguments\" 'listify))\n (let* (\n        (arg (argenv a))\n        (env (if (null arg)\n                 (zerror \"LISTIFY outside of LEXPR\" r)\n                 (car arg)))\n        (n   (if r (zileval (car r) a nil)))\n        (argn (length env)))\n  (cond ((null n)       env)\n        ((not (fixp n)) (zerror \"Arg to LISTIFY not a fixnum or NIL\" n))\n        ((minusp n)     (let ((l (+ argn n)))\n                             (if (plusp l)\n                                 (nthcdr l env)\n                                 env)))\n        ((zerop n)      nil)\n        ((lessp n argn) (do ((i 1 (1+ i))\n                             (a env (cdr a))\n                             (z nil))\n                            ((or (null a) (> i n)) z)\n                            (setq z (nconc z (list (car a))))))\n        (t              env))))\n\n\n;\n; EVEVWHEN - evaluate special form EVAL-WHEN\n;\n; (eval-when (compile) ignored.\n; (eval-when (load)    ignored.\n; (eval-when (eval)    evaluated.\n;\n\n(defun evevwhen (r a toplevelp)\n (unless toplevelp\n         (zerror \"Misplaced EVAL-WHEN\"))\n (or r (zerror \"Too few arguments\" 'eval-when))\n (when (memq 'eval (car r))\n       (evprogn (cdr r) a toplevelp)))\n\n;\n; EVDCL - evaluate special form DECLARE\n;\n\n(defun evdcl (r a toplevelp)\n (unless toplevelp\n         (zerror \"Misplaced DECLARE\" r))\n (dolist (declaration r)\n  (if (atom declaration)\n      (warn \"Invalid declaration\" declaration)\n      (case (car declaration)\n            ((special) (dolist (dclarg (cdr declaration))\n                               (evdcl-special dclarg)))\n            ; otherwise ignore declaration...\n      ))))\n\n(defun evdcl-special (var)\n (if (or (null var)\n         (not (symbolp var))\n         (eq var t))\n     (warn \"Invalid DECLARE SPECIAL variable\" var)\n     ;;; (proclaim `(special ,var))\n     (setf (specialp var) t)))\n\n;\n; EVBLOCK - evaluate special form BLOCK\n;\n\n(defun evblock (x a)\n (prog (blockname p penv)\n  (unless x\n          (zerror \"Missing block name and forms\" x))\n  (setq blockname (car x))\n  (unless (symbolp blockname)\n          (zerror \"Invalid BLOCK block name\" blockname))\n\n  (setq p (make-progenv))          ; Fresh PROG environment component.\n\n  (setf (blocktag p) (cons blockname t)) ; Create a unique BLOCK tag.\n\n  (setq penv (copyenv a))          ; Create a new environment.\n  (push p (progenv penv))          ; Add new PROG environment component.\n\n  (unwind-protect\n   (catch (blocktag p)\n          (setf (progvalue p)\n                (multiple-value-list\n                 (evprogn (cdr x) penv nil))))\n\n  ;;; If RETURN-FROM is executed, a THROW will occur that sets\n  ;;; (progvalue p) to the value(s) being returned.\n\n   (setf (cdr (blocktag p)) nil)   ; Invalidate RETURN from this BLOCK.\n  )\n\n  (return (values-list (progvalue p)))\n))\n\n;\n; EVRETFROM - evaluate special form RETURN-FROM\n;\n\n(defun evretfrom (l a &aux bname)\n (cond\n  ( (null l)            (zerror \"Missing block name\" 'return-from))\n  ( (cddr l)            (zerror \"Too many arguments\" 'return-from))\n  ( (not (symbolp (setq bname (car l))))\n                        (zerror  \"Invalid RETURN-FROM block name\" bname))\n  ( t\n    (loop for env in (progenv a)\n          with btag\n          do   (setq btag (blocktag env))\n          when (and btag (eq bname (car btag)))\n          do   (unless (cdr btag)\n                       (zerror \"RETURN-FROM block inactive\" bname))\n               (throw (blocktag env)\n                      (setf (progvalue env)\n                            (multiple-value-list\n                             (zileval (if (cdr l) (cadr l) nil) a nil)\n                            )\n                      ))\n          finally (zerror \"RETURN-FROM block does not exist\" bname)))))\n\n;\n; EVTAGBODY - evaluate special form TAGBODY\n;\n\n(defun evtagbody (x a &aux stmt p penv)\n (when x                             ; Return NIL if no forms.\n  (setq p (make-progenv))            ; Fresh PROG environment component.\n  (setf (tagbodytag p) (cons nil t)) ; Create a unique TAGBODY tag.\n  (setf (progbody p) x)              ; Executable body including tags.\n  (setf (progrest p) x)            ; Initialize executable body to body.\n  (setq penv (copyenv a))          ; Create a new environment.\n  (push p (progenv penv))          ; Add new PROG environment component.\n\n  (unwind-protect\n   (loop do\n         (setq stmt (car (progrest p)))\n         (setf (progrest p) (cdr (progrest p)))\n         (unless (atom stmt)\n                 (catch (tagbodytag p)\n                        (zileval stmt penv nil)))\n\n                 ; If (GO xxx), will change PROGREST.\n\n         while (progrest p)\n   )\n   (setf (cdr (tagbodytag p)) nil) ; Invalidate GO to this TAGBODY.\n  ))\n nil) ; Always return NIL.\n\n;\n; EVMVLIST - evaluate special form MULTIPLE-VALUE-LIST\n;\n\n(defun evmvlist (r a)\n (cond\n  ((null r)\n   (zerror \"Too few arguments\" 'multiple-value-list))\n  ((not (null (cdr r)))\n   (zerror \"Too many arguments\" 'multiple-value-list))\n  (t\n   (multiple-value-list (zileval (car r) a nil)))))\n\n;\n; EVMVBIND - evaluate special form MULTIPLE-VALUE-BIND\n;\n\n(defun evmvbind (r a)\n (cond\n  ((or (null r) (null (cdr r)))\n   (zerror \"Too few arguments\" 'multiple-value-bind))\n  (t\n   (let (((vars form . body) r))\n        (do ((v vars (cdr v)))\n            ((null v))\n            (cond\n             ((atom v)\n              (zerror \"MULTIPLE-VALUE-BIND arglist not a proper list\"\n                      vars))\n             ((llkeywdp (car v))\n              (zerror\n    \"MULTIPLE-VALUE-BIND arglist cannot contain lambda list keywords\"\n                     vars))))\n        ;;;\n        ;;; To avoid a lot of duplication of code, and to let the\n        ;;; code in ZILAPPLY handle the binding, we process a form\n        ;;;  (MULTIPLE-VALUE-BIND (A B C) (VALUE-FORM) . BODY)\n        ;;; as if it were\n        ;;;  ((LAMBDA (&OPTIONAL (A NIL) (B NIL) (C NIL) &REST (NIL))\n        ;;;           . BODY)\n        ;;;   (MULTIPLE-VALUE-LIST (VALUE-FORM)))\n        ;;; The explicit NILs are there in case the variable names\n        ;;; are destructuring templates, which is accepted in ZIL.\n        ;;; The body may, of course, contain declarations.\n        ;;; This works out as equivalent, if you think about it -\n        ;;; the variables are set to NIL if not found in the\n        ;;; resulting list, and any extras are swallowed up by the\n        ;;; dummy &REST argument.  (This would work as a macro for\n        ;;; compilation as well, except that we don't want to CONS\n        ;;; in compiled code - the whole point of multiple values\n        ;;; is to avoid consing!)\n        ;;;\n        ;;; (NIL) works as the dummy &REST argument because:\n        ;;;  * we don't want to use GENSYM in the interpreter so that\n        ;;;    user calls to GENSYM come out in \"normal\" sequence\n        ;;;  * &REST NIL is equivalent to no &REST arg, the way the\n        ;;;    interpreter works now\n        ;;;  * &REST (NIL) is a destructuring request that throws away\n        ;;;    the CAR of the &REST list and ignores the rest (n.p.i.)\n        ;;;\n        (zilapply\n         (mkfunarg\n          `(lambda (&optional ,.(mapcar #'(lambda (x) `(,x nil))\n                                        vars)\n                              &rest (nil))\n                   . ,(or body '(nil)))\n           a)\n         (multiple-value-list (zileval form a nil))\n         a\n         'multiple-value-bind)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILFLAT": {"ttr": 8462, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x10\\x00$\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:10:00", "lines": 36, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; (defun flatc    (x) (zilflat x nil))\n; (defun flatsize (x) (zilflat x t  ))\n;\n\n(defun zilflat (x p)\n (cond\n  ((null x)    3) ; length of \"NIL\"\n  ((consp x)   (prog (n)\n                     (setq n 1)\n                loop\n                     (setq n (+ 1 n (zilflat (zcar x) p)))\n                     (when (setq x (cdr x))\n                           (if (atom x)\n                               (return (+ 3 n (zilflat x p)))\n                               (go loop)))\n                     (return n)))\n  ((vectorp x) (if (zerop (vlength x))\n                   3\n                   (1+ (zilflat (vlist x) p))))\n  ((funargp x) (+ #.(+ (string-length \"<FUNARG \") (string-length \" >\"))\n                  (zilflat (funfun x) p)))\n  ((structp x) (+ #.(+ (string-length \"<STRUCT \")\n                       (string-length \" >\")\n                       -2)              ; subtract 2 for vlist parens\n                  (zilflat (vlist x) p)))\n  (t           (string-length (tostring x p)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILHELP": {"ttr": 8464, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x13\\x00\\x92\\x00<\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:13:00", "lines": 146, "newlines": 60, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; This function is called ZILHELP, but is invoked by a macro named HELP,\n; so that users can have the benefit of using (HELP) under ZIL without\n; needing to quote the operand; but it was done this way primarily so\n; there is no conflict with the TSO HELP command, in case one wishes\n; to do (TSO 'HELP).\n;\n; A is the function name for which HELP info is desired.\n; F is T for full-screen, NIL for no-full-screen.\n;\n;                       ; e.g. (HELP CAR) --> (ZILHELP 'CAR)\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/09/88 - Added support for new special forms pertaining to        *\n;*            BLOCK, TAGBODY and multiple values.                      *\n;* 06/17/88 - Now returns no values.                                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n(declare (special *zil-help-library*))\n\n(defun zilhelp (&optional a f)\n (if a\n  then\n       (unless (symbolp a)\n               (zerror \"HELP operand not a symbol\" a))\n       (let ((helpmember (string-append \"'\" *zil-help-library* \"(\"\n                               (zilhelp-member-name a) \")'\")))\n        (if (not (open helpmember :probe))\n         then\n             (princ \"There is no HELP available for \")\n             (princ a)\n             (princ \".\")\n             (terpri)\n         else\n         if f\n         then\n            (cond\n             ((ispfp) (zisexec \"CONTROL DISPLAY REFRESH\")\n                      (zisexec \"BROWSE DATASET(\" helpmember \")\")\n                      (zisexec \"CONTROL DISPLAY REFRESH\")\n             )\n             (t       (tso \"LIST \" helpmember \" NON FUL\")))\n            (cterpri)\n            (princ a)\n         else\n            (with-open-file (file helpmember)\n              (loop\n                    initially (clrscrn)\n                    for line = (readline file)\n                    until (eof file)\n                    do (cterpri) (princ line)\n                    ))\n         endif\n        ))\n  else\n;       (princ \"HELP is available for the following members of...\")\n;       (terpri)\n;       (tso \"XLISTM '\" *zil-help-library* \"'\")\n;       (terpri)\n        (princ\n\"\nHELP documentation is contained in '\")\n(princ *zil-help-library*)\n(princ \"'.\n\nType (HELP ZIL)        for an introduction to ZIL.\nType (HELP FUNCTIONS)  for a list of functions.\nType (HELP <name>)     for information about <name>, where <name> is\n                       a ZIL function or a member of '\")\n(princ *zil-help-library*)\n(princ \"'.\")\n#+DRAPER (progn\n(princ \"\n\nFor a list of help members, type (TSO \\\"XLISTM '\")\n(princ *zil-help-library*)\n(princ \"'\\\").\n\nFor full screen help, type (HELP name T); for full screen news, (NEWS T).\n\n\"\n        )\n         ) ; end #+DRAPER\n  endif\n )\n (values)\n)\n\n(defun zilhelp-member-name (name)\n (let* ((autoload (get name 'autoload))\n        (loadname (if (and autoload (symbolp autoload))\n                      autoload\n                      name))\n        (pair (assq loadname '(\n                               (+                    . \"PLUS\"    )\n                               (-                    . \"DIFFEREN\")\n                               (*                    . \"TIMES\"   )\n                               (/                    . \"QUOTIENT\")\n                               (//                   . \"REMAINDE\")\n                               (\\\\                   . \"REMAINDE\")\n                               (**                   . \"EXPT\"    )\n                               (\u00ac                    . \"EXPT\"    )\n                               (=                    . \"ZILEQUAL\")\n                               (<                    . \"LESSP\"   )\n                               (>                    . \"GREATERP\")\n                               (1+                   . \"ADD1\"    )\n                               (1-                   . \"SUB1\"    )\n                               (zil                  . \"$@INTRO\" )\n                               (functions            . \"$HELP\"   )\n                               (do*                  . \"DO\"      )\n                               (let*                 . \"LET\"     )\n                               (list*                . \"LIST\"    )\n                               (prog*                . \"PROG\"    )\n                               (eval-when            . \"EVALWHEN\")\n                               (unwind-protect       . \"UNWIND\"  )\n                               (princ-to-string      . \"PRINTS\"  )\n                               (prin1-to-string      . \"PRINTS\"  )\n                               (with-open-file       . \"WITHOPEN\")\n                               (return-from          . \"RETURNFR\")\n                               (multiple-value-bind  . \"MVBIND\"  )\n                               (multiple-value-call  . \"MVCALL\"  )\n                               (multiple-value-list  . \"MVLIST\"  )\n                               (multiple-value-prog1 . \"MVPROG1\" )\n                               (multiple-value-setq  . \"MVSETQ\"  )\n                       )))\n       (realname (if pair (cdr pair) loadname))\n      )\n       (cond\n        (pair\n         (cdr pair))\n        ((> (string-length loadname) 8)\n         (string-substr loadname 1 8))\n        (t\n         loadname))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILIN": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x00D\\x00Q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 68, "newlines": 81, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The ZIL 1.3 Interpreter.\n;\n; Note: Top-level specials defined in ZEVINIT.\n;\n\n (declare (special *version*))\n\n ;;;(zevinit) ; ZIL system initialization is now done from ZILINIT.\n\n (set-feature 'zilin)\n\n (princ \"LISP interpreter (ZIL \")\n (princ *version*)\n (princ #.(string-append \") - Compiled \" (ppdate)))\n (terpri)\n (princ \"Type (NEWS) for news, (HELP) for help, (EXIT) for exit.\")\n (terpri)\n\n (setabend t)                   ; Activate ABEND interception.\n\n;\n; Note: Attention handling is not available while loading the INIT file\n;       (unless (SETATTN T) and a (CATCH T ...) are coded therein).\n;\n\n (catch nil\n  (let ((parm (string-upcase (getparm nil))))\n   (cond\n    ((not (eql parm \"\"))\n     (princ \"Loading INIT file \")\n     (princ parm)\n     (princ \".\")\n     (terpri)\n     (load parm :verbose nil :print t)\n     (terpri)\n    )\n    ((catch nil (ifilep 'init))   ; If INIT exists, load it.\n     (princ \"Loading INIT file.\")\n     (terpri)\n     (read-eval-print 'init)\n     (terpri)\n    )\n    (t\n     (princ \"No INIT file in use.\")\n     (terpri)\n    ))))\n\n (setattn  t)                   ; Activate attention handling.\n\n (read-eval-print nil)          ; READ-EVAL-PRINT loop on std. input.\n\n (setattn  nil)                 ; Deactivate attention handling.\n (setabend nil)                 ; Deactivate ABEND handling.\n\n (princ \"LISP interpreter (ZIL \")\n (princ *version*)\n (princ \") ended.\")\n (terpri)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILMACS": {"ttr": 8707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x00\\x88\\x08/\\x00\\x89\\x15o\\x11\\x15\\x01\\n\\x00\\xe1\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "1988-03-22T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 266, "newlines": 225, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;**********************************************************************\n;\n; Standard MACLIB header for all ZILCO compiler modules.\n;\n;**********************************************************************\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/22/88 - Added declarations for new modules ZCGIASSQ and ZCGIMEMQ *\n;* 03/28/88 - Added declarations for new module ZCGSGOTO.              *\n;* 04/06/88 - Added declarations for new module ZCCVALGO.              *\n;* 04/10/88 - Removed the following variables from the SPECIAL list:   *\n;*            PROGVARS, GOLIST, PROGEXIT                               *\n;* 04/25/88 - Support for determination of superfluous initializations *\n;*            of PROG and &AUX variables to NIL.  This involves two    *\n;*            new fields in the contour that are used to detect cases  *\n;*            of a variable unconditionally being set before it is     *\n;*            ever referenced.  This is an extension of, and replaces, *\n;*            the SETQ-initialization-hacking scheme used in ZCCPROG.  *\n;*            This also requires a new P-code form, CSETNIL, and a new *\n;*            code generator module, ZCGCSNIL.                         *\n;* 04/28/88 - ZCGSTPRM is obsolete; now part of ZCGSTVRS.              *\n;* 05/01/88 - ZCGSTVRS takes more arguments.                           *\n;* 05/13/88 - Added DEFARGS for ZXARITH and ZXRELOP.                   *\n;* 06/06/88 - Extended ZILCEC structure to support BLOCK and TAGBODY.  *\n;*            Added DEFARGS for new compiler routines to support       *\n;*            multiple values and new special forms.                   *\n;* 06/10/88 - Added ZCGMVINI for multiple value support.               *\n;* 06/13/88 - Added ZCCTHROW for multiple value support.               *\n;* 06/16/88 - Added ZILCOMVP for multiple value support.               *\n;* 06/23/88 - Removed support for PROG and RETURN.                     *\n;*                                                                     *\n;***********************************************************************\n;\n; *** MACRO DEFINITIONS FOR ZILCO ET AL. ***\n;\n\n(eval-when (compile)\n           (princ \"Loading ZILCO macros.\")\n           (terpri)\n)\n\n;\n; MODQ attaches a list to the end of a string of lists\n; representing a body of pseudocode or whatever else.\n; PUSHing onto the beginning of the list and NREVERSEing it later\n; would be better.\n;\n\n(defmacro modq (x y) ; add a statement to the given list\n `(nconc ,x (ncons ,y))\n)\n\n(defmacro notp (x)   ; test if a predicate is a (NOT xxx) form.\n (if (atom x)\n     `(and (consp ,x) (eq (car ,x) 'not))\n     (let ((g (gensym)))\n          `(let ((,g ,x))\n                (and (consp ,g) (eq (car ,g) 'not))))))\n\n(defmacro predp (x)   ; test if a predicate is a (foo-p xxx) form.\n (if (atom x)\n     `(and (consp ,x)\n           (symbolp (car ,x))\n           (get (car ,x) 'predicate))\n     (let ((g (gensym)))\n          `(let ((,g ,x))\n                (and (consp ,g)\n                     (symbolp (car ,g))\n                     (get (car ,g) 'predicate))))))\n\n(defmacro alistboundp (pair)\n `(eq (cdr (get (cdr ,pair) 'bindingtype)) t))\n\n(defmacro where-it-is (q)\n `(or (get (cdr ,q) 'location)\n      (putprop (cdr ,q) (gensym) 'location)))\n\n(declare (special\n  alfatoms alllists allsubrs alone argbase atoms body cc codelen\n  codelist debug fluid-asaved fluid-unbounds intfuncs lastarg lists\n  main name numatoms parms pdbas pdmax procs program regs restofit\n  special-asaved special-freevars special-unbounds stack stackmax\n  subrs tailrecur zdef zzzconp zzzcont zzzstksz\n ))\n\n(defstruct zilcec             ; Compilation environment contour.\n                              ; ZCCMKENV is the function that builds it,\n                              ; but other functions set the fields.\n           type               ; DEFUN, LAMBDA, PROG, etc., etc.\n           creator            ; Contour of lexical encloser for funargs\n           bindings           ; Locally bound variable bindings\n           specials           ; Variables declared SPECIAL\n                              ; (be they for bindings or pervasive)\n           go-tags            ; Tags for PROG contour\n           return-tags        ; (formerly PROGEXIT) BLOCK/PROG RETURNs\n           lexpr-arg          ; Name of arg for LEXPR contour\n           tempcond           ; \"Temporarily conditional\" flag  04/25/88\n           permcond           ; \"Permanently conditional\" flag  04/25/88\n           block-name         ; Name of block for PROG/BLOCK\n\n;;;\n;;; The following have been replaced by SPECIALS:\n;;;\n;;;        local-specials     ; Variables locally declared SPECIAL\n;;;                           ; (for bindings)\n;;;        pervasive-specials ; Variables pervasively declared SPECIAL\n;;;                           ; (for references only, not bindings)\n;;;\n\n   ;;; More fields will be added as time goes on, mainly for ;;;\n   ;;; new types of declarations that will be supported..... ;;;\n\n)\n\n;;;\n;;; The following maps the contents of the special variable CC.\n;;;\n\n(defmacro cc-extendedp (x) `(cddr ,x))\n(defmacro cc-true-op   (x) `(car ,x))\n(defmacro cc-false-op  (x) `(cadr ,x))\n(defmacro cc-out-op    (x) `(caddr ,x))\n(defmacro cc-out-logic (x) `(cadddr ,x))\n(defmacro cc-emit-code (x) `(car (cddddr ,x)))\n\n(defargs ZCCAND     4 4 nil)\n(defargs ZCCATOM    4 4 nil)\n(defargs ZCCBIND    2 2 nil)\n(defargs ZCCBLOCK   4 4 nil)   ; 06/06/88\n(defargs ZCCCALL    5 5 nil)\n(defargs ZCCCATCH   4 4 nil)\n(defargs ZCCCOND    4 4 nil)\n(defargs ZCCCONST   4 4 nil)\n(defargs ZCCDCL     4 4 nil)\n(defargs ZCCDEF     4 4 nil)\n(defargs ZCCEVAL    5 5 nil)\n(defargs ZCCEVCOM   4 4 nil)\n(defargs ZCCEXPR    5 5 nil)\n(defargs ZCCFARG    5 5 nil)\n(defargs ZCCFAST    5 5 nil)\n(defargs ZCCFCALL   4 4 nil)\n(defargs ZCCFUNC    4 4 nil)\n(defargs ZCCGO      2 2 nil)\n(defargs ZCCLAMA    4 4 nil)\n(defargs ZCCLAMB    3 3 nil)\n(defargs ZCCLEXFN   5 5 nil)\n(defargs ZCCMKCEC   2 2 nil)\n(defargs ZCCMVBND   4 4 nil)\n(defargs ZCCMVLST   4 4 nil)\n(defargs ZCCNOT     4 4 nil)\n(defargs ZCCOR      4 4 nil)\n(defargs ZCCPRED    1 1 nil)\n(defargs ZCCPROGN   4 4 nil)\n(defargs ZCCQUOTE   4 4 nil)\n(defargs ZCCRETF    2 2 nil)   ; 06/06/88\n(defargs ZCCSETQ    4 4 nil)\n(defargs ZCCTBODY   4 4 nil)   ; 06/06/88\n(defargs ZCCTHROW   4 4 nil)   ; 06/13/88\n(defargs ZCCUWP     4 4 nil)\n(defargs ZCCVALGO   2 2 nil)\n(defargs ZCCVALS    4 4 nil)   ; 06/06/88\n(defargs ZCGAVAIL   1 1 nil)\n(defargs ZCGBASE    2 2 nil)\n(defargs ZCGBCALL   1 1 nil)\n(defargs ZCGBEGIN   1 1 nil)\n(defargs ZCGBIND    1 1 nil)\n(defargs ZCGBLAM    1 1 nil)\n(defargs ZCGBTAG    1 1 nil)\n(defargs ZCGBUWP    1 1 nil)\n(defargs ZCGCALL    1 1 nil)\n(defargs ZCGCLOS    1 1 nil)\n(defargs ZCGCODCK   2 2 nil)\n(defargs ZCGCSNIL   1 1 nil)   ; 04/25/88\n(defargs ZCGDEF     1 1 nil)\n(defargs ZCGELAM    1 1 nil)\n(defargs ZCGEND     1 1 nil)\n(defargs ZCGEMIT    5 5 nil)\n(defargs ZCGENOUT   4 4 nil)\n(defargs ZCGERROR   1 1 nil)\n(defargs ZCGETAG    1 1 nil)\n(defargs ZCGEUWP    1 1 nil)\n(defargs ZCGGETIT   1 1 nil)\n(defargs ZCGGTARG   2 2 nil)\n(defargs ZCGGTBST   1 1 nil)\n(defargs ZCGGTREG   0 0 nil)\n(defargs ZCGGTVAR   1 1 nil)\n(defargs ZCGIASSQ   5 5 nil)\n(defargs ZCGIMEMQ   5 5 nil)\n(defargs ZCGINEXT   5 5 nil)\n(defargs ZCGINLIN   1 1 nil)\n(defargs ZCGIPRED   4 4 nil)\n(defargs ZCGKEY     1 1 nil)\n(defargs ZCGLABEL   1 1 nil)\n(defargs ZCGLOAD    2 2 nil)\n(defargs ZCGMVINI   1 1 nil)\n(defargs ZCGOPT     1 1 nil)\n(defargs ZCGRECUR   1 1 nil)\n(defargs ZCGRELS    1 1 nil)\n(defargs ZCGRESV    1 1 nil)\n(defargs ZCGSGOTO   1 1 nil)\n(defargs ZCGSTOPT   1 1 nil)\n(defargs ZCGSTTRG   2 2 nil)\n(defargs ZCGSTVRS   4 4 nil)\n(defargs ZCGSUBR    1 1 nil)\n(defargs ZILCOADD   2 2 nil)\n(defargs ZILCOARG   2 2 nil)\n(defargs ZILCOAUV   2 2 nil)\n(defargs ZILCOCOM   3 3 nil)\n(defargs ZILCOCON   2 2 nil)\n(defargs ZILCODCL   3 3 nil)\n(defargs ZILCOERR   1 1 nil)\n(defargs ZILCOGEN   1 1 nil)\n(defargs ZILCOINT   0 0 nil)\n(defargs ZILCOMEX   2 2 nil)\n(defargs ZILCOMOD   2 2 nil)\n(defargs ZILCOMVP   2 2 nil)  ; 06/16/88\n(defargs ZILCOQUO   1 1 nil)\n(defargs ZILCOSEG   3 3 nil)\n(defargs ZILCOSYM   2 2 nil)\n(defargs ZILCOTRN   2 2 nil)\n(defargs ZILCOVTA   1 1 nil)\n\n(defargs ZXARITH    3 4 nil)\n(defargs ZXRELOP    2 2 nil)\n\n(eval-when (compile)\n           (princ \"ZILCO preprocessing complete.\")\n           (terpri)\n)\n;\n; *** END MACRO DEFINITIONS ***\n;\n\n;\n; Obsolete compiler modules ***\n;\n\n;(defargs ZCCPROG    4 4 nil)\n;(defargs ZCCRETN    2 2 nil)\n;(defargs ZCGBPROG   1 1 nil)\n;(defargs ZCGECALL   1 1 nil)\n;(defargs ZCGENLST   2 2 nil)\n;(defargs ZCGEPROG   1 1 nil)\n;(defargs ZCCFPRT    3 3 nil)\n;(defargs ZCGFREE    0 0 nil)\n;(defargs ZCGGTLOC   1 1 nil)\n;(defargs ZCGGTPRM   1 1 nil)\n;(defargs ZCGLCVAR   1 1 nil)\n;(defargs ZCGSETT    1 1 nil)\n;(defargs ZCGSMALL   1 1 nil)\n;(defargs ZCGSTATM   1 1 nil)\n;(defargs ZCGSTLST   1 1 nil)\n;(defargs ZCGSTNIL   1 1 nil)\n;(defargs ZCGSTPRM   3 3 nil)  ; 04/28/88\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILMACS0": {"ttr": 8710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x04\\x8f\\x00\\x90\\x04\\x8f\\t5\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-02-17T00:00:00", "modifydate": "1990-02-17T09:35:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1990 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n; Loaded by ZIL compiler if echoing source file to list file.\n; Optionally use this instead of the IEBGENER step in compiler JCL.\n\n(eval-when (compile)\n (echo 'src 'list)\n)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILPP": {"ttr": 8712, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x00e\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 101, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZIL pretty printer SUBR.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/17/88 - Now returns no values.                                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n(declare (special *trace*))\n\n(defun zilpp (f &optional o)\n (cond\n  ((symbolp f)          (pp-symbol f o))\n  ((atom f)             (zerror \"Not a function or variable\" f))\n  ((eq (car f) 'lambda) (pp-lambda f \"#<anonymous function>\" 'expr o))\n  ((eq (car f) 'label)  (pp-lambda (cddr f) (cadr f) 'expr o))\n  (t                    (zerror \"Not a function or variable\" f))\n )\n (cterpri o)\n (values)   ; Return no values, so nothing prints.\n)\n\n(defun pp-symbol (f o &aux p)\n (cond\n  ((assq f *trace*)\n   (let ((z (ziltrace f 'pp)))\n        ;\n        ; (car z) = 'expr or 'subr\n        ; (cdr z) = lambda-expression\n        ;\n        (case (car z)\n         ((nil) (setq p t) (pp-symbol f o))\n         (expr  (setq p t) (pp-lambda (cdr z) f 'expr o))\n        )))\n  ((setq p (get f 'macro)) (pp-lambda p f 'macro o))\n  ((setq p (get f 'expr))  (pp-lambda p f 'expr  o))\n  ((setq p (get f 'fexpr)) (pp-lambda p f 'fexpr o))\n )\n (when (boundp f)\n       (setq p t)\n       (pprint `(setq ,f ,(let ((val (symeval f)))\n                               (if (and val\n                                       (neq val t)\n                                       (or (symbolp val) (consp val))\n                                   )\n                                   `',val\n                                   val)))\n               o)\n       (cterpri o)\n )\n\n (unless p (zerror \"No interpretive function definition or value\" f))\n)\n\n(defun pp-lambda (bod nam typ out)\n (unless (and (consp bod) (eq (car bod) 'lambda))\n         (zerror `(\"Invalid \" ,typ \" property\") nam bod))\n (let* ((arglist (cadr bod))          ; Argument list.\n        (defmacrop (and (eq typ 'macro)\n                   (consp arglist)\n                   (null (car arglist)))))\n       (cterpri out)\n       (princ (if defmacrop \"(DEFMACRO \" \"(DEFUN \") out)  ; ))\n       (prin1 nam out)                ; Function name.\n       (unless (or defmacrop (eq typ 'expr))\n               (princ \" \" out)\n               (princ typ out))       ; Function type.\n       (princ \" \" out)\n       (cond\n        ((and (eq typ 'fexpr)\n              (null (cadr arglist)))\n                         (pprint (ncons (car arglist)) out))\n        ((null arglist)  (princ \"()\" out))\n        ((atom arglist)  (prin1 arglist out))\n        (defmacrop       (pprint (cdr arglist) out))\n        (t               (pprint arglist out)))\n       (terpri out)\n       (loop for i in (cddr bod) do   ; Function body.\n        (cterpri out)\n        (princ \" \" out)\n        (pprint i out)\n       )\n       (cterpri out)    ; (\n       (princ \")\" out)\n       (cterpri out)\n )\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILPROGV": {"ttr": 8714, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x00+\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 43, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZILPROGV\n;\n; See the macro definition for PROGV for how this is used.\n;\n; Note: lambda-expr is assumed to be a lexical closure.\n;\n; UNWIND-PROTECT is not needed, since THROW always resets the\n; SPECIAL-ALIST anyhow.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/14/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun zilprogv (variable-list value-list lambda-expr\n                 &aux (savespec (special-alist)))\n (do ((varlist variable-list (cdr varlist))\n      (vallist value-list (cdr vallist))\n     )\n     ((null varlist))\n     (push (cons (zcar varlist)\n                 (if vallist (zcar vallist) (zilunbnd)))\n           (special-alist)))\n (multiple-value-prog1\n  (funcall lambda-expr)\n  (setf (special-alist) savespec)\n )\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILTEST": {"ttr": 8716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x11\\x9f\\x00\\x89\\x15o\\x11\\x15\\x00}\\x00z\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-04-28T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 125, "newlines": 122, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; ZIL 1.3 documentation tester.\n;;;\n;;; Syntax: (ZILTEST symbol-or-string)\n;;;\n;;; where symbol is a member of *ZIL-HELP-LIBRARY* to be tested\n;;; or string is a dsname to be tested\n;;;\n;\n;***********************************************************************\n;*                                                                     *\n;* Created 04/28/88.                                                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n(declare (special *zil-help-library*))\n\n(defun ziltest (x)\n (with-open-file (file\n                  (cond\n                   ((stringp x)\n                    x)\n                   ((symbolp x)\n                    (string-append \"'\" *zil-help-library* \"(\" x \")'\"))\n                   (t\n                    (zerror \"ZILTEST arg not a string or symbol\" x))))\n                 (ziltest-readdoc file x)))\n\n(defun ziltest-readdoc (file name)\n (prog (count)\n  loop\n   (when (eof file)\n         (zerror \"No examples found in doc\" name))\n   (or (stringp name)\n       (eql (car (string-scan (readline file))) \"Examples:\")\n       (go loop))\n   (when (plusp (setq count (ziltest-putdata file name)))\n         (terpri)\n         (princ \"There are \") (princ count)\n         (princ \" errors in your documentation or implementation.\")\n         (terpri))\n   (return t)))\n\n(defun ziltest-putdata (=file =name)\n (prog (=x = =y =z count)\n  (setq count 0)\n loop\n  (and (eof =file) (return count))\n  (setq =x (read =file))\n  (and (eof =file) (return count))\n  (setq = (read =file))\n  (and (eof =file)\n       (zerror \"\\\"X\\\" but no \\\" = Y \\\" found in doc member\" =name))\n  (or (eq = '==>) (zerror \"No ==> found in doc member\" =name))\n  (prin1 =x)\n  (princ \" ==> \")\n  ;\n  ; To make sure that objects are created properly in V/S space,\n  ; we force construction of a new object immediately following\n  ; evaluation.  If the object created by the function being\n  ; tested didn't set ZLCVSNXT, it will get clobbered by the\n  ; new object.\n  ;\n  (cond\n   ((ok (setq =z (eval =x)) (string-append \"***clobbered***\"))\n    (prin1 =z)\n    (terpri))\n   (t\n    (setq =z (list \"***ERROR***\"))\n    (princ \"*** No value - error!!! ***\")\n    (terpri)))\n  ;\n  ; Must evaluate x before reading y, in case reading y has a side\n  ; effect that would change the evaluation of x.  A case in point\n  ; is GENTEMP, which returns different values depending on what\n  ; has been read in.\n  ;\n  (setq =y (read =file))\n  (and (eof =file) (zerror \"\\\"X = \\\" but no \\\"Y\\\" found.\"))\n  (cond\n   ((ziltest-pequal =y =z) #|(princ \"You're absolutely right!\")|#)\n   (t\n    (terpri)\n    (princ \"Wrong!!! Doc and implementation mismatch!\")\n    (terpri)\n    (princ \"The documentation says... \")\n    (prin1 =y)\n    (terpri)\n    (princ \"The LISP system returns.. \")\n    (prin1 =z)\n    (terpri)\n    (terpri)\n    (incf count)))\n  (go loop)))\n\n(defun ziltest-pequal (a b)\n (or\n  (eql a b)\n  (and (symbolp a)\n       (symbolp b)\n       (eql (pname a) (pname b)))\n  (and (dfloatp a)\n       (dfloatp b)\n       (<= (abs (- a b)) #.(make-flonum #z34100000 #z00000000)))\n  (and (sfloatp a)\n       (sfloatp b)\n       (<= (abs (- a b)) #.(make-flonum #z3C100000)))\n  (and (consp a)\n       (consp b)\n       (ziltest-pequal (car a) (car b))\n       (ziltest-pequal (cdr a) (cdr b)))\n  (and (vecp a)\n       (vecp b)\n       (eq (typep a) (typep b))\n       (ziltest-pequal (vlist a) (vlist b)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILTRACE": {"ttr": 8718, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x00\\xe6\\x006\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 230, "newlines": 54, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/17/88 - Support for multiple values.                             *\n;*                                                                     *\n;* 11/04/88 - Support for AT and OFF.  See MXATOFF for details.        *\n;*                                                                     *\n;***********************************************************************\n;\n(eval-when (eval)\n (defmacro trace   (&rest x) `(ziltrace ',x 'trace))\n (defmacro untrace (&rest x) `(ziltrace ',x 'untrace))\n (defun    at      macro (x) (mxatoff x))\n (defun    off     macro (x) (mxatoff x))\n)\n\n(eval-when (compile)\n (defmacro tracerprop () ''subr))\n\n(eval-when (eval)\n (defmacro tracerprop () ''expr))\n\n(declare (special *trace* *trace-indent*))\n\n(defstruct trace\n           function-name\n           function-property\n           function-code\n           function-hook\n           function-entry\n           function-exit\n           function-entry-quietp\n           function-exit-quietp\n           features\n)\n\n(defun ziltrace (fl whatfor)\n (case whatfor\n  (trace    (ziltrace-trace fl))   ; FL is a list of functions\n  (untrace  (ziltrace-untrace fl)) ; FL is a list of functions\n  (pp       (ziltrace-getfun fl))  ; FL is a single function\n  (entry    (ziltrace-entry  fl))  ; FL is a list (tfun efun quietp)\n  (exit     (ziltrace-exit   fl))  ; FL is a list (tfun efun quietp)\n  (t        (zerror \"Invalid second arg to ZILTRACE\" whatfor))))\n\n(defun ziltrace-assq (fn)\n (unless (symbolp fn)\n         (zerror \"Function name to be traced not a symbol\" fn))\n (let ((tf (assq fn *trace*)))\n      (cond\n       ((null tf) nil)\n       ((neq (trace-function-hook (cdr tf)) (get fn (tracerprop)))\n        (format t \"~&Function ~S became untraced when redefined.~%\"\n                  fn)\n        (setq *trace* (delq tf *trace*))\n        nil)\n       (t\n        tf))))\n\n(defun ziltrace-getfun (function) ; Interface used by ZILPP.\n                                  ; The arg is a symbol, not a list.\n                                  ; Returns a list (prop . code)\n (let ((the-one (ziltrace-assq function)))\n      (if the-one\n          (cons (trace-function-property (cdr the-one))\n                (trace-function-code (cdr the-one)))\n          nil)))\n\n(defun ziltrace-trace (fl)\n (cond\n      ((null fl) (loop for tf in *trace*\n                       when (ziltrace-assq (car tf))\n                       collect (car tf)))\n      ((atom fl) (zerror \"Invalid TRACE function list\" fl))\n      (t         (mapcan #'ziltrace-trace1 fl)\n                 )))\n\n(defun ziltrace-trace1 (fn &aux (ff nil)) ; This traces one function.\n (cond\n  ((ziltrace-assq fn)\n   (format t \"~&Function ~S is already being traced.~%\" fn)\n   nil)\n  (t\n   (let (((fp fc) (getl fn '(subr expr fexpr |SPECIAL FORM| macro))))\n    (case fp\n     ((fexpr |SPECIAL FORM| macro)\n      (format t \"~&Unable to trace ~S ~A.~%\" fp fn)\n      nil)\n     ((subr expr)\n      (let* ((fs (make-trace :function-name         fn\n                             :function-property     fp\n                             :function-code         fc\n                             :function-hook         nil\n                             :function-entry        nil\n                             :function-exit         nil\n                             :function-entry-quietp nil\n                             :function-exit-quietp  nil\n                             :features              ff\n                 ))\n             (fh #'(lambda (&rest fa) (trace-encapsulate fs fa)))\n            )\n            (setf (trace-function-hook fs) fh)\n            (push (cons fn fs) *trace*)\n            (remprop fn fp)\n            ;\n            ; There's an exposure here if an interrupt takes place,\n            ; particularly if an EXPR is traced.\n            ;\n            (setf (get fn (tracerprop)) fh)\n            (ncons fn)))\n     (otherwise\n      (cond\n       ((zevauto fn nil)\n        (ziltrace-trace1 fn))\n       (t\n        (format t \"~&Unable to trace ~A, function not defined.~%\" fn)\n        nil))))))))\n\n(defun trace-encapsulate (fs fa &aux fv)\n (let ((fn  (trace-function-name fs))\n    ;;;(fp  (trace-function-property fs))\n       (fc  (trace-function-code fs))\n    ;;;(fh  (trace-function-hook fs))\n       (fe  (trace-function-entry fs))\n       (fx  (trace-function-exit fs))\n       (feq (trace-function-entry-quietp fs))\n       (fxq (trace-function-exit-quietp fs))\n    ;;;(ff  (trace-features fs))\n      )\n  (let ((*trace-indent* (1+ *trace-indent*)))\n       (trace-enter fe fn fa feq *trace-indent*)\n    ;;;(when ff (trace-enter-features ff))\n       (setq fv (multiple-value-list (zilapply fc fa nil fn)))\n       (trace-exit fx fn fv fxq *trace-indent*)\n    ;;;(when ff (trace-exit-features ff))\n       (values-list fv))))\n\n(defun ziltrace-untrace (fl)\n (cond\n      ((null fl) (let ((funs (mapcar #'car *trace*)))\n                      (mapcan #'ziltrace-untrace1 funs)))\n\n      ((atom fl) (zerror \"Invalid UNTRACE function list\" fl))\n      (t         (mapcan #'ziltrace-untrace1 fl))))\n\n(defun ziltrace-untrace1 (f) ; This untraces one function.\n (let ((the-one (ziltrace-assq f)))\n      (cond\n       (the-one\n        (remprop f (tracerprop))\n         ;\n         ; There's an exposure here if an interrupt takes place,\n         ; particularly if an EXPR is traced.\n         ;\n        (setf (get f (trace-function-property (cdr the-one)))\n              (trace-function-code (cdr the-one)))\n        (setq *trace* (delq the-one *trace*))\n        (ncons f))\n       (t\n        (format t \"~&Function ~A was not being traced.~%\" f)\n        nil))))\n\n;\n; x = user exit function (AT ...), if any\n; f = function name being traced\n; l = argument list or values list\n; q = if non-NIL, suppress entry/exit message\n; i = indent\n;\n\n(defun trace-enter (x f l q i)\n (cond\n  (x\n   (unless q (format t \"~&~V@A;At entry to ~S.~%\" i \"\" f))\n   (funcall x f l))\n  (t\n   (format t \"~&~V@A;Enter ~S ~:S~&\" i \"\" f l))))\n\n(defun trace-exit (x f l q i)\n (cond\n  (x\n   (unless q (format t \"~&~V@A;At exit from ~S.~%\" i \"\" f))\n   (funcall x f l))\n  (t\n   (format t \"~&~V@A;Exit ~S: ~{~S~\u00ac, ~}~&\" i \"\" f l))))\n\n(defun ziltrace-entry ((fn exp quietp))\n (ziltrace-make-entry-function fn exp quietp))\n\n(defun ziltrace-exit ((fn exp quietp))\n (ziltrace-make-exit-function fn exp quietp))\n\n(defun ziltrace-make-entry-function (fn exp quietp)\n (let ((the-one (ziltrace-assq fn)))\n  (cond\n   (the-one\n    (setf (trace-function-entry        (cdr the-one)) exp)\n    (setf (trace-function-entry-quietp (cdr the-one)) quietp)\n    fn\n   )\n   ((null exp)\n    (format t \"~&Function ~A was not being traced.~%\" fn)\n    nil)\n   ((ziltrace-trace1 fn)\n    (ziltrace-make-entry-function fn exp quietp)))))\n\n(defun ziltrace-make-exit-function (fn exp quietp)\n (let ((the-one (ziltrace-assq fn)))\n  (cond\n   (the-one\n    (setf (trace-function-exit        (cdr the-one)) exp)\n    (setf (trace-function-exit-quietp (cdr the-one)) quietp)\n    fn\n   )\n   ((null exp)\n    (format t \"~&Function ~A was not being traced.~%\" fn)\n    nil)\n   ((ziltrace-trace1 fn)\n    (ziltrace-make-exit-function fn exp quietp)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZLARRAY": {"ttr": 8721, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x01\\x8a\\x01m\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 394, "newlines": 365, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* This member must be compiled as a MODULE.                           *\n;*                                                                     *\n;***********************************************************************\n;\n;=======================================================================\n;\n; The infamous array-fake-out package.\n;\n; An array is a structure of type ZIL-ARRAY\n; whose elements are the type, dimensions, data, etc., and,\n; most important, a function used to access array information.\n;\n; A symbol with an ARRAY property is also given an SUBR property\n; which is a lexical closure binding the array to ZARRAY, and\n; which simply executes the functional portion of the array.\n; In this way the interpreter need not be modified to recognize arrays.\n;\n;=======================================================================\n\n;\n;***********************************************************************\n;*                                                                     *\n;* 01/23/87 - Now supports arrays with any positive # of dimensions.   *\n;*            1- and 2-dimensional arrays are more efficient, though.  *\n;*                                                                     *\n;***********************************************************************\n;\n\n; Herald.\n\n(when (< (msglevel) 2)\n (cterpri)\n (princ \"Loading \\\"ZLARRAY\\\", ZIL's Maclisp-compatible array module.\")\n (terpri)\n)\n\n; Definition of an array object.\n\n(defstruct zil-array\n           name\n           data\n           type\n           dimensions\n           function\n)\n\n(defmacro zil-array-dimension-1 (array)\n `(zcar (zil-array-dimensions ,array)))\n\n(defmacro zil-array-dimension-2 (array)\n `(zcadr (zil-array-dimensions ,array)))\n\n(putprop 'zil-array\n         #'(lambda (array &rest args)\n                   (zilapply (zil-array-function array) args))\n         'defstruct-funcall-method)\n\n(defun zil-array (array)\n (let ((real-array (if (symbolp array) (get array 'array) array)))\n      (if (not (zil-array-p real-array))\n          (zerror \"Not an array\" array)\n          real-array)))\n\n(defun zil-1d-array-handler (array dim1 val val?)\n (cond\n  ((null dim1)\n   (zil-array-data array))\n  ((not (integerp dim1))\n   (zerror \"Invalid index-1 specified for array\"\n           (zil-array-name array) dim1))\n  ((or (minusp dim1) (>= dim1 (zil-array-dimension-1 array)))\n   (zerror \"Out-of-range index-1 specified for array\"\n           (zil-array-name array) dim1))\n  (val?\n   (vset (zil-array-data array) dim1 val))\n  (t\n   (vref (zil-array-data array) dim1))))\n\n(defun zil-2d-array-handler (array dim1 dim2 val val?)\n (cond\n  ((and (null dim1) (null dim2))\n   (zil-array-data array))\n  ((not (integerp dim1))\n   (zerror \"Invalid index-1 specified for array\"\n           (zil-array-name array) dim1))\n  ((not (integerp dim2))\n   (zerror \"Invalid index-2 specified for array\"\n           (zil-array-name array) dim2))\n  ((or (minusp dim1) (>= dim1 (zil-array-dimension-1 array)))\n   (zerror \"Out-of-range index-1 specified for array\"\n           (zil-array-name array) dim1))\n  ((or (minusp dim2) (>= dim2 (zil-array-dimension-2 array)))\n   (zerror \"Out-of-range index-2 specified for array\"\n           (zil-array-name array) dim2))\n  (t\n   (let ((index (+ (* dim1 (zil-array-dimension-2 array)) dim2)))\n        (if val?\n            (vset (zil-array-data array) index val)\n            (vref (zil-array-data array) index))))))\n\n(defun zil-nd-array-handler (array dims)\n (let (\n       (rank (length (zil-array-dimensions array)))\n       (rlen (length dims))\n       (val)\n       (val?)\n      )\n  (cond\n   ((eql rlen rank)\n    (setq val? nil))\n   ((eql rlen (1+ rank))\n    (setq val (zcar (last dims))\n          val? t))\n   ((< rlen rank)\n    (zerror \"Too few arguments to array\" (zil-array-name array)))\n   (t\n    (zerror \"Too many arguments to array\" (zil-array-name array))))\n  (cond\n   ((mapand #'null dims)\n    (zil-array-data array))\n   (t (do (\n           (dims dims (cdr dims))\n           (dimx (zil-array-dimensions array)\n                 (cdr dimx))\n           (index 0)\n          )\n          ((null dimx)\n           (if val?\n               (vset (zil-array-data array) index val)\n               (vref (zil-array-data array) index)))\n          (let ((dim (zcar dims)))\n               (cond\n                ((not (integerp dim))\n                 (zerror \"Invalid index specified for array\"\n                         (zil-array-name array) dim))\n                ((or (minusp dim)\n                     (>= dim (zcar dimx)))\n                 (zerror \"Out-of-range index specified for array\"\n                         (zil-array-name array) dim))\n                (t\n                 (incf index\n                       (* dim (do ((d (cdr dimx) (cdr d))\n                                   (prod 1 (* (zcar d) prod)))\n                                  ((null d) prod))))))))))))\n\n(defun arrayp (a)\n (zil-array-p (if (symbolp a) (get a 'array) a)))\n\n;\n; *ARRAYCALL must be defined before *ARRAY, since *ARRAY uses the SUBR\n; property of *ARRAYCALL.\n;\n\n(xdefmacro arraycall (type array &rest dims)\n `(*arraycall ',type ,array . ,dims))\n\n(defun *arraycall (type array &rest dims)\n (let ((real-array (zil-array array)))\n      (zilapply (zil-array-function real-array) dims)))\n\n(defun (*arraycall setfmethod) (a b)\n `(,@a ,b)\n)\n\n(eval-when ()\n #.(defvar funprop ' #+ZILCO subr #-ZILCO expr)\n)\n\n(defun *array (name type &rest dims\n                         &aux (ndims (length dims))\n                              newarray oldarray oldsubr arfun)\n\n (when name\n       (when (setq oldarray (get name 'array))\n             (push oldarray (get name 'array-save-array))\n             (remprop name 'array)))\n\n (setq newarray\n  (let ((size (case ndims\n                    (0 (zerror \"No array dimensions given\" name))\n                    (1 (adv (zcar dims)))\n                    (2 (* (adv (zcar dims)) (adv (zcadr dims))))\n                    (t (do ((dims dims (cdr dims))\n                            (prod 1 (* (adv (zcar dims)) prod)))\n                           ((null dims) prod)))))\n        (initial-value (case type\n                             (fixnum 0)\n                             (flonum 0.0)\n                             (t nil)))\n       )\n        (make-zil-array\n            :name       name\n            :data       (make-vector size initial-value)\n            :type       type\n            :dimensions dims\n        )))\n\n (setf (zil-array-function newarray)\n       (let ((zarray newarray)) ; This variable is closed over.\n        (case ndims\n         (1 #'(lambda (&optional (arg1 nil arg1?)\n                                 (arg2 nil arg2?)\n                       &rest     argr)\n               (unless arg1?\n                (zerror \"Too few arguments to array\"\n                        (zil-array-name zarray)))\n               (when argr\n                (zerror \"Too many arguments to array\"\n                        (zil-array-name zarray)))\n               (zil-1d-array-handler zarray arg1 arg2 arg2?)))\n         (2 #'(lambda (&optional (arg1 nil arg1?)\n                                 (arg2 nil arg2?)\n                                 (arg3 nil arg3?)\n                       &rest     argr)\n               (unless (and arg1? arg2?)\n                (zerror \"Too few arguments to array\"\n                        (zil-array-name zarray)))\n               (when argr\n                (zerror \"Too many arguments to array\"\n                        (zil-array-name zarray)))\n               (zil-2d-array-handler zarray arg1 arg2 arg3 arg3?)))\n         (t #'(lambda (&rest argr)\n               (zil-nd-array-handler zarray argr))))))\n\n (cond\n  (name\n   (putprop name newarray 'array)\n   (when (setq oldsubr (get name '#.funprop))\n         (push oldsubr (get name 'array-save-subr))\n         (remprop name '#.funprop))\n\n   (setf (plist name); Put new functional prop on end so gets found last\n         (nconc (plist name)\n                (list '#.funprop (zil-array-function newarray))))\n\n   (putprop name #'(lambda (a b) `(store ,a ,b)) 'setfmethod)\n\n   name)       ; Return the name of the array.\n  (t\n   newarray)   ; Unnamed array - return the array object itself.\n )\n)\n\n(defmacro adv (x)\n (let ((g (gensym)))\n      `(let ((,g ,x))\n            (if (integerp ,g)\n                ,g\n                (zerror \"Invalid array dimension specified\" name ,g)))))\n\n\n(xdefmacro array (name type &rest dims)\n (prog\n  `(*array ',name ',type . ,dims)\n  (putprop name #'(lambda (a b) `(store ,a ,b)) 'setfmethod)\n )\n)\n\n(xdefmacro store (form value) (mxstore form value))\n\n(defun mxstore (form value)\n (prog (newform)\n  xloop\n       (and (consp form)\n            (eq (zcar form) 'apply)\n            (return `(apply . ,(store-munge (cdr form) value))))\n       (setq newform (macroexpand-1 form))\n       (unless (eq newform form)\n               (setq form newform)\n               (go xloop))\n       (return `(,@newform ,value))\n )\n)\n\n(defmacro store-munge (args value)\n `(loop for sub-args on ,args\n        when (null (cdr sub-args))\n        collect `(append ,(zcar sub-args) (list ,,value))\n        else\n        collect (zcar sub-args)\n  ))\n\n(defun arraydims (array)\n (setq array (zil-array array))\n (cons (zil-array-type array)\n       (zil-array-dimensions array))\n)\n\n(defun array-type (array)\n (zil-array-type (zil-array array))\n)\n\n(defun array-\\#-dims (array)\n (length (zil-array-dimensions (zil-array array)))\n)\n\n(defun array-dimension-n (dim array)\n (let ((array (zil-array array)))\n  (cond\n   ((not (integerp dim))\n    (zerror \"Arg 1 to ARRAY-DIMENSION-N not an integer\" dim))\n   ((not (plusp dim))\n    nil)\n   (t\n    (nth (1- dim) (zil-array-dimensions array))))))\n\n(defun listarray (array)\n (vlist (zil-array-data (zil-array array))))\n\n(defun fillarray (array value &aux real-array)\n (setq real-array (zil-array array))\n (cond\n  ((arrayp value)\n   (do* ((i 0 (add1 i))\n         (d (zil-array-data real-array))\n         (l (vlength d))\n         (filler (zil-array-data (zil-array value)))\n         (fi 0 (add1 fi))\n         (fl (vlength filler))\n        )\n        ((or (>= fi fl) (>= i l)) array)\n        (vset d i (vref filler fi))))\n  ((vectorp value)\n   (do* ((i 0 (add1 i))\n         (d (zil-array-data real-array))\n         (l (vlength d))\n         (fi 0 (add1 fi))\n         (fl (vlength value))\n        )\n        ((or (>= fi fl) (>= i l)) array)\n        (vset d i (vref value fi))))\n  ((consp value)\n   (do* ((i 0 (add1 i))\n         (d (zil-array-data real-array))\n         (l (vlength d))\n         (value value (cdr value))\n         (lastval (car (last value)))         ; Note - no ZCAR here.\n        )\n        ((>= i l) array)\n        (vset d i (if value (zcar value) lastval))))\n  (t\n   (zerror \"Arg 2 to FILLARRAY not an array, vector or list\" value))))\n\n(defun *rearray (array &optional type &rest dims &aux real-array a)\n (setq real-array (zil-array array))\n (cond\n  ((not (symbolp array))\n   (warn \"Can't do *REARRAY on this array\" array)\n   nil)\n  ((null type)                           ; No type or dimensions.\n   (if (setq a (pop (get array 'array-save-subr)))\n       (putprop array a '#.funprop)\n       (remprop array '#.funprop))\n   (if (setq a (pop (get array 'array-save-array)))\n       (putprop array a 'array)\n       (remprop array 'array))\n  )\n  ((null dims)                           ; Type but no dimensions.\n   (setf (zil-array-type real-array) type)\n  )\n  (t\n   (prog (a b c d e f i)\n         (setq a (zil-array-data real-array))     ; Old array data.\n         (setq b (zilapply #'*array (list* array type dims)))\n         (setq c (zil-array-data (zil-array b)))  ; New array data.\n         (setq d (vlength c))\n         (setq e (vlength a))\n         (setq i 0)\n    loop (and (eql i d)\n              (return array))\n         (and (eql i e) (go loop2))\n         (vset c i (setq f (vref a i)))\n         (setq i (add1 i))\n         (go loop)\n   loop2 (and (eql i d)\n              (return array))\n         (vset c i f)\n         (setq i (add1 i))\n         (go loop2)\n         )))\n array\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZLFLAVOR": {"ttr": 8963, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x011\\x00\\x00\\x00\\x86)O\\x00\\x893\\x1f\\x08\\x16\\x06W\\x05O\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.49", "flags": 0, "createdate": "1986-10-21T00:00:00", "modifydate": "1989-11-27T08:16:00", "lines": 1623, "newlines": 1359, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZIL 1.3 flavor system - November 1987\n;\n; This file defines all the FLAVORS user-accessible functions.\n;\n; Other files used:\n;\n;  ZLFLVSTR defines the flavor structure.\n;  ZLFLVAUX defines other flavor functions.\n;  ZLVANLLA creates VANILLA-FLAVOR flavor.\n;\n; Implementation is as follows:\n;\n; A flavor is a structure consisting of the flavor methods,\n; instance variables, etc., etc.\n;\n; An INSTANCE of a flavor is a structure that has a property that\n; enables it to be FUNCALLed, as well as a lexical closure that embodies\n; the flavor stuff.  Instance variables are not closed over, but are\n; inserted into the special variable binding environment using some very\n; hairy kludgery,\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;* 11/27/89 - Support for \"(varname)\" spec in DEFFLAVOR var list.      *\n;*                                                                     *\n;***********************************************************************\n;\n;\n; Unique macro-defining hack for compile-time and run-time macros.\n;\n\n(defmacro defmacro-for-all (name arglist . body)\n `(progn\n   (defmacro ,name ,arglist . ,body)\n   (eval-when (load)\n    (xdefmacro ,name ,arglist . ,body)\n   )\n   ',name\n  )\n)\n\n(defmacro bindenv (env) `(car ,env))\n\n(include #.(zil-source-member zlflvstr))   ; Flavor defstruct.\n\n#|---------------------------------------------------------------------\n\n(defvar *print-escape* t) ; In case Common Lisp printer not available\n(defvar *print-level*  t) ; In case Common Lisp printer not available\n\n---------------------------------------------------------------------|#\n\n(defvar *all-flavor-names* nil \"List of all flavor names.\")\n\n(defvar *flavor-msglevel* 1 \"Message level for flavor messages.\")\n;\n; 0 - display all flavor informational messages\n; 1 - suppress informational messages, display warnings and errors\n; 2 - display errors only\n;\n\n; Enable SEND/FUNCALL of a flavor instance object.\n\n(putprop 'zil-flavor-instance\n         #'(lambda (instance &rest args)\n            (zilapply (zil-flavor-instance-closure-object instance)\n                      args))\n         'defstruct-funcall-method)\n\n#|---------------------------------------------------------------------\n\n; Enable printing of a flavor instance object.\n\n(putprop 'zil-flavor-instance\n         #'(lambda (object &optional stream\n                                     (depth 0)\n                                     (escape *print-escape*))\n            (send object :print-self stream depth escape))\n         'defstruct-print-method)\n\n---------------------------------------------------------------------|#\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Some utility functions.                                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun zil-get-flavor (flavor-name)\n (or (get flavor-name 'flavor)\n     (zerror \"Not defined as a flavor\" flavor-name)))\n\n;\n; This collects primary methods (actually message-method pairs).\n;\n; Used by ZIL-INITIALIZE-FLAVOR to regenerate methods for a flavor.\n;\n\n(defun zil-collect-primary-methods (flavor &aux (mlist nil))\n (loop for flavorname in (flavor-all-flavor-list flavor)\n       (loop for methodpair in\n                 (flavor-primary-methods (zil-get-flavor flavorname))\n             unless (assq (car methodpair) mlist)\n                 do (push methodpair mlist)))\n mlist\n)\n\n;\n; This collects instance variables.\n;\n; Used by MAKE-INSTANCE (this will change) to determine all the\n; instance variables that need to be generated into the closure,\n; and by the VANILLA-FLAVOR :DESCRIBE method to find all the\n; instance variables for the instance.\n;\n; This function returns three lists:\n;   the list of instance VARIABLES\n;   the list of instance KEYWORDS\n;   the list of instance INITIALIZERS\n;\n; As the instance variables are collected, the lists of required\n; instance variables for the component flavors are checked.\n;\n\n(defun zil-collect-instance-variables (flavor &aux vlist klist ilist)\n (loop for flavorname in (flavor-all-flavor-list flavor)\n   (let ((f (zil-get-flavor flavorname)))\n        (loop for variable    in (flavor-instance-variables    f)\n              for keyword     in (flavor-instance-keywords     f)\n              for initializer in (flavor-instance-initializers f)\n              unless (memq variable vlist)\n                  do (push variable    vlist)\n                     (push keyword     klist)\n                     (push initializer ilist))))\n (values (nreverse vlist) (nreverse klist) (nreverse ilist))\n)\n\n;\n; This builds a composite init plist.\n;\n; Used by MAKE-INSTANCE to determine initial values for instance\n; variables based on the flavor definition, after any\n; init-plist specified by the caller of MAKE-INSTANCE, and after any\n; initialization forms found in the DEFFLAVOR instance variable\n; declarations.\n;\n; This function returns a disembodied property list in which the\n; value are actually \"thunks\" which must be funcalled to get the\n; initialization values.\n;\n\n(defun zil-collect-init-plist (flavor &aux (plist (list nil)))\n (loop for flavorname in (flavor-all-flavor-list flavor)\n       (loop for subplist on\n                 (cdr (flavor-init-plist\n                       (zil-get-flavor flavorname)))\n             by #'cddr\n             (let (((indicator thunk) subplist))\n                  (unless (get plist indicator)\n                          (putprop plist thunk indicator)))))\n plist\n)\n\n;\n; This initializes a flavor.  Done by MAKE-INSTANCE if the flavor\n; has not yet been initialized.\n;\n\n(defun zil-initialize-flavor (flavor\n                       &aux component-flavor-list included-flavor-list)\n (unless (flavor-initialized flavor)\n  ;\n  ; Build the list of component flavors.  This is a list, not a tree.\n  ;\n  ; We assume that each component flavor has an already-built linear\n  ; list of component flavors just like the one we are building.  It\n  ; turns out that it is not necessary to descend further than 2\n  ; levels to build this tree.\n  ;\n\n  (when (lessp *flavor-msglevel* 2)\n        (cterpri)\n        (princ \"Initializing flavor \")\n        (prin1 (flavor-name flavor))\n        (terpri)\n  )\n\n  ;\n  ; First, make a linear tree-walking list of all the component flavors.\n  ;\n\n  (loop for c in (flavor-component-flavors flavor)\n        unless (memq c component-flavor-list)\n            do (push c component-flavor-list)\n               (loop for x in (flavor-component-flavor-list\n                               (zil-initialize-flavor\n                                (zil-get-flavor c)))\n                     unless (memq x component-flavor-list)\n                         do (push x component-flavor-list)\n               )\n  )\n  (loop for c in (flavor-included-flavors flavor)\n               (loop for x in (flavor-component-flavor-list\n                               (zil-initialize-flavor\n                                (zil-get-flavor c)))\n                     unless (memq x component-flavor-list)\n                         do (push x component-flavor-list)\n               )\n  )\n\n  ;\n  ; Now, make this list the component flavor list of the flavor.\n  ;\n\n  (setf (flavor-component-flavor-list flavor)\n        (nreverse component-flavor-list))\n\n  ;\n  ; Next, make a linear tree-walking list of all the included flavors.\n  ;\n\n  (loop for c in (flavor-component-flavor-list flavor)\n               (loop for x in (flavor-included-flavor-list\n                                (zil-get-flavor c))\n                     unless (memq x included-flavor-list)\n                         do (push x included-flavor-list)\n               )\n  )\n  (loop for c in (flavor-included-flavors flavor)\n        unless (memq c included-flavor-list)\n            do (push c included-flavor-list)\n               (loop for x in (flavor-component-flavor-list\n                               (zil-initialize-flavor\n                                (zil-get-flavor c)))\n                     unless (memq x included-flavor-list)\n                         do (push x included-flavor-list)\n               )\n               (loop for x in (flavor-included-flavor-list\n                                (zil-get-flavor c))\n                     unless (memq x included-flavor-list)\n                         do (push x included-flavor-list)\n               )\n  )\n\n  ;\n  ; Now, make this list the included flavor list of the flavor.\n  ;\n\n  (setf (flavor-included-flavor-list flavor)\n        (nreverse included-flavor-list))\n\n\n  ;\n  ; Now, combine these two lists for ease of method-searching, etc.\n  ;\n\n  (setf (flavor-all-flavor-list flavor)\n        (append (list (flavor-name flavor))\n                (flavor-component-flavor-list flavor)\n                (flavor-included-flavor-list flavor)))\n\n  ;\n  ; For each component or included flavor, indicate that this flavor\n  ; is dependent on it by adding it to their list of dependent flavors.\n  ;\n\n  (loop for fname in (cdr (flavor-all-flavor-list flavor))\n   (let ((f (zil-get-flavor fname)))\n    (unless (memq (flavor-name flavor) (flavor-dependent-flavor-list f))\n            (push (flavor-name flavor) (flavor-dependent-flavor-list f))\n    )))\n\n  ;\n  ; Find all the primary methods for this flavor and all its\n  ; component flavors, and build the combined methods for them.\n  ;\n  (loop for (message) in (zil-collect-primary-methods flavor)\n         do\n            (zil-regenerate-method flavor message)\n  )\n\n  ;\n  ; Find all the instance variables for this flavor, as well as\n  ; the corresponding keywords and initializers.\n  ;\n  (multiple-value-bind\n     (instance-variables instance-keywords instance-initializers)\n     (zil-collect-instance-variables flavor)\n   (setf (flavor-all-instance-variables flavor)   instance-variables)\n   (setf (flavor-all-instance-keywords  flavor)   instance-keywords)\n   (setf (flavor-all-instance-initializers flavor)instance-initializers)\n  )\n\n  ;\n  ; Clear the which-operations list.\n  ;\n  (setf (flavor-which-operations flavor) nil)\n\n  ;\n  ; Mark flavor initialized.\n  ;\n  (setf (flavor-initialized flavor) t)\n )\n flavor\n)\n\n;\n;***********************************************************************\n;*                                                                     *\n;* DECLARE-FLAVOR-INSTANCE-VARIABLES:                                  *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro-for-all declare-flavor-instance-variables (flavor-name . def)\n (let ((f (or (zil-get-flavor flavor-name)\n              (zerror\n \"Flavor not defined, can't expand DECLARE-FLAVOR-INSTANCE-VARIABLES\"\n                     flavor-name))))\n  `(progn\n    (declare (special . ,(flavor-all-instance-variables f)))\n    ,def))\n)\n\n;\n;***********************************************************************\n;*                                                                     *\n;* SEND:                                                               *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro-for-all send (instance method &rest methodargs)\n `(funcall ,instance ,method . ,methodargs))\n\n\n;\n;***********************************************************************\n;*                                                                     *\n;* DEFFLAVOR:                                                          *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro-for-all defflavor\n (flavor-name instance-variables component-flavors &rest flavor-options)\n (mxdefflavor flavor-name instance-variables component-flavors\n              flavor-options))\n\n(defun mxdefflavor (flavor-name instance-variables component-flavors\n                    flavor-options\n                    &aux\n                         instance-variable-list\n                         instance-keyword-list\n                         instance-initializer-list\n                         default-defmethods\n                         init-plist\n                         default-init-plist\n                         new-default-init-plist\n                         gettable-instance-variables\n                         settable-instance-variables\n                         initable-instance-variables\n                         init-keywords\n                         initialized-keywords\n                         included-flavor-list\n                         no-vanilla-flavor\n                         required-instance-variables\n                         required-methods\n                         default-handler\n                         outside-macros\n                         method-combination-list\n                         (g (gensym)))\n\n (unless (listp instance-variables)\n         (zerror \"Invalid instance variable list\"\n                 flavor-name instance-variables))\n\n (unless (listp component-flavors)\n         (zerror \"Invalid component flavor list\"\n                 flavor-name component-flavors))\n\n ;\n ; Build the instance variable list and the instance keyword list.\n ;\n\n (loop for x in instance-variables\n  when (atom x)\n    do (let ((k (keywordify x)))\n        (zil-check-instance-variable flavor-name x\n                                     instance-variable-list)\n        (push k instance-keyword-list)\n        (push x instance-variable-list)\n        (push nil instance-initializer-list))\n  else\n  when (symbolp (car x))\n    do (let ((k (keywordify (car x))))\n        (zil-check-instance-variable flavor-name (car x)\n                                     instance-variable-list)\n        (push k instance-keyword-list)\n        (push (car x) instance-variable-list)\n        (cond\n         ((null (cdr x))\n          (push nil instance-initializer-list))\n         ((or (atom (cdr x)) (cddr x))\n          (zerror \"Invalid instance variable specification\"\n                  flavor-name x))\n         (t\n          (push `(subr (lambda () ,(cadr x)))\n                 instance-initializer-list))))\n  else\n    do (zerror \"Invalid instance variable name\" flavor-name (car x))\n  finally\n       (setq instance-keyword-list (nreverse instance-keyword-list))\n       (setq instance-variable-list (nreverse instance-variable-list))\n       (setq instance-initializer-list\n             (nreverse instance-initializer-list))\n )\n  ;\n  ; Analyze the options.\n  ;\n (loop for opt in flavor-options do\n  (let (oname ovalue ovalue?)\n       (cond\n        ((atom opt)\n         (setq oname opt ovalue? nil))\n        ((and (cdr opt) (atom (cdr opt)))\n         (zerror \"Invalid flavor option specification\" flavor-name opt))\n        (t\n         (setq oname (car opt) ovalue (cdr opt) ovalue? t)))\n       (case oname\n        (:gettable-instance-variables\n         (let ((the-list (zil-check-instance-specs ovalue? ovalue\n                             instance-variable-list)))\n              (mark-gettable the-list))\n        )\n        (:settable-instance-variables\n         (let ((the-list (zil-check-instance-specs ovalue? ovalue\n                             instance-variable-list)))\n              (mark-settable the-list)\n              (mark-gettable the-list)\n              (mark-initable the-list)\n              (mark-init-key the-list))\n        )\n        (:initable-instance-variables\n         (let ((the-list (zil-check-instance-specs ovalue? ovalue\n                             instance-variable-list)))\n              (mark-initable the-list)\n              (mark-init-key the-list))\n        )\n        (:init-keywords\n         (mark-init-key (if ovalue? ovalue nil))\n        )\n        (:no-vanilla-flavor\n         (if ovalue? (zerror \"No value permitted for this flavor option\"\n                             flavor-name oname))\n         (setq no-vanilla-flavor t))\n        (:included-flavors\n         (setq included-flavor-list ovalue))\n        (:default-init-plist\n         (unless ovalue?\n                 (zerror \"A value is required for this flavor option\"\n                         flavor-name oname))\n         (setq default-init-plist ovalue)\n        )\n        (:required-instance-variables\n         (unless ovalue?\n                 (zerror \"A value is required for this flavor option\"\n                         flavor-name oname))\n         (setq required-instance-variables ovalue)\n        )\n        (:required-methods\n         (unless ovalue?\n                 (zerror \"A value is required for this flavor option\"\n                         flavor-name oname))\n         (setq required-methods ovalue)\n        )\n        (:default-handler\n         (unless ovalue?\n                 (zerror \"A value is required for this flavor option\"\n                         flavor-name oname))\n         (unless (and ovalue\n                      (symbolp (car ovalue))\n                      (null (cdr ovalue))\n                 )\n                 (zerror \"A single function name must be specified\"\n                         flavor-name oname ovalue))\n         (setq default-handler (car ovalue))\n        )\n        (:outside-accessible-instance-variables\n         (let ((the-list (zil-check-instance-specs ovalue? ovalue\n                             instance-variable-list)))\n              (loop for var in the-list\n                    (push `(defmacro ,(concat flavor-name \"-\" var) (,g)\n                            `(symeval-in-instance ,,g ',',var))\n                          outside-macros)))\n        )\n        (:method-combination\n         (unless ovalue?\n                 (zerror \"A value is required for this flavor option\"\n                         flavor-name oname))\n         (loop for x in ovalue do\n               (unless (consp x)\n                       (zerror \"Invalid argument to :METHOD-COMBINATION\"\n                               flavor-name x))\n               (let (((type order . messages) x))\n                    (loop for message in messages\n                          when (assq message method-combination-list)\n                            do (zerror\n              \"Duplicate message name specified for :METHOD-COMBINATION\"\n                                      flavor-name message)\n                          else\n                               (push (cons message (cons type order))\n                                     method-combination-list))))\n        )\n        ((\n          :ordered-instance-variables\n          :select-method-order\n          :documentation\n         )\n         (warn  \"Sorry, this flavor option not supported in ZIL\"\n                flavor-name oname))\n        (t\n         (zerror \"Unknown flavor option\" flavor-name oname)))\n  )\n )\n\n  ;\n  ; For each instance variable specified, we create two methods:\n  ;\n  ; (e.g. given an instance variable FOO)\n  ;\n  ; (1) A method FOO, which returns the value of FOO;\n  ; (2) A method SET-FOO, which sets FOO to a new value.\n  ;\n\n  (loop for var in instance-variable-list\n        for key in instance-keyword-list\n    when (memq var settable-instance-variables)\n         (push `(defmethod (,flavor-name ,(concat \":SET-\" var)) (,g)\n                           (setq ,var ,g))\n               default-defmethods)\n    when (memq var gettable-instance-variables)\n         (push `(defmethod (,flavor-name ,key) () ,var)\n               default-defmethods)\n  )\n\n  ;\n  ; If :default-handler is specified, create the method.\n  ;\n  (when default-handler\n   (push `(defmethod (,flavor-name :default-handler) ,default-handler)\n         default-defmethods))\n\n  ;\n  ; If :initable-instance-variables is specified,\n  ; build the init-plist out of all the specified instance\n  ; variables and their specified values.  The init-plist,\n  ; a disembodied property list, is used when an instance of\n  ; a flavor is created via MAKE-INSTANCE.\n  ;\n  ; Entries are added to the init-plist only for variables that\n  ; have initial values specified on the DEFFLAVOR declarations\n  ; thereof.\n  ;\n\n  ;\n  ; The init-plist is actually a run-time list consisting of\n  ; constant indicators and \"thunks\" (argless lambda subrs).\n  ;\n  ; e.g.:\n  ;\n  ; (foo bar baz frob) ==>\n  ; (list nil 'foo (subr (lambda () bar)) 'baz (subr (lambda () frob)))\n  ;\n\n  (setq init-plist (list nil))\n\n  (loop for var   in instance-variable-list\n        for key   in instance-keyword-list\n        for thunk in instance-initializer-list\n    when (and thunk (memq var initable-instance-variables))\n         (push key initialized-keywords)\n         (push `',key init-plist)\n         (push thunk  init-plist)\n  )\n\n  ;\n  ; The value of default-init-plist is a list of alternating\n  ; keyword-value pairs.  For each pair, add it to the existing\n  ; init-plist, converting indicators and values as above.\n  ;\n\n  (setq new-default-init-plist (list nil))\n\n  (loop for subplist on default-init-plist by #'cddr\n        (unless (cdr subplist)\n                (zerror \"Odd number of elements in default-init-plist\"\n                        flavor-name))\n        (let (((indicator value) subplist))\n             (unless (keywordp indicator)\n                     (zerror\n\":DEFAULT-INIT-PLIST indicator must be a keyword\"\n                       flavor-name indicator))\n             (if (memq indicator initialized-keywords)\n                 (warn\n\":DEFAULT-INIT-PLIST spec overridden by instance variable init spec\"\n                       flavor-name indicator)\n                 (let ((newind `',indicator)\n                       (newval `(subr (lambda () ,value))))\n                      (push newind init-plist)\n                      (push newval init-plist)\n                      (push newind new-default-init-plist)\n                      (push newval new-default-init-plist)))))\n\n  (setq init-plist (nreverse init-plist))\n  (setq default-init-plist (nreverse new-default-init-plist))\n\n  ;\n  ; Make sure that VANILLA-FLAVOR is included in the component flavors,\n  ; unless otherwise indicated.\n  ;\n\n  (unless (or no-vanilla-flavor\n              (memq 'vanilla-flavor included-flavor-list))\n          (setq included-flavor-list\n                `(,@included-flavor-list vanilla-flavor)))\n\n  ;\n  ; OK, here's the macro expansion.\n  ;\n\n `(progn\n   (zil-create-flavor ',flavor-name\n                      ',instance-variable-list\n                      ',instance-keyword-list\n                      ',component-flavors\n                      ',included-flavor-list\n                      ',init-keywords\n                      ',required-instance-variables\n                      ',required-methods\n                      ',method-combination-list\n                      (list . ,instance-initializer-list)\n                      (list . ,init-plist)\n                      (list . ,default-init-plist)\n   )\n   ,.default-defmethods\n\n   ,(when outside-macros\n          `(progn\n            (eval-when (compile load eval) . ,outside-macros)\n            (eval-when (load)\n            . ,(mapcar #'(lambda (x) `(xdefmacro . ,(cdr x)))\n                       outside-macros))))\n\n   ',flavor-name\n  )\n)\n\n(defun zil-create-flavor (flavor-name\n                          instance-variables\n                          instance-keywords\n                          component-flavors\n                          included-flavors\n                          init-keywords\n                          required-instance-variables\n                          required-methods\n                          method-combination-list\n                          instance-initializers\n                          init-plist\n                          default-init-plist\n                         )\n (let ((z (make-flavor\n             name                         flavor-name\n             instance-variables           instance-variables\n             instance-keywords            instance-keywords\n             component-flavors            component-flavors\n             included-flavors             included-flavors\n             init-keywords                init-keywords\n             required-instance-variables  required-instance-variables\n             required-methods             required-methods\n             method-combination-list      method-combination-list\n             instance-initializers        instance-initializers\n             init-plist                   init-plist\n             default-init-plist           default-init-plist\n\n             ; All other fields NIL including flavor-initialized.\n\n          ))\n       oldflavor\n      )\n      (cond\n       ((memq flavor-name *all-flavor-names*)\n        (warn \"Flavor being redefined.  Old methods retained.\"\n              flavor-name)\n        (setq oldflavor (zil-get-flavor flavor-name))\n        (setf (flavor-combined-methods z)\n              (flavor-combined-methods oldflavor)) ; This must change!\n        (setf (flavor-primary-methods z)\n              (flavor-primary-methods oldflavor))\n        (setf (flavor-before-methods z)\n              (flavor-before-methods oldflavor))\n        (setf (flavor-after-methods z)\n              (flavor-after-methods oldflavor))\n        (setf (flavor-default-methods z)\n              (flavor-default-methods oldflavor))\n        (setf (flavor-wrapper-methods z)\n              (flavor-wrapper-methods oldflavor))\n        (setf (flavor-dependent-flavor-list z)\n              (flavor-dependent-flavor-list oldflavor))\n        ; All other fields NIL including flavor-initialized.\n\n        ; If the flavor being redefined has other flavors depending\n        ; on it, then mark them uninitialized to force them to be\n        ; regenerated next time an instantiation is done on them.\n\n        (when (flavor-initialized oldflavor)\n              (loop for f in (flavor-dependent-flavor-list oldflavor)\n                when (lessp *flavor-msglevel* 2)\n                  do (cterpri)\n                     (princ \"Resetting flavor \")\n                     (prin1 (flavor-name (zil-get-flavor f)))\n                     (terpri)\n                do (setf (flavor-initialized (zil-get-flavor f)) nil)))\n       )\n       (t\n        (push flavor-name *all-flavor-names*)\n       )\n      )\n      (putprop flavor-name z 'flavor)\n      flavor-name\n )\n)\n\n(defmacro mark-gettable (x)\n `(mapc #'(lambda (x)\n                  (or (memq x gettable-instance-variables)\n                      (push x gettable-instance-variables)))\n        ,x))\n\n(defmacro mark-settable (x)\n `(mapc #'(lambda (x)\n                  (or (memq x settable-instance-variables)\n                      (push x settable-instance-variables)))\n        ,x))\n\n(defmacro mark-initable (x)\n `(mapc #'(lambda (x)\n                  (or (memq x initable-instance-variables)\n                      (push x initable-instance-variables))\n          )\n        ,x))\n\n(defmacro mark-init-key (x)\n `(mapc #'(lambda (x)\n                  (setq x (keywordify x))\n                  (or (memq x init-keywords)\n                      (push x init-keywords))\n          )\n        ,x))\n\n\n\n(defun zil-check-instance-variable (nam var lis)\n (when (keywordp var)\n       (zerror \"Instance variable should not be a keyword\" nam var))\n (when (memq var lis)\n       (zerror \"Duplicate instance variable\" nam var)))\n\n(defun zil-check-instance-specs (ovalue? ovalue instance-variable-list)\n (cond\n  (ovalue?\n   (loop for var in ovalue\n         unless (memq var instance-variable-list)\n             do (zerror\n \"Instance variable requested in flavor option but not present in list\"\n                       var)\n   )\n   ovalue\n  )\n  (t instance-variable-list)))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* DEFMETHOD:                                                          *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro-for-all defmethod\n ((flavor-name message-name &optional (message-type nil message-type?))\n  arglist . body)\n (mxdefmethod flavor-name message-name message-type message-type?\n              arglist body))\n\n(defun mxdefmethod\n (flavor-name message-name message-type message-type? arglist body)\n (if message-type?\n     (psetq message-name message-type\n            message-type message-name)\n     (setq  message-name message-name\n            message-type :primary)\n )\n (if (and arglist (symbolp arglist))\n  ; (DEFMETHOD (FOO BAR) ANOTHER-FUNCTION-NAME)\n  (if body\n   (zerror\n\"Invalid DEFMETHOD syntax (cannot specify function symbol with body)\"\n                  arglist body)\n   `(zil-create-method ',flavor-name ',message-name ',message-type\n                       (subr ,arglist))\n  )\n  (let\n   ((f (concat flavor-name\n               \"-\"\n               (if message-type? (unkeywordify message-type) \"\")\n               (if message-type? \"-\" \"\")\n               (unkeywordify message-name)\n               \"-METHOD\"\n       )))\n  `(progn\n    (defun ,f (,(gensym) . ,arglist) . ,body)\n    (zil-create-method ',flavor-name ',message-name ',message-type\n                        (subr ,f))))))\n\n(defun zil-create-method\n      (flavor-name message-name message-type f &aux z)\n (let ((flavor (zil-get-flavor flavor-name)))\n      (case message-type\n            (:primary\n             (if (setq z (assq message-name\n                         (flavor-primary-methods flavor)))\n                 (rplacd z f)\n                 (push (cons message-name f)\n                       (flavor-primary-methods flavor)))\n            )\n            (:before\n             (if (setq z (assq message-name\n                         (flavor-before-methods flavor)))\n                 (rplacd z f)\n                 (push (cons message-name f)\n                       (flavor-before-methods flavor)))\n            )\n            (:after\n             (if (setq z (assq message-name\n                         (flavor-after-methods flavor)))\n                 (rplacd z f)\n                 (push (cons message-name f)\n                       (flavor-after-methods flavor)))\n            )\n            (:default\n             (if (setq z (assq message-name\n                         (flavor-default-methods flavor)))\n                 (rplacd z f)\n                 (push (cons message-name f)\n                       (flavor-default-methods flavor)))\n            )\n            (:wrapper\n             (if (setq z (assq message-name\n                         (flavor-wrapper-methods flavor)))\n                 (rplacd z f)\n                 (push (cons message-name f)\n                       (flavor-wrapper-methods flavor)))\n            )\n            ((:combined)\n             (zerror \"Message type not supported by DEFMETHOD\"\n                     flavor-name message-type message-name)\n            )\n            (otherwise\n             (zerror \"Message type unknown to DEFMETHOD\"\n                     flavor-name message-type message-name)))\n  ;\n  ; If the flavor has already been initialized,\n  ; regenerate the method to be invoked for this message.\n  ; Note that this will encompass all the different types of methods\n  ; existing for this message.\n  ; Also, if there are flavors that depend on this flavor\n  ; (which can be true only if this flavor has been initialized),\n  ; then regenerate the methods for this message for all those flavors.\n  ;\n\n  (when (flavor-initialized flavor)\n        (zil-regenerate-method flavor message-name)\n        (loop for fname in (flavor-dependent-flavor-list flavor)\n              (let ((f (zil-get-flavor fname)))\n                   (when (flavor-initialized f)\n                         (zil-regenerate-method f message-name)))))\n\n  ; Return the name of the function as the value of DEFMETHOD.\n\n  f\n\n )\n)\n\n;\n; This function determines the combination type for a message of a\n; given flavor.  It returns a cons of type and order.\n;\n\n(defun zil-method-combination-type (flavor message-name\n                                    &aux type order tflavor)\n (loop for flavorname in (flavor-all-flavor-list flavor)\n       (let* ((f\n               (zil-get-flavor flavorname))\n              ((nil typ . ord)\n               (assq message-name (flavor-method-combination-list f)))\n             )\n             (cond\n              ((null typ)\n               nil)\n              ((null type)\n               (setq type typ order ord tflavor flavorname))\n              ((eq typ type)\n               (unless (eq ord order)\n                       (when (lessp *flavor-msglevel* 3)\n                        (cterpri)\n                        (princ \"Order keyword mismatch for message \")\n                        (prin1 message-name)\n                        (princ \" using \")\n                        (prin1 type)\n                        (princ \" combination\")\n                        (terpri)\n                        (princ \"Flavor \")\n                        (prin1 tflavor)\n                        (princ \" specifies \")\n                        (prin1 order)\n                        (princ \", but flavor \")\n                        (prin1 flavorname)\n                        (princ \" specifies \")\n                        (prin1 ord)\n                        (terpri)\n                       )\n                       (zerror \"Method generation failed for flavor \"\n                               (flavor-name flavor)))\n              )\n              (t\n                       (when (lessp *flavor-msglevel* 3)\n                        (cterpri)\n                       (princ \"Combination type mismatch for message \")\n                        (prin1 message-name)\n                        (terpri)\n                        (princ \"Flavor \")\n                        (prin1 tflavor)\n                        (princ \" specifies \")\n                        (prin1 type)\n                        (princ \", but flavor \")\n                        (prin1 flavorname)\n                        (princ \" specifies \")\n                        (prin1 typ)\n                        (terpri)\n                       )\n                       (zerror \"Method generation failed for flavor \"\n                               (flavor-name flavor))))))\n (if type (cons type order) '(:daemon . nil))\n)\n\n;\n; This function builds the combined method for the message name and\n; adds it to the flavor (or replaces the existing one).\n;\n\n(defun zil-regenerate-method (flavor message-name)\n\n (when (lessp *flavor-msglevel* 1)\n       (cterpri)\n       (princ \"(Re)generating methods for message \")\n       (prin1 message-name)\n       (princ \" for flavor \")\n       (prin1 (flavor-name flavor))\n       (terpri)\n )\n\n (setf (flavor-which-operations flavor) nil)\n\n (let*\n  (((type . order)\n    (zil-method-combination-type flavor message-name)\n   )\n   (methoddef\n    ;\n    ; (function-name argsymbol body)\n    ;\n    ; or just function-name (if daemon combination and no before/after)\n    ;\n    (case type\n     (:daemon (zil-regenerate-daemon-method flavor message-name order))\n     (:progn  (zil-regenerate-progn-method  flavor message-name order))\n     (:or     (zil-regenerate-or-method     flavor message-name order))\n     (:and    (zil-regenerate-and-method    flavor message-name order))\n     (:list   (zil-regenerate-list-method   flavor message-name order))\n     (:inverse-list\n       (zil-regenerate-inverse-list-method  flavor message-name order))\n     (otherwise\n      (zerror \"Unknown method combination type\"\n              (flavor-name flavor) message-name type))\n    )\n   )\n   (methodfun\n    (cond\n     ((atom methoddef)\n      methoddef)\n     (t\n      (let (((mname margs mbody) methoddef))\n            (eval `(defun ,mname (&rest ,margs)\n                          ,(zil-flavor-wrap flavor message-name\n                                            mname margs mbody)))\n            mname\n      )\n     )\n    )\n   )\n   (z\n    (assq message-name (flavor-combined-methods flavor))\n   )\n  )\n  (if z\n      (rplacd z methodfun)\n      (push (cons message-name methodfun)\n            (flavor-combined-methods flavor)))\n )\n ; The return value is not important.\n)\n\n;\n; This function applies all wrappers to the generated code for the\n; combined method.\n;\n\n(defun zil-flavor-wrap (flavor message-name mname margs mbody)\n (do ((w (zil-collect-wrappers flavor message-name)\n         (cdr w))\n      (b mbody\n         (funcall (cdar w) message-name margs (list b)))\n     )\n     ((null w) b)))\n\n(defun zil-collect-wrappers (flavor message &aux mlist m)\n (loop for f in (flavor-all-flavor-list flavor)\n       when (setq m (assq message\n                          (flavor-wrapper-methods (zil-get-flavor f))))\n         do (push m mlist)\n )\n mlist  ;  base-flavor-first order, so that the base flavor's wrapper\n        ;  (e.g. for vanilla-flavor) goes on first, etc., and the\n        ;  wrapper for self's flavor goes on last.\n)\n\n;\n; These are the functions that generate the combined method code\n; - in the form (functionname argsym body) - for each method\n; combination type.\n;\n\n(defun zil-regenerate-daemon-method (flavor message-name ignored)\n\n ;\n ; Build the method that will execute all these different kinds\n ; of individual methods.\n\n (let (\n       (primary-method\n        (zil-combine-daemon-methods flavor message-name))\n       (before-method-list\n        (zil-combine-before-methods flavor message-name))\n       (after-method-list\n        (zil-combine-after-methods flavor message-name))\n       (wrapper-list\n        (zil-collect-wrappers flavor message-name))\n      )\n      (if (and (null before-method-list)\n               (null after-method-list)\n               (null wrapper-list))\n          ;\n          ; If no BEFORE/AFTER and no wrappers,\n          ; just the primary method...\n          ;\n          (cdr primary-method)\n          ;\n          ; else...\n          ;\n          (let (\n                (combined-function-name\n                 (concat (flavor-name flavor)\n                         \"-COMBINED-\"\n                         (unkeywordify message-name)\n                         \"-DAEMON-METHOD\"))\n                (args (gensym))\n               )\n           `(,combined-function-name\n             ,args\n             (progn\n              ,.(mapcar #'(lambda (x) (zil-make-method-call x args))\n                        before-method-list)\n              (multiple-value-prog1\n               ,(zil-make-method-call primary-method args)\n               ,.(mapcar #'(lambda (x) (zil-make-method-call x args))\n                         after-method-list)\n              )))))))\n\n(defun zil-regenerate-progn-method (flavor message-name order)\n (let (\n       (method-list\n        (zil-combine-untyped-methods flavor message-name order))\n       (combined-function-name\n         (concat (flavor-name flavor)\n                 \"-COMBINED-\"\n                 (unkeywordify message-name)\n                 \"-PROGN-METHOD\"))\n       (args (gensym))\n      )\n      `(,combined-function-name\n        ,args\n        (progn . ,(mapcar #'(lambda (x) (zil-make-method-call x args))\n                          method-list)))))\n\n(defun zil-regenerate-or-method (flavor message-name order)\n (let (\n       (method-list\n        (zil-combine-untyped-methods flavor message-name order))\n       (combined-function-name\n         (concat (flavor-name flavor)\n                 \"-COMBINED-\"\n                 (unkeywordify message-name)\n                 \"-OR-METHOD\"))\n       (args (gensym))\n      )\n      `(,combined-function-name\n        ,args\n        (or . ,(mapcar #'(lambda (x) (zil-make-method-call x args))\n                       method-list)))))\n\n(defun zil-regenerate-and-method (flavor message-name order)\n (let (\n       (method-list\n        (zil-combine-untyped-methods flavor message-name order))\n       (combined-function-name\n         (concat (flavor-name flavor)\n                 \"-COMBINED-\"\n                 (unkeywordify message-name)\n                 \"-AND-METHOD\"))\n       (args (gensym))\n      )\n      `(,combined-function-name\n        ,args\n        (and . ,(mapcar #'(lambda (x) (zil-make-method-call x args))\n                        method-list)))))\n\n(defun zil-regenerate-list-method (flavor message-name order)\n (let (\n       (method-list\n        (zil-combine-untyped-methods flavor message-name order))\n       (combined-function-name\n         (concat (flavor-name flavor)\n                 \"-COMBINED-\"\n                 (unkeywordify message-name)\n                 \"-LIST-METHOD\"))\n       (args (gensym))\n      )\n      `(,combined-function-name\n        ,args\n        (list . ,(mapcar #'(lambda (x) (zil-make-method-call x args))\n                         method-list)))))\n\n(defun zil-regenerate-inverse-list-method (flavor message-name order)\n (let (\n       (method-list\n        (zil-combine-untyped-methods flavor message-name order))\n       (combined-function-name\n         (concat (flavor-name flavor)\n                 \"-COMBINED-\"\n                 (unkeywordify message-name)\n                 \"-INVERSE-LIST-METHOD\"))\n       (args (gensym))\n       (arg1 (gensym))\n       (arg2 (gensym))\n      )\n      `(,combined-function-name\n        ,args\n       ;\n       ; (funcall m1 arg1 (car arg2))\n       ; (funcall m2 arg1 (cadr arg2))\n       ; (funcall m3 arg1 (caddr arg2))\n       ; ... etc. ...\n       ;\n       ; or...\n       ;\n       ; (apply m1 (list arg1 (car arg2)))\n       ; (apply m2 (list arg1 (cadr arg2)))\n       ; (apply m3 (list arg1 (caddr arg2)))\n       ; ... etc. ...\n       ;\n        (let (((,arg1 ,arg2) ,args))\n             ;\n             ; We'd like to have number-of-arg-checking here...\n             ; maybe in a future enhancement to ZIL we can have\n             ; (declare (destructuring-arg-check ,args))\n             ; or something like that...?\n             ;\n           . ,(do ((z nil (cons `(funcall ',(cdar m) ,arg1 (car ,a)) z))\n                   (m method-list (cdr m))\n                   (a arg2 `(cdr ,a))\n                  )\n                  ((null m) (nreverse z)))))))\n\n\n(defun zil-make-method-call (methodpair args)\n (let ((m (cdr methodpair)))\n      `(,(if (codep m) 'zilxsub 'zilapply) ',m ,args)))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* DEFWRAPPER:                                                         *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro-for-all defwrapper ((wf wm) (wa . wb) wz)\n (unless (atom wb)\n  (zerror \"Incorrect DEFWRAPPER syntax, arg2 must be (arglist . body)\"\n          `(,wa . ,wb)))\n (let ((wargs (gensym)))\n      `(defmethod (,wf :wrapper ,wm) (,wargs ,wb)\n                  `(let (((nil . ,',wa) ,,wargs)) ,,wz))))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* MAKE-INSTANCE:                                                      *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun make-instance (flavor-name &rest keyworded-arguments)\n (instantiate-flavor flavor-name keyworded-arguments t))\n\n(defun instantiate-flavor (flavor-name arg-plist\n                           &optional send-init-message-p area)\n (when area\n  (when (lessp *flavor-msglevel* 2)\n        (cterpri)\n        (princ \"Warning: area arg to INSTANTIATE-FLAVOR ignored: \")\n        (prin1 flavor-name)\n        (princ \" \")\n        (prin1 area)\n        (terpri)))\n\n (let* (\n        (flavor       (zil-get-flavor flavor-name))\n        (the-instance)\n        (value-alist)\n        (instance-variables)\n        (instance-values)\n        (instance-keywords)\n        (instance-initializers)\n        (collective-init-plist)\n        (init-plist)\n        (initializer)\n        (instance-alist)\n        (instance-joint)\n        (save-joint)\n       )\n\n  ;\n  ; If the flavor has not been initialized, initialize it.\n  ;\n\n  (zil-initialize-flavor flavor)\n\n  ;\n  ; Validity check the keyworded arguments.\n  ;\n\n  (loop for k on arg-plist by #'cddr\n   (unless (memq (car k) (flavor-init-keywords flavor))\n           (zerror \"Not an initialization keyword of this flavor\"\n                   flavor-name (car k)))\n   (unless (cdr k)\n           (zerror \"Odd number of init-plist arguments to MAKE-INSTANCE\"\n                   flavor-name arg-plist))\n  )\n\n  ;\n  ; Check that all required instance variables have been provided.\n  ;\n  ; Note: Don't check your own required instance variable list.\n  ;\n\n  (loop\n    with reqlist = nil\n    for flavorname in (cdr (flavor-all-flavor-list flavor))\n    do\n     (let ((f (zil-get-flavor flavorname)))\n          (loop for reqvar in (flavor-required-instance-variables f)\n            unless (memq reqvar (flavor-all-instance-variables flavor))\n                do (push (cons reqvar flavorname) reqlist)))\n    finally\n     (loop with lost = nil\n           for (reqvar . reqflavorname) in reqlist\n           when (lessp *flavor-msglevel* 3)\n             do (cterpri)\n                (princ \"Instance variable \")\n                (prin1 reqvar)\n                (princ \" (required by flavor \")\n                (prin1 reqflavorname)\n                (princ \")\")\n                (princ \" was not found.\")\n                (terpri)\n           do (setq lost t)\n       finally\n              (when lost\n                    (zerror \"Instantiation failed for flavor\"\n                            (flavor-name flavor)))))\n\n\n  ;\n  ; Check that all required methods have been provided.\n  ;\n  ; Note: Don't check your own required method list.\n  ;\n\n  (loop\n    with reqlist = nil\n    for flavorname in (cdr (flavor-all-flavor-list flavor))\n    do\n     (let ((f (zil-get-flavor flavorname)))\n          (loop for reqmsg in (flavor-required-methods f)\n            unless (assq reqmsg (flavor-combined-methods flavor))\n                do (push (cons reqmsg flavorname) reqlist)))\n    finally\n     (loop with lost = nil\n           for (reqmsg . reqflavorname) in reqlist\n           when (lessp *flavor-msglevel* 3)\n             do (cterpri)\n                (princ \"Method for message \")\n                (prin1 reqmsg)\n                (princ \" (required by flavor \")\n                (prin1 reqflavorname)\n                (princ \")\")\n                (princ \" was not found.\")\n                (terpri)\n           do (setq lost t)\n       finally\n              (when lost\n                    (zerror \"Instantiation failed for flavor\"\n                            (flavor-name flavor)))))\n\n\n  ;\n  ; This builds the binding environment of instance variables from\n  ; which the closure which implements the instance will be created.\n  ;\n\n  ;\n  ; Initialize all instance variables.\n  ; From:\n  ; (1) Keyword specified on call to MAKE-INSTANCE.\n  ; (2) Default-init-plist specification.\n  ; (3) Initializer specified on the instance variable in DEFFLAVOR.\n  ;\n  ; (Q: Does this also pick up from component flavors'\n  ;     default-init-plists?   Currently the answer is YES,\n  ;     based on the current implementation of ZIL-COLLECT-INIT-PLIST.)\n  ;\n\n  (setq collective-init-plist (zil-collect-init-plist flavor))\n\n  (loop for var in (flavor-all-instance-variables    flavor)\n        for key in (flavor-all-instance-keywords     flavor)\n        for ini in (flavor-all-instance-initializers flavor)\n        with kval\n     do\n        (push var instance-variables)\n        (push (cond\n               ((setq kval\n                (getk arg-plist key)) ; Specified on MAKE-INSTANCE call\n                (car kval))\n               ((setq initializer (get collective-init-plist key))\n                (funcall initializer)); Specified in :DEFAULT-INIT-PLIST\n               (ini\n                (funcall ini))        ; Specified on DEFFLAVOR var decl\n               (t (zilunbnd)))        ; Not specified\n              instance-values)\n  )\n\n\n  ;\n  ; Only if the flavor has an :INIT method:\n  ;\n  ; Construct the init-plist to be passed to the :INIT method.\n  ; This contains the keyworded arguments to MAKE-INSTANCE plus\n  ; the contents of the flavor's default-init-plist.\n  ;\n  ; (Q: Does it also contain component flavors' default-init-plists?)\n  ;\n\n  ;\n  ; Problem: Right now the init plist also contains the initialization\n  ;          specs from the instance variable specs in DEFFLAVOR.\n  ;          This is probably not right.  To correct this problem,\n  ;          we have to store the default-init-plist separately from\n  ;          the init-plist in the flavor structure.\n  ;\n\n  (when (and send-init-message-p\n             (assq ':init (flavor-combined-methods flavor)))\n\n   (setq init-plist (cons nil arg-plist))\n\n   (loop for subplist on (cdr (flavor-default-init-plist flavor))\n         by #'cddr\n         do\n             (let (((indicator thunk) subplist))\n                  (or (getk (cdr init-plist) indicator)\n                      (putprop init-plist (funcall thunk) indicator)))))\n\n  ;\n  ; Construct the partial alist from the instance variables and values\n  ; that will be glued onto the special alist when the instance is\n  ; funcalled.  Obtain the pointer to the \"joint\" where this alist\n  ; will be \"glued\".\n  ;\n\n\n  (setq instance-alist\n        (do ((vars instance-variables (cdr vars))\n             (vals instance-values    (cdr vals))\n             (pair)\n             (z)\n            )\n            ((null vals) z)\n            (setq pair (cons (car vars) (car vals)))\n            (if (null z)\n                (setq z (setq instance-joint (cons pair z)))\n                (push pair z))))\n\n\n  ;\n  ; Build the closure that is the instance.\n  ;\n  ; Note cheap NCONC substitute to glue instance variables onto\n  ; the special binding environment.\n  ;\n  ; We can't use PROGV because the bindings themselves need to be\n  ; retained in case of assignments.\n  ;\n  ; INSTANCE-JOINT and SAVE-JOINT exist so that the alist gets\n  ; reglued properly for SENDs to the same instance recursively.\n  ; It's kind of complicated, but the point is that\n  ; the system doesn't work unless you do this.\n  ;\n\n  (setq the-instance\n        (make-zil-flavor-instance\n          :flavor-name\n          (flavor-name flavor)\n          :closure-object\n          #'(lambda (&rest methodargs &aux recp savealist savepop)\n              (setq savealist (special-alist))\n              (when (setq recp (cdr instance-joint))\n                    (push nil save-joint))\n              (unwind-protect\n               (progn\n                  (when instance-alist\n                    (when recp\n                      (do ((subalist (special-alist) (cdr subalist)))\n                          ((null (cdr subalist)))\n                          (when (eq (cdr subalist) instance-alist)\n                            (setf (car save-joint) subalist)\n                            (setf (cdr subalist) (cdr instance-joint))\n                            (return))))\n                    (rplacd instance-joint (special-alist))\n                    (setf (special-alist) instance-alist))\n                  (let ((self the-instance)\n                        (*flavor* flavor))\n                    (declare (special self *flavor*))\n                    (zil-flavor-dispatch flavor methodargs))\n               )\n               (when recp (setq savepop (pop save-joint)))\n               (when instance-alist\n                     (when (and recp savepop\n                               (neq (cdr savepop) instance-alist))\n                          (setf (cdr instance-joint) (cdr savepop))\n                          (setf (cdr savepop) instance-alist))\n                    (setf (special-alist) savealist))\n              ))))\n\n  (when send-init-message-p\n        (send the-instance :send-if-handles :init init-plist))\n\n\n  the-instance\n\n))\n\n;\n; This is the function invoked from the closure built by MAKE-INSTANCE\n; which dispatches on methods requested by SEND.\n;\n\n(defun zil-flavor-dispatch (flavor methodargs)\n (unless methodargs\n      (zerror \"Missing message arg to instance\" (flavor-name flavor)))\n (zilapply (or (cdr (assq (car methodargs)\n                          (flavor-combined-methods flavor)))\n               (cdr (assq ':default-handler\n                          (flavor-combined-methods flavor)))\n               (zerror \"No method defined to handle this message\"\n                       (flavor-name flavor)\n                       (car methodargs)))\n           methodargs)\n)\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Method combination functions.                                       *\n;*                                                                     *\n;***********************************************************************\n;\n\n;\n; Default method combination for combining primary :DAEMON methods.\n;\n; This function returns the first primary method encountered\n; (it doesn't really \"combine\" anything).\n;\n\n(defun zil-combine-daemon-methods (flavor message &aux m)\n (or\n     (loop for f in (flavor-all-flavor-list flavor)\n           when (setq m\n                      (assq message\n                        (flavor-primary-methods (zil-get-flavor f))))\n           return m\n     )\n     (zerror \"No primary :DAEMON method found for this message\"\n             (flavor-name flavor) message)))\n\n;\n; Default method combination for combining primary (untyped) methods.\n;\n\n(defun zil-combine-untyped-methods (flavor message order &aux mlist m)\n ;\n ; Collect all the primary (untyped) methods.\n ;\n (loop for f in (flavor-all-flavor-list flavor)\n       when (setq m (assq message\n                          (flavor-primary-methods (zil-get-flavor f))))\n         do (push m mlist)\n )\n ;\n ; If there are no primary (untyped) methods,\n ; then collect all the default methods.\n ;\n (when (null mlist)\n  (loop for f in (flavor-all-flavor-list flavor)\n        when (setq m (assq message\n                           (flavor-default-methods (zil-get-flavor f))))\n          do (push m mlist)\n  )\n )\n (unless mlist\n  (zerror \"No untyped methods found to combine\"\n          (flavor-name flavor) message))\n\n (case order\n  (:base-flavor-first   mlist)\n  (:base-flavor-last    (nreverse mlist))\n  (t (zerror \"Invalid order keyword\"\n             (flavor-name flavor)\n             message\n             order)))\n)\n\n;\n; Default method combination for combining BEFORE methods.\n;\n; This returns all the BEFORE methods, in component flavor order.\n;\n\n(defun zil-combine-before-methods (flavor message &aux mlist m)\n (loop for f in (flavor-all-flavor-list flavor)\n       when (setq m (assq message\n                          (flavor-before-methods (zil-get-flavor f))))\n         do (push m mlist)\n )\n (nreverse mlist)\n)\n\n;\n; Default method combination for combining AFTER methods.\n;\n; This returns all the AFTER methods, in reverse component flavor order.\n;\n\n(defun zil-combine-after-methods (flavor message &aux mlist m)\n (loop for f in (flavor-all-flavor-list flavor)\n       when (setq m (assq message\n                          (flavor-after-methods (zil-get-flavor f))))\n         do (push m mlist)\n )\n mlist\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZLFLVAUX": {"ttr": 9221, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x00\\x9b\\x00\\x91\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 155, "newlines": 145, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZIL 1.3 flavor system - November 1987\n;\n; More FLAVORS functions.\n;\n\n(include #.(zil-source-member zlflvstr))  ; Flavor defstruct.\n\n;\n; Need this to compile calls to SEND in this module.\n;\n\n(defmacro send (&rest args) `(funcall . ,args))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* DESCRIBE:                                                           *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun describe (object)\n (send object :describe))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* DESCRIBE-FLAVOR:                                                    *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro flavordump (&rest slots)\n `(progn . ,(mapcar #'flavordump1 slots)))\n\n(eval-when (compile eval)\n (defun flavordump1 (slot)\n  `(format t \"~&~A~2%~S~2%\" ,(string-append slot \":\")\n                             (,(concat \"FLAVOR-\" slot) flavor)))\n)\n\n(defun describe-flavor (flavor-name)\n (let ((flavor (zil-get-flavor flavor-name)))\n      (flavordump\n           name\n           instance-variables\n           instance-keywords\n           instance-initializers\n           all-instance-variables\n           all-instance-keywords\n           all-instance-initializers\n           component-flavors\n           included-flavors\n           combined-methods\n           primary-methods\n           before-methods\n           after-methods\n           default-methods\n           wrapper-methods\n           component-flavor-list\n           included-flavor-list\n           all-flavor-list\n           dependent-flavor-list\n           required-instance-variables\n           required-methods\n           method-combination-list\n           init-plist\n           default-init-plist\n           init-keywords\n           which-operations\n           initialized\n      )\n      flavor-name))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* FUNCALL-SELF :                                                      *\n;*                                                                     *\n;***********************************************************************\n;\n\n(xdefmacro funcall-self (message &rest args)\n `(funcall self ,message . ,args))\n\n(xdefmacro send-self (message &rest args)\n `(send self ,message . ,args))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* GET-HANDLER-FOR:                                                    *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun get-handler-for (object message)\n (send object :get-handler-for message))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* SET-IN-INSTANCE:                                                    *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun set-in-instance (instance symbol value)\n (send instance :set-in-instance symbol value))\n\n;\n;***********************************************************************\n;*                                                                     *\n;* SYMEVAL-IN-INSTANCE:                                                *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun symeval-in-instance (instance symbol &optional no-error-p)\n (send instance :symeval-in-instance symbol no-error-p))\n\n;;;\n;;; SETF method for SYMEVAL-IN-INSTANCE\n;;;\n\n(defun (symeval-in-instance setfmethod) (place value)\n (unless (eql (length place) 3)\n         (zerror \"Invalid SETF syntax\" place))\n `(set-in-instance ,(cadr place) ,(caddr place) ,value))\n\n;\n; Not implemented yet:\n;\n; Functions\n;\n;   lexpr-funcall-self\n;   recompile-flavor\n;\n; Macros\n;\n;   compile-flavor-methods\n;\n; Variables\n;\n;   *flavor-compilations*\n;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZLFLVSTR": {"ttr": 9223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x007\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 55, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; ZIL 1.3 flavor system - August 1987\n;\n;\n; Define the structure of the type FLAVOR.\n;\n\n(defstruct flavor\n           name\n           instance-variables\n           instance-keywords\n           instance-initializers\n           all-instance-variables\n           all-instance-keywords\n           all-instance-initializers\n           component-flavors\n           included-flavors\n           combined-methods\n           primary-methods\n           before-methods\n           after-methods\n           default-methods\n           wrapper-methods\n           component-flavor-list\n           included-flavor-list\n           all-flavor-list\n           dependent-flavor-list\n           required-instance-variables\n           required-methods\n           method-combination-list\n           init-plist\n           default-init-plist\n           init-keywords\n           which-operations\n           initialized\n\n)\n\n;\n; Define the structure of the type ZIL-FLAVOR-INSTANCE.\n;\n\n(defstruct zil-flavor-instance ; An instance of a given flavor.\n           flavor-name         ; The symbol that names the flavor.\n           closure-object      ; The lexical closure that implements it.\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZLVANLLA": {"ttr": 9225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x01G\\x00\\xef\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 327, "newlines": 239, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n\n;;;\n;;; ZIL 1.3 FLAVORS system - November 1987\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Flavor system initialization.                                       *\n;*                                                                     *\n;* Define the VANILLA-FLAVOR flavor.                                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (compile)\n (zlflavor)                     ; Load the FLAVORS functions.\n)\n\n(include #.(zil-source-member zcsdfstr)) ; Read/print/stream defs.\n(include #.(zil-source-member zlflvstr)) ; Flavor defstruct.\n\n(defflavor vanilla-flavor\n           ()                   ; No instance variables\n           ()                   ; No component flavors\n           :no-vanilla-flavor   ; Options\n)\n\n#|---------------------------------------------------------------------\n\n The following is not active now, but will be when a true Common LISP\n printer function is established - some day.\n\n-----------------------------------------------------------------------\n\n(defmacro %llprint (a stream level escape)\n;;;\n;`(write ,a :stream ,stream :escape ,escape :level ,level)\n;;;\n (let ((ga (gensym))\n       (gs (gensym))\n      )\n      `(let (\n             (,ga ,a)\n             (,gs ,stream)\n             (*print-level* ,level)\n            )\n            (declare (special *print-level*))\n            (if ,escape\n                (prin1 ,ga ,gs)\n                (princ ,ga ,gs)))))\n\n(declare (special *print-level* *print-length* *print-escape*))\n\n;\n; Default :PRINT-SELF method.\n;\n\n(defmethod (vanilla-flavor :print-self)\n           (&optional (file nil)\n                      (prindepth 0)\n                      (slashify-p *print-escape*))\n (let (\n       (level (if *print-level* (- (1+ *print-level*) prindepth)))\n      )\n      (princ    \"#<Instance of flavor \" file)\n      (%llprint (flavor-name *flavor*)  file level slashify-p)\n      (princ    \" \"                     file)\n      (%llprint (maknum self)           file level slashify-p)\n      (princ    \">\"                     file)\n      self       ; Dunno what else to return.\n))\n\n---------------------------------------------------------------------|#\n\n;\n; Default :PRINT-SELF method.\n;\n\n(defmethod (vanilla-flavor :print-self)\n           (&optional file prindepth slashify-p)\n (let ((b (if slashify-p #.%%%prin1 #.%%%princ)))\n  (when prindepth\n        (warn\n     \"Warning: Argument 2 to :PRINT-SELF method (depth) ignored by ZIL.\"\n        ))\n        (zcprint \"#<Instance of flavor \" file b)\n        (zcprint (flavor-name *flavor*)  file b)\n        (zcprint \" \"                     file b)\n        (zcprint (maknum self)           file b)\n        (zcprint \">\"                     file b)\n        self       ; Dunno what else to return.\n))\n\n;\n; Default :DESCRIBE method.\n;\n\n(defmethod (vanilla-flavor :describe)\n           ()\n (let (\n       (vars (flavor-all-instance-variables *flavor*))\n       (coms (flavor-component-flavor-list *flavor*))\n       (incs (flavor-included-flavor-list *flavor*))\n       (alls (flavor-all-flavor-list *flavor*))\n      )\n  (send self ':print-self)\n  (princ \" is an object of flavor \")\n  (prin1 (flavor-name *flavor*))\n  (princ \".\")\n  (terpri)\n  (if coms\n   then\n     (princ \"It directly or indirectly depends upon component flavors:\")\n     (loop for com in coms do\n      (cterpri)\n      (princ \"         \")\n      (prin1 com)\n      (terpri)\n     )\n   else\n     (princ \"It has no component flavors.\")\n     (terpri)\n   endif\n  )\n  (if incs\n   then\n     (princ \"It directly or indirectly depends upon included flavors:\")\n     (loop for inc in incs do\n      (cterpri)\n      (princ \"         \")\n      (prin1 inc)\n      (terpri)\n     )\n   else\n     (princ \"It has no included flavors.\")\n     (terpri)\n   endif\n  )\n  (if alls\n   then\n     (princ \"Thus, it directly or indirectly depends upon flavors:\")\n     (loop for all in alls do\n      (cterpri)\n      (princ \"         \")\n      (prin1 all)\n      (terpri)\n     )\n   else\n     (princ \"Thus, it has no other flavors.\")\n     (terpri)\n   endif\n  )\n  (if vars\n   then\n      (princ \"It has instance variable values:\")\n      (loop for var in vars do\n       (cterpri)\n       (princ \"         \")\n       (prin1 var)\n       (princ \"   \")\n       (let ((binding (assq var (special-alist))))\n            (princ \"   \")\n            (prin1 (if binding (cdr binding) (zilunbnd))))\n       (terpri)\n      )\n   else\n      (princ \"It has no instance variable values.\")\n      (terpri)\n   endif\n  )\n  (values) ; Dunno what else to return.\n )\n)\n\n;\n; Default :GET-HANDLER-FOR method.\n;\n\n(defmethod (vanilla-flavor :get-handler-for)\n           (message)\n (cdr (assq message (flavor-combined-methods *flavor*)))\n)\n\n;\n; Default :WHICH-OPERATIONS method.\n;\n\n(defmethod (vanilla-flavor :which-operations)\n           ()\n (or (flavor-which-operations *flavor*)\n     (setf (flavor-which-operations *flavor*)\n           (mapcar #'car (flavor-combined-methods *flavor*))))\n)\n\n;\n; Default :EVAL-INSIDE-YOURSELF method.\n;\n\n(defmethod (vanilla-flavor :eval-inside-yourself)\n           (form)\n (eval form)\n)\n\n;\n; Default :FUNCALL-INSIDE-YOURSELF method.\n;\n\n(defmethod (vanilla-flavor :funcall-inside-yourself)\n           (function &rest args)\n (zilapply function args)\n)\n\n;\n;***********************************************************************\n;*                                                                     *\n;* The following messages are for compatibility with the NIL           *\n;* implementation of FLAVORS.                                          *\n;*                                                                     *\n;***********************************************************************\n;\n;\n; Default :SEND-IF-HANDLES method.\n;\n; Note that the first argument to a message handling method is the\n; message name.\n;\n\n(defmethod (vanilla-flavor :send-if-handles)\n           (&rest margs)\n (or margs\n    (zerror \"Required message arg missing for :SEND-IF-HANDLES message\"))\n (let ((h (get-handler-for self (car margs))))\n      (if h\n          ; (send self message . args)\n          (zilapply h margs)\n          nil\n      )))\n\n;\n; Default :OPERATION-HANDLED-P method.\n;\n\n(defmethod (vanilla-flavor :operation-handled-p)\n           (message)\n (if (assq message (flavor-combined-methods *flavor*)) t nil)\n)\n\n;\n; Default :EQUAL method.\n;\n\n(defmethod (vanilla-flavor :equal)\n           (other-object)\n (eq self other-object)\n)\n\n;\n; Default :SYMEVAL-IN-INSTANCE method.\n;\n\n(defmethod (vanilla-flavor :symeval-in-instance)\n           (symbol &optional no-error-p)\n (cond\n  ((boundp symbol)\n   (symeval symbol))\n  (no-error-p\n   nil)\n  (t\n   (zerror \"SYMEVAL-IN-INSTANCE variable not bound in instance\" symbol)\n  )))\n\n;\n; Default :SET-IN-INSTANCE method.\n;\n\n(defmethod (vanilla-flavor :set-in-instance)\n           (symbol value)\n (cond\n  ((assq symbol (special-alist))\n   (set symbol value))\n  (t\n   (zerror \"SET-IN-INSTANCE variable not bound in instance\" symbol))))\n\n;\n; Default :SXHASH method.\n;\n\n(defmethod (vanilla-flavor :sxhash)\n           ()\n (sxhash (flavor-name *flavor*))  ; That's what NIL does.\n)\n\n;\n; Default :EVAL method.\n;\n\n(defmethod (vanilla-flavor :eval)\n           ()\n (zerror \"Instances of this flavor cannot be evaluated\"\n         (flavor-name *flavor*) self)\n)\n\n;\n; The following NIL-implementation messages are not supported:\n;\n; :funcall,\n; :exhibit-self, :select-nth, :store-nth,\n; :pp-dispatch, :pp-anaphor-dispatch\n;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZMADD": {"ttr": 9228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x15\\x00 \\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:15:00", "lines": 32, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMADD\"\n;;;\n;;; Executes ZILADD over elements of a list.  Assumes:\n;;;\n;;; (DEFUN +    (&REST X) (ZMADD X))\n;;; (DEFUN PLUS (&REST X) (ZMADD X))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; + and PLUS as macros that expand into the requisite number of calls\n;;; to ZILADD.\n;;;\n\n(defun zmadd (x)\n (if (null x)\n     0\n     (prog (v)\n           (setq v (zcar x))\n       loop\n           (when (setq x (cdr x))\n                 (setq v (ziladd v (zcar x)))\n                 (go loop))\n           (return v))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMDIV": {"ttr": 9230, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x16\\x00%\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 37, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMDIV\"\n;;;\n;;; Executes ZILDIV over elements of a list.    Assumes:\n;;;\n;;; (DEFUN /        (&REST X) (ZMDIV X T))\n;;; (DEFUN QUOTIENT (&REST X) (ZMDIV X NIL))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; / and QUOTIENT as macros that expand into the requisite number of\n;;; calls to ZILDIV.\n;;;\n\n(defun zmdiv (x onep)\n (cond\n  ((null x)\n   1)\n  ((and onep\n        (null (cdr x)))\n   (zildiv 1 (zcar x)))\n  (t\n   (prog (v)\n         (setq v (zcar x))\n     loop\n         (when (setq x (cdr x))\n               (setq v (zildiv v (zcar x)))\n               (go loop))\n         (return v)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMEQ": {"ttr": 9232, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x1f\\x00\\x89\\x15o\\x11\\x16\\x00(\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-08T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 40, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMEQ\"\n;;;\n;;; Executes ZILEQUAL over elements of a list. Assumes:\n;;;\n;;; (DEFUN = (&REST X) (ZMEQ X))\n;;;\n;;; This is for use under the interpreter only.  The compiler expands\n;;; = into the requisite number of calls to ZILEQUAL.\n;;;\n\n(defun zmeq (x)\n (cond\n  ((null x)\n   (zerror \"Missing argument(s)\" '=))\n  ((null (cdr x))\n   t)\n  ((null (cddr x))\n   (zilequal (car x) (cadr x)))\n  (t (prog (v)\n       loop\n           (setq v (zcar x))\n           (when (setq x (cdr x))\n                 (unless (zilequal v (zcar x))\n                         (return nil))\n                 (go loop))\n           (return t)))))\n\n(eval-when (eval)\n (defun = (&rest x) (zmeq x))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMGCD": {"ttr": 9234, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x16\\x00\\x1f\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 31, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMGCD\"\n;;;\n;;; Executes GCD2 over elements of a list.  Assumes:\n;;;\n;;; (DEFUN GCD  (&REST X) (ZMGCD X))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; GCD as a macro that expands into the requisite number of calls\n;;; to GCD2.\n;;;\n\n(defun zmgcd (x)\n (if (null x)\n     0\n     (prog (v)\n           (setq v (zcar x))\n       loop\n           (when (setq x (cdr x))\n                 (setq v (gcd2 v (zcar x)))\n                 (go loop))\n           (return v))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMGT": {"ttr": 9236, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x1f\\x00\\x89\\x15o\\x11\\x16\\x00(\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-08T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 40, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMGT\"\n;;;\n;;; Executes GREATERP over elements of a list.  Assumes:\n;;;\n;;; (DEFUN > (&REST X) (ZMGT X))\n;;;\n;;; This is for use under the interpreter only.  The compiler expands\n;;; > into the requisite number of calls to GREATERP.\n;;;\n\n(defun zmgt (x)\n (cond\n  ((null x)\n   (zerror \"Missing argument(s)\" '>))\n  ((null (cdr x))\n   t)\n  ((null (cddr x))\n   (greaterp (car x) (cadr x)))\n  (t (prog (v)\n       loop\n           (setq v (zcar x))\n           (when (setq x (cdr x))\n                 (unless (greaterp v (zcar x))\n                         (return nil))\n                 (go loop))\n           (return t)))))\n\n(eval-when (eval)\n (defun > (&rest x) (zmgt x))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMLT": {"ttr": 9238, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x1f\\x00\\x89\\x15o\\x11\\x16\\x00(\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-08T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 40, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMLT\"\n;;;\n;;; Executes LESSP over elements of a list.  Assumes:\n;;;\n;;; (DEFUN < (&REST X) (ZMLT X))\n;;;\n;;; This is for use under the interpreter only.  The compiler expands\n;;; < into the requisite number of calls to LESSP.\n;;;\n\n(defun zmlt (x)\n (cond\n  ((null x)\n   (zerror \"Missing argument(s)\" '<))\n  ((null (cdr x))\n   t)\n  ((null (cddr x))\n   (lessp (car x) (cadr x)))\n  (t (prog (v)\n       loop\n           (setq v (zcar x))\n           (when (setq x (cdr x))\n                 (unless (lessp v (zcar x))\n                         (return nil))\n                 (go loop))\n           (return t)))))\n\n(eval-when (eval)\n (defun < (&rest x) (zmlt x))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMMAX": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x16\\x00\\x1e\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 30, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMMAX\"\n;;;\n;;; Executes MAX2 over elements of a list.  Assumes:\n;;;\n;;; (DEFUN MAX (&REST X) (ZMMAX X))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; MAX as a macro that expands into the requisite number of calls\n;;; to MAX2.\n;;;\n\n(defun zmmax (x)\n (unless x (zerror \"No arguments\" 'max))\n (prog (v)\n       (setq v (zcar x))\n   loop\n       (when (setq x (cdr x))\n             (setq v (max2 v (zcar x)))\n             (go loop))\n       (return v)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMMIN": {"ttr": 9475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x16\\x00\\x1e\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 30, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMMIN\"\n;;;\n;;; Executes MIN2 over elements of a list.  Assumes:\n;;;\n;;; (DEFUN MIN (&REST X) (ZMMIN X))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; MIN as a macro that expands into the requisite number of calls\n;;; to MIN2.\n;;;\n\n(defun zmmin (x)\n (unless x (zerror \"No arguments\" 'min))\n (prog (v)\n       (setq v (zcar x))\n   loop\n       (when (setq x (cdr x))\n             (setq v (min2 v (zcar x)))\n             (go loop))\n       (return v)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMMUL": {"ttr": 9477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x16\\x00 \\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 32, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMMUL\"\n;;;\n;;; Executes ZILMUL over elements of a list.    Assumes:\n;;;\n;;; (DEFUN *     (&REST X) (ZMMUL X))\n;;; (DEFUN TIMES (&REST X) (ZMMUL X))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; * and TIMES as macros that expand into the requisite number of\n;;; calls to ZILMUL.\n;;;\n\n(defun zmmul (x)\n (if (null x)\n     1\n     (prog (v)\n           (setq v (zcar x))\n       loop\n           (when (setq x (cdr x))\n                 (setq v (zilmul v (zcar x)))\n                 (go loop))\n           (return v))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMNGT": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x1f\\x00\\x89\\x15o\\x11\\x16\\x00(\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-08T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 40, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMNGT\"\n;;;\n;;; Executes NGREATERP over elements of a list. Assumes:\n;;;\n;;; (DEFUN <= (&REST X) (ZMNGT X))\n;;;\n;;; This is for use under the interpreter only.  The compiler expands\n;;; <= into the requisite number of calls to NGREATERP.\n;;;\n\n(defun zmngt (x)\n (cond\n  ((null x)\n   (zerror \"Missing argument(s)\" '<=))\n  ((null (cdr x))\n   t)\n  ((null (cddr x))\n   (ngreaterp (car x) (cadr x)))\n  (t (prog (v)\n       loop\n           (setq v (zcar x))\n           (when (setq x (cdr x))\n                 (unless (ngreaterp v (zcar x))\n                         (return nil))\n                 (go loop))\n           (return t)))))\n\n(eval-when (eval)\n (defun <= (&rest x) (zmngt x))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMNLT": {"ttr": 9481, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x1f\\x00\\x89\\x15o\\x11\\x16\\x00(\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-08T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 40, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMNLT\"\n;;;\n;;; Executes NLESSP over elements of a list. Assumes:\n;;;\n;;; (DEFUN >= (&REST X) (ZMNLT X))\n;;;\n;;; This is for use under the interpreter only.  The compiler expands\n;;; >= into the requisite number of calls to NLESSP.\n;;;\n\n(defun zmnlt (x)\n (cond\n  ((null x)\n   (zerror \"Missing argument(s)\" '>=))\n  ((null (cdr x))\n   t)\n  ((null (cddr x))\n   (nlessp (car x) (cadr x)))\n  (t (prog (v)\n       loop\n           (setq v (zcar x))\n           (when (setq x (cdr x))\n                 (unless (nlessp v (zcar x))\n                         (return nil))\n                 (go loop))\n           (return t)))))\n\n(eval-when (eval)\n (defun >= (&rest x) (zmnlt x))\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMREM": {"ttr": 9483, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x16\\x00!\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 33, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMREM\"\n;;;\n;;; Executes ZILREM over elements of a list. Assumes:\n;;;\n;;; (DEFUN //        (&REST X) (ZMREM X))\n;;; (DEFUN REMAINDER (&REST X) (ZMREM X))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; // and REMAINDER as macros that expand into the requisite number of\n;;; calls to ZILREM.\n;;;\n;;; NOTE: (// n) currently returns n, not 1//n.\n;;;\n\n(defun zmrem (x)\n (if (null x)\n     1\n     (prog (v)\n           (setq v (zcar x))\n       loop\n           (when (setq x (cdr x))\n                 (setq v (zilrem v (zcar x)))\n                 (go loop))\n           (return v))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMSASCII": {"ttr": 9485, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x16\\x00\\x15\\x00\\x0b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:16:00", "lines": 21, "newlines": 11, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; Not Common Lisp, but for Macsyma only.\n;;;\n;;; Not part of standard ZIL since ASCII isn't really ASCII,\n;;; if you know what I mean.\n;;;\n\n(defun ascii (x)\n (ebcdic x t)\n)\n\n(defload ascii zmsascii)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSERROR": {"ttr": 9487, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x89\\x13\\x7f\\x00\\x89\\x15o\\x11\\x17\\x00$\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1989-05-17T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 36, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the Maclisp version of ERROR, for use by Macsyma.\n;\n; See the Maclisp manual, page 229.\n;\n\n(defun zmserror (&optional (msg nil msg?) (datum nil datum?) kwd)\n (when msg?\n       (when (< (msglevel) 3)\n             (cterpri)\n             (princ \"Error: \")\n             (if (atom msg)\n                 (princ msg)\n                 (dolist (i msg)\n                         (princ i)\n                         (princ \" \")))\n             (when datum?\n                   (princ \" - \")\n                   (prin1 datum))\n;;;;;        (when kwd\n;;;;;              (cterpri)\n;;;;;              (princ \";(\")\n;;;;;              (princ kwd)\n;;;;;              (princ \" error signalled.)\"))\n             (terpri)))\n (throw nil nil)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZMSPRINT": {"ttr": 9489, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x18\\x8f\\x00\\x89\\x15o\\x11\\x17\\x00*\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-07T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 42, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n;***********************************************************************\n;*                                                                     *\n;* MACSYMA-compatible printer - sensitive to \u00acW and \u00acR variables.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when ()\n #.(defvar ttyoff '\u00acW)\n #.(defvar writefilep '\u00acR)\n)\n\n(include #.(zil-source-member zcsdfstr))\n\n(declare (special #.ttyoff #.writefilep))\n\n(defun zmsprint (a f b)\n (if   (or (null f) (eq f t))\n       (let ((y #.ttyoff)\n             (w #.writefilep))\n            (prog1 (if y\n                       (if (eql b #.%%%charpos) 1 nil)\n                       (zdprint a f b)\n                   )\n                   (when w\n                    (zdprint a w b)\n                   )\n            )\n       )\n       (zdprint a f b)\n )\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSREADL": {"ttr": 9491, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x00)\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 41, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n\n ; READLIST kludge for Macsyma only.\n ;\n ; This READLIST hack assumes that it is passed a list of characters\n ; (fixnums) or symbols (representing single characters)\n ; except for the SYMBOL slash, which represents an escape character.\n ; This is how it is used in SUPRV.\n ;\n ; Will probably not go away, since this one simulates Maclisp syntax,\n ; unless READ-FROM-STRING or something can handle this.\n ;\n\n (defun readlist (a)\n  (prog (z c car numeric?)\n        (setq numeric? t)\n   loop\n      (cond\n       ((null a)\n        (return (zilimpl (nreverse z) t numeric?)))\n       ((eq (setq car (zcar a)) '/)\n        (setq a (cdr a)\n              numeric? nil\n              c (ebcdic (zcar a)))) ; Assume always followed by fixnum.\n       ((symbolp car)\n        (setq c car)) ; Assume already upper case.\n       (t\n        (setq c (ebcdic (char-upcase car)))))\n      (push c z)\n      (setq a (cdr a))\n      (go loop)))\n\n(defload readlist zmsreadl)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSSUBST": {"ttr": 9493, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x15_\\x00\\x89\\x15o\\x11\\x17\\x00\\x1e\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-06-04T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 30, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the Maclisp version of SUBST, for use by Macsyma.\n;\n; See the Maclisp manual, page 109.  The test is EQUAL, like SUBSTQUA,\n; but the result is completely newly consed tree structure.\n; Therefore, (ZMSSUBST NIL NIL X) is equivalent to (COPYTREE X).\n;\n\n(defun zmssubst (a b x)\n (cond\n  ((equal b x) a)\n  ((atom x)    x)\n  (t           (cons (zmssubst a b (zcar x))\n                     (and\n                         ;(cdr x) ; <--- Prevents substing NIL tails.\n                         ;\n                         ; The above has been commented out because\n                         ; it is believed that Maclisp doesn't do\n                         ; substitution that way.\n                         ;\n                          (zmssubst a b (cdr x)))))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSUB": {"ttr": 9495, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x00$\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 36, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZMSUB\"\n;;;\n;;; Executes ZILSUB over elements of a list.  Assumes:\n;;;\n;;; (DEFUN -          (&REST X) (ZMSUB X T))\n;;; (DEFUN DIFFERENCE (&REST X) (ZMSUB X NIL))\n;;;\n;;; This is for use under the interpreter only.  The compiler implements\n;;; - and DIFFERENCE as macros that expand into the requisite number of\n;;; calls to ZILSUB.\n;;;\n\n(defun zmsub (x onep)\n (cond\n  ((null x)\n   0)\n  ((and onep (null (cdr x)))\n   (minus (zcar x)))\n  (t\n   (prog (v)\n         (setq v (zcar x))\n     loop\n         (when (setq x (cdr x))\n               (setq v (zilsub v (zcar x)))\n               (go loop))\n         (return v)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZPUTFPO": {"ttr": 9497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x880\\x7f\\x00\\x89\\x15o\\x11\\x17\\x00\\x0e\\x00\\t\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-02T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 14, "newlines": 9, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n(include #.(zil-source-member zcsdfstr))\n\n(defun zputfpo (c &optional f)\n (zcprint c f #.%%%charpos)\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZRMAPPLY": {"ttr": 9499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x00#\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 35, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZRMAPPLY\"\n;;;\n;;; This is a general-purpose reader macro whose purpose in life is to\n;;; apply a user's interpretive reader macro code.\n;;;\n;;; The DEFRDMAC function assigns this code to interpretive reader\n;;; macros as in the following example:\n;;;\n;;; (DEFRDMAC '|?| '(LAMBDA (X) (QUESTION-MARK-MACRO X)))\n;;;\n;;;  executes the following:\n;;;\n;;; (RDRMACRO '|?| (ZILLOAD 'ZRMAPPLY))\n;;; (PUTPROP '*READERMACRO* '(LAMBDA (X) (QUESTION-MARK-MACRO X)) '|?|)\n;;;\n;;; This example will cause the character ? to act as a reader macro\n;;; character to execute the function which is the property of\n;;; indicator \"?\" on the property list of the atom *READERMACRO*.\n;;;\n;;; The function must take one argument, which will be the file name.\n;;;\n\n(defun zrmapply (f) ; F is the file name being read.\n (funcall (get '*readermacro* (rmchar)) f)\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZRMBQ": {"ttr": 9501, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x00\\x1f\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 31, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This function is used to implement the reader macro ` (backquote).\n;\n;            This function now returns the expansion of a backquoted\n;            expression at read time, rather than at evaluation time.\n;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; Old function definition (created a call to the ` macro)\n;\n; (DEFUN ZRMBQ (F)\n;  (LIST '|`| (READ F))\n; )\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defargs mxbq 1 1 nil)\n\n(defun zrmbq (f) ; F is the file name passed by the READ function\n (mxbq (read f))\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZRMCOMMA": {"ttr": 9503, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This function is used to implement the reader macro , (comma).\n;\n\n(defun zrmcomma (f) ; F is the file name passed by the READ function\n `(,(case (tyipeek nil f)\n          (#\\@         (tyi f)            ; Throw away the character.\n                       '|,@|)\n          (#\\.         (tyi f)            ; Throw away the character.\n                       '|,.|)\n          (t           '|,|))\n   ,(read f)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZRMQUOTE": {"ttr": 9505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x00\\x10\\x00\\r\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 16, "newlines": 13, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This function is used to implement the reader macro ' (QUOTE).\n;\n\n(defun zrmquote (x) ; X is the file name passed by the READ function\n `(quote ,(read x))\n)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZRMSELF": {"ttr": 9507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x00\\x16\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 22, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; \"ZRMSELF\"\n;;;\n;;; This is a general-purpose reader macro whose purpose in life is to\n;;; return the character itself, like a single-syntax character.\n;;;\n;;; This may be used to simulate at least one use of the MACLisp\n;;; SETSYNTAX function.\n;;;\n\n(defun zrmself (f) ; F is the file name being read.\n (rmchar)          ; Just return the reader macro character.\n)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZRMSHARP": {"ttr": 9509, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x87\\x05O\\x00\\x89\\x15o\\x11\\x17\\x01\\xb5\\x01\\x0c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1987-02-23T00:00:00", "modifydate": "1989-06-05T11:17:00", "lines": 437, "newlines": 268, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This function is used to implement the reader macro #.\n;\n; Currently the only syntax supported is:\n;\n;   #'FOO   --> (FUNCTION FOO)\n;   #+FOO BAR  --> BAR, only if feature FOO exists\n;   #-FOO BAR  --> BAR, only if feature FOO doesn't exist\n;   #.FOO   --> evaluated value of FOO.\n;   #/FOO   --> the fixnum corresponding to the character FOO.\n;   #\\FOO   --> same as #/FOO.\n;   #\u00acY     --> the fixnum correspinding to \"CONTROL Y\" if it existed.\n;   #o777   --> integer expressed in octal.\n;   #O777   --> integer expressed in octal.\n;   #x7F0   --> integer expressed in hex.\n;   #X7F0   --> integer expressed in hex.\n;   #b101   --> integer expressed in binary.\n;   #B101   --> integer expressed in binary.\n;   #nnRnnn --> integer expressed in radix nn.\n;   #|...|# --> comments.\n;   #(...)  --> vector.\n;\n;   #,FOO   --> load-time evaluation of FOO.  Currently this is\n;               identical to #.FOO, which it's supposed to be\n;               under the interpreter anyhow.\n;\n; ZIL-only extensions...\n;\n;   #z7F0   --> FIXNUM expressed in hex.\n;   #Z7F0   --> FIXNUM expressed in hex.\n;\n; and...\n;\n;   # followed by a character, if the symbol whose print name is that\n;     character has a SHARPMACRO property.  This property must be a\n;     function of one argument (the file name) much like a read macro.\n;\n\n(eval-when ()  ; Processed by nobody but READ.\n #.(progn\n    (defvar character-types\n     '(\n           (NULL      .   #X00)\n           (HT        .   #X05)\n           (TAB       .   #X05)\n           (DEL       .   #X07)\n           (RUBOUT    .   #X07)\n           (VT        .   #X0B)\n           (CR        .   #X0D)\n           (RETURN    .   #X0D)\n           (NL        .   #X15)\n           (NEWLINE   .   #X15)\n           (BS        .   #X16)\n           (BACKSPACE .   #X16)\n           (LF        .   #X25)\n           (LINEFEED  .   #X25)\n           (FF        .   #X2C)\n           (FORM      .   #X2C)\n           (PAGE      .   #X2C)\n           (SP        .   #X40)\n           (SPACE     .   #X40)\n           (ALT       .   #X100) ; \"Invalid\".\n           (ALTMODE   .   #X100) ; \"Invalid\".\n     ))\n  )\n)\n\n(defmacro upsym (x)\n `(ebcdic (char-upcase ,x) t))\n\n(defun zrmsharp (f) ; F is the file name passed by the READ function\n\n (let* (\n        (c) ; Will be set to first non-numeric character read.\n        (n (prog (d z)\n             loop\n                 (setq c (or (tyipeek nil f nil #+ZIL13 nil)\n                             (zerror \"No dispatch character for #\")))\n                 (setq d (digit-char-p c 10))\n                 (when (null d)\n                       (return z))\n                 (setq z (+ (* 10 (or z 0)) d))\n                 (tyi f)   ; Throw away the numeric char to get next 1\n                 (go loop)\n          ))\n        (a (upsym c))\n        (b (get a 'sharpmacro))\n       )\n       (cond\n        (b                            (funcall b f n))\n        ((eq a '\\')                   (sharp-quote   f n))\n        ((eq a '\\+)                   (sharp-plus    f n))\n        ((eq a '\\-)                   (sharp-minus   f n))\n        ((eq a '\\.)                   (sharp-period  f n))\n        ((eq a '\\,)                   (sharp-comma   f n))\n        ((eq a '\\/)                   (sharp-escape  f n))\n        ((eq a '\\\\)                   (sharp-escape  f n))\n        ((eq a '\\\u00ac)                   (sharp-control f n))\n        ((eq a '\\O)                   (sharp-octal   f n))\n        ((eq a '\\X)                   (sharp-hex     f n))\n        ((eq a '\\B)                   (sharp-binary  f n))\n        ((eq a '\\R)                   (sharp-radix-n f n))\n        ((eq a '\\|)                   (sharp-comment f n))\n        ((eq a '\\()  #| ) |#          (sharp-vector  f n))\n        ((eq a '\\Z)                   (sharp-hex370  f n))\n        (t (zerror \"Unknown dispatch character following #\" a)))))\n\n;=======================================================================\n\n;\n; #'foo --> (FUNCTION foo)\n;\n\n(defun sharp-quote (f n)\n (when n (warn \"Numeric modifier not allowed for #'\" n))\n (tyi f)     ; Throw away the character following the #.\n `(function ,(read f))\n)\n\n;=======================================================================\n\n;\n; #.(foo) --> ...whatever the value of (foo) is...\n;\n\n(defun sharp-period (f n)\n (when n (warn \"Numeric modifier not allowed for #.\" n))\n (tyi f) ; Throw away the character following the #.\n (catch nil (eval (read f)))  ; Return NIL if error evaluating form.\n)\n\n;=======================================================================\n\n;\n; #,(foo) --> ...whatever the value of (foo) is at load time ...\n;\n\n(defun sharp-comma (f n)\n (when n (warn \"Numeric modifier not allowed for #,\" n))\n (when (featurep 'zilco) ; If being read by the compiler\n  (cterpri)\n  (princ \"Load-time evaluation (#,) not supported by ZIL compiler.\")\n  (terpri)\n  (princ \"Processing as read-time evaluation (#.).\")\n  (terpri)\n )\n (sharp-period f nil) ; Process like #.\n)\n\n;=======================================================================\n\n;\n; #+foo --> if foo is a feature, then whatever follows\n;\n\n(defun sharp-plus (f n)\n (when n (warn \"Numeric modifier not allowed for #+\" n))\n (tyi f) ; Throw away the character following the #.\n (cond\n       ((sharp-eval-features (read f)) (read f))\n       (t                              (read f) (rmnil))))\n\n;\n; #-foo --> if foo is NOT a feature, then whatever follows\n;\n\n(defun sharp-minus (f n)\n (when n (warn \"Numeric modifier not allowed for #-\" n))\n (tyi f) ; Throw away the character following the #.\n (cond\n       ((sharp-eval-features (read f)) (read f) (rmnil))\n       (t                              (read f))))\n\n(defun sharp-eval-features (x)\n (cond\n      ((atom x)           (featurep x))\n      ((eq (zcar x) 'or)  (mapor  #'sharp-eval-features (cdr x)))\n      ((eq (zcar x) 'and) (mapand #'sharp-eval-features (cdr x)))\n      ((eq (zcar x) 'not) (if (and (cdr x) (null (cddr x)))\n                              (not (sharp-eval-features (zcadr x)))\n                              (zerror \"Invalid feature spec form\" x)))\n      (t                  (zerror \"Invalid feature spec form\" x))))\n\n;\n; #/foo --> returns a character object (actually a fixnum)\n; #\\foo --> same as #/foo\n;\n\n(defun sharp-escape (f n)\n (when n (warn \"Numeric modifier not allowed for #\\\\\" n))\n (tyi f) ; Throw away the character following the #.\n (character-representation f))\n\n;\n; #\u00acfoo --> returns an impossible character object fixnum for CNTL-foo\n;\n\n(defun sharp-control (f n)\n (when n (warn \"Numeric modifier not allowed for #\u00ac\" n))\n (tyi f) ; Throw away the character following the #.\n (+ 256 (character-representation f))\n)\n\n(defun character-representation (f)\n (let ((a (tyipeek nil f)))\n  (if (alpha-char-p a)\n      (let* ((r (read f))\n             (c (assq r '#.character-types)))\n            (if c (cdr c)\n                  (if (eql (string-length r) 1) ; If it read 1 character\n                      a\n                      (zerror \"Unknown character representation\" r))))\n      (tyi f))))\n\n;\n; #o777 ...\n;\n(defun sharp-octal (f n)\n (when n (warn \"Numeric modifier not allowed for #O\" n))\n (sharp-radix f 8))\n\n;\n; #x1AC8 ...\n;\n(defun sharp-hex (f n)\n (when n (warn \"Numeric modifier not allowed for #X\" n))\n (sharp-radix f 16))\n\n;\n; #b1011 ...\n;\n(defun sharp-binary (f n)\n (when n (warn \"Numeric modifier not allowed for #B\" n))\n (sharp-radix f 2))\n\n;\n; #36rfoobar ...\n;\n(defun sharp-radix-n (f n)\n (unless n (zerror \"Numeric modifier required for #R\"))\n (when (or (< n 2) (> n 36))\n       (zerror \"Invalid radix modifier for #R\" n))\n (sharp-radix f n))\n\n(defun sharp-radix (f radix)\n (tyi f) ; Throw away the character following the #.\n (prog (a z neg? err)\n       (setq z 0)\n  get1\n       (when (eql (setq a (or (tyipeek nil f nil #+ZIL13 nil)\n                   (zerror \"No digits following # with radix\" radix)))\n                  #\\SP)\n             (tyi f)\n             (go get1))\n       (case a\n             ((#\\-) (setq neg? t)\n                    (go next))\n             ((#\\+) (setq neg? nil)\n                    (go next))\n       )\n  loop\n       (let ((weight (or (digit-char-p a 36) (go ret))))\n            (if (not (< weight radix))\n                (push (symbol-name (ebcdic a)) err)\n                (setq z (+ weight (* z radix)))))\n  next\n       (tyi f)\n       (setq a (tyipeek nil f))\n       (go loop)\n  ret\n       (when err\n             (zerror `(\"Invalid digit(s) for radix \" ,radix)\n                    (nreverse err)))\n       (return (if neg? (minus z) z))\n )\n)\n\n;;;\n;;; #Znnn is like #Xnnn except that it always produces a fixnum,\n;;; which can be two's complement, and therefore cannot have more\n;;; than 8 hex characters.\n;;;\n;;; For example...\n;;;\n;;; #XFFFFFFFF  =  42\n;;; #ZFFFFFFFF  =  -1\n;;;\n\n(defun sharp-hex370 (f n)\n (when n (warn \"Numeric modifier not allowed for #Z\" n))\n (tyi f) ; Throw away the character following the #.\n (prog (a z count err)\n       (setq z 0 count 0)\n  get1\n       (when (eql (setq a (or (tyipeek nil f nil #+ZIL13 nil)\n                              (zerror \"No digits following #Z\")))\n                  #\\SP)\n             (tyi f)\n             (go get1))\n  loop\n       (when (> count 8)\n             (zerror \"Too many hex digits in #Z constant\"))\n       (setq count (1+ count))\n       (let ((weight (or (digit-char-p a 36) (go ret))))\n            (if (not (< weight 16))\n                (push (symbol-name (ebcdic a)) err)\n                (setq z (+ weight (lsh z 4)))))\n  next\n       (tyi f)\n       (setq a (tyipeek nil f))\n       (go loop)\n  ret\n       (when err (zerror \"Invalid hex digit(s)\" (nreverse err)))\n       (return z)\n )\n)\n\n;\n; #| comment ... |#\n;\n(defun sharp-comment (f n)\n (when n (warn \"Numeric modifier not allowed for #|\" n))\n (tyi f) ; Throw away the character following the #.\n (prog (c)\n  loop (setq c (tyi f))           ; Search for other comment characters.\n  chk1 (cond                      ; See what we got.\n        ((eof f) (return (rmnil)))  ; If end of file, terminate.\n        ((eql c #\\|)                ; If we got |, we might have |#.\n         (setq c (tyi f))           ; Get next character.\n         (or (eql c #\\#) (go chk1)) ; If not #, check as usual.\n         (return (rmnil)))          ; If |# found, return to reader.\n        ((eql c #\\#)                ; If we got #, may be nested #|.\n         (setq c (tyi f))           ; Get next character.\n         (or (eql c #\\|) (go chk1)) ; If not #|, keep checking.\n         (sharp-comment f n)        ; Process nested comment group.\n         (go loop))                 ; and then keep going.\n        (t (go loop)))))\n;\n; #(foo bar baz)\n;\n(defun sharp-vector (f n)\n ; Don't throw away the left parenthesis - we need it to read the list\n (cond\n  (n\n   (prog (z l i y)\n         (setq z (make-vector n))\n         (setq l (read f))\n         (setq i 0)\n         (setq y nil)\n    loop\n         (cond\n          ((eql i n)\n           (when l (warn \"Too many objects for #(, ignored\" l)) ; )\n           (return z))\n          ((null l)\n           (vset z i y))\n          ((atom l)\n           (zerror \"Improper syntax for #(\" l))    ; )\n          (t\n           (setq y (zcar l))\n           (vset z i y)))\n         (setq l (cdr l))\n         (setq i (1+ i))\n         (go loop)))\n\n  (t\n   (zmvector (read f)))))\n\n;;;\n;;; Just a random repository of code that would be inserted into\n;;; ZRMSHARP if we wanted to make #\u00acfoo do something.\n;;;\n;;; We have NOT activated it.  #\u00ac exists only because of Macsyma,\n;;; and we don't want to cause any \"real\" EBCDIC characters to\n;;; start behaving like ASCII control characters.  So we let #\u00ac\n;;; generate an \"impossible\" character instead.\n;;;\n;;; (defvar control-fakeouts\n;;;  (let ((cflist (make-list 256)))\n;;;        ;\n;;;        ; Since it's not clear whether #\u00aca is supposed to be the\n;;;        ; same as #\u00acA or not, and #\u00ac is not even defined as part\n;;;        ; of CL, the lower-case letters are left undefined.\n;;;        ;\n;;;        (setf (nth #\\@  cflist) #X00) ; NUL\n;;;        (setf (nth #\\A  cflist) #X01) ; SOH\n;;;        (setf (nth #\\B  cflist) #X02) ; STX\n;;;        (setf (nth #\\C  cflist) #X03) ; ETX\n;;;        (setf (nth #\\D  cflist) #X37) ; EOT\n;;;        (setf (nth #\\E  cflist) #X2D) ; ENQ\n;;;        (setf (nth #\\F  cflist) #X2E) ; ACK\n;;;        (setf (nth #\\G  cflist) #X2F) ; BEL\n;;;        (setf (nth #\\H  cflist) #X16) ; BS\n;;;        (setf (nth #\\I  cflist) #X05) ; HT\n;;;        (setf (nth #\\J  cflist) #X25) ; LF\n;;;        (setf (nth #\\K  cflist) #X0B) ; VT\n;;;        (setf (nth #\\L  cflist) #X0C) ; FF\n;;;        (setf (nth #\\M  cflist) #X0D) ; CR\n;;;        (setf (nth #\\N  cflist) #X0E) ; SO\n;;;        (setf (nth #\\O  cflist) #X0F) ; SI\n;;;        (setf (nth #\\P  cflist) #X10) ; DLE\n;;;        (setf (nth #\\Q  cflist) #X11) ; DC1\n;;;        (setf (nth #\\R  cflist) #X12) ; DC2\n;;;        (setf (nth #\\S  cflist) #X13) ; DC3\n;;;        (setf (nth #\\T  cflist) #X3C) ; DC4\n;;;        (setf (nth #\\U  cflist) #X3D) ; NAK\n;;;        (setf (nth #\\V  cflist) #X32) ; SYN\n;;;        (setf (nth #\\W  cflist) #X26) ; ETB\n;;;        (setf (nth #\\X  cflist) #X18) ; CAN\n;;;        (setf (nth #\\Y  cflist) #X19) ; EM\n;;;        (setf (nth #\\Z  cflist) #X3F) ; SUB\n;;;        (setf (nth #XAD cflist) #X27) ; ESC   (cntl-left-bracket)\n;;;        (setf (nth #\\\\  cflist) #X1C) ; {I}FS\n;;;        (setf (nth #XBD cflist) #X1D) ; {I}GS (cntl-right-bracket)\n;;;        (setf (nth #\\\u00ac  cflist) #X1E) ; {I}RS\n;;;        (setf (nth #\\_  cflist) #X1F) ; {I}US\n;;;        (setf (nth #\\`  cflist) #X40) ; SP\n;;;        (setf (nth #\\{  cflist) #\\; ) ; ;\n;;;        (setf (nth #\\|  cflist) #\\< ) ; <\n;;;        (setf (nth #\\}  cflist) #\\= ) ; =\n;;;        (setf (nth #\\~  cflist) #\\> ) ; >\n;;;        (setf (nth #X07 cflist) #\\? ) ; ?    (cntl-rubout)\n;;;        cflist\n;;;  ))\n;;;  (defun sharp-control (f)\n;;;   (tyi f) ; Throw away the character following the #.\n;;;   (let ((c (character-representation f)))\n;;;        (or (nth c '#.control-fakeouts)\n;;;            (zerror \"Unknown ASCII control spec\" (ebcdic c)))))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXADD1": {"ttr": 9732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x13/\\x00\\x89\\x15o\\x11\\x18\\x00Q\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-05-11T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 81, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for ADD1 (1+).\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (eval)\n (deftrans add1   zxadd1)\n (deftrans 1+     zxadd1)\n)\n\n(defun zxadd1 (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 1 argument.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 2))\n   xform)\n\n  (t\n   (let* (\n          (arg (cadr xform))\n          (carg (zilcocon arg nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the argument is constant, perform the test at compile time.\n  ;;\n  ;; Note: If errors (like non-numeric arg) occur, the compiler\n  ;;       transform mechanism will trap the error and suppress\n  ;;       the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          (carg\n           (warn \"Performing compile-time ADD1\" xform)\n           (add1 (car carg)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (ADD1 (SUB1 x)) --> (VALUES x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and (consp arg)\n                (eql (length arg) 2)\n                (memq (car arg) '(sub1 1-)))\n           `(values ,(cadr arg)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXAND": {"ttr": 9734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87#/\\x00\\x89\\x15o\\x11\\x18\\x00\\\\\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-08-20T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 92, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for AND.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/29/88 - Optimization from AND to COND in certain cases added to  *\n;*            improve code generation for weird things like MEMQ.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n\n(defun zxand (xform xenv xcon)\n\n (prog (head tail body form formcon)\n  (setq head (car xform) tail (cdr xform))\n  ;;\n  ;; (AND) --> T\n  ;;\n  (when (null tail) (return t))\n  ;;\n  ;; (AND x) --> x\n  ;;\n  (when (null (cdr tail)) (return (car tail)))\n  ;;\n  ;; If for effect only (context is null):\n  ;;\n  ;; (AND x y) --> (COND (x y))\n  ;;\n  ;; This enables somewhat better code in certain situations, like\n  ;; when x is (MEMQ ...).\n  ;;\n  (when (and (null xcon) (null (cddr tail)))\n        (return `(cond (,(car tail) ,(cadr tail)))))\n\n  (setq body tail)\n\n loop\n\n  (setq form (car body))\n  (setq formcon (zilcocon form nil))\n\n  (cond\n   ;;\n   ;; form not a constant - no optimization this round\n   ;;\n   ((null formcon)\n    (go continue))\n   ;;\n   ;; constant form is last - no optimization is to be done\n   ;;\n   ((null (cdr body))\n    (return xform))\n   ;;\n   ;; (AND <forms> NIL <more_forms>) --> (AND <forms> NIL)\n   ;;\n   ((null (car formcon))\n    (warn `(\"AND forms not executed following constant \" ,(car formcon))\n       (cdr body))\n    (return (cons head (loop for oldform in tail\n                             collect oldform\n                             until (eq oldform form)))))\n   ;;\n   ;; (AND <forms> 'TRUE <more_forms>) --> (AND <forms> <more-forms>)\n   ;;\n   (t\n    (return (cons head (remq form tail))))\n  )\n\n continue\n\n  (if (setq body (cdr body))     ; Next form\n      (go loop)\n      (return xform))            ; No more optimizations apply\n\n )\n)\n\n(eval-when (eval)\n (deftrans and zxand))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXAPPEND": {"ttr": 9736, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x19O\\x00\\x89\\x15o\\x11\\x18\\x00\\x19\\x00\\x16\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-07-13T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 25, "newlines": 22, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This is the compiler transformation function for APPEND.\n;;;\n;;; (DEFTRANS APPEND ZXAPPEND)\n;;;\n;;; This replaces the old MXAPPEND \"macro\" expander.\n;;;\n\n; Note that (APPEND FOO) --> (APPEND2 FOO NIL) for idiomatic list-copy.\n\n(defun zxappend (l ignore1 ignore2) (zxappend1 (cdr l)))\n\n(defun zxappend1 (l)\n (cond ((null l)        nil)\n       ((null (cdr l))  `(append2 ,(car l) nil))\n       ((null (cddr l)) `(append2 ,(car l) ,(cadr l)))\n       (t               `(append2 ,(car l) ,(zxappend1 (cdr l))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXARFUN": {"ttr": 9738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x13?\\x00\\x89\\x15o\\x11\\x18\\x00\\xad\\x00\\xb9\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-05-12T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 173, "newlines": 185, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for all ZIL functions that always\n; return the same value for constant arguments, and that have no\n; other transform properties.\n;\n; These include but are not limited to arithmetic functions.\n;\n; The primary purpose of this transform is constant folding -\n; evaluation of operations on constants at compile time.\n;\n; Predicates are handled here too.  But equality predicates cannot be\n; included, since the result of an equality predicate is not always\n; guaranteed to be meaningful - the result of an equality test at\n; compile time may not be the result it will always return for two\n; such objects.\n;\n; LOG is not handled by this transform - see ZXLOG.\n;\n; ADD1 (1+) and SUB1 (1-) are not handled by this transform -\n; they should have their own.\n;\n; Hey, NTH and NTHCDR should have their own transforms too!\n;\n; Transforms for ZIFxxx aren't necessary, since they will never occur\n; in actual code.\n;\n; Accessors (CAR, CDR, etc.) aren't included here - see ZXCARCDR.\n;\n; KEYWORDP isn't here, because eventually it will check the package\n; cell of the symbol, which can conceivably be altered.  Right now\n; it checks the print name, which is unalterable, but this is a\n; temporary hack for a packageless ZIL.\n;\n; Functions that return new vectors cannot be included here, since\n; ZIL can't compile inline constant vectors.  Anyhow, the same\n; principle applies to vectors as to lists.\n;\n; Functions that return new lists are generally not included here,\n; since lists should be consed afresh whenever possible.\n;\n; The same should apply to strings, but not now, since ZIL doesn't\n; have mutable strings yet.  So we can transform string-creators.\n;\n;\n;\n;\n;\n\n(eval-when (eval)\n (mapc #'(lambda (x) (putprop x 'zxarfun 'compiler-transform))\n       '(abs\n         alphacp\n         alpha-char-p\n         atom\n         bigp\n         char\n         closurep\n         codep\n         consp\n         dfloatp\n         digitcp\n         digit-char-p\n         ebcdic\n         evenp\n         fixnump\n         fixp\n         float\n         floatp\n         funargp\n         getchar\n         getcharn\n         greaterp\n         haipart   ; at least until it has its own transform\n         haulong\n         index\n         string-index\n         integerp\n         land      ; at least until it has its own transform\n         length\n         lessp\n         listp\n         llkeywdp  ; yes, checks print name only\n         llvars    ; yes, syntactic-surface-scanner\n         logbitp   ; at least until it has its own transform\n         logcount\n         lognot\n         logtest   ; at least until it has its own transform\n         lor       ; at least until it has its own transform\n         lxor      ; at least until it has its own transform\n         max2\n         minus\n         minusp\n         min2\n         mkbignum\n         make-bignum\n         mkfixnum\n         make-fixnum\n         mkflonum\n         make-flonum\n         not\n         null\n         numberp\n         oddp\n         plusp\n         sfloatp\n         slength\n         string-length\n         stringp\n         structp\n         subrp\n         symbolp\n         unebcdic\n         vecp\n         vectorp\n         verify\n         string-verify\n         vlength\n         zerop\n         zilbool\n         zilflat\n         zilintln\n         integer-length\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;        sxhash            ; No, what if hashing algorithm changes?\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; The following create strings.  They probably shouldn't be\n;;; constant-folded, since some day strings will be mutable.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; chardown char-downcase charup char-upcase downcase string-downcase\n; sappend string-append sappendl string-appendl scapital\n; string-capitalize sltrim string-left-trim sremove string-remove\n; sreverse string-reverse srtrim string-right-trim strim string-trim\n; substr string-substr tostring upcase string-upcase\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        ))\n)\n\n(defun zxarfun (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If all arguments are constant, perform the test at compile time.\n  ;;\n  ;; Note: If errors (like wrong # of arguments) occur, the compiler\n  ;;       transform mechanism will trap the error and suppress\n  ;;       the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((every #'(lambda (x) (zilcocon x nil)) (cdr xform))\n           (warn \"Evaluating at compile time\" xform)\n           `',(eval xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          (t xform)))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZXARITH": {"ttr": 9740, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x19_\\x00\\x89\\x15o\\x11\\x18\\x007\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 55, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is a general-purpose compiler transform for arithmetic\n; functions that take multiple arguments.  For example...\n;\n; (PLUS 1 2 3 4) --> (ZILADD (ZILADD (ZILADD 1 2) 3) 4)\n;\n; There are 4 arguments:  (1) the form to be transformed\n;                         (2) the name of the primitive binary function\n;                         (3) the identity value (if no operands)\n;                         (4) NIL if it's OK to have no operands\n;                             (in which case the value specified by\n;                             (3) is returned); otherwise an error is\n;                             signalled if no operands are specified.\n;                             This arg is optional, default = NIL.\n;\n; This used to be MXARITH, a \"macro\" expander.  As such, the\n; environment and context args are not (currently) passed from\n; the compiler transform to this function.\n;\n; e.g. (deftrans plus (x) (zxarith (cdr x) 'ziladd 0))\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n\n(defun zxarith (args func iden &optional needsargs)\n (cond\n  ((null args)        (if needsargs\n                          (zerror \"Missing argument(s)\" needsargs)\n                          iden))\n  ((null (cdr args)) `(values ,(car args))) ;Assume (arithfunc n) <=> n.\n  ((null (cddr args)) `(,func . ,args))\n  (t (zxarith-reverse (reverse args) func iden))))\n\n(defun zxarith-reverse (args func iden)\n (cond\n  ((null (cddr args)) `(,func ,(cadr args) ,(car args)))\n  (t `(,func ,(zxarith-reverse (cdr args) func iden) ,(car args)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXASSOC": {"ttr": 9742, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x88\\to\\x00\\x89\\x15o\\x11\\x18\\x00\\xe0\\x00\\xdd\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 224, "newlines": 221, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform function for ASSOC.\n;\n; Currently, inline code is always generated (except in the\n; case of :TEST #'EQ, when a call to ASSQ is generated, which\n; compiles inline anyhow).\n;\n\n(eval-when (eval)\n (deftrans assoc zxassoc)\n)\n\n(defmacro local-variable-p (x)       ; Please, x must be a symbol.\n `(and (symbolp ,x) (memq ,x xenv)))\n\n(defun zxassoc (xform xenv xcon)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Note that there must be at least 2 arguments.  If there are fewer,\n  ;; no transformation is done.  However, if there are more, then GETK\n  ;; will signal an error for invalid keywords,\n  ;; and this will cause the transformation to fail, which in the\n  ;; compiler has the effect of suppressing the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n (cond\n  ((lessp (length xform) 3)\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (rest (cdddr xform))\n          (rest-length (length rest))\n          (test      (getk rest ':test))\n          (test-not  (getk rest ':test-not))\n          (key       (getk rest ':key))\n          (expected-length (+ (if test 2 0)\n                              (if test-not 2 0)\n                              (if key 2 0)))\n         )\n    (zxassoc-optimize xform xenv xcon arg1 arg2\n                       rest-length expected-length\n                       (car test) (car test-not) (car key)\n                       test test-not key)))))\n\n(defun zxassoc-optimize (xform xenv xcon arg1 arg2\n                                          rest-length expected-length\n                                          test test-not key\n                                          test? test-not? key?)\n (let (\n       (carg1  (zilcocon arg1 nil))\n       (carg2  (zilcocon arg2 nil))\n       (ctest     (if test?     (zxassoc-confun test)))\n       (ctest-not (if test-not? (zxassoc-confun test-not)))\n       (ckey      (if key?      (zxassoc-confun key)))\n      )\n\n      (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the length of the &rest argument is such that more keys were\n  ;; specified than expected, then suppress the transformation.\n  ;;\n  ;; Checking for keys is done this way to allow for the possibility\n  ;; of non-constant key names, :allow-other-keys, etc.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((> rest-length expected-length)\n        (warn \"Nonstandard or unexpected keyword args to ASSOC\" xform)\n        xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If all arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((and carg1\n             carg2\n             (or (not test?) ctest)\n             (or (not test-not?) ctest-not)\n             (or (not key?) ckey)\n        )\n        (warn \"Evaluating ASSOC with constant args at compile time\"\n              xform)\n        `',(eval xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If :TEST is #'EQ or 'EQ, and no other keywords are specified,\n  ;; then transform the call to ASSQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((and test?\n             (not test-not?)\n             (not key?)\n             (eq (car ctest) 'eq))\n        `(assq ,arg1 ,arg2))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both :TEST and :TEST-NOT specified, error.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((and test? test-not?)\n        (zerror \"Both :TEST and :TEST-NOT keywords given to ASSOC\"\n                xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, transform the call to inline code.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n     (t\n      (let (\n            (loop  (gensym))\n            (true  (gensym))\n            (arglist    nil)\n            (lambdalist nil)\n            (elt   (gensym))\n            (item)\n            (alist)\n            (ftest)\n            (fkey)\n            (comparison)\n           )\n       (cond\n        ((or carg1 (local-variable-p arg1))\n         (setq item arg1))\n        (t\n         (let ((g (gensym)))\n              (push arg1 arglist)\n              (push g lambdalist)\n              (setq item g))))\n       (let ((g (gensym)))\n            (push arg2 arglist)\n            (push g lambdalist)\n            (setq alist g))\n       (cond\n        (ctest\n         (setq ftest ctest))\n        ((not test?)\n         (setq ftest '(eql)))\n        ((local-variable-p test)\n         (setq ftest `(funcall ,test)))\n        (t\n         (let ((g (gensym)))\n              (push test arglist)\n              (push g lambdalist)\n              (setq ftest `(funcall ,g)))))\n       (cond\n        (ctest-not\n         (setq ftest ctest-not))\n        ((and test-not? (local-variable-p test-not))\n         (setq ftest `(funcall ,test-not)))\n        (test-not?\n         (let ((g (gensym)))\n              (push test-not arglist)\n              (push g lambdalist)\n              (setq ftest `(funcall ,g)))))\n       (cond\n        (ckey\n         (setq fkey ckey))\n        ((not key?)\n         (setq fkey '(progn)))\n        ((local-variable-p key)\n         (setq fkey `(funcall ,key)))\n        (t\n         (let ((g (gensym)))\n              (push key arglist)\n              (push g lambdalist)\n              (setq fkey `(funcall ,g)))))\n\n       ; There is some doubt about the meaning of the :key.\n       ; See the source of ASSOC for possible interpretations.\n\n       (setq comparison\n             (let ((x `(,@ftest ,item (,@fkey (zcar ,elt)))))\n                  (if test-not? `(not ,x) x)))\n\n       `((lambda ,(nreverse lambdalist)\n                 (and ,alist\n                  (prog (,elt)\n                   ,loop\n                        (cond\n                         ((and (setq ,elt (zcar ,alist))\n                               ,comparison)\n                          (go ,true))\n                         ((setq ,alist (cdr ,alist))\n                          (go ,loop))\n                         (t\n                          (return nil)))\n                   ,true\n                        (return ,elt))))\n         ,.(nreverse arglist)))))))\n\n\n(defun zxassoc-confun (x)\n (cond\n  ((and (consp x)\n        (consp (cdr x))\n        (null  (cddr x))\n        (memq (car x) '(function quote)))\n   (ncons (cadr x)))\n  (t\n   (zilcocon x nil))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXBINOP": {"ttr": 9745, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x88\\x13\\x1f\\x00\\x89\\x15o\\x11\\x18\\x00\\xf9\\x00\\xdf\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1988-05-10T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 249, "newlines": 223, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for ZIL arithmetic binary operators.\n;\n; These include:\n;\n;   ZILADD - the 2-argument function underlying + or PLUS\n;   ZILSUB - the 2-argument function underlying - or DIFFERENCE\n;   ZILMUL - the 2-argument function underlying * or TIMES\n;   ZILDIV - the 2-argument function underlying / or QUOTIENT\n;   ZILREM - the 2-argument function underlying // or REMAINDER\n;\n; The primary purpose of this transform is:\n;\n; (1) Constant folding - evaluation of binary operations on\n;     two constants at compile time\n;\n; (2) Algebraic simplification - elimination of adding zero or\n;     multiplying by 1\n;\n; (3) Conversion to 1+ and 1- where appropriate\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n\n(eval-when (eval)\n (deftrans ziladd zxbinop)\n (deftrans zilsub zxbinop)\n (deftrans zilmul zxbinop)\n (deftrans zildiv zxbinop)\n (deftrans zilrem zxbinop)\n (deftrans lsh    zxbinop)\n (deftrans ash    zxbinop)\n (deftrans rot    zxbinop)\n)\n\n(defun zxbinop (xform xenv xcon &aux\n                                (func (car xform))\n                                (intfunp\n                                 (memq func '(zilrem ash lsh rot))))\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;; Note: If errors (like division by zero) occur, the compiler\n  ;;       transform mechanism will trap the error and suppress\n  ;;       the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 carg2)\n           (warn `(\"Performing compile-time \"\n                   ,(case func\n                          (ziladd \"addition\")\n                          (zilsub \"subtraction\")\n                          (zilmul \"multiplication\")\n                          (zildiv \"division\")\n                          (zilrem \"remainder\")\n                          (t      func)))\n                 (car carg1) (car carg2))\n           (funcall func (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If one of the arguments is a constant, and the other is not,\n  ;; then possible transformations depend on the function.\n  ;;\n  ;; Note that the constant argument must be of the correct type to\n  ;; preserve correctness.  Optimizing out a constant of the wrong\n  ;; type could prevent the required type coercions.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Errors:\n  ;;\n  ;; (anyfunc not-a-number x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((or (and carg1 (not (numberp (car carg1))))\n               (and carg2 (not (numberp (car carg2)))))\n           (zerror \"Non-numeric argument\" xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Errors:\n  ;;\n  ;; (intfun not-an-integer x)\n  ;; (intfun x not-an-integer)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and intfunp\n                (or (and carg1 (not (integerp (car carg1))))\n                    (and carg2 (not (integerp (car carg2))))))\n           (zerror \"Non-integer argument\" xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (ZILDIV x 0.0)  --> error\n  ;; (ZILREM x 0.0)  --> error\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and (memq func '(zildiv zilrem))\n                carg2 (zerop (car carg2)))\n           (zerror \"Compile-time division by zero\" xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (ZILADD x 0)  --> (VALUES x)\n  ;; (ZILSUB x 0)  --> (VALUES x)\n  ;; (ZILMUL x 0)  --> not transformed, may go to 0 or 0.0\n  ;; (ZILDIV x 0)  --> error\n  ;; (ZILREM x 0)  --> error\n  ;; (LSH    x 0)  --> (VALUES x)\n  ;; (ASH    x 0)  --> (VALUES x)\n  ;; (ROT    x 0)  --> (VALUES x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg2 0)\n           (case func\n                 ((ziladd zilsub lsh ash rot)\n                  `(values ,arg1))\n                 (t        xform)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (ZILADD 0 x)  --> (VALUES x)\n  ;; (ZILSUB 0 x)  --> (MINUS x)\n  ;; (ZILMUL 0 x)  --> not transformed, may go to 0 or 0.0\n  ;; (ZILDIV 0 x)  --> not transformed, may go to 0 or 0.0\n  ;; (ZILREM 0 x)  --> (PROGN x 0)\n  ;; (LSH    0 x)  --> (PROGN x 0)\n  ;; (ASH    0 x)  --> (PROGN x 0)\n  ;; (ROT    0 x)  --> (PROGN x 0)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg1 0)\n           (case func\n                 (ziladd               `(values ,arg2))\n                 (zilsub               `(minus ,arg2))\n                 ((zilrem lsh ash rot) `(progn ,arg2 0))\n                 (t                    xform)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (ZILADD x 1)  --> (ADD1 x)\n  ;; (ZILSUB x 1)  --> (SUB1 x)\n  ;; (ZILMUL x 1)  --> (VALUES x)\n  ;; (ZILDIV x 1)  --> (VALUES x)\n  ;; (ZILREM x 1)  --> (PROGN x 0)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg2 1)\n           (case func\n                 (ziladd    `(add1 ,arg1))\n                 (zilsub    `(sub1 ,arg1))\n                 ((zilmul\n                   zildiv)  `(values ,arg1))\n                 (zilrem    `(progn ,arg1 0))\n                 (t         xform)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (ZILADD x -1)  --> (SUB1 x)\n  ;; (ZILSUB x -1)  --> (ADD1 x)\n  ;; (ZILMUL x -1)  --> (MINUS x)\n  ;; (ZILDIV x -1)  --> (MINUS x)\n  ;; (ZILREM x -1)  --> (PROGN x 0)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg2 -1)\n           (case func\n                 (ziladd   `(sub1 ,arg1))\n                 (zilsub   `(add1 ,arg1))\n                 (zilmul   `(minus ,arg1))\n                 (zildiv   `(minus ,arg1))\n                 (zilrem   `(progn ,arg1 0))\n                 (t        xform)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (ZILADD -1 x)  --> (SUB1 x)\n  ;; (ZILSUB -1 x)  --> not transformed\n  ;; (ZILMUL -1 x)  --> (MINUS x)\n  ;; (ZILDIV -1 x)  --> not transformed\n  ;; (ZILREM -1 x)  --> not transformed\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg1 -1)\n           (case func\n                 (ziladd   `(sub1 ,arg2))\n                 (zilmul   `(minus ,arg2))\n                 (t        xform)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXBOOLE": {"ttr": 9748, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x19O\\x00\\x89\\x15o\\x11\\x18\\x00$\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-13T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 36, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The compiler transform for BOOLE.\n;\n; (BOOLE A B C D) --> (ZILBOOL A (ZILBOOL A B C) D)\n;\n; E.G. (DEFTRANS BOOLE ZXBOOLE)\n;\n; This replaces the old MXBOOLE \"macro\" expander.\n;\n\n(defun zxboole (x ignore1 ignore2 &aux (args (cdr x)))\n (cond\n  ((null (cddr args))\n   (zerror \"Too few arguments\" x))\n  ((null (cdddr args))\n   `(zilbool . ,args))\n  ((fixp (car args))\n   (zxboole-reverse (car args) (reverse (cdr args))))\n  (t\n   (let ((temp (gensym)))\n        `(let ((,temp ,(car args)))\n              ,(zxboole-reverse temp (reverse (cdr args))))))))\n\n(defun zxboole-reverse (op args)\n (cond\n  ((null (cddr args)) `(zilbool ,op ,(cadr args) ,(car args)))\n  (t `(zilbool ,op ,(zxboole-reverse op (cdr args)) ,(car args)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXCARCDR": {"ttr": 9985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87#/\\x00\\x89\\x15o\\x11\\x18\\x00L\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-08-20T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 76, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for CAR, CDR, etc. - in general,\n; accessor functions for CONSes and symbols.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;*   Note: I haven't incorporated constant-folding.                    *\n;*                                                                     *\n;***********************************************************************\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n\n(eval-when (eval)\n (deftrans car          zxcarcdr)\n (deftrans cdr          zxcarcdr)\n (deftrans zcar         zxcarcdr)\n (deftrans zcdr         zxcarcdr)\n (deftrans plist        zxcarcdr)\n (deftrans symbol-plist zxcarcdr)\n)\n\n(defun zxcarcdr (xform xenv xcon &aux arg)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 1 argument.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 2))\n   xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the context is null (evaluated for effect only),\n  ;; return the argument without taking the CAR/CDR thereof.\n  ;;\n  ;; This allows the macro expansion of (SETF (CAR x) y) to be\n  ;; transformed into a simple call to RPLACA, for example, where\n  ;; the return value is not important.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((null xcon)\n   `(values ,(cadr xform)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (t xform)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZXCOND": {"ttr": 9987, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\"O\\x00\\x89\\x15o\\x11\\x18\\x00Q\\x00N\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-08-12T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 81, "newlines": 78, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for COND.\n;\n\n(defun zxcond (xform xenv xcon)\n\n (prog (head tail body clause thenform thencon elseform)\n  (setq head (car xform)  ; Should be 'COND.\n        tail (cdr xform)\n        body (cdr xform))\n  ;;\n  ;; (COND) --> NIL\n  ;;\n  (when (null body) (return nil))\n\n loop\n\n  (setq clause (car body))\n  ;;\n  ;; (COND ... ATOM ...)  is an error\n  ;;\n  (when (atom clause)\n        (zerror \"Invalid COND clause (not a list)\" clause))\n  (setq thenform (car clause)\n        thencon  (zilcocon thenform nil)\n        elseform (cdr clause))\n  (cond\n   ;;\n   ;; THEN clause not a constant - no optimization possible\n   ;;\n   ((null thencon)\n    (go continue))\n   ;;\n   ;; (COND (A B) (NIL FOO BAR) (C D)) --> (COND (A B) (C D))\n   ;;\n   ((null (car thencon))\n    (unless (null elseform)\n            (warn \"COND forms not executed due to false THEN clause\"\n                  elseform))\n    (return (cons head (remq clause tail))))\n   ;;\n   ;; At this point the \"then clause\" is TRUE.\n   ;;\n   (t\n    (when (cdr body)\n          (warn \"COND clauses skipped due to true THEN clause\"\n                (cdr body)))\n    (return\n     (if (eq (car tail) clause)\n         ;;\n         ;; (COND ('TRUE FOO BAR)) --> (PROGN FOO BAR)\n         ;; (COND ('TRUE))         --> 'TRUE\n         ;;\n         (if (null elseform) thenform (cons 'progn elseform))\n         ;;\n         ;; (COND (A B) (T FOO BAR) (C D)) --> (COND (A B) (T FOO BAR))\n         ;;\n         (cons head (loop for oldform in tail\n                          collect oldform\n                          until (eq oldform clause)))))))\n\n continue\n\n  (if (setq body (cdr body))     ; Next clause\n      (go loop)\n      (return xform))            ; No more optimizations apply\n\n )\n)\n\n(eval-when (eval)\n (deftrans cond zxcond))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXEQUAL": {"ttr": 9989, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x19\\x8f\\x00\\x89\\x15o\\x11\\x18\\x00e\\x00n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-17T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 101, "newlines": 110, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for EQUAL.\n;\n\n(defun zxequal (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* ((arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If one of the arguments is a constant, and the other is not,\n  ;; then optimize the call.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         (cond\n          ((and carg1 (not carg2))\n           (zxequal-optimize xform arg2 (car carg1)))\n\n          ((and carg2 (not carg1))\n           (zxequal-optimize xform arg1 (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 carg2)\n          (warn \"Evaluating EQUAL of two constants at compile time\"\n                (car carg1) (car carg2))\n          (equal (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          (t xform))))))\n\n(defun zxequal-optimize (xform arg carg)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If one of the arguments is a number, convert to call to EQL.\n  ;;\n  ;; e.g. (EQUAL X 1) --> (EQL X 1)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((numberp carg)\n   `(eql ,arg ,carg))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If one of the arguments is a symbol, convert to call to EQ.\n  ;;\n  ;; e.g. (EQUAL X 'FOO) --> (EQ X 'FOO)\n  ;;      (EQUAL NIL X)  --> (EQ X 'NIL) ; may be further transformed\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((symbolp carg)\n   `(eq ,arg ',carg))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (t\n   xform)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXEXPT": {"ttr": 9991, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x13?\\x00\\x89\\x15o\\x11\\x18\\x00\\x84\\x00\\xbc\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-05-12T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 132, "newlines": 188, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for EXPT.\n;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Cannot transform the following:\n  ;;\n  ;; (EXPT x 0) could be 1 or 1.0 or 1.0F0\n  ;; (EXPT 0 x) could be 0 or 1 or an error\n  ;; (EXPT 1 x) could be 1 or 1.0 or 1.0F0\n  ;;\n  ;; More interesting transformations involving ASH would be possible\n  ;; if we knew the type(s) of the argument(s).  That requires\n  ;; processing of declarations...\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n\n(eval-when (eval)\n (deftrans expt   zxexpt)\n (deftrans **     zxexpt)\n (deftrans \u00ac      zxexpt)\n)\n\n(defun zxexpt (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;; Note: If errors (like non-numeric arg) occur, the compiler\n  ;;       transform mechanism will trap the error and suppress\n  ;;       the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 carg2)\n           (warn \"Performing compile-time exponentiation\" xform)\n           (expt (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Errors:\n  ;;\n  ;; (EXPT not-a-number x)\n  ;; (EXPT x not-a-number)\n  ;; (EXPT x bignum)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 (not (numberp (car carg1))))\n           (zerror \"Non-numeric first argument to EXPT\" xform))\n\n          ((and carg2 (not (numberp (car carg2))))\n           (zerror \"Non-numeric second argument to EXPT\" xform))\n\n          ((and carg2 (bigp (car carg2)))\n           (zerror \"Second argument to EXPT is a bignum\" xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (EXPT x 1) --> (VALUES x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg2 1)\n           `(values ,arg1))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (EXPT x 2) --> (ZILMUL x x)\n  ;; (EXPT (foo) 2) --> ((LAMBDA (G00001) (ZILMUL G00001 G00001)) (foo))\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg2 2)\n           (if (local-variable-p arg1)\n               `(zilmul ,arg1 ,arg1)\n               (let ((g (gensym)))\n                    `((lambda (,g) (zilmul ,g ,g)) ,arg1))))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n(defmacro local-variable-p (x)       ; Please, x must be a symbol.\n `(and (symbolp ,x) (memq ,x xenv)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXFIX": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87(\\x7f\\x00\\x89\\x15o\\x11\\x18\\x00n\\x00T\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1989-06-05T11:18:00", "lines": 110, "newlines": 84, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for CEILING, FLOOR, ROUND, TRUNCATE.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defmacro possible-multiple-value-context-p ()\n `(memq (car xcon) '(:dummy :value :return :mvlist :mvbind)))\n\n(defun zxfix (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be either 1 or 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (member (length xform) '(2 3)))\n   xform)\n\n  (t\n\n   (let* ((function (car xform))\n          (zilfixnum (cdr (or (assq function '((fix      . 4) ;FIX=FLOOR\n                                               (truncate . 0)\n                                               (floor    . 4)\n                                               (ceiling  . 8)\n                                               (round    . 12)))\n                              (zerror \"Invalid caller of ZXFIX\" xform))))\n          (arg1 (cadr xform))\n          (carg1 (zilcocon arg1 nil))\n          (arg2? (cddr xform))\n          (arg2 (if arg2? (caddr xform) nil))\n          (carg2 (if arg2? (zilcocon arg2 nil)))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there is any possibility of multiple values being returned,\n  ;; do not optimize.  Return the form as is.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((possible-multiple-value-context-p)\n           xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there is only one argument, and it is a constant, perform the\n  ;; operation at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 (not arg2?))\n           (warn \"Evaluating at compile time\" xform)\n           (funcall function (car carg1)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there are two arguments, and they are both constant, perform\n  ;; the operation at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 carg2)\n          (warn \"Evaluating at compile time\" xform)\n          (funcall function (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there is exactly 1 argument, convert to call to ZILFIX.\n  ;;\n  ;; e.g. (TRUNCATE FOO) --> (ZILFIX FOO 0)\n  ;;      (FLOOR    FOO) --> (ZILFIX FOO 4)\n  ;;      (CEILING  FOO) --> (ZILFIX FOO 8)\n  ;;      (ROUND    FOO) --> (ZILFIX FOO 12)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((not arg2?)\n          `(zilfix ,arg1 ,zilfixnum))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXGCD2": {"ttr": 9995, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x13O\\x00\\x89\\x15o\\x11\\x19\\x00q\\x00s\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-05-13T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 113, "newlines": 115, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for GCD2.\n;\n\n(eval-when (eval)\n (deftrans gcd2 zxgcd2)\n)\n\n(defun zxgcd2 (xform xenv xcon &aux (l (length xform)))\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql l 3))\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the arguments are constant, perform the test at compile time.\n  ;;\n  ;; Note: If errors (like wrong argument type) occur, the compiler\n  ;;       transform mechanism will trap the error and suppress\n  ;;       the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 carg2)\n           (warn \"Performing compile-time GCD\" arg1 arg2)\n           (gcd (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Errors:\n  ;;\n  ;; (GCD2 not-an-integer x)\n  ;; (GCD2 x not-an-integer)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 (not (integerp (car carg1))))\n           (zerror \"Non-integer first argument to GCD\" xform))\n\n          ((and carg2 (not (integerp (car carg2))))\n           (zerror \"Non-integer second argument to GCD\" xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (GCD2 x 0)  --> (ABS x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg2 0)\n           `(abs ,arg1))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (GCD2 0 x)  --> (ABS x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg1 0)\n           `(abs ,arg2))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (GCD2 x 1)  --> (PROGN x 1)\n  ;; (GCD2 x -1) --> (PROGN x 1)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((or (eql arg2 1) (eql arg2 -1))\n           `(progn ,arg1 1))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (GCD2 1 x)  --> (PROGN x 1)\n  ;; (GCD2 -1 x) --> (PROGN x 1)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((or (eql arg1 1) (eql arg1 -1))\n           `(progn ,arg2 1))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXINTERN": {"ttr": 9997, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x1f\\x00\\x89\\x15o\\x11\\x19\\x001\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 49, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This is the compiler transformation function for INTERN.\n;;;\n;;; (DEFTRANS INTERN ZXINTERN)\n;;;\n\n(defun zxintern (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there is exactly 1 argument, convert to call to MKATOM.\n  ;;\n  ;; e.g. (INTERN FOO) --> (MKATOM FOO T NIL)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((eql (length xform) 2)\n   `(mkatom ,(cadr xform) t nil))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there are exactly 2 arguments, issue warning about the second\n  ;; argument being ignored and convert to call to MKATOM.\n  ;;\n  ;; e.g. (INTERN FOO 'LISP) --> (MKATOM FOO T NIL)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((eql (length xform) 3)\n   (warn \"Package argument to INTERN ignored in ZIL\" (caddr xform))\n   `(mkatom ,(cadr xform) t nil))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (t xform)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXLIST": {"ttr": 9999, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x19O\\x00\\x89\\x15o\\x11\\x19\\x00\\x1b\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-13T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 27, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;;\n;;; This is the compiler transform for the LIST function.\n;;;\n;;; (DEFTRANS LIST ZXLIST)\n;;;\n;;; Compare MXLIST, which used to expand the LIST \"macro\" but is now\n;;; used only for LIST*.\n;;;\n\n(defun zxlist (l ignore1 ignore2)\n (case (car l)\n  (list              (zxlist1 (cdr l)))\n  (t                 (zerror \"Unknown caller of ZXLIST\" (car l)))))\n\n(defun zxlist1 (l)\n (cond\n  ((null l) nil)\n  (t        `(cons ,(car l) ,(zxlist1 (cdr l))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXLOG": {"ttr": 10001, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x13/\\x00\\x89\\x15o\\x11\\x19\\x00M\\x00J\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-05-11T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 77, "newlines": 74, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for LOG.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 05/11/88 - Added constant-folding.                                  *\n;*                                                                     *\n;***********************************************************************\n;\n(defun zxlog (xform xenv xcon &aux (l (length xform))\n                                   (2argp (eql l 3)))\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be 1 or 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (or (eql l 2) (eql l 3)))\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform)) ; may be NIL if not 2argp\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (if 2argp (zilcocon arg2 nil)))\n         )\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the arguments are constant, perform the test at compile time.\n  ;;\n  ;; Note: If errors (like wrong argument type) occur, the compiler\n  ;;       transform mechanism will trap the error and suppress\n  ;;       the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 (or (not 2argp) carg2))\n           (warn \"Evaluating at compile time\" xform)\n           (eval xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there is exactly 1 argument, convert to call to ZIFLOG.\n  ;;\n  ;; e.g. (LOG FOO) --> (ZIFLOG FOO)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((not 2argp)\n          `(ziflog ,(cadr xform)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXMAP": {"ttr": 10003, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87\\x19O\\x00\\x89\\x15o\\x11\\x19\\x01s\\x00\\xfc\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-07-13T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 371, "newlines": 252, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform function for all of the\n; mapping functions in the compiled environment.\n;\n; Args: (1) the name of the mapping function.\n;       (2) the (headless) body of the mapping macro call.\n;\n; For example:\n;\n; (DEFTRANS MAPCAR ZXMAP)\n;\n; The mapping functions are transformed into open compiled code\n; because they take a function specification as an operand.\n;\n; This function replaces the old MXMAP mapping macro.\n;\n\n(defun zxmap (x ignore1 ignore2    ; Ignore environment and context\n  &aux ((mf . mb) x)               ; Macro name & body of macro call.\n       (f (map-macro-check mf mb)) ; Check args and get function name.\n       (l (cdr mb))                ; List of lists.\n       (g (do ((l l (cdr l))       ; List of GENSYM's for locals.\n               (z nil (cons (gensym) z)))\n              ((null l) z))))\n\n (case mf\n  (mapl              (zxmapl     f l g))\n  (mapc              (zxmapc     f l g))\n  (maplist           (zxmaplist  f l g))\n  (mapcar            (zxmapcar   f l g))\n  (mapand            (zxmapand   f l g))\n  (mapor             (zxmapor    f l g))\n  (mapcan            (zxmapcan   f l g))\n  (mapcon            (zxmapcon   f l g))\n  (every             (zxevery    f l g))\n  (notany            (zxnotany   f l g))\n  (notevery          (zxnotevery f l g))\n  (some              (zxsome     f l g))\n  (t                 (zerror \"Unknown caller of ZXMAP\" mf))))\n\n;;;\n;;; *** Helper functions ***\n;;;\n;;;\n;;; This function will flag specification errors on map functions.\n;;; It returns the function argument if it is a constant function,\n;;; (FUNCALL function-argument) otherwise.\n;;;\n\n(defun map-macro-check (mf mb)\n (prog (ff lam)\n  (unless (and mb (cdr mb))                ; Two or more args required.\n          (zerror \"Too few arguments\" mf))\n  (setq ff (car mb))  ; The function form.\n  (unless (and (consp ff)\n               (or (eq (car ff) 'quote)\n                   (eq (car ff) 'function)))\n          (return (list 'funcall ff)))\n\n  (and (or (atom (cdr ff))   ; (QUOTE), (QUOTE . FOO), etc.\n           (cddr ff))        ; (QUOTE A B), etc.\n       (zerror `(\"Invalid argument to \" ,mf) ff))\n\n  (setq lam (cadr ff))       ; (QUOTE something) or (FUNCTION something)\n  (or (atom lam)             ; ... verify the \"something\".\n      (eq (car lam) 'lambda)\n      (eq (car lam) 'label)\n      (zerror `(\"First arg of \" ,mf\n                \" not a function name or LAMBDA-expression\")\n              lam))\n\n  (or lam (zerror \"NIL is an invalid function name\" mf))\n  (return (list lam))\n )\n)\n\n(defun zxmap-init (g l v) ; Builds SETQ to set PROG list locals.\n                          ;\n                          ; (SETQ G1 L1 G2 L2 G3 L3)\n                          ;\n                          ; or\n                          ;\n                          ; (SETQ V L1 G1 V G2 L2 G3 L3)\n                          ;\n (do ((l l (cdr l))\n      (g g (cdr g))\n      (z nil))\n     ((null l) `(setq . ,(nreverse z)))\n     (if v\n      then\n          (push v z)\n          (push (car l) z)\n          (push (car g) z)\n          (push v z)\n          (setq v nil)\n      else\n          (push (car g) z)\n          (push (car l) z)\n      endif\n     )))\n\n(defun zxmap-incr (g)   ; Builds SETQ to CDR down all lists.\n                        ;\n                        ; (SETQ G1 (CDR G1)\n                        ;       G2 (CDR G2)\n                        ;       G3 (CDR G3))\n                        ;\n                        ;\n (do ((g g (cdr g))\n      (z nil))\n     ((null g) `(setq . ,(nreverse z)))\n     (push (car g) z)\n     (push `(cdr ,(car g)) z)))\n\n(defun zxmap-cars (g)   ;Builds list of CAR's of local list variables.\n                        ;\n                        ; ((CAR G1) (CAR G2) (CAR G3))\n                        ;\n (mapcar #'(lambda (x) `(zcar ,x)) g)\n)\n\n;\n;======================================================================\n;\n\n(defun zxmapl (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(prog (,v . ,g)\n         ,(zxmap-init g l v)\n    ,tag (cond ((and . ,g)\n                (,.f ,@g)\n                ,(zxmap-incr g)\n                (go ,tag)))\n         (return ,v))))\n\n(defun zxmapc (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(prog (,v . ,g)\n         ,(zxmap-init g l v)\n    ,tag (cond ((and . ,g)\n                (,.f ,@(zxmap-cars g))\n                ,(zxmap-incr g)\n                (go ,tag)))\n         (return ,v))))\n\n(defun zxmaplist (f l g)\n (let ((v (gensym)) (d (gensym)) (e (gensym)) (tag (gensym)))\n  `(prog (,v ,d ,e . ,g)\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (setq ,d (cons (,.f ,@g) nil))\n               (cond (,v (rplacd ,e ,d))\n                     (t  (setq ,v ,d)))\n               (setq ,e ,d)\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return ,v))))\n\n(defun zxmapcar (f l g)\n (let ((v (gensym)) (d (gensym)) (e (gensym)) (tag (gensym)))\n  `(prog (,v ,d ,e . ,g)\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (setq ,d (cons (,.f ,@(zxmap-cars g)) nil))\n               (cond (,v (rplacd ,e ,d))\n                     (t  (setq ,v ,d)))\n               (setq ,e ,d)\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return ,v))))\n\n\n(defun zxmapand (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(prog (,v . ,g)\n         (setq ,v t)\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (or (setq ,v (,.f ,@(zxmap-cars g))) (return ,v))\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return ,v))))\n\n;\n; MAPOR and SOME are identical, so use the same transformation.\n;\n(defmacro zxmapor (&rest args) `(zxsome . ,args))\n\n(defun zxmapcan (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(prog (,v . ,g)\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (setq ,v (nconc2 ,v (,.f ,@(zxmap-cars g))))\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return ,v))))\n\n(defun zxmapcon (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(prog (,v . ,g)\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (setq ,v (nconc2 ,v (,.f ,@g)))\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return ,v))))\n\n;=== SOME ===\n\n(defun zxsome (f l g)\n (case (length l)\n       (1 (zxsome-1 f l g))\n       (t (zxsome-m f l g))))\n\n(defun zxsome-1 (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(let ((,v ,(car l)))\n    (when ,v\n          (prog ()\n              ,tag\n                (return (or (,.f (zcar ,v))\n                            (when (setq ,v (cdr ,v))\n                                  (go ,tag)))))))))\n\n(defun zxsome-m (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(prog (,v . ,g)\n;;;;;;;; (setq ,v nil) ; V initialized to NIL by PROG\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (and (setq ,v (,.f ,@(zxmap-cars g))) (return ,v))\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return ,v))))\n\n;=== EVERY ===\n\n(defun zxevery (f l g)\n (case (length l)\n       (1 (zxevery-1 f l g))\n       (t (zxevery-m f l g))))\n\n(defun zxevery-1 (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(let ((,v ,(car l)))\n    (if ,v\n        (prog ()\n            ,tag\n              (when (,.f (zcar ,v))\n                    (when (setq ,v (cdr ,v))\n                          (go ,tag))\n                    (return t))\n              (return nil))\n        t))))\n\n(defun zxevery-m (f l g)\n (let ((tag (gensym)))\n  `(prog ,g\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (or (,.f ,@(zxmap-cars g)) (return nil))\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return t))))\n\n;=== NOTEVERY ===\n\n(defun zxnotevery (f l g)\n (case (length l)\n       (1 (zxnotevery-1 f l g))\n       (t (zxnotevery-m f l g))))\n\n(defun zxnotevery-1 (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(let ((,v ,(car l)))\n    (if ,v\n        (prog ()\n            ,tag\n              (when (,.f (zcar ,v))\n                    (when (setq ,v (cdr ,v))\n                          (go ,tag))\n                    (return nil))\n              (return t))\n        nil))))\n\n(defun zxnotevery-m (f l g)\n (let ((tag (gensym)))\n  `(prog ,g\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (or (,.f ,@(zxmap-cars g)) (return t))\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return nil))))\n\n;=== NOTANY ===\n\n(defun zxnotany (f l g)\n (case (length l)\n       (1 (zxnotany-1 f l g))\n       (t (zxnotany-m f l g))))\n\n(defun zxnotany-1 (f l g)\n (let ((v (gensym)) (tag (gensym)))\n  `(let ((,v ,(car l)))\n    (if ,v\n        (prog ()\n            ,tag\n              (unless (,.f (zcar ,v))\n                      (when (setq ,v (cdr ,v))\n                            (go ,tag))\n                      (return t))\n              (return nil))\n        t))))\n\n(defun zxnotany-m (f l g)\n (let ((tag (gensym)))\n  `(prog ,g\n         ,(zxmap-init g l nil)\n    ,tag (cond ((and . ,g)\n               (and (,.f ,@(zxmap-cars g)) (return nil))\n               ,(zxmap-incr g)\n               (go ,tag)))\n         (return t))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\n; *** This function is now obsolete. ***\n;\n; MXZMAP performs the macro expansion for mapping functions in the\n; COMPILED environment when the function being mapped is not constant.\n;\n; Args: (1) the name of the mapping function.\n;       (2) the (headless) body of the mapping macro call.\n;\n; For example:\n;\n; (MAPCAR FUNVAR X) is expanded via (MXZMAP '(MAPCAR FUNVAR X))\n;\n;\n;(defun mxzmap (xx)\n; (let (((f . x) xx))\n;      (cond\n;       ((null x)        (zerror \"Missing argument\" F))\n;       ((null (cdr x))  (zerror \"No lists specified\" F))\n;       (t               `(,(mapname f)\n;                          ,(car x)\n;                          (list . ,(cdr x))\n;                         )))))\n;\n;(defun mapname (mf)\n; (cond\n;  ((eq mf 'mapl     ) 'zmapl   )\n;  ((eq mf 'mapc     ) 'zmapc   )\n;  ((eq mf 'maplist  ) 'zmaplist)\n;  ((eq mf 'mapcar   ) 'zmapcar )\n;  ((eq mf 'mapand   ) 'zmapand )\n;  ((eq mf 'mapor    ) 'zmapor  )\n;  ((eq mf 'mapcan   ) 'zmapcan )\n;  ((eq mf 'mapcon   ) 'zmapcon )\n;  (t                  (zerror \"Unknown caller of MXZMAP\" mf))))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXMAPAT": {"ttr": 10006, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x19o\\x00\\x89\\x15o\\x11\\x19\\x00\\x18\\x00\\x15\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-07-15T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 24, "newlines": 21, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The compiler transform for MAPATOMS.\n;\n\n(defun zxmapat (form xenv xcon)\n (if (eql (length form) 2)\n     (let ((f (cadr form))\n           (g (gensym)))\n          `(dolist (,g (oblist) nil)\n                   ,(if (and (consp f)\n                             (eql (length f) 2)\n                             (or (eq (car f) 'quote)\n                                 (eq (car f) 'function)))\n                        `(,(cadr f) ,g)\n                        `(funcall ,f ,g))))\n     (zerror \"Wrong number of arguments to MAPATOMS\")))\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXMEMBER": {"ttr": 10241, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x88\\t_\\x00\\x89\\x15o\\x11\\x19\\x00\\xd9\\x00\\xa4\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1988-04-04T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 217, "newlines": 164, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform function for MEMBER.\n;\n; Currently, inline code is always generated (except in the\n; case of :TEST #'EQ, when a call to MEMQ is generated, which\n; compiles inline anyhow).\n;\n\n(eval-when (eval)\n (deftrans member zxmember)\n)\n\n(defmacro local-variable-p (x)       ; Please, x must be a symbol.\n `(and (symbolp ,x) (memq ,x xenv)))\n\n(defun zxmember (xform xenv xcon)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Note that there must be at least 2 arguments.  If there are fewer,\n  ;; no transformation is done.  However, if there are more, then GETK\n  ;; will signal an error for invalid keywords,\n  ;; and this will cause the transformation to fail, which in the\n  ;; compiler has the effect of suppressing the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n (cond\n  ((lessp (length xform) 3)\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (rest (cdddr xform))\n          (rest-length (length rest))\n          (test      (getk rest ':test))\n          (test-not  (getk rest ':test-not))\n          (key       (getk rest ':key))\n          (expected-length (+ (if test 2 0)\n                              (if test-not 2 0)\n                              (if key 2 0)))\n         )\n    (zxmember-optimize xform xenv xcon arg1 arg2\n                       rest-length expected-length\n                       (car test) (car test-not) (car key)\n                       test test-not key)))))\n\n(defun zxmember-optimize (xform xenv xcon arg1 arg2\n                                          rest-length expected-length\n                                          test test-not key\n                                          test? test-not? key?)\n (let (\n       (carg1  (zilcocon arg1 nil))\n       (carg2  (zilcocon arg2 nil))\n       (ctest     (if test?     (zxmember-confun test)))\n       (ctest-not (if test-not? (zxmember-confun test-not)))\n       (ckey      (if key?      (zxmember-confun key)))\n      )\n\n      (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the length of the &rest argument is such that more keys were\n  ;; specified than expected, then suppress the transformation.\n  ;;\n  ;; Checking for keys is done this way to allow for the possibility\n  ;; of non-constant key names, :allow-other-keys, etc.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((> rest-length expected-length)\n        (warn \"Nonstandard or unexpected keyword args to MEMBER\" xform)\n        xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If all arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((and carg1\n             carg2\n             (or (not test?) ctest)\n             (or (not test-not?) ctest-not)\n             (or (not key?) ckey)\n        )\n        (warn \"Evaluating MEMBER with constant args at compile time\"\n              xform)\n        `',(eval xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If :TEST is #'EQ or 'EQ, and no other keywords are specified,\n  ;; then transform the call to MEMQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((and test?\n             (not test-not?)\n             (not key?)\n             (eq (car ctest) 'eq))\n        `(memq ,arg1 ,arg2))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both :TEST and :TEST-NOT specified, error.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((and test? test-not?)\n        (zerror \"Both :TEST and :TEST-NOT keywords given to MEMBER\"\n                xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, transform the call to inline code.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n     (t\n      (let (\n            (loop  (gensym))\n            (true  (gensym))\n            (arglist    nil)\n            (lambdalist nil)\n            (item)\n            (list)\n            (ftest)\n            (fkey)\n            (comparison)\n           )\n       (cond\n        ((or carg1 (local-variable-p arg1))\n         (setq item arg1))\n        (t\n         (let ((g (gensym)))\n              (push arg1 arglist)\n              (push g lambdalist)\n              (setq item g))))\n       (let ((g (gensym)))\n            (push arg2 arglist)\n            (push g lambdalist)\n            (setq list g))\n       (cond\n        (ctest\n         (setq ftest ctest))\n        ((not test?)\n         (setq ftest '(eql)))\n        ((local-variable-p test)\n         (setq ftest `(funcall ,test)))\n        (t\n         (let ((g (gensym)))\n              (push test arglist)\n              (push g lambdalist)\n              (setq ftest `(funcall ,g)))))\n       (cond\n        (ctest-not\n         (setq ftest ctest-not))\n        ((and test-not? (local-variable-p test-not))\n         (setq ftest `(funcall ,test-not)))\n        (test-not?\n         (let ((g (gensym)))\n              (push test-not arglist)\n              (push g lambdalist)\n              (setq ftest `(funcall ,g)))))\n       (cond\n        (ckey\n         (setq fkey ckey))\n        ((not key?)\n         (setq fkey '(progn)))\n        ((local-variable-p key)\n         (setq fkey `(funcall ,key)))\n        (t\n         (let ((g (gensym)))\n              (push key arglist)\n              (push g lambdalist)\n              (setq fkey `(funcall ,g)))))\n\n       (setq comparison\n             (let ((x `(,@ftest ,item (,@fkey (zcar ,list)))))\n                  (if test-not? `(not ,x) x)))\n\n       `((lambda ,(nreverse lambdalist)\n                 (and ,list\n                      (prog ()\n                       ,loop\n                            (cond\n                             (,comparison\n                              (go ,true))\n                             ((setq ,list (cdr ,list))\n                              (go ,loop)))\n                       ,true\n                            (return ,list))))\n         ,.(nreverse arglist)))))))\n\n\n(defun zxmember-confun (x)\n (cond\n  ((and (consp x)\n        (consp (cdr x))\n        (null  (cddr x))\n        (memq (car x) '(function quote)))\n   (ncons (cadr x)))\n  (t\n   (zilcocon x nil))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXMEMQUA": {"ttr": 10244, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x10?\\x00\\x89\\x15o\\x11\\x19\\x00u\\x00r\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-04-12T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 117, "newlines": 114, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform function for MEMQUAL.\n;\n; Created 04/12/88.\n;\n; Useful in Macsyma and other Maclisp-compatibility-requiring\n; environments where MEMBER gets transformed to MEMQUAL in order\n; to use a #'EQUAL test.\n;\n; This is NOT a default ZIL transformation.  Code that wants to\n; use this for MEMBER must include the following:\n;\n; (eval-when (compile)\n;  (deftrans member  zxmemqua)\n;  (deftrans memqual zxmemqua) ; Not required - who codes MEMQUAL?!\n; )\n; (eval-when (load eval)\n;  (defload member memqual)\n; )\n;\n; Don't do (defload member memqual) at compile time, because\n; DEFLOAD and DEFTRANS don't get along with each other too well.\n;\n; Note that for interpretive use, MEMBER is just DEFLOADed to MEMQUAL.\n; Which we used to do in the compiler as well, until we made MEMBER\n; 100% Common Lisp and inline.\n;\n\n(eval-when (eval)\n (deftrans member zxmemqua)\n)\n\n(defun zxmemqua (xform xenv xcon)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, punt transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n (cond\n  ((not (eql (length xform) 3))\n   `(memqual . ,(cdr xform)))\n\n  (t\n   (let* ((arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 carg2)\n          (unless (listp (car carg2))\n                  (zerror \"Argument 2 to MEMBER not a list\" arg2))\n          (warn \"Evaluating MEMBER for 2 constant args at compile time\"\n                xform)\n (warn \"Since this is Maclisp-compatible, ZIL's MEMQUAL is being used.\")\n          `',(memqual (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If only the first argument is a constant, and it is a symbol,\n  ;; then use MEMQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 (symbolp (car carg1)))\n          (zxmemqua-to-memq xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If only the second argument is a constant, and it is a list of\n  ;; symbols, then use MEMQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg2\n               (do ((l (car carg2) (cdr l)))\n                   ((null l) t)\n                   (when (atom l)\n                         (warn \"Arg 2 to MEMBER is improper list\" arg2)\n                         (return nil))\n                   (unless (symbolp (car l))\n                           (return nil))))\n          (zxmemqua-to-memq xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, transform the call to a call to MEMQUAL.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       (t\n        `(memqual ,arg1 ,arg2)))))))\n\n(defun zxmemqua-to-memq (xform)\n (let ((ans `(memq . ,(cdr xform))))\n      (when (< (msglevel) 2)\n            (format t \"~&Warning: converting ~S to ~S~%\" xform ans))\n      ans))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXNCONC": {"ttr": 10246, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x19O\\x00\\x89\\x15o\\x11\\x19\\x00\\x17\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-07-13T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 23, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;;; This is the compiler transformation function for NCONC.\n;;;\n;;; (DEFTRANS NCONC ZXNCONC)\n;;;\n;;; This replaces the old MXNCONC \"macro\" expander.\n;;;\n\n(defun zxnconc (l ignore1 ignore2) (zxnconc1 (cdr l)))\n\n(defun zxnconc1 (l)\n (cond ((null l)        nil)\n       ((null (cdr l))  (car l))\n       ((null (cddr l)) `(nconc2 ,(car l) ,(cadr l)))\n       (t               `(nconc2 ,(car l) ,(zxnconc1 (cdr l))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXNTH": {"ttr": 10248, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x13\\x8f\\x00\\x89\\x15o\\x11\\x19\\x00b\\x00[\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-05-17T00:00:00", "modifydate": "1989-06-05T11:19:00", "lines": 98, "newlines": 91, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for NTH.\n;\n\n(eval-when (eval)\n (deftrans nth zxnth)\n)\n\n(eval-when ()\n #.(defvar *zxnth-threshold* 4\n    \"The maximum value for which to transform NTH to CAR.\")\n)\n\n(defun zxnth (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n ;\n ; Don't do this - we're not constant-folding list operations,\n ; because we're overly cautious about destructive operations.\n ;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;;\n ;;; If both arguments are constant, perform the test at compile time.\n ;;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;\n ;        ((and carg1 carg2)\n ;         (warn \"Evaluating at compile time\" xform)\n ;         `',(nth (car carg1) (car carg2)))\n ;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Errors:\n  ;;\n  ;; (NTH not-a-nonnegative-fixnum x)\n  ;; (NTH x not-a-list)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 (not (and (fixnump (car carg1))\n                                (not (minusp (car carg1))))))\n           (zerror \"Invalid first argument to NTH\" xform))\n\n          ((and carg2 (not (listp (car carg2))))\n           (zerror \"Invalid second argument to NTH\" xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (NTH 0 x) --> (CAR x)\n  ;; (NTH 1 x) --> (CADR x)\n  ;; (NTH 2 x) --> (CADDR x)\n  ;; etc.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 (<= (car carg1) #.*zxnth-threshold*))\n           (let ((f arg2))\n                (dotimes (i (car carg1))\n                         (setq f `(cdr ,f)))\n                `(car ,f)))\n\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXNTHCDR": {"ttr": 10250, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x13\\x8f\\x00\\x89\\x15o\\x11 \\x00p\\x00c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-05-17T00:00:00", "modifydate": "1989-06-05T11:20:00", "lines": 112, "newlines": 99, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for NTHCDR.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n\n(eval-when (eval)\n (deftrans nthcdr zxnthcdr)\n)\n\n(eval-when ()\n #.(defvar *zxnthcdr-threshold* 4\n    \"The maximum value for which to transform NTHCDR to CDR.\")\n)\n\n(defun zxnthcdr (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* (\n          (arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n ;\n ; Don't do this - we're not constant-folding list operations,\n ; because we're overly cautious about destructive operations.\n ;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;;\n ;;; If both arguments are constant, perform the test at compile time.\n ;;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;\n ;        ((and carg1 carg2)\n ;         (warn \"Evaluating at compile time\" xform)\n ;         `',(nthcdr (car carg1) (car carg2)))\n ;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Errors:\n  ;;\n  ;; (NTHCDR not-a-nonnegative-fixnum x)\n  ;; (NTHCDR x not-a-list)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 (not (and (fixnump (car carg1))\n                                (not (minusp (car carg1))))))\n           (zerror \"Invalid first argument to NTHCDR\" xform))\n\n          ((and carg2 (not (listp (car carg2))))\n           (zerror \"Invalid second argument to NTHCDR\" xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (NTHCDR 0 x) --> (VALUES x)\n  ;; (NTHCDR 1 x) --> (CDR x)\n  ;; (NTHCDR 2 x) --> (CDDR x)\n  ;; (NTHCDR 3 x) --> (CDDDR x)\n  ;; etc.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((eql arg1 0)\n           `(values ,arg2))\n\n          ((and carg1 (<= (car carg1) #.*zxnthcdr-threshold*))\n           (let ((f arg2))\n                (dotimes (i (car carg1))\n                         (setq f `(cdr ,f)))\n                f))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXOR": {"ttr": 10252, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\"_\\x00\\x89\\x15o\\x11 \\x00[\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-08-13T00:00:00", "modifydate": "1989-06-05T11:20:00", "lines": 91, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for OR.\n;\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 03/29/88 - Optimization from OR to COND in certain cases added to   *\n;*            improve code generation for weird things like MEMQ.      *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun zxor (xform xenv xcon)\n\n (prog (head tail body form formcon)\n  (setq head (car xform) tail (cdr xform))\n  ;;\n  ;; (OR) --> NIL\n  ;;\n  (when (null tail) (return nil))\n  ;;\n  ;; (OR x) --> x\n  ;;\n  (when (null (cdr tail)) (return (car tail)))\n  ;;\n  ;; If for effect only (context is null):\n  ;;\n  ;; (OR x y) --> (COND ((NOT x) y))\n  ;;\n  ;; This enables somewhat better code in certain situations, like\n  ;; when x is (MEMQ ...).\n  ;;\n  (when (and (null xcon) (null (cddr tail)))\n        (return `(cond ((not ,(car tail)) ,(cadr tail)))))\n\n  (setq body tail)\n\n loop\n\n  (setq form (car body))\n  (setq formcon (zilcocon form nil))\n\n  (cond\n   ;;\n   ;; form not a constant - no optimization this round\n   ;;\n   ((null formcon)\n    (go continue))\n   ;;\n   ;; constant form is last - no optimization to be done\n   ;;\n   ((null (cdr body))\n    (return xform))\n   ;;\n   ;; (OR <forms> 'TRUE <more_forms>) --> (OR <forms> 'TRUE)\n   ;;\n   ((not (null (car formcon)))\n    (warn `(\"OR forms not executed following constant \" ,(car formcon))\n      (cdr body))\n    (return (cons head (loop for oldform in tail\n                             collect oldform\n                             until (eq oldform form)))))\n   ;;\n   ;; (OR <forms> NIL <more_forms>) --> (OR <forms> <more-forms>)\n   ;;\n   (t\n    (return (cons head (remq form tail))))\n  )\n\n continue\n\n  (if (setq body (cdr body))     ; Next form\n      (go loop)\n      (return xform))            ; No more optimizations apply\n\n )\n)\n\n(eval-when (eval)\n (deftrans or zxor))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXPROGN": {"ttr": 10254, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x19_\\x00\\x89\\x15o\\x11 \\x00C\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1989-06-05T11:20:00", "lines": 67, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for PROGN.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Note:  Compiler transformation of both explicit and implicit PROGN  *\n;*        takes care of the following, which therefore need not be     *\n;*        handled in this function:                                    *\n;*                                                                     *\n;* (1) Removing all arguments of NIL from the form (note that any      *\n;*     atom, or form with an appropriate transform, gets converted     *\n;*     to NIL if it is being evaluated in a null context, i.e. for     *\n;*     effect only, and therefore is subject to being removed by       *\n;*     this operation).                                                *\n;*                                                                     *\n;* (2) PROGN-flattening, i.e. taking the arguments in a nested PROGN   *\n;*     and making them arguments to this (explicit or implicit)        *\n;*     PROGN so that they are subject to the same techniques.          *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun zxprogn (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there are no arguments, return the form NIL.\n  ;;\n  ;; i.e. (PROGN) --> NIL\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((null (cdr xform))\n   nil)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there is exactly one argument, return that argument without\n  ;; the PROGN wrapped around it.\n  ;;\n  ;; e.g. (PROGN FOO) --> FOO\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((null (cddr xform))\n   (cadr xform))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (t xform)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZXQUOTE": {"ttr": 10256, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x19_\\x00\\x89\\x15o\\x11 \\x00<\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-07-14T00:00:00", "modifydate": "1989-06-05T11:20:00", "lines": 60, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for QUOTE.\n;\n\n(defun zxquote (xform xenv xcon &aux arg)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 1 argument.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 2))\n   xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the context is null (evaluated for effect only),\n  ;; return NIL.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((null xcon)\n   nil)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the type of the argument is such that quoting is not necessary,\n  ;; return the argument without the QUOTE.\n  ;;\n  ;; e.g. (QUOTE T) --> T\n  ;;      (QUOTE 1) --> 1\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((or (null (setq arg (cadr xform)))\n       (eq arg t)\n;;;;;;;(and (symbolp arg)\n;;;;;;;;;;;;(eq (pbind arg) arg));;naah, don't strip quote off\n       (and (atom arg) (not (symbolp arg))))\n   arg)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (t xform)))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZXRELOP": {"ttr": 10258, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x1f\\x00\\x89\\x15o\\x11!\\x00S\\x00P\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-08T00:00:00", "modifydate": "1989-06-05T11:21:00", "lines": 83, "newlines": 80, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is a general-purpose compiler transform for relational operator\n; functions that take multiple arguments.  For example...\n;\n; (< 1 2 3 4) --> (AND (LESSP 1 2) (LESSP 2 3) (LESSP 3 4))\n;\n; There are 2 arguments:  (1) the function name\n;                         (2) the name of the primitive binary function\n;\n; If 1 arg is specified, the result is defined to be T.\n;\n; e.g. (deftrans < (x) (zxrelop x 'lessp))\n;\n\n(defun zxrelop (x func)\n (let (((funname . args) x))\n  (cond\n   ((null args)\n    (zerror \"Too few arguments\" funname))\n   ((null (cdr args))  `t)\n   ((null (cddr args)) `(,func . ,args))\n   (t (zxrelop-let args func)))))\n\n(defun zxrelop-let (args func)\n (let* (\n        (llist   (zxrelop-llist args))\n        (letlist (zxrelop-letlist llist))\n        (newargs (mapcar #'(lambda (x) (or (car x) (cadr x))) llist))\n       )\n\n;;; For example:\n;;;\n;;;  (ZXRELOP '(< A B (C) (D) E) 'LESSP)\n;;;\n;;; ARGS    = (A B C D E)\n;;; FUNC    = LESSP\n;;; LLIST   = ((NIL A) (NIL B) (G1 (C)) (G2 (D)) (NIL E))\n;;; LETLIST = (G1 G2)\n;;; NEWARGS = (A B G1 G2 E)\n;;;\n;;; which would result in the following expansion:\n;;;\n;;; (LET ((G1 (C))\n;;;       (G2 (D)))\n;;;      (AND (LESSP A B)\n;;;           (LESSP B G1)\n;;;           (LESSP G1 G2)\n;;;           (LESSP G2 E)))\n;;;\n\n `(let ,letlist\n       (and . ,(loop for subargs on newargs while (cdr subargs)\n                     collect\n                     `(,func ,(car subargs) ,(cadr subargs)))))))\n\n(defun zxrelop-llist (args)\n (loop for subargs on (cdr args) while (cdr subargs)\n       collect (zxrelop-varpair (car subargs)) into z\n       finally (return (nconc (list (zxrelop-varpair (car args)))\n                              z\n                              (list (zxrelop-varpair (car subargs)))\n                       ))))\n\n(defun zxrelop-letlist (llist)\n (loop for i in llist\n       when (car i) collect i))\n\n(defun zxrelop-varpair (form)\n (list\n       (if (or (atom form)\n               (eq (car form) 'quote))\n           nil\n           (gensym))\n       form))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXSEQOPT": {"ttr": 10260, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x11\\x8f\\x00\\x89\\x15o\\x11!\\x00\\x9a\\x00\\x97\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-04-27T00:00:00", "modifydate": "1989-06-05T11:21:00", "lines": 154, "newlines": 151, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; \"Sequence optimization\" or \"Sequential optimization\"\n; or \"SETQ optimization\"\n;\n;***********************************************************************\n;*                                                                     *\n;* Created 04/27/88.                                                   *\n;*                                                                     *\n;***********************************************************************\n;\n; This transformation function is invoked by ZILCOTRN when it is\n; processing a sequential block of forms, as in the special forms\n; PROGN, PROG, BLOCK, TAGBODY.\n;\n; Its purpose is to perform certain kinds of optimizations relating to\n; expressions that occur adjacent to each other.  In particular, it\n; tries to optimize things like\n;\n;   (SETQ A (FOO))\n;   (BAR A B)\n;\n; to\n;\n;   (BAR (SETQ A (FOO)) B)\n;\n; in order to avoid unnecessary reloading of variables from memory when\n; they're still in registers.\n;\n; The arguments are the same as the arguments to any \"normal\" compiler\n; transform function, plus an additional argument which is true if\n; the body contains GO tags; but the first argument is a list of\n; forms without a \"head\", since implicit PROGN's may also be passed\n; to this routine.  This function is expected to return a list of\n; \"headless\" forms (or the original first argument) in similar fashion.\n;\n\n(defun zxseqopt (xform xenv xcon tagp)\n\n  (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there are no SETQ's in the body, no transformations apply\n  ;; at this time.  Obviously this may change in the future, but we\n  ;; do this precheck now to avoid at least some unnecessary consing.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   ((null (assq 'setq xform))\n    xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise loop through the body, looking for pairs of forms that\n  ;; can be combined.  The combination takes the form of rebuilding\n  ;; the body with the newly combined form instead of the two originals.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   (t\n    (prog (boddy z)\n          (setq boddy xform)\n     loop\n          (cond\n           ((atom boddy)\n            (return (nreconc z boddy)))\n           ((atom (cdr boddy))\n            (push (car boddy) z))\n           ((valid-setq-p (car boddy))\n            (let ((x (maybe-subst-setq-for-var (car boddy)\n                                               (cadr boddy)\n                                               tagp)))\n                 (cond\n                  ((null x)\n                   (push (car boddy) z))\n                  (t\n                   (setq boddy (cons x (cddr boddy)))\n                   (go loop)))))\n           (t\n            (push (car boddy) z)))\n          (setq boddy (cdr boddy))\n          (go loop)))))\n\n(defun valid-setq-p (x &aux var)\n (and (consp x)\n      (eq (car x) 'setq)\n      (eql (length x) 3)\n      (symbolp (setq var (cadr x)))\n      (not (eq (pbind var) var))))\n\n(defun maybe-subst-setq-for-var (setqform form tagp)\n (let ((var (cadr setqform))\n       (flen)\n      )\n      (cond\n       ((atom form)\n        ;\n        ; (SETQ A foo) A  -->  (SETQ A foo)\n        ;\n        (if (and (not tagp) (eq form var)) setqform nil))\n       ((eql (setq flen (length form)) 1)\n        nil)\n       ((memq (car form) '(and or return catch arg setarg listify))\n        ;\n        ; (SETQ A foo) (AND A bar)      --> (AND (SETQ A foo) bar)\n        ; (SETQ A foo) (OR (baz A) bar) --> (OR (baz (SETQ A foo)) bar)\n        ;\n        (let ((x (maybe-subst-setq-for-var setqform (cadr form) nil)))\n             (if (null x)\n                 nil\n                 `(,(car form) ,x . ,(cddr form)))))\n       ((and (eq (car form) 'setq)\n             (> flen 2))\n        ;\n        ; (SETQ A foo) (SETQ B A)       --> (SETQ B (SETQ A foo))\n        ; (SETQ A foo) (SETQ B (baz A)) --> (SETQ B (baz (SETQ A foo)))\n        ;\n        (let ((x (maybe-subst-setq-for-var setqform (caddr form) nil)))\n             (if (null x)\n                 nil\n                 `(,(car form) ,(cadr form) ,x . ,(cadddr form)))))\n       ((and (eq (car form) 'cond)\n             (consp (cadr form)))\n        ;\n        ; (SETQ A foo) (COND (A bar))   --> (COND ((SETQ A foo) bar))\n        ;\n        (let ((x (maybe-subst-setq-for-var setqform (caadr form) nil)))\n             (if (null x)\n                 nil\n                 `(,(car form) (,x . ,(cdadr form)) . ,(cddr form)))))\n       ((valid-function-name-p (car form))\n        ;\n        ; (SETQ A foo) (baz A)        --> (baz (SETQ A foo))\n        ; (SETQ A foo) (baz (frob A)) --> (baz (frob (SETQ A foo)))\n        ;\n        (let ((x (maybe-subst-setq-for-var setqform (cadr form) nil)))\n             (if (null x)\n                 nil\n                 `(,(car form) ,x . ,(cddr form)))))\n       (t nil))))\n\n(defun valid-function-name-p (form)\n (if (consp form)\n     (memq (car form) '(lambda label))\n     (not (getl form '(|SPECIAL FORM| macro cmacro fexpr)))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXSETQ": {"ttr": 10262, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x11\\x8f\\x00\\x89\\x15o\\x11!\\x00^\\x00[\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-04-27T00:00:00", "modifydate": "1989-06-05T11:21:00", "lines": 94, "newlines": 91, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for SETQ.\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Created 04/27/88.                                                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n(eval-when (eval)\n (deftrans setq zxsetq)\n)\n\n(defun zxsetq (xform xenv xcon)\n (let* ((form (cdr xform))\n        (flen (length form))\n       )\n\n  (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there are no arguments, return the form NIL.\n  ;;\n  ;; i.e. (SETQ) --> NIL\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   ((zerop flen)\n    nil)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there is an odd number of arguments, don't attempt to transform.\n  ;; The compiler will flag the error.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   ((oddp flen)\n    form)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the (even) number of arguments is greater than 2, break the\n  ;; form up into two-argument SETQ's wrapped in a PROGN.\n  ;;\n  ;; This seemingly unnecessary transformation is designed to make it\n  ;; easier for PROGN-processing transformations to perform certain\n  ;; optimizations relating to SETQ's (the PROGN will be eliminated\n  ;; by other transformations).\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   ((> flen 2)\n    `(progn . ,(do ((form form (cddr form))\n                    (z nil (cons `(setq ,(car form) ,(cadr form)) z))\n                   )\n                   ((null form) (nreverse z)))))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If there are exactly 2 arguments, try some other possibilities.\n  ;;\n  ;; For example, if the variable name is a symbol, and the value\n  ;; is the same (EQ) symbol, suppress the assignment.  E.g.,\n  ;;\n  ;; (SETQ X X) --> X\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   ((and (symbolp (car form)) ; Must be a valid non-self-evaluating name\n         (not (eq (pbind (car form)) (car form)))\n         (eq (car form) (cadr form)))\n    (car form))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n   (t xform))))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZXSUB1": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x13/\\x00\\x89\\x15o\\x11!\\x00R\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-05-11T00:00:00", "modifydate": "1989-06-05T11:21:00", "lines": 82, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for SUB1 (1-).\n;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/20/88 - Support for multiple values.                             *\n;*                                                                     *\n;***********************************************************************\n;\n\n\n(eval-when (eval)\n (deftrans sub1   zxsub1)\n (deftrans 1-     zxsub1)\n)\n\n(defun zxsub1 (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 1 argument.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 2))\n   xform)\n\n  (t\n   (let* (\n          (arg (cadr xform))\n          (carg (zilcocon arg nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the argument is constant, perform the test at compile time.\n  ;;\n  ;; Note: If errors (like non-numeric arg) occur, the compiler\n  ;;       transform mechanism will trap the error and suppress\n  ;;       the transformation.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          (carg\n           (warn \"Performing compile-time SUB1\" xform)\n           (sub1 (car carg)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (SUB1 (ADD1 x)) --> (VALUES x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and (consp arg)\n                (eql (length arg) 2)\n                (memq (car arg) '(add1 1+)))\n           `(values ,(cadr arg)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXTYPEP": {"ttr": 10499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87 ?\\x00\\x89\\x15o\\x11!\\x00\\x92\\x00m\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-07-22T00:00:00", "modifydate": "1989-06-05T11:21:00", "lines": 146, "newlines": 109, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for TYPEP.\n;\n\n;;;\n;;; Note to Macsyma installers:  Do NOT use (TYPEP X 'INTEGER)!!!\n;;; (TYPEP X 'INTEGER) transforms to (INTEGERP X), which compiles\n;;; into a call to the Macsyma function INTEGERP.\n;;;\n\n;\n;***********************************************************************\n;*                                                                     *\n;* Change activity:                                                    *\n;*                                                                     *\n;* 06/21/88 - Support for transforming (TYPEP 'foo).                   *\n;*                                                                     *\n;***********************************************************************\n;\n\n(defun zxtypep (xform xenv xcon)\n (case (length xform)\n       (2  (zxtypep-1arg xform xenv xcon))  ; TYPEP with 1 argument\n       (3  (zxtypep-2arg xform xenv xcon))  ; TYPEP with 2 arguments\n       (t  xform)))\n\n(defun zxtypep-1arg (xform xenv xcon)\n (let* ((arg1 (cadr xform))\n        (carg1 (zilcocon arg1 nil))\n       )\n\n       (cond\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; If the argument is a constant, perform the test at compile time.\n;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        (carg1\n         (warn \"Evaluating TYPEP of one constant at compile time\"\n               (car carg1))\n         `',(typep (car carg1)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Otherwise, no transformations apply.  Return the original form.\n;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        (t xform))))\n\n\n(defun zxtypep-2arg (xform xenv xcon)\n\n (let* ((arg1 (cadr xform))\n        (arg2 (caddr xform))\n        (carg1 (zilcocon arg1 nil))\n        (carg2 (zilcocon arg2 nil))\n       )\n\n       (cond\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; If both arguments are constant, perform the test at compile time.\n;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       ((and carg1 carg2)\n        (warn \"Evaluating TYPEP of two constants at compile time\"\n              (car carg1) (car carg2))\n        (typep (car carg1) (car carg2)))  ; Always T or NIL.\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; If argument 2 is a constant, and argument 1 is not,\n;; then optimize the call.\n;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        ((and carg2 (not carg1))\n         (zxtypep-optimize arg1 (car carg2)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Otherwise, no transformations apply.  Return the original form.\n;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        (t xform))))\n\n(defun zxtypep-optimize (arg carg)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Optimize all the cases of (TYPEP <arg1> '<arg2>) where <arg2> is\n  ;; a known type that can be compiled inline efficiently.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n (case carg\n\n       ((atom)       `(atom    ,arg))\n       ((list)       `(listp    ,arg))\n       ((cons)       `(consp    ,arg))\n       ((symbol)     `(symbolp  ,arg))\n       ((fixnum)     `(fixnump  ,arg))\n       ((float\n         flonum)     `(floatp   ,arg))\n       ((\n         short-float\n         single-float\n        )            `(sfloatp  ,arg))\n       ((\n         double-float\n        )            `(dfloatp  ,arg))\n       ((bignum)     `(bigp     ,arg))\n       ((integer)    `(integerp ,arg))\n       ((string)     `(stringp  ,arg))\n       ((vector)     `(vectorp  ,arg))\n       ((compiled-function\n         code)       `(codep    ,arg))\n       ((subr)       `(subrp    ,arg))\n       ((closure)    `(closurep ,arg))\n       ((funarg)     `(funargp  ,arg))\n       ((struct\n         defstruct\n         structure)  `(structp  ,arg))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Reconstruct TYPEP call.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       (otherwise    `(typep ,arg ',carg))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXVALUES": {"ttr": 10501, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x17/\\x00\\x89\\x15o\\x11\"\\x00R\\x00O\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-20T00:00:00", "modifydate": "1989-06-05T11:22:00", "lines": 82, "newlines": 79, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for VALUES.\n;\n\n(eval-when (eval)\n (deftrans values zxvalues)\n)\n\n(defun zxvalues (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 1 argument.  If not, skip transform.\n  ;; Sure, we could transform calls to VALUES where there are\n  ;; more (or less) than 1 argument, but we won't bother, at\n  ;; least not this time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 2))\n   xform)\n\n  (t\n   (let* (\n          (arg (cadr xform))\n          (carg (zilcocon arg nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the argument is not in the form of a function that can\n  ;; potentially return multiple values, transform the call to\n  ;; an invocation of the arg itself, without VALUES.\n  ;;\n  ;; (VALUES X) --> X\n  ;; (VALUES \"foo\")  --> \"foo\"\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((or carg         ; Argument is a constant\n               (atom arg)   ; Argument is a variable\n               (memq (car arg)\n                     '(setq function subr tagbody multiple-value-list))\n               (and (eq (get (car arg) 'defined-by) 'system)\n                    (get (car arg) 'builtin)\n                    (get (car arg) 'inline)\n                    (neq (car arg) 'values)))\n\n           arg)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If the call is being evaluated in an environment which does\n  ;; not call for multiple values, transform the call to an\n  ;; invocation of the arg itself, without VALUES.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((not (memq (car xcon)\n                      '(:dummy :value :return :mvlist :mvbind)))\n           arg)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXZILEQ": {"ttr": 10503, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\"\\x9f\\x00\\x89\\x15o\\x11#\\x00_\\x00\\\\\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-08-17T00:00:00", "modifydate": "1989-06-05T11:23:00", "lines": 95, "newlines": 92, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for ZILEQUAL.\n;\n; Note: ZILEQUAL is the two-argument function underlying the = function.\n;\n\n(eval-when (eval)\n (deftrans zilequal zxzileq)\n)\n\n(defun zxzileq (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* ((arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If one of the arguments is a constant, and the other is not,\n  ;; then optimize the call.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         (cond\n          ((and carg1 (not carg2))\n           (zxzileq-optimize xform arg2 (car carg1)))\n\n          ((and carg2 (not carg1))\n           (zxzileq-optimize xform arg1 (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 carg2)\n          (warn \"Evaluating ZILEQUAL of two constants at compile time\"\n                (car carg1) (car carg2))\n          (zilequal (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          (t xform))))))\n\n(defun zxzileq-optimize (xform arg carg)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If one of the arguments is zero, convert to call to ZEROP.\n  ;;\n  ;; e.g. (ZILEQUAL X 0) --> (ZEROP X)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((and (numberp carg) (zerop carg))\n   `(zerop ,arg))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  (t\n   xform)))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXZILGT": {"ttr": 10505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\"\\x9f\\x00\\x89\\x15o\\x11#\\x00Q\\x00N\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-08-17T00:00:00", "modifydate": "1989-06-05T11:23:00", "lines": 81, "newlines": 78, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for GREATERP.\n;\n; Note: GREATERP is the two-argument function underlying the < function.\n;\n\n(eval-when (eval)\n (deftrans greaterp zxzilgt)\n)\n\n(defun zxzilgt (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* ((arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 carg2)\n           (warn \"Evaluating GREATERP of two constants at compile time\"\n                 (car carg1) (car carg2))\n           (greaterp (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (GREATERP x 0) --> (PLUSP x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg2\n               (numberp (car carg2))\n               (zerop (car carg2)))\n          `(plusp ,arg1))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (GREATERP 0 x) --> (MINUSP x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1\n               (numberp (car carg1))\n               (zerop (car carg1)))\n          `(minusp ,arg2))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXZILLT": {"ttr": 10507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\"\\x9f\\x00\\x89\\x15o\\x11#\\x00Q\\x00N\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-08-17T00:00:00", "modifydate": "1989-06-05T11:23:00", "lines": 81, "newlines": 78, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; This is the compiler transform for LESSP.\n;\n; Note: LESSP is the two-argument function underlying the < function.\n;\n\n(eval-when (eval)\n (deftrans lessp zxzillt)\n)\n\n(defun zxzillt (xform xenv xcon)\n\n (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* ((arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n          ((and carg1 carg2)\n           (warn \"Evaluating LESSP of two constants at compile time\"\n                 (car carg1) (car carg2))\n           (lessp (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (LESSP x 0) --> (MINUSP x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg2\n               (numberp (car carg2))\n               (zerop (car carg2)))\n          `(minusp ,arg1))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; (LESSP 0 x) --> (PLUSP x)\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1\n               (numberp (car carg1))\n               (zerop (car carg1)))\n          `(plusp ,arg2))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, no transformations apply.  Return the original form.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n           (t xform))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXZMSASS": {"ttr": 10509, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\t\\x0f\\x00\\x89\\x15o\\x11#\\x00d\\x00b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-03-30T00:00:00", "modifydate": "1989-06-05T11:23:00", "lines": 100, "newlines": 98, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The compiler transform for ASSQ, used in Macsyma.\n;\n; This hack makes ASSQ work for fixnums, but only when necessary.\n;\n; Note that for interpretive use, ASSQ is just DEFLOADed to ZMSASSQ.\n; Which we used to do in the compiler as well, until we made ASSQ\n; compile inline - which we're trying to take advantage of now.\n;\n\n(eval-when (eval)\n (deftrans assq zxzmsass)\n)\n\n(defun zxzmsass (xform xenv xcon)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n (cond\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* ((arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 carg2)\n          (warn \"Evaluating ASSQ for 2 constant args at compile time\"\n                xform)\n          (warn \"Since this is for Macsyma, ZMSASSQ is being used.\")\n          `',(zmsassq (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If only the first argument is a constant, and it is a symbol,\n  ;; then use ASSQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 (symbolp (car carg1)))\n          xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If only the second argument is a constant, and it is a list of\n  ;; items, each of which is either NIL or a CONS whose CAR is a\n  ;; symbol, then use ASSQ.\n  ;;\n  ;; Note: Invalid alists will be warned about by the compiler\n  ;;       itself, so don't worry your little head about them here.\n  ;;       Actually, you won't get warned because we'll be calling\n  ;;       ZMSASSQ instead, about which the compiler knows nothing...\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg2\n               (do ((l (car carg2) (cdr l)))\n                   ((null l) t)\n                   (when (atom l) (return nil))\n                   (unless (or (null (car l))\n                               (and (consp (car l))\n                                    (symbolp (caar l))))\n                           (return nil))))\n          xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, transform the call to a call to ZMSASSQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       (t\n        (let ((ans `(zmsassq ,arg1 ,arg2)))\n             (when (< (msglevel) 2)\n              (format t \"~&Warning: converting ~S to ~S~%\" xform ans))\n             ans)))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXZMSEQ": {"ttr": 10511, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x87\\x19\\x7f\\x00\\x89\\x15o\\x11#\\x00J\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1987-07-16T00:00:00", "modifydate": "1989-06-05T11:23:00", "lines": 74, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The compiler transform for EQ, used in Macsyma.\n;\n; This hack makes EQ work for fixnums, but only when necessary.\n;\n; The following is done during the macro loading phase of the compiler:\n;\n;(eval-when (compile eval)\n; (defvar *zil-eq-nohack* nil\n;         \"If NIL, EQ is converted to ZMSEQ where necessary to support\n;          EQness of fixnums.  If T, EQ stays EQ for efficiency.\"\n; )\n;)\n\n(declare (special *zil-eq-nohack*))\n\n(defun zxzmseq (form xenv xcon)\n (unless (eql (length form) 3)\n         (zerror \"Wrong number of arguments\" form))\n (let ((arg1 (second form))\n       (arg2 (third form)))\n      (cond\n       ;\n       ; (EQ (TYPEP X) 'FIXNUM) --> (TYPEP X 'FIXNUM)\n       ;\n       ((and (consp arg1)\n             (eql (length arg1) 2)\n             (eq (car arg1) 'typep)\n             (consp arg1)\n             (eq (car arg2) 'quote))\n        `(typep ,(cadr arg1) ,arg2))\n       ;\n       ;\n       ;\n       ((or *zil-eq-nohack*\n            (eq-arg-is-not-a-number arg1)\n            (eq-arg-is-not-a-number arg2)\n            (eq-ok-for-macsyma arg1 arg2))\n        form)\n       (t\n        (let ((ans `(zmseq ,arg1 ,arg2)))\n             (when (< (msglevel) 2)\n              (format t \"~&Warning: converting ~S to ~S~%\" form ans))\n             ans)))))\n\n(defun eq-arg-is-not-a-number (x)\n (cond\n  ((null x) t)\n  ((eq x t) t)\n  ((symbolp x)\n   (if (eq (pbind x) x) t nil))  ; Only if self-evaluating (keywords)\n  ((numberp x) nil)\n  ((atom x) t)\n  ((and (eq (car x) 'quote)\n        (listp (cdr x)))\n   (not (numberp (cadr x))))\n  (t nil)\n )\n)\n\n(defun eq-ok-for-macsyma (arg1 arg2 &key (flipargs t))\n (or (eq arg1 'munbound)\n     (and (symbolp arg1)\n          (equal arg2 `(symeval ,arg1)))\n     (and flipargs (eq-ok-for-macsyma arg2 arg1 :flipargs nil))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZXZMSMEM": {"ttr": 10513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\t\\x0f\\x00\\x89\\x15o\\x11#\\x00^\\x00\\\\\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-03-30T00:00:00", "modifydate": "1989-06-05T11:23:00", "lines": 94, "newlines": 92, "modlines": 0, "user": "SEB1525"}, "text": "\n;***********************************************************************\n;*                                                                     *\n;* ZIL (c) Copyright 1989 The Charles Stark Draper Laboratory Inc.     *\n;*         All rights reserved.                                        *\n;*                                                                     *\n;***********************************************************************\n\n;\n; The compiler transform for MEMQ, used in Macsyma.\n;\n; This hack makes MEMQ work for fixnums, but only when necessary.\n;\n; Note that for interpretive use, MEMQ is just DEFLOADed to ZMSMEMQ.\n; Which we used to do in the compiler as well, until we made MEMQ\n; compile inline - which we're trying to take advantage of now.\n;\n\n(eval-when (eval)\n (deftrans memq zxzmsmem)\n)\n\n(defun zxzmsmem (xform xenv xcon)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; There must be exactly 2 arguments.  If not, skip transform.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n (cond\n  ((not (eql (length xform) 3))\n   xform)\n\n  (t\n   (let* ((arg1 (cadr xform))\n          (arg2 (caddr xform))\n          (carg1 (zilcocon arg1 nil))\n          (carg2 (zilcocon arg2 nil))\n         )\n\n         (cond\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If both arguments are constant, perform the test at compile time.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 carg2)\n          (warn \"Evaluating MEMQ for 2 constant args at compile time\"\n                xform)\n          (warn \"Since this is for Macsyma, ZMSMEMQ is being used.\")\n          `',(zmsmemq (car carg1) (car carg2)))\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If only the first argument is a constant, and it is a symbol,\n  ;; then use MEMQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg1 (symbolp (car carg1)))\n          xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; If only the second argument is a constant, and it is a list of\n  ;; symbols, then use MEMQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n         ((and carg2\n               (do ((l (car carg2) (cdr l)))\n                   ((null l) t)\n                   (when (atom l)\n                         (warn \"Arg 2 to MEMQ is improper list\" arg2)\n                         (return nil))\n                   (unless (symbolp (car l))\n                           (return nil))))\n          xform)\n\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;;\n  ;; Otherwise, transform the call to a call to ZMSMEMQ.\n  ;;\n  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n       (t\n        (let ((ans `(zmsmemq ,arg1 ,arg2)))\n             (when (< (msglevel) 2)\n              (format t \"~&Warning: converting ~S to ~S~%\" xform ans))\n             ans)))))))\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT476/CBT.V500.FILE476.PDS/LISP.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT476/CBT.V500.FILE476.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}