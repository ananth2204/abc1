{"INMR01": {"INMLRECL": 80, "INMFNODE": "CSDLMVS", "INMFUID": "SEB1525", "INMTNODE": "MVS", "INMTUID": "CSDL", "INMFTIME": "20000926092905000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1704794, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 6233, "INMRECFM": "VB", "INMDIR": 103, "INMDSNAM": "PROGLIB.ZILCBT.TEXT", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1704794, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1704794, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"PROGLIB.ZILCBT.TEXT": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6233, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "000269", "DS1SCEXT": "b'\\x80\\x18Y'", "DS1SCALO": "b'P\\x00\\x002'", "DS1LSTAR": "b'\\x00#\\x0c'", "DS1TRBAL": "b'\\x94|'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x04\\x10\\x00\\x04\\xa9-p'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x04\\x10\\x00\\x04\\xa9-p'", "b'X\\xf3x\\xc0\\x00\\x00\\x01&\\x00\\x02\\x01(\\x00\\x07\\x00$'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$@INTRO": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x000\\x00\\x86\\x01O\\x01\\x00$\\x1f\\x162\\x00l\\x00n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1986-01-14T00:00:00", "modifydate": "2000-08-28T16:32:30", "lines": 108, "newlines": 110, "modlines": 0, "user": "SEB1525"}, "text": "************************************************************************\n***                                                  |               ***\n***  ZZZZZZZZZZZZZZZZZ    IIIII   LLLLL              |               ***\n***  ZZZZZZZZZZZZZZZZZ     III     LLL               |  L  I  S  P   ***\n***  Z            ZZZ      III     LLL               |               ***\n***              ZZZ       III     LLL               |               ***\n***             ZZZ        III     LLL               |      ON       ***\n***            ZZZ         III     LLL               |               ***\n***           ZZZ          III     LLL               |               ***\n***          ZZZ           III     LLL               |   M  V  S     ***\n***         ZZZ            III     LLL               |               ***\n***        ZZZ             III     LLL               |    _____      ***\n***       ZZZ              III     LLL               |   |   | \\     ***\n***      ZZZ               III     LLL               |   |  ___ \\    ***\n***     ZZZ                III     LLL               |   | /...\\ \\   ***\n***    ZZZ                 III     LLL               |   | |.o.| |   ***\n***   ZZZ                  III     LLL               |   |_|...|-|   ***\n***  ZZZ            Z      III     LLL            L  |   | \\___/ /   ***\n***  ZZZZZZZZZZZZZZZZ      III     LLLLLLLLLLLLLLLL  |   |   |  /    ***\n***  ZZZZZZZZZZZZZZZZ     IIIII   LLLLLLLLLLLLLLLLL  |   |_____/     ***\n***                                                  |               ***\n************************************************************************\n\n\n ZIL - LISP for MVS - Version 1.3\n Copyright (c) 1989 The Charles Stark Draper Laboratory Inc.\n All Rights Reserved\n\n\n ZIL LISP runs on IBM 370 series mainframe computers under the MVS\n operating system.  Although not yet totally a dialect of Common LISP,\n it attempts to be as compatible with Common LISP and Maclisp as\n possible.\n\n The ZIL compiler and interpreter are written and compiled in ZIL.\n\n CREDITS\n\n Zil is the creation of:\n\n  Steve \"Batchman\" Bacher <seb@draper.com> - the original conception,\n  the compiler, the interpreter, and the bulk of the runtime, including\n  the interfaces to TSO and ISPF and the Flavors object system.\n\n  Kjeld \"Sandy\" Hvatum <kjeld@ultranet.com> - the runtime code that\n  implements \"bignum\" arithmetic, symbol hashing and interning, the\n  vectorizing garbage collector (available only if you have the\n  370 Vector Facility), and thorough, exhaustive testing.\n\n Zil was developed at the Charles Stark Draper Laboratory (formerly the\n MIT Instrumentation Laboratory) in Cambridge, Massachusetts, starting\n in 1983.  Steve and Sandy have successfully ported a number of AI\n applications to it, notably OPS5 (an expert system builder) and\n DOE Macsyma (a symbolic algebra powerhouse).  In addition, some\n local applications were developed using Zil, including an expert\n system (under OPS5) to analyze and unload tapes on the mainframe.\n\n TUTORIAL INFORMATION\n\n This document is primarily a reference manual; it is not intended as an\n introduction to the LISP language.  One book that can be recommended as\n a good introductory text for the LISP user is:\n\n   LISP (Third Edition) - Winston and Horn\n\n This book gives a good introduction to the language, along with\n numerous AI-oriented programming examples.\n\n There are, inevitably, differences between the LISP described in a\n commercially available book and a particular implementation like ZIL;\n nevertheless, the basic concepts of the language are generally the\n same.  When in doubt, you should always refer to this document for\n the actual behavior of a function in ZIL.\n\n There is a documentation member for each LISP function.\n\n\n\n For additional information, see the following members of this document:\n\n $ARITH   - Comments pertaining to ZIL arithmetic functions in general.\n $ARRAY   - ZIL's Maclisp-compatible array facility.\n $ATTN    - Attention interrupt processing.\n $BIGNUM  - Information on bignums (arbitrary precision integers).\n $CALL    - How to call your compiled LISP program.\n $CODES   - ZIL error codes and their associated messages.\n $COMPILE - What the compiler is looking for.\n $DEFUN   - Description of how functions are defined.\n $EQUAL   - The various equality functions.\n $FILE    - Information on how files work in ZIL functions.\n $FLAVORS - ZIL's implementation of FLAVORS object-oriented programming.\n $FORMS   - Formats of atoms, lists, and objects that can be typed in.\n $FORTRAN - Explanation of when ZIL uses the FORTRAN run-time library.\n $HELP    - One-line summary of available functions.\n $INIT    - How to use an INIT file.\n $INT     - How to run the interpreter on TSO.\n $JCL     - How to run the compiler in batch.\n $LEXPR   - Explanation of Maclisp-style LEXPR's.\n $MAP     - Explanation of how ZIL handles mapping functions.\n $NEWS    - Latest news about ZIL.\n $PARM    - Execution-time parameter options.\n $PRINTER - Explanation of the ZIL printer interface.\n $PROP    - Property lists.\n $RMACRO  - Available reader macro characters.\n $SPECIAL - Globally defined special variables.\n $SPF     - Using the ISPF interface.\n $TRACE   - Using the function trace facility.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ARITH": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87$\\x7f\\x00\\x87%\\x8f\\x17%\\x000\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-04T00:00:00", "modifydate": "1987-09-15T17:25:00", "lines": 48, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\n The following comments pertain to ZIL arithmetic functions in general\n (i.e. +, -, etc.).\n\n Type coercion is as follows:\n\n     integer op integer            -->  integer\n     integer op single-float       -->  single-float\n     integer op double-float       -->  double-float\n     single-float op integer       -->  single-float\n     single-float op single-float  -->  single-float\n     single-float op double-float  -->  double-float\n     double-float op integer       -->  double-float\n     double-float op single-float  -->  double-float\n     double-float op double-float  -->  double-float\n\n Note that \"integers\" comprise fixnums and bignums, where the\n appropriate type of integer is generated depending on the\n magnitude.\n\n For functions that take more than 2 arguments, the binary operation\n is applied to the arguments in left-to-right order, following the\n coercion rules described above.\n\n For functions that take only one argument, the type of the result is\n the same as the type of the argument.  (Note that this is not true of\n the transcendental functions, for which an integer argument produces a\n double-float result.)\n\n In ZIL, the above coercion applies to division as it does to all\n other operations, meaning that dividing one integer by another\n will produce a (truncated) integer result.\n\n Errors will be signalled in the following circumstances:\n\n  Non-numeric arguments.\n\n  Integer (bignum) too large to convert to single-float or double-float\n  as appropriate.\n\n  Not enough vector/string space to build a bignum or double-float\n  result.\n\n Floating-point overflow is not detected by the code,\n and may result in a program check (0CC) abend.\n\n Floating-point underflow is ignored and may produce a zero result.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ARRAY": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00P\\x00\\x87&\\x0f\\x01\\x00#\\x1f\\x11\\x11\\x01\\x83\\x00\\x0b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "2000-08-18T11:11:50", "lines": 387, "newlines": 11, "modlines": 0, "user": "SEB1525"}, "text": "\n ZIL has a Maclisp-style array facility; it includes the *ARRAY, ARRAY,\n ARRAYP, STORE, ARRAYCALL, FILLARRAY, ARRAYDIMS and *REARRAY functions,\n as well as supporting the function-call syntax of array references.\n\n Arrays are not to be confused with vectors, which are native ZIL\n objects.  Vectors are always one-dimensional, and their elements are\n accessed via VREF and VSET.  Arrays may have any number of dimensions,\n and their elements must be accessed via the array functions documented\n herein.  Keep in mind, however, that vectors are far more efficient\n than arrays, at least in the current implementation of ZIL.  Arrays are\n present chiefly because Macsyma requires them.\n\n The array functions are autoloading, in that referencing one of\n them will cause them all to become defined under the interpreter.\n To compile code that uses any of these, however, you must include\n the following:\n\n (eval-when (compile)\n  (zlarray)\n )\n\n A complete discussion of these functions, as they are implemented in\n Maclisp, may be found in the following manual:\n\n  The Revised Maclisp Manual (Pitman) - MIT/LCS/TR-295\n\n  p. 140 & ff.\n\n Herewith, a summary of the ZIL implementation, scarfed copiously\n from the above manual at times.\n\n An array object is a structure of type ZIL-ARRAY which is created via\n the ARRAY macro or the *ARRAY function.  An array has a fixed number of\n dimensions, and an array access requires the same number of subscripts\n as the array has dimensions.  Omitted subscripts do not default; it is\n an error not to provide the correct number of subscripts for an array\n reference.  In the ZIL implementation, there is no theoretical limit on\n the number of dimensions an array may have; however, more than two\n dimensions is not recommended as far as performance goes.\n\n Maclisp supports four basic kinds of arrays - FIXNUM, FLONUM, T and NIL\n - but in ZIL these are all processed identically, except for the way\n the array data is initialized.  A FIXNUM array has all its elements\n initialized to 0 when it is created; a FLONUM array has all its\n elements initialized to 0.0 when it is created.  All other kinds of\n arrays have all their elements initialized to NIL when they are\n created.  Note that when an array is *REARRAYed, the new array type\n has no effect on how the array data is reinitialized.\n\n A \"named array\" is a symbol which has an ARRAY property, the value of\n which is an array object.  Named arrays can be thought of as functions\n of a fixed number of fixnum arguments, which are its subscripts.  The\n form (F X), which normally refers to a function F called on an argument\n X, can also be a reference to a named array F with the single subscript\n X.  This is effected in ZIL by defining a SUBR property for F which\n implements the array access (any existing function definition is saved\n and then restored when the array is \"un-defined\").\n\n Array indices are ZERO-BASED.\n\n You can reference an element of an array in the following ways:\n\n  (1) Like a function call:  (arrayname dim1 dim2 ...)\n      e.g. (F 5) gets the 5th element of array F, analogous to the\n      FORTRAN notation F(5)\n\n  (2) Using the ARRAYCALL function (actually a macro):\n      (ARRAYCALL T arrayobj dim1 dim2 ...)\n      This form is usually used with unnamed arrays, since you can't\n      use the other form.\n      (e.g. (ARRAYCALL T F 5)\n\n An array is also a function that can be applied to arguments; or you\n can apply a named array by name.  For example, if you have a named\n array defined by\n\n   (ARRAY FOO T 10 10)\n\n then you can get to element (2,2) of the array by any of the\n following means:\n\n   (FOO 2 2)\n   (ARRAYCALL T 'FOO 2 2)\n   (FUNCALL 'FOO 2 2)\n   (APPLY 'FOO '(2 2))\n\n The preferred way to access an array, however, is ARRAYCALL, which\n is the only one of the above that works (or is guaranteed to work)\n on unnamed arrays.\n\n\n The following functions and macros are available to process arrays:\n\n\n (ARRAY name1 type2 &rest dims)\n\n  where name1 and type2 are NOT evaluated, or\n\n (*ARRAY name1 type2 &rest dims)\n\n  where name1 and type2 ARE evaluated, are the functions used to\n  create both named and unnamed arrays.  Either one creates an\n  N-dimensional array (where N is the number of \"dims\") of the type\n  specified by type1 (which is generally T, FIXNUM or FLONUM).\n  If name1 is NIL, this creates an unnamed array object, which is\n  returned.  Otherwise, name1 must be a symbol which is to designate\n  a named array, in which case the newly created array object is made\n  the value of name1's ARRAY property, any existing function and array\n  definitions for name1 are saved, and name1 is returned as the value\n  of the form.\n\n  Each \"dim\" must be a positive integer specifying the length of the\n  corresponding dimension.  The indices used are zero-origined, so\n  the maximum index for a given dimension of length L is L-1.\n  The array elements are initialized to NIL, unless the array type\n  is FIXNUM (in which case they are initialized to 0) or FLONUM (in\n  which case they are initialized to 0.0).\n\n  The Maclisp array types OBARRAY and READTABLE are not supported by\n  ZIL, and will be treated as type T.\n\n\n (ZIL-ARRAY array1)\n\n  returns the array object associated with array1, which must be either\n  a symbol that names a named array, or an unnamed array, or the value\n  of the ARRAY property of another symbol.  If this object is not an\n  array, an error is signalled.  This function is used by most of the\n  other array functions to get hold of the actual array object that is\n  to be processed.\n\n\n (ARRAYP arg1)\n\n  returns T if arg1 is a Maclisp-style array, otherwise NIL.  arg1 can\n  be a symbol that names an array or an unnamed array.\n\n\n (ARRAYCALL type1 array1 &rest dims)\n\n  where type1 is NOT evaluated, or\n\n (*ARRAYCALL type1 array1 &rest dims)\n\n  where type1 IS evaluated, accesses an element of the array specified\n  by array1.  If the number of arguments following array1 is equal to\n  the number of dimensions of the array, this returns the corresponding\n  element of the array (unless all the dimension arguments are NIL, in\n  which case the entire vector of array elements is returned).  If the\n  number of arguments following array1 is one more than the number of\n  dimensions of the array, the last argument is a value to which the\n  corresponding element of the array is set, and that is also the\n  returned value.\n\n  As stated above, (foo dim1 dim2 ... {newvalue}) is equivalent to\n  (arraycall t 'foo dim1 dim2 ... {newvalue}).  Note that for named\n  arrays, the array1 argument must be quoted, or else it must be a\n  form that evaluates to the NAME of the named array.\n\n\n (STORE arrayref1 val2)\n\n  where arrayref1 is any form that can be used to access an element\n  of an array as described above, sets the corresponding element of\n  the array to val2.\n\n  SETF may also be used to store array values.\n  The following are equivalent:\n\n  (FOO 2 2 'BAR)\n  (STORE (FOO 2 2) 'BAR)\n  (SETF (FOO 2 2) 'BAR)\n  (ARRAYCALL T 'FOO 2 2 'BAR)\n  (*ARRAYCALL T 'FOO 2 2 'BAR)\n  (SETF (ARRAYCALL T 'FOO 2 2) 'BAR)\n  (SETF (*ARRAYCALL T 'FOO 2 2) 'BAR)\n\n  In fact, even the following is permitted:\n\n  (STORE (APPLY 'FOO '(2 2)) 'BAR)\n\n  That is a special case because it occurs in some Macsyma code.\n\n\n (*REARRAY name1 &optional type2 &rest dims)\n\n  is used to \"undefine\" an array, or change the type or dimensions of\n  an existing array.  In ZIL, name1 must be the name of a named array.\n\n  (*REARRAY name1) gets rid of the array associated with name1.  Any\n  previous function or array definition name1 had is restored.  name1 is\n  returned.\n\n  (*REARRAY name1 type2 dim3 ...) is like (*ARRAY name1 type2 dim3 ...)\n  except that the contents of the previously existing array named by\n  name1 are copied into a new array with the specified type and\n  dimensions, and this new array is made the array associated with\n  name1.  The array elements are copied as if a LISTARRAY followed by\n  a FILLARRAY had been done, without regard to the new array type.\n\n\n (FILLARRAY array1 arg2)\n\n  If arg2 is a list, this fills array1 (a named or unnamed array)\n  sequentially with successive elements of arg2, of whi excess\n  elements are ignored, and the LAST element of arg2 is used to fill\n  any remaining array slots.\n\n  If arg2 is another array, its successive elements are used to fill in\n  the array the same as if arg2 were a list, except that if arg2 is too\n  short, the remaining slots in array1 are unchanged.  Row-major order\n  is observed.\n\n  If arg2 is a ZIL vector, its successive elements are used to fill in\n  the array the same as if arg2 were a list, except that if arg2 is too\n  short, the remaining slots in array1 are unchanged.  Row-major order\n  is observed.\n\n  If arg2 is anything else, an error is signalled.\n\n  array1 is returned as the value.\n\n (LISTARRAY array1)\n\n  takes the elements of array1 and returns a list of those elements.\n  The length of the list is the size of the array (the product of its\n  dimensions) and the elements are present in the list in the same\n  order as they are stored in the array, starting with the 0th element.\n  Row-major order is observed.\n\n\n (ARRAYDIMS array1)\n\n  Returns a list whose CAR is the array type and the rest of whose\n  elements are the lengths of the dimensions of array1.\n\n\n (ARRAY-\\#-DIMS array1)\n\n  where the \\ is not part of the function name, but present because\n  that's how you have to type it, returns the number of dimensions\n  of array1.\n\n\n (ARRAY-DIMENSION-N num1 array2)\n\n  returns the length of dimension num1 of array array2.  num1 must be\n  an integer.  If num1 is greater than the number of dimensions,\n  NIL is returned.  If num1 is not positive, NIL is returned.\n\n\n (ARRAY-TYPE array1)\n\n  returns the type of array1.\n\nExamples:\n\n ; 1. Examples using named arrays.\n\n (ARRAY FOO T 2 3)          ==> FOO\n (ARRAYP 'FOO)              ==> T\n (ARRAYP (GET 'FOO 'ARRAY)) ==> T\n (ARRAYDIMS 'FOO)           ==> (T 2 3)\n (ARRAY-\\#-DIMS 'FOO)       ==> 2\n (ARRAY-DIMENSION-N 1 'FOO) ==> 2\n (ARRAY-DIMENSION-N 2 'FOO) ==> 3\n (ARRAY-DIMENSION-N 3 'FOO) ==> NIL\n (ARRAY-TYPE 'FOO)          ==> T\n (FOO NIL NIL)              ==> #(NIL NIL NIL NIL NIL NIL)\n (PROGN\n  (FILLARRAY 'FOO '(A B C))\n  (FOO NIL NIL))            ==> #(A B C C C C)\n (PROGN\n  (FILLARRAY 'FOO #(D E F))\n  (FOO NIL NIL))            ==> #(D E F C C C)\n (LISTARRAY 'FOO)           ==> (D E F C C C)\n (DOTIMES (I 2)\n  (DOTIMES (J 3)\n   (FOO I J (LIST I J))))   ==> NIL\n (FOO 1 2)                  ==> (1 2)\n (ARRAYCALL T 'FOO 1 2)     ==> (1 2)\n (FUNCALL 'FOO 1 2)         ==> (1 2)\n (APPLY 'FOO '(1 2))        ==> (1 2)\n\n\n (FOO 1 2 'B1)                        ==> B1\n (FOO 1 2)                            ==> B1\n (STORE (FOO 1 2) 'B2)                ==> B2\n (FOO 1 2)                            ==> B2\n (SETF (FOO 1 2) 'B3)                 ==> B3\n (FOO 1 2)                            ==> B3\n (ARRAYCALL T 'FOO 1 2 'B4)           ==> B4\n (FOO 1 2)                            ==> B4\n (*ARRAYCALL T 'FOO 1 2 'B5)          ==> B5\n (FOO 1 2)                            ==> B5\n (SETF (ARRAYCALL T 'FOO 1 2) 'B6)    ==> B6\n (FOO 1 2)                            ==> B6\n (SETF (*ARRAYCALL T 'FOO 1 2) 'B7)   ==> B7\n (FOO 1 2)                            ==> B7\n (STORE (APPLY 'FOO '(1 2)) 'B8)      ==> B8\n (FOO 1 2)                            ==> B8\n\n (*ARRAY 'BAR 'FIXNUM 10)    ==> BAR\n (ARRAYP 'BAR)               ==> T\n (ARRAYDIMS 'BAR)            ==> (FIXNUM 10)\n (ARRAY-\\#-DIMS 'BAR)        ==> 1\n (ARRAY-DIMENSION-N 1 'BAR)  ==> 10\n (ARRAY-DIMENSION-N 2 'BAR)  ==> NIL\n (ARRAY-DIMENSION-N 3 'BAR)  ==> NIL\n (ARRAY-TYPE 'BAR)           ==> FIXNUM\n (LISTARRAY 'BAR)            ==> (0 0 0 0 0 0 0 0 0 0)\n (FILLARRAY 'FOO 'BAR)       ==> FOO\n (LISTARRAY 'FOO)            ==> (0 0 0 0 0 0)\n (FILLARRAY 'FOO '(A B C D)) ==> FOO\n (LISTARRAY 'FOO)            ==> (A B C D D D)\n\n (*REARRAY 'FOO 'FIXNUM 10)  ==> FOO\n (ARRAYP 'FOO)               ==> T\n (ARRAYDIMS 'FOO)            ==> (FIXNUM 10)\n (ARRAY-\\#-DIMS 'FOO)        ==> 1\n (ARRAY-DIMENSION-N 1 'FOO)  ==> 10\n (ARRAY-DIMENSION-N 2 'FOO)  ==> NIL\n (ARRAY-DIMENSION-N 3 'FOO)  ==> NIL\n (ARRAY-TYPE 'FOO)           ==> FIXNUM\n (LISTARRAY 'FOO)            ==> (A B C D D D D D D D)\n (DOTIMES (I 10)\n   (FOO I (* I I)))          ==> NIL\n (LISTARRAY 'FOO)            ==> (0 1 4 9 16 25 36 49 64 81)\n (ARRAYCALL T 'FOO 3)        ==> 9\n\n\n ; 2. Examples using unnamed arrays.\n\n (PROGN\n  (SETQ A (ARRAY NIL T 2 3))\n  (ARRAYP A))               ==> T\n (ARRAYDIMS A)              ==> (T 2 3)\n (ARRAY-\\#-DIMS A)          ==> 2\n (ARRAY-DIMENSION-N 1 A)    ==> 2\n (ARRAY-DIMENSION-N 2 A)    ==> 3\n (ARRAY-DIMENSION-N 3 A)    ==> NIL\n (ARRAY-TYPE A)             ==> T\n (PROGN\n  (FILLARRAY A '(A B C))\n  (LISTARRAY A))            ==> (A B C C C C)\n (PROGN\n  (FILLARRAY A #(D E F))\n  (LISTARRAY A))            ==> (D E F C C C)\n (DOTIMES (I 2)\n  (DOTIMES (J 3)\n   (*ARRAYCALL 'T A I J (LIST I J))))   ==> NIL\n (ARRAYCALL T A 1 2)        ==> (1 2)\n\n (FUNCALL A 1 2)            ==> (1 2)\n (APPLY A '(1 2))           ==> (1 2)\n\n\n (ARRAYCALL T A 1 2 'V1)              ==> V1\n (ARRAYCALL T A 1 2)                  ==> V1\n (*ARRAYCALL T A 1 2 'V2)             ==> V2\n (ARRAYCALL T A 1 2)                  ==> V2\n (SETF (ARRAYCALL T A 1 2) 'V3)       ==> V3\n (ARRAYCALL T A 1 2)                  ==> V3\n (SETF (*ARRAYCALL T A 1 2) 'V4)      ==> V4\n (ARRAYCALL T A 1 2)                  ==> V4\n\n (STORE (APPLY A '(1 2)) 'V5)         ==> V5\n (ARRAYCALL T A 1 2)                  ==> V5\n\n (PROGN\n  (SETQ B (*ARRAY NIL 'FIXNUM 10))\n  (ARRAYP B))                ==> T\n (ARRAYDIMS B)               ==> (FIXNUM 10)\n (ARRAY-\\#-DIMS B)           ==> 1\n (ARRAY-DIMENSION-N 1 B)     ==> 10\n (ARRAY-DIMENSION-N 2 B)     ==> NIL\n (ARRAY-DIMENSION-N 3 B)     ==> NIL\n (ARRAY-TYPE B)              ==> FIXNUM\n (LISTARRAY B)               ==> (0 0 0 0 0 0 0 0 0 0)\n (PROGN\n  (FILLARRAY A B)\n  (LISTARRAY A))             ==> (0 0 0 0 0 0)\n (PROGN\n  (FILLARRAY A '(A B C D))\n  (LISTARRAY A))            ==> (A B C D D D)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ATTN": {"ttr": 537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x87$_\\x00\\x87(\\x0f\\x07C\\x00*\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-02T00:00:00", "modifydate": "1987-10-07T07:43:00", "lines": 42, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nThe following messages elicit responses from the ZIL user.\nAppropriate responses are documented along with the message.\n\nZIL0051 ATTENTION INTERRUPT: TYPE A(BORT), R(ESUME), T(IME), H(ELP).\n\nAn attention interrupt was detected as a result of pressing attention\n(PA1).  Responses:\n\n <enter>    -  Processing resumes as if no attention had occurred.\n <PA1>      -  The ZIL process is terminated, and control returns to\n               \"the system\".\n A + <enter> - The current function is aborted and control returns to\n               the \"top level\".  The identity of the \"top level\" is\n               dependent upon the environment; normally, under the\n               interpreter, this is the top level of the READ-EVAL-PRINT\n               loop.  This level is defined as the scope of a CATCH\n               frame using tag T.\n R + <enter> - Processing resumes as if no attention had occurred.\n T + <enter> - Time used so far is displayed via the TSO TIME command,\n               and the user is reprompted as above.\n H + <enter> - Information describing these options is displayed,\n               and the user is reprompted as above.\n anything else - The user is reprompted as above.\n\n\nZIL0052 NON-INTERRUPTIBLE PROCESS.  ABORTS WILL BE DEFERRED UNTIL PROCESS IS COMPLETE.\n\nAn attention interrupt was detected as a result of pressing attention\n(PA1); ZIL is currently in a section of code that cannot be safely\ninterrupted (e.g. the garbage collector or the loader).  Responses are\nthe same as above.  However, if an abort is requested, the abort is\ndeferred until the uninterruptible section of code is completed.  The\ndeferral may not be perceptible, since in most cases the uninterruptible\nwindow is short, but it is there.\n\nZIL0054 ATTENTION ABORT TO TOP LEVEL.\n\nAfter an A was typed in response to message ZIL0051, a THROW to tag T\nwas executed, causing execution to resume at whatever was defined as the\nLISP \"top level\", normally the READ-EVAL-PRINT loop.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$BIGNUM": {"ttr": 539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x05\\x7f\\x00\\x86\\x05\\x7f\\x11\\x00\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-26T00:00:00", "modifydate": "1986-02-26T11:00:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\n The ZIL internal structure of bignums is as follows:\n\n A bignum is an object in vector/string space which looks much like\n a string, except for the type indicator.  The body of the bignum is\n a series of fullwords, each of which contains a digit of the bignum\n in base 31 (31-bit radix).  These words are stored in reverse order,\n least significant word first.\n\n Negative bignums are stored using their absolute value, with the\n high-order bit of the leftmost word set to 1.  All other high-order\n bits (in positive and negative bignums) are zero.\n\n Bignums are always normalized: this means that (1) a bignum can never\n have a value between -2147483648 and 2147483647 inclusive, as this is\n always forced to be held as a fixnum; (2) the most significant\n (rightmost) word is never zero, since leading zero \"bigits\" are always\n removed; and (3) the minimum number of 31-bit \"bigits\" in a bignum is\n 2.  The combination (-2147483647 1) can never occur, since this would\n represent -2147483648, which must be a fixnum.\n\n For examples, see the documentation for the functions BIGLIST,\n BIGNUM and MKBIGNUM, which convert between bignums and lists of\n fixnums that make them up.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CALL": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x007\\x00\\x86\\x01O\\x01\\x00$/\\x15Y\\x00\\xd2\\x00\\xae\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1986-01-14T00:00:00", "modifydate": "2000-08-29T15:59:37", "lines": 210, "newlines": 174, "modlines": 0, "user": "SEB1525"}, "text": "\n========================================================================\n\n      Before you read this, read member $COMPILE to understand the\n      difference between a PROGRAM and a FUNCTION.  The following\n      discussion pertains to PROGRAMs only.  Note, however, that\n      the ZIL interpreter is a LISP PROGRAM, so the comments about\n      file I/O pertain within the interpreter as well.\n\n========================================================================\n\n A compiled LISP program can be invoked via the EXECPGM or CALL command\n under TSO, or via the // EXEC JCL statement in batch, as long as you\n have access to the following libraries:\n\n  '(your.library.name)' - wherever your LISP program resides.\n  'PROGLIB.ZIL.LOAD'    - contains ZIL execution-time routines, the\n           compiler and interpreter, and LISP functions for evaluation.\n\n On TSO, you may allocate these libraries via the ALLOCATE command:\n\n   ALLOC FI(ZILLIB) SHR REU DA(your.library.name 'PROGLIB.ZIL.LOAD')\n\n Then you can do one of the following:\n\n If you have the EXECPGM command (from file 183 of the SHARE CBT tape)\n on your system, you can do:\n\n   EXECPGM myzilprogram PARM('optional parm string') TASKLIB(ZILLIB)\n\n Otherwise, if you have TSO/E 2.5 or later, and you are in READY mode\n (i.e. not under ISPF), you can do:\n\n   TSOLIB ACT LIBRARY(ZILLIB)\n\n followed by\n\n   CALL *(myzilprogram) 'optional parm string'\n\n or\n\n   myzilprogram optional parm string\n\n since Zil programs are built to be invoked either as OS programs or\n TSO command processors.\n\n Otherwise, you can only invoke your program under ISPF, via CALL or an\n ISPEXEC SELECT dialog call (either PGM or CMD), and only if your\n library and 'PROGLIB.ZIL.LOAD' are available to it, either through\n being allocated to ISPLLIB or being the library in which the ZIL\n program resides.  Note that LIBDEF is not sufficient to allow this.\n\n In batch, you may include a //STEPLIB DD statement to define these\n libraries, as follows:\n\n   //        EXEC PGM=myzilprogram,PARM='optional parm string'\n   //STEPLIB DD DISP=SHR,DSN=userid.your.library.name\n   //        DD DISP=SHR,DSN=PROGLIB.ZIL.LOAD\n\n Note:  In all cases, the parameter string is optional and may be\n        omitted entirely.  See \"Passing a Parameter at Run Time\"\n        below for more information.\n\n You can use ISPF ZIL option 6 to invoke a LISP PROGRAM - the proper\n run-time environment will be set up automatically for you, with\n standard input and output allocated to the terminal.\n\n Don't try to invoke a compiled PROGRAM under the interpreter;\n that's strictly for FUNCTIONs and MODULEs only.\n\n\nRegion Size Requirements:\n\n When running on an MVS/XA system, ZIL uses virtual storage above the\n 16MB line for most data.  Load modules, however, reside below the 16MB\n line.  For most applications.  you should be able to run with a TSO\n region size of 6144K; running with a larger region size will not affect\n ZIL's memory usage, but will leave more room for ZIL to load its\n modules, reducing the likelihood of out-of-storage abends.\n\n If you are under ISPF, remember that split screen mode also uses a lot\n of storage (especially if the other screen is in EDIT).  A similar\n caveat applies to PIE/Sessions users who have many sessions active.\n\n\nPassing a Parameter at Run Time:\n\n\n You may pass a PARM string to your program; the GETPARM function will\n retrieve it and make a symbol out of it.  Note that if no PARM string\n is specified, GETPARM returns the null symbol (printed as ||).\n\n The parameter value may be passed as a JCL-style PARM string (in\n batch or via the CALL or EXECPGM command) or as TSO command operands.\n If it is passed in the latter fashion, any leading blanks, commas or\n comment sequences of the form /* ... */ are ignored.\n\n If the parameter string begins with a backslash character \"\\\", then\n special processing is done:  the portion of the parameter up to the\n second backslash character is ignored by GETPARM, and the information\n between the backslashes (if any) is processed at ZIL initialization\n time.  For an explanation of this information, see member $PARM of\n this documentation.\n\n\nFiles:\n\n\n You will need the following DD names if you run in batch:\n\n  ZILI - the standard input file.\n  ZILO - the standard output file.\n\n In foreground, these files are used if allocated; however, you do not\n need them, since if either one is missing, the TSO terminal is used\n as the input source or output destination.\n\n In addition, DDNAME ZILDRIBL is used as a \"dribble\" file; if this is\n allocated, ZIL will copy all terminal input and terminal output (with\n the exception of a few system messages) to this file.  If you are not\n using the terminal for input or output, dribbling will not take place.\n\n You need not pre-allocate other files you may need; you can use the\n OPEN function under ZIL to allocate input or output files.  However,\n files can be preallocated (they will be opened automatically by ZIL\n when an I/O function is executed against them) as follows:\n\n  Any DD name (file name) of the format ZILIxxxx will be accessible\n  to input functions (e.g. READ) that reference file \"xxxx\".\n\n  Furthermore, any DD name of the format ZILOyyyy will be accessible\n  to output functions (e.g. PRINT) that reference file \"yyyy\".\n\n On non-XA systems, it may be necessary to use this \"pre-allocation\"\n technique to insure the availability of sufficient virtual storage\n to open the files.\n\n Examples:\n\n You may enter the following TSO command:\n\n      alloc fi(zilifoo) da(foobar.data) shr reuse\n\n (Note: The \"REUSE\" keyword is available only if TSO/E is installed.)\n\n You can also enter it while you are under ZIL, as follows:\n\n      (tso \"alloc fi(zilifoo) da(foobar.data) shr reuse\")\n\n    This establishes an input file called FOO.  When you are in LISP,\n    the function call (READ 'FOO) will read an S-expression from the\n    dataset FOOBAR.DATA.\n\n You can also enter the following TSO command:\n\n      alloc fi(zilobar) da(foobar.data) old reuse\n\n    which you can also enter while you are under ZIL, as follows:\n\n      (tso \"alloc fi(zilobar) da(foobar.data) old reuse\")\n\n    This establishes an output file called BAR.  When you are in LISP,\n    the function call (PRINT 'HI 'BAR) will write the S-expression HI\n    into the dataset FOOBAR.DATA.\n\n These files will not be opened until they are referenced by function\n calls; therefore, you need not worry about clobbering an output file\n that is allocated to a ZILO... DD name but is never used.\n\n Alternatively, you may access files under ZIL.  Examples:\n\n     (setq a (open \"'abc1234.foobar.data'\" 'in)) ; returns a file name\n     (setq b (read a))\n     (close a 'in)\n\n     (setq x (open \"temp.data\" 'out)) ; New file may or may not exist.\n     (print 'foo x)\n     (close x 'out)\n\n The recommended way to do this is to use WITH-OPEN-FILE.\n For example:\n\n     (with-open-file (file \"'abc1234.foobar.data'\" 'in)\n      (loop until (eof file)\n            do (print (read file))))\n\n     (with-open-file (outf \"temp.data\" 'out)\n      (print *big-hairy-lisp-structure* outf))\n\n You can also load files of LISP source code into the interpreter:\n\n     (load \"'proglib.zil.source(init)'\")\n\n Both fixed-length and variable-length records are supported for input\n and output file I/O, but only fixed-length records are supported for\n standard input and output (ZILI and ZILO), as well as the dribble file.\n\n You can use the XZIFILE and XZOFILE CLIST's to allocate files.  The\n following commands are equivalent:\n\n XZIFILE FOO FOOBAR.DATA  <=>  ALLOC FI(ZILIFOO) DA(FOOBAR.DATA) SHR\n\n XZOFILE BAR FOOBAR.DATA  <=>  ALLOC FI(ZILOBAR) DA(FOOBAR.DATA) OLD\n\n Notes: The REUSE keyword is optional on both of the above.\n        XZOFILE will create the dataset as new if it does not exist.\n        The XZIFREE and XZOFREE CLIST's will free ZIL files similarly.\n\n These clists reside in 'PROGLIB.ZIL.CLIST'.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CHANGES": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x18\\x00\\x86\\x01O\\x01\\x00#\\x1f\\x148\\x01D\\x00\\x8e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1986-01-14T00:00:00", "modifydate": "2000-08-18T14:38:18", "lines": 324, "newlines": 142, "modlines": 0, "user": "SEB1525"}, "text": "************************************************************************\n*                                                                      *\n*                      ZIL 1.3 - CHANGES FROM 1.2                      *\n*                                                                      *\n************************************************************************\n\n========================================================================\n\n The most significant changes in this edition of ZIL are:\n\n * Full Lexical Scoping\n\n * Double Precision Floating-Point Arithmetic\n\n * Dropping of Support for LISP 1.5 Syntax\n\n * Across-the-board Performance Improvement of More than 10%\n\n========================================================================\n\nI.  NEW FEATURES OF ZIL 1.3\n\n LEXICAL SCOPING\n\n By far the most important change in ZIL 1.3 is FULL support of\n Common-LISP-style LEXICAL SCOPING.  This includes comprehensive\n handling of SPECIAL declarations in BOTH interpreted and compiled code.\n\n All ZIL code should be checked for variables that are not locally\n bound, and the appropriate declarations should be added.\n\n In particular, SPECIAL variables are NOT captured by lexical closures.\n This means that the behavior of some code will change if you do not\n declare your variables correctly!\n\n Furthermore...\n\n    ZIL 1.3 code is INCOMPATIBLE with ZIL 1.2 code because:\n\n    (a) Many miscellaneous changes have been made to the structure\n        of LISP objects and load modules.\n\n    (b) Many common functions have different definitions - this has\n        been done in cases where the ZIL 1.2 definition did not agree\n        with Maclisp or Common LISP.\n\n    (c) Some ZIL 1.2 functions have disappeared, been renamed, or\n        been replaced by new functions.\n\n    (d) All support for LISP 1.5 syntactic constructs has been DROPPED.\n\n    Your ZIL 1.2 LISP source code should run just as well interpretively\n    under ZIL 1.3 as long as it does not use the old LISP 1.5-style\n    syntax or have dependencies on the function definitions that work\n    differently now; most code will not run into a problem unless you\n    have been depending on features peculiar to ZIL.\n\n    However, ALL compiled code must be recompiled to run under the\n    new ZIL.\n\n    Some LISP objects may print out slightly differently.\n\n    If you need to run code under both versions of ZIL, you can use the\n    \"read conditionalization\" facility in your source.  Any form\n    preceded by #+ZIL13 (or #-ZIL12) will be read under ZIL 1.3 only;\n    any form preceded by #-ZIL13 (or #+ZIL12) will be read under ZIL 1.2\n    only.  Note, however, that this will NOT enable LISP 1.5 syntactic\n    constructs to be read; the ZIL 1.3 reader will not handle the $$\n    construct correctly EVEN if it is inside a #+ZIL12 or #-ZIL13.\n\n========================================================================\n\n DOUBLE PRECISION\n\n    ZIL 1.3 now has two kinds of floating-point numbers (\"flonums\"):\n    \"single-float\" and \"double-float\".  These correspond to the\n    single-precision and double-precision formats of the IBM/370\n    architecture.\n\n    Floating-point numbers read into ZIL 1.3 are DOUBLE-PRECISION\n    by default.  This means numbers with a decimal point and a\n    fractional part with no exponent marker, or numbers with an\n    exponent marker of \"E\" or \"D\".\n\n    Numbers with an exponent marker of \"S\" or \"F\" are read in as\n    single-precision flonums.\n\n    The ZIL 1.3 printer will print double-precision flonums without\n    exponent markers, or with a \"D\" exponent marker if the number\n    needs to be printed using scientific notation.  Single-precision\n    flonums will be printed with an \"F\" exponent marker.\n\n    Extended precision is not supported.\n\n    All transcendental functions now return double-precision results\n    when they are passed either integer or double-float arguments;\n    they will return single-precision values only when their arguments\n    are single-floats.\n\n    In arithmetic functions, conversion rules are as follows:\n\n     integer op single-float  -->  single-float\n     integer op double-float  -->  double-float\n     single-float op double-float  --> double-float\n\n    The FLOAT function takes an optional second argument, which is\n    a flonum of the type desired for the result.  If this argument\n    is omitted, FLOAT obeys the rules pertaining to transcendental\n    functions described above.\n\n    Single precision is less expensive than double precision, both\n    in CPU time and in memory usage.  However, double precision\n    tends to be more useful for many applications.  Note that some\n    improvements in accuracy may be observed in ZIL 1.3 single\n    precision operations as well.\n\n========================================================================\n\n READER CONTINUATION PROCESSING\n\n    The ZIL 1.3 reader and printer support a continuation character\n    feature:  an object which occupies more than one line will be\n    printed in pieces, with the ZIL continuation character (the cent\n    sign) in the final position of each line.  The reader, when it sees\n    the cent sign in the final position of a line, will process the\n    characters on the following line as part of the object currently\n    being read in, without any newlines.  (This does not apply to data\n    read in from the terminal, although the continuation characters may\n    appear when an object is printed out on the terminal.)\n\n    With this feature, it is possible to print long strings, bignums,\n    etc. out to a file and read them back in.\n\n    For fixed-length records, the cent sign will be treated as a\n    continuation character if it occupies the last data column.  For\n    example, a RECFM=FB LRECL=80 data set will recognize the cent sign\n    as a continuation character if it is in column 80 for unnumbered\n    data sets, or column 72 for numbered data sets.\n\n    For variable-length records, the cent sign will be treated as a\n    continuation character if it occupies the last column of any record,\n    even if it is not the maximum length.\n\n    The cent sign will NOT be treated as a continuation if it is\n    preceded by a backslash, or if it is part of a comment field or\n    otherwise not part of a Lisp object being read in.\n\n========================================================================\n\nII.  NO LONGER AVAILABLE IN ZIL 1.3\n\n    A. OBSOLETE FUNCTIONS DELETED\n\n       (Any of the below may or may not be available in the system.\n       Finding one of them still working is NOT to be interpreted\n       as an indication that you can get away with using it in\n       ZIL 1.3, as it can be removed AT ANY TIME.  Furthermore,\n       you will not get any sort of a warning that it is not\n       available; the ZIL system will treat the feature as any\n       other undefined function name would be treated.)\n\n       ALIST, CSET, and CSETQ are no longer defined in ZIL 1.3.\n       ALIST has been replaced by the new function SPECIAL-ALIST,\n       reflecting ZIL 1.3's support for Common LISP compatible\n       lexical scoping rules.\n\n       The \"%\" compile-time directive is obsolete.\n       Use (EVAL-WHEN (COMPILE) ...) instead.\n\n       The special significance of (DEFUN NIL ...) to the compiler\n       has been removed.  It is now an error to attempt to define\n       a function with a name of NIL.\n\n       TRACEALL:\n       The capability of being able to trace ALL ZIL function calls\n       has been removed, due to a completely new implementation of\n       the TRACE facility.  Since no other LISP implementations\n       (except the LISP 1.5 interpreter) have it, and it usually\n       is good for nothing except reams of unusable output,\n       the facility has been deleted.  In the future there should\n       be Common LISP compatible debugging facilities like EVALHOOK,\n       hopefully.\n\n    B. The following syntactic features have been REMOVED from\n       ZIL 1.3, and will cause incorrect output in the reader:\n\n       Support for the nnnB and nnnO syntaxes for binary and octal\n        integer constants (use #Bnnn and #Onnn)\n       Support for the \"$$\" delimited symbol (use |...| or backslash)\n\n    C. The following functions and facilities are still available\n       under ZIL 1.3, but are officially obsolete,\n       and will some day be removed:\n\n       DEFINE and DEFLIST (the LISP 1.5 functions)\n       ZCDR (retained for now, identical to CDR - both CDR and ZCDR\n        compile into 1-instruction sequences, so ZCDR is no longer\n        required, although ZCAR still is).\n\n    D. Symbols whose print names begin with a leading colon (known\n       as \"keywords\" in ZIL, although they are not \"keywords\" in the\n       Common Lisp sense) always evaluate to themselves.  As such,\n       they cannot be used in LAMBDA lists or be assigned values\n       via SETQ.\n\nIII. FUNCTIONS REDEFINED OR RENAMED\n\n    A. PRINT, PRINTC\n\n       Now equivalent to TERPRI followed by PRIN1/PRINC and a space,\n       not PRIN1/PRINC followed by TERPRI.\n\n       For better control over output, use of FORMAT is recommended.\n\n    B. LOAD\n\n       Now takes keyword arguments as documented in the Common Lisp\n       guide.  The old NOPRINT operand is not supported (although\n       it is still supported by READ-EVAL-PRINT).\n\n    C. TOSTRING\n\n       Formerly called MKSTRING or MAKE-STRING.  The latter names are\n       now undefined, due to conflicts with the Common Lisp\n       MAKE-STRING function.  When this name becomes reused, it will\n       be the Common Lisp definition that is used for it.\n\n    D. APPLY, OPEN, CLOSE, READCH more like maclisp\n       PEEKCH, TYI, TYIPEEK...\n\n\nIV. NEW FUNCTIONS and FORMS\n\n    SPECIAL-ALIST - replaces ALIST\n    TIME - allows you to measure the elapsed time of a given form\n    LOCALLY - allows you to associate declarations with a form\n\n    Many more will be added as time goes on.\n\n\nV.  UPWARD COMPATIBLE CHANGES TO OLD FUNCTIONS\n\n    See the individual descriptions for details.\n\nVI.  IMPROVED USABILITY FEATURES\n\n    B. The ED function, when specified with no arguments, puts you\n       into ISPF EDIT on the temporary dataset used to store\n       function definitions when you type (ED 'functionname).\n       Also, if ISPF services are not available, ED will tell you\n       gently but firmly why you can't use it.\n\n\nVII. RESTRICTIONS REMOVED\n\n    A. The ZIL 1.3 compiler never generates output that fails to\n       assemble due to addressability errors.  You no longer need to\n       include (DECLARE (BASEREG ...)) declarations when compiling long\n       modules (in fact, the compiler no longer processes this\n       declaration).  The compiler now determines the addressability\n       requirements of the code it is compiling and generates the\n       additional base registers itself.  No programmer action is\n       needed.\n\n       Note, however, that a function whose generated object code is\n       longer than 16K bytes still cannot be compiled (unless it is\n       segmented - see (DECLARE (SEGMENT ...))).\n\n    B. TSO commands that invoke ZIL programs can be invoked from\n       within other ZIL programs (via the TSO function).  ZIL\n       programs can also be invoked under other ZIL programs via\n       the INVOKE function.  This means running the compiler under\n       the interpreter, OPS5 under the compiler, etc.  The programs\n       remain completely separate and do not interact with each other,\n       as if they weren't even LISP programs.\n\n    C. New output files now get created with BLKSIZE=6160 rather\n       than 3120, owing to the virtual storage constraint relief\n       of having VSS above the line.  This will improve I/O\n       performance.\n\n\nVIII.  INTERNAL ENHANCEMENTS\n\n    A. The garbage collector can now collect objects defined in\n       compiled modules as inline objects.  This means that\n       in-line compiled lists will no longer cause lossage\n       (at least in theory) when a GC takes place.  This is still\n       NOT a recommendation to use such things!!!\n\n    B. Vector/string space is now allocated above the 16MB line.\n       As a result of this improvement, the default size of\n       vector/string space has been increased to 1 megabyte.\n\n    C. A \"small fixnum table\", containing the integers -1 through 255,\n       is built at initialization time.  Most references to fixnums\n       in this range, and many functions which return values in this\n       range, will now use pointers into this table rather than\n       consing up fresh fixnums.  This will reduce the frequency of\n       garbage collections and speed up some applications, particularly\n       those which process character objects.\n\n    D. The internal format of symbols has changed; symbol headers are\n       constructed in vector/string space rather than CONS space,\n       and contain cells which will be used for further enhancements\n       to ZIL.  Loading of compiled code has been optimized by\n       storing the symbol hash code in the load module to reduce the\n       instruction path length for internment of compiled symbols.\n\n    E. Many miscellaneous enhancements have been made to the compiler\n       to generate better code sequences for commonly used functions.\n       In general, performance is faster by 10% or more.  However,\n       individual garbage collections and function loads may take\n       slightly longer in some cases than before.  Yet for most\n       applications, the total time will be less, even including\n       loading and GC times.\n\n\nIX. MISCELLANEOUS CHANGES\n\n    A. ...\n\n     And lots more - just print off this help library and read it.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CHGS12": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x00\\x87\\x18?\\x01\\x00#\\x1f\\x15\\x04\\x01H\\x01H\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-07-02T00:00:00", "modifydate": "2000-08-18T15:04:11", "lines": 328, "newlines": 328, "modlines": 0, "user": "SEB1525"}, "text": "************************************************************************\n*                                                                      *\n*                      ZIL 1.2 - CHANGES FROM 1.1                      *\n*                                                                      *\n************************************************************************\n\n    ZIL 1.2 code is INCOMPATIBLE with ZIL 1.1 code because:\n\n    (a) A new, more efficient internal architecture is used for\n        symbols, fixnums and flonums.\n\n    (b) Many common functions have different definitions - this has\n        been done in cases where the ZIL 1.1 definition did not agree\n        with the typical usage and/or Common LISP.\n\n    (c) Some features of ZIL 1.1 have been dropped, most notably the\n        \"logical\" atom type.\n\n    Your ZIL 1.1 code should run just as well interpretively under ZIL\n    1.2 as long as it does not have dependencies on the function\n    definitions that work differently now; most code will not run into a\n    problem since such dependencies are usually negative (for example,\n    depending on fixnums NOT to succeed in a MEMBER test).  Also, since\n    values will print out differently, output may look somewhat\n    different; you may wish to recode your programs to use PRINC instead\n    of PRIN1/PRINT if this is not acceptable to you.\n\n    However, ALL compiled code must be recompiled to run under the\n    new ZIL.\n\n    If you need to run code under both versions of ZIL, you can use\n    the \"read conditionalization\" facility in your source.  Any\n    form preceded by #+ZIL12 will be read under ZIL 1.2 only; any\n    form preceded by #-ZIL12 will be read under ZIL 1.1 only.\n\nI.  NO LONGER AVAILABLE IN ZIL 1.2\n\n    A. \"LOGICAL\" DATA TYPE REMOVED - LOGP FUNCTION DOES NOT EXIST\n\n       Functions that formerly accessed and created \"logical\" atoms\n       now work on and return fixnums.  The nnnQ and nnnB syntaxes,\n       while still supported, now create fixnums.  In any case, the\n       Common LISP #Xnnn, #Bnnn and #Onnn syntaxes are preferred\n       for source-level compatibility (these also create integers).\n\n    B. CSETQ INVALID IN COMPILED CODE\n\n       The old \"global variable\" feature was never useful, and\n       limited ZIL's extensibility, so it has been removed.\n       CSETQ is still available under the interpreter, but its\n       use is definitely not recommended.  The Common LISP DEFVAR\n       special form is the preferred way to create global variables.\n\n    C. SPECIAL MEANINGS OF \"OBLIST\" AND \"ALIST\" SYMBOLS NOT\n       AVAILABLE (AT LEAST IN COMPILED CODE) - USE NEW FUNCTIONS\n       (OBLIST) AND (ALIST)\n\n       The lists returned by (OBLIST) and (ALIST) are identical to\n       what OBLIST and ALIST return, but it may not be feasible to\n       print them - use these function with extreme caution.\n\n    D. \"SLASHIFY\" OBSOLETE - USE \"MAKE-STRING\" WITH NEW 2ND ARG\n\n       Slashification is now built into the ZIL atom dumping and\n       printing routines.\n\n    E. \"PPATOM\" OBSOLETE - \"PRIN1\" NOW DOES THE JOB\n\n       PRIN1 now supports slashification, as above.\n\n    F. \"CLCAR\" AND \"CLCDR\" REMOVED, NO LONGER NEEDED\n\n       Since the CAR and CDR of NIL return NIL by default in ZIL 1.2,\n       these are not needed; furthermore, the compiler generates\n       more efficient code for CAR and CDR than for CLCAR and CLCDR.\n       If you need the old functionality (for whatever reason), use\n       the \"secret\" ZIL functions ZCAR and ZCDR, new in 1.2.\n\n    G. \"SETARGS\" REMOVED, USE \"DEFARGS\"\n\n       This function was meaningful under the compiler only, so now\n       there is a special form just for that purpose, which means\n       that you don't have to quote the arguments.\n\n    H. The following functions and facilities are still available\n       under the ZIL 1.2 interpreter but are officially obsolete,\n       and will some day be removed:\n\n       CSET and CSETQ (replaced by DEFVAR)\n       Constants OBLIST and ALIST (replaced by (OBLIST) and (ALIST))\n       % for compile-time directives (replaced by EVAL-WHEN)\n\n\nII. FUNCTIONS REDEFINED\n\n    A. PRIN1, PRINT NOW PRINT OUT IN \"READABLE-BACK-IN\" FORMAT.\n\n       Also, these functions, as well as PRINC, now return the\n       object they print, not NIL.\n\n    B. ASSOC, MEMBER, DELETE, REMOVE, INTERSECTION,\n       UNION, SUBLIS, SUBST, EQUAL NOW USE AN \"EQL\" TEST;\n       ASSQ, MEMQ, DELQ, REMQ, INTRQ, UNIONQ, SUBLISQ, SUBSTQ\n       USE AN \"EQ\" TEST\n\n       This default was chosen for Common LISP compatibility.\n       Since many other dialects of LISP use an EQUAL test for\n       these functions, however, a means has been provided to\n       switch to this other mode for ASSOC, DELETE, MEMBER and\n       REMOVE.\n\n    C. UNARY \"-\" AND \"/\" NOW PERFORM NEGATION AND RECIPROCATION\n\n       This was the screwiest incompatibility of all.\n\n    D. \"=\" IS NOW THE SAME AS EQUALP, NOT EQUAL\n\n       What's more, the functions =, < and > now take multiple\n       arguments.  So do <= and >=, for that matter, although\n       /= doesn't (too much of a pain to implement).\n\n    E. MAPC AND MAPL NOW RETURN FIRST INPUT LIST, NOT VALUE OF LAST\n       FUNCTION APPLICATION\n\n       This is not that important since these are usually executed\n       for effect.\n\n    F. EXPLODE TAKES ONLY 1 ARGUMENT, ALWAYS INTERNS SYMBOLS,\n       USES PRIN1 FORMAT; NEW FUNCTION \"EXPLODEC\" USES PRINC FORMAT\n\n       Just like the Maclisp one.  Also see IMPLODE.\n\n    G. GETPARM RETURNS NULL SYMBOL INSTEAD OF NIL WHEN NO PARM PRESENT\n\n       The only reason ZIL1.1 returned NIL in this case was that it\n       didn't support symbols with null print names.  Now that these\n       are legal, GETPARM works the way it was supposed to in the\n       first place.  By the way, it also works in \"command processor\"\n       environments.\n\n    H. IMPLODE TAKES FIRST CHARACTERS ONLY OF ARGS, ALWAYS INTERNS\n       SYMBOLS; NEW FUNCTION \"CONCATL\" CREATED FOR COMPATIBILITY WITH\n       OLD IMPLODE\n\n       Just like the Maclisp one.  Also see EXPLODE.\n       Some of the functions that replaced the old IMPLODE were\n       designed with Franz LISP semicompatibility in mind.\n\n    I. PP TAKES MULTIPLE UNEVALUATED ARGUMENTS, NOT AN EVALUATED\n       (QUOTED) SYMBOL PLUS OPTIONAL FILE NAME - USE ZILPP FOR THE\n       OLD BEHAVIOR\n\n       Debuggers should prefer this behavior.  Also, PP will print\n       out SETQ's of symbols that have values.  This makes it more\n       like the NIL version of PP.\n\n    J. TRACE AND UNTRACE TAKE MULTIPLE UNEVALUATED ARGUMENTS,\n       NOT AN EVALUATED (QUOTED) LIST\n       TRACE WITH NO OPERANDS RETURNS LIST OF TRACED FUNCTIONS -\n       USE NEW \"TRACEALL\" FUNCTION TO DO GLOBAL TRACING\n\n       That's how most LISPs do it.\n\n    In addition, functions that used to accept or return logical\n    atoms now accept or return fixnums in their place.\n\nIII. NEW DATA TYPES\n\n    Some of these data types were introduced during ZIL 1.1's reign,\n    but are given full support now.\n\n    A. STRINGS\n\n    B. VECTORS\n\n    D. FUNARGS (INTERPRETED LEXICAL CLOSURES)\n\n    There is an infinite precision integer (bignum) package under\n    development - it will be announced when it is ready.\n\nIV. NEW FUNCTIONS\n\n    See $HELP.  There are lots of these.\n\nV.  UPWARD COMPATIBLE CHANGES TO OLD FUNCTIONS\n\n    A. CAR,CDR - (CAR NIL) AND (CDR NIL) RETURN NIL\n\n    At long last!  Use ZCAR and ZCDR for the old, fast ones.\n    Note that CLCAR and CLCDR are dead.\n\n    B. CATCH - TAKES MULTIPLE FORMS (IMPLICIT PROGN)\n\n    We also have UNWIND-PROTECT now.\n\n    C. ERROR - TAKES &REST ARGS\n\n    Just throw them on - they'll all come out somewhere.\n\n    D. GETPARM - WORKS WHEN ZIL PROGRAM IS INVOKED AS A TSO\n                 COMMAND PROCESSOR\n\n    Like I told you above.\n\n    E. FIXP - TRUE FOR FIXNUMS AND BIGNUMS; USE NEW PREDICATES\n              \"BIGP\", \"FIXNUMP\", AND \"INTEGERP\" - THE LAST IS\n              EQUIVALENT TO FIXP\n\n    This won't matter much now, but wait until the full bignum\n    support is available.\n\n    F. MKSTRING - NEW OPTIONAL ARG SPECIFIES SLASHIFICATION\n\n    Also called MAKE-STRING.\n\n    G. MKVECTOR - NEW OPTIONAL ARG SPECIFIES INITIAL ELEMENT\n\n    Also called MAKE-VECTOR.\n\n    H. READ   - TAKES 2 OPTIONAL ARGS, SECOND IS EOF VALUE\n\n    Just like Franz LISP, etc.\n\n    I. RETURN - VALUE IS OPTIONAL, DEFAULTS TO NIL\n\n    Makes PROG-ramming easier.\n\n    J. TSO - TAKES ANY NUMBER OF STRINGS\n\n    Now you can build TSO commands out of anything you want\n    without worrying about exactly how to stick it all together.\n    TSO with no args currently does nothing, just smiles at you.\n\nVI.  IMPROVED USABILITY FEATURES\n\n    A. EXTENDED AUTOLOADING\n\n    The AUTOLOAD property of a symbol may be a string representing\n    a data set name to be loaded automatically, or a list which is\n    a form to be evaluated, in order to make the symbol become a\n    defined function.  This allows all sorts of creative\n    autoloading schemes to be implemented.\n\n    B. PRETTY-PRINTING, DRIBBLING, EDITING OF FUNCTION DEFINITIONS\n\n    Should make life under the interpreter a lot easier.\n    \"Dribbling\" just means having a hard copy of your entire ZIL\n    session (on file or SYSOUT), input and output included.\n\n    C. NEW SPECIAL VARIABLES: * ** *** - + ++ +++\n\n    Using these variables, you can recall the previous values\n    returned, typed in, etc.  Saves lots of typing.\n\nVII. RESTRICTIONS REMOVED\n\n    A. Symbol names may now be of any length; there is no maximum.\n       A null symbol name (read in as ||) is now permissible.\n       Strings are not limited to 32767 bytes; both strings and\n       symbol names are limited in size only by the available\n       amount of vector/string space to hold them.\n\n    B. With the advent of infinite precision arithmetic (bignums),\n       the traditional 2**31-1 limitation on fixed arithmetic is gone\n       for most operations.\n\nVIII.  INTERNAL ENHANCEMENTS\n\n    A. The internal format of symbols has changed; symbol print names\n       are now true strings rather than chains of CONSes.  Fixnums\n       and flonums are also more space-efficient, each taking one\n       CONS cell rather than two.  This has the following results:\n\n       1. Garbage collections are less frequent and faster.\n       2. Fixnum and flonum arithmetic is faster.\n\n       Because of these changes, less CONS space is required in a\n       typical ZIL session.  On the other hand, vector/string space\n       is used more heavily.  We plan to fine tune the allocation\n       of these respective spaces as time goes on, and the amount\n       of vector/string space is controllable at compile time for\n       a top-level ZIL program such as the interpreter.\n\n    B. Many ZIL routines that were originally written in LISP and\n       compiled have been rewritten in assembler and optimized for\n       speed.  In many cases this gave us breathing space to insert\n       additional validity checking; all the functions that access\n       property lists, for example, now signal an error if the format\n       of the property list is invalid.\n\n    C. The compiler has been changed to generate fewer relocatable\n       address constants in load modules; relocation of most pointers\n       is performed dynamically when a compiled ZIL function is first\n       executed.  This has the following benefits:\n\n       1. Compiled ZIL load modules take up less disk space, since\n          the RLD (relocation dictionary) records should be shorter\n          and fewer in number.\n\n       2. Loading of ZIL modules should take less time.\n\n       In addition, the process of interning symbols on the oblist\n       has been improved and should be faster.  This will also\n       reduce load time for ZIL functions.\n\nIX. MISCELLANEOUS CHANGES\n\n     A. CSETQ (\"global\") variables under the interpreter now maintain\n        their values on the property list via the VALUE indicator as\n        a CONS of the symbol name itself with the actual value; thus\n        the value is the CDR of the VALUE property, not the CAR.\n        This was done to be parallel with the binding entries on the\n        alist, for (future???) access from compiled code.\n\n     B. PUTPROP inserts new properties at the head of the property\n        list, not at the end as before.\n\n     C. SET and SETQ now automatically invoke DEFVAR, not CSET/CSETQ,\n        when an unbound variable is specified.\n\n     D. The ZIL compilation procedures now use the faster H assembler\n        instead of the F assembler.\n\n     E. It is no longer necessary to specify DCB information for file\n        ZILO when used (e.g. in batch).\n\n     And lots more - just print off this help library and read it.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CLIST": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00E\\x00\\x86\\x02/\\x01\\x00$/\\x16\\x01\\x00:\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-22T00:00:00", "modifydate": "2000-08-29T16:01:45", "lines": 58, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\n***********************************************************************\n*                                                                     *\n*        If you are hooked up to PROGLIB.ZIL.* in your TSO LOGON or   *\n*        ISPF allocations, all you need to do to use ZIL is invoke    *\n*        the XZIL clist (from inside or outside of ISPF) to get to    *\n*        the ZIL primary option menu.  From there you can invoke      *\n*        the interpreter, call a compiled LISP program, or do a       *\n*        foreground or background compile.                            *\n*                                                                     *\n***********************************************************************\n\nThe following CLIST's are available to all TSO users:\n\n       LISP      - invokes the ZIL interpreter directly.\n       LISPCOMP  - compiles a ZIL LISP source file.\n\nThe following CLIST's are available via PROGLIB:\n\n       XZIL      - invokes the ZIL ISPF interface.\n\n       XZIFILE   - allocates a ZIL input file.\n       XZOFILE   - allocates a ZIL output file.\n       XZIFREE   - frees a ZIL input file.\n       XZOFREE   - frees a ZIL output file.\n\n\n(The CLISTs that handle ZIL files are especially useful for users who\n don't remember the format of ZIL file names.  The special file name\n structure was necessitated by the need of ZIL in an non-XA system to\n determine how much storage to reserve for the operating system, since\n it allocated the rest as CONS space.  However, you do not need to use\n these to access files under ZIL, since the LOAD and OPEN functions can\n reference data sets directly.)\n\n\n To use ZIL, if you have the ZIL libraries allocated, just enter:\n\n  XZIL\n\n This places you in an ISPF-based full-screen dialog.  Option 3 runs the\n ZIL LISP interpreter; the rest should be self-explanatory.  A tutorial\n is contained as well.\n\n If you just want to run the interpreter with a minimum of fuss,\n the LISP CLIST is for you.  This starts up the ZIL interpreter\n without using ISPF; it can even be used on a line-mode terminal.\n\n Once you are in the interpreter, the LISP function (HELP) is\n available to assist you. (HELP FUNCTIONS) will display a list of\n available LISP functions.\n\n On TSO, if help is required, you may enter:\n\n  HELP LISP\n\n which should direct you to other sources of information as well.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CODES": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01A\\x00\\x19\\x00\\x86\\x02/\\x01\\x00#\\x1f\\x15\\x07\\x00\\xec\\x01\\x05\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.65", "flags": 0, "createdate": "1986-01-22T00:00:00", "modifydate": "2000-08-18T15:07:19", "lines": 236, "newlines": 261, "modlines": 0, "user": "SEB1525"}, "text": "\n\n *** EXECUTION-TIME ZIL ABENDS, ERRORS AND MESSAGES ***\n\n\nIf you get a system abend code, here are some probable causes:\n\n\n001,002 - I/O error.  Probably not disastrous; the most likely cause\n      is that you are attempting to read from a partitioned data set\n      (PDS) without specifying a member name.  002 is the code\n      associated with errors doing I/O to variable-length records.\n\n0C3 - disastrous error, either in the garbage collector or some other\n      routine with relatively new code in it that has a path needing\n      to be verified without the overhead of a whole new error code.\n      Such abends should be reported immediately, and a dump should\n      be obtained where possible.\n\n0C4 - some probable causes:\n      (a) An attempt was made to use the CAR or CDR of an atom in\n          compiled code, to access an element of a vector with an\n          invalid index, or access some part of an object when the\n          target was not of the correct type.  ZIL considers this an\n          error, but does not check for it in compiled code.\n      (b) A low-level ZIL function was passed an object of the wrong\n          type, but the function did no error checking because it was\n          coded for speed.\n      (c) One of the internal ZIL modules was erroneously called as\n          a function.\n\n013 - OPEN error.  Check that the file being referenced was properly\n      allocated.  A nonexistent member name may have been specified.\n\n213 - OPEN error.  A data set was allocated but did not really exist\n      (it may have been deleted by the TSO DELETE command without\n      having been freed).\n\n737 - file error.  A nonexistent member name may have been specified\n      in a concatenation.\n\n913 - file could not be accessed because it was protected by RACF/ACF2.\n\nB37 - out-of-space condition on an output file.  Check that your code\n      is not in a loop writing output.  You may have to recreate the\n      dataset outside of ZIL with a larger size.\n\nD37 - out-of-space condition on an output file - no secondary allocation\n      was specified.  See description of B37 above for more information.\n\nE37 - out-of-space condition writing to a PDS member.  See description\n      of B37 above for more information.\n\n80A, 106, 878, etc. -\n      A TSO command or other system function was unable to get enough\n      storage to execute.  This can happen if you are running a ZIL\n      application that loads many large compiled modules.  If you are\n      running under ISPF in split screen mode, try terminating the other\n      logical screen.  If you are using PIE/Sessions, try terminating\n      other active PIE sessions.  Otherwise, try restarting the ZIL\n      application with a lower value for CSSIZE or VSSIZE.  If this does\n      not help, try logging on with a larger region size, or increasing\n      the REGION parameter in your batch job.\n\n For messages below which result in errors, the code listed is returned\n as a user abend code, unless the program is intercepting errors (a\n CATCH with a tag of NIL will trap such errors).  Errors signalled by\n the ERROR function will cause the active LISP program to abend with a\n user abend code of zero if there is no error interception.\n\n Note: At the present time, there is no in-depth documentation for the\n       meanings of those messages which are not self-evident (there's no\n       explanation for self-evident messages either, of course).  This\n       should be provided some time in the future.  However, most such\n       errors will be easily recognized and all are recoverable, with\n       the exception of internal errors detected by the garbage\n       collector, which are always fatal.\n\n\n The severity flags are as follows:\n\n  0  -  Informational.\n  1  -  Warning.\n  2  -  Error.  These usually cause a THROW to tag NIL (signal error).\n  3  -  Severe. These are unusual but non-fatal conditions.\n  F  -  Fatal. These cause ZIL to be terminated.\n\n With the exception of fatal error messages, the display of these\n can be overridden by the appropriate (MSGLEVEL n) function call.\n\n-----------------------------------------------------------------------\nCode Flag  Associated Message\n-----------------------------------------------------------------------\n\n0001  F  NO STORAGE AVAILABLE FOR ZIL INITIALIZATION.\n0002  1  SYNTAX ERROR IN PARAMETER FIELD, INITIALIZATION PARAMETERS IGNORED.\n0003  F  ZIL ALREADY LOADED, RECURSIVE INVOCATION NOT ALLOWED.\n0004  F  STANDARD INPUT FILE NOT AVAILABLE, CANNOT BE OPENED.\n0005  F  STANDARD OUTPUT FILE NOT AVAILABLE, CANNOT BE OPENED.\n0006  0  FILE ____ OPEN FOR ______.\n0007  3  File ____ open failed.\n0008  2  File ____ does not exist (ddname ________ not allocated).\n0009  2  File name not a 1-4 character symbol.\n0010  2  OPEN: Invalid data set name.\n0011  2  OPEN: Undefined type.\n0012  2  OPEN: Allocation failed for ________.\n0013  2  OPEN: Syntax error in data set name / member name.\n0014  2  IKJEFF18 (DAIRFAIL) error - unable to display allocation failure message.\n0015  2  OPEN: Cannot process partitioned data set in APPEND mode.\n0016  2  OPEN: Member name specified but dataset not partitioned.\n0017  2  OPEN: A member name must be specified for data set ________.\n0018  2  OPEN: Specified member not found in data set ________.\n0019  2  OPEN: Unable to open data set to verify member name.\n0020  2  OPEN: Data set not sequential or partitioned, or is empty.\n0021  2  CLOSE: Undefined type.\n0022  2  CLOSE: File is not closable.\n0023  2  CLOSE: Not a currently open input/output file.\n0025  2  ISPF dialog services not available, cannot edit dataset.\n0026  2  Error detected by ISPF EDIT, could not edit dataset.\n0030  2  File ____ open failed, ABEND code ___, reason code ___.\n0031  2  File ____ is not usable.  Try closing it first.\n0032  2  Not enough memory available for file block.\n0040  2  SETABEND failed, bad return code from ESTAE.\n0041  2  ZIL ABEND AT ________ IN FUNCTION ________.\n0042  2  ABEND in ZIL at ________, system/user code ___, reason code ___.\n0043  2  FLOATING-POINT OVERFLOW EXCEPTION OCCURRED.\n0050  2  SETATTN failed, bad return code from STAX.\n0051  0  ATTENTION INTERRUPT: TYPE A(BORT), R(ESUME), T(IME), H(ELP).\n0052  0  NON-INTERRUPTIBLE PROCESS.  ABORTS WILL BE DEFERRED UNTIL PROCESS IS COMPLETE.\n0053  F  UNABLE TO PROCESS ATTENTION INTERRUPT, ZIL RB NOT FOUND ON RB CHAIN.\n0054  0  ATTENTION ABORT TO TOP LEVEL.\n0055  0  *** various informational messages for attention help ***\n0060  2  No storage available for FORTRAN interface.\n0061  2  FORTRAN interface initialization failed, module ZIFINIT could not be loaded.\n0070  F  INDIRECT SYMBOL POINTER NOT FORWARDED.\n0071  3  Not enough memory for inline compiled object pointer storage.\n1000  2  Control stack overflow.  Possible infinite recursion.\n1001  0  ________ NOT FOUND ON ZIL LOAD MODULE LIBRARY.\n1002  2  ________ NOT FOUND, FUNCTION REFERENCE NOT RESOLVED.\n1003  3  ________ LOAD FAILED, NOT ENOUGH SYSTEM STORAGE.\n1004  3  ________ LOAD FAILED, CHECK SYSTEM MESSAGES FOR REASON.\n1005  0  CANNOT LOAD FUNCTION, NAME LONGER THAN 8 CHARACTERS.\n1006  3  BLDL ERROR - INVALID TASK LIBRARY OR STEPLIB DD SPECIFICATION.\n1007  3  BLDL ERROR - NOT ENOUGH SYSTEM STORAGE.\n1008  3  BLDL ERROR - RETURN CODE 8, REASON CODE 8.\n1009  1  CANNOT LOAD FUNCTION, NAME NOT A STRING OR SYMBOL.\n1010  0  ________ LOADED AT ADDRESS ________.\n1011  2  No catch active for tag.\n1012  3  ________ LOAD FAILED, RMODE=ANY MODULE LOADED ABOVE 16 MB LINE.\n1013  3  ________ LOAD FAILED, NOT A VALID ZIL FUNCTION.\n1014  2  Unable to load compiled function ________.\n1015  2  Unable to load ZCREXEC, stream operations impossible.\n1016  2  Unable to load ZCPEXEC, stream operations impossible.\n1100  1  GARBAGE COLLECTION INVOKED BY ________.\n1101  2  GARBAGE COLLECTION FAILED. NO MORE CONS CELLS AVAILABLE.\n1102  1  GARBAGE COLLECTION DONE, ______ CONS CELLS FREE, _____ VSS BYTES FREE.\n1103  0  REGISTER 0 NOT SET ON ENTRY TO CONS FOR GARBAGE COLLECTION.\n1104  F  SEVERE ERROR, GARBAGE COLLECTION CANNOT CONTINUE.\n1105  F  OBJECT ON OBLIST NOT A SYMBOL, GARBAGE COLLECTION TERMINATED.\n1106  F  IMPROPER OBJECT ON ALIST, GARBAGE COLLECTION TERMINATED.\n1107  F  INVALID OBJECT IN VECTOR/STRING SPACE, GARBAGE COLLECTION TERMINATED.\n1108  F  SYMBOL PRINT NAME IS NOT A STRING, GARBAGE COLLECTION TERMINATED.\n1109  F  NOT ENOUGH MEMORY FOR VECTOR SWEEP WORK AREA, GARBAGE COLLECTION TERMINATED.\n1110  F  NON-FORWARDED SYMBOL IN OBLIST HASH ARRAY,GARBAGE COLLECTION TERMINATED.\n1200  2  Call to unresolved compiled function.\n1300  2  Unbound variable ________ in compiled function ________.\n1301  2  Too few arguments passed to function ________.\n1302  2  Too many arguments passed to function ________.\n1303  2  Attempt to execute invalid ZIL function ________.\n1304  2  Undefined keyword ________ passed to function ________.\n1305  2  Invalid keyword list passed to function ________.\n1401  2  Too few arguments passed by FUNCALL to ________.\n1402  2  Too many arguments passed by FUNCALL to ________.\n1403  2  Attempt to FUNCALL invalid ZIL function ________.\n1500  2  ________ ABENDED, COMPLETION CODE ________.\n1501  2  PROGRAM ________ NOT FOUND ON SYSTEM LIBRARY.\n1502  2  ATTACH OF PROGRAM ________ FAILED.\n1503  2  DETACH OF PROGRAM ________ FAILED.\n1600  *  BACK TRACE OF PUSH DOWN STACK FOLLOWS.\n1601  *  END OF ZIL STACK TRACE.\n2001  2  Syntax error reading file.\n2002  2  Missing right paren(s) at end of file.\n2003  2  Read after end of file.\n2004  2  Extraneous data in dotted pair.\n2005  2  Missing closing delimiter at end of file.\n2006  2  End of file encountered.\n2007  1  Not enough memory to build symbol name from list.\n2008  2  No character following symbol delimiter.\n2009  2  Syntax error in dotted pair.\n2018  2  Internal error in reader macro processing.\n2019  2  No character following escape character.\n2020  2  Unmatched right parenthesis \")\".\n2021  2  Period \".\" not in dotted pair.\n2022  2  Not enough vector/string space to build string.\n2023  2  String too long, string not built.\n2025  2  No string space available to create GENSYM.\n2030  2  Invalid reader macro character.\n2031  1  Non-null argument 1 to TYIPEEK ignored by ZIL.\n2049  2  NOT ENOUGH MEMORY TO EXPAND TABS OR NEWLINES.\n2050  2  Invalid ZILVSS request for ____ bytes of vector/string space.\n2051  2  Object to be concatenated by ZILVSS is not a string.\n2100  2  No vector/string space available, symbol not built.\n2120  2  TSO: Command exceeds maximum length of 32763.\n2121  2  TSO: Command feature not available, TSO is not active.\n2122  2  TSO: Cannot convert argument to string.\n2123  2  TSO: Not enough memory to build TSO command.\n2124  2  TSO: Requested command was abnormally terminated.\n2125  2  TSO: Requested command terminated due to attention.\n2133  2  No vector/string space available for FUNARG.\n2200  2  ZILADMP: OBJECT TO BE DUMPED IS A LIST, NOT AN ATOM.\n2201  2  ZILADMP: OBJECT TO BE DUMPED IS A VECTOR.\n2202  1  ZILADMP: NOT ENOUGH MEMORY TO DUMP BIGNUM.\n2203  1  ZILADMP: BIGNUM LENGTH LESS THAN 2 WORDS.\n2204  1  ZILADMP: SEVERE LOSSAGE IN 2-WORD BIGNUM CODE.\n2205  1  ZILADMP: A WORD OTHER THAN THE LEAST SIGNIFICANT WORD OF A BIGNUM IS NEGATIVE.\n2206  1  ZILADMP: THE MOST SIGNIFICANT WORD OF A BIGNUM IS ZERO (I.E. NOT NORMALIZED).\n2207  1  ZILADMP: OBJECT TO BE DUMPED IS A FUNARG (LEXICAL CLOSURE).\n2208  1  ZILADMP: NOT ENOUGH MEMORY TO DUMP STRING TEXT.\n2209  1  ZILADMP: THE MOST NEGATIVE FIXNUM, -2**31, WAS REPRESENTED AS A BIGNUM - SERIOUS BUG, PLEASE REPORT.\n2210  1  ZILADMP: BIGNUM LENGTH NOT A MULTIPLE OF 4.\n2211  1  ZILADMP: INTERNAL ERROR FORMATTING FLONUM.\n2300  2  No vector/string space available to intern symbol.\n2301  2  Internal error, cannot handle oblist hash table size of _____.\n2302  2  More than 50,000 interned symbols.  New symbol not interned, oblist hash table limit reached.\n3101  2  No vector/string space available for bignum.\n3102  2  ZILDIV: Not enough memory to perform trial division.\n4001  0  Warning: {miscellaneous warning message}\n4002  0  Error: {miscellaneous error message}\n4010  2  Not enough vector/string space to build object.\n4011  2  Invalid property list detected.\n4012  2  Improper keyword list specified.\n4100  2  Conversion of bignum to float not supported.\n4101  2  Float-to-bignum compare not supported.\n4102  2  Floating-point overflow converting bignum to float.\n4103  2  No vector/string space available to build double-float.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$COMPILE": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x86\\x02/\\x00\\x88\\x02\\x9f\\x08B\\x00\\xfd\\x00\\xc2\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1986-01-22T00:00:00", "modifydate": "1988-01-29T08:42:00", "lines": 253, "newlines": 194, "modlines": 0, "user": "SEB1525"}, "text": "\nThree kinds of sources can be compiled: FUNCTIONS, PROGRAMS and MODULES.\n\nIn JCL to run the compiler, PROG=F specifies a FUNCTION;\nPROG=P specifies a PROGRAM; PROG=M specifies a MODULE.\n\n(See member $JCL for details on JCL.)\n\nYou can use ISPF's XZIL option 4 to compile a FUNCTION, PROGRAM or\nMODULE in the foreground, or ISPF's XZIL option 5 to submit a background\njob to compile a FUNCTION, PROGRAM or MODULE.\n\nA PROGRAM is a LISP \"top-level\", i.e. a series of LISP expressions\nwhich are executed in sequence, optionally along with function and macro\ndefinitions (DEFUN's).  This produces a top-level load module which\nresides in a load library and can be called from TSO or batch in the\nusual ways (see member $CALL for more details), or invoked from ISPF's\nXZIL option 6.  The ZIL interpreter and compiler are examples of ZIL\nPROGRAM's.\n\nA FUNCTION is one or more DEFUN's - function and macro definitions - of\nwhich one DEFUN must be a function definition whose name matches the\nmember name of the function you are compiling.  This produces an NCAL\nload module suitable for linkediting into a compiled PROGRAM or being\ninvoked under the interpreter.  To execute the function under the\ninterpreter, you simply call it as if it were already defined; ZIL will\nautomatically load the function code when you need it (assuming that you\nhave made the load library available to the interpreter session).\n\nA MODULE is a series of LISP expressions, including DEFUN's and anything\nelse you wish, which is compiled into a function whose purpose is to\nload the contents of the source file you are compiling.  This produces\nan NCAL load module which can be loaded under the interpreter by\ninvoking the module as a function with no arguments.\nTo execute any of the functions defined therein, you call the module\nby typing (FOO) - where FOO is the name of the module - once only.\nSubsequently you can reference any of the functions defined in that\nmodule in the normal fashion.\n\nBriefly, compiling a FUNCTION is analogous to the Common LISP\n(COMPILE functionname) function; compiling a MODULE is analogous to\nthe Common LISP (COMPILE-FILE filename) function; compiling a PROGRAM\nis analogous to compiling FORTRAN, PL/1, etc. programs that can be\ncalled or invoked from TSO or batch.\n\nRestrictions:\n\n(Note: In this discussion, macro calls that expand into DEFUN's -\n       like DEFMACRO - are considered equivalent to DEFUN's that you\n       code yourself.  See items (7) and (8) below for more info.)\n\nA PROGRAM cannot have a DEFUN defining a function or macro whose name\nconflicts with the name of the program you are compiling.\n\nA FUNCTION must have a DEFUN defining a function (not a macro -\ncompilation of macro code is not supported at this time) whose name\nmatches the name of the function you are compiling.  No top-level forms\nother than expressions with DEFUN, DEFMACRO, DEFLOAD, DECLARE,\nEVAL-WHEN, or PROGN's consisting of these forms, or macros which expand\ninto these forms, may occur in a file being compiled as a FUNCTION.\n\nA MODULE cannot have a DEFUN defining a function or macro whose name\nconflicts with the name of the module you are compiling.\n\nWhether in a PROGRAM or in a FUNCTION, the following apply:\n\n(1) DEFUN's et al. must be at top level, i.e. not embedded within\n    another expression.  E.g. the following is illegal:\n\n      (PROG () (DEFUN F (X) (PRINT X))\n               (AAA BBB CCC)\n               (DEFMACRO M (Y) `(FOO BAR ,Y))\n      )\n\n    Removing the PROG \"shell\" will make the above valid, but the\n    DEFUN's are processed by the compiler, not executed at run time.\n\n    Note: Top-level forms may be coded within a PROGN; they will be\n          processed as if they were actually at top level.\n\n\n(2) You may code the DEFLOAD special form to associate LISP function\n    names with \"IBM-style\" external names for compilation (it performs\n    a similar but different task under the interpreter).  DEFLOAD may\n    be used to identify the main function or any external functions.\n\n    For example:\n\n      (DEFLOAD BIG-HAIRY-FUNCTION-NAME FUNNAME)\n\n    will cause references to BIG-HAIRY-FUNCTION-NAME to be compiled\n    using an external name of FUNNAME, which may be a separately\n    compiled function.  If the source file name is FUNNAME, you may\n    call the actual main function BIG-HAIRY-FUNCTION-NAME as long as\n    you code the DEFLOAD telling the compiler about it.\n\n    DEFLOAD, like DEFUN, must be at top level (but see (7) and (8)).\n\n(3) The form (END), when coded with no arguments, indicates end of\n    source input to the compiler.  This is obviously not required, but\n    is present to permit compiler testing with input typed in from the\n    terminal (as under ISPF's XZIL option 7).  (END) has a similar\n    meaning to the READ-EVAL-PRINT loop used by the interpreter.\n\n(4) The DECLARE special form is used for declarations, including\n    compiler options.  See member DECLARE for a full explanation\n    of what can be specified.\n\n(5) Compiler directives may be coded via the EVAL-WHEN special form\n    (see member EVALWHEN of this document for more information).\n    The (EVAL-WHEN (COMPILE) ...) construct is used to specify\n    LISP code that the compiler is to evaluate in its own\n    environment.\n\n    Compiler directives can occur at top level only.\n\n    Example:  If you have the following in your source:\n\n      (EVAL-WHEN (COMPILE)\n        (PRINT \"Hello, I'm compiling your program now!\")\n      )\n\n    the compiler will print the message:\n\n       \"Hello, I'm compiling your program now!\"\n\n\n(6) The DEFARGS form tells the compiler about a function that you are\n    invoking but are not defining in your code (i.e. an external user\n    function).\n\n    Normally, when the compiler finds a call to a function that is not\n    defined in your code, and it is not a \"standard\" ZIL function as can\n    be found in this documentation, the compiler converts the call to a\n    FUNCALL, which will interpretively apply the function symbol to the\n    specified arguments.  This enables compiled code to call interpreted\n    code without having to explicitly code FUNCALL's.\n\n    However, if you know that the function exists as a compiled SUBR and\n    you want to tell the compiler about it (so that it can generate a\n    direct branch to the code), you can use DEFARGS.  For example:\n\n      (DEFARGS SOMEFUNC 1 2)\n\n    tells the compiler that there is a function called SOMEFUNC\n    with a definition something like:\n\n      (DEFUN SOMEFUNC (A &OPTIONAL B) ...)\n\n    So, if the compiler finds a function call like\n\n      (DEFUN PIG (A B) (CONS (SOMEFUNC A) B))\n\n    it is to treat SOMEFUNC as an EXPR (actually a SUBR since it will be\n    a compiled load module in a link library) with at least 1 and at\n    most 2 arguments required (any arguments omitted will be passed as\n    unsupplied optional arguments and will be bound to their default\n    values at execution time).  Note that the function name must conform\n    to IBM naming standards since it will become an external reference\n    (i.e.  1-8 alphameric characters, first one alphabetic or national).\n\n    (The function SOMEFUNC will be linked with your PROGRAM if SOMEFUNC\n    was previously compiled as a FUNCTION.  If SOMEFUNC is referenced by\n    code in a separately compiled FUNCTION named OTHRFUNC, it will not\n    be linked into OTHRFUNC when OTHRFUNC is compiled (FUNCTIONS are\n    linkedited with NCAL), but if you compile a PROGRAM that calls\n    OTHRFUNC, then both OTHRFUNC and SOMEFUNC will be linked into the\n    PROGRAM when the PROGRAM is linkedited.)\n\n    To tell the compiler that SOMEFUNC has a &REST argument, if it\n    was defined externally with a &REST keyword in its lambda list,\n    or if it has &KEY keywords in its lambda list,\n    specify T as the fourth argument.  Here are some examples:\n\n      (DEFARGS SOMEFUNC 2 5)   ; 2 required,  3 optional, no &rest\n      (DEFARGS SOMEFUNC 2 2)   ; 2 required, no optional, no &rest\n      (DEFARGS SOMEFUNC 2 5 T) ; 2 required,  3 optional,  1 &rest\n      (DEFARGS SOMEFUNC 2 2 T) ; 2 required, no optional,  1 &rest\n\n    It is NOT necessary to have a DEFARGS for any of the following:\n\n      Macros.\n\n      \"Standard\" functions (the ones every LISP user knows and loves).\n\n      Functions invoked via APPLY or FUNCALL,\n      if they are referenced as 'FOO rather than #'FOO.\n\n      Functions defined in your source via DEFUN's (internal functions).\n\n    Note: (DEFARGS funcname NIL) is a special case that makes the\n          compiler think it doesn't know anything about \"funcname\".\n\n(7) DECLARE(SPECIAL) may be used at top level to identify variables as\n    \"special\" (dynamically bound) variables.  See member DECLARE of\n    this documentation for more information.\n\n    In a MODULE, DEFVAR is the preferred way of defining globally bound\n    special variables.  Note: DEFVAR is not supported when compiling a\n    FUNCTION.\n\n(8) DEFUN's, EVAL-WHEN's, DECLARE's and other top-level forms may be\n    generated by macro calls that occur at top level, provided that the\n    macros which generate them are defined preceding their calls in the\n    source.  For example, if you had a macro MYDEF which expanded into a\n    (DEFUN ...) which you wanted the compiler to process, you would have\n    to have the following, in this order:\n\n      (DEFMACRO MYDEF ...\n      ...\n      (MYDEF ...\n\n    The compiler would recognize the function (be it SUBR or MACRO)\n    defined by the DEFUN that MYDEF expanded into, as if you had\n    coded it at top level directly.\n\n(9) PROGN can be used to get a series of DEFUN's or other top-level\n    S-expressions treated by the compiler as if they were actually at\n    top level, even though they are actually enclosed within a PROGN.\n    This may be useful if you have a macro which generates a series of\n    DEFUN's (perhaps something similar to a structure definition\n    facility) which you want the compiler to recognize as top-level\n    DEFUN's; a macro cannot generate more than one S-expression, but it\n    can generate a single PROGN form to contain multiple forms.\n\n    To use this, you enclose the forms within a PROGN special form.\n    Note that this works equally well interpreted, since the\n    interpreter makes no distinction about \"top-levelness\".\n\n    The (PROGN ...) form may be generated by a macro call.\n\n    For example:\n\n    (PROGN\n           (DEFUN FOO (X) (CONS X NIL))\n           (DEFUN BAR (X) (CONS (FOO X) X))\n    )\n\n    is equivalent to specifying both of the above DEFUN's at top level.\n\n\n(10) The (END) end-of-file indication may NOT be generated by a macro.\n\n(11) Currently there is no support for external FEXPR's (or, for that\n     matter, any FSUBR's, that is to say compiled FEXPR's).\n     In a MODULE, any FEXPR definitions the compiler sees will be\n     transformed into equivalent MACRO definitions.\n\n     Macro definitions may not be compiled either at this time.\n\n(12) For more notes about DEFUN usage under the compiler, see member\n     $DEFUN of this document.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DEFUN": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x86\\x02/\\x00\\x88\\x02\\x9f\\x08E\\x00\\xbc\\x00\\xd9\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1986-01-22T00:00:00", "modifydate": "1988-01-29T08:45:00", "lines": 188, "newlines": 217, "modlines": 0, "user": "SEB1525"}, "text": "\nThe DEFUN function is the basic function-defining technique.\nNote that in a compiled program or function, it does not generate\nexecutable code to perform the DEFUN a la interpretive mode,\nbut causes a compiled function to be created.  For that reason,\nit must occur at top level in compiled code.\n\n\nIn the interpretive environment, you can define EXPR's, FEXPR's,\nLEXPR's, or MACRO's on the fly (EXPR is the default format).\n\nIn a compiled PROGRAM or FUNCTION, you can define EXPR's or MACRO's.\nEXPR's become part of the compiled code as SUBR's; MACRO's become\nknown to the compiler so that they can be expanded when they are\nencountered in the source code. FEXPR's are not supported\nby the compiler; neither are direct calls to FEXPR's or LEXPR's,\nalthough LEXPR's may be invoked via APPLY.\n\nIn a compiled MODULE, all kinds of DEFUN's are permitted.  However,\nFEXPR's are converted by the compiler into equivalent MACRO definitions\nthat are available at both compile time and run time.\n\nThe default function type is EXPR.\n\n\nIn the following descriptions, \"func\" is the name given to the function\nbeing defined, \"var1\"...\"varn\" are symbols that represent variables\nwhich are bound at function evaluation time, and the forms \"form1\",\n\"form2\", etc., constitute the body of the function, which is evaluated\nunder the binding environment established in accordance with the other\noperands.\n\n\nTo define an EXPR...\n\n\n(DEFUN func (var1 var2 ... varn) (form1) (form2) ... (formn))\n\nor\n\n(DEFUN func EXPR (var1 var2 ... varn) (form1) (form2) ... (formn))\n\nwhich are equivalent, and create an EXPR named \"func\" (under the\ninterpreter) or define a SUBR named \"func\" to the compiler.  Each\n\"varn\" is evaluated and bound to the corresponding parameter in the\ninvocation of the function.\n\nAny number of \"varn\"'s, including none, can be specified.\n\n\"Lambda list keywords\" like &OPTIONAL, &REST, &AUX and &KEY can be\nembedded in the argument list (see member LAMBDA of this documentation\nfor more information).\n\n\"varn\"'s must be symbols that do not normally evaluate to themselves,\nor lists (destructuring templates) of valid variable names.\nIn other words, T and symbols whose print names begin with colons\nare not legal variable names.  Note that NIL is permissible as a\nstand-in for an unused argument.  This interpretation is consistent\nwith lambda-list destructuring, where the argument is destructured\ninto the empty list (i.e. no variables inherit a value from that\nactual parameter).\n\nSpecial case:  If the argument list is a single non-null symbol,\n this is a definition of a LEXPR, in which case the symbol is bound\n to the number of arguments passed, and the (evaluated) arguments\n themselves are accessible via the ARG function.\n\nIn addition to Common LISP features, the following features of lambda\nlists are supported by both the interpreter and the compiler, for DEFUNs\nand DEFMACROs:\n\n* Destructuring arguments (e.g. (LAMBDA ((A B) (C . D)) ...))\n\n* LEXPR definitions\n\nThe following are not supported in ZIL at this time:\n\n &WHOLE, &ENV\n\n\nTo define a FEXPR...\n\n\n(DEFUN func FEXPR (firstvar alistvar) (form1) (form2) ... (formn))\n\nwhich is valid only under the interpreter (in general) and creates a\nFEXPR, where \"firstvar\" is bound to the list of (unevaluated) arguments\nand \"alistvar\" becomes bound to the current evaluation environment\n(which contains the variable bindings in effect when the function is\ninvoked - this provides a dynamic rather than a lexical evaluation\nenvironment if it is referenced).  You would use the environment\nargument to pass to EVAL if you want to evaluate some of your\narguments, since arguments to FEXPR's are not evaluated.\n\nAlthough \"firstvar\" is required, \"alistvar\" is optional.\n\nIf \"alistvar\" is omitted, a dummy second argument is generated\ninternally in the function definition, which cannot be referenced\nin the body of the FEXPR.\n\n\"&-keywords\" are not valid in the argument list of a FEXPR.\n\n\nTo define a MACRO...\n\n\n(DEFUN func MACRO (var) (form))\n\nwhich creates a MACRO (under the interpreter) or defines a MACRO to\nthe compiler (the compiler will expand macro calls and compile\nthe expanded code as if you had coded it directly).  \"var\" is bound\nto the entire macro call form; the CAR of it is the macro name, and\nthe CDR of it is the list of (unevaluated) arguments.\n\nExactly one argument \"var\" must be specified.\n\n(Note: DEFMACRO, which is implemented as a macro that expands into\n       a DEFUN, may also be used to define macros.  See the DEFMACRO\n       documentation member for more info.)\n\n\nNote that for all uses of DEFUN, any number of \"formn\"'s may be\nspecified, as long as at least one form is present.  Only the last\none, however, returns a value to the caller of the function; the\nothers are evaluated for their \"side effects\" only.  This is known\nas an \"implicit PROGN\".\n\n\nExamples:\n\n(DEFUN FIRST (X) (CAR X))\n\nIf you type (FIRST FOO), X will be bound to the value of FOO.\n\n(DEFUN FIRST FEXPR (X A) (CAR (EVAL (CAR X) A)))\n\nIf you type (FIRST FOO), X will be bound to the list (FOO).\n\n(DEFUN FIRST MACRO (X) (LIST 'CAR (CADR X)))\n\nIf you type (FIRST FOO), X will be bound to the list (FOO) and\nthe macro will expand to:\n\n   (CAR FOO)\n\nThis will be evaluated in turn.\n\n(Note: (DEFMACRO FIRST (A) (LIST 'CAR A))\n       produces the same result as (DEFUN FIRST MACRO ... ) above.)\n\nNote that all of the above will return the same value - namely,\nthe CAR of the object currently bound to the symbol FOO.\n\n\n LEXPR's - these are functions which are defined like EXPR's, except\n           that the argument list is not a list but a symbol (other\n           than NIL), which is bound to the number of (evaluated)\n           arguments passed to the function.  The arguments themselves\n           may be extracted via the ARG special form.\n\n\n The syntax (DEFUN (funcname fprop) ...) tells the interpreter to\n take the body of the function (wrapped in the appropriate LAMBDA)\n and make it the \"fprop\" property of the \"funcname\" symbol.  The\n compiler supports this syntax only if you are compiling a MODULE.\n\n\n Default arguments for &OPTIONAL values, and predicates telling\n whether an argument was supplied, may be specified on a DEFUN\n lambda list.  For example:\n\n    (DEFUN FOO (A &OPTIONAL (B 'BAR) (C 'BAZ C-SUPPLIED-P))\n\n sets arg B to BAR if it was omitted; sets args C to BAZ and\n C-SUPPLIED-P to NIL if C was omitted.  If a value for arg C was\n given on a call to FOO, C-SUPPLIED-P is bound to T.\n\n\n Destructuring of arguments...e.g. (DEFUN FOO ((A B) C) ...)\n results in the first argument in a call to FOO being \"destructured\"\n into args A and B, i.e. the CAR goes into A and the CADR goes into B.\n This works equally well with dotted pairs, and the destructuring may\n be nested.\n\n Note:  Destructuring and all the other lambda-list features are also\n        available on DEFMACRO.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$EQUAL": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87$\\x7f\\x00\\x88\\x02\\x9f\\x08G\\x00u\\x00\\x14\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-09-04T00:00:00", "modifydate": "1988-01-29T08:47:00", "lines": 117, "newlines": 20, "modlines": 0, "user": "SEB1525"}, "text": "\n These are the distinctions between the various equality functions:\n\n  EQ - tests if the two arguments have the same memory address\n       (their pointers are numerically equal).\n\n  EQL - like =, but the types of the arguments must match.\n        Two lists are EQL only if they are EQ.\n\n  EQUAL - tests if two lists have the same structure\n          (true if their CAR's are EQUAL and their CDR's are EQUAL).\n          Note that EQUAL for atoms is equivalent to EQL.\n\n  = or\n  ZILEQUAL - For symbols and strings, tests if their print names are\n             identical, CASE INCLUDED.\n             For numbers, tests if they are numerically equal.\n\n  EQUALP - For symbols and strings, tests if their print names are\n           identical WITHOUT REGARD TO CASE.\n           For lists, true if the CAR's are EQUALP and the CDR's\n           are EQUALP.\n           For numbers, same as =.\n           For vectors, true if they have the same number of elements\n           and the elements are EQUALP.\n           For all other objects, same as EQL.\n\n  (EQUALP is the Common LISP EQUALP.  Note that the EQUALP available\n  in earlier releases of ZIL was closer to ZILEQUAL.)\n\n  EQL in ZIL differs from Common LISP EQL in that it can compare\n  strings.  The philosophy behind this is that in ZIL, strings are\n  unmodifiable entities, whereas Common LISP supports functions\n  that change the contents of strings.\n\n  Note that ZILEQUAL is the two-argument function underlying =.\n  Furthermore, ZILEQUAL (or =) is the only equality predicate that\n  will error out if argument types are passed to it that it cannot\n  compare, much like GREATERP or LESSP will.\n\n  Two integers with the same value may not be EQ, but they\n  will always be EQL, EQUAL or =.\n\nExamples:\n\n ;;; Comparing numbers\n\n (EQ     1 1.0) ==> NIL\n (EQL    1 1.0) ==> NIL\n (EQUAL  1 1.0) ==> NIL\n (EQUALP 1 1.0) ==> T\n (=      1 1.0) ==> T\n\n ;;; Comparing strings\n\n (EQ     \"foo\" (string-append \"foo\")) ==> NIL\n (EQL    \"foo\" (string-append \"foo\")) ==> T  ; not in Common Lisp!\n (EQUAL  \"foo\" (string-append \"foo\")) ==> T  ; not in Common Lisp!\n (EQUALP \"foo\" (string-append \"foo\")) ==> T\n (=      \"foo\" (string-append \"foo\")) ==> T\n\n (EQ     \"FOO\" \"foo\") ==> NIL\n (EQL    \"FOO\" \"foo\") ==> NIL\n (EQUAL  \"FOO\" \"foo\") ==> NIL\n (EQUALP \"FOO\" \"foo\") ==> T\n (=      \"FOO\" \"foo\") ==> NIL\n\n ;;; Comparing lists\n\n (EQ     '(A B) '(A B)) ==> NIL\n (EQL    '(A B) '(A B)) ==> NIL\n (EQUAL  '(A B) '(A B)) ==> T\n (EQUALP '(A B) '(A B)) ==> T\n (=      '(A B) '(A B)) ==> (\"***ERROR***\") ; = can't compare lists\n\n (EQ     '(1 2) '(1 2)) ==> NIL\n (EQL    '(1 2) '(1 2)) ==> NIL\n (EQUAL  '(1 2) '(1 2)) ==> T\n (EQUALP '(1 2) '(1 2)) ==> T\n (=      '(1 2) '(1 2)) ==> (\"***ERROR***\") ; = can't compare lists\n\n (EQ     '(1 2) '(1.0 2.0)) ==> NIL\n (EQL    '(1 2) '(1.0 2.0)) ==> NIL\n (EQUAL  '(1 2) '(1.0 2.0)) ==> NIL\n (EQUALP '(1 2) '(1.0 2.0)) ==> T\n (=      '(1 2) '(1.0 2.0)) ==> (\"***ERROR***\") ; = can't compare lists\n\n ;;; Comparing symbols to symbols\n\n (EQ     (MAKNAM  '(A B C)) 'ABC) ==> NIL\n (EQL    (MAKNAM  '(A B C)) 'ABC) ==> NIL\n (EQUAL  (MAKNAM  '(A B C)) 'ABC) ==> NIL\n (EQUALP (MAKNAM  '(A B C)) 'ABC) ==> NIL\n (=      (MAKNAM  '(A B C)) 'ABC) ==> T\n\n ;;; Comparing symbols to strings\n\n (EQ     (MAKNAM  '(A B C)) \"ABC\") ==> NIL\n (EQL    (MAKNAM  '(A B C)) \"ABC\") ==> NIL\n (EQUAL  (MAKNAM  '(A B C)) \"ABC\") ==> NIL\n (EQUALP (MAKNAM  '(A B C)) \"ABC\") ==> NIL\n (=      (MAKNAM  '(A B C)) \"ABC\") ==> T\n\n ;;; Comparing vectors\n\n (EQ     #(A B C) #(A B C)) ==> NIL\n (EQL    #(A B C) #(A B C)) ==> NIL\n (EQUAL  #(A B C) #(A B C)) ==> NIL\n (EQUALP #(A B C) #(A B C)) ==> T\n (=      #(A B C) #(A B C)) ==> (\"***ERROR***\") ; can't compare vectors\n\n (EQ     #(1 2 3) #(1.0 2.0 3.0)) ==> NIL\n (EQL    #(1 2 3) #(1.0 2.0 3.0)) ==> NIL\n (EQUAL  #(1 2 3) #(1.0 2.0 3.0)) ==> NIL\n (EQUALP #(1 2 3) #(1.0 2.0 3.0)) ==> T\n (=      #(1 2 3) #(1.0 2.0 3.0)) ==> (\"***ERROR***\") ; can't compare\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FILE": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x02/\\x00\\x88\\x02\\x9f\\x08Q\\x00\\x90\\x00\\xb0\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-01-22T00:00:00", "modifydate": "1988-01-29T08:51:00", "lines": 144, "newlines": 176, "modlines": 0, "user": "SEB1525"}, "text": "\n ZIL File System\n\n A file is an object, not directly accessible from ZIL code, which\n describes a currently open file.\n\n Files are specified on ZIL I/O functions as symbols of from 1 to 4\n characters.  The symbol name is used to construct a file name (as\n explained below), and is used to locate the file via an EQ test.  Note\n that a symbol name of more than 4 characters cannot be used as a file\n name.\n\n There are two types of files:  input files and output files.  Whether\n a file is an input file or an output file depends wholly upon the\n context, i.e. what function is using it.  Thus, the same symbol\n may be simultaneously an input and an output file while referencing\n two totally separate data sets or allocations.\n\n A file name may be one of the following:\n\n  NIL - in which case the standard input or output file is used\n        (the DDNAME is ZILI for standard input or ZILO for standard\n        output).  Note that either one of these DDNAMES need not\n        be allocated; if ZILI is missing, the terminal will be used\n        for standard input, and if ZILO is missing, the terminal will\n        be used for standard output.  Thus, both of these DDNAMES\n        are required in batch since there's no terminal there.\n\n  T   - in which case the TSO terminal is used (the DDNAME is ZILIT\n        for input and ZILOT for output).  If either ZILIT or ZILOT is\n        allocated, it will be used.  If you run in batch, then\n        if ZILIT is missing, standard input (ZILI) will be used;\n        and if ZILOT is missing, standard output (ZILO) will be used.\n\n  xxxx (where xxxx is a symbol whose name is from 1 to 4 characters) -\n        if the context requires an input file, a DDNAME ZILIxxxx must\n        have been allocated and will be opened for input when it is\n        used in a function call.  If the context demands an output\n        file, a DDNAME ZILOxxxx must have been allocated and will be\n        opened for output when it is used in a function call.  All\n        such files are automatically closed at ZIL program\n        termination time.\n\n In addition, file names may be generated by the OPEN function,\n and files are removed from the ZIL system by the CLOSE function.\n\n In nearly all cases, the file name operand of a function is optional\n (and defaults to NIL), except where otherwise indicated.\n\n\n The following functions operate on both input and output files:\n\n OPEN     - allocates a data set to a file and opens it.\n CLOSE    - closes a file.\n\n (Note that OPEN does NOT take a file name as an argument, but\n  returns one.  Also note that ZIL is probably the only system\n  around which uses a type operand on CLOSE.)\n\n Examples:\n\n    Under TSO, you may enter:\n\n      alloc fi(zilifoo) da(foobar.data) shr reuse\n\n    (Note: The \"REUSE\" keyword is available only if TSO/Extensions is\n           installed on your system.)\n\n    This establishes an input file called FOO.  When you are in LISP,\n    the function call (READ 'FOO) will read an S-expression from the\n    dataset FOOBAR.DATA.\n\n      alloc fi(zilobar) da(foobar.data) old reuse\n\n    This establishes an output file called BAR.  When you are in LISP,\n    the function call (PRINT 'HI 'BAR) will write the S-expression HI\n    into the dataset FOOBAR.DATA.\n\n These files will not be opened until they are referenced by function\n calls; therefore, you need not worry about clobbering an output file\n that is allocated to a ZILO... DD name but is never used.\n\n At Draper Lab, if you are hooked up to PROGLIB via XSETUP, then you can\n use the XZIFILE and XZOFILE CLIST's to allocate files.   The following\n commands are equivalent:\n\n XZIFILE FOO FOOBAR.DATA   <=>  ALLOC FI(ZILIFOO) DA(FOOBAR.DATA) SHR\n\n XZOFILE BAR FOOBAR.DATA   <=>  ALLOC FI(ZILOBAR) DA(FOOBAR.DATA) OLD\n\n Notes: The REUSE keyword is optional on both.\n        XZOFILE will create the dataset as new if it does not exist.\n        The XZIFREE and XZOFREE CLIST's will free ZIL files similarly.\n\n Alternatively, you may enter under ZIL:\n\n  (setq foo (open \"foobar.data\" 'input))\n\n This sets the value of the variable FOO to the file name returned\n by OPEN, which may then be used in subsequent statements like\n READ and CLOSE.\n\n Both fixed-length and variable-length records are supported for input\n and output file I/O; however, only fixed-length records are supported\n for standard input and output (file NIL).  Input and output data sets\n must be sequential (although a PDS with a member name is OK).\n\n Currently, if a new dataset is created for an output request, the\n DCB attributes RECFM=FB, LRECL=80, BLKSIZE=6160 are assigned.\n\n For input files, ZIL determines dynamically whether the file is line\n numbered, as follows:\n\n 1.  If the file is allocated to the terminal, it is never considered\n     to be line numbered.  This allows continuous typing of input\n     across terminal rows.\n\n 2.  If the file is allocated to a data set, the presence of numerics in\n     the appropriate columns is used to determine whether the entire\n     file is line-numbered or not.  If ZIL thinks it is, the line number\n     field is NOT ACCESSIBLE by any ZIL function.  As usual for TSO, the\n     last 8 columns of fixed-length records and the first 8 columns of\n     variable-length records are presumed to be the line number field.\n     Note that in the case of concatenated data sets, the first record\n     of the first data set in the concatenation establishes the number\n     mode for the whole concatenation.  Most ZIL source is unnumbered.\n\nFile I/O notes:\n\n If a file is allocated to the terminal, special processing takes place\n that is a bit different from what happens with non-LISP programs:\n\n  (1) Input data is not necessarily folded to upper case; processing of\n  case follows exactly the same rules as input from a data set.\n\n  (2) /* is NOT an EOF indication.  Your program will have to have its\n  own logic to determine when you want to get out of an interactive\n  loop, or else you may be stuck talking to your program forever (of\n  course, you can always attention out).\n\n To test whether an input file exists, use (IFILEP filename).\n\n To test whether an output file exists, use (OFILEP filename).\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "$FLAVORS": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87$\\x7f\\x00\\x882\\x8f\\x13$\\x00{\\x00\\x89\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-09-04T00:00:00", "modifydate": "1988-11-23T13:24:00", "lines": 123, "newlines": 137, "modlines": 0, "user": "SEB1525"}, "text": "\nFLAVORS is an object-oriented programming paradigm familiar to users of\nLisp Machine LISP and NIL.  The ZIL implementation is nearly identical\nto the one described in the Lisp Machine manual, plus one or two\nNIL-compatible features.  (See \"References\" at the bottom of this item.)\n\nAs of 11/23/88, all of the features in the MIT AI lab paper on\nFLAVORS are implemented except for:\n\nThe function LEXPR-FUNCALL-SELF\nThe function RECOMPILE-FLAVOR\nThe macro COMPILE-FLAVOR-METHODS\nThe variable *FLAVOR-COMPILATIONS*\nThe DEFFLAVOR options :ORDERED-INSTANCE-VARIABLES,\n                      :SELECT-METHOD-ORDER,\n                  and :DOCUMENTATION.\n(DEFFLAVOR will issue a warning if any of these are specified, then\nwill ignore them and proceed to define the flavor without errors.)\n\n\nThese may be available in the near future as the system is enhanced.\n\nIn addition, the following should be noted:\n\n(1) Since ZIL does not currently have a package system, functions and\n    variables residing in the SI package occur without the package\n    prefix, e.g. SI:DESCRIBE-FLAVOR is implemented as DESCRIBE-FLAVOR.\n\n(2) \"Keywords\" in ZIL are any symbols the first character of whose\n    print name is a colon (since there is no \"keyword package\" in ZIL).\n    If a symbol is a \"keyword\", both the interpreter and the compiler\n    recognize it as self-evaluating UNLESS there is a currently\n    active LAMBDA-binding for the symbol.  The compiler may issue a\n    warning message when it sees an unbound keyword symbol; this\n    warning message may be ignored if you use keywords in the\n    traditional LISP manner.\n\nTo use FLAVORS in ZIL under the interpreter, type the following\n(or add it to your INIT file):\n\n (FLAVORS)\n\nThis defines all the FLAVORS functions and macros, and defines\nVANILLA-FLAVOR and all of its methods.  The :SEND-IF-HANDLES,\n:OPERATION-HANDLED-P, :SXHASH and :EVAL methods, available in the NIL\nimplementation of FLAVORS, are also defined here for VANILLA-FLAVOR.\n\nNote:  It is actually not necessary to include this in an interpreted\n       code file, since any use of a FLAVOR function will cause\n       FLAVORS to be brought in automatically via autoloading.\n\nTo use FLAVORS in compiled code, include the following in your\nsource file:\n\n (EVAL-WHEN (COMPILE LOAD EVAL)\n  (FLAVORS)\n )\n\nYou don't have to specify all 3 EVAL-WHEN times.  COMPILE lets the\ncompiler recognize the FLAVORS macros (DEFFLAVOR, DEFMETHOD, etc.)\nwhen it encounters them, so that it can compile them correctly.  LOAD\nspecifies that the FLAVORS functions and macros are to be available when\nthe code is brought in under the interpreter, so that the user can use\nFLAVORS functions there as well; if the code is designed to use FLAVORS\ninternally only, LOAD need not be specified (as long as the autoloading\nsystem is capable of bringing in FLAVORS dynamically).  EVAL is\nnecessary only when you run the source code directly under the\ninterpreter instead of the compiled version (perhaps for debugging).\n\nNote that in ZIL, the SEND and DESCRIBE functions are part of\nthe FLAVORS system, and cannot be used unless you bring in FLAVORS\nin one of the above ways.\n\nAdditional ZIL-only features:\n\n *FLAVOR-MSGLEVEL*  (variable)\n\nThis variable controls the display of messages issued by FLAVORS\nas it is defining, instantiating, and initializing components of\nthe FLAVOR system.  Many of these messages would be displayed the\nfirst time a flavor is instantiated (e.g. via the first\nMAKE-INSTANCE).\nHas one of the following values:\n\n  0  -  allow all messages to appear.\n  1  -  suppress informational messages.\n  2  -  suppress informational and warning messages.\n  3  -  suppress informational, warning and error messages.\n\nThe default for this variable is 1.\n\nNote:\n\nSince COMPILE-FLAVOR-METHODS is not implemented yet, a module that uses\nFLAVORS compiled will have its combined method functions constructed\ninterpretively at flavor instantiation time.  However, the individual\n(non-combined) methods built by DEFMETHOD will be compiled; in fact, the\nGET-HANDLER-FOR function may return a compiled code object rather than a\nsymbol as a method name.\n\nAn advantage of this implementation is that wrappers take effect at\ndefinition time; execution of the DEFWRAPPER form causes automatic\nregeneration of methods for the associated wrapper.\n\nThere are some gray areas in the FLAVORS documentation about the\ninteraction of component flavors and included flavors, and about\nthe contents of the default-init-plist.  ZIL's implementation may\nor may not differ in certain subtle respects where these are not\nclearly laid out in the Lisp Machine documentation.\n\n\nReferences:\n\n\n\"Flavors: Message Passing in the Lisp Machine\"\nA.I. Memo No. 602\nD. Weinreb, D. Moon - MIT Artificial Intelligence Laboratory, Nov. 1980\n\nNIL Reference Manual\nMIT/LCS/TR-311\nG. Burke, G. Carrette, C. Eliot\nMIT Laboratory for Computer Science, January 1984\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FORMS": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x02?\\x00\\x88\\x02\\x9f\\x08U\\x00\\xa4\\x00\\x9b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-23T00:00:00", "modifydate": "1988-01-29T08:55:00", "lines": 164, "newlines": 155, "modlines": 0, "user": "SEB1525"}, "text": "\nFormats of objects that can be typed into the interpreter\n   (i.e. supported by the READ function):\n\n1. Atom - any string of characters not including blank, comma, parens,\n          dots, or a quote, backquote, comma, or sharp sign.\n\n   Possible formats are:\n\n   Numbers...\n\n    Fixnum (integer):     0, 17, 3., -1, 21\n\n     Note: The nnnBn and nnnQn syntaxes are no longer supported for\n           fixnums.  They will generate symbols instead.\n\n    Bignum (integer):     2147483648, 1000000000000\n    Double-float:         1.5, -2D3, .78, 3.1415926E-1\n    Single-float:         1.5S0, -2F3\n\n   Strings...\n\n    As follows:           \"This is a string\"\n    Escape conventions:   \"This one has a double quote \\\" mark\"\n                          \"This one has one backslash \\\\ like this\"\n    Null strings are OK:  \"\"\n\n   Symbols...\n\n    Normal:               FOO, print-name, NIL, Case-iS+NoT*RElevaNt\n    Escaped:              h\\i\\ \\there    (this prints as: |Hi tHERE|)\n                          \\01  (a symbol whose print name is \"01\")\n    Barred:               h|i ther|e     (this prints as: |Hi therE|)\n                          |01| (a symbol whose print name is \"01\")\n\n    Note: Delimited strings, as in $$/This is a symbol/,\n          are NO LONGER SUPPORTED.\n\n    All other formats are treated as symbols.\n\n    Alpha characters in symbols are folded to upper case (except when\n      they occur in escaped or barred atoms), and all symbols\n      typed in are interned on the object list (OBLIST).\n    Fixnum atoms are stored as fullword values, but bignums exist too.\n    Flonum atoms are single or double precision; the default is double.\n    Strings are stored as is.\n\n\n2. List - (form form form)  ... where form is an atom, list or pair.\n\n3. Dotted pair - (form1 . form2) ... produces a cons whose CAR is form1\n                                     and whose CDR is form2.\n   Note that (A . (B . (C . NIL))) is the same as (A B C).\n\n4. Vectors - #(form form form) ... see $RMACRO for more information\n                                   about this and other syntaxes\n                                   provided by reader macros.\n\nNotes:\n\n * A quote mark ' can precede a form; e.g. 'A is same as (QUOTE A).\n                      '(A B '(C)) = (QUOTE (A B (QUOTE (C))))\n\n   Other special characters have unique syntaxes implemented by the\n   reader macro facility.  For details, see member $RMACRO of this\n   documentation.\n\n   For example, #'A is the same as (FUNCTION A), and the backquote `\n   and comma , are used to implement the backquoting facility, which\n   is documented in any LISP manual.\n\n   These are implemented via the reader macro facility; other reader\n   macros for other characters may be defined by the user using\n   RDRMACRO or DEFRDMAC.\n\n * NIL is equivalent to ().\n\n * (END), when typed at top level, terminates the interpreter.\n\n * Semicolons ; terminate the current line and may be used to add\n   comments.\n\n * All alpha characters are folded to upper case EXCEPT in strings and\n   delimited, escaped or barred symbols, e.g.\n   '(a b (c) \\d |e| \"f\")  ===> (A B (C) |d| |e| \"f\")\n\n * End-of-line terminates a symbol name (unless it is a barred atom),\n   and is ignored in all other cases...\n   except in the case of strings, where an internal hex character (hex\n   0D, carriage return) is added to the string to represent a newline.\n\n * There are two ways under ZIL to create symbol names with special\n   characters.  Both methods always produce symbols even when\n   they contain all numeric characters.\n\n   An \"escaped atom\" is a name containing normal atom characters and\n   backslashes \\ (hex E0).  When a backslash is encountered, the\n   character immediately following the backslash is treated as part of\n   the atom being built, be it blank, semicolon, etc., with case\n   preserved.\n\n   A \"barred atom\" is a name containing normal atom characters and\n   vetical bars (|).  All characters between two vertical bars are\n   treated as part of the atom being built, be it blank, semicolon,\n   etc., with case preserved - with the single exception that\n   backslashes still function as escape characters.  Note that the bars\n   DO NOT delimit the name itself, but merely the portion of the name\n   being processed in this way.\n\n   Note: Vertical bars have no such syntactic function in strings.\n\n   The following all produce the symbol whose name is... Foo\\ (Bar;)\n\n   f\\o\\o\\\\\\ \\(b\\a\\r\\;\\)\n   f|oo\\\\ (|b|ar;)|\n   |Foo\\\\ (Bar;)|\n   \\F\\o\\o\\\\\\ \\(\\B\\a\\r\\;\\)\n\n * Both the reader and the printer support a continuation character\n   feature:  an object which occupies more than one line will be printed\n   in pieces, with the ZIL continuation character (the cent sign) in the\n   final position of each line.  The reader, when it sees the cent sign\n   in the final position of a line, will process the characters on the\n   following line as part of the object currently being read in, without\n   any newlines.  (This does not apply to data read in from the\n   terminal, although the continuation characters may appear when an\n   object is printed out on the terminal.)\n\n   With this feature, it is possible to print long strings, bignums,\n   etc. out to a file and read them back in.\n\n   For fixed-length records, the cent sign will be treated as a\n   continuation character if it occupies the last data column.  For\n   example, a RECFM=FB LRECL=80 data set will recognize the cent sign as\n   a continuation character if it is in column 80 for unnumbered data\n   sets, or column 72 for numbered data sets.\n\n   For variable-length records, the cent sign will be treated as a\n   continuation character if it occupies the last column of any record,\n   even if it is not the maximum length.\n\n   The cent sign will NOT be treated as a continuation if it is preceded\n   by a backslash, or if it is part of a comment field or otherwise not\n   part of a Lisp object being read in.\n\n * The following restrictions of ZIL 1.1 have been lifted in ZIL 1.2:\n\n   (a) Null characters (hex 00) are permitted in symbol names.\n   (b) A symbol name with a zero length (e.g. ||) is permitted and\n       has a print name of \"\".\n   (c) Symbol print names may be any length (like strings, this is\n       subject to the amount of vector/string space available to\n       build the string).\n\n Restrictions:\n\n   (d) A numeric character sequence produces a symbol if it\n       has an exponent with more than 4 decimal digits.\n\n *  The symbols NIL and T always evaluate to themselves,\n    as do symbols whose print name begins with a colon (\"keywords\").\n    Also, the symbols * ** *** + ++ +++ - have special meanings\n    when they are evaluated.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$FORTRAN": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x17O\\x00\\x87$_\\x14X\\x00\\x1f\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-06-23T00:00:00", "modifydate": "1987-09-02T14:58:00", "lines": 31, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\n   The ZIL FORTRAN Interface\n\nTo implement some of the more esoteric mathematical functions, ZIL\nutilizes the VS FORTRAN subroutine library.  In order to enable these\nfunctions to execute, you must have the VS FORTRAN subroutine library\navailable to ZIL at run time.\n\nThis library, normally 'SYS1.FORTLIB', need not be allocated at ZIL\nrun time.  The required FORTRAN subroutines are linkedited with ZIL\nmodule ZIFINIT, which is loaded the first time a ZIL mathematical\nsubroutine is used.\n\nVS FORTRAN version 1 release 4, VS FORTRAN version 2, or a\nhigher version/release, is required in order to use these functions.\n\nThe following functions utilize the ZIL FORTRAN interface:\n\n   ACOS\n   ASIN\n   ATAN\n   COS\n   EXP\n   LOG\n   SIN\n   SQRT\n   TAN\n\n(This list will be added to as time goes by.)\n\nBoth single and double precision versions of these routines are used.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$HELP": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01K\\x00\\x00\\x00\\x86\\x02?\\x00\\x89\\x15\\x8f\\x178\\x01\\x81\\x00\\xcc\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.75", "flags": 0, "createdate": "1986-01-23T00:00:00", "modifydate": "1989-06-07T17:38:00", "lines": 385, "newlines": 204, "modlines": 0, "user": "SEB1525"}, "text": "Function Name #Args   Returns/Description\n___________________________________________\n<             1-any#  T if args are all < (monotonically decreasing).\n<=            1-any#  Inverse of >.\n+             any#    Adds args together.\n*             any#    Multiplies args together.\n**            2       Same as EXPT.\n-             any#    Unary minus, or subtracts all args in sequence.\n/             any#    Reciprocal, or divides all args in sequence.\n//            any#    Same as REMAINDER.\n/=            2       T if args are not numerically equal, else NIL.\n>             1-any#  T if args are all > (monotonically increasing).\n>=            1-any#  Inverse of <.\n=             1-any#  T if args are all numerically equal, else NIL.\nABS           1       Absolute value of its argument.\nACOS          1       Arccosine of arg1.\nADD1          1       Sum of argument + 1.\nADJOIN        2-any#  CONSes arg 1 onto list arg 2 if not already there.\nALPHA-CHAR-P  1       T if arg1 is an alphabetic character, else NIL.\nAND           any#    NIL if any args are NIL, else returns last arg.\nAPPEND        any#    (APPEND '(A B) '(C D)) ===> (A B C D)\nAPPLY         2-any#  Applies function to list of arguments.\nAPROPOS       1       List of all known symbols with arg1 as substring.\nARG           0-1     Accesses arguments of a LEXPR.\nASH           2       Arith. shift left (right if neg) of arg1 by arg2.\nASIN          1       Arcsine of arg1.\nASSOC         2       (ASSOC '1 '((1 . A) (2 . B))) ===> (1 . A)\nASSQ          2       (ASSQ 'X '((A . B) (X . Y))) ===> (X . Y)\nAT            any#    Sets a tracing breakpoint for function entry/exit.\nATAN          2       Arctangent of arg1/arg2.\nATOM          1       T if arg is any kind of atom, else NIL.\nBIGP          1       T if argument is a bignum, else NIL.\nBLOCK         any#    Evaluate a named block of forms or RETURN-FROM it.\nBOOLE         3-any#  Applies Boolean op defined by arg1 to args 2, 3.\nBOUNDP        1       T is symbol is bound (has a value) else NIL.\nBUTLAST       1-2     List of all but the last arg2 element(s) of arg1.\nCAAAR         1       CAR of CAR of CAR of arg 1.\nCAADR         1       CAR of CAR of CDR of arg 1.\nCAAR          1       CAR of CAR of arg 1.\nCADAR         1       CAR of CDR of CAR of arg 1.\nCADDDR        1       CAR of CDR of CDR of CDR of arg 1.\nCADDR         1       CAR of CDR of CDR of arg 1.\nCADR          1       CAR of CDR of arg 1.\nCAR           1       (CAR '(A B C)) ===> A\nCASE          any#    LISP's contribution to structured programming.\nCATCH         2-any#  Evaluates arg2 with arg1 as THROW tag (see THROW).\nCDAAR         1       CDR of CAR of CAR of arg 1.\nCDADR         1       CDR of CAR of CDR of arg 1.\nCDAR          1       CDR of CAR of arg 1.\nCDDAR         1       CDR of CDR of CAR of arg 1.\nCDDDR         1       CDR of CDR of CDR of arg 1.\nCDDR          1       CDR of CDR of arg 1.\nCDR           1       (CDR '(A B C)) ===> (B C)\nCEILING       1-2     Converts floating point to integer.\nCHAR          2       Returns fixnum character in arg1 indexed by arg2.\nCHARACTERP    1       T if arg is a fixnum between 0 and 255, else NIL.\nCHAR-DOWNCASE 1       (CHAR-DOWNCASE #/A) ==> #/a\nCHAR-UPCASE   1       (CHAR-UPCASE #/a) ==> #/A\nCLOSE         1-2     Closes a file that was opened for input or output.\nCLOSUREP      1       T if arg is a compiled code closure, else NIL.\nCLRSCRN       0       Clears the screen of your 3270 terminal.\nCODEP         1       T if arg is a SUBR or compiled closure, else NIL.\nCOMMENT       any#    All args are comments, returns 'COMMENT.\nCONCAT        any#    (CONCAT 'FOO 'BAR) ===> FOOBAR ; interned symbol.\nCONCATL       1-2     (CONCATL '(A B C)) ===> ABC\nCOND          any#    Args in pairs, returns CADR of 1st whose CAR\u00ac=NIL.\nCONS          2       (CONS 'A '(B C D)) ===> (A B C D)\nCONSP         1       T if arg is a non-null list or dotted pair.\nCOPYSYMBOL    2       Makes an uninterned copy of a symbol.\nCOPYTREE      1       Makes a copy of its arg which shares no CONSes.\nCOS           1       Cosine of arg1.\nCTERPRI       0-1     Conditionally forces new line on output file.\nCURDATE       0       Returns year, month and day as list of 3 numbers.\nCURJDATE      0       Returns year and Julian day as list of 2 numbers.\nCURTIME       0       Returns current time of day as list of 3 numbers.\nDECF          1-2     Decrements arg 1 by arg 2 (default 1).\nDEFLOAD       2       Associates an external name with a function name.\nDEFMACRO      any#    Defines a macro.\nDEFRDMAC      2       Defines a reader macro.\nDEFSTRUCT     1-any#  Defines a structure type.\nDEFUN         any#    Defines a function.\nDEFVAR        2       Defines a global variable.\nDELETE        2-3     Destructive REMOVE (alters second argument).\nDESETQ        any#    \"Destructuring\" SETQ.\nDFLOATP       1       T if argument is a double-float, else NIL.\nDIFFERENCE    any#    Difference of all arguments (a - b - c - ...)\nDIGIT-CHAR-P  1-2     The numeric weight of arg1 as a digit, else NIL.\nDO, DO*       any#    Various kinds of iteration.\nDOLIST        2-any#  Iterates over a list.\nDOTIMES       2-any#  Iterates over a sequence of integers.\nEBCDIC        1-2     Takes fixnum and returns EBCDIC character.\nECHO          1-3     Sets input file arg1 to echo to output file arg2.\nED            0-1     Edits a file or a function definition under ISPF.\nEND           0       Indicates end of input to compiler or interpreter.\nENDP          1       T if arg is empty list, false if non-empty list.\nENDREAD       0-1     Forces end of current record of input file.\nEOF           0-1     T if end of file reached on input file, else NIL.\nEQ            2       T if arguments identical (same addr), else NIL.\nEQL           2       T if args have same type and contents, else NIL.\nEQUAL         2       T if arguments have same structure, else NIL.\nEQUALP        2       T if 2 arguments are similar, else NIL.\nERROR         0-any#  Prints error message and throws to tag NIL.\nEVAL          1-2     Evaluates argument.\nEVAL-WHEN     any#    Evaluates in specific env. (compile/load/eval)\nEVENP         1       T if integer is divisible by 2, else NIL.\nEVERY         2-any#  T if every application of arg1 to lists is true.\nEXIT          0-1     Terminates ZIL program, with optional return code.\nEXP           2       E to the arg1'th power.\nEXPLODE       1       (EXPLODE \"abc\") ===> (|\"| |a| |b| |c| |\"|)\nEXPLODEC      1       (EXPLODEC \"abc\") ===> (|a| |b| |c|)\nEXPLODEN      1       (EXPLODEN \"abc\") ===> (129 130 131)\nEXPT          2       Arg 1 to power of arg 2.\nFBOUNDP       1       T is symbol has a function definition, else NIL.\nFEATUREP      1       T if arg 1 is a \"feature\", else NIL.\nFEXPAND       1       Performs complete macro expansion of a form.\nFIRSTN        2       List of the first arg1 elements of list arg2.\nFIX           1       Converts floating point arg 1 to integer.\nFIXNUMP       1       T if argument is a fixnum, else NIL.\nFIXP          1       T if argument is a fixnum or bignum, else NIL.\nFLATC         1       Returns number of chars in object when PRINC'd.\nFLATSIZE      1       Returns number of chars in object when PRIN1'd.\nFLOAT         1-2     Converts integer arg 1 to floating point.\nFLOATP        1       T if argument is a floating point atom, else NIL.\nFLOOR         1-2     Converts floating point to integer.\nFMAKUNBOUND   1       \"Undefines\" a function.\nFORMAT        2-any#  Formats and/or prints messages with variable data.\nFUNARGP       1       T if arg is an interpreted closure (see FUNCTION).\nFUNCALL       1-any#  Applies function arg 1 to other args.\nFUNCTION      1       Creates an interpreted lexical closure (funarg).\nGC            0       Causes a garbage collection.\nGCD           0-any   Greatest common denominator of its args.\nGCMSG         1       Sets display of garbage collection messages.\nGCTIME        0       Returns total garbage collection time in millisec.\nGENSYM        0-1     Returns a unique uninterned symbol.\nGENTEMP       0-1     Returns a unique interned symbol.\nGET           2-3     Returns property value of arg 1's indicator arg 2.\nGETCHAR       2       Returns arg2'th character of arg1 as symbol.\nGETCHARN      2       Returns arg2'th character of arg1 as fixnum.\nGETL          2       Returns subplist of arg1 whose CAR is in list arg2\nGETPARM       0-2     Makes an atom out of PARM field passed to program.\nGO            1       Used in PROG: branches to label arg 1.\nGREATERP      2       T if argument 1 is greater than arg 2, else NIL.\nHAIPART       2       An integer from the high-order arg2 bits of arg1.\nHAULONG       1       Number of significant bits in integer abs(arg1).\nHELP          0-2     Obtain on-line help info from ZIL documentation.\nIF            any#    (IF A B C) = (COND (A B) (T C))\nIFILEP        1       T if specified input file exists, else NIL.\nIMPLODE       1       (IMPLODE '(A B C)) ===> ABC (interned symbol)\nINCF          1-2     Increments arg 1 by arg 2 (default 1).\nINCLUDE       1       Includes executable code from dataset arg 1.\nINCLUDEF      1       Includes executable code from dataset arg 1.\nINTEGER-LENGTH 1      Number of significant bits in integer arg1.\nINTEGERP      1       T if argument is a fixnum or bignum, else NIL.\nINTERSECTION  2       Set intersection of two lists using EQL test.\nINTRQ         2       Set intersection of two lists using EQ test.\nINVOKE        1 2     Calls program arg1 with parameter string arg2.\nLAST          1       (LAST '(A B C)) ===> (C)\nLDIFF         2       List of elements of a list not in a sublist of it.\nLENGTH        1       (LENGTH '(A B (C1 C2) D)) ===> 3\nLESSP         2       T if argument 1 is less than argument 2, else NIL.\nLET, LET*     any#    Sets up local variables and evaluates arguments.\nLIST          any#    (LIST 'A 'B 'C) ===> (A B C)\nLIST*         any#    (LIST* 'A 'B 'C) ===> (A B . C)\nLISTIFY       0-1     Returns a list of arguments to a LEXPR.\nLISTP         1       T if arg is NIL, a list or dotted pair, else NIL.\nLOAD          1-any#  Read-eval-prints a dataset into ZIL environment.\nLOCALLY       any#    Associates declarations with forms to evaluate.\nLOG           1-2     Logarithm of arg1 to base arg2 (default base E).\nLOGAND        any#    Logical AND of all its arguments.\nLOGBITP       2       T if the arg1'th bit of arg2 is 1, else NIL.\nLOGCOUNT      1       Number of 1-bits in integer (# of 0-bits if neg).\nLOGIOR        any#    Logical inclusive OR of all its arguments.\nLOGNOT        1       Logical complement (NOT) of its argument.\nLOGTEST       2       T if any of arg1's 1-bits are 1 in arg2, else NIL.\nLOGXOR        any#    Logical exclusive OR of all its arguments.\nLOOP          any#    Various kinds of iteration.\nLSH           2       Logical shift left (right if neg) of arg1 by arg2.\nMACROEXPAND   1       Expands a macro call repeatedly.\nMACROEXPAND-1 1       Expands a macro call once.\nMAKNAM        1-3     (MAKNAM '(A B C)) ===> ABC (uninterned symbol)\nMAKUNBOUND    1       \"Undefines\" a variable.\nMAPAND        2-any#  AND of all applies of arg 1 to elements of arg 2-n\nMAPC          2-any#  Applies function arg 1 to all elements of arg 2-n.\nMAPCAN        2-any#  Like MAPCAR but NCONC's all the results together.\nMAPCAR        2-any#  Like MAPC but returns list of all the results.\nMAPCON        2-any#  Like MAPLIST but NCONC's all the results together.\nMAPL          2-any#  Applies function arg 1 to all sublists of arg 2-n.\nMAPLIST       2-any#  Like MAPL but returns list of all the results.\nMAPOR         2-any#  OR of all applies of arg 1 to elements of arg 2-n.\nMAX           1-any#  Returns the greatest of its arguments.\nMEMBER        2       (MEMBER '2 '(1 2 3)) ===> (2 3)\nMEMQ          2       (MEMQ 'B '(A B C)) ===> (B C)\nMIN           1-any#  Returns the smallest of its arguments.\nMINUS         1       Returns the argument times -1.\nMINUSP        1       T if atom is negative, else NIL.\nMKATOM        1-3     Makes an atom (symbol or number) out of arg1.\nMKLIST        1-2     Makes a list of (arg 1) elements.\nMKVECTOR      1-2     Makes a vector of (arg 1) elements.\nMSGLEVEL      0-1     Returns or sets current message level.\nMULTIPLE-VALUE-BIND   Binds args to multiple values and executes body.\nMULTIPLE-VALUE-CALL   Calls function with all values of forms passed.\nMULTIPLE-VALUE-LIST   Returns list of multiple values of form.\nMULTIPLE-VALUE-PROG1  Like PROG1 but passes multiple values through.\nMULTIPLE-VALUE-SETQ   Sets variables to multiple values of a form.\nNCONC         any#    Destructive APPEND (alters its arguments).\nNCONS         1       (NCONS FOO) <=> (CONS FOO NIL)\nNEQ           2       (NEQ A B) <=> (NOT (EQ A B))\nNEWLINEP      0-1     T if end of line reached on input file, else NIL.\nNOT           1       T if argument is NIL, else NIL.\nNOTANY        2-any#  T if all applications of arg1 to lists are false.\nNOTEVERY      2-any#  T if some application of arg1 to lists is false.\nNRECONC       2       (NRECONC X Y) is same as (NCONC (NREVERSE X) Y).\nNREVERSE      1       Destructive REVERSE (alters its argument).\nNTH           2       The \"n'th\" element of a list, counting from zero.\nNTHCDR        2       The \"n'th\" sublist of a list, counting from zero.\nNULL          1       Same as NOT.\nNUMBERP       1       T if argument is fixnum/flonum/bignum, else NIL.\nOBLIST        0       Returns the object list of all interned symbols.\nODDP          1       NIL if integer is divisible by 2, else T.\nOFF           1       Removes an AT tracing breakpoint.\nOFILEP        1       T if specified output file exists, else NIL.\nOK            any#    Returns T if args evaluate without error, else NIL\nOPEN          1-2     Takes a dsname, opens it, returns a file.\nOR            any#    Returns first non-NIL argument or NIL.\nPAIRLIS       2-3     Add pairs from arg1 and arg2 onto alist arg3.\nPBIND         1       Returns contents of value/binding cell of symbol.\nPEEK          1       Returns word from memory using arg 1 as pointer.\nPEEKB         1       Returns byte from memory using arg 1 as pointer.\nPEEKC         1-2     Returns char from memory using arg 1 as pointer.\nPEEKCH        0-3     Like READCH but does not update character pointer.\nPEEKL         2-3     Invokes PEEKC to build list of chars from memory.\nPLIST         1       Same as SYMBOL-PLIST.\nPLUS          any#    Sum of all arguments.\nPLUSP         1       T if atom is positive, else NIL.\nPM            1-2     Pretty-prints the macro expansion of its arg.\nPM1           1-2     Pretty-prints the macro expansion of its arg.\nPNAME         1       Same as SYMBOL-NAME.\nPOP           1-2     Removes object from front of list and returns it.\nPP            any#    Pretty-prints a function definition.\nPPDATE        0-1     A string containing formatted date.\nPPRINT        1-2     Pretty-prints a LISP object.\nPPTIME        0-1     A string containing formatted time.\nPRINC         1-2     Prints arg 1 as is to output file, no TERPRI.\nPRINC-TO-STRING 1     PRINC's arg 1 into a string.\nPRINT         1-2     Prints arg 1 \"readably\" to output file & TERPRI's.\nPRINTC        1-2     Prints arg 1 as is to output file and TERPRI's.\nPRINTS        1-1     Prints arg 1 into a string.\nPRIN1         1-2     Prints arg 1 \"readably\" to output file, no TERPRI.\nPRIN1-TO-STRING 1     PRIN1's arg 1 into a string.\nPROBE-FILE    1       Same as PROBEF.\nPROBEF        1       Returns arg1 if it's an existing dsname, else NIL.\nPROG          any#    Has arg list, labels, GO and RETURN statements.\nPROGN         any#    Evaluates all arguments, returns the last.\nPROGV         any#    Evaluates body with vars specified at runtime.\nPROG1         any#    Evaluates all arguments, returns the first.\nPROG2         any#    Evaluates all arguments, returns the second.\nPSETQ         any#    Assigns values to local variables in parallel.\nPUSH          2       Sets arg2 to (CONS list1 arg2).\nPUSHNEW       2-any#  PUSHes arg 1 onto list arg 2 if not already there.\nPUTDATA       any#    Displays values of LISP forms for debugging.\nPUTPROP       3       Assigns arg 2 as value of property arg 3 to arg 1.\nQUIT          0-1     Forces EOF on input file; ends the interpreter.\nQUOTE         1       Returns argument 1 unevaluated.\nQUOTIENT      any#    Quotient of all arguments (a / b / c / ...)\nRANDOM        0-1     Returns a random fixnum or flonum between 0 & arg1\nREAD          0-2     Returns S-expression from input file.\nREAD-EVAL-PRINT 0-3   Read-eval-print loop over an entire input file.\nREADCH        0-3     Returns a single character from input file.\nREADLINE      0-1     Returns a line from input file as a string.\nREMAINDER     any#    Remainder of all arguments (a // b // c // ...)\nREMOVE        2-3     (REMOVE '2 '(1 2 2 3 4 5)) ===> (1 3 4 5)\nREMOVE-DUPLICATES 1   (REMOVE-DUPLICATES '(F O O B A R)) ==> (F O B A R)\nREMPROP       2       Removes property arg 2 from arg 1.\nREMQ          2-3     (REMQ   'O '(F O O B A R)) ===> (F B A R)\nRETURN        0-1     Exits from PROG with evaluated arg 1 as value.\nRETURN-FROM   1-2     Exits from BLOCK of matching name with a value.\nREVAPPEND     2       (REVAPPEND X Y) is same as (APPEND (REVERSE X) Y).\nREVERSALL     1       (REVERSALL '(A (B C) D)) ===> (D (C B) A)\nREVERSE       1       (REVERSE  '(A (B C) D)) ===> (D (B C) A)\nROT           2       Bitwise rotate of fixnum arg1 by arg2.\nROUND         1-2     Argument rounded to the nearest integer.\nRPLACA        2       Replaces the CAR of arg 1 with arg 2.\nRPLACD        2       Replaces the CDR of arg 1 with arg 2.\nRUNTIME       0       Returns session CPU time in milliseconds.\nSCRSIZE       0       Current terminal number of rows and # of columns.\nSET           2       Assigns argument 2 to local variable argument 1.\nSETABEND      1       Controls whether ABENDS are to terminate ZIL.\nSETARG        2       Replaces arguments of a LEXPR.\nSETATTN       1       Controls whether attentions are to terminate ZIL.\nSETBRACK      2-3     Controls how square brackets are printed.\nSETDEBUG      1       Control debugging mode.\nSETF          any#    Various kinds of assignments or alterations.\nSETFEAT       1       Makes argument 1 a \"feature\".\nSETNFEAT      1       Makes argument 1 NOT a \"feature\".\nSETPLIST      2       Sets the property list of arg 1 to arg 2.\nSETQ          any#    Assigns values to local variables sequentially.\nSFLOATP       1       T if argument is a single-float, else NIL.\nSIN           1       Sine of arg1.\nSLEEP         1       Puts ZIL in wait state for specified # of seconds.\nSOME          2-any#  True if some application of arg1 to lists is true.\nSORT          1-2     Sorts list arg1 by function arg2, makes new list.\nSORTCAR       1-2     Sorts list arg1 by comparing CAR's using fun arg2.\nSPECIAL-ALIST 0       Returns current SPECIAL variable binding env.\nSQRT          1       Square root of arg1.\nSTRING-APPEND any#    Makes a string out of a bunch of other strings.\nSTRING-APPENDL 1      Makes a string out of a list of other strings.\nSTRING-CAPITALIZE 1   Capitalizes words in a string.\nSTRING-DOWNCASE 1     Translates a string to all lowercase.\nSTRING-INDEX  2-3     (STRING-INDEX \"foobar\" \"bar\") ===> 4 (like PL/1)\nSTRING-LEFT-TRIM 2    Trims characters from arg1 off beginning of arg2.\nSTRING-LENGTH 1       Returns the length of a string.\nSTRING-REMOVE 2       Returns a string like arg2 but without arg1 chars.\nSTRING-REVERSE 1      Reverses a string.\nSTRING-RIGHT-TRIM 2   Trims characters from arg1 off the end of arg2.\nSTRING-SCAN   1-7     Converts a string into a list of tokens.\nSTRING-SUBSTR 1-3     (STRING-SUBSTR \"foobar\" 2 3) ===> \"oob\"\nSTRING-TRANSLATE 3    Translates a string from some chars to others.\nSTRING-TRIM   2       Trims characters from arg1 from both ends of arg2.\nSTRING-UPCASE 1       Translates a string to all uppercase.\nSTRING-VERIFY 2-3     (STRING-VERIFY \"123X4\" \"12345\") ===> 4 (like PL/1)\nSTRING        1       Takes string, symbol or fixnum and returns string.\nSTRINGP       1       T if arg 1 is a string, else NIL.\nSTRUCTP       1       T if arg 1 is a structure, else NIL.\nSTRUCTURE     any#    (STRUCTURE 'A 'B ...) makes a structure of type A.\nSUBLIS        2       Executes SUBST using elements of association list.\nSUBLISQ       2       Like SUBLIS but uses EQ test instead of EQL.\nSUBRP         1       T is arg is a compiled code SUBR object, else NIL.\nSUBST         3       (SUBST '1 '2 '(1 2 3)) ===> (1 1 3)\nSUBSTQ        3       (SUBSTQ 'A 'B '(A B C)) ===> (A A C)\nSUB1          1       Difference of argument - 1.\nSXHASH        1       The unique hash code for argument 1.\nSYMBOL-NAME   1       Returns symbol's print name string.\nSYMBOL-PLIST  1       Returns symbol's property list.\nSYMBOLP       1       T if argument is a symbol, else NIL.\nSYMEVAL       1-2     EVAL for dynamically bound atoms only.\nTABS          1-2     Sets tabs mode on or off in output file arg2.\nTAGBODY       any#    Evaluate forms with tags (labels) you can GO to.\nTAN           1       Tangent of arg1.\nTERPRI        0-1     Forces new line on output file.\nTHROW         2       Exits to CATCH that had tag arg1, returning arg2.\nTIME          any#    Displays CPU time used in evaluating forms.\nTIMES         any#    Product of all arguments.\nTOSTRING      1-2     Coerces arg 1 to a string.\nTRACE         any#    Activates tracing for selected functions.\nTRUNCATE      1-2     Converts floating point to integer.\nTSO           any#    Executes argument(s) as TSO command or CLIST.\nTTAB          1-2     Sets output file column to (arg 1 + 1).\nTYI           0-3     Reads a character from a file, returned as fixnum.\nTYIPEEK       0-4     Like TYI but does not update character pointer.\nTYO           1-2     Outputs character represented by fixnum arg2.\nTYPEP         1-2     Returns type of arg1, or T if arg1 is type arg2.\nUCONCAT       any#    (UCONCAT 'FOO 'BAR) ==> FOOBAR;uninterned symbol.\nUNEBCDIC      1       Takes EBCDIC character and returns fixnum.\nUNION         2       Set union of two lists.  Uses EQL test.\nUNIONQ        2       Set union of two lists.  Uses EQ test.\nUNLESS        2-any#  If arg 1 is NIL, evaluates all the other args.\nUNTRACE       0-any#  Deactivates tracing for all or selected functions.\nUNTYI         1-3     \"Unreads\" a character from a file read by TYI.\nUNWIND-PROTECT 1-any# Evaluates arg1 and forces execution of other args.\nUNWORD        1       Converts a 4-character symbol to a fixnum.\nUSERID        0       A string containing your TSO userid.\nVALUES        any#    Returns any number of multiple values.\nVALUES-LIST   1       Returns the elements of a list as multiple values.\nVCOPY         1       Copies a vector or structure.\nVECP          1       T if arg 1 is a vector, structure or funarg.\nVECTOR        any#    (VECTOR 'A 'B) makes a vector with elements A, B.\nVECTORP       1       T if arg 1 is a vector, else NIL.\nVFILL         2       Sets all elements of vector arg1 to arg2.\nVLENGTH       1       Number of elements (dimension) of a vector.\nVLIST         1       Makes a list out of a vector.\nVREF          2       Extracts an element from a vector.\nVSET          3       Updates an element of a vector.\nWARN          1-any#  Prints warning message.\nWHEN          2-any#  If arg 1 is not NIL, evaluates all the other args.\nWITH-OPEN-FILE any#   Opens a file, executes forms, closes the file.\nWORD          1-2     Converts a fixnum to a 4-character symbol.\nXCONS         2       (XCONS A B) <=> (CONS B A)\nXTAB          1-2     Increments output file column by arg 1.\nZEROP         1       T if atom is zero, else NIL.\nZGETFPI       0-1     Returns current column in input file.\nZGETFPO       0-1     Returns current column in output file.\nZPUTFPI       1-2     Sets current column to arg 1 in input file.\nZPUTFPO       1-2     Sets current column to arg 1 in output file.\n1+            1       Same as ADD1\n1-            1       Same as SUB1.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INIT": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x00\\x87&\\x0f\\x01\\x00&_\\t8\\x00\\x1c\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "2000-09-21T09:38:09", "lines": 28, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\n INIT files are optional.\n\n You can create an INIT file to be loaded into ZIL when you start up.\n\n You may wish to include the MSGLEVEL function, as follows:\n\n    (msglevel 0)   ; permits all messages to display\n    (msglevel 1)   ; the default, suppresses informational messages.\n    (msglevel 2)   ; suppresses informational and warning messages.\n    (msglevel 3)   ; suppresses all messages (not recommended!).\n\n To control the display of garbage collection messages, try:\n\n    (gcmsg nil)   ; suppresses all garbage collection messages\n    (gcmsg t)     ; lets you see garbage collection messages\n\n Each form in the INIT file is evaluated and the result is printed.\n Because of this, you can include messages in the INIT file as\n strings, which evaluate to themselves and thus cause themselves\n to be printed as the INIT file is loaded.\n\n To suppress messages from INIT file forms, you can enclose them\n in a PROGN, of which the last form is the only one whose value\n will be printed.\n\n INIT files cannot be compiled.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INT": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00@\\x00\\x86\\x02?\\x01\\x00&_\\t4\\x00d\\x00\\x91\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-23T00:00:00", "modifydate": "2000-09-21T09:34:40", "lines": 100, "newlines": 145, "modlines": 0, "user": "SEB1525"}, "text": "\n***********************************************************************\n*                                                                     *\n*        If you have the required ISPF setup for ZIL (CLIST, HELP,    *\n*        PANEL, MSG, SKEL), all you need to do to use ZIL is invoke   *\n*        the XZIL clist (from inside or outside of ISPF) to get to    *\n*        the ZIL primary option menu.  From there you can invoke      *\n*        the interpreter, call a compiled LISP program, or do a       *\n*        foreground or background compile.                            *\n*                                                                     *\n***********************************************************************\n\nTo run the ZIL interpreter, you may do either of the following:\n\n  (1) Use ISPF XZIL option 3.\n\n  (2) Use the LISP clist.\n\n*********************************************************************\n\nYou may find these LISP functions useful under the interpreter:\n\n  (END)  - terminates the interpreter \"cleanly\" by telling the\n           interpreter to terminate itself.  (END) must be coded by\n           itself, with no arguments, and cannot be generated by a\n           macro expansion.  Contrast this with (QUIT) and (EXIT),\n           which are executable ZIL functions.\n\n  (QUIT) - terminates the interpreter \"cleanly\" by simulating an\n           end-of-file condition on the input file (you can specify\n           an optional file name to simulate EOF on some other file,\n           but it won't kill the interpreter that way).\n\n  (EXIT) - terminates the interpreter \"dirtily\" by causing immediate\n           exit from LISP code back to the operating system.  An\n           optional return code specification on EXIT will set\n           the return code for the caller (e.g. (EXIT 12) sets the\n           return code to 12).\n\n  (HELP) - displays members of the on-line ZIL documentation\n           contained in 'PROGLIB.ZIL.TEXT'.\n           (HELP FUNCTIONS) will display a list of available LISP\n           functions.\n\n  (MSGLEVEL) - coded as is, displays the current message level.\n           Coded as (MSGLEVEL n), where n is a number between 0 and 3,\n           controls the display of ZIL messages at the terminal.\n           0, the initial default, allows all messages; 1 suppresses\n           informational messages, and 2 permits only error messages\n           to appear.\n\n  (PP  name) - pretty-prints the function definition of \"name\" to your\n               terminal.  (ZILPP 'name 'file) pretty-prints the\n               definition to output file \"file\".\n\n  (ED 'name) - pretty-prints the function definition of \"name\" to a\n               temporary LISP source dataset and enters ISPF EDIT to\n               allow you to edit it.  If there is no function\n               definition for \"name\", you are given a starting file\n               in which to create it.  After you save it, the newly\n               created definition is automatically reloaded into\n               your ZIL environment.\n\n               Note:  ED is available only under ISPF.\n\n\n*********************************************************************\n\n Some Helpful Features\n\n The following symbols are assigned values that are useful during an\n interpretive session:\n\n  *     always contains the last value returned from an evaluation by\n        the interpreter top-level.\n  **    contains the previous value of *.\n  ***   contains the previous value of **.\n\n  +     always contains the last form typed in at top level.\n  ++    contains the previous value of +.\n  +++   contains the previous value of ++.\n\n  -     contains the form currently being processed by the interpreter.\n\n\n*********************************************************************\n\n The \"Dribble\" Facility\n\nZIL has a \"dribble\" facility, which allows you to specify a file (which\ncan be a data set or a SYSOUT class) into which all terminal input and\noutput will be copied during a ZIL session.  To use it, simply specify\nthe DRIBBLE keyword on the LISP CLIST, or fill in the DRIBBLE\nspecifications on the XZIL option 3 panel.\n\n*********************************************************************\n\nUse the TSO HELP command for more information on the XZIL and LISP\nclists.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JCL": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x16\\x00\\x86\\x02?\\x01\\x00&_\\t7\\x00U\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-23T00:00:00", "modifydate": "2000-09-21T09:37:16", "lines": 85, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\n***********************************************************************\n*                                                                     *\n*        If you have the required ISPF setup for ZIL (CLIST, HELP,    *\n*        PANEL, MSG, SKEL), all you need to do to use ZIL is invoke   *\n*        the XZIL clist (from inside or outside of ISPF) to get to    *\n*        the ZIL primary option menu.  From there you can invoke      *\n*        the interpreter, call a compiled LISP program, or do a       *\n*        foreground or background compile.                            *\n*                                                                     *\n***********************************************************************\n\nTo run the ZIL interpreter in batch, you can use the following JCL:\n\n // ------- JOB statement ---\n //ZILPROC  JCLLIB ORDER=PROGLIB.ZIL.CNTL\n //MYRUN    EXEC   XZIL        (see optional parameters below)\n //SYSIN    DD *\n  (include your Lisp input here)\n /*\n\nYou can specify the following optional parameters on the EXEC statement:\n\n    INIT=        (name of INIT file)\n    ACSIZE=      (nnnM, nnnK or nnn)\n    CSSIZE=      (nnnM, nnnK or nnn)\n    PDSIZE=      (nnnM, nnnK or nnn)\n    VSSIZE=      (nnnM, nnnK or nnn)\n    SUBRLIB=     (load library containing compiled user functions)\n    SYS=         (SYS=N for new system, SYS=O for old system)\n\nNote: You must include a JCLLIB JCL statement to pick up the\n      XZILCO cataloged procedure, which resides in\n      'PROGLIB.ZIL.CNTL'.\n\nTo compile a LISP top-level program using the ZIL compiler...\n\n//AAA1234 JOB ...\n//ZILPROC JCLLIB ORDER=PROGLIB.ZIL.CNTL\n//PRGCMP  EXEC XZILCO,NAME=progname,PROG=P,\n//             SOURCE='AAA1234.xxx.LISP(member)', <== member req if PDS\n//             LOAD='AAA1234.xxx.LOAD'  <=== do not specify member name\n\nTo compile a LISP function using the ZIL compiler...\n\n//AAA1234 JOB ...\n//ZILPROC JCLLIB ORDER=PROGLIB.ZIL.CNTL\n//FUNCMP  EXEC XZILCO,NAME=progname,PROG=F,LP=NCAL,\n//             SOURCE='AAA1234.xxx.LISP(member)', <== member req if PDS\n//             LOAD='AAA1234.xxx.LOAD'  <=== do not specify member name\n\nTo compile a LISP module using the ZIL compiler...\n\n//AAA1234 JOB ...\n//ZILPROC JCLLIB ORDER=PROGLIB.ZIL.CNTL\n//FUNCMP  EXEC XZILCO,NAME=progname,PROG=M,LP=NCAL,\n//             SOURCE='AAA1234.xxx.LISP(member)', <== member req if PDS\n//             LOAD='AAA1234.xxx.LOAD'  <=== do not specify member name\n\nAdditional parameters optional:\n\n// MAC1='AAA1234.xxx.LISP(mymacros)'\n// MAC2='AAA1234.xxx.LISP(mymacros)'\n// MAC3='AAA1234.xxx.LISP(mymacros)'\n// MAC4='AAA1234.xxx.LISP(mymacros)'\n\ndefine your own LISP macros (and compiler directives) to be used at\ncompilation time.  Member names are required if partitioned data sets\nare specified.\n\n// SUB1='AAA1234.xxx.LOAD'\n// SUB2='AAA1234.xxx.LOAD'\n// SUB3='AAA1234.xxx.LOAD'\n// SUB4='AAA1234.xxx.LOAD'\n\ndefine your own compiled LISP subroutine libraries to resolve external\nreferences (i.e. compiled functions) in your source program at linkedit\ntime.  These must be load module libraries; member names are not\npermitted.  The SUBn parameters are meaningful for compilations of\nPROGRAMs only.\n\nNote: You must include a JCLLIB DD statement to pick up the\n      XZILCO cataloged procedure, which resides in\n      'PROGLIB.ZIL.CNTL'.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$LEXPR": {"ttr": 1298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87$_\\x00\\x87&\\x0f\\x07%\\x00\\x1c\\x00\\x16\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-02T00:00:00", "modifydate": "1987-09-17T07:25:00", "lines": 28, "newlines": 22, "modlines": 0, "user": "SEB1525"}, "text": "\nZIL supports Maclisp-style LEXPR's.  I.e., an EXPR with a non-NIL\natom in place of an arglist is considered to work like a LEXPR, in\nthat the atom is bound to a list of the (evaluated) arguments, and\nthe special form ARG is used to access the arguments.\n\nThe formal parameter x in (defun f x ...) is bound to the number of\narguments passed, not the arglist.\n\nThe following special forms are used to access LEXPR arguments:\n\n  (ARG)     ... returns the length of the list.\n  (ARG NIL) ... same as (ARG).\n  (ARG T)   ... returns the list itself (this is unique to ZIL!).\n  (ARG 1)   ... returns the first element of the list.\n  (ARG 2)   ... (etc.)  (ARG 0) et al. are errors.\n\n  (SETARG n frob) ... sets (ARG n) to frob.  n must be a valid fixnum.\n\n  (LISTIFY &optional n) ... returns the list of LEXPR args, if n is\n                            omitted or NIL.\n  (LISTIFY n), n positive, returns a list of the first n LEXPR args.\n  (LISTIFY n), n negative, returns a list of the last -n LEXPR args.\n\nThe scope of a LEXPR is lexical, much like GO and RETURN in PROG's.\nNote:  Use of the LEXPR-oriented special forms in funargs is not\nguaranteed to work outside of interpreted code.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MAP": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02?\\x00\\x87$_\\x15Q\\x00N\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-23T00:00:00", "modifydate": "1987-09-02T15:51:00", "lines": 78, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\n  The following discussion pertains to the ZIL \"mapping functions\",\n  which comprise the following:\n\n  MAPAND, MAPC, MAPCAN, MAPCAR, MAPCON, MAPL, MAPLIST, MAPOR.\n\n  ...and also to...\n\n  SOME, EVERY, NOTANY, NOTEVERY\n\n\n The function specified by the first argument must be one of the\n following:\n\n  A function name (a symbol with an EXPR or SUBR property).\n\n  A functional object (e.g. the value of the form (FUNCTION ...),\n  which can be written as #'...).\n\n  A LAMBDA-expression (a list whose CAR is the atom LAMBDA).\n\n In both cases, the specified function must take the same number of\n arguments as the number of lists specified (it may have optional\n additional arguments, but an n-argument call must be permissible\n where n is the number of lists specified).\n The argument is always evaluated when the function is applied; hence\n special forms, MACRO's, FEXPR's, and FSUBR's are not permitted.\n\n The behavior of a mapping function when it is passed the name of a\n MACRO may differ in the interpreted and compiled environments, but\n is an error in either case, and the results should not be relied\n upon.  It is an error to pass a mapping function the name of an\n FEXPR or FSUBR under the interpreter; the compiler does not support\n these, so the question is moot in the compiled environment.\n\n In the interests of generating efficient code for the mapping\n functions wherever possible, the specifications for the first\n argument are implemented differently in the compiled and interpretive\n environments.  In the interpretive environment, the first argument\n always EVALUATES to a valid function as described above, and is\n executed via APPLY.  In the compiled environment, when the first\n argument is CODED as either (QUOTE x) - 'x - or (FUNCTION x) - #'x -\n where x is a valid function name or LAMBDA-expression as defined above,\n an inline code loop is generated; otherwise a call to a run-time\n routine is generated which APPLY's the value of the first argument as a\n function.\n\n This raises an interesting point:  Technically the use of '(LAMBDA ...\n inhibits lexical scoping of variables referenced within the quoted\n lambda that are bound outside of it.  However, when the form is\n compiled, the LAMBDA is expanded inline anyhow, so lexical scoping\n is not inhibited.  This might be considered illegal, but we do it\n anyhow.\n\n Currently the compiler makes no distinction between (QUOTE x) and\n (FUNCTION x) in the first argument of a mapping function.\n Therefore, specifying (FUNCTION f) does NOT create a closure or\n other type of compiled code object in this context.\n\n The following are valid for both the compiler and the interpreter:\n\n (MAPCAR 'PRINT SOME-LIST)\n (MAPCAR #'(LAMBDA (X) (PRINT X)) SOME-LIST)\n (MAPCAR (FUNCTION CONS) SOME-LIST OTHER-LIST)\n (MAPCAR (QUOTE (LAMBDA (X Y) (CONS X Y))) SOME-LIST OTHER-LIST)\n (LET ((FUN-NAME 'PRINT))\n      (MAPCAR FUN-NAME SOME-LIST))\n\n The following are never valid (function takes wrong number of args):\n\n (MAPCAR 'CONS SOME-LIST)\n (MAPCAR #'(LAMBDA (X) (CONS X NIL)) SOME-LIST OTHER-LIST)\n\n All the arguments other than the function argument must be proper\n lists (NIL is permissible).  Atoms, dotted pairs and lists ending\n in dotted pairs are erroneous and may cause unpredictable results.\n Processing terminates as soon as the shortest list runs out.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$NEWS": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00\\x00\\x00\\x86\\x02?\\x00\\x89\\x05O\\x17Q\\x01\\x16\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "1986-01-23T00:00:00", "modifydate": "1989-02-23T17:51:00", "lines": 278, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "\n************************************************************************\n\n ZIL news entries are in chronological order, the latest first.\n\n Always check this member for updates and changes to the ZIL system.\n\n************************************************************************\n\n========================================================================\n===                                                                  ===\n===       ZIL CHANGES AVAILABLE IN NEW VERSION ONLY FOLLOW           ===\n===                                                                  ===\n========================================================================\n\n------------------------------------------------------------------------\n\n 02/23/89 - FLOOR, CEILING, TRUNCATE, ROUND RETURN MULTIPLE VALUES\n\n------------------------------------------------------------------------\n\nThe FLOOR, CEILING, TRUNCATE, and ROUND functions now return two values\nas documented in \"Common LISP: The Language\".  Note that the first value\nis the same as it ever was.\n\n\n========================================================================\n===                                                                  ===\n===       ZIL CHANGES INCORPORATED IN CURRENT VERSION FOLLOW         ===\n===                                                                  ===\n========================================================================\n\n------------------------------------------------------------------------\n\n 11/07/88 - ENHANCED TRACING FUNCTIONS\n\n------------------------------------------------------------------------\n\nThe following new functions (actually macros) are available in ZIL:\n\n  AT      - specifies processing done on entry to or exit from function\n\n  OFF     - cancels a previous AT request\n\nThese make it easier to set \"breakpoints\" at functions from which you\ncan execute arbitrary code to see what is going on.\nThe PUTDATA function is particularly useful with these new functions.\n\nSee members $TRACE, AT and OFF in this document for more information\n(type (HELP $TRACE) or (HELP AT) or (HELP OFF)).\n\n------------------------------------------------------------------------\n\n 09/16/88 - ISPF INTERFACE IMPROVEMENT\n\n------------------------------------------------------------------------\n\n Normally the ZISEXEC function (and Macsyma's ISPEXEC function)\n translates the entire ISPF dialog service request buffer\n to uppercase.  Now, however, this translation to uppercase is\n bypassed if the requested dialog service is the SELECT service.\n\n If the first seven characters of the dialog request are \"SELECT \"\n (or \"select \"), the buffer is left as is with respect to case.\n This permits commands or program parameters with lowercase data\n to be executed using the SELECT service.  If there are leading\n blanks or other junk preceding the word SELECT, though, the\n uppercase translation is still done.\n\n------------------------------------------------------------------------\n\n 06/22/88 - MULTIPLE VALUES NOW SUPPORTED IN ZIL\n\n------------------------------------------------------------------------\n\n ZIL now contains full support for multiple values, as documented in\n \"Common LISP: The Language\", pp. 133-139.  This consists of the\n following new functions, macros and special forms:\n\n   MULTIPLE-VALUE-BIND\n   MULTIPLE-VALUE-CALL\n   MULTIPLE-VALUE-LIST\n   MULTIPLE-VALUE-PROG1\n   MULTIPLE-VALUE-SETQ\n   VALUES\n   VALUES-LIST\n\n As a ZIL-only extension, the argument list of MULTIPLE-VALUE-BIND\n may contain destructuring templates in place of variable names.\n As a degenerate case of this, NIL works as a placeholder in the\n MULTIPLE-VALUE-BIND arglist for values you don't care about.\n\n As a side effect of this upgrade, THROW is now a special form rather\n than a function.  This was necessary in order to allow THROW to return\n multiple values.  Existing code which has THROW compiled as a\n function need not be recompiled (since existing code never tried\n to return multiple values from anything!).\n\n Note that although all of these work exactly as documented in CLtL,\n they may not be implemented the same way internally.  In particular,\n MULTIPLE-VALUE-LIST and MULTIPLE-VALUE-BIND are special forms in ZIL,\n and MULTIPLE-VALUE-CALL is a macro.\n\n The constant MULTIPLE-VALUES-LIMIT does not exist in ZIL, since ZIL\n doesn't support DEFCONSTANTs, but up to 4095 multiple values can be\n safely passed at all times, and more may be used in many cases.\n\n Not all the functions defined in Common LISP as returning more than\n one value do so at this time, but support in this area is forthcoming.\n\n The reader supports the return of zero values from a reader macro\n as signifying the return of \"nothing\".  This should be used instead\n of the old (RMNIL) function where possible, to maintain Common LISP\n compatibility.\n\n One more point:  If you're interested in using multiple values to get\n rid of some consing and processing time, think again.  Only the use of\n MULTIPLE-VALUE-BIND in compiled code is guaranteed to avoid consing,\n and in many cases the CPU time required to determine if multiple values\n should be returned may be greater than the time to CONS up a list of\n values.\n\n------------------------------------------------------------------------\n\n 06/22/88 - NEW SPECIAL FORMS: BLOCK, TAGBODY, RETURN-FROM\n            PROG, RETURN, PROG* (NEW) NOW MACROS, NOT SPECIAL FORMS\n\n------------------------------------------------------------------------\n\n The Common LISP special forms BLOCK, TAGBODY and RETURN-FROM are\n now implemented in ZIL.  Refer to Common LISP documentation for\n details of how these work.  Note that using GO, RETURN or\n RETURN-FROM to transfer control in a TAGBODY or BLOCK\n across \"funarg\" boundaries works under the interpreter but not\n under the compiler.\n\n These special forms are designed to replace PROG, which is considered\n archaic and stylistically poor.  PROG and RETURN have been converted\n from special forms to macros.  In addition, PROG syntax has been\n enhanced to support the full variable list syntax of Common LISP,\n and PROG* (the \"sequential binding\" version of PROG) is available\n as well.\n------------------------------------------------------------------------\n\n 04/11/88 - NEW \"PUTDATA\" MACRO TO ASSIST IN DEBUGGING\n\n------------------------------------------------------------------------\n\n A new macro, PUTDATA, has been added to ZIL.  This macro allows\n you to insert code in a LISP function to print out the values\n of any variables, function calls, or any other expressions that\n can be evaluated, in a format similar to that of the PL/1\n PUT DATA statement.  OK, it's not a real interactive debugger,\n but it helps a little.\n\n For more information, do (HELP PUTDATA), or see member PUTDATA\n of this documentation.\n\n------------------------------------------------------------------------\n\n 04/04/88 - \"ASSOC\" and \"MEMBER\" NOW 100% COMMON-LISP COMPATIBLE -\n            SUPPORT KEYWORDS :TEST, :TEST-NOT, :KEY\n\n------------------------------------------------------------------------\n\n The ASSOC and MEMBER functions now support the keyword syntax\n documented in the Common LISP manual.  Specifically, the :TEST,\n :TEST-NOT, and :KEY keywords work.  As part of this upgrade,\n ASSQ, MEMQ, ASSOC and MEMBER always compile into inline code\n (which they never did previously), and ASSQ and MEMQ have had\n minimal argument checking added in the interpretive versions.\n\n Note that the behavior of these functions under Macsyma has not\n changed, due to Maclisp compatibility requirements.\n\n------------------------------------------------------------------------\n\n 04/26/88 - \"HAULONG\" DEFINITION CORRECTED\n\n------------------------------------------------------------------------\n\n (HAULONG 0) formerly returned 1.  This was inconsistent with Maclisp\n and NIL, and has been corrected.  (HAULONG 0) now returns 0.\n There is a small possibility that some Macsyma code may have been\n affected by this bug.  Anyhow, it should be correct now.\n\n The documentation for HAULONG has been corrected as well.\n\n------------------------------------------------------------------------\n\n 02/26/88 - \"FORMAT\" UPGRADED - NOW COMPLETE AND CORRECT\n\n------------------------------------------------------------------------\n\n A new version of FORMAT has been installed.  This version is a 100%\n complete implementation of FORMAT as documented in Guy Steele's\n \"Common LISP: The Language\".  Furthermore, it corrects some errors\n in the old FORMAT's floating-point formatting routines.\n\n For more information, do (HELP FORMAT).\n\n------------------------------------------------------------------------\n\n 01/28/88 - \"TSO\" FUNCTION IMPROVED\n\n------------------------------------------------------------------------\n\n A new version of the TSO function has been installed.  Features:\n\n * XCLIST is no longer used.  Instead, all processing is contained\n   entirely within the ZIL code.\n\n * Commands that ABEND or are interrupted by attention result in\n   TSO signalling an error, rather than just returning a useless\n   return code.\n\n * There is no longer a problem with executing commands whose names\n   conflict with ZIL module names (e.g. PRINT).  TSO will always\n   search only the MVS link pack area and system link list for\n   commands.  This also means that STEPLIB and task libraries\n   are NOT searched for command names; use XCMD for that feature.\n\n * TSO commands that require APF authorization, as well as TEST,\n   are supported.  CALL to an APF authorized program, however,\n   will not.  Use XINVOKE or TSOEXEC in such cases.\n\n * The maximum length of a TSO command string is 32763, not 32767.\n   This was probably always true, but now the error is flagged\n   properly.\n\n------------------------------------------------------------------------\n\n 01/13/88 - NEW FUNCTIONS AND VARIABLES\n\n------------------------------------------------------------------------\n\n The following new functions have been added to ZIL:\n\n   (VCOPY x)             -  makes a copy of the vector or structure x.\n   (STRING-CAPITALIZE x) -  makes a copy of the string x with all\n                            words within the string capitalized.\n\n   Refer to the ZIL documentation for VCOPY and SCAPITAL,\n   or use the (HELP) function under ZIL, for more information.\n\n The following new global variables are present in ZIL:\n\n   *ZIL-SOURCE-LIBRARY*  -  a string containing the fully-qualified\n                            (but NOT single-quoted) name of the\n                            partitioned data set containing the\n                            source code for the ZIL system.\n\n   *ZIL-HELP-LIBRARY*    -  a string containing the fully-qualified\n                            (but NOT single-quoted) name of the\n                            partitioned data set containing the\n                            documentation for the ZIL system.\n\n Note that these variables return different values under the \"new\"\n (SYS=N) system and the current (SYS=) system.\n\n For more information, see member $SPECIAL of the ZIL documentation,\n or do (HELP $SPECIAL) under ZIL.\n\n------------------------------------------------------------------------\n\n 11/03/87 - ANNOUNCING ZIL 1.3\n            MORE COMPATIBLE WITH COMMON LISP, BUT LESS COMPATIBLE\n            WITH ZIL 1.2 - RECOMPILE EVERYTHING\n            FULL LEXICAL SCOPING - CHECK USE OF VARIABLES\n            DOUBLE PRECISION FLOATING POINT IS THE DEFAULT\n            NEW INTERPRETER, COMPILER, OPS5, MACSYMA ALSO INSTALLED\n------------------------------------------------------------------------\n\n ZIL 1.3 is here!  For more information, consult 'PROGLIB.ZIL.TEXT'.\n\n Member $CHANGES tells what's different.\n Type (HELP $CHANGES) under ZIL 1.3 to see this information.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$OPTIONS": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02?\\x00\\x86\\x10o\\x18\\x04\\x00\\x08\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-23T00:00:00", "modifydate": "1986-04-16T18:04:00", "lines": 8, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\n Compilation options may be specified by the programmer via DECLARE.\n See member DECLARE for full explanation.\n\n Initialization options may be specified in the PARM field by\n enclosing them between backslashes at the beginning of the PARM\n string.  See member $PARM for full explanation.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PARM": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x10o\\x00\\x88\\x02\\x9f\\tV\\x00o\\x00\\x12\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-04-16T00:00:00", "modifydate": "1988-01-29T09:56:00", "lines": 111, "newlines": 18, "modlines": 0, "user": "SEB1525"}, "text": "\nProcessing of Run-time Parameters at Initialization Time\n\n\n You may pass a PARM string to your program; the GETPARM function will\n retrieve it and make a symbol out of it.  Note that if no PARM string\n is specified, GETPARM returns the null symbol (printed as ||).\n\n The parameter value may be passed as a JCL-style PARM string (in\n batch or via the CALL or XINVOKE command) or as TSO command operands\n via XCMD.  If it is passed in the latter fashion, any leading blanks,\n commas or /* ... */ sequences are ignored.  However, there is no\n 100-character limitation imposed by MVS as there is for JCL-style\n PARM passing.\n\n If the parameter string begins with a backslash character \"\\\", then\n special processing is done:  the portion of the parameter up to the\n second backslash character is ignored by GETPARM, and the information\n between the backslashes (if any) is processed at ZIL initialization\n time.  The syntax is as follows:\n\n  \\keyword=value,keyword=value...\\\n\n For all keywords defined here, \"value\" must be a number, optionally\n ending in the letter K or M.  If it ends in K, it represents the\n value of the numeric portion multiplied by 1024; if it ends in M,\n it represents the value of the numeric portion multiplied by 1048576\n (e.g. 4K = 4096; 1M = 1024K).\n\n Keywords may be abbreviated to as little as 1 letter; e.g.\n V=2M is the same as VSS=2048K or VSSIZE=2097152.\n\n The following keywords are recognized:\n\n  PDSIZE=value - specifies the size of the push down stack to be\n     allocated at initialization time.  If this is omitted, the default\n     value of 65536 (64K) is used.\n\n     This space is allocated above 16 megabytes if possible.\n\n  CSSIZE=value - specifies the size of the CONS space (\"free list\") to\n     be allocated at initialization time.  If this is omitted, the\n     default value of 4 megabytes (4096K) is used.\n\n     Lists (conses), fixnums, single-floats, and the header portions\n     of executable objects are allocated in this space.\n\n     This value represents the TOTAL allocation, not to be confused\n     with the initial ACTIVE size of the space - see ACSIZE below.\n\n     This space is allocated above 16 megabytes if possible.\n\n  ACSIZE=value - specifies the size of the CONS space (\"free list\") to\n     be considered active initially.  If this is omitted, the\n     default value of 2 megabytes (2048K) is used.\n\n     This value controls how much of the total CONS space (as specified\n     by CSSIZE) is in use, until it is determined (by the garbage\n     collector) that more space is needed, at which time the ACSIZE\n     value is doubled, provided that it does not exceed the CSSIZE\n     value.  Thus, this is the only one of the values described here\n     that can change during execution.\n\n  VSSIZE=value - specifies the size of vector/string space (the space\n     used to build symbols, vectors, strings, double-floats, bignums and\n     structures) to be allocated at initialization time.  If this is\n     omitted, the default value of 1 megabyte (1024K) is used.\n\n     Note that this space is allocated in duplicate, due to the copying\n     garbage collection scheme used for this space in ZIL.  Thus in\n     actuality twice the specified value is required.\n\n     This space is allocated above 16 megabytes if possible.\n\n  Note:\n\n     When ZIL runs in a non-XA system, for each DDNAME of the form\n     ZILIxxxx or ZILOxxxx found to be allocated at ZIL initialization\n     time, whether or not it is eventually referenced as a ZIL file, an\n     additional 32K is reserved for operating system functions so that\n     if the files need to be opened, sufficient memory will be\n     available.\n\nExamples:\n\n You could invoke the interpreter on TSO as follows:\n\n  CALL 'PROGLIB.ZIL.LOAD(ZILIN)' '\\C=3M,VSSIZE=800K,PD=65536\\initfile'\n\n where initfile is the name of your INIT file.\n\n Or you could use the PDSIZE, CSSIZE, ACSIZE, and VSSIZE operands on the\n XZINT CLIST.\n\n If you want to be able to access your own compiled functions,\n you could do the following:\n\n  ALLOC FILE(ZILLIB) DA(my.load.library) SHR REU\n  XINV ZILIN '\\CSSIZE=3072K,V=8192,PDS=64K\\my.init.file' +\n       LIB('PROGLIB.ZIL.LOAD') FILE(ZILLIB)\n\n In both of the above cases, the function call (GETPARM T) would\n return the symbol |my.init.file|.  The contents of the PARM string\n are used by the particular ZIL program in different ways;  the\n interpreter, the compiler, OPS5 and Macsyma all use the PARM string\n for their own purposes.\n See the help for GETPARM for more information.\n\n Note: These examples do not include redirection of standard input\n       and output, or use of a dribble file.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PRINTER": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x18\\x9f\\x00\\x88\\x02\\x9f\\tV\\x00.\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1988-01-29T09:56:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\n  ZCPRINT is the low-level interface to the \"current ZIL printer\",\n  called by PRINC, PRIN1, CTERPRI, TERPRI and TYO.\n\n  ZDPRINT is the \"default ZIL printer\", set to be the \"current ZIL\n  printer\" at ZIL initialization time but not otherwise called by\n  built-in ZIL code.\n\n  ZILSPRT is the low-level function that takes a SUBR argument and makes\n  it the new \"current ZIL printer\".\n\n  SETPRT is the function that takes any function object and causes it to\n  be the new \"current ZIL printer\".\n\n  Any function which is to act as the \"current ZIL printer\", including\n  ZCPRINT and ZDPRINT, takes three required arguments:\n\n  arg 1 = the object to be printed, if applicable.\n  arg 2 = the file to print it on.\n  arg 3 = a fixnum built from the following boolean values:\n\n       ..00  =  print a character object (TYO)\n       ..01  =  print a LISP object (PRINC/PRIN1)\n       ..10  =  control, not print (CTERPRI/TERPRI)\n       .x..  =  0 = don't slashify, 1 = slashify\n       x...  =  0 = unconditional, 1 = conditional\n\n  The following ZIL printing functions are defined as follows:\n\n   (DEFUN TYO     (X &OPTIONAL F) (ZCPRINT X F #b0000))  ; arg 3 =  0\n   (DEFUN PRINC   (X &OPTIONAL F) (ZCPRINT X F #b0001))  ; arg 3 =  1\n   (DEFUN PRIN1   (X &OPTIONAL F) (ZCPRINT X F #b0101))  ; arg 3 =  5\n   (DEFUN TERPRI  (  &OPTIONAL F) (ZCPRINT X F #b0010))  ; arg 3 =  2\n   (DEFUN CTERPRI (  &OPTIONAL F) (ZCPRINT X F #b1010))  ; arg 3 = 10\n\n  PRINT and PRINTC are built on calls to the above ZIL functions.\n  All ZIL code that calls these functions is affected by the setting\n  of the \"current ZIL printer\".\n\n  All output is affected except:\n\n  * Error messages from ZIL functions (except for functions written\n    in LISP)\n\n  * System messages like GC messages\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PROP": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x87%\\x1f\\x00\\x88\\x02\\x9f\\tX\\x00\\xce\\x00\\x83\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1987-09-08T00:00:00", "modifydate": "1988-01-29T09:58:00", "lines": 206, "newlines": 131, "modlines": 0, "user": "SEB1525"}, "text": "\n PROPERTY LISTS\n\n A property list is a list of an even number of elements (zero or more)\n of alternating \"indicators\" and \"values\".  The indicators are, in\n general, symbols (although in theory they could be anything), while\n the values are any kind of LISP object.\n\n A property list is typically stored in the property list cell of a\n symbol; however, there are also \"disembodied property lists\", which\n are lists whose CDR is a property list as described above.  Thus,\n a disembodied property list always has an odd number of elements.\n\n Property lists are destructively updated by replacing the value\n elements associated with the preceding indicators, or by splicing a\n new indicator/value pair onto the end.  Therefore, using a constant\n (quoted) list as a property list is a very bad idea.\n\n If a property list processing function encounters an invalid\n property list (odd number of elements, or not a proper list),\n an error is signalled.\n\n In the descriptions of functions below, the term \"place\" refers to\n either a symbol, in which case the property list stored in the\n symbol's property list cell is used, or a list, in which case the\n list is treated as a disembodied property list (i.e. the CDR of\n the list).  If \"place\" is not a symbol or a list, then an error is\n signalled, except where otherwise indicated.\n\n The following functions are used to access property lists:\n\n  (GET place indicator &optional defaultvalue)\n\n   returns the value associated with \"indicator\" on the property list\n   stored in \"place\".  If there is no \"indicator\" on the property list,\n   \"defaultvalue\" (NIL if omitted) is returned.\n\n  (PUTPROP place value indicator)\n\n   modifies the property list stored in \"place\" by assigning the\n   \"indicator\" the specified \"value\".  If \"indicator\" is already\n   on the property list, its current value is replaced by \"value\".\n\n  (SETF (GET place indicator) value) is equivalent to the above\n   use of PUTPROP, and is the accepted Common Lisp way of setting\n   properties.\n\n  (REMPROP place indicator)\n\n   removes the indicator-value pair specified by \"indicator\" from\n   the property list stored in \"place\".  It does NOT assign a\n   default value to \"indicator\".\n\n  (SYMBOL-PLIST symbol)\n   or\n  (PLIST symbol)\n\n   returns the entire property list stored in the property list cell\n   of \"symbol\", which must be a symbol.\n\n  (SETPLIST symbol plist)\n   or\n  (SETF (SYMBOL-PLIST symbol) plist)\n\n   takes the property list \"plist\" and stores it in the property list\n   cell of \"symbol\", which must be a symbol.  No validity checking\n   is done on either the old or new property list.  This function\n   should generally NOT be used.\n\n  (GETL place indicator-list)\n\n   searches the property list stored in \"place\" for one of the\n   indicators specified in \"indicator-list\" and returns the\n   sublist of the property list starting with that indicator.\n   The found indicator is the CAR of the return value, and the\n   associated value is the CADR thereof.\n\n  (GETK place keyword)\n\n   is a specialized form of GET that is used to search a function\n   argument list for keyword values.  It is not generally used on\n   property lists per se.\n\n  For GET and GETL, if \"place\" is neither a symbol nor a list, a warning\n  message is issued and the default value is returned.  This is\n  necessary for compatibility with Maclisp, and is required for Macsyma\n  to work.\n\n  For more information on these and other functions that manipulate\n  property lists, see the members of this documentation that describe\n  the individual functions.\n\n  The indicators on property lists may be, in general, any interned\n  symbol.  However, the following property indicators are used by the\n  ZIL system itself and have special meanings.  Using these as property\n  indicators can have untoward outcomes.\n\n   ARRAY  - the structure which implements the Maclisp-compatible-array\n            definition of a symbol, placed there by *ARRAY, for example.\n\n   ARRAY-SAVE-ARRAY - used to \"push down\" existing ARRAY properties\n            when a Maclisp-compatible array is redefined.\n\n   ARRAY-SAVE-SUBR - used to \"push down\" existing function definitions\n            when a Maclisp-compatible array is redefined.\n\n   AUTOLOAD - a value which tells the ZIL system how to locate the\n              function definition of a symbol that doesn't have one yet.\n\n   AUTOVALUE - a value which tells the ZIL system how to locate the\n               global value of a symbol that doesn't have one.  This is\n               known as \"symbol-autoloading\", a feature unique to ZIL.\n\n   DOCUMENTATION - used to store the \"documentation string\" associated\n             with a symbol via DEFVAR (but not DEFUN at this time).\n\n   EXPR   - the interpreted definition of a function associated with\n            a symbol, placed there by DEFUN, for example.\n\n   FEXPR  - the interpreted definition of a FEXPR associated with\n            a symbol, placed there by DEFUN, for example.\n\n   FLAVOR - the structure which defines the symbol as a flavor, placed\n            there by DEFFLAVOR, for example.\n\n   LOADFILE - the name of the file from which a function definition was\n            loaded, placed there by DEFUN, for example.\n\n   MACRO  - the macro definition associated with a symbol, placed\n            there by DEFMACRO, for example.\n\n   SETFMETHOD - the function used by the SETF macro to transform SETF\n            calls for that function into the appropriate code sequence.\n\n   SHARPMACRO - a function used by the reader to process the \"#\"\n            dispatch character for reader macro characters defined\n            by the user.\n\n   SPECIAL - if non-null, indicates that the symbol with this property\n             has been declared SPECIAL under the interpreter.  This is\n             not used by the compiler.\n\n   |SPECIAL FORM| - if non-null, the symbol with this property is\n            defined as a special form to ZIL.  You cannot create\n            your own special forms; processing of special forms\n            is embedded in various parts of the ZIL system.\n\n   SUBR   - the compiled code definition of a function associated with\n            a symbol, placed there automatically by the ZIL system.\n\n   ZIL-NO-AUTOLOAD - if non-null, indicates that the symbol with this\n              property has been determined to be undefined and that ZIL\n              should not try to autoload it again.\n\n   ... et al. ...\n\n The following properties are used by the ZIL compiler:\n\n   CAUTOLOAD - a value which tells the compiler how to locate the\n              function definition of a symbol that doesn't have one yet.\n\n   CEXPR  - the function definition of a symbol placed there when the\n            compiler sees a DEFUN.\n\n   CMACRO - the macro definition of a symbol placed there when the\n            compiler sees a DEFMACRO.\n\n   COMPILER-TRANSFORM - the compiler transform function associated\n            with a symbol, placed there by DEFTRANS, for example.\n\n   DEFINED-BY - tells the compiler whether a function the compiler\n                knows about is defined by the system or not.\n\n   LEXPRARG - tells the compiler whether a function the compiler\n              knows about is a LEXPR.\n\n   MAXARGS - tells the compiler the maximum number of arguments\n             that can be passed to a function the compiler knows about.\n\n   MINARGS - tells the compiler the minimum number of arguments\n             that can be passed to a function the compiler knows about.\n\n   RESTARG - tells the compiler whether you can pass a &REST arg\n             to a function the compiler knows about.\n\n In addition to the above, properties whose names begin with the\n characters DEFSTRUCT are reserved for use by DEFSTRUCT, and\n property names beginning with the characters ZIL are also\n reserved.  (In this context, \"reserved\" means you can use them\n but you're likely to break the system if you do.)\n\n Furthermore, many property names are used internally by the\n compiler.  If you execute code at compile time (i.e. using the\n EVAL-WHEN special form), you must be careful not to rely on\n specific property indicators, since these may conflict with the\n ones used by the compiler, and confuse the compiler.\n\n\n The following SYMBOLS use their property lists in system-dependent\n ways.  Putting properties on these symbols may affect the system\n in ways that you wouldn't expect.\n\n  *FLAVORS*     - used by the FLAVORS system.\n  *READERMACRO* - used to store reader macro definitions.\n  *ZILCO*       - used to store compiler attributes.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$READER": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x881?\\x00\\x882\\x8f\\x08(\\x00<\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-11-08T00:00:00", "modifydate": "1988-11-23T08:28:00", "lines": 60, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\n  ZCREAD is the low-level interface to the \"current ZIL reader\",\n  called by READ, TYI, TYIPEEK, READLINE, and many other routines.\n\n  ZDREAD is the \"default ZIL reader\", set to be the \"current ZIL\n  reader\" at ZIL initialization time but not otherwise called by\n  built-in ZIL code.\n\n  ZILSRD is the low-level function that takes a SUBR argument and makes\n  it the new \"current ZIL reader\".\n\n  SETREAD is the function that takes any function object and causes it\n  to be the new \"current ZIL reader\".\n\n  Any function which is to act as the \"current ZIL reader\", including\n  ZCREAD and ZDREAD, takes six required arguments:\n\n   arg 1 = the file to read from.\n   arg 2 = a fixnum built from the boolean values listed below.\n   arg 3 = miscellaneous function-dependent data (e.g. char operand).\n   arg 4 = eof-error-p.\n   arg 5 = eofval.\n   arg 6 = recursive-p.\n\n  Arg 2 values are made up from the following bit settings:\n\n  00000000  =  Read an S-expression (READ)\n  .....001  =  Read a character (TYI)\n  .....010  =  Unread a character (UNTYI)\n  .....011  =  Peek a character (TYIPEEK)\n  .....100  =  Intern a character (READCH)\n  .....110  =  Intern a character (PEEKCH)\n  ....1...  =  EOF request\n  ...1....  =  EOL (newline) request\n  ..1.....  =  1 = set EOF/EOL, 0 = test EOF/EOL\n  .1......  =  Read a line of data (READLINE)\n  1.......  =  Readtable functions\n  1......1  =  Set reader macro\n  1.....1.  =  Set MACLISP readtable\n  1....1..  =  Return reader macro character\n\n\n  Sample calling sequence:\n\n   (defun read (&optional file eoferp eofval recurp)\n          (zcread file #b0000000 nil eoferp eofval recurp))\n\n  There are many others, not listed here.  Note that even the one\n  above may not be the one in use in the present ZIL, depending on\n  whether we want the Maclisp READ or the Common Lisp READ.\n\n  All input functions are built on calls to the above ZIL functions.\n  All ZIL code that calls these functions is affected by the setting\n  of the \"current ZIL reader\".\n\n  All input is affected except:\n\n  * Responses to ZIL attention prompts (these always come from the\n    terminal)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "$RMACRO": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x86\\x02O\\x00\\x90\\x17\\x1f\\t\\x01\\x01\\x04\\x00\\xd6\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1990-06-20T09:01:00", "lines": 260, "newlines": 214, "modlines": 0, "user": "SEB1525"}, "text": "\n    The ZIL reader macro facility defines special syntaxes for\n    particular special characters.  The RDRMACRO and\n    DEFRDMAC functions may be used to define new reader macros.\n\n Reader macro definitions for the following characters are predefined:\n\n ' (single quote)\n ` (backquote)\n , (comma)\n # (sharp sign)\n\n The sharp sign (#) reader macro dispatches on the character following\n in the input stream.  The functions for the following combinations\n are predefined.\n\n (Note:  Where it says that something \"returns\" something, that means\n         that it is returned to the reader, as if you had typed in\n         that value directly; the resulting form is then processed by\n         the interpreter.  Thus, #'A --> (FUNCTION A) --> <#FUNARG A>.)\n\n  #' (single quote) - #'A returns (FUNCTION A).\n  #. (period)       - #.A returns the result of evaluating A.\n  #+ (plus sign)    - #+A reads the next object if A is a \"feature\".\n  #- (minus sign)   - #-A skips the next object if A is a \"feature\".\n  #\\ (backslash)    - #\\A returns the fixnum equivalent of A.\n  #/ (slash)        - #/A is the same as #\\A, for Maclisp compatibility.\n  #| (vertical bar) - #| ... |# is a comment sequence (can be nested).\n  #( (left paren)   - #(foo etc) returns a vector containing foo, etc.\n  #x, #X            - #xnnn returns an integer equal to hex nnn.\n  #o, #O            - #onnn returns an integer equal to octal nnn.\n  #b, #B            - #bnnn returns an integer equal to binary nnn.\n  #r, #R            - #mmrnnn returns an integer equal to what nnn means\n                      in radix mm.\n  #z, #Z            - #znnn returns a FIXNUM equal to hex nnn, where nnn\n                      might be two's complement value.\n\n  Note: #\u00ac (ASCII control-<char>) and #, (load-time evaluation)\n        are quasi-supported but do not generate anything useful.\n\n Other \"dispatching\" characters may be activated by placing a function\n (something that can be APPLY'ed) on the SHARPMACRO property of the\n character.  The function works the same way as one used for DEFRDMAC,\n except that the (RMCHAR) function will return # and not the\n dispatching character.\n\n\n    The following system-defined reader macros are available:\n\n\n    ' (quote mark) - wraps (QUOTE ...) around the next item read.\n                     Examples:    'FOO --> (QUOTE FOO)\n                                  '(A B C) --> (QUOTE (A B C))\n\n\n    ` (backquote)  - the Common LISP backquote syntax, complete\n                     with commas.  The , ,@ ,. syntaxes are all\n                     supported.  Useful with macro definitions.\n                     Refer to any Maclisp or Common LISP manual\n                     for a complete description of backquoting.\n\n     The form that the backquote generates is significant when\n     it is EVALUATED.  What it generates at READ time should not\n     be depended upon, and is not relevant.\n\n     Examples:  (assume the value of B is the list (FOO BAR))\n                `(A B C) evaluates to the list (A B C).\n                `(A ,B C) evaluates to the list (A (FOO BAR) C).\n                `(A ,@B C) evaluates to the list (A FOO BAR C).\n\n     Backquotes (along with commas) are extremely useful in coding\n     macro expansion functions or other functions that build LISP\n     programs or other lists where most of the elements are constant.\n\n\n    , (comma) - valid only within a backquoted form (see above).\n\n\n    # (sharp sign) - the currently predefined uses for this are:\n\n       #' (with quote mark) - wraps (FUNCTION ...) around the next\n                              item read.  Examples:\n\n            #'FOO --> (FUNCTION FOO)\n            #'(LAMBDA (X) X) --> (FUNCTION (LAMBDA (X) X))\n\n       #.  (with period) - evaluates the next item read and returns\n                           its value, as if the value had been in\n                           the input stream.\n\n           Example:  #.(LIST 'A 'B 'C) --> (A B C)\n\n       The following two syntaxes are used to select items based on\n       the presence or absence of a \"feature\".  A feature FOO is\n       said to be present if the symbol FOO is on the list which\n       is the value of the symbol *FEATURES*.\n\n       This is intended to be used with code ported to multiple\n       LISP installations; you must activate the desired feature(s)\n       using PUTPROP or SETF yourself.\n\n       #+  (with plus sign)  - if the next item read is a \"feature\",\n                               then returns the item after that,\n                               otherwise returns nothing.\n\n       #-  (with minus sign) - if the next item read is NOT a feature,\n                              then returns nothing,\n                              otherwise returns the item after it.\n\n       A \"feature\" in this context is one of the following:\n\n       (1) An atom which is a member of the value of *FEATURES*.\n       (2) A list (OR feat1 feat2 feat3 ...), such that at least one\n           of the \"featn\"'s is a \"feature\".\n       (3) A list (AND feat1 feat2 feat3 ...), such that all of the\n           \"featn\"'s are \"features\".\n       (4) A list (NOT feat1) where feat1 is NOT a \"feature\".\n\n       The following features are currently present in ZIL:\n\n       ZIL ZIL13 GC BIGNUM MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP\n\n       ... and, depending on the installation, some or all of:\n\n       CSDL DRAPER TSO MVS XA VF\n\n       In addition, under the interpreter, there is a ZILIN feature;\n       under the compiler, there is a ZILCO feature;\n       under OPS5, there is an OPS5 feature;\n       under MACSYMA, there is a MACSYMA feature.\n\n       #/  (with slash) or\n       #\\  (with backslash) - returns the fixnum equivalent of whatever\n                              follows.  If it is one of the following,\n                              it returns the corresponding fixnum:\n\n          NULL             0     (i.e. hex 00)\n          HT, TAB          5     (i.e. hex 05)\n          DEL, RUBOUT      7     (i.e. hex 07)\n          VT              11     (i.e. hex 0B)\n          CR, RETURN      13     (i.e. hex 0D)\n          NL, NEWLINE     21     (i.e. hex 15)\n          BS, BACKSPACE   22     (i.e. hex 16)\n          LF, LINEFEED    37     (i.e. hex 25)\n          FF, FORM, PAGE  44     (i.e. hex 2C)\n          SP, SPACE       64     (i.e. hex 40)\n          ALT, ALTMODE   256     (an \"invalid\" value)\n\n           Otherwise, the EBCDIC equivalent of the character\n           immediately following the / or \\ is returned.\n\n      Examples:    #/a     is the same as the fixnum 129\n                   #/A     is the same as the fixnum 193\n                   #/SPACE is the same as the fixnum 64\n\n      #\u00ac (with logical not sign) - returns 256 plus the EBCDIC\n                                   equivalent of the character\n                                   immediately following.\n\n                                   (This is subject to change.)\n\n      This is supposed to provide an approximation of the ASCII\n      (control-{character}) character type, which of course has no\n      meaning in EBCDIC.  It is provided to make LISP code developed on\n      ASCII systems portable.\n\n      #| ... |# - denotes a comment sequence.  This is similar to PL/1's\n      /* ... */, EXCEPT that the #| ... |# syntax can be NESTED.  This\n      makes it easier to surround blocks of code (which may already\n      contain comments) with a bigger comment block.\n\n      The following syntaxes all return INTEGERS, but allow them to\n      be specified in a base other than 10.\n\n      #o or #O - treats the following characters as octal digits\n                 (0 through 7 only) and builds an integer.\n\n      #x or #X - treats the following characters as hexadecimal digits\n                 (0-9, a-f, A-F) and builds an integer.\n\n      #b or #B - treats the following characters as binary digits\n                 (0 and 1 only) and builds an integer.\n\n      #36r or #36R - treats the following characters as base-36\n                 digits (0-9, a-z, A-Z) and builds an integer.\n                 Any numeric base between 2 and 36 inclusive may\n                 be specified using this syntax, and only the\n                 appropriate alphanumeric digits may be used.\n\n      In other words, #b... is equivalent to #2r...\n                      #o... is equivalent to #8r...\n                      #x... is equivalent to #16r...\n\n      The following holds for all the above:\n\n        Alphanumeric characters which are not valid in the specified\n        base are flagged as errors.  The digits must be terminated by\n        a valid delimiter character (or end of line).\n\n        An optional + or - sign can occur between the radix\n        specification and the digits.\n\n        Overflow cannot occur.  Since the result may be any precision\n        (i.e. a \"bignum\" is possible), #xFFFFFFFF reads as 4294967295,\n        not -1.  However, #x-FF (for example) would read in as the\n        integer -255.\n\n        Note:  The above is a major difference between ZIL 1.2 and\n               ZIL 1.3, and is consistent with Common Lisp.\n\n      #z or #Z - is like #X except that it always builds a FIXNUM.\n                 A maximum of 8 hex digits can be specified, and\n                 a sign is not permitted.  The value may be in\n                 two's complement notation.  This format, a ZIL-only\n                 extension, is used to type in hex fixnums, and works\n                 the way #x used to do in ZIL 1.2.\n\n      For example, #xFFFFFFFF = the integer 42\n               but #zFFFFFFFF = the integer -1\n\n      #( (left parenthesis) - returns a vector.  The vector can contain etc.\n                              any number of elements from zero to the\n                              maximum for which vector/string space is\n                              available to build the vector.  The\n                              dimension of the vector is equal to the\n                              number of elements in the vector.  The\n                              elements can be any LISP object, including\n                              other vectors.\n\n       The values within the vector are not evaluated.\n\n       Example: #(1 2 (A B) #(C) \"foo\") returns a vector of 5 elements.\n\n       Note:  This construct cannot be compiled.  Vectors must be\n              built dynamically using the VECTOR or MKVECTOR function\n              in compiled code.\n\n\n       Other \"dispatching\" characters may be activated by placing a\n       function (something that can be APPLY'ed) on the SHARPMACRO\n       property of the character.  The function works the same way as\n       one used for DEFRDMAC, except:\n\n       (1) it takes 2 arguments - the file object and the numeric\n           modifier (NIL if none) between the # and the character.\n\n       (2) the (RMCHAR) function will return # and not the dispatching\n           character.\n\n       Note that the dispatch character in question will be the first\n       character read by READ/READCH/TYI.  If you wish to ignore it,\n       just issue (TYI f), where f is the 1st argument to the function,\n       as the first form, and it will be thrown away.\n\n\n If you wish to define your own reader macros, you may refer to the\n documentation for the functions DEFRDMAC, RDRMACRO, RMCHAR and RMNIL\n for more information.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SFORMS": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x880\\x9f\\x00\\x880\\x9f\\x07&\\x00&\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-04T00:00:00", "modifydate": "1988-11-04T07:26:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\n The following are the special forms in Zil:\n\n     AND\n     ARG\n     BLOCK\n     CATCH\n     COND\n     DECLARE\n     DEFLOAD\n     DEFUN\n     DEFVAR\n     EVAL-WHEN\n     FUNCTION\n     GO\n     LISTIFY\n     MULTIPLE-VALUE-BIND\n     MULTIPLE-VALUE-LIST\n     OR\n     PROGN\n     QUOTE\n     RETURN-FROM\n     SETARG\n     SETQ\n     SUBR\n     TAGBODY\n     THROW\n     UNWIND-PROTECT\n\n Note that PROG and RETURN, which used to be special forms, are\n now macros.\n\n Not all of these are special forms in Common Lisp.  Also, some\n Common Lisp special forms are implemented as macros in Zil.\n For this reason, it is more accurate to call Zil \"Common Lisp\n compatible\" than a Common Lisp implementation, if strict legality\n is at stake.  This may change in the future.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SPECIAL": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87(o\\x01\\x00&_\\tP\\x00C\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-10-13T00:00:00", "modifydate": "2000-09-21T09:50:00", "lines": 67, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\n The following global SPECIAL variables are defined to ZIL at\n initialization time.  Note that to bind these, you MUST include\n a SPECIAL declaration for them - ZIL will not assume they are\n SPECIAL otherwise.\n\n\n  *version*            - a string identifying the current version\n                         of ZIL (i.e., \"1.3\").\n\n  *features*           - a list of symbols naming \"features\"\n                          (see FEATUREP for more info).\n\n  *load-verbose*       - the default value of the :VERBOSE keyword\n                         used by the LOAD function (q.v.).\n\n  *loadfile*           - identifies the current file being loaded,\n                         for a function's LOADFILE property.\n\n  *trace*              - used internally by TRACE.\n  *trace-indent*       - used internally by TRACE.\n  *gentemp-counter*    - used internally by GENTEMP.\n  *mxsetf-initialized* - used internally by SETF.\n\n  *zil-source-library* - a string identifying the library containing\n                         ZIL LISP source code, used by the\n                         (zil-source-member ...) macro to load or\n                         include source members.  The default is:\n\n                           \"PROGLIB.ZIL.LISP\"  -  production\n                           \"PROGLIB.ZIL.NLISP\" -  test\n                           \"PROGLIB.ZIL.OLISP\" -  backup\n\n                         Note that the string, although containing a\n                         fully qualified data set name, does not\n                         contain single quotes.  This is to make it\n                         easier to construct a dsname(member) string.\n\n  *zil-help-library*   - a string identifying the library containing\n                         ZIL help information, used by the ZILHELP\n                         function (and, by extension, HELP).\n                         Changing this changes the library from which\n                         HELP fetches its members.  The default is:\n\n                           \"PROGLIB.ZIL.TEXT\"  -  production\n                           \"PROGLIB.ZIL.NTEXT\" -  test\n                           \"PROGLIB.ZIL.OTEXT\" -  backup\n\n                         Note that the string, although containing a\n                         fully qualified data set name, does not\n                         contain single quotes.  This is to make it\n                         easier to construct a dsname(member) string.\n\n  *zil-panel-library*  - a string identifying the library containing\n                         ZIL ISPF panels, used by the ZFSEXEC function.\n                         Changing this changes where the ISPF interface\n                         finds the default panels.  The default is:\n\n                           \"PROGLIB.ZIL.PANEL\"  -  production\n                           \"PROGLIB.ZIL.NPANEL\" -  test\n                           \"PROGLIB.ZIL.OPANEL\" -  backup\n\n                         Note that the string, although containing a\n                         fully qualified data set name, does not\n                         contain single quotes.  This is to make it\n                         easier to construct a dsname(member) string.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SPF": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00'\\x00\\x86\\x02O\\x01\\x00&_\\t9\\x003\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "2000-09-21T09:39:27", "lines": 51, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\n***********************************************************************\n*                                                                     *\n*        If you have the required ISPF setup for ZIL (CLIST, HELP,    *\n*        PANEL, MSG, SKEL), all you need to do to use ZIL is invoke   *\n*        the XZIL clist (from inside or outside of ISPF) to get to    *\n*        the ZIL primary option menu.  From there you can invoke      *\n*        the interpreter, call a compiled LISP program, or do a       *\n*        foreground or background compile.                            *\n*                                                                     *\n***********************************************************************\n\nThe ISPF interface to ZIL is available by executing the clist XZIL,\neither from READY mode (in which case other ISPF options are not readily\navailable), or from within ISPF option 6 (in which case you can split\nthe screen and use any other ISPF options you desire).\n\nThe first screen you will see is the ZIL primary option menu, which\nshould be self-explanatory.\n\n\n ---------------------  ZIL PRIMARY OPTION MENU --------------------------------\n OPTION ===>\n\n            --------------------------------------------------\n           |                                                  |\n           |  ZIL - LISP on MVS - (c) 1987 C. S. Draper Lab.  |\n           |                                                  |\n            --------------------------------------------------\n\n    1+ NEWS        - Display latest ZIL news\n    2+ EDIT        - Edit a ZIL source program or function\n    3+ ZIL         - Invoke the ZIL interpreter\n    4+ COMPILE     - Compile/assemble/link ZIL program/function online\n    5+ BATCH       - Submit JCL to compile/assemble/link ZIL program/function\n    6+ TSO         - Invoke compiled ZIL program\n    7+ TEST        - Test the ZIL compiler\n    8+ RELINK      - Link new copy of function into existing program\n    9+ ASSEMBLE    - Assemble ZIL machine language function\n    T+ TUTORIAL    - Display information about ZIL\n    X+ EXIT        - Terminate this option.\n\n Press END key to terminate ZIL option.\n\n\nThe option you will use most often will be (3), the interpreter, which\nis what users generally have in mind when \"using LISP\" is spoken of.\nOptions 4 and 5 may be used to compile LISP functions or programs;\noptions 7 and 9 are for the use of the ZIL developers only.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$TRACE": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02O\\x00\\x880\\x9f\\x081\\x00\\x9f\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1988-11-04T08:31:00", "lines": 159, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\n                 *** ZIL Function Tracing ***\n\nThe ZIL interpreter helps you to debug your code by providing a\ntracing facility, invoked by the TRACE function, which shows the\nexecution of all or selected LISP functions as they are running.\n\nThe following functions (actually macros) are available in ZIL:\n\n  TRACE   - activates tracing for all or selected LISP functions.\n\n  UNTRACE - deactivates tracing for all or selected functions.\n\n  AT      - specifies processing done on entry to or exit from function\n\n  OFF     - cancels a previous AT request\n\n  PUTDATA - displays value of a form (not strictly a tracing function)\n\nFunction calls that can be traced include:\n\n  EXPR's (interpreted functions that evaluate their arguments)\n  SUBR's (compiled functions, when called by interpretive code)\n\nFunction calls that CANNOT be traced include:\n\n  FEXPR's (interpreted functions that don't evaluate their arguments)\n  MACRO's (although the macro expansion process can be traced by\n           tracing the individual functions invoked during\n           macro expansion)\n  Special forms (see member $SFORMS for a complete list of these)\n  Compiled code invoked from other compiled code (unless it is\n           invoked via FUNCALL)\n\nFor the exact syntax of TRACE, UNTRACE, AT, OFF and PUTDATA,\nsee the members of this document of those names.\n\nThe trace output takes the following form:\n\n When a function is about to be executed, its name is displayed\n next to the word \";Enter\" along with its (evaluated) argument\n list.\n\n When a function is exited, its name is displayed next to the\n word \";Exit\" along with the values that it is returning.\n\n Here is a sample session that illustrates tracing capabilities:\n\n (defun foo (x) (values (cons x x) t))\n  FOO\n\n (foo 'bar)\n  (BAR . BAR)\n  T\n\n (trace foo cons)\n  (FOO CONS)\n\n (foo 'bar)\n  ;Enter FOO (BAR)\n   ;Enter CONS (BAR BAR)\n   ;Exit CONS: (BAR . BAR)\n  ;Exit FOO: (BAR . BAR), T\n  (BAR . BAR)\n  T\n\n (untrace foo cons)\n  (FOO CONS)\n\n (at foo)\n  FOO\n\n ; Note that as soon as an AT is executed, normal tracing is activated\n ; for both entry and exit, and the particular AT that is specified\n ; overrides only that aspect of the tracing.\n\n (foo 'bar)\n  ;At entry to FOO.\n  ;Exit FOO: (BAR . BAR), T\n (BAR . BAR)\n T\n\n (at (foo entry) (&rest args) (putdata args))\n FOO\n\n (foo 1)\n  ;At entry to FOO.\n ARGS=(1)\n  ;Exit FOO: (1 . 1), T\n (1 . 1)\n T\n\n (at (foo :entry) (arg1) (putdata arg1))\n FOO\n\n (foo 1)\n  ;At entry to FOO.\n ARG1=\n  ;Exit FOO: (1 . 1), T\n (1 . 1)\n T\n\n (at (foo :entry t) (arg1) (putdata arg1))\n FOO\n\n (foo 1)\n ARG1=\n  ;Exit FOO: (1 . 1), T\n (1 . 1)\n T\n\n (at (foo exit) (&rest values) (putdata values))\n FOO\n\n (foo 1)\n ARG1=\n  ;At exit from FOO.\n VALUES=((1 . 1) T)\n (1 . 1)\n T\n\n (at (foo :exit t) (v1 v2) (putdata v1 v2))\n FOO\n\n (foo 1)\n ARG1=\n V1=(1 . 1),V2=T\n (1 . 1)\n T\n\n (off foo)\n FOO\n\n ; Note that OFF removes AT processing from either entry or exit, and\n ; restores normal tracing behavior for that aspect.  UNTRACE is still\n ; required to remove all tracing from the function.\n\n (foo 1)\n  ;Enter FOO (1)\n V1=(1 . 1),V2=T\n (1 . 1)\n T\n\n (off (foo exit))\n FOO\n\n (foo 1)\n  ;Enter FOO (1)\n  ;Exit FOO: (1 . 1), T\n (1 . 1)\n T\n\n (untrace foo)\n (FOO)\n\n (foo 1)\n (1 . 1)\n T\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ABS": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x08o\\x00\\x87$_\\x17\\x01\\x00$\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-27T00:00:00", "modifydate": "1987-09-02T17:01:00", "lines": 36, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ABS\n\nSyntax:   (ABS arg1)\n\n arg1 (required, evaluated) - a number.\n\nReturns:\n\n The absolute value of arg1.\n\nProcessing:\n\n If arg1 is negative, the corresponding positive number of the same\n type is returned.  Otherwise, arg1 is returned.\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\nExamples:\n\n (ABS 0)              ==> 0\n (ABS 2)              ==> 2\n (ABS -3)             ==> 3\n (ABS 1.5)            ==> 1.5\n (ABS -1.5)           ==> 1.5\n (ABS 1.5F0)          ==> 1.5F0\n (ABS -1.5F0)         ==> 1.5F0\n (ABS 2147483648)     ==> 21\n (ABS -2147483648)    ==> 21\n (ABS 1000000000000)  ==> 10000\n (ABS -1000000000000) ==> 10000\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ACOS": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x7f\\x00\\x87$_\\x17\\x18\\x00&\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-26T00:00:00", "modifydate": "1987-09-02T17:18:00", "lines": 38, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ACOS\n\nSyntax:   (ACOS num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n A number which is the arccosine of num1 in radians.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the\n value from num1.  If num1 is a single-precision flonum, the\n result is a single-precision flonum; otherwise the result is\n a double-precision flonum.\n\nErrors signaled:\n\n num1 not a number between -1 and 1.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\nExamples:\n\n (ACOS 0)     ==>   1.57079632\n (ACOS -1)    ==>   3.14159265\n (ACOS 1)     ==>   0.0\n (ACOS 1.0d0) ==>   0.0\n (ACOS 1.0f0) ==>   0.0F0\n (ACOS 0.5)   ==>   1.04719755\n (ACOS 0.5F0) ==>   1.0471973F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ACSIZE": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x07)\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T07:29:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ACSIZE\n\nSyntax:   (ACSIZE)\n\nReturns:\n\n An integer containing the total number of BYTES (not cells) in\n the currently active portion of CONS space.\n\nNotes:\n\n This value may be specified via the PARM field, or in a DECLARE,\n when a ZIL \"program\" is run.  See members $PARM and DECLARE of\n this documentation for more information.\n\n This value controls how much of the total CONS space (as specified by\n CSSIZE) is in use, until it is determined (by the garbage collector)\n that more space is needed, at which time the ACSIZE value is doubled,\n provided that it does not exceed the CSSIZE value.  Thus, the value\n returned by (ACSIZE) can change during execution.\n\n Do not confuse this function with CSSIZE, which returns the total\n number of bytes in all of allocated CONS space.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADD1": {"ttr": 1809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02O\\x00\\x87$\\x7f\\x07C\\x00\"\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1987-09-04T07:43:00", "lines": 34, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ADD1\n\nSyntax:   (ADD1 num1)\n    or:   (1+ num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n The sum of the argument and 1 (num1 + 1), of the same type as num1.\n\nProcessing:\n\n (ADD1 n) is equivalent to (+ n 1)\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for more information.\n\nNotes:\n\n See member $ARITH for more information.\n\nExamples:\n\n (ADD1 2)              ==> 3\n (ADD1 2147483647)     ==> 21\n (ADD1 -1000000000000) ==> -9999\n (1+ 1.0)              ==> 2.0\n (1+ 3.5F0)            ==> 4.5F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ADJOIN": {"ttr": 1811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x8f\\x00\\x87(\\x8f\\x17V\\x00L\\x00L\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-15T00:00:00", "modifydate": "1987-10-15T17:56:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: ADJOIN\n\nSyntax:   (ADJOIN item list2 &rest keywords)\n\n item1  (required, evaluated) - any LISP object.\n list2  (required, evaluated) - a list.\n\nReturns:\n\n If item1 is not already a member of list2, then the list formed by\n CONSing item1 onto the front of list2; otherwise, list2.\n\nProcessing:\n\n If item1 is already a member of the list which is the value of list2,\n list2 is returned unaltered.   Otherwise, item1 is CONSed onto the\n front of the list specified by list2, and the augmented list is\n returned as the value.\n\n list2 is NOT modified.\n\n The member test is determined by the keywords, if any, specified on\n the call to ADJOIN (using Common LISP keyword syntax).\n The valid keywords are:\n\n :TEST   -  must be #'EQ, #'EQL or #'EQUAL\n :KEY    -  must be #'CAR\n\n Both are optional.  If :TEST is omitted, the default is #'EQL.\n\n The test is performed by one of the MEMBER functions if the :KEY\n keyword is omitted; by one of the ASSOC functions if the :KEY\n keyword is specified as #'CAR (or 'CAR).\n\n The MEMBER functions are:  MEMQ      for :TEST #'EQ    (or 'EQ)\n                            MEMQL     for :TEST #'EQL   (or 'EQL)\n                            MEMQUAL   for :TEST #'EQUAL (or 'EQUAL)\n\n The ASSOC  functions are:  ASSQ      for :TEST #'EQ    (or 'EQ)\n                            ASSQL     for :TEST #'EQL   (or 'EQL)\n                            ASSQUAL   for :TEST #'EQUAL (or 'EQUAL)\n\n If an ASSOC function is used, the CAR of item1 is compared with the\n CAR of each member of list2.   Otherwise, item1 is compared with\n each member of list2.\n\nErrors signaled:\n\n Invalid keyword specification.\n Unsupported value for keyword.\n\nNotes:\n\n Compare PUSHNEW, which SETF's its second argument but is otherwise\n identical to ADJOIN.\n\nExamples:\n\n (ADJOIN 'A '(A B C))               ==> (A B C)\n (ADJOIN 'B '(A B C))               ==> (A B C)\n (ADJOIN 'C '(A B C))               ==> (A B C)\n (ADJOIN 'D '(A B C))               ==> (D A B C)\n\n (SETQ X '((A . 1)))                ==> ((A . 1))\n (ADJOIN '(A . 1) X :KEY #'CAR)     ==> ((A . 1))\n (ADJOIN '(A . 3) X)                ==> ((A . 3) (A . 1))\n (ADJOIN '(A . 3) X :KEY #'CAR)     ==> ((A . 1))\n (ADJOIN '(B . 2) X :KEY #'CAR)     ==> ((B . 2) (A . 1))\n\n (SETQ A '(2.0 1.0))          ==> (2.0 1.0)\n (ADJOIN 1.0 A)               ==> (2.0 1.0)\n (ADJOIN 1.0 A :TEST #'EQ)    ==> (1.0 2.0 1.0)\n (ADJOIN 1.0 A :TEST #'EQL)   ==> (2.0 1.0)\n (ADJOIN 1.0 A :TEST #'EQUAL) ==> (2.0 1.0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALPHACP": {"ttr": 1813, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86$\\x7f\\x00\\x87$o\\x079\\x00%\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-09-04T00:00:00", "modifydate": "1987-09-03T07:39:00", "lines": 37, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ALPHA-CHAR-P\n\nSyntax:   (ALPHA-CHAR-P arg1)\n    or:   (ALPHACP arg1)\n\n arg1 (required, evaluated) - a fixnum.\n\nReturns:\n\n T if the EBCDIC character represented by the fixnum arg1 is alphabetic\n (either lower or upper case), else NIL.\n\nProcessing:\n\n If arg1 is a number whose EBCDIC value represents an alphabetic\n character, T is returned; if arg1 is not in the range 0-255 or\n represents a non-alphabetic character, NIL is returned.\n\nErrors signaled:\n\n arg1 not a fixnum.\n\nNotes:\n\nExamples:\n\n (ALPHA-CHAR-P #/a)  ==> T\n (ALPHA-CHAR-P #/A)  ==> T\n (ALPHA-CHAR-P #/1)  ==> NIL\n (ALPHA-CHAR-P -1)   ==> NIL\n (ALPHA-CHAR-P #/$)  ==> NIL\n (ALPHA-CHAR-P 999)  ==> NIL\n (ALPHA-CHAR-P 10000000000000000)\n                     ==> (\"***ERROR***\") ; Not a fixnum.\n (ALPHA-CHAR-P \"a\")  ==> (\"***ERROR***\") ; Not a fixnum.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AND": {"ttr": 1815, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02O\\x00\\x87$o\\x07@\\x00%\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1987-09-03T07:40:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: AND\n\nSyntax:   (AND &rest args)\n\n arg (optional, conditionally evaluated) - any LISP object.\n\nReturns:\n\n NIL if any of the arguments is NIL, else the last argument specified.\n\nProcessing:\n\n Each argument in succession is evaluated until one of them returns\n NIL; if so, evaluation of the following arguments is bypassed.\n This is known as \"short-circuit\" evaluation.\n\n AND with no arguments returns T, by definition.\n\n AND may be used as a mini-conditional, e.g.:\n\n  (AND condition1 result) is equivalent to (IF condition1 THEN result).\n  (AND cond1 cond2 ... condn result) is equivalent to\n                         (IF (AND cond1 cond2 ... condn) THEN result).\n\nErrors signaled:\n\n None.\n\nExamples:\n\n (AND)                   ==> T\n (AND 'A 'B 'C)          ==> C\n (AND 'A NIL 'C)         ==> NIL\n (AND (EQ 'A 'A) 'TRUE)  ==> TRUE\n (AND (EQ 'A 'B) 'FALSE) ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPEND": {"ttr": 1817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02O\\x00\\x87$o\\x07A\\x007\\x00<\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1987-09-03T07:41:00", "lines": 55, "newlines": 60, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: APPEND\n\nSyntax:   (APPEND &rest lists)\n\n list (optional, evaluated) - a proper list\n                              (although the last argument need not be).\n\nReturns:\n\n A list consisting of the elements (CAR's) of all the arguments\n combined into one list.\n\nProcessing:\n\n All arguments except the last are copied (via repeated CONS), each\n argument being RPLACD'd onto the last CAR of the copy of the\n preceding argument.\n\n (APPEND), with no arguments, returns NIL.\n\n (APPEND list) returns a  new copy of \"list\", with each CAR of\n \"list\" re-CONS'ed.\n\n Compare NCONC, which destructively alters its arguments.\n\nErrors signaled:\n\n An argument other than the last one is not a proper list.\n\nNotes:\n\n As a special case, (APPEND atom), where atom is not a list, returns\n the selfsame atom.\n\n (APPEND list) is a commonly used idiom for making a copy of a list.\n\nExamples:\n\n (APPEND)                    ==> NIL\n (SETQ X '(A B C))           ==> (A B C)\n (SETQ Y (APPEND X))         ==> (A B C) ; this is a COPY of X.\n (EQ X Y)                    ==> NIL\n (EQUAL X Y)                 ==> T\n\n;The following shows how the last argument to APPEND is NOT copied.\n\n (SETQ X '(A))               ==> (A)\n (SETQ Y '(B C))             ==> (B C)\n (SETQ Z '(D E F))           ==> (D E F)\n (SETQ W (APPEND X Y Z))     ==> (A B C D E F)\n (EQ X W)                    ==> NIL\n (EQ Y (CDR W))              ==> NIL\n (EQ Z (CDDDR W))            ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPEND2": {"ttr": 1819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02O\\x00\\x87$o\\x07C\\x00?\\x00A\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1987-09-03T07:43:00", "lines": 63, "newlines": 65, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: APPEND2\n\nSyntax:   (APPEND2 list1 list2)\n\n list1 (required, evaluated) - a proper list.\n list2 (required, evaluated) - any LISP object, but generally a list.\n\nReturns:\n\n A list consisting of the elements of argument 1 followed by the\n elements of argument 2.\n\nProcessing:\n\n The first argument list is copied (via repeated CONS) and the second\n argument is RPLACD'd onto the last CAR of the copy of the first\n argument.\n\n (APPEND2 list NIL) creates a new copy of \"list\", with each CAR of\n \"list\" re-CONS'ed.\n\n Compare NCONC2, which destructively alters the first argument.\n\nErrors signaled:\n\n list1 not a proper list.\n\nNotes:\n\n APPEND2 is the two-argument form of APPEND, used to implement\n calls to APPEND in most compiled code.\n\n If the second argument is an atom, a list ending in a dotted pair\n will result.\n\n As a special case, (APPEND2 atom NIL), where atom is not a list,\n returns the selfsame atom.\n\nExamples:\n\n (APPEND2 NIL NIL)           ==> NIL\n (APPEND2 NIL '(A B C))      ==> (A B C)\n (APPEND2 '(A B C) NIL)      ==> (A B C)\n (APPEND2 '(A) '(B))         ==> (A B)\n (APPEND2 '(A) 'B)           ==> (A . B)\n (APPEND2 '(A B) '(C D))     ==> (A B C D)\n (APPEND2 '(A B C) 'D)       ==> (A B C . D)\n\n;The following shows how a new copy of a list is made using APPEND2.\n\n (SETQ X '(A B C))           ==> (A B C)\n (SETQ Y (APPEND2 X NIL))    ==> (A B C)\n (EQ X Y)                    ==> NIL\n (EQUAL X Y)                 ==> T\n\n;The following shows how the second argument to APPEND2 is NOT copied.\n\n (SETQ X '(A))               ==> (A)\n (SETQ Y '(B C))             ==> (B C)\n (SETQ Z (APPEND2 X Y))      ==> (A B C)\n (EQ (CDR Z) Y)              ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPLY": {"ttr": 1821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x02O\\x00\\x87$o\\x07G\\x00`\\x00b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1987-09-03T07:47:00", "lines": 96, "newlines": 98, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: APPLY\n\nSyntax:   (APPLY fun1 &rest lists2)\n\n fun1   (required, evaluated) - an atom or proper list.\n lists2 (required, evaluated) - one or more arguments, of which the\n                                last must be NIL or a list.\n\nReturns:\n\n The result of applying the function specified by fun1 to the argument\n list made up of the elements of list2.\n\nProcessing:\n\n The first argument (fun1) must be one of the following:\n\n   A compiled code SUBR or closure.\n   An interpreted lexical closure (funarg).\n   A symbol which is the name of a defined function.\n   A LAMBDA-expression (a list whose CAR is the atom LAMBDA).\n   A LABEL-expression (a list whose CAR is the atom LABEL).\n\n   The FUNCTION form (to which the #' syntax is equivalent) returns a\n   funarg under the interpreter, and a closure when compiled;\n   either of these is valid as the first argument to APPLY.\n\n   A symbol may represent a function as follows:\n\n     The name of a function defined either as an EXPR (e.g. via DEFUN)\n     or as a SUBR (a loaded compiled code function).\n\n     Special forms, macros, and FEXPR's are not supported.\n     This makes sense, since the second argument is assumed to\n     consist of evaluated forms, which are not valid for these\n     kinds of functions.\n\n     If the symbol has no current function definition, it will be\n     resolved via the ZEVAUTO function, which will use the AUTOLOAD\n     property, if present, to try to load a definition for the function.\n     If the symbol has no AUTOLOAD property, a compiled code function\n     definition of the same name will be searched for; if it is found,\n     it will be made the SUBR property of the symbol for future access.\n     The compiled code is then executed as part of the APPLY process.\n\n The arguments specified by lists2 are made into a list by consing all\n but the last argument onto the last argument (as the LIST* function\n would do).  This list of arguments is considered to have been ALREADY\n EVALUATED.  These are passed to the function specified by the first\n argument, and the function is evaluated with this as its argument list.\n\n The most typical use of APPLY is probably the case where the name of\n a function is specified as a variable.\n For example:\n\n   (DEFUN CALLFUNK (F) (APPLY F '(1 2 3)))\n\n When (CALLFUNK #'FOO) is executed, the local variable F is\n bound to the functional value of FOO, which is applied to the\n argument list (1 2 3).\n\n The following are equivalent:\n\n  (APPLY F '(1 2 3))\n  (APPLY F 1 '(2 3))\n  (APPLY F 1 2 '(3))\n  (APPLY F 1 2 3 NIL)\n\nErrors signaled:\n\n Wrong number of arguments.\n Last argument not a list.\n Errors pertaining to applying the function definition.\n\nNotes:\n\n You cannot pass an evaluation environment to APPLY.\n If you need to use one, you must use ZILAPPLY.\n\nExamples:\n\n (APPLY 'CAR '((A B C)))            ==> A\n (APPLY #'CONS '(FOO (BAR BAZ)))    ==> (FOO BAR BAZ)\n (APPLY #'CONS '(A B))              ==> (A . B)\n (APPLY #'CONS 'A '(B))             ==> (A . B)\n (APPLY #'CONS 'A 'B NIL)           ==> (A . B)\n (APPLY #'(LAMBDA (X) (CONS X X))\n         \"value-of-x\" NIL)          ==> (\"value-of-x\" . \"value-of-x\")\n\n ; The following illustrates lexical scoping.\n\n (LET ((A \"value-of-a\"))\n      (APPLY #'(LAMBDA (X) (CONS X A))\n             \"value-of-x\" NIL))     ==> (\"value-of-x\" . \"value-of-a\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APROPOS": {"ttr": 1823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x06o\\x00\\x88\\x11\\x9f\\x15T\\x00<\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-03-07T00:00:00", "modifydate": "1988-04-28T15:54:00", "lines": 60, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: APROPOS\n\nSyntax:   (APROPOS string1)\n\n string1 (required, evaluated) - a string or symbol.\n\nReturns:\n\n A list of all the currently interned symbols that have string1\n as a substring.\n\nProcessing:\n\n All interned symbols are searched to find those whose print names\n have string1 as a substring.  If string1 is a symbol, its print name\n is used.\n\n This provides a kind of list of function or variable names that\n contain the requested string somewhere within them.\n\n A case-insensitive comparison is done; thus case is irrelevant to\n both the search string and the members of the oblist.\n\n If the string is null, all currently interned symbols will be returned.\n\nErrors signaled:\n\n Argument not a string or symbol.\n\nNotes:\n\n When a SYMBOL is typed in as the argument to APROPOS, it is interned\n automatically, and since every string is a substring of itself, such a\n symbol will always satisfy the search, and therefore will appear in the\n returned list.\n\n Not all ZIL-defined function names will appear; some become interned\n only when referenced.  Therefore, APROPOS is not an exhaustive\n way of determining what ZIL functions are available.\n\n APROPOS is equivalent to Common LISP APROPOS-LIST (Common LISP\n APROPOS is supposed to display detailed info about each symbol found\n but return no values).\n\nExamples:\n\n; Note: These are possible return values; the actual values will\n;       vary depending on what has been loaded into the LISP system.\n\n 'MEMBER  ==> MEMBER       ; Just to insure these symbols are interned.\n 'MEMQ    ==> MEMQ         ;\n 'MEMQL   ==> MEMQL        ;\n 'MEMQUAL ==> MEMQUAL      ;\n\n (APROPOS \"MEM\")   ==> (MEMQUAL MEMQL MEMQ MEMBER ZIL-SOURCE-MEMBER)\n (APROPOS \"mem\")   ==> (MEMQUAL MEMQL MEMQ MEMBER ZIL-SOURCE-MEMBER)\n (APROPOS 'MEM)    ==> (MEM MEMQUAL MEMQL MEMQ MEMBER ZIL-SOURCE-MEMBER)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ARG": {"ttr": 1825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87&\\x0f\\x07&\\x00'\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-17T07:26:00", "lines": 39, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: ARG\n\nSyntax:   (ARG &optional arg1)\n\n arg1 (optional, evaluated) - T, NIL, or an integer.\n\nReturns:\n\n If arg1 is omitted or NIL, an integer representing the number of\n arguments passed to the currently active LEXPR.\n\n If arg1 is T, the list of arguments passed to the currently active\n LEXPR.\n\n If arg1 is an integer, the arg1'th argument passed to the currently\n active LEXPR.\n\nProcessing:\n\n As above.\n\nErrors signaled:\n\n ARG issued outside LEXPR.\n arg1 out of range, or otherwise invalid.\n\nNotes:\n\n No error checking is done in compiled code.  Results are unpredictable\n if an invalid argument is passed.\n\n See member $LEXPR for information about LEXPR's.\n\nExamples:\n\n (DEFUN FOO X (LIST (ARG T) (ARG NIL) (ARG 1) (ARG 2)))   ==> FOO\n (FOO 'BAR 'BAZ)       ==> ((BAR BAZ) 2 BAR BAZ)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ARGS": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87(o\\x08S\\x007\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-10-13T08:53:00", "lines": 55, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ARGS\n\nSyntax:   (ARGS fun1 &optional arg2)\n\n fun1 (required, evaluated) - a symbol.\n arg2 (optional, evaluated) - anything you want; it's not used anyhow.\n\nReturns:\n\n See under Processing.\n\nProcessing:\n\n If arg2 is omitted...\n\n  If fun1 names a compiled function, then:\n   a cons (NIL . n) if fun1 takes n required args and no &optional args\n   a cons (m . n) if fun1 takes m required args and (n-m) &optional args\n   a cons (m . 510) if fun1 takes m required args and any &rest args\n   (the 510 is octal 776)\n\n  If fun1 names an interpreted function, a warning is issued and NIL is\n  returned.\n\n  If fun1 does not have a function definition, an error is signalled.\n\n If arg2 is specified...\n\n  A warning message is issued to the effect that changing the number of\n  args of a function in ZIL is not possible, and fun1 is returned.\n\n  In addition, if the value of the special variable *LOADFILE* is\n  non-NIL, it is made the value of the LOADFILE property of fun1, to\n  identify the file (if any) from which the ARGS request was issued\n  (this is to identify translated Macsyma code files, which use ARGS in\n  this manner).\n\nErrors signaled:\n\n fun1 does not name a compiled function (see above).\n\nNotes:\n\n This is a Maclisp function (which may explain the crazy return values)\n which exists in ZIL only to support Macsyma.\n\n Interpretive function definitions are not supported.\n\nExamples:\n\n (ARGS 'CAR)              ==> (NIL . 1)\n (ARGS 'FLOAT)            ==> (1 . 2)\n (ARGS 'APPEND)           ==> (0 . 510)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ARRAY": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x17B\\x00\\x03\\x00\\x03\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T17:42:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "SEB1525"}, "text": "\n See member $ARRAY for information on Maclisp-style arrays in ZIL.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASH": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x88\\x16_\\x08W\\x006\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1988-06-13T08:57:00", "lines": 54, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ASH\n\nSyntax:   (ASH arg1 arg2)\n\n arg1 (required, evaluated) - an integer.\n arg2 (required, evaluated) - an integer.\n\nReturns:\n\n An integer containing the result of an arithmetic shift operation\n performed on arg1, with arg2 specifying the number of bits to shift\n (left if positive, right if negative).\n\nProcessing:\n\n An arithmetic shift operation is performed on the numeric contents of\n arg1 (not in place), with arg2 determining the amount and direction of\n the shift.\n\n If arg2 is positive, a left shift of N bits takes place, with N being\n the absolute value of the integer arg2.\n\n If arg2 is negative, a right shift of N bits takes place, with N being\n the absolute value of the integer arg2.\n\n If arg2 is zero, no shift takes place, but arg1 is returned.\n\n The arguments and the result are always integers.  This means that\n 1-bits will be shifted out according to the rules of the IBM/370 SLA or\n SRA instruction - except if the result is a bignum, in which case it\n is treated as a two's-complement long integer.\n\nErrors signaled:\n\n First argument not an integer.\n Second argument not an integer.\n\nNotes:\n\n Compare LSH, which does a logical shift.  ASH and LSH differ when\n arg1 is negative and a right shift is performed; ASH propagates the\n sign bit while LSH fills in with zero bits on the left.\n Also, LSH is a fixnum-only function which never produces a bignum.\n\nExamples:\n\n (ASH 10 0)      ==> 10\n (ASH 10 1)      ==> 20\n (ASH 10 2)      ==> 40\n (ASH 96 -3)     ==> 12\n (ASH -1 1)      ==> -2            ;  i.e. FFFFFFFF goes to FFFFFFFE\n (ASH -1 -1)     ==> -1            ;  i.e. FFFFFFFF goes to FFFFFFFF\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASIN": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x7f\\x00\\x87$o\\x08\\t\\x00'\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-26T00:00:00", "modifydate": "1987-09-03T08:09:00", "lines": 39, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ASIN\n\nSyntax:   (ASIN num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n A number which is the arcsine of num1 in radians.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the\n value from num1.  If num1 is a single-precision flonum, the\n result is a single-precision flonum; otherwise the result is\n a double-precision flonum.\n\nErrors signaled:\n\n num1 not a number between -1 and 1.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\nExamples:\n\n(ASIN 0)     ==> 0.0\n(ASIN 1)     ==> 1.57079632\n(ASIN -1)    ==> -1.57079632\n(ASIN 0.5)   ==> 0.52359877\n(ASIN -0.5)  ==> -0.52359877\n(ASIN 0.5F0) ==> 0.5235988F0\n(ASIN \"foo\") ==> (\"***ERROR***\")\n(ASIN 1000)  ==> (\"***ERROR***\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSOC": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x88\\t\\x8f\\x13\\x03\\x00p\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1988-04-07T13:03:00", "lines": 112, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ASSOC\n\nSyntax:   (ASSOC item1 alist2 &key test test-not key)\n\n item1    (required, evaluated) - any LISP object.\n alist2   (required, evaluated) - a list in association list format\n                                  (i.e. a list of dotted pairs).\n test     (optional, evaluated) - a predicate function of two arguments.\n test-not (optional, evaluated) - a predicate function of two arguments.\n key      (optional, evaluated) - an accessor function of one argument.\n\nReturns:\n\n The first dotted pair in alist2 whose CAR is equal to item1\n according to the test specified by the keywords;\n NIL if no such pair exists.\n\nProcessing:\n\n alist2 (an association list) is searched for an element (dotted pair)\n whose CAR is equal to item1.  When the first such pair is found, the\n pointer to it is returned.\n\n The caller of ASSOC may use the CDR of the returned pair as the \"value\"\n of item1 as found on the alist2 association list, unless NIL is\n returned, indicating no value found.\n\n NIL may occur in place of a dotted pair anywhere within alist2; when\n this is the case, it is skipped over and the search continues.\n\n If no keywords are specified, a match occurs when an element of\n alist2 is found that item1 is EQL to the CAR of.\n\n The keywords are processed as follows:\n\n :test (default #'eql)  - specifies a predicate function of two\n                          arguments used when comparing item1 to the CAR\n                          of each element of alist2. If the function\n                          returns a non-NIL value, a match occurs.  The\n                          first argument is always item1, and the second\n                          argument is always the CAR of the current\n                          element of alist2 (with the :key function\n                          applied if :key is specified).\n\n :test-not (no default) - specifies a predicate function of two\n                          arguments used when comparing item1 to each\n                          element of alist2. If the function returns\n                          NIL, a match occurs.  The first argument is\n                          always item1, and the second argument is\n                          always the CAR of the current element of\n                          alist2 (with the :key function applied if :key\n                          is specified).\n\n :key (no default)      - specifies an accessor function of one argument\n                          that is applied to the CAR of each element of\n                          alist2 before comparing it to item1 via the\n                          :test or :test-not function.  Note that the\n                          :key function is applied after CAR, NOT\n                          instead of CAR.\n\n The :test and :test-not keywords may not both be specified.\n\nErrors signaled:\n\n alist2 not a list.\n Both :test and :test-not keywords specified.\n Invalid keyword specification.\n\nNotes:\n\n ASSOC is, by default, implemented with an EQL test for Common LISP\n compatibility.  If Maclisp or Franz LISP compatibility is desired,\n ASSOC may be equated with ZIL function ASSQUAL via the DEFLOAD special\n form.  See ASSQ and ASSQUAL for more info.\n\n Under Macsyma, ASSOC performs an EQUAL test.\n\n Unpredictable results will occur if the second argument is not NIL or\n a list of dotted pairs.\n\nExamples:\n\n (ASSOC 'A NIL)                           ==> NIL\n (ASSOC 'A '((A . 1) (B . 2) (C . 3)))    ==> (A . 1)\n (ASSOC 'D '((A . 1) (B . 2) (C . 3)))    ==> NIL\n (ASSOC 'BAZ '((FOO . BAR) (BAZ . FROB) (BAZ . NICATE)))\n                                          ==> (BAZ . FROB)\n\n ;The following shows that the default comparison test is EQL.\n\n (ASSOC 1   '((1 . A) (2 . B) (3 . C)))     ==> (1 . A)\n (ASSOC 1.0 '((1 . A) (2 . B) (3 . C)))     ==> NIL\n\n (ASSOC 'A '((A) (B) (C)) :TEST #'EQL)      ==> (A)\n (ASSOC 'B '((A) (B) (C)) :TEST #'EQL)      ==> (B)\n (ASSOC 'C '((A) (B) (C)) :TEST #'EQL)      ==> (C)\n (ASSOC 'D '((A) (B) (C)) :TEST #'EQL)      ==> NIL\n\n (ASSOC 'A '((A) (B) (C)) :TEST-NOT #'EQL)  ==> (B)\n (ASSOC 'B '((A) (B) (C)) :TEST-NOT #'EQL)  ==> (A)\n (ASSOC 'C '((A) (B) (C)) :TEST-NOT #'EQL)  ==> (A)\n (ASSOC 'D '((A) (B) (C)) :TEST-NOT #'EQL)  ==> (A)\n\n (ASSOC 'C '(((A) B) ((C) D) ((E) F)))             ==> NIL\n (ASSOC 'C '(((A) B) ((C) D) ((E) F)) :KEY #'CAR)  ==> ((C) D)\n\n ;The default comparison test is EQL.\n\n (ASSOC '(2) '(((1) . A) ((2) . B)))                ==> NIL\n (ASSOC '(2) '(((1) . A) ((2) . B)) :TEST #'EQUAL)  ==> ((2) . B)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSQ": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x88\\t\\x8f\\x13\\x05\\x001\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1988-04-07T13:05:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ASSQ\n\nSyntax:   (ASSQ arg1 alist2)\n\n arg1   (required, evaluated) - any LISP object, but generally a symbol.\n alist2 (required, evaluated) - a list in association list format\n                                (i.e. a list of dotted pairs).\n\nReturns:\n\n The first dotted pair in alist2 whose CAR is EQ to arg1;\n NIL if no such pair exists.\n\nProcessing:\n\n alist2 (an association list) is searched for an element (dotted pair)\n whose CAR is EQ to arg1.  When the first such pair is found, the\n pointer to it is returned.  The caller of ASSQ may use the CDR of the\n returned pair as the \"value\" of arg1 as found on the alist2 association\n list, unless NIL is returned, indicating no value found.\n\n NIL may occur in place of a dotted pair anywhere within alist2; when\n this is the case, it is skipped over and the search continues.\n\nErrors signaled:\n\n alist2 not a list.\n\nNotes:\n\n Unpredictable results will occur if the second argument is not NIL or\n a list of dotted pairs.\n\n ASSQ is equivalent to Common LISP (ASSOC ... #TEST #'EQ).\n Compare ASSOC, which is like ASSQ but uses an EQL test by default.\n\nExamples:\n\n (ASSQ 'A NIL)                            ==> NIL\n (ASSQ 'A '((A . 1) (B . 2) (C . 3)))     ==> (A . 1)\n (ASSQ 'D '((A . 1) (B . 2) (C . 3)))     ==> NIL\n (ASSQ 'BAZ '((FOO . BAR) (BAZ . FROB) (BAZ . NICATE)))\n                                          ==> (BAZ . FROB)\n\n ;The following shows that the comparison test is EQ.\n\n (ASSQ 1.0 '((1.0 . A) (2.0 . B) (3.0 . C)))      ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSQL": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x06?\\x00\\x87\\x13\\x9f\\x17A\\x004\\x003\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-05-19T17:41:00", "lines": 52, "newlines": 51, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ASSQL\n\nSyntax:   (ASSQL arg1 alist2)\n\n arg1   (required, evaluated) - any LISP object.\n alist2 (required, evaluated) - a list in association list format\n                                (i.e. a list of dotted pairs).\n\nReturns:\n\n The first dotted pair in alist2 whose CAR is EQL to arg1;\n NIL if no such pair exists.\n\nProcessing:\n\n alist2 (an association list) is searched for an element (dotted pair)\n whose CAR is EQL to arg1.  When the first such pair is found, the\n pointer to it is returned.  The caller of ASSQL may use the CDR of the\n returned pair as the \"value\" of arg1 as found on the alist2 association\n list, unless NIL is returned, indicating no value found.\n\n NIL may occur in place of a dotted pair anywhere within alist2; when\n this is the case, it is skipped over and the search continues.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.\n Unpredictable results will occur if the second argument is not NIL or\n a list of dotted pairs.\n\n Compare ASSQ, which is like ASSQL but uses an EQ test;\n and ASSQUAL, which is like ASSQL but uses an EQUAL test.\n\nExamples:\n\n (ASSQL 'A NIL)                           ==> NIL\n (ASSQL 'A '((A . 1) (B . 2) (C . 3)))    ==> (A . 1)\n (ASSQL 'D '((A . 1) (B . 2) (C . 3)))    ==> NIL\n (ASSQL 'BAZ '((FOO . BAR) (BAZ . FROB) (BAZ . NICATE)))\n                                          ==> (BAZ . FROB)\n\n ;The following shows that the comparison test is EQL.\n\n (ASSQL 1.0 '((1.0 . A) (2.0 . B) (3.0 . C)))     ==> (1.0 . A)\n (ASSQL 1.0 '((1 . A) (2 . B) (3 . C)))     ==> NIL\n (ASSQL '(A B) '(((C D) E) ((A B) Z)))      ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSQUAL": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x06?\\x00\\x86\\x06?\\x17\\x06\\x004\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1986-03-04T17:06:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ASSQUAL\n\nSyntax:   (ASSQUAL arg1 alist2)\n\n arg1   (required, evaluated) - any LISP object.\n alist2 (required, evaluated) - a list in association list format\n                                (i.e. a list of dotted pairs).\n\nReturns:\n\n The first dotted pair in alist2 whose CAR is EQUAL to arg1;\n NIL if no such pair exists.\n\nProcessing:\n\n alist2 (an association list) is searched for an element (dotted pair)\n whose CAR is EQUAL to arg1. When the first such pair is found, the\n pointer to it is returned.  The caller of ASSQUAL may use the CDR of the\n returned pair as the \"value\" of arg1 as found on the alist2 association\n list, unless NIL is returned, indicating no value found.\n\n NIL may occur in place of a dotted pair anywhere within alist2; when\n this is the case, it is skipped over and the search continues.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.\n Unpredictable results will occur if the second argument is not NIL or\n a list of dotted pairs.\n\n Compare ASSQ, which is like ASSQUAL but uses an EQ test;\n and ASSQL, which is like ASSQL but uses an EQL test.\n\nExamples:\n\n (ASSQUAL 'A NIL)                         ==> NIL\n (ASSQUAL 'A '((A . 1) (B . 2) (C . 3)))  ==> (A . 1)\n (ASSQUAL 'D '((A . 1) (B . 2) (C . 3)))  ==> NIL\n (ASSQUAL 'BAZ '((FOO . BAR) (BAZ . FROB) (BAZ . NICATE)))\n                                          ==> (BAZ . FROB)\n\n ;The following shows that the comparison test is EQUAL.\n\n (ASSQUAL 1 '((1 . A) (2 . B) (3 . C)))     ==> (1 . A)\n (ASSQUAL 1.0 '((1 . A) (2 . B) (3 . C)))   ==> NIL\n (ASSQUAL '(A B) '(((C D) E) ((A B) Z)))    ==> ((A B) Z)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AT": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x880\\x9f\\x00\\x880\\x9f\\t7\\x00\\xa5\\x00\\xa2\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-04T00:00:00", "modifydate": "1988-11-04T09:37:00", "lines": 165, "newlines": 162, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: AT\n\nSyntax:   (AT funspec)\n    or:   (AT funspec arglist &rest body)\n\n funspec (required, not evaluated) - a symbol funname, list (funname),\n         or a list (funname aspect) or (funname aspect quietp),\n         where: funname is a symbol naming a function\n                aspect is one of:  ENTRY, :ENTRY, EXIT, :EXIT\n                quietp is any value, generally T or NIL\n\nReturns:\n\n funname, after activating tracing for the function named by funname\n and associating the action specified by arglist and body with entry\n to or exit from the function.\n\nProcessing:\n\n First of all, tracing is activated for the function specified by\n funname in the normal way.  This means that the default \"Entering\"\n and \"Exiting\" displays will occur, where AT does not specify otherwise.\n\n What happens next depends on the aspect, which is either entry or exit.\n Entry specifies action to be taken immediately before calls to the\n function are entered; exit specifies action to be taken immediately\n after values are returned from the function.\n\n If no aspect is given, it defaults to entry.\n\n If no arglist or body is specified, then the only action is to\n display the message \"At entry to {funname}\" or \"At exit from {funname}\"\n at the appropriate point, and with the appropriate indentation.\n If an arglist and a body are specified, then a lambda-expression is\n created from the arglist and body which define a function to be\n executed at entry to or exit from the function in addition to the\n \"At...\" message.  If quietp is non-NIL, the \"At...\" message is\n suppressed, and only the action specified by arglist and body is\n performed.\n\n For entry, the arglist maps the arguments to the function.  They may\n be specified as for the function's normal argument list, or any other\n arglist format may be used.  A &rest argument may be used to get the\n entire argument list at once.\n\n For exit, the arglist maps the values returned by the function.  If\n the function returns a single value, an arglist of one variable is\n the norm.  A &rest argument may be used to get the list of all values\n returned (a list of one value for functions that do not return\n multiple values).\n\n\n The OFF macro may be used to cancel an AT for entry or exit to a\n function, or a subsequent AT may be used to replace an existing one.\n However, OFF merely reverts entry or exit processing to the default\n for tracing; UNTRACE must be used to cancel tracing entirely for\n the function.\n\nErrors signaled:\n\n Invalid function name.\n Argument list but no body specified.\n Invalid aspect (not entry or exit).\n\nNotes:\n\n See also OFF, TRACE, and UNTRACE.\n\n See member $TRACE of this document for a description of tracing,\n and for examples of use.\n\n The PUTDATA macro is useful for displaying values.  See PUTDATA.\n\n See ZILTRACE for technical details on how tracing and untracing\n are effected.\n\nExamples:\n\n;(AT FOO)\n;(AT (FOO ENTRY))\n;(AT (FOO :ENTRY))\n;(AT (FOO ENTRY NIL))     all set a \"breakpoint\" at entry to FOO\n;                         that prints \"At entry to FOO\" only.\n;(AT FOO)\n;(AT (FOO EXIT))\n;(AT (FOO :EXIT))\n;(AT (FOO EXIT NIL))      all set a \"breakpoint\" at exit from FOO\n;                         that prints \"At exit from FOO\" only.\n;\n;(AT FOO (A) (PUTDATA A))       prints \"At entry to FOO\" and displays\n;                               the value of the first argument to FOO.\n;\n;(AT FOO (&REST A) (PRINT A))   prints \"At entry to FOO\" and prints\n;                               the value of the list of args to FOO.\n;\n;(AT (FOO ENTRY T) (A) (PUTDATA A))\n;                               displays the value of arg 1 to FOO\n;                               upon entry, but does not print any\n;                               entry message.\n;\n;(AT (FOO EXIT) (V) (PRINT V))  prints \"At exit from FOO\" and prints\n;                               the single value returned from FOO.\n;\n;(AT (FOO EXIT T) (&REST V) (PUTDATA V))\n;                               displays the list of values returned by\n;                               FOO at exit, but does not print any\n;                               exit message.\n\n; Here's a fancy use of AT to trace the inputs and outputs to a\n; function.  Note how lexical scoping is taken advantage of.\n\n(DEFUN FIB (X) (IF (< X 2) 1 (+ (FIB (1- X)) (FIB (- X 2)))))\n  ==> FIB\n\n(LET (A)\n (AT (FIB ENTRY T) (N) (PUSH `(IN ,N) A))\n (AT (FIB EXIT T) (V)\n (PUSH `( OUT ,V) A))\n (FIB 10)\n (REVERSE A))\n\n  ==>\n\n((IN 10) (IN 9) (IN 8) (IN 7) (IN 6) (IN 5) (IN 4) (IN 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (IN 3) (IN 2) (IN 1) (OUT 1)\n (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (OUT 8) (IN 4) (IN 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (OUT 13) (IN 5)\n (IN 4) (IN 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1)\n (OUT 1) (OUT 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5)\n (IN 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1)\n (OUT 3) (OUT 8) (OUT 21) (IN 6) (IN 5) (IN 4) (IN 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (IN 3) (IN 2) (IN 1) (OUT 1)\n (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (OUT 8) (IN 4) (IN 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (OUT 13) (OUT 34)\n (IN 7) (IN 6) (IN 5) (IN 4) (IN 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1)\n (OUT 2) (IN 1) (OUT 1) (OUT 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1)\n (OUT 2) (OUT 5) (IN 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2)\n (IN 1) (OUT 1) (OUT 3) (OUT 8) (IN 4) (IN 3) (IN 2) (IN 1) (OUT 1)\n (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (IN 2) (IN 1) (OUT 1)\n (IN 0) (OUT 1) (OUT 2) (OUT 5) (OUT 13) (IN 5) (IN 4) (IN 3) (IN 2)\n (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (IN 2)\n (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (IN 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (OUT 8) (OUT 21)\n (OUT 55) (IN 8) (IN 7) (IN 6) (IN 5) (IN 4) (IN 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (IN 3) (IN 2) (IN 1) (OUT 1)\n (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (OUT 8) (IN 4) (IN 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (OUT 13) (IN 5)\n (IN 4) (IN 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1)\n (OUT 1) (OUT 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5)\n (IN 3) (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1)\n (OUT 3) (OUT 8) (OUT 21) (IN 6) (IN 5) (IN 4) (IN 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (IN 2) (IN 1)\n (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (IN 3) (IN 2) (IN 1) (OUT 1)\n (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3) (OUT 8) (IN 4) (IN 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (IN 1) (OUT 1) (OUT 3)\n (IN 2) (IN 1) (OUT 1) (IN 0) (OUT 1) (OUT 2) (OUT 5) (OUT 13) (OUT 34)\n (OUT 89))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ATAN": {"ttr": 2068, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x17O\\x00\\x87$o\\x08\\x18\\x007\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-06-23T00:00:00", "modifydate": "1987-09-03T08:18:00", "lines": 55, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ATAN\n\nSyntax:   (ATAN num1 num2)\n\n num1 (required, evaluated) - a number.\n num2 (required, evaluated) - a number.\n\nReturns:\n\n A number which is the arctangent of num2/num1 in radians.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the value\n from num1.  If num1 and num2 are both single-precision flonums, or one\n is an integer and the other is a single-precision flonum, the result is\n a single-precision flonum; otherwise the result is a double-precision\n flonum.\n\nErrors signaled:\n\n num1 or num2 not numeric.\n num1 and num2 may not both be zero.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\n Bignums are not supported as arguments to this function.\n\nExamples:\n\n (ATAN 0     1)      ==> 0.0\n (ATAN 0     1.0F0)  ==> 0.0F0\n (ATAN 0     1.0)    ==> 0.0\n\n (ATAN 0.0F0 1)      ==> 0.0F0\n (ATAN 0.0F0 1.0F0)  ==> 0.0F0\n (ATAN 0.0F0 1.0)    ==> 0.0\n\n (ATAN 0.0   1)      ==> 0.0\n (ATAN 0.0   1.0F0)  ==> 0.0\n (ATAN 0.0   1.0)    ==> 0.0\n\n (ATAN 0 1)   ==> 0.0\n (ATAN 1 0)   ==> 1.57079632\n (ATAN 1 1)   ==> 0.78539816\n (ATAN -1 -1) ==> -2.35619449\n (ATAN 1 -1)  ==> 2.35619449\n\n (ATAN 0 0)   ==> (\"***ERROR***\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ATOM": {"ttr": 2070, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x088\\x000\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T08:38:00", "lines": 48, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ATOM\n\nSyntax:   (ATOM arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is an atom, otherwise NIL.\n\nProcessing:\n\n Any LISP object that is of a valid type other than a CONS is\n considered an atom.  These include:\n\n  NIL\n  Symbols\n  Numbers\n  Strings\n  Vectors\n  Code objects\n  Structures\n\n The following are not atoms:\n\n  Lists\n  Dotted pairs\n  Values returned by various weird functions (RMNIL, ZILUNBND, etc.).\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (ATOM 'FOO)              ==> T\n (ATOM NIL)               ==> T\n (ATOM '(NIL))            ==> NIL\n (ATOM 3.1415927)         ==> T\n (ATOM \"hi there\")        ==> T\n (ATOM '(A B C))          ==> NIL\n (ATOM #(A B C))          ==> T\n (ATOM #'FOO)             ==> T\n (ATOM (GET 'ATOM 'SUBR)) ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BIGLIST": {"ttr": 2072, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x05\\x7f\\x00\\x87$o\\x088\\x00\\x1e\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-26T00:00:00", "modifydate": "1987-09-03T08:38:00", "lines": 30, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: BIGLIST\n\nSyntax:   (BIGLIST arg1)\n\n arg1 (required, evaluated) - a bignum.\n\nReturns:\n\n A list of fixnums which constitute the body of the bignum in\n physical order.\n\nProcessing:\n\n The contents of the list is dependent upon the internal implementation\n of bignums.  See $BIGNUM for more information.\n\nErrors signaled:\n\n arg1 not a bignum.\n\nNotes:\n\n MKBIGNUM will turn the list of fixnums back into a bignum.\n\nExamples:\n\n (BIGLIST 2147483648) ==> (0 1)\n (BIGLIST -2147483649) ==> (-2147483647 1)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BIGNUM": {"ttr": 2074, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x05\\x7f\\x00\\x87$o\\x089\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-26T00:00:00", "modifydate": "1987-09-03T08:39:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: BIGNUM\n\nSyntax:   (BIGNUM fix1 ... fixn)\n\n fixn (required, evaluated) - a fixnum.\n\nReturns:\n\n A bignum created from the fixn's.\n\nProcessing:\n\n BIGNUM invokes MKBIGNUM to build the bignum.\n\n The contents of the list is dependent upon the internal implementation\n of bignums.  See $BIGNUM for more information.\n\nErrors signaled:\n\n Errors detected by MKBIGNUM (q.v.).\n\nNotes:\n\n  BIGLIST will turn the bignum back into a list.\n\nExamples:\n\n (BIGNUM 0 1)              ==> 21\n (BIGNUM 1 2 3)            ==> 138350580595\n (BIGNUM -2147483647 1)    ==> -21\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BIGP": {"ttr": 2076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87$o\\x089\\x00!\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-03T08:39:00", "lines": 33, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: BIGP\n\nSyntax:   (BIGP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a bignum, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n A fixnum is an integer in the range -2147483648 thru 2147483647, of\n which FIXNUMP is true.  Integers outside of this range are bignums, of\n which BIGP is true.  The predicate INTEGERP may be used to test if an\n object is an integer (fixnum or bignum).\n\nExamples:\n\n (BIGP 1)             ==> NIL\n (BIGP 1.0)           ==> NIL\n (BIGP '(1))          ==> NIL\n (BIGP 'ONE)          ==> NIL\n (BIGP 123456789876)  ==> T\n (BIGP (** 2 31))     ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BLOCK": {"ttr": 2078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x16\\x1f\\x00\\x88\\x16\\x1f\\x089\\x00A\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-09T00:00:00", "modifydate": "1988-06-09T08:39:00", "lines": 65, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: BLOCK\n\nSyntax:   (BLOCK name1 &rest forms)\n\n name1 (required, not evaluated) - asymbol.\n form  (optional, evaluated)     -\n\nReturns:\n\n The last of the forms, unless a RETURN-FROM with a block name of name1\n is executed during evaluation of the forms in the BLOCK, in which case\n the value returned by the RETURN-FROM form becomes the return value.\n\nProcessing:\n\n The first argument is a symbol which names the block.\n\n The rest of the forms in the BLOCK constitute the body of the BLOCK,\n and are processed like an implicit PROGN.\n\n If a RETURN-FROM form is evaluated during execution of the forms in\n the block, and the block name specified on the RETURN-FROM is EQ to\n name1, the block is exited, returning the value returned by the\n RETURN-FROM form.  This applies only if the block is not shadowed\n by another block of the same name being invoked during execution\n of this block, of course.\n\n Blocks may be nested; a block shadows an outer block of the same name.\n\nErrors signaled:\n\n Missing or invalid block name.\n\nNotes:\n\n See HELP member RETURNFR for more information about RETURN-FROM and\n restrictions pertinent thereto, particularly those which involve\n functionality available under the interpreter but not (as yet) in\n compiled code.\n\n RETURN-FROM is valid as long as it is lexically apparent in\n the code.  This means that it will be processed as long as it is\n not the product of function evaluation.  The following are\n valid occurrences of RETURN-FROM:\n\n (BLOCK FOO (DO 'SOMETHING) (RETURN-FROM FOO T))\n (BLOCK BAR1\n        (BLOCK BAR2\n               (COND ((EQ A T) (RETURN-FROM BAR2 A))\n                     (T (PROGN (PRINT 1) (RETURN-FROM BAR1))))))\n\n\n The following is NOT valid:\n\n (DEFUN SUMFUNK () (RETURN-FROM NOGOOD 'Z))\n (BLOCK NOGOOD (SUMFUNK))\n\n A \"No matching RETURN-FROM block name\" error will be signalled.\n\nExamples:\n\n (BLOCK A 1 2 3)                    ==> 3\n (BLOCK A 1 2 (RETURN-FROM A 4) 3)  ==> 4\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BOOLE": {"ttr": 2080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x86\\x11\\x1f\\x00\\x87$o\\x08@\\x00L\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1986-04-21T00:00:00", "modifydate": "1987-09-03T08:40:00", "lines": 76, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: BOOLE\n\nSyntax:   (BOOLE op1 arg2 arg3 &rest args)\n\n op1  (required, evaluated) - a fixnum between 0 and 15, inclusive.\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a fixnum.\n args (optional, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical operation performed on\n arg1, arg2 and other args if specified.  The logical operation is\n specified by op1.\n\nProcessing:\n\n If additional args are specified, the operation is performed in a\n left-associative manner.  Otherwise, the operation is performed on\n arg1 and arg2.\n\n This is a fixnum-only operation.  op1 specifies the Boolean operation\n to be performed on args 2 and 3 via a \"truth table\" as follows:\n\n (Note - this table is taken from p. 223, \"Common LISP: The Language\",\n         Guy L. Steele, Jr., Digital Press, 1984.  However, the actual\n         bit configurations are given only in the Maclisp manual.)\n\n           arg2 bit:  0   1   0   1\n           arg3 bit:  0   0   1   1\n     op1                              Operation or value returned\n__________________________________________________________________\n 0  (#B0000)          0   0   0   0   0\n 1  (#B0001)          0   0   0   1   (logand arg2 arg3)\n 2  (#B0010)          0   1   0   0   (logand (lognot arg2) arg3)\n 3  (#B0011)          0   1   0   1   arg3\n 4  (#B0100)          0   0   1   0   (logand arg2 (lognot arg3))\n 5  (#B0101)          0   0   1   1   arg2\n 6  (#B0110)          0   1   1   0   (logxor arg2 arg3)\n 7  (#B0111)          0   1   1   1   (logior arg2 arg3)\n 8  (#B1000)          1   0   0   0   (lognot (logior arg2 arg3))\n 9  (#B1001)          1   0   0   1   (lognot (logxor arg2 arg3))\n10  (#B1010)          1   1   0   0   (lognot arg2)\n11  (#B1011)          1   1   0   1   (logior (lognot arg2) arg3)\n12  (#B1100)          1   0   1   0   (lognot arg3)\n13  (#B1101)          1   0   1   1   (logior arg2 (lognot arg3))\n14  (#B1110)          1   1   1   0   (lognot (logand arg2 arg3))\n15  (#B1111)          1   1   1   1   1\n\nErrors signaled:\n\n op1 not a fixnum between 0 and 15 inclusive.\n arg2 or arg3 not a fixnum.\n\nNotes:\n\nExamples:\n\n (BOOLE  0 #z0000FFFF #zF0F0F0F0)    ==> #z\n (BOOLE  1 #z0000FFFF #zF0F0F0F0)    ==> #z0000F0F0\n (BOOLE  2 #z0000FFFF #zF0F0F0F0)    ==> #zF0F00000\n (BOOLE  3 #z0000FFFF #zF0F0F0F0)    ==> #zF0F0F0F0\n (BOOLE  4 #z0000FFFF #zF0F0F0F0)    ==> #z00000F0F\n (BOOLE  5 #z0000FFFF #zF0F0F0F0)    ==> #z0000FFFF\n (BOOLE  6 #z0000FFFF #zF0F0F0F0)    ==> #zF0F00F0F\n (BOOLE  7 #z0000FFFF #zF0F0F0F0)    ==> #zF0F0FFFF\n (BOOLE  8 #z0000FFFF #zF0F0F0F0)    ==> #z0F0F0000\n (BOOLE  9 #z0000FFFF #zF0F0F0F0)    ==> #z0F0FF0F0\n (BOOLE 10 #z0000FFFF #zF0F0F0F0)    ==> #zFFFF0000\n (BOOLE 11 #z0000FFFF #zF0F0F0F0)    ==> #zFFFFF0F0\n (BOOLE 12 #z0000FFFF #zF0F0F0F0)    ==> #z0F0F0F0F\n (BOOLE 13 #z0000FFFF #zF0F0F0F0)    ==> #z0F0FFFFF\n (BOOLE 14 #z0000FFFF #zF0F0F0F0)    ==> #zFFFF0F0F\n (BOOLE 15 #z0000FFFF #zF0F0F0F0)    ==> #zFFFFFFFF\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BOUNDP": {"ttr": 2082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x88\\x12O\\x08\\x02\\x00;\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1988-05-03T08:02:00", "lines": 59, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: BOUNDP\n\nSyntax:   (BOUNDP arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n T or NIL, depending of whether the symbol specified by arg1 currently\n has a value (is bound).\n\nProcessing:\n\n The variable specified by arg1 must have a current SPECIAL binding\n (either globally, e.g. via DEFVAR, or dynamically, e.g. via LET).\n\n If it does, T is returned; otherwise, if it has a valid AUTOVALUE\n property the symbol autoload process is invoked to see if a binding can\n be obtained.  If no binding is available, NIL is returned.\n\n Lexical bindings are NOT eligible.\n\n If the symbol is NIL, T or a keyword, BOUNDP may or may not be true,\n depending on the implementation.\n\n If the argument is not a symbol, a warning message is issued and NIL\n is returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Remember that the argument to BOUNDP is evaluated.\n\n See SETQ and SYMEVAL for more information.\n\nExamples:\n\n (PROGN\n  (SETPLIST 'A NIL)                  ; Remove any funny properties.\n  (MAKUNBOUND 'A)\n )                                   ==> A ; Insure A not bound.\n\n (BOUNDP '*FEATURES*)     ==> T  ; This is always present.\n (BOUNDP 'A)              ==> NIL\n (LET ((A)) (BOUNDP 'A))  ==> NIL\n (LET ((A)) (DECLARE (SPECIAL A))\n            (BOUNDP 'A))  ==> T\n (BOUNDP 'A)              ==> NIL\n (DEFVAR A 'B)            ==> A\n (BOUNDP 'A)              ==> T\n\n (BOUNDP NIL)  ==> NIL ; or T\n (BOUNDP T)    ==> NIL ; or T\n (BOUNDP :FOO) ==> NIL ; or T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BUTLAST": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86!?\\x00\\x87$o\\x08C\\x00#\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-08-01T00:00:00", "modifydate": "1987-09-03T08:43:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: BUTLAST\n\nSyntax:   (BUTLAST list1 &optional count2)\n\n list1 (required, evaluated) - a proper list.\n count2 (optional, evaluated) - a fixnum.\n\nReturns:\n\n A list of all but the last count2 elements of list list1, where\n count2 defaults to 1.\n\nProcessing:\n\n The elements of list1 are copied, except for the last count2 elements. by\n If count2 is greater than the length of list1, NIL is returned.\n\nErrors signaled:\n\n Arg1 not a proper list.\n Arg2 not an integer.\n\nNotes:\n\nExamples:\n\n (BUTLAST '(A B C D))    ==>  (A B C)\n (BUTLAST '(A B C D) 1)  ==>  (A B C)\n (BUTLAST '(A B C D) 2)  ==>  (A B)\n (BUTLAST '(A B C D) 3)  ==>  (A)\n (BUTLAST '(A B C D) 4)  ==>  NIL\n (BUTLAST '(A B C D) 5)  ==>  NIL\n (BUTLAST '(A B C D) 0)  ==>  (A B C D)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CAAAR": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x08E\\x00\"\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T08:45:00", "lines": 34, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CAAAR\n\nSyntax:   (CAAAR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CAR of the CAR of the CAR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CAAAR '(((A B)\n           (C D)\n          )\n          ((E F)\n           (G H)\n          )\n         )      ) ==> A\n\n (CAAAAR NIL)     ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CAADR": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x08F\\x00\\x1d\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T08:46:00", "lines": 29, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CAADR\n\nSyntax:   (CAADR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CAR of the CAR of the CDR of list1.\n\nProcessing:\n\n In effect, this returns the CAR of the second element of a list.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CAADR '((A B) (C D)))  ==> C\n (CADDR NIL)             ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CAAR": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x08G\\x00\\x1b\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T08:47:00", "lines": 27, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CAAR\n\nSyntax:   (CAAR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CAR of the CAR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CAAR '((A B) (C D))) ==> A\n (CAAR NIL)            ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CADAR": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x08I\\x00\\x1a\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T08:49:00", "lines": 26, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CADAR\n\nSyntax:   (CADAR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CAR of the CDR of the CAR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\nExamples:\n\n (CADAR '((A B C) (D E F) (G H I)))  ==> B\n (CADAR NIL)                         ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CADDDR": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87%\\x8f\\x17\\x16\\x00\\x1d\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-15T17:16:00", "lines": 29, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CADDDR\n\nSyntax:   (CADDDR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CAR of the CDR of the CDR of the CDR of list1.\n\nProcessing:\n\n In effect, this returns the fourth element of a list.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CADDDR '(A B C D E)) ==> D\n (CADDDR NIL)          ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CADDR": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87%\\x8f\\x17\\x16\\x00\\x1d\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-15T17:16:00", "lines": 29, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CADDR\n\nSyntax:   (CADDR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CAR of the CDR of the CDR of list1.\n\nProcessing:\n\n In effect, this returns the third element of a list.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CADDR '(A B C D E)) ==> C\n (CADDR NIL)          ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CADR": {"ttr": 2319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87%\\x8f\\x17\\x15\\x00\\x1d\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-15T17:15:00", "lines": 29, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CADR\n\nSyntax:   (CADR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CAR of the CDR of list1.\n\nProcessing:\n\n In effect, this returns the second element of a list.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CADR '(A B C D E))  ==> B\n (CADR NIL)           ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CAR": {"ttr": 2321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x08R\\x00'\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T08:52:00", "lines": 39, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CAR\n\nSyntax:   (CAR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The first element of list1, or NIL if list1 is NIL.\n\nProcessing:\n\n If list1 is NIL, then NIL is returned.  Otherwise the contents of\n the CAR cell of list1 is returned.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n There is a function ZCAR which is functionally identical to CAR\n except that (ZCAR NIL) is an error, and is not defined.  This may\n be used, particularly in compiled code, for speed when you know\n that the argument will never be NIL.  Note that erroneously passing\n NIL to ZCAR will not be detected in compiled code.\n\nExamples:\n\n (CAR NIL)                ==> NIL\n (CAR '(A))               ==> A\n (CAR '(A B C D))         ==> A\n (CAR '((A1 A2) (B1 B2))) ==> (A1 A2)\n (CAR '(A . B))           ==> A\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CASE": {"ttr": 2323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x05_\\x00\\x87$o\\x08T\\x00K\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-24T00:00:00", "modifydate": "1987-09-03T08:54:00", "lines": 75, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: CASE\n\nSyntax:  (CASE arg1 (arg2a arg2b ... arg2z) ... (argna argnb ... argnz))\n\n arg1 (required, evaluated) - any LISP object.\n\n arg2a (not evaluated) - one of the following:\n\n   T or OTHERWISE\n   an atom\n   a list of one or more elements\n\n arg2n (optional, conditionally evaluated) - any LISP object.\n\nReturns:\n\n The last element of a clause for which arg1 matches the first element,\n either by being EQL to it or by being a member of it.\n\nProcessing:\n\n The general format of CASE is:\n\n   (CASE form                                                           ))\n       (test1 consequent1 ... consequentn)\n       (test2 consequent1 ... consequentn)\n       ...\n       (testn consequent1 ... consequentn)\n   )\n\n in which the \"testn\"'s are generally lists of values (NOT evaluated),\n although an atomic value (other than NIL) is interpreted as a list\n of one value; or T or OTHERWISE, meaning none-of-the-above.\n\n The \"form\" is evaluated and compared (using EQL) to the constant\n values specified by the \"testn\"s.  When it matches (via EQL or MEMBER)\n the forms in that clause containing the \"testn\" are evaluated as an\n implicit PROGN, and the rest of the CASE is skipped.\n If none of the clauses match, NIL is returned.\n\n\nErrors signaled:\n\n Invalid syntax (missing or invalid arguments).\n\nNotes:\n\n CASE attempts to generate EQ and/or MEMQ tests where applicable,\n for maximum efficiency.  Because of this, it is not necessary to\n use CASEQ, which is identical to CASE, and is available for\n Maclisp compatibility.\n\n For a complete discussion of CASE, refer to a MACLisp or Common LISP\n reference manual.\n\nExamples:\n\n(DEFUN TESTCASE (A)\n (CASE A\n  (0 \"zero\")\n  (1 \"one\")\n  ((2) \"two\")\n  ((3 4 5) \"three, four or five\")\n  (t \"some other number\")\n ))                                   ==> TESTCASE\n\n (TESTCASE 0)     ==> \"zero\"\n (TESTCASE 1)     ==> \"one\"\n (TESTCASE 2)     ==> \"two\"\n (TESTCASE 3)     ==> \"three, four or five\"\n (TESTCASE 4)     ==> \"three, four or five\"\n (TESTCASE 5)     ==> \"three, four or five\"\n (TESTCASE 6)     ==> \"some other number\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CATCH": {"ttr": 2325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x88\\t\\x9f\\x08X\\x00_\\x00_\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1988-04-08T08:58:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: CATCH\n\nSyntax:   (CATCH tag1 &rest forms)\n\n tag1 (required, evaluated) - any LISP object, but usually an atom.\n forms (required, evaluated) - any LISP object.\n\nReturns:\n\n The result of evaluating forms in sequence, returning the value of the\n last form, unless a THROW specifying a tag EQ to tag1 is executed\n during evaluation of one of the forms, in which case case the value\n returned by the THROW is returned.\n\nProcessing:\n\n tag1 is the \"tag\" and is evaluated first.  A catch frame is then\n created and the rest of the forms are evaluated like an implicit PROGN;\n if during the evaluation of any of these forms a THROW occurs with a\n first argument (tag) EQ to tag1, evaluation is immediately terminated\n and the value specified as the second argument of the THROW is returned\n as the value of the CATCH.  Otherwise the value returned by the last\n form in forms is returned from the CATCH.\n\n The catch frame stacked by CATCH is removed when the forms evaluation\n is complete (or when a THROW occurs).  This frame is used to store the\n current state of the ZIL environment, including the current variable\n binding environment; thus, variable bindings are restored to the status\n they possessed upon entry to the CATCH function.\n\n A CATCH may occur within the context of another CATCH; in this\n case, THROW will throw to the nearest (most recently created) CATCH\n with a matching tag.\n\n A CATCH may catch only a THROW to a tag that matches via EQ.\n Thus, the tag is generally a symbol, though it does not have to be.\n\n A THROW may occur in one of two ways:\n\n (1) The argument being evaluated is a function call that invokes\n     a THROW function, directly or indirectly.\n\n (2) An error is signalled, either by the ERROR function or by a\n     ZIL primitive (assembler language level function), which\n     results in a THROW to tag NIL.\n\n (3) An attention interrupt is caused by the terminal user pressing\n     the PA1 key (or equivalent), which results in a THROW to tag T.\n\n Thus, a CATCH with a tag of NIL will \"capture\" all signalled errors.\n\n There are two tags which have special meaning to ZIL:\n\n NIL - as described above, this catches all \"signalled\" LISP errors,\n       including system ABENDs in ZIL code (the handling of which\n       can be disabled via SETABEND NIL).\n\n T - this catches attention interrupts fielded by the ZIL attention\n     handler (which can be disabled via SETATTN NIL).\n\n The ZIL top-level READ-EVAL-PRINT loop contains CATCHes for both\n of these tags.\n\nErrors signalled:\n\n Invalid syntax (too few arguments to CATCH).\n\nNotes:\n\n GO or RETURN may be issued from within a CATCH to outside the\n CATCH, if there is a PROG which will process it.\n\nExamples:\n\n (CATCH 'A 'B)  ==> B ; Trivial case.\n\n (CATCH 'FOO (THROW 'FOO 'BAR) 'FROB)   ==> BAR\n\n (CATCH NIL\n        (CATCH 'ZZZ (THROW 'FOO 'BAR) 'FROB))  ==> NIL\n\n  ; No THROW matched the CATCH tag - an error was signalled,\n  ; resulting in a THROW to NIL.\n  ; In addition, an error message would appear at the user's terminal.\n\n (CATCH '(FOO) (THROW '(FOO) 'BAR) 'FROB)   ==> (\"***ERROR***\")\n\n  ; The THROW tag was not EQ to the CATCH tag - error was signalled.\n\n (CATCH NIL (+ 'A 'B))                        ==> NIL\n\n  ; An error was signalled, causing a THROW to NIL.\n  ; In addition, an error message would appear at the user's terminal.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CDAAR": {"ttr": 2327, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x02\\x00\\x1b\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:02:00", "lines": 27, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CDAAR\n\nSyntax:   (CDAAR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CDR of the CAR of the CAR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CDAAR '((((A B) C) D) E))  ==> (C)\n (CDAAR NIL)                 ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDADR": {"ttr": 2329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x03\\x00\\x1d\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:03:00", "lines": 29, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CDADR\n\nSyntax:   (CDADR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CDR of the CAR of the CDR of list1.\n\nProcessing:\n\n In effect, this returns the CDR of the second element of the list.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CDADR '((A B) (C D)))  ==> (D)\n (CDADR NIL)             ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDAR": {"ttr": 2331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x04\\x00\\x1b\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:04:00", "lines": 27, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CDAR\n\nSyntax:   (CDAR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CDR of the CAR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CDAR '((A B) (C D)))  ==> (B)\n (CDAR NIL)             ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDDAR": {"ttr": 2333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x04\\x00\\x1b\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:04:00", "lines": 27, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CDDAR\n\nSyntax:   (CDDAR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CDR of the CDR of the CAR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CDDAR '((A B C) (D E F) (G H I)))  ==> (C)\n (CDDAR NIL)                         ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDDDR": {"ttr": 2335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x04\\x00\\x1b\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:04:00", "lines": 27, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CDDDR\n\nSyntax:   (CDDDR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CDR of the CDR of the CDR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CDDDR '(A B C D E))  ==> (D E)\n (CDDDR NIL)           ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDDR": {"ttr": 2337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x05\\x00\\x1b\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:05:00", "lines": 27, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CDDR\n\nSyntax:   (CDDR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The CDR of the CDR of list1.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CDDR '(A B C D E))  ==> (C D E)\n (CDDR NIL)           ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDR": {"ttr": 2339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x05\\x00%\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:05:00", "lines": 37, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CDR\n\nSyntax:   (CDR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n NIL, if list1 is NIL; or the portion of the list specified by list1\n that does not include the first element (CAR); or, if list1 is a dotted\n pair, the second element of the pair.\n\nProcessing:\n\n The \"rest\" of a list, i.e. a list of the second through last elements,\n is the value returned.  This is always a sublist of the original list\n (not a copy).  CDR of NIL or of a one-element list returns NIL.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (CDR NIL)                ==> NIL\n (CDR '(A))               ==> NIL\n (CDR '(A B))             ==> (B)\n (CDR '(A B C D))         ==> (B C D)\n (CDR '((A1 A2) (B1 B2))) ==> ((B1 B2))\n (CDR '(A . B))           ==> B\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CEILING": {"ttr": 2341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87(\\x7f\\x00\\x89\\x05O\\x17G\\x00Y\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1989-02-23T17:47:00", "lines": 89, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CEILING\n\nSyntax:   (CEILING arg1 &optional arg2)\n\n arg1 (required, evaluated) - a number.\n arg2 (optional, evaluated) - a number.\n\nReturns:\n\n Two values:\n\n  (1) arg1, or arg1 divided by arg2, converted to an integer.\n  (2) If arg1 only is specified, the difference of arg1 and the\n      first value.\n      If arg1 and arg2 are specified, the remainder, i.e. the difference\n      of arg1 and (arg2 times the first value).\n\nProcessing:\n\n If arg2 is specified, arg1 is divided by arg2 such that a floating\n point result is obtained.  Otherwise, the argument is set to arg1.\n\n If the argument is float, the nearest integer greater than or equal to\n the argument is returned.\n\n If the argument is integer, itself is returned.\n\nErrors signaled:\n\n Non-numeric argument(s).\n\nNotes:\n\n Compare ROUND, which rounds its argument to the nearest integer; FLOOR,\n which returns the nearest integer less than or equal to its argument;\n and TRUNCATE, which returns the integer part of the flonum.\n\n Note that flonums whose exponent is large (in either direction) may\n result in integers whose value does not accurately represent the\n integer part of the flonum.\n\nExamples:\n\n ; Note: Only the first value is shown in these examples.\n\n (CEILING 1)                ==> 1\n (CEILING 1.5)              ==> 2\n (CEILING 1.5F0)            ==> 2\n (CEILING 1.9)              ==> 2\n (CEILING 1.9F0)            ==> 2\n (CEILING 1.2)              ==> 2\n (CEILING 1.2F0)            ==> 2\n (CEILING 0)                ==> 0\n (CEILING 0.5)              ==> 1\n (CEILING 0.5F0)            ==> 1\n (CEILING 0.9)              ==> 1\n (CEILING 0.9F0)            ==> 1\n (CEILING 0.2)              ==> 1\n (CEILING 0.2F0)            ==> 1\n (CEILING -1)               ==> -1\n (CEILING -1.5)             ==> -1\n (CEILING -1.9)             ==> -1\n (CEILING -1.2)             ==> -1\n (CEILING -0)               ==> 0\n (CEILING -0.5)             ==> 0\n (CEILING -0.9)             ==> 0\n (CEILING -0.2)             ==> 0\n (CEILING 7E-4)             ==> 1\n (CEILING -123.45)          ==> -123\n (CEILING -123.45F0)        ==> -123\n (CEILING 2147483647.0)     ==> 21\n (CEILING 2147483647.5)     ==> 21\n (CEILING 2147483648.0)     ==> 21\n (CEILING 2147483648.5)     ==> 21\n (CEILING 2147483649.0)     ==> 21\n (CEILING 2147483649.5)     ==> 21\n (CEILING -2147483647.0)    ==> -21\n (CEILING -2147483647.5)    ==> -21\n (CEILING -2147483648.0)    ==> -21\n (CEILING -2147483648.5)    ==> -21\n (CEILING -2147483649.0)    ==> -21\n (CEILING -2147483649.5)    ==> -21\n\n (CEILING 10 3)             ==> 4\n (CEILING -10 3)            ==> -3\n (CEILING 9 3)              ==> 3\n (CEILING -9 3)             ==> -3\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHAR": {"ttr": 2343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x08O\\x00\\x87$o\\x17\\x06\\x00/\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-25T00:00:00", "modifydate": "1987-09-03T17:06:00", "lines": 47, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CHAR\n\nSyntax:   (CHAR string1 index2)\n\n string1 (required, evaluated) - a string.\n index2  (required, evaluated) - a fixnum.\n\nReturns:\n\n The index2'th character of string1, as a fixnum.\n\nProcessing:\n\n index2 is used as a zero-based index into string1, where the characters\n of the string are indexed from 0 to the string length minus 1.\n\n The resultant character is made into the fixnum representing the\n EBCDIC value of the character.\n\n If index2 is out of bounds with respect to the string, NIL is returned.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Invalid second argument (not a fixnum).\n\nNotes:\n\n Observe the distinctions between the character extracting functions:\n\n GETCHAR   -  uses one-based indexing, returns a symbol.\n GETCHARN  -  uses one-based indexing, returns a fixnum.\n CHAR      -  uses zero-based indexing, returns a fixnum.\n\nExamples:\n\n (CHAR \"foo\" 0)           ==> #\\f\n (CHAR \"foo\" 1)           ==> #\\o\n (CHAR \"foo\" 2)           ==> #\\o\n (CHAR \"foo\" 3)           ==> NIL\n (CHAR \"foo\" 4)           ==> NIL\n (CHAR 'BAR 0)            ==> #\\B\n (CHAR 'BAR 1)            ==> #\\A\n (CHAR 'BAR 2)            ==> #\\R\n (CHAR 'BAR 3)            ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHARDOWN": {"ttr": 2345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x05\\x8f\\x00\\x87$o\\x17\\x07\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-27T00:00:00", "modifydate": "1987-09-03T17:07:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CHAR-DOWNCASE\n\nSyntax:   (CHAR-DOWNCASE arg1)\n    or:   (CHARDOWN arg1)\n\n arg1 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum representing the EBCDIC character which is the lower-case\n equivalent of the character represented by the fixnum arg1.\n\nProcessing:\n\n If arg1 does not represent a lower-case alphabetic character,\n itself is returned; otherwise the equivalent lower-case fixnum\n is returned.\n\nErrors signaled:\n\n arg1 not a fixnum.\n\nNotes:\n\nExamples:\n\n (CHAR-DOWNCASE #/a)  ==> #/a\n (CHAR-DOWNCASE #/A)  ==> #/a\n (CHAR-DOWNCASE #/1)  ==> #/1\n (CHAR-DOWNCASE 4000) ==> 4000  ; unchanged.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHARP": {"ttr": 2347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x1f\\x00\\x885\\x1f\\t\"\\x005\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-16T00:00:00", "modifydate": "1988-12-16T09:22:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CHARACTERP\n\nSyntax:   (CHARACTERP arg1)\n    or:   (CHARP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a \"character\" (i.e. an integer between 0 and 255),\n else NIL.\n\nProcessing:\n\n If the argument is a fixnum, and its value is such that it can be\n considered a \"character\" (i.e. it can fit in 8 bits), then T is\n returned.  Otherwise NIL is returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Characters are not a true data type in ZIL.  They are in Common LISP.\n\nExamples:\n\n (CHARACTERP 1.0)          ==> NIL\n (CHARACTERP 1.0F0)        ==> NIL\n (CHARACTERP \"1\")          ==> NIL\n (CHARACTERP '(1))         ==> NIL\n (CHARACTERP 'ONE)         ==> NIL\n (CHARACTERP 1)            ==> T\n (characterp 0)            ==> T\n (characterp 255)          ==> T\n (characterp 256)          ==> NIL\n (characterp -1)           ==> NIL\n (characterp -255)         ==> NIL\n (characterp 0.0)          ==> NIL\n (characterp 2147483648)   ==> NIL\n (CHARACTERP 123456789876) ==> NIL\n (characterp #\\space)      ==> T\n (characterp #\\tab  )      ==> T\n (characterp #\\nl   )      ==> T\n (characterp #\\$    )      ==> T\n (characterp #\\a    )      ==> T\n (characterp #\\A    )      ==> T\n (characterp #\\0    )      ==> T\n (characterp #\\?    )      ==> T\n (loop for i from 0 to 255 always (characterp i))  ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHARUP": {"ttr": 2349, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x05\\x8f\\x00\\x87$o\\x17\\x07\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-27T00:00:00", "modifydate": "1987-09-03T17:07:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CHAR-UPCASE\n\nSyntax:   (CHAR-UPCASE arg1)\n    or:   (CHARUP arg1)\n\n arg1 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum representing the EBCDIC character which is the upper-case\n equivalent of the character represented by the fixnum arg1.\n\nProcessing:\n\n If arg1 does not represent a lower-case alphabetic character,\n itself is returned; otherwise the equivalent upper-case fixnum\n is returned.\n\nErrors signaled:\n\n arg1 not a fixnum.\n\nNotes:\n\nExamples:\n\n (CHAR-UPCASE #/a)    ==> #/A\n (CHAR-UPCASE #/A)    ==> #/A\n (CHAR-UPCASE #/1)    ==> #/1\n (CHAR-UPCASE 4000)   ==> 4000  ; unchanged.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CLOSE": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\\x18\\x00Y\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:18:00", "lines": 89, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CLOSE\n\nSyntax:   (CLOSE file1 &optional arg2)\n\n file1 (required, evaluated) - a file name.\n arg2  (optional, evaluated) - NIL, or one of the following symbols:\n                               INPUT, OUTPUT, IN, OUT, APPEND.\n\nReturns:\n\n NIL, after closing the file specified by file1.  Whether the file is an\n input file or an output file is determined by arg2.\n\nProcessing:\n\n The file specified by file1, if it exists, is closed and the associated\n file block is freed, as well as storage associated with the file.\n\n arg2 determines whether the file is an input or output file, since\n these are distinct in ZIL.  Possible values are:\n\n   INPUT   -  the file is open for input.\n   OUTPUT  -  the file is open for output.\n   APPEND  -  the file is open for output in \"append\" mode.\n\n If arg2 is omitted or NIL, INPUT is assumed.\n\n IN and INPUT are equivalent, as are OUT, OUTPUT and APPEND (these\n variants exist for compatibility with the types specified on OPEN and\n have no effect on what happens to the data set when it is closed).\n\n Any of these non-NIL values can be specified with a leading colon\n (i.e. as a \"keyword\").  In other words, OUT and :OUT are equivalent.\n Furthermore, if a list is specified as the second argument, the CAR\n of that list is assumed to be the file type and is analyzed as above.\n Thus, the following are equivalent:\n\n   (CLOSE F)\n   (CLOSE F NIL)\n   (CLOSE F 'IN)\n   (CLOSE F 'INPUT)\n   (CLOSE F :IN)\n   (CLOSE F :INPUT)\n   (CLOSE F '(IN))\n   (CLOSE F '(:INPUT FROBNICANT BARFUCIOUS))\n\n Once a file is closed, a subsequent input or output operation on the\n same file causes it to be reopened.  Thus, if you have read from a file\n and wish to start reading it from the beginning, CLOSE the file and\n then issue a READ.  If you wish to overwrite a file, wiping out\n whatever you have previously printed there, CLOSE it (don't forget to\n specify 'OUTPUT or 'OUT) and write to it again.\n\n It may be necessary to CLOSE one or more files in order to make\n virtual storage available to other functions (including OPEN of\n other files).\n\nErrors signaled:\n\n Invalid second argument (not one of those listed above).\n File NIL specified (closing standard input/output is not allowed).\n File does not exist (possibly file type not correctly specified).\n\nNotes:\n\n See OPEN for more information.\n\n See member $FILE for more information on file names.\n\n Under Macsyma, CLOSE does not require the second argument.\n Furthermore, you can CLOSE only files that were opened via the\n OPEN function in Macsyma (in other words, you cannot CLOSE files\n that are opened implicitly by an I/O operation).\n\nExamples:\n\n  (CLOSE 'FOO)            closes input file FOO.\n  (CLOSE 'FOO 'INPUT)     closes input file FOO.\n  (CLOSE 'FOO 'OUTPUT)    closes output file FOO.\n  (CLOSE 'FOO 'APPEND)    closes output file FOO (equivalent to prev).\n\n A typical sequence could be like this:\n\n (SETQ A (OPEN \"'PROGLIB.ZIL.SOURCE(JUNK)'\"))\n (READ A)\n  ...\n (CLOSE A)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLOSUREP": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\"\\x00*\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:22:00", "lines": 42, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CLOSUREP\n\nSyntax:   (CLOSUREP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a compiled closure, otherwise NIL.\n\nProcessing:\n\n A compiled closure is the result of compiling the special form\n (FUNCTION ...); this creates an object consisting of a pointer to\n compiled subroutine code and a pointer to the environment current at\n the time the closure was created.\n\n Compiled closures may be executed directly by ZILXSUB or ZILXFUN, but\n they are generally passed to APPLY or FUNCALL.\n In addition, they can be specified as the CAR of a list passed to EVAL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The FUNCTION special form in the interpretive environment\n does not create a CLOSUREP form; rather, it creates an object\n called a FUNARG (interpreted lexical closure).  The predicate\n FUNARGP returns T for such an object.\n\nExamples:\n\n (CLOSUREP 'CAR)           ==> NIL\n (CLOSUREP (FUNCTION CAR)) ==> NIL ; in the interpretive environment\n;(CLOSUREP (FUNCTION CAR)) ==> T ; compiled\n (CLOSUREP (ZILLOAD 'CAR)) ==> NIL\n (SETF (PLIST 'FOO) NIL)   ==> NIL ; dummy to initialize SETF setup\n (CLOSUREP (GET 'CAR 'SETFMETHOD)) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CLRSCRN": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17\"\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:22:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CLRSCRN\n\nSyntax:   (CLRSCRN)\n\nReturns:\n\n NIL, after clearing the screen of a 3270-type terminal.\n\nProcessing:\n\n TCAM/VTAM conventions are adhered to in order to insure, whenever\n possible, that line messages are not lost when the screen is cleared.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (CLRSCRN)     ... returns NIL after clearing the screen.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CODEP": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\\x17#\\x00!\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T17:23:00", "lines": 33, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CODEP\n\nSyntax:   (CODEP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is some type of compiled code object or compiled closure,\n otherwise NIL.\n\nProcessing:\n\n See SUBRP and CLOSUREP for descriptions of the types of compiled\n code objects known to ZIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (CODEP 'CAR)               ==> NIL\n (CODEP (FUNCTION CAR))     ==> NIL ; in the interpretive environment\n;(CODEP (FUNCTION CAR))     ==> T ; compiled\n (CODEP (ZILLOAD 'CAR))     ==> T\n (CODEP (GET 'CODEP 'SUBR)) ==> T\n (SETF (PLIST 'FOO) NIL)    ==> NIL ; dummy to initialize SETF setup\n (CODEP (GET 'CAR 'SETFMETHOD)) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMMENT": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87$o\\x17%\\x00 \\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-03T17:25:00", "lines": 32, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: COMMENT\n\nSyntax:   (COMMENT &rest args)\n\n arg (optional, not evaluated) - any LISP object.\n\nReturns:\n\n The symbol COMMENT.\n\nProcessing:\n\n This is treated as a comment, and does nothing.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Using real comments (with ; or #| ... |#) is preferable, since\n LISP syntax rules have to be adhered to inside (COMMENT ...)\n but not with the other constructs.\n\n The compiler will usually optimize out uses of COMMENT, but not\n if you use it somewhere where it has to return a value!\n\nExamples:\n\n (COMMENT THIS IS JUST A DUMB COMMENT)  ==>  COMMENT\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONCAT": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x04/\\x00\\x87%\\x8f\\x076\\x005\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-02-11T00:00:00", "modifydate": "1987-09-15T07:36:00", "lines": 53, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CONCAT\n\nSyntax:   (CONCAT &rest args)\n\n arg (optional, evaluated) - any object that is not a list, vector,\n                             structure, or interpreted lexical closure.\n\nReturns:\n\n An interned symbol whose print name consists of args concatenated to\n form a new atom name.\n\nProcessing:\n\n The args are converted to the character representations that they have\n when printed via PRINC.  These are the actual print names for symbols,\n the text for strings, converted representations for numbers, and\n internally generated values for other types.  The resulting character\n strings are concatenated together to build a symbol whose name is that\n string, and that symbol is interned on the oblist.\n\n If there are no args, a symbol with a null print name is returned.\n\nErrors signaled:\n\n List, vector, structure, or funarg found as one of the arguments.\n\nNotes:\n\n This is a Franz LISP function, added to ZIL for OPS5 support.\n Compare UCONCAT, which is identical to CONCAT except that it\n creates an uninterned symbol.\n\n Compare CONCATL, which is like applying CONCAT to a list of arguments.\n\n Also compare ZILIMPL, which may be used to create numbers as well as\n interned or uninterned symbols; and STRING-APPEND, which builds\n strings rather than symbols.\n\nExamples:\n\n (CONCAT)                   ==> ||\n (CONCAT 'A)                ==> A\n (CONCAT 'A 'B 1 'C \"D\")    ==> AB1CD\n (CONCAT \"f\" \"o\" \"o\")       ==> |foo|\n (CONCAT \"FOO\" 'BAR)        ==> FOOBAR\n (CONCAT 007 1.0 \"foobar\")  ==> |71.0foobar|\n\n (SETQ A (CONCAT 'F 'O 'O))        ==> FOO\n (SETQ B (CONCAT \"F\" \"O\" \"O\"))     ==> FOO\n (EQ A B)                          ==> T   ; always interned.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONCATL": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x05\\x0f\\x00\\x87$o\\x18\\x06\\x004\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-19T00:00:00", "modifydate": "1987-09-03T18:06:00", "lines": 52, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CONCATL\n\nSyntax:   (CONCATL arg1)\n\n arg1 (required, evaluated) - a proper list of atoms.\n\nReturns:\n\n An interned symbol whose print name consists of the atoms in the list\n specified by arg1 concatenated to form a new atom name.\n\nProcessing:\n\n The CAR's of arg1, which must be a non-null list of atoms, are\n converted to the character representations that they have when printed\n via PRINC.  These are the actual print names for symbols, the text for\n strings, converted representations for numbers, and internally\n generated values for other types.  The resulting character strings are\n concatenated together to build an interned symbol whose name is that\n string.\n\n arg1 may be NIL, in which case a symbol with a null print name is\n returned.\n\nErrors signaled:\n\n arg1 not a list of atoms (nested lists and vectors are not permitted).\n\nNotes:\n\n CONCATL is a Franz LISP function which is implemented in ZIL using\n ZILIMPL.\n\n Compare UCONCATL, which is identical to CONCATL except that it\n returns an uninterned symbol.\n\n (CONCATL x) is equivalent to (APPLY #'CONCAT x), but more efficient.\n\n (UCONCATL x) is equivalent to (APPLY #'UCONCAT x), but more efficient.\n\n\nExamples:\n\n (CONCATL '(A))                ==> A\n (CONCATL '(F O O))            ==> FOO\n (CONCATL '(FOO BAR))          ==> FOOBAR\n (CONCATL '(007 1.0 \"foobar\")) ==> |71.0foobar| ; A symbol.\n\n (SETQ A (CONCATL '(F O O)))       ==> FOO ; interned.\n (EQ A 'FOO)                       ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COND": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\"\\x02\\x00N\\x00O\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T22:02:00", "lines": 78, "newlines": 79, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: COND\n\nSyntax:   (COND clause1 clause2 ... clausen)\n\n          where each clausex is of one of the following forms:\n            (form1)\n            (form1 form2)\n            (form1 ... formn)\n\n          Any number of clauses may be specified, but each clause\n          must be a proper list of 1 or more elements.\n\n formx (conditionally evaluated) - any LISP object.\n\nReturns:\n\n The final element of the first clause for which the first formx element\n evaluates to a non-NIL value; NIL if no clauses satisfy this condition.\n\nProcessing:\n\n Each clause is taken in succession.  The first element of the clause is\n evaluated.  If the result was NIL, the remaining elements (if any) of\n the clause are bypassed and processing continues with the next clause.\n If the result was non-NIL, then if this was the only element in the\n clause (i.e. the clause is a singleton list), that value is returned as\n the result of the COND; otherwise the remaining elements of the clause\n are evaluated in succession and the last such value is returned as the\n result; all following \"pairs\" are bypassed.\n\n This is known as \"short-circuit\" evaluation.\n\n If no clause is found with a first element that evaluates to non-NIL,\n NIL is returned as the value of the COND function.\n\n By convention, T is generally used as the first element of the\n final clause; since T always evaluates to non-NIL, this makes the\n final clause the \"otherwise\" or \"ELSE\" clause of the COND.\n\n (COND ((cond1 result1) (cond2 result2) ... (T resultn))\n  is equivalent to\n (IF cond1 THEN result1 ELSE IF cond2 THEN result2 ... ELSE resultn).\n\nErrors signaled:\n\n Invalid syntax (argument clause not a list).\n\nNotes:\n\nExamples:\n\n (COND ('A 'B) ('C 'D))     ==> B\n\n (COND (NIL 'B) ('C 'D))    ==> D\n\n (COND ((EQ 'A 'B) 'C))     ==> NIL\n\n (COND ((EQ 'A 'A) 'TRUE1)\n       ((EQ 'A 'B) 'TRUE2)\n       (T          'FALSE)) ==> TRUE1\n\n (COND ((EQ 'A 'B) 'TRUE1)\n       ((EQ 'A 'A) 'TRUE2)\n       (T          'FALSE)) ==> TRUE2\n\n (COND ((EQ 'A 'B) 'TRUE1)\n       ((EQ 'A 'C) 'TRUE2)\n       (T          'FALSE)) ==> FALSE\n\n (COND ((EQ 'A 'B) 'TRUE1)\n       ((EQ 'A 'C) 'TRUE2)\n       ((EQ 'A 'D) 'TRUE3)) ==> NIL\n\n (COND ('A) ('B 'C))        ==> A\n\n (COND ('A 'B 'C) ('D 'E))  ==> C\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONS": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o\"\\x03\\x00%\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T22:03:00", "lines": 37, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CONS\n\nSyntax:   (CONS arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n A cons (list or dotted pair) whose CAR is arg1 and whose CDR is arg2.\n\n If arg2 is a list or NIL, a list is produced; if arg2 is an atom, a\n dotted pair is produced.  In fact, a list is the special case of a\n dotted pair whose second element is a list or NIL.\n\nProcessing:\n\n A new cell is obtained from available CONS space to construct the new\n object.  If CONS space is exhausted, a garbage collection occurs, and\n the new cell is returned if enough storage is reclaimed to permit it.\n\nErrors signaled:\n\n No cons cells free after garbage collection.\n\nNotes:\n\nExamples:\n\n (CONS 'A '(B C D))       ==> (A B C D)\n (CONS 'A 'B)             ==> (A . B)\n (CONS 'A '(B))           ==> (A B)\n (CONS '(A B) '(C D))     ==> ((A B) C D)\n (CONS 'A NIL)            ==> (A)\n (CONS NIL NIL)           ==> (NIL)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONSP": {"ttr": 2579, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87$o\"\\x04\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-03T22:04:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CONSP\n\nSyntax:   (CONSP arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a cons (non-null list or dotted pair), otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (CONSP 'FOO)            ==> NIL\n (CONSP NIL)             ==> NIL\n (CONSP '(NIL))          ==> T\n (CONSP \"hi there\")      ==> NIL\n (CONSP '(A B C))        ==> T\n (CONSP #(A B C))        ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYENV": {"ttr": 2581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x08\\x17\\x00\\x1e\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:17:00", "lines": 30, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: COPYENV\n\nSyntax:   (COPYENV env1)\n\n env1 (required, evaluated) - an evaluation environment.\n\nReturns:\n\n A new evaluation environment which is a copy of env1.\n\nProcessing:\n\n COPYENV builds an evaluation environment which contains the same\n components as env1.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This is an internal ZIL function used by the evaluator to implement\n lexical scoping.  The format of an evaluation environment is\n system-dependent; however, the FUNENV function will return the\n environment component of an interpreted lexical closure if you're\n interested in knowing what an evaluation environment looks like in ZIL.\n\n See also MKNEWENV.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COPYSYM": {"ttr": 2583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86#O\\x00\\x87$o\"\\x07\\x009\\x008\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-08-22T00:00:00", "modifydate": "1987-09-03T22:07:00", "lines": 57, "newlines": 56, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: COPY-SYMBOL\n\nSyntax:   (COPY-SYMBOL symbol1 arg2)\n    or:   (COPYSYM symbol1 arg2)\n\n symbol1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n An uninterned symbol whose print name is the same as symbol1's, with\n a copy of its property list only if arg2 is non-NIL.\n\nProcessing:\n\n A new symbol is created with the same print name as that of symbol1.\n The new symbol is not interned on the oblist; therefore it will not\n be EQ to symbol1 or any other symbol.\n\n If arg2 is NIL, the new symbol will be given a null property list.\n Otherwise (arg2 is non-NIL), a copy of symbol1's property list (this\n is a top-level copy as made by APPEND) is made the property list of\n the new symbol.  Also if arg2 is non-NIL, the current SPECIAL\n variable value and function definition are copied to the new symbol.\n\nErrors signaled:\n\n First argument not a symbol.\n\nNotes:\n\n If the property list is copied, it is done in order to prevent\n property list operations from side-effecting the property list of\n the other symbol.\n\nExamples:\n\n (SETPLIST 'FOO (LIST 'A 'B 'C 'D)) ==> FOO\n (SETQ A (COPY-SYMBOL 'FOO NIL))    ==> FOO ; but not interned\n (EQ A 'FOO)                        ==> NIL\n (PLIST A)                          ==> NIL\n\n (GET 'FOO 'A)                      ==> B\n (GET A 'A)                         ==> NIL\n\n (SETQ A (COPY-SYMBOL 'FOO T))      ==> FOO ; but not interned\n (EQ A 'FOO)                        ==> NIL\n (PLIST A)                          ==> (A B C D)\n\n (GET 'FOO 'A)                      ==> B\n (GET A 'A)                         ==> B\n\n (SETF (GET 'FOO 'A) 'C)            ==> C\n (GET 'FOO 'A)                      ==> C\n (GET A 'A)                         ==> B  ; not affected.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COPYTREE": {"ttr": 2585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x05/\\x00\\x87$o\"\\t\\x00+\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-21T00:00:00", "modifydate": "1987-09-03T22:09:00", "lines": 43, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: COPY-TREE\n\nSyntax:   (COPY-TREE list1)\n    or:   (COPYTREE list1)\n\n list1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A copy of list1 which shares no CONSes with it.\n\nProcessing:\n\n If list1 is an atom, it is returned.  Otherwise, a new copy of list1\n is built by consing COPY-TREE of (car list1) with COPY-TREE of\n (cdr list1).\n\n The resulting list is EQUAL, but not EQ, to the original list, as are\n all its non-atomic elements.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n It may be useful to use COPY-TREE to make updatable copies of inline\n compiled lists, which can otherwise not be updated without potentially\n compromising the integrity of the LISP system.\n\nExamples:\n\n (COPY-TREE 'A)            ==> A\n (COPY-TREE '(A B))        ==> (A B)\n (COPY-TREE '(A (B) C))    ==> (A (B) C)\n (SETQ X '((A B) C . D))   ==> ((A B) C . D)\n (SETQ Y (COPY-TREE X))    ==> ((A B) C . D)\n (EQ X Y)                  ==> NIL\n (EQUAL X Y)               ==> T\n (EQ (CAR X) (CAR Y))      ==> NIL\n (EQUAL (CAR X) (CAR Y))   ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COS": {"ttr": 2587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x7f\\x00\\x87$o\"\\x16\\x00,\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-26T00:00:00", "modifydate": "1987-09-03T22:16:00", "lines": 44, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: COS\n\nSyntax:   (COS num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n A number which is the cosine of num1, where num1 is expressed in\n radians.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the\n value from num1.  If num1 is a single-precision flonum, the\n result is a single-precision flonum; otherwise the result is\n a double-precision flonum.\n\nErrors signaled:\n\n Non-numeric argument.\n For single precision, abs(arg) greater than 823549.5625.\n For double precision, abs(arg) greater than 3537118876014220.125.\n These values are the maximum that the FORTRAN subroutine library\n will successfully process.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\n Bignums are not supported as arguments to this function.\n\n\nExamples:\n\n(COS 0) ==> 1.0\n(COS 1) ==> 0.54030230\n(COS -1) ==> 0.54030230\n(COS 0.5) ==> 0.87758256\n(COS 0.5F0) ==> 0.8775826F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CSSIZE": {"ttr": 2589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x07/\\x00\\x87$o\"#\\x00\\x16\\x00\\n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-03-13T00:00:00", "modifydate": "1987-09-03T22:23:00", "lines": 22, "newlines": 10, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CSSIZE\n\nSyntax:   (CSSIZE)\n\nReturns:\n\n An integer containing the total number of BYTES (not cells) in\n CONS space.\n\nNotes:\n\n This value may be specified via the PARM field, or in a DECLARE,\n when a ZIL \"program\" is run.  See members $PARM and DECLARE of\n this documentation for more information.\n\n Do not confuse this function with ACSIZE, which returns the total\n number of bytes in currently active CONS space.  CSSIZE returns\n the maximum amount of CONS space allocated that may be called upon\n to be in use, provided that enough CONS cells are used up after a\n certain number of garbage collections.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTERPRI": {"ttr": 2591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x08\\x15\\x00.\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:15:00", "lines": 46, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CTERPRI\n\nSyntax:   (CTERPRI &optional file1)\n\n file1 (optional, evaluated) - an output file name.\n\nReturns:\n\n T or NIL, depending on whether there is data on the current line\n of the output file specified by file1.\n\nProcessing:\n\n Each invocation of CTERPRI causes a line to be written out to the\n specified output file if and only if there is data on the current\n output line (T is returned as the value).  If no data has been\n written to the current line, no operation is performed (NIL is\n returned in that case).\n\n The current character position is reset to 1 when CTERPRI is issued,\n and the output line is cleared to blanks.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n CTERPRI invokes TERPRI to write out the current output line.\n See TERPRI for more information.\n\n See member $PRINTER for more information on printing functions.\n\nExamples:\n\n (CTERPRI)\n (CTERPRI NIL) ...are equivalent and return NIL after writing the\n                 current line of standard output, if it is not empty.\n\n (CTERPRI 'FOO) ...writes out the contents of the current line of\n                  output file FOO, if there is any data on it.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CURDATE": {"ttr": 2593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x00\\x86\"O\\x01\\x00\\x10O\\x14G\\x00&\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-08-12T00:00:00", "modifydate": "2000-04-13T14:47:48", "lines": 38, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CURDATE\n\nSyntax:   (CURDATE)\n    or:   (CURRENT-DATE)\n\nReturns:\n\n A list of 3 integers, representing the current date as the year,\n month, and day of month.\n\nProcessing:\n\n The current date is determined and converted from Julian to Gregorian,\n and a list is made of the 3 components.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The algorithm used to determine if the current year is a leap year\n will fail in the year 2100, and for all multiples of 100 that are\n not also multiples of 400 thereafter.\n\n If a garbage collection occurs while building the list, the date\n returned may be inaccurate if it was requested before midnight\n but the GC completed after midnight.\n\n The year returned is a 4-digit year, as opposed to Zil prior to\n 2000, which was not Y2K compliant and returned a 2-digit year.\n\nExamples:\n\n; (CURDATE)     ==> (86 8 12)   ; on August 12, 1986\n; (CURDATE)     ==> (2000 4 13) ; on April 13, 2000\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CURJDATE": {"ttr": 2595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x00\\x86#?\\x01\\x00\\x10O\\x14H\\x00!\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-08-21T00:00:00", "modifydate": "2000-04-13T14:48:41", "lines": 33, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CURJDATE\n\nSyntax:   (CURJDATE)\n    or:   (CURRENT-JDATE)\n\nReturns:\n\n A list of 2 integers, representing the current Julian date as the\n year and days.\n\nProcessing:\n\n The current date is determined and a list is made of the 2 components.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n If a garbage collection occurs while building the list, the date\n returned may be inaccurate if it was requested before midnight\n but the GC completed after midnight.\n\n The year returned is a 4-digit year, as opposed to Zil prior to\n 2000, which was not Y2K compliant and returned a 2-digit year.\n\nExamples:\n\n; (CURJDATE)    ==> (86 233)   ; on August 21, 1986\n; (CURJDATE)    ==> (2000 104) ; on April 13, 2000\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CURTIME": {"ttr": 2597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\"O\\x00\\x86\"O\\x08H\\x00\\x1f\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-08-12T00:00:00", "modifydate": "1986-08-12T08:48:00", "lines": 31, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: CURTIME\n\nSyntax:   (CURTIME)\n    or:   (CURRENT-TIME)\n\nReturns:\n\n A list of 3 integers, representing the current time in hours,\n minutes, and seconds.\n\nProcessing:\n\n The current time of day is determined, and a list is made of the\n 2 components.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n If a garbage collection occurs while building the list, the time\n returned may be inaccurate; but it will reflect the time before\n the GC occurred.\n\nExamples:\n\n; (CURTIME)     ==> (8 10 31)   ; at 8:10 AM and 31 seconds\n; (CURTIME)     ==> (13 14 15)  ; at 1:14 PM and 15 seconds\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DECF": {"ttr": 2599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x865\\x7f\\x00\\x87$o\"&\\x00+\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-12-23T00:00:00", "modifydate": "1987-09-03T22:26:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DECF\n\nSyntax:   (DECF place1 &optional decrement2)\n\n place1 (required) - a form acceptable to SETF which evaluates to a\n                     number.\n decrement2 (optional, evaluated) - a number.\n\nReturns:\n\n place1, after it has been decremented by decrement2.\n\nProcessing:\n\n place1 is typically a variable, but in general is any form acceptable\n as the first argument to SETF.\n The variable or location specified by place1 is decremented by\n subtracting from it the value of decrement2, which defaults to 1 if not\n specified.\n\nErrors signaled:\n\n None by the macro, but the decrement will fail if bad args are used.\n\nNotes:\n\n Compare INCF, which increments.\n\n DECF is a macro that expands something like this:\n\n  (DECF a b)  --> (SETF a (- a b))\n\nExamples:\n\n (SETQ A 10)  ==> 10\n (DECF A)     ==> 9\n A            ==> 9\n (DECF A 3)   ==> 6\n A            ==> 6\n (DECF A -1)  ==> 7\n A            ==> 7\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DECLARE": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x86\\x07o\\x00\\x87$o\"S\\x00\\xec\\x008\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1986-03-17T00:00:00", "modifydate": "1987-09-03T22:53:00", "lines": 236, "newlines": 56, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: DECLARE\n\nSyntax:   (DECLARE &rest args)\n\n arg (optional, not evaluated) - any LISP object.\n\nReturns:\n\n NIL.\n\nProcessing:\n\n Under the ZIL interpreter, all DECLAREs except those for SPECIAL\n variables are ignored.  However, under the compiler DECLARE is used to\n convey information about a host of different things.\n\n Although there are many clauses that can occur within a DECLARE,\n many are ignored by the ZIL compiler (although they do not cause\n an error).  The ones recognized by ZIL include those below.\n\n DECLARE may occur at top level, or within a LAMBDA, DEFUN, PROG,\n LET, or other variable binding form, provided that the DECLARE\n form or forms be the first forms in the body; that is, they may\n not be preceded by other kinds of forms, with the possible\n exception of documentation strings.\n\n Within a form, the only recognized clauses are:\n\n   (SPECIAL &rest vars) - this clause tells the compiler AND the\n     interpreter that the variables (symbols) named herein are to be\n     processed as \"free\" variables; i.e. other functions may refer to\n     their dynamic bindings, these being true Common LISP \"special\"\n     variables.\n\n     A SPECIAL declaration at \"top level\" causes the affected variable\n     bindings to be treated as SPECIAL everywhere they are found.\n\n     A SPECIAL declaration within a form affects only those bindings\n     done specifically by that form, unless the variables referenced\n     are not bound in that form, in which case the declaration\n     applies to references in the body of that form.  The actual\n     details of how SPECIAL declarations work are quite involved.\n     For the complete story, read the discussion in Steele's\n     \"Common LISP: The Language\" in the section on declarations.\n\n\n At top level, the recognized DECLARE clauses are:\n\n   (SPECIAL &rest vars) - this clause tells the compiler that the\n     variables (symbols) named herein are to be compiled as \"free\"\n     variables as for DECLARE inside a function.  The difference\n     is that a top-level DECLARE SPECIAL causes ALL references to\n     those variables in the file to be compiled as \"free\" variables.\n     Under the interpreter, this declaration affects all future\n     bindings of the variables affected.  This may produce unwanted\n     results, so use top-level DECLARE under the interpreter with\n     EXTREME CAUTION.\n\n   (SEGMENT (func num) (func num) ...) tells the compiler to \"segment\"\n     the body of function \"func\" into \"num\" parts.  The value of \"num\"\n     must be an integer greater than zero.\n\n     Segmenting is a way of solving the problem of compiling a function\n     whose generated code would contain more than 16K of addressable\n     code and data.\n\n     When you specify, for example,\n\n      (DECLARE (SEGMENT (FOO 8)))\n\n     the compiler will automatically take the body of FOO and attempt\n     to split it up into 8 segments of approximately equal size.  In\n     fact, the number of segments may be different; the compiler tries\n     to compute the size of each segment by dividing the total length\n     of the function body by the requested segment count.\n\n     When the compiler segments a function, it first \"flattens out\"\n     the function body by fully macroexpanding it, splicing the\n     contents of imbedded PROGN's into the function body, and\n     discarding all atoms or constant forms except for the last\n     form, which is the one that would be returned as a value.\n     It then uses the number of forms in the body as the basis for\n     determining how to segment it.\n\n     After segmentation, the original function body is, in effect,\n     replaced by a body which contains n calls to internally\n     generated functions of no arguments (where n is less than or\n     equal to the requested segment count).  The internally generated\n     functions have names like |<function-name SEGMENT n|.\n     If the segment count is greater than or equal to the length of\n     the function body, then one segment is generated for each form\n     in the body.\n\n     You should choose the number of segments in such a way as to\n     guarantee that the size of each segment will be within the 16K\n     limit, so that the generated code for each will compile\n     successfully.\n\n     The function being segmented should have a null argument list.\n     Otherwise, the variables in the argument list will become \"free\"\n     variables in the segmented function code, and (even though they are\n     lexically in the correct place) will generate overhead of creating\n     non-local bindings.  The compiler will warn you when you segment a\n     function with a non-null argument list.\n\n     You should not use segmentation unless absolutely necessary,\n     because of the additional function call overhead that result.\n\n     Segmentation is particularly useful when compiling a MODULE, which\n     may have a huge number of forms.  To use segmentation when\n     compiling module FROB, for example, specify:\n\n       (DECLARE (SEGMENT (FROB n)))\n\n     Even though there is no explicit definition of FROB in the MODULE\n     (in fact, an explicit definition would be illegal!), the compiler\n     will segment the top-level surrounding function it builds to\n     effect the loading of the code in the module.\n\n\n   (NOCOMPILE funcspec ...) tells the compiler that the function\n     represented by \"funcspec\" is to be loaded interpretively rather\n     than compiled.\n\n     Currently this is applicable only to definitions that occur in\n     a file being compiled as a MODULE.\n\n     One or more \"funcspec\"'s may be coded; each is either a symbol\n     which is defined as a function name somewhere in the file being\n     compiled, or a list (function-name function-property) such as\n     can occur in a definition of the form (DEFUN (FOO BAR) ...).\n\n     You may need this if the function in question contains code\n     that the compiler doesn't like but works fine interpreted.\n\n     Warning: If the function refers to \"free\" variables that are\n              bound in other (compiled) functions but are not\n              declared \"special\", they may wind up undefined when\n              the uncompiled code is called.\n\n\n    (DEFAULT-BINDING ...)\n     specifies what the compiler is to do with a \"free\" variable\n     reference that has not been subject to a declaration.  The\n     default is (DEFAULT-BINDING SPECIAL), which means that the\n     compiler assumes (like the interpreter in a similar situation)\n     that the variable was meant to be SPECIAL, and is compiled\n     thus.  It does not affect references to the variable in\n     other environments.  You could specify (DEFAULT-BINDING NIL)\n     to tell the compiler to treat such variable references as\n     errors that terminate the compilation.\n\n\n   (PDSIZE value) - valid for PROGRAM's only, this specifies the\n     size of the push down stack to be allocated at initialization.\n     This value may be specified as a fixnum or a value in the\n     format nnnK or nnnM.  The default value is 65536 (64K).\n\n     This space is allocated above 16 megabytes if possible.\n\n\n   (CSSIZE value) - valid for PROGRAM's only, this specifies the total\n     size of the CONS space to be allocated at initialization time.  If\n     this is omitted, the default value of 4 megabytes (4096K) is used.\n\n     Lists (conses), fixnums, single-floats, and the header portions\n     of executable objects are allocated in this space.\n\n     This value represents the TOTAL allocation, not to be confused\n     with the initial ACTIVE size of the space - see ACSIZE below.\n\n     This space is allocated above 16 megabytes if possible.\n\n   (ACSIZE value) - valid for PROGRAM's only, this specifies the size of\n     the CONS space to be considered active initially.  If this is\n     omitted, the default value of 2 megabytes (2048K) is used.\n\n     This value controls how much of the total CONS space (as specified\n     by CSSIZE) is in use, until it is determined (by the garbage\n     collector) that more space is needed, at which time the ACSIZE\n     value is doubled, provided that it does not exceed the CSSIZE\n     value.  Thus, this is the only one of the values described here\n     that can change during execution.\n\n   (VSSIZE value) - valid for PROGRAM's only, this specifies the size of\n     vector/string space (the space used to build symbols, vectors,\n     strings, double-floats, bignums and structures) to be allocated at\n     initialization time.  If this is omitted, the default value of\n     1024K is used.\n\n     Note that this space is allocated in duplicate, due to the copying\n     garbage collection scheme used for this space in ZIL.  Thus in\n     actuality twice the specified virtual storage is required.\n\n     This space is allocated above 16 megabytes if possible.\n\n\n   (OSSIZE value) - This is no longer supported.  Valid for PROGRAM's\n     only, this used to specify the size of memory to be reserved for\n     the operating system at initialization time (i.e. NOT allocated to\n     ZIL).  However, since ZIL now uses memory above the 16-megabyte\n     line, it is not necessary to reserve room for OS functions as much\n     as before.\n\n The following declarations are no longer present in ZIL 1.3:\n\n     AUTOFUNCALL - all ZIL 1.3 code is compiled as if (AUTOFUNCALL T)\n                   were specified.\n     AUTOSPECIAL - all ZIL 1.3 code is compiled as if (AUTOSPECIAL T)\n                   were specified.\n     BASEREG     - the ZIL 1.3 compiler determines the correct\n                   generation of code for functions up to 16K bytes\n                   in length.  Beyond that, the compilation will\n                   terminate with an error message, and you will\n                   have to use segmentation (see above) to get your\n                   function to compile.\n\nErrors signaled:\n\n Invalid DECLARE clause (not a proper list).\n Misplaced DECLARE clause (found within a function in a place where\n its value would be used if it were evaluated).\n Miscellaneous errors within DECLARE clauses (for example, object\n other than a symbol found in a SPECIAL clause).\n\nNotes:\n\nExamples:\n\n  (defun foo (x y z)\n   (declare (special x y))\n   (bar x y z))\n\n  (declare (cssize 8M) (vssize 256K))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFARGS": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x170\\x00K\\x00K\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:30:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DEFARGS\n\nSyntax:   (DEFARGS fun1 minargs2 &optional maxargs3 restarg4)\n\n fun1     (required, not evaluated) - a symbol.\n minargs2 (required, not evaluated) - an integer or NIL.\n maxargs3 (optional, not evaluated) - an integer.\n restarg4 (optional, not evaluated) - T or NIL.\n\nReturns:\n\n Who knows?\n\nProcessing:\n\n This does nothing under the interpreter.  But it tells the compiler\n about a function that you are invoking but are not defining in your\n code (i.e. an external user function).\n\n Normally, when the compiler finds a call to a function that is not\n defined in your code, and it is not a \"standard\" ZIL function as can\n be found in this documentation, the compiler converts the call to a\n FUNCALL, which will interpretively apply the function symbol to the\n specified arguments.  This enables compiled code to call interpreted\n code without having to explicitly code FUNCALL's.\n\n However, if you know that the function exists as a compiled SUBR and\n you want to tell the compiler about it (so that it can generate a\n direct branch to the code), you can use DEFARGS.  For example:\n\n   (DEFARGS SOMEFUNC 1 2)\n\n tells the compiler that there is a function called SOMEFUNC\n with a definition something like:\n\n   (DEFUN SOMEFUNC (A &OPTIONAL B) ...)\n\n So, if the compiler finds a function call like\n\n   (DEFUN PIG (A B) (CONS (SOMEFUNC A) B))\n\n it is to treat SOMEFUNC as an EXPR (actually a SUBR since it will be\n a compiled load module in a link library) with at least 1 and at\n most 2 arguments required (any arguments omitted will be passed as\n unsupplied optional arguments and will be bound to their default\n values at execution time).  Note that the function name must conform\n to IBM naming standards since it will become an external reference\n (i.e.  1-8 alphameric characters, first one alphabetic or national).\n\n To tell the compiler that SOMEFUNC has a &REST argument, if it\n was defined externally with a &REST keyword in its lambda list,\n or if it has &KEY keywords in its lambda list,\n specify T as the fourth argument.  Here are some examples:\n\n   (DEFARGS SOMEFUNC 2 5)   ; 2 required,  3 optional, no &rest\n   (DEFARGS SOMEFUNC 2 2)   ; 2 required, no optional, no &rest\n   (DEFARGS SOMEFUNC 2 5 T) ; 2 required,  3 optional,  1 &rest\n   (DEFARGS SOMEFUNC 2 2 T) ; 2 required, no optional,  1 &rest\n\n You can also use this format:\n\n       (DEFARGS funcname NIL)\n\n This will make the compiler \"not know about\" funcname.  Any\n calls to funcname will be compiled as FUNCALLs.\n\n See member $COMPILE for more details about how to use this.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFFLIC": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x864_\\x00\\x87$o\"U\\x00]\\x00[\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-12-11T00:00:00", "modifydate": "1987-09-03T22:55:00", "lines": 93, "newlines": 91, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DEFFLIC\n\nSyntax:   (DEFFLIC arg1 arg2 &optional arg3 arg4)\n\n arg1 (required, not evaluated) - a function name.\n arg2 (required, not evaluated) - a data set name.\n arg3 (optional, not evaluated) - any LISP object, generally T or NIL.\n arg4 (optional, not evaluated) - any LISP object, generally T or NIL.\n\nReturns:\n\n arg1, after building a function definition for it that evaluates all\n the forms contained in file arg2.\n\nProcessing:\n\n DEFFLIC generates a \"Fast Loading Interpreted Code\" file, i.e. a\n compiled load module containing interpretive forms.\n\n DEFFLIC is a macro that expands into a DEFUN, which defines arg1 as a\n function that evaluates a list of forms; this list of forms is\n essentially identical to the forms found in the data set specified by\n arg2.  The effect is as follows:\n\n Given a function FOO generated by:\n\n  (DEFFLIC FOO \"MY.LISP(STUFF)\")\n\n when the function (FOO) is invoked inside the ZIL interpreter, code\n is executed to evaluate all the forms that appeared in MY.LISP(STUFF).\n However, these forms are not being read in from that file; rather,\n the forms exist as an in-line compiled list contained within the\n function definition of FOO.\n\n The forms themselves are not compiled.  To generate a load module that\n loads a file in compiled format, compile the file as a MODULE.\n\n Description of the optional args to DEFFLIC:\n\n  If arg3 is specified and non-NIL, then the forms are macroexpanded\n  before they are added to the function; the default is to add them\n  as is without macroexpanding them.\n\n  If arg4 is specified and non-NIL, code is added to the function to\n  print out the values of the forms as they are evaluated when the\n  function is executed; this is a debugging capability.\n\n The funcation generated by DEFFLIC has 2 optional args, as follows:\n\n  (functionname &optional arg1 arg2)\n\n  If arg1 is specified when the function is invoked, then\n  the result of evaluating each form is printed (i.e. a read-eval-print\n  loop is executed rather than just a read-eval loop).\n\n  If arg2 is specified when the function is invoked, then\n  each form itself is printed before evaluation is attempted on it.\n\n  As you might imagine, DEFFLIC is primarily for use with the compiler;\n  in general, you would compile a ZIL source member FOO which contained\n  ONLY the DEFFLIC form pointing to another data set which contained\n  the actual forms to be evaluated.\n\nErrors signalled:\n\n Too few arguments.\n\nNotes:\n\n \"FLIC\" stands for \"Fast Loading Interpreted Code.\"\n DEFFLIC can be used to load interpretive DEFUN's et al. in a compiled\n form that bypasses the overhead associated with READ.  It is especially\n useful if the original file contained lots of read-time evaluation,\n conditionals, reader macros, etc.\n\n You may have to use DEFFLIC to create a compiled version of a module to\n be loaded if it is brought in by the compiler to define macros, for\n example.  Normal compilation of a file with macro definitions does not\n make them available to the requestor when the compiled file is\n executed.  The need for DEFFLIC is based, also, on the fact that on\n occasion there may be certain features of DEFUN that the ZIL compiler\n still does not support, preventing these kinds of function definitions\n from being compiled successfully.  But (DECLARE (NOCOMPILE ...))\n should handle these increasingly rare cases (there should be no such\n cases ideally!).\n\n\n DEFFLIC replaces DEFFASL, which is now obsolete.  The functionality\n is the same (except that the messages issued by DEFFLIC may be\n suppressed via (MSGLEVEL 2)), but the name more accurately describes\n the contents and usage.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFLOAD": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o#\\x00\\x00R\\x00Q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T23:00:00", "lines": 82, "newlines": 81, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: DEFLOAD\n\nSyntax:   (DEFLOAD fun1 sym2)\n\n fun1 (required, not evaluated) - a symbol naming a function.\n sym2 (required, not evaluated) - a valid IBM-style symbol\n                                  (8 characters or less, alphanumeric).\n\nReturns:\n\n fun1, after associating with it the IBM-style external name specified\n by sym2.\n\nProcessing:\n\n Under the interpreter, DEFLOAD places sym2 on the AUTOLOAD property of\n fun1.  When the interpreter attempts to resolve fun1 as a function call\n (i.e.  when it is the CAR of a form being evaluated or is the first\n argument of APPLY), the AUTOLOAD property value is used, if present,\n to pass to ZILLOAD, who searches for the name on the system library.\n (If there is no AUTOLOAD property, fun1 is used.)\n\n Any existing function definitions on fun1's property list are removed\n when DEFLOAD is issued.  Specifying NIL for sym2 is equivalent to\n removing the AUTOLOAD property, or making fun1 be its own external\n name.\n\n Under the compiler, DEFLOAD associates a given function name fun1 with\n an external name sym2, which is used as follows:\n\n If code to call fun1 function is compiled, and fun1 is not defined in\n the source file, the external name (V-con) generated by the compiler is\n sym2.\n\n If fun1 is defined in the source file, the internal name assigned to it\n is sym2.  This is irrelevant EXCEPT when fun1 is intended to be the\n main function of the file but the source file name is sym2, and is a\n way of creating a function which must be loaded via an IBM-style name\n but whose true name is longer.  For example, assume source file FOO is\n being compiled; normally you would have to have\n\n  (DEFUN FOO ...)\n\n somewhere in the file.  But you could also have this:\n\n  (DEFUN FOO-BAR-BAZ ...)\n\n along with\n\n  (DEFLOAD FOO-BAR-BAZ FOO)\n\n which tells the compiler that FOO-BAR-BAZ will be known externally\n as FOO, and is the main function of the source file.\n\n\nErrors signalled:\n\n Invalid syntax (too few arguments, or args not both symbols).\n\nNotes:\n\n sym2 must conform to IBM requirements for member names (8 characters or\n less, all alphanumeric, first character not alphabetic).  In addition,\n under the compiler, symbols beginning with the # character or the\n prefix ZLC are reserved, since they would generate conflicts with\n compiler-generated labels.\n\n If sym2 does not conform to this standard, and sym2 has been made a\n \"known\" function via DEFARGS, the compiler will substitute a GENSYM\n symbol for the external name and report an error.  Under the\n interpreter, function loading will fail.\n\n Note carefully that DEFLOAD does NOT simply equate one function with\n another; it will result in a compiled code object being assigned ONLY.\n\nExamples:\n\n (DEFLOAD INTERSECTION INTERSEC)\n\n (DEFLOAD HAIRY-FUNCTION-NAME HFNAME)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFMACRO": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o#\\x18\\x00k\\x00j\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T23:18:00", "lines": 107, "newlines": 106, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DEFMACRO\n\nSyntax:   (DEFMACRO macro1 arglist2 &rest forms)\n\n macro1   (required, not evaluated) - a non-null symbol.\n arglist2 (required, not evaluated) - a lambda list.\n form     (not evaluated) - an atom or proper list.\n\nReturns:\n\n macro1, after establishing a macro definition for it in the current\n environment.\n\nProcessing:\n\n DEFMACRO is a macro that expands into a DEFUN that defines a macro.\n The syntax is as follows:\n\n  (DEFMACRO macro-name (arg1 arg2 ... argn) form1 form2 ... formn)\n\n where:\n\n  macro-name is the name of the macro being defined\n  argn's     are symbols to be bound to the corresponding arguments\n             on the macro call\n  formn's    are forms to be evaluated when the macro is expanded,\n             the last returning the macro expansion.\n\n For example, (DEFMACRO FOO (A B) `(CONS ,B ,A))\n\n is basically equivalent to:\n\n              (DEFUN FOO MACRO (X) `(CONS ,(CADDR X) ,(CADR X)))\n\n except that the macro definition generated by DEFMACRO insures that\n the number of passed arguments is correct.\n\n DEFMACRO should be used to define macros when there must be a specific\n number of arguments on the macro call, including none.\n\n The &OPTIONAL and &REST keywords may be used as well, in the same way\n as they are used on the LAMBDA list of a function, for macros which\n accept a variable number of arguments.  In addition, destructuring of\n arguments is allowed, and default values and \"supplied-p\" variables for\n &OPTIONAL args are available.\n\n The single argument which is bound to the macro call is not accessible\n when DEFMACRO is used; if you wish to access this, you must use DEFUN\n to define your macro.\n\n In the interpretive environment, DEFMACRO places a LAMBDA-expression\n on the MACRO property of the symbol specified by the first argument.\n Some examples should illustrate:\n\n  (DEFMACRO FOO (A B) (PRINT 'HI) (LIST 'CONS B A))\n\n makes a list functionally similar to\n\n (LAMBDA (G00001)\n         (PRINT 'HI) (LIST 'CONS (CADDR G00001) (CADR G00001)))\n\n the value of FOO's MACRO property.\n\n Note that in a compiled program or function, DEFMACRO does not\n generate executable code to define the macro a la interpretive\n mode, but causes a macro to be made available to the compiler.\n For that reason, it can occur only at top level in compiled code.\n\n The use of NIL as the macro name is invalid.\n\nErrors signalled:\n\n Invalid syntax (too few arguments, or invalid argument list).\n Errors detected by DEFUN (q.v.).\n\n The following errors are detected at macro call time by a macro\n created by DEFMACRO:\n\n  Too few or too many arguments specified on macro call\n  Invalid argument list syntax (misplaced &OPTIONAL or &REST)\n\nNotes:\n\n To cause a macro to become defined at run time in a compiled program or\n function, it is necessary to use XDEFUN, XDEFMACRO or PUTPROP to place\n the function body (LAMBDA and all) on the symbol's property list under\n the MACRO property.  DEFMACRO's not at top level are not compilable.\n\n The Common LISP \"destructuring\" feature is supported in the\n argument list of DEFMACRO.  &OPTIONAL and &REST are supported as well.\n However, &WHOLE and &ENV are not supported at this time.\n\nExamples:\n\n (DEFMACRO FIRST (A) (LIST 'CAR A))\n\n   is equivalent to\n\n (DEFUN FIRST MACRO (X) (LIST 'CAR (CADR X)))\n\n  and defines a function that returns the CAR of its one argument.\n\n (FIRST '(1 2 3))   ==>  1\n (FIRST)            signals a \"too few arguments\" error.\n (FIRST A B)        signals a \"too many arguments\" error.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFMOD": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x07\\x0f\\x00\\x87$o#@\\x00\\xd2\\x00\\xbf\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-03-11T00:00:00", "modifydate": "1987-09-03T23:40:00", "lines": 210, "newlines": 191, "modlines": 0, "user": "SEB1525"}, "text": "\n**********************************************************************\n*                                                                    *\n* This function is obsolete.  Use INCLUDE while compiling a MODULE.  *\n*                                                                    *\n**********************************************************************\n\n\nMacro: DEFMODULE\n\nSyntax:   (DEFMODULE arg1 arg2 &optional arg3)\n\n arg1 (required, not evaluated) - a function name.\n arg2 (required, not evaluated) - a data set name.\n arg3 (optional, not evaluated) - any LISP object, generally T or NIL.\n\nReturns:\n\n arg1, after building a function definition for it that loads all the\n compiled forms contained in file arg2.\n\nProcessing:\n\n DEFMODULE compiles a file into a load module that may be invoked under\n the interpreter to bring in all the code from the file in compiled\n format, including function definitions.\n\n DEFMODULE is a macro that expands into a list of forms bracketed by\n a PROGN; the forms are taken from the file and processed as follows:\n\n Given a function FOO generated by:\n\n  (DEFMODULE FOO \"MY.LISP(STUFF)\")\n\n a compilable function is built that, when executed by typing (foo)\n under the interpreter, does the operations generally expected by\n implementations of compiled modules created by, say, a COMPILE-FILE\n call in other LISP systems.\n When the function (FOO) is invoked inside the ZIL interpreter, code is\n executed to load all the compiled function definitions and other forms\n that appeared in MY.LISP(STUFF).  Each form from that file is\n processed by the compiler as follows:\n\n If the form is a macro call, the macro expansion is processed.\n This includes forms for which DEFMACRO's or DEFUN's that define\n the macro expansions are included in the file itself, as long as\n such definitions precede the macro calls.\n\n If the form is a DEFUN, then the function definition is compiled\n (where possible) and assigned at load time to the symbol naming\n the function, as follows:\n\n (DEFUN f arglist ...)\n or\n (DEFUN f EXPR ...)    places the compiled definition of f on the\n                       SUBR property of f, insuring that no conflicting\n                       function definitions are present.\n\n (DEFUN f MACRO ...)   (or DEFMACRO) makes the macro known in the\n                       compiler environment.  The macro is not\n                       made known at load time, however.\n\n (DEFUN f FEXPR ...)   places the interpretive definition of f on the\n                       FEXPR property of f, after a warning is issued\n                       that FEXPR's cannot be compiled.\n                       In addition, creates an equivalent macro\n                       definition which is used internally in case there\n                       are any calls to the FEXPR in the code.\n\n (DEFUN f x ...)       (i.e. a non-null atomic arglist) places the\n                       interpretive definition of f on the EXPR\n                       property of f, after a warning is issued that\n                       LEXPR's cannot be compiled.\n\n (DEFUN (f p) ...)     places the compiled definition on the \"p\"\n                       property of the symbol F.  Note that this is\n                       the only way that a file containing such a\n                       function definition can be compiled.\n\n If the function f has been declared non-compilable by means of a\n declaration of the form (DECLARE (NOCOMPILE f ...)) or\n (DECLARE (NOCOMPILE (f p) ... )) - the latter being intended for\n the (DEFUN (f p) ...) definition type - the interpretive definition\n of the function will be placed on the appropriate property.\n\n Note: In cases where a compiled function definition is generated,\n       the definition is assigned as a compiled SUBR; this is similar to\n       the case where a function is autoloaded after having been\n       compiled as a function.  This means that the code will be\n       executed in the variable binding environment active when the\n       function is evaluated (executed).  Thus, dynamic scoping is the\n       normal behavior for compiled functions loaded in this manner.\n\n If the form is a DEFVAR or a DEFLOAD, the usual compiler processing\n is done for it, and a call to DEFVAR or DEFLOAD is added to the\n module to be executed at load time.\n\n If the form is a DECLARE, the usual compiler processing is done.\n\n If the form is an EVAL-WHEN, the forms within are processed thusly:\n\n  EVAL-WHEN (COMPILE) - forms are evaluated by the compiler itself.\n  EVAL-WHEN (LOAD)    - forms are processed as being described now.\n  EVAL-WHEN (EVAL)    - ignored.\n\n If the form is a PROGN, the forms within are processed as being\n described now.\n\n If the form is anything else, it is added to the generated module\n to be executed at load time.\n\n The generated module is a function with no arguments.\n\n Description of the optional args to DEFMODULE:\n\n  If arg3 is specified and non-NIL, the values of the forms as they are\n  generated are printed on the standard output file during expansion\n  (i.e. compilation); this is a debugging capability.\n\n  As you might imagine, DEFMODULE is primarily for use with the\n  compiler; in general, you would compile a ZIL source member FOO which\n  contained ONLY the DEFMODULE form pointing to another data set which\n  contained the actual forms to be compiled.\n\nErrors signalled:\n\n Too few arguments.\n\nNotes:\n\n The function generated by compiling a source file containing a\n DEFMODULE call is quite useful as an AUTOLOAD property on the\n functions that are contained within - e.g.:\n\n  (defprop foo (loadfoo) autoload)\n  (defprop bar (loadfoo) autoload)\n\n If LOADFOO is a module created by compiling a file containing:\n\n  (defmodule loadfoo \"some.file\")\n\n and \"some.file\" is a data set containing DEFUN's for foo and bar,\n then this is a convenient way of autoloading the definitions of\n foo and bar.\n\n Compare DEFFLIC, which also produces a load module but does not\n compile any of the forms; rather, it causes them to be evaluated\n interpretively at load time.\n\nExamples:\n\n\n If we encounter the form:\n\n  (defmodule zmfoo \"my.lisp(foo)\")\n\n and the file MY.LISP(FOO) looks like this...\n\n  (defun foo1 (x) (blah1))        ;    1\n  (defun (baz frob) (y) (hair))   ;    2\n  (defmacro mac (x) `(frob ,x))   ;    3\n  (mac \"junk\")                    ;    4\n  (some random form)              ;    5\n  (defvar pi 3.1415926)           ;    6\n  (defload frobnicate frobozz)    ;    7\n  (eval-when (compile)\n   (print \"hello world\"))         ;    8\n  (eval-when (load)\n   (frob))                        ;    9\n  (eval-when (eval)\n   (eccch))                       ;   10\n\n then the resulting form will be (more or less):\n\n  (progn\n   (defun zmfoo ()\n     (zevdsub 'foo1 (subr foo1))                 ; 1 - assign SUBR prop\n     (putprop 'baz (subr (lambda (y) (hair))) 'frob)  ; 2\n     (frob \"junk\")                               ; 4 - expanded MAC\n     (some random form)                          ; 5\n     (xdefvar pi 3.1415926)                      ; 6\n     (xdefload frobnicate frobozz)               ; 7\n     (frob)                                      ; 9\n   )\n   (defun foo1 (x) (blah1))                      ; 1\n   (defun mac macro (nil x) `(frob ,x))          ; 2 - expanded DEFMACRO\n   (defvar pi 3.1415926)                         ; 6\n   (defload frobnicate frobozz)                  ; 7\n   (eval-when (compile)\n    (print \"hello world\"))                       ; 8\n  )\n\n  Then if you type (zmfoo) under the interpreter, the following will\n  occur:\n   FOO1 will be defined as a SUBR (compiled EXPR) - dynamically scoped.\n   BAZ will have a compiled SUBR on its FROB property.\n   The FROB and SOME functions (whatever they are) will be executed.\n   PI will be created as a globally bound variable with a value.\n   FROBNICATE will be assigned FROBOZZ as its AUTOLOAD property.\n\n  While this is being compiled, \"hello world\" will appear on the\n  compiler's standard output file.\n\n  Note that (9) is ignored - (eval-when (eval)) forms are always ignored\n  at compile time.\n\n  Note that function code is compiled with names where desirable and\n  that is why sometimes (subr name) and sometimes (subr (lambda...)) is\n  generated.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFPROP": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x17#\\x00!\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:23:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DEFPROP\n\nSyntax:   (DEFPROP arg1 arg2 arg3)\n\n arg1 (required, not evaluated) - a symbol.\n arg2 (required, not evaluated) - any LISP object.\n arg3 (required, not evaluated) - any LISP object, generally a symbol.\n\nReturns:\n\n arg2, after it has been made the value of the property specified by\n arg3 on the property list of the atom specified by arg1.\n\nProcessing:\n\n (DEFPROP x y z) is identical to (PUTPROP 'x 'y 'z).\n\n See PUTPROP.\n\nErrors signaled:\n\n Property list errors (see member $PROP).\n\nNotes:\n\n See member $PROP for information about property lists.\n\nExamples:\n\n (DEFPROP A B C)        ==> B\n (GET 'A 'C)            ==> B\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFRDMAC": {"ttr": 2833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x88\\x17\\x9f\\x088\\x00T\\x00M\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1988-06-27T08:38:00", "lines": 84, "newlines": 77, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DEFRDMAC\n\nSyntax:   (DEFRDMAC char1 fun2)\n\n char1 (required, evaluated) - a one-character symbol, string or fixnum.\n fun2  (required, evaluated) - an object suitable for processing as a\n                               function by APPLY.\n\nReturns:\n\n char1, after assigning the function specified by fun2 to the character\n specified by char1 as a reader macro.\n\nProcessing:\n\n The RDRMACRO function is invoked to associate the character specified\n by char1 with the compiled code SUBR for the ZRMAPPLY function; this\n function searches the atom *READERMACRO* for a property whose indicator\n is this character, the value being the function of one argument to be\n applied.  fun2 is placed on the property list of the atom *READERMACRO*\n in this way, so that ZRMAPPLY will APPLY it.\n\n The function is applied in the environment active at the time the\n READ function encounters the reader macro character.\n\n fun2 must specify a function that takes one argument; this argument is\n bound to the file name currently in use by READ when it invokes the\n reader macro.  This enables the reader macro code to access data from\n the file being read, via functions like READ, READCH and PEEKCH.\n\n If the code needs to access the reader macro character as an atom,\n the RMCHAR function will do this.\n\n If the function wishes to return \"nothing\" to the reader (i.e. have\n the reader continue reading with the next S-expression),\n it may return zero values (e.g. via the form (VALUES)), or\n the RMNIL function will do this.\n\n The function is typically a symbol, a funarg (created by the FUNCTION\n special form), or a LAMBDA or LABEL expression (see APPLY for more\n information).\n\nErrors signaled:\n\n Errors encountered by RDRMACRO (q.v.).\n\nNotes:\n\n See documentation on READ, RDRMACRO and RMCHAR for more information\n on reader macro processing.\n\n Reader macro definitions for the following characters are predefined:\n\n ' (single quote)\n ` (backquote)\n , (comma)\n # (sharp sign)\n\n See member $RMACRO in this documentation for details on these.\n\nExamples:\n\n Assume a reader macro defined thus:\n\n   (DEFRDMAC '|?| '(LAMBDA (X) (LIST (RMCHAR) (READ X))))\n\n Then, when the following is read in:\n\n   ?FOO\n\n the following will be returned by READ:\n\n   (? FOO)\n\n (Note that under the interpreter, this will be evaluated by EVAL\n before the user sees the result.)\n\n The following are equivalent:\n\n  (DEFRDMAC '|?| #'MYQRFUN)\n  (DEFRDMAC \"?\"  #'MYQRFUN)\n  (DEFRDMAC #\\?  #'MYQRFUN)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFSTRUC": {"ttr": 2835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87&\\x1f\\x00\\x88\\x19\\x7f\\x08&\\x00p\\x00Z\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1988-07-15T08:26:00", "lines": 112, "newlines": 90, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DEFSTRUCT\n\nSyntax:   (DEFSTRUCT type1 &rest args)\n\n type1 (required, not evaluated) - a symbol.\n arg (optional) - see description below.\n\nReturns:\n\n type1, after defining a type of structure by that name.\n\nProcessing:\n\n DEFSTRUCT is a Lisp way of creating new data structures (essentially\n new data types).  When DEFSTRUCT is issued, a series of macro\n definitions are created which define ways of creating an object\n (structure) of the specified type, of accessing slots in that\n structure, of updating slots in that structure, and of testing\n whether a given Lisp object is of that type.\n\n As an illustration, consider this definition:\n\n  (DEFSTRUCT KONS KAR KDR)\n\n This form defines a type of object called a KONS, which consists of\n two slots, called KAR and KDR.  The following macros are defined\n when this DEFSTRUCT is executed:\n\n  (MAKE-KONS &key KAR KDR)\n\n   creates an object of type KONS, for which you can optionally\n   specify initial values for the KAR and KDR slots.  For Maclisp\n   compatibility, the \"keywords\" may be specified with or without\n   leading colons - thus the syntax is not true &key syntax in the\n   strict sense.\n\n  (COPY-KONS object &key KAR KDR)\n\n   makes a copy of an object of type KONS, for which you can optionally\n   specify new values for the KAR and KDR slots.  For Maclisp\n   compatibility, the \"keywords\" may be specified with or without\n   leading colons - thus the syntax is not true &key syntax in the\n   strict sense.\n\n  (KONS-P arg1)\n\n   returns T if arg1 is a KONS, and NIL otherwise.\n\n  (KONS-KAR kons1)\n\n   returns the value of the KAR slot of the KONS specified by kons1.\n\n  (KONS-KDR kons1)\n\n   returns the value of the KDR slot of the KONS specified by kons1.\n\n  (SETF (KONS-KAR kons1) val2)\n\n   sets the value of the KAR slot of KONS kons1 to val2.\n\n  (SETF (KONS-KDR kons1) val2)\n\n   sets the value of the KDR slot of KONS kons1 to val2.\n\n Although DEFSTRUCT defines objects that are structures by default, it\n may also be used to define objects as trees (i.e. conses) or\n Maclisp-style arrays.  There are many options; consult the Common Lisp\n or Maclisp manual for full details.  Not all of those options are\n currently implemented in Zil, however.\n\n The full available syntax of DEFSTRUCT is something like this:\n\n  Minimal syntax: (DEFSTRUCT struct-name slot1 slot2 slot3 ... )\n\n  Maximal syntax:\n\n   (DEFSTRUCT\n     struct-name | (struct-name\n                    {ARRAY | TREE}\n                    {CONC-NAME   | (CONC-NAME   {NIL | name})}\n                    {CONSTRUCTOR | (CONSTRUCTOR {NIL | name} {arglist})}\n                    {COPIER      | (COPIER      {NIL | name})}\n                    {(EVAL-WHEN ({COMPILE} {LOAD} {EVAL}))}\n                   )\n     {slot | (slot {default-value})}*\n   )\n\n The default for the EVAL-WHEN specification is (COMPILE EVAL).\n\n The symbols capitalized above (not including DEFSTRUCT, NIL, or values\n inside EVAL-WHEN) may optionally be prefixed with a colon.  E.g.,\n COPIER or :COPIER may be specified.\n\n Again, for more details, consult a Common Lisp or Maclisp manual.\n\n See STRUCTUR for more information about structures.\n\nErrors signaled:\n\n Lots of syntax errors.\n\nNotes:\n\n DEFSTRUCT itself does NOT allocate any objects; it merely defines the\n operations that you would use to create and manipulate them.  It does\n this inside an EVAL-WHEN so that it can be used freely in both compiled\n and interpreted code.\n\n (TYPEP object type) will return T for \"object\" created by DEFSTRUCT of\n a type name \"type\", unless the ARRAY or TREE option was specified.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFTRANS": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x17Y\\x00q\\x00q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:59:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DEFTRANS\n\nSyntax:   (DEFTRANS fun1 fun2)\n\n fun1     (required, not evaluated) - a symbol that names a function.\n fun2     (required, not evaluated) - a symbol that names a function.\n\n    or:   (DEFTRANS fun1 arglist2 &rest forms)\n\n fun1     (required, not evaluated) - a symbol that names a function.\n arglist2 (required, not evaluated) - a list of either 1 or 3 symbols.\n form     (optional, not evaluated) - any LISP objects.\n\nReturns:\n\n A compiler transform function for fun1.\n\nProcessing:\n\n DEFTRANS defines a compiler transform function.  The proper way to\n use this is in compiler input inside an (EVAL-WHEN (COMPILE) ... )\n form, since it assigns the symbol specified by fun1 the compiler\n transform function as the value of the COMPILER-TRANSFORM property.\n\n In the case of the (DEFTRANS fun1 fun2) syntax, the function named\n by fun2 becomes the compiler transform for fun1.\n\n In the case of the (DEFTRANS fun1 arglist2 &rest forms) syntax,\n a compiler transform function is constructed from arglist and forms\n as follows:\n\n  If arglist2 has 3 elements, the function is\n    (LAMBDA arglist2 . forms).\n\n  If arglist2 has 1 element, the function is\n    (LAMBDA (arg1 arg2 arg3) . forms), where arg1 is the single\n  element of arglist2, and arg2 and arg3 are generated symbols.\n\n A compiler transform is a function of 3 arguments which is invoked\n by the compiler during the phase in which it transforms function calls\n for the purpose of optimization.  The function ZILCOTRN may be used\n to try out the transformation.\n\n Transforming a form consists of the following steps:\n\n (1) Fully macroexpand the form (using MACROEXPAND).\n (2) If the result is an atom, do the appropriate processing\n     on the atom (if any).\n     If the result is a function call, transform each argument\n     to the function call via ZILCOTRN.\n     If the result is a special form, transform the arguments\n     (where appropriate) via ZILCOTRN.\n (3) If the CAR of the form is a LAMBDA expression,\n     transform the contents of the LAMBDA expression and\n     apply transformations associated with LAMBDA to the form.\n     If the CAR of the form is a symbol, and it has an\n     associated compiler transform function, apply that\n     function to the result of (2).\n     If the CAR of the form does not have an associated\n     compiler transform function, we are finished.\n (4) If the result of (3) is EQUAL to the result of (2),\n     we are finished.  Otherwise, repeat the process\n     from (1).\n\n A compiler transform function receives 3 arguments:\n\n (1) the complete form being transformed (the CAR being the\n     function name)\n (2) the \"environment\", in whatever form that may take\n (3) a list of keywords describing the context in which the\n     form is being evaluated.  If this list is null, the\n     form is being evaluated for effect only.  Possible\n     keywords that may be present include:\n\n       :value        will be used as a return value (or values)\n       :argument     will be used as an argument to a function\n       :setq         will be used to set a variable\n       :predicate    will be used in a test for NIL\n\n     ...and others...\n\n     More than one of the above keywords may be present.\n\n Note: As a special hack for callers of ZILCOTRN that wish to\n       pass a LAMBDA expression, ZILCOTRN (but not its lower-\n       level functions) will transform a LAMBDA-expression\n       as well as an evaluable form.\n\n The ZILCOTRN function takes 1 required argument - the form to\n be transformed - and 1 optional argument, which (if non-NIL)\n activates \"debug mode\" so that you can see each step of the\n transformation.  To get all the compiler's transformations\n into your interpretive session, execute (ZILCOINT) before\n using this function.\n\n The ZILCOCON function can be used in compiler transformations\n to see if a LISP object identifies a \"constant\" (i.e. is\n self-evaluating).  It returns NIL if not, and a CONS whose CAR\n is the value of the constant if it is (the CDR is reserved for\n future enhancements).\n\nErrors signaled:\n\n None.  Errors signalled during compiler transform function execution\n do not abort ZILCOTRN, but cause transformation to be nullified.\n In other words, the form will remain untransformed.\n\nNotes:\n\n Remember, you MUST enclose DEFTRANS inside (EVAL-WHEN (COMPILE) ...)\n for it to work in a compiled source code file.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFUN": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87(o\\x085\\x00[\\x00U\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-10-13T08:35:00", "lines": 91, "newlines": 85, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: DEFUN\n\nSyntax:   (DEFUN name1 {arg2} arglist3 &rest forms)\n\n name1    (required, not evaluated) - a symbol, or a list of 2 symbols.\n arg2     (optional, not evaluated) - EXPR, FEXPR, or MACRO.\n arglist3 (required, not evaluated) - a lambda list.\n form     (not evaluated) - an atom or proper list.\n\nReturns:\n\n name1 (or (car name1)), after establishing a function definition for it\n in the current environment.\n\nProcessing:\n\n See member $DEFUN for more details about defining functions.\n\n See member LAMBDA for information about the argument list.\n\n In the interpretive environment, DEFUN places a LAMBDA-expression on\n the property list of the symbol specified by name1.  arg2, when\n specified (i.e. atomic), is the name of the property thus assigned; the\n default property is EXPR.  Some examples should illustrate:\n\n  (DEFUN FOO (A B) (PRINT 'HI) (CONS B A))\n\n makes the list (LAMBDA (A B) (PRINT 'HI) (CONS B A))\n the value of FOO's EXPR property.\n\n  (DEFUN FOO MACRO (X) (CONS X NIL))\n\n makes the list (LAMBDA (X) (CONS X NIL))\n the value of FOO's MACRO property.\n\n The DEFUN function is the basic function-defining technique.\n Note that in a compiled program or function, it does not generate\n executable code to perform the DEFUN a la interpretive mode,\n but causes a compiled function to be created.  For that reason,\n it must occur at top level in compiled code.\n\n (DEFUN fun-name (arglist) (body))\n\n is equivalent to\n\n (DEFUN fun-name EXPR (arglist) (body))\n\n fun-name may not be NIL.\n\nErrors signalled:\n\n Invalid syntax (too few arguments, or missing function body).\n Function name not a symbol or list (symbol + property).\n Argument list not a list (may mean invalid function type).\n Unknown function type: not EXPR, FEXPR or MACRO.\n Wrong number of arguments for FEXPR (not 1 or 2) or MACRO (not 1).\n Attempt to define an FEXPR to the compiler.\n\nNotes:\n\n To cause a function to become defined at run time in a compiled program\n or function, it is necessary to use XDEFUN, XDEFMACRO or PUTPROP to\n place the function body (LAMBDA and all) on the symbol's property list.\n DEFUN's not at top level are not compilable.\n\n DEFUN sets the LOADFILE property of the symbol to the current value\n of the special variable *LOADFILE*, which is set by LOAD (for example)\n to the name of the file being loaded.\n\n DEFUN removes conflicting function definitions as follows:\n\n * Any SUBR property is removed.\n * If an EXPR is being defined, any existing MACRO property is removed.\n * If a FEXPR is being defined, any existing EXPR or MACRO property is\n   removed.\n\n This insures correct execution of the defined function according to the\n rules of evaluation (see member $EVAL of this document for more\n details).\n\nExamples:\n\n (DEFUN FIRST (X) (CAR X))\n\n (DEFUN FIRST FEXPR (X A) (CAR (EVAL (CAR X) A)))\n\n (DEFUN FIRST MACRO (X) (LIST 'CAR (CADR X)))\n\nall define a function that returns the CAR of its one argument.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFVAR": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x04O\\x00\\x87$o#C\\x00J\\x00F\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-02-13T00:00:00", "modifydate": "1987-09-03T23:43:00", "lines": 74, "newlines": 70, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: DEFVAR\n\nSyntax:   (DEFVAR var1 &optional val2 doc3)\n\n var1    (required, not evaluated) - a symbol.\n val2    (optional, conditionally evaluated) - any LISP form.\n doc3    (optional, not evaluated) - a string.\n\nReturns:\n\n var1, after it has been established as a global variable in the\n current LISP environment.\n\nProcessing:\n\n If val2 is not specified:\n\n If the variable specified by var1 is already currently bound, no action\n is taken and a warning message is issued; otherwise the variable is\n identified as a DEFVAR variable (this is done internally by creating a\n global binding for it with no value).  The variable does NOT become\n bound at this time.\n\n If val2 is specified:\n\n If the variable specified by var1 is already currently bound, no action\n is taken and a warning message is issued; otherwise the variable is\n added to the global binding environment and is assigned the value\n specified by evaluating val2.  If doc3 is present, it is considered to\n be a documentation string and is made the value of the DOCUMENTATION\n property of the symbol var1.\n\n var1 may not be NIL, T or a \"keyword\".\n\n DEFVAR is valid at top level only.  Bindings created by DEFVAR are\n always SPECIAL bindings.\n\n The compiler supports DEFVAR at top level only, and only when\n compiling a MODULE.  It is not permitted when compiling a FUNCTION.\n\nErrors signaled:\n\n Not at top level.\n Missing argument, or too many arguments.\n Invalid first argument (must be a non-null symbol).\n Invalid documentation argument (must be a string).\n\nNotes:\n\n DEFVAR may be issued more than once for the same variable name, but\n the value, if provided, is assigned only the first time, and then\n only if the variable is not bound yet.\n\n A DEFVAR variable may be subsequently assigned a new value via SETQ.\n As long as the SETQ is issued in an environment that does not have\n a shadowing dynamic binding for the same variable, the reassignment\n will affect that variable's global value.\n\nExamples:\n\n (DEFVAR FOO)         ==> FOO\n FOO                  ==> (\"***ERROR***\") ; Unbound variable error.\n (DEFVAR FOO NIL)     ==> FOO\n FOO                  ==> NIL\n (DEFVAR FOO 'BAR)    ==> FOO\n FOO                  ==> NIL   ; note that the value is not changed.\n (SETQ FOO 'BAZ)      ==> BAZ\n FOO                  ==> BAZ   ; SETQ has changed the value.\n (DEFVAR FROB 'NICK \"A variable set by DEFVAR.\")\n                      ==> FROB\n FROB                 ==> NICK\n (GET 'FROB 'DOCUMENTATION) ==> \"A variable set by DEFVAR.\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELETE": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o#D\\x00T\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T23:44:00", "lines": 84, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DELETE\n\nSyntax:   (DELETE arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of list2 except for those\n which are EQL to arg1.\n\nProcessing:\n\n list2 is destructively altered.  Each atom found within list2 that is\n EQL to arg1 is deleted from list2.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n Compare REMOVE, which is the non-destructive equivalent of DELETE.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by DELETE.\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n DELETE is, by default, implemented with an EQL test for Common LISP\n compatibility, using the ZIL function DELQL.  If Maclisp or Franz LISP\n compatibility is desired, DELETE may be equated with ZIL function\n DELQUAL via the DEFLOAD special form.  See DELQ, DELQL and DELQUAL for\n more info.\n\n Under Macsyma, DELETE performs an EQUAL test.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\n As with all the \"destructive\" functions, DELETE should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\n Do not depend upon DELETE's altering of list2 if the CAR of list2\n matches arg1.  Use SETQ to insure updating of list2, as follows:\n\n  (SETQ Y (DELETE X Y))\n\nExamples:\n\n (DELETE 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (DELETE '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO BAR) (FOO) FOO BAR) ; Test is EQL, not EQUAL.\n\n (DELETE 2 '(1 2 3 4 5)) ==> (1 3 4 5)        ; Test is EQL, not EQ.\n\n (DELETE 1 '(1 2 1 2 1) 0) ==> (1 2 1 2 1)\n (DELETE 1 '(1 2 1 2 1) 1) ==> (2 1 2 1)\n (DELETE 1 '(1 2 1 2 1) 2) ==> (2 2 1)\n (DELETE 1 '(1 2 1 2 1) 3) ==> (2 2)\n\n;The following shows how the list is altered by DELETE.\n\n (SETQ X '(A B C D E))       ==> (A B C D E)\n X                           ==> (A B C D E)\n (SETQ Y (DELETE 'A X))      ==> (B C D E)\n X                           ==> (A B C D E)\n Y                           ==> (B C D E)\n (EQ X Y)                    ==> NIL\n (SETQ Y (DELETE 'C X))      ==> (A B D E)\n X                           ==> (A B D E)\n Y                           ==> (A B D E)\n (EQ X Y)                    ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELQ": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$o#E\\x00O\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-03T23:45:00", "lines": 79, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DELQ\n\nSyntax:   (DELQ arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object, but should be a symbol.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of list2 except for those\n which are EQ to arg1.\n\nProcessing:\n\n list2 is destructively altered.  Each atom found within list2 that is\n EQ to arg1 is deleted from list2.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n Compare REMQ, which is the non-destructive equivalent of DELQ.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by DELQ.\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n Compare DELETE, which is like DELQ but uses an EQL test.\n DELQ is equivalent to Common LISP (DELETE ... #TEST #'EQ).\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\n As with all the \"destructive\" functions, DELQ should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\n Do not depend upon DELQ's altering of list2 if the CAR of list2\n matches arg1.  Use SETQ to insure updating of list2, as follows:\n\n  (SETQ Y (DELQ X Y))\n\nExamples:\n\n (DELQ 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (DELQ '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO BAR) (FOO) FOO BAR) ; Test is EQ, not EQUAL.\n\n (DELQ 2.0 '(1.0 2.0 3.0)) ==> (1.0 2.0 3.0)     ; Test is EQ, not EQL.\n\n (DELQ 'X '(X Y X Y X) 0) ==> (X Y X Y X)\n (DELQ 'X '(X Y X Y X) 1) ==> (Y X Y X)\n (DELQ 'X '(X Y X Y X) 2) ==> (Y Y X)\n (DELQ 'X '(X Y X Y X) 3) ==> (Y Y)\n\n;The following shows how the list is altered by DELQ.\n\n (SETQ X '(A B C D E))       ==> (A B C D E)\n X                           ==> (A B C D E)\n (SETQ Y (DELQ 'A X))        ==> (B C D E)\n X                           ==> (A B C D E)\n Y                           ==> (B C D E)\n (EQ X Y)                    ==> NIL\n (SETQ Y (DELQ 'C X))        ==> (A B D E)\n X                           ==> (A B D E)\n Y                           ==> (A B D E)\n (EQ X Y)                    ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELQL": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x06?\\x00\\x87$o#F\\x00O\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-03T23:46:00", "lines": 79, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DELQL\n\nSyntax:   (DELQL arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of list2 except for those\n which are EQL to arg1.\n\nProcessing:\n\n list2 is destructively altered.  Each atom found within list2 that is\n EQL to arg1 is deleted from list2.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n Compare REMQL, which is the non-destructive equivalent of DELQL.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by DELQL.\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n Compare DELQ, which is like DELQL but uses an EQ test;\n and DELQUAL, which is like DELQL but uses an EQUAL test.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\n As with all the \"destructive\" functions, DELQL should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\n Do not depend upon DELQL's altering of list2 if the CAR of list2\n matches arg1.  Use SETQ to insure updating of list2, as follows:\n\n  (SETQ Y (DELQL X Y))\n\nExamples:\n\n (DELQL 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (DELQL '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO BAR) (FOO) FOO BAR) ; Test is EQL, not EQUAL.\n\n (DELQL 2 '(1 2 3 4 5)) ==> (1 3 4 5)         ; Test is EQL, not EQ.\n\n (DELQL 1 '(1 2 1 2 1) 0) ==> (1 2 1 2 1)\n (DELQL 1 '(1 2 1 2 1) 1) ==> (2 1 2 1)\n (DELQL 1 '(1 2 1 2 1) 2) ==> (2 2 1)\n (DELQL 1 '(1 2 1 2 1) 3) ==> (2 2)\n\n;The following shows how the list is altered by DELQL.\n\n (SETQ X '(A B C D E))       ==> (A B C D E)\n X                           ==> (A B C D E)\n (SETQ Y (DELQL 'A X))       ==> (B C D E)\n X                           ==> (A B C D E)\n Y                           ==> (B C D E)\n (EQ X Y)                    ==> NIL\n (SETQ Y (DELQL 'C X))       ==> (A B D E)\n X                           ==> (A B D E)\n Y                           ==> (A B D E)\n (EQ X Y)                    ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELQUAL": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x06?\\x00\\x87$o#G\\x00O\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-03T23:47:00", "lines": 79, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DELQUAL\n\nSyntax:   (DELQUAL arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of list2 except for those\n which are EQUAL to arg1.\n\nProcessing:\n\n list2 is destructively altered.  Each atom found within list2 that is\n EQUAL to arg1 is deleted from list2.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n Compare REMQUAL, which is the non-destructive equivalent of DELQUAL.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by DELQUAL.\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n Compare DELQ, which is like DELQUAL but uses an EQ test;\n and DELQL, which is like DELQUAL but uses an EQL test.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\n As with all the \"destructive\" functions, DELQUAL should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\n Do not depend upon DELQUAL's altering of list2 if the CAR of list2\n matches arg1.  Use SETQ to insure updating of list2, as follows:\n\n  (SETQ Y (DELQUAL X Y))\n\nExamples:\n\n (DELQUAL 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (DELQUAL '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO) FOO BAR) ; Test is EQUAL, not EQL.\n\n (DELQUAL 2 '(1 2 3 4 5)) ==> (1 3 4 5)       ; Test is EQUAL, not EQ.\n\n (DELQUAL 1 '(1 2 1 2 1) 0) ==> (1 2 1 2 1)\n (DELQUAL 1 '(1 2 1 2 1) 1) ==> (2 1 2 1)\n (DELQUAL 1 '(1 2 1 2 1) 2) ==> (2 2 1)\n (DELQUAL 1 '(1 2 1 2 1) 3) ==> (2 2)\n\n;The following shows how the list is altered by DELQUAL.\n\n (SETQ X '(A B C D E))       ==> (A B C D E)\n X                           ==> (A B C D E)\n (SETQ Y (DELQUAL 'A X))     ==> (B C D E)\n X                           ==> (A B C D E)\n Y                           ==> (B C D E)\n (EQ X Y)                    ==> NIL\n (SETQ Y (DELQUAL 'C X))     ==> (A B D E)\n X                           ==> (A B D E)\n Y                           ==> (A B D E)\n (EQ X Y)                    ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DESETQ": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x072\\x00P\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T07:32:00", "lines": 80, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DESETQ\n\nSyntax:   (DESETQ &rest args)\n\n args occur in pairs: arg1 and arg2.\n\n arg1 (required, not evaluated) - a symbol or list.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n The last argument, after each argument pair is processed as a series of\n SETQ's generated through the interpretation of arg1 as a destructuring\n of the value of arg2.\n\nProcessing:\n\n For each arg1 and arg2 in the argument list...\n\n arg1 is treated as follows:\n If it is a non-NIL symbol, DESETQ is identical to SETQ.\n If it is a cons, the CAR of arg1 is DESETQ'd to the CAR of the value\n of arg2, and the CDR of arg1 is DESETQ'd to the CDR of the value of\n arg2.\n If it is NIL, the corresponding value of arg2 is ignored.  This\n permits \"holes\" in the destructuring assignment.\n\n The bindings are exactly like those done by SETQ (q.v.).\n\nErrors signaled:\n\n Odd number of arguments.\n Errors detected by SETQ (q.v.).\n\nNotes:\n\n Destructuring is the process of binding arguments according to a\n CAR/CDR structure of variable names; this process is used in\n DEFMACRO and DEFUN, and is available to LET and LET* as well as\n anonymous LAMBDAs.\n\n See the help for SETQ for more information.\n\n \"&-keywords\" are not supported by DESETQ.  If you need this sort\n of functionality, you must use the destructuring provided by\n DEFUN/LAMBDA/LET et al.\n\n DESETQ is a macro that generates calls to CAR and CDR.  If it is\n desired to generate calls to ZCAR for efficiency (meaning that you\n know that NIL will never be \"carred\"), then you must effect this by\n including\n\n  (DEFLOAD CAR ZCAR)\n\n in the source file.\n\nExamples:\n\n (DESETQ (A B (C D) E . F) '(1 2 (3 4) 5 6 7))  ==> (1 2 (3 4) 5 6 7)\n\n                A ==> 1\n                B ==> 2\n                C ==> 3\n                D ==> 4\n                E ==> 5\n                F ==> (6 7)\n\n (DESETQ ((A NIL B) NIL C) '((1 2 3) 4 5)) ==> ((1 2 3) 4 5)\n\n                A ==> 1\n                B ==> 3\n                C ==> 5\n\n (DESETQ (A) '(1) (B) '(2) (C) '(3)) ==> (3)\n\n                A ==> 1\n                B ==> 2\n                C ==> 3\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFLOATP": {"ttr": 3089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x074\\x00!\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T07:34:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DFLOATP\n\nSyntax:   (DFLOATP arg1)\n    or:   (DOUBLE-FLOAT-P arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a double-float, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare SFLOATP, which returns T if its argument is a single-float;\n and FLOATP, which returns T for any kind of flonum.\n\nExamples:\n\n (DFLOATP 1.0)   ==> T\n (DFLOATP 1)     ==> NIL\n (DFLOATP 1E1)   ==> T\n (DFLOATP 1.0D0) ==> T\n (DFLOATP 1.0F0) ==> NIL\n (DFLOATP '(1))  ==> NIL\n (DFLOATP 'ONE)  ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIFFEREN": {"ttr": 3091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x07E\\x00)\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T07:45:00", "lines": 41, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DIFFERENCE\n\nSyntax:   (DIFFERENCE arg1 arg2 ... argn)\n  Also:   (- arg1 arg2 ... argn)\n\n Any number of arguments may be specified.\n\n argn (evaluated) - a number.\n\nReturns:\n\n The difference, taken in succession, of all the arguments.\n\nProcessing:\n\n If no arguments are specified, 0 is returned.\n\n If one argument is specified, then processing differs for\n DIFFERENCE and -.  (DIFFERENCE n) returns n, but (- n) returns\n the unary minus of n.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for more information.\n\nNotes:\n\n See member $ARITH for more information.\n\nExamples:\n\n (DIFFERENCE)         ==> 0\n (DIFFERENCE 4)       ==> 4\n (- 4)                ==> -4\n (- 1 2)              ==> -1\n (DIFFERENCE 10 3)    ==> 7\n (DIFFERENCE 9 1 1.0) ==> 7.0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIGITCP": {"ttr": 3093, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86$\\x7f\\x00\\x87$\\x7f\\x07E\\x001\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-09-04T00:00:00", "modifydate": "1987-09-04T07:45:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: DIGIT-CHAR-P\n\nSyntax:   (DIGIT-CHAR-P char1 &optional (radix2 10))\n    or:   (DIGITCP char1 &optional (radix2 10))\n\n char1 (required, evaluated) - a fixnum.\n radix2 (optional, evaluated) - a fixnum between 2 and 36.\n\nReturns:\n\n A fixnum representing the numeric \"weight\" of the EBCDIC character\n represented by the fixnum char1, if it is a \"digit\" in the radix\n specified by radix2, else NIL.\n\nProcessing:\n\n If char1 is a number whose EBCDIC value represents a \"digit\" in the\n radix specified by radix2, its \"weight\" is returned; this is a fixnum\n whose value is the \"meaning\" of the digit in that radix.  If char1 is\n not in the range 0-255 or represents a non-numeric character in the\n specified radix, NIL is returned.\n\n Only alphabetic characters (lower or upper case) and EBCDIC numerics\n can be DIGIT-CHAR-P.\n\nErrors signaled:\n\n char1 not a fixnum.\n radix1 not a fixnum between 2 and 36.\n\nNotes:\n\nExamples:\n\n (DIGIT-CHAR-P #/9)    ==> 9     ; Default radix is 10.\n (DIGIT-CHAR-P #/a)    ==> NIL   ; Default radix is 10.\n (DIGIT-CHAR-P #/A)    ==> NIL   ; Default radix is 10.\n (DIGIT-CHAR-P #/a 16) ==> 10\n (DIGIT-CHAR-P #/a 8)  ==> NIL\n (DIGIT-CHAR-P #/9 16) ==> 9\n (DIGIT-CHAR-P #/9 10) ==> 9\n (DIGIT-CHAR-P #/9 8)  ==> NIL\n (DIGIT-CHAR-P #/1)    ==> 1     ; True in all valid radices.\n (DIGIT-CHAR-P 1)      ==> NIL\n (DIGIT-CHAR-P -1)     ==> NIL\n (DIGIT-CHAR-P 999)    ==> NIL\n (DIGIT-CHAR-P \"0\")    ==> (\"***ERROR***\") ; Not a fixnum.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DO": {"ttr": 3095, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87%\\x1f\\x17G\\x00[\\x00W\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-08T17:47:00", "lines": 91, "newlines": 87, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DO, DO*\n\nSyntax:   (DO arg1 arg2 arg3 ... argn)\n  Also:   (DO* arg1 arg2 arg3 ... argn)\n\n The first argument (a list of local variables with initialization\n and increment specifications) is required.\n\n The second argument (the termination clause) is required.\n\n At least one subsequent argument is required, but any number of\n arguments greater than two may be specified.\n\n arg1 (partially evaluated) - a list of local variable clauses, i.e.\n lists of three elements each, where the first element (not evaluated)\n is a symbol, the second (evaluated) is the value to which the symbol\n is to be initially bound, and the third (not evaluated) is a form\n which specifies how the local variable is to be incremented.\n\n arg2 (optionally evaluated) - a termination clause, i.e.\n a list of two or more elements similar to a COND clause, in which\n the first element is evaluated and the rest are evaluated only\n if the first returns a non-NIL value.\n\n argn (conditionally evaluated) - any LISP object.\n\nReturns:\n\n The last of the elements of the clause specified by the second\n argument.\n\nProcessing:\n\n The general format of DO is:\n\n   (DO ((var1 value1 incr1) (var2 value2 incr2) ... (varn valuen incrn))\n       (test1 consequent1 ... consequentn)\n       form1\n       form2\n       ...\n       formn\n   )\n\n in which the \"varn\"'s must be symbols and are not evaluated, the\n \"valuen\"'s are any LISP objects and are evaluated when the\n corresponding variables are bound, the \"incr1\"s are forms which are\n evaluated to increment the varn's, and the \"test1\", \"consequentn\"s, and\n \"formn\"'s are any LISP objects and are evaluated in sequence in the\n binding environment set up by the variable/value pairs.\n\n Although the clauses in the first argument are supposed to contain 3\n elements, the second and/or third may be omitted.  Furthermore, for\n each element of arg1, a symbol may be specified; this is equivalent\n to a list of one element.  In other words:\n\n (DO (I J K) ...     is equivalent to   (DO ((I) (J) (K)) ...\n  which in turn is the same as (DO ((I NIL) (J NIL) (K NIL)) ...\n\n DO* is the same as DO, except that the variables are bound\n in parallel rather than sequentially.\n\n In summary:\n\n DO binds each variable in the environment present outside of the DO.\n The variables are incremented in parallel.\n\n DO* binds each variable in the environment present immediately before\n the variable-value list, so that each binding can refer to previous\n (but not subsequent) DO variables.  The variables are incremented\n sequentially.\n\nErrors signaled:\n\n Invalid syntax (missing or invalid arguments).\n\nNotes:\n\n For a complete discussion of DO, refer to a MACLisp or Common LISP\n reference manual.\n\nExamples:\n\n (DO ((I 10 (SUB1 I))\n      (J NIL (CONS 'FOO J))\n     )\n     ((ZEROP I) J)\n     NIL\n )                      ==>  (FOO FOO FOO FOO FOO FOO FOO FOO FOO FOO)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOLIST": {"ttr": 3097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87$\\x7f\\x07G\\x00<\\x00<\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-04T07:47:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DOLIST\n\nSyntax:   (DOLIST arg1 &rest args)\n\n The first argument (a list of a local variable with an initialization\n and optional increment specifications) is required.\n\n At least one subsequent argument is required, but any number of\n arguments greater than two may be specified.\n\n arg1 (partially evaluated) - a local variable clause, i.e.\n a list of 2 or 3 elements, where the first element (not evaluated)\n is a symbol, the second (evaluated) is the value to which the symbol\n is to be initially bound, and the third (evaluated) is the value to\n be returned (this is optional and defaults to NIL).\n\n argn (conditionally evaluated) - any LISP object.\n\nReturns:\n\n The third element of the list arg1, or NIL, after executing the\n body (args) with the first element of arg1 bound to successive\n CAR's of the second element of arg2.\n\nProcessing:\n\n The general format of DOLIST is:\n\n   (DOLIST (var list &optional result) . body)\n\n DOLIST iterates over elements of \"list\".  First \"list\" is evaluated,\n which should produce a list.  Then the forms in \"body\" are evaluated;\n the entire body is executed once for each element (CAR) in the list, in\n order, with the variable \"var\" bound to the element.  Then \"var\" is\n bound to NIL, and \"result\" (a single form, NOT an implicit PROGN) is\n evaluated, and the result is the value returned from DOLIST.\n\n If \"result\" is omitted, DOLIST returns NIL after executing the body.\n\n A RETURN may be used within the body to terminate the loop and return\n a specified value.\n\nErrors signaled:\n\n Invalid syntax (missing or invalid arguments).\n Invalid variable name (not a symbol).\n\nNotes:\n\n The list argument is assumed to evaluate to a proper list.\n No error checking is done.\n\nExamples:\n\n (LET ((FOO NIL))\n      (DOLIST (X '(A B C D) FOO) (PUSH X FOO)))\n\n          ==> (D C B A)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOTIMES": {"ttr": 3099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87$\\x7f\\x07G\\x00@\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-04T07:47:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: DOTIMES\n\nSyntax:   (DOTIMES arg1 &rest args)\n\n The first argument (a list of a local variable with an initialization\n and optional increment specifications) is required.\n\n At least one subsequent argument is required, but any number of\n arguments greater than two may be specified.\n\n arg1 (partially evaluated) - a local variable clause, i.e.  a list of 2\n or 3 elements, where the first element (not evaluated) is a symbol, the\n second (evaluated) is a fixnum which the variable is compared to, and\n the third (evaluated) is the value to be returned (this is optional and\n defaults to NIL).\n\n argn (conditionally evaluated) - any LISP object.\n\nReturns:\n\n The third element of the list arg1, or NIL, after executing the\n body (args) with the first element of arg1 bound to successive\n increments of the second element of arg2.\n\nProcessing:\n\n The general format of DOTIMES is:\n\n   (DOTIMES (var count &optional result) . body)\n\n DOTIMES iterates over a sequence of integers.  First \"count\" is\n evaluated, which should produce an integer.  Then the forms in \"body\"\n are evaluated; the entire body is executed once for each integer from\n zero (inclusive) to the value of \"count\" (exclusive), in order, with\n the variable \"var\" bound to the integer.  (Note that if the value of\n \"count\" is zero or less, the body is not executed at all.)  At the\n end of this, \"var\" is bound to the number of times the body was\n executed, which should be the value of \"count\" if it was truly\n an integer.  Then \"result\" (a single form, NOT an implicit PROGN) is\n evaluated, and the result is the value returned from DOTIMES.\n\n If \"result\" is omitted, DOTIMES returns NIL after executing the body.\n\n A RETURN may be used within the body to terminate the loop and return\n a specified value.\n\nErrors signaled:\n\n Invalid syntax (missing or invalid arguments).\n Invalid variable name (not a symbol).\n\nNotes:\n\n The count argument is assumed to evaluate to a integer, or at least\n a number.  If it does not, a run-time error will occur.\n\nExamples:\n\n (LET ((FOO NIL))\n      (DOTIMES (X 10 FOO) (PUSH X FOO)))\n\n          ==> (9 8 7 6 5 4 3 2 1 0)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOWNCASE": {"ttr": 3101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x86\\x07o\\x00\\x87$\\x7f\\x07G\\x00'\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-17T00:00:00", "modifydate": "1987-09-04T07:47:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-DOWNCASE\n\nSyntax:   (STRING-DOWNCASE string1)\n    or:   (DOWNCASE string1)\n\n string1 (required, evaluated) - a string.\n\nReturns:\n\n A string identical to string1, except that all upper-case\n alphabetic characters are replaced with their lower-case equivalents.\n\nProcessing:\n\n The input argument is not altered.\n\n As with most string-handling functions, symbols are acceptable.\n However, the returned value is always a string.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Insufficient vector/string space to build the result.\n\nNotes:\n\n Compare STRING-UPCASE.\n\nExamples:\n\n (STRING-DOWNCASE \"\")        ==> \"\"\n (STRING-DOWNCASE \"a\")       ==> \"a\"\n (STRING-DOWNCASE \"A\")       ==> \"a\"\n (STRING-DOWNCASE \"foo\")     ==> \"foo\"\n (STRING-DOWNCASE \"FOO\")     ==> \"foo\"\n (STRING-DOWNCASE NIL)       ==> \"nil\"\n (STRING-DOWNCASE '|Foo Bar|) ==> \"foo bar\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EBCDIC": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x07P\\x00/\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T07:50:00", "lines": 47, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ECHO": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x862\\x1f\\x00\\x87$\\x7f\\x07Q\\x00;\\x00;\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-11-17T00:00:00", "modifydate": "1987-09-04T07:51:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ECHO\n\nSyntax:   (ECHO file1 &optional file2 arg3)\n\n arg1 (required, evaluated) - an input file name.\n arg2 (optional, evaluated) - an output file name.\n arg3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n NIL, after ECHO mode has been set on or off for input file file1.\n\nProcessing:\n\n If file2 is omitted, ECHO mode is set off for file1.\n If file2 is specified, it is made the \"ECHO\" file for file1. All input\n from file1 is echoed, character for character, onto output file file2.\n\n An input file cannot have more than one echo output file associated\n with it.  If file1 already has an echo file when (ECHO file1 file2)\n is issued, that echoing relationship is terminated.\n\n If arg3 is specified and non-NIL, the echoing takes place even if\n both file1 and file2 are allocated to the terminal.  The default\n mode of operation is to disable echoing when this is true, since\n all input can be seen and it would be unnecessary to have it displayed\n a second time.\n\n If file2 gets closed while file1 is echoing to it, file1 is\n unaffected except that echoing ceases to take place.  Reopening\n file2 is not sufficient to get echoing started again; the ECHO\n function must be reissued to reinstate echoing.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Invalid output file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Specified ouyput file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\nExamples:\n\n (ECHO NIL NIL) specifies that all input from standard input is to\n be printed on standard output unless both are allocated to the\n terminal.\n\n (ECHO NIL NIL NIL) is equivalent to the above.\n\n (ECHO NIL NIL T) specifies that all input from standard input is to\n be printed on standard output, even if both are allocated to the\n terminal.\n\n (ECHO NIL) terminates echo mode for standard input.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ED": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x08\\x13\\x00f\\x00L\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:13:00", "lines": 102, "newlines": 76, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ED\n\nSyntax:   (ED &optional arg1)\n\n arg1 (optional, evaluated) - a symbol or a string.\n\nReturns:\n\n (See under PROCESSING for description.)\n\nProcessing:\n\n If arg1 is omitted or NIL, the ISPF editor is entered on the dataset\n created by the (ED 'symbolname) function, which is created as a new\n (empty) dataset if it doesn't already exist.\n\n If arg1 is a string, it is interpreted as a data set name (similarly to\n the way it is interpreted by OPEN) and the ISPF editor is entered on\n this dataset.  For this case, the return value from ED is arg1.\n\n If arg1 is a symbol, the interpretive function definition associated\n with the symbol is pretty-printed into a temporary data set, and then\n the ISPF editor is entered on this dataset.  If the dataset is saved,\n the contents are then loaded under the interpreter, and the return\n value is that returned by the LOAD function; if the dataset was not\n saved, NIL is returned and no load takes place.\n\n If a symbol with no interpretive function definition is specified,\n the ISPF editor is entered on a data set with no LISP code in it\n (only comments).  The user may then enter a new function definition\n and save it for loading into the interpreter.  Although any valid\n LISP forms may be entered, it is generally assumed that the file\n will contain a (re)definition of the function being edited.\n\n This function is available only if ZIL was entered under ISPF.\n\nErrors signaled:\n\n Arg1 not a symbol or a string, or a null string, or a string\n longer than 56 characters.\n\n ISPF dialog services not available; either ZIL is running outside\n of ISPF or it is running under the TSO Authorized Service Facility\n or other environment where ISPF dialog services are temporarily\n unavailable.\n\n Errors detected by the ISPF EDIT service.\n\nNotes:\n\n ISPF and ISPF/PDF Version 2 must be installed to use this function.\n\n ED may be used to do quick editing of function definitions that\n were typed in \"on the fly\" under ZIL.  To save a permanent copy,\n you can use the CREATE or REPLACE command of the ISPF editor.\n You can use this to create function definitions for functions\n that have not been defined yet, as well as functions that are\n already defined.\n\n If you were in split screen mode when you started ZIL, you will\n be put back into the same split screen mode when ED enters ISPF.\n Thus, (ED) is convenient when running an interactive ZIL session\n under one screen of ISPF; you can use it just to flip back to\n the other screen periodically, without actually having to edit\n anything.\n\n The name of the temporary data set is \"tsoprefix.SPFTEMPZ.ZILEDIT.LISP\"\n and is not changeable (sorry).  The data set will be created as NEW\n if it does not exist in your catalog.  Note that whenever\n (ED 'functionname) is used, this dataset is opened for output and\n rewritten, so the previous contents are always lost.  On the other\n hand, (ED) goes into EDIT on the previous contents of that data set.\n\n In ZIL 1.2, (ED \"data.set.name\") returned T if the dataset was saved,\n and NIL if it wasn't.  This was changed so that you could type\n (LOAD *) under the interpreter to load the data set just edited\n if you wanted to.  The ZILEDIT function still returns T or NIL\n depending on whether the dataset was saved.\n\n At Draper, if ED is invoked from within a LISP program (including\n the interpreter) that was invoked under ISPF via the XINVOKE command,\n ED will fail due to ISPF dialog services not being available.  For\n this reason, the ZIL interpreter is invoked by the ISPF option via\n XCMD (to pick up library allocations).\n\nExamples:\n\n (ED 'foo)\n\n enters the ISPF editor on a file containing a pretty-printed\n definition of the function foo.\n\n (ED)\n\n reenters the ISPF editor on whatever you had put in that file\n last time.\n\n (ED \"cmd.clist(zlogon)\")\n\n allows you to edit your ZLOGON CLIST while under ZIL.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EIGHTH": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x177\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:37:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: EIGHTH\n\nSyntax:   (EIGHTH list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The eighth element of list1, or NIL if list1 has less than 8 elements.\n\nProcessing:\n\n (EIGHTH x) is the same as (CADDDR (CADDDR X)).\n\nErrors signaled:\n\n See CAR, CDR, etc.\n\nNotes:\n\n See CAR, CDR, etc.\n\nExamples:\n\n (EIGHTH NIL)                  ==> NIL\n (EIGHTH '(A))                 ==> NIL\n (EIGHTH '(A B C D E F G H))   ==> H\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDP": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x15\\x8f\\x00\\x89\\x15\\x8f\\x177\\x00!\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-07T00:00:00", "modifydate": "1989-06-07T17:37:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ENDP\n\nSyntax:   (ENDP arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is NIL, NIL if arg1 is a CONS.\n\nProcessing:\n\n If arg1 is NIL, then T is returned.  If arg1 is a CONS (a non-null\n list), NIL is returned.  If arg1 is not NIL or a CONS, an error is\n signaled.\n\nErrors signaled:\n\n arg1 not NIL or a CONS.  Note that this error may not be signaled\n in compiled code.\n\nNotes:\n\n ENDP is the recommended way of testing for the end of a list.  It\n supports \"proper lists\" only, not lists ending in an atom.\n\nExamples:\n\n (ENDP NIL)              ==> T\n (ENDP '(NIL))           ==> NIL\n (ENDP '(A B C))         ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENDREAD": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x08\\x15\\x005\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:15:00", "lines": 53, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ENDREAD\n\nSyntax:   (ENDREAD &optional file1)\n\n file1 (optional, evaluated) - an input file name.\n\nReturns:\n\n NIL; end-of-line status is forced on the file specified by file1.\n\nProcessing:\n\n End-of-line is set in the file block for the input file specified by\n file1, so that subsequent input functions (READ, READCH, etc.) initiate\n a fresh read operation.  This has the effect of causing READCH to\n detect end-of-line if it is the next input operation against the file.\n\n ENDREAD does not set the \"newline\" flag tested by NEWLINEP, but if\n READCH is issued afterwards it will return NIL and cause NEWLINEP\n to be true.\n\n For data sets, this means that a new logical record will be read\n from the file, skipping all characters in the current record that\n have not been read yet.\n\n For files allocated to the terminal, this causes unprocessed input\n to be discarded; the user must then type in new data.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n When the input is from the terminal, ENDREAD results in a TGET\n macro instruction being issued on the next READ-type function call\n to the file.  However, a TCLEARQ macro is NOT issued, so the input\n buffers are not truly \"flushed\", even though the remainder of the\n data in the current input is not processed.  Since ZIL sees the\n input as logical records with a length of 80, the input \"flushing\"\n is on a 80-byte record basis.\n\nExamples:\n\n (ENDREAD)\n (ENDREAD NIL) ...are equivalent.\n\n (ENDREAD 'FOO)  forces a new line condition on the input file FOO.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EOF": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x08\\x17\\x00+\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:17:00", "lines": 43, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EOF\n\nSyntax:   (EOF &optional file1)\n\n file1 (optional, evaluated) - an input file name.\n\nReturns:\n\n T if end-of-file status has been reached on the input file specified\n by file1, else NIL.\n\nProcessing:\n\n If the end-of-file flag is on in the input file file1, T is returned;\n otherwise NIL is returned.\n\n A ZIL program or function should issue this function call while\n processing one or more READ/READCH/TYI calls to see if end-of-file has\n been reached, in order to prevent a \"read after end of file\" run-time\n error.  A NIL result returned by READ or READCH, or an \"eofval\" from\n TYI, should be ignored if the end-of-file flag is on for the file in\n question.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n If the QUIT function has been issued against the file, EOF will\n return T.\n\nExamples:\n\n (EOF)\n (EOF NIL)    ...are equivalent.\n\n (EOF 'FOO)      returns T if end-of-file has been reached on FOO.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQ": {"ttr": 3343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x08&\\x004\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:26:00", "lines": 52, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EQ\n\nSyntax:   (EQ arg1 arg2)\n\n arg1 (required,evaluated) - any LISP object.\n arg2 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is the same object as arg2, otherwise NIL.\n\nProcessing:\n\n EQ means that the pointer representing arg1 is the same (the address is\n numerically the same) as the pointer representing arg2.  Two symbols\n with the same print name are EQ unless one was created by a function\n that did not intern the value on the oblist (e.g. GENSYM).  Two numbers\n are not necessarily EQ; use = to test equality of numbers, or EQL if\n the numbers must be of the same type.  Two lists are not necessarily\n EQ; use EQUAL to test equality of lists.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n See member $EQUAL for more information about equality predicates.\n\nExamples:\n\n (EQ 'A 'A)           ==> T\n (EQ 'A 'B)           ==> NIL\n (EQ () NIL)          ==> T\n\n (SETQ X '(A B))      ==> (A B)\n (SETQ Y X)           ==> (A B)\n (EQ X Y)             ==> T\n\n (SETQ X '(A B))      ==> (A B)\n (SETQ Y '(A B))      ==> (A B)\n (EQ X Y)             ==> NIL ; always when interpreted, usually when\n                              ; compiled\n\n;(EQ 1 1)             ==> {unpredictable: either T or NIL}\n\n (EQ (+ 1 1) 2)       ==> NIL\n\n (EQ (MAKNAM  '(A B C)) 'ABC) ==> NIL\n (EQ (IMPLODE '(A B C)) 'ABC) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EQL": {"ttr": 3345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x086\\x00/\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:36:00", "lines": 47, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EQL\n\nSyntax:   (EQL arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if the types and contents of arg1 and arg2 are identical, else NIL.\n\nProcessing:\n\n If the arguments are EQ, regardless of type, the result is\n always true (i.e. T is returned).\n\n If the types of the arguments are different, the result is\n always false (i.e. NIL is returned).\n\n If both arguments are numbers, a numeric compare is performed of\n the appropriate number type.  Remember that the types must match.\n\n If both arguments are strings, the string contents are compared.\n Case is significant.\n\n For all other types (including symbols and lists), the two arguments\n are considered EQL if and only if they are EQ.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n See member $EQUAL for more information about equality predicates.\n\nExamples:\n\n (EQL 'FOO 'FOO)     ==> T\n (EQL 'A 'B)         ==> NIL\n (EQL (ADD1 1) 2)    ==> T\n (EQL 1 1.0)         ==> NIL\n (EQL 'A \"A\")        ==> NIL\n (EQL \"A\" \"A\")       ==> T\n (EQL \"A\" \"a\")       ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQUAL": {"ttr": 3347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x087\\x004\\x00K\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:37:00", "lines": 52, "newlines": 75, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EQUAL\n\nSyntax:   (EQUAL arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if the structures of arg1 and arg2 are identical, else NIL.\n\nProcessing:\n\n If the arguments are both atoms, EQUAL is equivalent to EQL.\n If one argument is an atom and the other is a list, EQUAL returns NIL.\n If both arguments are lists,\n EQUAL returns T if the following conditions hold:\n  The lists have the same length.\n  The CAR's of the lists are EQUAL.\n  The CDR's of the lists are EQUAL.\n\n Note that fixnums are never EQUAL to flonums!  If you wish to\n compare these, use EQUALP or =.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n EQUAL will loop infinitely on circular lists.  It will recur until\n the push-down stack overflows on lists which contain elements that\n point into themselves.\n\n See member $EQUAL for more information about equality predicates.\n\nExamples:\n\n (EQUAL 'FOO 'FOO)         ==> T\n (EQUAL 'A 'B)             ==> NIL\n (EQUAL 1 1)               ==> T\n (EQUAL 1.0 1.0)           ==> T\n (EQUAL 1 1.0)             ==> NIL\n (EQUAL (ADD1 1000) 1001)  ==> T\n (EQUAL \"A\" \"A\")           ==> T\n (EQUAL \"A\" \"a\")           ==> NIL\n\n (EQUAL (LIST 1 2)     (LIST 1 2))     ==> T\n (EQUAL (LIST \"A\" \"B\") (LIST \"A\" \"B\")) ==> T\n (EQUAL (LIST 'A 'B)   (LIST 'A 'B))   ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQUALP": {"ttr": 3349, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x08H\\x00G\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T08:48:00", "lines": 71, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EQUALP\n\nSyntax:   (EQUALP arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object.\n args (optional, evaluated) - any LISP object.\n\nReturns:\n\n T if the contents of all the args are identical, else NIL.\n\nProcessing:\n\n For EQUALP, which takes exactly two args, the following holds.\n\n  If the arguments are EQ, regardless of type, the result is\n  always true (i.e. T is returned).\n\n  If one argument is numeric and the other is not, the result is\n  always false (i.e. NIL is returned).\n\n  If both arguments are numbers, a numeric comparison is performed.\n  If the types differ, the appropriate conversion is performed (see\n  member $ARITH for conversion rules) and the numeric compare is done.\n\n  If both arguments are strings, a character compare is done on the\n  contents thereof, after translating them both internally to uppercase.\n\n  If both arguments are lists, they are EQUALP if they have the\n  same number of elements, the CAR's are EQUALP, and the CDR's\n  are EQUALP.\n\n  If both arguments are vectors, they are EQUALP if they have the\n  same number of elements and all the elements are respectively\n  EQUALP.\n\n  For all other types, the arguments are EQUALP only if they are EQL.\n\n For =, which takes any number of args, the result is T if there is\n only one arg, or if all the args are EQUALP to each other (only\n adjacent pairs are compared); otherwise the result is NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n See member $EQUAL for more information on equality predicates.\n\n EQUALP in ZIL 1.3 is (more or less) the Common Lisp EQUALP.\n The function called EQUALP in earlier releases of ZIL is most\n nearly similar to ZILEQUAL, which is new in ZIL 1.3.\n\n EQUALP is potentially considerably more expensive than any of the\n other equality predicates.  It is provided only because it exists\n in Common Lisp and there has always been a ZIL function by that\n name, even if it behaves somewhat differently.\n\nExamples:\n\n (EQUALP 'FOO 'FOO)       ==> T\n (EQUALP 'A 'B)           ==> NIL\n (EQUALP (ADD1 1) 2)      ==> T\n (EQUALP 1 1.0)           ==> T\n (EQUALP \"A\" \"A\")         ==> T\n (EQUALP \"A\" \"a\")         ==> T\n (EQUALP \"A\" 'A )         ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ERROR": {"ttr": 3351, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x89\\x14/\\x17S\\x00A\\x00A\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1989-05-22T17:53:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ERROR\n\nSyntax:   (ERROR &optional arg1 &rest args)\n\n arg1 (optional, evaluated) - any LISP object, but generally a string.\n args (optional, evaluated) - any LISP object.\n\nReturns:\n\n Nothing; after arg1 (and the other arguments, if non-NIL) is printed to\n the standard output file, a THROW to tag NIL is issued.\n\nProcessing:\n\n If the first argument is omitted, or is a list, control is passed to\n ZERROR.  This is for compatibility with earlier ZIL versions of the\n ERROR function.  See ZERROR for more information.\n\n Similarly, if the first argument is a string that does not contain\n FORMAT directives (tildes), and there are additional arguments\n specified, control is passed to ZERROR to format the message with\n the additional arguments.  Note that the formatting is done in such\n a way as to provide an error prefix and appropriate indentation on\n each line of the error message.\n\n Otherwise, the first argument is assumed to be a FORMAT string with\n directives specifying how to format the error message with the\n arguments specified, and the message is written to the standard output\n file using FORMAT.  Control is then passed to ZERROR with no arguments\n to cause ZIL to signal an error.\n\n Generally, the first argument is an error message, and the other\n arguments are the objects in question that were in error.\n\n If the current message level is greater than 2, no writing to the\n standard output file takes place, but the error signalling still\n takes place.\n\nErrors signaled:\n\n Errors in formatting the string.\n\nNotes:\n\n See ZERROR for information on how error signalling is done in ZIL\n at a slightly lower (but not the lowest) level.\n\nExamples:\n\n (SETQ A 'VALUE-OF-A)\n (ERROR \"Invalid argument:  ~A\" A)  will print:\n\n  ;Error: Invalid argument:  VALUE-OF-A\n\n on the standard output file and signal an error.\n\n (ERROR \"Invalid argument:~%~A~%Please enter another.\" A)  will print:\n\n  ;Error: Invalid argument:\n  ;       VALUE-OF-A\n  ;       Please enter another.\n\n on the standard output file and signal an error.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EVAL": {"ttr": 3353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x88\\x12O\\x08\\x01\\x00;\\x008\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1988-05-03T08:01:00", "lines": 59, "newlines": 56, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EVAL\n\nSyntax:   (EVAL arg1 &optional arg2)\n\n arg1 (required, evaluated) - an atom or proper list.\n arg2 (optional, evaluated) - a list in association list format\n                              (i.e. a list of dotted pairs).\n\nReturns:\n\n The result of evaluating arg1, with the variable binding environment\n specified by arg2 being used to resolve variable bindings.\n\nProcessing:\n\n Note that it will appear to the interpreter user that two evaluations\n of the first argument occur:  the first as part of normal argument\n evaluation, and the second as performed by the EVAL function specified.\n\n arg2 is designed for use of EVAL inside FEXPR definitions, and is not\n recommended for use otherwise.\n arg2, if not specified, defaults to NIL, in which case the current\n interpretive lexical variable binding environment (alist) is used.\n If a non-NIL value is specified, interpretive lexical variable bindings\n will be determined from the association list specified by this\n argument; if a variable encountered during the evaluation process is\n not present in this list and not dynamically bound, it will be unbound\n and will signal an error.\n\nErrors signaled:\n\n Too numerous to detail.\n\nNotes:\n\n Unpredictable results will occur if the second argument is not NIL or\n a list of dotted pairs.\n\n To pass a complete evaluation environment to EVAL, you must use\n ZILEVAL instead.\n\nExamples:\n\n (PROGN\n  (SETPLIST 'A NIL)                  ; Remove any funny properties.\n  (MAKUNBOUND 'A)\n )                                   ==> A ; Insure A not bound.\n\n (EVAL '(CAR '(A B C)))              ==> A\n (EVAL '(QUOTE FOO))                 ==> FOO\n\n (LET ((A \"no-value\"))\n      (EVAL 'A))                     ==> (\"***ERROR***\") ; unbound\n (LET ((A \"no-value\"))\n      (EVAL 'A '((FOO . BAR))))      ==> (\"***ERROR***\") ; unbound\n (LET ((A \"no-value\"))\n      (EVAL 'A '((A . 1) (B . 2) (C . 3)))) ==> 1\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EVALWHEN": {"ttr": 3355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x07\\x8f\\x00\\x87$\\x7f\\x17\\t\\x00I\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-19T00:00:00", "modifydate": "1987-09-04T17:09:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: EVAL-WHEN\n\nSyntax:   (EVAL-WHEN times &rest forms)\n\n times (required, not evaluated) - a list of one or more of the\n                                 following symbols: COMPILE, LOAD, EVAL\n forms (evaluated) - zero or more LISP forms.\n\nReturns:\n\n If and when the forms are evaluated, the last of the forms;\n otherwise NIL.\n\nProcessing:\n\n Under the interpreter, the forms are evaluated as an implicit PROGN\n only if EVAL is a member of the times list.\n COMPILE and LOAD, if specified, are ignored by the interpreter.\n\n The compiler processes EVAL-WHEN forms as follows:\n\n  If COMPILE is a member of the times list, the forms are evaluated\n  (as an implicit PROGN) by the compiler itself.\n\n  If LOAD is a member of the times list, the forms are compiled as\n  if they had appeared normally in the file.\n\n  EVAL, if specified, is ignored by the compiler.\n\nErrors signaled:\n\n Missing times list.\n\nNotes:\n\n Originally under ZIL, compiler directives had to be coded via the %\n function.  A list whose CAR is % caused the CDR of that list to be\n evaluated by the compiler.\n\n This feature, while still supported for convenience, is now obsolete.\n The Common LISP (EVAL-WHEN (COMPILE) ...forms...)  construct is the\n correct way to specify compiler directives.\n\n Compiler directives can occur at top level only.\n\n A common use of EVAL-WHEN is for macro definitions that must be known\n to the compiler and to compile-time macro expanders; for example,\n definitions of SETF methods.  In cases like these, it is best to\n surround such definitions in an (EVAL-WHEN (COMPILE LOAD EVAL) ...)\n to cover all cases, including the running of the source code\n interpretively for testing.\n\n For more information, see member $COMPILE of this document.\n\nExamples:\n\n (EVAL-WHEN (COMPILE LOAD EVAL)\n   (DEFMACRO FOO (X) (BAR X))\n   (DEFUN BAR (X) `(SOME EXPANSION WITH ,X)))\n\n If you have the following in your source:\n\n   (EVAL-WHEN (COMPILE)\n    (PRINC \"Hello, I'm compiling your program now!\")\n    (TERPRI)\n   )\n\n the compiler will print the message:\n\n   Hello, I'm compiling your program now!\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EVENP": {"ttr": 3357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x17\\x11\\x00\\x1c\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T17:11:00", "lines": 28, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EVENP\n\nSyntax:   (EVENP arg1)\n\n arg1 (required, evaluated) - an integer.\n\nReturns:\n\n T if arg1 is even (divisible by two), else NIL.\n\nProcessing:\n\nErrors signaled:\n\n Non-integer argument.\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (EVENP 0)        ==> T\n (EVENP 7)        ==> NIL\n (EVENP -8)       ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EVERY": {"ttr": 3359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x12\\x7f\\x00\\x87$\\x7f\\x17\\x12\\x00/\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-05-07T00:00:00", "modifydate": "1987-09-04T17:12:00", "lines": 47, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EVERY\n\nSyntax:   (EVERY arg1 arg2 ... argn)\n\n arg1 (required, evaluated) - a function that can be APPLY'ed.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n NIL if any of the values produced by applying the first argument\n function to successive elements (CAR's) of the other argument lists\n is NIL, else T.\n\nProcessing:\n\n The function specified by the first argument is applied to each of the\n elements (CAR's) of the lists specified by the other arguments, until\n one of the lists is exhausted (in which case EVERY returns T) or a null\n value is produced by this application (in which case EVERY returns\n NIL).\n\n If no lists are specified, EVERY returns T.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare SOME, NOTANY, NOTEVERY, and the mapping functions.\n See $MAP for more information.\n\nExamples:\n\n (EVERY #'INTEGERP NIL)            ==> T\n (EVERY #'INTEGERP '(A B C D E))   ==> NIL\n (EVERY #'INTEGERP '(1 2 3 4 5))   ==> T\n (EVERY #'INTEGERP '(A 2 3 4 5))   ==> NIL\n (EVERY #'INTEGERP '(1 2 3 4 E))   ==> NIL\n (EVERY #'INTEGERP '(A B 3 D E))   ==> NIL\n (EVERY #'EQ '(A B C) '(A B C D))  ==> T\n (EVERY #'EQ '(X B C) '(A B C D))  ==> NIL\n (EVERY #'EQ '(X Y Z) '(A B C D))  ==> NIL\n (EVERY #'EQ '(A B Z) '(A B C D))  ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXIT": {"ttr": 3361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x17\\x12\\x009\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T17:12:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EXIT\n\nSyntax:   (EXIT &optional arg1)\n\n arg1 (optional, evaluated) - a fixnum or NIL.\n\nReturns:\n\n Nothing; processing is terminated and control returned to the system.\n\nProcessing:\n\n The LISP environment is terminated and control is returned to the\n operating system, TSO, or whoever invoked the LISP program.\n\n In the interpretive environment, the LISP program is the interpreter,\n so (EXIT) kills the interpreter without letting it put out its\n friendly \"I ended\" message.\n\n If the argument is non-NIL, it is assumed to be a fixnum and the\n return code from the LISP program is set to its contents.\n\n If the argument is NIL, the return code is not set (in practice this\n means that the return code is zero).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Since the argument is not checked for validity, the return code\n contents will be unpredictable if the argument is not a fixnum.\n However, the return to the system will be executed regardless.\n\n This function may be used in LISP programs to return non-zero return\n codes which may be tested in CLIST's or JCL.\n\n Invoked from within a LISP function (compiled or interpreted) running\n under the interpreter, EXIT causes immediate termination of the\n interpreter.  Compare QUIT, which stops the interpreter cleanly by\n forcing an end-of-data condition on the standard input file.\n\n Do not confuse this with the (END) function, which indicates end of\n source input to the compiler.\n\nExamples:\n\n (EXIT)\n (EXIT NIL)\n (EXIT 0)     ...are all equivalent.\n\n (EXIT 12)       returns a code of 12 to the system.\n (EXIT -1)       returns a crazy return code, but returns nonetheless.\n (EXIT '(A B C)) returns a crazy return code, but returns nonetheless.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXP": {"ttr": 3363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x7f\\x00\\x87$\\x7f\\x17\\x14\\x00%\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-26T00:00:00", "modifydate": "1987-09-04T17:14:00", "lines": 37, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EXP\n\nSyntax:   (EXP num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n A number whose value is E raised to the num1'th power.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the\n value from num1.  If num1 is a single-precision flonum, the\n result is a single-precision flonum; otherwise the result is\n a double-precision flonum.\n\nErrors signaled:\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\n This function will fail for values of num1 about 174.673 or greater.\n\n\nExamples:\n\n(EXP 1) ==> 2.71828182\n(EXP 0) ==> 1.0\n(EXP -1) ==> 0.36787944\n(EXP 2.0) ==> 7.38905609\n(EXP 2.0F0) ==> 7.3890562F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXPLODE": {"ttr": 3365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x7f\\x00\\x87$\\x7f\\x17\\x15\\x002\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-27T00:00:00", "modifydate": "1987-09-04T17:15:00", "lines": 50, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EXPLODE\n\nSyntax:   (EXPLODE arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A list of single-character symbols corresponding to the\n character representation of arg1 as printed out via PRIN1.\n\nProcessing:\n\n arg1 is converted to the character representation which it has when it\n is printed - as it looks via PRIN1.  Each character in this\n representation is then used to build a symbol whose print name is that\n single character, and all of these symbols are interned on the oblist\n and consed together to form a list, which is returned as the value.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare EXPLODEC, which is similar but uses the representation\n generated by PRINC.\n\n Previous releases of ZIL had an optional argument to EXPLODE that\n specified whether or not to intern the generated symbols.  EXPLODE\n now interns all symbols; to get the old behavior, use ZILEXPL, an\n internal function that takes 2 optional arguments.  The second\n optional argument to ZILEXPL specifies whether to use PRIN1 (T)\n or PRINC (NIL) style exploding; EXPLODEC uses the latter.\n\nExamples:\n\n (EXPLODE 'A)     ==> (A)\n (EXPLODE NIL)    ==> (N I L)\n (EXPLODE 007)    ==> (|7|) ; note that this is the symbol |7|,\n                              ; not the fixnum 7.\n (EXPLODE '|007|) ==> (|\\|| |0| |0| |7| |\\||) ; note symbols all.\n (EXPLODE \"hi\")   ==> (|\"| |h| |i| |\"|)\n\n (EXPLODE '|a b|)        ==> (|\\|| |a| | | |b| |\\||)\n (EXPLODEC '|a b|)       ==> (|a| | | |b|)\n (EXPLODE \"abc\")         ==> (|\"| |a| |b| |c| |\"|)\n (EXPLODEC \"abc\")        ==> (|a| |b| |c|)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXPLODEC": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03_\\x00\\x87$\\x7f\\x17\\x16\\x00+\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-04T00:00:00", "modifydate": "1987-09-04T17:16:00", "lines": 43, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EXPLODEC\n\nSyntax:   (EXPLODEC arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A list of single-character symbols corresponding to the\n character representation of arg1 as printed out via PRINC.\n\nProcessing:\n\n arg1 is converted to the character representation which it has when it\n is printed - as it looks via PRINC.  Each character in this\n representation is then used to build a symbol whose print name is that\n single character, and all of these symbols are interned on the oblist\n and consed together to form a list, which is returned as the value.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare EXPLODE, which is similar but uses the representation\n generated by PRIN1.\n\nExamples:\n\n (EXPLODEC 'A)     ==> (A)\n (EXPLODEC NIL)    ==> (N I L)\n (EXPLODEC 007)    ==> (|7|) ; note that this is the symbol |7|,\n                              ; not the fixnum 7.\n (EXPLODEC '|007|) ==> (|0| |0| |7|) ; note symbols all.\n (EXPLODEC \"hi\")   ==> (|h| |i|)\n\n (EXPLODE '|a b|)        ==> (|\\|| |a| | | |b| |\\||)\n (EXPLODEC '|a b|)       ==> (|a| | | |b|)\n (EXPLODE \"abc\")         ==> (|\"| |a| |b| |c| |\"|)\n (EXPLODEC \"abc\")        ==> (|a| |b| |c|)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXPLODEN": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x11\\x9f\\x00\\x87$\\x7f\\x17\\x16\\x00+\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-04-29T00:00:00", "modifydate": "1987-09-04T17:16:00", "lines": 43, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EXPLODEN\n\nSyntax:   (EXPLODEN arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A list of fixnums corresponding to the character representation of arg1\n as printed out via PRINC.\n\nProcessing:\n\n arg1 is converted to the character representation which it has when it\n is printed - as it looks via PRINC.  Each character in this\n representation is then used to build a fixnum whose value is the EBCDIC\n representation of that single character, and all of these fixnums are\n consed together to form a list, which is returned as the value.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare EXPLODEC, which is similar but generates a list of interned\n symbols.\n\n EXPLODEN is analogous to EXPLODEC in that it uses the PRINC-style\n format of its argument.  There is no analogous function that creates\n a list of fixnums in PRIN1 format.  If you don't believe me, go and\n check the Maclisp manual.\n\nExamples:\n\n (EXPLODEN 'A)     ==> (193)\n (EXPLODEN \"A\")    ==> (193)\n (EXPLODEN \"a\")    ==> (129)\n (EXPLODEN NIL)    ==> (#\\N #\\I #\\L)\n (EXPLODEN 007)    ==> (247)\n (EXPLODEN '|007|) ==> (240 240 247)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXPT": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87$\\x7f\\x17H\\x00M\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-04T17:48:00", "lines": 77, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: EXPT\n\nSyntax:   (EXPT num1 num2)\n    or:   (** num1 num2)\n\n num1 (required,evaluated) - an integer or flonum.\n num2 (required,evaluated) - a fixnum or flonum.\n\nReturns:\n\n num1 raised to the power of num2 (num1 ** num2).\n\nProcessing:\n\n When num2 is a negative integer, a result is returned equivalent to 1\n divided by num1 ** abs(num2).  If num1 is an integer, this will be a\n (truncated) integer result.\n\n (EXPT 0 0) returns 1.\n\n See member $ARITH for more information.\n\nErrors:\n\n Invalid exponent (only fixnums and flonums, no bignums).\n See member $ARITH for other errors.\n\nNotes:\n\n See member $ARITH for more information.\n\n Flonum exponents are computed as follows:\n\n    Y     Y log(X)\n   X  =  e\n\n (i.e. using the LOG and EXP functions).  Therefore, flonum\n exponentiation requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\nExamples:\n\n (EXPT 2 3)     ==> 8\n (EXPT 4 2)     ==> 16\n (EXPT 4.0 2)   ==> 16.0\n (EXPT 4 -2)    ==> 0     ;  i.e. (/ 1 16)\n (EXPT 4.0 -2)  ==> 0.0625\n (EXPT 2 31)    ==> 21\n (EXPT 2 32)    ==> 42\n (EXPT 99 0)    ==> 1\n (EXPT 99 1)    ==> 99\n (EXPT 0 0)     ==> 1\n (EXPT 0 1)     ==> 0\n (EXPT 0 2)     ==> 0\n\n ; Beware of using EXPT as a substitute for SQRT.\n\n (SQRT 25)         ==> 5.0\n (EXPT 25 0.5)     ==> 4.99999999\n (EXPT 25.0 0.5)   ==> 4.99999999\n (EXPT .25 0.5)    ==> 0.5\n\n ; As you can see, certain inaccuracies creep in.\n ; But this will illustrate the type coercion.\n\n (EXPT 2     3    )  ==> 8\n (EXPT 2     3.0F0)  ==> 8.0000038F0\n (EXPT 2     3.0D0)  ==> 7.9999999999999984D0\n (EXPT 2.0F0 3    )  ==> 8.0F0\n (EXPT 2.0F0 3.0F0)  ==> 8.0000038F0\n (EXPT 2.0F0 3.0D0)  ==> 8.0000000457117033D0\n (EXPT 2.0D0 3    )  ==> 8.0D0\n (EXPT 2.0D0 3.0F0)  ==> 7.9999999999999984D0\n (EXPT 2.0D0 3.0D0)  ==> 7.9999999999999984D0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FBOUNDP": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\t?\\x00\\x87$\\x7f\\x17S\\x00<\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-03T00:00:00", "modifydate": "1987-09-04T17:53:00", "lines": 60, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FBOUNDP\n\nSyntax:   (FBOUNDP arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n T or NIL, depending of whether the symbol specified by arg1 currently\n has a function definition.\n\nProcessing:\n\n The variable specified by arg1 must have one of the following:\n\n  (1) a MACRO, EXPR or FEXPR definition, as assigned by DEFUN or\n      DEFMACRO.\n\n  (2) a SUBR definition, as assigned when a compiled code definition\n      is loaded from the system library for this function.\n\n  (3) a special form definition, as set up by the evaluator at\n      initialization time.\n\n If it does, T is returned; otherwise the autoload process is invoked\n to attempt to locate a function definition.  If this process fails\n to make the function defined, NIL is returned.\n\n If the argument is not a symbol, a warning message is issued and NIL\n is returned.\n\n In the compiled environment, FBOUNDP may not be true of symbols which\n are the names of internally defined functions (functions which are\n only called from external compiled functions within a single compiled\n function source file).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Remember that the argument to FBOUNDP is evaluated for its value.\n\n The form (DEFUN (function property) ... ) does NOT make \"function\"\n FBOUNDP.  That does not count as a function definition for the\n symbol.\n\nExamples:\n\n (FBOUNDP 'CAR)             ==>  T\n (FBOUNDP 'COND)            ==>  T\n (FBOUNDP 'DO)              ==>  T\n (FBOUNDP 'NEW-FUNCTION)    ==>  NIL\n (DEFUN (NEW-FUNCTION SETFMETHOD) (A B) NIL) ==> NEW-FUNCTION\n (FBOUNDP 'NEW-FUNCTION)    ==>  NIL\n (DEFUN NEW-FUNCTION () T)  ==>  NEW-FUNCTION\n (FBOUNDP 'NEW-FUNCTION)    ==>  T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FEATUREP": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x10\\x00\\x865\\x7f\\x01\\x00$\\x1f\\x164\\x00A\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-12-23T00:00:00", "modifydate": "2000-08-28T16:34:10", "lines": 65, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FEATUREP\n\nSyntax:   (FEATUREP arg1)\n\n arg1  (required, evaluated) - any LISP object, but generally a symbol.\n\nReturns:\n\n T if arg1 is a member of the \"features list\", else NIL.\n\nProcessing:\n\n The list of features (which is the value of the global variable\n *FEATURES*) is searched for a value which is EQ to arg1.  If one\n is found, T is returned; else NIL is returned.\n\n An object which is FEATUREP may be used in the reader macro\n notations #+object and #-object.  #+object causes the next item\n to be read only if object is FEATUREP; #-object causes the next item\n to be read only if object is NOT FEATUREP.\n\n An object may be made to be FEATUREP by SET-FEATURE, and may be\n made NOT FEATUREP by SET-NOFEATURE.\n\n The \"features\" feature is generally used to select implementation-\n -dependent code at read time when processing LISP source code that is\n designed to run on more than one system.  See member $RMACRO of this\n documentation for more information on the use of \"features\".\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The following features are currently present in ZIL:\n\n ZIL ZIL13 GC BIGNUM MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP\n\n ... and, depending on the installation, some or all of:\n\n CSDL DRAPER TSO MVS XA VF\n\n In addition, under the interpreter, there is a ZILIN feature;\n under the compiler, there is a ZILCO feature;\n under OPS5, there is an OPS5 feature;\n under MACSYMA, there is a MACSYMA feature.\n\nExamples:\n\n (FEATUREP 'ZIL)          ==> T\n (FEATUREP 'MACLISP)      ==> NIL\n\n (FEATUREP 'FOO)          ==> NIL\n (PROGN\n  (SET-FEATURE 'FOO)\n  (FEATUREP 'FOO)\n )                         ==> T\n\n (PROGN\n  (SET-NOFEATURE 'FOO)\n  (FEATUREP 'FOO)\n )                         ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FEXPAND": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86&\\x9f\\x00\\x87%/\\t\\x00\\x006\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-09-26T00:00:00", "modifydate": "1987-09-09T09:00:00", "lines": 54, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FEXPAND\n\nSyntax:   (FEXPAND arg1)\n\n arg1 (required, evaluated) - an atom or proper list.\n\nReturns:\n\n A form which is equivalent to the form specified by arg1, but\n completely macroexpanded - i.e. all macros have been expanded\n throughout the code until no macros are left.\n\nProcessing:\n\n A codewalk is done through the form, expanding all macros\n encountered until none are left.\n\n FEXPAND uses MACROEXPAND to expand forms that it knows occur in\n \"evaluable\" positions in the form.  To do this, it makes certain\n assumptions about the function calls in the form.  It knows about\n every special form and its syntax, and assumes that any function\n call that is not already defined as a macro, an FEXPR, or a CMACRO\n (a macro definition known to the compiler) is a function that\n evaluates its arguments.  In addition, function definitions inside\n LAMBDA lists and DEFUN's are expanded (note that '(LAMBDA ...),\n being a quoted list, will not be expanded, but #'(LAMBDA ...) will).\n\nErrors signaled:\n\n Errors detected by macroexpansion.\n\nNotes:\n\n Unpredictable results will occur if any form or subform is not an\n atom or a proper list.\n\nExamples:\n\n (DEFMACRO FOO (X) `(BAR ,X))          ==> FOO\n\n (MACROEXPAND '(FOO (FOO X)))          ==> (BAR (FOO X))\n (FEXPAND '(FOO (FOO X)))              ==> (BAR (BAR X))\n\n (MACROEXPAND '(SETQ A (FOO 1)))       ==> (SETQ A (FOO 1))\n (FEXPAND '(SETQ A (FOO 1)))           ==> (SETQ A (BAR 1))\n\n (DEFMACRO M1 (X) `(M2 ,X))         ==> M1\n (DEFMACRO M2 (X) `(M3 ,X))         ==> M2\n\n (MACROEXPAND-1 '(M1 (M1 A)))           ==> (M2 (M1 A))\n (MACROEXPAND   '(M1 (M1 A)))           ==> (M3 (M1 A))\n (FEXPAND       '(M1 (M1 A)))           ==> (M3 (M3 A))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIFTH": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x175\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:35:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: FIFTH\n\nSyntax:   (FIFTH list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The fifth element of list1, or NIL if list1 has less than 5 elements.\n\nProcessing:\n\n (FIFTH x) is the same as (CAR (CADDDR X)).\n\nErrors signaled:\n\n See CAR, CDR, etc.\n\nNotes:\n\n See CAR, CDR, etc.\n\nExamples:\n\n (FIFTH NIL)                 ==> NIL\n (FIFTH '(A))                ==> NIL\n (FIFTH '(A B C D E))        ==> E\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIRST": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x171\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:31:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: FIRST\n\nSyntax:   (FIRST list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The first element of list1, or NIL if list1 is null.\n\nProcessing:\n\n This is the same as CAR.\n\nErrors signaled:\n\n See CAR.\n\nNotes:\n\n See CAR.\n\nExamples:\n\n (FIRST NIL)                ==> NIL\n (FIRST '(A))               ==> A\n (FIRST '(A B C D))         ==> A\n (FIRST '((A1 A2) (B1 B2))) ==> (A1 A2)\n (FIRST '(A . B))           ==> A\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIRSTN": {"ttr": 3601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x86\\x19\\x1f\\x00\\x87%\\x1f\\x07\\x18\\x00'\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-07-10T00:00:00", "modifydate": "1987-09-08T07:18:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FIRSTN\n\nSyntax:   (FIRSTN count1 list2)\n\n count1 (required, evaluated) - a fixnum.\n list2 (required, evaluated) - a proper list.\n\nReturns:\n\n A list of the first count1 elements of list list2.\n\nProcessing:\n\n If count1 is zero, NIL is returned.  Otherwise the elements (CAR's)    by\n of list2 are consed up to form a new list until count1 is exhausted.\n\n The length of the new list is the minimum of count1 and the length\n of list2.\n\nErrors signaled:\n\n First argument not a fixnum, or is negative.\n Second argument not a proper list.\n\nNotes:\n\n (FIRST1 n l) for n less than zero may be defined some day as returning\n the last n elements of l, but you can use NTHCDR for that.\n\nExamples:\n\n (FIRSTN 0 '(A B C))      ==> NIL\n (FIRSTN 1 '(A B C))      ==> (A)\n (FIRSTN 2 '(A B C))      ==> (A B)\n (FIRSTN 3 '(A B C))      ==> (A B C)\n (FIRSTN 4 '(A B C))      ==> (A B C)\n (FIRSTN 5 '(A B C))      ==> (A B C)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIX": {"ttr": 3603, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87(\\x7f\\x08\\x18\\x00?\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-10-14T08:18:00", "lines": 63, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FIX\n\nSyntax:   (FIX arg1)\n\n arg1 (required, evaluated) - a number.\n\nReturns:\n\n The argument converted to an integer.\n\nProcessing:\n\n If the argument is float, the nearest integer less than or equal to\n the argument is returned.\n\n If the argument is integer, itself is returned.\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\n Compare ROUND, which rounds its argument to the nearest integer;\n CEILING, which returns the nearest integer greater than or equal to its\n argument; and TRUNCATE, which returns the integer part of the flonum.\n FIX is identical to FLOOR in ZIL 1.3.\n\n Note that flonums whose exponent is large (in either direction) may\n result in integers whose value does not accurately represent the\n integer part of the flonum.\n\nExamples:\n\n (FIX 1)        ==> 1\n (FIX 1.5)      ==> 1\n (FIX 1.5F0)    ==> 1\n (FIX 1.9)      ==> 1\n (FIX 1.9F0)    ==> 1\n (FIX 1.2)      ==> 1\n (FIX 1.2F0)    ==> 1\n (FIX -1)       ==> -1\n (FIX -1.5)     ==> -2\n (FIX -1.9)     ==> -2\n (FIX -1.2)     ==> -2\n (FIX 7E-4)     ==> 0\n (FIX -123.45)  ==> -124\n (FIX -123.45F0)==> -124\n (FIX 2147483647.0)         ==> 21\n (FIX 2147483647.5)         ==> 21\n (FIX 2147483648.0)         ==> 21\n (FIX 2147483648.5)         ==> 21\n (FIX 2147483649.0)         ==> 21\n (FIX 2147483649.5)         ==> 21\n (FIX -2147483647.0)        ==> -21\n (FIX -2147483647.5)        ==> -21\n (FIX -2147483648.0)        ==> -21\n (FIX -2147483648.5)        ==> -21\n (FIX -2147483649.0)        ==> -21\n (FIX -2147483649.5)        ==> -21\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIXNUMP": {"ttr": 3605, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x05\\x1f\\x00\\x87$\\x9f\\x00\\x10\\x00\"\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-20T00:00:00", "modifydate": "1987-09-06T00:10:00", "lines": 34, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FIXNUMP\n\nSyntax:   (FIXNUMP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a fixnum, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n A fixnum is an integer in the range -2147483648 thru 2147483647.\n Integers outside of this range are bignums, of which BIGP is true.\n The predicate INTEGERP may be used to test if an object is an\n integer (fixnum or bignum).\n\nExamples:\n\n (FIXNUMP 1)            ==> T\n (FIXNUMP 1.0)          ==> NIL\n (FIXNUMP 1.0F0)        ==> NIL\n (FIXNUMP '(1))         ==> NIL\n (FIXNUMP 'ONE)         ==> NIL\n (FIXNUMP 123456789876) ==> NIL\n (FIXNUMP (** 2 31))    ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIXP": {"ttr": 3607, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87$\\x9f\\x00\\x11\\x00%\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-06T00:11:00", "lines": 37, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FIXP\n\nSyntax:   (FIXP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is an integer (fixnum or bignum), otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n FIXP is identical to INTEGERP; in fact, INTEGERP is the preferred\n predicate, since its meaning is unambiguous with respect to bignums.\n\n A fixnum is an integer in the range -2147483648 thru 2147483647.\n Integers outside of this range are bignums, of which BIGP is true.\n The predicate FIXNUMP may be used to test if an object is an\n integer (fixnum or bignum).\n\nExamples:\n\n (FIXP 1)               ==> T\n (FIXP 1.0)             ==> NIL\n (FIXP 1.0F0)           ==> NIL\n (FIXP '(1))            ==> NIL\n (FIXP 'ONE)            ==> NIL\n (FIXP 123456789876)    ==> T\n (FIXP (** 2 31))       ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLATC": {"ttr": 3609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87$\\x9f\\x00!\\x00%\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-06T00:21:00", "lines": 37, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FLATC\n\nSyntax:   (FLATC arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n An integer containing the number of characters required to print\n out the represention of arg1 via PRINC.\n\nProcessing:\n\n The number of character positions taken up by the printed format\n of the object is returned as the value.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare FLATSIZE, which tells how many characters it takes to print\n something via PRIN1.\n\nExamples:\n\n (FLATC NIL)                 ==> 3\n (FLATC 'FOOBAR)             ==> 6\n (FLATC '(A))                ==> 3\n (FLATC '(A B C))            ==> 7\n (FLATC '(FOO . BAR))        ==> 11\n (FLATC '|HI THERE|)         ==> 8\n (FLATC 00012)               ==> 2    ;  length of fixnum 12\n (FLATC \"00012\")             ==> 5    ;  length of string \"00012\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLATSIZE": {"ttr": 3611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87$\\x9f\\x00!\\x00%\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-06T00:21:00", "lines": 37, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FLATSIZE\n\nSyntax:   (FLATSIZE arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n An integer containing the number of characters required to print\n out the represention of arg1 via PRIN1.\n\nProcessing:\n\n The number of character positions taken up by the printed format\n of the object is returned as the value.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare FLATC, which tells how many characters it takes to print\n something via PRINC.\n\nExamples:\n\n (FLATSIZE NIL)              ==> 3\n (FLATSIZE 'FOOBAR)          ==> 6\n (FLATSIZE '(A))             ==> 3\n (FLATSIZE '(A B C))         ==> 7\n (FLATSIZE '(FOO . BAR))     ==> 11\n (FLATSIZE '|HI THERE|)      ==> 10\n (FLATSIZE 00012)            ==> 2    ;  fixnum 12\n (FLATSIZE \"00012\")          ==> 7    ;  string \"00012\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLAVORS": {"ttr": 3613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87$\\x7f\\x00\\x87$\\x7f\\x17\\t\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-04T00:00:00", "modifydate": "1987-09-04T17:09:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FLAVORS\n\nThis function loads the ZIL FLAVORS system.\n\nFor more information, type (HELP $FLAVORS), or see the $FLAVORS\nmember of this documentation.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLOAT": {"ttr": 3615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87$\\x9f\\x00'\\x000\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-06T00:27:00", "lines": 48, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FLOAT\n\nSyntax:   (FLOAT arg1 &optional arg2)\n\n arg1 (required, evaluated) - a number.\n arg2 (optional, evaluated) - a flonum.\n\nReturns:\n\n arg1 converted to a flonum.\n\nProcessing:\n\n If arg2 is omitted or NIL, the following takes place:\n\n  If arg1 is a single-float or double-float, itself is returned.\n\n  If arg1 is an integer, the value is converted to double-float\n  and returned as a flonum.\n\n If arg2 is specified, the following takes place:\n\n  If arg1 is a flonum of the same type (single or double) as arg2,\n  itself is returned.\n\n  Otherwise, arg1 is converted to a flonum of the same type as arg2\n  (single-float or double-float) and that value is returned as a\n  flonum.\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\nExamples:\n\n (FLOAT 3)          ==> 3.0\n (FLOAT 3.5)        ==> 3.5\n (FLOAT 3.5F0)      ==> 3.5F0\n (FLOAT 3 0.0)      ==> 3.0\n (FLOAT 3 0.0F0)    ==> 3.0F0\n (FLOAT 3.0 0.0)    ==> 3.0\n (FLOAT 3.0 0.0F0)  ==> 3.0F0\n (FLOAT 3.0F0 0.0)  ==> 3.0\n (FLOAT 3.0F0 0.0F0)==> 3.0F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLOATP": {"ttr": 3617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87$\\x9f\\x000\\x00!\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-06T00:30:00", "lines": 33, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FLOATP\n\nSyntax:   (FLOATP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a flonum (single-float or double-float), otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare SFLOATP and DFLOATP, the predicates that test specifically\n for single-float and double-float respectively.  (FLOATP X) is\n equivalent to (OR (SFLOATP X) (DFLOATP X)).\n\nExamples:\n\n (FLOATP 1.0)  ==> T\n (FLOATP 1)    ==> NIL\n (FLOATP 1E1)  ==> T\n (FLOATP 1.0D0) ==> T\n (FLOATP 1.0F0) ==> T\n (FLOATP '(1)) ==> NIL\n (FLOATP 'ONE) ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLOOR": {"ttr": 3619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87&/\\x00\\x89\\x05O\\x17G\\x00[\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-09-19T00:00:00", "modifydate": "1989-02-23T17:47:00", "lines": 91, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FLOOR\n\nSyntax:   (FLOOR arg1 &optional arg2)\n\n arg1 (required, evaluated) - a number.\n arg2 (optional, evaluated) - a number.\n\nReturns:\n\n Two values:\n\n  (1) arg1, or arg1 divided by arg2, converted to an integer.\n  (2) If arg1 only is specified, the difference of arg1 and the\n      first value.\n      If arg1 and arg2 are specified, the remainder, i.e. the difference\n      of arg1 and (arg2 times the first value).\n\nProcessing:\n\n If arg2 is specified, arg1 is divided by arg2 such that a floating\n point result is obtained.  Otherwise, the argument is set to arg1.\n\n If the argument is float, the nearest integer less than or equal to\n the argument is returned.\n\n If the argument is integer, itself is returned.\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\n Compare ROUND, which rounds its argument to the nearest integer;\n CEILING, which returns the nearest integer greater than or equal to its\n argument; and TRUNCATE, which returns the integer part of the flonum.\n FIX is identical to FLOOR in ZIL 1.3.\n\n Note that flonums whose exponent is large (in either direction) may\n result in integers whose value does not accurately represent the\n integer part of the flonum.\n\nExamples:\n\n ; Note: Only the first value is shown in these examples.\n\n (FLOOR 1)                  ==> 1\n (FLOOR 1.5)                ==> 1\n (FLOOR 1.5F0)              ==> 1\n (FLOOR 1.9)                ==> 1\n (FLOOR 1.9F0)              ==> 1\n (FLOOR 1.2)                ==> 1\n (FLOOR 1.2F0)              ==> 1\n (FLOOR -1)                 ==> -1\n (FLOOR -1.5)               ==> -2\n (FLOOR -1.9)               ==> -2\n (FLOOR -1.2)               ==> -2\n (FLOOR 0)                  ==> 0\n (FLOOR 0.5)                ==> 0\n (FLOOR 0.5F0)              ==> 0\n (FLOOR 0.9)                ==> 0\n (FLOOR 0.9F0)              ==> 0\n (FLOOR 0.2)                ==> 0\n (FLOOR 0.2F0)              ==> 0\n (FLOOR -0)                 ==> 0\n (FLOOR -0.5)               ==> -1\n (FLOOR -0.9)               ==> -1\n (FLOOR -0.2)               ==> -1\n (FLOOR 7E-4)               ==> 0\n (FLOOR -123.45)            ==> -124\n (FLOOR -123.45F0)          ==> -124\n (FLOOR 2147483647.0)       ==> 21\n (FLOOR 2147483647.5)       ==> 21\n (FLOOR 2147483648.0)       ==> 21\n (FLOOR 2147483648.5)       ==> 21\n (FLOOR 2147483649.0)       ==> 21\n (FLOOR 2147483649.5)       ==> 21\n (FLOOR -2147483647.0)      ==> -21\n (FLOOR -2147483647.5)      ==> -21\n (FLOOR -2147483648.0)      ==> -21\n (FLOOR -2147483648.5)      ==> -21\n (FLOOR -2147483649.0)      ==> -21\n (FLOOR -2147483649.5)      ==> -21\n\n (FLOOR 10 3)               ==> 3\n (FLOOR -10 3)              ==> -4\n (FLOOR 9 3)                ==> 3\n (FLOOR -9 3)               ==> -3\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FMAKUNBO": {"ttr": 3621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\t?\\x00\\x87$\\x9f\\x002\\x000\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-04-03T00:00:00", "modifydate": "1987-09-06T00:32:00", "lines": 48, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FMAKUNBOUND\n\nSyntax:   (FMAKUNBOUND arg1)\n    or:   (FMAKUNBO    arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n arg1, after removing the current function or macro definition\n therefrom.\n\nProcessing:\n\n Any MACRO, EXPR, FEXPR or SUBR definition currently associated with\n arg1 is removed.\n\n Note that if the function had or can have a SUBR definition, the\n next reference to that name as a function may cause it to become\n defined as a function again.\n\n Note that special forms cannot be FMAKUNBOUND'ed.\n\nErrors signaled:\n\n Arg not a symbol.\n Arg names a special form (it is illegal to \"undefine\" these).\n\nNotes:\n\n FMAKUNBOUND does not remove AUTOLOAD properties.  (Maybe it should.)\n\n Remember that the argument to FMAKUNBOUND is evaluated.\n\nExamples:\n\n (DEFUN FOO! (X) NIL)   ==> FOO!\n (FBOUNDP 'FOO!)        ==> T\n (FMAKUNBOUND 'FOO!)    ==> FOO!\n (FBOUNDP 'FOO!)        ==> NIL\n\n (FMAKUNBOUND 'COND)    ==> (\"***ERROR***\") ; Cannot undefine ...\n (FBOUNDP 'COND)        ==> T    ; Special forms cannot be killed.\n\n (FMAKUNBOUND 'CAR)     ==> CAR\n (FBOUNDP 'CAR)         ==> T    ; SUBR definition just gets reloaded.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FORMAT": {"ttr": 3623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x86\\x11?\\x00\\x88\\x05\\x7f\\t!\\x01\\x1b\\x00X\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1986-04-23T00:00:00", "modifydate": "1988-02-26T09:21:00", "lines": 283, "newlines": 88, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FORMAT\n\nSyntax:   (FORMAT dest1 string2 &rest args)\n\n dest1   (required, evaluated) - T, NIL, a file name (symbol), or a\n                                 string.\n string2 (required, evaluated) - a string.\n arg     (optional, evaluated) - any LISP object.\n\nReturns:\n\n If dest1 is T, NIL after printing a formatted line to the standard\n output file.  If dest1 is NIL, a string containing the formatted line.\n If dest1 is a string, a string containing the formatted line\n string-appended to dest1.  Otherwise, NIL after printing the formatted\n line to the file dest1.\n\nProcessing:\n\n FORMAT takes a string with \"format directives\" indicated by embedded\n tildes \"~\", formats the args into the string according to the\n specifications of the directives, and either prints the resultant\n string to the standard output file (if dest1 is T), returns the\n formatted data as a string (if dest1 is NIL), string-appends the data\n to string dest1 (nondestructively, of course), or prints the string to\n the output file specified by dest1.\n\n In other words, use (FORMAT T \"format-string\" format-args ...) to\n actually print something;\n use (FORMAT NIL \"format-string\" format-args ...) to return a string\n that has been formatted.\n\n For a complete description of FORMAT, refer to Guy Steele's\n \"Common LISP: The Language\", pp. 385 & ff.\n\n The ZIL implementation of FORMAT is 100% complete and correct with\n respect to the Common LISP specification.\n\n All modifier syntax discussed in the Common LISP guide (@, :, padchar,\n V, #, etc.) is available, and is supported for all the format\n directives above.  Note that in cases where a character may be\n specified as a prefix modifier (by a preceding quote), a number is not\n permitted, and vice versa.\n\n Here is a summary of the FORMAT directives:\n\n ~<newline> - causes following newline and/or whitespace to be ignored,\n              depending on modifiers.\n ~<carriage return>\n            - same as <newline>.  End of line is also equivalent.\n ~<left bracket>...~<right bracket>\n            - selects one of a series of elements to be formatted.\n              Note that cent sign may be used in place of left bracket,\n              and broken vertical bar may be used in place of right\n              bracket, on IBM 3270 keyboards.\n ~{...~}    - iterates over the elements of a list.\n ~<...~>    - does text justification.\n ~(...~)    - does case conversion.\n ~|         - generates a formfeed (hex 2c).  Useless on MVS.\n ~&         - conditionally generates a newline.\n ~$         - formats in dollar-sign-suitable floating-point.\n ~*         - ignores or backs up in format arguments.\n ~;         - used to separate elements in a ~< or ~<left bracket> group\n ~\u00ac         - escape, used to exit a formatting sequence.\n ~%         - generates a newline.\n ~?         - indirect format string processing.\n ~~         - generates a tilde.\n ~A         - formats like PRINC prints.\n ~B         - formats in binary.\n ~C         - formats as a character where possible.\n ~D         - formats in decimal.\n ~E         - formats in exponential floating-point.\n ~F         - formats in fixed-format floating-point.\n ~G         - formats in general-format floating-point.\n ~O         - formats in octal.\n ~P         - formats plural endings.\n ~R         - formats in the specified radix, or English or Roman.\n ~S         - formats like PRIN1 prints.\n ~T         - relative or absolute tabulation.\n ~X         - formats in hexadecimal.  Note that X does NOT generate\n              spaces like it does in Maclisp.\n\nThe following extensions are unique to the ZIL implementation:\n\n ~Z         - generates debugging output during the formatting process.\n\n  As stated above, tilde + cent sign is functionally equivalent to tilde\n  + left bracket, and tilde + broken vertical bar (hex 6A) is\n  functionally equivalent to tilde + right bracket.  Do not confuse this\n  with the unbroken vertical bar (hex 4F), which is the \"formfeed\"\n  directive.\n\nThe following differences may be observed in the ZIL implementation:\n\n  The exponent character used by the ~E directive defaults to D for\n  double-precision floats and F for single-precision floats, not E\n  as in many Common LISPs.\n\n  Where the current column needs to be computed (e.g. for a tabulation\n  request), the current output column is used when formatting to a file,\n  and the number of characters output since the last newline (plus 1) is\n  used when formatting to a string.\n\n  The line length, used by the ~:; directive inside a ~<...~> group,\n  always defaults to 72, regardless of the output destination.\n\nErrors signaled:\n\n Syntax errors - invalid FORMAT directives, etc.\n\n Note - not all errors are signalled.  Undefined modifiers, for\n        example, may cause errors or may simply be ignored.\n\nNotes:\n\n FORMAT is also discussed in the following manuals:\n\n  The Revised Maclisp Manual (K. Pitman)\n  NIL Reference Manual (Burke, Carrette, Eliot)\n\n However, ZIL follows the Common LISP specifications.\n\nExamples:\n\n (FORMAT NIL \"foo ~A bar\" 'frob) ==> \"foo FROB bar\"\n\n (FORMAT NIL \"X'~X'\" 4095)        ==> \"X'FFF'\"\n\n; The following examples are taken from CLtL, pp. 385&ff.\n\n(progn\n (declare (special x y n))\n (setq x 5)\n (setq y \"elephant\")\n (setq n 3)\n t\n) ==> T\n\n(format nil \"foo\")                     ==> \"foo\"\n(format nil \"The answer is ~D.\" x)     ==> \"The answer is 5.\"\n(format nil \"The answer is ~3D.\" x)    ==> \"The answer is   5.\"\n(format nil \"The answer is ~3,'0D.\" x) ==> \"The answer is 005.\"\n(format nil \"The answer is ~:D.\" (expt 47 x))\n                                       ==> \"The answer is 229,345,007.\"\n(format nil \"Look at the ~A!\" y)       ==> \"Look at the elephant!\"\n\n(format nil \"Type ~:C to ~A.\"  #\\D \"delete all your files\")\n        ==> \"Type D to delete all your files.\"\n\n(format nil \"~D item~:P found.\" n)\n        ==> \"3 items found.\"\n\n(format nil \"~R dog~:\u00a2s are~; is~\u00a6 here.\" n (= n 1))\n        ==> \"three dogs are here.\"\n\n(format nil \"~R dog~:*~\u00a2s are~; is~:;s are~\u00a6 here.\" n)\n        ==> \"three dogs are here.\"\n\n(format nil \"Here ~\u00a2are~;is~:;are~\u00a6 ~:*~R pupp~:@p.\" n)\n        ==> \"Here are three puppies.\"\n\n(format nil \"~D tr~:@p/~D win~:P\" 7 1) ==> \"7 tries/1 win\"\n(format nil \"~D tr~:@p/~D win~:P\" 1 0) ==> \"1 try/0 wins\"\n(format nil \"~D tr~:@p/~D win~:P\" 1 3) ==> \"1 try/3 wins\"\n\n(defun foo (x)\n (format nil \"~6,2F|~6,2,1,'*F|~6,2,,'?F|~6F|~,2F|~F\"\n         x x x x x x))   ==> FOO\n\n(foo 3.14159)     ==>  \"  3.14| 31.42|  3.14|3.1416|3.14|3.14159\"\n(foo -3.14159)    ==>  \" -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159\"\n(foo 100.0)       ==>  \"100.00|******|100.00| 100.0|100.00|100.0\"\n(foo 1234.0)      ==> \"1234.00|******|??????|1234.0|1234.00|1234.0\"\n(foo 0.006)       ==>  \"  0.01|  0.06|  0.01| 0.006|0.01|0.006\"\n\n(defun foo (x)\n (format nil\n         \"~9,2,1,,'*E|~10,3,2,2,'?,,'$E|~9,3,2,-2,'%@e|~9,2E\"\n         x x x x))       ==>  FOO\n\n(foo 3.14159)    ==>  \"  3.14D+0| 31.42$-01|+.003D+03|  3.14D+0\"\n(foo -3.14159)   ==>  \" -3.14D+0|-31.42$-01|-.003D+03| -3.14D+0\"\n(foo 1100.0)     ==>  \"  1.10D+3| 11.00$+02|+.001D+06|  1.10D+3\"\n(foo 1.1E13)     ==>  \"*********| 11.00$+12|+.001D+16| 1.10D+13\"\n\n(defun foo (x)\n (format nil\n         \"~9,2,1,,'*G|~9,3,2,3,'?,,'$G|~9,3,2,0,'%G|~9,2G\"\n         x x x x))       ==>  FOO\n\n(foo 0.0314159)  ==>  \"  3.14D-2|314.2$-04|0.314D-01|  3.14D-2\"\n(foo 0.314159)   ==>  \"  0.31   |0.314    |0.314    | 0.31    \"\n(foo 3.14159)    ==>  \"   3.1   | 3.14    | 3.14    |  3.1    \"\n(foo 31.4159)    ==>  \"   31.   | 31.4    | 31.4    |  31.    \"\n(foo 314.159)    ==>  \"  3.14D+2| 314.    | 314.    |  3.14D+2\"\n(foo 3141.59)    ==>  \"  3.14D+3|314.2$+01|0.314D+04|  3.14D+3\"\n(foo 3.14E12)    ==>  \"*********|314.0$+10|0.314D+13| 3.14D+12\"\n\n(format nil \"The winners are:~{ ~S~}.\" '(fred harry jill))\n\n  ==> \"The winners are: FRED HARRY JILL.\"\n\n(format nil \"Pairs:~{ <~S,~S>~}.\" '(a 1 b 2 c 3))\n\n  ==> \"Pairs: <A,1> <B,2> <C,3>.\"\n\n(format nil \"Pairs:~:{ <~S,~S>~}.\" '((a 1) (b 2) (c 3)))\n\n  ==> \"Pairs: <A,1> <B,2> <C,3>.\"\n\n(format nil \"Pairs:~:@{ <~S,~S>~}.\" '(a 1) '(b 2) '(c 3))\n\n  ==> \"Pairs: <A,1> <B,2> <C,3>.\"\n\n(let ((*print-level* nil) (*print-length* 5))\n     (declare (special *print-level* *print-length*))\n     (format nil\n             \"~@\u00a2 print level = ~D~\u00a6~@\u00a2 print length = ~D~\u00a6\"\n             *print-level* *print-length*))\n\n  ==> \" print length = 5\"\n\n (progn\n  (declare (special foo))\n  (setq foo\n        \"Items:~#\u00a2 none~; ~S~; ~S and ~S~:;~@{~#\u00a2~; and~\u00a6 ~S~\u00ac,~}~\u00a6.\")\n  t) ==> T\n\n (format nil foo)                 ==> \"Items: none.\"\n (format nil foo 'foo)            ==> \"Items: FOO.\"\n (format nil foo 'foo 'bar)       ==> \"Items: FOO and BAR.\"\n (format nil foo 'foo 'bar 'baz)  ==> \"Items: FOO, BAR, and BAZ.\"\n (format nil foo 'foo 'bar 'baz 'quux)\n                                  ==> \"Items: FOO, BAR, BAZ, and QUUX.\"\n\n (format nil \"~10<foo~;bar~>\")    ==> \"foo    bar\"\n (format nil \"~10:<foo~;bar~>\")   ==> \"  foo  bar\"\n (format nil \"~10:@<foo~;bar~>\")  ==> \"  foo bar \"\n (format nil \"~10<foobar~>\")      ==> \"    foobar\"\n (format nil \"~10:<foobar~>\")     ==> \"    foobar\"\n (format nil \"~10@<foobar~>\")     ==> \"foobar    \"\n (format nil \"~10:@<foobar~>\")    ==> \"  foobar  \"\n\n (format nil \"~? ~D\" \"<~A ~D>\" '(\"Foo\" 5) 7)     ==>  \"<Foo 5> 7\"\n (format nil \"~? ~D\" \"<~A ~D>\" '(\"Foo\" 5 14) 7)  ==>  \"<Foo 5> 7\"\n\n (format nil \"~@? ~D\" \"<~A ~D>\" \"Foo\" 5 7)       ==>  \"<Foo 5> 7\"\n (format nil \"~@? ~D\" \"<~A ~D>\" \"Foo\" 5 14 7)    ==>  \"<Foo 5> 14\"\n\n (format nil \"~@R ~(~@R~)\" 14 14)                ==>  \"XIV xiv\"\n\n (defun f (n) (format nil \"~@(~R~) error~:P detected.\" n))  ==> F\n\n (f 0)    ==>  \"Zero errors detected.\"\n (f 1)    ==>  \"One error detected.\"\n (f 23)   ==>  \"Twenty-three errors detected.\"\n\n (progn\n  (declare (special donestr))\n  (setq donestr \"Done.~\u00ac ~D warning~:P.~\u00ac ~D error~:P.\")\n  t) ==> T\n\n (format nil donestr)             ==> \"Done.\"\n (format nil donestr 3)           ==> \"Done. 3 warnings.\"\n (format nil donestr 3 5)         ==> \"Done. 3 warnings. 5 errors.\"\n\n (ok (setq tellstr \"~@(~@\u00a2~R~\u00a6~\u00ac ~A.~)\")) ==> t\n ;\n ; CLtL is wrong when it says this returns \"Twenty-three.\"\n ;\n (format nil tellstr 23)           ==> \"Twenty-three\"\n ;\n ; CLtL is wrong when it says this returns \"Losers.\"\n ;\n (format nil tellstr nil \"losers\") ==> \" Losers.\"\n (format nil tellstr 23 \"losers\")  ==> \"Twenty-three losers.\"\n\n (format nil \"~15<~S~;~\u00ac~S~;~\u00ac~S~>\" 'foo)       ==> \"            FOO\"\n (format nil \"~15<~S~;~\u00ac~S~;~\u00ac~S~>\" 'foo 'bar)  ==> \"FOO         BAR\"\n (format nil \"~15<~S~;~\u00ac~S~;~\u00ac~S~>\" 'foo 'bar 'baz)\n                                                ==> \"FOO   BAR   BAZ\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FOURTH": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x173\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:33:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: FOURTH\n\nSyntax:   (FOURTH list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The fourth element of list1, or NIL if list1 has less than 4 elements.\n\nProcessing:\n\n This is the same as CADDDR.\n\nErrors signaled:\n\n See CADDDR.\n\nNotes:\n\n See CADDDR.\n\nExamples:\n\n (FOURTH NIL)                ==> NIL\n (FOURTH '(A))               ==> NIL\n (FOURTH '(A B C D))         ==> D\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FSZIL": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x00&?\\x01\\x00&?\\t\\x02\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-19T00:00:00", "modifydate": "2000-09-19T09:02:37", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FSZIL\n\nSyntax:   (FSZIL)\n\nReturns:\n\n T, after invoking an ISPF dialog implementation of the ZIL Lisp\n interpreter in scrollable full-screen mode, until the END key is\n pressed by the terminal user.\n\nProcessing:\n\n FSZIL uses the ZFSEXEC service to present an ISPF dialog loop which\n consists of:\n\n  displaying the FSZIL panel\n\n  accepting S-expressions from the user, entered on the panel\n\n  terminating if the END command is typed (or the END key is pressed)\n\n  processing any dialog commands entered on the ISPF command line\n\n  evaluating the input S-expression, resulting in zero or more values\n  which, along with any other generated standard output, are captured\n  and directed to the panel display.\n\nErrors signaled:\n\n ISPF environment not active.\n\nNotes:\n\n ZIL-MVS only.  ISPF version 2 required.  If PDF is not installed\n along with ISPF, attempts to display error messages may fail.\n\n Evaluation of expressions that attempt to read from standard input\n will be dramatically unsuccessful.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FUNARGP": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87$\\x9f\\x00A\\x00(\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-06T00:41:00", "lines": 40, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FUNARGP\n\nSyntax:   (FUNARGP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is an interpreted lexical closure (funarg), otherwise NIL.\n\nProcessing:\n\n An interpreted lexical closure is the result of evaluating the\n special form (FUNCTION ...); this creates an object consisting of a\n pointer to an object that can be FUNCALL'ed or APPLY'ed and a pointer\n to the environment current at the time the closure was created.\n\n Funargs may be passed to APPLY or specified as the CAR of a list\n passed to EVAL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The FUNCTION special form in the compiled environment does not create a\n FUNARGP form; rather, it creates a compiled closure.  The predicate\n CLOSUREP returns T for such an object.\n\n See also MKFUNARG, the low-level function that builds funargs.\n\nExamples:\n\n (FUNARGP 'CAR)          ==> NIL\n (FUNARGP (FUNCTION CAR)) ==> T ; in the interpretive environment\n;(FUNARGP (FUNCTION CAR)) ==> NIL ; compiled\n (FUNARGP (ZILLOAD 'CAR)) ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FUNCALL": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87$\\x9f\\x00A\\x00\\x1d\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-06T00:41:00", "lines": 29, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FUNCALL\n\nSyntax:   (FUNCALL fun1 &rest args)\n\n fun1   (required, evaluated) - a function that can be APPLY'ed.\n argn   (optional, evaluated) - any LISP object.\n\nReturns:\n\n The result of applying the function specified by fun1 to the arguments\n specified by args, in the default variable binding environment.\n\nProcessing:\n\n In the interpretive environment, FUNCALL is an interface to APPLY\n (q.v.).  See APPLY for what are valid functions.\n\nErrors signaled:\n\n Many (see APPLY).\n\nNotes:\n\nExamples:\n\n (FUNCALL 'CAR '(A B C))              ==> A\n (FUNCALL #'CONS 'FOO 'BAR)           ==> (FOO . BAR)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FUNCTION": {"ttr": 3851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87$\\x9f\\x00E\\x007\\x00A\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-06T00:45:00", "lines": 55, "newlines": 65, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: FUNCTION\n\nSyntax:   (FUNCTION arg1)\n\n arg1 (required, not evaluated) - a symbol or LAMBDA-expression.\n\nReturns:\n\n Under the compiler:\n\n A compiled-code closure object, built from arg1 (the function) and the\n current evaluation environment.  CLOSUREP is true of this object.\n\n Under the interpreter:\n\n An interpreted lexical closure object (known in ZIL as a funarg), built\n from arg1 (the function) and the current evaluation environment.\n FUNARGP is true of this object.\n\nProcessing:\n\n The current evaluation environment is obtained and used, together\n with arg1, to build a compiled-code closure object (in compiled code),\n or a funarg object (under the interpreter).  This expression defines a\n closure when it occurs in a position where a function name or\n LAMBDA-expression is expected, including:\n\n  The CAR of a form to be evaluated by EVAL.\n  The first argument of the FUNCALL or APPLY function.\n  The first argument of a mapping function (MAPCAR, MAPC, etc.).\n\n A closure is an instance of a function invocation with its own\n \"local\" binding environment, independent of the environment under\n which the function invocation occurs.  This implements non-local\n \"lexical scoping\".\n\nErrors signaled:\n\n Invalid function name (not a symbol or a valid LAMBDA or LABEL expr).\n Function name is a macro or a special form.\n\n Note that these errors may not be signalled until the function is\n actually used, depending on the implementation.\n\nNotes:\n\n The reader macro call #'x expands into (FUNCTION x), e.g.:\n\n  #'FOO                   --> (FUNCTION FOO)\n  #'(LAMBDA (X) (FOO X))  --> (FUNCTION (LAMBDA (X) (FOO X)))\n\n See $MAP for information pertaining to the use of FUNCTION and QUOTE\n in the mapping functions.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FUNENV": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x10\\x0f\\x00\\x87$\\x9f\\x00F\\x00\\x18\\x00\\x15\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-10T00:00:00", "modifydate": "1987-09-06T00:46:00", "lines": 24, "newlines": 21, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FUNENV\n\nSyntax:   (FUNENV funarg1)\n\n funarg1 (required, evaluated) - an interpreted lexical closure (funarg)\n\nReturns:\n\n The environment component of funarg1.\n\nProcessing:\n\nErrors signaled:\n\n Argument not a funarg.\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n This function is used by APPLY, and should be used by nobody else.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FUNFUN": {"ttr": 3855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x10\\x0f\\x00\\x87$\\x9f\\x00G\\x00\\x1d\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-10T00:00:00", "modifydate": "1987-09-06T00:47:00", "lines": 29, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: FUNFUN\n\nSyntax:   (FUNFUN funarg1)\n\n funarg1 (required, evaluated) - an interpreted lexical closure (funarg)\n\nReturns:\n\n The function component of funarg1.\n\nProcessing:\n\nErrors signaled:\n\n Argument not a funarg.\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n This function is used by APPLY, and should be used by nobody else.\n\nExamples:\n\n (FUNFUN (FUNCTION FOO))    ==> FOO\n (FUNFUN #'(LAMBDA (X) X))  ==> (LAMBDA (X) X)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GC": {"ttr": 3857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87$\\x9f\\x00H\\x00\\x1b\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-06T00:48:00", "lines": 27, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GC\n\nSyntax:   (GC)\n\nReturns:\n\n The list (NIL), i.e. a CONS of NIL and NIL, after forcing a\n garbage collection to occur.\n\nProcessing:\n\n The free list pointer is altered so that it points to the end of\n the free list, and a dummy CONS is issued; when CONS detects the end\n of the free list, it causes a garbage collection.  The dummy CONS\n is returned as the value of the function.\n\nErrors signaled:\n\n No CONS cells free after garbage collection.\n\nNotes:\n\nExamples:\n\n (GC)  ==> (NIL) ; after causing a garbage collection to take place\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCD": {"ttr": 3859, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x05_\\x00\\x87$\\x9f\\x00I\\x00O\\x00J\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-24T00:00:00", "modifydate": "1987-09-06T00:49:00", "lines": 79, "newlines": 74, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GCD\n\nSyntax:   (GCD &rest nums)\n\n num (optional, evaluated) - an integer.\n\nReturns:\n\n The greatest common denominator of its args.\n\nProcessing:\n\n The result is always positive.\n\n (GCD) returns 0.  GCD of one argument returns the same argument.\n\nErrors signaled:\n\n Non-integer argument.\n\nNotes:\n\nExamples:\n\n  (GCD)          ==> 0\n  (GCD 1234)     ==> 1234\n  (GCD 100 8)    ==> 4\n  (GCD 100 8 6)  ==> 2\n\n  (GCD  0  0)    ==> 0\n  (GCD  1  0)    ==> 1\n  (GCD  0  1)    ==> 1\n  (GCD -1  0)    ==> 1\n  (GCD  0 -1)    ==> 1\n  (GCD  24  60)  ==> 12\n  (GCD  24 -60)  ==> 12\n  (GCD -24  60)  ==> 12\n  (GCD -24 -60)  ==> 12\n  (GCD 0 0)      ==> 0\n  (GCD 1 1)      ==> 1\n  (GCD -1 0)     ==> 1\n  (GCD 1 0)      ==> 1\n  (GCD 0 1)      ==> 1\n  (GCD 0 -1)     ==> 1\n  (GCD -1 1)     ==> 1\n  (GCD 1 -1)     ==> 1\n  (GCD -1 -1)    ==> 1\n  (GCD 0 2)      ==> 2\n  (GCD 1 2)      ==> 1\n  (GCD 2 1)      ==> 1\n  (GCD 2 4)      ==> 2\n  (GCD 4 2)      ==> 2\n  (GCD -2 4)     ==> 2\n  (GCD 2 -4)     ==> 2\n  (GCD -2 -4)    ==> 2\n\n  (GCD 1000000000 1024)         ==> 512\n  (GCD -1000000000 1024)        ==> 512\n  (GCD 1000000000 -1024)        ==> 512\n  (GCD 2147483647 0)            ==> 21\n  (GCD 0 2147483647)            ==> 21\n  (GCD 0 -2147483648)           ==> 21\n  (GCD -2147483648 0)           ==> 21\n  (GCD -2147483648 -2147483648) ==> 21\n  (GCD  1000000000  2147483647) ==> 1\n  (GCD  1000000000 -2147483647) ==> 1\n  (GCD -1000000000  2147483647) ==> 1\n  (GCD -1000000000 -2147483647) ==> 1\n  (GCD  2147483647  1000000000) ==> 1\n  (GCD  2147483647 -1000000000) ==> 1\n  (GCD -2147483647  1000000000) ==> 1\n  (GCD -2147483647 -1000000000) ==> 1\n  (GCD 75025 46368)             ==> 1\n  (GCD -2147483648  1000000000) ==> 512\n  (GCD -2147483648 -1000000000) ==> 512\n  (GCD  1000000000 -2147483648) ==> 512\n  (GCD -1000000000 -2147483648) ==> 512\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCD2": {"ttr": 3861, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\t\\x06\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T09:06:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GCD2\n\nSyntax:   (GCD2 num1 num2)\n\n num1 (optional, evaluated) - an integer.\n num2 (optional, evaluated) - an integer.\n\nReturns:\n\n The greatest common denominator of num1 and num2.\n\nProcessing:\n\n The result is always positive.\n\nErrors signaled:\n\n Non-integer argument.\n\nNotes:\n\n This is the two-argument version of GCD, used to implement calls to\n GCD in most compiled code.\n\nExamples:\n\n  (GCD2 100 8)    ==> 4\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCMSG": {"ttr": 3863, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x06?\\x00\\x87$\\x9f\\x00S\\x00&\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-06T00:53:00", "lines": 38, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GCMSG\n\nSyntax:   (GCMSG arg1)\n\n arg1 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n If arg1 is omitted, T if garbage collection messages are currently\n enabled, else NIL.  If arg1 is specified, arg1 after setting the\n display of garbage collection messages on or off.\n\nProcessing:\n\n If arg1 is omitted, then if garbage collection messages are currently\n enabled for display, T is returned; if they are not, NIL is returned.\n\n If arg1 is NIL, the flag that controls the display of garbage\n collection messages is set not to display them.\n Otherwise, the flag that controls the display of garbage\n collection messages is set to display them.\n\n I.E., (GCMSG T) enables GC messages; (GCMSG NIL) disables them.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (GCMSG) returns T or NIL, depending on whether garbage collection\n         messages are enabled.\n (GCMSG T) enables garbage collection messages.\n (GCMSG NIL) disables garbage collection messages.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCTIME": {"ttr": 3865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x07\\x1f\\x00\\x87$\\x9f\\x00T\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-03-12T00:00:00", "modifydate": "1987-09-06T00:54:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GCTIME\n\nSyntax:   (GCTIME)\n\nReturns:\n\n An integer containing the number of milliseconds (thousandths of a\n second) of CPU time used so far by garbage collections in the the\n current ZIL session.\n\nProcessing:\n\n The value is initially zero, and incremented by each garbage collection\n by taking the difference between the \"job step elapsed time\" at start\n of GC and \"job step elapsed time\" at end of GC.  The time values are\n similar to those retrieved by the RUNTIME function.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n (GCTIME) is a cumulative value.  To time a particular GC, record the\n value of (GCTIME) before and after, and take the difference.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENSYM": {"ttr": 3867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x07\"\\x00F\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T07:22:00", "lines": 70, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GENSYM\n\nSyntax:   (GENSYM &optional arg1)\n\nReturns:\n\n A unique uninterned symbol (not on the oblist) whose print name\n consists of the \"GENSYM prefix\" concatenated with a number\n incremented sequentially by each invocation.\n\nProcessing:\n\n The GENSYM counter (initially 1) is used to construct a symbol name,\n and a symbol is built from it and the GENSYM prefix (initially \"G\").\n The symbol is not interned, which means that it will not be EQ to any\n other atom.\n\n Following creation of the symbol, the GENSYM counter is incremented.\n\n If the optional argument is specified, it is processed as follows:\n\n If it is an integer, it must be non-negative; the GENSYM counter is\n set to that value and then used when the symbol is created; it\n becomes the basis for all counter incrementing until the counter\n is reset again.\n\n If it is a string, it becomes the new GENSYM prefix, and is used in\n the creation of this and all subsequent GENSYM's until the prefix\n is reset again.\n\n If it is a symbol, the symbol's print name is used as for strings\n as described above.\n\n If the optional argument is omitted, the current prefix and counter\n are used to create the symbol name.\n\nErrors signaled:\n\n Not enough vector/string space to build the object.\n\nNotes:\n\n The GENSYM number is converted to a decimal value of not less than\n 6 digits, including leading zeroes.\n\n Resetting the counter will create atoms that appear to have the same\n print name as previously created GENSYM atoms; however, they will still\n be unique.  Use of such atoms in contexts where the generated names are\n required to be unique on a character basis, however, is not guaranteed.\n\n In the current implementation, the GENSYM counter may not be a bignum.\n In fact, it will overflow when the value exceeds 2147483647.  However,\n unique GENSYMs will still be created, even though their names may not\n be all that wonderful.\n\nExamples:\n\n (GENSYM '7)    ==> G00007\n (GENSYM)       ==> G00008\n (EQ (GENSYM) (GENSYM)) ==> NIL ; Always NIL.\n (GENSYM '100)  ==> G00100\n (GENSYM \"FOO\") ==> FOO00101\n (GENSYM)       ==> FOO00102\n (GENSYM 4)     ==> FOO00004\n (GENSYM 'G)    ==> G00005\n (SETQ A (GENSYM))  ==> G00006\n (EQ A 'G00006)     ==> NIL\n (= A 'G00006)      ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENTEMP": {"ttr": 3869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86&o\\x00\\x87%\\x1f\\x07#\\x003\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-09-23T00:00:00", "modifydate": "1987-09-08T07:23:00", "lines": 51, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GENTEMP\n\nSyntax:   (GENTEMP &optional pfx1 arg2)\n\n pfx1 (optional, evaluated) - a string or symbol.\n arg2 (optional, evaluated) - any LISP object (it is ignored).\n\nReturns:\n\n A unique interned symbol whose print name consists of the \"GENTEMP\n prefix\" pfx1 concatenated with a number incremented sequentially by\n each invocation.\n\nProcessing:\n\n The GENTEMP counter (initially 0) is incremented and used to construct\n a symbol name, together with the GENTEMP prefix, and a symbol is built\n from these.  The counter is incremented until a symbol name is obtained\n that does not currently exist on the oblist (i.e. is not interned), and\n a new interned symbol with that name is created.\n\n The prefix, if not specified by pfx1, defaults to T.\n\n The second optional argument to GENTEMP is supported for compatibility\n with other LISP's, but it is not used in ZIL at this time.\n\nErrors signaled:\n\n Invalid prefix.\n\nNotes:\n\n Compare GENSYM, which creates uninterned symbols.  The differences\n between GENSYM and GENTEMP, other than the fact that GENTEMP symbols\n are interned, are that the GENTEMP counter does not include leading\n zeroes when the symbol name is built, and that the default prefix\n is different.\n\nExamples:\n\n (GENTEMP)           ==> T1\n (GENTEMP)           ==> T2\n (SETQ A (GENTEMP))  ==> T3\n (EQ A 'T3)          ==> T   ; GENTEMP's are always interned.\n 'T4                 ==> T4\n (GENTEMP)           ==> T5  ; GENTEMP skips over already-interned names\n (GENTEMP 'FOO)      ==> FOO6\n (GENTEMP \"a\")       ==> |a7|\n (GENTEMP)           ==> T8\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GET": {"ttr": 3871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x08\\x13\\x00G\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T08:13:00", "lines": 71, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GET\n\nSyntax:   (GET arg1 arg2 &optional arg3)\n\n arg1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - any LISP object, but generally a symbol.\n arg3 (optional, evaluated) - any LISP object.\n\nReturns:\n\n The property value of the indicator specified by arg2 from the property\n list of arg1; arg3 (default NIL) if the indicator is not found.\n\nProcessing:\n\n The property list of the symbol specified by arg1 is searched for an\n indicator-value \"pair\" for which the indicator is EQ to arg2.  If the\n specified property is not present on the property list, arg3 (or NIL if\n arg3 was omitted) is returned.\n\n Although arg1 normally must be a symbol, ZIL will accept a first\n argument of a list, in which case the CDR of the list is treated like a\n property list.  This is the \"disembodied property list\" used in\n Maclisp.\n\n If arg1 is not a symbol or a list, a warning message is issued and arg3\n (or NIL) is returned.  This actually should be an error, but is\n accepted for compatibility with Maclisp.\n\nErrors signaled:\n\n Property list errors (see member $PROP).\n\nNotes:\n\n See member $PROP for information about property lists.\n\nExamples:\n\n (SETPLIST 'A NIL)                   ==> A\n (GET 'A 'FOO)                       ==> NIL\n (SETPLIST 'A '(FOO BAR BAZ (FROB NICK ATE)))\n                                     ==> A\n (GET 'A 'FOO)                       ==> BAR\n (GET 'A 'FOO \"default\")             ==> BAR\n (GET 'A 'BAR)                       ==> NIL\n (GET 'A 'BAR \"default\")             ==> \"default\"\n (GET 'A 'BAZ)                       ==> (FROB NICK ATE)\n\n (REMPROP 'A 'BAZ)                   ==> (FROB NICK ATE)\n (GET 'A 'BAZ)                       ==> NIL\n (GET 'A 'BAZ \"default\")             ==> \"default\"\n\n;The comparison test is EQ, not EQUAL or EQUALP.\n\n (PUTPROP 'A 'X 1.0)                 ==> X\n (PLIST 'A)                          ==> (1.0 X FOO BAR)\n (GET 'A 1.0)                        ==> NIL\n\n;Maclisp compatibility.\n\n (GET '(A B C D E) 'A)  ==> NIL\n (GET '(A B C D E) 'B)  ==> C\n (GET '(A B C D E) 'C)  ==> NIL\n (GET '(A B C D E) 'D)  ==> E\n (GET '(A B C D E) 'E)  ==> NIL\n\n (GET 1 2)              ==> NIL  ;  with a warning message\n (GET 1 2 3)            ==> 3    ;  with a warning message\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETCHAR": {"ttr": 3873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x04/\\x00\\x87%\\x1f\\x08Q\\x00+\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-11T00:00:00", "modifydate": "1987-09-08T08:51:00", "lines": 43, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GETCHAR\n\nSyntax:   (GETCHAR string1 index2)\n\n string1 (required, evaluated) - a string.\n index2  (required, evaluated) - a fixnum.\n\nReturns:\n\n The index2'th character of string1, as an interned symbol.\n\nProcessing:\n\n index2 is used as a one-based index into string1, where the characters\n of the string are indexed from 1 to the string length.\n\n The resultant character is made into a symbol which is always\n interned on the oblist.\n\n If index2 is less than 1 or greater than the length of the string,\n NIL is returned.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Invalid second argument (not a fixnum).\n\nNotes:\n\n Observe the distinctions between the character extracting functions:\n\n GETCHAR   -  uses one-based indexing, returns a symbol.\n GETCHARN  -  uses one-based indexing, returns a fixnum.\n CHAR      -  uses zero-based indexing, returns a fixnum.\n\nExamples:\n\n (GETCHAR \"foo\" 1)        ==> |f|\n (GETCHAR \"foo\" 0)        ==> NIL\n (GETCHAR \"foo\" 4)        ==> NIL\n (GETCHAR 'BAR 3)         ==> R\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETCHARN": {"ttr": 3875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x08O\\x00\\x87%\\x1f\\x08R\\x00.\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-25T00:00:00", "modifydate": "1987-09-08T08:52:00", "lines": 46, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GETCHARN\n\nSyntax:   (GETCHARN string1 index2)\n\n string1 (required, evaluated) - a string.\n index2  (required, evaluated) - a fixnum.\n\nReturns:\n\n The index2'th character of string1, as a fixnum.\n\nProcessing:\n\n index2 is used as a one-based index into string1, where the characters\n of the string are indexed from 1 to the string length.\n\n The resultant character is made into the fixnum representing the\n EBCDIC value of the character.\n\n If index2 is out of bounds with respect to the string, the fixnum 0\n is returned.  Note that there is no way to distinguish this case from\n the case of the null (hex 00) character being returned from inside\n the string.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Invalid second argument (not a fixnum).\n\nNotes:\n\n Observe the distinctions between the character extracting functions:\n\n GETCHAR   -  uses one-based indexing, returns a symbol.\n GETCHARN  -  uses one-based indexing, returns a fixnum.\n CHAR      -  uses zero-based indexing, returns a fixnum.\n\nExamples:\n\n (GETCHARN \"foo\" 2)       ==> #\\o\n (GETCHARN \"foo\" 1)       ==> #\\f\n (GETCHARN \"foo\" 0)       ==> #\\NULL\n (GETCHARN \"foo\" 4)       ==> #\\NULL\n (GETCHARN 'BAR 2)        ==> #\\A\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETK": {"ttr": 3877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x860\\x9f\\x00\\x87%\\x1f\\x08R\\x005\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-11-05T00:00:00", "modifydate": "1987-09-08T08:52:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GETK\n\nSyntax:   (GETK arg1 arg2 &optional arg3)\n\n arg1 (required, evaluated) - a proper list.\n arg2 (required, evaluated) - any LISP object, but generally a symbol.\n arg3 (required, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n The sublist of arg1 whose CAR is the \"value\" associated with the\n \"keyword\" arg2, i.e. the CDR of the sublist of arg1 whose CAR is EQ\n to arg2; NIL if no such keyword exists.\n\nProcessing:\n\n arg1 is not a \"disembodied property list\", but a list of alternating\n keywords and values.  The list is searched for a keyword-value \"pair\"\n for which the keyword is EQ to arg2.\n\n If such a value is present, the sublist of arg1 beginning with that\n value is returned; the CAR of this list is the value found.  If the\n specified keyword arg2 is not present on the list, NIL is returned.\n\n If arg1 is found to be an improper list or a list with an odd number of\n elements, then arg3 is consulted.  If arg3 is omitted or NIL, an error\n will be signalled in this case; if arg3 is specified and non-NIL, the\n function will just return NIL.\n\nErrors signaled:\n\n Invalid list (see above for details on when an error is signalled).\n\nNotes:\n\n GETK is similar to GET and GETL, but is designed to operate on\n keyword lists provided by callers of functions whose LAMBDA argument\n lists contain a &key specification.\n\nExamples:\n\n (GETK '(:A X :B Y :C Z) ':A)     ==>  (X :B Y :C Z)\n (GETK '(:A X :B Y :C Z) 'X)      ==>  NIL\n (GETK '(:A X :B Y :C Z) ':B)     ==>  (Y :C Z)\n (GETK '(:A X :B Y :C Z) 'Y)      ==>  NIL\n (GETK '(:A X :B Y :C Z) ':C)     ==>  (Z)\n (GETK '(:A X :B Y :C Z) 'Z)      ==>  NIL\n (GETK '(:A X :B Y :C Z) ':D)     ==>  NIL\n (GETK '(A BAD LIST) 'X)          ==>  (\"***ERROR***\")\n (GETK '(A BAD LIST) 'X NIL)      ==>  (\"***ERROR***\")\n (GETK '(A BAD LIST) 'X T)        ==>  NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETL": {"ttr": 3879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87\\x13/\\x088\\x00C\\x00B\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-05-12T08:38:00", "lines": 67, "newlines": 66, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GETL\n\nSyntax:   (GETL arg1 arg2)\n\n arg1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - a list.\n\nReturns:\n\n The sublist of the property list of arg1 whose CAR is a property\n indicator EQ to one of the elements of arg2, or NIL if no such\n indicator exists.\n\nProcessing:\n\n The property list of the atom specified by arg1 is searched for an\n indicator-value \"pair\" for which the indicator is EQ to one of the\n elements of arg2.\n\n If such a property is present, the sublist of the property list is\n returned; the CAR of this list is the indicator found, and the CADR\n (second element) is the property value.\n\n If the specified property is not present on the property list, NIL is\n returned.\n\n The first matching property indicator in the property list determines\n the return value; the order of the elements in arg2 is irrelevant.\n\n Although the first argument must be a symbol, ZIL will accept a\n first argument of a list, in which case the CDR of the list is\n treated like a property list.  This is the \"disembodied property list\"\n used in Maclisp.\n\n If the first argument is not a symbol or a list, a warning message\n is issued and NIL is returned.  This actually should be an error,\n but is accepted for compatibility with Maclisp.\n\nErrors signaled:\n\n Invalid property list (not a proper list or NIL).\n\nNotes:\n\n A property list has the following format:\n\n  (indicator1 value1 indicator2 value2 ...)\n\n where (GETL atom indicator1) returns \"value1\", etc.\n\nExamples:\n\n (SETPLIST 'A NIL)                   ==> A\n (GETL 'A '(FOO BAR))                ==> NIL\n (SETPLIST 'A '(FOO BAR BAZ (FROB NICK ATE)))\n                                     ==> A\n (GETL 'A '(FOO BAR BAZ))            ==> (FOO BAR BAZ (FROB NICK ATE))\n (GETL 'A '(BAZ FOO BAR))            ==> (FOO BAR BAZ (FROB NICK ATE))\n (GETL 'A '(BAZ))                    ==> (BAZ (FROB NICK ATE))\n (GETL 'A '(BAR FROB))               ==> NIL\n\n;The comparison test is EQ, not EQUAL or EQUALP.\n\n (SETF (PLIST 'A) '(1.0 X))          ==> (1.0 X)\n (GETL 'A '(1.0 2.0 3.0))            ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETPARM": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x88\\x12O\\x08\\x05\\x00\\x9e\\x00u\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1988-05-03T08:05:00", "lines": 158, "newlines": 117, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GETPARM\n\nSyntax:   (GETPARM arg1 arg2)\n\n arg1 (optional, evaluated) - any LISP object, but generally T or NIL.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A symbol whose print name is taken from the parameter\n string passed to the currently running ZIL program.\n\nProcessing:\n\n A ZIL program may be invoked in background via JCL like the following:\n\n  //stepname EXEC PGM=progname,PARM='parm string'\n\n (See the JCL manual for variations on this format.)\n\n A ZIL program may be invoked from TSO in the following manner:\n\n  CALL MY.LOAD(MYPROG) 'parm string'\n\n or it may be invoked as a command processor, e.g.:\n\n  MYCMD parm string\n\n (Other TSO commands that invoke user programs, such as TEST,\n  pass parameter strings in similar format.)\n\n In all cases, the string \"parm string\" is accessed by the GETPARM\n function, which builds a symbol from this string.\n\n If no parm string is passed to the program, or a null parm string\n is passed, GETPARM returns a symbol with a null print name.\n\n If the ZIL program was invoked as a TSO command processor, GETPARM\n returns the parameters starting with the first non-delimiter character\n following the command name; the data is returned asis (not folded to\n upper case), in contrast to the other methods which cause unconditional\n translation to upper case, thanks to the operating system.\n\n If the first character of the parm string is a backslash \"\\\", where\n the first character is determined by the scanning method described\n in the above paragraph, then GETPARM skips over all characters between\n this backslash and the next backslash, inclusive, returning the\n substring of the parm field starting from the character following the\n second backslash (if there is no second backslash, a null string is\n used).  This is because the data between the backslashes, if any, is\n reserved for ZIL initialization-time option specifications.\n\n If the first argument is non-NIL, the resulting atom is interned on the\n oblist; otherwise it is not interned (this is the default behavior),\n meaning that it will not be EQ to any other atom.\n\n If the second argument is non-NIL, the atom building routine will\n attempt to convert the atom to a numeric type, according to its syntax\n as the READ function would interpret it.  If the second argument is\n NIL, the atom is always treated as a symbol (this is the default\n behavior).  When a non-NIL second argument is specified, handling is\n the same as for the MKATOM function (q.v.).\n\nErrors signaled:\n\n None, except for those associated with failure to build the result.\n\nNotes:\n\n The contents of the PARM string are used by each ZIL program in\n different ways;  the interpreter, the compiler, OPS5 and Macsyma all\n use the PARM string for their own purposes.\n\n Under the interpreter, GETPARM returns the name of the INIT file\n that was specified (the \"null symbol\", ||, is returned when no INIT\n file is in use).\n\nExamples (cannot be run unless you invoke the interpreter as shown):\n\n ;If the parameter passed to ZILIN was:  ''\n\n (GETPARM)                    ==> ||\n\n ;If the parameter passed to ZILIN was:  '(HI, THERE.)'\n\n (GETPARM)                    ==> |(HI, THERE.)| ; note - 1 symbol.\n\n ;If the parameter passed to ZILIN was:  'FOO'\n\n (SETQ A (GETPARM NIL))       ==> FOO ; not interned.\n (SETQ B (GETPARM T))         ==> FOO ; interned.\n (EQ A 'FOO)                  ==> NIL\n (EQ B 'FOO)                  ==> T\n\n ;If the parameter passed to ZILIN was:  '007'\n\n (GETPARM NIL NIL)            ==> 007 ; note - symbol, not fixnum.\n (GETPARM NIL T)              ==> 7 ; note - fixnum, not symbol.\n\n ;If ZILIN was invoked via XCMD (i.e. as a command processor) with\n ; the following input line:\n ;\n ; ZILIN foo bar\n\n (GETPARM)                    ==> |foo bar|\n\n ;If ZILIN was invoked via XINV (i.e. as a program) with\n ; the following input line:\n ;\n ; XINV ZILIN 'foo bar'\n\n (GETPARM)                    ==> |FOO BAR|\n\n ;\n ; Examples with backslashes:\n ;\n\n ; XINV ZILIN '\\VSSIZE=1024K\\foo bar'\n\n (GETPARM)                    ==> |FOO BAR|\n\n ; XINV ZILIN '\\VSSIZE=1024K'\n\n (GETPARM)                    ==> ||\n\n ; XINV ZILIN '\\\\This - \\ - is a backslash'\n\n (GETPARM)                    ==> |THIS - \\\\ - IS A BACKSLASH|\n\n ; XCMD ZILIN  \\VSSIZE=1024K\\foo bar\n\n (GETPARM)                    ==> |foo bar|\n\n ; XCMD ZILIN  \\VSSIZE=1024K\n\n (GETPARM)                    ==> ||\n\n ; XINV ZILIN  '    This preserves leading blanks but not case.'\n\n (GETPARM)       ==> |    THIS PRESERVES LEADING BLANKS BUT NOT CASE.|\n\n ; XCMD ZILIN       This does not preserve leading blanks.\n\n (GETPARM)       ==> |This does not preserve leading blanks.|\n\n ; XCMD ZILIN  \\\\   This is a way to preserve leading blanks.\n\n (GETPARM)       ==> |   This is a way to preserve leading blanks.|\n\n ; XCMD ZILIN  , /* comment */ Leading delimiters and comments are lost.\n\n (GETPARM)       ==> |Leading delimiters and comments are lost.|\n\n ; XCMD ZILIN  \\\\, /* comment */ Everything is retained.\n\n (GETPARM)       ==> |, /* comment */ Everything is retained.|\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GO": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x88\\t\\x9f\\t\\x00\\x00E\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1988-04-08T09:00:00", "lines": 69, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: GO\n\nSyntax:   (GO arg1)\n\n arg1 (required,not evaluated) - a non-null symbol or integer.\n\nReturns:\n\n There is no return value.  Instead, control transfers to the form\n following the symbol (tag) that is EQL to arg1 in the current PROG.\n\nProcessing:\n\n GO is valid only within a PROG.\n\n Control transfers to the form following the GO tag\n that is EQL to arg1 in the current PROG being evaluated.\n PROG evaluation continues with that form and subsequent forms.\n\n The tag must be a symbol or an integer;\n other types of atoms are not valid GO tags.\n\n GO may transfer control to a tag in a PROG which is not the\n immediately enclosing PROG.  Under the interpreter, this even works\n with lexical closures (FUNARGs), which may produce some bizarre\n results.  In compiled code, GO may transfer control to a tag in a\n PROG which is not the immediately enclosing PROG, as long as control\n is dynamically within that PROG - i.e. no branching out of FUNARGS.\n\n When GO transfers control from inside a form protected by\n UNWIND-PROTECT to outside that form, the UNWIND-PROTECT cleanup forms\n are executed before control is passed to the target of the GO.\n\nErrors signaled:\n\n Missing or invalid tag argument\n GO tag not defined in current PROG\n GO outside of a PROG\n\nNotes:\n\n GO and RETURN are valid as long as they are lexically apparent in\n the code.  This means that they will be processed as long as they\n are not the product of function evaluation.  The following are\n valid occurrences of GO and RETURN:\n\n (PROG (A B C) LOOP (DO 'SOMETHING) (GO LOOP) (RETURN T))\n (PROG (A B C) (COND ((EQ A T) (GO LOOP)))\n               LOOP (PROG2 (PRINT A) (RETURN B)))\n\n The following is NOT valid:\n\n (DEFUN SUMFUNK () (GO LAB))\n (PROG (A) LAB (COND ((NULL A) (RETURN T))) (SUMFUNK))\n\n A \"GO outside of PROG\" error will be signalled.\n\nExamples:\n\n (PROG (A B)\n       (SETQ A '(1 2 3 4))\n  LOOP (COND ((NULL A) (GO EXIT)))\n       (SETQ B (CONS (ADD1 (CAR A)) B))\n       (SETQ A (CDR A))\n       (GO LOOP)\n  EXIT (RETURN B)\n )                                ==> (5 4 3 2)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREATERP": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x13\\x16\\x00B\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T13:16:00", "lines": 66, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: GREATERP\n\nSyntax:   (GREATERP arg1 arg2)\n    or:   (> arg1 &rest args)\n\n arg1 (required, evaluated) - a number, string or symbol.\n arg2 (required, evaluated) - a number, string or symbol.\n args (optional, evaluated) - a number, string or symbol.\n\nReturns:\n\n For symbols and strings:\n\n  T if the print name of each arg is alphanumerically greater than its\n  preceding arg (using the EBCDIC collating sequence), else NIL.\n\n For numbers:\n\n  T if each arg is numerically greater than its preceding arg,\n  else NIL.\n\nProcessing:\n\n For GREATERP, which takes exactly two args, the following holds:\n\n  If the arguments are EQ, regardless of type, the result is\n  always false (i.e. NIL is returned).\n\n  If both arguments are numbers, a numeric comparison is performed.\n  If the types differ, the appropriate conversion is performed (see\n  member $ARITH for conversion rules) and the numeric compare is done.\n\n  If both arguments are strings or symbols, a character comparison is\n  performed on the string text of the atoms, where the string text of\n  a symbol is its print name.  Case is significant.\n\n For >, which takes any number of args, the result is T if there is only\n one arg, or if all the args are monotonically increasing (adjacent\n pairs are compared via GREATERP); otherwise the result is NIL.\n\nErrors signaled:\n\n Non-atomic argument.\n One argument is a string or symbol and another is a number.\n\nNotes:\n\nExamples:\n\n (GREATERP 'FOO 'FOO)   ==> NIL\n (GREATERP 'A 'B)       ==> NIL\n (GREATERP 'AAA 'A)     ==> T\n (GREATERP 'FOO 'BAR)   ==> T\n (GREATERP \"foo\" \"bar\") ==> T\n (GREATERP \"FOO\" 'BAR)  ==> T\n (GREATERP 'FOO  \"BAR\") ==> T\n (GREATERP 2.0 3)       ==> NIL\n (GREATERP 1 1.0)       ==> NIL\n\n (> 9)                  ==> T\n (> 9 8)                ==> T\n (> 9 8 7)              ==> T\n (> 9 8 7 6)            ==> T\n (> 9 8 6 7 5)          ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HAIPART": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x19_\\x00\\x87%\\x1f\\x17\\x19\\x00\"\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-07-14T00:00:00", "modifydate": "1987-09-08T17:19:00", "lines": 34, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: HAIPART\n\nSyntax:   (HAIPART arg1 arg2)\n\n arg1 (required, evaluated) - an integer.\n arg2 (required, evaluated) - a fixnum.\n\nReturns:\n\n If arg2 is non-negative, an integer whose contents are the high-order\n arg2 bits of (ABS arg1).  If arg2 is negative, a fixnum whose contents\n are the (ABS arg2) low-order bits of (ABS arg1).\n\nProcessing:\n\n If (ABS arg2) is greater than the number of significant bits in arg1\n (i.e. (HAULONG arg1)), (ABS arg1) is returned.\n\nErrors signaled:\n\n First argument not an integer.\n Second argument not a fixnum.\n\nNotes:\n\nExamples:\n\n (HAIPART  7 2)       ==> 3\n (HAIPART  #o1234 3)  ==> 5\n (HAIPART -153 4)     ==> 9\n (HAIPART  123 -4)    ==> 11\n (HAIPART -123 -4)    ==> 11\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HAULONG": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x11\\x8f\\x00\\x88\\x15_\\x10\\x11\\x00.\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-04-28T00:00:00", "modifydate": "1988-06-03T10:11:00", "lines": 46, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: HAULONG\n\nSyntax:   (HAULONG arg1)\n\n arg1 (required, evaluated) - an integer.\n\nReturns:\n\n An integer containing the number of significant bits in the\n absolute value of arg1.\n\nProcessing:\n\n If arg1 is zero, 0 is returned.  Otherwise the total number of bits in\n the absolute value of the integer arg1, minus the number of leading\n zero bits, gives the value.\n\nErrors signaled:\n\n First argument not an integer.\n\nNotes:\n\n HAULONG is a Maclisp function.  Compare INTEGER-LENGTH (or ZILINTLN),\n a Common Lisp function.  Note that INTEGER-LENGTH is different for\n negative arguments.\n\nExamples:\n\n (HAULONG 0)    ==> 0\n (HAULONG 1)    ==> 1\n (HAULONG -1)   ==> 1\n (HAULONG 2)    ==> 2\n (HAULONG 3)    ==> 2\n (HAULONG 4)    ==> 3\n (HAULONG 5)    ==> 3\n (HAULONG #b1001001001)     ==> 10\n (HAULONG #b0110110110)     ==> 9\n (HAULONG 2147483647)       ==> 31\n (HAULONG 2147483648)       ==> 32\n (HAULONG -2147483647)      ==> 31\n (HAULONG -2147483648)      ==> 32\n (HAULONG (** 2 60))        ==> 61\n (HAULONG (+ (** 2 60) -1)) ==> 60\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HELP": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x88\\x16\\x9f\\x08Y\\x004\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1988-06-17T08:59:00", "lines": 52, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: HELP\n\nSyntax:   (HELP &optional arg1 arg2)\n\n arg1 (optional, not evaluated) - a symbol.\n arg2 (optional, not evaluated) - any LISP object, generally T or NIL.\n\nReturns:\n\n No values, after listing the on-line ZIL documentation member of the\n name specified by arg1.\n\nProcessing:\n\n If arg1 is omitted or NIL, general help information is displayed.\n\n If arg1 is ZIL, member $@INTRO is displayed.\n If arg1 is FUNCTIONS, member $HELP is displayed.\n\n If arg1 is the name of a ZIL function or macro, the member of the\n on-line ZIL documentation that describes that function or macro\n is displayed.\n\n If arg1 is anything else, the corresponding member of the on-line ZIL\n documentation is displayed in line mode if arg2 is omitted or NIL,\n or in full screen mode if arg2 is specified and non-NIL.\n\nErrors signaled:\n\n First argument not an (unquoted) symbol.\n\nNotes:\n\n The HELP information is taken from the online dataset specified by\n the global variable *ZIL-HELP-LIBRARY*, whose default value is:\n   \"PROGLIB.ZIL.TEXT\" for the production system;\n   \"PROGLIB.ZIL.NTEXT\" for the test system;\n   \"PROGLIB.ZIL.OTEXT\" for the backup system.\n (Note that the string, although containing a fully qualified name,\n  does not contain single quotes.)\n You can list, browse or print members of this\n dataset as well as viewing them via the HELP function.\n\nExamples:\n\n (HELP ZIL)   displays the introduction to ZIL.\n\n (HELP CAR)   displays information on CAR in line mode.\n\n (HELP + T)   displays information on PLUS in full screen mode.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IF": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x17'\\x00M\\x00R\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:27:00", "lines": 77, "newlines": 82, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: IF\n\nSyntax:   (IF arg1 arg2 ... argn)\n\n At least 3 arguments must be specified.\n\n The format must be one of the following:\n\n (IF form1 THEN form2)\n (IF form1 THEN form2 ENDIF)\n (IF form1 THEN form2 ELSE form3)\n (IF form1 THEN form2 ELSE form3 ENDIF)\n (IF form1 THEN form2 ELSE IF form3 THEN ...\n (IF form1 THEN form2 ELSEIF form3 THEN ...\n\n (IF form1 form2)       - equivalent to (IF form1 THEN form2)\n (IF form1 form2 form3) - equivalent to (IF form1 THEN form2 ELSE form3)\n\n Multiple forms can follow THEN and ELSE, e.g.\n (IF form1 THEN form2 form3 ELSE form4 form5 ...)\n\n Zero forms can follow as well, e.g.\n (IF form1 THEN ELSE IF form2 THEN form3 ELSE ENDIF)\n\n (...provided ENDIF is used at the end when no forms follow ELSE).\n\nReturns:\n\n One of the \"formn\"s that does not follow an \"IF\".\n\nProcessing:\n\n Either the same as Common LISP (IF test trueform falseform) or\n typical IF-THEN-ELSE; should be intuitively self-evident.\n\n The test, as you might imagine, is non-NIL vs. NIL.\n\n If none of the IF forms are non-NIL, NIL is returned.\n\n When there are multiple forms following a THEN and that path is taken,\n the last of the forms is returned as the value.\n When there are no forms following a THEN and the THEN path is taken,\n the value of the condition form following the IF is returned.\n When there are no forms following an ELSE and the ELSE path is taken,\n T is returned (this is a \"feature\" that will be removed eventually).\n\nErrors signaled:\n\n Invalid syntax.\n\nNotes:\n\n Examples of how the IF macro expands into the corresponding COND:\n\n (IF A B)                 --> (COND (A B))\n (IF A B C)               --> (COND (A B) (T C))\n\n (IF A THEN B C ELSE D E) --> (COND (A B C) (T D E))\n (IF A THEN ELSE B ENDIF) --> (COND (A) (T B))\n (IF A THEN B ELSE ENDIF) --> (COND (A B) (T))  ; \"Feature\" (i.e. \"bug\")\n\n Compare WHEN and UNLESS, which also expand into COND's.\n\nExamples:\n\n (IF T 'FOO 'BAR)       ==> FOO\n (IF NIL 'FOO 'BAR)     ==> BAR\n (IF T 'FOO)            ==> FOO\n (IF NIL 'FOO)          ==> NIL\n (IF T THEN 'FOO)       ==> FOO\n (IF NIL THEN 'FOO)     ==> NIL\n (IF (= 1 2) THEN 'TRU1 ELSE IF (= 3 3) THEN 'TRU2 ELSE 'TRU3 ENDIF)\n                        ==> TRU2\n (IF 'A  THEN ELSE 'B)  ==> A\n (IF NIL THEN ELSE 'B)  ==> B\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFILEP": {"ttr": 4111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x863_\\x00\\x87%\\x1f\\x17(\\x00*\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-12-01T00:00:00", "modifydate": "1987-09-08T17:28:00", "lines": 42, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: IFILEP\n\nSyntax:   (IFILEP file1)\n\n file1 (required, evaluated) - a file name.\n\nReturns:\n\n T if file1 is a valid input file, else NIL.\n\nProcessing:\n\n If the file specified by file1 is an already open input file, then T is\n returned.  If the file is not an already open input file, then an\n attempt is made to open the file name consisting of 'ZILI' + the file\n name, as for all ZIL file accessing functions.  If such a file exists,\n T is returned; otherwise NIL is returned.  If any error occurs trying\n to process the file, the error is signalled; in other words, IFILEP\n suppresses \"file does not exist\" errors only.\n\nErrors signaled:\n\n See above description.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Because an MVS file (ddname) allocation remains around even after\n the file is closed under ZIL, issuing IFILEP against a closed\n input file will cause the file to be reopened.\n\nExamples:\n\n (IFILEP NIL)    will always return T.\n\n (IFILEP 'FOO)   returns T if a ddname ZILIFOO is allocated to a\n                 usable data set.\n\n (IFILEP (OPEN \"cmd.clist(zlogon)\"))     should return T.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMPLODE": {"ttr": 4113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x17)\\x002\\x00G\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:29:00", "lines": 50, "newlines": 71, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: IMPLODE\n\nSyntax:   (IMPLODE arg1)\n\n arg1 (required, evaluated) - a proper list of atoms.\n\nReturns:\n\n An interned symbol whose print name consists of the characters in the\n list specified by arg2, concatenated to form a new atom name.\n\nProcessing:\n\n The CAR's of arg1, which must be a non-null list of fixnums, strings\n and/or symbols, are converted as follows:\n\n  For a fixnum, its EBCDIC character equivalent is obtained.\n  For a string, its first character is obtained.\n  For a symbol, the first character of its print name is obtained.\n\n These are concatenated to build an interned symbol whose print name is\n the string resulting from the concatenation.\n\n arg1 may be NIL, in which case a symbol with a null print name is\n returned.\n\nErrors signaled:\n\n arg1 not a list of atoms (nested lists and vectors are not permitted).\n An object other than a fixnum, string or symbol was encountered.\n\nNotes:\n\n Compare MAKNAM, which is identical but doesn't intern its symbol.\n\n The old ZIL 1.1 IMPLODE is now called ZILIMPL; the IMPLODE described\n here is essentially the Maclisp definition.\n\nExamples:\n\n (IMPLODE NIL)                 ==> ||\n (IMPLODE '(A))                ==> A\n (IMPLODE '(F O O))            ==> FOO\n (IMPLODE '(FOO BAR))          ==> FB\n (IMPLODE '(#/a #/b \"c\"))      ==> |abc|\n\n (SETQ A (IMPLODE '(F O O)))   ==> FOO\n (EQ A 'FOO)                   ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INCF": {"ttr": 4115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x865\\x7f\\x00\\x87%\\x1f\\x17)\\x00*\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-12-23T00:00:00", "modifydate": "1987-09-08T17:29:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: INCF\n\nSyntax:   (INCF place1 &optional increment2)\n\n place1 (required) - a form acceptable to SETF which evaluates to a\n                     number.\n increment2 (optional, evaluated) - a number.\n\nReturns:\n\n place1, after it has been incremented by increment2.\n\nProcessing:\n\n place1 is typically a variable, but in general is any form acceptable\n as the first argument to SETF.\n The variable or location specified by place1 is incremented by adding\n to it the value of increment2, which defaults to 1 if not specified.\n\nErrors signaled:\n\n None by the macro, but the increment will fail if bad args are used.\n\nNotes:\n\n Compare DECF, which decrements.\n\n INCF is a macro that expands something like this:\n\n  (INCF a b)  --> (SETF a (+ a b))\n\nExamples:\n\n (SETQ A 1)   ==> 1\n (INCF A)     ==> 2\n A            ==> 2\n (INCF A 3)   ==> 5\n A            ==> 5\n (INCF A -1)  ==> 4\n A            ==> 4\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INCLUDE": {"ttr": 4117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x15_\\x00\\x87&\\x0f\\x086\\x00&\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-06-04T00:00:00", "modifydate": "1987-09-17T08:36:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: INCLUDE\n\nSyntax:   (INCLUDE dsn1)\n\n dsn1  (required, not evaluated) - a data set name (string or symbol).\n\nReturns:\n\n NIL, after including all the forms in the dataset specified by dsn1.\n\nProcessing:\n\n INCLUDE is a macro which allows you to include LISP source code from\n another data set into other code; it expands into a PROGN containing\n all the forms from the data set, with NIL as the last value.\n\n READ errors do not terminate the operation.\n\nErrors signaled:\n\n Errors detected by OPEN and READ.\n\nNotes:\n\n INCLUDE can be used under the compiler to incorporate source code\n (e.g. macro definitions) only in locations that are subject to\n macroexpansion.  Under the interpreter, INCLUDE functions\n similarly to LOAD.\n\n Compare INCLUDEF, which is identical to INCLUDE except that it\n evaluates its argument.\n\n The function XINCLUDE, which underlies INCLUDE and INCLUDEF,\n performs the actual expansion (i.e. it returns a PROGN list made\n from the contents of the file).  Direct use of XINCLUDE, while\n not recommended, may be useful in certain situations.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INCLUDEF": {"ttr": 4119, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x15_\\x00\\x87&\\x0f\\x086\\x00&\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-06-04T00:00:00", "modifydate": "1987-09-17T08:36:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: INCLUDEF\n\nSyntax:   (INCLUDEF dsn1)\n\n dsn1  (required, evaluated) - a data set name (string or symbol).\n\nReturns:\n\n NIL, after including all the forms in the dataset specified by dsn1.\n\nProcessing:\n\n INCLUDEF is a macro which allows you to include LISP source code from\n another data set into other code; it expands into a PROGN containing\n all the forms from the data set, with NIL as the last value.\n\n READ errors do not terminate the operation.\n\nErrors signaled:\n\n Errors detected by OPEN and READ.\n\nNotes:\n\n INCLUDEF can be used under the compiler to incorporate source code\n (e.g. macro definitions) only in locations that are subject to\n macroexpansion.  Under the interpreter, INCLUDEF functions\n similarly to LOAD.\n\n Compare INCLUDE, which is identical to INCLUDEF except that it\n does not evaluate its argument.\n\n The function XINCLUDE, which underlies INCLUDE and INCLUDEF,\n performs the actual expansion (i.e. it returns a PROGN list made\n from the contents of the file).  Direct use of XINCLUDE, while\n not recommended, may be useful in certain situations.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INDEX": {"ttr": 4121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x06o\\x00\\x87%\\x1f\\x171\\x00L\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-07T00:00:00", "modifydate": "1987-09-08T17:31:00", "lines": 76, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-INDEX\n\nSyntax: (STRING-INDEX string1 string2 &optional index3)\n    or:        (INDEX string1 string2 &optional index3)\n\n string1 (required, evaluated) - a string.\n string2 (required, evaluated) - a string.\n index3  (optional, evaluated) - a positive fixnum.\n\nReturns:\n\n The index of string2 within string1, with the search beginning at\n the offset specified by index3 (or the beginning of string1 if\n index3 is omitted); NIL if string2 does not occur within string1.\n\nProcessing:\n\n One-based indexing is used.\n\n String1 is searched from either the beginning (if index3 is omitted,\n i.e. defaults to 1) or the offset specified by index3; when the first\n substring thereof that is equal (in a case-sensitive character\n comparison) to string2 is located, the one-based offset of that\n substring within string1 is returned.  If string2 does not match any\n substring of string1, NIL is returned.\n\n If string2 is null, a fixnum 0 is returned.  Other than that case,\n NIL is always returned when string1 is null.\n\n The offset is always relative to the beginning of the entire string1,\n even when index3 is specified.\n\n As with most string-handling functions, symbols are acceptable for\n either of the first 2 arguments.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Invalid second argument (not a string).\n Invalid third argument (not a positive fixnum).\n\nNotes:\n\n This function is analogous to the PL/1 INDEX function; the optional\n third argument, while not present in PL/1, corresponds to a SHARE\n requirement for an optional third argument to PL/1 INDEX.\n\n Specifying the third arg is NOT equivalent to specifying a SUBSTR\n as the second arg.  Observe the examples.  This feature may be\n useful in parsing a string into a sequence of tokens.\n\nExamples:\n\n (INDEX \"\" \"non-null-string\")   ==> NIL\n (INDEX \"\" \"\")                  ==> 0     ; Special case.\n (INDEX \"any-string\" \"\")        ==> 0     ; Special case.\n (INDEX \"foobar\" \"f\")           ==> 1\n (INDEX \"foobar\" \"o\")           ==> 2\n (INDEX \"foobar\" \"r\")           ==> 6\n (INDEX \"foobar\" \"z\")           ==> NIL\n (INDEX \"foobar\" \"bar\")         ==> 4\n (INDEX \"foobar\" \"foobar\")      ==> 1\n (INDEX \"foobar\" \"foobarbaz\")   ==> NIL\n\n; The following examples show that (INDEX x y z) is NOT the same as\n; (INDEX (SUBSTR x z) y).\n\n (INDEX \"blah blah blah\" \"blah\" 5)          ==> 6\n (INDEX (SUBSTR \"blah blah blah\" 5) \"blah\") ==> 2\n\n (INDEX \"foobar\" \"o\" 1)         ==> 2     ; Search \"foobar\".\n (INDEX \"foobar\" \"o\" 2)         ==> 2     ; Search  \"oobar\" only.\n (INDEX \"foobar\" \"o\" 3)         ==> 3     ; Search   \"obar\" only.\n (INDEX \"foobar\" \"o\" 4)         ==> NIL   ; Search    \"bar\" only.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTEGERP": {"ttr": 4123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x1f\\x173\\x00$\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-08T17:33:00", "lines": 36, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: INTEGERP\n\nSyntax:   (INTEGERP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is an integer (fixnum or bignum), otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n A fixnum is an integer in the range -2147483648 thru 2147483647.\n Integers outside of this range are bignums, of which BIGP is true.\n The predicate FIXNUMP may be used to test if an object is a fixnum\n and not a bignum.\n\n INTEGERP has a different definition in MAcsyma.  Use FIXP to get\n the same functionality under Macsyma.\n\nExamples:\n\n (INTEGERP 1)            ==> T\n (INTEGERP 1.0)          ==> NIL\n (INTEGERP '(1))         ==> NIL\n (INTEGERP 'ONE)         ==> NIL\n (INTEGERP 123456789876) ==> T\n (INTEGERP (** 2 31))    ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INTERN": {"ttr": 4125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\t6\\x00%\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T09:36:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: INTERN\n\nSyntax:   (INTERN string1 &optional arg2)\n\n string1 (required, evaluated) - a string.\n arg2 (optional, evaluated) - any Lisp object; it is ignored.\n\nReturns:\n\n An interned symbol whose print name is string1.\n\nProcessing:\n\n string1 is used to build a new symbol whose print name is string1.  The\n symbol is interned on the oblist.\n\n\nErrors signaled:\n\n Errors signalled by MKATOM (q.v.).                                     ).\n\nNotes:\n\nExamples:\n\n (INTERN \"A\")                  ==> A\n (INTERN \"hi there\")           ==> |hi there|\n (INTERN \"(F O O)\")            ==> |(F O O)|\n (INTERN \"007\")             ==> |007|\n\n (SETQ A (INTERN \"FOO\"))       ==> FOO\n (EQ A 'FOO)                   ==> T\n\n (SETQ B 'BAR)                 ==> BAR\n (EQ B (INTERN \"BAR\"))         ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTERSEC": {"ttr": 4127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x173\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:33:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: INTERSECTION\n\nSyntax:   (INTERSECTION arg1 arg2)\n    or:   (INTERSEC arg1 arg2)\n\n arg1 (required, evaluated) - a proper list.\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n A list containing only the elements that occur in both arguments.\n\nProcessing:\n\n A new list is constructed from the elements of the two arguments;\n if an element occurs once in each list argument, it will occur\n once in the result.  No other guarantee is given with respect\n to the order of the elements, or how many times a given element\n will occur if it occurs more than once in one of the input lists.\n\n The test used is EQL.  Compare INTRQ, which uses the EQ test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.\n Unpredictable results will occur if the first and second arguments\n are not proper lists.\n\nExamples:\n\n (INTERSEC NIL '(A B C))              ==> NIL\n (INTERSEC '(A B C) '(D E F))         ==> NIL\n (INTERSEC '(A B C D E) '(A E I O U)) ==> (A E)\n (INTERSEC '(1.0 2.0 3.0) '(2.0 3.0 4.0))  ==> (2.0 3.0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INTRPRET": {"ttr": 4129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x176\\x00v\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:36:00", "lines": 118, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: READ-EVAL-PRINT\n\nSyntax:   (READ-EVAL-PRINT &optional file1 file2 string3)\n    or:   (INTRPRET &optional file1 file2 string3)\n\n file1 (optional, evaluated) - an input file name.\n file2 (optional, evaluated) - an output file name, or the atom NOPRINT.\n string3 (optional, evaluated) - a string.\n\nReturns:\n\n A null string, after executing a READ-EVAL-PRINT loop over file1\n while printing to file2.\n\nProcessing:\n\n If string3 is specified, it is displayed on file2 as a prompt.\n An S-expression is read from file1; it is evaluated and the result is\n printed to file2 (unless the value of file2 is NOPRINT, in which case\n only the evaluation is done).  This process is repeated until\n end-of-file is reached on file1, or the form (END) is read.\n\n Within the loop, the following special variables are available to\n the top-level user:\n\n  *    contains the last value printed by the READ-EVAL-PRINT loop.\n  **   contains the previous value of *.\n  ***  contains the previous value of **.\n  +    contains the last form read by the READ-EVAL-PRINT loop.\n  ++   contains the previous value of +.\n  +++  contains the previous value of ++.\n  -    contains the form the READ-EVAL-PRINT loop is currently\n       evaluating.  If you type in - by itself, the value will be -.\n\n If file1 is omitted or NIL, the standard input file is used.\n\n If file2 is omitted or NIL, the standard output file is used.\n\n If string3 is omitted or NIL, no prompt is displayed.\n\nErrors signaled:\n\n Invalid input file object.\n Invalid output file object.\n\n Note:  Errors encountered by READ, EVAL, and PRINT are trapped, as\n        are attention interrupts (provided attention handling is\n        enabled).\n\nNotes:\n\n The prompt string (string3) is displayed via PRINC, which means that\n the cursor is not moved to the next line.  If you want a prompting\n string that also moves the cursor to the next line, you must specify\n one that ends in a new line (hex 15) or carriage return (hex 0D).\n You can code such a string as follows:\n\n   #.(string-append \"foo\" (ebcdic #\\CR))\n\n is the same as coding\n\n   \"foo:\"\n\n where the : is actually a hex 0D.\n Similarly...\n\n   (setq ps (string-append ps (ebcdic #\\NL)))\n\n will stick a newline character X'15' on the end of the value of PS.\n\n The QUIT function, when evaluated, will cause an end-of-file condition\n to be forced on its specified input file.  This once provided the only\n means of ending the INTRPRET loop; hence its name.\n\n The form (END), when typed as is, is a termination signal to\n READ-EVAL-PRINT.  Since it is not actually a function, it cannot be\n embedded within another function or generated by a macro, and it can\n have no operands.\n\n READ-EVAL-PRINT is used in the interpretive environment to \"load\" a\n sequential dataset (or PDS member) of interpretive function\n definitions, macros, or whatever you wish.  It is generally assumed\n that the file specified has not been read yet; if it has,\n READ-EVAL-PRINT will start processing at the current input record and\n character position.  If you try to READ-EVAL-PRINT the same file more\n than once, you will get a \"read after end of file\" error the second\n time.\n\n Use the LOAD function to insure that an entire data set is loaded\n from beginning to end.\n\nExamples:\n\n (INTRPRET)\n (INTRPRET NIL)\n (INTRPRET NIL NIL)\n (INTRPRET NIL NIL NIL)  are equivalent and execute a READ-EVAL-PRINT\n                         loop from standard input to standard output\n                         with no prompting string.\n\n (INTRPRET 'INIT)    reads, evaluates and prints all S-expressions on\n                     input file INIT.\n\n (INTRPRET 'FOO 'NOPRINT) reads and evaluates, without printing, all\n                          S-expressions on input file FOO.\n\n (INTRPRET 'BAR 'OUT) reads S-expressions from input file BAR,\n                      evaluates them, and prints to output file OUT.\n\n (INTRPRET NIL NIL \">\") executes a READ-EVAL-PRINT loop with a prompt\n                      of > and no carriage return.\n\n (INTRPRET NIL NIL #.(string-append \"ZIL\" (ebcdic #x0D)))\n\n                   executes a READ-EVAL-PRINT loop with a prompt of\n                   ZIL and a carriage return.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "INTRQ": {"ttr": 4131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x176\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:36:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: INTRQ\n\nSyntax:   (INTRQ arg1 arg2)\n    or:   (INTRQ arg1 arg2)\n\n arg1 (required, evaluated) - a proper list.\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n A list containing only the elements that occur in both arguments.\n\nProcessing:\n\n A new list is constructed from the elements of the two arguments;\n if an element occurs once in each list argument, it will occur\n once in the result.  No other guarantee is given with respect\n to the order of the elements, or how many times a given element\n will occur if it occurs more than once in one of the input lists.\n\n The test used is EQ.  Compare INTERSECTION, which uses the EQL test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.\n Unpredictable results will occur if the first and second arguments\n are not proper lists.\n\nExamples:\n\n (INTRQ NIL '(A B C))                   ==> NIL\n (INTRQ '(A B C) '(D E F))              ==> NIL\n (INTRQ '(A B C D E) '(A E I O U))      ==> (A E)\n (INTRQ '(1.0 2.0 3.0) '(2.0 3.0 4.0))  ==> NIL   ; Test is EQ.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INVOKE": {"ttr": 4354, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x08\\x7f\\x00\\x87%\\x1f\\x178\\x00L\\x00R\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-28T00:00:00", "modifydate": "1987-09-08T17:38:00", "lines": 76, "newlines": 82, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: INVOKE\n\nSyntax:   (INVOKE arg1 &optional arg2)\n\n arg1 (required, evaluated) - a string (or symbol) between 1 and 8\n                              characters in length.\n arg2 (optional, evaluated) - a string between 0 and 100 characters\n                              in length.\n\nReturns:\n\n A fixnum containing the return code from the program named by arg1\n after it is invoked, or NIL if that program abended.\n\nProcessing:\n\n arg1 is assumed to be the name of a valid load module residing in\n a system load library or the link pack area.\n If arg2 is present and not NIL, it must be a string which is\n taken to be the parameter string to be passed to the program.\n If arg2 is omitted or NIL, a null parameter string is used.\n\n Note that both args are unconditionally translated to UPPER CASE,\n in accordance with OS conventions.\n\n The contents of the return code (register 15) when the program returns\n control are used to build a fixnum containing the value to be returned\n as the INVOKE function value. This should be 0 if the command completed\n successfully.\n\n If the program abnormally terminates (ABENDs), a message is displayed\n to that effect and INVOKE returns NIL as the value.\n\n INVOKE, unlike TSO, will work in batch environments as well as\n foreground.\n\n You cannot invoke TSO commands with this function, or programs that\n require APF authorization (like IEBCOPY).  (You must use the TSO\n function, with the TSOEXEC command if necessary, if you require\n these features.)\n\n The success of this function is dependent upon the amount of system\n memory available at the time that the program is attempted to be\n invoked.  If there is insufficient virtual storage, the program\n requested will probably ABEND.\n\nErrors signaled:\n\n Program name invalid or not found.\n Second arg not a string (it cannot be a symbol, for then NIL would\n be ambiguous as a PARM value).\n Miscellaneous system failures.\n\nNotes:\n\n Programs which have the same names as compiled ZIL functions or other\n ZIL routines will not work.  The system will attempt to execute the ZIL\n code as a program and unpredictable results will occur.\n\n The requested program must be either in a system library, the link\n pack area (LPA), or a JOBLIB, STEPLIB or task library; the library\n containing ZIL modules will work (because you may wish to include a\n STEPLIB in batch for both ZIL code and invoked programs), but, as\n stated above, results are definitely not predictable.\n\nExamples:\n\n (INVOKE 'IEFBR14) ==> 0\n\n (INVOKE \"IEBGENER\")   will call the IEBGENER utility and\n  (assuming that you have set up the proper allocations previously)\n  will return the return code from IEBGENER.\n\n (INVOKE 'X3NOTIFY \"/ABC1234\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPFP": {"ttr": 4356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x02\\x8f\\x00\\x87%\\x9f\\x07@\\x00$\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-01-28T00:00:00", "modifydate": "1987-09-16T07:40:00", "lines": 36, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ISPFP\n\nSyntax:   (ISPFP)\n\nReturns:\n\n T if ISPF dialog services are available in the current environment,\n else NIL.\n\nProcessing:\n\n A test similar to the one performed by ISPLINK is done to see if there\n is a valid ISPF environment, suitable for invoking dialog services.\n If there is, T is returned; otherwise NIL is returned.\n\n Note that this function is more accurate than, for example, the\n &SYSISPF CLIST variable, because ISPFP will return NIL in certain\n cases where &SYSISPF would give you the wrong answer, most notably\n when ZIL has been invoked via the TSO Authorized Service Facility\n under ISPF.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n ISPF Version 2 must be installed to use this function.\n\n It has been noted that ISPFP will falsely return T when ISPF dialog\n services are not available because of a subtasking environment that\n does not have a SELECT CMD at the top of the task tree.  However,\n this failure is present in the ISPF Version 2 Release 3 ISPQRY\n program as well, and may or may not be fixed by IBM.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "KEYWORDP": {"ttr": 4358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\tO\\x00\\x87%\\x1f\\x17B\\x00*\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-04T00:00:00", "modifydate": "1987-09-08T17:42:00", "lines": 42, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: KEYWORDP\n\nSyntax:   (KEYWORDP arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a \"keyword\", otherwise NIL.\n\nProcessing:\n\n In Common LISP, a \"keyword\" is a symbol interned in the keyword\n package, and is printed with a leading colon.\n\n ZIL does not support packages, so a symbol is considered to be a\n keyword if the first character in its print name is a colon.\n Keyword symbols always evaluate to themselves.\n\n A keyword symbol cannot be used in a LAMBDA list or other variable\n binding environment, nor can it be SETQ'd.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This is truly a kludge, but necessary to implement a minimal kind\n of support for functions with keyword arguments.\n\nExamples:\n\n (KEYWORDP 'FOO)    ==> NIL\n (KEYWORDP NIL)     ==> NIL\n (KEYWORDP 123)     ==> NIL\n (KEYWORDP '(A B C)) ==> NIL\n (KEYWORDP ':FOO)   ==> T\n (KEYWORDP '|:|)    ==> T\n (KEYWORDP \":foo\")  ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KWDIFY": {"ttr": 4360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x0f\\x00\\x88\\x12O\\x08\\x07\\x00&\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1988-05-03T08:07:00", "lines": 38, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: KEYWORDIFY\n\nSyntax:   (KEYWORDIFY arg1)\n    or:   (KWDIFY arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n A \"keyword\" symbol whose print name is equal to the print name of\n arg1 prefixed with a colon (\":\").\n\nProcessing:\n\n If arg1 is already a \"keyword\", itself is returned.  Otherwise,\n a colon is concatenated with the print name of arg1 and a new\n symbol is interned with that name.\n\nErrors signaled:\n\n Argument not a symbol.\n\nNotes:\n\n Since ZIL 1.3 does not have a package system, it does not have true\n Common Lisp \"keywords\".  However, any symbol with a print name starting\n with a colon is treated as a \"keyword\" in ZIL.  Such symbols evaluate\n to themselves and cannot be used as lambda list arguments.\n\nExamples:\n\n (KEYWORDIFY 'A)          ==> :A\n (KEYWORDIFY :B)          ==> :B\n (KEYWORDIFY NIL)         ==> :NIL\n (KEYWORDIFY '|foo|)      ==> |:foo|\n (KEYWORDIFY \"foo\")       ==> (\"***ERROR***\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LAMBDA": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x17D\\x00[\\x00K\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:44:00", "lines": 91, "newlines": 75, "modlines": 0, "user": "SEB1525"}, "text": "\nLAMBDA is not a function name, but a symbol that identifies an\ninterpretive function, such as can be created by a DEFUN.\nA LAMBDA-expression can also occur where a function name is normally\nused, e.g.:\n\n  ((LAMBDA (X) (CONS X NIL)) 'FOO)\n  (MAPCAR '(LAMBDA (X Y) (LIST Y X)) FOO BAR)\n  (FUNCTION (LAMBDA (X) (BAZ X X)))\n    ...the last being equivalent to #'(LAMBDA (X) (BAZ X X)).\n\nA list whose CAR is the symbol LAMBDA can be executed as a function\nby EVAL or APPLY, provided that its syntax is correct.  If a LAMBDA\nexpression appears by itself (anonymously), it is processed as an\nEXPR (as if the name of an EXPR had been specified in its place),\ni.e. all its arguments are evaluated and the body of the LAMBDA\nexpression is evaluated with the bindings set accordingly.\n\nThe syntax of a LAMBDA is as follows:\n\n  (LAMBDA arg1 arg2 ... argn)\n\nwhere arg1 is required and must be a valid argument list, and arg2\nthrough argn (at least one required) comprise the body of the function.\n\nThe elements of the argument list (arg1) are generally symbols which\nwill be bound to the function arguments when the body is executed.  The\nbody is an \"implicit PROGN\", meaning that all the forms are evaluated\nbut only the last one returns a value to the invoker of the LAMBDA\nexpression.\n\nIn addition to symbols that will be bound to values, the following\nkeywords may occur in a LAMBDA expression (these are valid for\nEXPR's and MACRO's only):\n\n &OPTIONAL - indicates that the symbols following are optional\n arguments, and need not be specified when the function is called.\n Any unspecified arguments in this list are bound to NIL (or an\n initialization form if one is provided).\n\n If there are fewer arguments passed to the function than are\n specified in the LAMBDA list prior to &OPTIONAL if any, an\n error is signalled.\n\n &REST - indicates that the symbol following (there must be one and\n only one symbol following) will be bound to the list of arguments\n \"left over\" after bindings for the others have been set up.  If\n &REST is not used and there are more arguments passed to the\n function than are defined in the LAMBDA list, an error is signalled.\n\n For example:\n\n  (DEFUN FOO (A B &OPTIONAL C D &REST E) (LIST A B C D E))\n\n  will result in the following:\n\n  (FOO)               signals an error (too few arguments).\n  (FOO 1)             signals an error (too few arguments).\n  (FOO 1 2)           ==> (1 2 NIL NIL NIL)\n  (FOO 1 2 3)         ==> (1 2 3 NIL NIL)\n  (FOO 1 2 3 4)       ==> (1 2 3 4 NIL)\n  (FOO 1 2 3 4 5)     ==> (1 2 3 4 (5))\n  (FOO 1 2 3 4 5 6)   ==> (1 2 3 4 (5 6))\n  (FOO 1 2 3 4 5 6 7) ==> (1 2 3 4 (5 6 7))\n\n See $COMPILE for details on compiling functions with &OPTIONAL or\n &REST arguments.\n\n Note: &BODY is synonymous with REST.\n\n &AUX - indicates that the symbols following are not arguments,\n and may not be passed as arguments, but are auxiliary variables\n that are bound to NIL (or an initialization form if one is\n provided).\n\n &KEY - allows the function to accept \"keywords\".  Keywords are\n values obtained from parsing the extra args to the function\n (which also go into the &REST arg if one is provided) as a\n list of alternating \"keywords\" and values.  In ZIL, a \"keyword\"\n is any symbol whose print name begins with a colon (this is to\n make them look like true Common LISP \"keywords\", which are\n ordinary symbols interned in the \"keyword package\").  Keywords\n are self-evaluating (unless currently bound), which means that\n it is not necessary to quote them.\n\n For detailed information on how to code the &OPTIONAL, &AUX and\n &KEY lambda list arguments, see any Common LISP reference.\n\n For more information (as well as additional features of LAMBDA\n lists), see member $DEFUN.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LAND": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x17D\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:44:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LAND\n\nSyntax:   (LAND arg1 arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical AND operation\n performed on arg1 and arg2.\n\nProcessing:\n\n This is a fixnum-only operation.\n\nErrors signaled:\n\n arg1 or arg2 not a fixnum.\n\nNotes:\n\n LOGAND performs the logical AND function on any number of arguments.\n\nExamples:\n\n (LAND 7 5)              ==> 5\n (LAND 5 -2)             ==> 4\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LAST": {"ttr": 4366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%\\x1f\\x17D\\x00$\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-08T17:44:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LAST\n\nSyntax:   (LAST arg1)\n\n arg1 (required, evaluated) - a proper list.\n\nReturns:\n\n The last sublist of the list specified by arg1.\n\nProcessing:\n\n Successive sublists (CDR's) of the list are examined until the one with\n a single element (i.e. one whose own CDR is NIL or atomic) is found;\n then that sublist is returned.\n\n If the list ends in a dotted pair, the returned value is that\n dotted pair; otherwise the returned value is a list of one element.\n\n If arg1 is NIL or atomic, itself is returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (LAST NIL)                  ==> NIL\n (LAST '(A))                 ==> (A)\n (LAST '(A B . C))           ==> (B . C)\n (LAST '(A B C D))           ==> (D)\n (LAST '((A B) (C D)))       ==> ((C D))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LASTCAR": {"ttr": 4368, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x07D\\x00#\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T07:44:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LASTCAR\n\nSyntax:   (LASTCAR arg1)\n\n arg1 (required, evaluated) - a proper list.\n\nReturns:\n\n The CAR of the last sublist of the list specified by arg1.\n\nProcessing:\n\n If arg1 is NIL or atomic, itself is returned.\n If arg1 is a proper list, the last element of the list is returned.\n If arg1 is a list ending in a dotted pair (a cons whose CAR is not\n NIL), the CDR of that dotted pair is returned.\n\n Note that (LASTCAR x) is NOT equivalent to (CAR (LAST x)) because\n of this last case.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (LASTCAR NIL)                  ==> NIL\n (LASTCAR '(A))                 ==> A\n (LASTCAR '(A B . C))           ==> C   ;  ! not B\n (LASTCAR '(A B C D))           ==> D\n (LASTCAR '((A B) (C D)))       ==> (C D)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LDIFF": {"ttr": 4370, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x881\\x9f\\x00\\x881\\x9f\\x08 \\x00/\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-14T00:00:00", "modifydate": "1988-11-14T08:20:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LDIFF\n\nSyntax:   (LDIFF arg1 arg2)\n\n arg1 (required, evaluated) - a list.\n arg2 (required, evaluated) - a list.\n\nReturns:\n\n A list containing all the elements of the part of arg1 that is not\n part of arg2, in the sense that arg2 is a sublist of arg1.\n\nProcessing:\n\n LDIFF is \"list difference\".\n\n The elements of arg1 are collected by cdr'ing down arg1 until it\n becomes EQ to arg2 (i.e. arg2 is found to be a sublist of arg1),\n or until the end of list arg1 is reached, and these elements are\n consed into a new list.\n\n If arg2 is not a sublist of arg1, then a copy of arg1 is created.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (PROGN\n  (SETQ X '(A B C D E F . G) Y (CDDDR X))\n  NIL)                                      ==> NIL\n\n X ==> (A B C D E F . G)\n Y ==> (D E F . G)\n\n (LDIFF X Y)              ==> (A B C)\n (LDIFF X '(D E F . G))   ==> (A B C D E F . G)   ; EQUAL but not EQ\n (LDIFF X X)              ==> NIL\n (LDIFF X NIL)            ==> (A B C D E F . G)\n (LDIFF X (CDR X))        ==> (A)\n (LDIFF X (CDDR X))       ==> (A B)\n (LDIFF X 'G)             ==> (A B C D E F)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LENGTH": {"ttr": 4372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%\\x1f\\x17F\\x00&\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-08T17:46:00", "lines": 38, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LENGTH\n\nSyntax:   (LENGTH arg1)\n\n arg1 (required, evaluated) - a proper list.\n\nReturns:\n\n An integer containing the number of elements (CAR's) in the list\n specified by arg1.\n\nProcessing:\n\n The elements of the list are counted and an integer is returned\n containing the total count.  This function does not count all\n atomic elements, only the first-level CAR's.\n\n A dotted pair, a list ending in a dotted pair, or an atom other\n than NIL is invalid and will cause an error to be signalled.\n The length of NIL is zero.\n\nErrors signaled:\n\n Argument not a proper list (see above).\n\nNotes:\n\n The LENGTH function will loop infinitely on circular lists.\n\nExamples:\n\n (LENGTH NIL)                ==> 0\n (LENGTH '(A))               ==> 1\n (LENGTH '(A B C))           ==> 3\n (LENGTH '((A B) C))         ==> 2\n (LENGTH '((A B) (C D)))     ==> 2\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LESSP": {"ttr": 4374, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x17F\\x00C\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:46:00", "lines": 67, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LESSP\n\nSyntax:   (LESSP arg1 arg2)\n    or:   (< arg1 &rest args)\n\n arg1 (required, evaluated) - a number, string or symbol.\n arg2 (required, evaluated) - a number, string or symbol.\n args (optional, evaluated) - a number, string or symbol.\n\nReturns:\n\n For symbols and strings:\n\n  T if the print name of each arg is alphanumerically less than its\n  preceding arg (using the EBCDIC collating sequence), else NIL.\n\n For numbers:\n\n  T if each arg is numerically less than its preceding arg,\n  else NIL.\n\nProcessing:\n\n For LESSP, which takes exactly two args, the following holds:\n\n  If the arguments are EQ, regardless of type, the result is\n  always false (i.e. NIL is returned).\n\n  If both arguments are numbers, a numeric comparison is performed.\n  If the types differ, the appropriate conversion is performed (see\n  member $ARITH for conversion rules) and the numeric compare is done.\n\n  If both arguments are strings or symbols, a character comparison is\n  performed on the string text of the atoms, where the string text of\n  a symbol is its print name.  Case is significant.\n\n For <, which takes any number of args, the result is T if there is only\n one arg, or if all the args are monotonically decreasing (adjacent\n pairs are compared via LESSP); otherwise the result is NIL.\n\nErrors signaled:\n\n Non-atomic argument.\n One argument is a string or symbol and another is a number.\n\nNotes:\n\nExamples:\n\n (LESSP 'FOO 'FOO)      ==> NIL\n (LESSP 'A 'B)          ==> T\n (LESSP 'AAA 'A)        ==> NIL\n (LESSP 'BAR 'BAZ)      ==> T\n (LESSP \"bar\" \"baz\")    ==> T\n (LESSP \"BAR\" 'BAZ)     ==> T\n (LESSP 'BAR  \"BAZ\")    ==> T\n (LESSP 2.0 3)          ==> T\n (LESSP 1 1.0)          ==> NIL\n\n (< 1)                  ==> T\n (< 1 2)                ==> T\n (< 1 2 3)              ==> T\n (< 1 2 3 3)            ==> NIL\n (< 1 2 3 4 5)          ==> T\n (< 1 2 4 3 5)          ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LET": {"ttr": 4376, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x88\\x17O\\x08B\\x00k\\x00s\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1988-06-22T08:42:00", "lines": 107, "newlines": 115, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: LET, LET*\n\nSyntax:   (LET arg1 arg2 ... argn)\n  Also:   (LET* arg1 arg2 ... argn)\n\n The first argument (the list of local variable bindings) is required;\n at least one subsequent argument is required, but any number of\n arguments greater than one may be specified.\n\n arg1 (partially evaluated) - a list of local variable bindings, i.e.\n lists of two elements each, where the first element is a symbol\n (not evaluated) and the second is the value to which the symbol\n is to be bound (evaluated).\n\n argn (conditionally evaluated) - any LISP object.\n\nReturns:\n\n The last of the arguments.\n\nProcessing:\n\n The general format of LET is:\n\n   (LET ((var1 value1) (var2 value2) ... (varn valuen))\n        form1\n        form2\n        ...\n        formn\n   )\n\n in which the \"varn\"'s must be variable names (symbols or destructuring\n templates) and are not evaluated, the \"valuen\"'s are any LISP objects\n and are evaluated when the corresponding variables are bound, and the\n \"formn\"'s are any LISP objects and are evaluated in sequence in the\n binding environment set up by the variable/value pairs.\n\n The first argument is a list of two-element lists (binding\n specifications), of which the CAR (first element) is the name of a\n variable to be local to the body to the LET.  For each of these,\n the variable is initially bound to the value specified as the CDR\n (second element) of the binding specification, and becomes unbound\n when the LET body terminates.\n\n The rest of the forms in the LET constitute the body of the\n LET, and are processed in succession, a la PROGN.  The value\n of the last form in the body is returned as the value of the LET.\n\n LET* is the same as LET, except that LET binds its variables\n sequentially whereas LET* does parallel binding.\n\n In summary:\n\n LET binds each variable in the environment present outside of the LET.\n\n LET* binds each variable in the environment present immediately before\n the variable-value pair, so that each binding can refer to previous\n (but not subsequent) LET variables.\n\nErrors signaled:\n\n Invalid syntax (missing or invalid first argument).\n\nNotes:\n\n Under the current implementation of ZIL, LET is a macro whose expansion\n involves a LAMBDA-expression, e.g.:\n\n (LET ((A VALUE-OF-A)\n       (B (SOME FUNC)))\n      (FORM 1)\n      (FORM 2)\n      (FORM 3))       -->   ((LAMBDA (A B)\n                                     (FORM 1)\n                                     (FORM 2)\n                                     (FORM 3))\n                              VALUE-OF-A\n                              (SOME FUNC))\n\n LET* expands into a series of nested LET's (lambda-expressions).\n\n Declarations are processed so that they refer to the appropriate\n variable bindings.\n\n These techniques enforce the variable binding strategies.\n\nExamples:\n\n\n (LET ((A '(1 2 3 4))\n       (B '(5 6 7 8))\n       (C NIL)\n       (D NIL)\n      )\n      (SETQ C (CAR A))\n      (SETQ D (CAR B))\n      (+ C D)\n )                         ==>  6\n\n\n (SETQ A \"a\")          ==> \"a\"\n (SETQ B \"b\")          ==> \"b\"\n\n (LET  ((A (LIST A)) (B A)) (LIST A B))  ==>  ((\"a\") \"a\")\n (LET* ((A (LIST A)) (B A)) (LIST A B))  ==>  ((\"a\") (\"a\"))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIST": {"ttr": 4378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%\\x1f\\x17H\\x00:\\x00:\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-08T17:48:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LIST, LIST*\n\nSyntax:   (LIST &rest args)\n  Also:   (LIST* &rest args)\n\n Any number of arguments may be specified.\n\n arg (evaluated) - any LISP object.\n\nReturns:\n\n For LIST:   a proper list (arg1 arg2 ... argn).\n\n For LIST*:  a list (arg1 arg2 ... argm . argn), ending in a dotted\n             pair of the last 2 args.\n\nProcessing:\n\n The arguments are CONS'ed in succession to build the list out of\n new cells.\n\n LIST always returns a proper list; (LIST) returns NIL.\n\n LIST* returns a list ending in a dotted pair; (LIST* a) returns a,\n but (LIST*) is an error.\n\nErrors signaled:\n\n Errors detected by CONS (q.v.).\n No arguments on LIST*.\n\nNotes:\n\n (LIST 'a 'b 'c) is equivalent to (QUOTE (a b c)) in the interpretive\n environment, but in the compiled environment the former builds a new\n list out of CONS cells each time it is executed, while the latter\n creates an in-line constant list in the load module whose address is\n loaded.  If the list may be modified during execution of the program,\n you MUST use the LIST form rather than the QUOTE form.\n\nExamples:\n\n (LIST)                 ==> NIL\n (LIST NIL)             ==> (NIL)\n (LIST 'A)              ==> (A)\n (LIST 'A 'B)           ==> (A B)\n (LIST '(A B) 'C)       ==> ((A B) C)\n (LIST 'A '(B C))       ==> (A (B C))\n (LIST 1 2 3 4 5 6 7)   ==> (1 2 3 4 5 6 7)\n\n (LIST* NIL)            ==> NIL\n (LIST* 'A)             ==> A\n (LIST* 'A 'B)          ==> (A . B)\n (LIST* '(A B) 'C)      ==> ((A B) . C)\n (LIST* 'A '(B C))      ==> (A B C)    ; note same as (A . (B C))\n (LIST* 1 2 3 4 5 6 7)  ==> (1 2 3 4 5 6 . 7)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTIFY": {"ttr": 4380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87&\\x0f\\x07&\\x00>\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-17T07:26:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: LISTIFY\n\nSyntax:   (LISTIFY &optional arg1)\n\n arg1 (optional, evaluated) - NIL or an integer.\n\nReturns:\n\n If arg1 is omitted or NIL, the list of arguments to the currently\n active LEXPR.\n\n If arg1 is a positive integer, a list of the first arg1 arguments\n to the currently active LEXPR.\n\n If arg1 is a negative integer, a list of the last arg1 arguments\n to the currently active LEXPR.\n\nProcessing:\n\n If n is greater than the number of arguments, the entire list of\n arguments is returned.\n\nErrors signaled:\n\n LISTIFY issued outside a LEXPR.\n Invalid argument.\n\nNotes:\n\n No error checking is done in compiled code.  Results are unpredictable\n if an invalid argument is passed.\n\n See member $LEXPR for information about LEXPR's.\n\nExamples:\n\n (defun foo x\n  (declare (special y))\n  (listify y)\n )                     ==> FOO\n\n (defun bar (y z)\n  (declare (special y))\n  (apply #'foo z)\n )                     ==> BAR\n\n (bar nil nil)         ==> NIL\n (bar nil '(a))        ==> (A)\n (bar nil '(a b))      ==> (A B)\n (bar 0   '(a b c d))  ==> NIL\n (bar 1   '(a b c d))  ==> (A)\n (bar 2   '(a b c d))  ==> (A B)\n (bar 3   '(a b c d))  ==> (A B C)\n (bar 4   '(a b c d))  ==> (A B C D)\n (bar 5   '(a b c d))  ==> (A B C D)\n (bar -1  '(a b c d))  ==> (D)\n (bar -2  '(a b c d))  ==> (C D)\n (bar -3  '(a b c d))  ==> (B C D)\n (bar -4  '(a b c d))  ==> (A B C D)\n (bar -5  '(a b c d))  ==> (A B C D)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTP": {"ttr": 4382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x1f\\x17H\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-08T17:48:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LISTP\n\nSyntax:   (LISTP arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a list, otherwise NIL.\n\nProcessing:\n\n NIL, conses and dotted pairs all satisfy this predicate.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (LISTP 'FOO)            ==> NIL\n (LISTP NIL)             ==> T\n (LISTP '(NIL))          ==> T\n (LISTP \"hi there\")      ==> NIL\n (LISTP '(A B C))        ==> T\n (LISTP #(A B C))        ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLKEYWDP": {"ttr": 4384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x861_\\x00\\x87%\\x1f\\x17I\\x00)\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-11-11T00:00:00", "modifydate": "1987-09-08T17:49:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LLKEYWDP\n\nSyntax:   (LLKEYWDP arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a \"lambda list keyword\", otherwise NIL.\n\nProcessing:\n\n A \"lambda list keyword\" is any symbol the first character of whose\n print name is an ampersand.  Lambda list keywords are exactly like\n other symbols, except that when they occur in lambda lists they\n have special meaning; they cannot represent variables.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This is used by ZIL when it processes LAMBDA argument lists.\n\n The fact that a given symbol is LLKEYWDP does not necessarily mean\n that it is valid in a lambda list; an error is signalled if an\n symbol beginning with & appears in a lambda list that is not\n meaningful to ZIL (i.e. not &OPTIONAL, &REST, &AUX, etc.).\n\nExamples:\n\n (LLKEYWDP 'FOO)       ==> NIL\n (LLKEYWDP 123)        ==> NIL\n (LLKEYWDP '&OPTIONAL) ==> T\n (LLKEYWDP '&FOO)      ==> T\n (LLKEYWDP '|&|)       ==> T\n (LLKEYWDP \"&foo\")     ==> NIL\n (LLKEYWDP '(&A B C))  ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLVARS": {"ttr": 4386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x08\\x03\\x00-\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:03:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LLVARS\n\nSyntax:   (LLVARS bvl1)\n\n bvl1 (required, evaluated) - a \"lambda list\" (an atom or list which\n                              is valid in the argument list position\n                              of a LAMBDA expression).\n\nReturns:\n\n A list of all the variable names (symbols) specified in bvl1.\n\nProcessing:\n\n All of the symbols that name variables (formal parameters) in the\n lambda list specified by bvl1 are returned.  These include required\n and optional argument names, &REST and &AUX\n variable names, keyword variable names (not the keywords), and any\n \"supplied-p\" arguments.\n\n For any of the above, if the \"variable\" is actually a destructuring\n template, all of the constituent symbols that name parameters to\n destructure into are returned.  NIL is never returned.\n\nErrors signaled:\n\n Invalid lambda list syntax.\n\nNotes:\n\n This function is used by ZIL when it needs to analyze a lambda list\n (e.g. when parsing SPECIAL declarations in macros).\n\nExamples:\n\n (LLVARS NIL)          ==> NIL\n (LLVARS 'X)           ==> (X)\n (LLVARS '(A B C))     ==> (C B A)\n (LLVARS '(A &OPTIONAL B &REST C &AUX D))      ==> (D C B A)\n (LLVARS '(&OPTIONAL (O1 O2 O3) &AUX (A1 A2))) ==> (A1 O3 O1)\n (LLVARS '(&KEY K1 (K2 K3) ((:K4 K5) K6 K7)))   ==> (K5 K7 K2 K1)\n (LLVARS '((A1 A2) (NIL (B1 . B2)) &REST (Z1 Z2 Z3)))\n         ==> (Z3 Z2 Z1 B2 B1 A2 A1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOAD": {"ttr": 4388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%\\x1f\\x17X\\x00E\\x00;\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-08T17:58:00", "lines": 69, "newlines": 59, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOAD\n\nSyntax:   (LOAD dsn1 &key verbose print if-does-not-exist)\n\n dsn1  (required, evaluated) - a symbol.\n verbose\n       (optional, evaluated) - any LISP object (but generally T or NIL).\n print\n       (optional, evaluated) - any LISP object (but generally T or NIL).\n if-does-not-exist\n       (optional, evaluated) - any LISP object (but generally T or NIL).\n\nReturns:\n\n If the keyword :if-does-not-exist is given a value of NIL, and the\n data set specified by dsn1 does not exist, NIL.  Otherwise T, after\n executing a READ-EVAL-PRINT loop over the data set specified by dsn1.\n\nProcessing:\n\n dsn1, which should be a string, is interpreted as a data set name in\n standard TSO format (quoted or unquoted, member name present or\n absent).  Translation to all upper case is done automatically.\n This data set is dynamically allocated and opened for input.\n\n An S-expression is read from the data set; it is evaluated and the\n result is printed to standard output if the keyword :print is given\n a non-NIL value.  This process is repeated\n until end-of-file is reached on the data set or the form (END) is read.\n\n If the keyword :verbose is given a non-NIL value, a message is\n displayed at the start of the load operation identifying the data set\n being loaded.  If that keyword is given a value of NIL, the message\n is not displayed.  The default behavior is determined by the value\n of the global variable *LOAD-VERBOSE*, which is initially T.\n\n If the keyword :if-does-not-exist is given a non-NIL value, which is\n the default, LOAD will error out if the data set specified by dsn1\n does not exist.  However, if :if-does-not-exist is given a value of\n NIL, then LOAD will not error out if the data set can't be found.\n Instead, it will just return NIL.\n\nErrors signaled:\n\n Errors detected by OPEN and READ-EVAL-PRINT.\n\n Note:  Errors detected by READ, EVAL, and PRINT are trapped.\n\nNotes:\n\n The form (END), when coded as is, is a termination signal to LOAD.\n Since it is not actually a function, it cannot be embedded within\n another function or generated by a macro, and it can have no operands.\n\n LOAD is used in the interpretive environment to \"load\" a sequential\n dataset (or PDS member) of interpretive function definitions, macros,\n or whatever you wish.\n\n See INTRPRET for more information.\n\nExamples:\n\n (Watch the quote marks carefully!)\n\n  (LOAD \"cmd.lisp(myfunc)\")\n  (LOAD \"'someone.elses.dataset'\")\n  (LOAD \"'PROGLIB.ZIL.SOURCE($CL)'\" :PRINT T :VERBOSE NIL)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCALLY": {"ttr": 4390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x17D\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:44:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: LOCALLY\n\nSyntax:   (LOCALLY declarations &body body)\n\nReturns:\n\n The value of the last form in body.\n\nProcessing:\n\n This provdes a way of associating declarations with one or more\n forms without having to provide a binding construct like LET or\n LAMBDA.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (SET 'A 'FOO)                                 ==> FOO\n (LOCALLY (DECLARE (SPECIAL A)) A)             ==> FOO\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOG": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x7f\\x00\\x87%/\\x07F\\x005\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-26T00:00:00", "modifydate": "1987-09-09T07:46:00", "lines": 53, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOG\n\nSyntax:   (LOG num1 &optional base2)\n\n num1  (required, evaluated) - a number.\n base2 (optional, evaluated) - a number.\n\nReturns:\n\n A number which is the logarithm of num1, to the base base2 if base2 is\n specified, otherwise to the base E.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the value.\n If num1 is a single-precision flonum and base2 is omitted, or num1 and\n base2 are both single-precision flonums, or one is an integer and the\n other is a single-precision flonum, the result is a single-precision\n flonum; otherwise the result is a double-precision flonum.\n\nErrors signaled:\n\n Non-numeric argument.\n num1 is zero or negative.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\n\nExamples:\n\n (LOG (EXP 1))     ==> 1.0\n (LOG 1)           ==> 0.0\n (LOG 1.0)         ==> 0.0\n (LOG 1.0F0)       ==> 0.0F0\n (LOG 0)           ==> (\"***ERROR***\")\n (LOG -1)          ==> (\"***ERROR***\")\n (LOG 100)         ==> 4.60517018\n (LOG 100 10)      ==> 2.0\n (LOG 8 2)         ==> 3.0\n (LOG 8 2.0F0)     ==> 2.999999F0\n (LOG 8 2.0)       ==> 3.0\n (LOG 8.0F0 2)     ==> 2.999999F0\n (LOG 8.0F0 2.0F0) ==> 2.999999F0\n (LOG 8.0F0 2.0)   ==> 2.99999932\n (LOG 8.0 2)       ==> 3.0\n (LOG 8.0 2.0F0)   ==> 2.9999999\n (LOG 8.0 2.0)     ==> 3.0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGAND": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%/\\x07Y\\x00\\x1f\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-09T07:59:00", "lines": 31, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOGAND\n\nSyntax:   (LOGAND &rest args)\n\n argn (optional, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical AND operation performed on\n the args in succession.\n\nProcessing:\n\n This is a fixnum-only operation.\n (LOGAND) returns -1, which is an identity for this operation.\n\nErrors signaled:\n\n arg not a fixnum.\n\nNotes:\n\nExamples:\n\n (LOGAND)               ==> -1\n (LOGAND 255)           ==> 255\n (LOGAND 255 127)       ==> 127\n (LOGAND 255 127 63)    ==> 63\n (LOGAND 255 127 63 31) ==> 31\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGBITP": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x07\\x8f\\x00\\x88\\x10_\\x13\\x14\\x004\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-03-18T00:00:00", "modifydate": "1988-04-14T13:14:00", "lines": 52, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOGBITP\n\nSyntax:   (LOGBITP arg1 arg2)\n\n arg1 (required, evaluated) - a non-negative integer.\n arg2 (required, evaluated) - an integer.\n\nReturns:\n\n T or NIL, depending on whether the arg1'th bit (counting from the\n right and starting with zero) is a 1 in arg2.\n\nProcessing:\n\n This is an integer-only operation.\n arg1 is a bitwise \"index\" into arg2 (i.e. arg1 signifies the bit\n that is on in the integer (expt 2 arg1).  If the corresponding bit\n in arg2 is on, then T is returned, else NIL is returned.\n\n If arg2 is negative, a two's-complement representation of arg2 is\n used to determine the bit setting.\n\nErrors signaled:\n\n arg1 not a non-negative integer.\n arg2 not a integer.\n\nNotes:\n\nExamples:\n\n (LOGBITP 0 1)            ==> T\n (LOGBITP 1 1)            ==> NIL\n (LOGBITP 2 1)            ==> NIL\n (LOGBITP 0 2)            ==> NIL\n (LOGBITP 1 2)            ==> T\n (LOGBITP 2 1)            ==> NIL\n (LOOP FOR I FROM 0 TO 31 COUNT (LOGBITP I 0))    ==> 0\n (LOOP FOR I FROM 0 TO 31 COUNT (LOGBITP I -1))   ==> 32\n (DEFUN FOO (X)\n  (DO ((H (HAULONG X))\n       (I 0 (1+ I))\n       (Z NIL (CONS (LOGBITP I X) Z)))\n      ((>= I H) Z)))      ==> FOO\n (FOO #B101001)           ==> (T NIL T NIL NIL T)\n (FOO #B111101)           ==> (T T T T NIL T)\n\n (LOGBITP 63 1)           ==> NIL\n (LOGBITP 64 1)           ==> NIL\n (LOGBITP 65 1)           ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGCOUNT": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10_\\x00\\x88\\x10_\\x13(\\x006\\x006\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-14T00:00:00", "modifydate": "1988-04-14T13:28:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOGCOUNT\n\nSyntax:   (LOGCOUNT arg1)\n\n arg1 (required, evaluated) - an integer.\n\nReturns:\n\n If arg1 is non-negative, an integer containing the number of 1-bits in\n arg1.  If arg1 is negative, an integer containing the number of 0-bits\n in the two's-complement representation of arg1.\n\nProcessing:\n\n This is an integer-only operation.\n The number of 1-bits in the binary representation of arg1 is counted\n and returned as an integer.\n\n If arg2 is negative, the number of 0-bits is counted, rather than the\n number of 1-bits.  A two's-complement representation of arg2 is used to\n determine the bit count, assuming that the number contains 1-bits\n infinitely out to the left end.\n\nErrors signaled:\n\n arg1 not an integer.\n\nNotes:\n\nExamples:\n\n (LOGCOUNT 0)               ==> 0\n (LOGCOUNT 1)               ==> 1\n (LOGCOUNT 2)               ==> 1\n (LOGCOUNT 3)               ==> 2\n (LOGCOUNT #B1010101)       ==> 4\n (LOGCOUNT #B0101010)       ==> 3\n (LOGCOUNT 2147483647)      ==> 31\n (LOGCOUNT 2147483648)      ==> 1\n (LOGCOUNT 2147483649)      ==> 2\n (LOGCOUNT (** 2 99))       ==> 1\n (LOGCOUNT (1- (** 2 99)))  ==> 99\n (LOGCOUNT (1+ (** 2 99)))  ==> 2\n\n (LOGCOUNT -1)              ==> 0   ; like X'FFFFFFFF'\n (LOGCOUNT -2)              ==> 1   ; like X'FFFFFFFE'\n (LOGCOUNT -2147483647)     ==> 30  ; like X'80000001'\n (LOGCOUNT -2147483648)     ==> 31  ; like X'80000000'\n (LOGCOUNT -2147483649)     ==> 1   ; like X'...FFFFFFFE FFFFFFFF'\n (LOGCOUNT (** -2 99))      ==> 99\n (LOGCOUNT (1- (** -2 99))) ==> 1\n (LOGCOUNT (1+ (** -2 99))) ==> 98\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGIOR": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x05_\\x00\\x87%/\\x08\\x01\\x00 \\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-24T00:00:00", "modifydate": "1987-09-09T08:01:00", "lines": 32, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOGIOR\n\nSyntax:   (LOGIOR &rest args)\n\n argn (optional, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical OR operation performed on\n the args in succession.\n\nProcessing:\n\n This is a fixnum-only operation.\n (LOGIOR) returns 0, which is an identity for this operation.\n\nErrors signaled:\n\n arg not a fixnum.\n\nNotes:\n\n\nExamples:\n\n (LOGIOR) ==> 0\n (LOGIOR 256) ==> 256\n (LOGIOR 256 128) ==> 384\n (LOGIOR 256 128 64) ==> 448\n (LOGIOR 256 128 64 32) ==> 480\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGNOT": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x11\\x1f\\x00\\x88\\x15_\\x10\\x18\\x00\\x1f\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-04-21T00:00:00", "modifydate": "1988-06-03T10:18:00", "lines": 31, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOGNOT\n\nSyntax:   (LOGNOT arg1)\n\n arg1 (required, evaluated) - an integer\n\nReturns:\n\n An integer containing the result of a complement operation performed on\n arg1 - i.e. changing 0-bits to 1-bits and vice versa.\n\nProcessing:\n\n This is an integer-only operation.  If arg1 is negative, the\n operation is performed on the two's-complement representation.\n (LOGNOT a) is equivalent to (LOGXOR a -1).\n\nErrors signaled:\n\n arg1 not an integer.\n\nNotes:\n\nExamples:\n\n (LOGNOT 0) ==> -1\n (LOGNOT -1) ==> 0\n (LOGNOT #zf00ff00f) ==> #z0ff00ff0\n (LOGNOT #xf00f00f00f00f00f00f00)  ==> #x-f00f00f00f00f00f00f01\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGTEST": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x11\\x1f\\x00\\x88\\x15_\\x10 \\x00&\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-04-21T00:00:00", "modifydate": "1988-06-03T10:20:00", "lines": 38, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOGTEST\n\nSyntax:   (LOGTEST arg1 arg2)\n\n arg1 (required, evaluated) - an integer.\n arg2 (required, evaluated) - an integer.\n\nReturns:\n\n T or NIL, depending on whether any of the 1-bits contained in arg1\n are also 1 in arg2.\n\nProcessing:\n\n This is an integer-only operation.\n (LOGTEST a b) is equivalent to (NOT (ZEROP (LOGAND a b))).\n\nErrors signaled:\n\n arg1 not an integer.\n\nNotes:\n\n This is kind of like the IBM/370 Test Under Mask instruction.\n\nExamples:\n\n (LOGTEST 0 0)            ==> NIL\n (LOGTEST #X1 27)         ==> T\n (LOGTEST #X1 28)         ==> NIL\n (LOGTEST #b1111 #b10000) ==> NIL\n (LOGTEST #b1010 #b01001) ==> T\n (LOGTEST #xf00f00f00f00f00f00f00f00\n          #x00f00f00f00f00f00f00f00f)    ==> NIL\n (LOGTEST #xf00f00f00f00f00f00f00f00\n          #x00f00f00f00f00f00f00f10f)    ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGXOR": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%/\\x08\\x02\\x00 \\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-09T08:02:00", "lines": 32, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOGXOR\n\nSyntax:   (LOGXOR &rest args)\n\n argn (optional, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical XOR (exclusive or)\n operation performed on the args in succession.\n\nProcessing:\n\n This is a fixnum-only operation.\n (LOGXOR) returns 0, which is an identity for this operation.\n\nErrors signaled:\n\n arg not a fixnum.\n\nNotes:\n\n\nExamples:\n\n (LOGXOR) ==> 0\n (LOGXOR 2730) ==> 2730\n (LOGXOR 2730 2650) ==> 240\n (LOGXOR 2730 2650 1365) ==> 1445\n (LOGXOR 2730 2650 1365 43690) ==> 44815\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOOP": {"ttr": 4625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%/\\x08\\x16\\x00V\\x00J\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-09T08:16:00", "lines": 86, "newlines": 74, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: LOOP\n\nSyntax:   (LOOP forms)\n\n forms: see below.\n\nReturns:\n\n Depends on what the forms are.\n\nProcessing:\n\n This is the generalized looping macro; versions of this are present\n in Maclisp and NIL, but it has not become standardized in Common LISP\n as yet.  Some examples follow below.\n\n ZIL currently supports the following LOOP keywords:\n\n FOR clauses including IN, ON, FROM, TO, DOWNTO, BY, =, THEN keywords\n WITH clauses including the = keyword\n\n DO, INITIALLY, FINALLY\n\n IF, WHEN, UNLESS (including ELSE clauses)\n\n WHILE, UNTIL, RETURN\n\n ALWAYS, NEVER, THEREIS\n\n COLLECT, NCONC, APPEND (including the INTO subkeyword)\n\n SUM, COUNT, MAXIMIZE, MINIMIZE (including theINTO subkeyword)\n\n PUSH (similar to COLLECT but CONSes onto front of list being built)\n\n .. and -ING forms of the above where appropriate.\n\n AS is synonymous with FOR.\n\n If no LOOP keyword is present, DO is assumed where appropriate.\n\n Destructuring is also supported.\n\n Type declarations (... FOR X FIXNUM ...) are accepted but ignored.\n\nErrors signaled:\n\n Syntax errors - invalid, misplaced or unsupported keywords, etc.\n\nNotes:\n\n For an in-depth discussion of LOOP, refer to one of the following:\n\n  The Revised Maclisp Manual (K. Pitman)\n  NIL Reference Manual (Burke, Carrette, Eliot)\n\n ZIL does not yet support all of the features described therein,\n though most of the Maclisp-documented features are present.\n\n It is the intention of the ZIL developers to add to the capability\n of the LOOP macro as time goes by.  Right now it is set up for\n minimal support of most outside code.\n\nExamples:\n\n (LOOP FOR X IN '(A B C) COLLECT (CONS X X))\n                          ==> ((A . A) (B . B) (C . C))\n\n (LOOP FOR I FROM 1 TO 10 NCONC (LIST (+ I 100)))\n                          ==> (101 102 103 104 105 106 107 108 109 110)\n\n (LOOP FOR X IN '(A B C D E F G)\n       UNLESS (EQ X 'E) COLLECT X INTO Z\n       FINALLY (RETURN (NREVERSE Z)))\n                          ==> (G F D C B A)\n\n (LOOP FOR X ON '(A B C D E F G H) BY #'CDDR\n       COLLECT (CAR X)\n       UNTIL (EQ (CAR X) 'E))\n                          ==> (A C E)\n\n (LOOP FOR X IN (OBLIST) ALWAYS (ATOM X)) ==> T\n\n (LOOP FOR I FROM 10 DOWNTO 1 NEVER (> I 10)) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOR": {"ttr": 4627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x17D\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:44:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LOR\n\nSyntax:   (LOR arg1 arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical inclusive OR operation\n performed on arg1 and arg2.\n\nProcessing:\n\n This is a fixnum-only operation.\n\nErrors signaled:\n\n arg1 or arg2 not a fixnum.\n\nNotes:\n\n LOGOR performs the logical OR function on any number of arguments.\n\nExamples:\n\n (LOR 7 5)               ==> 7\n (LOR 5 -2)              ==> -1\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LSH": {"ttr": 4629, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87$o\\x07T\\x004\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-03T07:54:00", "lines": 52, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LSH\n\nSyntax:   (LSH arg1 arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical shift operation performed\n on arg1, with arg2 specifying the number of bits to shift (left if\n positive, right if negative).\n\nProcessing:\n\n A logical shift operation is performed on the numeric contents of arg1\n (not in place), with arg2 determining the amount and direction of the\n shift.\n\n If arg2 is positive, a left shift of N bits takes place, with N being\n the absolute value of the fixnum arg2.\n\n If arg2 is negative, a right shift of N bits takes place, with N being\n the absolute value of the fixnum arg2.\n\n If arg2 is zero, no shift takes place, but arg1 is returned.\n\n The arguments and the result are always fixnums.  This means that\n 1-bits will be shifted out according to the rules of the IBM/370 SLL or\n SRL instruction.  A \"bignum\" is never produced by this function.\n\nErrors signaled:\n\n First argument not a fixnum.\n Second argument not a fixnum.\n\nNotes:\n\n Compare ASH, which does an arithmetic shift.  ASH and LSH differ when\n arg1 is negative and a right shift is performed; ASH propagates the\n sign bit while LSH fills in with zero bits on the left.\n\nExamples:\n\n (LSH 10 0)      ==> 10\n (LSH 10 1)      ==> 20\n (LSH 10 2)      ==> 40\n (LSH 96 -3)     ==> 12\n (LSH -1 1)      ==> -2            ;  i.e. FFFFFFFF goes to FFFFFFFE\n (LSH -1 -1)     ==> 2147483647    ;  i.e. FFFFFFFF goes to 7FFFFFFF\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LXOR": {"ttr": 4631, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x8f\\x00\\x87%\\x1f\\x17D\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-28T00:00:00", "modifydate": "1987-09-08T17:44:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: LXOR\n\nSyntax:   (LXOR arg1 arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical exclusive OR operation\n performed on arg1 and arg2.\n\nProcessing:\n\n This is a fixnum-only operation.\n\nErrors signaled:\n\n arg1 or arg2 not a fixnum.\n\nNotes:\n\n LOGXOR performs the logical XOR function on any number of arguments.\n\nExamples:\n\n (LXOR 7 5)              ==> 2\n (LXOR 5 -2)             ==> -5\n (LXOR 1234 1234)        ==> 0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAKNAM": {"ttr": 4633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x04\\x9f\\x00\\x87%/\\x08\\x18\\x00/\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-18T00:00:00", "modifydate": "1987-09-09T08:18:00", "lines": 47, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAKNAM\n\nSyntax:   (MAKNAM arg1)\n\n arg1 (required, evaluated) - a proper list of atoms.\n\nReturns:\n\n An uninterned symbol whose print name consists of the characters in the\n list specified by arg2, concatenated to form a new atom name.\n\nProcessing:\n\n The CAR's of arg1, which must be a non-null list of fixnums, strings\n and/or symbols, are converted as follows:\n\n  For a fixnum, its EBCDIC character equivalent is obtained.\n  For a string, its first character is obtained.\n  For a symbol, the first character of its print name is obtained.\n\n These are concatenated to build an uninterned symbol whose print name\n is the string resulting from the concatenation.\n\n arg1 may be NIL, in which case a symbol with a null print name is\n returned.\n\nErrors signaled:\n\n arg1 not a list of atoms (nested lists and vectors are not permitted).\n An object other than a fixnum, string or symbol was encountered.\n\nNotes:\n\n Compare IMPLODE, which is identical but creates an interned symbol.\n\nExamples:\n\n (MAKNAM NIL)                  ==> ||\n (MAKNAM '(A))                 ==> A\n (MAKNAM '(F O O))             ==> FOO\n (MAKNAM '(FOO BAR))           ==> FB\n (MAKNAM '(#/a #/b \"c\"))       ==> |abc|\n\n (SETQ A (MAKNAM '(F O O)))    ==> FOO\n (EQ A 'FOO)                   ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKNUM": {"ttr": 4635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x11\\x1f\\x00\\x87%/\\x08\\x19\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-04-21T00:00:00", "modifydate": "1987-09-09T08:19:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAKNUM\n\nSyntax:   (MAKNUM arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A fixnum whose contents represent the virtual address of arg1.\n\nProcessing:\n\n The address of the object specified by arg1 is interpreted as a\n fixnum and returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This function is useless, but some hacks from other LISPs use this.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAKUNBOU": {"ttr": 4637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x07\\x1f\\x00\\x88\\x12O\\x08\\x10\\x00N\\x00?\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-03-12T00:00:00", "modifydate": "1988-05-03T08:10:00", "lines": 78, "newlines": 63, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAKUNBOUND\n\nSyntax:   (MAKUNBOUND arg1)\n    or:   (MAKUNBOU   arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n arg1, after removing the current binding thereof (whether dynamic\n or global).\n\nProcessing:\n\n The variable specified by arg1 must have one of the following:\n\n  (1) a current dynamic (special) binding.\n\n  (2) a current global binding (as assigned by DEFVAR, for example).\n\n If it does, that binding is undone.  Global bindings are always\n undone, and only the current dynamic or DEFVAR binding, if one exists,\n is undone.\n\n What \"undone\" means in this context is NOT that the binding is removed;\n rather, the binding is made valueless.  This means that while the\n current binding remains active, the symbol will have no value.  If\n the current binding shadows another binding, then when the current\n binding scope is exited the previous binding will have effect again.\n\nErrors signaled:\n\n Arg not a symbol.\n\nNotes:\n\n Remember that the argument to MAKUNBOUND is evaluated.\n\n See BOUNDP, DEFVAR, SETQ and SYMEVAL for more information.\n\nExamples:\n\n(progn\n (setplist 'a nil)                ; Remove any funny properties.\n (makunbound 'a)\n)                           ==> A ; Insure A not bound.\n\n(boundp 'a)                 ==> NIL\n(defvar a 'foo)             ==> A\na                           ==> FOO\n(makunbound 'a)             ==> A\na                           ==> (\"***ERROR***\") ; Unbound variable - A\n\n(let ((a 1) (b 2))\n     (declare (special a))\n     (boundp 'a))           ==> T\n\n(let ((a 1) (b 2))\n     (declare (special a))\n     (makunbound 'a)\n     (boundp 'a))           ==> NIL\n\n(let ((a 1) (b nil))\n     (declare (special a))\n     (let ((a 2))\n          (declare (special a))\n          (push (if (boundp 'a) a nil) b)\n          (makunbound 'a)\n          (push (if (boundp 'a) a nil) b)\n     )\n     (push (if (boundp 'a) a nil) b)\n     (makunbound 'a)\n     (push (if (boundp 'a) a nil) b)\n     (nreverse b)\n)\n                           ==> (2 nil 1 nil)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "MAPAND": {"ttr": 4639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x082\\x007\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:32:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPAND\n\nSyntax:   (MAPAND arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n NIL if any of the values produced by applying the first argument\n function to successive elements (CAR's) of the other argument lists\n are NIL, else the last value thus generated.\n\nProcessing:\n\n The function specified by the first argument is applied to each of the\n elements (CAR's) of the lists specified by the other arguments, until\n one of the lists is exhausted or a value of NIL is produced by this\n application.  When the latter occurs, MAPAND returns NIL.\n\n If all the elements return non-NIL values when the function is applied,\n the last value is returned (i.e. the value produced by applying the\n function to the last CAR's of the lists).\n\n If any of the list arguments is NIL, MAPAND returns T, by definition.\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\nExamples:\n\n (MAPAND #'ATOM NIL)               ==> T\n (MAPAND #'ATOM '(A B C D E F))    ==> T\n (MAPAND #'ATOM '(A B C D (E F)))  ==> NIL\n (MAPAND #'EQ '(A B C) '(A B C))   ==> T\n (MAPAND #'EQ '(A B C) '(A C B))   ==> NIL\n (MAPAND #'EQ '(A B C) '(A)    )   ==> T\n\n (MAPAND #'(LAMBDA (X) (EQ X 'FOO)) '(FOO FOO FOO))  ==> T\n\n (MAPAND #'(LAMBDA (X) (EQ X 'FOO)) '(FOO BAR BAZ))  ==> NIL\n\n (MAPAND #'(LAMBDA (X) (IF (= X 1) 'FOO 'BAR))\n         '(1 2 3 2 1))                              ==> FOO\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPATOMS": {"ttr": 4641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x08\\x10\\x00\"\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:10:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPATOMS\n\nSyntax:   (MAPATOMS fun1)\n\n fun1 (required, evaluated) - a function that can be APPLY'd.\n\nReturns:\n\n NIL, after applying fun1 to every interned symbol on the oblist.\n\nProcessing:\n\n This is a lot like (MAPC #'fun1 (OBLIST)) would be, except that\n returns NIL.\n\nErrors signaled:\n\n Only those signalled by fun1 or FUNCALL\n\nNotes:\n\n Unfortunately, there is no function like MAPATOMS that corresponds\n to (MAPCAR #'fun1 (OBLIST)).  Maybe there should be one.\n\nExamples:\n\n (let ((z 0))\n      (mapatoms #'(lambda (x)\n                          (case x\n                                ((foo bar baz)\n                                 (incf z))\n                                (t nil))))\n      z)  ==> 3\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPC": {"ttr": 4643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x086\\x00?\\x008\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:36:00", "lines": 63, "newlines": 56, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPC\n\nSyntax:   (MAPC arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n arg2, after applying the function specified by arg1 to the last\n elements of the lists specified by the other arguments.\n\nProcessing:\n\n The function specified by arg1 is applied to each of the elements\n (CAR's) of the lists specified by the other arguments.  The first or\n only input list is returned as the value of the MAPC call.\n\n Processing ends as soon as one of the lists is exhausted\n (i.e. becomes NIL).\n\n Generally, the function is used for its side effects and not for\n the values returned thereby.\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\nExamples:\n\n (let ((a nil))\n      (list\n       (mapc #'(lambda (x) (push (cons x x) a)) '(1 2 3 4 5))\n       a))\n            ==> ((1 2 3 4 5) ((5 . 5) (4 . 4) (3 . 3) (2 . 2) (1 . 1)))\n\n (let ((a nil))\n      (mapc #'(lambda (x y) (push (+ x y) a)) '(1 2 3) '(10 20 30))\n      a)\n            ==> (33 22 11)\n\n;\n;(MAPC #'PRINT '(A B C D E))\n;\n;prints:\n;\n;  A\n;  B\n;  C\n;  D\n;  E\n;\n;on the standard output file.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPCAN": {"ttr": 4645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x088\\x008\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:38:00", "lines": 56, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPCAN\n\nSyntax:   (MAPCAN arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n A list of values generated by NCONC'ing the results of the applications\n of the function specified by the first argument to the elements of the\n lists specified by the other arguments.\n\nProcessing:\n\n The function specified by the first argument is applied to each of\n the elements (CAR's) of the lists specified by the other arguments;\n it is assumed that a list (which may be NIL) is returned by each\n application.  The results are destructively attached via NCONC to\n create a list of all the values as they are generated, and returned\n as the value of the MAPCAN call.\n\n Processing ends as soon as one of the lists is exhausted\n (i.e. becomes NIL).\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\n Results are unpredictable (and likely to be disastrous) if the\n function, when applied to an element of the list, returns an atom\n rather than NIL or a proper list.\n\n Since NCONC is applied to the results of the function calls, be\n careful not to specify a function - such as CDR or (LAMBDA (X) X) -\n that returns the actual element or a sublist thereof; such usage\n will corrupt the elements of the list.\n\nExamples:\n\n (MAPCAN #'(LAMBDA (X) (APPEND X NIL)) '((A B C) (D E) (F) NIL (G H)))\n                         ==>  (A B C D E F G H)\n\n (mapcan #'(lambda (x y) (if (eq x y) nil (list x y)))\n         '(the quick brown fox) '(the slow brown ooze))\n           ==> (quick slow fox ooze)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPCAR": {"ttr": 4647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x089\\x002\\x003\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:39:00", "lines": 50, "newlines": 51, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPCAR\n\nSyntax:   (MAPCAR arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n The list of values generated by the application of the function\n specified by the first argument to the elements of the lists specified\n by the other arguments.\n\nProcessing:\n\n The function specified by the first argument is applied to each of\n the elements (CAR's) of the lists specified by the other arguments.\n A list is built of these values as they are generated, and returned\n as the value of the MAPCAR call.\n\n Processing ends as soon as one of the lists is exhausted\n (i.e. becomes NIL).\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\nExamples:\n\n (MAPCAR #'CAR '((A B) (C D) (E F)))  ==> (A C E)\n\n (MAPCAR #'(LAMBDA (X) (CONS X X)) '(A B C D E))\n                         ==>  ((A . A) (B . B) (C . C) (D  . D) (E . E))\n\n (MAPCAR #'CONS '(A B C) '(D E F))    ==> ((A . D) (B . E) (C . F))\n\n (MAPCAR #'+ '(1 2 3 4) '(50 60))   ==> (51 62)\n\n (MAPCAR #'(LAMBDA (A B C) (LIST A B C))\n         '(1 2 3) '(4 5 6) '(7 8 9)) ==> ((1 4 7) (2 5 8) (3 6 9))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPCON": {"ttr": 4649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x08A\\x00;\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:41:00", "lines": 59, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPCON\n\nSyntax:   (MAPCON arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n A list of values generated by NCONC'ing the results of the applications\n of the function specified by the first argument to the sublists of the\n lists specified by the other arguments.\n\nProcessing:\n\n The function specified by the first argument is applied to each of\n the sublists (CDR's) of the lists specified by the other arguments,\n starting with the lists themselves and ending with the last non-NIL\n sublists; it is assumed that a list (which may be NIL) is returned by\n each application.  The results are destructively attached via NCONC\n to create a list of all the values as they are generated, and\n returned as the value of the MAPCON call.\n\n Processing ends as soon as one of the lists is exhausted\n (i.e. becomes NIL).\n\n If any list argument is NIL, NIL is returned as the value.\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\n Results are unpredictable (and likely to be disastrous) if the\n function, when applied to a sublist of the list, returns an atom\n rather than NIL or a proper list.\n\n Since NCONC is applied to the results of the function calls, be\n careful not to specify a function (such as CDR or (LAMBDA (X) X)\n that returns the actual element or a sublist thereof; such usage\n will corrupt the list, and may cause MAPCON to fail to terminate.\n\nExamples:\n\n (MAPCON #'(LAMBDA (X) (APPEND X NIL)) '(A B C D E))\n                       ==>  (A B C D E B C D E C D E D E E)\n\n (mapcon #'(lambda (x y) (if (equal x y) nil (list (car x) (car y))))\n          '(f o o b a r) '(r g o b a r))\n         ==> (f r o g)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPL": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x08C\\x00B\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:43:00", "lines": 66, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPL\n\nSyntax:   (MAPL arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n arg2, after applying the function specified by arg1 to the last\n non-null sublist of the shortest of the lists specified by the other\n arguments.\n\nProcessing:\n\n The function specified by arg1 is applied to each of the sublists\n (CDR's) of the lists specified by the other arguments, starting with\n the lists themselves and ending with the last non-NIL sublist.  The\n first or only input list is returned as the value of the MAPL call.\n\n Processing ends as soon as one of the lists is exhausted\n (i.e. becomes NIL).\n\n Generally, the function is used for its side effects and not for\n the values returned thereby.\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\nExamples:\n\n (let ((a nil))\n      (list\n       (mapl #'(lambda (x) (push (length x) a)) '(a b c d e))\n       a))\n            ==> ((a b c d e) (1 2 3 4 5))\n\n (let ((a nil))\n      (mapl #'(lambda (x y) (push (+ (car x) (car y)) a))\n             '(1 2 3) '(10 20 30))\n      a)\n            ==> (33 22 11)\n\n\n;(MAPL #'PRINT '(A B C D E))\n;\n;prints:\n;\n;  (A B C D E)\n;  (B C D E)\n;  (C D E)\n;  (D E)\n;  (E)\n;\n;on the standard output file.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPLIST": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x08D\\x000\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:44:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPLIST\n\nSyntax:   (MAPLIST arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n The list of values generated by the application of the function\n specified by the first argument to the sublists of the lists specified\n by the other arguments.\n\nProcessing:\n\n The function specified by the first argument is applied to each of\n the sublists (CDR's) of the lists specified by the other arguments,\n starting with the lists themselves and ending with the last non-NIL\n sublist.  A list is built of these values as they are generated, and\n returned as the value of the MAPLIST call.\n\n Processing ends as soon as one of the lists is exhausted\n (i.e. becomes NIL).\n\n If any list argument is NIL, NIL is returned as the value.\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\nExamples:\n\n (MAPLIST #'LENGTH '(A B C D E F G)) ==> (7 6 5 4 3 2 1)\n\n (MAPLIST #'(LAMBDA (X) (EQ (CAR X) 'FOO)) '(FOO BAR BAZ FOO FROB))\n                         ==>  (T NIL NIL T NIL)\n\n (MAPLIST #'APPEND '(A B C) '(D E F)) ==>((A B C D E F) (B C E F) (C F))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPOR": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x08D\\x006\\x006\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:44:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAPOR\n\nSyntax:   (MAPOR arg1 arg2 ... argn)\n\n At least 2 arguments must be specified.\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n The first non-NIL of the values produced by applying the first argument\n function to successive elements (CAR's) of the other argument lists;\n NIL if no such value is generated.\n\nProcessing:\n\n The function specified by the first argument is applied to each of the\n elements (CAR's) of the lists specified by the other arguments, until\n one of the lists is exhausted or a non-NIL value is produced by this\n application.  When this occurs, MAPOR returns that generated value.\n\n If all the elements of the list return NIL when the function is\n applied, NIL is returned.\n\n If any list argument is NIL, MAPOR returns NIL, by definition.\n\nErrors signaled:\n\n Invalid number of arguments (function and at least 1 list required).\n\nNotes:\n\n See member $MAP of this documentation for more information on what\n may be coded on a mapping function.\n\nExamples:\n\n (MAPOR #'ATOM NIL)                ==> NIL\n (MAPOR #'ATOM '(A B C D E F))     ==> T\n (MAPOR #'ATOM '(A B C D (E F)))   ==> T\n (MAPOR #'ATOM '((A B) (C D)))     ==> NIL\n (MAPOR #'EQ '(A B C) '(A B C))    ==> T\n (MAPOR #'EQ '(A B C) '(A C B))    ==> T\n (MAPOR #'EQ '(A B C) '(D E F))    ==> NIL\n\n (MAPOR #'(LAMBDA (X) X) '(FOO BAR BAZ))   ==> FOO\n\n (MAPOR #'(LAMBDA (X) X) '(NIL BAR BAZ))   ==> BAR\n\n (MAPOR #'(LAMBDA (X) X) '(NIL NIL NIL))   ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAX": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x04/\\x00\\x87%/\\x08E\\x00\"\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-11T00:00:00", "modifydate": "1987-09-09T08:45:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAX\n\nSyntax:   (MAX &rest args)\n At least 1 arg is required.\n\n arg (optional, evaluated) - a number, string or symbol.\n\nReturns:\n\n The arg which has the greatest value, according to the rules\n of GREATERP.\n\nProcessing:\n\n See GREATERP for how comparisons are done.  All the arguments to\n MAX must be of compatible types (i.e. no mixing alpha and numeric).\n\nErrors signaled:\n\n Missing arguments (at least one required).\n Errors detected by GREATERP (q.v.).\n\nNotes:\n\nExamples:\n\n (MAX 1)                 ==> 1\n (MAX \"A\" \"B\")           ==> \"B\"\n (MAX 2 1)               ==> 2\n (MAX 1 2 3)             ==> 3\n (MAX \"F\" \"R\" \"O\" \"G\")   ==> \"R\"\n (MAX 'F 'O 'O 'B 'A 'R) ==> R\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAXARGS": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x08I\\x00,\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:49:00", "lines": 44, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAXARGS\n\nSyntax:   (MAXARGS arg1)\n\n arg1 (required, evaluated) - a compiled code object (SUBR or closure).\n\nReturns:\n\n A fixnum specifying the maximum number of arguments that can be\n passed to the specified compiled code object.\n\nProcessing:\n\n MAXARGS looks at the compiled code header information, extracts the\n maximum number of arguments therefrom, and builds a fixnum containing\n the value.\n\n Two ways to specify compiled code objects are:\n\n (1) (GET function-name 'SUBR) - which gets the current function\n     definition provided that it has been loaded.\n (2) (ZILLOAD function-name)   - which loads the function from disk.\n\n See also MINARGS.\n\nErrors signaled:\n\n Argument not a compiled code object or closure.\n\nNotes:\n\n This function was formerly used by the evaluator, but is now useless.\n It has been retained because someone somewhere might find it useful.\n In particular, the ARGS function uses this internally.\n\nExamples:\n\n (PRINT (CAR NIL))              ==> NIL ; to load CAR and PRINT.\n (MAXARGS (GET 'CAR 'SUBR))     ==> 1   ; after CAR has been used.\n (MAXARGS (ZILLOAD 'GC))        ==> 0\n (MAXARGS (GET 'PRINT 'SUBR))   ==> 2   ; after PRINT has been used.\n (MAXARGS (ZILLOAD 'READCH))    ==> 3\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAX2": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\t\\x07\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T09:07:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAX2\n\nSyntax:   (MAX2 arg1 arg2)\n\n arg1 (required, evaluated) - a number, string or symbol.\n arg2 (required, evaluated) - a number, string or symbol.\n\nReturns:\n\n The arg which has the greater value, according to the rules\n of GREATERP.\n\nProcessing:\n\n See GREATERP for how comparisons are done.  The arguments to\n MAX2 must be of compatible types (i.e. no mixing alpha and numeric).\n\nErrors signaled:\n\n Errors detected by GREATERP (q.v.).\n\nNotes:\n\n This is the two-argument version of MAX, used to implement calls to\n MAX in most compiled code.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEMBER": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x88\\t\\x8f\\x13\\x06\\x00h\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1988-04-07T13:06:00", "lines": 104, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MEMBER\n\nSyntax:   (MEMBER item1 list2 &key test test-not key)\n\n item1    (required, evaluated) - any LISP object.\n list2    (required, evaluated) - a proper list.\n test     (optional, evaluated) - a predicate function of two arguments.\n test-not (optional, evaluated) - a predicate function of two arguments.\n key      (optional, evaluated) - an accessor function of one argument.\n\nReturns:\n\n The first sublist (CDR) of list2 whose CAR is equal to item1\n according to the test specified by the keywords;\n NIL if no such sublist exists.\n\nProcessing:\n\n The list specified by list2 is searched for an element that is equal\n to item1; when one is found, a pointer to the sublist of list2 of\n which item1 is the CAR is returned as the value.\n\n This enables the MEMBER caller to use the information, e.g. in an\n ordering test.  In a list L, element A precedes element B if\n (MEMBER B (MEMBER A L)) is non-NIL.\n\n If no keywords are specified, a match occurs when an element of\n list2 is found that item1 is EQL to.\n\n The keywords are processed as follows:\n\n :test (default #'eql)  - specifies a predicate function of two\n                          arguments used when comparing item1 to each\n                          element of list2.  If the function returns a\n                          non-NIL value, a match occurs.  The first\n                          argument is always item1, and the second\n                          argument is always the current element of\n                          list2 (with the :key function applied if :key\n                          is specified).\n\n :test-not (no default) - specifies a predicate function of two\n                          arguments used when comparing item1 to each\n                          element of list2.  If the function returns\n                          NIL, a match occurs.  The first argument is\n                          always item1, and the second argument is\n                          always the current element of list2 (with the\n                          :key function applied if :key is specified).\n\n :key (no default)      - specifies an accessor function of one argument\n                          that is applied to each element of list2\n                          before comparing it to item1 via the :test or\n                          :test-not function.  Note that the :key\n                          function is applied only to the element of\n                          list2, NOT to item1.\n\n The :test and :test-not keywords may not both be specified.\n\nErrors signaled:\n\n list2 not a list.\n Both :test and :test-not keywords specified.\n Invalid keyword specification.\n\nNotes:\n\n Unpredictable results will occur if list2 is not a proper list.\n\n MEMBER is, by default, implemented with an EQL test for Common LISP\n compatibility.  If Maclisp or Franz LISP compatibility is desired,\n MEMBER may be equated with ZIL function MEMQUAL via the DEFLOAD special\n form.  See MEMQ and MEMQUAL for more info.\n\n Under Macsyma, MEMBER performs an EQUAL test.\n\nExamples:\n\n (MEMBER 'A NIL)                          ==> NIL\n (MEMBER 'A '(A B C D E F G))             ==> (A B C D E F G)\n (MEMBER 'D '(A B C D E F G))             ==> (D E F G)\n (MEMBER 'G '(A B C D E F G))             ==> (G)\n (MEMBER 'H '(A B C D E F G))             ==> NIL\n\n (MEMBER 'A '(A B C) :TEST #'EQL)         ==> (A B C)\n (MEMBER 'B '(A B C) :TEST #'EQL)         ==> (B C)\n (MEMBER 'C '(A B C) :TEST #'EQL)         ==> (C)\n (MEMBER 'D '(A B C) :TEST #'EQL)         ==> NIL\n\n (MEMBER 'A '(A B C) :TEST-NOT #'EQL)     ==> (B C)\n (MEMBER 'B '(A B C) :TEST-NOT #'EQL)     ==> (A B C)\n (MEMBER 'C '(A B C) :TEST-NOT #'EQL)     ==> (A B C)\n (MEMBER 'D '(A B C) :TEST-NOT #'EQL)     ==> (A B C)\n\n ;Sublists are NOT recursively searched, unless :KEY is specified.\n\n (MEMBER 'C '((A B) (C D) (E F)))             ==> NIL\n (MEMBER 'C '((A B) (C D) (E F)) :KEY #'CAR)  ==> ((C D) (E F))\n\n ;The default comparison test is EQL.\n\n (MEMBER 3 '(1 2 3 4 5 6 7))                   ==> (3 4 5 6 7)\n (MEMBER '(1 2) '((1 2) (3 4)))                ==> NIL\n (MEMBER '(1 2) '((1 2) (3 4)) :TEST #'EQUAL)  ==> ((1 2) (3 4))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEMQ": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x88\\t\\x8f\\x13\\x06\\x002\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1988-04-07T13:06:00", "lines": 50, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MEMQ\n\nSyntax:   (MEMQ arg1 list2)\n\n arg1  (required, evaluated) - any LISP object, but generally a symbol.\n list2 (required, evaluated) - a proper list.\n\nReturns:\n\n The first sublist (CDR) of list2 whose CAR is EQ to arg1;\n NIL if no such sublist exists.\n\nProcessing:\n\n The list specified by list2 is searched for an element that is EQ to\n arg1; when one is found, a pointer to the sublist of list2 of which\n arg1 is the CAR is returned as the value.\n\n This enables the MEMQ caller to use the information, e.g. in an\n ordering test.  In a list L, element A precedes element B if\n (MEMQ B (MEMQ A L)) is non-NIL.\n\nErrors signaled:\n\n list2 not a list.\n\nNotes:\n\n Unpredictable results will occur if list2 is not a proper list.\n\n MEMQ is equivalent to Common LISP (MEMBER ... #TEST #'EQ).\n Compare MEMBER, which is like MEMQ but uses an EQL test by default.\n\nExamples:\n\n (MEMQ 'A NIL)                            ==> NIL\n (MEMQ 'A '(A B C D E F G))               ==> (A B C D E F G)\n (MEMQ 'D '(A B C D E F G))               ==> (D E F G)\n (MEMQ 'G '(A B C D E F G))               ==> (G)\n (MEMQ 'H '(A B C D E F G))               ==> NIL\n\n ;Sublists are NOT recursively searched.\n\n (MEMQ 'A '((A B) (C D) (E F)))              ==> NIL\n\n ;The comparison test is EQ.\n\n (MEMQ 3.0 '(1.0 2.0 3.0 4.0 5.0 6.0 7.0))   ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEMQL": {"ttr": 4881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x06?\\x00\\x87%/\\x08R\\x001\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-09T08:52:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MEMQL\n\nSyntax:   (MEMQL arg1 list2)\n\n arg1  (required, evaluated) - any LISP object.\n list2 (required, evaluated) - a proper list.\n\nReturns:\n\n The first sublist (CDR) of list2 whose CAR is EQL to arg1;\n NIL if no such sublist exists.\n\nProcessing:\n\n The list specified by list2 is searched for an element that is EQL to\n arg1; when one is found, a pointer to the sublist of list2 of which\n arg1 is the CAR is returned as the value.\n\n This enables the MEMQL caller to use the information, e.g. in an\n ordering test.  In a list L, element A precedes element B if\n (MEMQL B (MEMQL A L)) is non-NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare MEMQ, which is like MEMQL but uses an EQ test.\n and MEMQUAL, which is like MEMQL but uses an EQUAL test.\n\nExamples:\n\n (MEMQL 'A NIL)                           ==> NIL\n (MEMQL 'A '(A B C D E F G))              ==> (A B C D E F G)\n (MEMQL 'D '(A B C D E F G))              ==> (D E F G)\n (MEMQL 'G '(A B C D E F G))              ==> (G)\n (MEMQL 'H '(A B C D E F G))              ==> NIL\n\n ;Sublists are NOT recursively searched.\n\n (MEMQL 'A '((A B) (C D) (E F)))          ==> NIL\n\n ;The comparison test is EQL, not EQ or EQUAL.\n\n (MEMQL 3 '(1 2 3 4 5 6 7))               ==> (3 4 5 6 7)\n (MEMQL '(1 2) '((1 2) (3 4)))            ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEMQUAL": {"ttr": 4883, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x06?\\x00\\x87%/\\x08R\\x001\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-09T08:52:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MEMQUAL\n\nSyntax:   (MEMQUAL arg1 list2)\n\n arg1  (required, evaluated) - any LISP object.\n list2 (required, evaluated) - a proper list.\n\nReturns:\n\n The first sublist (CDR) of list2 whose CAR is EQUAL to arg1;\n NIL if no such sublist exists.\n\nProcessing:\n\n The list specified by list2 is searched for an element that is EQUAL to\n arg1; when one is found, a pointer to the sublist of list2 of which\n arg1 is the CAR is returned as the value.\n\n This enables the MEMQUAL caller to use the information, e.g. in an\n ordering test.  In a list L, element A precedes element B if\n (MEMQUAL B (MEMQUAL A L)) is non-NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare MEMQ, which is like MEMQUAL but uses an EQ test.\n and MEMQL, which is like MEMQL but uses an EQL test.\n\nExamples:\n\n (MEMQUAL 'A NIL)                         ==> NIL\n (MEMQUAL 'A '(A B C D E F G))            ==> (A B C D E F G)\n (MEMQUAL 'D '(A B C D E F G))            ==> (D E F G)\n (MEMQUAL 'G '(A B C D E F G))            ==> (G)\n (MEMQUAL 'H '(A B C D E F G))            ==> NIL\n\n ;Sublists are NOT recursively searched.\n\n (MEMQUAL 'A '((A B) (C D) (E F)))        ==> NIL\n\n ;The comparison test is EQUAL, not EQ or EQL.\n\n (MEMQUAL 3 '(1 2 3 4 5 6 7))             ==> (3 4 5 6 7)\n (MEMQUAL '(1 2) '((1 2) (3 4)))          ==> ((1 2) (3 4))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEXPAND": {"ttr": 4885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x08X\\x002\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:58:00", "lines": 50, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MACROEXPAND\n\nSyntax:   (MACROEXPAND arg1)\n    or:   (MEXPAND arg1)\n\n arg1 (required, evaluated) - an atom or proper list.\n\nReturns:\n\n A form which represents the expansion of the macro call specified by\n the first argument.\n\nProcessing:\n\n If arg1 is an atom, it is returned unchanged; otherwise it is assumed\n to be a proper list.  If the CAR of this list is a symbol with the\n MACRO property, then the list is a macro call, and the value of the\n MACRO property is used to expand the macro call.  Otherwise the list is\n returned unchanged.\n\n MACROEXPAND repeatedly expands the form until either the returned\n form is atomic or its CAR is not the name of a macro.  Compare\n MACROEXPAND-1 (aka MEXPAND1), which expands the form only once.\n\n Also compare FEXPAND, which does a code-walking full macroexpansion\n of its argument.\n\n The value of the MACRO property is assumed to be a LAMBDA list valid\n for a macro definition.  If it is not, it is APPLY'ed with a warning\n message.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Unpredictable results will occur if the first argument is not an atom\n or a proper list.\n\nExamples:\n\n (DEFMACRO M1 (X) `(M2 ,X))         ==> M1\n (DEFMACRO M2 (X) `(M3 ,X))         ==> M2\n\n (MACROEXPAND-1 '(M1 (M1 A)))           ==> (M2 (M1 A))\n (MACROEXPAND   '(M1 (M1 A)))           ==> (M3 (M1 A))\n (FEXPAND       '(M1 (M1 A)))           ==> (M3 (M3 A))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MEXPAND1": {"ttr": 4887, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87%/\\x00\\x87%/\\x08Y\\x002\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-09T00:00:00", "modifydate": "1987-09-09T08:59:00", "lines": 50, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MACROEXPAND-1\n\nSyntax:   (MACROEXPAND-1 arg1)\n    or:   (MEXPAND1 arg1)\n\n arg1 (required, evaluated) - an atom or proper list.\n\nReturns:\n\n A form which represents the expansion of the macro call specified by\n the first argument.\n\nProcessing:\n\n If arg1 is an atom, it is returned unchanged; otherwise it is assumed\n to be a proper list.  If the CAR of this list is a symbol with the\n MACRO property, then the list is a macro call, and the value of the\n MACRO property is used to expand the macro call.  Otherwise the list is\n returned unchanged.\n\n MACROEXPAND-1 expands the form only once.  Compare MACROEXPAND (aka\n MEXPAND), which expands the form repeatedly until the form is not a\n macro call.\n\n Also compare FEXPAND, which does a code-walking full macroexpansion\n of its argument.\n\n The value of the MACRO property is assumed to be a LAMBDA list valid\n for a macro definition.  If it is not, it is APPLY'ed with a warning\n message.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Unpredictable results will occur if the first argument is not an atom\n or a proper list.\n\nExamples:\n\n (DEFMACRO M1 (X) `(M2 ,X))         ==> M1\n (DEFMACRO M2 (X) `(M3 ,X))         ==> M2\n\n (MACROEXPAND-1 '(M1 (M1 A)))           ==> (M2 (M1 A))\n (MACROEXPAND   '(M1 (M1 A)))           ==> (M3 (M1 A))\n (FEXPAND       '(M1 (M1 A)))           ==> (M3 (M3 A))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MIN": {"ttr": 4889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x04/\\x00\\x87%/\\x08F\\x00\"\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-02-11T00:00:00", "modifydate": "1987-09-09T08:46:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MIN\n\nSyntax:   (MIN &rest args)\n At least 1 arg is required.\n\n arg (optional, evaluated) - a number, string or symbol.\n\nReturns:\n\n The arg which has the smallest value, according to the rules\n of GREATERP.\n\nProcessing:\n\n See GREATERP for how comparisons are done.  All the arguments to\n MIN must be of compatible types (i.e. no mixing alpha and numeric).\n\nErrors signaled:\n\n Missing arguments (at least one required).\n Errors detected by GREATERP (q.v.).\n\nNotes:\n\nExamples:\n\n (MIN 1)                 ==> 1\n (MIN \"A\" \"B\")           ==> \"A\"\n (MIN 2 1)               ==> 1\n (MIN 1 2 3)             ==> 1\n (MIN \"F\" \"R\" \"O\" \"G\")   ==> \"F\"\n (MIN 'F 'O 'O 'B 'A 'R) ==> A\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MINARGS": {"ttr": 4891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x08P\\x00,\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T08:50:00", "lines": 44, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MINARGS\n\nSyntax:   (MINARGS arg1)\n\n arg1 (required, evaluated) - a compiled code object (SUBR or closure).\n\nReturns:\n\n A fixnum specifying the minimum number of arguments that can be\n passed to the specified compiled code object.\n\nProcessing:\n\n MINARGS looks at the compiled code header information, extracts the\n minimum number of arguments therefrom, and builds a fixnum containing\n the value.\n\n Two ways to specify compiled code objects are:\n\n (1) (GET function-name 'SUBR) - which gets the current function\n     definition provided that it has been loaded.\n (2) (ZILLOAD function-name)   - which loads the function from disk.\n\n See also MAXARGS.\n\nErrors signaled:\n\n Argument not a compiled code object or closure.\n\nNotes:\n\n This function was formerly used by the evaluator, but is now useless.\n It has been retained because someone somewhere might find it useful.\n In particular, the ARGS function uses this internally.\n\nExamples:\n\n (PRINT (CAR NIL))              ==> NIL ; to load CAR and PRINT.\n (MINARGS (GET 'CAR 'SUBR))     ==> 1   ; after CAR has been used.\n (MINARGS (ZILLOAD 'GC))        ==> 0\n (MINARGS (GET 'PRINT 'SUBR))   ==> 1   ; after PRINT has been used.\n (MINARGS (ZILLOAD 'READCH))    ==> 0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MINUS": {"ttr": 4893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x86\\x08\\x7f\\x00\\x87%/\\x17\\x17\\x00'\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-28T00:00:00", "modifydate": "1987-09-09T17:17:00", "lines": 39, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MINUS\n\nSyntax:   (MINUS arg1)\n\n arg1 (required, evaluated) - a number.\n\nReturns:\n\n The negative of arg1 (i.e. the value of arg1 multiplied by -1).\n\nProcessing:\n\n If arg1 is positive, the corresponding negative number of the same\n type is returned.  Otherwise, the corresponding positive number of\n the same type is returned.\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\nExamples:\n\n (MINUS 0)              ==> 0\n (MINUS 0.0)            ==> 0.0\n (MINUS 0.0F0)          ==> 0.0F0\n (MINUS 2)              ==> -2\n (MINUS -3)             ==> 3\n (MINUS 1.5)            ==> -1.5\n (MINUS 1.5F0)          ==> -1.5F0\n (MINUS -1.5)           ==> 1.5\n (MINUS -1.5F0)         ==> 1.5F0\n (MINUS 2147483648)     ==> -21\n (MINUS -2147483648)    ==> 21\n (MINUS 1000000000000)  ==> -10000\n (MINUS -1000000000000) ==> 10000\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MINUSP": {"ttr": 4895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x17\\x18\\x00\"\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T17:18:00", "lines": 34, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MINUSP\n\nSyntax:   (MINUSP arg1)\n\n arg1 (required, evaluated) - a number.\n\nReturns:\n\n T if arg1 is negative (less than zero), else NIL.\n\nProcessing:\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (MINUSP 0)         ==> NIL\n (MINUSP 1)         ==> NIL\n (MINUSP -1)        ==> T\n (MINUSP 0.0)       ==> NIL\n (MINUSP 0.0F0)     ==> NIL\n (MINUSP -0.0)      ==> NIL\n (MINUSP -0.0F0)    ==> NIL\n (MINUSP -0.0001)   ==> T\n (MINUSP -0.0001F0) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MIN2": {"ttr": 4897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\t\\x08\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T09:08:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MIN2\n\nSyntax:   (MIN2 arg1 arg2)\n\n arg1 (required, evaluated) - a number, string or symbol.\n arg2 (required, evaluated) - a number, string or symbol.\n\nReturns:\n\n The arg which has the smaller value, according to the rules\n of GREATERP.\n\nProcessing:\n\n See GREATERP for how comparisons are done.  The arguments to\n MIN2 must be of compatible types (i.e. no mixing alpha and numeric).\n\nErrors signaled:\n\n Errors detected by GREATERP (q.v.).\n\nNotes:\n\n This is the two-argument version of MIN, used to implement calls to\n MIN in most compiled code.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKATOM": {"ttr": 4899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x08O\\x00\\x87&\\x1f\\x10\\x08\\x00F\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-03-25T00:00:00", "modifydate": "1987-09-18T10:08:00", "lines": 70, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MKATOM\n\nSyntax:   (MKATOM string1 &optional arg2 arg3)\n    or:   (MAKE-ATOM string1 &optional arg2 arg3)\n\n string1 (required, evaluated) - a string.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n arg3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n If arg3 is specified and non-NIL, and string1 is syntactically\n numeric, a numeric atom which, when printed, looks like string1;\n otherwise a symbol whose print name consists of string1.\n\nProcessing:\n\n If arg3 is omitted or NIL, string1 is used to build a new symbol\n whose print name is string1.  The symbol is interned only if arg2\n is specified and non-NIL.\n\n If arg3 is specified and non-NIL, then an attempt is made to build a\n numeric atom (fixnum, flonum or bignum), according to the syntax of\n string1 as the READ function would interpret it.  If the string is not\n syntactically numeric, then a symbol is created as for the case above,\n with arg2 determining whether to intern the symbol.\n\n Note that when a non-NIL third argument is specified, the following\n holds true:\n\n (1) If the atom is numeric, the setting of the second argument is\n     ignored, since only symbols are ever interned on the oblist.\n\n (2) If the atom is syntactically non-numeric, a symbol will be created.\n     In this case the setting of the second argument is significant.\n\n (3) List notation (parentheses, dots, etc.) is not valid and will\n     be treated as part of a symbol name.\n\n (4) Floating-point overflow is not detected by the code, and may\n     result in a program check (0CC) abend.  Floating-point underflow is\n     ignored and may produce a zero result.\n\nErrors signaled:\n\n string1 not a string or symbol.                                        ).\n\nNotes:\n\n See MAKE-NUMBER, which takes 1 argument and is a convenient way\n of specifying MAKE-ATOM with a third argument of T.  MAKE-NUMBER\n may create a symbol, but will never intern it.\n\nExamples:\n\n (MAKE-ATOM \"A\")               ==> A\n (MAKE-ATOM \"hi there\")        ==> |hi there|\n (MAKE-ATOM \"(F O O)\")         ==> |(F O O)| ; Lists are never built.\n\n (SETQ A (MKATOM \"FOO\" NIL))   ==> FOO ; not interned.\n (SETQ B (MKATOM \"FOO\" T))     ==> FOO ; interned.\n (EQ A 'FOO)                   ==> NIL\n (EQ B 'FOO)                   ==> T\n\n (MKATOM \"007\" NIL NIL)     ==> |007| ; an uninterned symbol.\n (MKATOM \"007\" NIL T)       ==> 7     ; a fixnum.\n (MKATOM \"007\" T NIL)       ==> |007| ; an interned symbol.\n (MKATOM \"007\" T T)         ==> 7     ; a fixnum.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MKBIGNUM": {"ttr": 4901, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x05\\x7f\\x00\\x87%/\\x17 \\x00$\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-26T00:00:00", "modifydate": "1987-09-09T17:20:00", "lines": 36, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MKBIGNUM\n\nSyntax:   (MKBIGNUM list1)\n    or:   (MAKE-BIGNUM list1)\n\n list1 (required, evaluated) - a proper list of at least 2 fixnums.\n\nReturns:\n\n A bignum created from the fixnums in list1.\n\nProcessing:\n\n The contents of the list is dependent upon the internal implementation\n of bignums.  See $BIGNUM for more information.\n\nErrors signaled:\n\n Argument not a proper list of at least 2 fixnums.\n Invalid list of fixnums:\n  zero in most-significant-word position\n  negative value in position other than first\n  the bignum would have had the value -2147483648 (most negative fixnum)\n Not enough space to build bignum.\n\nNotes:\n\n  BIGLIST will turn the bignum back into a list.\n\nExamples:\n\n (MKBIGNUM '(0 1))            ==> 21\n (MKBIGNUM '(1 2 3))          ==> 138350580595\n (MKBIGNUM '(-2147483647 1))  ==> -21\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKFIXNUM": {"ttr": 4903, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x86!/\\x00\\x87%/\\x17$\\x00'\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-07-31T00:00:00", "modifydate": "1987-09-09T17:24:00", "lines": 39, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MKFIXNUM\n\nSyntax:   (MKFIXNUM flo1)\n    or:   (MAKE-FIXNUM flo1)\n\n flo1 (required, evaluated) - a flonum.\n\nReturns:\n\n If flo1 is a single-float, a fixnum created therefrom.\n If flo1 is a double-float, a dotted pair (CONS) of 2 fixnums created\n therefrom.\n\nProcessing:\n\n The value of flo1 is NOT converted; rather, the bitwise contents of\n the flonum value are inserted into the newly created fixnum(s).\n\nErrors signaled:\n\n Argument not a flonum.\n\nNotes:\n\n  MKFLONUM will turn the fixnum(s) back into a flonum.\n  Note that flonums are always stored in normalized form in ZIL.\n\nExamples:\n\n (MKFIXNUM 1.0F0)  ==> #z\n (MKFIXNUM -1.5F0) ==> #zC1180000\n (MKFIXNUM 0.0F0)  ==> #z\n\n (MKFIXNUM 1.0D0)  ==> (#z41100000 . #z00000000)\n (MKFIXNUM -1.5D0) ==> (#zC1180000 . #z00000000)\n (MKFIXNUM 0.0D0)  ==> (#z00000000 . #z00000000)\n (MKFIXNUM 0.6D0)  ==> (#z40999999 . #z99999999)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKFLONUM": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86!/\\x00\\x87%/\\x171\\x00:\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-07-31T00:00:00", "modifydate": "1987-09-09T17:31:00", "lines": 58, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MKFLONUM\n\nSyntax:   (MKFLONUM fix1 &optional fix2)\n    or:   (MAKE-FLONUM fix1 &optional fix2)\n\n fix1 (required, evaluated) - a fixnum.\n fix2 (optional, evaluated) - a fixnum.\n\nReturns:\n\n If fix2 is omitted, a single-float created from fix1.\n If fix2 is specified, a double-float created from fix1 and fix2.\n\nProcessing:\n\n The values of fix1 and fix2 are NOT converted; rather, the bitwise\n contents of the fixnum values are used to create the floating-point\n number.  If fix2 is omitted, the value of fix1 is inserted into the\n newly created single-float.  Otherwise, the values of fix1 and fix2\n are concatenated to form a doubleword which is inserted into the\n newly created double-float.  In both cases, the leftmost 8 bits\n form the characteristic and the remaining bits form the mantissa\n (or is it the other way around?).\n\n The value is normalized by adding a normalized floating-point zero to\n it.  This is necessary to insure, among other things, the bitwise\n equality of all flonum zero values.  Therefore, the resulting flonum\n may not have the same bitwise configuration as the input fixnum;\n specifically, MKFIXNUM may not return fix1 (and fix2, if applicable)\n when applied to the result of (MKFLONUM fix1 {fix2}).\n\nErrors signaled:\n\n Argument not a fixnum.\n\nNotes:\n\n MKFIXNUM will turn the flonum back into fixnum(s).  Note, however,\n that it will not return the original fixnum(s) if MKFLONUM has had to\n normalize the value (see above).\n\nExamples:\n\n (MKFLONUM #z41100000)        ==> 1.0F0\n (MKFIXNUM 1.0F0)             ==> #z\n (MKFLONUM #zC1180000)        ==> -1.5F0\n (MKFIXNUM -1.5F0)            ==> #zC1180000\n (MKFLONUM #z40000000)        ==> 0.0F0\n (MKFIXNUM 0.0F0)             ==> #z00000000  ; note: normalized!\n\n (MKFLONUM #z41100000 #z00000000) ==> 1.0D0\n (MKFIXNUM 1.0D0)             ==> (#z41100000 . #z00000000)\n (MKFLONUM #z40999999 #z99999999) ==> 0.6D0\n (MKFIXNUM 0.6D0)             ==> (#z40999999 . #z99999999)\n (MKFLONUM #z40000000 #z00000000) ==> 0.0D0\n (MKFIXNUM 0.0D0)             ==> (#z00000000 . #z00000000) ;normalized!\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKFUNARG": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%/\\x171\\x00\\x18\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-09T17:31:00", "lines": 24, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MKFUNARG\n\nSyntax:   (MKFUNARG arg1 arg2)\n\n arg1 (required, evaluated) - a LISP object that can be APPLY'ed.\n arg2 (required, evaluated) - an evaluation environment.\n\nReturns:\n\n An interpreted lexical closure (funarg) whose function component\n is arg1 and whose environment component is arg2.\n\nProcessing:\n\nErrors signaled:\n\n None (so watch out!).\n\nNotes:\n\n MKFUNARG is used by the evaluator to process the FUNCTION special form.\n Nobody else should be using this function.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKLIST": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x17\\x8f\\x00\\x87%/\\x172\\x00%\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-06-27T00:00:00", "modifydate": "1987-09-09T17:32:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAKE-LIST\n\nSyntax:   (MAKE-LIST arg1 &optional arg2)\n    or:   (MKLIST arg1 &optional arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (optional, evaluated) - any LISP object.\n\nReturns:\n\n A list of (n) elements, where n is the value of arg1, and all of\n the elements are arg2.\n\nProcessing:\n\n A list is CONSed up with the number of elements specified by arg1,     urned\n which must be a fixnum.  All of the elements are initialized to arg2,\n which defaults to NIL.\n\n A zero length is valid, in which case the list has no elements.\n\nErrors signaled:\n\n Length argument not a fixnum, or negative.\n\nNotes:\n\n MAKE-LIST and MKLIST are equivalent and both acceptable names.\n\nExamples:\n\n (MAKE-LIST 0)       ==> NIL\n (MAKE-LIST 1)       ==> (NIL)\n (MAKE-LIST 5)       ==> (NIL NIL NIL NIL NIL)\n (MAKE-LIST 5 \"foo\") ==> (\"foo\" \"foo\" \"foo\" \"foo\" \"foo\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MKNEWENV": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x08!\\x00$\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:21:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MKNEWENV\n\nSyntax:   (MKNEWENV &optional arg1)\n\n arg1 (optional, evaluated) - a variable binding environment (alist).\n\nReturns:\n\n A new evaluation environment which contains the variable binding\n environment specified by arg1 (or none), and default (null) entries\n for the other components of the environment.\n\nProcessing:\n\n MKNEWENV builds an evaluation environment which contains the\n variable binding environment specified by arg1 (or a null one if\n arg1 is omitted), and null entries for the other components.\n\n The variable binding environment is a LEXICAL one, not the\n SPECIAL (dynamic) variable binding environment.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This is an internal ZIL function used by the evaluator to implement\n lexical scoping.  The format of an evaluation environment is\n system-dependent; however, the FUNENV function will return the\n environment component of an interpreted lexical closure if you're\n interested in knowing what an evaluation environment looks like in ZIL.\n\n See also COPYENV.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKNUMBER": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x10\\t\\x000\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T10:09:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MKNUMBER\n\nSyntax:   (MKNUMBER string1)\n    or:   (MAKE-NUMBER string1)\n\n string1 (required, evaluated) - a string.\n\nReturns:\n\n If string1 is syntactically numeric, a numeric atom which, when\n printed, looks like string1; otherwise an uninterned symbol whose print\n name consists of string1.\n\nProcessing:\n\n An attempt is made to build a numeric atom (fixnum, flonum or bignum),\n according to the syntax of string1 as the READ function would interpret\n it.  If the string is not syntactically numeric, then an uninterned\n symbol is created whose print name is string1.\n\n Notes:\n\n (1) List notation (parentheses, dots, etc.) is not valid and will\n     be treated as part of a symbol name.\n\n (2) Floating-point overflow is not detected by the code, and may\n     result in a program check (0CC) abend.  Floating-point underflow is\n     ignored and may produce a zero result.\n\nErrors signaled:\n\n string1 not a string or symbol.                                        ).\n\nNotes:\n\nExamples:\n\n (MAKE-NUMBER \"007\")           ==> 7     ; a fixnum.\n (MAKE-NUMBER \"1.5\")           ==> 1.5   ; a flonum.\n (MAKE-NUMBER \"A\")             ==> A\n (MAKE-NUMBER \"hi there\")      ==> |hi there|\n (MAKE-NUMBER \"(F O O)\")       ==> |(F O O)| ; Lists are never built.\n\n (SETQ A (MKNUMBER \"FOO\"))     ==> FOO ; not interned.\n (EQ A 'FOO)                   ==> NIL\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MKSTRUCT": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x87(\\x1f\\x00\\x87(\\x1f\\x07@\\x00'\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-08T00:00:00", "modifydate": "1987-10-08T07:40:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAKE-STRUCT\n\nSyntax:   (MAKE-STRUCT arg1 arg2)\n    or:   (MKSTRUCT arg1 arg2)\n\n arg1 (required, evaluated) - a positive fixnum.\n arg2 (required, evaluated) - a symbol.\n\nReturns:\n\n A structure of (n) elements, where n is the value of arg1, and the\n type is arg2.\n\nProcessing:\n\n A structure is allocated with the number of elements specified by arg1, urned\n which must be a fixnum.  All of the elements are initialized to NIL\n except for the structure type, which is set to arg2.\n\n A length of 1 is valid, in which case the structure has no elements.\n\n The predicates VECP and STRUCTP are true of structures.\n\nErrors signaled:\n\n Arg 1 not a positive fixnum.\n Arg 2 not a symbol.\n Not enough structure space to build the structure, even after GC.\n\nNotes:\n\n MAKE-STRUCT and MKSTRUCT are equivalent and both acceptable names.\n\n Compare ZMSTRUCT, which makes a structure out of a list.\n\n MKSTRUCT is generally not to be used by the ZIL programmer.  Use\n DEFSTRUCT to define and manipulate structures.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKVECTOR": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x173\\x00'\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T17:33:00", "lines": 39, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MAKE-VECTOR\n\nSyntax:   (MAKE-VECTOR arg1 &optional arg2)\n    or:   (MKVECTOR arg1 &optional arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (optional, evaluated) - any LISP object.\n\nReturns:\n\n A vector of (n) elements, where n is the value of arg1, and all of\n the elements are arg2.\n\nProcessing:\n\n A vector is allocated with the number of elements specified by arg1,   urned\n which must be a fixnum.  All of the elements are initialized to arg2,\n which defaults to NIL.\n\n A zero length is valid, in which case the vector has no elements.\n\nErrors signaled:\n\n Argument not a fixnum.\n Not enough vector space to build the vector, even after GC;\n or vector length is negative.\n\nNotes:\n\n MAKE-VECTOR and MKVECTOR are equivalent and both acceptable names.\n\nExamples:\n\n (MAKE-VECTOR 0)   ==> #()\n (MAKE-VECTOR 1)   ==> #(NIL)\n (MAKE-VECTOR 5)   ==> #(NIL NIL NIL NIL NIL)\n (MAKE-VECTOR 5 \"foo\") ==> #(\"foo\" \"foo\" \"foo\" \"foo\" \"foo\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODEL": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x88\\x12O\\x08\\x11\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1988-05-03T08:11:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MODEL\n\nSyntax:   (MODEL arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n Nothing.\n\nProcessing:\n\n This is just a model for documentation members.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Copy this into new members when creating new documentation.\n\nExamples:\n\n (MODEL T)                ==> (\"***ERROR***\")\n (MODEL NIL)              ==> (\"***ERROR***\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGLEVEL": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x17@\\x00R\\x00O\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T17:40:00", "lines": 82, "newlines": 79, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: MSGLEVEL\n\nSyntax:   (MSGLEVEL &optional arg1)\n\n arg1 (optional, evaluated) - a fixnum between 0 and 3, or NIL.\n\nReturns:\n\n A fixnum representing the current message level; if a non-NIL value\n is specified, that value becomes the current message level and is\n returned.\n\nProcessing:\n\n If the argument is NIL or omitted, the current message level is\n returned as a fixnum.\n\n If the argument is not NIL, it represents a value to be assigned to\n the message level.  The current message level is updated to this\n value and the argument value is returned as the value.\n\n The message level works like this:  Whenever a low-level ZIL function\n displays a ZIL message, it checks the current message level against the\n severity level of the message.  Messages whose severity level is less\n than the current message level are not displayed.\n\n The message/severity levels are as follows:\n\n 0 - informational; displayed for information only, no error condition.\n\n 1 - warning; something unusual but not serious.\n\n 2 - error; accompanied by signalling of an error (THROW to tag NIL).\n\n 3 - severe; an unusual condition that the user must know about.\n\n The initial message level is 1 (all but trivial informational messages\n displayed), except under Macsyma, where it is 2.\n\n Messages issued via the WARN function are suppressed when the\n message level is greater than 1.\n\n Messages issued via the ERROR function are suppressed when the\n message level is greater than 2.\n\nErrors signaled:\n\n Invalid argument (not a fixnum, or out of range - must be 0,1,2, or 3).\n\nNotes:\n\n Messages that result in unconditional termination of the ZIL\n environment, such as sever garbage collection errors, are not subject\n to suppression; they will always appear, regardless of the setting of\n MSGLEVEL.\n\n Garbage collection messages are not subject to MSGLEVEL.  See GCMSG.\n\n MSGLEVEL is used to control the display of message issued by ZIL\n assembler-level modules via TPUT.\n\n See member $CODES for the severity levels associated with these\n messages.\n\n Setting the message level higher than 2 is not recommended.\n\nExamples:\n\n (MSGLEVEL)\n (MSGLEVEL NIL) ...are equivalent and return the current message level.\n\n (MSGLEVEL 0)      permits all messages to be displayed.\n (MSGLEVEL 1)      suppresses informational messages.\n (MSGLEVEL 2)      suppresses informational and warning messages;\n                   only errors will be reported.\n (MSGLEVEL 3)      suppresses all messages except those that report\n                   unusual system errors or fatal errors, or\n                   garbage collection messages; this is not\n                   recommended, as it will result in errors being\n                   signalled with no message being displayed.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MVBIND": {"ttr": 5139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x16\\x7f\\x00\\x88\\x16\\x7f\\x08T\\x00\\\\\\x00Y\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-15T00:00:00", "modifydate": "1988-06-15T08:54:00", "lines": 92, "newlines": 89, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: MULTIPLE-VALUE-BIND\n\nSyntax:   (MULTIPLE-VALUE-BIND list1 form2 &rest body)\n\n list1 (required, not evaluated) - a list of variables.\n form2 (required, evaluated)     - any LISP object.\n body  (optional, evaluated)     - a list of zero or more declarations\n                                   and forms to be executed.\n\nReturns:\n\n The value of the last form in the body, after setting up a binding\n environment containing the variables in list1, which are bound to\n the values returned from form2.\n\nProcessing:\n\n form2 is evaluated with the expectation that multiple values may be\n returned.  A local binding environment is then created with the\n variables in list1 (which may be symbols or destructuring templates).\n The values returned from form2 are assigned to these variables in\n order, according to the following rules:\n\n  If there are fewer values than variables, the remaining variables\n  are set to NIL.\n\n  If there are more values than variables, the excess values are\n  ignored.\n\n Note that if the form returns no values, all of the variables are\n set to NIL.  If the form returns a single value (for example, it\n is not a multiple-value-returning function at all), then the first\n variable in list1 receives the value and the others (if any) are\n set to NIL.\n\n The body is then executed in the new binding environment.  Note\n that declarations can occur at the beginning of the body, and may\n affect the binding of the variables in list1, particularly SPECIAL\n declarations.  The value of the last form in the body is returned\n as the value of the special form.\n\nErrors signaled:\n\n Too few arguments.\n Invalid argument list (not a proper list, lambda list keywords\n found at a non-destructuring level, or other error detected by\n lambda list processing).\n\nNotes:\n\n Compare MULTIPLE-VALUE-SETQ, which does assignment without creating\n new bindings.\n\n See VALUES and VALUES-LIST for information on how multiple values\n are returned from a function.\n\n See Guy Steele's \"Common LISP: The Language\", pp. 133-139, for\n an explanation of multiple values in LISP.  Although the constant\n MULTIPLE-VALUES-LIMIT is not defined in ZIL, returning more than\n 4095 multiple values is not supported.\n\n In many cases, use of multiple values in ZIL is more expensive than\n just consing up a list of the values and extracting the values from\n the list via destructuring.  In any case, out of all the forms that\n request multiple values, only MULTIPLE-VALUE-BIND in compiled code\n is guaranteed not to cons in ZIL.\n\nExamples:\n\n (MULTIPLE-VALUE-BIND (A    ) (VALUES 1 2 3 4) (LIST A    ))\n     ==> (1)\n (MULTIPLE-VALUE-BIND (A B  ) (VALUES 1 2 3 4) (LIST A B  ))\n     ==> (1 2)\n (MULTIPLE-VALUE-BIND (A B C) (VALUES 1 2 3 4) (LIST A B C))\n     ==> (1 2 3)\n (MULTIPLE-VALUE-BIND (A B C D) (VALUES 1 2 3 4) (LIST A B C D))\n     ==> (1 2 3 4)\n (MULTIPLE-VALUE-BIND (A B C D E) (VALUES 1 2 3 4) (LIST A B C D E))\n     ==> (1 2 3 4 NIL)\n (MULTIPLE-VALUE-BIND (A B C) (VALUES)         (LIST A B C))\n     ==> (NIL NIL NIL)\n (MULTIPLE-VALUE-BIND (A B C) (VALUES 1)       (LIST A B C))\n     ==> (1 NIL NIL)\n (MULTIPLE-VALUE-BIND (A B C) (VALUES 1 2)     (LIST A B C))\n     ==> (1 2 NIL)\n (MULTIPLE-VALUE-BIND (A B C) (VALUES 1 2 3)   (LIST A B C))\n     ==> (1 2 3)\n (MULTIPLE-VALUE-BIND (A B C) (VALUES 1 2 3 4) (LIST A B C))\n     ==> (1 2 3)\n (MULTIPLE-VALUE-BIND (A B C) 'FOOBAR          (LIST A B C))\n     ==> (FOOBAR NIL NIL)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVCALL": {"ttr": 5141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x7f\\x00\\x88\\x16\\x7f\\x08@\\x002\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-15T00:00:00", "modifydate": "1988-06-15T08:40:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: MULTIPLE-VALUE-CALL\n\nSyntax:   (MULTIPLE-VALUE-CALL func1 &rest forms)\n\n func1 (required, evaluated) - a function.\n forms (optional, evaluated) - any LISP object.\n\nReturns:\n\n The value returned by func1 when it is called with all the arguments\n generated by evaluating the forms and collecting all their multiple\n values together.\n\nProcessing:\n\n First func1 is evaluated to return an object which can be called as a\n function, in the usual LISP sense.  Then the forms are evaluated with\n the expectation that multiple values may be returned, and the values\n are all retained in succession and passed to the function, whose return\n value is the return value.  Thus, the number of arguments passed to\n the function is the total of the numbers of values returned from all\n the forms.\n\nErrors signaled:\n\n Too few arguments.\n func1 not a valid function (errors signalled by APPLY).\n\nNotes:\n\n See VALUES and VALUES-LIST for information on how multiple values\n are returned from a function.\n\n See Guy Steele's \"Common LISP: The Language\", pp. 133-139, for\n an explanation of multiple values in LISP.  Although the constant\n MULTIPLE-VALUES-LIMIT is not defined in ZIL, returning more than\n 4095 multiple values is not supported.\n\n In many cases, use of multiple values in ZIL is more expensive than\n just consing up a list of the values and extracting the values from\n the list via destructuring.  In any case, out of all the forms that\n request multiple values, only MULTIPLE-VALUE-BIND in compiled code\n is guaranteed not to cons in ZIL.\n\nExamples:\n\n (MULTIPLE-VALUE-CALL #'CONS (VALUES 1 2))    ==> (1 . 2)\n (MULTIPLE-VALUE-CALL #'LIST (VALUES) (VALUES 'A) (VALUES 'B 'C) 'D)\n                                              ==> (A B C D)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVLIST": {"ttr": 5143, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x7f\\x00\\x88\\x16\\x7f\\x08E\\x000\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-15T00:00:00", "modifydate": "1988-06-15T08:45:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: MULTIPLE-VALUE-LIST\n\nSyntax:   (MULTIPLE-VALUE-LIST form1)\n\n form1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A list of all the multiple values returned by form1, or a list of the\n one value returned by form1 if form1 did not return multiple values.\n\nProcessing:\n\n form1 is evaluated with\n the expectation that multiple values may be returned, and the values\n are made into a list which is returned as the value of this special\n form.  If form1 returns no values, NIL is returned.  If form1 returns\n a single value, a singleton list of that value is returned.\n\nErrors signaled:\n\n Missing argument.\n Too many arguments.\n\nNotes:\n\n See VALUES and VALUES-LIST for information on how multiple values\n are returned from a function.\n\n See Guy Steele's \"Common LISP: The Language\", pp. 133-139, for\n an explanation of multiple values in LISP.  Although the constant\n MULTIPLE-VALUES-LIMIT is not defined in ZIL, returning more than\n 4095 multiple values is not supported.\n\n In many cases, use of multiple values in ZIL is more expensive than\n just consing up a list of the values and extracting the values from\n the list via destructuring.  In any case, out of all the forms that\n request multiple values, only MULTIPLE-VALUE-BIND in compiled code\n is guaranteed not to cons in ZIL.\n\nExamples:\n\n (MULTIPLE-VALUE-LIST 'A)              ==> (A)\n (MULTIPLE-VALUE-LIST (VALUES))        ==> NIL\n (MULTIPLE-VALUE-LIST (VALUES 1))      ==> (1)\n (MULTIPLE-VALUE-LIST (VALUES 1 2 3))  ==> (1 2 3)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVPROG1": {"ttr": 5145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x7f\\x00\\x88\\x16\\x7f\\x08Q\\x002\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-15T00:00:00", "modifydate": "1988-06-15T08:51:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: MULTIPLE-VALUE-PROG1\n\nSyntax:   (MULTIPLE-VALUE-PROG1 arg1 &rest args)\n\n argn (optional, evaluated) - any LISP object.\n At least 1 argument is required.\n\nReturns:\n\n The values returned by the first of the arguments, after evaluating all\n of the arguments in sequence.\n\nProcessing:\n\n All of the arguments are evaluated; since only the values of the first\n are used, the others are generally specified for their effect only.\n The results of evaluating arg1 with the expectation that multiple\n values will be returned are passed as the values of this form.\n\n In other words, MULTIPLE-VALUE-PROG1 is identical to PROG1 except that\n if the first argument produces multiple values, all of these values\n will be returned.  PROG1 always returns a single value, as does PROG2.\n\nErrors signaled:\n\n Too few arguments (at least one is required).\n\nNotes:\n\n See VALUES and VALUES-LIST for information on how multiple values\n are returned from a function.\n\n See Guy Steele's \"Common LISP: The Language\", pp. 133-139, for\n an explanation of multiple values in LISP.  Although the constant\n MULTIPLE-VALUES-LIMIT is not defined in ZIL, returning more than\n 4095 multiple values is not supported.\n\n In many cases, use of multiple values in ZIL is more expensive than\n just consing up a list of the values and extracting the values from\n the list via destructuring.  In any case, out of all the forms that\n request multiple values, only MULTIPLE-VALUE-BIND in compiled code\n is guaranteed not to cons in ZIL.\n\nExamples:\n\n (MULTIPLE-VALUE-LIST (PROG1 (VALUES 1 2) 'A 'B))  ==> (1)\n (MULTIPLE-VALUE-LIST (MULTIPLE-VALUE-PROG1 (VALUES 1 2) 'A 'B))\n                                                   ==> (1 2)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSETQ": {"ttr": 5147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x7f\\x00\\x88\\x16\\x7f\\x08W\\x00J\\x00J\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-15T00:00:00", "modifydate": "1988-06-15T08:57:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: MULTIPLE-VALUE-SETQ\n\nSyntax:   (MULTIPLE-VALUE-SETQ list1 form2)\n\n list1 (required, not evaluated) - a list of variables.\n form2 (required, evaluated)     - any LISP object.\n\nReturns:\n\n The first value returned by form2, after all the values returned by\n form2 are assigned to the variables in list1.\n\nProcessing:\n\n form2 is evaluated with the expectation that multiple values may be\n returned.  The values are then assigned to the variables in list1\n (which must be symbols) in order, according to the following rules:\n\n  If there are fewer values than variables, the remaining variables\n  are set to NIL.\n\n  If there are more values than variables, the excess values are\n  ignored.\n\n Note that if the form returns no values, all of the variables are\n set to NIL.  If the form returns a single value (for example, it\n is not a multiple-value-returning function at all), then the first\n variable in list1 receives the value and the others (if any) are\n set to NIL.\n\n Note that no new bindings are created.  The variables are assigned\n exactly as they would be by SETQ.\n\nErrors signaled:\n\n Too few or too many arguments.\n Invalid variable list (errors detected by SETQ).\n\nNotes:\n\n Compare MULTIPLE-VALUE-BIND, which creates a new binding environment\n with new variable names.\n\n See VALUES and VALUES-LIST for information on how multiple values\n are returned from a function.\n\n See Guy Steele's \"Common LISP: The Language\", pp. 133-139, for\n an explanation of multiple values in LISP.  Although the constant\n MULTIPLE-VALUES-LIMIT is not defined in ZIL, returning more than\n 4095 multiple values is not supported.\n\n In many cases, use of multiple values in ZIL is more expensive than\n just consing up a list of the values and extracting the values from\n the list via destructuring.  In any case, out of all the forms that\n request multiple values, only MULTIPLE-VALUE-BIND in compiled code\n is guaranteed not to cons in ZIL.\n\nExamples:\n\n (DECLARE (SPECIAL A B C D E F G))    ==> NIL\n\n (MULTIPLE-VALUE-SETQ (A    ) (VALUES 1 2 3 4))   ==> 1\n (MULTIPLE-VALUE-SETQ (B C  ) (VALUES 5 6 7 8))   ==> 5\n (MULTIPLE-VALUE-SETQ (D E F) (VALUES 9))         ==> 9\n (MULTIPLE-VALUE-SETQ (G    ) (VALUES))           ==> NIL\n A  ==> 1\n B  ==> 5\n C  ==> 6\n D  ==> 9\n E  ==> NIL\n F  ==> NIL\n G  ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NCONC": {"ttr": 5149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x17A\\x00>\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T17:41:00", "lines": 62, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NCONC\n\nSyntax:   (NCONC &rest lists)\n\n list (optional, evaluated) - a list\n                             (although the last argument need not be).\n\nReturns:\n\n A list consisting of all the elements (CAR's) of all the arguments\n combined into one list.\n\nProcessing:\n\n All arguments except the last are destructively altered.  Each\n argument is RPLACD'd onto the last CAR of the preceding argument.\n\n (NCONC) (with no arguments) returns NIL.\n\n (NCONC list) returns \"list\", unaltered.\n\n If the first argument is NIL, NCONC of the remainder of the list is\n returned.\n\n Compare APPEND, which makes copies of its arguments (except for the\n last one, of course).\n\nErrors signaled:\n\n Argument not a proper list.\n\nNotes:\n\n As with all the \"destructive\" functions, NCONC should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\n Do not depend upon NCONC's altering of the first argument if the\n first argument may be NIL.  Use SETQ to insure updating of the\n first argument, as follows:\n\n  (SETQ X (NCONC X Y))\n\nExamples:\n\n (NCONC)                     ==> NIL\n (NCONC '(A B C))            ==> (A B C)\n (NCONC '(A B C) '(D E F))   ==> (A B C D E F)\n\n;The following shows how the list is altered by NCONC.\n\n (SETQ X '(A))               ==> (A)\n (SETQ Y '(B C))             ==> (B C)\n (SETQ Z '(D E F))           ==> (D E F)\n (SETQ W (NCONC X Y Z))      ==> (A B C D E F)\n X                           ==> (A B C D E F)\n Y                           ==> (B C D E F)\n Z                           ==> (D E F)\n (EQ X W)                    ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NCONC2": {"ttr": 5151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x17B\\x00D\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T17:42:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NCONC2\n\nSyntax:   (NCONC2 arg1 arg2)\n\n arg1 (required, evaluated) - a proper list.\n arg2 (required, evaluated) - any LISP object, but generally a list.\n\nReturns:\n\n A list consisting of the elements of arg1 followed by the elements of\n arg2.\n\nProcessing:\n\n If arg1 is NIL, arg2 is returned.  Otherwise, arg1 is destructively\n altered; arg2 is RPLACD'd onto the last CAR of arg1.\n\n If arg2 is atomic, a list ending in a dotted pair will result.\n\n Compare APPEND2, which makes a copy of its first argument.\n\nErrors signaled:\n\n Argument 1 not a proper list.\n\nNotes:\n\n NCONC2 is the two-argument form of NCONC, used to implement calls to\n NCONC in most compiled code.\n\n As with all the \"destructive\" functions, NCONC2 should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\n Do not depend upon NCONC2's altering of the first argument if the\n first argument may be NIL.  Use SETQ to insure updating of the\n first argument, as follows:\n\n  (SETQ X (NCONC2 X Y))\n\nExamples:\n\n (NCONC2 NIL NIL)            ==> NIL\n (NCONC2 NIL '(A B C))       ==> (A B C)\n (NCONC2 '(A B C) NIL)       ==> (A B C)\n (NCONC2 '(A) '(B))          ==> (A B)\n (NCONC2 '(A) 'B)            ==> (A . B)\n (NCONC2 '(A B) '(C D))      ==> (A B C D)\n (NCONC2 '(A B C) 'D)        ==> (A B C . D)\n\n;The following shows how the list is altered by NCONC2.\n\n (SETQ X '(A B C))           ==> (A B C)\n X                           ==> (A B C)\n (SETQ Y (NCONC2 X '(D E)))  ==> (A B C D E)\n X                           ==> (A B C D E)\n Y                           ==> (A B C D E)\n (EQ X Y)                    ==> T\n\n;The following shows how the second argument to NCONC2 is not copied.\n\n (SETQ X '(A))               ==> (A)\n (SETQ Y '(B C))             ==> (B C)\n (SETQ Z (NCONC2 X Y))       ==> (A B C)\n (EQ (CDR Z) Y)              ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NCONS": {"ttr": 5153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%/\\x18\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-09T18:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NCONS\n\nSyntax:   (NCONS arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A CONS (list or dotted pair) whose CAR is arg1 and whose CDR is NIL.\n\nProcessing:\n\n (NCONS arg1) is identical to (CONS arg1 NIL).\n\nErrors signaled:\n\n None except for garbage collection errors.\n\nNotes:\n\n\nExamples:\n\n (NCONS NIL)              ==> (NIL)\n (NCONS 'A)               ==> (A)\n (NCONS '(A B))           ==> ((A B))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NEQ": {"ttr": 5155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%/\\x18\\x01\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-09T18:01:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: NEQ\n\nSyntax:   (NEQ arg1 arg2)\n\n arg1 (required,evaluated) - any LISP object.\n arg2 (required,evaluated) - any LISP object.\n\nReturns:\n\n NIL if arg1 is EQ to arg2, otherwise T.\n\nProcessing:\n\n See EQ for more information.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (NEQ 'A 'A)           ==> NIL\n (NEQ 'A 'B)           ==> T\n (NEQ \"a\" \"a\")         ==> T\n (NEQ () NIL)          ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWLINEP": {"ttr": 5157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18\\x04\\x000\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:04:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NEWLINEP\n\nSyntax:   (NEWLINEP arg1)\n\n arg1 (optional, evaluated) - an input file name.\n\nReturns:\n\n T if end-of-line status has been reached on the input file specified\n by arg1, else NIL.\n\nProcessing:\n\n If the newline flag is on in the input file specified by arg1,\n T is returned; otherwise NIL is returned.\n\n A ZIL program or function should issue this function call while\n processing one or more READCH or TYI calls to see if end-of-line has\n been reached, especially if characters are to be processed without\n regard to end-of-line conditions.  A NIL result returned by READCH may\n be caused by either end-of-file or end-of-line; the EOF and NEWLINEP\n functions should be used to test for these.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n\nNotes:\n\n See READCH and TYI for more information on end-of-file and end-of-line\n conditions.\n\n See member $FILE for more information on file names.\n\n READCH, READLINE, TYI, and ZILRDCH are currently the only functions\n that set NEWLINEP to true.  ENDREAD will not do this; it will only\n cause a subsequent READCH, etc. to detect end-of-line and return NIL,\n at which point NEWLINEP will be true.\n\nExamples:\n\n (NEWLINEP)\n (NEWLINEP NIL) ...are equivalent.\n\n (NEWLINEP 'FOO) returns T if end-of-line has been reached on FOO.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NEWS": {"ttr": 5159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&_\\x00\\x88\\x16\\x9f\\x08Y\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-22T00:00:00", "modifydate": "1988-06-17T08:59:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: NEWS\n\nSyntax:   (NEWS &optional arg1)\n\n arg1 (optional, not evaluated) - any LISP object, generally T or NIL.\n\nReturns:\n\n No values, after listing the on-line ZIL news if any.\n\nProcessing:\n\n Member $NEWS of 'PROGLIB.ZIL.TEXT', which contains the current ZIL\n news if any, is displayed in line mode if arg1 is omitted or NIL,\n or in full screen mode if arg1 is specified and non-NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NOT": {"ttr": 5378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18\\x04\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:04:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NOT\n\nSyntax:   (NOT arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is NIL, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n NOT is equivalent to NULL.\n\nExamples:\n\n (NOT T)          ==> NIL\n (NOT NIL)        ==> T\n (NOT '(NIL))     ==> NIL\n (NOT (EQ 'A 'A)) ==> NIL\n (NOT (EQ 'A 'B)) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NOTANY": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x12\\x7f\\x00\\x87%/\\x18\\x04\\x00.\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-05-07T00:00:00", "modifydate": "1987-09-09T18:04:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NOTANY\n\nSyntax:   (NOTANY arg1 arg2 ... argn)\n\n arg1 (required, evaluated) - a function that can be APPLY'ed.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n T if all of the values produced by applying the first argument\n function to successive elements (CAR's) of the other argument lists\n are NIL, else T.\n\nProcessing:\n\n The function specified by the first argument is applied to each of the\n elements (CAR's) of the lists specified by the other arguments, until\n one of the lists is exhausted (in which case NOTANY returns T) or a\n non-NIL value is produced by this application (in which case NOTANY\n returns NIL).\n\n If no lists are specified, NOTANY returns T.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare SOME, EVERY, NOTEVERY, and the mapping functions.\n\nExamples:\n\n (NOTANY #'INTEGERP NIL)           ==> T\n (NOTANY #'INTEGERP '(A B C D E))  ==> T\n (NOTANY #'INTEGERP '(1 2 3 4 5))  ==> NIL\n (NOTANY #'INTEGERP '(A 2 3 4 5))  ==> NIL\n (NOTANY #'INTEGERP '(1 2 3 4 E))  ==> NIL\n (NOTANY #'INTEGERP '(A B 3 D E))  ==> NIL\n (NOTANY #'EQ '(A B C) '(A B C D)) ==> NIL\n (NOTANY #'EQ '(X B C) '(A B C D)) ==> NIL\n (NOTANY #'EQ '(X Y Z) '(A B C D)) ==> T\n (NOTANY #'EQ '(A B Z) '(A B C D)) ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NOTEVERY": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x12\\x7f\\x00\\x87%/\\x18\\x05\\x00.\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-05-07T00:00:00", "modifydate": "1987-09-09T18:05:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NOTEVERY\n\nSyntax:   (NOTEVERY arg1 arg2 ... argn)\n\n arg1 (required, evaluated) - a function that can be APPLY'ed.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n T if any of the values produced by applying the first argument\n function to successive elements (CAR's) of the other argument lists\n is NIL, else NIL.\n\nProcessing:\n\n The function specified by the first argument is applied to each of the\n elements (CAR's) of the lists specified by the other arguments, until\n one of the lists is exhausted (in which case NOTEVERY returns NIL)\n or a null value is produced by this application (in which case NOTEVERY\n returns T).\n\n If no lists are specified, NOTEVERY returns NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare SOME, EVERY, NOTANY, and the mapping functions.\n\nExamples:\n\n (NOTEVERY #'INTEGERP NIL)           ==> NIL\n (NOTEVERY #'INTEGERP '(A B C D E))  ==> T\n (NOTEVERY #'INTEGERP '(1 2 3 4 5))  ==> NIL\n (NOTEVERY #'INTEGERP '(A 2 3 4 5))  ==> T\n (NOTEVERY #'INTEGERP '(1 2 3 4 E))  ==> T\n (NOTEVERY #'INTEGERP '(A B 3 D E))  ==> T\n (NOTEVERY #'EQ '(A B C) '(A B C D)) ==> NIL\n (NOTEVERY #'EQ '(X B C) '(A B C D)) ==> T\n (NOTEVERY #'EQ '(X Y Z) '(A B C D)) ==> T\n (NOTEVERY #'EQ '(A B Z) '(A B C D)) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NRECONC": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x19\\x1f\\x00\\x87%/\\x18\\x05\\x00B\\x00B\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-07-10T00:00:00", "modifydate": "1987-09-09T18:05:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NRECONC\n\nSyntax:   (NRECONC arg1 arg2)\n\n arg1 (required, evaluated) - a proper list.\n arg2 (required, evaluated) - any LISP object, but generally a list.\n\nReturns:\n\n A list consisting of the elements of arg1 in reverse order followed by\n the elements of arg2.\n\nProcessing:\n\n (NRECONC X Y) is equivalent to (NCONC (NREVERSE X) Y).\n\n If arg1 is NIL, arg2 is returned.  Otherwise, arg1 is destructively\n altered.\n\n If arg2 is atomic, a list ending in a dotted pair will result.\n\n Compare REVAPPEND, which does not destroy its first argument.\n\nErrors signaled:\n\n Argument 1 not a proper list.\n\nNotes:\n\n As with all the \"destructive\" functions, NRECONC should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\n Do not depend upon NRECONC's altering of the first argument if the\n first argument may be NIL.  Use SETQ to insure updating of the\n first argument, as follows:\n\n  (SETQ X (NRECONC X Y))\n\nExamples:\n\n (NRECONC NIL NIL)           ==> NIL\n (NRECONC NIL '(A B C))      ==> (A B C)\n (NRECONC '(A B C) NIL)      ==> (C B A)\n (NRECONC '(A) '(B))         ==> (A B)\n (NRECONC '(A) 'B)           ==> (A . B)\n (NRECONC '(A B) '(C D))     ==> (B A C D)\n (NRECONC '(A B C) 'D)       ==> (C B A . D)\n\n;The following shows how the list is altered by NRECONC.\n\n (SETQ X '(A B C))           ==> (A B C)\n X                           ==> (A B C)\n (SETQ Y (NRECONC X '(D E))) ==> (C B A D E)\n X                           ==> (A D E)\n Y                           ==> (C B A D E)\n\n;The following shows how the second argument to NRECONC is not copied.\n\n (SETQ X '(A))               ==> (A)\n (SETQ Y '(B C))             ==> (B C)\n (SETQ Z (NRECONC X Y))      ==> (A B C)\n (EQ (CDR Z) Y)              ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NREVERSE": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18\\x05\\x00&\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:05:00", "lines": 38, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NREVERSE\n\nSyntax:   (NREVERSE list1)\n\n list1 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of list1 in reverse order.\n\nProcessing:\n\n The cells of list1 are bashed to make the reversed list.\n Note that the CAR's of the list are NOT recursively NREVERSEd.\n\n Compare REVERSE, which makes a copy of its argument.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (NREVERSE NIL)              ==> NIL\n (NREVERSE '(A))             ==> (A)\n (NREVERSE '(A B C D))       ==> (D C B A)\n (NREVERSE '((A B) (C D)))   ==> ((C D) (A B))\n\n;The following shows how NREVERSE destroys its argument.\n\n (SETQ X '(Z I L))           ==> (Z I L)\n X                           ==> (Z I L)\n (SETQ Y (NREVERSE X))       ==> (L I Z)\n X                           ==> (Z)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NTH": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18\\x06\\x00)\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:06:00", "lines": 41, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NTH\n\nSyntax:   (NTH arg1 arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n The \"n'th\" element of the list specified by arg2, where arg1 selects\n which element, counting from zero.\n\nProcessing:\n\n If arg1 is greater than or equal to the length of the list specified by\n arg2, NIL is returned.  Otherwise the \"nth\" CAR of the list is\n returned, as follows:\n\n  (NTH 0 list) is equivalent to (CAR list),\n  (NTH 1 list) is equivalent to (CADR list),\n  etc.\n\nErrors signaled:\n\n First argument not a fixnum, or is negative.\n Second argument not a proper list or NIL.\n\nNotes:\n\n Although (NTH 0 list) is equivalent to (CAR list), it is not as\n efficient since the first argument is always evaluated arithmetically.\n\nExamples:\n\n (NTH 0 '(A B C))         ==> A\n (NTH 1 '(A B C))         ==> B\n (NTH 2 '(A B C))         ==> C\n (NTH 3 '(A B C))         ==> NIL\n (NTH 4 '(A B C))         ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NTHCDR": {"ttr": 5390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18\\x07\\x00*\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:07:00", "lines": 42, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NTHCDR\n\nSyntax:   (NTHCDR arg1 arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n The \"n'th\" sublist of the list specified by arg2, where arg1 selects\n which sublist, counting from zero.\n\nProcessing:\n\n If arg1 is greater than or equal to the length of the list specified by\n arg2, NIL is returned.  Otherwise the \"nth\" CDR of the list is\n returned, as follows:\n\n  (NTHCDR 0 list) is equivalent to list,\n  (NTHCDR 1 list) is equivalent to (CDR list),\n  (NTHCDR 2 list) is equivalent to (CDDR list),\n  etc.\n\nErrors signaled:\n\n First argument not a fixnum, or is negative.\n Second argument not a proper list or NIL.\n\nNotes:\n\n Although (NTHCDR 1 list) is equivalent to (CDR list), it is not as\n efficient since the first argument is always evaluated arithmetically.\n\nExamples:\n\n (NTHCDR 0 '(A B C))      ==> (A B C)\n (NTHCDR 1 '(A B C))      ==> (B C)\n (NTHCDR 2 '(A B C))      ==> (C)\n (NTHCDR 3 '(A B C))      ==> NIL\n (NTHCDR 4 '(A B C))      ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NULL": {"ttr": 5392, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18\\x04\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:04:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NULL\n\nSyntax:   (NULL arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is NIL, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n NULL is equivalent to NOT.\n\nExamples:\n\n (NULL T)          ==> NIL\n (NULL NIL)        ==> T\n (NULL '(NIL))     ==> NIL\n (NULL (EQ 'A 'A)) ==> NIL\n (NULL (EQ 'A 'B)) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NUMBERP": {"ttr": 5394, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18\\x08\\x00\"\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:08:00", "lines": 34, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: NUMBERP\n\nSyntax:   (NUMBERP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a number, otherwise NIL.\n\nProcessing:\n\n Fixnums, bignums, single-floats, and double-floats are all numbers.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (NUMBERP 1.0)    ==> T\n (NUMBERP 1)      ==> T\n (NUMBERP '1)     ==> T\n (NUMBERP '\\1)    ==> NIL\n (NUMBERP \"1\")    ==> NIL\n (NUMBERP 1F1)    ==> T\n (NUMBERP 1D1)    ==> T\n (NUMBERP 1000000000000000000000000000) ==> T\n (NUMBERP '(1))   ==> NIL\n (NUMBERP 'ONE)   ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OBLIST": {"ttr": 5396, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%/\\x18\\x12\\x00\\x1c\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-09T18:12:00", "lines": 28, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: OBLIST\n\nSyntax:   (OBLIST)\n\nReturns:\n\n The current list (oblist) of interned symbols.\n\nProcessing:\n\n A list of all the currently interned symbols is returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Do not perform destructive operations on the oblist.  Such actions have\n unpredictable results, and could conceivably be dangerous to the ZIL\n environment.\n\n The officially sanctioned Common Lisp way of accessing interned\n symbols is via the MAPATOMS macro.  Use of the (OBLIST) function\n is frowned upon, and will probably cause experienced LISP programmers\n to laugh at your use of such a blatantly old-fashioned feature.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ODDP": {"ttr": 5398, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x11O\\x00\\x87%/\\x18\\x12\\x00 \\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-04-24T00:00:00", "modifydate": "1987-09-09T18:12:00", "lines": 32, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ODDP\n\nSyntax:   (ODDP arg1)\n\n arg1 (required, evaluated) - an integer.\n\nReturns:\n\n T if arg1 is odd (not divisible by two), else NIL.\n\nProcessing:\n\nErrors signaled:\n\n Non-integer argument.\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (ODDP 0)              ==> NIL\n (ODDP 7)              ==> T\n (ODDP -8)             ==> NIL\n (ODDP 10000000000000) ==> NIL\n (ODDP 99999999999999) ==> T\n (ODDP -1000000000000) ==> NIL\n (ODDP -9999999999999) ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OFF": {"ttr": 5400, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x880\\x9f\\x00\\x880\\x9f\\t7\\x006\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-04T00:00:00", "modifydate": "1988-11-04T09:37:00", "lines": 54, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: OFF\n\nSyntax:   (OFF funspec)\n\n funspec (required, not evaluated) - a symbol funname, list (funname),\n         or a list (funname aspect),\n         where: funname is a symbol naming a function\n                aspect is one of:  ENTRY, :ENTRY, EXIT, :EXIT\n\nReturns:\n\n funname, after cancelling any outstanding AT specification for the\n function specified by funname and the aspect.\n\nProcessing:\n\n Any processing specified by a previous AT for the function and the\n aspect (entry or exit) is cancelled.  This results in reversion of\n the function's entry or exit processing to the default tracing\n behavior, which is to print \"Entering\" or \"Exiting\" and the\n argument or values list.\n\n If no aspect is given, it defaults to entry.\n\n If the function is not currently being traced, or there is no AT\n for that function, no action is taken.  Specifically, OFF does NOT\n remove tracing for the function; use UNTRACE for that purpose.\n\n\nErrors signaled:\n\n Invalid function name.\n Invalid aspect (not entry or exit).\n\nNotes:\n\n See also AT, TRACE, and UNTRACE.\n\n See member $TRACE of this document for a description of tracing,\n and for examples of use.\n\n See ZILTRACE for technical details on how tracing and untracing\n are effected.\n\nExamples:\n\n;(OFF FOO)\n;(OFF (FOO ENTRY))\n;(OFF (FOO :ENTRY))       all remove an AT breakpoint for FOO entry.\n;\n;(OFF (FOO EXIT))\n;(OFF (FOO :EXIT))        all remove an AT breakpoint for FOO exit.\n;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OFILEP": {"ttr": 5402, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x863_\\x00\\x87%/\\x18\\x12\\x00+\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-12-01T00:00:00", "modifydate": "1987-09-09T18:12:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: OFILEP\n\nSyntax:   (OFILEP file1)\n\n file1 (required, evaluated) - a file name.\n\nReturns:\n\n T if file1 is a valid output file, else NIL.\n\nProcessing:\n\n If the file specified by the first argument is an already open output\n file, then T is returned.  If the file is not an already open output\n file, then an attempt is made to open the file name consisting of\n 'ZILO' + the file name, as for all ZIL file accessing functions.\n If such a file exists, T is returned; otherwise NIL is returned.\n If any error occurs trying to process the file, the error is\n signalled; in other words, OFILEP suppresses \"file does not exist\"\n errors only.\n\nErrors signaled:\n\n See above description.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Because an MVS file (ddname) allocation remains around even after\n the file is closed under ZIL, issuing OFILEP against a closed\n output file will cause the file to be reopened.\n\nExamples:\n\n (OFILEP NIL)    will always return T.\n\n (OFILEP 'FOO)   returns T if a ddname ZILOFOO is allocated to a\n                 usable data set.\n\n (OFILEP (OPEN \"foo.data\" 'out))     should return T.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OK": {"ttr": 5404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%/\\x18\\x14\\x00,\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-09T18:14:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: OK\n\nSyntax:   (OK &rest forms)\n\n forms (required, evaluated) - any LISP object.\n\nReturns:\n\n T if all the forms are successfully evaluated without error;\n NIL if an error occurred during evaluation of any of the forms\n (i.e. THROW to tag NIL).\n\nProcessing:\n\n The forms are evaluated as an implicit PROGN.  If an error occurs\n (or a THROW to tag NIL) while any of these forms is evaluated,\n evaluation terminates and the OK form returns NIL.  If no error\n occurs, OK returns T.\n\n See ERROR, CATCH and THROW for more information.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n OK is a convenient way to do something and tell whether an error\n occurred while doing it.\n\nExamples:\n\n (FMAKUNBOUND 'FOO)                  ==> FOO\n (PROG (A)\n       (IF (OK (SETQ A (FOO)))\n           (RETURN A)\n           (RETURN \"A not set.\")))   ==> \"A not set.\" ; FOO not defined\n (DEFUN FOO () \"success\")            ==> FOO\n (PROG (A)\n       (IF (OK (SETQ A (FOO)))\n           (RETURN A)\n           (RETURN \"A not set.\")))   ==> \"success\"    ; FOO was defined\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPEN": {"ttr": 5406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18$\\x00\\x98\\x00Q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:24:00", "lines": 152, "newlines": 81, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: OPEN\n\nSyntax:   (OPEN arg1 &optional arg2)\n\n arg1 (required, evaluated) - a data set name (string or symbol).\n arg2 (optional, evaluated) - NIL, or one of the following symbols:\n                              INPUT, OUTPUT, IN, OUT, APPEND, PROBE.\n\nReturns:\n\n If arg2 is not PROBE:\n\n A file name, after allocating the data set specified by arg1 and\n opening it for the mode specified by arg2.\n\n If arg2 is PROBE:\n\n arg1 if it exists as a data set name, else NIL.\n\nProcessing:\n\n arg1, which should be a symbol or string, is interpreted as a data set\n name in standard TSO format (quoted or unquoted, member name present or\n absent).\n\n If arg2 is not PROBE, the data set is dynamically allocated and opened.\n The mode is determined by arg2 as follows:\n\n   INPUT    -  the file is opened for input.\n   OUTPUT   -  the file is opened for output.\n   APPEND   -  the file is opened for output in \"append\" mode.\n\n If arg2 is omitted or NIL, INPUT is assumed.\n\n IN and INPUT are equivalent, as are OUT and OUTPUT.\n\n Any of these non-NIL values can be specified with a leading colon\n (i.e. as a \"keyword\").  In other words, OUT and :OUT are equivalent.\n Furthermore, if a list is specified as the second argument, the CAR\n of that list is assumed to be the file type and is analyzed as above.\n Thus, the following are equivalent:\n\n   (OPEN \"foo.data\")\n   (OPEN \"foo.data\" NIL)\n   (OPEN \"foo.data\" 'IN)\n   (OPEN \"foo.data\" 'INPUT)\n   (OPEN \"foo.data\" :IN)\n   (OPEN \"foo.data\" :INPUT)\n   (OPEN \"foo.data\" '(IN))\n   (OPEN \"foo.data\" '(:INPUT FROBNICANT BARFUCIOUS))\n\n If arg2 is PROBE or :PROBE, then the data set is dynamically\n allocated to see if it actually exists.  If so, arg1 is returned;\n otherwise NIL is returned.\n\n The data set name may contain lower and/or upper case characters;\n OPEN translates the name to all upper case internally.\n\n If the data set is opened for input, it must be either a sequential\n data set or a partitioned data set with a valid member name (i.e. the\n member must already exist).  It must be a currently existing\n (cataloged) data set.\n\n If the data set is opened for output, it must be either a sequential\n data set or a partitioned data set with a member name (which need not\n exist already).  If it does not currently exist, it will be created\n as a new data set.  The data set is allocated exclusively, and thus\n cannot be in use by any other user or job.\n\n If APPEND was specified as arg2 and the data set already exists, the\n data set is allocated as MOD so that data will be written after any\n existing data in the dataset.  If OUT or OUTPUT was specified as arg2\n and the data set already exists, it will be made empty when it is\n opened, and data will be written to it starting at the beginning of the\n data set.  Currently NO WARNING is given that this has happened!\n\n If PROBE was specified as arg2, the data set is considered to be \"not\n found\" if it is not cataloged, it is syntactically invalid, a member\n name was specified but is not found, or if a member name is specified\n and the data set is not partitioned.  All other error conditions still\n signal errors.  Furthermore, no file object is created when PROBE is\n specified.\n\n Note: The following discussion of file objects does not pertain to\n OPEN with the PROBE option.\n\n Each invocation of OPEN creates a new, unique ZIL file allocation, so\n that accesses to that file start at the beginning of the file.  Up to\n 9999 input and output files can be concurrently open by OPEN (it may be\n necessary to CLOSE some files to prevent OPEN from being unable to\n acquire virtual storage or use a file name).\n\n The file names are maintained in a counter that starts at 0001 and is\n incremented by 1.  The file name is always a 4-character symbol,\n despite its digital content.  No check is made for counter overflow;\n thus the limitation above.\n\nErrors signaled:\n\n Invalid second argument (not one of those listed above).\n Data set not available, or other dynamic allocation failure.\n Syntax error in data set name or member name.\n A data set with a member name was specified for an APPEND request\n  (this is not permitted in MVS - you cannot open a PDS member as MOD).\n A member name was specified but the dataset is not partitioned.\n The specified member name is not in the dataset.\n The dataset is not sequential or partitioned, or an input request\n  was made for a dataset that was never opened (is empty).\n Errors in system routines used to verify or report on allocation.\n\n Note: Some of the above errors may not be errors if PROBE is\n specified, but may merely cause NIL to be returned.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See CLOSE for more information, particularly about the behavior\n of OPEN and CLOSE under Macsyma.\n\n Currently, if a new dataset is created for an output request, the\n DCB attributes RECFM=FB, LRECL=80, BLKSIZE=6160 are assigned.  You\n may override these attributes by preallocating the data set before\n issuing OPEN.\n\n Although no check is made for the following conditions, you should\n NEVER do them:\n\n * Have more than 1 member of the same PDS open for output\n   (they will write to the same area of the PDS, and when they are\n    closed the directory entries will point to the same data)\n\n * Open a file for APPEND while it is also open for OUTPUT\n   (you must CLOSE the OUTPUT file before opening it for APPEND)\n\nExamples:\n\n (Watch the quote marks carefully!)\n\n  (OPEN \"cmd.lisp(myfunc)\")\n  (OPEN \"'SOMEONE.ELSES.DATASET'\" 'INPUT)\n  (OPEN '|foo.data| 'OUTPUT) ; OK, because the dsname is always upcased.\n\n A typical sequence could be like this:\n\n (SETQ A (OPEN \"'proglib.zil.source(junk)'\"))\n (LOOP DO (READ A) UNTIL (EOF A)\n       FINALLY (CLOSE A))\n\n However, WITH-OPEN-FILE is the preferred form to use for this.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OR": {"ttr": 5409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%/\\x18$\\x00)\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-09T18:24:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: OR\n\nSyntax:   (OR &rest args)\n\n arg (conditionally evaluated) - any LISP object.\n\nReturns:\n\n The first non-NIL argument specified; NIL if there is no such arg.\n\nProcessing:\n\n Each argument in succession is evaluated until one of them returns a\n value other than NIL; if so, evaluation of the following arguments\n is bypassed.  This is known as \"short-circuit\" evaluation.\n\n OR with no arguments returns NIL, by definition.\n\n OR may be used as a mini-conditional, e.g.:\n\n  (OR condition1 result) is equivalent to\n                                   (IF (NOT condition1) THEN result).\n  (OR cond1 cond2 ... condn result) is equivalent to\n                   (IF (NOT (OR cond1 cond2 ... condn)) THEN result).\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (OR)                    ==> NIL\n (OR 'A 'B 'C)           ==> A\n (OR NIL 'B 'C)          ==> B\n (OR NIL NIL NIL)        ==> NIL\n (OR (EQ 'A 'A) 'FALSE)  ==> T\n (OR (EQ 'A 'B) 'TRUE)   ==> TRUE\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PAIRLIS": {"ttr": 5411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(o\\x00\\x87(o\\x18\\x03\\x00*\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-13T00:00:00", "modifydate": "1987-10-13T18:03:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PAIRLIS\n\nSyntax:   (PAIRLIS list1 list2 &optional alist3)\n\n list1  (required, evaluated) - a proper list.\n list2  (required, evaluated) - a proper list.\n alist3 (optional, evaluated) - a list of dotted pairs.\n\n\nReturns:\n\n A list consisting of dotted pairs of elements taken from list1 and\n list3 consed onto alist3.\n\nProcessing:\n\n Elements (CAR's) of list1 and list2 are taken and made into dotted\n pairs, and these pairs are consed onto the beginning of arg3\n (which defaults to NIL) to make a new association list.\n\n alist3 is unchanged.\n\nErrors signaled:\n\n list1 or list2 not a proper list.\n list1 and list2 are not of the same length.\n\nNotes:\n\n The pairs end up in the result alist in reverse order; in other words,\n the last elements of list1 and list2 make up the first pair of the\n resulting alist.\n\n list3 is not validity checked; it may be any kind of object at all.\n\nExamples:\n\n (PAIRLIS '(A B C) '(1 2 3)) ==> ((C . 3) (B . 2) (A . 1))\n (PAIRLIS '(A B) '(1 2) '((F . O) (O . NIL)))\n                             ==> ((B . 2) (A . 1) (F . O) (O . NIL))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARSBODY": {"ttr": 5413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x17?\\x00\\x88\\x17?\\x17E\\x00v\\x00v\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-21T00:00:00", "modifydate": "1988-06-21T17:45:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PARSE-BODY\n\nSyntax:   (PARSE-BODY body1 &optional env2 docp3)\n    or:   (PARSBODY   body1 &optional env2 docp3)\n\n body1 (required, evaluated) - a list of forms.\n env2  (optional, evaluated) - a macroexpansion environment.\n docp3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n 5 values:\n\n   (1) A documentation string, or NIL.\n   (2) A list of declaration specifications.\n   (3) A list of body forms, not macroexpanded.\n   (4) A macroexpanded form of the first element of (3), or NIL.\n   (5) T if (4) is a valid macroexpansion of (3), otherwise NIL.\n\nProcessing:\n\n PARSE-BODY is used to parse the body of a LAMBDA or a macro with\n syntax similar to a LAMBDA into a documentation string, declarations,\n and the body without the documentation string or declarations.\n\n body1 is the body to be parsed.\n\n env2 is the macroexpansion environment.  Currently this argument is\n ignored, so you can specify anything you want, preferably NIL.\n\n docp3 is NIL if the body is not expected to contain a documentation\n string; otherwise a documentation string will be processed if present,\n as in the syntax of DEFUN.\n\nErrors signaled:\n\n None.  If errors occur during macroexpansion, they are ignored.\n\nNotes:\n\n PARSE-BODY must macroexpand forms in the body as it searches for\n declarations (into which macros can expand) and for documentation\n strings (into which macros CANNOT expand).\n\n Only one documentation string is permitted per body, although it\n can occur before, after, or between DECLARE forms.  Any other\n strings are assumed to be part of the body.\n\n Currently, if PARSE-BODY is used in the compiler (e.g. by a\n macroexpansion function that is taking apart the body of a\n macro form for compilation), it does not have access to any\n compile-time-only macros (CMACRO's).  This means that if you\n define any macros that expand into declarations, they must be\n made known at evaluation time as well (via EVAL-WHEN), just\n like SETF methods do.\n\n The caller of PARSE-BODY may use value 4 consed with the CDR of\n value 3 as the new body, provided that value 5 is non-NIL.  In\n this way, redundant macroexpansion may be avoided.\n\nExamples:\n\n (MULTIPLE-VALUE-LIST\n  (PARSE-BODY NIL))    ==>   (NIL NIL NIL NIL NIL)\n\n (MULTIPLE-VALUE-LIST\n  (PARSE-BODY '((CAR X) (CDR X)) NIL T))\n                       ==>   (NIL NIL ((CAR X) (CDR X)) (CAR X) T)\n\n (MULTIPLE-VALUE-LIST\n  (PARSE-BODY '((DECLARE (SPECIAL X))\n                (DECLARE (FIXNUM I) (FLONUM J))\n                (IF A B)\n                (IF C D)\n                FOO\n               )\n               NIL\n               T))\n                       ==>   (NIL\n                              ((SPECIAL X) (FIXNUM I) (FLONUM J))\n                              ((IF A B) (IF C D) FOO)\n                              (COND (A B))\n                              T\n                             )\n\n\n (MULTIPLE-VALUE-LIST\n  (PARSE-BODY '(\"this is a doc string\"\n                (DECLARE (SPECIAL X))\n                FOOBAR\n               )\n               NIL\n               T))\n                       ==>   (\"this is a doc string\"\n                              ((SPECIAL X))\n                              (FOOBAR)\n                              FOOBAR\n                              T\n                             )\n\n\n (MULTIPLE-VALUE-LIST\n  (PARSE-BODY '(\"this is a doc string\"\n                (DECLARE (SPECIAL X))\n                FOOBAR\n               )\n               NIL\n               NIL))\n                       ==>   (NIL\n                              NIL\n                              (\"this is a doc string\"\n                               (DECLARE (SPECIAL X))\n                               FOOBAR)\n                              \"this is a doc string\"\n                              T\n                             )\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PBIND": {"ttr": 5415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87%\\x9f\\x00\\x88\\x12O\\x08\\x18\\x00E\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1988-05-03T08:18:00", "lines": 69, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PBIND\n\nSyntax:   (PBIND arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n The contents of the value/binding cell of arg1.\n\nProcessing:\n\n If arg1 has no global value (even if it is dynamically bound),\n an object whose CDR is the \"unbound marker\" is returned.\n This could be the \"unbound marker\" itself - see ZILUNBND.\n\n If arg1 is self-evaluating (e.g. NIL, T or a \"keyword\"),\n arg1 is returned.\n\n Otherwise, a CONS whose CDR is the global value of the symbol\n is returned.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n The fact that (CDR (PBIND x)) returns the \"unbound marker\"\n does NOT means that x is unbound.  However, if (PBIND x) returns x,\n then x is self-evaluating.  This is a fair assumption that is used\n by many internal ZIL routines.\n\n This function is intended for internal use only, and is intimately\n tied up with ZIL's binding techniques.  Do not depend on it!\n\n See SETPBIND, which modifies the value/binding cell.  (Another\n function not to be used!)\n\nExamples:\n\n ; Assume PBIND_A and PBIND_B have never been assigned values.\n\n (PBIND NIL)        ==> NIL\n (PBIND T)          ==> T\n (PBIND :FOO)       ==> :FOO\n\n (PBIND 'PBIND_A)         ==> #.(zilunbnd) ; the \"unbound\" marker\n (SETQ PBIND_A \"foo\")     ==> \"foo\"\n (PBIND 'PBIND_A)         ==> (PBIND_A . \"foo\")\n\n (MAKUNBOUND 'PBIND_A)    ==> PBIND_A\n (PBIND 'PBIND_A)    ==> (PBIND_A . #.(zilunbnd)) ; \"bound\" but no value\n\n (MAKUNBOUND 'PBIND_B)    ==> PBIND_B\n (PBIND 'PBIND_B)         ==> #.(zilunbnd) ; the \"unbound\" marker\n\n (LET ((PBIND_B 1)) (PBIND 'PBIND_B)) ==> #.(zilunbnd)\n                                   ; Local binding makes no difference.\n\n (LET ((PBIND_B 1))\n      (DECLARE (SPECIAL PBIND_B))\n      (PBIND 'PBIND_B))  ==> #.(zilunbnd)\n      ; Even SPECIAL binding makes no difference.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSIZE": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x07/\\x00\\x87%?\\x07A\\x00\\x10\\x00\\n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-03-13T00:00:00", "modifydate": "1987-09-10T07:41:00", "lines": 16, "newlines": 10, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PDSIZE\n\nSyntax:   (PDSIZE)\n\nReturns:\n\n An integer containing the total number of BYTES (not stack slots)\n on the control stack (\"push-down stack\").\n\nNotes:\n\n This value may be specified via the PARM field, or in a DECLARE,\n when a ZIL \"program\" is run.  See members $PARM and DECLARE of\n this documentation for more information.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PEEK": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%?\\x07D\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-10T07:44:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PEEK\n\nSyntax:   (PEEK arg1)\n\n arg1 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum whose contents represent the contents of the fullword of\n virtual storage at the memory location pointed to by arg1.\n\nProcessing:\n\n arg1 is interpreted as a 31-bit address and is used as a pointer to\n access active main storage.\n\nErrors signaled:\n\n arg1 not a fixnum.\n\nNotes:\n\n Currently this function does not check the validity of the address.\n Therefore, 0C4 ABENDs are likely when using this function.\n\nExamples:\n\n (PEEK 0)                 ==> 67895296  ; i.e. X'040C0000'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PEEKB": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%?\\x07F\\x00!\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-10T07:46:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PEEKB\n\nSyntax:   (PEEKB arg1)\n\n arg1 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum whose contents represent the contents of the BYTE of\n virtual storage at the memory location pointed to by arg1.\n\nProcessing:\n\n arg1 is interpreted as a 31-bit address and is used as a pointer to\n access active main storage.\n\n This function loads 1 BYTE and makes a fixnum out of it;\n compare PEEK, which returns a FULLWORD of storage.\n\nErrors signaled:\n\n arg1 not a fixnum.\n\nNotes:\n\n Currently this function does not check the validity of the address.\n Therefore, 0C4 ABENDs are likely when using this function.\n\nExamples:\n\n (PEEKB 0)                     ==> 4         ; i.e. X'04'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PEEKC": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x88\\x12O\\x08\\x19\\x00(\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1988-05-03T08:19:00", "lines": 40, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "PEEKCH": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x881_\\x14\\x01\\x00\\x87\\x00X\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-11-10T14:01:00", "lines": 135, "newlines": 88, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PEEKCH\n\nSyntax:   (PEEKCH &optional file1 eofval2 newlineval3)\n\n file1       (optional, evaluated) - an input file name.\n eofval2     (optional, evaluated) - any LISP object.\n newlineval3 (optional, evaluated) - any LISP object.\n\nDefaults:\n\n file1 defaults to standard input (NIL).\n eofval2 defaults to NIL.\n newlineval3 defaults to the symbol whose print name is hex 0D\n             (carriage return).\n\nReturns:\n\n An interned symbol whose print name is a character read from the input\n file specified by file1; or eofval2 if end-of-file is encountered while\n scanning for a character; or newlineval3 if end-of-line is encountered\n while scanning for a character.\n\nProcessing:\n\n The file specified by file1 is read from the current character position\n and logical record (the ENDREAD and ZPUTFPI functions can change\n these).  One character is returned and made into a symbol, but the\n current character pointer is NOT updated to point to the next\n character.  Thus, repeated calls to PEEKCH without an intervening READ\n or READCH will return the same value.\n\n Compare READCH, which is identical to PEEKCH except that it updates\n the current character pointer (and also causes \"newline\" to be set).\n\n The character always creates an interned symbol, and is never\n uppercased.\n\n If end-of-file (i.e. the current character pointer has reached the end\n of the file) is encountered, eofval2 (or NIL if not supplied) is\n returned instead of a character.\n\n If end-of-line (i.e. the current character pointer has reached the end\n of the line) is encountered, newlineval3 is returned instead of a\n character.\n\n If the file is already in end-of-file status when PEEKCH is issued,\n an error is signalled.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n PEEKCH is designed for applications that need to do scanning in such\n a way as not to \"swallow up\" a character in the input stream.  It is,\n however, not perfect at this time, and its interaction with READ\n and READCH has not been thoroughly examined.\n\n A READCH following a PEEKCH should return the same symbol that\n PEEKCH did.\n\n PEEKCH does not set NEWLINEP.\n\n The PEEKCH provided in previous releases of ZIL, which had different\n syntax, is now called ZILPKCH.\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (progn\n  (with-open-file (file \"$$foo.$$test\" :out)\n   (format file \"~&?foobar~%\")\n  )\n  (setq foo (open \"$$foo.$$test\" :in))\n  t\n )                                  ==> T\n\n (PEEKCH FOO 'EOF 'NEWLINE)         ==> NEWLINE\n\n (TYI FOO)                          ==> #\\CR ; swallow first newline\n (TYI FOO)                          ==> #\\?  ; prime for a character\n\n (SETQ A (PEEKCH FOO 'EOF 'NEWLINE))  ==> |f|\n (EQ A                          '|f|)     ==> T\n (READCH FOO 'EOF 'NEWLINE)  ==> |f|      ; Swallow the character.\n\n (SETQ A (PEEKCH FOO 'EOF 'NEWLINE))  ==> |o|\n (EQ A                          '|o|)     ==> T\n (READCH FOO 'EOF 'NEWLINE)  ==> |o|      ; Swallow the character.\n\n (SETQ A (PEEKCH FOO 'EOF 'NEWLINE))  ==> |o|\n (EQ A                          '|o|)     ==> T\n (READCH FOO 'EOF 'NEWLINE)  ==> |o|      ; Swallow the character.\n\n (SETQ A (PEEKCH FOO 'EOF 'NEWLINE))  ==> |b|\n (EQ A                          '|b|)     ==> T\n (READCH FOO 'EOF 'NEWLINE)  ==> |b|      ; Swallow the character.\n\n (SETQ A (PEEKCH FOO 'EOF 'NEWLINE))  ==> |a|\n (EQ A                          '|a|)     ==> T\n (READCH FOO 'EOF 'NEWLINE)  ==> |a|      ; Swallow the character.\n\n (SETQ A (PEEKCH FOO 'EOF 'NEWLINE))  ==> |r|\n (EQ A                          '|r|)     ==> T\n (READCH FOO 'EOF 'NEWLINE)  ==> |r|      ; Swallow the character.\n\n (loop until (neq (peekch foo) '| |)\n       do (readch foo)\n       finally (return t))   ==> T\n\n  ;\n  ; Now watch what happens when we get to a newline.\n  ;\n\n (PEEKCH FOO 'EOF 'NEWLINE)  ==> NEWLINE\n (READCH FOO 'EOF 'NEWLINE)  ==> NEWLINE  ; Swallow the character.\n (READCH FOO 'EOF 'NEWLINE)  ==> EOF      ; Read the next one.\n\n\n;\n; Unfortunately, there seems to be no way to get PEEKCH to return EOF,\n; due to problems explained above with new-line-processing.\n;\n\n (PEEKCH FOO)                ==> (\"***ERROR***\") ; Read after EOF.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PEEKL": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x88\\x12O\\x08#\\x000\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1988-05-03T08:23:00", "lines": 48, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PEEKL\n\nSyntax:   (PEEKL arg1 arg2 &optional arg3)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a fixnum.\n arg3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A list, arg2 in length, of 1-character symbols whose contents represent\n the contents of the bytes of virtual storage starting at the memory\n location pointed to by arg1.\n\nProcessing:\n\n arg1 is interpreted as a 31-bit address and is used as a pointer to\n access active main storage.\n\n arg2 specifies the number of bytes to be collected and made into a\n list.\n\n If arg3 is specified and not NIL, the symbol is interned on the\n oblist; otherwise it is not.\n\n The IMPLODE function may be used to turn this list into a symbol;\n STRING-APPEND may be applied to the list to turn it into a string.\n\nErrors signaled:\n\n arg1 or arg2 not a fixnum.\n\nNotes:\n\n Currently this function does not check the validity of the address.\n Therefore, 0C4 ABENDs are likely when using this function.\n\nExamples:\n\n;(SETQ A (PEEKL (+ (PEEK #X10) #X154) 8)) ==> (N O N A M E | | | |)\n;(IMPLODE A)                              ==> |NONAME  |\n;(APPLY #'STRING-APPEND A)                ==> \"NONAME  \"\n;\n (SETQ A (PEEKL (+ (PEEK #X10) #X154) 8)) ==> (C S D L | | | | | | | |)\n (IMPLODE A)                              ==> |CSDL    |\n (APPLY #'STRING-APPEND A)                ==> \"CSDL    \"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLIST": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x08%\\x00>\\x00;\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T08:25:00", "lines": 62, "newlines": 59, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SYMBOL-PLIST\n\nSyntax:   (SYMBOL-PLIST arg1)\n    or:   (PLIST arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n The property list of arg1.\n\nProcessing:\n\n If arg1 has no property list, NIL is returned.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n SYMBOL-PLIST and PLIST are both acceptable names, for compatibility\n with both Common LISP and Maclisp.\n\n See member $PROP for information about property lists.\n\nExamples:\n\n (prog ()\n  (SETQ A (GENSYM))\n )                      ==> NIL\n\n (PLIST A)              ==> NIL\n\n (GET A 'FOO)           ==> NIL\n (GET A 'BAZ)           ==> NIL\n\n (PUTPROP A 'BAR 'FOO)  ==> BAR\n\n (PLIST A)              ==> (FOO BAR)\n\n (GET A 'FOO)           ==> BAR\n (GET A 'BAZ)           ==> NIL\n\n (PUTPROP A '(FROB NICK ATE) 'BAZ)  ==> (FROB NICK ATE)\n\n (PLIST A)              ==> (BAZ (FROB NICK ATE) FOO BAR)\n\n (GET A 'FOO)           ==> BAR\n (GET A 'BAZ)           ==> (FROB NICK ATE)\n\n (REMPROP A 'FOO)       ==> BAR\n\n (PLIST A)              ==> (BAZ (FROB NICK ATE))\n\n (GET A 'FOO)           ==> NIL\n (GET A 'BAZ)           ==> (FROB NICK ATE)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PLUS": {"ttr": 5647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x08'\\x00%\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T08:27:00", "lines": 37, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PLUS\n\nSyntax:   (PLUS &rest args)\n    or:   (+ &rest args)\n\n arg (evaluated) - a number.\n\nReturns:\n\n The sum of all the arguments.\n\nProcessing:\n\n If no arguments are specified, 0 is returned.\n If one argument is specified, that argument is returned.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for errors detected.\n\nNotes:\n\nExamples:\n\n (+)                ==> 0\n (+ 4)              ==> 4\n (+ 1 2)            ==> 3\n (+ 3 3 3.0)        ==> 9.0\n\n (PLUS)             ==> 0\n (PLUS 4)           ==> 4\n (PLUS 1 2)         ==> 3\n (PLUS 3 3 3.0)     ==> 9.0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PLUSP": {"ttr": 5649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\t\\x7f\\x00\\x87%?\\x08(\\x00#\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-04-07T00:00:00", "modifydate": "1987-09-10T08:28:00", "lines": 35, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PLUSP\n\nSyntax:   (PLUSP arg1)\n\n arg1 (required, evaluated) - a number.\n\nReturns:\n\n T if arg1 is positive (greater than zero), else NIL.\n\nProcessing:\n\nErrors signaled:\n\n arg1 not a number.\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (PLUSP 0)        ==> NIL\n (PLUSP 1)        ==> T\n (PLUSP -1)       ==> NIL\n (PLUSP 0.0)      ==> NIL\n (PLUSP -0.0)     ==> NIL\n (PLUSP -0.0001)  ==> NIL\n (PLUSP 0.0F0)    ==> NIL\n (PLUSP -0.0F0)   ==> NIL\n (PLUSP -0.0001F0)==> NIL\n (PLUSP 3.14159)  ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PM": {"ttr": 5651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x86\\x08?\\x00\\x88\\x18\\x1f\\x07D\\x00'\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-03-24T00:00:00", "modifydate": "1988-06-29T07:44:00", "lines": 39, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PM\n\nSyntax:   (PM arg1 &optional arg2)\n\n arg1 (required, evaluated) - a LISP object.\n arg2 (optional, evaluated) - a file name.\n\nReturns:\n\n No values, after the macro expansion of the form specified by arg1 is\n pretty-printed on the file specified by arg2.\n\nProcessing:\n\n arg1 is macroexpanded by MACROEXPAND and then pretty-printed.  The\n default file is the standard output file.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This function exists purely for the convenience of the ZIL developer.\n\n See PPRINT, MEXPAND and PP for more details.\n\n Compare PM1, which is like PM but uses MACROEXPAND-1.\n\nExamples:\n\n (PM '(IF A B C))\n\n  causes the following to be printed on the standard output file:\n\n (COND (A B)\n       (T C))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PM1": {"ttr": 5653, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x87%?\\x00\\x88\\x18\\x1f\\x07D\\x00'\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-10T00:00:00", "modifydate": "1988-06-29T07:44:00", "lines": 39, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PM1\n\nSyntax:   (PM1 arg1 &optional arg2)\n\n arg1 (required, evaluated) - a LISP object.\n arg2 (optional, evaluated) - a file name.\n\nReturns:\n\n No values, after the macro expansion of the form specified by arg1 is\n pretty-printed on the file specified by arg2.\n\nProcessing:\n\n arg1 is macroexpanded by MACROEXPAND-1 and then pretty-printed.  The\n default file is the standard output file.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This function exists purely for the convenience of the ZIL developer.\n\n See PPRINT, MEXPAND and PP for more details.\n\n Compare PM, which is like PM1 but uses MACROEXPAND.\n\nExamples:\n\n (PM1 '(IF A B C))\n\n  causes the following to be printed on the standard output file:\n\n (COND (A B)\n       (T C))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNAME": {"ttr": 5655, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%?\\x081\\x00!\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-10T08:31:00", "lines": 33, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SYMBOL-NAME\n\nSyntax:   (SYMBOL-NAME arg1)\n    or:   (PNAME arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n A string which is the print name of arg1.\n\nProcessing:\n\n There is no function to alter the print name of a symbol.\n This is simply not permitted.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (PNAME 'A)             ==> \"A\"\n (PNAME '||)            ==> \"\"\n (PNAME 'foobar)       ==> \"FOOBAR\"\n (PNAME '|foobar|)     ==> \"foobar\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP": {"ttr": 5657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%?\\x083\\x007\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-10T08:33:00", "lines": 55, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: POP\n\nSyntax:   (POP stack1 &optional place2)\n\n stack1 (required) - a form which evaluates to a list.\n place2 (optional) - a form acceptable as the first argument to SETF.\n\nReturns:\n\n The object that used to be the CAR of stack1, but has been removed,\n causing stack1 to become its own CDR.\n\nProcessing:\n\n stack1 is typically a variable, but in general is any form acceptable\n as the first argument to SETF.  The result of POP is the CAR of the\n contents of stack1, and as a side effect the CDR of the contents of\n stack1 is stored back into stack1.\n\n If place2 is specified, it must be a symbol or form known to SETF.\n The object that used to be the CAR of stack1 is assigned to be the\n value of place2 (such that evaluating the form place2 will return\n that value).\n\n Conceptually, this is a \"POP\" operation on a push-down stack.\n Compare PUSH.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n POP is a macro that expands something like this:\n\n  (POP a)   --> (PROG1 (CAR a) (SETF a (CDR a)))\n\n  (POP a b) expands into something similar to (SETF b (POP a)).\n\n The optional second argument to POP is present in Nil, and probably in\n other Lisp implementations, but has never been documented anywhere but\n here.  It is required by Macsyma; that's why it's there to begin with.\n\nExamples:\n\n  (SETQ STACK '(A B C))      ==> (A B C)\n  STACK                      ==> (A B C)\n  (POP STACK)                ==> A\n  STACK                      ==> (B C)\n  (SETQ Z NIL)               ==> NIL\n  (POP STACK Z)              ==> B\n  STACK                      ==> (C)\n  Z                          ==> B\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PP": {"ttr": 5659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x16\\x9f\\x08\\x04\\x00:\\x009\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-17T08:04:00", "lines": 58, "newlines": 57, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PP\n\nSyntax:   (PP &rest funs)\n\n fun (optional, not evaluated) - a symbol or LAMBDA-expression.\n\nReturns:\n\n No values, after the LISP function specified by each fun, and its\n global value if any, are pretty-printed on the standard output file.\n\nProcessing:\n\n Each fun (not evaluated) is processed in turn.\n\n If fun is a symbol, its interpretive function definition is printed.\n If fun is a lambda-expression, a fake DEFUN defining the lambda\n expression is printed.  In either case, the output takes the form\n of a DEFUN that creates the function definition.\n\n The interpretive function definition specified by each fun is printed\n on the standard output file in such a way as to:\n\n  (1) be as readable as possible to the human user.\n  (2) be able to be read back in as LISP code.\n\n This is known as \"pretty printing.\"\n\n Furthermore, if the fun is a variable with a global value, a SETQ\n that would assign the value is printed.\n\nErrors signaled:\n\n None (errors signaled by ZILPP are trapped).\n\nNotes:\n\n PP invokes ZILPP, which is the function equivalent to the old PP of\n ZIL 1.1.  You need to use ZILPP if you wish to pretty-print a\n function definition to a file other than standard output.\n See ZILPP and ED.\n\nExamples:\n\n (pp foo)\n (pp foo bar)\n (pp (lambda (x) (foo x)))\n\n (defun foo (a b) (cons b a))\n (pp foo)\n\n  results in the following being printed on the standard output file:\n\n (DEFUN FOO (A B)\n  (CONS B A)\n )\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PPDATE": {"ttr": 5661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00%\\x00\\x86\"\\x7f\\x01\\x00\\x10O\\x14U\\x00&\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-08-15T00:00:00", "modifydate": "2000-04-13T14:55:25", "lines": 38, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PPDATE\n\nSyntax:   (PPDATE &optional date1)\n\n date1 (optional, evaluated) - a list of 3 fixnums.\n\nReturns:\n\n A string containing the date represented by date1 in \"pretty\" format.\n\nProcessing:\n\n If date1 is omitted, the current date is used.  Otherwise, date1 is\n assumed to be a list (year month day) in a format like that returned\n by CURDATE (CURRENT-DATE).\n\n If a year less than 100 is supplied as part of the date argument, a\n windowing algorithm is used to convert it to a valid four-digit year.\n The algorithm is the one described in \"Common Lisp: The Language\",\n Second Edition.  It is an error to provide a three-digit year.\n\nErrors signaled:\n\n Invalid date.\n\nNotes:\n\n See CURDATE for disclaimers.\n\nExamples:\n\n; (PPDATE)            ==> \"August 15, 1986\"   ; on August 15, 1986\n\n; (PPDATE '(1 1 1))   ==> \"January 1, 2001\"   ; on April 13, 2000\n\n; (PPDATE '(99 12 31))==> \"December 31, 1999\" ; on April 13, 2000\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PPRINT": {"ttr": 5663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x16\\x9f\\x08\\x04\\x00.\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-17T08:04:00", "lines": 46, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PPRINT\n\nSyntax:   (PPRINT arg1 &optional file2)\n    or:   (PRETTY-PRINT arg1 &optional file2)\n\n arg1 (required, evaluated) - a LISP object.\n file2 (optional, evaluated) - an output file name.\n\nReturns:\n\n No values, after the LISP object specified by arg1 is pretty-printed on\n the file specified by file2.\n\nProcessing:\n\n arg1 is printed on the output file specified by file2 in such a way as\n to:\n\n  (1) be as readable as possible to the human user.\n  (2) be able to be read back in as LISP code.\n\n This is known as \"pretty printing.\"\n\nErrors signaled:\n\n None.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See also PP and ZILPP, which pretty-print function definitions.\n\nExamples:\n\n (PPRINT '(foo bar (baz frob) (mumble frotz)))\n\n  causes the following to be printed on the standard output file:\n\n (FOO BAR (BAZ FROB)\n          (MUMBLE FROTZ))\n\n  Note that the exact format may vary, depending on the state of\n  development of the ZIL pretty-printer.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PPTIME": {"ttr": 5665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\"\\x7f\\x00\\x87%?\\x089\\x00&\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-08-15T00:00:00", "modifydate": "1987-09-10T08:39:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PPTIME\n\nSyntax:   (PPTIME &optional time1)\n\n time1 (optional, evaluated) - a list of 3 fixnums.\n\nReturns:\n\n A string containing the time represented by time1 in \"pretty\" format.\n\nProcessing:\n\n If time1 is omitted, the current time is used.  Otherwise, time1 is\n assumed to be a list (hour minute second) in a format like that\n returned by CURTIME (CURRENT-TIME).\n\n The \"second\" (that is, the third item in the list) may be omitted,\n since it is not used.\n\nErrors signaled:\n\n Invalid time.\n\nNotes:\n\n See CURTIME for disclaimers.\n\nExamples:\n\n; (PPTIME)           ==> \"5:30 P.M.\"         ; at 5:30 PM\n\n  (PPTIME '(1 1 1))  ==> \"1:01 A.M.\"\n  (PPTIME '(0 0))  ==> \"12:00 Mid.\"\n  (PPTIME '(12 0))  ==> \"12:00 Noon\"\n  (PPTIME '(0 1 2))  ==> \"12:01 A.M.\"\n  (PPTIME '(13 14))  ==> \"1:14 P.M.\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREFIX": {"ttr": 5667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x8f\\x00\\x87%\\x8f\\x083\\x005\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-15T00:00:00", "modifydate": "1987-09-15T08:33:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PREFIX\n\nSyntax:   (PREFIX)\n\nReturns:\n\n A string containing your TSO PREFIX or NIL if not in a TSO environment.\n\nProcessing:\n\n In foreground, or in TSO in batch, a string whose contents are your TSO\n prefix used to qualify data set names (in batch, this returns a null\n string unless you have issued the TSO PROFILE command to set the\n prefix).  In background other than TSO batch, PREFIX returns NIL.\n\n The prefix may be changed by issing the TSO PROFILE command.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare USERID, which returns the TSO userid.\n\nExamples:\n\n ;\n ; (PREFIX)  ==> \"ABC1234\"  if your TSO prefix is ABC1234\n ; (PREFIX)  ==> NIL        if ZIL is run in non-TSO batch\n ; (PREFIX)  ==> \"\"         if ZIL is run under TSO in batch\n ;                          and prefix was not set by PROFILE command\n ;\n\n (LET ((SAVE-PREFIX (PREFIX))\n       (PREFLIST '()))\n  (UNWIND-PROTECT\n   (PROGN\n    (TSO \"PROFILE PREFIX(FOO)\")\n    (PUSH \"Changed prefix\" PREFLIST)\n    (PUSH (PREFIX) PREFLIST)\n    (TSO \"PROFILE NOPREFIX\")\n    (PUSH \"No prefix\" PREFLIST)\n    (PUSH (PREFIX) PREFLIST)\n   )\n   (TSO \"PROFILE PREFIX(\" SAVE-PREFIX \")\")\n  )\n  (TSO \"PROFILE LIST\")\n  (NREVERSE PREFLIST)\n )\n    ==>       (\"Changed prefix\" \"FOO\" \"No prefix\" \"\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINC": {"ttr": 5669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x08F\\x00Y\\x00X\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T08:46:00", "lines": 89, "newlines": 88, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PRINC\n\nSyntax:   (PRINC arg1 file2)\n\n arg1  (required, evaluated) - any LISP object.\n file2 (optional, evaluated) - an output file name.\n\nReturns:\n\n arg1, after it has been printed on file2.\n\nProcessing:\n\n arg1 is printed at the current character position on the current line\n of output file file2 (the TERPRI and ZPUTFPO functions can change\n these).\n\n The current character position is updated to point to the position\n immediately following the last character written.\n\n The printed representation of the object, where possible, will be\n in \"human-readable form\".\n\n (1) Symbols and strings are not printed with delimiters; the text of\n     their names is printed as is.\n\n (2) The accuracy of flonum values is not the greatest.\n\n (3) Objects which cannot be typed in directly (e.g. compiled code\n     objects, structures, unrecognizable entities) will print\n     using the #< ... > syntax.  This is defined as not being able\n     to be read back in.\n\n If the printed representation of an atom, or a dot or parenthesis,\n would extend past the end of the current line, and that printed\n representation is shorter than the line length, the TERPRI function\n is invoked to write out the current line and start a new line.\n\n The null list () is printed as NIL.\n\n The QUOTE function is always printed in full, never as a quote mark.\n\n Lists are printed in dotted-pair notation if they contain a CONS\n whose CDR is a non-NIL atom; otherwise they are printed in standard\n list format.\n\n A string or symbol print name longer than the output line length will\n be split between the next line (after a TERPRI) and the line following.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member $PRINTER for more information on printing functions.\n\n Compare PRIN1, which is almost the same but prints objects in formats\n that can be read back in.\n\nExamples:\n\n (PRINC 'A)\n (PRINC 'A NIL)  are equivalent and return A after printing...\n\n                 A\n\n                 on the standard output file.\n\n Note that the interpreter will print A (the returned value)\n on the standard output file as well.\n\n (PROGN\n  (PRINC 'A               'FOO)\n  (PRINC NIL              'FOO)\n  (PRINC (CONS 'B 'C)     'FOO)\n  (PRINC (LIST '|b| '|c|) 'FOO)\n  (PRINC \"Hi there.\"      'FOO)\n )\n                 returns \"Hi there.\" after printing...\n\n                 ANIL(B . C)(b c)Hi there.\n\n                 on output file FOO.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINT": {"ttr": 5671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x08P\\x00O\\x00N\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T08:50:00", "lines": 79, "newlines": 78, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PRINT\n\nSyntax:   (PRINT arg1 &optional arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (optional, evaluated) - an output file name.\n\nReturns:\n\n arg1, after it has been printed on the file specified by arg2.\n\nProcessing:\n\n The object is printed at the current character position on the\n current line of the specified output file (the TERPRI and ZPUTFPO\n functions can change these).\n\n First TERPRI is invoked to write out the current line and reset the\n current character pointer to the beginning of the next line.  Then the\n object is printed, and the current character pointer is incremented by\n 1 (i.e. a space is printed after the object).  Compare this to PRIN1,\n which does not force a new line and resets the current character\n position to immediately after the just-printed object (no space\n following).\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member $PRINTER for more information on printing functions.\n\n PRINT does whatever PRIN1 does with respect to the manner in which\n it prints objects.  See PRIN1 for more information.\n\nExamples:\n\n (PRINT 'A)\n (PRINT 'A NIL)  are equivalent and return A after printing...\n\n                 A\n\n                 on the standard output file.\n\n Note that the interpreter will print A (the returned value)\n on the standard output file as well; this will print on the next\n line, causing the user to see:\n\n A\n A\n\n as the result.\n\n Thus the value will appear twice to the user.\n\n (PROGN\n  (PRINT 'A              'FOO)\n  (PRINT NIL             'FOO)\n  (PRINT (CONS 'B 'C)    'FOO)\n  (PRINT (LIST 'B 'C)    'FOO)\n  (PRINT '|Hi there.|    'FOO)\n  (PRINT \"a string\"      'FOO)\n )\n                 returns \"a string\" after printing...\n\n                 A\n                 NIL\n                 (B . C)\n                 (B C)\n                 |Hi there.|\n                 \"a string\"\n\n                 on output file FOO.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTC": {"ttr": 5673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x08?\\x00\\x87%?\\x08Q\\x00F\\x00H\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-24T00:00:00", "modifydate": "1987-09-10T08:51:00", "lines": 70, "newlines": 72, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PRINTC\n\nSyntax:   (PRINTC arg1 &optional arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (optional, evaluated) - an output file name.\n\nReturns:\n\n arg1, after it has been printed on the file specified by arg2.\n\nProcessing:\n\n PRINTC is like PRINT, but prints out in PRINC-like form rather\n than PRIN1-like form.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member $PRINTER for more information on printing functions.\n\n PRINTC does whatever PRINC does with respect to the manner in which\n it prints objects.  See PRINC for more information.\n\nExamples:\n\n (PRINTC \"a\")\n (PRINTC \"a\" NIL) are equivalent and return A after printing...\n\n                  a\n\n                  on the standard output file.\n\n Note that the interpreter will print \"a\" (the returned value)\n on the standard output file as well; this will print on the next\n line, causing the user to see:\n\n a\n \"a\"\n\n as the result.\n\n Thus the value will appear twice to the user.\n\n (PROGN\n  (PRINTC 'A             'FOO)\n  (PRINTC NIL            'FOO)\n  (PRINTC (CONS 'B 'C)   'FOO)\n  (PRINTC (LIST 'B 'C)   'FOO)\n  (PRINTC '|Hi there.|   'FOO)\n  (PRINTC \"a string\"     'FOO)\n )\n                 returns \"a string\" after printing...\n\n                 A\n                 NIL\n                 (B . C)\n                 (B C)\n                 Hi there.\n                 a string\n\n                 on output file FOO.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTS": {"ttr": 5890, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x08?\\x00\\x87%?\\x08U\\x00)\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-24T00:00:00", "modifydate": "1987-09-10T08:55:00", "lines": 41, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PRINTS\n\nSyntax:   (PRINTS arg1 &optional opt2)\n\n arg1  (required, evaluated) - any LISP object.\n opt2  (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A string containing the printed representation of arg1.\n\nProcessing:\n\n A string is built which contains the characters which would appear\n if arg1 was printed (like PRINC if opt2 is omitted or NIL, else like\n PRIN1 if opt2 is specified and non-NIL).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The following macros are also available in ZIL.\n\n  (PRINC-TO-STRING x)  is equivalent to (PRINTS x NIL).\n  (PRIN1-TO-STRING x)  is equivalent to (PRINTS x T).\n\n See PRINC and PRIN1 for more information on how things are printed.\n\n\nExamples:\n\n (PRINTS 'A)             ==> \"A\"\n (PRINTS '(FOO BAR))     ==> \"(FOO BAR)\"\n (PRINTS 007)            ==> \"7\"\n (PRINTS '|foo|)         ==> \"foo\"\n (PRINTS '|foo| NIL)     ==> \"foo\"\n (PRINTS '|foo| T)       ==> \"|foo|\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRIN1": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x08S\\x00U\\x00d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T08:53:00", "lines": 85, "newlines": 100, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PRIN1\n\nSyntax:   (PRIN1 arg1 &optional file2)\n\n arg1  (required, evaluated) - any LISP object.\n file2 (optional, evaluated) - an output file name.\n\nReturns:\n\n arg1, after it has been printed on the file specified by file2.\n\nProcessing:\n\n arg1 is printed at the current character position on the current line\n of the output file file2 (the TERPRI and ZPUTFPO functions can change\n these).\n\n The current character position is updated to point to the position\n immediately following the last character written.\n\n The printed representation of the object, where possible, will be\n identical to the format in which the same object could be read in\n (parentheses, dots, etc.), with the following exceptions:\n\n (1) The accuracy of flonum values is not the greatest.\n\n (2) Objects which cannot be typed in directly (e.g. compiled code\n     objects, structures, unrecognizable entities) will print\n     using the #< ... > syntax.  This is defined as not being able\n     to be read back in.\n\n If the printed representation of an atom, or a dot or parenthesis,\n would extend past the end of the current line, and that printed\n representation is shorter than the line length, the TERPRI function\n is invoked to write out the current line and start a new line.\n\n The null list () is printed as NIL.\n\n The QUOTE function is always printed in full, never as a quote mark.\n\n Lists are printed in dotted-pair notation if they contain a CONS\n whose CDR is a non-NIL atom; otherwise they are printed in standard\n list format.\n\n A string or symbol print name longer than the output line length will\n be split between the next line (after a TERPRI) and the line following.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member $PRINTER for more information on printer functions.\n\n Compare PRINC, which is almost the same but prints out\n objects in \"human-readable\" format.\n\nExamples:\n\n (PRIN1 'A)\n (PRIN1 'A NIL)  are equivalent and return A after printing...\n\n                 A\n\n                 on the standard output file.\n\n (PROGN\n  (PRIN1 'A              'FOO)\n  (PRIN1 NIL             'FOO)\n  (PRIN1 (CONS 'B 'C)    'FOO)\n  (PRIN1 (LIST 'B 'C)    'FOO)\n  (PRIN1 '|Hi there.|    'FOO)\n  (PRIN1 \"A string\"      'FOO)\n )\n                 returns \"A string\" after printing...\n\n                 ANIL(B . C)(B C)|Hi there.|\"A string\"\n\n                 on output file FOO.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROBEF": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x863\\x9f\\x00\\x88\\x12O\\x08&\\x00-\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-12-05T00:00:00", "modifydate": "1988-05-03T08:26:00", "lines": 45, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PROBEF\n\nSyntax:   (PROBEF arg1)\n    or:   (PROBE-FILE arg1)\n\n arg1 (required, evaluated) - a string representing a data set name.\n\nReturns:\n\n A string containing the data set name represented by arg1 if it\n names a valid and existing data set name, else NIL.\n\nProcessing:\n\n PROBEF invokes OPEN with the PROBE option to see if the data set\n specified by arg1 exists.  If it does, a copy of arg1 is returned\n which is (at least currently) arg1 uppercased; otherwise NIL is\n returned.\n\n A message is also issued that the data set is not found, which can\n be suppressed only via (MSGLEVEL 3) (not recommended).  To avoid\n seeing this message, you might wish to use (OPEN arg1 'PROBE)\n directly.\n\nErrors signaled:\n\n See OPEN.\n\nNotes:\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (PROBEF \"'csd.cmd.clist(xsetup)'\")  ==> \"'CSD.CMD.CLIST(XSETUP)'\"\n\n (PROBEF \"'csd.cmd.clist(junk)'\")  ==> NIL\n\n (PROBEF \"\u00ac&*()_\")  ==>  NIL   ; Syntax errors are considered bad dsns.\n\n (PROBEF \"cmd.clist\")   ==>(\"***ERROR***\"); Still considered an error.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROG": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x17O\\x08F\\x00\\x9c\\x00Z\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-22T08:46:00", "lines": 156, "newlines": 90, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PROG, PROG*\n\nSyntax:   (PROG varlist1 &rest forms)\n          (PROG* varlist1 &rest forms)\n\n The first argument (the local variable list) is required;\n at least one subsequent argument is required, but any number of\n arguments greater than one may be specified.\n\n varlist1 (not evaluated) - a (possibly empty) list of symbols or\n                            variable-value pairs.\n form     (conditionally evaluated if a list) - a symbol or a list.\n\nReturns:\n\n NIL, unless a RETURN (or RETURN-FROM NIL) is executed during evaluation\n of the forms within the PROG, in which case the value generated by the\n RETURN (or RETURN-FROM NIL) becomes the return value.\n\nProcessing:\n\n (1) The first argument is a list of variable bindings defining variable\n     names local to the PROG.  Each is in one of the following forms:\n\n      symbol   -  the variable named \"symbol\" is bound to NIL\n      (symbol form)  - the variable named \"symbol\" is bound to the value\n                       obtained by evaluating \"form\".  The environment\n                       in which \"form\" is evaluated depends on whether\n                       PROG or PROG* is being used - see below.\n\n      In either case, a destructuring template may be substituted for\n      \"symbol\", in which case the initial value is destructured.\n      See LET or DESETQ for more information on destructuring.\n\n     The variables become unbound when the PROG is terminated.\n\n     SETQ may be used to assign values to these variables\n     within the PROG.\n\n (2) Declarations may optionally follow the argument list, and are\n     processed if present.  Declarations may affect the variables\n     specified in the argument list.\n\n (3) The rest of the forms in the PROG constitute the body of the\n     PROG, and are processed in succession, as follows:\n\n     (a) If the form is NIL, it is ignored.\n\n     (b) If the form is a symbol, it is not evaluated, but kept\n         as a tag which a GO form can branch to.\n\n     (c) If the form is an integer, it is not evaluated, but kept\n         as a tag which a GO form can branch to.  In other words,\n         integers can be used as GO tags much as symbols can, for\n         compatibility with Maclisp.\n\n     (d) If the form is a list, it is evaluated.\n\n     (e) It is an error if the form is not of one of the above types.\n\n (3) If the end of the PROG is reached, it is terminated and NIL is\n     returned as its value.\n\n The above sequence can be altered by the execution of the special\n forms GO and RETURN if they are encountered during evaluation (see\n the GO and RETURN documentation for details).\n\n GO causes control to pass to the specified tag (symbol or integer) in\n the PROG body.  The form following the tag becomes the next form to\n be evaluated, and processing continues from there.\n\n RETURN causes evaluation of its argument and exit from the PROG using\n that value as the return value.  If no RETURN statement is executed,\n the PROG will either loop infinitely (until an error occurs) or\n return NIL when the end of the body is reached.\n\n Since a BLOCK named NIL is built by the PROG, it is also possible to\n use the form (RETURN-FROM NIL ...) to return a value from the PROG in\n the same way as (RETURN ...).  See BLOCK and RETURN-FROM (member\n RETURNFR of this documentation) for more information.\n\n PROG* is the same as PROG, except that PROG binds its variables\n sequentially whereas PROG* does parallel binding.\n\n In other words:\n\n PROG binds each variable in the environment present outside of the\n PROG.\n\n PROG* binds each variable in the environment present immediately before\n the variable-value pair, so that each binding can refer to previous\n (but not subsequent) PROG variables.\n\nErrors signaled:\n\n Invalid syntax (missing argument list or body, arg1 not a list).\n\nNotes:\n\n PROG used to be a special form, but is now a macro which expands into\n a LET, BLOCK and TAGBODY.  PROG* is identical to PROG except that it\n expands into LET* instead of LET.\n\n GO and RETURN are valid as long as they are lexically apparent in\n the code.  This means that they will be processed as long as they\n are not the product of function evaluation.  The following are\n valid occurrences of GO and RETURN:\n\n (PROG (A B C) LOOP (DO 'SOMETHING) (GO LOOP) (RETURN T))\n (PROG (A B C) (COND ((EQ A T) (GO LOOP)))\n               LOOP (PROG2 (PRINT A) (RETURN B)))\n\n The following is NOT valid:\n\n (DEFUN SUMFUNK () (GO LAB))\n (PROG (A) LAB (COND ((NULL A) (RETURN T))) (SUMFUNK))\n\n A \"GO outside of PROG\" error will be signalled.\n\n See members GO and RETURN for more information on restrictions\n pertaining to GO and RETURN, particularly those which involve\n functionality available under the interpreter but not (as yet)\n in compiled code.\n\n The same applies to RETURN-FROM.\n\nExamples:\n\n (PROG () (RETURN T))             ==> T\n (PROG () T)                      ==> NIL\n\n (PROG (A B)\n       (SETQ A '(1 2 3 4))\n  LOOP (COND ((NULL A) (RETURN B)))\n       (SETQ B (CONS (ADD1 (CAR A)) B))\n       (SETQ A (CDR A))\n       (GO LOOP)\n )                                ==> (5 4 3 2)\n\n (PROG ((A '(1 2 3 4))\n        (B '(5 6 7 8))\n        (C NIL)\n        (D NIL)\n       )\n       (SETQ C (CAR A))\n       (SETQ D (CAR B))\n       (RETURN (+ C D))\n )                         ==>  6\n\n (SETQ A \"a\")          ==> \"a\"\n (SETQ B \"b\")          ==> \"b\"\n\n (PROG  ((A (LIST A)) (B A)) (RETURN (LIST A B)))  ==>  ((\"a\") \"a\")\n (PROG* ((A (LIST A)) (B A)) (RETURN (LIST A B)))  ==>  ((\"a\") (\"a\"))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROGN": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x12R\\x00*\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T12:52:00", "lines": 42, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: PROGN\n\nSyntax:   (PROGN &rest args)\n\n arg (evaluated) - any LISP object.\n\nReturns:\n\n The last of the arguments.\n\nProcessing:\n\n Each argument is evaluated in turn; since the values of all\n arguments but the last are not used, these are generally\n specified for their effects only.  When the last argument is\n evaluated, its value is returned.\n\n If there are no arguments, PROGN returns NIL.\n\n In compiled code, PROGN signifies a series of forms to be\n processed as \"top-level\" forms.  See $COMPILE for more information.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The format (PROGN 'COMPILE ...) used to be the traditional way to\n signal a series of top-level forms to the compiler; it is no longer\n necessary since PROGN always does this without the 'COMPILE.  See\n $COMPILE for more information.\n\nExamples:\n\n (PROGN)                          ==> NIL\n (PROGN 'A)                       ==> A\n (PROGN 'A 'B)                    ==> B\n (PROGN 'A 'B 'C)                 ==> C\n (PROGN (SETQ X '(A B)) (CAR X))  ==> A\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROGV": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x13?\\x00\\x87&\\x0f\\tS\\x008\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-05-13T00:00:00", "modifydate": "1987-09-17T09:53:00", "lines": 56, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PROGV\n\nSyntax:   (PROGV varlist1 vallist2 &rest forms)\n\n varlist1 (required, evaluated) - a list of symbols.\n vallist2 (required, evaluated) - a list of LISP objects.\n form     (evaluated) - any LISP form.\n\nReturns:\n\n The last form in forms, in a SPECIAL variable binding environment\n specified by varlist1 and vallist2.\n\nProcessing:\n\n The first argument is a list of symbols defining variable\n names local to the PROGV.  The variables are initially bound to\n the corresponding values in the second argument, and revert to\n their previous status when the PROGV is terminated.\n\n If the list of variables is longer than the list of values,\n the excess variables are made unbound (more accurately,\n dynamic bindings are created but are assigned no values).\n\n If the list of values is longer than the list of variables,\n the excess values are ignored.\n\n The rest of the forms in the PROGV constitute the body of the\n PROGV, and are evaluated in succession, with the variables\n specified in varlist1 bound to the values in vallist2.  The\n last of these evaluated forms is returned as the value.\n\n It is important to remember that the bindings generated this\n way are dynamically scoped (\"SPECIAL\").  In particular, they\n cannot be captured by lexical closures.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n PROGV exists to provide a way of specifying a binding environment\n at run time rather than lexically, in that the variable specs are\n actually evaluated.  This is primarily useful for building\n embedded interpreters.\n\n At the present time, PROGV is implemented as a macro which expands\n by turning the forms into a lexical closure.  This should be kept\n in mind when compiling PROGV constructs.\n\nExamples:\n\n (PROGV '(A B C) '(1 2 3) (EVAL '(LIST A B C))) ==> (1 2 3)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROG1": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x16\\x7f\\x08P\\x00\"\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-15T08:50:00", "lines": 34, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PROG1\n\nSyntax:   (PROG1 arg1 &rest args)\n\n argn (optional, evaluated) - any LISP object.\n At least 1 argument is required.\n\nReturns:\n\n The first of the arguments, after evaluating all of them in sequence.\n\nProcessing:\n\n All of the arguments are evaluated; since only the value of the first\n is used, the others are generally specified for their effect only.\n The result of evaluating the first argument is returned as the value.\n\nErrors signaled:\n\n Too few arguments (at least one is required).\n\nNotes:\n\n PROG1 always returns a single value, no matter what the first form\n is.  See MULTIPLE-VALUE-PROG1, which returns all the values from\n the first form.\n\nExamples:\n\n (PROG1 'A)                       ==> A\n (PROG1 'A 'B)                    ==> A\n (PROG1 'A 'B 'C 'D)              ==> A\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PROG2": {"ttr": 5904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x16\\x7f\\x08Q\\x00%\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-15T08:51:00", "lines": 37, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nMacron: PROG2\n\nSyntax:   (PROG2 arg1 arg2 &rest args)\n\n argn (optional, evaluated) - any LISP object.\n At least 2 arguments are required.\n\nReturns:\n\n The second of the arguments, after evaluating all of them in sequence.\n\nProcessing:\n\n All of the arguments are evaluated; since only the value of the second\n is used, the others are generally specified for their effect only.\n The result of evaluating the second argument is returned as the value.\n\nErrors signaled:\n\n Too few arguments (at least two are required).\n\nNotes:\n\n PROG2 always returns a single value, no matter what the second form\n is.  See MULTIPLE-VALUE-PROG1, which returns all the values from\n the first form.\n\nExamples:\n\n (PROG2 'A 'B)                    ==> B\n (PROG2 'A 'B 'C 'D)              ==> B\n (PROG2 (SETQ X '(A B))\n        (CAR X)\n        (SETQ X '(C D)))          ==> A\n (MULTIPLE-VALUE-LIST (PROG2 'A (VALUES 1 2 3) 'B))   ==> (1)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PSETQ": {"ttr": 5906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%?\\x12X\\x00.\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-10T12:58:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PSETQ\n\nSyntax:   (PSETQ &rest args)\n\n args occur in pairs: arg1 and arg2.\n\n arg1 (required, not evaluated) - a symbol.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n The last argument, after the variables specified by the odd-numbered\n arguments have been bound to the values specified by the\n even-numbered arguments.\n\nProcessing:\n\n The values of the even-numbered arguments are obtained, and then the\n variables represented by the odd-numbered arguments are set to these\n values respectively.  This is similar to SETQ, except for the fact\n that the assignments are in parallel.  Thus, the value of a given\n argument does not depend on a prior assignment that takes place\n in the same PSETQ form.\n\n See SETQ for details on variable binding.\n\nErrors signaled:\n\n Invalid syntax (an even number of arguments required).\n Invalid first argument.\n\nNotes:\n\n See SETQ for details on variable binding.\n\nExamples:\n\n (LET ((A 1) (B 2) (C 3))\n      (SETQ A 0 B A C B)\n      (LIST A B C))        ==>  (0 0 0)\n\n (LET ((A 1) (B 2) (C 3))\n      (PSETQ A 0 B A C B)\n      (LIST A B C))        ==>  (0 1 2)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUSH": {"ttr": 5908, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%?\\x13\\x02\\x00;\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-10T13:02:00", "lines": 59, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PUSH\n\nSyntax:   (PUSH item1 place2)\n\n item1  (required, evaluated) - any LISP object.\n place2 (required           ) - a form acceptable to SETF which\n                                evaluates to a list.\n\nReturns:\n\n place2, after item1 has been CONSed to the front of it.\n\nProcessing:\n\n place2 is typically a variable, but in general is any form acceptable\n as the first argument to SETF.  item1 is CONSed onto the front of the\n list specified by place2, and the augmented list is stored back into\n place2 and returned as the value.\n\n Conceptually, this is a \"push\" operation on a push-down stack.\n Compare POP and PUSHNEW.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n PUSH is a macro that expands something like this:\n\n  (PUSH a b)  --> (SETF b (CONS a b))\n\n At the present time, the macro expansion does not guarantee 100%\n clean one-time evaluation of the second argument.  Thus, if you\n code something like\n\n  (PUSH 'a (GET (foo) (bar)))\n\n it may expand into something like\n\n  (SETF (GET (foo) (bar)) (CONS 'a (GET (foo) (bar))))\n\n which means that although the GET will be evaluated only once\n (since the SETF will translate the first GET into the\n appropriate PUTPROP or whatever), (foo) and (bar) may be\n evaluated twice each.  This may be fixed some day; if it is,\n you may or may not be informed of the upgrade.\n\nExamples:\n\n (SETQ A '(FOO))          ==> (FOO)\n (PUSH 'BAR A)            ==> (BAR FOO)\n A                        ==> (BAR FOO)\n (PUTPROP 'A 'V 'P)       ==> V\n (GET 'A 'P)              ==> V\n (PUSH 'BAZ (GET 'A 'P))  ==> (BAZ . V)\n (GET 'A 'P)              ==> (BAZ . V)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PUSHNEW": {"ttr": 5910, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x860O\\x00\\x87(\\x8f\\x17W\\x00e\\x00X\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-10-31T00:00:00", "modifydate": "1987-10-15T17:57:00", "lines": 101, "newlines": 88, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PUSHNEW\n\nSyntax:   (PUSHNEW item place2 &rest keywords)\n\n item1  (required, evaluated) - any LISP object.\n place2 (required           ) - a form acceptable to SETF which\n                                evaluates to a list.\n\nReturns:\n\n place2, after item1 has been CONSed to the front of it if it is not\n already a member of place2.\n\nProcessing:\n\n place2 is typically a variable, but in general is any form acceptable\n as the first argument to SETF.\n If item1 is already a member of the list which is the value of place2,\n place2 is returned unaltered.  Otherwise, item1 is CONSed onto the\n front of the list specified by place2, and the augmented list is stored\n back into place2 and returned as the value.\n\n The member test is determined by the keywords, if any, specified on\n the call to PUSHNEW (using Common LISP keyword syntax).\n The valid keywords are:\n\n :TEST   -  must be #'EQ, #'EQL or #'EQUAL\n :KEY    -  must be #'CAR\n\n Both are optional.  If :TEST is omitted, the default is #'EQL.\n\n The test is performed by one of the MEMBER functions if the :KEY\n keyword is omitted; by one of the ASSOC functions if the :KEY\n keyword is specified as #'CAR (or 'CAR).\n\n The MEMBER functions are:  MEMQ      for :TEST #'EQ    (or 'EQ)\n                            MEMQL     for :TEST #'EQL   (or 'EQL)\n                            MEMQUAL   for :TEST #'EQUAL (or 'EQUAL)\n\n The ASSOC  functions are:  ASSQ      for :TEST #'EQ    (or 'EQ)\n                            ASSQL     for :TEST #'EQL   (or 'EQL)\n                            ASSQUAL   for :TEST #'EQUAL (or 'EQUAL)\n\n If an ASSOC function is used, the CAR of item1 is compared with the\n CAR of each member of place2.  Otherwise, item1 is compared with\n each member of place2.\n\nErrors signaled:\n\n Invalid keyword specification.\n Unsupported value for keyword.\n\nNotes:\n\n Compare ADJOIN, which is similar but does not SETF the second arg,\n just returns a CONS of arg1 and arg2.\n\n Conceptually, this is an operation which adds an element to a set.\n Compare PUSH and POP.\n\n At the present time, the macro expansion does not guarantee 100%\n clean one-time evaluation of the second argument.  Thus, if you\n code something like\n\n  (PUSHNEW 'a (GET (foo) (bar)))\n\n (which expands into some stuff), (foo) and (bar) may be\n evaluated twice each.  This may be fixed some day; if it is,\n you may or may not be informed of the upgrade.\n\nExamples:\n\n (SETQ A NIL)           ==> NIL\n (PUSHNEW 'FOO A)       ==> (FOO)\n (PUSHNEW 'BAR A)       ==> (BAR FOO)\n (PUSHNEW 'FOO A)       ==> (BAR FOO)\n (PUSHNEW 'BAR A)       ==> (BAR FOO)\n (PUSHNEW 'BAZ A)       ==> (BAZ BAR FOO)\n A                      ==> (BAZ BAR FOO)\n\n (PUTPROP 'A '(V) 'P)         ==> (V)\n (GET 'A 'P)                  ==> (V)\n (PUSHNEW 'W (GET 'A 'P))     ==> (W V)\n (GET 'A 'P)                  ==> (W V)\n\n (SETQ X NIL)                       ==> NIL\n (PUSHNEW '(A . 1) X :KEY #'CAR)    ==> ((A . 1))\n (PUSHNEW '(B . 2) X :KEY #'CAR)    ==> ((B . 2) (A . 1))\n (PUSHNEW '(A . 3) X :KEY #'CAR)    ==> ((B . 2) (A . 1))\n X                                  ==> ((B . 2) (A . 1))\n\n (SETQ A NIL)                ==> NIL\n (PUSHNEW 1.0 A)             ==> (1.0)\n (PUSHNEW 2.0 A)             ==> (2.0 1.0)\n (PUSHNEW 1.0 A)             ==> (2.0 1.0)\n (PUSHNEW 1.0 A :TEST #'EQ)  ==> (1.0 2.0 1.0)\n (PUSHNEW 2.0 A :TEST #'EQL) ==> (1.0 2.0 1.0)\n (PUSHNEW 2.0 A :TEST #'EQ)  ==> (2.0 1.0 2.0 1.0)\n A                           ==> (2.0 1.0 2.0 1.0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUTDATA": {"ttr": 5912, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x10/\\x00\\x880\\x9f\\t8\\x00/\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-04-11T00:00:00", "modifydate": "1988-11-04T09:38:00", "lines": 47, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: PUTDATA\n\nSyntax:   (PUTDATA &rest forms)\n\n form (optional, not evaluated) - any LISP form that can be evaluated.\n\nReturns:\n\n T, after the forms and their values are printed on the standard output\n file in \"A=B,C=D\" format.\n\nProcessing:\n\n Each form and its value is printed in turn on standard output, with\n an equal sign between the form and the value.  Commas separate\n successive forms, if there are more than one specified.\n\n It is insured that output begins on a new line, and a TERPRI is done\n at the end; all the output ends up on the same line as far as\n is possible.  To get multiline output, issue multiple PUTDATA's.\n\n This macro is primarily for debugging purposes, to display the\n values of variables or LISP expressions at various points in a\n program.  As you may have guessed, it is inspired by the PL/1\n \"PUT DATA\" statement.\n\nErrors signaled:\n\n None (evaluation errors are trapped).\n\nNotes:\n\n Currently PUTDATA with no arguments is accepted and essentially\n just does a TERPRI.\n\n PUTDATA is particularly useful in conjunction with the AT and OFF\n tracing macros.  See AT, OFF and $TRACE for examples of usage.\n\nExamples:\n\n (setq a 'foo b 'bar)\n\n (putdata a b (cons a b))    results in the following being printed:\n\n A=FOO,B=BAR,(CONS A B)=(FOO . BAR)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "PUTPROP": {"ttr": 5914, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x13\\x06\\x00@\\x00K\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T13:06:00", "lines": 64, "newlines": 75, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: PUTPROP\n\nSyntax:   (PUTPROP arg1 arg2 arg3)\n\n arg1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - any LISP object.\n arg3 (required, evaluated) - any LISP object, but generally a symbol.\n\nReturns:\n\n arg2, after it has been made the value of the property specified by\n arg3 on the property list of the atom specified by arg1.\n\nProcessing:\n\n Herein, arg1 is the atom whose property list is being manipulated;\n arg2 is the property value being assigned, and arg3 is the name of\n the property (the indicator).\n\n If arg3 is already an indicator on the property list of arg1,\n then the current value of the arg3 property is (destructively)\n replaced by arg2.  Otherwise, the indicator/value \"pair\" consisting\n of arg2 and arg3 is added (CONS'ed) to the beginning of the\n property list of arg1.\n\n Specifying NIL as arg2 is equivalent to doing (REMPROP arg1 arg3),\n except that REMPROP actually splices the indicator/value pair out\n of the property list whereas PUTPROP merely replaces the value\n with NIL.\n\n Although arg1 must be a symbol, ZIL will accept a first argument of a\n list, in which case the CDR of the list is treated like a property\n list.  This is the \"disembodied property list\" used in Maclisp.\n\nErrors signaled:\n\n Property list errors (see member $PROP).\n\nNotes:\n\n See member $PROP for information about property lists.\n\nExamples:\n\n (SETPLIST 'A NIL)                  ==> A\n (GET 'A 'FOO)                      ==> NIL\n (GET 'A 'BAZ)                      ==> NIL\n\n (PUTPROP 'A 'BAR 'FOO)             ==> BAR\n (PLIST 'A)                         ==> (FOO BAR)\n (GET 'A 'FOO)                      ==> BAR\n (GET 'A 'BAZ)                      ==> NIL\n\n (PUTPROP 'A '(FROB NICK ATE) 'BAZ) ==> (FROB NICK ATE)\n (PLIST 'A)                         ==> (BAZ (FROB NICK ATE) FOO BAR)\n (GET 'A 'FOO)                      ==> BAR\n (GET 'A 'BAZ)                      ==> (FROB NICK ATE)\n\n (PUTPROP 'A 'FROB 'BAZ)            ==> FROB\n (PLIST 'A)                         ==> (BAZ FROB FOO BAR)\n (GET 'A 'FOO)                      ==> BAR\n (GET 'A 'BAZ)                      ==> FROB\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QUIT": {"ttr": 5916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x19@\\x000\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T19:40:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: QUIT\n\nSyntax:   (QUIT &optional arg1)\n\n arg1 (optional, evaluated) - an input file name.\n\nReturns:\n\n NIL; end-of-file status is forced on the file specified by arg1.\n\nProcessing:\n\n A flag is set on in the file block for the input file specified by arg1\n so that subsequent input functions (READ, READCH, etc.)  receive an\n end-of-file indication.  Subsequent processing is dependent upon the\n program structure.\n\n If the argument is NIL or is omitted (same thing), end-of-file is\n forced upon standard input.  This is one way of terminating the ZIL\n interpreter, which reads, evaluates, and prints the values of forms\n from the standard input file until end-of-file is encountered.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Invoked from within a LISP function (compiled or interpreted)\n running under the interpreter, (QUIT) or (QUIT NIL) causes the\n interpreter to shut down cleanly and terminate.  Compare EXIT,\n which terminates the interpreter unkindly by forcing return to the\n operating system.\n\n You can also use (END), which is not a function but indicates end of\n input to READ-EVAL-PRINT or to the compiler.\n\nExamples:\n\n (QUIT)\n (QUIT NIL)   ...are equivalent.\n\n (QUIT 'FOO)     forces end-of-file on the input file FOO.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QUOTE": {"ttr": 5918, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x19B\\x002\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T19:42:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: QUOTE\n\nSyntax:   (QUOTE arg1)\n\n arg1 (required, not evaluated) - any LISP object.\n\nReturns:\n\n The first argument.\n\nProcessing:\n\n QUOTE is the general way of specifying \"constant\" values in LISP.\n\n The reader macro ' (hex 7D) is a shorthand for the QUOTE function,\n so that 'form is the same as (QUOTE form).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n (LIST 'a 'b 'c) is equivalent to (QUOTE (a b c)) in the interpretive\n environment, but in the compiled environment the former builds a new\n list out of CONS cells each time it is executed, while the latter\n creates an in-line constant list in the load module whose address is\n loaded.  If the list may be modified during execution of the program,\n you MUST use the LIST form rather than the QUOTE form.\n\n The ' abbreviation for QUOTE is implemented as a reader macro.\n See $RMACRO for more information on reader macros.\n\nExamples:\n\n (QUOTE A)          ==> A\n (QUOTE 001)        ==> 1\n (QUOTE |001|)      ==> |001|     ; note that this is a symbol.\n (QUOTE (A B C))    ==> (A B C)\n (QUOTE (QUOTE A))  ==> (QUOTE A)\n\n;Equivalent to the above are:\n\n 'A                 ==> A\n '001               ==> 1\n '|001|             ==> |001|     ; note that this is a symbol.\n '(A B C)           ==> (A B C)\n ''A                ==> (QUOTE A)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QUOTIENT": {"ttr": 5920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%?\\x19E\\x00&\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T19:45:00", "lines": 38, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: QUOTIENT\n\nSyntax:   (QUOTIENT &rest args)\n    or:   (/ &rest args)\n\n arg (evaluated) - a number.\n\nReturns:\n\n The quotient (taken in succession) of all the arguments.\n\nProcessing:\n\n If no arguments are specified, 1 is returned.  If one argument is\n specified, then for QUOTIENT, that argument is returned; for /, the\n result of dividing 1 by that argument is returned.  Note that if the\n argument is an integer whose absolute value is greater than 1, the\n result will be zero, which makes it rather useless an operation.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for errors detected.\n\nNotes:\n\nExamples:\n\n (QUOTIENT 10 3)       ==> 3\n (QUOTIENT 101 10 2.0) ==> 5.0\n (QUOTIENT 101.0 10 2) ==> 5.05\n (QUOTIENT)            ==> 1\n (QUOTIENT 4)          ==> 4\n (/ 4)                 ==> 0\n (/ 4.0)               ==> 0.25\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RANDOM": {"ttr": 5922, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x12\\x8f\\x00\\x87%?\\x19I\\x00\\x1f\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-05-08T00:00:00", "modifydate": "1987-09-10T19:49:00", "lines": 31, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RANDOM\n\nSyntax:   (RANDOM &optional arg1)\n\n arg1 (optional, evaluated) - a positive fixnum or flonum.\n\nReturns:\n\n A random number greater than 0 and less than arg1.\n\nProcessing:\n\n If arg1 is specified, a number of the same type between 0 and arg1\n is returned.\n If arg1 is omitted, the internal random state is reset (i.e.\n the seed), and a random fixnum is returned.\n\nErrors signaled:\n\n Invalid argument (not a positive fixnum or flonum).\n\nNotes:\n\nExamples:\n\n; (There are no examples because the value returned by RANDOM is\n;  supposed to be unpredictable, by definition.  However, the same\n;  series of numbers should be generated by the same sequence of\n;  calls to RANDOM in two different ZIL sessions.)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RDRMACRO": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x17\\x9f\\x088\\x00c\\x00V\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-27T08:38:00", "lines": 99, "newlines": 86, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RDRMACRO\n\nSyntax:   (RDRMACRO arg1 arg2)\n\n arg1 (required, evaluated) - a one-character symbol or string, or\n                              a character fixnum.\n arg2 (required, evaluated) - a compiled code SUBR object, or NIL.\n\nReturns:\n\n NIL, after assigning the compiled code SUBR specified by arg2 to the\n character specified by arg1 as a reader macro.\n\nProcessing:\n\n If arg2 is NIL, the reader macro definition for the character specified\n by arg1 is removed from the read table.\n\n Otherwise, the read table and reader macro chain are updated with a\n definition of the character specified by arg1 as a reader macro; when\n the READ function encounters it, it will execute the compiled code\n object specified as arg2 to RDRMACRO.\n\n The compiled code SUBR must be a function that takes one argument;\n this argument is bound to the file name currently in use by READ\n when it invokes the reader macro.  This enables the reader macro\n code to access data from the file being read, via functions like\n READ, READCH and PEEKCH.\n\n The code is executed under the environment active at the time that\n READ invokes it; closures are not permitted.\n\n If the code needs to access the reader macro character as an atom,\n the RMCHAR function will do this.\n\n If the function wishes to return \"nothing\" to the reader (i.e. have\n the reader continue reading with the next S-expression),\n it may return zero values (e.g. via the form (VALUES)), or\n the RMNIL function will do this.\n\n This is a low-level function, generally for internal use.\n To specify interpretive code or other types of objects as reader\n macros, use the DEFRDMAC function.\n\n The following are equivalent:\n\n  (RDRMACRO '|?|  (ZILLOAD 'MYFUNK))\n  (RDRMACRO  \"?\"  (ZILLOAD 'MYFUNK))\n  (RDRMACRO  #\\?  (ZILLOAD 'MYFUNK))\n\nErrors signaled:\n\n Invalid first or second argument.\n\nNotes:\n\n See documentation on READ, DEFRDMAC and RMCHAR for more information\n on reader macro processing.\n\n A SUBR compiled code object is a value that is returned only by the\n ZILLOAD function.  Closures, whether compiled or interpreted, are not\n permitted by RDRMACRO; use DEFRDMAC to define reader macros using\n arbitrary forms that can be APPLY'ed.\n\n Currently, when a reader macro definition is deleted, the syntax for\n the reader macro character is restored to whatever it was before it was\n made into a reader macro.\n\n Reader macro definitions for the following characters are predefined:\n\n ' (single quote)\n ` (backquote)\n , (comma)\n # (sharp sign)\n\n See member $RMACRO in this documentation for details on these.\n\nExamples:\n\n Assume a reader macro defined thus:\n\n   (RDRMACRO '|?| (ZILLOAD 'QFOO))\n\n where QFOO is a SUBR derived from compiling the function:\n\n   (DEFUN QFOO (X) (LIST (RMCHAR) (READ X)))\n\n Then, when the following is read in:\n\n   ?FOO\n\n the following will be returned by READ:\n\n   (? FOO)\n\n (Note that under the interpreter, this will be evaluated by EVAL\n before the user sees the result.)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "READ": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87)O\\x17\\x05\\x00\\x82\\x00a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-10-21T17:05:00", "lines": 130, "newlines": 97, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: READ\n\nSyntax:   (READ &optional file1 value2)\n\n file1  (optional, evaluated) - an input file name.\n value2 (optional, evaluated) - any LISP object.\n\nReturns:\n\n An S-expression (atom or list) read from the input file specified by\n file1, or value2 if end-of-file is encountered while scanning for an\n S-expression.\n\nProcessing:\n\n NIL is the default for both file1 and value2.\n\n The file file1 is read from the current character position and logical\n record (the ENDREAD and ZPUTFPI functions can change these).\n Input is read according to the formats described in member $FORMS\n of this documentation.\n\n The returned S-expression (atom, list, or dotted pair) is returned\n as is; it is not evaluated.  () and NIL are equivalent.\n\n If a syntax error (unmatched right parenthesis or misplaced period) is\n encountered, an error is signalled.  If a syntax error occurs while\n attempting to process a dotted pair, an error is signalled when the\n entire S-expression is processed, no matter how deep the nesting of\n lists at the point where the dotted pair error was found.\n\n If end-of-file is encountered while scanning for a non-separator\n character, value2 is returned (the EOF function should be used to\n determine if this was the case).  If the file is already in end-of-file\n status when READ is issued, an error is signalled.\n\n READ never sets the \"newline\" indication tested by NEWLINEP.\n End-of-line is considered to be an atom delimiter except when an\n escaped (| ... |) atom is being scanned.  If end-of-line occurs while\n a string (\"...\") is being processed, a newline character is inserted\n in the string and reading continues.  End-of-line is ignored in all\n other cases.\n\n Both the reader and the printer support a continuation character\n feature:  an object which occupies more than one line will be printed\n in pieces, with the ZIL continuation character (the cent sign) in the\n final position of each line.  The reader, when it sees the cent sign in\n the final position of a line, will process the characters on the\n following line as part of the object currently being read in, without\n any newlines.  (This does not apply to data read in from the terminal,\n although the continuation characters may appear when an object is\n printed out on the terminal.)\n\n With this feature, it is possible to print long strings, bignums,\n etc. out to a file and read them back in.\n\n For fixed-length records, the cent sign will be treated as a\n continuation character if it occupies the last data column.  For\n example, a RECFM=FB LRECL=80 data set will recognize the cent sign as a\n continuation character if it is in column 80 for unnumbered data sets,\n or column 72 for numbered data sets.\n\n For variable-length records, the cent sign will be treated as a\n continuation character if it occupies the last column of any record,\n even if it is not the maximum length.\n\n The cent sign will NOT be treated as a continuation if it is preceded\n by a backslash, or if it is part of a comment field or otherwise not\n part of a Lisp object being read in.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n Misplaced period or right parenthesis.\n Incomplete list or vector (end-of-file encountered before closing right\n  parenthesis found).\n No character following escape character (backslash); i.e.,\n  end-of-file detected when a character was required.\n Errors signalled by reader macro functions.\n Internal reader macro dispatching error (this falls into the famous\n  \"this-should-never-happen\" class of errors).\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member $FORMS for syntax of forms accepted by READ.\n\n See member $RMACRO for syntax of reader macro characters.\n\n The ' abbreviation for QUOTE is implemented as a reader macro.\n This and the # (sharp sign), ` (backquote) and , (comma) are the\n only characters with reader macros implemented by the system by\n default; the user can define other reader macros via the RDRMACRO\n and DEFRDMAC functions.  A read table defining the separator and\n delimiter characters as well as reader macro characters is\n allocated the first time READ is issued.\n\n The syntax of the / and \\ characters can be altered via the RMMAC\n function to provide capability of reading LISP code written in Maclisp\n or for a Maclisp-compatible reader.  The RMINIT function will restore\n the reader to its default mode.  See RMMAC and RMINIT for more\n information.\n\n Reader macro definitions for the following characters are predefined:\n\n ' (single quote)\n ` (backquote)\n , (comma)\n # (sharp sign)\n\n See member $RMACRO in this documentation for details on these.\n\nExamples:\n\n (READ)\n (READ NIL)   ...are equivalent and return an atom, list, dotted pair,\n                 etc. from the standard input file.\n\n (READ 'FOO)     returns an S-expression from the input file FOO.\n                 If end-of-file is reached while reading FOO, then\n                 this will return NIL.\n\n (READ 'FOO \"eof\")  will return \"eof\" if end of file is reached on\n                    input file FOO, otherwise returns an S-expression\n                    as above.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "READCH": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x08\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x12O\\x08'\\x00d\\x00Q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.08", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-05-03T08:27:00", "lines": 100, "newlines": 81, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: READCH\n\nSyntax:   (READCH &optional file1 eofval2 newlineval3)\n\n file1       (optional, evaluated) - an input file name.\n eofval2     (optional, evaluated) - any LISP object.\n newlineval3 (optional, evaluated) - any LISP object.\n\nDefaults:\n\n file1 defaults to standard input (NIL).\n eofval2 defaults to NIL.\n newlineval3 defaults to the symbol whose print name is hex 0D\n             (carriage return).\n\nReturns:\n\n An interned symbol whose print name is a character read from the input\n file specified by file1; or eofval2 if end-of-file is encountered while\n scanning for a character; or newlineval3 if end-of-line is encountered\n while scanning for a character.\n\nProcessing:\n\n The file specified by file1 is read from the current character position\n and logical record (the ENDREAD and ZPUTFPI functions can change\n these).  One character is returned and made into a symbol, and the\n current character pointer is updated to point to the next character.\n\n The character always creates an interned symbol, and is never\n uppercased.\n\n If end-of-file (i.e. the current character pointer has reached the end\n of the file) is encountered, eofval2 (or NIL if not supplied) is\n returned instead of a character.\n\n If end-of-line (i.e. the current character pointer has reached the end\n of the line) is encountered, newlineval3 is returned instead of a\n character.  In this case, the next call to READCH will return either\n the first character from the next line, or end-of-file (note that the\n end-of-file condition is always preceded by the end-of-line condition\n unless the file is empty).\n\n If the file is already in end-of-file status when READCH is issued,\n an error is signalled.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n READCH, READLINE, TYI and ZILRDCH are the only functions that can cause\n the \"newline\" indication to be set in an input file (see NEWLINEP).\n\n Currently, if READCH is issued against a file allocated to the\n terminal (including standard input) which has never been accessed\n by READ or READCH before, it will return NIL and NEWLINEP will\n return true.  In other words, the first input from a terminal file\n is a \"newline\".\n\n Compare PEEKCH, which is like READCH but does not change the current\n character pointer.\n\n The READCH provided in previous releases of ZIL, which had different\n syntax, is now called ZILRDCH.\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (progn\n  (with-open-file (file \"$$foo.$$test\" :out)\n   (format file \"~&?foobar~%\")\n  )\n  (setq foo (open \"$$foo.$$test\" :in))\n  t\n )                                  ==> T\n\n (READCH FOO 'EOF 'NEWLINE)  ==> NEWLINE\n (READCH FOO 'EOF 'NEWLINE)  ==> |?|\n (READCH FOO 'EOF 'NEWLINE)  ==> |f|\n (READCH FOO 'EOF 'NEWLINE)  ==> |o|\n (READCH FOO 'EOF 'NEWLINE)  ==> |o|\n (READCH FOO 'EOF 'NEWLINE)  ==> |b|\n (READCH FOO 'EOF 'NEWLINE)  ==> |a|\n (READCH FOO 'EOF 'NEWLINE)  ==> |r|\n\n (loop for a = (readch foo 'eof 'newline)\n       unless (eq a '| |)\n       return a)             ==> NEWLINE\n (newlinep foo)              ==> T\n (READCH FOO 'EOF 'NEWLINE)  ==> EOF\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "READLINE": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x88\\x12O\\x08(\\x00\\\\\\x00C\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1988-05-03T08:28:00", "lines": 92, "newlines": 67, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: READLINE\n\nSyntax:   (READLINE &optional arg1)\n\n arg1 (optional, evaluated) - an input file name.\n\nReturns:\n\n A string containing the contents of a single line (record) read from\n the input file specified by arg1, or NIL if end-of-file is encountered.\n while scanning for a character.\n\nProcessing:\n\n If the file specified by arg1 is in newline state, the next record\n is read; otherwise the current input record is used.  In either case,\n the result is a string whose length is equal to the length of the\n current input record and whose text is the contents of the record\n as is, with no character translation.\n\n If the file has fixed-length records, all values returned by READLINE\n will have the same length (the LRECL of the file).  For files with\n a variable-length record format, the value will have the length of\n the current record (the value in the RDW minus 4).\n\n READLINE always sets NEWLINEP to true.\n\n If end-of-file is encountered, NIL is returned (the EOF function will\n return T in this case).\n\n If the file is already in end-of-file status when READLINE is issued,\n an error is signalled.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n READCH, READLINE, TYI and ZILRDCH are the only functions that can cause\n the \"newline\" indication to be set in an input file (see NEWLINEP).\n\nExamples:\n\n #|\n Assume lines of input from file FOO, and that it has a variable-length\n record format:\n\n  Four score and seven\n  years ago\n  our fathers\n  brought forth\n\n  |#\n\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (progn\n  (with-open-file (file \"$$foo.$$test\" :out)\n   (princ \"Four score and seven\" file)\n   (terpri file)\n   (princ \"years ago\" file)\n   (terpri file)\n   (princ \"our fathers\" file)\n   (terpri file)\n   (princ \"brought forth\" file)\n   (terpri file)\n  )\n  (setq foo (open \"$$foo.$$test\" :in))\n  t\n )                                  ==> T\n\n (defun readslime (x) (string-right-trim \" \" (readline x)))\n                                    ==> READSLIME\n\n (READSLIME FOO)       ==> \"Four score and seven\"\n (READ FOO)            ==> YEARS\n (READSLIME FOO)       ==> \"years ago\"\n (READ FOO)            ==> OUR\n (READ FOO)            ==> FATHERS\n (READSLIME FOO)       ==> \"our fathers\"   ; those blanks did it\n (READSLIME FOO)       ==> \"brought forth\"\n (READSLIME FOO)       ==> \"NIL\" ; because READLINE returned NIL\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "REMAINDE": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? $\\x00!\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:24:00", "lines": 33, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMAINDER\n\nSyntax:   (REMAINDER &rest args)\n    or:   (// &rest args)\n    or:   (\\\\ &rest args)\n\n arg (evaluated) - an integer.\n\nReturns:\n\n The remainder (taken in succession) of all the arguments.\n\nProcessing:\n\n If no arguments are specified, 1 is returned.\n If one argument is specified, that argument is returned.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for errors detected.\n\nNotes:\n\nExamples:\n\n (REMAINDER)           ==> 1\n (REMAINDER 4)         ==> 4\n (REMAINDER 10 3)      ==> 1\n (REMAINDER 100 30 7)  ==> 3\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMDUPQ": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? %\\x00.\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:25:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMDUPQ\n\nSyntax:   (REMDUPQ arg1)\n\n arg1   (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of all the elements of arg1, but with duplicate\n elements removed.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the list specified by arg1.  If any element of the list is EQ\n to an element already in the list, it is not included; thus any such\n elements occur only once in the returned list.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by REMDUPQ.\n\n Compare REMDUPQL, which is like REMDUPQ but uses an EQL test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if arg1 is not a proper list.\n\n Keep in mind that EQ, not EQL, is used for the comparisons.\n Thus, only symbols, in general, will work as the first argument.\n\nExamples:\n\n (REMDUPQ '(F O O B A R B A Z F R O B)) ==> (F O B A R Z)\n\n (REMDUPQ '((F O O) (F O O) (B A R)))   ==> ((F O O) (F O O) (B A R))\n                                            ; Test is EQ, not EQUAL.\n\n (REMDUPQ '(2.0 1.0 4.0 7.0 4.0 8.0))   ==> (2.0 1.0 4.0 7.0 4.0 8.0)\n                                            ; Test is EQ, not EQL.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMDUPQL": {"ttr": 6157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x06?\\x00\\x87%? %\\x00*\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-10T20:25:00", "lines": 42, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMDUPQL\n\nSyntax:   (REMDUPQL arg1)\n\n arg1   (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of all the elements of arg1, but with duplicate\n elements removed.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the list specified by arg1.  If any element of the list is EQL\n to an element already in the list, it is not included; thus any such\n elements occur only once in the returned list.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by REMDUPQL.\n\n Compare REMDUPQ, which is like REMDUPQL but uses an EQ test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if arg1 is not a proper list.\n\nExamples:\n\n (REMDUPQL '(F O O B A R B A Z F R O B)) ==> (F O B A R Z)\n\n (REMDUPQL '(2.0 1.0 4.0 7.0 4.0 8.0))   ==> (2.0 1.0 4.0 7.0 8.0)\n\n (REMDUPQL '((F O O) (F O O) (B A R)))   ==> ((F O O) (F O O) (B A R))\n                                            ; Test is EQL, not EQUAL.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMDUPQU": {"ttr": 6159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x14\\x0f\\x00\\x87%? %\\x00*\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-05-20T00:00:00", "modifydate": "1987-09-10T20:25:00", "lines": 42, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMDUPQU\n\nSyntax:   (REMDUPQU arg1)\n\n arg1   (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of all the elements of arg1, but with duplicate\n elements removed.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the list specified by arg1.  If any element of the list is EQUAL\n to an element already in the list, it is not included; thus any such\n elements occur only once in the returned list.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by REMDUPQU.\n\n Compare REMDUPQ, which is like REMDUPQU but uses an EQ test;\n and REMDUPQL, which is like REMDUPQU but uses an EQL test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if arg1 is not a proper list.\n\nExamples:\n\n (REMDUPQU '(F O O B A R B A Z F R O B)) ==> (F O B A R Z)\n\n (REMDUPQU '(2.0 1.0 4.0 7.0 4.0 8.0))   ==> (2.0 1.0 4.0 7.0 8.0)\n\n (REMDUPQU '((F O O) (F O O) (B A R)))   ==> ((F O O) (B A R))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMOVE": {"ttr": 6161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? '\\x00C\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:27:00", "lines": 67, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMOVE\n\nSyntax:   (REMOVE arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of argument 2 except for those\n which are EQL to argument 1.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the list specified by the second argument.  Each atom found\n within the list structure that is EQL to the first argument is\n omitted from the new list.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n When count3 is used, some list structure may be shared between list2\n and the return value.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by REMOVE.\n\n Compare DELETE, which is the destructive equivalent of REMOVE.\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n REMOVE is, by default, implemented with an EQL test for Common LISP\n compatibility, using the ZIL function REMQL.  If Maclisp or Franz LISP\n compatibility is desired, REMOVE may be equated with ZIL function\n REMQUAL via the DEFLOAD special form.  See REMQ, REMQL and REMQUAL for\n more info.\n\n Under Macsyma, REMOVE performs an EQUAL test.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\nExamples:\n\n (REMOVE 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (REMOVE '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO BAR) (FOO) FOO BAR) ; Test is EQL, not EQUAL.\n\n (REMOVE '3 '(1 2 3 4 5))\n            ==> (1 2 4 5)    ; Test is EQL, not EQ.\n\n (REMOVE 'X '(X Y X Y X) 0) ==> (X Y X Y X)\n (REMOVE 'X '(X Y X Y X) 1) ==> (Y X Y X)\n (REMOVE 'X '(X Y X Y X) 2) ==> (Y Y X)\n (REMOVE 'X '(X Y X Y X) 3) ==> (Y Y)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMPROP": {"ttr": 6163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? (\\x005\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:28:00", "lines": 53, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMPROP\n\nSyntax:   (REMPROP arg1 arg2)\n\n arg1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - any LISP object, but generally a symbol.\n\nReturns:\n\n The value of the property specified by the second argument, as taken\n and removed from the property list specified by the first argument.\n If the property was not present, NIL is returned and the property\n list is unharmed.\n\nProcessing:\n\n The indicator/value pair for the property specified by the second\n argument is removed from the property list of the atom specified\n by the first argument.\n\n Although the first argument must be a symbol, ZIL will accept a\n first argument of a list, in which case the CDR of the list is\n treated like a property list.  This is the \"disembodied property list\"\n used in Maclisp.\n\nErrors signaled:\n\n Property list errors (see member $PROP).\n\nNotes:\n\n See member $PROP for information about property lists.\n\nExamples:\n\n (SETPLIST 'A '(FOO BAR BAZ (FROB NICK ATE)))\n                         ==> A\n (GET 'A 'FOO)           ==> BAR\n (GET 'A 'BAZ)           ==> (FROB NICK ATE)\n\n (REMPROP 'A 'FOO)       ==> BAR\n (GET 'A 'FOO)           ==> NIL\n (GET 'A 'BAZ)           ==> (FROB NICK ATE)\n\n (REMPROP 'A 'BAZ)       ==> (FROB NICK ATE)\n (GET 'A 'FOO)           ==> NIL\n (GET 'A 'BAZ)           ==> NIL\n\n (REMPROP 'A 'FOO)       ==> NIL\n (GET 'A 'FOO)           ==> NIL\n (GET 'A 'BAZ)           ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REMQ": {"ttr": 6165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? )\\x00@\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:29:00", "lines": 64, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMQ\n\nSyntax:   (REMQ arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object, but generally a symbol.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of argument 2 except for those\n which are EQ to argument 1.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the list specified by the second argument.  Each atom found\n within the list structure that is EQ to the first argument is\n omitted from the new list.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n When count3 is used, some list structure may be shared between list2\n and the return value.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by REMQ.\n\n Compare REMOVE, which is like REMQ but uses an EQL test;\n and DELQ, which is the destructive equivalent of REMQ.\n REMQ is equivalent to Common LISP (REMOVE ... :TEST #'EQ).\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\n Keep in mind that EQ, not EQL, is used for the comparisons.\n Thus, only symbols, in general, will work as the first argument.\n\nExamples:\n\n (REMQ 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (REMQ '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO BAR) (FOO) FOO BAR) ; Test is EQ, not EQUAL.\n\n (REMQ '3.0 '(1.0 2.0 3.0 4.0 5.0))\n            ==> (1.0 2.0 3.0 4.0 5.0)   ; Test is EQ, not EQL.\n\n (REMQ 'X '(X Y X Y X) 0) ==> (X Y X Y X)\n (REMQ 'X '(X Y X Y X) 1) ==> (Y X Y X)\n (REMQ 'X '(X Y X Y X) 2) ==> (Y Y X)\n (REMQ 'X '(X Y X Y X) 3) ==> (Y Y)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMQL": {"ttr": 6167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x06?\\x00\\x87%? )\\x00?\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-10T20:29:00", "lines": 63, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMQL\n\nSyntax:   (REMQL arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of argument 2 except for those\n which are EQL to argument 1.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the list specified by the second argument.  Each atom found\n within the list structure that is EQL to the first argument is\n omitted from the new list.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n When count3 is used, some list structure may be shared between list2\n and the return value.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by REMQL.\n\n Compare REMQ, which is like REMQL but uses an EQ test;\n and REMQUAL, which is like REMQL but uses an EQUAL test.\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\n The DELETE/DELQ/DELQL/DELQUAL family is the destructive equivalent\n of the REMOVE/REMQ/REMQL/REMQUAL family.\n\nExamples:\n\n (REMQL 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (REMQL '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO BAR) (FOO) FOO BAR) ; Test is EQL, not EQUAL.\n\n (REMQL '3 '(1 2 3 4 5))\n            ==> (1 2 4 5)    ; Test is EQL, not EQ.\n\n (REMQL 'X '(X Y X Y X) 0) ==> (X Y X Y X)\n (REMQL 'X '(X Y X Y X) 1) ==> (Y X Y X)\n (REMQL 'X '(X Y X Y X) 2) ==> (Y Y X)\n (REMQL 'X '(X Y X Y X) 3) ==> (Y Y)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMQUAL": {"ttr": 6169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x06?\\x00\\x87%? 0\\x00?\\x002\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "1987-09-10T20:30:00", "lines": 63, "newlines": 50, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REMQUAL\n\nSyntax:   (REMQUAL arg1 list2 &optional count3)\n\n arg1   (required, evaluated) - any LISP object.\n list2  (required, evaluated) - a proper list.\n count3 (optional, evaluated) - an integer.\n\nReturns:\n\n A list consisting of all the elements of argument 2 except for those\n which are EQUAL to argument 1.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the list specified by the second argument.  Each atom found\n within the list structure that is EQUAL to the first argument is\n omitted from the new list.\n\n If count3 is omitted or NIL, all occurrences of arg1 are removed from\n list2.  Otherwise, only the first count3 occurrences of arg1 are\n removed.  If count3 is less than 1, no elements are removed.\n\n When count3 is used, some list structure may be shared between list2\n and the return value.\n\n Note that only top-level elements of the list are considered;\n non-atomic elements are NOT recursively processed by REMQUAL.\n\n Compare REMQ, which is like REMQUAL but uses an EQ test;\n and REMQL, which is like REMQL but uses an EQL test.\n\nErrors signaled:\n\n Invalid count argument (not a fixnum or NIL).\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list.\n\n The DELETE/DELQ/DELQL/DELQUAL family is the destructive equivalent\n of the REMOVE/REMQ/REMQUAL/REMQUAL family.\n\nExamples:\n\n (REMQUAL 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (QUICK BROWN FOX JUMPS OVER LAZY DOG)\n\n (REMQUAL '(FOO BAR) '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> (FOO (FOO) FOO BAR) ; Test is EQUAL, not EQL.\n\n (REMQUAL '3 '(1 2 3 4 5))\n            ==> (1 2 4 5)    ; Test is EQUAL, not EQ.\n\n (REMQUAL 'X '(X Y X Y X) 0) ==> (X Y X Y X)\n (REMQUAL 'X '(X Y X Y X) 1) ==> (Y X Y X)\n (REMQUAL 'X '(X Y X Y X) 2) ==> (Y Y X)\n (REMQUAL 'X '(X Y X Y X) 3) ==> (Y Y)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RESTARG": {"ttr": 6171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%? 1\\x00+\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-10T20:31:00", "lines": 43, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RESTARG\n\nSyntax:   (RESTARG arg1)\n\n arg1 (required, evaluated) - a compiled code object (SUBR or closure).\n\nReturns:\n\n T or NIL, depending on whether the compiled code object specified by\n arg1 accepts &REST arguments.\n\nProcessing:\n\n RESTARG looks at the compiled code header information, extracts the\n restarg value therefrom, and returns T or NIL.\n\n Two ways to specify compiled code objects are:\n\n (1) (GET function-name 'SUBR) - which gets the current function\n     definition provided that it has been loaded.\n (2) (ZILLOAD function-name)   - which loads the function from disk.\n\nErrors signaled:\n\n Argument not a compiled code object or closure.\n\nNotes:\n\n This function was created for parallelism with MAXARGS and MINARGS.\n In particular, the ARGS function uses this internally.\n\n Functions that take keyword arguments are considered to take a\n &REST arg.\n\nExamples:\n\n (APPEND (CAR NIL) NIL)         ==> NIL ; to load CAR and APPEND.\n (RESTARG (GET 'CAR 'SUBR))     ==> NIL ; after CAR has been used.\n (RESTARG (ZILLOAD 'GC))        ==> NIL\n (RESTARG (GET 'APPEND 'SUBR))  ==> T   ; after APPEND has been used.\n (RESTARG (ZILLOAD 'MAPCAR))    ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RETURN": {"ttr": 6173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x88\\x17O\\x08H\\x00A\\x006\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1988-06-22T08:48:00", "lines": 65, "newlines": 54, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: RETURN\n\nSyntax:   (RETURN &optional arg1)\n\n arg1 (optional, evaluated) - any LISP object.\n\nReturns:\n\n There is no return value.  The value of the first argument is the\n return value for the currently active PROG, or BLOCK named NIL.\n\nProcessing:\n\n RETURN is valid only within a PROG, or a BLOCK named NIL.\n\n The argument is evaluated and the current PROG (or BLOCK named NIL) is\n exited using that value as its return value.  If the argument is\n omitted, NIL is used as the value.\n\n Under the interpreter, RETURN may exit a PROG even when it is\n executed from within a lexical closure (FUNARG), which may produce\n some bizarre results.  In compiled code, RETURN may not branch out\n of a FUNARG.\n\n When RETURN transfers control from inside a form protected by\n UNWIND-PROTECT to outside that form, the UNWIND-PROTECT cleanup forms\n are executed before the PROG is exited.\n\nErrors signaled:\n\n Missing argument\n RETURN outside of a PROG or BLOCK named NIL\n\nNotes:\n\n RETURN used to be a special form, but is now a macro that expands\n into a (RETURN-FROM NIL ...).  See PROG, which is now a macro that\n expands into a BLOCK named NIL, among other things.\n\n GO and RETURN are valid as long as they are lexically apparent in\n the code.  This means that they will be processed as long as they\n are not the product of function evaluation.  The following are\n valid occurrences of GO and RETURN:\n\n (PROG (A B C) LOOP (DO 'SOMETHING) (GO LOOP) (RETURN T))\n (PROG (A B C) (COND ((EQ A T) (GO LOOP)))\n               LOOP (PROG2 (PRINT A) (RETURN B)))\n\n The following is NOT valid:\n\n (DEFUN SUMFUNK (A) (RETURN A))\n (PROG (B) LAB (COND ((NULL A) (SUMFUNK T))) (SUMFUNK NIL))\n\n A \"RETURN outside of PROG\" error will be signalled.\n\nExamples:\n\n (PROG (X)\n       (SETQ X (CONS 'A X))\n       (SETQ X (CONS 'B X))\n       (SETQ X (CONS 'C X))\n       (RETURN X)\n )                                ==> (C B A)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RETURNFR": {"ttr": 6175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x1f\\x00\\x88\\x16\\x1f\\x08E\\x00D\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-09T00:00:00", "modifydate": "1988-06-09T08:45:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: RETURN-FROM\n\nSyntax:   (RETURN-FROM name1 &optional arg2)\n\n name1 (required, evaluated) - a symbol.\n arg2  (optional, evaluated) - any LISP object.\n\nReturns:\n\n There is no return value.  The value of arg2 is the\n return value for the currently active BLOCK named name1.\n\nProcessing:\n\n arg2 is evaluated and the current BLOCK whose name is EQ to name1 is\n exited using that value as its return value.  If arg2 is omitted, NIL\n is used as the value.\n\n RETURN-FROM is valid only within a BLOCK.\n (Exception:  If name1 is NIL, then RETURN-FROM is valid within a\n PROG, which is like a BLOCK named NIL.)\n\n Under the interpreter, RETURN-FROM may exit a BLOCK even when it is\n executed from within a lexical closure (FUNARG), which may produce some\n bizarre results.  In compiled code, RETURN-FROM may not branch out of a\n FUNARG.\n\n When RETURN-FROM transfers control from inside a form protected by\n UNWIND-PROTECT to outside that form, the UNWIND-PROTECT cleanup forms\n are executed before the BLOCK is exited.\n\nErrors signaled:\n\n Missing block name\n RETURN-FROM block name not active\n\nNotes:\n\n RETURN-FROM is valid as long as it is lexically apparent in\n the code.  This means that it will be processed as long as it is\n not the product of function evaluation.  The following are\n valid occurrences of RETURN-FROM:\n\n (BLOCK FOO (DO 'SOMETHING) (RETURN-FROM FOO T))\n (BLOCK BAR1\n        (BLOCK BAR2\n               (COND ((EQ A T) (RETURN-FROM BAR2 A))\n                     (T (PROGN (PRINT 1) (RETURN-FROM BAR1))))))\n\n\n The following is NOT valid:\n\n (DEFUN SUMFUNK () (RETURN-FROM NOGOOD 'Z))\n (BLOCK NOGOOD (SUMFUNK))\n\n A \"No matching RETURN-FROM block name\" error will be signalled.\n\nExamples:\n\n (LET (X)\n      (BLOCK FOO\n            (SETQ X (CONS 'A X))\n            (SETQ X (CONS 'B X))\n            (SETQ X (CONS 'C X))\n            (RETURN-FROM FOO X)\n      ))                               ==> (C B A)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REVAPPEN": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x19\\x1f\\x00\\x87%? 2\\x001\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-07-10T00:00:00", "modifydate": "1987-09-10T20:32:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REVAPPEND\n\nSyntax:   (REVAPPEND list1 list2)\n    or:   (REVAPPEN list1 list2)\n\n list1 (required, evaluated) - a proper list.\n list2 (required, evaluated) - any LISP object, but generally a list.\n\nReturns:\n\n A list consisting of the elements of argument 1 in reverse order\n followed by the elements of argument 2.\n\nProcessing:\n\n (REVAPPEND X Y) is equivalent to (APPEND (REVERSE X) Y), in particular\n with respect to the fact that the first argument is copied, not\n destroyed.\n\n Compare NRECONC, which destructively alters the first argument.\n\nErrors signaled:\n\n list1 not a proper list.\n\nNotes:\n\n As a special case, (REVAPPEND atom NIL), where atom is not a list,\n returns the selfsame atom.\n\n\nExamples:\n\n (REVAPPEND NIL NIL)         ==> NIL\n (REVAPPEND NIL '(A B C))    ==> (A B C)\n (REVAPPEND '(A B C) NIL)    ==> (C B A)\n (REVAPPEND '(A) '(B))       ==> (A B)\n (REVAPPEND '(A) 'B)         ==> (A . B)\n (REVAPPEND '(A B) '(C D))   ==> (B A C D)\n (REVAPPEND '(A B C) 'D)     ==> (C B A . D)\n\n;The following shows how the second argument to REVAPPEND is NOT copied.\n\n (SETQ X '(A B))             ==> (A B)\n (SETQ Y '(C D))             ==> (C D)\n (SETQ Z (REVAPPEND X Y))    ==> (B A C D)\n (EQ (CDDR Z) Y)             ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REVERSAL": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%? 3\\x00%\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-10T20:33:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REVERSALL\n\nSyntax:   (REVERSALL arg1)\n    or:   (REVERSAL arg1)\n\n arg1 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of argument 1 in reverse order,\n with all the sublists reversed as well.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the first list.  Any sublists are recursively reversed.\n\n Compare REVERSE, which reorders the top-level elements but does not\n recursively reverse them.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the argument.\n Unpredictable results will occur if the argument is not a proper list.\n\nExamples:\n\n (REVERSAL NIL)              ==> NIL\n (REVERSAL '(A))             ==> (A)\n (REVERSAL '(A B C D))       ==> (D C B A)\n (REVERSAL '((A B) (C D)))   ==> ((D C) (B A))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REVERSE": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x02\\x9f\\x00\\x87%? 5\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-29T00:00:00", "modifydate": "1987-09-10T20:35:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: REVERSE\n\nSyntax:   (REVERSE list1)\n\n list1 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of list1 in reverse order.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements\n of the first list.  Note that the CAR's of the list are NOT\n recursively reversed.\n\n Compare NREVERSE, which destroys its argument;\n and REVERSALL, which recursively reverses the elements.\n\nErrors signaled:\n\n Argument not a proper list.\n\nNotes:\n\nExamples:\n\n (REVERSE NIL)               ==> NIL\n (REVERSE '(A))              ==> (A)\n (REVERSE '(A B C D))        ==> (D C B A)\n (REVERSE '((A B) (C D)))    ==> ((C D) (A B))\n\n;The following shows how a new copy of a list is made using REVERSE.\n\n (SETQ X '(A D A))           ==> (A D A)\n (SETQ Y (REVERSE X))        ==> (A D A)\n (EQ X Y)                    ==> NIL\n (EQUAL X Y)                 ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMCHAR": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? 6\\x00<\\x00<\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:36:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RMCHAR\n\nSyntax:   (RMCHAR)\n\nReturns:\n\n A symbol whose print name is the current reader macro character.\n\nProcessing:\n\n When the READ function is about to process a reader macro, it sets\n the current macro character whose macro it is processing.  This\n value is returned by the RMCHAR function.\n\n If this function is executed outside of a reader macro processing\n environment, unpredictable results will occur.\n\n RMCHAR is meant to be executed by a reader macro which needs to\n reference the macro character which triggered it.  Therefore,\n the symbol is always interned on the oblist.\n\n RMCHAR does NOT return the dispatching character associated with\n a # (sharp sign) reader macro subfunction.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n See documentation on READ, DEFRDMAC and RDRMACRO for more information\n on reader macro processing.\n\n Reader macro definitions for the following characters are predefined:\n\n ' (single quote)\n ` (backquote)\n , (comma)\n # (sharp sign)\n\n See member $RMACRO in this documentation for details on these.\n\nExamples:\n\n Assume a reader macro defined thus:\n\n   (DEFRDMAC '|?| '(LAMBDA (X) (LIST (RMCHAR) (READ X))))\n\n Then, when the following is read in:\n\n   ?FOO\n\n the following will be returned by READ:\n\n   (? FOO)\n\n (Note that under the interpreter, this will be evaluated by EVAL\n before the user sees the result.)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMINIT": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? 6\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:36:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RMINIT\n\nSyntax:   (RMINIT)\n\nReturns:\n\n NIL, after restoring the read table to its default mode of operation.\n\nProcessing:\n\n The read table is reset to its initial status, cancelling any\n user-defined reader macros and re-establishing the standard meanings\n for all characters.  This includes the forward and backward slash\n characters / and \\, which may have been changed by the RMMAC function.\n the same as the backslash \\ character, i.e. as a single escape.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n If you use this to cancel RMMAC, you lose all your reader macro\n definitions that you changed.  Too bad.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMMAC": {"ttr": 6411, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%? 9\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-10T20:39:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RMMAC\n\nSyntax:   (RMMAC)\n\nReturns:\n\n NIL, after changing the syntax of the slash (/) and backslash (\\).\n\nProcessing:\n\n The read table is modified to treat the forward slash character /\n the same as the backslash \\ character, i.e. as a single escape.\n\n The backslash then becomes a \"normal\" character, with no escapism.\n\n The purpose of this hack is to enable Maclisp-style reader syntax.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n To restore default reader syntax, use the RMINIT function.  Note,\n however, that that currently results in the cancellation of any\n user-defined reader macros.\n\nExamples:\n\n Before executing RMMAC:\n\n   '/foo\\bar  ==>   /FOObAR\n\n   (RMMAC)    ==>   NIL\n\n After executing RMMAC:\n\n   '/foo\\bar  ==>   fOO\\BAR\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMNIL": {"ttr": 6413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x17\\x9f\\x089\\x005\\x003\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-27T08:39:00", "lines": 53, "newlines": 51, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RMNIL\n\nSyntax:   (RMNIL)\n\nReturns:\n\n An object, known as \"RMNIL\", which has special meaning to the reader.\n\nProcessing:\n\n When the READ function invokes a reader macro, it generally uses\n the value returned by the macro as the value \"read\".  However, in some\n cases a reader macro may wish to indicate that nothing was returned.\n The RMNIL function is used to transmit this wish back to the reader.\n When the reader receives this special object as a return value from\n a reader macro, it is redriven to read another object.  Thus the\n reader macro has returned \"nothing\" to the reader.\n\n If this function is executed outside of a reader macro processing\n environment, or an attempt is made to print its value, the results\n are undefined.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The same functionality may be provided by a reader macro by\n returning zero values (e.g. via the form (VALUES)).  RMNIL\n is present for compatibility with earlier releases of ZIL\n that did not contain multiple values processing.\n\n See documentation on READ, DEFRDMAC and RDRMACRO for more information\n on reader macro processing.\n\n The #+ and #- reader macro syntaxes use this function.\n\nExamples:\n\n Assume a reader macro defined thus:\n\n   (DEFRDMAC '|?| '(LAMBDA (X) (READ X) (RMNIL)))\n\n Then, when the following is read in:\n\n   '(?FOO BAR BAZ)\n\n the \"FOO\" will be ignored and the result will be:\n\n   (QUOTE (BAR BAZ))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ROT": {"ttr": 6415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x19\\x7f\\x00\\x87%O\\x074\\x00,\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-07-16T00:00:00", "modifydate": "1987-09-11T07:34:00", "lines": 44, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ROT\n\nSyntax:   (ROT arg1 arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of an arithmetic rotate operation\n performed on arg1, with arg2 specifying the number of bits to rotate\n (left if positive, right if negative).\n\nProcessing:\n\n An arithmetic rotate operation is performed on the numeric contents of\n arg1 (not in place), with arg2 determining the amount and direction of\n the rotation.\n\n If arg2 is positive, a left rotate of N bits takes place, with N being\n the absolute value of the fixnum arg2.\n\n If arg2 is negative, a right rotate of N bits takes place, with N being\n the absolute value of the fixnum arg2.\n\n If arg2 is zero, no rotate takes place, but arg1 is returned.\n\nErrors signaled:\n\n First argument not a fixnum.\n Second argument not a fixnum.\n\nNotes:\n\n Results are not valid if the absolute value of arg2 is greater than 31.\n\nExamples:\n\n (rot 1 -1) ==> -2147483648  ; Standard way to get most negative fixnum.\n (rot 1 2)  ==> 4\n (rot -1 7) ==> -1\n (rot 1 -2) ==> #z\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ROUND": {"ttr": 6417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x86\\x04/\\x00\\x89\\x05O\\x17H\\x00n\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-02-11T00:00:00", "modifydate": "1989-02-23T17:48:00", "lines": 110, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ROUND\n\nSyntax:   (ROUND arg1 &optional arg2)\n\n arg1 (required, evaluated) - a number.\n arg2 (optional, evaluated) - a number.\n\nReturns:\n\n Two values:\n\n  (1) arg1, or arg1 divided by arg2, rounded to the nearest integer.\n  (2) If arg1 only is specified, the difference of arg1 and the\n      first value.\n      If arg1 and arg2 are specified, the remainder, i.e. the difference\n      of arg1 and (arg2 times the first value).\n\nProcessing:\n\n If arg2 is specified, arg1 is divided by arg2 such that a floating\n point result is obtained.  Otherwise, the argument is set to arg1.\n\n If the argument is float, it is rounded to the nearest integer.\n The rounding is accomplished as if 0.5 were added to the absolute\n value of the result, with the exception that if the value of the\n argument lies exactly halfway between two integers (xxx.5), it\n is rounded to the next EVEN integer.\n\n If the argument is integer, itself is returned.\n\nErrors signaled:\n\n Non-numeric argument(s).\n\nNotes:\n\n Compare CEILING, FLOOR and TRUNCATE.\n\n The rounding to the nearest even integer algorithm breaks down in\n cases where a bignum result must be returned due to the magnitude\n of the floating-point argument.\n\nExamples:\n\n ; Note: Only the first value is shown in these examples.\n\n (ROUND 1)       ==> 1\n (ROUND 1.5)     ==> 2\n (ROUND 1.9)     ==> 2\n (ROUND 1.2)     ==> 1\n (ROUND 1.5F0)   ==> 2\n (ROUND 1.9F0)   ==> 2\n (ROUND 1.2F0)   ==> 1\n (ROUND -1)      ==> -1\n (ROUND -1.5)    ==> -2\n (ROUND -1.9)    ==> -2\n (ROUND -1.2)    ==> -1\n (ROUND -1.5F0)  ==> -2\n (ROUND -1.9F0)  ==> -2\n (ROUND -1.2F0)  ==> -1\n (ROUND 0)       ==> 0\n (ROUND 0.5)     ==> 0\n (ROUND 0.9)     ==> 1\n (ROUND 0.2)     ==> 0\n (ROUND 0.5F0)   ==> 0\n (ROUND 0.9F0)   ==> 1\n (ROUND 0.2F0)   ==> 0\n (ROUND -0)      ==> 0\n (ROUND -0.5)    ==> 0\n (ROUND -0.9)    ==> -1\n (ROUND -0.2)    ==> 0\n (ROUND -0.5F0)  ==> 0\n (ROUND -0.9F0)  ==> -1\n (ROUND -0.2F0)  ==> 0\n\n (ROUND 6.5)     ==> 6\n (ROUND 5.5)     ==> 6\n (ROUND 4.5)     ==> 4\n (ROUND 3.5)     ==> 4\n (ROUND 2.5)     ==> 2\n (ROUND 1.5)     ==> 2\n (ROUND 0.5)     ==> 0\n (ROUND -0.5)    ==> 0\n (ROUND -1.5)    ==> -2\n (ROUND -2.5)    ==> -2\n (ROUND -3.5)    ==> -4\n (ROUND -4.5)    ==> -4\n (ROUND -5.5)    ==> -6\n (ROUND -6.5)    ==> -6\n\n (ROUND 9 3)     ==> 3\n (ROUND 10 3)    ==> 3\n (ROUND 11 3)    ==> 4\n (ROUND 12 3)    ==> 4\n (ROUND -9 3)    ==> -3\n (ROUND -10 3)   ==> -3\n (ROUND -11 3)   ==> -4\n (ROUND -12 3)   ==> -4\n\n (ROUND 20 2)    ==> 10\n (ROUND 21 2)    ==> 10\n (ROUND 22 2)    ==> 11\n (ROUND 23 2)    ==> 12\n (ROUND 24 2)    ==> 12\n (ROUND 25 2)    ==> 12\n (ROUND 26 2)    ==> 13\n (ROUND 27 2)    ==> 14\n (ROUND 28 2)    ==> 14\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RPLACA": {"ttr": 6419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x077\\x00+\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T07:37:00", "lines": 43, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RPLACA\n\nSyntax:   (RPLACA arg1 arg2)\n\n arg1 (required, evaluated) - a cons (list or dotted pair).\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n The first argument, with its CAR replaced by the second argument.\n\nProcessing:\n\n The second argument destructively replaces the CAR of the first\n argument; i.e. the first argument becomes a CONS of the second\n argument and the CDR of the first argument, but without obtaining\n a new cell.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n As with all the \"destructive\" functions, RPLACA should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\nExamples:\n\n (SETQ X '(A B C))  ==> (A B C)\n X                  ==> (A B C)\n\n (RPLACA X 'D)      ==> (D B C)\n X                  ==> (D B C)\n\n;Note that the value of X has been altered.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RPLACD": {"ttr": 6421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x077\\x00+\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T07:37:00", "lines": 43, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RPLACD\n\nSyntax:   (RPLACD arg1 arg2)\n\n arg1 (required, evaluated) - a cons (list or dotted pair).\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n The first argument, with its CDR replaced by the second argument.\n\nProcessing:\n\n The second argument destructively replaces the CDR of the first\n argument; i.e. the first argument becomes a CONS of the CAR of the\n first argument and the second argument, but without obtaining\n a new cell.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n As with all the \"destructive\" functions, RPLACD should not be used\n on an in-line compiled list, i.e. a list derived from compiling the\n construct (QUOTE (form1 form2 ...)).  This will cause further\n references to the in-line constant list to be incorrect.\n\nExamples:\n\n (SETQ X '(A B C D))  ==> (A B C D)\n X                    ==> (A B C D)\n\n (RPLACD X '(E F))    ==> (A E F)\n X                    ==> (A E F)\n\n;Note that the value of X has been altered.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RUNTIME": {"ttr": 6423, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x13O\\x00\\x87%O\\x077\\x00\\x1f\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-05-14T00:00:00", "modifydate": "1987-09-11T07:37:00", "lines": 31, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: RUNTIME\n\nSyntax:   (RUNTIME)\n    or:   (CPUTIME)\n\nReturns:\n\n An integer containing the number of milliseconds (thousandths of a\n second) of CPU time used so far in the current TSO session or batch\n job.\n\nProcessing:\n\n The value is taken from the \"job step elapsed time\" field of the\n address space control block (ASCB) and converted to milliseconds.\n This is the same source of the info that the TSO CLIST variable\n &SYSCPU uses.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n For compatibility with earlier ZIL code, this function may also be\n called CPUTIME.\n\n This is generally useful only by taking the value at two different\n points and subtracting to get CPU time elapsed between those points.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SALIST": {"ttr": 6425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x13/\\x00\\x87%O\\x078\\x00\"\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-05-12T00:00:00", "modifydate": "1987-09-11T07:38:00", "lines": 34, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SPECIAL-ALIST\n\nSyntax:   (SPECIAL-ALIST)\n    or:   (SALIST)\n\nReturns:\n\n The current special variable binding environment (alist).\n\nProcessing:\n\n The current special variable binding environment, normally implemented\n in ZIL as an \"association list\" of dotted pairs of dynamically bound\n symbols and their values, is returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n SETSALST, or SETF on SPECIAL-ALIST, may be used to update this. But\n please don't unless you really know what you are doing.\n\n The value of the \"special alist\" is reset by a THROW, even if\n it has been changed via SETF of SPECIAL-ALIST.\n\n In ZIL 1.3 there are two variable binding \"alists\": the\n \"special alist\" and the \"lexical alist\". The \"special alist\" is used\n to implement SPECIAL variable bindings, and the \"lexical alist\" is\n used to effect lexical bindings in cases where the bindings are\n across LAMBDA boundaries or captured by lexical closures.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAPPEND": {"ttr": 6427, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87)/#(\\x00'\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-10-19T23:28:00", "lines": 39, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-APPEND\n\nSyntax:   (STRING-APPEND &rest args)\n    or:   (SAPPEND &rest args)\n\n arg (required, evaluated) - a string.\n\nReturns:\n\n A string made up of all the args concatenated to form a new string.\n\nProcessing:\n\n If no arguments are specified, a null string is returned.\n\nErrors signaled:\n\n Argument not a string.\n\nNotes:\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.\n\n Arguments other than symbols and strings are not permitted.  (This\n is unlike CONCAT, for example, that allows most atomic objects as\n arguments, but makes a symbol.)  Use TOSTRING to transform numbers,\n for example, into strings.\n\n Compare STRING-APPENDL, which applies STRING-APPEND to a list\n of arguments.\n\nExamples:\n\n (STRING-APPEND)                   ==> \"\"\n (STRING-APPEND \"A\")               ==> \"A\"\n (STRING-APPEND \"foo\" \"bar\" \"baz\") ==> \"foobarbaz\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAPPENDL": {"ttr": 6429, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x86\\x08?\\x00\\x87)/#(\\x00'\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-03-24T00:00:00", "modifydate": "1987-10-19T23:28:00", "lines": 39, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-APPENDL\n\nSyntax:   (STRING-SAPPENDL list1)\n    or:   (SAPPENDL list1)\n\n list1 (required, evaluated) - a list of strings.\n\nReturns:\n\n A string made up of all the elements of list1 concatenated to form a\n new string.\n\nProcessing:\n\n If list1 is NIL, a null string is returned.\n\nErrors signaled:\n\n Argument other than a string contained within the list.\n\nNotes:\n\n (SAPPENDL a) is equivalent to (APPLY #'STRING-APPEND a), but faster.\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.\n\n Arguments other than symbols and strings are not permitted.  (This\n is unlike CONCATL, for example, that allows most atomic objects in\n the list argument, but makes a symbol.)  Use TOSTRING to transform\n numbers, for example, into strings.\n\nExamples:\n\n (SAPPENDL NIL)                    ==> \"\"\n (SAPPENDL '(\"A\"))                 ==> \"A\"\n (SAPPENDL '(\"foo\" \"bar\" \"baz\"))   ==> \"foobarbaz\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SASSOC": {"ttr": 6431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f I\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T20:49:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: SASSOC\n\nSyntax:   (SASSOC arg1 alist2 fun3)\n\n arg1   (required, evaluated) - any LISP object.\n alist2 (required, evaluated) - a list in association list format\n                                (i.e. a list of dotted pairs).\n fun3   (required, evaluated) - a function of no arguments.\n\nReturns:\n\n The first dotted pair in alist2 whose CAR matches arg1;\n the result of invoking fun3 if no such pair exists.\n\nProcessing:\n\n Same as for ASSOC, except that if no matching pair is found, fun3 is\n executed.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Since this is a macro that expands into a call to ASSOC, it uses\n whatever equality test ASSOC uses.  See ASSOC for more information.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SASSQ": {"ttr": 6433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f P\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T20:50:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: SASSQ\n\nSyntax:   (SASSQ arg1 alist2 fun3)\n\n arg1   (required, evaluated) - any LISP object.\n alist2 (required, evaluated) - a list in association list format\n                                (i.e. a list of dotted pairs).\n fun3   (required, evaluated) - a function of no arguments.\n\nReturns:\n\n The first dotted pair in alist2 whose CAR matches arg1;\n the result of invoking fun3 if no such pair exists.\n\nProcessing:\n\n Same as for ASSQ, except that if no matching pair is found, fun3 is\n executed.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Since this is a macro that expands into a call to ASSQ, it uses\n whatever equality test ASSQ uses.   See ASSQ for more information.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCAPITAL": {"ttr": 6435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x01?\\x00\\x88\\x01?\\x08P\\x00;\\x00;\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-13T00:00:00", "modifydate": "1988-01-13T08:50:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-CAPITALIZE\n\nSyntax:   (STRING-CAPITALIZE string1)\n    or:   (SCAPITAL string1)\n\n string1 (required, evaluated) - a string.\n\nReturns:\n\n A string identical to string1, except that all words in the\n string are capitalized (see below for details).\n\nProcessing:\n\n The input argument is not altered.  A copy, if necessary, is returned\n as follows:\n\n Each word in the string is translated such that the first character\n is uppercased if it is a lowercase alphabetic, and the other\n characters are lowercased if they are uppercase alphabetic.\n\n A \"word\" is defined as a sequence of ALPHANUMERIC characters within\n the string, delimited by whitespace OR other non-alphanumerics.\n Note that the national characters (@,#,$) are considered\n non-alphanumeric for the purposes of STRING-CAPITALIZE.\n\n As with most string-handling functions, symbols are acceptable.\n However, the returned value is always a string.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Insufficient vector/string space to build the result.\n\nNotes:\n\n Compare STRING-UPCASE and STRING-DOWNCASE.\n\nExamples:\n\n (STRING-CAPITALIZE \"\")      ==> \"\"\n (STRING-CAPITALIZE \"a\")     ==> \"A\"\n (STRING-CAPITALIZE \"A\")     ==> \"A\"\n (STRING-CAPITALIZE \"foo\")   ==> \"Foo\"\n (STRING-CAPITALIZE \"FOO\")   ==> \"Foo\"\n (STRING-CAPITALIZE NIL)     ==> \"Nil\"\n (STRING-CAPITALIZE '|Foo Bar|) ==> \"Foo Bar\"\n\n; Examples from Steele's \"Common LISP: The Language\" follow.\n\n (string-capitalize \" hello \") ==> \" Hello \"\n (string-capitalize\n     \"occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION\")\n ==> \"Occluded Casements Forestall Inadvertent Defenestration\"\n (string-capitalize 'kludgy-hash-search) ==> \"Kludgy-Hash-Search\"\n (string-capitalize \"DON'T!\")            ==> \"Don'T!\"   ; not \"Don't!\"\n (string-capitalize \"pipe 13a, foo16c\")  ==> \"Pipe 13a, Foo16c\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRSIZE": {"ttr": 6437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x02o\\x00\\x87%O\\x07D\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-01-26T00:00:00", "modifydate": "1987-09-11T07:44:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SCRSIZE\n\nSyntax:   (SCRSIZE)\n\nReturns:\n\n A CONS (dotted pair) of the current number of rows and the current\n number of columns of your display terminal.\n\nProcessing:\n\n The MVS GTSIZE macro is used to obtain the CURRENT terminal attributes\n and return them as a pair of fixnums.  If this function is invoked in\n a batch environment, (0 . 132) will be returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n What this function returns depends on your CURRENT screen size, which\n can be changed on TSO via the TERMINAL or XSCREEN command.\n\nExamples:\n\n (SCRSIZE)     ... returns (43 . 80) on a 3278 model 4.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SECOND": {"ttr": 6439, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x172\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:32:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: SECOND\n\nSyntax:   (SECOND list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The second element of list1, or NIL if list1 has less than 2 elements.\n\nProcessing:\n\n This is the same as CADR.\n\nErrors signaled:\n\n See CADR.\n\nNotes:\n\n See CADR.\n\nExamples:\n\n (SECOND NIL)                ==> NIL\n (SECOND '(A))               ==> NIL\n (SECOND '(A B C D))         ==> B\n (SECOND '((A1 A2) (B1 B2))) ==> (B1 B2)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SET": {"ttr": 6441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87&\\x0f\\t\\x18\\x00>\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-17T09:18:00", "lines": 62, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SET\n\nSyntax:   (SET var1 val2)\n\n var1 (required, evaluated) - a symbol.\n val2 (required, evaluated) - any LISP object.\n\nReturns:\n\n val2, after the variable specified by var1 has been bound\n to the value specified by val2.\n\nProcessing:\n\n SET performs a similar function to SETQ, except that the first\n argument is evaluated (it must return a valid symbol).\n\n The current dynamic (SPECIAL) binding of the variable specified by the\n first argument is altered to refer to the (evaluated) second argument;\n in other words, the \"value\" of var1 is set to val2.\n\n This is NOT a new binding; the previous binding is not saved but\n is overlaid.\n\n If the variable is not currently bound, a global binding is created\n using the specifed value.\n\n The symbol may not be self-evaluating (NIL, T or a keyword).\n\n SET does not affect lexical (non-SPECIAL) bindings.\n\nErrors signaled:\n\n Invalid first argument.\n\nNotes:\n\n SET is rarely used; SETQ is the usual assignment function for\n local variables.\n\n The extent of a local SET assignment is limited to the extent of the\n binding itself; when the binding disappears, the SET assignment also\n disappears.  If a previous binding of the variable was \"shadowed\" by\n the other, the previous binding is \"uncovered\" in the same way as if\n the SET had never been issued.  A SET assignment to a globally bound\n variable affects the global binding.\n\n Although SET assigns a dynamic binding to a variable, it does not\n automatically cause that variable to become globally declared\n SPECIAL.\n\nExamples:\n\n (let ((a 'z))\n      (setq a 'Z)             ; This sets local value of A.\n      (set 'a 'set-quote-a)   ; This sets global value of A.\n      (set a  'set-a)         ; This sets global value of Z.\n      a)              ==> Z\n A                    ==> SET-QUOTE-A\n Z                    ==> SET-A\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "SETABEND": {"ttr": 6443, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x16\\x7f\\x00\\x87%O\\x07T\\x00,\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-06-16T00:00:00", "modifydate": "1987-09-11T07:54:00", "lines": 44, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETABEND\n\nSyntax:   (SETABEND arg1)\n\n arg1 (required, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n arg1, after issuing an ESTAE macro instruction to control the\n operation of ZIL if an abnormal termination (ABEND) should occur.\n\nProcessing:\n\n If arg1 is NIL, then any ABENDs occurring in ZIL code will cause\n the entire ZIL session to be abnormally terminated.\n\n Otherwise, any ABENDs occurring in ZIL code will cause an error to\n be signalled and a THROW to tag NIL to occur, as for any normal\n kind of ZIL error.\n\nErrors signaled:\n\n ESTAE failure (e.g. some other routine cancelled ZIL's ESTAE).\n\nNotes:\n\n Certain ZIL floating-point operations may result in program checks\n (e.g. overflow).  If (SETABEND NIL) is specified, these will result in\n termination of ZIL.\n\n Some ZIL operations are uninterruptible (e.g. the garbage collector).\n If an ABEND occurs during such a process, the ZIL session is abnormally\n terminated, as no recovery is possible.\n\n Abends in programs or commands invoked from ZIL via the INVOKE or TSO\n functions never terminate ZIL; neither do abends on file opens.\n However, errors in I/O are subject to SETABEND control.\n\nExamples:\n\n (SETABEND T) enables abend handling.\n (SETABEND NIL) disables abend handling.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETARG": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87&\\x0f\\x07&\\x00&\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-17T07:26:00", "lines": 38, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: SETARG\n\nSyntax:   (ARG arg1 arg2)\n\n arg1 (required, evaluated) - an integer.\n arg2 (required, evaluated) - ayn LISP object.\n\nReturns:\n\n arg2, after the arg1'th argument of the currently active LEXPR has\n been replaced by arg2.\n\nProcessing:\n\n As above.\n\nErrors signaled:\n\n SETARG issued outside LEXPR.\n arg1 out of range, or otherwise invalid.\n\nNotes:\n\n No error checking is done in compiled code.  Results are unpredictable\n if an invalid argument is passed.\n\n See member $LEXPR for information about LEXPR's.\n\nExamples:\n\n (DEFUN FOO X\n        (LIST (SETARG 1 'A)\n              (SETARG 2 'B)\n              (ARG T)))  ==> FOO\n\n (FOO 'X 'Y 'Z)        ==> (A B (A B Z))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETATTN": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x16\\x8f\\x00\\x86 /\\x136\\x00,\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-17T00:00:00", "modifydate": "1986-07-21T13:36:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETATTN\n\nSyntax:   (SETATTN arg1)\n\n arg1 (required, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n arg1, after issuing a STAX macro instruction to control the\n operation of ZIL if an attention interrupt (PA1) should occur.\n\nProcessing:\n\n If arg1 is NIL, then any attention interrupts entered by the user\n during ZIL code will cause the entire ZIL session to be flushed.\n\n Otherwise, any attentions occurring in ZIL code will cause the ZIL\n attention handler to gain control.  The handler permits the user to\n abort the current process (which causes a THROW to tag T, which is\n presumed to be \"top level\" from the point of view of the user)\n or to continue with the current process as if attention had never been\n hit.   If an attention interrupt is entered at this point, ZIL is\n flushed.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Some ZIL operations are uninterruptible (e.g. the garbage collector).\n If an attention interrupt occurs during such a process, the user's\n only options are to resume ZIL operation or flush ZIL entirely by\n hitting attention again.\n\n Attentions in programs or commands invoked from ZIL via the TSO\n function never terminate ZIL.\n\nExamples:\n\n (SETATTN T) enables attention handling.\n (SETATTN NIL) disables attention handling.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETBRACK": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x00\\x8f\\x00\\x87\\x01_\\x14\\x15\\x00k\\x00k\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-01-08T00:00:00", "modifydate": "1987-01-15T14:15:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETBRACK\n\nSyntax:   (SETBRACK arg1 arg2 &optional arg3)\n\n arg1 (required, evaluated) - a fixnum between 0 and 255 inclusive.\n arg2 (required, evaluated) - a fixnum between 0 and 255 inclusive.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n NIL, after changing the default characters used for printout of\n left and right square brackets for files with tab expansion active\n and no slashification.\n\nProcessing:\n\n Since IBM does not support square brackets consistently, ZIL's\n default initial behavior when printing them is as follows:\n\n (1) For files without the tab expansion feature, square brackets are\n     sent as is.\n\n (2) For files with the tab expansion feature, square brackets are\n     translated to curly braces so they can be browsed easily.\n\n The above applies only to output generated by PRINC, i.e. without\n slashification.  For PRIN1 output, square brackets are always sent\n as is for read-print consistency.\n\n If the file in question is the TSO terminal, ZIL attempts to determine\n how best to send square brackets so that they look like brackets.\n It does this via a terminal output translate table, which is\n initialized based on terminal type (for example, the characters\n hex 41 and hex 42 display as brackets on a 3180, whereas the\n characters hex BA and hex BB display as brackets on a 3179).\n\n Sometimes, however, this is not sufficient, as for a remote terminal\n emulating a 3270.  In these cases the brackets will end up being\n sent as garbage characters.\n\n SETBRACK tells ZIL to use the characters arg1 and arg2 as left and\n right square brackets respectively whenever writing to a file via PRINC\n if tab expansion is active for that file, whether the file is a dataset\n or the terminal.\n\n Argument 1 is the character to be output for left square brackets.\n Argument 2 is the character to be output for right square brackets.\n\n Argument 3, if specified and non-NIL, requests that the change be\n made to the terminal output translate table as well.  This will\n cause the exact characters specified to be sent to the terminal as\n desired.  The default (i.e. arg3 NIL or omitted) is to let ZIL try to\n determine the best way of sending square brackets to the terminal,\n which may be invalid for certain kinds of terminal connections.\n\n For example, to tell ZIL to send square brackets to a VT220 which\n is connected to MVS via a 7171 controller, do:\n\n  (setbrack #XAD #XBD T)  ; print \"real\" brackets, even to terminal\n\n For a 3278 model 4, a 3279, a 3179 or a 3180:\n\n  (setbrack #XAD #XBD NIL); print \"real\" brackets, let ZIL translate\n                          ; to correct terminal code\n\n For this case, if you were to do:\n\n  (setbrack #X41 X42)\n\n for example, terminal printout would be correct, but file printout\n would be incorrect.  This is why the former is preferred.  Use\n (setbrack <weird hex char> <other weird hex char>) only in cases\n when you want square brackets at your terminal but there is no\n other way to get them, and remember that file output will be bad\n if the tab expansion feature is used in the file.\n\n For a 3278 model 2:\n\n  (setbrack #XAD #XBD NIL); send \"real\" brackets.  There's no way\n                          ; to print them on the terminal, so let\n                          ; it display as garbage.\n\n To restore default operation, which sends curly braces:\n\n  (setbrack #XC0 #XD0 NIL)\n   or\n  (setbrack #\\{ #\\} NIL)\n\n NIL may be omitted where specified in all examples above.\n\nErrors signaled:\n\n arg1 not a fixnum between 0 and 255.\n arg2 not a fixnum between 0 and 255.\n\nNotes:\n\n Terminal and file input are completely unaffected by this function,\n as are display of curly braces.  However, whenever ZIL displays\n square brackets correctly to the terminal, the line may be\n overtyped and the brackets will be transmitted properly as input.\n\nExamples:\n\n See in processing description above.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETDEBUG": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x863\\x0f\\x00\\x863\\x0f\\x172\\x00\\x1f\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-11-26T00:00:00", "modifydate": "1986-11-26T17:32:00", "lines": 31, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETDEBUG\n\nSyntax:   (SETDEBUG arg1)\n\n arg1 (required, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n arg1, after setting ZIL debugging mode on or off.\n\nProcessing:\n\n If arg1 is NIL, the flag that controls debugging mode is set off.\n Otherwise, the flag that controls debugging mode is set on.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Currently, debugging mode means that if a ZIL function signals an\n error, a traceback of the push down stack will be printed on the\n standard output file.  No interactive debugging environment exists yet.\n\nExamples:\n\n (SETDEBUG T) enables debugging mode.\n (SETDEBUG NIL) disables debugging mode.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETF": {"ttr": 6665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x865o\\x06U\\x00{\\x00s\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1986-12-22T06:55:00", "lines": 123, "newlines": 115, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETF\n\nSyntax:   (SETF arg1 arg2)\n\n arg1 (required, not evaluated) - a symbol or one of a special\n                                  group of forms (see below).\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n The second argument, after altering the value of the entity\n described by the form of the first argument.\n\nProcessing:\n\n SETF is a macro that expands into code to execute a function that\n alters or updates the value or other entity associated with a\n LISP object.  The following forms are recognized by SETF for the\n first argument:\n\n * A symbol - (SETF foo bar) is equivalent to (SETQ foo bar).\n\n * A form beginning with one of the following functions:\n\n    CAR    - (SETF (CAR a) b)       like (RPLACA a b).\n    CDR    - (SETF (CDR a) b)       like (RPLACD a b).\n    PLIST  - (SETF (PLIST a) b)     like (SETPLIST a b).\n    NTH    - (SETF (NTH a b) c)     like (RPLACA (NTHCDR a b) c)\n    NTHCDR - (SETF (NTHCDR a b) c)  like (RPLACD (NTHCDR (SUB1 a) b) c)\n    VREF   - (SETF (VREF a b) c)    like (VSET a b c)\n    ARG    - (SETF (ARG a) b)       like (SETARG a b)\n    GET    - (SETF (GET a b) c)     like (PUTPROP a c b)\n    ALIST  - (SETF (ALIST) a)       like (SETALIST a)\n\n    (The CA---R and CD---R functions expand similarly to CAR and CDR.)\n\n * A form whose CAR is a symbol with a SETFMETHOD property.\n\n * A macro call that expands to one of the above.\n\n The generated code is \"like\" the above examples, but not always\n exactly equivalent, because:\n\n   (1) SETF always returns the second argument as its value.\n\n   (2) SETF guarantees that the values indicated by a, b, and c are\n       evaluated exactly once and in the order in which they appear\n       on the SETF macro.\n\nErrors signalled:\n\n Invalid syntax (SETF requires exactly two arguments).\n\n Unsupported SETF form (not one of the above) for the first argument.\n\n Invalid syntax for the first form (must match the typical syntax\n of the function); e.g. (SETF (CAR A B) C) is an error.\n\nNotes:\n\n SETF is not sensitive to user-defined macros under the compiler\n unless the macros are defined to the execution-time component of\n the compiler using %.  For example:\n\n  (DEFMACRO MYMACRO (X) `(CAR ,X))\n\n In order to be able to compile the form (SETF (MYMACRO 'FOO) 'BAR)\n you must code in addition to the above:\n\n  (EVAL-WHEN (COMPILE)\n    (DEFMACRO MYMACRO (X) `(CAR ,X))\n  )\n\n Or, you can combine both into one form as follows:\n\n  (EVAL-WHEN (COMPILE LOAD)\n    (DEFMACRO MYMACRO (X) `(CAR ,X))\n  )\n\n so that the SETF macro expander, when invoked by the compiler,\n will recognize MYMACRO as a macro in its own environment; the\n first DEFMACRO enables the compiler to expand direct macro calls\n to MYMACRO only.\n\n In the case of NTHCDR, SETF will generate a SETQ if the first\n argument to NTHCDR is zero.  In many other cases, SETF may\n generate code that is in error, but will not necessarily be\n signalled as an error.  Use SETF with caution.\n\n Since the code generated by SETF usually involves destructive\n or environment-altering functions, all the basic caveats apply.\n SETF should not be used on an in-line compiled list, i.e. a list\n derived from compiling the construct (QUOTE (form1 form2 ...)).\n This may cause further references to the in-line constant list\n to be incorrect.\n\n It is the intention of the ZIL development group to add support\n for new forms to SETF as time goes by.\n\n Alternatively, you may make SETF recognize a form by placing a\n function of 2 arguments on the SETFMETHOD property of a function\n name to be known to SETF; this function will return the macro\n expansion to be evaluated.  The arguments will be the first and\n second arguments on the SETF call itself.\n\nExamples:\n\n (SETF A '(FOO BAR))    ==>   (FOO BAR)\n A                      ==>   (FOO BAR)\n (SETF (CAR A) 'BAZ)    ==>   BAZ\n A                      ==>   (BAZ BAR)\n (SETF (CDR A) 'FROB)   ==>   FROB\n A                      ==>   (BAZ . FROB)\n\n (SETF (PLIST 'ATTR) '(TYPE INPUT CAPS OFF JUST LEFT))\n                              ==>   (TYPE INPUT CAPS OFF JUST LEFT)\n (PLIST 'ATTR)                ==>   (TYPE INPUT CAPS OFF JUST LEFT)\n (GET 'ATTR 'CAPS)            ==>   OFF\n (SETF (GET 'ATTR 'CAPS) 'ON) ==>   ON\n (GET 'ATTR 'CAPS)            ==>   ON\n (PLIST 'ATTR)                ==>   (TYPE INPUT CAPS ON JUST LEFT)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETFEAT": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x13\\x00\\x866?\\x01\\x00$\\x1f\\x165\\x004\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-12-29T00:00:00", "modifydate": "2000-08-28T16:35:13", "lines": 52, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SET-FEATURE\n\nSyntax:   (SET-FEATURE arg1)\n    or:   (SETFEAT arg1)\n\n arg1  (required, evaluated) - a symbol.\n\nReturns:\n\n The current features list, after arg1 has been added to it.\n\nProcessing:\n\n The list of features (which is the value of the global variable\n *FEATURES*) is searched for a value which is EQ to arg1.  If one\n is found, nothing is done; else arg1 is added to the list.\n\n SET-FEATURE is used to make something a \"feature\", which means that\n it may be used in #+arg1 read-conditionalizations.  See FEATUREP\n for more information.\n\n To remove a \"feature\", use SET-NOFEATURE (or SETNFEAT).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n In the normal ZIL environment, the only features present are ZIL and\n ZIL12 (the latter identifies this as ZIL 1.2).  However, under the\n compiler, there is a ZILCO feature as well.  (In fact, as a general\n principle, for a top-level program P there is a feature named P.)\n\nExamples:\n\n (FEATUREP 'ZIL)          ==> T\n (SET-FEATURE 'ZIL)\n          ==> (ZILIN ZIL ZIL13 TSO MVS XA GC BIGNUM\n               MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP)\n\n (FEATUREP 'FOO)          ==> NIL\n (SET-FEATURE 'FOO)\n          ==> (FOO ZILIN ZIL ZIL13 TSO MVS XA GC BIGNUM\n               MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP)\n (FEATUREP 'FOO)          ==> T\n (SET-NOFEATURE 'FOO)\n          ==> (ZILIN ZIL ZIL13 TSO MVS XA GC BIGNUM\n               MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP)\n (FEATUREP 'FOO)          ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETNFEAT": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00$\\x00\\x866?\\x01\\x00$\\x1f\\x165\\x002\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-12-29T00:00:00", "modifydate": "2000-08-28T16:35:24", "lines": 50, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SET-NOFEATURE\n\nSyntax:   (SET-NOFEATURE arg1)\n    or:   (SETNFEAT arg1)\n\n arg1  (required, evaluated) - a symbol.\n\nReturns:\n\n The current features list, after arg1 has been deleted from it.\n\nProcessing:\n\n The list of features (which is the value of the global variable\n *FEATURES*) is searched for a value which is EQ to arg1.  If none\n is found, nothing is done; else arg1 is removed from the list.\n\n SET-NOFEATURE is used to make something not a \"feature\", which means\n that it may be used in #-arg1 read-conditionalizations.  See FEATUREP\n for more information.\n\n To add a \"feature\", use SET-FEATURE (or SETFEAT).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n In the normal ZIL environment, the only features present are ZIL and\n ZIL12 (the latter identifies this as ZIL 1.2).  However, under the\n compiler, there is a ZILCO feature as well.  (In fact, as a general\n principle, for a top-level program P there is a feature named P.)\n\n Obviously, using SET-NOFEATURE to remove a \"feature\" that belongs\n there is EXTREMELY RISKY BUSINESS.\n\nExamples:\n\n (FEATUREP 'FOO)          ==> NIL\n (SET-FEATURE 'FOO)\n          ==> (FOO ZILIN ZIL ZIL13 TSO MVS XA GC BIGNUM\n               MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP)\n (FEATUREP 'FOO)          ==> T\n (SET-NOFEATURE 'FOO)\n          ==> (ZILIN ZIL ZIL13 TSO MVS XA GC BIGNUM\n               MULTIPLE-VALUES DESTRUCTURING FLAVORS LOOP)\n (FEATUREP 'FOO)          ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETPBIND": {"ttr": 6671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x087\\x00\"\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T08:37:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETPBIND\n\nSyntax:   (SETPBIND arg1 arg2)\n\n arg1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n arg2, after arg2 replaces the contents of the value/binding cell of\n arg1.\n\nProcessing:\n\n arg2 destructively replaces the contents of the value/binding cell\n of arg1.  See PBIND for what this contains.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n This function is intended for internal use only, and is intimately\n tied up with ZIL's binding techniques.  Do not depend on it!\n\nExamples:\n\n ; No examples.  We don't want you fooling around with this.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETPLIST": {"ttr": 6673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x86\\x03\\x0f\\x17G\\x00D\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1986-01-30T17:47:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETPLIST\n\nSyntax:   (SETPLIST arg1 arg2)\n\n arg1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - a property list.\n\nReturns:\n\n arg1, with its property list set to arg2.\n\nProcessing:\n\n arg2 destructively replaces the PLIST pointer of arg1; i.e. arg2\n becomes the property list of arg1.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No error checking is done at this time in compiled code.\n Issuing SETPLIST on a non-atomic first argument is illegal and highly\n dangerous to the ZIL environment.\n\n SETPLIST is NOT a substitute for PUTPROP, and should be avoided.\n\n A property list has the following format:\n\n  (indicator1 value1 indicator2 value2 ...)\n\n where (GET atom indicator1) returns \"value1\", etc.\n\n No checking is done to see if the second argument is a valid property\n list (or even a valid list).  Issuing SETPLIST with an improper\n second argument will cause the GET, PUTPROP, and REMPROP functions\n to fail disastrously, as well as other functions (including EVAL)\n that reference the property list of the atom.\n\n Because a property list is manipulated destructively, SETPLIST\n should not be used with a second argument of an in-line compiled\n list, i.e.  a list derived from compiling the construct\n (QUOTE (form1 form2 ...)).  This will cause further references to the\n in-line constant list to be incorrect.\n\nExamples:\n\n (SETPLIST 'A '(FOO BAR BAZ (FROB NICK ATE)))\n                           ==> A\n\n (PLIST 'A)                ==> (FOO BAR BAZ (FROB NICK ATE))\n (GET 'A 'FOO)             ==> BAR\n (GET 'A 'BAZ)             ==> (FROB NICK ATE)\n\n (SETPLIST 'A '(FOO BAR))  ==> A\n\n (PLIST 'A)                ==> (FOO BAR)\n (GET 'A 'FOO)             ==> BAR\n (GET 'A 'BAZ)             ==> NIL\n\n (SETPLIST 'A NIL)         ==> A\n\n (PLIST 'A)                ==> NIL\n (GET 'A 'FOO)             ==> NIL\n (GET 'A 'BAZ)             ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETPRT": {"ttr": 6675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x18\\x9f\\x00\\x87\\x18\\x9f\\x08C\\x00*\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1987-07-08T08:43:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETPRT\n\nSyntax:   (SETPRT arg1)\n\n arg1 (required, evaluated) - a LISP object that can be invoked as a\n                              function of 3 arguments.\n\nReturns:\n\n A SUBR that implements the activation of the function specified by arg1\n as the \"current ZIL printer\".\n\nProcessing:\n\n The function specified by arg1 is made the \"current ZIL printer\" by\n having the address of a compiled SUBR wrapper inserted by ZILSPRT in\n the field which is used by ZCPRINT to access the current ZIL printer.\n This causes the function arg1 to be invoked as the \"current ZIL\n printer\".\n\n See $PRINTER for information about how to specify the function to\n be used as the \"current ZIL printer\", and how it is used.\n\nErrors signaled:\n\n None (but beware of errors in your printer function!!!!!!!).\n\nNotes:\n\n This is the general interface to setting the \"current ZIL printer\".\n Performance-conscious applications should use ZILSPRT and create a\n compiled code SUBR to be the \"current ZIL printer\".\n\nExamples:\n\n;   (SETPRT #'(LAMBDA (A B C) (ZMSPRINT A B C)))\n;\n; makes the Maclisp-compatible Macsyma print functions active\n; (i.e. the ones that are sensitive to the special variables\n; \u00acR and \u00acW).  However, ZILSPRT is the recommended way to do this.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETQ": {"ttr": 6677, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x86$o\\x082\\x00x\\x00c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1986-09-03T08:32:00", "lines": 120, "newlines": 99, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETQ\n\nSyntax:   (SETQ &rest args)\n\n args occur in pairs: arg1 and arg2.\n\n arg1 (required, not evaluated) - a symbol.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n The last argument, after the variable specified by the first argument\n of each pair has been bound to the value specified by the second\n argument of the pair.\n\nProcessing:\n\n For each consecutive pair of arguments, the current binding of the\n variable specified by the first argument is altered to refer to the\n (evaluated) second argument; in other words, the \"value\" of arg1 is set\n to arg2.\n\n This is NOT a new binding; the previous binding is not saved but\n is overlaid.\n\n In the interpretive environment, or in a compiled MODULE, if the\n variable is not currently bound, a warning message is issued and a\n DEFVAR is issued to create a globally bound variable and set its value.\n The same situation would cause a run-time error in a compiled code\n FUNCTION or PROGRAM.\n\n The symbol may not be NIL or T.\n\n The bindings occur sequentially, meaning that each variable is\n bound to its value before the next value is determined.\n Compare PSETQ, where all the values are extracted before any\n assignments are done.\n\nErrors signaled:\n\n Invalid syntax (an even number of arguments required).\n Invalid first argument.\n\nNotes:\n\n Although SETQ may be used on lambda-list variables, this use is not\n common; SETQ is primarily useful in PROG's to act in the way that\n normal variables do in conventional programming languages.\n\n SETQ is supposed to be used only on variables bound locally somewhere;\n however, under the interpreter or in a MODULE it will do an automatic\n DEFVAR of the variable if it is not currently bound.\n\n The extent of a local SETQ assignment is limited to the extent of the\n binding itself; when the binding disappears, the SETQ assignment\n also disappears.  If a previous binding of the variable was\n \"shadowed\" by the other, the previous binding is \"uncovered\" in\n the same way as if the SETQ had never been issued.\n\n Global SETQ or DEFVAR assignments are like permanent bindings;\n they may be shadowed by local bindings, but they remain until undone\n via MAKUNBOUND (not recommended!).\n\n In the interpretive environment, the \"alist\", or association list,\n which is used to implement bindings for local variables and to\n effect \"dynamic scoping\", is a list of dotted pairs of which the\n CAR of a pair is a symbol and the CDR is its value.  Variable\n bindings on entry to a function or PROG are effected by pushing\n new CONS'es onto the alist; the previous alist pointer becomes\n effective again upon exit from the function or PROG.\n\n The compiled environment mechanism is different with local variables,\n but basically the same with respect to \"free\" variables, so that the\n semantics of variable access are the same in the interpretive and\n compiled environments.\n\nExamples:\n\n (DEFUN F (A B C D)\n     (SETQ A '(HI THERE))        ; ==> (HI THERE)\n     (SETQ B (CAR A))            ; ==> HI\n     (SETQ C (CDR A))            ; ==> (THERE)\n     (SETQ D\n      (PROG (A B C)\n            (SETQ A 1\n                  B (ADD1 A)\n                  C (+ A B))     ; ==> 3\n            (RETURN (LIST A B C))\n      ))                         ; ==> (1 2 3)\n     (SETQ C A)                  ; ==> (HI THERE)\n     (LIST A B C D)              ; ==> ((HI THERE) HI (HI THERE))\n)           ==> F\n\n(F 1 2 3 4) ==> ((HI THERE) HI (HI THERE) (1 2 3))\n\n;Note that if function G calls F with arguments X Y Z, the values of\n;X, Y and Z remain unchanged.\n\n (DEFUN G ()\n  (PROG (X Y Z)\n   (SETQ X 'XX)\n   (SETQ Y 'YY)\n   (SETQ Z 'ZZ)\n   (F X Y Z \"junk\")\n   (RETURN (LIST X Y Z))))        ==> G\n\n  (G)                             ==> (XX YY ZZ)\n\n; The following illustrates how the SETQ bindings are sequential,\n; as opposed to the parallel bindings of PSETQ.\n\n (LET ((A 1) (B 2) (C 3))\n      (SETQ A 0 B A C B)\n      (LIST A B C))        ==>  (0 0 0)\n\n (LET ((A 1) (B 2) (C 3))\n      (PSETQ A 0 B A C B)\n      (LIST A B C))        ==>  (0 1 2)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETREAD": {"ttr": 6679, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\t\\x11\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T09:11:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETREAD\n\nSyntax:   (SETREAD arg1)\n\n arg1 (required, evaluated) - a LISP object that can be invoked as a\n                              function of 6 arguments.\n\nReturns:\n\n A SUBR that implements the activation of the function specified by arg1\n as the \"current ZIL reader\".\n\nProcessing:\n\n The function specified by arg1 is made the \"current ZIL reader\" by\n having the address of a compiled SUBR wrapper inserted by ZILSRD in the\n field which is used by ZCREAD to access the current ZIL reader.  This\n causes the function arg1 to be invoked as the \"current ZIL reader\".\n\n See $READER for information about how to specify the function to\n be used as the \"current ZIL reader\", and how it is used.\n\nErrors signaled:\n\n None (but beware of errors in your reader function!!!!!!!).\n\nNotes:\n\n This is the general interface to setting the \"current ZIL reader\".\n Performance-conscious applications should use ZILSRD and create a\n compiled code SUBR to be the \"current ZIL reader\".\n\nExamples:\n\n;   (SETREAD #'(LAMBDA (A B C D E F) (MYREAD A B C D E F)))\n;\n; makes a fictional bunch of read functions active.\n; However, ZILSRD is the recommended way to do this in this case.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETSALST": {"ttr": 6681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%O\\x00\\x87%O\\x08\\x08\\x00/\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-11T00:00:00", "modifydate": "1987-09-11T08:08:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETSALST\n\nSyntax:   (SETSALST arg1)\n\n arg1 (required, evaluated) - an association list\n                              (a list of dotted pairs).\n\nReturns:\n\n arg1, with the current SPECIAL variable binding environment set to it.\n\nProcessing:\n\n The current SPECIAL variable binding environment is replaced with arg1.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n SETSALST is used internally by ZIL in certain places and should be\n avoided by all other users.  Issuing SETSALST is extremely dangerous\n unless you really know what you are doing.\n\n (SETF (SPECIAL-ALIST) arg1) is the preferred way to express this,\n if you really want to do it.\n\n This function may or may not have the effect you want, depending\n on where you execute it from.  In any case, you definitely should\n not be using it if you're not a ZIL implementer.\n\nExamples:\n\n (MAKUNBOUND 'A)           ==> A\n (BOUNDP 'A)               ==> NIL\n (SETSALST '((A . 1) (B . 2)))\n                           ==> ((A . 1) (B . 2))\n\n (SPECIAL-ALIST)           ==> ((A . 1) (B . 2))\n (BOUNDP 'A)               ==> T\n A                         ==> 1\n (SETQ A 3)                ==> 3\n A                         ==> 3\n (SPECIAL-ALIST)           ==> ((A . 3) (B . 2))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETSYNTA": {"ttr": 6683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x084\\x00Y\\x00Y\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:34:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SETSYNTAX\n\nSyntax:   (SETSYNTAX arg1 arg2 arg3)\n\n arg1 (required, evaluated) - a one-character symbol, string or fixnum.\n arg2 (required, evaluated) - MACRO or SINGLE.\n arg3 (required, evaluated) - a function or NIL.\n\nReturns:\n\n NIL, after assigning the character specified by arg1 the reader macro\n property specified by arg2 and arg3.\n\nProcessing:\n\n If arg2 is MACRO:\n\n   If arg3 is NIL, the reader macro definition for the character\n   specified by arg1 is removed from the read table.\n\n   Otherwise, the character specified by arg2 is associated with the\n   reader macro function specified by arg3.  This is done via the\n   DEFRDMAC function (q.v.).\n\n If arg2 is SINGLE:\n\n   arg3 must be NIL in this case.  The character specified by arg2 is\n   made to act like a reader macro character that returns itself, so\n   that when the READ function is reading characters to build a\n   symbol, it does not include that character, but returns that\n   character as a one-character symbol name.  Naturally, this does\n   not apply when the character occurs in a string or is delimited\n   by backslash or vertical bars.\n\n The following are equivalent (whether specifying SINGLE or MACRO):\n\n  (SETSYNTAX '|?|  'SINGLE NIL)\n  (SETSYNTAX  \"?\"  'SINGLE NIL)\n  (SETSYNTAX  #\\?  'SINGLE NIL)\n\nErrors signaled:\n\n Errors signalled by DEFRDMAC or RDRMACRO (q.v.).\n\nNotes:\n\n This is a Maclisp and Franz LISP function; in those dialects,\n SETSYNTAX has other uses, but in ZIL these are the only ones\n available.  SETSYNTAX is an interface to DEFRDMAC and RDRMACRO\n which is provided for compatibility.\n\n See documentation on READ, DEFRDMAC and RMCHAR for more information\n on reader macro processing.\n\n\nExamples:\n\n Assume a reader macro defined thus:\n\n   (SETSYNTAX '|?| 'MACRO #'(LAMBDA (F) (CONS 'Q (READ F))))\n\n Then, when the following is read in:\n\n   ?FOO\n\n the following will be returned by READ:\n\n   (Q FOO)\n\n (Note that under the interpreter, this will be evaluated by EVAL\n before the user sees the result.)\n\n If you say:\n\n   (SETSYNTAX #\\! 'SINGLE 'NIL)\n\n Then, when the following is read in:\n\n   !FOO\n\n READ will return the symbol !, and then the symbol FOO.\n\n (Again, these are subject to evaluation under the interpreter\n before the user sees the result.)\n\n (SETSYNTAX \"?\"  'MACRO NIL) will turn off processing of the ? macro.\n (SETSYNTAX '|!| 'MACRO NIL) will turn off processing of the ! macro.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SEVENTH": {"ttr": 6685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x176\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:36:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: SEVENTH\n\nSyntax:   (SEVENTH list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The seventh element of list1, or NIL if list1 has less than 7 elements.\n\nProcessing:\n\n (SEVENTH x) is the same as (CADDR (CADDDR X)).\n\nErrors signaled:\n\n See CAR, CDR, etc.\n\nNotes:\n\n See CAR, CDR, etc.\n\nExamples:\n\n (SEVENTH NIL)                 ==> NIL\n (SEVENTH '(A))                ==> NIL\n (SEVENTH '(A B C D E F G))    ==> G\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SFLOATP": {"ttr": 6687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x075\\x00!\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T07:35:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SFLOATP\n\nSyntax:   (SFLOATP arg1)\n    or:   (SINGLE-FLOAT-P arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a single-float, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare DFLOATP, which returns T if its argument is a double-float;\n and FLOATP, which returns T for any kind of flonum.\n\nExamples:\n\n (SFLOATP 1.0)   ==> NIL\n (SFLOATP 1)     ==> NIL\n (SFLOATP 1E1)   ==> NIL\n (SFLOATP 1.0D0) ==> NIL\n (SFLOATP 1.0F0) ==> T\n (SFLOATP '(1))  ==> NIL\n (SFLOATP 'ONE)  ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SIGNP": {"ttr": 6689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x17@\\x00%\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:40:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: SIGNP\n\nSyntax:   (SIGNP arg1 arg2)\n\n arg1 (required, not evaluated) - L, LE, E, N, GE, or G.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg2 is numeric and satisfies the test specified by arg1,\n else NIL.\n\nProcessing:\n\n If arg2 is numeric AND the following test holds, T is returned:\n\n Value of arg1        Test\n -------------        ----\n  L                    arg2 <  0\n  LE                   arg2 <= 0\n  E                    arg2 =  0\n  N                    arg2 /= 0\n  GE                   arg2 >= 0\n  G                    arg2 >  0\n\n Remember that arg1 is NOT evaluated, but arg2 IS.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This is a Maclisp facility that even Maclisp programmers don't use.\n It is required by Macsyma.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SIN": {"ttr": 6691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x7f\\x00\\x87%O\\x08\\x10\\x00+\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-26T00:00:00", "modifydate": "1987-09-11T08:10:00", "lines": 43, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SIN\n\nSyntax:   (SIN num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n A number which is the sine of num1, where num1 is expressed in\n radians.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the\n value from num1.  If num1 is a single-precision flonum, the\n result is a single-precision flonum; otherwise the result is\n a double-precision flonum.\n\nErrors signaled:\n\n Non-numeric argument.\n For single precision, abs(arg) greater than 823549.5625.\n For double precision, abs(arg) greater than 3537118876014220.125.\n These values are the maximum that the FORTRAN subroutine library\n will successfully process.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\n Bignums are not supported as arguments to this function.\n\nExamples:\n\n(SIN 0) ==> 0.0\n(SIN 1) ==> 0.84147098\n(SIN -1) ==> -0.84147098\n(SIN 0.5) ==> 0.4794255\n(SIN 0.5F0) ==> 0.4794255F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SIXTH": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x176\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:36:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: SIXTH\n\nSyntax:   (SIXTH list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The sixth element of list1, or NIL if list1 has less than 6 elements.\n\nProcessing:\n\n (SIXTH x) is the same as (CADR (CADDDR X)).\n\nErrors signaled:\n\n See CAR, CDR, etc.\n\nNotes:\n\n See CAR, CDR, etc.\n\nExamples:\n\n (SIXTH NIL)                 ==> NIL\n (SIXTH '(A))                ==> NIL\n (SIXTH '(A B C D E F))      ==> F\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLEEP": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\"O\\x00\\x87%O\\x08\\x11\\x00\\x16\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-08-12T00:00:00", "modifydate": "1987-09-11T08:11:00", "lines": 22, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SLEEP\n\nSyntax:   (SLEEP arg1)\n\n arg1 (required, evaluated) - a positive fixnum.\n\nReturns:\n\n NIL, after placing the ZIL system in a wait state for arg1 seconds.\n\nProcessing:\n\n A STIMER macro instruction is issued to cause ZIL to wait for the\n specified number of seconds before processing resumes.\n\nErrors signaled:\n\n arg1 not a positive fixnum.\n\nNotes:\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLENGTH": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08\\x11\\x00\"\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:11:00", "lines": 34, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-LENGTH\n\nSyntax:   (STRING-LENGTH arg1)\n    or:   (SLENGTH arg1)\n\n arg1 (required, evaluated) - a string.\n\nReturns:\n\n An integer containing the number of characters in the string specified\n by arg1; i.e. the length of the string.\n\nProcessing:\n\n The length of the string is returned as an integer.\n\n As for most string-handling functions, a symbol is accepted for the\n string argument; in this case the length of the print name of the\n symbol is returned.\n\nErrors signaled:\n\n Argument not a string.\n\nNotes:\n\nExamples:\n\n (STRING-LENGTH \"\")    ==>  0\n (STRING-LENGTH \"foo\") ==>  3\n (STRING-LENGTH \"\\\"\")  ==>  1\n (STRING-LENGTH NIL)   ==>  3\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLTRIM": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x12\\x0f\\x00\\x880o\\x12R\\x00,\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-30T00:00:00", "modifydate": "1988-11-01T12:52:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-LEFT-TRIM\n\nSyntax:   (STRING-LEFT-TRIM bag1 str2)\n    or:   (SLTRIM bag1 str2)\n\n bag1 (required, evaluated) - a string.\n str2 (required, evaluated) - a string.\n\nReturns:\n\n A string built by removing all characters present in bag1 from the\n  beginning of str2; in other words, leading characters are removed.\n\nProcessing:\n\n bag1 is treated as a \"character bag\", and str2 is scanned from the\n beginning for characters which are part of that bag.  The result\n is a substring of str2 from the first character which is not part\n of that bag.\n\nErrors signaled:\n\n bag1 not a string.\n arg2 not a string.\n\nNotes:\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.  However, this\n function always returns a string.\n\n Unlike Common LISP, ZIL does not permit a list to be specified\n for bag1.  Since symbols are permitted, NIL is interpreted as a\n \"character bag\" of the characters N, I and L.\n\nExamples:\n\n (STRING-LEFT-TRIM \"of\" \"foobar\")  ==> \"bar\"\n (STRING-LEFT-TRIM \"\"   \"foobar\")  ==> \"foobar\"\n (STRING-LEFT-TRIM \"xy\" \"foobar\")  ==> \"foobar\"\n (STRING-LEFT-TRIM \"fb\" \"foobar\")  ==> \"oobar\"\n (STRING-LEFT-TRIM 'FO  'FOOBAR )  ==> \"BAR\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SOME": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x12\\x7f\\x00\\x87%O\\x08\\x12\\x00/\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-05-07T00:00:00", "modifydate": "1987-09-11T08:12:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SOME\n\nSyntax:   (SOME arg1 arg2 ... argn)\n\n arg1 (required, evaluated) - a function that can be APPLY'ed.\n arg2 (optional, evaluated) - a proper list.\n argn (optional, evaluated) - a proper list.\n\nReturns:\n\n NIL if all of the values produced by applying the first argument\n function to successive elements (CAR's) of the other argument lists\n are NIL, else the first non-NIL value thus generated.\n\nProcessing:\n\n The function specified by the first argument is applied to each of the\n elements (CAR's) of the lists specified by the other arguments, until\n one of the lists is exhausted or a non-NIL value is produced by this\n application.  When the latter occurs, SOME returns that value.\n\n If no lists are specified, SOME returns NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare EVERY, NOTANY, NOTEVERY, and the mapping functions.\n\nExamples:\n\n (SOME #'INTEGERP NIL)             ==> NIL\n (SOME #'INTEGERP '(A B C D E))    ==> NIL\n (SOME #'INTEGERP '(1 2 3 4 5))    ==> T\n (SOME #'INTEGERP '(A 2 3 4 5))    ==> T\n (SOME #'INTEGERP '(1 2 3 4 E))    ==> T\n (SOME #'INTEGERP '(A B 3 D E))    ==> T\n (SOME #'EQ '(A B C) '(A B C D))   ==> T\n (SOME #'EQ '(X B C) '(A B C D))   ==> T\n (SOME #'EQ '(X Y Z) '(A B C D))   ==> NIL\n (SOME #'EQ '(A B Z) '(A B C D))   ==> T\n\n (SOME #'(LAMBDA (X) (IF X 'FOO NIL)) '(NIL A NIL B NIL))  ==> FOO\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SORT": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%O\\x08\\x16\\x00:\\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-11T08:16:00", "lines": 58, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SORT\n\nSyntax:   (SORT list1 &optional fun2)\n\n list1 (required, evaluated) - a proper list.\n fun2  (optional, evaluated) - a function that can be APPLY'ed.\n\nReturns:\n\n A new list containing the elements of list1 in order according to the\n two-argument predicate specified by fun2.\n\nProcessing:\n\n A new list is built, using the predicate function specified by fun2.\n This must be a function that takes 2 arguments and returns NIL or\n something other than NIL to tell whether one argument is \"less\"\n than the other in the desired sequence.\n\n If fun2 is omitted or NIL, the comparison function defaults to LESSP.\n\n Note that ZIL's SORT does NOT alter the list in place; it always\n creates a new list.\n\nErrors signaled:\n\n arg1 not a list (but see Notes).\n None, except for those signalled by fun2 or FUNCALLing of fun2.\n\nNotes:\n\n Note that it is more efficient to use LESSP than <, and to use\n GREATERP than >, since < and > are defined to take any\n number of arguments, but LESSP and GREATERP are functional binary\n operators.  If you use LESSP, however, it is much more efficient\n to omit the second argument, since this allows SORT to call LESSP\n directly rather than using FUNCALL.\n\n The optionality of the second argument is a feature unique to ZIL,\n which can get away with this because in ZIL, LESSP works on\n character strings as well as numbers (but it doesn't work unless\n all the elements of the list are either strings or numbers!).\n\n This may not be a terribly fast implementation of SORT, but it gets the\n job done.  No error checking is done on the list argument beyond\n verifying that it is not an atom.  In other words, specify a list\n containing a dotted pair will have unpredictable results.\n\nExamples:\n\n (SORT '(1 4 2 8 5 7))              ==> (1 2 4 5 7 8)\n (SORT '(F O O B A R))              ==> (A B F O O R)\n (SORT '(1 4 2 8 5 7) #'GREATERP)   ==> (8 7 5 4 2 1)\n (SORT '(\"the\" \"quick\" \"yellow\" \"wolf\")\n       #'(LAMBDA (X Y) (< (STRING-LENGTH X) (STRING-LENGTH Y))))\n                              ==> (\"the\" \"wolf\" \"quick\" \"yellow\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SORTCAR": {"ttr": 6925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x10\\x7f\\x00\\x87%O\\x08#\\x00-\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-17T00:00:00", "modifydate": "1987-09-11T08:23:00", "lines": 45, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SORTCAR\n\nSyntax:   (SORTCAR list1 &optional fun2)\n\n list1 (required, evaluated) - a proper list.\n fun2  (optional, evaluated) - a function that can be APPLY'ed.\n\nReturns:\n\n A new list containing the elements of list1 in order, such that the\n CAR's of the list satisfy the two-argument predicate specified by fun2.\n\nProcessing:\n\n A new list is built, using the predicate function specified by fun2.\n This must be a function that takes 2 arguments and returns NIL or\n something other than NIL to tell whether the CAR of one argument is\n \"less\" than the CAR of the other in the desired sequence.\n\n If fun2 is omitted or NIL, the comparison function defaults to LESSP.\n\n Note that ZIL's SORTCAR does NOT alter the list in place; it always\n creates a new list.\n\nErrors signaled:\n\n See SORT for errors.\n\nNotes:\n\n See SORT for more information.\n\n Even though omitting the optional argument is more efficient that\n explicitly specifying LESSP, SORTCAR is less efficient than SORT\n (at least in the current implementation) because it invokes SORT\n using its own internal functional argument.  However, omitting\n the optional argument to SORTCAR insures that you won't have to\n do TWO FUNCALL's on each comparison.\n\nExamples:\n\n (SORTCAR '((Q 1) (W 2) (E 3) (R 4))) ==> ((E 3) (Q 1) (R 4) (W 2))\n (SORTCAR '((F) (O) (O)) #'GREATERP) ==> ((O) (O) (F))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SQRT": {"ttr": 6927, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x17O\\x00\\x87%O\\x08&\\x00*\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-06-23T00:00:00", "modifydate": "1987-09-11T08:26:00", "lines": 42, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SQRT\n\nSyntax:   (SQRT num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n A number which is the square root of num1.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the\n value from num1.  If num1 is a single-precision flonum, the\n result is a single-precision flonum; otherwise the result is\n a double-precision flonum.\n\nErrors signaled:\n\n Argument is negative or not a number.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\n Bignums are not supported as arguments to this function.\n\n\nExamples:\n\n(SQRT 9)     ==> 3.0\n(SQRT 9.0F0) ==> 3.0F0\n(SQRT 9.0)   ==> 3.0\n(SQRT 1.5)   ==> 1.22474487\n(SQRT 1.5F0) ==> 1.2247448F0\n(SQRT 2)     ==> 1.41421356\n(SQRT 2.0)   ==> 1.41421356\n(SQRT 2.0F0) ==> 1.4142132F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SREMOVE": {"ttr": 6929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x13o\\x00\\x87%O\\x08(\\x002\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-05-16T00:00:00", "modifydate": "1987-09-11T08:28:00", "lines": 50, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-REMOVE\n\nSyntax:   (STRING-REMOVE bag1 str2)\n    or:   (SREMOVE bag1 str2)\n\n bag1 (required, evaluated) - a string.\n str1 (required, evaluated) - a string.\n\nReturns:\n\n A string built by removing all characters present in bag1 from str2.\n\nProcessing:\n\n bag1 is treated as a \"character bag\", and str2 is scanned for\n characters which are part of that bag.  The result is a new string\n which contains only the characters in str2 which are not part of that\n bag.\n\nErrors signaled:\n\n bag1 not a string.\n arg2 not a string.\n\nNotes:\n\n STRING-REMOVE is different from STRING-TRIM, etc., in that it removes\n ALL occurrences of characters, not just those at either end.\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.  However, this\n function always returns a string.\n\n Unlike Common LISP, ZIL does not permit a list to be specified for\n bag1.  (Not that this matters for STRING-REMOVE, which isn't even a\n Common LISP function anyhow.)  Since symbols are permitted, NIL is\n interpreted as a \"character bag\" of the characters N, I and L.\n\nExamples:\n\n (STRING-REMOVE \"ar\" \"foobar\")     ==> \"foob\"\n (STRING-REMOVE \"\" \"foobar\")       ==> \"foobar\"\n (STRING-REMOVE \"xy\" \"foobar\")     ==> \"foobar\"\n (STRING-REMOVE \"fr\" \"foobar\")     ==> \"ooba\"\n (STRING-REMOVE \"fobra\" \"foobar\")  ==> \"\"\n (STRING-REMOVE 'FAR 'FOOBAR )     ==> \"OOB\"\n (STRING-REMOVE \" \" \" a b c \")     ==> \"abc\"\n (STRING-REMOVE \"farbo\" \"foobar\")  ==> \"\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SREVERSE": {"ttr": 6931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x12\\x0f\\x00\\x87%O\\x08(\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-04-30T00:00:00", "modifydate": "1987-09-11T08:28:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-REVERSE\n\nSyntax:   (STRING-REVERSE arg1)\n    or:   (SREVERSE arg1)\n\n arg1 (required, evaluated) - a string.\n\nReturns:\n\n A string made up of all the characters in arg1 in reverse order.\n\nProcessing:\n\nErrors signaled:\n\n arg1 not a string.\n\nNotes:\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.  However, this\n function always returns a string.\n\nExamples:\n\n (STRING-REVERSE \"\")               ==> \"\"\n (STRING-REVERSE \"A\")              ==> \"A\"\n (STRING-REVERSE \"foo\")            ==> \"oof\"\n (STRING-REVERSE 'FOOBAR)          ==> \"RABOOF\" ; note - a string!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SRTRIM": {"ttr": 6933, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x12\\x0f\\x00\\x880o\\x12R\\x00+\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-30T00:00:00", "modifydate": "1988-11-01T12:52:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-RIGHT-TRIM\n\nSyntax:   (STRING-RIGHT-TRIM bag1 str2)\n    or:   (SRTRIM bag1 str2)\n\n bag1 (required, evaluated) - a string.\n str2 (required, evaluated) - a string.\n\nReturns:\n\n A string built by removing all characters present in bag1 from the\n  end of str2; in other words, trailing characters are removed.\n\nProcessing:\n\n bag1 is treated as a \"character bag\", and str2 is scanned from the end\n for characters which are part of that bag.  The result is a substring\n of str2 up to the last character which is not part of that bag.\n\nErrors signaled:\n\n bag1 not a string.\n arg2 not a string.\n\nNotes:\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.  However, this\n function always returns a string.\n\n Unlike Common LISP, ZIL does not permit a list to be specified\n for bag1.  Since symbols are permitted, NIL is interpreted as a\n \"character bag\" of the characters N, I and L.\n\nExamples:\n\n (STRING-RIGHT-TRIM \"ar\" \"foobar\") ==> \"foob\"\n (STRING-RIGHT-TRIM \"\"  \"foobar\")  ==> \"foobar\"\n (STRING-RIGHT-TRIM \"xy\" \"foobar\") ==> \"foobar\"\n (STRING-RIGHT-TRIM \"fr\" \"foobar\") ==> \"fooba\"\n (STRING-RIGHT-TRIM 'RA  'FOOBAR ) ==> \"FOOB\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SSCAN": {"ttr": 6935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08O\\x00\\x88\\x08O\\x08E\\x00\\xb1\\x00\\xb1\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-24T00:00:00", "modifydate": "1988-03-24T08:45:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-SCAN\n\nSyntax:   (STRING-SCAN str1 &optional bag2 bag3 str4 str5 str6 list7)\n    or:   (SSCAN       str1 &optional bag2 bag3 str4 str5 str6 list7)\n\n str1  (required, evaluated) - a string.\n bag2  (optional, evaluated) - a string.           Default: \" \" (blank)\n bag3  (optional, evaluated) - a string.           Default: \"\"  (null)\n str4  (optional, evaluated) - a string.           Default: \"\"  (null)\n str5  (optional, evaluated) - a string.           Default: \"\"  (null)\n str6  (optional, evaluated) - a string.           Default: \"\"  (null)\n list7 (optional, evaluated) - a list of strings.  Default: NIL\n\nReturns:\n\n  A list of strings, all of which are \"words\" or \"tokens\" in str1.\n\nProcessing:\n\n  str1 is lexically scanned and broken up into \"words\" or \"tokens\"\n  according to the specifications of the optional arguments as follows:\n\n  bag2:  the whitespace specifier, which is a \"bag\" of string characters\n         which act as whitespace (in other words, the occurrence of any\n         of the characters in the \"whitespace bag\" marks the end of a\n         word).\n\n         For example, \" ,\" would specify that blanks and commas act\n         as whitespace characters.\n\n         The default is \" \", a bag containing the blank as the only\n         whitespace character.\n\n         None of the whitespace characters appear anywhere in the\n         list returned by this function.\n\n  bag3:  the singleton specifier, which is a \"bag\" of string characters\n         to act as self-defined single characters.  Each character in\n         str1 that is found in this \"bag\" gets\n         returned as a one-character string in the resulting list.\n\n         For example, \"+-*/\" would specify that the standard arithmetic\n         operators should be tokenized as single-character strings.\n\n         The default is \"\", a bag with no characters.\n\n  str4:  either a null string, a one-character string, or a\n         two-character string, which defines a \"quote\" character.  The\n         first character of the string defines the character to be used\n         to quote strings, and the second character determines the\n         convention for embedding the quote character in the string.  If\n         a one-character string is specified, or the second character is\n         the same as the first, the quote character is specified by\n         doubling it (e.g. 'don''t').  If the second character is a\n         different character from the first, it is a \"single escape\"\n         character, and any character following it is contained in the\n         quoted string (e.g. \"don\\\"t\").\n\n         The string is constructed including the enclosing quotes and\n         doubled embedded quotes or escape characters.  In this way the\n         caller can distinguish between quoted and unquoted strings,\n         but is responsible for unquoting the string him/herself.\n\n         An error is signalled if the ending quote of a string is not\n         found, or if the escape character is not followed by something.\n\n         If a null string is specified, no quote character is used.\n         Only one quote character can be specified.\n\n         For example, \"'\" or \"''\" specifies standard TSO or FORTRAN\n         quoting conventions.  \"\\\"\\\\\" (which is a 2-character string\n         containing a \" character and a \\ character) specifies the\n         Common LISP string quoting convention.\n\n         The default is \"\", the null string, meaning no quoting.\n\n  str5:  a beginning-comment string (not a \"bag\") which signals the\n         beginning of a comment.  Comments are terminated by\n         end-of-string or the ending-comment string specified in\n         argument 6 if it is specified.  Only one set of comment\n         strings can be specified.\n\n         For example, if str5 is \";\" and str6 is \"\", this represents\n         the Common LISP commenting convention.\n\n         The default is \"\", the null string, meaning no commenting.\n\n  str6:  an ending-comment string (not a \"bag\") which signals the\n         end of a comment.\n\n         For example, if str5 is \"/*\" and str6 is \"*/\", this represents\n         standard TSO or PL/1 commenting conventions.\n\n         The default is \"\", the null string, meaning that if str5 is\n         specified, comments can be terminated only by end of string.\n\n  list7: a list of multiple-character tokens (strings of length 2 or\n         more).  Each of these, if encountered in the string being\n         scanned, ends up as a token in the result, regardless of\n         the functionality of the individual characters in the\n         multiple-character token otherwise (an exception is if the\n         beginning comment string occurs completely or partially in\n         the string where the multiple-character token seems to\n         appear, in which case the commenting takes precedence).\n         Any null strings in the list7 list are ignored.\n\n         For example, if list7 is (\"**\" \"<=\" \">=\" \"\u00ac=\" \"->\"), this\n         causes some standard operators in PL/1 to be recognized\n         as tokens.\n\n         The default is NIL, the null list, meaning that no\n         multiple-character tokens are recognized.\n\n  Thus, if STRING-SCAN is specified with the required string\n  argument only, it will be broken up into words separated by\n  occurrences of one or more consecutive blanks (the blanks do\n  not appear in the output list).  No quoting or commenting\n  conventions or special tokens are recognized.\n\n  If str1 is null or contains only whitespace characters or comment\n  sequences, then NIL, the null list, is returned.\n\nErrors signaled:\n\n Some argument not a string, or argument 7 not a proper list of strings.\n Argument 5 or 6 longer than 256 characters, or an element of argument 7\n longer than 256 characters.\n Missing quote character while scanning str1.\n Dangling escape character while scanning str1.\n\nNotes:\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.  This is true of\n arguments 1 through 6, as well as individual elements of argument 7.\n However, this function always returns a list of strings.\n\n Unlike Common LISP, ZIL does not permit a list to be specified\n for \"bags\".  Since symbols are permitted, NIL is interpreted as a\n \"character bag\" of the characters N, I and L.  Note, however, that\n argument 7, being a list, may be specified as NIL, meaning no\n multiple-character tokens.\n\nExamples:\n\n (STRING-SCAN \"foo bar\")            ==> (\"foo\" \"bar\")\n (SSCAN \"a+b*c\")                    ==> (\"a+b*c\")\n (SSCAN \"a+b*c\" \" \" \"+*\")           ==> (\"a\" \"+\" \"b\" \"*\" \"c\")\n (SSCAN \"'foo bar'\")                ==> (\"'foo\" \"bar'\")\n (SSCAN \"'foo bar'\" \" \" \"\" \"'\")     ==> (\"'foo bar'\")\n (SSCAN \"'don''t'\" \" \" \"\" \"'\")      ==> (\"'don''t'\")\n (SSCAN \"'don/'t'\" \" \" \"\" \"'/\")     ==> (\"'don/'t'\")\n (SSCAN \"foo /* junk */ bar\")       ==> (\"foo\" \"/*\" \"junk\" \"*/\" \"bar\")\n (SSCAN \"foo /* junk */ bar\"\n        \" \" \"\" \"\" \"/*\" \"*/\")        ==> (\"foo\" \"bar\")\n (SSCAN \"a:=if b=c then d else e\")  ==>\n                                  (\"a:=if\" \"b=c\" \"then\" \"d\" \"else\" \"e\")\n\n (SSCAN \"a:=if b=c then d else e\" \" \" \"=\" \"\" \"\" \"\")\n                  ==> (\"a:\" \"=\" \"if\" \"b\" \"=\" \"c\" \"then\" \"d\" \"else\" \"e\")\n\n (SSCAN \"a:=if b=c then d else e\" \" \" \"=\" \"\" \"\" \"\" '(\":=\"))\n                  ==> (\"a\" \":=\" \"if\" \"b\" \"=\" \"c\" \"then\" \"d\" \"else\" \"e\")\n\n (SSCAN \"foo//*bar\" \" \" \"/\" \"\" \"\" \"\")        ==> (\"foo\" \"/\" \"/\" \"*bar\")\n (SSCAN \"foo//*bar\" \" \" \"/\" \"\" \"/*\" \"*/\")    ==> (\"foo\" \"/\")\n (SSCAN \"foo//*bar\" \" \" \"/\" \"\" \"/*\" \"*/\" '(\"//\"))==> (\"foo\" \"/\")\n (SSCAN \"foo//*bar\" \" \" \"\" \"\" \"\" \"\" '(\"//\"))     ==> (\"foo\" \"//\" \"*bar\")\n (SSCAN \"foo//*bar\" \" \" \"\" \"\" \"/*\" \"*/\" '(\"//\")) ==> (\"foo/\")\n\n (STRING-SCAN \"'SYS1.LINKLIB(IEFBR14)'\" \"\" \"()'.\") ==>\n                       (\"'\" \"SYS1\" \".\" \"LINKLIB\" \"(\" \"IEFBR14\" \")\" \"'\")\n\n (STRING-SCAN \"'SYS1.LINKLIB(IEFBR14)'\" \"\" \"()'.\" \"'\") ==>\n                       (\"'SYS1.LINKLIB(IEFBR14)'\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRIM": {"ttr": 6938, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x12\\x0f\\x00\\x880o\\x12R\\x002\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-04-30T00:00:00", "modifydate": "1988-11-01T12:52:00", "lines": 50, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-TRIM\n\nSyntax:   (STRING-TRIM bag1 str2)\n    or:   (STRIM bag1 str2)\n\n bag1 (required, evaluated) - a string.\n str2 (required, evaluated) - a string.\n\nReturns:\n\n A string built by removing all characters present in bag1 from both\n ends of str2; in other words, leading and trailing characters are\n removed.\n\nProcessing:\n\n bag1 is treated as a \"character bag\", and str2 is scanned from both the\n beginning and the end for characters which are part of that bag.  The\n result is a substring of str2 from the first character which is not\n part of the bag up to the last character which is not part of that bag.\n\nErrors signaled:\n\n bag1 not a string.\n arg2 not a string.\n\nNotes:\n\n STRING-TRIM is equivalent to doing both STRING-LEFT-TRIM and\n STRING-RIGHT-TRIM on a string.\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.  However, this\n function always returns a string.\n\n Unlike Common LISP, ZIL does not permit a list to be specified\n for bag1.  Since symbols are permitted, NIL is interpreted as a\n \"character bag\" of the characters N, I and L.\n\nExamples:\n\n (STRING-TRIM \"ar\" \"foobar\") ==> \"foob\"\n (STRING-TRIM \"\" \"foobar\")   ==> \"foobar\"\n (STRING-TRIM \"xy\" \"foobar\") ==> \"foobar\"\n (STRING-TRIM \"fr\" \"foobar\") ==> \"ooba\"\n (STRING-TRIM \"fobra\" \"foobar\") ==> \"\"\n (STRING-TRIM 'FAR 'FOOBAR ) ==> \"OOB\"\n (STRING-TRIM \" \" \" a b c \") ==> \"a b c\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING": {"ttr": 6940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882o\\x00\\x882o\\x10\\x04\\x00)\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "1988-11-21T10:04:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "STRINGP": {"ttr": 6942, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08)\\x00\\x19\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:29:00", "lines": 25, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRINGP\n\nSyntax:   (STRINGP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a string, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (STRINGP 'FOO)           ==> NIL\n (STRINGP \"FOO\")          ==> T\n (STRINGP #(#\\F #\\O #\\O)) ==> NIL ; not a \"vector of characters\" in ZIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRUCTP": {"ttr": 6944, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86&/\\x00\\x87%O\\x081\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-09-19T00:00:00", "modifydate": "1987-09-11T08:31:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRUCTP\n\nSyntax:   (STRUCTP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a structure, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n DEFSTRUCT (and STRUCTURE) are used to create structures.\n\nExamples:\n\n (STRUCTP '(A B C))             ==> NIL\n (STRUCTP #(A B C))             ==> NIL\n (STRUCTP (STRUCTURE 'A 'B 'C)) ==> T\n\n (DEFSTRUCT FOO BAR BAZ)        ==> FOO\n (STRUCTP (MAKE-FOO))           ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRUCTUR": {"ttr": 6946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86&/\\x00\\x87%O\\x08C\\x00!\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-09-19T00:00:00", "modifydate": "1987-09-11T08:43:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRUCTURE\n\nSyntax:   (STRUCTURE &rest args)\n\n At least 1 argument must be specified.\n\n arg (evaluated) - any LISP object; but the first must be a symbol.\n\nReturns:\n\n A structure whose type is the first argument and whose elements are\n the remaining arguments.\n\nProcessing:\n\n A new structure is built, of dimension equal to the number of elements\n specified.  The type of the structure is set to the first element, and\n the elements of the structure are initialized to the remaining\n specified values.\n\n The predicates VECP and STRUCTP are true of structures.\n\nErrors signaled:\n\n No arguments specified, or first argument is not a symbol.\n Not enough vector/string space to build structure.\n\nNotes:\n\n STRUCTURE is generally not to be used by the ZIL programmer.  Use\n DEFSTRUCT to define and manipulate structures.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBLIS": {"ttr": 6948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08D\\x009\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:44:00", "lines": 57, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUBLIS\n\nSyntax:   (SUBLIS arg1 arg2)\n\n arg1 (required, evaluated) - a list in association list format\n                              (i.e. a list of dotted pairs).\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of argument 2, with all occurrences\n of arguments (at any level) replaced by other arguments if they\n occur in the alist specified by argument 1.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements of\n the list specified by the second argument.\n For each atom found at any level of the list, if it is EQL to the\n first element (CAR) of some pair in the association list specified\n by the first argument, the second element (CDR) of the alist pair is\n substituted for said atom in the new list.\n\n Thus, the alist acts as a list of \"from\"-to\" mappings used to\n effect substitutions (a la SUBST) in the target list, which remains\n unaltered.\n\n Compare SUBLISQ, which uses an EQ test (i.e. ASSQ rather than ASSOC).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list, or if the first argument is not NIL or a list of dotted pairs.\n\nExamples:\n\n (SUBLIS '((THE . A) (FOX . WOLF) (DOG . CAT))\n         '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n\n         ==> (A QUICK BROWN WOLF JUMPS OVER A LAZY CAT)\n\n (SUBLIS '((1 . A) (2 . HAVE) (3 . I))\n         '(3 2 1 CONTACT))\n\n         ==> (I HAVE A CONTACT)\n\n (SUBLIS '((1.0 . A) (2.0 . HAVE) (3.0 . I))\n         '(3.0 2.0 1.0 CONTACT))\n\n         ==> (I HAVE A CONTACT)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBLISQ": {"ttr": 6950, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08D\\x004\\x004\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:44:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUBLISQ\n\nSyntax:   (SUBLISQ arg1 arg2)\n\n arg1 (required, evaluated) - a list in association list format\n                              (i.e. a list of dotted pairs).\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of argument 2, with all occurrences\n of arguments (at any level) replaced by other arguments if they\n occur in the alist specified by argument 1.\n\nProcessing:\n\n A new list is built (through repeated CONS'ing) from the elements of\n the list specified by the second argument.\n For each atom found at any level of the list, if it is EQ to the\n first element (CAR) of some pair in the association list specified\n by the first argument, the second element (CDR) of the alist pair is\n substituted for said atom in the new list.\n\n Thus, the alist acts as a list of \"from\"-to\" mappings used to\n effect substitutions (a la SUBST) in the target list, which remains\n unaltered.\n\n Compare SUBLIS, which uses an EQL test (i.e. ASSOC rather than ASSQ).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the second argument is not an atom or a proper\n list, or if the first argument is not NIL or a list of dotted pairs.\n\nExamples:\n\n (SUBLISQ '((THE . A) (FOX . WOLF) (DOG . CAT))\n         '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n\n         ==> (A QUICK BROWN WOLF JUMPS OVER A LAZY CAT)\n\n (SUBLISQ '((1.0 . A) (2.0 . HAVE) (3.0 . I))\n         '(3.0 2.0 1.0 CONTACT))\n\n         ==> (3.0 2.0 1.0 CONTACT)    ; Test is EQ, not EQL.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBR": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x11\\x1f\\x00\\x87%O\\x08E\\x00(\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-21T00:00:00", "modifydate": "1987-09-11T08:45:00", "lines": 40, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: SUBR\n\nSyntax:   (SUBR arg1)\n\n arg1 (required, not evaluated) - a symbol or LAMBDA-expression.\n\nReturns:\n\n Under the compiler:\n\n A compiled-code SUBR object, built from arg1 (the SUBR).  SUBRP is\n true of this object.\n\n Under the interpreter:\n\n arg1.\n\nProcessing:\n\n Under the compiler, SUBR generates a compiled code object for the\n function or LAMBDA-expression specified; if a LAMBDA-expression is\n specified, it is caused to be compiled.  No lexical closure is\n generated.\n\n Under the interpreter, SUBR is identical to QUOTE.  Its intention is\n to return an object which is to be interpreted like a function with\n the same definition as that object.  No closure is generated.\n\nErrors signaled:\n\n Invalid SUBR name (not a symbol or a valid LAMBDA or LABEL expr).\n SUBR name is a macro or a special form.\n\nNotes:\n\n See ZILLOAD and ZILXSUB for more information about SUBRs.\n Compare FUNCTION, which defines a lexical closure.  SUBRs do not\n capture a lexical environment when evaluated, unlike closures.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBRP": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08F\\x00\\x1e\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:46:00", "lines": 30, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUBRP\n\nSyntax:   (SUBRP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a SUBR (a compiled code object), otherwise NIL.\n\nProcessing:\n\n A SUBR is a compiled code object that can be returned only by the\n ZILLOAD function, or by the SUBR special form in compiled code only.\n The compiled code itself is created by compiling a\n function (an EXPR) and stored in a load module library.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (SUBRP 'CAR)            ==> NIL\n (SUBRP (FUNCTION CAR))  ==> NIL\n (SUBRP (ZILLOAD 'CAR))  ==> T\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBST": {"ttr": 7173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08H\\x00<\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:48:00", "lines": 60, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUBST\n\nSyntax:   (SUBST arg1 arg2 arg3)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object, but should be a symbol.\n arg3 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of arg3, with all occurrences\n of arg2 (at any level) replaced by arg1.\n\nProcessing:\n\n If arg3 is an atom, it is returned as is.\n Otherwise...\n\n A new list is built (through repeated CONS'ing) from the elements of\n the list specified by arg3.  For each atom found within the list\n structure, if it is EQL to arg2 then arg1 is substituted for it in the\n new list.  Note that the CAR's of the list are recursively substituted.\n\n Compare SUBSTQ, which uses an EQ test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The Maclisp idiom (SUBST NIL NIL form), used to do a full copy of a\n list structure, WILL NOT WORK in ZIL.  Use COPYTREE for this purpose.\n\n SUBST is, by default, implemented with an EQL test for Common LISP\n compatibility, using the ZIL function SUBSTQL. If Maclisp or Franz LISP\n compatibility is desired, SUBST may be equated with ZIL function\n SUBSTQUA via the DEFLOAD special form.  See SUBSTQ, SUBSTQL and\n SUBSTQUA for more info.\n\n Under Macsyma, SUBST performs an EQUAL test.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the third argument is not an atom or a proper\n list.\n\nExamples:\n\n (SUBST 'A 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (A QUICK BROWN FOX JUMPS OVER A LAZY DOG)\n\n (SUBST '(FOO BAR) 'FOO '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> ((FOO BAR) ((FOO BAR) BAR) ((FOO BAR)) (FOO BAR) BAR)\n\n (SUBST '(NEW WINE) '(OLD BOTTLES) '(PUT (OLD BOTTLES) IN OLD BOTTLES))\n            ==> (PUT (OLD BOTTLES) IN OLD BOTTLES)\n\n (SUBST 2.0 1.0 '(1.0 2.0 3.0))    ==> (2.0 2.0 3.0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSTQ": {"ttr": 7175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08I\\x004\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:49:00", "lines": 52, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUBSTQ\n\nSyntax:   (SUBSTQ arg1 arg2 arg3)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object, but should be a symbol.\n arg3 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of arg3, with all occurrences\n of arg2 (at any level) replaced by arg1.\n\nProcessing:\n\n If arg3 is an atom, it is returned as is.\n Otherwise...\n\n A new list is built (through repeated CONS'ing) from the elements of\n the list specified by arg3.  For each atom found within the list\n structure, if it is EQ to arg2 then arg1 is substituted for it in the\n new list.  Note that the CAR's of the list are recursively substituted.\n\n Compare SUBST, which uses an EQL test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n (SUBSTQ NIL NIL form) will NOT do a full copy of a list structure\n in ZIL.  Use COPYTREE for this purpose.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the third argument is not an atom or a proper\n list.\n\n Keep in mind that EQ, not EQL or EQUAL, is used for the comparisons.\n Thus, only symbols, in general, will work as the second argument.\n\nExamples:\n\n (SUBSTQ 'A 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (A QUICK BROWN FOX JUMPS OVER A LAZY DOG)\n\n (SUBSTQ '(FOO BAR) 'FOO '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> ((FOO BAR) ((FOO BAR) BAR) ((FOO BAR)) (FOO BAR) BAR)\n\n (SUBSTQ 2.0 1.0 '(1.0 2.0 3.0))   ==> (1.0 2.0 3.0) ; Test is EQ.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSTQL": {"ttr": 7177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\t?\\x00\\x87%O\\x08I\\x004\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-04-03T00:00:00", "modifydate": "1987-09-11T08:49:00", "lines": 52, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUBSTQL\n\nSyntax:   (SUBSTQL arg1 arg2 arg3)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object, but should be a symbol.\n arg3 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of arg3, with all occurrences\n of arg2 (at any level) replaced by arg1.\n\nProcessing:\n\n If arg3 is an atom, it is returned as is.\n Otherwise...\n\n A new list is built (through repeated CONS'ing) from the elements of\n the list specified by arg3.  For each atom found within the list\n structure, if it is EQL to arg2 then arg1 is substituted for it in the\n new list.  Note that the CAR's of the list are recursively substituted.\n\n Compare SUBSTQ, which uses an EQ test; and SUBSTQUA, which uses EQUAL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n (SUBSTQL NIL NIL form) will NOT do a full copy of a list structure\n in ZIL.  Use COPYTREE for this purpose.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the third argument is not an atom or a proper\n list.\n\nExamples:\n\n (SUBSTQL 'A 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (A QUICK BROWN FOX JUMPS OVER A LAZY DOG)\n\n (SUBSTQL '(FOO BAR) 'FOO '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> ((FOO BAR) ((FOO BAR) BAR) ((FOO BAR)) (FOO BAR) BAR)\n\n (SUBSTQL '(NEW WINE) '(OLD BOTTLES) '(PUT (OLD BOTTLES) IN OLD BOTTLES))\n            ==> (PUT (OLD BOTTLES) IN OLD BOTTLES)\n\n (SUBSTQL 2.0 1.0 '(1.0 2.0 3.0))  ==> (2.0 2.0 3.0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSTQUA": {"ttr": 7179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\t?\\x00\\x87%O\\x08I\\x00<\\x003\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-04-03T00:00:00", "modifydate": "1987-09-11T08:49:00", "lines": 60, "newlines": 51, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUBSTQUA\n\nSyntax:   (SUBSTQUA arg1 arg2 arg3)\n    or:   (SUBSTQUAL arg1 arg2 arg3)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object, but should be a symbol.\n arg3 (required, evaluated) - a proper list.\n\nReturns:\n\n A list consisting of the elements of arg3, with all occurrences\n of arg2 (at any level) replaced by arg1.\n\nProcessing:\n\n If arg3 is an atom, it is returned as is.\n Otherwise...\n\n A new list is built (through repeated CONS'ing) from the elements of\n the list specified by arg3.  For each atom found within the list\n structure, if it is EQUAL to arg2 then arg1 is substituted for it in\n the new list.  Note that the CAR's of the list are recursively\n substituted.\n\n Compare SUBSTQ, which uses an EQ test; and SUBSTQL, which uses EQL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n (SUBSTQUA NIL NIL form) will NOT do a full copy of a list structure\n in ZIL.  Use COPYTREE for this purpose.\n\n Beware - if the third arg is a list ending in a sublist which matches\n the second arg, it will be substituted.  This is because the algorithm\n treats any CDR of the list as substitutable.  This is how Common LISP\n defines (SUBST ... :TEST #'EQUAL), and how it works in NIL.\n\n No checking is done as to the validity of the arguments.  Unpredictable\n results will occur if the third argument is not an atom or a proper\n list.\n\nExamples:\n\n (SUBSTQUAL 'A 'THE '(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG))\n                          ==> (A QUICK BROWN FOX JUMPS OVER A LAZY DOG)\n\n (SUBSTQUAL '(FOO BAR) 'FOO '(FOO (FOO BAR) (FOO) FOO BAR))\n            ==> ((FOO BAR) ((FOO BAR) BAR) ((FOO BAR)) (FOO BAR) BAR)\n\n (SUBSTQUAL '(NEW WINE) '(OLD BOTTLES)\n             '(PUT (OLD BOTTLES) IN OLD BOTTLES))\n             ==> (PUT (NEW WINE) IN NEW WINE)\n\n (SUBSTQUAL 2.0 1.0 '(1.0 2.0 3.0)) ==> (2.0 2.0 3.0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSTR": {"ttr": 7181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x06_\\x00\\x87%O\\x08Q\\x00V\\x00G\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-06T00:00:00", "modifydate": "1987-09-11T08:51:00", "lines": 86, "newlines": 71, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-SUBSTR\n\nSyntax: (STRING-SUBSTR string1 index2 &optional length3)\n    or:        (SUBSTR string1 index2 &optional length3)\n\n string1 (required, evaluated) - a string.\n index2  (optional, evaluated) - a fixnum or NIL.\n length3 (optional, evaluated) - a fixnum or NIL.\n\nReturns:\n\n A copy of a substring of string1, starting at the character at\n position index2 for a length of length3 (or up to the end if\n length3 is omitted).\n\nProcessing:\n\n One-based indexing is used.\n\n If length3 is NIL or omitted, the default value is used as\n explained below.\n\n If index2 is NIL, the null string is returned.  This exists to\n facilitate the use of SUBSTR in conjunction with other string\n functions like INDEX, which may return either a fixnum or NIL.\n\n If index2 is positive, (length3) characters of string1 starting at\n position index2 from the beginning are made into a string.\n length3 defaults to the length of the string from index2 to the end.\n\n If index2 is negative, (length3) characters of string1 starting at\n position index2 from the end are made into a string.\n length3 defaults to the length of the string from index2 to the end.\n\n If the requested length exceeds the bounds of the string, the portion\n up to the end of the string is returned - i.e. the requested length\n is adjusted to stay within the confines of the string.  If the\n requested length is zero, a null string is returned, provided that\n index2 is valid.\n\n If index2 is zero, length3 is negative, or the absolute value of\n index2 is greater than the length of string1, the null string is\n returned.\n\n As with most string-handling functions, symbols are acceptable.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Invalid second argument (not a fixnum or NIL).\n Invalid third argument (not a fixnum or NIL).\n\nNotes:\n\n This function is analogous to the PL/1 SUBSTR function, and is most\n nearly similar to Franz LISP SUBSTRING (in its use of negative values).\n Other implementations of LISP interpret the third argument to similar\n functions differently.\n\nExamples:\n\n (SUBSTR \"frob\" -5)        ==> \"\"\n (SUBSTR \"frob\" -4)        ==> \"frob\"\n (SUBSTR \"frob\" -3)        ==> \"rob\"\n (SUBSTR \"frob\" -2)        ==> \"ob\"\n (SUBSTR \"frob\" -1)        ==> \"b\"\n (SUBSTR \"frob\" 0)         ==> \"\"\n (SUBSTR \"frob\" 1)         ==> \"frob\"\n (SUBSTR \"frob\" 2)         ==> \"rob\"\n (SUBSTR \"frob\" 3)         ==> \"ob\"\n (SUBSTR \"frob\" 4)         ==> \"b\"\n (SUBSTR \"frob\" 5)         ==> \"\"\n\n (SUBSTR \"frob\" NIL)       ==> \"\"\n\n (SUBSTR \"frob\" 1 2)       ==> \"fr\"\n (SUBSTR \"frob\" 2 4)       ==> \"rob\"\n (SUBSTR \"frob\" 3 1)       ==> \"o\"\n (SUBSTR \"frob\" 2 0)       ==> \"\"\n (SUBSTR \"frob\" 3 -1)      ==> \"\"\n (SUBSTR \"frob\" -3 2)      ==> \"ro\"\n (SUBSTR \"frob\" -5 4)      ==> \"\"\n (SUBSTR \"frob\" -6 0)      ==> \"\"\n (SUBSTR \"frob\" 4 1)       ==> \"b\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUB1": {"ttr": 7183, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x02O\\x00\\x87%O\\x08R\\x00#\\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "1987-09-11T08:52:00", "lines": 35, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SUB1\n\nSyntax:   (SUB1 num1)\n    or:   (1- num1)\n\n num1 (required,evaluated) - a number.\n\nReturns:\n\n The difference of the argument and 1 (num1 - 1), of the same type as\n num1.\n\nProcessing:\n\n See $ARITH for more information.\n\nErrors signaled:\n\n See $ARITH for more information.\n\nNotes:\n\n See $ARITH for more information.\n\nExamples:\n\n (SUB1 3)      ==> 2\n (1- 2.0)      ==> 1.0\n (1- 2.0F0)    ==> 1.0F0\n (SUB1 10000000000000000000000000000001) ==>\n       100000000000000000000000\n (SUB1 -9999999999999999999999999999999) ==>\n      -100000000000000000000000\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SXHASH": {"ttr": 7185, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x17\\x8f\\x00\\x87%O\\x08S\\x00.\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-06-27T00:00:00", "modifydate": "1987-09-11T08:53:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SXHASH\n\nSyntax:   (SXHASH arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n A fixnum containing the hash code for arg1.\n\nProcessing:\n\n A non-negative fixnum is generated from the contents of arg1, such\n that the value will be numerically equal to the value generated for\n any object that is EQL to arg1.  This is a \"hash code\" for the\n object.  The same argument will always return the same hash code.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n The value from this function may be used in various hashing algorithms\n to speed up table lookups, etc.\n\n For maximum usefulness, you should take the value modulo some number\n which is NOT a power of 2 (for example, the dimension of a vector\n being used as a hash table).  SXHASH does not perform any modulus\n arithmetic; it returns a raw value between 0 and 2147483647.\n\n SXHASH may fail to terminate on circular or self-referencing lists.\n This is due to limitations in the implementation; actually this is\n not correct and represents lossage in ZIL.\n\n The hash code is NOT dependent in any way upon the virtual memory\n address of the object; such a dependency would cause the same object\n to return a different hash value if it were relocated by a garbage\n collection.\n\nExamples:\n\n; (There are no examples because the value returned by SXHASH is\n;  implementation dependent, and is of little meaning by itself.)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYMBOLP": {"ttr": 7187, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%O\\x08T\\x00$\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-11T08:54:00", "lines": 36, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SYMBOLP\n\nSyntax:   (SYMBOLP arg1)\n\n arg1 (required, evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a symbol, otherwise NIL.\n\nProcessing:\n\n Symbols may be created by being read in, or built via functions like\n IMPLODE, CONCAT and MAKNAM.  Note that some of these functions create\n interned symbols and some created uninterned ones.\n\n NIL is also a symbol.\n\nErrors signaled:\n\n None.\n\nNotes:\n\nExamples:\n\n (SYMBOLP 'FOO)     ==> T\n (SYMBOLP NIL)      ==> T\n (SYMBOLP 123)      ==> NIL\n (SYMBOLP '(A B C)) ==> NIL\n (SYMBOLP '12)      ==> NIL\n (SYMBOLP (GENSYM)) ==> T\n (SYMBOLP '\\12)     ==> T\n (SYMBOLP \"12\")     ==> NIL    ; strings are not symbols\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYMEVAL": {"ttr": 7189, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x12O\\x081\\x00A\\x00C\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-05-03T08:31:00", "lines": 65, "newlines": 67, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: SYMEVAL\n\nSyntax:   (SYMEVAL arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n The current dynamic (special) value of the symbol arg1.\n\nProcessing:\n\n Remember that arg1 is evaluated.\n\n arg1 must be a symbol other than T, NIL or a keyword.\n\n The current global or dynamic \"SPECIAL\" binding for the symbol is\n located and the value, if one exists, is returned.\n (Symbol autoloading may be invoked if there is an AUTOVALUE\n property on the symbol and it does not currently have a\n dynamically bound value.)\n\nErrors signaled:\n\n Variable has no value (either because there is no binding or\n because the binding has no value).\n\nNotes:\n\n SYMEVAL is not a substitute for EVAL.  Use is not encouraged.\n\n Do not pass T, NIL, or a keyword (symbol beginning with \":\") to\n SYMEVAL.\n\n The old optional \"alist\" argument to SYMEVAL is no longer supported.\n SYMEVAL cannot be used to access lexical bindings.\n\n No error checking is done in SYMEVAL.  Use EVAL if you\n are not sure whether an object to be evaluated is a symbol or not.\n Unpredictable results will occur if arg1 is not a symbol.\n\nExamples:\n\n (MAKUNBOUND 'FOO)                     ==> FOO\n (MAKUNBOUND 'BAZ)                     ==> BAZ\n (DEFVAR FOO 'BAR)                     ==> FOO\n FOO                                   ==> BAR\n (SYMEVAL 'FOO)                        ==> BAR\n (SYMEVAL 'BAZ)                        ==> (\"***ERROR***\")\n                                       ; Error - unbound variable.\n (MAKUNBOUND 'A)                       ==> A\n A                                     ==> (\"***ERROR***\")\n                                       ; Error - unbound variable.\n (SYMEVAL 'A)                          ==> (\"***ERROR***\")\n                                       ; Error - unbound variable.\n (LET ((A 'NEW-VALUE-OF-A))            ; Local lexical binding.\n      (SYMEVAL 'A))                    ==> (\"***ERROR***\")\n                                       ; Error - unbound variable.\n (LET ((A 'NEW-VALUE-OF-A))\n      (DECLARE (SPECIAL A))\n      (SYMEVAL 'A))                    ==> NEW-VALUE-OF-A\n (SYMEVAL 'A)                          ==> (\"***ERROR***\")\n                                       ; Error - unbound variable.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TABS": {"ttr": 7191, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x16\\x1f\\x00\\x87%_#P\\x00>\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-10T00:00:00", "modifydate": "1987-09-12T23:50:00", "lines": 62, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TABS\n\nSyntax:   (TABS arg1 &optional arg2)\n\n arg1 (required, evaluated) - any LISP object, but generally T or NIL.\n arg2 (optional, evaluated) - an output file name.\n\nReturns:\n\n arg1, after tabs mode has been set on or off for the output file\n specified by arg2.\n\nProcessing:\n\n If arg1 is NIL, tabs mode is set off for output file arg2.\n Otherwise, tabs mode is set on for output file arg2.\n\n Tabs mode controls how the ZIL printer handles the following characters\n in a PRINC-style print request:\n\n   X'05'   (horizontal tab)\n   X'0D'   (carriage return)\n   X'15'   (newline)\n   X'AD'   (left square bracket)\n   X'BD'   (right square bracket)\n\n If tabs mode is off, these characters are written to the output file\n just like any other character (subject to minimal character\n translation if a terminal is the destination to prevent terminal\n errors).\n\n If tabs mode is on, then the tab character causes tabbing to occur\n based on a tab size of 8 positions, and both carriage return and\n newline cause the current line to be completed and a new line begun.\n Furthermore, square brackets are translated to the corresponding\n curly braces (unless the SETBRACK function was used to change this).\n\n The default tabs mode is ON for terminal files and OFF for other files.\n\n PRIN1-style print operations are not sensitive to TABS mode; all\n characters are output as is to preserve read-print equivalency.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member SETBRACK to see how to control the printing of square\n brackets when TABS mode is active for a file.\n\nExamples:\n\n (TABS NIL) and (TABS NIL NIL) are equivalent, and set tabs mode off\n        for the standard output file.\n\n (TABS T 'FOO)      sets tabs mode on for output file FOO.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TAGBODY": {"ttr": 7193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x1f\\x00\\x88\\x16\\x1f\\x08A\\x00S\\x00S\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-09T00:00:00", "modifydate": "1988-06-09T08:41:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: TAGBODY\n\nSyntax:   (TAGBODY &rest forms)\n\n form     (conditionally evaluated if a list) - a symbol or a list.\n\nReturns:\n\n NIL.\n\nProcessing:\n\n The forms in a TAGBODY are processed in succession as follows:\n\n (a) If the form is NIL, it is ignored.\n\n (b) If the form is a symbol, it is not evaluated, but kept\n     as a tag which a GO form can branch to.\n\n (c) If the form is an integer, it is not evaluated, but kept\n     as a tag which a GO form can branch to.  In other words,\n     integers can be used as GO tags much as symbols can, for\n     compatibility with Maclisp.\n\n (d) If the form is a list, it is evaluated.\n\n (e) It is an error if the form is not of one of the above types.\n\n (f) If the end of the TAGBODY is reached, it is terminated and NIL is\n     returned as its value.\n\n The above sequence can be altered by the execution of the GO special\n form if it is encountered during evaluation (see the GO documentation\n for details).\n\n GO causes control to pass to the specified tag (symbol or integer) in\n the TAGBODY.  The form following the tag becomes the next form to\n be evaluated, and processing continues from there.\n\nErrors signaled:\n\n Invalid or duplicate GO tags.\n\nNotes:\n\n GO is valid as long as it are lexically apparent in\n the code.  This means that it will be processed as long as it\n is not the product of function evaluation.  The following are\n valid occurrences of GO:\n\n (TAGBODY LOOP (DO 'SOMETHING) (GO LOOP))\n (TAGBODY (COND ((EQ A T) (GO LOOP)))\n          LOOP\n          (PROG2 (PRINT A) (GO B))\n          B\n          (PRINT Z))\n\n The following is NOT valid:\n\n (DEFUN SUMFUNK () (GO LAB))\n (TAGBODY LAB (SUMFUNK))\n\n A \"GO outside of TAGBODY\" error will be signalled.\n\n See member GO for more information on restrictions pertaining to GO,\n particularly those which involve functionality available under the\n interpreter but not (as yet) in compiled code.\n\nExamples:\n\n (LET (A B)\n      (TAGBODY\n               (SETQ A '(1 2 3 4))\n          LOOP (COND ((NULL A) (GO END)))\n               (SETQ B (CONS (ADD1 (CAR A)) B))\n               (SETQ A (CDR A))\n               (GO LOOP)\n           END\n               (SETQ A B)\n      )\n      A)                               ==> (5 4 3 2)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAN": {"ttr": 7195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x7f\\x00\\x87%o\\x00\\x00\\x003\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-26T00:00:00", "modifydate": "1987-09-13T00:00:00", "lines": 51, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TAN\n\nSyntax:   (TAN num1)\n\n num1 (required, evaluated) - a number.\n\nReturns:\n\n A number which is the tangent of num1, where num1 is expressed in\n radians.\n\nProcessing:\n\n The FORTRAN subroutine library interface is used to compute the\n value from num1.  If num1 is a single-precision flonum, the\n result is a single-precision flonum; otherwise the result is\n a double-precision flonum.\n\nErrors signaled:\n\n Non-numeric argument.\n For single precision, abs(arg) greater than 823549.5625.\n For double precision, abs(arg) greater than 3537118876014220.125.\n These values are the maximum that the FORTRAN subroutine library\n will successfully process.\n\nNotes:\n\n This function requires the FORTRAN subroutine library interface\n to be available.  See member $FORTRAN of this documentation for\n further information.\n\n Bignums are not supported as arguments to this function.\n\n Since the tangent of PI/2, in theory, cannot exist because it would\n require division by zero, computation of (TAN n) where n is supposed\n to be PI/2 does not produce a result that bcan reasonably be\n considered valid.\n\n Similarly, the tangent of PI is supposed to be zero, but (TAN n) where\n n is a close approximation of PI is unlikely to return this result.\n\nExamples:\n\n(TAN 0) ==> 0.0\n(TAN 1) ==> 1.55740772\n(TAN -1) ==> -1.55740772\n(TAN 0.5) ==> 0.54630248\n(TAN 0.5F0) ==> 0.5463025F0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TERPRI": {"ttr": 7197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%o\\x00\\x02\\x00-\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-13T00:02:00", "lines": 45, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TERPRI\n\nSyntax:   (TERPRI &optional file1)\n\n file1 (optional, evaluated) - an output file name.\n\nReturns:\n\n NIL, after the current line of the output file specified by the\n first argument is written out.\n\nProcessing:\n\n Each invocation of TERPRI causes a line to be written out to the\n specified output file.  If no data has been written to the current\n line, a line of blanks is written out.\n\n The current character position is reset to 1 when TERPRI is issued,\n and the output line is cleared to blanks.\n\n The CTERPRI, PRINC, PRIN1 and PRINT functions automatically invoke\n TERPRI when they need to; see the documentation for these functions for\n more information.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member $PRINTER for more information on printing functions\n\nExamples:\n\n (TERPRI)\n (TERPRI NIL) ...are equivalent and return NIL after writing the\n                 current line of standard output.\n\n (TERPRI 'FOO) ...writes out the contents of the current line of\n                  output file FOO.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THIRD": {"ttr": 7199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x173\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T17:33:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: THIRD\n\nSyntax:   (THIRD list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The third element of list1, or NIL if list1 has less than 3 elements.\n\nProcessing:\n\n This is the same as CADDR.\n\nErrors signaled:\n\n See CADDR.\n\nNotes:\n\n See CADDR.\n\nExamples:\n\n (THIRD NIL)                 ==> NIL\n (THIRD '(A))                ==> NIL\n (THIRD '(A B C D))          ==> C\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THROW": {"ttr": 7201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x16_\"7\\x00I\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-06-13T22:37:00", "lines": 73, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: THROW\n\nSyntax:   (THROW arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object, but usually a symbol.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n arg2, but not to the caller.  THROW causes control to pass back to the\n most recently established CATCH that specified a tag EQ to arg1.\n\nProcessing:\n\n arg1 is the \"tag\"; both arguments are evaluated.  The stack is then\n searched for a catch frame containing a tag EQ to arg1.  When one is\n found, control passes to the end of the CATCH and arg2 from THROW is\n returned as the value of the CATCH.\n\n If no catch frame is found with a matching tag, an error is signalled.\n Since the signalling of an error causes a THROW to NIL, a CATCH with\n a tag of NIL will catch such a THROW if one exists.\n\n The catch frame stacked by CATCH is removed when the forms evaluation\n is complete (or when a THROW occurs).  This frame is used to store the\n current state of the ZIL environment, including the current variable\n binding environment; thus, variable bindings are restored to the status\n they possessed upon entry to the CATCH function.\n\n If there are pending UNWIND-PROTECT cleanup forms, these forms are\n executed before control is returned to the end of the CATCH.  If\n a THROW or error occurs during execution of one of these cleanup\n forms, it is NOT protected by the same CATCH.\n\n A THROW may catch only a THROW to a tag that matches via EQ.\n Thus, the tag is generally a symbol, though it does not have to be.\n\n A THROW may occur in one of the following ways:\n\n (1) Directly via the THROW function.\n\n (2) When an error is signalled, either by the ERROR function or by a\n     ZIL primitive (assembler language level function), which results\n     in a THROW to tag NIL.\n\n (3) When an attention interrupt is caused by the terminal user pressing\n     the PA1 key (or equivalent), which results in a THROW to tag T.\n\n Thus, a CATCH with a tag of NIL will \"capture\" all standard\n signalled errors; a CATCH with a tag of T will catch attention\n interruptions.\n\n If no CATCH is active for a tag of NIL, this is considered to be a\n fatal error and the ZIL program is abended with a user code.  If the\n error message issued by the module calling THROW begins with the\n characters ZILnnnn, where nnnn is a 4-digit number between 0001 and\n 4095, that number is used as the user abend code; otherwise a user\n abend code of zero is issued.\n\n Thus, a THROW to any tag when no CATCH exists either for that tag\n or for NIL will result in the abending of the ZIL program.\n\nErrors signaled:\n\n No CATCH found with specified tag.\n\nNotes:\n\nExamples:\n\n See CATCH for examples.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIME": {"ttr": 7203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x1f\\x00\\x88\\x16\\x8f\\t\\x05\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1988-06-16T09:05:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: TIME\n\nSyntax:   (TIME &rest forms)\n\n form (optional, evaluated) - any LISP object.\n\nReturns:\n\n The value of the last form, after printing out the CPU time and GC time\n (if any) required to evaluate all the forms.\n\nProcessing:\n\n The current run time and GC time are saved, then the forms are\n evaluated in sequence, then the difference between the run time\n and GC time are computed and displayed.  Thus, you can use this\n form to show how much CPU time and/or GC time it takes for a\n particular operation or operations.\n\nErrors signaled:\n\n None.  If any of the forms error out during evaluation, you still\n get the time displayed.\n\nNotes:\n\n The run time shown does not include the GC time if any.\n\n For best results, you should execute the forms at least once before\n timing them.  In that way load time is not a factor.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIMES": {"ttr": 7205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%o\\x00\\t\\x00'\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-13T00:09:00", "lines": 39, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TIMES\n\nSyntax:   (TIMES &rest args)\n    or:   (* &rest args)\n\n arg (evaluated) - a number.\n\nReturns:\n\n The product of all the arguments.\n\nProcessing:\n\n If no arguments are specified, 1 is returned.\n If one argument is specified, that argument is returned.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for errors detected.\n\nNotes:\n\nExamples:\n\n (*)                   ==> 1\n (* 4)                 ==> 4\n (* 2 3)               ==> 6\n (* 3 3 3.0)           ==> 27.0\n (* 2 2 2 2)           ==> 16\n\n (TIMES)               ==> 1\n (TIMES 4)             ==> 4\n (TIMES 2 3)           ==> 6\n (TIMES 3 3 3.0)       ==> 27.0\n (TIMES 2 2 2 2)       ==> 16\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TOSTRING": {"ttr": 7425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87)/\\x00\\x87)/#(\\x00=\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-19T00:00:00", "modifydate": "1987-10-19T23:28:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TOSTRING\n\nSyntax:   (TOSTRING arg1 &optional arg2)\n\n arg1 (required, evaluated) - an atom.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A string that looks like the printed representation of arg1\n (via PRINC if arg2 is NIL, via PRIN1 otherwise).\n\nProcessing:\n\n arg2 specifies whether slashification is to occur.\n\n If arg2 is omitted or NIL, then:\n\n If arg1 is a string, it is returned as is.\n If arg1 is a symbol, its print name is returned.\n If arg1 is any other object acceptable to TOSTRING, a string is\n built containing the characters that arg1 would use when it is printed\n by PRINC.\n\n If arg2 is non-NIL, then:\n\n If arg1 is a string, a new string is built that contains enclosing\n double quote marks as well as backslashes preceding any double quotes\n or backslashes contained in the string.\n\n If arg1 is a symbol, a string is built that contains the print name\n of the symbol, plus vertical bars and backslashes where necessary to\n make it look the way it would be read in.\n\n If arg1 is any other object acceptable to TOSTRING, a string is\n built containing the characters that arg1 would use when it is printed\n by PRIN1.\n\nErrors signaled:\n\n arg1 is a list, vector or structure; these objects cannot be converted\n to strings by this function.\n Not enough string space to build the string, even after GC.\n\nNotes:\n\n TOSTRING used to be called MKSTRING and have an alias of MAKE-STRING,\n but this has been eliminated since it would conflict with the Common\n Lisp definition of MAKE-STRING.\n\nExamples:\n\n (TOSTRING \"hi there\"  )    ==>  \"hi there\"\n (TOSTRING 'foo        )    ==>  \"FOO\"\n (TOSTRING 01          )    ==>  \"1\"\n (TOSTRING \"hi there\" T)    ==>     \"\\\"hi there\\\"\"\n (TOSTRING 'foo       T)    ==>  \"FOO\"\n (TOSTRING '|foo|     T)    ==>  \"|foo|\"\n (TOSTRING 01         T)    ==>  \"1\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRACE": {"ttr": 7427, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x880\\x9f\\t8\\x002\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-11-04T09:38:00", "lines": 50, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: TRACE\n\nSyntax:   (TRACE &rest funs)\n\n fun (optional, not evaluated) - zero or more function names (symbols).\n\nReturns:\n\n If no operands are specified, the list of functions currently being\n traced; otherwise, funs, after tracing has been activated for the\n functions named in the list.\n\nProcessing:\n\n If no funs are specified, the list of functions for which tracing is\n currently enabled is returned; no other action is taken.\n\n Otherwise, tracing is activated for each function name in this list\n which has a function definition (autoloading will be done of\n necessary to locate this function definition).  If a function is\n not currently defined, it will not be traced.\n\n Only EXPR's and SUBR's can be traced; FEXPR's and MACRO's cannot.\n Furthermore, calls from compiled code to compiled code cannot be\n traced unless the calls are implemented indirectly (via FUNCALL).\n\n The UNTRACE function is used to turn tracing off.\n\nErrors signaled:\n\n One of the funs not a symbol.\n\nNotes:\n\n See member $TRACE of this document for a description of tracing.\n\n See also AT, OFF and PUTDATA for more information.\n\n See ZILTRACE for technical details on how tracing and untracing\n are effected.\n\nExamples:\n\n (TRACE)          returns the list of functions currently being traced.\n\n (TRACE FOO)          activates tracing for function FOO.\n\n (TRACE CAR CDR CONS) activates tracing for functions CAR, CDR and CONS.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRUNCATE": {"ttr": 7429, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87&/\\x00\\x89\\x05O\\x17H\\x00\\\\\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-09-19T00:00:00", "modifydate": "1989-02-23T17:48:00", "lines": 92, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TRUNCATE\n\nSyntax:   (TRUNCATE arg1 &optional arg2)\n\n arg1 (required, evaluated) - a number.\n arg2 (optional, evaluated) - a number.\n\nReturns:\n\n Two values:\n\n  (1) arg1, or arg1 divided by arg2, truncated to an integer.\n  (2) If arg1 only is specified, the difference of arg1 and the\n      first value.\n      If arg1 and arg2 are specified, the remainder, i.e. the difference\n      of arg1 and (arg2 times the first value).\n\nProcessing:\n\n If arg2 is specified, arg1 is divided by arg2 such that a floating\n point result is obtained.  Otherwise, the argument is set to arg1.\n\n If the argument is float, the fractional portion of the value is\n truncated and the integer portion is returned as an integer.\n\n If the argument is integer, itself is returned.\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\n Compare ROUND, which rounds its argument to the nearest integer;\n CEILING, which returns the nearest integer greater than or equal to its\n argument; and FLOOR, which returns the nearest integer less than or\n equal to its argument.\n\n Note that FIX is identical to FLOOR, not TRUNCATE, in ZIL 1.3.\n\n Note that flonums whose exponent is large (in either direction) may\n result in integers whose value does not accurately represent the\n integer part of the flonum.\n\nExamples:\n\n ; Note: Only the first value is shown in these examples.\n\n (TRUNCATE 1)               ==> 1\n (TRUNCATE 1.5)             ==> 1\n (TRUNCATE 1.5F0)           ==> 1\n (TRUNCATE 1.9)             ==> 1\n (TRUNCATE 1.9F0)           ==> 1\n (TRUNCATE 1.2)             ==> 1\n (TRUNCATE 1.2F0)           ==> 1\n (TRUNCATE -1)              ==> -1\n (TRUNCATE -1.5)            ==> -1\n (TRUNCATE -1.9)            ==> -1\n (TRUNCATE -1.2)            ==> -1\n (TRUNCATE 0)               ==> 0\n (TRUNCATE 0.5)             ==> 0\n (TRUNCATE 0.5F0)           ==> 0\n (TRUNCATE 0.9)             ==> 0\n (TRUNCATE 0.9F0)           ==> 0\n (TRUNCATE 0.2)             ==> 0\n (TRUNCATE 0.2F0)           ==> 0\n (TRUNCATE -0)              ==> 0\n (TRUNCATE -0.5)            ==> 0\n (TRUNCATE -0.9)            ==> 0\n (TRUNCATE -0.2)            ==> 0\n (TRUNCATE 7E-4)            ==> 0\n (TRUNCATE -123.45)         ==> -123\n (TRUNCATE -123.45F0)       ==> -123\n (TRUNCATE 2147483647.0)    ==> 21\n (TRUNCATE 2147483647.5)    ==> 21\n (TRUNCATE 2147483648.0)    ==> 21\n (TRUNCATE 2147483648.5)    ==> 21\n (TRUNCATE 2147483649.0)    ==> 21\n (TRUNCATE 2147483649.5)    ==> 21\n (TRUNCATE -2147483647.0)   ==> -21\n (TRUNCATE -2147483647.5)   ==> -21\n (TRUNCATE -2147483648.0)   ==> -21\n (TRUNCATE -2147483648.5)   ==> -21\n (TRUNCATE -2147483649.0)   ==> -21\n (TRUNCATE -2147483649.5)   ==> -21\n\n (TRUNCATE 10 3)            ==> 3\n (TRUNCATE -10 3)           ==> -3\n (TRUNCATE 9 3)             ==> 3\n (TRUNCATE -9 3)            ==> -3\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSO": {"ttr": 7431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x88\\x12O\\x083\\x00K\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1988-05-03T08:33:00", "lines": 75, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TSO\n\nSyntax:   (TSO &rest args)\n\n arg (required, evaluated) - a string (or symbol).\n\nReturns:\n\n A fixnum containing the return code from the TSO command or CLIST\n specified by the command buffer bult from concatenating the text\n of the arguments.\n\nProcessing:\n\n The arguments are concatenated to form a character string buffer which\n is assumed to contain a valid TSO command or CLIST, and it is executed.\n\n If no arguments are specified, a null buffer is built and executed\n as a null command (at least at this time).\n\n The contents of the return code (register 15) when the command or CLIST\n returns control, which will be the command or CLIST return code, are\n used to build a fixnum containing the value to be returned as the TSO\n function value.  This should be 0 if the command completed\n successfully.\n\n Attention interrupts or system ABENDs will terminate the TSO\n command or CLIST, and ZIL will signal an error.\n\n You cannot execute the ISPEXEC command with this function, or a CALL to\n a program that requires APF authorization (like IEBCOPY).  (You can use\n the TSOEXEC command to invoke the CALL command if you want to\n accomplish the latter.)  CLIST's should not contain TERMIN or ATTN\n statements.\n\n The success of this function is dependent upon the amount of system\n memory available at the time that the TSO command is attempted to be\n executed.  If there is insufficient virtual storage, the TSO command\n requested will probably ABEND.\n\nErrors signaled:\n\n Arguments that cannot be converted into strings (lists, vectors, etc.).\n Command text exceeds 32763 bytes.\n Requested command has abended or was attentioned out of.\n\nNotes:\n\n TSO must be available for this function to work.  TSO/Extensions,\n however, is not required, except to invoke TEST or APF authorized\n commands.\n\n TSO commands may have the same names as compiled ZIL functions;\n however, they must reside in the system link pack area or system\n link list.  They will not be found if they reside only in a STEPLIB\n or task library.\n\nExamples:\n\n (TSO 'TIME) ; will display the current time and return:\n             ==> 0\n\n;(TSO \"alloc file(zilifoo) da(foobar.data) shr reuse\")\n;\n;            ; will dynamically allocate ZIL input file FOO and return\n;\n;            ==> 0  ; if the allocation was successful,\n;            ==> 12 ; if the allocation was unsuccessful.\n;\n;(LET ((A 'TSO))\n;     (TSO \"LIST 'PROGLIB.ZIL.TEXT(\" A \")'\"))\n;\n;           ...lists this documentation member.\n;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TTAB": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%o\\x00\\x19\\x00-\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-13T00:19:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: TTAB\n\nSyntax:   (TTAB arg1 &optional arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (optional, evaluated) - an output file name.\n\nReturns:\n\n A fixnum containing the sum of arg1 plus 1, which is used to update the\n current character pointer of the output file specified by arg2.\n\nProcessing:\n\n The ZPUTFPO function is invoked to update the current character\n pointer.  The value specified in the TTAB function is a zero-based\n offset, which is transformed into a 1-based column specification\n by the macro expansion.\n\n See ZPUTFPO for more information.\n\nErrors signaled:\n\n Errors detected by ZPUTFPO and ADD1 (q.v.).\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Use of an out-of-range value as the first argument may cause\n serious errors in the ZIL environment.  Do so with extreme caution.\n\n The following examples illustrate the macro expansion for TTAB:\n\n (TTAB 3 FILE) --> (ZPUTFPO 4 FILE)\n (TTAB N FILE) --> (ZPUTFPO (ADD1 N) FILE)\n\nExamples:\n\n (TTAB 0) and (TTAB 0 NIL) are equivalent, and permit the current\n             line of standard output to be overlaid with new data.\n\n (TTAB 9 'FOO)  sets the current column of output file FOO to 10.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYI": {"ttr": 7435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x19\\x7f\\x00\\x88\\x12O\\x084\\x00]\\x00@\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-07-16T00:00:00", "modifydate": "1988-05-03T08:34:00", "lines": 93, "newlines": 64, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TYI\n\nSyntax:   (TYI &optional file1 eofval2 newlineval3)\n\n file1 (optional, evaluated) - an input file name.\n eofval2 (optional, evaluated) - any LISP object.\n newlineval3 (optional, evaluated( - any LISP object.\n\nReturns:\n\n A fixnum representing a character read from file1, unless end of file\n is encountered on file1, in which case eofval2 is returned, or end of\n line is encountered on file1, in which case newlineval3 is returned.\n\nProcessing:\n\n The file specified by arg1 is read from the current character position\n and logical record (the ENDREAD and ZPUTFPI functions can change\n these).  The EBCDIC value of one character is returned as a fixnum,\n and the current character pointer is updated to point to the next\n character.\n\n If the end of a line is encountered while reading the file, then if the\n optional newlineval3 argument was specified, it is returned; if the\n newlineval3 argument has not been specified, an EBCDIC CR (hex 0D) is\n returned (i.e. fixnum 13).  NEWLINEP is also set to true for the file.\n In this case, the next call to TYI will return either the first\n character from the next line, or end-of-file (note that the end-of-file\n condition is always preceded by the end-of-line condition unless the\n file is empty).\n\n If end of file is encountered while reading the file, eofval2 is\n returned as the value.  If eofval2 was not specified, a fixnum -1 is\n returned.\n\n If the file is already in end-of-file status when TYI is issued,\n an error is signalled.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n READCH, READLINE, TYI and ZILRDCH are the only functions that can cause\n the \"newline\" indication to be set in an input file (see NEWLINEP).\n\n Currently, if TYI is issued against a file allocated to the terminal\n (including standard input) which has never been accessed by READ,\n READCH or TYI before, it will return an EBCDIC CR.  In other words, the\n first input from a terminal file is a \"newline\".\n\n Compare READCH, which returns a symbol.\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (progn\n  (with-open-file (file \"$$foo.$$test\" :out)\n   (format file \"~&?foobar~%\")\n  )\n  (setq foo (open \"$$foo.$$test\" :in))\n  t\n )                                  ==> T\n\n (TYI FOO 'EOF 'NEWLINE)     ==> NEWLINE\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\?\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\f\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\o\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\o\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\b\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\a\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\r\n\n (loop while (eql (tyipeek nil foo) #\\sp)\n       do (tyi foo)\n       finally (return t))   ==> T\n\n  ;\n  ; Now watch what happens when we get to a newline.\n  ;\n\n (TYI FOO)                   ==> #\\CR     ; Default newline.\n (TYI FOO)                   ==> -1       ; Default end-of-file.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "TYIPEEK": {"ttr": 7437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86&/\\x00\\x883_\\x14\\x17\\x00\\x88\\x00B\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-09-19T00:00:00", "modifydate": "1988-11-30T14:17:00", "lines": 136, "newlines": 66, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TYIPEEK\n\nSyntax:   (TYIPEEK &optional arg1 file2 eofval3 newlineval4)\n\n arg1  (optional, evaluated) - NIL, T or a fixnum between 0 and 255.\n file2 (optional, evaluated) - a file name.\n eofval3 (optional, evaluated) - any LISP object.\n newlineval4 (optional, evaluated) - any LISP object.\n\nReturns:\n\n A fixnum representing a character read from file2, unless end of file\n is encountered on file2, in which case eofval3 is returned; or end of\n line is encountered on file2, in which case newlineval4 is returned.\n\nProcessing:\n\n The file specified by file2 is read from the current character position\n and logical record (the ENDREAD and ZPUTFPI functions can change\n these).  One character is returned and made into a fixnum, but the\n current character pointer is NOT updated to point to the next\n character.  Thus, repeated calls to TYIPEEK without an intervening\n READ, READCH, TYI or ZILRDCH will return the same value.\n\n Whether this character is returned immediately or the scan continues\n for a \"wanted\" character is determined by arg1.  If arg1 is NIL,\n which is the default if it is omitted, the first-peeked-at character\n is returned.  If arg1 is T, \"whitespace\" characters (normally blank,\n newline and carriage return) are skipped over and the first\n non-whitespace character to be \"peeked\" at is returned.  If arg1 is\n a character (i.e. an integer between 0 and 255), characters are\n skipped until a character matching arg1 is found.\n\n If the end of a line is encountered while reading the file, then if the\n optional newlineval3 argument was specified, it is returned; if the\n newlineval3 argument has not been specified, an EBCDIC CR (hex 0D) is\n returned (i.e. fixnum 13) (unless arg1 is T or a character other\n than CR, in which case the CR is skipped and the next character read).\n\n If end of file is encountered while reading the file, eofval2 is\n returned as the value.  If eofval2 was not specified, a fixnum -1 is\n returned.  This applies no matter what the value of arg1 is.\n\n If the file is already in end-of-file status when TYI is issued,\n an error is signalled.\n\n Compare TYI, which is identical to TYIPEEK except that it updates\n the current character pointer (and also causes \"newline\" to be set).\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n TYIPEEK is designed for applications that need to do scanning in such\n a way as not to \"swallow up\" a character in the input stream.  It is,\n however, not perfect at this time, and its interaction with READ,\n READCH and UNTYI has not been thoroughly examined.\n\n A TYI following a TYIPEEK should return the same character that\n TYIPEEK did (in the EQL sense only).\n\n TYIPEEK does not set NEWLINEP; only READCH, READLINE, TYI and ZILRDCH\n do that.\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (progn\n  (with-open-file (file \"$$foo.$$test\" :out)\n   (format file \"~&?foobar a b c~%\")\n  )\n  (setq foo (open \"$$foo.$$test\" :in))\n  t\n )                                  ==> T\n\n (TYIPEEK NIL FOO 'EOF 'NEWLINE)    ==> NEWLINE\n\n (TYI FOO)                          ==> #\\CR ; swallow first newline\n (TYI FOO)                          ==> #\\?  ; prime for a character\n\n (SETQ A (TYIPEEK NIL FOO 'EOF 'NEWLINE)) ==> #\\f\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\f      ; Swallow the character.\n\n (SETQ A (TYIPEEK NIL FOO 'EOF 'NEWLINE)) ==> #\\o\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\o      ; Swallow the character.\n\n (SETQ A (TYIPEEK NIL FOO 'EOF 'NEWLINE)) ==> #\\o\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\o      ; Swallow the character.\n\n (SETQ A (TYIPEEK NIL FOO 'EOF 'NEWLINE)) ==> #\\b\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\b      ; Swallow the character.\n\n (SETQ A (TYIPEEK NIL FOO 'EOF 'NEWLINE)) ==> #\\a\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\a      ; Swallow the character.\n\n (SETQ A (TYIPEEK NIL FOO 'EOF 'NEWLINE)) ==> #\\r\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\r      ; Swallow the character.\n\n (SETQ A (TYIPEEK T FOO 'EOF 'NEWLINE))   ==> #\\a ; skip over blanks\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\a      ; Swallow the character.\n\n (SETQ A (TYIPEEK #\\c FOO 'EOF 'NEWLINE)) ==> #\\c ; skip until c\n (TYI FOO 'EOF 'NEWLINE)     ==> #\\c      ; Swallow the character.\n\n (loop while (eql (TYIPEEK NIL foo) #\\sp)\n       do (TYI foo)\n       finally (return t))   ==> T\n\n  ;\n  ; Now watch what happens when we get to a newline.\n  ;\n\n (TYIPEEK NIL FOO)           ==> #\\cr\n (TYIPEEK NIL FOO 'EOF)      ==> #\\cr\n (TYIPEEK NIL FOO 'EOF 'NEWLINE) ==> NEWLINE\n (TYI FOO 'EOF 'NEWLINE)     ==> NEWLINE  ; Swallow the character.\n (TYI FOO 'EOF 'NEWLINE)     ==> EOF      ; Read the next one.\n\n\n;\n; Unfortunately, there seems to be no way to get TYIPEEK NIL to return\n; EOF, due to problems with new-line-processing.\n;\n\n (TYIPEEK NIL FOO)           ==> (\"***ERROR***\") ; Read after EOF.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "TYO": {"ttr": 7439, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x11\\x9f\\x00\\x87%o\\x008\\x00*\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-04-29T00:00:00", "modifydate": "1987-09-13T00:38:00", "lines": 42, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TYO\n\nSyntax:   (TYO char1 &optional file2)\n\n char1 (required, evaluated) - a fixnum between 0 and 255.\n file2 (optional, evaluated) - an output file name.\n\nReturns:\n\n The EBCDIC value represented by char1, after it has been printed on\n file2.\n\nProcessing:\n\n char1 is output to the current character position on the current line\n of output file file2 (the TERPRI and ZPUTFPO functions can change\n these).\n\n The current character position is updated to point to the position\n immediately following the last character written.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n See member $PRINTER for more information on printing functions.\n\nExamples:\n\n (TYO #/A)\n (TYO 193 NIL)   are equivalent and return A after printing...\n\n                 A\n\n                 on the standard output file.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYPEP": {"ttr": 7441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86&/\\x00\\x87(o\\x17\\x19\\x00\\xb7\\x00\\x9e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-09-19T00:00:00", "modifydate": "1987-10-13T17:19:00", "lines": 183, "newlines": 158, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: TYPEP\n\nSyntax:   (TYPEP arg1 &optional arg2)\n\n arg1 (required,evaluated) - any LISP object.\n arg2 (optional,evaluated) - a type specifier (see below).\n\nReturns:\n\n If arg2 is omitted, a symbol identifying the type of arg1.\n If arg2 is specified, T if arg1 satisfies the type specification\n indicated by arg2, else NIL.\n\nProcessing:\n\n If arg2 is omitted, one of the following symbols is returned,\n depending on the type of arg1:\n\n  LIST, SYMBOL, FIXNUM, BIGNUM, SINGLE-FLOAT, DOUBLE-FLOAT, STRING,\n  VECTOR, SUBR, CLOSURE, FUNARG\n\n or:\n\n  if arg1 is an instance of a flavor, the name of the flavor is returned\n\n or:\n\n  if arg1 is a structure, then the type of the structure is returned\n  (i.e. the zeroth element), provided that this is a valid symbol.\n  If the structure type is not a valid symbol, STRUCT is returned.\n\n or:\n\n  if the type cannot be determined as one of the above, ATOM is returned.\n\n If arg2 is present, it must be a valid type specifier as follows:\n\n  *  A symbol.\n\n  *  A list in one of the following formats:\n\n     (OR type-specifier1 type-specifier2 ...)\n     (AND type-specifier1 type-specifier2 ...)\n     (NOT type-specifier)\n     (MEMBER object1 object2 ...)\n     (SATISFIES function-of-one-argument)\n\n TYPEP with two arguments will return T if:\n\n  * arg2 is one of the following and arg1 is an object of that type:\n\n      TYPEP arg2      Predicate to be satisfied\n   ______________________________________________________\n\n      ATOM                ATOM\n      LIST                LISTP\n      CONS                CONSP\n      SYMBOL              SYMBOLP\n      FIXNUM              FIXNUMP\n      FLOAT, FLONUM       FLOATP\n      FLOAT, FLONUM       FLOATP\n      SINGLE-FLOAT        SFLOATP\n      DOUBLE-FLOAT        DFLOATP\n      BIGNUM              BIGP\n      INTEGER             INTEGERP\n      STRING              STRINGP\n      VECTOR              VECTORP\n      CODE                CODEP\n      SUBR                SUBRP\n      CLOSURE             CLOSUREP\n      FUNARG              FUNARGP\n      STRUCT, STRUCTURE   STRUCTP\n\n  Note: For compatibility and convenience, the following are accepted:\n        SHORT-FLOAT for SINGLE-FLOAT\n        COMPILED-FUNCTION for CODE\n        DEFSTRUCT for STRUCT\n\n\n * arg1 is a structure of type arg2 (i.e. the zeroth element of arg1\n   is the symbol arg2)\n\n * arg2 is the symbol CHARACTER and arg1 is a fixnum between 0 and 255\n\n * arg1 is a list (NOT x) and (TYPEP arg1 x) is false\n\n * arg1 is a list (OR x1 x2 ... ) and (TYPEP arg1 xn) is true for ANY\n   of the xn's\n\n * arg1 is a list (AND x1 x2 ... ) and (TYPEP arg1 xn) is true for ALL\n   of the xn's\n\n * arg1 is a list (MEMBER x1 x2 ...) and arg1 is EQL to any of the\n   xn's (remember, these are not evaluated, since they are already\n   in an evaluated list)\n\n * arg1 is a list (SATISFIES x) and (FUNCALL x arg1) returns a non-NIL\n   value\n\n If arg1 is a list whose CAR is not one of the listed keywords,\n a warning message is issued and TYPEP returns NIL.\n\n\nErrors signaled:\n\n Invalid type specifier (not a symbol or a list).\n\nNotes:\n\n arg2 specified as NIL is NOT the same as omitting arg2.  A type\n specifier of NIL satisfies no type, and (TYPEP anything NIL) will\n always return NIL.  On the other hand, if arg2 is T then TYPEP will\n always return T, since all objects are assumed to satisfy type T.\n\nExamples:\n\n (TYPEP NIL)                        ==> SYMBOL\n (TYPEP 'A)                         ==> SYMBOL\n (TYPEP '(A B C))                   ==> LIST\n (TYPEP '(A . B))                   ==> LIST\n (TYPEP \"foo\")                      ==> STRING\n (TYPEP #(A B C))                   ==> VECTOR\n (TYPEP 1)                          ==> FIXNUM\n (TYPEP 1.0)                        ==> DOUBLE-FLOAT\n (TYPEP 1.0F0)                      ==> SINGLE-FLOAT\n (TYPEP 1.0D0)                      ==> DOUBLE-FLOAT\n (TYPEP 1000000000000000)           ==> BIGNUM\n (TYPEP (GET 'TYPEP 'SUBR))         ==> SUBR\n (TYPEP #'FOO)                      ==> FUNARG ; if interpreted\n                                  ; ==> CLOSURE ; if compiled\n (TYPEP (STRUCTURE 'A 'B 'C))       ==> A\n\n (TYPEP NIL 'SYMBOL)                ==> T\n (TYPEP NIL 'LIST)                  ==> T\n (TYPEP NIL 'CONS)                  ==> NIL\n (TYPEP NIL 'ATOM)                  ==> T\n (TYPEP NIL 'STRING)                ==> NIL\n (TYPEP 'A '(AND ATOM SYMBOL))      ==> T\n (TYPEP 'A '(AND SYMBOL FIXNUM))    ==> NIL\n (TYPEP 'A '(OR SYMBOL FIXNUM))     ==> T\n (TYPEP 'A '(OR FIXNUM FLONUM))     ==> NIL\n (TYPEP 'A '(OR FIXNUM FLONUM))     ==> NIL\n (TYPEP 'A '(NOT SYMBOL))           ==> NIL\n (TYPEP 'A '(NOT FIXNUM))           ==> T\n\n (TYPEP 1.0F0 'FLOAT)               ==> T\n (TYPEP 1.0F0 'SINGLE-FLOAT)        ==> T\n (TYPEP 1.0F0 'DOUBLE-FLOAT)        ==> NIL\n (TYPEP 1.0D0 'FLOAT)               ==> T\n (TYPEP 1.0D0 'SINGLE-FLOAT)        ==> NIL\n (TYPEP 1.0D0 'DOUBLE-FLOAT)        ==> T\n\n (DEFSTRUCT FOO BAR BAZ)            ==> FOO\n (SETQ A (MAKE-FOO))                ==> #.(STRUCTURE 'FOO NIL NIL)\n (TYPEP A)                          ==> FOO\n (TYPEP A 'FOO)                     ==> T\n (TYPEP A 'STRUCTURE)               ==> T\n\n (DEFFLAVOR SHIP () () )            ==> SHIP\n (PROGN\n  (SETQ A (MAKE-INSTANCE 'SHIP))\n  (TYPEP A)\n )                                  ==> SHIP\n (TYPEP A 'SHIP)                    ==> T\n (TYPEP A 'ZIL-FLAVOR-INSTANCE)     ==> T\n (TYPEP A 'STRUCTURE)               ==> T\n\n (TYPEP 0 '(AND FIXNUM INTEGER (NOT FLONUM)))   ==> T\n (TYPEP 0 '(MEMBER 0 1 2 3 4))      ==> T\n (TYPEP 0 '(SATISFIES ZEROP))       ==> T\n\n (TYPEP 0.0 '(AND FIXNUM INTEGER (NOT FLONUM)))   ==> NIL\n (TYPEP 0.0 '(MEMBER 0 1 2 3 4))    ==> NIL\n (TYPEP 0.0 '(SATISFIES ZEROP))     ==> T\n\n (TYPEP   0 'CHARACTER)             ==> T\n (TYPEP 255 'CHARACTER)             ==> T\n (TYPEP  -1 'CHARACTER)             ==> NIL\n (TYPEP 999 'CHARACTER)             ==> NIL\n (TYPEP \"a\" 'CHARACTER)             ==> NIL\n (TYPEP #\\a 'CHARACTER)             ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCONCAT": {"ttr": 7444, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x05\\x0f\\x00\\x87%\\x8f\\x077\\x003\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-19T00:00:00", "modifydate": "1987-09-15T07:37:00", "lines": 51, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UCONCAT\n\nSyntax:   (UCONCAT &rest args)\n\n arg (optional, evaluated) - any object that is not a list, vector,\n                             structure, or interpreted lexical closure.\n\nReturns:\n\n An uninterned symbol whose print name consists of args concatenated to\n form a new atom name.\n\nProcessing:\n\n The args are converted to the character representations that they have\n when printed via PRINC.  These are the actual print names for symbols,\n the text for strings, converted representations for numbers, and\n internally generated values for other types.  The resulting character\n strings are concatenated together to build a symbol whose name is that\n string.  The symbol is NOT interned on the oblist.\n\n If there are no args, a symbol with a null print name is returned.\n\nErrors signaled:\n\n List, vector, structure, or funarg found as one of the arguments.\n\nNotes:\n\n This is a Franz LISP function.\n Compare CONCAT, which is identical to UCONCAT except that it\n creates an interned symbol.\n\n Also compare ZILIMPL, which may be used to create numbers as well as\n interned or uninterned symbols; and STRING-APPEND, which builds\n strings rather than symbols.\n\nExamples:\n\n (UCONCAT)                  ==> ||\n (UCONCAT 'A)               ==> A\n (UCONCAT 'A 'B 1 'C \"D\")   ==> AB1CD\n (UCONCAT \"f\" \"o\" \"o\")      ==> |foo|\n (UCONCAT \"FOO\" 'BAR)       ==> FOOBAR\n (UCONCAT 007 1.0 \"foobar\") ==> |71.0foobar|\n\n (SETQ A (UCONCAT 'F 'O 'O))       ==> FOO\n (SETQ B (UCONCAT \"F\" \"O\" \"O\"))    ==> FOO\n (EQ A B)                          ==> NIL ; not interned.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCONCATL": {"ttr": 7446, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87$o\\x00\\x87$o\\x18\\x06\\x001\\x00;\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-03T00:00:00", "modifydate": "1987-09-03T18:06:00", "lines": 49, "newlines": 59, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UCONCATL\n\nSyntax:   (UCONCATL arg1)\n\n arg1 (required, evaluated) - a proper list of atoms.\n\nReturns:\n\n An uninterned symbol whose print name consists of the atoms in the list\n specified by arg1 concatenated to form a new atom name.\n\nProcessing:\n\n The CAR's of arg1, which must be a non-null list of atoms, are\n converted to the character representations that they have when printed\n via PRINC.  These are the actual print names for symbols, the text for\n strings, converted representations for numbers, and internally\n generated values for other types.  The resulting character strings are\n concatenated together to build an uninterned symbol whose name is that\n string.\n\n arg1 may be NIL, in which case a symbol with a null print name is\n returned.\n\nErrors signaled:\n\n arg1 not a list of atoms (nested lists and vectors are not permitted).\n\nNotes:\n\n Compare CONCATL, which is identical to UCONCATL except that it\n returns an interned symbol.\n\n (CONCATL x) is equivalent to (APPLY #'CONCAT x), but more efficient.\n\n (UCONCATL x) is equivalent to (APPLY #'UCONCAT x), but more efficient.\n\n\nExamples:\n\n (UCONCATL '(A))                 ==> A\n (UCONCATL '(F O O))             ==> FOO\n (UCONCATL '(FOO BAR))           ==> FOOBAR\n (UCONCATL '(007 1.0 \"foobar\"))  ==> |71.0foobar| ; A symbol.\n\n (SETQ A (UCONCATL '(F O O)))    ==> FOO ; uninterned.\n (EQ A 'FOO)                     ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNEBCDIC": {"ttr": 7448, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x078\\x00#\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T07:38:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UNEBCDIC\n\nSyntax:   (UNEBCDIC arg1)\n\n arg1 (required, evaluated) - a string or symbol whose text or print\n                              name is 1 character.\n\nReturns:\n\n A fixnum representing the EBCDIC value of the single-character atom\n specified by arg1.\n\nProcessing:\n\n The character representation of arg1, which should be a symbol or\n string, is used to construct the fixnum which is its EBCDIC value.\n\nErrors signaled:\n\n First argument not a string or symbol of 1 character.\n\nNotes:\n\n Compare EBCDIC, which does the reverse.  Note, however, that\n (UNEBCDIC (EBCDIC x)) does NOT return x if the value of x is not\n between 0 and 255.\n\nExamples:\n\n (UNEBCDIC 'A)        ==> 193\n (UNEBCDIC '|a|)      ==> 129\n (UNEBCDIC \"a\")       ==> 129\n (UNEBCDIC '\\\\)       ==> 224\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNION": {"ttr": 7450, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x078\\x00*\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T07:38:00", "lines": 42, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UNION\n\nSyntax:   (UNION arg1 arg2)\n\n arg1 (required, evaluated) - a proper list.\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n A list containing all the elements of both arguments.\n\nProcessing:\n\n A new list is constructed from the elements of the two arguments;\n if an element occurs once in each list argument, it will occur\n once in the result.  No other guarantee is given with respect\n to the order of the elements, or how many times a given element\n will occur if it occurs more than once in one of the input lists.\n\n The equality test is EQL.  Compare UNIONQ, which uses an EQ test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.\n Unpredictable results will occur if the first and second arguments\n are not proper lists.\n\nExamples:\n\n (UNION NIL NIL)                   ==> NIL\n (UNION NIL '(A B C))              ==> (A B C)\n (UNION '(A B C) NIL)              ==> (A B C)\n (UNION '(A B C) '(D E F))         ==> (A B C D E F)\n (UNION '(A B C D E) '(A E I O U)) ==> (B C D A E I O U)\n (UNION '(1.0 2.0 3.0 4.0) '(2.0 4.0 6.0 8.0))\n                                   ==> (1.0 3.0 2.0 4.0 6.0 8.0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNIONQ": {"ttr": 7452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x079\\x00*\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T07:39:00", "lines": 42, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UNIONQ\n\nSyntax:   (UNIONQ arg1 arg2)\n\n arg1 (required, evaluated) - a proper list.\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n A list containing all the elements of both arguments.\n\nProcessing:\n\n A new list is constructed from the elements of the two arguments;\n if an element occurs once in each list argument, it will occur\n once in the result.  No other guarantee is given with respect\n to the order of the elements, or how many times a given element\n will occur if it occurs more than once in one of the input lists.\n\n The equality test is EQ.  Compare UNION, which uses an EQL test.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n No checking is done as to the validity of the arguments.\n Unpredictable results will occur if the first and second arguments\n are not proper lists.\n\nExamples:\n\n (UNIONQ NIL NIL)                   ==> NIL\n (UNIONQ NIL '(A B C))              ==> (A B C)\n (UNIONQ '(A B C) NIL)              ==> (A B C)\n (UNIONQ '(A B C) '(D E F))         ==> (A B C D E F)\n (UNIONQ '(A B C D E) '(A E I O U)) ==> (B C D A E I O U)\n (UNIONQ '(1.0 2.0 3.0 4.0) '(2.0 4.0 6.0 8.0))\n                 ==> (1.0 2.0 3.0 4.0 2.0 4.0 6.0 8.0) ; Test is EQ.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNKWDIFY": {"ttr": 7454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x0f\\x00\\x88\\x12O\\x08\\x08\\x00&\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1988-05-03T08:08:00", "lines": 38, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UNKEYWORDIFY\n\nSyntax:   (UNKEYWORDIFY arg1)\n    or:   (UNKWDIFY arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n A symbol whose print name is equal to the print name of\n arg1 minus the leading colon (\":\") if any.\n\nProcessing:\n\n If arg1 is not a \"keyword\", itself is returned.  Otherwise,\n an interned symbol is created whose print name is equal to\n the print name of arg1 without the initial colon.\n\nErrors signaled:\n\n arg1 not a symbol.\n\nNotes:\n\n Since ZIL 1.3 does not have a package system, it does not have true\n Common Lisp \"keywords\".  However, any symbol with a print name starting\n with a colon is treated as a \"keyword\" in ZIL.  Such symbols evaluate\n to themselves and cannot be used as lambda list arguments.\n\nExamples:\n\n (UNKEYWORDIFY 'A)         ==> A\n (UNKEYWORDIFY ':B)        ==> B\n (UNKEYWORDIFY '|:|)       ==> ||\n (UNKEYWORDIFY ':TEST)     ==> TEST\n (UNKEYWORDIFY 'TEST)      ==> TEST\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNLESS": {"ttr": 7456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%\\x8f\\x07@\\x00\"\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-15T07:40:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: UNLESS\n\nSyntax:   (UNLESS arg1 &rest args)\n\n arg1 (required, evaluated) - any LISP object.\n argn (optional, evaluated) - any LISP object.\n\nReturns:\n\n If arg1 evaluates to NIL, the last of the args; otherwise, NIL.\n\nProcessing:\n\n If arg1 evaluates to NIL, the rest of the arguments are evaluated as an\n implicit PROGN, returning the last of them.  Otherwise processing\n terminates and NIL is returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare WHEN, which does the reverse test.\n\nExamples:\n\n (UNLESS (F)\n       (PRINT 'A)\n       (PRINT 'B)\n       'FOO)       if (F) returns other than NIL, returns NIL;\n                   if (F) returns NIL, prints A and B and returns FOO.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNTRACE": {"ttr": 7682, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x07A\\x00)\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T07:41:00", "lines": 41, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: UNTRACE\n\nSyntax:   (UNTRACE &rest funs)\n\n fun (optional, not evaluated) - zero or more function names (symbols).\n\nReturns:\n\n funs, after tracing has been deactivated for the functions named in the\n list, or for all functions if no operands are specified.\n\nProcessing:\n\n If no funs are specified, tracing is deactivated for all function\n names.  Otherwise, tracing is deactivated for each function name in\n this list.\n\n The function TRACE is used to activate function tracing.\n\nErrors signaled:\n\n One of the funs not a symbol.\n\nNotes:\n\n See member $TRACE of this document for a description of tracing and\n what kinds of functions can be traced.\n\n See ZILTRACE for technical details on how tracing and untracing\n are effected.\n\nExamples:\n\n (UNTRACE) will deactivate tracing for all functions in the\n           interpretive environment.\n\n (UNTRACE FOO)    deactivates tracing for function FOO.\n\n (UNTRACE CAR CDR CONS) deactivates tracing for CAR, CDR, and CONS.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNTYI": {"ttr": 7684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\x10G\\x00K\\x00K\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T10:47:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UNTYI\n\nSyntax:   (UNTYI char &optional file1 eofval2 newlineval3)\n\n char  (required, evaluated) - a fixnum between 0 and 255.\n file1 (optional, evaluated) - an input file name.\n eofval2 (optional, evaluated) - any LISP object.\n newlineval3 (optional, evaluated( - any LISP object.\n\nReturns:\n\n A fixnum representing the character most recently read (via TYI or\n TYIPEEK) from file1, unless end of file was encountered on file1, in\n which case eofval2 is returned, or end of line was encountered on\n file1, in which case newlineval3 is returned.\n\nProcessing:\n\n The character most recently read by TYI or TYIPEEK from the input\n file specified by file1 is returned.  No I/O is done to that file.\n\n The next invocation of TYI or TYIPEEK will return the character\n \"unread\" by UNTYI, as if it had been magically placed back in the file.\n\n UNTYI can \"unread\" at most one character.  If UNTYI is invoked twice in\n succession without an intervening TYI or TYIPEEK, an error is\n signalled.\n\n The (required) character argument is used as a check to insure that\n you are \"unreading\" the character you think you are.  If the character\n does not match the most recently read one, an error is signalled.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Invalid character argument.\n UNTYI called out of sequence (see above).\n\nNotes:\n\n See member $FILE for more information on file names.\n\n The interaction between TYI and UNTYI is well defined, but the         se\n interaction between TYIPEEK and UNTYI is not.  Use at your own risk.\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (progn\n  (with-open-file (file \"$$foo.$$test\" :out)\n   (format file \"~&?foobar~%\")\n  )\n  (setq foo (open \"$$foo.$$test\" :in))\n  t\n )                                  ==> T\n\n (defun test-untyi (file &aux a)\n  (list (setq a (tyi file 'eof 'newline))\n        (untyi a file 'eof 'newline)\n        (tyi file 'eof 'newline)))  ==> TEST-UNTYI\n\n (TEST-UNTYI FOO)          ==> (NEWLINE NEWLINE NEWLINE)\n (TEST-UNTYI FOO)          ==> (#\\? #\\? #\\?)\n (TEST-UNTYI FOO)          ==> (#\\f #\\f #\\f)\n (TEST-UNTYI FOO)          ==> (#\\o #\\o #\\o)\n (TEST-UNTYI FOO)          ==> (#\\o #\\o #\\o)\n (TEST-UNTYI FOO)          ==> (#\\b #\\b #\\b)\n (TEST-UNTYI FOO)          ==> (#\\a #\\a #\\a)\n (TEST-UNTYI FOO)          ==> (#\\r #\\r #\\r)\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "UNWIND": {"ttr": 7686, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x86\\x06/\\x00\\x88\\t\\x9f\\x08X\\x00;\\x00E\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1986-03-03T00:00:00", "modifydate": "1988-04-08T08:58:00", "lines": 59, "newlines": 69, "modlines": 0, "user": "SEB1525"}, "text": "\nSpecial Form: UNWIND-PROTECT\n\nSyntax:   (UNWIND-PROTECT protected-form &rest cleanup-forms)\n\n protected-form (required, evaluated) - any LISP object.\n cleanup-forms (evaluated) - any LISP object.\n\n At least 1 cleanup-form is required.\n\nReturns:\n\n The result of evaluating protected-form, unless a THROW (or error)\n occurs during its evaluation, in which case the value returned by\n the THROW (NIL if an error) is returned.\n\nProcessing:\n\n protected-form is evaluated first.  An UNWIND-PROTECT frame is created\n and protected-form is evaluated; the frame is then deactivated\n (though it remains on the stack) and the cleanup-forms are evaluated.\n If during the evaluation of the protected form a non-local exit of any\n kind occurs that causes the evaluation of the protected form to abort\n (this includes THROW, GO, RETURN, and errors), the cleanup forms are\n still executed, but the returning of the value, if any, takes place as\n if there otherwise had been no enclosing UNWIND-PROTECT.\n\n The UNWIND-PROTECT frame stacked by UNWIND-PROTECT is removed when the\n evaluation of the protected form is complete (or when a non-local exit\n occurs).  This frame is used to store the current state of the ZIL\n environment, including the current variable binding environment; thus,\n variable bindings are restored to the status they possessed upon entry\n to the UNWIND-PROTECTed code.\n\nErrors signaled:\n\n Invalid syntax (too few arguments to UNWIND-PROTECT).\n\nNotes:\n\n See CATCH and THROW for more information.\n\n UNWIND-PROTECT is used when a function must restore an environment\n or perform otherwise essential code that cannot be skipped even if\n an error should occur.  See a Common LISP or other manual for more\n information on the usefulness of UNWIND-PROTECT.\n\n GO or RETURN may be issued from within the protected form or the\n cleanup form to outside the UNWIND-PROTECT, if there is a PROG which\n will process it.\n\nExamples:\n\n (UNWIND-PROTECT 'A 'B) ==> A ; Trivial case.\n\n (CATCH 'FOO\n   (UNWIND-PROTECT (THROW 'FOO 'BAR) (PRINT \"FROB\"))) ==> BAR\n  ; after FROB is printed.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNWORD": {"ttr": 7688, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%\\x8f\\x07E\\x00\\x1c\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-15T07:45:00", "lines": 28, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: UNWORD\n\nSyntax:   (UNWORD arg1)\n\n arg1 (required, evaluated) - a 4-character string or symbol.\n\nReturns:\n\n A fixnum whose value is the EBCDIC contents of arg1.\n\nProcessing:\n\n The print name or text of arg1 is interpreted as 4 EBCDIC bytes and\n loaded as a fixnum.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare WORD, which performs the reverse operation.\n\nExamples:\n\n (UNWORD \"    \")          ==> #z\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UPCASE": {"ttr": 7690, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x07o\\x00\\x87%\\x8f\\x07F\\x00&\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-17T00:00:00", "modifydate": "1987-09-15T07:46:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-UPCASE\n\nSyntax:   (STRING-UPCASE string1)\n    or:   (UPCASE string1)\n\n string1 (required, evaluated) - a string.\n\nReturns:\n\n A string identical to string1, except that all lower-case\n alphabetic characters are replaced with their upper-case equivalents.\n\nProcessing:\n\n The input argument is not altered.\n\n As with most string-handling functions, symbols are acceptable.\n However, the returned value is always a string.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Insufficient vector/string space to build the result.\n\nNotes:\n\n Compare STRING-DOWNCASE.\n\nExamples:\n\n (STRING-UPCASE \"\")          ==> \"\"\n (STRING-UPCASE \"a\")         ==> \"A\"\n (STRING-UPCASE \"A\")         ==> \"A\"\n (STRING-UPCASE \"foo\")       ==> \"FOO\"\n (STRING-UPCASE NIL)         ==> \"NIL\"\n (STRING-UPCASE '|Foo Bar|)  ==> \"FOO BAR\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USERID": {"ttr": 7692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\"\\x7f\\x00\\x87%\\x8f\\x08$\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-08-15T00:00:00", "modifydate": "1987-09-15T08:24:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: USERID\n\nSyntax:   (USERID)\n\nReturns:\n\n A string containing your TSO userid or NIL if not in a TSO environment.\n\nProcessing:\n\n In foreground, or in TSO in batch, a string whose contents are your\n TSO userid that you logon with (in batch, this may return a null\n string or the userid under which you submitted the job, depending on\n the system).  In background other than TSO batch, USERID returns NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare PREFIX, which returns the TSO dataset prefix.\n\nExamples:\n;\n;(USERID)  ==>  \"ABC1234\"    -   if ABC1234 is logged on\n;\n;(USERID)  ==>  NIL          -   if running ZIL in batch.\n;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VALUES": {"ttr": 7694, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x7f\\x00\\x88\\x16\\x7f\\x08\\x07\\x00D\\x00D\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-15T00:00:00", "modifydate": "1988-06-15T08:07:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VALUES\n\nSyntax:   (VALUES &rest args)\n\n Any number of arguments may be specified.\n\n arg (evaluated) - any LISP object.\n\nReturns:\n\n The values specified by the arguments, as multiple values.  If\n multiple values are not being requested, the first argument is\n returned, or NIL if no arguments are specified.\n\nProcessing:\n\n If multiple values are being requested by a special form (like\n MULTIPLE-VALUE-LIST or MULTIPLE-VALUE-BIND, for example) that directly\n or indirectly calls VALUES, and the call to VALUES is in tail-recursive\n (value-returning) position, then all of the arguments to VALUES are\n returned as multiple values - or, more accurately, as many values as\n are being requested are returned.\n\n If there is no request for multiple values at the time that VALUES is\n executed, or if VALUES is being executed in other than tail-recursive\n position (e.g. as an argument to a function, as a predicate, or to set\n a variable to a value), then the value returned is the first of the\n arguments.  If there are no arguments, NIL is returned as a single\n value (zero values would be returned as multiple values).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare VALUES-LIST (VALUESL), which returns all the elements of\n an existing list as multiple values.\n\n See Guy Steele's \"Common LISP: The Language\", pp. 133-139, for\n an explanation of multiple values in LISP.  Although the constant\n MULTIPLE-VALUES-LIMIT is not defined in ZIL, returning more than\n 4095 multiple values is not supported.\n\n (VALUES form), with one argument, is equivalent to specifying form\n by itself, except that in value-returning position it forces the\n return of a single value; this is useful in cases where form is\n a call to a function that normally returns more than one value\n but you want to return exactly one value only.\n\n In many cases, use of multiple values in ZIL is more expensive than\n just consing up a list of the values and extracting the values from\n the list via destructuring.  In any case, out of all the forms that\n request multiple values, only MULTIPLE-VALUE-BIND in compiled code\n is guaranteed not to cons in ZIL.\n\nExamples:\n\n (VALUES)               ==> NIL\n (VALUES 'A)            ==> A\n (VALUES 'A 'B)         ==> A\n (VALUES 'A 'B 'C)      ==> A\n (MULTIPLE-VALUE-LIST (VALUES))           ==> NIL\n (MULTIPLE-VALUE-LIST (VALUES 1))         ==> (1)\n (MULTIPLE-VALUE-LIST (VALUES 1 2))       ==> (1 2)\n (MULTIPLE-VALUE-LIST (VALUES 1 2 3))     ==> (1 2 3)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VALUESL": {"ttr": 7696, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x16\\x7f\\x00\\x88\\x16\\x7f\\x08\\x13\\x00=\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-15T00:00:00", "modifydate": "1988-06-15T08:13:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VALUES-LIST\n\nSyntax:   (VALUES-LIST list1)\n    or:   (VALUESL     list1)\n\n list (required, evaluated) - a proper list.\n\nReturns:\n\n The values specified by the elements of list1, as multiple values.  If\n multiple values are not being requested, the CAR of list1 is returned,\n or NIL if list1 is NIL.\n\nProcessing:\n\n If multiple values are being requested by a special form (like\n MULTIPLE-VALUE-LIST or MULTIPLE-VALUE-BIND, for example) that directly\n or indirectly calls VALUES-LIST, and the call to VALUES-LIST is in\n tail-recursive (value-returning) position, then all of the elements of\n list1 are returned as multiple values - or, more accurately, as many\n values as are being requested are returned.\n\n If there is no request for multiple values at the time that VALUES-LIST\n is executed, or if VALUES-LIST is being executed in other than\n tail-recursive position (e.g. as an argument to a function, as a\n predicate, or to set a variable to a value), then the value returned is\n the first element (CAR) of list1.  If list1 is NIL, NIL is returned as\n a single value (zero values would be returned as multiple values).\n\nErrors signaled:\n\n list1 not a proper list.\n\nNotes:\n\n Compare VALUES, which returns all of its arguments as multiple values.\n (VALUES-LIST list) is equivalent to (APPLY #'VALUES list).\n\n See Guy Steele's \"Common LISP: The Language\", pp. 133-139, for\n an explanation of multiple values in LISP.  Although the constant\n MULTIPLE-VALUES-LIMIT is not defined in ZIL, returning more than\n 4095 multiple values is not supported.\n\n In many cases, use of multiple values in ZIL is more expensive than\n just consing up a list of the values and extracting the values from\n the list via destructuring.  In any case, out of all the forms that\n request multiple values, only MULTIPLE-VALUE-BIND in compiled code\n is guaranteed not to cons in ZIL.\n\nExamples:\n\n (VALUES-LIST NIL)      ==> NIL\n (VALUES-LIST '(A))     ==> A\n (VALUES-LIST '(A B))   ==> A\n (VALUES-LIST '(A B C)) ==> A\n (MULTIPLE-VALUE-LIST (VALUES-LIST NIL))       ==> NIL\n (MULTIPLE-VALUE-LIST (VALUES-LIST '(1)))      ==> (1)\n (MULTIPLE-VALUE-LIST (VALUES-LIST '(1 2)))    ==> (1 2)\n (MULTIPLE-VALUE-LIST (VALUES-LIST '(1 2 3)))  ==> (1 2 3)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VCOPY": {"ttr": 7698, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x01?\\x00\\x88\\x01?\\x08I\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-01-13T00:00:00", "modifydate": "1988-01-13T08:49:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VCOPY\n\nSyntax:   (VCOPY arg1)\n\n arg1 (required, evaluated) - a vector-type object.\n\nReturns:\n\n A vector-type object of the same type, size and elements of arg1.\n\nProcessing:\n\n An exact copy is made of arg1.\n\nErrors signaled:\n\n Argument not a vector-type object (does not satisfy VECP).\n\nNotes:\n\n A \"vector-type object\" is an object composed of contiguous instances\n of other LISP objects.  In ZIL, vectors, structures and funargs\n (interpreted lexical closures) are vector-type objects that satisfy\n the predicate VECP.\n\nExamples:\n\n (VCOPY #(FOO BAR BAZ))       ==> #(FOO BAR BAZ)\n (VCOPY #())                  ==> #()\n (VCOPY (STRUCTURE 'A 'B 'C)) ==> #.(STRUCTURE 'A 'B 'C)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VECP": {"ttr": 7700, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86&/\\x00\\x87%\\x8f\\x17\\x03\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-09-19T00:00:00", "modifydate": "1987-09-15T17:03:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VECP\n\nSyntax:   (VECP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a vector-type object, otherwise NIL.\n\nProcessing:\n\n A \"vector-type object\" is an object which is composed of contiguous\n instances of other LISP objects; i.e. an object on which it is\n valid to do operations like VREF and VSET.\n\n In ZIL, vectors, structures, and funargs (interpreted lexical\n closures) are all VECP.\n\nErrors signaled:\n\n None.\n\nNotes:\nExamples:\n\n (VECP '(A B C))              ==> NIL\n (VECP #(A B C))              ==> T\n (VECP (STRUCTURE 'A 'B 'C))  ==> T\n (VECP #'FOO)                 ==> T ; if interpreted; NIL if compiled\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VECTOR": {"ttr": 7702, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17\\x04\\x00)\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:04:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VECTOR\n\nSyntax:   (VECTOR &rest args)\n\n Any number of arguments may be specified.\n\n arg (evaluated) - any LISP object.\n\nReturns:\n\n A vector #(arg1 arg2 ... argn).\n\nProcessing:\n\n A new vector is built, of length equal to the number of elements\n specified, and the elements are initialized to the specified values.\n\nErrors signaled:\n\n Not enough vector space to build vector.\n\nNotes:\n\n (VECTOR 'a 'b 'c) is equivalent to #(a b c) in the interpretive\n environment, but in the compiled environment the former builds a new\n vector from the specified elements each time it is executed, while the\n latter is not supported by the compiler (at least not at this time).\n Since vectors may be modified during execution of the program, you\n MUST use VECTOR or MKVECTOR to build then dynamically from compiled\n functions.\n\nExamples:\n\n (VECTOR)               ==> #()\n (VECTOR NIL)           ==> #(NIL)\n (VECTOR 'A)            ==> #(A)\n (VECTOR 'A 'B)         ==> #(A B)\n (VECTOR '(A B) 'C)     ==> #((A B) C)\n (VECTOR 1 2 3 4 5 6 7) ==> #(1 2 3 4 5 6 7)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VECTORP": {"ttr": 7704, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17\\x04\\x00\\x1f\\x00\\x18\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:04:00", "lines": 31, "newlines": 24, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VECTORP\n\nSyntax:   (VECTORP arg1)\n\n arg1 (required,evaluated) - any LISP object.\n\nReturns:\n\n T if arg1 is a vector, otherwise NIL.\n\nProcessing:\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Only true vectors are VECTORP.\n Compare VECP, which is true of any vector-type object in ZIL.\n\nExamples:\n\n (VECTORP '(A B C))             ==> NIL\n (VECTORP #(A B C))             ==> T\n (VECTORP (MKVECTOR 10))        ==> T\n (VECTORP (STRUCTURE 'A 'B 'C)) ==> NIL\n (VECTORP #'FOO)                ==> NIL\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VERIFY": {"ttr": 7706, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x07\\x8f\\x00\\x87%\\x8f\\x17\\x04\\x00V\\x00U\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-19T00:00:00", "modifydate": "1987-09-15T17:04:00", "lines": 86, "newlines": 85, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-VERIFY\n\nSyntax: (STRING-VERIFY string1 string2 &optional index3)\n    or:        (VERIFY string1 string2 &optional index3)\n\n string1 (required, evaluated) - a string.\n string2 (required, evaluated) - a string.\n index3 (optional, evaluated) - a positive fixnum.\n\nReturns:\n\n The one-based index of the first character within string1 that\n does not match any of the characters in string2, with the search\n starting from location index3, or from the beginning of string1 if\n index3 is omitted); NIL if all the characters of string1 are found\n in string2.\n\nProcessing:\n\n One-based indexing is used.\n\n String1 is searched from either the beginning (if index3 is omitted,\n i.e. defaults to 1) or the offset specified by index3; when a\n character is found in string1 that is not a member of the set of\n characters contained in string2 (in a case-sensitive character\n comparison), the one-based offset of that character within string1\n is returned.  If string1 does not contain any characters that are\n absent from string2, NIL is returned.\n\n If string1 is the null string, NIL is always returned, as there are,\n trivially, no non-matching characters in string1.\n\n If string2 is the null string, 1 is always returned, as, trivially,\n none of the characters of string1 are found in string2.\n\n The offset is always relative to the beginning of the entire string1,\n even when index3 is specified.\n\n As with most string-handling functions, symbols are acceptable for\n either of the first 2 arguments.\n\nErrors signaled:\n\n Invalid first argument (not a string).\n Invalid second argument (not a string).\n Invalid third argument (not a positive fixnum).\n\nNotes:\n\n This function is analogous to the PL/1 VERIFY function; the optional\n third argument, while not present in PL/1, is analogous to a similar\n argument for INDEX (q.v.).\n\n The second arg may be thought of as a specification of a table of\n \"valid\" characters, and the result as the index of the first \"bad\"\n character in the string.  Thus, VERIFY is useful in checking that\n a string is all alphabetic, numeric, etc.  Alternatively, it may\n be used to skip over leading whitespace characters, etc. in a\n string to get to the first \"significant\" character.\n\n Specifying the third arg is NOT equivalent to specifying a SUBSTR\n as the second arg.  Observe the examples.  This feature may be\n useful in parsing a string into a sequence of tokens.\n\nExamples:\n\n (VERIFY \"\" \"non-null-string\")  ==> NIL\n (VERIFY \"\" \"\")                 ==> NIL\n (VERIFY \"any-string\" \"\")       ==> 1     ; All characters \"bad\".\n (VERIFY \"foobar\" \"abfor\")      ==> NIL\n (VERIFY \"foobar\" \"abfo\")       ==> 6     ; Stopped at \"r\".\n (VERIFY \"foobar\" \"abor\")       ==> 1     ; Stopped at \"f\".\n (VERIFY \" foobar\" \" \")         ==> 2\n\n; The following examples show that (VERIFY x y z) is NOT the same as\n; (VERIFY (SUBSTR x z) y).\n\n (VERIFY \"123X456\" \"123456789\" 3)          ==> 4\n (VERIFY (SUBSTR \"123X456\" 3) \"123456789\") ==> 2\n\n (VERIFY \"foobar\" \"abfr\" 1)        ==> 2     ; Search \"foobar\".\n (VERIFY \"foobar\" \"abfr\" 2)        ==> 2     ; Search  \"oobar\" only.\n (VERIFY \"foobar\" \"abfr\" 3)        ==> 3     ; Search   \"obar\" only.\n (VERIFY \"foobar\" \"abfr\" 4)        ==> NIL   ; Search    \"bar\" only.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VFILL": {"ttr": 7708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x8f\\x00\\x87%\\x8f\\x17\\x05\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-27T00:00:00", "modifydate": "1987-09-15T17:05:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VFILL\n\nSyntax:   (VFILL arg1 arg2)\n\n arg1 (required, evaluated) - a vector.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n arg1, with all of its elements set to arg2.\n\nProcessing:\n\n All of the elements of the vector arg1 are set to arg2.\n\n If the vector is of length zero, nothing is done to it.\n\nErrors signaled:\n\n Argument 1 not a vector.\n\nNotes:\n\nExamples:\n\n (VFILL #() 'FOO)           ==> #()\n (VFILL #(A) 'FOO)          ==> #(FOO)\n (VFILL #(A B C) 'FOO)      ==> #(FOO FOO FOO)\n (VFILL #(A B C) '(1 2 3))  ==>  #((1 2 3) (1 2 3) (1 2 3))\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VLENGTH": {"ttr": 7710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87%\\x8f\\x00\\x87%\\x8f\\x17\\x05\\x00&\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-15T00:00:00", "modifydate": "1987-09-15T17:05:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VLENGTH\n\nSyntax:   (VLENGTH arg1)\n\n arg1 (required, evaluated) - a vector-type object.\n\nReturns:\n\n An integer containing the number of elements in the vector\n specified by arg1; i.e. the length of the vector.\n\nProcessing:\n\n The length of the vector (a vector is conceptually the same as\n a one-dimensional array) is returned as an integer.\n\nErrors signaled:\n\n Argument not a vector-type object (does not satisfy VECP).\n\nNotes:\n\n This function was formerly known as VDIM, which name is still\n available for compatibility.\n\n A \"vector-type object\" is an object composed of contiguous instances\n of other LISP objects.  In ZIL, vectors, structures and funargs\n (interpreted lexical closures) are vector-type objects that satisfy\n the predicate VECP.\n\nExamples:\n\n (VLENGTH #(FOO BAR BAZ))       ==> 3\n (VLENGTH #())                  ==> 0\n (VLENGTH (MKVECTOR 10))        ==> 10\n (VLENGTH (STRUCTURE 'A 'B 'C)) ==> 3\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VLIST": {"ttr": 7712, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x17\\x8f\\x00\\x87%\\x8f\\x17\\x05\\x00!\\x00\\x1b\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-06-27T00:00:00", "modifydate": "1987-09-15T17:05:00", "lines": 33, "newlines": 27, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VLIST\n\nSyntax:   (VLIST arg1)\n\n arg1 (required, evaluated) - a vector-type object.\n\nReturns:\n\n A list containing the elements of the vector specified by arg1.\n\nProcessing:\n\n A list is built by repeated CONSing of the elements of arg1.\n\nErrors signaled:\n\n Argument not a vector-type object (does not satisfy VECP).\n\nNotes:\n\n A \"vector-type object\" is an object composed of contiguous instances\n of other LISP objects.  In ZIL, vectors, structures and funargs\n (interpreted lexical closures) are vector-type objects that satisfy\n the predicate VECP.\n\nExamples:\n\n (VLIST #(FOO BAR BAZ))  ==> (FOO BAR BAZ)\n (VLIST #())             ==> NIL\n (VLIST (MKVECTOR 10))   ==> (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)\n (VLIST (STRUCTURE 'A 'B 'C)) ==> (A B C)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VREF": {"ttr": 7714, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17\\x07\\x006\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:07:00", "lines": 54, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VREF\n\nSyntax:   (VREF vector1 index2)\n\n vector1 (required, evaluated) - a vector-type object.\n index2  (required, evaluated) - a fixnum.\n\nReturns:\n\n The index2'th element of vector1.\n\nProcessing:\n\n index2 is used as an index into vector1, where the elements of the\n vector are indexed from zero to the length minus 1.\n\n VSET is used to set values in the vector.\n\nErrors signaled:\n\n Invalid first argument (not a vector-type object).\n Invalid second argument (not a fixnum).\n Index out of range (negative or greater than the maximum index for\n the vector, which is the length minus 1).\n\nNotes:\n\n A \"vector-type object\" is an object composed of contiguous instances\n of other LISP objects.  In ZIL, vectors, structures and funargs\n (interpreted lexical closures) are vector-type objects that satisfy\n the predicate VECP.\n\nExamples:\n\n (SETQ V (MKVECTOR 5))    ==> #(NIL NIL NIL NIL NIL)\n (VSET V 0 'FOO)          ==> FOO\n (VSET V 1 'BAR)          ==> BAR\n (VSET V 2 'BAZ)          ==> BAZ\n (VSET V 3 'FROB)         ==> FROB\n V                        ==> #(FOO BAR BAZ FROB NIL)\n (VREF V 0)               ==> FOO\n (VREF V 1)               ==> BAR\n (VREF V 4)               ==> NIL\n;(VREF V 5) is an error.\n\n; VREF may also be used to extract elements of structures.  However,\n; use of the macros defined by DEFSTRUCT is preferred.  To extract\n; the type (element 0) of the structure, use TYPEP.\n\n (VREF (STRUCTURE 'A 'B 'C) 0)   ==> A\n (VREF (STRUCTURE 'A 'B 'C) 1)   ==> B\n (VREF (STRUCTURE 'A 'B 'C) 2)   ==> C\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSET": {"ttr": 7716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17\\x07\\x002\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:07:00", "lines": 50, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VSET\n\nSyntax:   (VSET vector1 index2 arg3)\n\n vector1 (required, evaluated) - a vector-type object.\n index2  (required, evaluated) - a fixnum.\n arg3    (required, evaluated) - any LISP object.\n\nReturns:\n\n arg3, after setting the index2'th element of vector1 to its value.\n\nProcessing:\n\n index2 is used as an index into vector1, where the elements of the\n vector are indexed from zero to the length minus 1.  arg3 replaces\n the corresponding value in the vector.\n\n VREF is used to retrieve values from the vector.\n\nErrors signaled:\n\n Invalid first argument (not a vector-type object).\n Invalid second argument (not a fixnum).\n Index out of range (negative or greater than the maximum index for\n the vector, which is the length minus 1).\n\nNotes:\n\n SETF can be used with VREF to perform the same function.\n\n A \"vector-type object\" is an object composed of contiguous instances\n of other LISP objects.  In ZIL, vectors, structures and funargs\n (interpreted lexical closures) are vector-type objects that satisfy\n the predicate VECP.\n\nExamples:\n\n (SETQ V (MKVECTOR 5))    ==> #(NIL NIL NIL NIL NIL)\n (VSET V 0 'FOO)          ==> FOO\n (VSET V 1 'BAR)          ==> BAR\n (VSET V 2 'BAZ)          ==> BAZ\n (VSET V 3 'FROB)         ==> FROB\n;(VSET V 5 'BLAH) is an error\n V                        ==> #(FOO BAR BAZ FROB NIL)\n (VREF V 0)               ==> FOO\n (VREF V 1)               ==> BAR\n (VREF V 4)               ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSSIZE": {"ttr": 7718, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87\\x07/\\x00\\x87%\\x8f\\x17\\x07\\x00\\x10\\x00\\n\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-03-13T00:00:00", "modifydate": "1987-09-15T17:07:00", "lines": 16, "newlines": 10, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: VSSIZE\n\nSyntax:   (VSSIZE)\n\nReturns:\n\n An integer containing the total number of bytes in\n vector/string space.\n\nNotes:\n\n This value may be specified via the PARM field, or in a DECLARE,\n when a ZIL \"program\" is run.  See members $PARM and DECLARE of\n this documentation for more information.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WARN": {"ttr": 7720, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x08?\\x00\\x87%\\x8f\\x17\\t\\x00=\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-24T00:00:00", "modifydate": "1987-09-15T17:09:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: WARN\n\nSyntax:   (WARN arg1 &optional arg2 &rest args)\n\n arg1 (required, evaluated) - any LISP object, but generally a string.\n arg2 (optional, evaluated) - any LISP object.\n args (optional, evaluated) - any LISP object.\n\nReturns:\n\n NIL, after arg1 (and the other arguments, if non-NIL) are printed to\n the standard output file.\n\nProcessing:\n\n The first argument is assumed to be a message, and is therefore\n written to the standard output file via PRINC.\n\n If the second argument is not NIL, it is assumed to be a random LISP\n value, and is therefore written to the standard output file via PRIN1,\n with a dash separating the two values.\n\n If the rest of the args are present, they are assumed to be more\n random LISP values, and are therefore written to the standard output\n file in succession via PRIN1.\n\n A TERPRI is then issued to the standard output file, and a THROW to\n tag NIL is issued with a return value of NIL to be passed back to the\n most recent CATCH for tag NIL, if one exists.\n\n Generally, the first argument is a warning message, and the second\n argument is the object in question that is being warned about.\n\n If the current message level is greater than 1, no writing to the\n standard output file takes place.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare ERROR, which does a THROW to tag NIL to signal an error.\n WARN takes no such action.\n\nExamples:\n\n (WARN \"Larks' vomit!\")    will print:\n\n  Warning: Larks' vomit!\n\n on the standard output file and return NIL.\n\n (SETQ A \"value-of-a\")\n (WARN \"Invalid argument\" A)   will print:\n\n  Warning: Invalid argument - \"value-of-a\"\n\n on the standard output file and return NIL.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WHEN": {"ttr": 7722, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%\\x8f\\x17\\t\\x00$\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-15T17:09:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: WHEN\n\nSyntax:   (WHEN arg1 &rest args)\n\n arg1 (required, evaluated) - any LISP object.\n argn (optional, evaluated) - any LISP object.\n\nReturns:\n\n If arg1 evaluates to NIL, NIL;\n otherwise, the last of the args.\n\nProcessing:\n\n If arg1 evaluates to NIL, processing terminates and NIL is returned.\n Otherwise the rest of the arguments are evaluated as an implicit\n PROGN, returning the last of them.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare UNLESS, which does the reverse test.\n\nExamples:\n\n (WHEN (F)\n       (PRINT 'A)\n       (PRINT 'B)\n       'FOO)       if (F) returns NIL, returns NIL;\n                   if (F) returns other than NIL, prints A and B and\n                   returns FOO.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WITHOPEN": {"ttr": 7938, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x1f\\x00\\x88\\x12O\\x086\\x002\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1988-05-03T08:36:00", "lines": 50, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: WITH-OPEN-FILE\n\nSyntax:   (WITH-OPEN-FILE (filevar dsn &optional options) &rest body)\n\n filevar - a symbol that can be used as a lambda list variable.\n dsn     - a data set name (string or symbol).\n options - a value to be passed to OPEN.\n body    - zero or more forms to be executed.\n\nReturns:\n\n The value returned by the last of the body forms, with the variable\n speified by filevar being bound to the file returned by opening dsn.\n\nProcessing:\n\n WITH-OPEN-FILE opens dsn for the access type specified by options,\n binding filevar to the file returned by OPEN.  It then evaluates\n all the forms in body under this binding, closes the file, and\n returns the last value from the body.  It insures (via UNWIND-PROTECT)\n that the file is closed no matter what happens during executing of\n the body (THROW, errors, etc.).\n\nErrors signaled:\n\n None signalled by macro expansion, but...\n\nNotes:\n\n Because WITH-OPEN-FILE is a binding form, declarations are permitted\n at the beginning of the body.  Thus, for example, the variable\n specified by filevar can be declared SPECIAL if desired.\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (with-open-file (f \"foo.temp\" 'out)\n  (format f \"~&(a list of stuff)~%\")\n  'TRY-IT\n )                                     ==> TRY-IT\n\n (with-open-file (f \"foo.temp\")\n  (read f)\n )                                     ==> (A LIST OF STUFF)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WORD": {"ttr": 7940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%\\x8f\\x07E\\x00\"\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-15T07:45:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: WORD\n\nSyntax:   (WORD arg1 &optional arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A 4-character symbol whose print name is the EBCDIC contents of arg1.\n\nProcessing:\n\n The value of arg1 is interpreted as 4 EBCDIC bytes and\n used to build a print name for a symbol.\n\n If arg2 is present and not NIL, the symbol is interned on the\n oblist; otherwise it is not.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n Compare UNWORD, which performs the reverse operation.\n\nExamples:\n\n\n (WORD #z40404040)        ==> |    |\n (WORD #zE9C9D340 T)      ==> |ZIL |\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XCONS": {"ttr": 7942, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x14\\x1f\\x00\\x87%\\x8f\\x17\\x10\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-05-21T00:00:00", "modifydate": "1987-09-15T17:10:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: XCONS\n\nSyntax:   (XCONS arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object.\n\nReturns:\n\n A CONS (list or dotted pair) whose CAR is arg2 and whose CDR is arg1.\n\nProcessing:\n\n (XCONS arg1 arg2) is identical to (CONS arg2 arg1), except for the\n order of evaluation of the arguments.\n\nErrors signaled:\n\n None except for garbage collection errors.\n\nNotes:\n\n\nExamples:\n\n (XCONS 'A 'B)       ==> (B . A)\n (XCONS '(1 2 3) 4)  ==> (4 1 2 3)\n (XCONS NIL 'FOO)    ==> (FOO)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XDEFLOAD": {"ttr": 7944, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x08Q\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T08:51:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: XDEFLOAD\n\nSyntax:   (XDEFLOAD fun1 sym2)\n\n (The syntax is identical to that of DEFLOAD.)\n\nReturns:\n\n Same as what DEFLOAD returns.\n\nProcessing:\n\n XDEFLOAD executes DEFLOAD at RUN TIME\n (suitable for compiled initialization routines).\n\n Under the interpreter, XDEFLOAD is identical to DEFLOAD, except that\n it may be used in places where DEFLOAD is not allowed (i.e. at other\n than \"top level\").\n\n See DEFLOAD for more information.\n\nErrors signalled:\n\n See DEFLOAD.\n\nNotes:\n\n See ZEVDEFLD for more information.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDEFMACR": {"ttr": 7946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x08Q\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T08:51:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: XDEFMACRO\n\nSyntax:   (XDEFMACRO macro1 arglist2 &rest forms)\n\n (The syntax is identical to that of DEFMACRO.)\n\nReturns:\n\n Same as what DEFMACRO returns.\n\nProcessing:\n\n XDEFMACRO causes a run-time INTERPRETIVE macro definition to occur\n (suitable for compiled initialization routines).\n\n Under the interpreter, XDEFMACRO is identical to DEFMACRO, except that\n it may be used in places where DEFMACRO is not allowed (i.e. at other\n than \"top level\").\n\n See DEFMACRO for more information.\n\nErrors signalled:\n\n See DEFMACRO.\n\nNotes:\n\n XDEFUN bears the same relationship to DEFUN, and may be used to\n compile run-time INTERPRETIVE function definitions.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDEFUN": {"ttr": 7948, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87&\\x1f\\x08I\\x00*\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-18T08:49:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: XDEFUN\n\nSyntax:   (XDEFUN arg1 {arg2} arg3 arg4 ... argn)\n\n (The syntax is identical to that of DEFUN.)\n\nReturns:\n\n arg1, after establishing a function definition for that argument in the\n current environment.\n\nProcessing:\n\n XDEFUN causes a run-time INTERPRETIVE function definition to occur\n (suitable for compiled initialization routines).\n\n Under the interpreter, XDEFUN is identical to DEFUN, except that\n it may be used in places where DEFUN is not allowed (i.e. at other\n than \"top level\").\n\n See DEFUN for more information.\n\nErrors signalled:\n\n See DEFUN.\n\nNotes:\n\n XDEFMACRO bears the same relationship to DEFMACRO, and may be used to\n compile run-time macro definitions.\n\nExamples:\n\n (XDEFUN FIRST (X) (CAR X))\n\n (XDEFUN FIRST FEXPR (X A) (CAR (EVAL (CAR X) A)))\n\n (XDEFUN FIRST MACRO (X) (LIST 'CAR (CADR X)))\n\nall define (at run time) a function that returns the CAR of its arg.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDEFVAR": {"ttr": 7950, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x1f\\x00\\x87&\\x1f\\x08P\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-18T00:00:00", "modifydate": "1987-09-18T08:50:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: XDEFVAR\n\nSyntax:   (XDEFVAR var1 &optional val2 doc3)\n\n (The syntax is identical to that of DEFVAR.)\n\nReturns:\n\n Same as what DEFVAR returns.\n\nProcessing:\n\n XDEFVAR executes DEFVAR at RUN TIME\n (suitable for compiled initialization routines).\n\n Under the interpreter, XDEFVAR is identical to DEFVAR, except that\n it may be used in places where DEFVAR is not allowed (i.e. at other\n than \"top level\").\n\n See DEFVAR for more information.\n\nErrors signalled:\n\n See DEFVAR.\n\nNotes:\n\n See ZEVDVAR and ZEVXVAR for more information.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XINCLUDE": {"ttr": 7952, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x088\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:38:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: XINCLUDE\n\nSyntax:   (XINCLUDE dsn1)\n\n dsn1  (required, not evaluated) - a data set name (string or symbol).\n\nReturns:\n\n A list comprising the atom PROGN and all the forms in the dataset\n specified by dsn1, with NIL as the last element.\n\nProcessing:\n\n All the forms from the data set specified by dsn1 are read and\n collected (without evaluation) into a PROGN form with NIL as the\n last value.  If this form is evaluated, it should produce the\n same result as loading the original dsn1.\n\n READ errors do not terminate the operation.\n\nErrors signaled:\n\n Errors detected by OPEN and READ.\n\nNotes:\n\n XINCLUDE is the function that underlies the INCLUDE and INCLUDEF\n macros (q.v.).  Direct use of XINCLUDE is not recommended but may\n be useful under certain circumstances.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XLATE": {"ttr": 7954, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x880o\\x00\\x880o\\x12V\\x00%\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-01T00:00:00", "modifydate": "1988-11-01T12:56:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: STRING-TRANSLATE\n\nSyntax:   (STRING-TRANSLATE str1 bag2 bag3)\n    or:   (XLATE str1 bag2 bag3)\n\n str1 (required, evaluated) - a string.\n bag2 (required, evaluated) - a string.\n bag3 (required, evaluated) - a string.\n\nReturns:\n\n A string identical to string1, except that all characters occurring\n in bag3 are replaced with their equivalents in bag2, respectively.\n\nProcessing:\n\n The input argument is not altered.\n\n As with most string-handling functions, symbols are acceptable.\n However, the returned value is always a string.\n\nErrors signaled:\n\n Invalid first, second or third argument (not a string).\n Lengths of second and third arguments do not match.\n Insufficient vector/string space to build the result.\n\nNotes:\n\n This function is patterned after the PL/1 TRANSLATE built-in function.\n\nExamples:\n\n (STRING-TRANSLATE \"foobar\" \"u\" \"o\")   ==> \"fuubar\"\n (STRING-TRANSLATE \"Oobar\" \"Za\" \"Oo\")  ==> \"Zabar\" ; watch out for case!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XTAB": {"ttr": 7956, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17\\x15\\x00.\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:15:00", "lines": 46, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: XTAB\n\nSyntax:   (XTAB arg1 &optional arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (optional, evaluated) - an output file name.\n\nReturns:\n\n A fixnum containing the sum of arg1 plus 1, which is used to increment\n the current character pointer of the output file specified by arg2.\n\nProcessing:\n\n The ZGETFPO function is invoked to retrieve the current character\n pointer, and the ZPUTFPO function is invoked to update it.  The value\n specified in the XTAB function is a zero-based offset, which is\n transformed into a 1-based column specification by the macro expansion.\n\n See ZGETFPO and ZPUTFPO for more information.\n\nErrors signaled:\n\n Errors detected by ZGETFPO, ZPUTFPO and ZILADD (q.v.).\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Use of an out-of-range value as the first argument may cause\n serious errors in the ZIL environment.  Do so with extreme caution.\n\n The following examples illustrate the macro expansion for XTAB:\n\n (XTAB 3 FILE) --> (ZPUTFPO (ZILADD (ZGETFPO FILE) 3) FILE)\n (XTAB N FILE) --> (ZPUTFPO (ZILADD (ZGETFPO FILE) N) FILE)\n\nExamples:\n\n (XTAB 1) and (XTAB 1 NIL) are equivalent, and cause the current\n       column position of standard output to be \"tabbed\" over 1 space.\n\n (XTAB N 'BAR)  causes the current column position of output file BAR\n                to be \"tabbed\" over N spaces.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZCADDDR": {"ttr": 7958, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03_\\x00\\x87%\\x8f\\x17\\x18\\x00\"\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-04T00:00:00", "modifydate": "1987-09-15T17:18:00", "lines": 34, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZCADDDR\n\nSyntax:   (ZCADDDR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The ZCAR of the CDR of the CDR of the CDR of list1.\n\nProcessing:\n\n In effect, this function returns the fourth element of a list.\n\n This function is identical to CADDDR, except that it is an error if the\n CDDDR of the argument is NIL.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n This function may be used to generate very efficient compiled code when\n it is known that the CDDDR of the argument will never be NIL.\n\nExamples:\n\n (ZCADDDR '(A B C D E)) ==> D\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCADDR": {"ttr": 7960, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x86\\x03_\\x00\\x87%\\x8f\\x17\\x18\\x00\"\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1986-02-04T00:00:00", "modifydate": "1987-09-15T17:18:00", "lines": 34, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZCADDR\n\nSyntax:   (ZCADDR list1)\n\n list1 (required, evaluated) - a list.\n\nReturns:\n\n The ZCAR of the CDR of the CDR of list1.\n\nProcessing:\n\n In effect, this returns the third element of a list.\n\n This function is identical to CADDR, except that it is an error if the\n CDDR of the argument is NIL.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n This function may be used to generate very efficient compiled code when\n it is known that the CDDR of the argument will never be NIL.\n\nExamples:\n\n (ZCADDR '(A B C D E))  ==> C\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCADR": {"ttr": 7962, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03_\\x00\\x87%\\x8f\\x17\\x18\\x00 \\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-04T00:00:00", "modifydate": "1987-09-15T17:18:00", "lines": 32, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZCADR\n\nSyntax:   (ZCADR list1)\n\n list1 (required, evaluated) - a cons (list or dotted pair).\n\nReturns:\n\n The ZCAR of the CDR of list1.\n\nProcessing:\n\n This function is identical to CADR, except that it is an error if the\n CDR of the argument is NIL.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n This function may be used to generate very efficient compiled code when\n it is known that the the CDR of the argument will never be NIL.\n\nExamples:\n\n (ZCADR '(A B C D E))  ==> B\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCAR": {"ttr": 7964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03_\\x00\\x87%\\x8f\\x17\\x18\\x00$\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-04T00:00:00", "modifydate": "1987-09-15T17:18:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZCAR\n\nSyntax:   (ZCAR list1)\n\n list1 (required, evaluated) - a non-null list.\n\nReturns:\n\n The first element of list1.\n\nProcessing:\n\n Like CAR, except that (ZCAR NIL) is not defined and is an error.\n\nErrors signaled:\n\n Invalid argument (under the interpreter only).\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\n This function may be used to generate very efficient compiled code when\n it is known that the argument will never be NIL.\n\nExamples:\n\n (ZCAR '(A))               ==> A\n (ZCAR '(A B C D))         ==> A\n (ZCAR '((A1 A2) (B1 B2))) ==> (A1 A2)\n (ZCAR '(A . B))           ==> A\n\n;(ZCAR NIL)  is an error\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCPRINT": {"ttr": 7966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x18\\x9f\\x00\\x87%\\x8f\\x17\\x19\\x00,\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1987-09-15T17:19:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZCPRINT\n\nSyntax:   (ZCPRINT arg1 arg2 arg3)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - a file object.\n arg3 (required, evaluated) - a fixnum.\n\nReturns:\n\n The appropriate value, depending on the caller.\n\nProcessing:\n\n ZCPRINT is the low-level function that invokes the \"current ZIL\n printer\" (as opposed to ZDPRINT, the \"default ZIL printer\").\n\n See $PRINTER for information about how to specify the function to\n be used as the \"current ZIL printer\", and how it is used.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n You generally would not call ZCPRINT directly, unless you wanted to\n call a function with functionality like the following:\n\n  (defun princ-or-prin1 (object file slashify-p)\n   (if slashify-p\n       (prin1 object file)\n       (princ object file)))\n\n This could be defined instead (or coded inline) as\n\n  (defun princ-or-prin1 (object file slashify-p)\n   (zcprint object file (if slashify-p #b0101 #b0001)))\n\nExamples:\n\n  See $PRINTER for examples.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZCREAD": {"ttr": 7968, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x881?\\x00\\x881?\\x08$\\x00%\\x00%\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-08T00:00:00", "modifydate": "1988-11-08T08:24:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZCREAD\n\nSyntax:   (ZCREAD arg1 arg2 arg3 arg4 arg5 arg6)\n\n arg1 (required, evaluated) - a file object.\n arg2 (required, evaluated) - a fixnum.\n arg3 (required, evaluated) - any LISP object.\n arg4 (required, evaluated) - any LISP object.\n arg5 (required, evaluated) - any LISP object.\n arg6 (required, evaluated) - any LISP object.\n\nReturns:\n\n The appropriate value, depending on the caller.\n\nProcessing:\n\n ZCREAD is the low-level function that invokes the \"current ZIL\n reader\" (as opposed to ZDREAD, the \"default ZIL reader\").\n\n See $READER for information about how to specify the function to\n be used as the \"current ZIL reader\", and how it is used.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n You generally would not call ZCREAD directly.  ZCREAD exists only\n for the purpose of defining the standard ZIL input functions.\n\nExamples:\n\n  See $READER for examples.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZDPRINT": {"ttr": 7970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x18\\x9f\\x00\\x87%\\x8f\\x17 \\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1987-09-15T17:20:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZDPRINT\n\nSyntax:   (ZDPRINT arg1 arg2 arg3)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - a file object.\n arg3 (required, evaluated) - a fixnum.\n\nReturns:\n\n The appropriate value, depending on the caller.\n\nProcessing:\n\n ZDPRINT is the low-level function that invokes the \"default ZIL\n printer\" (as opposed to ZCPRINT, the \"current ZIL printer\").\n\n See $PRINTER for information about how to specify the function to\n be used as the \"current ZIL printer\", and how it is used.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n You would generally call ZDPRINT from a function you coded to\n replace the \"current ZIL printer\", if you wanted it to do\n \"default\" printer processing for some paths.  For example:\n\n  (defun my-printer (arg1 arg2 arg3)\n   (if *do-my-own-printing-stuff-p*\n       (my-printer-unique-stuff arg1 arg2 arg3)\n       (zdprint arg1 arg2 arg3)))\n\nExamples:\n\n  See $PRINTER for examples.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZDREAD": {"ttr": 7972, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\t\\x08\\x00,\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T09:08:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZDREAD\n\nSyntax:   (ZDREAD arg1 arg2 arg3 arg4 arg5 arg6)\n\n arg1 (required, evaluated) - a file object.\n arg2 (required, evaluated) - a fixnum.\n arg3 (required, evaluated) - any LISP object.\n arg4 (required, evaluated) - any LISP object.\n arg5 (required, evaluated) - any LISP object.\n arg6 (required, evaluated) - any LISP object.\n\nReturns:\n\n The appropriate value, depending on the caller.\n\nProcessing:\n\n ZDREAD is the low-level function that invokes the \"default ZIL reader\"\n (as opposed to ZCREAD, the \"current ZIL reader\").\n\n See $READER for information about how to specify the function to be\n used as the \"current ZIL reader\", and how it is used.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n\nNotes:\n\n You would generally call ZDREAD from a function you coded to replace\n the \"current ZIL reader\", if you wanted it to do \"default\" reader\n processing for some paths.  For example:\n\n  (defun my-reader (arg1 arg2 arg3 arg4 arg5 arg6)\n   (if *do-my-own-reading-stuff-p*\n       (my-reader-unique-stuff arg1 arg2 arg3 arg4 arg5 arg6)\n       (ZDREAD arg1 arg2 arg3 arg4 arg5 arg6)))\n\nExamples:\n\n  See $READER for examples.\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEROP": {"ttr": 7974, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17 \\x00\"\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:20:00", "lines": 34, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEROP\n\nSyntax:   (ZEROP arg1)\n\n arg1 (required, evaluated) - a number.\n\nReturns:\n\n T if arg1 is numerically zero, else NIL.\n\nProcessing:\n\nErrors signaled:\n\n Non-numeric argument.\n\nNotes:\n\n No errors are detected in compiled code; results are unpredictable\n if an invalid argument is passed.\n\nExamples:\n\n (ZEROP 0)         ==> T\n (ZEROP 1)         ==> NIL\n (ZEROP -1)        ==> NIL\n (ZEROP 0.0)       ==> T\n (ZEROP -0.0)      ==> T\n (ZEROP 0.0001)    ==> NIL\n (ZEROP 0.0F0)     ==> T\n (ZEROP -0.0F0)    ==> T\n (ZEROP 0.0001F0)  ==> NIL\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZERROR": {"ttr": 7976, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x89\\x13_\\x00\\x89\\x14/\\x17Q\\x00B\\x00B\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1989-05-15T00:00:00", "modifydate": "1989-05-22T17:51:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZERROR\n\nSyntax:   (ZERROR &optional arg1 arg2 &rest args)\n\n arg1 (optional, evaluated) - any LISP object, but generally a string.\n arg2 (optional, evaluated) - any LISP object.\n args (optional, evaluated) - any LISP object.\n\nReturns:\n\n Nothing; after arg1 (and the other arguments, if non-NIL) is printed to\n the standard output file, a THROW to tag NIL is issued.\n\nProcessing:\n\n The first argument is assumed to be a message, and is therefore\n written to the standard output file via PRINC.  If the first\n argument is omitted, nothing gets printed.\n\n If the second argument is not NIL, it is assumed to be a random LISP\n value, and is therefore written to the standard output file via PRIN1,\n with a dash separating the two values.\n\n If the rest of the args are present, they are assumed to be more\n random LISP values, and are therefore written to the standard output\n file in succession via PRIN1.\n\n A TERPRI is then issued to the standard output file, and a THROW to\n tag NIL is issued with a return value of NIL to be passed back to the\n most recent CATCH for tag NIL, if one exists.\n\n Generally, the first argument is an error message, and the second\n argument is the object in question that was in error.\n\n If the current message level is greater than 2, no writing to the\n standard output file takes place, but the THROW still occurs.\n\nErrors signaled:\n\n None (other than the error being requested!).\n\nNotes:\n\n If no CATCH is active for a tag of NIL, this is considered to be a\n fatal error and the ZIL program is abended with a user code.  If the\n error message (in this case, the first argument) begins with the\n characters ZILnnnn, where nnnn is a 4-digit number between 0001 and\n 4095, that number is used as the user abend code; otherwise a user\n abend code of zero is issued.\n\nExamples:\n\n (SETQ A 'VALUE-OF-A)\n (ZERROR \"Invalid argument\" A)  will print:\n\n  Error: Invalid argument - VALUE-OF-A\n\n on the standard output file and issue a THROW to tag NIL.\n\n (CATCH NIL (ZERROR \"Error message\"))  ==> NIL ; after printing\n\n  Error: Error message\n\n on the standard output file.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVAUTO": {"ttr": 7978, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x08H\\x00I\\x00I\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:48:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVAUTO\n\nSyntax:   (ZEVAUTO sym1 &optional errp)\n\n sym1 (required, evaluated) - a symbol.\n errp (required, evaluated) - T or NIL.\n\nReturns:\n\n NIL if no function definition could be found for sym1, otherwise\n a non-NIL value.\n\nProcessing:\n\n This function resolves a symbol sym1 being used as a function name\n when it currently has no function property.  Resolution is based\n on the value of the AUTOLOAD property, as follows:\n\n   If the AUTOLOAD property is a string, then it is the name of a\n   data set (file) to be loaded.\n\n   If the AUTOLOAD property is a non-null list, then it is a form\n   to be evaluated.\n\n In both of the above cases, it is presumed that the file or form,\n when loaded or evaluated, will cause sym1 to become defined as a\n function.\n\n   If the AUTOLOAD property is a symbol, then an attempt is made to\n   load the compiled function definition from the system ZIL library.\n   The name under which the function is searched for is the value of\n   sym1's AUTOLOAD property if non-NIL, or sym1 itself if the value of\n   sym1's AUTOLOAD property is NIL.\n\n To prevent infinite looping in the evaluator, ZEVAUTO removes the\n AUTOLOAD property from sym1 if it is a string or a list.  If it is a\n symbol, the AUTOLOAD property is retained; however, if the attempt to\n load the compiled function fails, then if errp is NIL, ZEVAUTO\n returns NIL, otherwise an \"undefined function\" error is signalled.\n\n The removal of the AUTOLOAD property is skipped if an error occurs\n processing the AUTOLOAD property.\n\n NOTE: If a form is the value of the AUTOLOAD property, it is\n       evaluated in a null evaluation environment.  In other words,\n       it is evaluated as if it had occurred at top level.  In\n       particular, no dynamic SPECIAL variable bindings are visible\n       (only global ones).\n\n Note that the autoload property is removed during autoloading\n (except when the autoload property is a symbol) and restored\n afterwards (in case, say, an attention interrupt occurred during\n the loading of a file).  If the autoload process went to completion\n the autoload property is removed anyhow.\n\nErrors signaled:\n\n Undefined function (if errp is NIL).\n Invalid AUTOLOAD property.\n\nNotes:\n\n The technique for preventing multiple autoload attempts has one minor\n drawback:\n\n Putting a property on a symbol's property list can have the effect of\n making the LISP system think that the symbol is not \"worthless\".  This\n means that functions like APROPOS and GCTWA, depending on their\n implementation, may undesirably treat these symbols as meaningful, when\n in fact the ZIL-NO-AUTOLOAD property only reinforces the worthlessness\n of the symbol (if it doesn't have any other features, that is).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVDEFLD": {"ttr": 7980, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x08S\\x00!\\x00!\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:53:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVDEFLD\n\nSyntax:   (ZEVDEFLD arg1 arg2)\n\n arg1 (required, evaluated) - a list of 2 symbols.\n arg2 (required, evaluated) - T or NIL.\n\nReturns:\n\n The second element of arg1 (which DEFLOAD returns).\n\nProcessing:\n\n This function implements DEFLOAD at run time.  arg1 is the argument\n list passed to DEFLOAD, which must be a list of 2 symbols.\n\n arg2 specifies whether DEFLOAD is being invoked at \"top level\" (T)\n or not (NIL).\n\n See DEFLOAD for more information.\n\nErrors signaled:\n\n Invalid number or type of arguments (invalid arg1).\n Not at top level (arg2 is NIL).\n\nNotes:\n\n There is a macro XDEFLOAD, which can be used to invoke DEFLOAD at run\n time (similarly to XDEFUN and XDEFMACRO).  The syntax is identical to\n that of DEFLOAD.  XDEFLOAD expands into a call to ZEVDEFLD.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVDEFUN": {"ttr": 7982, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x08U\\x00#\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T08:55:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVDEFUN\n\nSyntax:   (ZEVDEFUN arg1 arg2)\n\n arg1 (required, evaluated) - a list.\n arg2 (required, evaluated) - T or NIL.\n\nReturns:\n\n The first element of arg1 (which DEFUN returns).\n\nProcessing:\n\n This function implements DEFUN at run time.  arg1 is the argument\n list passed to DEFUN, with the CAR being the function name.\n\n arg2 specifies whether DEFUN is being invoked at \"top level\" (T)\n or not (NIL).\n\n See DEFUN for more information.\n\nErrors signaled:\n\n DEFUN syntax errors (invalid arg1).\n Not at top level (arg2 is NIL).\n\nNotes:\n\n ZEVDEFUN always creates an INTERPRETED definition.\n\n There is a macro XDEFUN, which can be used to invoke DEFUN at run\n time (similarly to XDEFUN and XDEFMACRO).  The syntax is identical to\n that of DEFUN.  XDEFUN expands into a call to ZEVDEFUN.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVDSUB": {"ttr": 8193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\t\\x00\\x00 \\x00 \\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:00:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVDSUB\n\nSyntax:   (ZEVDSUB sym1 subr2)\n\n sym1  (required, evaluated) - a symbol.\n subr2 (required, evaluated) - a compiled SUBR object.\n\nReturns:\n\n subr2, after assigning it to be the compiled code definition of sym1.\n\nProcessing:\n\n This function is called by compiled code in MODULE's that issue\n DEFUN to define compiled functions.  It assigns subr2 as the SUBR\n property of the symbol sym1.\n\n Any existing function or macro definitions are removed from sym1\n before subr2 is assigned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n ZEVDSUB always creates a COMPILED definition.\n\n subr2 could just as easily be a compiled lexical closure, but ZIL\n at present does not do this.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZEVDVAR": {"ttr": 8195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\t\\x03\\x00$\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:03:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVDVAR\n\nSyntax:   (ZEVDVAR arg1 arg2)\n\n arg1 (required, evaluated) - a list.\n arg2 (required, evaluated) - T or NIL.\n\nReturns:\n\n The first element of arg1 (which DEFVAR returns).\n\nProcessing:\n\n This function implements DEFVAR at run time.  arg1 is the argument\n list passed to DEFVAR, with the CAR being the variable name.\n\n arg2 specifies whether DEFVAR is being invoked at \"top level\" (T)\n or not (NIL).\n\n See DEFVAR for more information.\n\nErrors signaled:\n\n DEFVAR syntax errors (invalid arg1).\n Not at top level (arg2 is NIL).\n\nNotes:\n\n ZEVDVAR is used only by DEFVAR under the interpreter.  Compiled calls\n to DEFVAR in MODULE's use ZEVXVAR, which ZEVDVAR interfaces to.\n\n There is a macro XDEFVAR, which can be used to invoke DEFVAR at run\n time (similarly to XDEFUN and XDEFMACRO).  The syntax is identical to\n that of DEFVAR.  XDEFVAR expands into a call to ZEVXVAR (not ZEVDVAR).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVINIT": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\t\\x06\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:06:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVINIT\n\nSyntax:   (ZEVINIT)\n\nReturns:\n\n NIL\n\nProcessing:\n\n ZEVINIT performs initialization of the ZIL environment.  It defines\n global variables, macro definitions, and some function definitions.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n ZEVINIT is automatically executed by every ZIL program at\n initialization time.  It is NOT supposed to be invoked by ZIL code\n directly.  Invoking ZILINIT will reset lots of things to their default\n values, some in strange ways.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZEVLIST": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\t\\x16\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:16:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVLIST\n\nSyntax:   (ZEVLIST list1 env2)\n\n list1 (required, evaluated) - a list.\n env2  (required, evaluated) - an evaluation environment.\n\nReturns:\n\n A list consisting of the results of evaluating the elements of list1.\n\nProcessing:\n\n Each element of list1 is evaluated in the evaluation environment\n specified by env1, and the resulting list is returned.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n This is an internal function used by the EVAL and APPLY.\n Not for general use.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZEVMAPP": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\t\\x14\\x00/\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:14:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVMAPP\n\nSyntax:  (ZEVMAPP mexp1 form2 prop3)\n\n mexp1 (required, evaluated) - a LAMBDA expression.\n form2 (required, evaluated) - a macro form.\n prop3 (required, evaluated) - MACRO or CMACRO.\n\nReturns:\n\n The result of macroexpanding form2, using mexp1 as the macro expansion\n function.\n\nProcessing:\n\n This function applies a macro definition.\n\n mexp1 is the value of the MACRO or CMACRO property to be applied.\n\n form2 is the entire form, which is the argument to the macro expansion\n       function mexp1.\n\n prop3 is the macro property name - MACRO or CMACRO.\n\n mexp1 must be (LAMBDA arglist ...)\n where...\n  If arglist is a cons whose CAR is NIL, then this is an extended\n   macro arglist generated by DEFMACRO, and applied accordingly.\n  Otherwise, this is a standard MACRO arglist, applied the standard way.\n\n If mexp1 is not a LAMBDA expression, an \"invalid macro property\"\n warning is issued and it is applied the standard way.\n\nErrors signaled:\n\n Only those signalled by mexp1.\n\nNotes:\n\n The extended macro argument list generated by DEFMACRO is not\n compatible with Common Lisp, because it cannot be applied by APPLY\n and give correct results.  Some day this may be straightened out.\n\n For this reason, do not use APPLY or FUNCALL to apply macro expansion\n function definitions.  Always use ZEVMAPP.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVSET": {"ttr": 8203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\t)\\x00!\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:29:00", "lines": 33, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVSET\n\nSyntax:   (ZEVSET var1 val2)\n\n var1 (required, evaluated) - a symbol.\n val2 (required, evaluated) - any LISP object.\n\nReturns:\n\n val2, after the variable specified by var1 has been bound\n to the value specified by val2.\n\nProcessing:\n\n The current dynamic (SPECIAL) binding of var1 is altered to be val2;\n in other words, the \"value\" of var1 is set to val2.\n\n See SET for more details.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n ZEVSET is the internal ZIL function that implements dynamic binding\n assignments (SET and SETQ).\n\n No error checking is done.  ZEVSET assumes that you have passed it\n a valid, non-self-evaluating symbol.  If you have not, results\n could be disastrous.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVSYM": {"ttr": 8205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\t5\\x00B\\x00B\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:35:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVSYM\n\nSyntax:   (ZEVSYM var1)\n\n var1 (required, evaluated) - a symbol.\n\nReturns:\n\n The current dynamic (SPECIAL) BINDING (not the value) of the variable\n specified by var1, or NIL if the variable is unbound or bound to\n the \"unbound marker\".\n\nProcessing:\n\n arg1 must be a symbol other than T, NIL or a keyword.\n\n The current global or dynamic \"SPECIAL\" binding for the symbol is\n located and is returned, unless there is no binding or the\n value component of the binding is the \"unbound marker\", in\n which case NIL is returned.\n (Symbol autoloading may be invoked if there is an AUTOVALUE\n property on the symbol and it does not currently have a\n dynamically bound value.)\n\n The value of the variable is the CDR of the binding.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n ZEVSYM is the internal ZIL function that accesses SPECIAL variable\n bindings.  It underlies SYMEVAL as well as interpreted and compiled\n accesses of SPECIAL variable values.\n\n No error checking is done.  ZEVSYM assumes that you have passed it\n a valid, non-self-evaluating, dynamically bound symbol.\n\n Symbol-autoloading works on the value of the AUTOVALUE property, as\n follows:\n\n   If the AUTOVALUE property is a string, then it is the name of a\n   data set (file) to be loaded.\n\n   If the AUTOVALUE property is a non-null list, then it is a form\n   to be evaluated.\n\n In both of the above cases, it is presumed that the file or form,\n when loaded or evaluated, will cause the variable name in question\n to become defined.\n\n To prevent infinite looping in the evaluator, this function removes\n the AUTOVALUE property from the variable name if it is a string or\n a list.\n\n The removal of the AUTOVALUE property is skipped if an error occurs\n processing the AUTOVALUE property.\n\n NOTE: If a form is the value of the AUTOLOAD property, it is\n       evaluated in a null evaluation environment.  In other words,\n       it is evaluated as if it had occurred at top level.  In\n       particular, no dynamic SPECIAL variable bindings are visible\n       (only global ones).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEVXVAR": {"ttr": 8207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\tA\\x00M\\x00M\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:41:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZEVXVAR\n\nSyntax:   (ZEVXVAR arg1 arg2 arg3 arg4)\n\n arg1 (required, evaluated) - a symbol.\n arg2 (required, evaluated) - a LISP object, or a function of no args.\n arg3 (required, evaluated) - T or NIL.\n arg4 (required, evaluated) - a documentation string.\n\nReturns:\n\n arg1.\n\nProcessing:\n\n This function implements calls to DEFVAR in compiled MODULE's.\n\n It receives 4 arguments: (1) the variable symbol (arg 1 to DEFVAR)\n                          (2) either a constant initial value, or\n                              a function of no arguments which can\n                              be called to establish an initial value\n                          (3) a boolean which specifies whether the\n                              second argument is a constant or a\n                              \"thunk\" (function of no arguments).\n                          (4) the documentation string.\n\n The syntax of DEFVAR is:\n\n  (DEFVAR variable &optional value documentation)\n\n  When (DEFVAR variable) is specified, with no value...\n\n              If the variable already has a SPECIAL binding,\n              no action is taken.\n\n              Otherwise, the variable is proclaimed to be SPECIAL\n              (whatever form that takes).\n\n              If the variable is not already SPECIALly bound,\n              its binding cell is filled in with a binding, consisting\n              of a CONS of the symbol with its new value.\n\n  When (DEFVAR variable value ...) is specified...\n\n              If the variable already has a SPECIAL binding,\n              no action is taken.\n\n              Otherwise, the variable is proclaimed to be SPECIAL\n              (whatever form that takes).\n\n              If the variable is not already SPECIALly bound,\n              its binding cell is filled in with a binding, consisting\n              of a CONS of the symbol with its new value.\n\n              If there is a documentation string, it is made the\n              value of the variable's DOCUMENTATION property.\n\n              (The documentation is not added if the variable is\n              already present in the environment.)\n\n See DEFVAR for more information.\n\nErrors signaled:\n\n DEFVAR syntax errors (invalid arg1).\n Not at top level (arg2 is NIL).\n\nNotes:\n\n ZEVDVAR is used by DEFVAR under the interpreter.  Compiled calls\n to DEFVAR in MODULE's use ZEVXVAR.\n\n There is a macro XDEFVAR, which can be used to invoke DEFVAR at run\n time (similarly to XDEFUN and XDEFMACRO).  The syntax is identical to\n that of DEFVAR.  XDEFVAR expands into a call to ZEVXVAR.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZFSEXEC": {"ttr": 8209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00G\\x00\\x880\\x7f\\x01\\x00&_\\tV\\x02\\x1e\\x02$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-02T00:00:00", "modifydate": "2000-09-21T09:56:47", "lines": 542, "newlines": 548, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZFSEXEC\n\nSyntax:   (ZFSEXEC &key\n                   panel-name\n                   panel-library\n                   long-appl\n                   short-appl\n                   terpri-exit-function\n                   initialize-function\n                   terminate-function\n                   panel-init-function\n                   echo-input-function\n                   expr-list-function\n                   refreshp-function\n                   eval-expr-function\n                   good-eval-function\n                   bad-eval-function\n                   post-eval-function\n                   display-function\n                   output-row-function)\n\n All of the below are optional keywords whose values are evaluated.\n\n :panel-name           - a string identifying an ISPF display panel\n :panel-library        - a string identifying a partitioned MVS dataset.\n :long-appl            - a string describing the application.\n :short-appl           - a string describing the application.\n :terpri-exit-function - a function of 1 argument.\n :initialize-function  - a function of 1 argument.\n :terminate-function   - a function of 0 arguments.\n :panel-init-function  - a function of 0 arguments.\n :echo-input-function  - a function of 1 argument.\n :expr-list-function   - a function of 2 arguments.\n :refreshp-function    - a function of 0 arguments.\n :eval-expr-function   - a function of 3 arguments.\n :good-eval-function   - a function of 2 arguments.\n :bad-eval-function    - a function of 0 arguments.\n :post-eval-function   - a function of 0 arguments.\n :display-function     - a function of 1 argument.\n :output-row-function  - a function of 1 argument.\n\n Defaults:\n\n :panel-name           - \"ZFSEXEC\"\n :panel-library        - (string-append \"'\" *zil-panel-library* \"'\")\n :long-appl            - \"ZFSEXEC\"\n :short-appl           - \"ZFSEXEC\"\n\n Defaults for all keywords that identify functions are NIL, meaning\n that that function will not be used.\n\nReturns:\n\n NIL, after invoking an ISPF dialog which processes input and output,\n displaying it in scrollable full-screen mode, until the END key is\n pressed by the terminal user.\n\nProcessing:\n\n ZFSEXEC initializes an ISPF environment and then initiates an ISPF\n dialog loop which consists of:\n\n  displaying the panel specified by the :panel-name keyword\n\n  accepting input from the user, entered on the panel\n\n  terminating if the END command is typed (or the END key is pressed)\n\n  processing any dialog commands entered on the ISPF command line\n\n  processing the dialog input in accordance with the functions\n  specified by the caller, which will parse the input, process\n  each expression in the input, and generate an output display.\n  Part or all of this process will result in Lisp output which\n  is captured and directed to the panel display, rather than\n  being sent to the terminal as line-mode messages.\n\n  The keywords are handled as follows:\n\n :panel-name\n\n  is a string containing the name of the ISPF display panel, as would be\n  specified in an ISPEXEC \"DISPLAY PANEL(...)\" request.  If this keyword\n  is omitted, it defaults to \"ZFSEXEC\".  The panel must be similar to\n  the default panel, a model of which is available in the data set\n  'PROGLIB.ZIL.PANEL(ZFSEXEC)'.\n  Associated tutorial panels for the basic full-screen interface are in\n  'PROGLIB.ZIL.PANEL' beginning with the characters TZFSEX.\n\n  See below under :panel-library for how the search for the panel name\n  is done.\n\n :panel-library\n\n  is a string containing the name (in TSO format) of a partitioned MVS\n  data set, which is the panel data set where the panel lives.  If this\n  keyword is omitted, it defaults to the panel library specified by\n  *zil-panel-library*, with single quotes appended.  Note that single\n  quotes must be included if the name is fully qualified (which it\n  should be if you want this application to be independent of who runs\n  it!).\n\n  If the panel specified by :panel-name is already in the user's\n  current ISPF panel setup, the :panel-library keyword is ignored.\n  If it is not found there, however, the data set specified by the\n  :panel-library keyword is hooked up (via the ISPF LIBDEF service)\n  at ZFSEXEC initialization time, and the LIBDEF is undone at ZFSEXEC\n  termination time.  Therefore, any pre-existing panel LIBDEFs will be\n  CANCELLED during the session if this is the case.\n\n :long-appl\n\n  is a string describing the application.  It is suggested that this\n  string contain the name of the application together with a version\n  number and/or other identifying information.  This value is what\n  gets printed out on the header of SAVE files when the SAVE command\n  is issued during the dialog.\n\n :short-appl\n\n  is a string describing the application.  It should be brief,\n  preferably a single word.  This value gets inserted in error messages\n  and the like.\n\n :terpri-exit-function\n\n  is a function of 1 argument, as follows:\n\n  Arguments:\n\n   (1) A string containing the last full line of output that has been\n       generated by PRINT-type functions and captured by the dialog.\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called whenever a TERPRI is executed\n   and captured by the dialog's print trapper.  (Currently it does NOT\n   get control whenever a CTERPRI is executed, even if the CTERPRI\n   results in a TERPRI operation.)  Normally this is the point at\n   which the line will get added to the captured output, so the exit\n   gets called right before that is about to happen.\n\n  Purpose:  Since ZFSEXEC does not intercept READ operations, it has no\n   way of telling when the application will attempt to read input from\n   the terminal, and when the application does read input from the\n   terminal, it merely unlocks the keyboard without sending out any\n   data.  Therefore, if the application has a means of determining\n   at TERPRI time if a READ is likely to follow, or if for any other\n   reason (e.g. tracing or echoing) it wants to do something with the\n   output line, it can do it in the exit.  Note that the exit cannot\n   change what ZFSEXEC does with the line (e.g. it cannot prevent it\n   from becoming part of the output).\n\n :initialize-function\n\n  is a function of 1 argument, as follows:\n\n  Arguments:\n\n   (1) An integer containing the maximum depth of the scrollable output\n       section of the panel, as determined by the ISPF PQUERY service.\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called following initialization of the\n   ISPF environment when ZFSEXEC starts up.\n\n  Purpose:  To perform additional initialization which may or may not\n   pertain to the full-screen environment.  Knowledge of the depth of\n   the screen is made available to allow the setting of parameters\n   which may be dependent on this information.\n\n :terminate-function\n\n  is a function of no arguments, as follows:\n\n  Arguments:  None.\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called following termination of the\n   ISPF environment when ZFSEXEC winds down following the ISPF \"END\"\n   command or PF key.\n\n  Purpose:  To clean up anything which may have been done in the\n   initialization function.\n\n :panel-init-function\n\n  is a function of no arguments, as follows:\n\n  Arguments:  None.\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called each time the panel display\n   is about to occur, after the contents of the input fields are\n   regenerated but before the actual display.\n\n  Purpose:  To perform additional panel INIT processing, such as\n   regenerating the contents of a screen variable.  Note that this\n   function plus ZFSEXEC's own code perform the tasks normally\n   associated with an ISPF panel )INIT section.\n\n :echo-input-function\n\n  is a function of 1 argument, as follows:\n\n  Arguments:\n\n   (1) A string containing the value typed in by the user on the\n       second (non-ISPF-command) input field.\n\n  Returns:\n\n   The string to be echoed, in high intensity, in the scrollable\n   output display.\n\n  When called:  This function is called whenever the dialog is about to\n   process the user's input string (NOT when an ISPF command is\n   processed instead), and before the string, or the value returned by\n   the function, is echoed on the output.  At the time this function is\n   called, the input value as typed has already been stored for access\n   by input-retrieval (LEFT/RIGHT key) processing.\n\n  Purpose:  To modify the way the input is displayed when it is echoed\n   on the output display, and/or to do additional processing (such as\n   echoing or dribbling to an auxiliary file).  The contents of the\n   input may also be converted to another format and saved by the\n   application for ease of use in other functions (the return value\n   from this function is NOT passed to other functions).\n\n  If this function is not provided, the input string itself, without\n  modification, is echoed in high intensity on the output display.\n\n :expr-list-function\n\n  is a function of 2 arguments, as follows:\n\n  Arguments:\n\n   (1) A string containing the value typed in by the user on the\n       second (non-ISPF-command) input field.\n\n   (2) The ZFSEXEC print trapping function, used to capture all output.\n\n  Returns:\n\n   A list of expressions parsed from the input string, of which each\n   element is a list of three objects:\n    * The first object in each expression element is reserved, and\n      should be set to NIL.\n    * The second object in each expression element is a Lisp object that\n      represents something to be processed by the :eval-expr-function.\n    * The third object in each expression element is NIL if the \"value\"\n      of the \"evaluation\" of the expression is NOT to be displayed (via\n      the :display-function), and T (or any non-NIL value) if the\n      \"value\" IS to be displayed.\n\n  When called:  This function is called when the dialog needs to process\n   the user's input, which are assumed to be (possibly more than one)\n   input expressions typed in on the second input field.\n\n  Purpose:  To convert the input into the format used by the application\n   (much as the Lisp READ function converts disk or terminal input into\n   S-expressions).  Since syntactically it may be possible to enter\n   multiple expressions, a list of all the expressions needs to be\n   returned, even though the input is retained as a single input string\n   for purposes of input retrieval via the LEFT and RIGHT PF keys.\n\n   If the code that parses the input prints messages (e.g. when a syntax\n   error is detected), the output will go directly to the terminal,\n   unless the code is executed under control of the \"trapper\" function\n   passed as argument 2 to this function.  This should be done along\n   the following lines:\n\n    (defun my-expr-list-function (input-string trapper)\n     (let (expression-list)\n      ...\n      (funcall trapper\n        #'(lambda ()\n            (setq expression-list ...code-to-parse-input...)))\n      ...\n      expression-list))\n\n  If this function is not provided, a null list is returned, resulting\n  in no expressions being processed.  In this case, only the input is\n  echoed on the output display.\n\n :refreshp-function\n\n  is a function of no arguments, as follows:\n\n  Arguments:  None.\n\n  Returns:\n\n   NIL if an ISPF \"CONTROL DISPLAY REFRESH\" dialog service call is\n   NOT to be executed before a redisplay of the panel following the\n   processing of an input expression;  T (or any non-NIL value) if\n   the refresh IS to be done.\n\n  When called:  This function is called after a process-and-display\n   has been completed for given user input, and before the panel\n   is to be redisplayed with the new output.\n\n  Purpose:  To allow the application to have control over the decision\n   of the dialog to do a CONTROL DISPLAY REFRESH.  To save screen I/O,\n   the screen is not refreshed unless deemed necessary.  For example,\n   no refresh is done following scrolling or LOCATE or FIND operations.\n   However, since arbitrary code may be invoked during the processing\n   of an input expression, which may involve screen clears or TSO output\n   that causes full-screen mode to be turned off, an ISPF screen refresh\n   may be necessary in order to prevent the screen from being garbled.\n   The application has the opportunity to override this to improve\n   screen I/O, at the risk of screen destruction - in which case the\n   user must press the PA2 key to view the correctly formatted screen.\n   The application may, for example, maintain a global variable,\n   settable by the user, which controls whether to do these screen\n   refreshes; the recommended default value is to do the refresh.\n\n  If this function is not provided, the refresh is always done, as if\n  T was returned.\n\n :eval-expr-function\n\n  is a function of 3 arguments, as follows:\n\n  Arguments:\n\n   (1) The object to be processed (\"evaluated\"), as taken from the\n       second element of an entry on the expression list returned by\n       the :expr-list-function.\n\n   (2) A value taken from the third element of an entry on the\n       expression list returned by the :expr-list-function, specifying\n       whether output display is to be suppressed or not (NIL or a\n       non-NIL value).\n\n   (3) The ZFSEXEC print trapping function, used to capture all output.\n\n  Returns:\n\n   (1) A list of values returned by processing (\"evaluating\") the\n       expression in question.  For example, if the expression is a Lisp\n       S-expression that should be passed to EVAL, the list of multiple\n       values returned by the expression might be returned.  Normally,\n       however, a list of one value would be returned.\n\n  When called:  This function is called for each expression taken from\n   the list returned by the :expr-list-function, when the dialog needs\n   to process (\"evaluate\") it.\n\n  Purpose:  To \"evaluate\" the given expression.\n\n   ZFSEXEC takes care of error and attention handling.  The caller need\n   not worry about these.\n\n   If the code that processes the expressions generates intermediate\n   Lisp print output, the output will go directly to the terminal,\n   unless the code is executed under control of the \"trapper\" function\n   passed as argument 3 to this function.  This should be done along\n   the following lines:\n\n    (defun my-eval-expr-function (expression displayp trapper)\n     (let (values)\n      ...\n      (funcall trapper\n        #'(lambda ()\n            (setq values ...code-to-process-expression...)))\n      ...\n      values))\n\n  If this function is not provided, no processing is done, and thus\n  no output is generated.\n\n :good-eval-function\n\n  is a function of 2 arguments, as follows:\n\n  Arguments:\n\n   (1) The list of values returned by the :eval-expr-function.\n\n   (2) A value specifying whether output display is to be suppressed or\n       not (NIL or a non-NIL value).\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called when a valid list of values has\n   been returned from the :eval-expr-function (i.e. the second value\n   therefrom is non-NIL), before the display of the values, if any,\n   is to be done.\n\n  Purpose:  To do processing associated with successful \"evaluation\"\n   of an expression, such as setting application variables.\n\n :bad-eval-function\n\n  is a function of no arguments, as follows:\n\n  Arguments:  None.\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called when it has been determined\n   that \"evaluation\" done by the :eval-expr-function has not been\n   successful (i.e. the second value returned\n   therefrom is NIL).\n\n  Purpose:  To do processing associated with unsuccessful \"evaluation\"\n   of an expression, such as setting application variables.  There is\n   no need to generate error messages, since an ISPF error message is\n   generated by ZFSEXEC.\n\n :post-eval-function\n\n  is a function of no arguments, as follows:\n\n  Arguments:  None.\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called after processing by the\n   :eval-expr-function (whether successful or unsuccessful) and\n   output by the :display-function.\n\n  Purpose:  To do processing associated with finishing up the current\n   input and output and preparing for the entry of the next input\n   expression, such as setting application variables.\n\n :display-function\n\n  is a function of 1 argument, as follows:\n\n  Arguments:\n\n   (1) The list of values returned by the :eval-expr function.\n\n  Returns:  The return value is not used.\n\n  When called:  This function is called when it is time to display\n   the values generated by processing the input, after it has been\n   insured that a new output line will start.\n\n  Purpose:  To display the value or values returned by each\n   expression that has been \"evaluated\" by the :eval-expr-function.\n\n   Currently, the display is 100% under control of the print trapper.\n   It is, therefore, not possible to have Lisp print output go to\n   the terminal during this processing.\n\n   Error handling is managed by ZFSEXEC in this case, and an ISPF error\n   message is generated if an error occurs.\n\n  If this function is not provided, no output is displayed, except for\n  possible intermediate output generated during \"evaluation\" and a\n  possible new line.\n\n :output-row-function\n\n  is a function of 1 argument, as follows:\n\n  Arguments:\n\n   (1) A string which contains the contents of a new row which is\n       to be added to the scrollable output display.\n\n  Returns:\n\n   A string which contains the contents of the new row which is to\n   be added to the scrollable output display.  In other words, the\n   same string or a modified version thereof.\n\n  When called:  This function is called whenever a new row is to\n   be added to the scrollable output display, before the row is\n   padded out to 79 characters and the proper intensity attribute\n   is added.\n\n  Purpose:  To modify the contents of the output line on the display,\n   e.g. to translate unprintable characters to some other format, or\n   to echo or otherwise side-process the output lines.\n\n   The input string may be of any length between 0 and 79.  It is\n   padded with blanks to a length of 79 after it is passed through\n   this function.\n\n  If this function is not provided, the selfsame string is used to\n  generate the output row, with padding and attribute assignment,\n  as if an :output-row-function that merely returned the input\n  argument were executed.\n\nErrors signaled:\n\n ISPF environment not active.\n\nNotes:\n\n ZIL-MVS only.  ISPF version 2 required.  If PDF is not installed\n along with ISPF, attempts to display error messages may fail.\n\n This is the underlying driver for ZIL-based interactive applications\n that wish to use the full-screen interface.\n\n If ZFSEXEC is invoked without keywords, a dummy dialog (using the\n panel named ZFSEXEC) is invoked which accepts input from the user and\n echoes it, but does not generate any additional output to display.\n All of the ISPF features (scrolling, input retrieval, FIND command)\n are available.  The END command terminates the dialog.\n\n Although ZFSEXEC is designed to intercept all Lisp print operations\n (except for low-level error messages or garbage collection messages),\n it does not intercept read operations, nor is it designed to.  The\n application essentially is designed to behave like a top-level\n interpreter.  Invocation of arbitrary Lisp code that issues read\n operations entails problems with the terminal interface that the\n :terpri-exit-function is provided to attempt to deal with (poorly).\n\nExamples:\n\n; Here's how ZFSEXEC is used inside an implementation of ISPF\n; full-screen support for ZIL:\n\n (ZFSEXEC :panel-name           \"XFSZIL\"\n          :panel-library        \"'SEB1525.CMD.PANEL'\"\n          :short-appl           \"Lisp\"\n          :long-appl            (string-append \"ZIL Lisp \" *version*)\n          :terpri-exit-function nil\n          :initialize-function  #'fszil-user-initialize\n          :terminate-function   nil\n          :panel-init-function  nil\n          :echo-input-function  nil\n          :expr-list-function   #'fszil-user-get-expression-list\n          :refreshp-function    #'fszil-user-refreshp\n          :eval-expr-function   #'fszil-user-eval-expr\n          :good-eval-function   #'fszil-user-good-eval\n          :bad-eval-function    nil\n          :post-eval-function   nil\n          :display-function     #'fszil-user-display-value\n          :output-row-function  nil\n )\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZGETFPI": {"ttr": 8214, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17!\\x00-\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:21:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZGETFPI\n\nSyntax:   (ZGETFPI &optional arg1)\n\n arg1 (optional, evaluated) - an input file name.\n\nReturns:\n\n A fixnum representing the current character position of the\n input file specified by arg1.\n\nProcessing:\n\n The current character pointer is obtained from the file block and\n a fixnum is created from it.\n\n The value is a 1-based column value, and ranges from 1 to the logical\n line length of the input file.\n\n If end-of-line is currently true of the file, -1 is returned.\n\n The first argument, if omitted, defaults to NIL, which represents\n the standard input file.\n\n The value of the current character pointer for an input file is\n altered implicitly by input functions like READ, READCH and TYI,\n or explicitly by the ZPUTFPI function.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\nExamples:\n\n (ZGETFPI) and (ZGETFPI NIL) are equivalent and return the current\n           character pointer of the standard input file.\n\n (ZGETFPI 'FOO) returns the current character pointer of input file FOO.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZGETFPO": {"ttr": 8216, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17\"\\x000\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:22:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZGETFPO\n\nSyntax:   (ZGETFPO &optional arg1)\n\n arg1 (optional, evaluated) - an output file name.\n\nReturns:\n\n A fixnum representing the current character position of the\n output file specified by arg1.\n\nProcessing:\n\n The current character pointer is obtained from the file block and\n a fixnum is created from it.\n\n The value is a 1-based column value, and ranges from 1 to the logical\n line length of the output file, with the following exception:\n\n If the file is the standard output file (NIL), position 0 contains\n the current print control character.  This value may be returned\n by ZGETFPO if a previous ZPUTFPO set it to that value and no PRIN1,\n PRINT or TERPRI has been issued to that file.\n\n The first argument, if omitted, defaults to NIL, which represents\n the standard output file.\n\n The value of the current character pointer for an output file is\n altered implicitly by output functions like PRINC, PRIN1 and TERPRI,\n or explicitly by the ZPUTFPO function.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n\nNotes:\n\n See member $FILE for more information on file names.\n\nExamples:\n\n (ZGETFPO) and (ZGETFPO NIL) are equivalent and return the current\n           character pointer of the standard output file.\n\n (ZGETFPO 'FOO) returns the current character pointer of output file FOO\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILADD": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x14/\\x00\\x87%\\x8f\\x17#\\x00\\x8d\\x00\\x95\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-05-22T00:00:00", "modifydate": "1987-09-15T17:23:00", "lines": 141, "newlines": 149, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILADD\n\nSyntax:   (ZILADD num1 num2)\n\n num1 (required, evaluated) - a number.\n num2 (required, evaluated) - a number.\n\nReturns:\n\n The sum of the two arguments (num1 + num2).\n\nProcessing:\n\n This is the low-level 2-argument function that underlies PLUS and +.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for more information.\n\nNotes:\n\n See member $ARITH for more information.\n\nExamples:\n\n (ZILADD 1 2)     ==> 3\n (ZILADD 1.0 2)   ==> 3.0\n (ZILADD 1.0 2.0) ==> 3.0\n (ZILADD 1 2.0)   ==> 3.0\n\n; The following are included here for the purpose of verification of\n; the bignum ADD package.\n\n(ZILADD 1 0) ==> 1\n(ZILADD 1 1) ==> 2\n(ZILADD 1 -1) ==> 0\n(ZILADD 1 -2) ==> -1\n(ZILADD 1 2147483646) ==> 21\n(ZILADD 1 2147483647) ==> 21\n(ZILADD 1 2147483648) ==> 21\n(ZILADD 1 -2147483648) ==> -21\n(ZILADD 1 -2147483649) ==> -21\n(ZILADD 1 -2147483650) ==> -21\n(ZILADD 1 -2147483651) ==> -21\n; (ZILADD 1 (2\u00ac31-1)*((2\u00ac31)\u00ac5 + (2\u00ac31)\u00ac4)) follows\n(ZILADD 1 -98079714615416886913666561805061133785138390855265026048) ==>\n      -980797146154168869136665618050611337851383908552\n; (ZILADD 1 2\u00ac155-1) follows\n(ZILADD 1 45671926166590716193865151022383844364247891967) ==>\n      456719261665907161938651510223838443642\n; ZILADD tests\n(ZILADD 0 0) ==> 0\n(ZILADD 0 1) ==> 1\n(ZILADD 0 -1) ==> -1\n(ZILADD 1 0) ==> 1\n(ZILADD 1 1) ==> 2\n(ZILADD 1 -1) ==> 0\n(ZILADD -1 0) ==> -1\n(ZILADD -1 1) ==> 0\n(ZILADD -1 -1) ==> -2\n(ZILADD 2147483647 2147483647) ==> 42\n(ZILADD 2147483647 -2147483647) ==> 0\n(ZILADD -2147483647 2147483647) ==> 0\n(ZILADD -2147483647 -2147483647) ==> -42\n(ZILADD 2147483647 2147483648) ==> 42\n(ZILADD 2147483647 -2147483648) ==> -1\n(ZILADD -2147483647 2147483648) ==> 1\n(ZILADD -2147483647 -2147483648) ==> -42\n(ZILADD 2147483648 2147483647) ==> 42\n(ZILADD 2147483648 -2147483647) ==> 1\n(ZILADD -2147483648 2147483647) ==> -1\n(ZILADD -2147483648 -2147483647) ==> -42\n(ZILADD 2147483648 2147483648) ==> 42\n(ZILADD 2147483648 -2147483648) ==> 0\n(ZILADD -2147483648 2147483648) ==> 0\n(ZILADD -2147483648 -2147483648) ==> -42\n(ZILADD 2147483647         1) ==>  21\n(ZILADD 2147483647        -1) ==>  21\n(ZILADD 2147483648         1) ==>  21\n(ZILADD 2147483648        -1) ==>  21\n(ZILADD -2147483647       -1) ==> -21\n(ZILADD -2147483647        1) ==> -21\n(ZILADD -2147483648       -1) ==> -21\n(ZILADD -2147483648        1) ==> -21\n(ZILADD        1  2147483647) ==>  21\n(ZILADD       -1  2147483647) ==>  21\n(ZILADD        1  2147483648) ==>  21\n(ZILADD       -1  2147483648) ==>  21\n(ZILADD       -1 -2147483647) ==> -21\n(ZILADD        1 -2147483647) ==> -21\n(ZILADD       -1 -2147483648) ==> -21\n(ZILADD        1 -2147483648) ==> -21\n(ZILADD 10000000000000000000000000000000\n     -999999999999999999999999999999999999999) ==> 1\n(ZILADD -10000000000000000000000000000000\n       999999999999999999999999999999999999999) ==> -1\n(ZILADD 79228162514264337593543950336 -79228162514264337593543950335) ==> 1\n(ZILADD -79228162514264337593543950336 79228162514264337593543950335) ==> -1\n(ZILADD 79228162514264337593543950335 -79228162514264337593543950336) ==> -1\n(ZILADD -79228162514264337593543950335 79228162514264337593543950336) ==> 1\n(ZILADD 79228162514264337593543950337 -79228162514264337593543950335) ==> 2\n(ZILADD -79228162514264337593543950337 79228162514264337593543950335) ==> -2\n(ZILADD 79228162514264337593543950335 -79228162514264337593543950337) ==> -2\n(ZILADD -79228162514264337593543950335 79228162514264337593543950337) ==> 2\n(ZILADD 4294967295 -2147483648) ==> 21\n(ZILADD -2147483648 4294967295) ==> 21\n(ZILADD -4294967295 2147483648) ==> -21\n(ZILADD 2147483648 -4294967295) ==> -21\n(ZILADD 4294967295 -2147483649) ==> 21\n(ZILADD -2147483649 4294967295) ==> 21\n(ZILADD -4294967295 2147483649) ==> -21\n(ZILADD 2147483649 -4294967295) ==> -21\n(ZILADD 1000000000000000000000000000000000000000000000000000000\n     -100000000000000000000000000000000000000000000000000000000000000) ==> 0\n(ZILADD 1000000000000000000000000000000000000000000000000000000\n                                   -100000000000000000000000000000000)\n  ==>  999999999999999999999999999999000000000000000000000000\n(ZILADD -1000000000000000000000000000000000000000000000000000000\n                                    100000000000000000000000000000000)\n  ==> -999999999999999999999999999999000000000000000000000000\n(ZILADD                             1000000000000000000000000\n     -100000000000000000000000000000000000000000000000000000000000000)\n  ==> -999999999999999999999999999999000000000000000000000000\n(ZILADD                            -1000000000000000000000000\n      100000000000000000000000000000000000000000000000000000000000000)\n  ==>  999999999999999999999999999999000000000000000000000000\n(ZILADD 1000000000000000000000000000000000000000000000000000000\n      -99999999999999999999999999999900000000000000000000000000000000)\n  ==>                               1000000000000000000000000\n(ZILADD -1000000000000000000000000000000000000000000000000000000\n       99999999999999999999999999999900000000000000000000000000000000)\n  ==>                              -1000000000000000000000000\n(ZILADD 999999999999999999999999999999000000000000000000000000\n     -100000000000000000000000000000000000000000000000000000000000000)\n  ==>                              -1000000000000000000000000\n(ZILADD -999999999999999999999999999999000000000000000000000000\n      100000000000000000000000000000000000000000000000000000000000000)\n  ==>                               1000000000000000000000000\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILAPPLY": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\tI\\x00'\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:49:00", "lines": 39, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILAPPLY\n\nSyntax:   (ZILAPPLY fun1 list2 &optional env3 name4)\n\n fun1  (required, evaluated) - an atom or proper list.\n list2 (required, evaluated) - an argument list.\n env3  (optional, evaluated) - an evaluation environment.\n name4 (optional, evaluated) - a function name for error messages.\n\nReturns:\n\n The result of applying the function specified by fun1 to the argument\n list specified by list2.\n\nProcessing:\n\n See APPLY for what fun1 must be.\n\n The following are all equivalent to (ZILAPPLY F '(1 2 3)):\n\n  (APPLY F '(1 2 3))\n  (APPLY F 1 '(2 3))\n  (APPLY F 1 2 '(3))\n  (APPLY F 1 2 3 NIL)\n\nErrors signaled:\n\n See APPLY.\n\nNotes:\n\n ZILAPPLY is the internal ZIL function that underlies APPLY.  It has\n the capability of being passed an evaluation environment and a\n function name for error messages, which APPLY does not give you.\n On the other hand, it does not have the flexible syntax of APPLY\n with respect to specifying the argument list.\n Not for general use.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILBOOL": {"ttr": 8454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x08D\\x001\\x001\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T08:44:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILBOOL\n\nSyntax:   (ZILBOOL op1 arg2 arg3)\n\n op1  (required, evaluated) - a fixnum between 0 and 15, inclusive.\n arg2 (required, evaluated) - a fixnum.\n arg3 (required, evaluated) - a fixnum.\n\nReturns:\n\n A fixnum containing the result of a logical operation performed on\n arg2 and arg3.  The logical operation is specified by op1.\n\nProcessing:\n\n This is a fixnum-only operation.  op1 specifies the Boolean operation\n to be performed on arg2 and arg3.\n\n See BOOLE for the operations performed.\n\nErrors signaled:\n\n op1 not a fixnum between 0 and 15 inclusive.\n arg2 or arg3 not a fixnum.\n\nNotes:\n\n This is the low-level 3-argument function that underlies BOOLE.\n\nExamples:\n\n (ZILBOOL  0 #z0000FFFF #zF0F0F0F0)   ==> #z\n (ZILBOOL  1 #z0000FFFF #zF0F0F0F0)   ==> #z0000F0F0\n (ZILBOOL  2 #z0000FFFF #zF0F0F0F0)   ==> #zF0F00000\n (ZILBOOL  3 #z0000FFFF #zF0F0F0F0)   ==> #zF0F0F0F0\n (ZILBOOL  4 #z0000FFFF #zF0F0F0F0)   ==> #z00000F0F\n (ZILBOOL  5 #z0000FFFF #zF0F0F0F0)   ==> #z0000FFFF\n (ZILBOOL  6 #z0000FFFF #zF0F0F0F0)   ==> #zF0F00F0F\n (ZILBOOL  7 #z0000FFFF #zF0F0F0F0)   ==> #zF0F0FFFF\n (ZILBOOL  8 #z0000FFFF #zF0F0F0F0)   ==> #z0F0F0000\n (ZILBOOL  9 #z0000FFFF #zF0F0F0F0)   ==> #z0F0FF0F0\n (ZILBOOL 10 #z0000FFFF #zF0F0F0F0)   ==> #zFFFF0000\n (ZILBOOL 11 #z0000FFFF #zF0F0F0F0)   ==> #zFFFFF0F0\n (ZILBOOL 12 #z0000FFFF #zF0F0F0F0)   ==> #z0F0F0F0F\n (ZILBOOL 13 #z0000FFFF #zF0F0F0F0)   ==> #z0F0FFFFF\n (ZILBOOL 14 #z0000FFFF #zF0F0F0F0)   ==> #zFFFF0F0F\n (ZILBOOL 15 #z0000FFFF #zF0F0F0F0)   ==> #zFFFFFFFF\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILCLOSE": {"ttr": 8456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x08I\\x00#\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T08:49:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILCLOSE\n\nSyntax:   (ZILCLOSE file1 arg2)\n\n file1 (required, evaluated) - a file name.\n arg2  (required, evaluated) - a fixnum.\n\nReturns:\n\n NIL, after closing the file specified by file1.  The type of file\n access is determined by arg2.\n\nProcessing:\n\n See CLOSE for processing.\n\n arg2 is a fixnum that determines the type of file access.  Its contents\n are system-dependent.\n\nErrors signaled:\n\n See CLOSE for errors.\n\nNotes:\n\n This function underlies CLOSE.\n\n See member $FILE for more information on file names.\n\nExamples:\n\n ; None.  Use CLOSE, not this internal function whose processing of\n ; arg2 could change at any time.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILDIV": {"ttr": 8458, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x14/\\x00\\x87%\\x8f\\x17&\\x00\"\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-05-22T00:00:00", "modifydate": "1987-09-15T17:26:00", "lines": 34, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILDIV\n\nSyntax:   (ZILDIV num1 num2)\n\n num1 (required,evaluated) - a number.\n num2 (required,evaluated) - a number.\n\nReturns:\n\n The quotient of the two arguments (num1 / num2).\n\nProcessing:\n\n This is the low-level 2-argument function that underlies QUOTIENT and /\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n num2 is zero.\n See member $ARITH for more information.\n\nNotes:\n\n See member $ARITH for more information.\n\nExamples:\n\n (ZILDIV 6 2)      ==> 3\n (ZILDIV 9 2)      ==> 4\n (ZILDIV -10 3)    ==> -3\n (ZILDIV 5.0 2)    ==> 2.5\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILDSNI": {"ttr": 8460, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x02\\x7f\\x00\\x88\\x02\\x7f\\x08B\\x00,\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-27T00:00:00", "modifydate": "1988-01-27T08:42:00", "lines": 44, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILDSNI\n\nSyntax:   (ZILDSNI file1)\n\n file1 (required, evaluated) - a file name.\n\nReturns:\n\n A string containing the actual data set name (and member name, if any)\n to which the input file file1 is allocated.\n\nProcessing:\n\n A string is built as follows:  If file1 is a terminal file (i.e.\n allocated to the terminal or associated with the terminal by default),\n the string \"*\" is returned.  Otherwise file1 is accessed as an input\n file, and opened if not already open, and the data set name and the\n member name (if any) are retrieved from the JFCB for the file.\n Trailing blanks are removed from both the dsname and the member, and\n parentheses are included in the name if a member is present.  Single\n quotes are NOT included.\n\nErrors signaled:\n\n file1 not a valid input file name.\n file1 is not open (this can't happen, can it?).\n Not enough vector/string space to return string.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Because an MVS file (ddname) allocation remains around even after\n the file is closed under ZIL, issuing ZILDSNI against a closed\n input file will cause the file to be reopened.\n\nExamples:\n\n (ZILDSNI NIL)   will normally return \"*\".\n (ZILDSNI (OPEN \"foo.bar\"))  will return \"ABC1234.FOO.BAR\".\n (ZILDSNI (OPEN \"'foo.bar'\"))  will return \"FOO.BAR\".\n (ZILDSNI (OPEN \"'foo.bar(baz)'\"))  will return \"FOO.BAR(BAZ)\".\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILDSNO": {"ttr": 8462, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x02\\x7f\\x00\\x88\\x02\\x7f\\x08B\\x00,\\x00,\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-01-27T00:00:00", "modifydate": "1988-01-27T08:42:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILDSNO\n\nSyntax:   (ZILDSNO file1)\n\n file1 (required, evaluated) - a file name.\n\nReturns:\n\n A string containing the actual data set name (and member name, if any)\n to which the output file file1 is allocated.\n\nProcessing:\n\n A string is built as follows:  If file1 is a terminal file (i.e.\n allocated to the terminal or associated with the terminal by default),\n the string \"*\" is returned.  Otherwise file1 is accessed as an output\n file, and opened if not already open, and the data set name and the\n member name (if any) are retrieved from the JFCB for the file.\n Trailing blanks are removed from both the dsname and the member, and\n parentheses are included in the name if a member is present.  Single\n quotes are NOT included.\n\nErrors signaled:\n\n file1 not a valid output file name.\n file1 is not open (this can't happen, can it?).\n Not enough vector/string space to return string.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Because an MVS file (ddname) allocation remains around even after\n the file is closed under ZIL, issuing ZILDSNO against a closed\n output file will cause the file to be reopened.\n\nExamples:\n\n (ZILDSNO NIL)   will normally return \"*\".\n (ZILDSNO (OPEN \"foo.bar\" 'out))  will return \"ABC1234.FOO.BAR\".\n (ZILDSNO (OPEN \"'foo.bar'\" 'out))  will return \"FOO.BAR\".\n (ZILDSNO (OPEN \"'foo.bar(baz)'\" 'out))  will return \"FOO.BAR(BAZ)\".\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILDUMP": {"ttr": 8464, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x177\\x007\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T17:37:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILDUMP\n\nSyntax:   (ZILDUMP arg1)\n\n arg1 (required, evaluated) - a number or string.\n\nReturns:\n\n A string containing a hexadecimal representation of arg1.\n\nProcessing:\n\n If arg1 is a fixnum, a string of 8 hex characters representing the\n fullword integer value is returned.\n\n If arg1 is a bignum, a list of ZILDUMPed integers is returned\n representing the 31-bit \"bigits\" that make up the bignum.  The\n list is isomorphic to that returned by BIGLIST (q.v.).  See member\n $BIGNUM for more information about the internals of bignums.\n\n If arg1 is a single-float, a string of 8 hex characters representing\n the contents of the fullword containing the IBM/370 floating-point\n value is returned.  The first 2 hex characters represent the\n characteristic and the rest represent the mantissa.\n\n If arg1 is a DOUBLE-float, a string of 16 hex characters representing\n the contents of the doubleword containing the IBM/370 floating-point\n value is returned.  The first 2 hex characters represent the\n characteristic and the rest represent the mantissa.\n\n If arg1 is a string, a string of hex characters representing the\n EBCDIC contents of the string is returned.  The number of characters\n in the value is, of course, 2 times the length of the arg1 string.\n\nErrors signaled:\n\n arg1 not a number or a string.\n\nNotes:\n\n This differs from using FORMAT to convert an integer to hex.\n\nExamples:\n\n (ZILDUMP 1)             ==> \"00000001\"\n (ZILDUMP 4095)          ==> \"00000FFF\"\n (ZILDUMP -1)            ==> \"FFFFFFFF\"\n (ZILDUMP 2147483648)    ==> (\"00000000\" \"00000001\")\n (ZILDUMP -2147483648)   ==> \"80000000\"\n (ZILDUMP 1.0D0)         ==> \"4110000000000000\"\n (ZILDUMP 1.0F0)         ==> \"41100000\"\n (ZILDUMP \"foo\")         ==> \"869696\"\n (ZILDUMP \" \")           ==> \"40\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILEDIT": {"ttr": 8466, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x1f\\x00\\x87%\\x8f\\x17(\\x00B\\x00+\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-31T00:00:00", "modifydate": "1987-09-15T17:28:00", "lines": 66, "newlines": 43, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILEDIT\n\nSyntax:   (ZILEDIT arg1)\n\n arg1 (required, evaluated) - a data set name (string or symbol).\n\nReturns:\n\n T or NIL, depending on whether the data set specified by arg1 was\n saved after the ISPF editor has been invoked on it.\n\nProcessing:\n\n The ISPF editor is entered on the data set whose name is specified\n by arg1.  If the data was saved, T is returned; otherwise NIL is\n returned.\n\n If a PDS without a member name is specified, an ISPF member list\n will be displayed; in other words, this function is just like the\n ISPF EDIT service, and is in fact a direct interface thereto.\n\n No attempt is made to load the contents of the data set into the\n ZIL environment.\n\n This function is valid only if ZIL was entered under ISPF.\n\n Furthermore, if ZILEDIT is invoked from within a LISP program\n (including the interpreter) that was invoked under ISPF via the Draper\n XINVOKE command, or via a command or program that uses the\n TSO/Extensions Authorized Service Facility, it will fail due to ISPF\n dialog services not being available.\n\nErrors signaled:\n\n Arg1 not a symbol or a string, or a null string, or a string\n longer than 56 characters.\n\n ISPF dialog services not available; either ZIL is running outside\n of ISPF or it is running under the TSO Authorized Service Facility\n or other environment where ISPF dialog services are temporarily\n unavailable.\n\n Errors detected by ISPF dialog services (data set not available, etc.).\n\nNotes:\n\n ISPF and ISPF/PDF Version 2 must be installed to use this function.\n\n This function underlies ED.\n\n ZILEDIT may be used to edit any type of dataset, not just ZIL datasets.\n Use ED to edit function definitions.\n\n If you were in split screen mode when you started ZIL, you will\n be put back into the same split screen mode when ZILEDIT enters ISPF.\n\n The data set is opened for output.  See HELP for OPEN for more\n information on valid data set names.\n\nExamples:\n\n (ZILEDIT \"cmd.clist(zlogon)\")\n\n allows you to edit your ZLOGON CLIST while under ZIL.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILEQUAL": {"ttr": 8468, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87$\\x7f\\x00\\x87&\\x1f#\\x07\\x00F\\x00Z\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-09-04T00:00:00", "modifydate": "1987-09-18T23:07:00", "lines": 70, "newlines": 90, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILEQUAL\n\nSyntax:   (ZILEQUAL arg1 arg2)\n  Also:   (= arg1 &rest args)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - any LISP object.\n args (optional, evaluated) - any LISP object.\n\nReturns:\n\n T if the contents of all the args are identical, else NIL.\n\nProcessing:\n\n For ZILEQUAL, which takes exactly two args, the following holds.\n\n  If the arguments are EQ, regardless of type, the result is\n  always true (i.e. T is returned).\n\n  If one argument is numeric and the other is not, an error is\n  signalled, since the arguments cannot be compared.\n\n  (Exception: If one argument is numeric and the other is NIL,\n   the result is false.  This is a special case intended to handle\n   certain operations on lists of characters.)\n\n  If both arguments are numbers, a numeric comparison is performed.\n  If the types differ, the appropriate conversion is performed (see\n  member $ARITH for conversion rules) and the numeric compare is done.\n\n  If both arguments are strings or symbols, a comparison is performed on\n  the print name or string text of the atoms.  Note that case remains\n  significant in this comparison.\n\n  For all other types (including lists), an error is signalled, since\n  the arguments cannot be compared.\n\n For =, which takes any number of args, the result is T if there is\n only one arg, or if all the args are ZILEQUAL to each other (only\n adjacent pairs are compared); otherwise the result is NIL.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n See member $EQUAL for more information about equality predicates.\n\nExamples:\n\n (ZILEQUAL 'FOO 'FOO)     ==> T\n (ZILEQUAL 'A 'B)         ==> NIL\n (ZILEQUAL (ADD1 1) 2)    ==> T\n (ZILEQUAL 1 1.0)         ==> T\n (ZILEQUAL \"A\" \"A\")       ==> T\n (ZILEQUAL \"A\" \"a\")       ==> NIL\n (ZILEQUAL \"A\" 'A )       ==> T\n\n (= 1.0)                  ==> T\n (= 1.0 1.0)              ==> T\n (= 1.0 1.0 1.0)          ==> T\n (= 1.0 2.0 3.0 4.0)      ==> NIL\n (= 1.0 2.0 1.0 1.0 1.0)  ==> NIL\n\n (ZILEQUAL 1 NIL)         ==> NIL\n (ZILEQUAL NIL 1.0)       ==> NIL\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILEVAL": {"ttr": 8470, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\tI\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:49:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILEVAL\n\nSyntax:   (ZILEVAL arg1 arg2 arg3)\n\n arg1 (required, evaluated) - an atom or proper list.\n arg2 (required, evaluated) - an evaluation environment.\n arg3 (required, evaluated) - T or NIL.\n\nReturns:\n\n The result of evaluating arg1, with the evalation environment\n specified by arg2 being used to resolve variable bindings.\n\nProcessing:\n\n See EVAL.\n\n arg3 is T if this evaluation is to be considered at \"top level\",\n otherwise NIL.\n\nErrors signaled:\n\n See EVAL.\n\nNotes:\n\n ZILEVAL is the internal ZIL function that underlies EVAL.  It\n permits you to pass a complete evaluation environment to EVAL.\n Not for general use.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILEXPL": {"ttr": 8472, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\t\\x02\\x005\\x005\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T09:02:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILEXPL\n\nSyntax:   (ZILEXPL arg1 &optional arg2 arg3)\n\n arg1 (required, evaluated) - an atom.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n arg3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A list of either single-character symbols or fixnums, corresponding to\n the character representation of arg1 as printed out via PRINC or PRIN1.\n\nProcessing:\n\n arg1 is converted to the character representation which it has when it\n is printed - as it looks via either PRINC or PRIN1, depending on arg3.\n\n Each character in this representation is then used to build either a\n single-character symbol or a fixnum, depending on arg2; all of these\n are then consed together to form a list, which is returned as the\n value.\n\n arg2 defaults to NIL.  Processing is as follows, depending on the\n value of arg2:\n\n  If arg2 is NIL, the objects generated are uninterned symbols.\n  If arg2 is T, the objects generated are interned symbols.\n  If arg2 is a fixnum, the objects generated are fixnums (characters).\n\n arg3 defaults to NIL.  If arg3 is specified and non-NIL, the argument\n is processed as it looks when it is printed out via PRIN1 (i.e. it is\n \"slashified\"); otherwise it is processed as it looks when it is\n printed out via PRINC.\n\nErrors signaled:\n\n arg1 is a list, vector or structure, which cannot be exploded.\n\nNotes:\n\n This function underlies EXPLODE, EXPLODEC and EXPLODEN.\n\nExamples:\n\n (ZILEXPL '|007| NIL NIL) ==> (|0| |0| |7|)           ; all uninterned\n (ZILEXPL '|007| NIL T  ) ==> (|\\|| |0| |0| |7| |\\||) ; all uninterned\n (ZILEXPL '|007| T   NIL) ==> (|0| |0| |7|)           ; all interned\n (ZILEXPL '|007| T   T  ) ==> (|\\|| |0| |0| |7| |\\||) ; all interned\n (ZILEXPL '|007| 0   NIL) ==> (#\\0 #\\0 #\\7)           ; all fixnums\n (ZILEXPL '|007| 0   T  ) ==> (#\\| #\\0 #\\0 #\\7 #\\|)   ; all fixnums\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILFLAT": {"ttr": 8474, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\tP\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:50:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILFLAT\n\nSyntax:   (ZILFLAT arg1 arg2)\n\n arg1 (required, evaluated) - any LISP object.\n arg2 (required, evaluated) - T or NIL.\n\nReturns:\n\n An integer containing the number of characters required to print\n out the represention of arg1 (via PRINC if arg2 is NIL, via PRIN1\n if arg2 is T).\n\nProcessing:\n\n The number of character positions taken up by the printed format\n of the object is returned as the value.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n ZILFLAT is the internal ZIL function that underlies FLATC and\n FLATSIZE.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILHELP": {"ttr": 8476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\tR\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:52:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILHELP\n\nSyntax:   (ZILHELP &optional arg1 arg2)\n\n arg1 (optional, evaluated) - a symbol.\n arg2 (optional, evaluated) - any LISP object, generally T or NIL.\n\nReturns:\n\n T, after listing the on-line ZIL documentation member of the name\n specified by arg1.\n\nProcessing:\n\n See HELP.\n\nErrors signaled:\n\n See HELP.\n\nNotes:\n\n ZILHELP is the internal ZIL function that underlies HELP.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILIMPL": {"ttr": 8478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x04\\x9f\\x00\\x87%\\x8f\\x170\\x00J\\x00J\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-18T00:00:00", "modifydate": "1987-09-15T17:30:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILIMPL\n\nSyntax:   (ZILIMPL arg1 &optional arg2 arg3)\n\n arg1 (required, evaluated) - a proper list of atoms.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n arg3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A symbol whose print name consists of the atoms in the list specified\n by the first argument concatenated to form a new atom name.\n\nProcessing:\n\n The CAR's of the first argument, which must be a non-null list of\n atoms, are converted to the character representations that they have\n when printed via PRINC.  These are the actual print names for symbols,\n the text for strings, converted representations for numbers, and\n internally generated values for other types.  The resulting character\n strings are concatenated together to build a symbol whose name is that\n string.\n\n arg1 may be NIL, in which case a symbol with a null print name is\n returned.\n\n If the second argument is non-NIL, the resulting atom is interned on\n the oblist; otherwise it is not interned (this is the default\n behavior), meaning that it will not be EQ to any other atom.\n\n If the third argument is non-NIL, the atom building routine will\n attempt to convert the atom to a numeric type, according to its\n syntax as the READ function would interpret it.  If the third\n argument is NIL, the atom created is always a symbol (this is\n the default behavior).\n\n Note that when a non-NIL third argument is specified, the following\n holds true:\n\n (1) If the atom is numeric, the setting of the second argument is\n     ignored, since only symbols are ever interned on the oblist.\n\n (2) If the atom is syntactically non-numeric, a symbol will be created.\n     In this case the setting of the second argument is significant.\n\n (3) List notation (parentheses, dots, etc.) is not valid and will\n     be treated as part of a symbol name.\n\n (4) Floating-point overflow is not detected by the code, and may\n     result in a program check (0CC) abend.  Floating-point underflow is\n     ignored and may produce a zero result.\n\nErrors signaled:\n\n arg1 not a list of atoms (nested lists and vectors are not permitted).\n\nNotes:\n\nExamples:\n\n (ZILIMPL '(A))                ==> A\n (ZILIMPL '(F O O))            ==> FOO\n (ZILIMPL '(FOO BAR))          ==> FOOBAR\n (ZILIMPL '(007 1.0 \"foobar\")) ==> |71.0foobar| ; A symbol.\n\n (SETQ A (ZILIMPL '(F O O) NIL))   ==> FOO ; not interned.\n (SETQ B (ZILIMPL '(F O O) T))     ==> FOO ; interned.\n (EQ A 'FOO)                       ==> NIL\n (EQ B 'FOO)                       ==> T\n\n (ZILIMPL '(0 0 7) NIL NIL)    ==> |007| ; a symbol, not a fixnum.\n (ZILIMPL '(0 0 7) NIL T)      ==> 7     ; a fixnum.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILINTLN": {"ttr": 8480, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x15_\\x00\\x88\\x15_\\x10\\x10\\x00;\\x00;\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-06-03T00:00:00", "modifydate": "1988-06-03T10:10:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: INTEGER-LENGTH\n\nSyntax:   (INTEGER-LENGTH arg1)\n    or:   (ZILINTLN arg1)\n\n arg1 (required, evaluated) - an integer.\n\nReturns:\n\n An integer containing the number of significant bits in arg1.\n\nProcessing:\n\n If arg1 is positive, the total number of bits required to represent the\n number is returned, assuming that all leading 0-bits are omitted.\n\n If arg1 is negative, the total number of bits in the two's-complement\n representation of the number is returned, assuming that all leading\n 1-bits are omitted.\n\n If arg1 is zero, 0 is returned.\n\nErrors signaled:\n\n arg1 not an integer.\n\nNotes:\n\n Compare HAULONG, which is equivalent to (integer-length (abs x)).\n\nExamples:\n\n (INTEGER-LENGTH 0) ==> 0\n (INTEGER-LENGTH 1) ==> 1\n (INTEGER-LENGTH 2) ==> 2\n (INTEGER-LENGTH 3) ==> 2\n (INTEGER-LENGTH 4) ==> 3\n (INTEGER-LENGTH 5) ==> 3\n (INTEGER-LENGTH -1) ==> 0\n (INTEGER-LENGTH -2) ==> 1\n (INTEGER-LENGTH -3) ==> 2\n (INTEGER-LENGTH -4) ==> 2\n (INTEGER-LENGTH -5) ==> 3\n (INTEGER-LENGTH #b1001001001) ==> 10\n (INTEGER-LENGTH #b0110110110) ==> 9\n (INTEGER-LENGTH 2147483647) ==> 31\n (INTEGER-LENGTH 2147483648) ==> 32\n (INTEGER-LENGTH 2147483649) ==> 32\n (INTEGER-LENGTH -2147483647) ==> 31\n (INTEGER-LENGTH -2147483648) ==> 31\n (INTEGER-LENGTH -2147483649) ==> 32\n (INTEGER-LENGTH (** 2 60))            ==> 61\n (INTEGER-LENGTH (+ (** 2 60) +1))     ==> 61\n (INTEGER-LENGTH (+ (** 2 60) -1))     ==> 60\n (INTEGER-LENGTH (- (** 2 60)))        ==> 60\n (INTEGER-LENGTH (- (+ (** 2 60) +1))) ==> 61\n (INTEGER-LENGTH (- (+ (** 2 60) -1))) ==> 60\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILLOAD": {"ttr": 8482, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x178\\x00o\\x00\\x7f\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:38:00", "lines": 111, "newlines": 127, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILLOAD\n\nSyntax:   (ZILLOAD arg1)\n\n arg1 (required, evaluated) - a symbol (or string).\n\nReturns:\n\n The compiled code object with the same name as arg1, if it exists in\n storage or on the system library; otherwise NIL.\n\nProcessing:\n\n ZILLOAD builds the 8-character load module name to be searched for from\n the first argument; if the first argument is not a string or a symbol,\n or if it is longer than 8 characters, an error is signalled.\n\n It first searches its own table of in-memory module names; this table\n contains pointers to selected commonly used modules that are likely\n to be linkedited with the interpreter.  If it finds it, it returns\n the address of the in-line or linkedited code.\n\n If the module is not found this way, ZILLOAD then searches active\n system storage for the load module to see if it has already been\n loaded.  If it finds it, it then proceeds to resolve the external\n references to other functions (since these functions, if not resolved\n the first time this function was loaded, may have been loaded in\n afterwards).\n\n If the module is not currently in memory, then the BLDL system service\n is invoked to locate the directory entry for the load module in the\n system library.  If BLDL returns a code of 8, meaning that either there\n was an I/O error searching the directory or not enough system storage\n was available, an error is signalled since processing probably cannot\n continue productively.  If BLDL could not find a directory entry for\n the module, meaning that no such compiled function exists, ZILLOAD\n returns NIL (if this is the primary level of function search).\n\n If BLDL finds the module successfully, then the LOAD system service is\n issued to load the module into storage, and the entry point address of\n the module is used to construct the compiled code object, which is the\n value returned by ZILLOAD.\n\n If the LOAD operation failed, ZILLOAD returns NIL to indicate that the\n function was not loaded.\n\n ZILLOAD now must resolve external references within the compiled code,\n which would have been resolved by the linkage editor had the code been\n included in a ZIL program.  Each section of code contains a list of\n function names to which references exists; these may refer to internal\n subroutines in the same code, which may in turn have lists of external\n calls, etc., etc.  ZILLOAD processes the entire tree of external\n references recursively, re-invoking the search-and-load process for\n each one, and sending a message to the user's TSO terminal whenever a\n module cannot be located in the system library.\n\n If an external reference cannot be resolved because the module cannot\n be found, ZILLOAD continues with the next one.  The pointer to the\n unresolved code in the compiled function is replaced with the address\n of a special in-line routine that signals an \"call to unresolved\n compiled function\" error if a path is taken through the code that\n attempts to execute that function.  This could be caused by an\n erroneous use of DEFARGS in a compiled function or module.\n\n When this process is complete, ZILLOAD has the entry point address of\n the originally requested module.  This is used to CONS up the compiled\n code object which is the return value.\n\nErrors signaled:\n\n Invalid compiled function (the name of an internal ZIL routine was\n specified).\n BLDL error (the BLDL system service returned a code of 8).\n\nNotes:\n\n ZILLOAD is the only function that can create a compiled code object\n dynamically under the interpreter.  The result is generally stored as\n the value of a symbol's SUBR property.\n\n ZILXSUB (or FUNCALL or APPLY) may be used to execute the compiled code\n object returned by ZILLOAD.\n\n When ZILLOAD is invoked by the interpreter to resolve a function, it is\n passed the function's AUTOLOAD property if it has one and it is a\n symbol.  The DEFLOAD special form is used to assign AUTOLOAD properties\n to functions under the interpreter.\n\n Special forms have no compiled code definitions associated with them;\n ZILLOAD cannot be used to load them.\n\n In the ZIL environment, the term \"system library\" refers to the task\n library under which the ZIL program was invoked, or the step library\n defined by a //STEPLIB DD statement in batch.  Thus, a zero return code\n from BLDL does not necessarily mean to ZILLOAD that the function was\n located; ZILLOAD must verify that the directory entry came from an\n acceptable library and not from the operating system link list or from\n the link pack area.\n\nExamples:\n\n (ZILLOAD 'PUTPROP)  will locate the load module for the PUTPROP\n                     compiled function and return a pointer to it.\n\n (ZILLOAD 'CAR)      will return a pointer to the compiled code\n                     which implements the CAR function.\n\n (ZILLOAD 'COND)     will not find a load module named COND, since\n                     COND is a special form, and will return NIL.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILMUL": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x14/\\x00\\x87%\\x8f\\x179\\x00\\x93\\x00\\x87\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-05-22T00:00:00", "modifydate": "1987-09-15T17:39:00", "lines": 147, "newlines": 135, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILMUL\n\nSyntax:   (ZILMUL num1 num2)\n\n num1 (required,evaluated) - a number.\n num2 (required,evaluated) - a number.\n\nReturns:\n\n The product of the two arguments (num1 * num2).\n\nProcessing:\n\n This is the low-level 2-argument function that underlies TIMES and *.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for more information.\n\nNotes:\n\n See member $ARITH for more information.\n\nExamples:\n\n (ZILMUL 2 3)       ==> 6\n (ZILMUL 4.0 2)     ==> 8.0\n (ZILMUL 4 2.0)     ==> 8.0\n (ZILMUL 4.0 2.0)   ==> 8.0\n\n; The following are included here for the purpose of verification of\n; the bignum MULTIPLY package.\n\n(*  3  4) ==>  12\n(* -3  4) ==> -12\n(* -3 -4) ==>  12\n(*  3 -4) ==> -12\n(*  0  4) ==>   0\n(*  0  4) ==>   0\n(*  4  0) ==>   0\n(* -4  0) ==>   0\n(*  65536  32768) ==>  21\n(*  65536 -32768) ==> -21\n(* -65536  32768) ==> -21\n(* -65536 -32768) ==>  21\n(*  4294967296           1) ==>  42\n(*  4294967296          -1) ==> -42\n(* -4294967296           1) ==> -42\n(* -4294967296          -1) ==>  42\n(*           1  4294967296) ==>  42\n(*           1 -4294967296) ==> -42\n(*          -1  4294967296) ==> -42\n(*          -1 -4294967296) ==>  42\n(*  8589934592           1) ==>  85\n(*  8589934592          -1) ==> -85\n(* -8589934592           1) ==> -85\n(* -8589934592          -1) ==>  85\n(*           1  8589934592) ==>  85\n(*           1 -8589934592) ==> -85\n(*          -1  8589934592) ==> -85\n(*          -1 -8589934592) ==>  85\n(*  2147483647           2) ==>  42\n(*           2  2147483647) ==>  42\n(* -2147483647           2) ==> -42\n(*          -2  2147483647) ==> -42\n(*  2147483647          -2) ==> -42\n(*           2 -2147483647) ==> -42\n(* -2147483647          -2) ==>  42\n(*          -2 -2147483647) ==>  42\n(*  1073741824           2) ==>  21\n(*  1073741824          -2) ==> -21\n(* -1073741824           2) ==> -21\n(* -1073741824          -2) ==>  21\n(*  2           1073741824) ==>  21\n(*  2          -1073741824) ==> -21\n(* -2           1073741824) ==> -21\n(* -2          -1073741824) ==>  21\n(*  2147483647  2147483647) ==>  46116860141\n(*  2147483647 -2147483647) ==> -46116860141\n(* -2147483647  2147483647) ==> -46116860141\n(* -2147483647 -2147483647) ==>  46116860141\n(*  2147483647           0) ==>  0\n(*           0  2147483647) ==>  0\n(*  2147483648  2147483648) ==>  46116860184\n(*  2147483648 -2147483648) ==> -46116860184\n(* -2147483648  2147483648) ==> -46116860184\n(* -2147483648 -2147483648) ==>  46116860184\n(*  2147483648           1) ==>  21\n(*  2147483648          -1) ==> -21\n(* -2147483648           1) ==> -21\n(* -2147483648          -1) ==>  21\n(*  2147483648           0) ==>  0\n(* -2147483648           0) ==>  0\n(*           1  2147483648) ==>  21\n(*           1 -2147483648) ==> -21\n(*          -1  2147483648) ==> -21\n(*          -1 -2147483648) ==>  21\n(*           0  2147483648) ==>  0\n(*           0 -2147483648) ==>  0\n(*  2147483649           1) ==>  21\n(*  2147483649          -1) ==> -21\n(* -2147483649           1) ==> -21\n(* -2147483649          -1) ==>  21\n(*  2147483649           0) ==>  0\n(* -2147483649           0) ==>  0\n(*           1  2147483649) ==>  21\n(*           1 -2147483649) ==> -21\n(*          -1  2147483649) ==> -21\n(*          -1 -2147483649) ==>  21\n(*           0  2147483649) ==>  0\n(*           0 -2147483649) ==>  0\n(*  10000000000   1000000000) ==>  100000000000\n(*  10000000000  -1000000000) ==> -100000000000\n(* -10000000000   1000000000) ==> -100000000000\n(* -10000000000  -1000000000) ==>  100000000000\n(*   1000000000  10000000000) ==>  100000000000\n(*   1000000000 -10000000000) ==> -100000000000\n(*  -1000000000  10000000000) ==> -100000000000\n(*  -1000000000 -10000000000) ==>  100000000000\n(*  10000000000  10000000000) ==>  1000000000000\n(*  10000000000 -10000000000) ==> -1000000000000\n(* -10000000000  10000000000) ==> -1000000000000\n(* -10000000000 -10000000000) ==>  1000000000000\n(*  100000000000000000000  100000000000000000000) ==>  100000000000000000000000000000000\n(*  100000000000000000000 -100000000000000000000) ==> -100000000000000000000000000000000\n(* -100000000000000000000  100000000000000000000) ==> -100000000000000000000000000000000\n(* -100000000000000000000 -100000000000000000000) ==>  100000000000000000000000000000000\n(*  2147483648  2147483648  2147483648) ==>  99035203142830421991\n(*  2147483648  2147483648 -2147483648) ==> -99035203142830421991\n(*  2147483648 -2147483648  2147483648) ==> -99035203142830421991\n(*  2147483648 -2147483648 -2147483648) ==>  99035203142830421991\n(* -2147483648  2147483648  2147483648) ==> -99035203142830421991\n(* -2147483648  2147483648 -2147483648) ==>  99035203142830421991\n(* -2147483648 -2147483648  2147483648) ==>  99035203142830421991\n(* -2147483648 -2147483648 -2147483648) ==> -99035203142830421991\n(*  4611686018427387903  4611686018427387903) ==>  212676479325586539572375409276\n(*  4611686018427387903 -4611686018427387903) ==> -212676479325586539572375409276\n(* -4611686018427387903  4611686018427387903) ==> -212676479325586539572375409276\n(* -4611686018427387903 -4611686018427387903) ==>  212676479325586539572375409276\n(*  10000000000000000000000  100000000000000000000000) ==>  10000000000000000000000000000000000000\n(*  10000000000000000000000 -100000000000000000000000) ==> -10000000000000000000000000000000000000\n(* -10000000000000000000000  100000000000000000000000) ==> -10000000000000000000000000000000000000\n(* -10000000000000000000000 -100000000000000000000000) ==>  10000000000000000000000000000000000000\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILOPEN": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\x08I\\x00#\\x00#\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T08:49:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILOPEN\n\nSyntax:   (ZILOPEN file1 arg2)\n\n file1 (required, evaluated) - a file name.\n arg2  (required, evaluated) - a fixnum.\n\nReturns:\n\n Whatever OPEN is defined to return, after doing what OPEN is supposed\n to do with file1.  The type of file access is determined by arg2.\n\nProcessing:\n\n See OPEN for processing.\n\n arg2 is a fixnum that determines the type of file access.  Its contents\n are system-dependent.\n\nErrors signaled:\n\n See OPEN for errors.\n\nNotes:\n\n This function underlies OPEN.\n\n See member $FILE for more information on file names.\n\nExamples:\n\n ; None.  Use OPEN, not this internal function whose processing of\n ; arg2 could change at any time.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILPKCH": {"ttr": 8710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x13O\\x00\\x88\\x12O\\t\\x18\\x00j\\x00X\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-05-14T00:00:00", "modifydate": "1988-05-03T09:18:00", "lines": 106, "newlines": 88, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILPKCH\n\nSyntax:   (ZILPKCH &optional arg1 arg2 arg3)\n\n arg1 (optional, evaluated) - a file name.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n arg3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A symbol whose print name is a character read from the input file\n specified by arg1, or NIL if end-of-file or end-of-line is encountered\n while scanning for a character.\n\nProcessing:\n\n The file specified by arg1 is read from the current character position\n and logical record (the ENDREAD and ZPUTFPI functions can change\n these).  One character is returned and made into a symbol, but the\n current character pointer is NOT updated to point to the next\n character.  Thus, repeated calls to ZILPKCH without an intervening READ\n or ZILRDCH will return the same value.\n\n Compare ZILRDCH, which is identical to ZILPKCH except that it updates\n the current character pointer (and also causes \"newline\" to be set).\n\n If arg2 is specified and is non-NIL, the generated symbol is \"interned\"\n on the object list; otherwise it is not, in which case it will not be\n EQ to any other atom.\n\n If arg3 is specified and is non-NIL, the character returned from the\n file is translated to upper case before the symbol is built; otherwise\n it is used as is.\n\n If either end-of-file (i.e. the current character pointer has reached\n the end of the file) or end-of-line (i.e. the current character\n pointer has reached the end of the line) is encountered, NIL is\n returned instead of a character.\n\n If the file is already in end-of-file status when ZILPKCH is issued,\n an error is signalled.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n ZILPKCH is designed for applications that need to do scanning in such\n a way as not to \"swallow up\" a character in the input stream.  It is,\n however, not perfect at this time, and its interaction with READ\n and ZILRDCH has not been thoroughly examined.\n\n In the case of end-of-line, ZILPKCH may return NIL following the last\n ZILRDCH that retrieved a character from the current line, and also\n following a ZILRDCH that resulted in a \"newline\" condition; thus it may\n seem that ZILPKCH, when executed in alternation with ZILRDCH, returns two\n NILs in succession.  This is, admittedly, rather dicey, but has to do\n with code in ZILRDCH designed to prevent it from unlocking the terminal\n keyboard when it doesn't really want any new data.\n\n A ZILRDCH following a ZILPKCH should return the same character that\n ZILPKCH did (but not the same atom if interning is not requested).\n\n ZILPKCH does not set NEWLINEP; only ZILRDCH and READLINE do that.\n\nExamples:\n\n (when (null (prefix))\n       (tso (\"profile prefix(\" (userid) \")\"))\n       nil)                          ==> NIL\n\n (progn\n  (with-open-file (file \"$$foo.$$test\" :out)\n   (format file \"~&?foobar~%\")\n  )\n  (setq foo (open \"$$foo.$$test\" :in))\n  t\n )                                  ==> T\n\n (ZILPKCH FOO)                      ==> NIL ; newline\n\n (TYI FOO)                          ==> #\\CR ; swallow first newline\n (TYI FOO)                          ==> #\\?  ; prime for a character\n\n (SETQ   AT1 (ZILPKCH FOO NIL NIL)) ==> |f|\n (EQ     AT1 '|f|)                  ==> NIL\n (=      AT1 '|f|)                  ==> T\n\n (SETQ   AT2 (ZILPKCH FOO T  NIL))  ==> |f|\n (EQ     AT2 '|f|)                  ==> T\n (=      AT2 '|f|)                  ==> T\n\n (SETQ   AT3 (ZILPKCH FOO NIL T ))  ==> |F|\n (EQ     AT3 '|F|)                  ==> NIL\n (=      AT3 '|F|)                  ==> T\n\n (SETQ   AT4 (ZILPKCH FOO T   T ))  ==> |F|\n (EQ     AT4 '|F|)                  ==> T\n (=      AT4 '|F|)                  ==> T\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILPP": {"ttr": 8712, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x04_\\x00\\x88\\x16\\x9f\\x08\\x04\\x00A\\x00=\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-02-14T00:00:00", "modifydate": "1988-06-17T08:04:00", "lines": 65, "newlines": 61, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILPP\n\nSyntax:   (ZILPP arg1 arg2)\n\n arg1 (required, evaluated) - a symbol or LAMBDA-expression.\n arg2 (optional, evaluated) - a file name.\n\nReturns:\n\n No values, after the LISP function specified by arg1, as well as its\n value if any, is pretty-printed on the file specified by arg2.\n\nProcessing:\n\n If arg1 is a symbol, its interpretive function definition is printed.\n If arg1 is a lambda-expression, a fake DEFUN defining the lambda\n expression is printed.  In either case, the output takes the form\n of a DEFUN that creates the function definition.\n\n In addition, if arg1 is a symbol with a value, a fake SETQ assigning\n that value to it is printed.\n\n The interpretive function definition specified by arg1 is printed\n on the output file specified by arg2 in such a way as to:\n\n  (1) be as readable as possible to the human user.\n  (2) be able to be read back in as LISP code.\n\n This is known as \"pretty printing.\"\n\nErrors signaled:\n\n arg1 not a symbol or a lambda-expression.\n No interpretive function definition associated with arg1\n (its function definition may be a compiled code object).\n Function definition not a LAMBDA-expression.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n ZILPP is the same as what PP used to be in ZIL 1.1.  PP now takes\n zero or more unquoted functions names and pretty-prints them to\n the standard output file.\n\n ZILPP may be used to save function definitions in output files, for\n future use, by reading them back in under a later ZIL session.\n See ED.\n\nExamples:\n\n (zilpp 'foo)\n (zilpp 'foo 'out)\n (zilpp '(lambda (x) (foo x)))\n\n (defun foo (a b) (cons b a))\n (zilpp 'foo)\n\n  results in the following being printed on the standard output file:\n\n (DEFUN FOO (A B)\n  (CONS B A)\n )\n\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILPROGV": {"ttr": 8714, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\tU\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T09:55:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILPROGV\n\nSyntax:   (ZILPROGV varlist1 vallist2 closure3)\n\n varlist1 (required, evaluated) - a list of symbols.\n vallist2 (required, evaluated) - a list of LISP objects.\n closure3 (required, evaluated) - a lexical closure.\n\nReturns:\n\n The value returned by executing closure3 in a SPECIAL variable binding\n environment specified by varlist1 and vallist2.\n\nProcessing:\n\n See PROGV.\n\nErrors signaled:\n\n None.\n\nNotes:\n\n ZILPROGV is the internal ZIL function that underlies PROGV, which is\n implemented as a macro which expands by turning the forms into a\n lexical closure.  This should be kept in mind when compiling PROGV\n constructs.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILRDCH": {"ttr": 8716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x87%?\\x00\\x88\\x12O\\x088\\x00O\\x00Q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1987-09-10T00:00:00", "modifydate": "1988-05-03T08:38:00", "lines": 79, "newlines": 81, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILRDCH\n\nSyntax:   (ZILRDCH &optional arg1 arg2 arg3)\n\n arg1 (optional, evaluated) - a file name.\n arg2 (optional, evaluated) - any LISP object, but generally T or NIL.\n arg3 (optional, evaluated) - any LISP object, but generally T or NIL.\n\nReturns:\n\n A symbol whose print name is a character read from the input file\n specified by arg1, or NIL if end-of-file or end-of-line is encountered\n while scanning for a character.\n\nProcessing:\n\n The file specified by arg1 is read from the current character position\n and logical record (the ENDREAD and ZPUTFPI functions can change\n these).  One character is returned and made into a symbol, and the\n current character pointer is updated to point to the next character.\n\n If arg2 is specified and is non-NIL, the generated symbol is \"interned\"\n on the object list; otherwise it is not, in which case it will not be\n EQ to any other atom.\n\n If arg3 is specified and is non-NIL, the character returned from the\n file is translated to upper case before the symbol is built; otherwise\n it is used as is.\n\n If either end-of-file (i.e. the current character pointer has reached\n the end of the file) or end-of-line (i.e. the current character\n pointer has reached the end of the line) is encountered, NIL is\n returned (the EOF and NEWLINEP functions may be used to determine\n which of these was the case).  In the case of end-of-line, the next\n call to ZILRDCH will return either the first character from the next\n line, or end-of-file (note that the end-of-file condition is always\n preceded by the end-of-line condition unless the file is empty).\n\n If the file is already in end-of-file status when ZILRDCH is issued,\n an error is signalled.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n Read after end of file.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n ZILRDCH, READCH, READLINE and TYI are the only functions that can cause\n the \"newline\" indication to be set in an input file (see NEWLINEP).\n\n Currently, if ZILRDCH is issued against a file allocated to the\n terminal (including standard input) which has never been accessed by an\n input function before, it will return NIL and NEWLINEP will return\n true.  In other words, the first input from a terminal file is a\n \"newline\".\n\n Compare ZILPKCH, which is like ZILRDCH but does not change the current\n character pointer.\n\nExamples (assuming the following line of input from file FOO):\n\n fffffffffffffffffffffffffffffff...\n\n (SETQ   AT1 (ZILRDCH 'FOO NIL NIL)) ==> f\n (EQ     AT1 'f)                    ==> NIL\n (EQUALP AT1 'f)                    ==> T\n\n (SETQ   AT2 (ZILRDCH 'FOO T  NIL)) ==> f\n (EQ     AT2 'f)                    ==> T\n (EQUALP AT2 'f)                    ==> T\n\n (SETQ   AT3 (ZILRDCH 'FOO NIL T  ) ==> F\n (EQUALP AT3 'F)                    ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILREM": {"ttr": 8718, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x86\\x14/\\x00\\x87%\\x8f\\x17A\\x00)\\x00-\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-05-22T00:00:00", "modifydate": "1987-09-15T17:41:00", "lines": 41, "newlines": 45, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILREM\n\nSyntax:   (ZILREM num1 num2)\n\n num1 (required,evaluated) - an integer.\n num2 (required,evaluated) - an integer.\n\nReturns:\n\n The remainder of the two arguments (num1 // num2).\n\nProcessing:\n\n This is the low-level 2-argument function that underlies REMAINDER.\n\n See \"IBM/370 Principles of Operation\" for a description of the\n remainder returned from an integer DIVIDE operation, which is\n essentially what this function returns.\n\n When both arguments are positive, the result is equivalent to the\n mathematical MOD function.\n\nErrors signaled:\n\n Non-integer first or second argument.\n Second argument is zero.\n See member $ARITH for more information.\n\nNotes:\n\n See member $ARITH for more information.\n\nExamples:\n\n (ZILREM 6 2)      ==> 0\n (ZILREM 9 2)      ==> 1\n (ZILREM -10 3)    ==> -1\n (ZILREM 10 -3)    ==> 1\n (ZILREM -10 -3)   ==> -1\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSPAD": {"ttr": 8720, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x883?\\x00\\x883?\\x12G\\x00K\\x00K\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-28T00:00:00", "modifydate": "1988-11-28T12:47:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILSPAD\n\nSyntax:   (ZILSPAD str1 len2 pad3 arg4 arg5)\n\n str1 (required, evaluated) - a string.\n len2 (required, evaluated) - a non-negative fixnum.\n pad3 (required, evaluated) - a character (either a string of length 1\n                                        or a fixnum between 0 and 255).\n arg4 (required, evaluated) - any LISP object, but generally T or NIL.\n arg5 (required, evaluated) - a fixnum, generally 1, 0 or -1.\n\nReturns:\n\n A string containing the contents of str1 padded (using the character\n pad3) to the length of len2.\n\nProcessing:\n\n A string of length len2 is returned (unless arg4 is NIL and len2\n is less than the length of string str1, in which case a string of\n the same length as str1 is returned).  The string contains the\n text of str1, padded out to the length len2 using pad3 as the\n pad character.\n\n If arg4 is NIL, no truncation is done; the minimum length of the\n returned string will be the length of str1.\n\n If arg4 is non-NIL, truncation will be done; if len2 is less than\n the length of str1, a string containing only the first len2\n characters of str1 will be returned.\n\n arg5 determines how the padding will be done, as follows:\n\n  If arg5 is positive, the padding will be done on the right.  In\n  other words, the text will be left justified.\n\n  If arg5 is negative, the padding will be done on the left.  In\n  other words, the text will be right justified.\n\n  If arg5 is zero, the padding will be done on both sides.  In\n  other words, the text will be centered.\n\nErrors signaled:\n\n str1 not a string.\n len2 not a valid length.\n pad3 not a valid character.\n\nNotes:\n\n As for many functions that take strings as arguments, symbols are\n permitted; their print names are used in that case.  However, this\n function always returns a string.\n\nExamples:\n\n (ZILSPAD \"foo\" 10 \" \" NIL  1)    ==> \"foo       \"\n (ZILSPAD \"foo\" 10 \" \" NIL  0)    ==> \"   foo    \"\n (ZILSPAD \"foo\" 10 \" \" NIL -1)    ==> \"       foo\"\n (ZILSPAD \"foo\" 10 \" \" T    1)    ==> \"foo       \"\n (ZILSPAD \"foo\" 10 \" \" T    0)    ==> \"   foo    \"\n (ZILSPAD \"foo\" 10 \" \" T   -1)    ==> \"       foo\"\n\n (ZILSPAD \"foo\" 1 \" \" NIL  1)     ==> \"foo\"\n (ZILSPAD \"foo\" 1 \" \" NIL  0)     ==> \"foo\"\n (ZILSPAD \"foo\" 1 \" \" NIL -1)     ==> \"foo\"\n (ZILSPAD \"foo\" 1 \" \" T    1)     ==> \"f\"\n (ZILSPAD \"foo\" 1 \" \" T    0)     ==> \"f\"\n (ZILSPAD \"foo\" 1 \" \" T   -1)     ==> \"f\"\n\n (ZILSPAD 'something 20 \"-\" NIL 1) ==> \"SOMETHING-----------\"\n (ZILSPAD 'something 20 #/a NIL 1) ==> \"SOMETHINGaaaaaaaaaaa\"\n (ZILSPAD \"\"         20 #/z NIL 1) ==> \"zzzzzzzzzzzzzzzzzzzz\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSPKG": {"ttr": 8722, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x14/\\x00\\x89\\x14/\"V\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-05-22T00:00:00", "modifydate": "1989-05-22T22:56:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILSPKG\n\nSyntax:   (ZILSPKG arg1)\n\n arg1 (required, evaluated) - a symbol.\n\nReturns:\n\n The contents of the \"package cell\" of arg1, which is actually not a\n package but either T or NIL, indicating whether or not the symbol\n arg1 is interned.\n\nProcessing:\n\nErrors signaled:\n\n Invalid argument (not a symbol).\n\nNotes:\n\n This would be SYMBOL-PACKAGE if Zil had packages, which it doesn't.\nExamples:\n\n (ZILSPKG NIL)         ==> T\n (ZILSPKG T)           ==> T\n (ZILSPKG 'FOO)        ==> T\n (ZILSPKG (GENSYM))    ==> NIL\n (ZILSPKG (GENTEMP))   ==> T\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSPRT": {"ttr": 8724, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x18\\x9f\\x00\\x87\\x18\\x9f\\x089\\x00*\\x00*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-07-08T00:00:00", "modifydate": "1987-07-08T08:39:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILSPRT\n\nSyntax:   (ZILSPRT arg1)\n\n arg1 (required, evaluated) - a compiled code SUBR object.\n\nReturns:\n\n arg1, after assigning the compiled code SUBR specified by arg1 as the\n \"current ZIL printer\".\n\nProcessing:\n\n The SUBR specified by arg1 is made the \"current ZIL printer\" by\n having its address inserted in the field which is used by ZCPRINT\n to access the current ZIL printer.\n\n See $PRINTER for information about how to specify the function to\n be used as the \"current ZIL printer\", and how it is used.\n\nErrors signaled:\n\n Invalid argument.\n\nNotes:\n\n A SUBR compiled code object is a value that is returned only by the\n ZILLOAD function.  Closures, whether compiled or interpreted, are not\n permitted by ZILSPRT; use SETPRT to define the \"current ZIL printer\"\n using an arbitrary form that can be funcalled.\n\nExamples:\n\n;   (ZILSPRT (ZILLOAD 'ZMSPRINT))\n;\n;   or (ZILSPRT (SUBR ZMSPRINT)) under the compiler,\n;\n; makes the Maclisp-compatible Macsyma print functions active\n; (i.e. the ones that are sensitive to the special variables\n; \u00acR and \u00acW).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSRD": {"ttr": 8726, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\t\\x10\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T09:10:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILSRD\n\nSyntax:   (ZILSRD arg1)\n\n arg1 (required, evaluated) - a compiled code SUBR object.\n\nReturns:\n\n arg1, after assigning the compiled code SUBR specified by arg1 as the\n \"current ZIL reader\".\n\nProcessing:\n\n The SUBR specified by arg1 is made the \"current ZIL reader\" by\n having its address inserted in the field which is used by ZCREAD\n to access the current ZIL reader.\n\n See $READER for information about how to specify the function to\n be used as the \"current ZIL reader\", and how it is used.\n\nErrors signaled:\n\n Invalid argument.\n\nNotes:\n\n A SUBR compiled code object is a value that is returned only by the\n ZILLOAD function.  Closures, whether compiled or interpreted, are not\n permitted by ZILSRD; use SETREAD to define the \"current ZIL reader\"\n using an arbitrary form that can be funcalled.\n\nExamples:\n\n;   (ZILSRD (ZILLOAD 'MYREAD))\n;\n;   or (ZILSRD (SUBR MYREAD)) under the compiler,\n;\n; makes a fictional bunch of read functions active.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSUB": {"ttr": 8728, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x86\\x14/\\x00\\x87%\\x8f\\x17B\\x00 \\x00'\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-05-22T00:00:00", "modifydate": "1987-09-15T17:42:00", "lines": 32, "newlines": 39, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILSUB\n\nSyntax:   (ZILSUB num1 num2)\n\n num1 (required,evaluated) - a number.\n num2 (required,evaluated) - a number.\n\nReturns:\n\n The difference of the two arguments (num1 - num2).\n\nProcessing:\n\n This is the low-level 2-argument function that underlies DIFFERENCE and\n -.\n\n See member $ARITH for more information.\n\nErrors signaled:\n\n See member $ARITH for more information.\n\nNotes:\n\n See member $ARITH for more information.\n\nExamples:\n\n (ZILSUB 1 2) ==> -1\n (ZILSUB 4.0 1) ==> 3.0\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILTEST": {"ttr": 8730, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x11\\x9f\\x00\\x88\\x12O\\x08\\x07\\x000\\x000\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-04-28T00:00:00", "modifydate": "1988-05-03T08:07:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "SEB1525"}, "text": "\nMacro: ZILTEST\n\nSyntax:   (ZILTEST arg1)\n\n arg1 (optional, not evaluated) - a string or symbol.\n\nReturns:\n\n T, after testing the contents of the documentation or test file\n specified by arg1.\n\nProcessing:\n\n If arg1 is a string, it is the name of a dataset containing only\n test data (the format of which is described below).\n\n If arg1 is a symbol, it is the name of a member of the ZIL on-line\n help library (the value of the variable *ZIL-HELP-LIBRARY*) which\n contains test data following the word \"Examples:\" (which must be\n the first word on the line and include the colon).\n\n The test data consists of groups of three forms:  a LISP expression\n to be evaluated, the symbol ==>, and a LISP expression representing\n the value of the first expression.  (Note that none of these are\n quoted.)\n\n ZILTEST evaluates the first expression and compares it to the third,\n and keeps a count of how many are not equal (the comparison is like\n LISP EQUAL, but is fudged for floating-point numbers and vectors).\n Error messages are displayed for all cases that fail the test.\n\n If a form is supposed to signal an error, the third form must be\n (\"***ERROR***\"), i.e. a list containing the string \"***ERROR***\".\n\nErrors signaled:\n\n arg1 not a string or symbol.\n arg1 not found (member not in help library, or dataset doesn't exist).\n\nNotes:\n\nExamples:\n\n (ZILTEST 'CAR) tests the on-line documentation for the CAR function.\n\n (ZILTEST \"my.data(test)\") runs my.data(test) as a checkout.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILTRACE": {"ttr": 8732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x04_\\x00\\x87%\\x8f\\x17G\\x00&\\x00A\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-02-14T00:00:00", "modifydate": "1987-09-15T17:47:00", "lines": 38, "newlines": 65, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILTRACE\n\nSyntax:   (ZILTRACE arg1 arg2)\n\n arg1 (required, evaluated) - For TRACE and UNTRACE, a list of\n                              function names (symbols).\n                              For PP, a single function name (symbol).\n arg2 (required, evaluated) - one of the following symbols:\n                              TRACE, UNTRACE, PP\n\nReturns:\n\n If arg2 is TRACE or UNTRACE, whatever TRACE and UNTRACE are defined\n to return; if arg2 is PP, a LISP object which returns information\n about the function's original definition.\n\nProcessing:\n\n This function is invoked by the TRACE and UNTRACE macros to\n effect tracing and untracing, and by the ZILPP function and PP\n macro to obtain the definition of a function that is being traced.\n\n Information about traced functions is maintained as the value of\n the special variable *TRACE*, which is like an association list of\n traced functions.\n\nErrors signaled:\n\n arg2 not one of the defined types.\n arg1 not a list of symbols (for TRACE and UNTRACE).\n arg1 not a symbol (for PP).\n\nNotes:\n\n See member $TRACE of this document for a description of tracing and\n what kinds of functions can be traced.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILUNBND": {"ttr": 8734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\t\\x11\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T09:11:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILUNBND\n\nSyntax:   (ZILUNBND)\n\nReturns:\n\n An object known as the \"unbound marker\".                               .\n\nProcessing:\n\n An internal object called the \"unbound marker\" is used by ZIL to\n indicate variables that have SPECIAL bindings with no value, or\n to initialize the value/binding cells of symbols that have no\n global value.\n\n Since the \"unbound marker\" looks like a list to ZIL whose CAR and\n CDR point to itself, it is possible to test any binding for\n valuelessness by testing the CDR of the binding for EQness to\n (ZILUNBND).\n\nErrors signaled:\n\n None.\n\nNotes:\n\n See PBIND for more information.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILVTOS": {"ttr": 8736, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x100\\x00.\\x00.\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T10:30:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILVTOS\n\nSyntax:   (ZILVTOS vector1 length2)\n\n vector1 (required, evaluated) - a vector.\n length2 (required, evaluated) - a non-negative integer.\n\nReturns:\n\n A string of length length2 constructed from the characters in vector1.\n\nProcessing:\n\n The elements of vector1, starting from the first element and continuing\n for (length2) elements, must be characters (fixnums between 0 and 255\n inclusive).  These characters are used to construct a string of length\n length2, which is returned as the value.\n\nErrors signaled:\n\n vector1 not a vector.\n length2 not a non-negative fixnum, or greater than length of vector1.\n Non-character element found in vector1 (though it is OK to have\n  non-character elements of vector1 outside of the bound specified\n  by length2).\n Not enough string space to build the string, even after GC.\n\nNotes:\n\n This function is used primarily by the ZIL reader.\n\nExamples:\n\n (ZILVTOS #() 0)  ==> \"\"\n (ZILVTOS #(#\\sp) 0)  ==> \"\"\n (ZILVTOS #(#\\sp) 1)  ==> \" \"\n\n (ZILVTOS #(#\\f #\\o #\\o #\\b #\\a #\\r nil nil nil) 0)  ==>  \"\"\n (ZILVTOS #(#\\f #\\o #\\o #\\b #\\a #\\r nil nil nil) 1)  ==>  \"f\"\n (ZILVTOS #(#\\f #\\o #\\o #\\b #\\a #\\r nil nil nil) 2)  ==>  \"fo\"\n (ZILVTOS #(#\\f #\\o #\\o #\\b #\\a #\\r nil nil nil) 3)  ==>  \"foo\"\n (ZILVTOS #(#\\f #\\o #\\o #\\b #\\a #\\r nil nil nil) 4)  ==>  \"foob\"\n (ZILVTOS #(#\\f #\\o #\\o #\\b #\\a #\\r nil nil nil) 5)  ==>  \"fooba\"\n (ZILVTOS #(#\\f #\\o #\\o #\\b #\\a #\\r nil nil nil) 6)  ==>  \"foobar\"\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILXSUB": {"ttr": 8738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17I\\x00H\\x00Q\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:49:00", "lines": 72, "newlines": 81, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZILXSUB\n\nSyntax:   (ZILXSUB arg1 arg2)\n\n arg1 (required, evaluated) - a compiled code object.\n arg2 (required, evaluated) - a proper list.\n\nReturns:\n\n The result of evaluating the compiled code object specified by arg1,\n with the elements of the argument list specified by arg2 being placed\n on the stack.\n\nProcessing:\n\n This is the primitive function that executes compiled code objects\n (both SUBR's and closures).  Although it is accessible to all users, it\n is primarily used by the evaluator.\n\n ZILXSUB retrieves the elements from the list specified by arg2, and\n places them in successive stack locations.\n\n The minimum and maximum number of argument specifications embedded in\n the compiled code determine the number of arguments that the compiled\n code function must be passed.  If the maximum value is greater than\n the number of elements stacked (the length of the list), NIL is\n stored into the subsequent stack locations the proper number of times\n so that the correct maximum number of arguments is passed.\n If there is an &REST argument, a list is made out of the rest of\n the arguments to the compiled function and a pointer to that list\n is placed on the stack as the final argument.\n\n The arguments are passed as is; they are not re-evaluated,\n this having been taken care of by ZILXSUB's caller.\n\n If the first argument is a closure, the current dynamic variable\n binding environment is saved and set to the value of the environment\n component of the closure.\n\n Control is then passed to the compiled code object specified by arg1,\n via a machine language BALR instruction.\n\n The dynamic variable binding environment, if saved prior to calling the\n code, is then restored.\n\nErrors signaled:\n\n Argument is not a compiled code object or closure.\n Too few arguments passed (second argument too short).\n Too many arguments passed (second argument too long).\n\nNotes:\n\n Unpredictable results will occur if the second argument is not a\n proper list.\n\nExamples:\n\n Assume that in these examples, MYFUNC has a minimum of 1 argument\n and a maximum of 3 arguments.\n\n (ZILXSUB (GET 'MYFUNC 'SUBR) '(A B C))\n\n will execute the SUBR property of MYFUNC, passing it the argument list\n      (A B C).\n\n (ZILXSUB (GET 'MYFUNC 'SUBR) '(A))\n\n will execute the SUBR property of MYFUNC, passing it the argument list\n      (A NIL NIL).\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZISEXEC": {"ttr": 8961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x02\\x7f\\x00\\x88&\\x0f\\x08\\x19\\x00N\\x00A\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-01-27T00:00:00", "modifydate": "1988-09-16T08:19:00", "lines": 78, "newlines": 65, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZISEXEC\n\nSyntax:   (ZISEXEC &rest args)\n\n arg (required, evaluated) - a string (or symbol).\n\nReturns:\n\n An integer containing the return code from the ISPF dialog service\n specified by the command buffer built from concatenating the text\n of the arguments.\n\nProcessing:\n\n The arguments are concatenated to form a character string buffer which\n is assumed to contain a valid ISPF dialog service request in ISPEXEC\n format, and it is executed.\n\n The dialog service request buffer is translated to upper case, UNLESS\n the request is a SELECT service.  If the first seven characters of the\n service request are \"SELECT \" (or \"select \"), the buffer is left asis\n with respect to case.\n\n If no arguments are specified, a null buffer is built and executed as\n a dialog service (at least at this time), which is of course an error.\n\n The system routine ISPEX (alias of ISPEXEC) is used to invoke the\n service.  Naturally, ISPF must be active (i.e. ZIL must have been\n invoked under ISPF, and not via the Draper XINVOKE command or the\n TSO/Extensions Authorized Service Facility).\n\n The return code from the ISPF dialog service is used to build a fixnum\n containing the value to be returned as the ZISEXEC function value. This\n will generally be a number between 0 and 20.  Note, however, that\n return codes over 8 will be returned only if ISPEXEC CONTROL ERRORS\n RETURN is active; otherwise the dialog error will terminate the\n entire ZIL environment without warning.\n\n You can invoke any ISPF dialog service that is supported by the\n ISPEXEC routine as documented in the Dialog Services manuals for\n either ISPF or ISPF/PDF.  The syntax is the same as for the ISPEXEC\n CLIST pseudocommand.  Do not include \"ISPEXEC\" itself in the buffer;\n the first word should be the dialog service name (DISPLAY, TBOPEN,\n VGET, etc.).\n\n To access the values of function pool variables, which many ISPF\n dialog services update,  you must use the ZISGET and ZISPUT functions.\n\nErrors signaled:\n\n Invalid ISPF dialog service string (args cannot be converted to\n string format).\n\n ISPF dialog services not available; either ZIL is running outside\n of ISPF or it is running under the TSO Authorized Service Facility\n or other environment where ISPF dialog services are temporarily\n unavailable.\n\nNotes:\n\n ISPF Version 2 must be installed to use this function.\n\n Unless CONTROL ERRORS RETURN is active, a dialog service that fails\n will terminate ZIL entirely.  The same will happen if a dialog error\n occurs within a SELECTed dialog under this facility, even if CONTROL\n ERRORS RETURN is active.\n\n After a dialog service fails (with a return code greater than 8),\n you may access the error by using the ZISGET function to retrieve the\n value of ZERRMSG, ZERRSM and/or ZERRLM.\n\nExamples:\n\n (ZISEXEC \"control errors return\")\n\n (ZISEXEC \"display panel(\" some-panel \")\")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZISGET": {"ttr": 8963, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x02\\x7f\\x00\\x87%\\x8f\\x17R\\x00;\\x00:\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-01-27T00:00:00", "modifydate": "1987-09-15T17:52:00", "lines": 59, "newlines": 58, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZISGET\n\nSyntax:   (ZISGET arg1)\n\n arg1 (required, evaluated) - a string (or symbol).\n\nReturns:\n\n A string containing the value of the ISPF dialog variable whose name\n is arg1.\n\nProcessing:\n\n The ISPF VCOPY service is invoked to retrieve the value of the ISPF\n dialog variable whose name is specified by arg1.  Thus, the standard\n ISPF variable search takes place.\n\n The value is always returned as a string, regardless of how it is\n stored internally in the ISPF dialog.\n\n If the variable does not exist, a null string is returned.\n\n Naturally, ISPF must be active (see member ZISEXEC for details).\n\n You will need to use this function to access the values of dialog\n variables updated by such services as VGET, DISPLAY, and table\n services.\n\n To update the value of an ISPF dialog variable, use the ZISPUT\n function.\n\nErrors signaled:\n\n Invalid ISPF dialog variable name (not a string or symbol of from 1\n to 8 characters in length).\n\n ISPF dialog services not available; either ZIL is running outside\n of ISPF or it is running under the TSO Authorized Service Facility\n or other environment where ISPF dialog services are temporarily\n unavailable.\n\n ISPF dialog error (return code 20) returned from the VCOPY service.\n\nNotes:\n\n ISPF Version 2 must be installed to use this function.\n\n Unless CONTROL ERRORS RETURN is active, a VCOPY service that fails\n will terminate ZIL entirely.\n\nExamples:\n\n (ZISEXEC \"vget (foo) profile\") puts the value of foo in the function\npool, but does not yet make it available to ZIL.\n\n (ZISGET 'foo) or (ZISGET \"foo\") returns the value of the ISPF dialog\nvariable foo.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZISPUT": {"ttr": 8965, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x02\\x7f\\x00\\x87%\\x8f\\x17R\\x008\\x007\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-01-27T00:00:00", "modifydate": "1987-09-15T17:52:00", "lines": 56, "newlines": 55, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZISPUT\n\nSyntax:   (ZISPUT arg1 arg2)\n\n arg1 (required, evaluated) - a string (or symbol).\n arg2 (required, evaluated) - a symbol, string or number.\n\nReturns:\n\n arg2, after setting the value of the ISPF dialog variable whose name\n is arg1 to the value arg2.\n\nProcessing:\n\n The ISPF VREPLACE service is invoked to update the value of the ISPF\n dialog variable whose name is specified by arg1.\n\n The value is always stored as a character string, regardless of the\n type of arg2.  Note that arg2 cannot be a list, vector or structure.\n\n Naturally, ISPF must be active (see ZISEXEC for more information).\n\n You will need to use this function to update the values of dialog\n variables that you wish to reference in services like VPUT and DISPLAY.\n\n To access the value of an ISPF dialog variable, use the ZISGET\n function.\n\nErrors signaled:\n\n Invalid ISPF dialog variable name (not a string or symbol of from 1\n to 8 characters in length).\n\n Invalid arg2 (a list, vector or structure).\n\n ISPF dialog services not available; either ZIL is running outside\n of ISPF or it is running under the TSO Authorized Service Facility\n or other environment where ISPF dialog services are temporarily\n unavailable.\n\n ISPF dialog error (return code 20) returned from the VREPLACE service.\n\nNotes:\n\n ISPF Version 2 must be installed to use this function.\n\n Unless CONTROL ERRORS RETURN is active, a VREPLACE service that fails\n will terminate ZIL entirely.\n\nExamples:\n\n (ZISPUT 'foo \"bar\") sets the ISPF dialog variable FOO to \"bar\".\n\n (ZISPUT 'baz 1) sets the ISPF dialog variable BAZ to \"1\".\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZMVECTOR": {"ttr": 8967, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87%\\x9f\\x00\\x87%\\x9f\\t\\x15\\x00$\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-16T00:00:00", "modifydate": "1987-09-16T09:15:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZMVECTOR\n\nSyntax:   (ZMVECTOR arg1)\n\n arg1 (required, evaluated) - a list.\n\nReturns:\n\n A vector of (n) elements, where n is the length of arg1, and all of\n the elements are taken from the CAR's of arg1.\n\nProcessing:\n\n A vector is allocated with the number of elements specified by the     urned\n length of arg1, and all of the elements are initialized to the\n elements of arg1.  In other words, the list arg2 is converted to\n a vector.\n\n A null list is valid, in which case the vector has no elements.\n\nErrors signaled:\n\n arg1 not a proper list.\n Not enough vector space to build the vector, even after GC.\n\nNotes:\n\n The #( syntax uses this function.\n\nExamples:\n\n (ZMVECTOR ())        ==> #()\n (ZMVECTOR '(1))      ==> #(1)\n (ZMVECTOR '(A B C))  ==> #(A B C)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZPUTFPI": {"ttr": 8969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17S\\x00>\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:53:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZPUTFPI\n\nSyntax:   (ZPUTFPI arg1 &optional arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (optional, evaluated) - an input file name.\n\nReturns:\n\n arg1, which updates the current character pointer of the input file\n specified by arg2.\n\nProcessing:\n\n The fixnum value of arg1 replaces the current character position in the\n file block for the file specified by arg2, and is itself returned.\n\n The value is a 1-based column value, and should be between 1 and the\n logical line length of the input file.  If 0 is specified, the input\n file appears to all read operations as if end-of-file had occurred.\n If -1 is specified, the input file appears to all read operations\n as if end-of-line had occurred.\n If a value greater than the line length is specified, a new line\n condition is forced, but other results are unpredictable.\n\n The effect of changing the current input file pointer is:\n\n (1) to cause data on the current line to be re-read if the value is\n     decreased, or\n (2) to cause data on the current line to be skipped if the value is\n     increased.\n\n arg1, if omitted, defaults to NIL, which represents the standard input\n file.\n\n The value of the current character pointer for an input file is\n altered implicitly by input functions like READ, READCH and TYI.\n\nErrors signaled:\n\n Invalid input file object (not a symbol 4 characters or less).\n Specified input file is not allocated or could not be opened.\n First argument not a fixnum.\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Use of an out-of-range value as the first argument may cause\n serious errors in the ZIL environment.  Do so with extreme caution.\n\nExamples:\n\n (ZPUTFPI 1) and (ZPUTFPI 1 NIL) are equivalent, and cause the\n             current line of standard input to be reprocessed.\n\n (ZPUTFPI 10 'FOO)  sets the current column of input file FOO to 10.\n\n (ZPUTFPI (ADD (ZGETFPI 'BAR) N) 'BAR)   causes the current column\n             position of input file BAR to be \"tabbed\" over N spaces.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZPUTFPO": {"ttr": 8971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x86\\x03\\x0f\\x00\\x87%\\x8f\\x17T\\x00C\\x00C\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1986-01-30T00:00:00", "modifydate": "1987-09-15T17:54:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "SEB1525"}, "text": "\nFunction: ZPUTFPO\n\nSyntax:   (ZPUTFPO arg1 &optional arg2)\n\n arg1 (required, evaluated) - a fixnum.\n arg2 (optional, evaluated) - an output file name.\n\nReturns:\n\n arg1, which updates the current character pointer of the output file\n specified by arg2.\n\nProcessing:\n\n The fixnum value of arg1 replaces the current character position in the\n file block for the file specified by arg2, and is itself returned.\n\n The value is a 1-based column value, and should be between 1 and the\n logical line length of the output file, with the following exception:\n\n If the file is the standard output file (NIL), an argument of 0 will\n cause the current character pointer to point to the print control\n character; this technique may be used to set the print control\n character (ASA control characters are used).\n\n If 0 is specified on a file other than NIL, results are unpredictable.\n If a value greater than the line length is specified, a new line\n condition is forced, but other results are unpredictable.\n\n The effect of changing the current output file pointer is:\n\n (1) to cause data on the current line to be overlaid if the value is\n     decreased, or\n (2) to leave blanks in the current line between the previously\n     written data and the new location if the value is increased.\n\n arg1, if omitted, defaults to NIL, which represents\n the standard output file.\n\n The value of the current character pointer for an output file is\n altered implicitly by output functions like PRINC, PRIN1, and TERPRI.\n\nErrors signaled:\n\n Invalid output file object (not a symbol 4 characters or less).\n Specified output file is not allocated or could not be opened.\n First argument not a fixnum.\n First argument negative (less than 0).\n\nNotes:\n\n See member $FILE for more information on file names.\n\n Use of an out-of-range value as the first argument may cause\n serious errors in the ZIL environment.  Do so with extreme caution.\n\nExamples:\n\n (ZPUTFPO 1) and (ZPUTFPO 1 NIL) are equivalent, and permit the current\n             line of standard output to be overlaid with new data.\n\n (ZPUTFPO 10 'FOO)  sets the current column of output file FOO to 10.\n\n (ZPUTFPO (+ (ZGETFPO 'BAR) N) 'BAR)   causes the current column\n             position of output file BAR to be \"tabbed\" over N spaces.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT476/CBT.V500.FILE476.PDS/TEXT.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT476/CBT.V500.FILE476.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}