{"INMR01": {"INMLRECL": 80, "INMFNODE": "CSDLMVS", "INMFUID": "SEB1525", "INMTNODE": "MVS", "INMTUID": "CSDL", "INMFTIME": "20000926092757000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 4408950, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 6160, "INMRECFM": "FB", "INMDIR": 50, "INMDSNAM": "PROGLIB.ZILCBT.ASM", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 4408950, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 4408950, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"PROGLIB.ZILCBT.ASM": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6160, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "000269", "DS1SCEXT": "b'\\x80\\x18\\x10'", "DS1SCALO": "b'P\\x00\\x002'", "DS1LSTAR": "b'\\x00I\\x05'", "DS1TRBAL": "b'\\xb1\\x92'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x04\\x10\\x00\\x04\\xa9-p'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x04\\x10\\x00\\x04\\xa9-p'", "b'X\\xf3\\x13H\\x00\\x00\\x02\\x1a\\x00\\x00\\x02\\x1e\\x00\\r\\x00J'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"ABS": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11&\\x00_\\x00\\\\\\x00^\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:26:00", "lines": 95, "newlines": 92, "modlines": 94, "user": "SEB1525"}, "text": "         TITLE 'ABS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ABS TAKES ONE ARGUMENT - A FIXNUM, FLONUM OR BIGNUM                 *\n*                                                                     *\n***********************************************************************\nABS      #ZBEG MINARGS=1,MAXARGS=1,NAME='ABS'\n         #ZPDS 16\n         #ZSAV ,\n         SPACE\n         L     #15,0(,#11)         GET THE ARG\n         CLI   0(#15),##FIXNUM\n         BE    ABSFIX\n         CLI   0(#15),##SFLOAT\n         BE    ABSFLO\n         CLI   0(#15),##BIGNUM\n         BE    ABSBIG\n         CLI   0(#15),##DFLOAT\n         BE    ABSDFLO\n         B     ERROR\n         SPACE 1\nABSFIX   DS    0H                  ABS OF A FIXNUM\n         SPACE 1\n         ICM   #2,15,##CDR(#15)    GET FIXNUM VALUE\n         BNM   RETURN              IF NOT NEGATIVE, RETURN SELF\n         LPR   #2,#2               MAKE IT POSITIVE\n         BO    FIXOVFLO            IF OVERFLOW, MUST HAVE BEEN -2**31\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RETURN WITH VALUE\n         SPACE 1\nABSFLO   DS    0H                  ABS OF A FLONUM\n         SPACE 1\n         TM    ##CDR(#15),X'80'    IF ALREADY NONNEGATIVE\n         BZ    RETURN              THEN RETURN WITH SAME ATOM\n         LE    #F2,##CDR(,#15)     GET FLONUM VALUE\n         LPER  #F2,#F2             MAKE IT POSITIVE\n         STE   #F2,ZLCWORK\n         L     #2,ZLCWORK\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nABSBIG   DS    0H                  ABS OF A BIGNUM\n         SPACE 1\n         TM    ##VECDAT(#15),X'80' IF ALREADY NONNEGATIVE\n         BZ    RETURN              THEN RETURN WITH SAME ATOM\n         XR    #2,#2               CLEAR INSERT REGISTER\n         ICM   #2,7,1(#15)         GET BIGNUM LENGTH\n         LA    #2,4(,#2)           PLUS LENGTH OF HEADER\n         LR    #3,#2               SAVE THIS LENGTH\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         L     #15,ZLCBIG          GET ADDRESS OF BIGNUM MAKER\n         #BASR #14,#15             CALL ZILBIG\n         LR    #4,#15              SAVE ADDRESS OF NEW BIGNUM\n         LR    #0,#4               DESTINATION ADDRESS\n         L     #14,0(,#11)         SOURCE ADDRESS\n         LR    #1,#3               DESTINATION LENGTH\n         LR    #15,#3              SOURCE LENGTH\n         MVCL  #0,#14              MOVE OLD BIGNUM TO NEW BIGNUM\n         ST    #0,ZLCVSNXT         UPDATE V/S-SPACE POINTER\n         LR    #15,#4              GET ADDRESS OF BIGNUM AGAIN\n         NI    ##VECDAT(#15),X'7F' TURN OFF SIGN BIT TO MAKE IT PPLUS\n         B     RETURN\n         SPACE 1\nFIXOVFLO DS    0H\n         LA    #15,P2TO31          RETURN BIGNUM +2**31\n         B     RETURN\n         SPACE 1\nABSDFLO  DS    0H                  ABS OF A DOUBLE-FLOAT\n         SPACE 1\n         TM    8(#15),X'80'        IF ALREADY NONNEGATIVE\n         BZ    RETURN              THEN RETURN WITH SAME ATOM\n         LD    #F0,8(,#15)         GET FLONUM VALUE\n         LPDR  #F0,#F0             MAKE IT POSITIVE\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         #BASR #14,#15             CALL ZILMDF TO CONS UP DOUBLE FLOAT\n         B     RETURN              RETURN WITH NEW DOUBLE FLONUM OBJECT\n         SPACE 1\nP2TO31   DS    0A                  ALIGN BIGNUM TO FULLWORD\n         DC    YL1(##BIGNUM),AL3(8),F'0,1'   BIGNUM 2**31\nERROR    DS    0H\n         #ERR  2,'Argument to ABS not numeric - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ACSIZE": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11(\\x00\\x14\\x00\\x11\\x00\\x13\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:28:00", "lines": 20, "newlines": 17, "modlines": 19, "user": "SEB1525"}, "text": "         TITLE 'ACSIZE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nACSIZE   #ZBEG MINARGS=0,MAXARGS=0,NAME='ACSIZE'\n         #ZPDS 12                  DEFINE STACK SIZE\n         #ZSAV ARGS=0              SAVE REGISTERS\n         SPACE 1\n         L     #2,ZLCGCACD         GET NUMBER OF ACTIVE CONS CELLS\n         SLA   #2,3                CONVERT TO NUMBER OF BYTES\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         #ZRET ,                   RETURN WITH IT\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ADD1": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x110\\x01\\x1f\\x01\\x1c\\x01\\x1e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:30:00", "lines": 287, "newlines": 284, "modlines": 286, "user": "SEB1525"}, "text": "         TITLE 'ADD1 - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ADD1 TAKES ONE ARGUMENT - A NUMERIC ATOM                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nADD1     #ZBEG MINARGS=1,MAXARGS=1,NAME='ADD1'\n         SPACE\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #1,0(,#11)          LOAD FIRST (AND ONLY) ARGUMENT\n         CLI   ##TYPE(#1),##FIXNUM IS IT A FIXNUM?\n         BNE   NOTFIX              IF NOT, GO SOMEWHERE ELSE\n         L     #2,##CDR(,#1)       Get value of fixnum\n* Note: The following test assumes that the lowest small fixnum is 0.\n         CL    #2,ZLCSFTHI         If within small fixnum table range\n*                                  (and not equal to the largest small)\n         BL    SMALLFIX            then go to increment small fixnum\n         A     #2,#SFW1            ELSE ADD 1 TO FIXNUM\n         BO    MAKTWO31            OVERFLOW...MUST BE 2**31\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A NEW FIXNUM\n         B     RETURN\n*\nSMALLFIX DS    0H\n*\n***********************************************************************\n*                                                                     *\n* Fixnum between lowest and highest small fixnum from table           *\n* (but not equal to the highest).  We load the address of the         *\n* next higher fixnum from the table.                                  *\n*                                                                     *\n***********************************************************************\n*\n         SLA   #2,3                Multiply fixval by 8 for an index\n         LA    #15,#SFT+8(#2)      Get address of (fixval+1)th fixnum\n******** B     RETURN               from table and return with it\n         SPACE 1\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n*\nNOTFIX   CLI   ##TYPE(#1),##BIGNUM IS IT A BIGNUM?\n         BNE   NOTFXBG             NOT A BIGNUM NOR A FIXNUM\n*---------------------------------------------------------------------*\n*     IT'S A BIGNUM - pass control to ZILADD                          *\n*---------------------------------------------------------------------*\n         SPACE 1\n         LA    #2,#SFT1            Get address of fixnum +1\n         L     #15,@ZILADD         Get address of ZILADD\n         LR    #1,#11              Restore stack pointer\n         LM    #11,#12,4(#1)       Restore regs as if returning\n         L     #14,12(,#1)         Pass original return address\n         ST    #2,4(,#1)           Set arg 2 to ZILADD = fixnum 1\n*                                  (arg 1 is the same as arg to ADD1)\n         BR    #15                 Go to ZILADD to add +1 to bignum\n         SPACE 1\n         AGO   .SKIP               SKIP THIS CODE, CALL ZILADD INSTEAD\n***********************************************************************\n.        ICM   #6,15,##VECDAT(#1)  LOAD LS WORD AND TEST SIGN\n.        BM    BIGM                NEGATIVE BIGNUM\n.        AH    #6,=H'1'            ADD 1 TO LS WORD OF BIGNUM\n.        BO    BIGC1               CARRY FROM FIRST WORD\n*---------------------------------------------------------------------*\n*     IT'S A POSITIVE BIGNUM WITH NO CARRY OUT OF FIRST WORD          *\n*---------------------------------------------------------------------*\n.        LA    #0,16(,#11)         PASS CURRENT STACK LOC TO ZILBIG\n.        XR    #2,#2               CLEAR FOR 3-BYTE INSERT\n.        ICM   #2,7,1(#1)          GET 3-BYTE LENGTH OF BIGNUM\n.        L     #15,ZLCBIG\n.        #BASR #14,#15\n*\n.        LA    #3,##VECDAT(,#2)    CALC LEN OF HEADER+BIGNUM\n.        L     #4,0(,#11)          ADDRESS OF SOURCE\n.        LR    #2,#15              ADDRESS OF DESTINATION\n.        LR    #5,#3               LENGTH TO MOVE\n.        MVCL  #2,#4               COPY BIGNUM TO DESTINATION\n.        ST    #6,##VECDAT(,#15)   STORE UPDATED LS WORD IN NEW BIGN\n.        ST    #2,ZLCVSNXT         UPDATE VSS POINTER\n.        B     RETURN\n*---------------------------------------------------------------------*\n*     IT'S A POSITIVE BIGNUM WITH CARRY OUT OF FIRST WORD             *\n*---------------------------------------------------------------------*\nBIGC1    LA    #0,16(,#11)         PASS CURRENT STACK LOC TO ZILBIG\n.        XR    #3,#3               CLEAR FOR 3-BYTE INSERT\n.        ICM   #3,7,1(#1)          GET 3-BYTE LENGTH OF BIGNUM\n.        LA    #2,4(,#3)           IT MIGHT BE ONE WORD LONGER\n.        L     #15,ZLCBIG\n.        #BASR #14,#15\n*\n.        L     #7,0(,#11)          GET ARG 1 AGAIN\n.        LA    #0,##VECDAT(,#7)    CLCL PREP - SOURCE\n.        LR    #1,#3               BIGNUM LENGTH\n.        SH    #1,=H'4'            SUBTRACT LENGTH OF ONE WORD\n.        LA    #4,##VECDAT+4(,#7)  COMPARE WITH ONE WORD AHEAD\n.        LR    #5,#1               PUT IN BOTH OTHER CLCL LENGTH\n.        CLCL  #4,#0               FIND FIRST WORD THAT WON'T CARRY\n.        BE    BIGC1FUL            BIGNUM IS FULL - NEEDS NEW WORD\n*\n.        N     #4,=X'FFFFFFFC'     DROP DOWN TO NEAREST WORD BNDRY\n.        LR    #0,#7               MVCL PREP - ARG BIGNUM\n.        LA    #1,##VECDAT         MOVE ONLY HEADER, PAD REST WITH 0\n.        LR    #6,#4               SAVE POSITION OF WORD TO BE INC\n.        LR    #4,#15              DESTINATION - RESULT BIGNUM\n.        LR    #5,#6\n.        SR    #5,#7               CALCULATE LENGTH FOR MOVE & 0 PAD\n.        MVCL  #4,#0               NOW WE ARE UP TO WORD TO BE INC'D\n.        LA    #0,1\n.        A     #0,0(,#6)           CLCL VERIFIED THIS CAN'T OVERFLOW\n.        ST    #0,0(,#4)           MVCL PUT #4 IN RIGHT PLACE\n.        LA    #0,4(,#6)           PREP NEXT MVCL SOURCE\n.        LA    #4,4(,#4)           BUMP UP THE DESTINATION POINTER\n.        LA    #1,##VECDAT(#3,#7)  POINT TO END OF BIGNUM ARGUMENT\n.        SR    #1,#0               CALC LENGTH LEFT TO COPY\n.        LR    #5,#1               DESTINATION LENGTH TOO\n.        MVCL  #4,#0               COPY REST OF BIGNUM\n.        ST    #4,ZLCVSNXT         UPDATE VSS POINTER TO END OF RESULT\n.        B     RETURN\n*\nBIGC1FUL STCM  #2,7,1(#15)         STORE RESULT LEN (ONE WORD GREATER)\n.        XR    #1,#1        ****   THIS SHOULD ALREADY BE 0 FROM CLCL\n.        LA    #2,##VECDAT(,#15)   PREP FOR ZEROING DATA OF RESULT\n.        MVCL  #2,#0               FILL LENGTH #3 WITH ZEROES\n.        LA    #6,1                GENERATE 1 FOR MS WORD OF RESULT\n.        ST    #6,0(,#2)           PUT 1 IN MS WORD\n.        LA    #2,4(,#2)           POINT TO END FOR NEXT BIGNUM\n.        ST    #2,ZLCVSNXT         UPDATE VSS POINTER\n.        B     RETURN\n*---------------------------------------------------------------------*\n*                     IT'S A NEGATIVE BIGNUM                          *\n*---------------------------------------------------------------------*\nBIGM     CLC   0(12,#1),MTWO31M1   CHECK FOR -2**31 - 1 BIGNUM\n.        BE    MAMTWO31              GENERATE MOST NEGATIVE FIXNUM\n.        SH    #6,=H'1'            SUB1 (FOR SIGN AND MAGNITUDE)\n.        BO    MBIGC1              MUST CARRY FROM HIGHER WORDS\n*---------------------------------------------------------------------*\n*     IT'S A NEGATIVE BIGNUM WITH NO CARRY OUT OF FIRST WORD          *\n*---------------------------------------------------------------------*\n.        LA    #0,16(,#11)         PASS CURRENT STACK LOC TO ZILBIG\n.        XR    #2,#2               CLEAR FOR 3-BYTE INSERT\n.        ICM   #2,7,1(#1)          GET 3-BYTE LENGTH OF BIGNUM\n.        L     #15,ZLCBIG\n.        #BASR #14,#15\n*\n.        LA    #3,##VECDAT(,#2)    CALC LEN OF HEADER+BIGNUM\n.        L     #4,0(,#11)          ADDRESS OF SOURCE\n.        LR    #2,#15              ADDRESS OF DESTINATION\n.        LR    #5,#3               LENGTH TO MOVE\n.        MVCL  #2,#4               COPY BIGNUM TO DESTINATION\n.        ST    #6,##VECDAT(,#15)   STORE UPDATED LS WORD IN NEW BIGN\n.        ST    #2,ZLCVSNXT         UPDATE VSS POINTER\n.        B     RETURN\n*---------------------------------------------------------------------*\n*     IT'S A NEGATIVE BIGNUM WITH A CARRY OUT OF FIRST WORD           *\n*---------------------------------------------------------------------*\nMBIGC1   LA    #0,16(,#11)         PASS CURRENT STACK LOC TO ZILBIG\n.        XR    #2,#2               CLEAR FOR 3-BYTE INSERT\n.        ICM   #2,7,1(#1)          GET 3-BYTE LENGTH OF BIGNUM\n.        L     #15,ZLCBIG\n.        #BASR #14,#15\n*\n.        L     #3,0(,#11)          GET ARG 1 AGAIN\n.        LA    #4,##VECDAT+4(,#3)  CLCL PREP - POINT TO SECOND WORD\n.        LR    #5,#2               BIGNUM LENGTH\n.        SH    #5,=H'8'            COMPARING FROM 2ND LS TO 2ND MS\n.        XR    #1,#1               ZERO CLCL LENGTH AND PAD BYTE\n.        CLCL  #4,#0               FIND FIRST NONZERO WORD\n.        BE    MBIGCMS             CARRY FROM MS WORD\n*\n.        N     #4,=X'FFFFFFFC'     DROP DOWN TO NEAREST WORD BNDRY\n.        L     #0,0(,#3)           GET HEADER OF ARG\n.        L     #1,=X'7FFFFFFF'     7FFFFFFF FOR LS WORD, SIGN LATER\n.        STM   #0,#1,0(#15)        STORE HEADER AND LS WORD\n.        LA    #6,##VECDAT+4(,#15) MVCL PREP FOR COPYING 7FFFFFFF\n.        LA    #0,##VECDAT(,#15)\n.        LR    #7,#4\n.        SR    #7,#3\n.        SH    #7,=H'8'\n.        LR    #1,#7\n.        MVCL  #6,#0\n.        L     #1,0(,#4)           GET WORD THAT CAN CARRY OUT\n.        BCTR  #1,0                SUBTRACT ONE FROM WORD\n.        ST    #1,0(,#6)           STORE DECREMENTED WORD IN RESULT\n.        LA    #6,4(,#6)           BUMP TO NEXT FOR COPYING REST\n.        LA    #0,4(,#4)           BUMP TO NEXT IN SOURCE BIGNUM\n.        LA    #1,##VECDAT-4(#2,#3) POINT TO LAST WORD\n.        SR    #1,#4               CALCULATE # WORDS TO BE COPIED\n.        LR    #7,#1               PUT LENGTH IN BOTH MVCL OPERANDS\n.        MVCL  #6,#0               COPY UNCHANGED END OF BIGNUM\n.        OI    ##VECDAT(#15),X'80' SET NEGATIVE SIGN\n.        ST    #6,ZLCVSNXT         UPDATE VSS POINTER TO END OF RESULT\n.        B     RETURN\nMBIGCMS  L     #5,0(,#4)           LOAD MS WORD WHICH MUST CARRY OUT\n.        BCT   #5,MBIGMSP          SUBTRACT CARRY, STILL POSITIVE?\n.        L     #5,=X'7FFFFFFF'\n.        ST    #5,##VECDAT(,#15)\n.        LA    #6,##VECDAT+4(,#15)\n.        LR    #7,#2\n.        SH    #7,=H'8'\n.        LR    #1,#7\n.        LA    #0,##VECDAT(,#15)\n.        MVCL  #6,#0\n.        OI    ##VECDAT(#15),X'80' SET SIGN TO NEGATIVE\n.        SH    #2,=H'4'\n.        STCM  #2,7,1(#15)         RESULT LEN (ONE WORD SHORTER)\n.        ST    #6,ZLCVSNXT\n.        B     RETURN\n*\nMBIGMSP  L     #7,=X'7FFFFFFF'\n.        ST    #7,##VECDAT(,#15)\n.        LA    #6,##VECDAT+4(,#15)\n.        LR    #7,#2\n.        SH    #7,=H'8'\n.        LR    #1,#7\n.        LA    #0,##VECDAT(,#15)\n.        MVCL  #6,#0\n.        OI    ##VECDAT(#15),X'80' SET SIGN TO NEGATIVE\n.        STCM  #2,7,1(#15)         RESULT LEN (ONE WORD SHORTER)\n.        ST    #5,0(,#6)           STORE NEW MS WORD\n.        LA    #6,4(,#6)           INCREMENT TO NEXT AVAILABLE WRD\n.        ST    #6,ZLCVSNXT         STORE NEXT AVAIL WRD POINTER\n.        B     RETURN\n*\n*---------------------------------------------------------------------*\n*                IT'S THE MOST NEGATIVE FIXNUM                        *\n*---------------------------------------------------------------------*\nMAMTWO31 LA    #15,MTWO31          POINT TO -2*31 FIXNUM INLINE\n.        B     RETURN\n***********************************************************************\n.SKIP    ANOP  ,\n*---------------------------------------------------------------------*\n*              IT'S THE SMALLEST POSITIVE BIGNUM                      *\n*---------------------------------------------------------------------*\nMAKTWO31 LA    #15,TWO31           POINT TO 2**31 BIGNUM INLINE\n         B     RETURN\n*---------------------------------------------------------------------*\n*  IT'S NOT A FIXNUM NOR A BIGNUM, MUST BE A FLOAT OR AN ERROR        *\n*---------------------------------------------------------------------*\nNOTFXBG  CLI   ##TYPE(#1),##SFLOAT IF NOT SINGLE-FLOAT\n         BNE   NOTSFLO             THEN TRY SOMETHING ELSE\n         LE    #F0,##CDR(,#1)      LOAD FLOAT VALUE\n         AE    #F0,=E'1'           ADD 1\n         STE   #F0,ZLCWORK         PUT RESULT IN ATOM-MAKING REGISTER\n         L     #2,ZLCWORK\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN\n         SPACE\nNOTSFLO  CLI   ##TYPE(#1),##DFLOAT MUST BE DOUBLE-FLOAT\n         BNE   ERROR1              ELSE ERROR\n         LD    #F0,8(,#1)          LOAD FLOAT VALUE\n         AD    #F0,=D'1'           ADD 1\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         #BASR #14,#15             CALL ZILMDF TO CONS DOUBLE FLOAT\n         B     RETURN              Return with double float\n         SPACE 1\nERROR1   DS    0H                  NOT A NUMERIC ATOM\n         #ERR  2,'Argument to ADD1 not a number - ',0(#11)\n         SPACE 1\nZILSUBRS DS    0A\n@ZILADD  DC    V(ZILADD)           Address of subroutine\n         DC    CL8'ZILADD'\nZILSUBRE EQU   *\n         SPACE\n         DS    0A                  FORCE ALIGNMENT TO FULLWORD BNDRY\nTWO31    DC    YL1(##BIGNUM),AL3(8),F'0,1'  2**31 SMALLEST POS BIGNUM\n         SPACE 1\n         AGO   .SKIP2              DON'T NEED THESE WHEN SKIPPING\n***********************************************************************\n         DS    0A                  FORCE ALIGNMENT TO FULLWORD BNDRY\nMTWO31M1 DC    YL1(##BIGNUM),AL3(8),X'80000001',F'1'  -2**31 - 1\n         SPACE 1                       LEAST-NEGATIVE BIGNUM\n         DS    0A                  FORCE ALIGNMENT TO FULLWORD BNDRY\nMTWO31   DC    YL1(##FIXNUM),AL3(0),F'-2147483648'  MOST NEG FIXNUM\n         SPACE 1\n***********************************************************************\n.SKIP2   ANOP  ,\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALPHACP": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00&\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x12\\x007\\x004\\x006\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:12:26", "lines": 55, "newlines": 52, "modlines": 54, "user": "SEB1525"}, "text": "         TITLE 'ALPHACP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ALIAS \"ALPHA-CHAR-P\".                                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nALPHACP  #ZBEG MINARGS=1,MAXARGS=1,NAME='ALPHA-CHAR-P'\n         SPACE\n         L     #3,0(,#1)           GET ATOM (ARG 1 TO ALPHACP)\n         CLI   ##TYPE(#3),##FIXNUM MUST BE A FIXNUM\n         BNE   ERROR1              OR ELSE\n*\n* GET THE NUMERIC VALUE OF THE FIXNUM.\n*\n         L     #1,##CDR(,#3)       GET FIXNUM CONTENTS\n         CL    #1,=X'000000FF'     MUST BE 1-BYTE CHARACTER FIXNUM\n         BH    FALSE               ELSE NOT ALPHABETIC CHARACTE R\n         XR    #2,#2\n         IC    #2,TABLE(#1)        IF IN RANGE, LOAD CHAR FROM TABLE\n         LTR   #2,#2               IF TABLE ENTRY SAYS ALPHABETIC\n         BZ    FALSE               THEN...\nTRUE     LR    #15,#8               RETURN T\n         BR    #14                 ELSE\nFALSE    LR    #15,#10              RETURN NIL\n         BR    #14\n         SPACE 1\nTABLE    DC    256YL1(0)\n         ORG   TABLE+C'A'-X'40'\n         DC    X'010101010101010101'\n         ORG   TABLE+C'J'-X'40'\n         DC    X'010101010101010101'\n         ORG   TABLE+C'S'-X'40'\n         DC    X'0101010101010101'\n         ORG   TABLE+C'A'\n         DC    X'010101010101010101'\n         ORG   TABLE+C'J'\n         DC    X'010101010101010101'\n         ORG   TABLE+C'S'\n         DC    X'0101010101010101'\n         ORG\n         SPACE 1\nERROR1   DS    0H\n         LR    #2,#15\n         DROP  #15\n         USING ALPHACP,#2\n         #ERR  'Argument to ALPHA-CHAR-P not a fixnum - ',(#3)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APPEND2": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x111\\x00F\\x00C\\x00E\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:31:00", "lines": 70, "newlines": 67, "modlines": 69, "user": "SEB1525"}, "text": "         TITLE 'APPEND2 - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* APPEND2: APPEND FOR EXACTLY TWO ARGUMENTS.                          *\n*                                                                     *\n* THE COMPILER IMPLEMENTS APPEND AS A MACRO THAT EXPANDS INTO THE     *\n* REQUISITE CALLS TO APPEND2.                                         *\n*                                                                     *\n* UNDER THE INTERPRETER, APPEND IS A FUNCTION THAT TAKES A &REST ARG  *\n* AND INVOKES APPEND2.                                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nAPPEND2  #ZBEG MINARGS=2,MAXARGS=2,NAME='APPEND2'\n         SPACE 1\n         #ZPDS 2*4+12+4\n         #ZSAV ,\n         SPACE 1\n         LM    #3,#4,0(#11)        LOAD THE ARGUMENTS\n         SPACE 1\n         CR    #3,#10              IF LIST 1 IS NIL,\n         BE    ARG1NIL             THEN GO TO RETURN LIST 2\n         SPACE 1\nARG1NN   DS    0H\n         LR    #6,#10              INITIALIZE RESULT TO NIL\n         LA    #0,24(,#11)         SET CURRENT STACK POINTER FOR CONS\n         TM    ##TYPE(#3),##ATOM   IF LIST 1 NOT A LIST\n         BZ    INLOOP              THEN...\n         CR    #4,#10               IF LIST 2 IS NIL,\n         BNE   ERROR1               THEN...\n         LR    #15,#3                RETURN LIST 1\n         B     RETURN               ELSE ERROR\n         SPACE 1\nLOOP     DS    0H\n         TM    ##TYPE(#3),##ATOM   IF (SUB)LIST 1 NOT A LIST\n         BO    ERROR1              THEN ERROR\nINLOOP   DS    0H\n         L     #1,##CAR(,#3)       GET CAR OF (SUB)LIST 1\n         LR    #2,#4               GET LIST 2 (in case it's last cons)\n         L     #15,ZLCCONS         CALL CONS TO BUILD A PIECE OF THE\n         #BASR #14,#15              RESULT LIST\n         CR    #6,#10              IF NO RESULT YET,\n         BNE   BASHEND             THEN...\n         LR    #6,#15               START IT NOW FROM THIS PIECE\n         ST    #6,20(,#11)          SAVE ON STACK FOR POSSIBLE GC'ING\n         B     AFTBASH             ELSE...\nBASHEND  ST    #15,##CDR(,#5)       BASH LAST CONS OF RESULT LIST\nAFTBASH  LR    #5,#15              SET POINTER TO LAST CONS IN RESULT\n         L     #3,##CDR(,#3)       GO DOWN LIST 1\n         CR    #3,#10              IF END NOT REACHED YET\n         BNE   LOOP                THEN CONTINUE\n******** ST    #4,##CDR(,#5)       WHEN END, list 2 already bashed in\n         LR    #15,#6              RETURN THE RESULT LIST\n         SPACE 1\nRETURN   DS    0H                  #15 CONTAINS RETURN VALUE\n         #ZRET ,                   RETURN TO CALLER\n         SPACE 1\nARG1NIL  LR    #15,#4              ARG 1 IS NIL:  RETURN LIST 2\n         #ZRET ,                   RETURN TO CALLER\n         SPACE 3\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         #ERR  'Argument 1 to APPEND2 not a proper list - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASH": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01T\\x00\\x00\\x00\\x88\\x12\\x0f\\x00\\x89\\x15o\\x111\\x01\\x97\\x00\\xda\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.84", "flags": 0, "createdate": "1988-04-29T00:00:00", "modifydate": "1989-06-05T11:31:00", "lines": 407, "newlines": 218, "modlines": 0, "user": "SEB1525"}, "text": "         TITLE 'ASH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ASH takes two integer arguments.                                    *\n* This function does an arithmetic shift operation.  Compare LSH.     *\n*                                                                     *\n* Common Lisp complete.                                               *\n*                                                                     *\n* The trick with negative numbers is to realize that any 1-bits       *\n* shifted out on the right in magnitude notation is a remainder       *\n* part that will make the magnitude of the remaining negative         *\n* number one greater in magnitude.                                    *\n*                                                                     *\n* ASH could be approximately asymptotically doubled in speed by       *\n* vectorizing the BXLE loops, with testing to use the vectorized      *\n* version only when the length to be shifted reaches a threshhold.    *\n*                                                                     *\n***********************************************************************\nASH      #ZBEG MINARGS=2,MAXARGS=2,NAME='ASH'\n         #ZPDS 2*4+12+0 (= 20)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM Is arg 1 a fixnum?\n         BNE   NF1                 Go to Not Fixnum 1\n         CLI   ##TYPE(#7),##FIXNUM Is arg 2 a fixnum?\n         BNE   F1NF2               Go to Fixnum 1 Not Fixnum 2\nF1F2     ICM   #3,15,##CDR(#7)     Get shift index\n         BZ    I1FZ2               If 0, no shifting required\n         BM    F1FM2               If negative, right shift required\nF1FP2    CH    #3,=H'31'           Maximum useful shift amount\n         BH    F1FP2BZ             Shift is large enough for bignum\n         L     #2,##CDR(,#6)       Load fixnum to be shifted\n         SLA   #2,0(#3)            Shift the fixnum requested amount\n         BO    F1FP2B              Overflow, go make it a bignum\nRETFIX   #MKAT FIXED               Cons up a fixnum, probably not SF\nRET      #ZRET ,                   RESTORE REGISTERS AND RETURN\n*\nF1FM2    CH    #3,=H'-30'          Maximum useful shift\n         BL    F1FM2LRG            All but sign shifted out?\n         LCR   #3,#3               Change to positive shift amount\n         L     #2,##CDR(,#6)       Get number to be shifted\n         SRA   #2,0(#3)            Shift by amount of arg 2\n         CL    #2,ZLCSFTHI         Is number within small fixnum table?\n         BH    RETFIX              Need to cons the fixnum?\n         SLA   #2,3                Compute offset in small fixnum table\n         LA    #15,#SFT(#2)        Address in small fixnum table\n         B     RET                 Return to caller\n*\nF1FM2LRG TM    ##CDR(#6),X'80'     Test sign of fixnum\n         LA    #15,#SFT0           Load 0 in case it was positive\n         BZ    RET                 Return to caller if it was 0\n         LA    #15,#SFTM1          Load -1 because fixnum was neg\n         B     RET                 Return to caller\n*\nI1FZ2    LR    #15,#6              Return arg 1 unchanged\n         B     RET                 Return to caller\n*\nF1FP2B   L     #5,##CDR(,#6)       Load fixnum to be shifted\n         XR    #4,#4               Clear before shift left\n         LPR   #5,#5               Get magnitude of fixnum in 32 bits\n         SLDA  #4,1(#3)            Shift left requested amount +1\n         BO    MT62                Answer must be -2\u00ac62\n         SRL   #5,1                Correct for +1 shift too much\n         TM    ##CDR(#6),X'80'     Test sign of arg 1\n         LR    #6,#4               Save upper word from ZLCBIG clobber\n         BZ    NONEG               We don't need to make answer neg\n         O     #5,=X'80000000'     Insert minus sign before storing\nNONEG    L     #15,ZLCBIG          Address of bignum allocator\n         LA    #2,##VECDAT+8       Total length of desired bignum\n         #BASR #14,#15             Allocate bignum space\n         MVC   1(3,#15),=AL3(8)    Store bignum length\n         STM   #5,#6,##VECDAT(#15) Store two-word bignum\n         LA    #2,##VECDAT+8(,#15)  Generate new availability pointer\n         ST    #2,ZLCVSNXT         Store updated availability pointer\n         B     RET                 Return to caller\n*\nMT62     LA    #15,#MT62           Return pointer to -2\u00ac62h\n         B     RET                 Return to caller\n*\nF1FP2BZ  ICM   #2,B'1111',##CDR(#6) Load fixnum and test sign\n         BP    FP1FP2B             Answer will be positive bignum\n         BM    FM1FP2B             Answer will be negative bignum\n         LA    #15,#SFT0           Answer must be 0, load pointer to 0\n         B     RET                 Return to caller\n*\nFP1FP2B  XR    #4,#4               Clear for divide\n         LR    #5,#3               Get the requested shift amount\n         D     #4,=F'31'           Divide to get offset and local shift\n         SRDL  #2,32               Clear reg 2 and put in reg 3\n         SLDL  #2,1(#4)            Do local shift, plus extra for bit 0\n         SRL   #3,1                Correct for overshift of lower word\n         SLL   #5,2                Convert word offset to byte offset\n         LTR   #6,#2               Is highest word a zero?\n         L     #15,ZLCBIG          Address of bignum maker\n         BP    FP1FP2BH            High word is not zero?\n         LR    #2,#5               Copy whole word shift amount\n         AH    #2,=H'8'            Total bignum length for bignum maker\n         #BASR #14,#15             Get a bignum space\n         SH    #2,=H'4'            Bring down to data length of bignum\n         STCM  #2,B'0111',1(#15)   Store bignum length in bignum header\n         ST    #3,##VECDAT(#5,#15) Store highest word of new bignum\n         LA    #4,##VECDAT(,#15)   Start of area to zero out\n         XR    #7,#7               Zero source length and 0 pad - MVCL\n         LA    #2,##VECDAT(#2,#15) Point to end of result\n         MVCL  #4,#6               Zero out all but high word, #6 junk\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nFP1FP2BH LR    #2,#5               Copy whole word shift amount\n         AH    #2,=H'12'           Total bignum length for bignum maker\n         #BASR #14,#15             Get a bignum space\n         SH    #2,=H'4'            Bring down to data length of bignum\n         STCM  #2,B'0111',1(#15)   Store bignum length in bignum header\n         ST    #3,##VECDAT(#5,#15) Store highest word of new bignum\n         ST    #6,##VECDAT+4(#5,#15) Store highest word of new bignum\n         LA    #4,##VECDAT(,#15)   Start of area to zero out\n         XR    #7,#7               Zero source length and 0 pad - MVCL\n         LA    #2,##VECDAT(#2,#15) Point to end of result\n         MVCL  #4,#6               Zero out all but high word, #6 junk\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nFM1FP2B  XR    #4,#4               Clear for divide\n         LR    #5,#3               Get the requested shift amount\n         D     #4,=F'31'           Divide to get offset and local shift\n         LPR   #2,#2\n         SRDL  #2,32               Clear reg 2 and put in reg 3\n         SLDL  #2,1(#4)            Do local shift, plus extra for bit 0\n         SRL   #3,1                Correct for overshift of lower word\n         SLL   #5,2                Convert word offset to byte offset\n         LTR   #6,#2               Is highest word a zero?\n         L     #15,ZLCBIG          Address of bignum maker\n         BP    FM1FP2BH            High word is not zero?\n         LR    #2,#5               Copy whole word shift amount\n         AH    #2,=H'8'            Total bignum length for bignum maker\n         #BASR #14,#15             Get a bignum space\n         SH    #2,=H'4'            Bring down to data length of bignum\n         STCM  #2,B'0111',1(#15)   Store bignum length in bignum header\n         ST    #3,##VECDAT(#5,#15) Store highest word of new bignum\n         LA    #4,##VECDAT(,#15)   Start of area to zero out\n         LA    #6,=X'80'           First byte of minus bignum\n         LA    #7,1                Copy minus byte and pad rest with 0\n         LA    #2,##VECDAT(#2,#15) Point to end of result\n         MVCL  #4,#6               Zero out all but high word, #6 junk\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nFM1FP2BH LR    #2,#5               Copy whole word shift amount\n         AH    #2,=H'12'           Total bignum length for bignum maker\n         #BASR #14,#15             Get a bignum space\n         SH    #2,=H'4'            Bring down to data length of bignum\n         STCM  #2,B'0111',1(#15)   Store bignum length in bignum header\n         ST    #3,##VECDAT(#5,#15) Store highest word of new bignum\n         ST    #6,##VECDAT+4(#5,#15) Store highest word of new bignum\n         LA    #4,##VECDAT(,#15)   Start of area to zero out\n         LA    #6,=X'80'           First byte of minus bignum\n         LA    #7,1                Copy minus byte and pad rest with 0\n         LA    #2,##VECDAT(#2,#15) Point to end of result\n         MVCL  #4,#6               Zero out all but high word, #6 junk\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nF1NF2    CLI   ##TYPE(#7),##BIGNUM Is arg 2 a bignum?\n         BNE   ERROR2              Error, arg 2 not an integer\n         TM    ##VECDAT(#7),X'80'  Test sign of bignum\n         BO    F1BM2               Shift amount is negative bignum\nF1BP2    ICM   #5,B'1111',##CDR(#6) Test fixnum arg 1\n         BNZ   ERROR3              Bignum will blow up\nFZ1BP2   LA    #15,#SFT0           Load address of 0\n         B     RET                 Return to caller\n*\nF1BM2    TM    ##CDR(#6),X'80'     Test sign of fixnum to be shifted\n         LA    #15,#SFT0           Load address of 0 in case we need it\n         BZ    RET                 Fixnum was non-negative, answer is 0\n         LA    #15,#SFTM1          Fixnum is negative, answer is -1\n         B     RET                 Return to caller\n*\nNF1      CLI   ##TYPE(#6),##BIGNUM Is arg 1 a bignum?\n         BNE   ERROR1              If not, first arg is not integer\nB1       CLI   ##TYPE(#7),##FIXNUM Is arg 2 a fixnum?\n         BNE   B1NF2               Go to Bignum 1 Not Fixnum 2\nB1F2     ICM   #3,B'1111',##CDR(#7) Load index and test sign\n         BZ    I1FZ2               Arg 1 is integer, arg 2 is zero\n         BM    B1FM2               Go to bignum 1 Fixnum Minus 2\nB1FP2    XR    #2,#2               Clear upper word for divide\n         D     #2,=F'31'           Divide by bits/word\n         SLL   #3,2                Compute number of bytes of shift\n         LR    #7,#2               Save bit shift\n         XR    #5,#5               Clear for inserting bignum length\n         ICM   #5,B'0111',1(#6)    Get length of bignum\n         LR    #2,#5               Extra copy of bignum length\n         L     #15,ZLCBIG          Load address of bignum maker\n         AH    #2,=H'8'            Compute maximum length of result\n         AR    #2,#3               Add shift amount to length\n         #BASR #14,#15             Call bignum allocator\n         L     #6,0(,#11)          Reload pointer to arg1 after GC\n         L     #0,##VECDAT(,#6)    Load lowest word of source bignum\n         LA    #2,0(#3,#15)        Fake pointer inside new bignum\n         SLL   #0,1(#7)            Shift and squeeze out sign bit\n         SRL   #0,1                Return to correct position\n         ST    #0,##VECDAT(,#2)    Store inside new bignum\n         LA    #4,4                Size of a bignum word for BXLE\n         LR    #14,#4              Set start value for index\n         SR    #5,#4               Reduce termination to 1 word less\nB1FP2LOO L     #1,##VECDAT-4(#14,#6) Lower of pair from source\n         L     #0,##VECDAT(#14,#6) Upper of pair from source\n         SLL   #1,1                Squeeze out empty bit and join\n         SLDA  #0,0(#7)            Shift by required amount\n         ST    #0,##VECDAT(#14,#2) Store into source bignum\n         BXLE  #14,#4,B1FP2LOO     More words to shift?\n*                                  Now we do last special iteration\n         L     #1,##VECDAT-4(#14,#6) Highest word from source\n         XR    #0,#0               Clear because it's \"beyond end\"\n         SLDA  #0,1(#7)            Shift by amount and empty bit\n         ST    #0,##VECDAT(#14,#2) Store into source bignum\n         AR    #14,#3              Calculate total length for output\n         XR    #5,#5               Setup zero-pad for whole MVCL\n         LA    #2,##VECDAT(,#15)   Start of data area to zero out\n         MVCL  #2,#4               Pad sign and zeroes at bottom\n         TM    ##VECDAT(#6),X'80'  Test sign of input bignum\n         BZ    SIGNDONE            Bignum is positive\n         OI    ##VECDAT(#15),X'80' Insert minus sign into result bignum\nSIGNDONE LTR   #0,#0               Is highest word 0?\n         BZ    HIZ                 Highest word zero, don't lengthen\n         LA    #14,4(,#14)         Add length when it's longer\nHIZ      STCM  #14,B'0111',1(#15)  Store length into result bignum\n         LA    #2,##VECDAT(#14,#15) Update VSS availability pointer\n         ST    #2,ZLCVSNXT         Store availability pointer\n         B     RET                 Return to caller\n*\nB1FM2    XR    #2,#2               Clear upper word for divide\n         LCR   #3,#3               Take positive of the shift\n         D     #2,=F'31'           Divide by bits/word\n         SLL   #3,2                Compute number of bytes of shift\n         LR    #7,#2               Save bit shift\n         XR    #2,#2               Clear for inserting bignum length\n         ICM   #2,B'0111',1(#6)    Get length of bignum\n         SR    #2,#3               Subtract shift amount from length\n         BNP   B1IM2               All was shifted out on right\n         L     #15,ZLCBIG          Load address of bignum maker\n         AH    #2,=H'8'            Add length of ##VECDAT header+4\n         #BASR #14,#15             Call bignum allocator\n         L     #6,0(,#11)          Reload arg in case GC changed pointr\n         LR    #5,#2               Save result length\n         SH    #5,=H'12'           -4 -header -one extra word\n         LA    #2,0(#3,#6)         Fake pointer inside old bignum\n         BZ    B1FM2F              Answer must be fixnum\n         LA    #4,4                Size of a bignum word for BXLE\n         LR    #14,#4              Set start value for index\nB1FM2LOO L     #1,##VECDAT-4(#14,#2) Lower of pair from source\n         L     #0,##VECDAT(#14,#2) Upper of pair from source\n         SLL   #1,1                Squeeze out empty bit and join\n         SRDL  #0,0(#7)            Shift by required amount\n         SRL   #1,1                Open up a zero for leftmost bit\n         ST    #1,##VECDAT-4(#14,#15) Store into source bignum\n         BXLE  #14,#4,B1FM2LOO     More words to shift?\n*                                  Now we do last special iteration\n         L     #0,##VECDAT-4(#14,#2) Highest word from source\n         SRA   #0,0(#7)            Shift by amount and empty bit\n         BZ    B1FM2HZ             High word is zero, make shorter\n         ST    #0,##VECDAT-4(#14,#15) Store into source bignum\n         TM    ##VECDAT(#6),X'80'  Test sign of source bignum\n         BZ    VSRETBP             Return with positive bignum\n         B     VSRETBMC            Check bits and return neg big?\n*\nB1FM2F   L     #0,##VECDAT(,#2)    Get only needed word from source\n         TM    ##VECDAT(#6),X'80'  Test sign of source bignum\n         BO    BM1FM2F             Bignum is negative\n         SRL   #0,0(#7)            Shift by required amount\n         LR    #2,#0               Set up for consing\n         B     RETFIX\n*\nBM1FM2F  XR    #1,#1               Clear lower part of double reg\n         SRDL  #0,0(#7)            Shift discard bits into reg #1\n         LCR   #2,#0               Take negative of result\n         BZ    RETM1               Result must be neg 1\n         LTR   #1,#1               Any ones shifted out?\n         BZ    BM1FM2FC            Got to check lower bits too\n         BCTR  #2,0                Add one to magnitude of ASH\n         B     RETFIX              Make a fixnum\n*\nBM1FM2FC LA    #2,##VECDAT(,#6)    Get pointer to source header\n         LA    #4,=X'80'           Imitate first byte in neg big data\n         LA    #5,1                Compare length 1, 0-pad rest\n         CLCL  #2,#4               Find ones in displaced length\n         BNE   BM1FM2F1            Must add one to fixnum magnitude\n         LCR   #2,#0               Take negative of shifted answer\n         B     RETFIX              Make a fixnum\n*\nBM1FM2F1 LCR   #2,#0               Take negative of shifted word\n         BCTR  #2,0                Subtract one\n         B     RETFIX              Make a fixnum\n*\nB1FM2HZ  SH    #14,=H'4'           Answer is one word shorter, #14=len\n         CH    #14,=H'4'           Is answer only one word?\n         BE    B1FM2HZF            Answer must be a fixnum\nBFMRET   TM    ##VECDAT(#6),X'80'  Test sign of source bignum\n         BZ    VSRETBP             Return positive bignum\nVSRETBMC L     #0,##VECDAT(,#2)    Load rightmost used word in source\n         XR    #1,#1               Clear high word above mask\n         SRDL  #0,0(#7)            Shift by bit amount\n         LTR   #1,#1               Any bits shifted out on right?\n         BNZ   VSRETBM1            Return 1 less for neg bignum result\n         LTR   #3,#3               Are there whole words to check?\n         BZ    VSRETBM0            Nope, don't subtract one from result\n         LA    #2,##VECDAT(,#6)    Start of comparison to 0's\n         LA    #4,=X'80'           First byte to compare\n         LA    #5,1                Clear pad, 1 byte of real compare\n         CLCL  #2,#4               Compare to 0\n         BE    VSRETBM0            Did not find 1 bit, don't subtract 1\n*\nVSRETBM1 LR    #5,#14              Restore length\n         LA    #4,4                Load increment (size of a word)\n         LR    #14,#4              Index start\n         XR    #0,#0               Need zero for storing in loop\nBMCLOOP  L     #1,##VECDAT-4(#14,#15) Load word to carry to\n         AH    #1,=H'1'            Add carry\n         BNO   NOCARRY             Word did not overflow?\n         ST    #0,##VECDAT-4(#14,#15) Store zero if overflow\n         BXLE  #14,#4,BMCLOOP      More words to overflow to?\n*\n         LA    #1,1                Carry out of high word, add another\n         ST    #1,##VECDAT-4(#14,#15) Store the 1 in new high word\n         OI    ##VECDAT(#15),X'80' Insert minus sign bit into result\n         STCM  #14,B'0111',1(#15)  Store bignum length in header\n         LA    #14,##VECDAT(#14,#15) Update availability pointer\n         ST    #14,ZLCVSNXT        Store updated VSS pointer\n         B     RET                 Return to caller\n*\nNOCARRY  ST    #1,##VECDAT-4(#14,#15)\n         OI    ##VECDAT(#15),X'80' Insert minus sign bit into result\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         LA    #14,##VECDAT(#5,#15) Update availability pointer\n         ST    #14,ZLCVSNXT        Store updated VSS pointer\n         B     RET                 Return to caller\n*\nVSRETBM0 CH    #14,=H'8'           Two-word bignum?\n         BNE   VSRETBM             No need to check futher for -2\u00ac31\n         CLC   ##VECDAT(8,#15),#W0W1 Compare agains possible -2\u00ac31\n         BE    MT31                Answer is -2\u00ac31\nVSRETBM  OI    ##VECDAT(#15),X'80' Insert minus sign bit into result\nVSRETBP  STCM  #14,B'0111',1(#15)  Store bignum length in header\n         LA    #14,##VECDAT(#14,#15) Update availability pointer\n         ST    #14,ZLCVSNXT        Store updated VSS pointer\n         B     RET                 Return to caller\n*\nMT31     LA    #15,#MT31           Load address of -2\u00ac31\n         B     RET\n*\nB1FM2HZF TM    ##VECDAT(#6),X'80'  Test sign of source bignum\n         BO    RETFMC              Check for bits\n         CL    #1,ZLCSFTHI         Compare with small fixnum table max\n         LR    #2,#1               Proper register for consing fixnum\n         BH    RETFIX              Need to cons the fixnum?\n         SLA   #1,3                Compute offset in small fixnum table\n         LA    #15,#SFT(#1)        Address in small fixnum table\n         B     RET                 Return to caller\n*\nRETFMC   L     #0,##VECDAT(,#2)    Get lowest used word to check lowbit\n         XR    #1,#1               Clear second word of pair\n         SRDL  #0,0(#7)            Shift out unused bits\n         LTR   #1,#1               Test shifted out bits\n         BNZ   RETFSUB1            Return 1 less for neg fix result\n         LTR   #3,#3               Are there whole words to check?\n         BZ    RETFSUB0            Nope, don't subtract one from result\n         LA    #2,##VECDAT(,#6)    Get start of area to check for 1-bit\n         LA    #4,=X'80'           First byte to compare\n         LA    #5,1                Compare 1 byte and 0-pad rest\n         CLCL  #2,#4               Search for for 1-bits\n         BNE   RETFSUB1            Return 1 less for neg fix result\nRETFSUB0 L     #2,##VECDAT-4(#14,#15) Get what should be a fixnum\n         LCR   #2,#2               Take negative\n         B     RETFIX              Return fixnum\n*\nRETFSUB1 L     #2,##VECDAT-4(#14,#15) Get what should be a fixnum\n         LCR   #2,#2               Take negative\n         BCTR  #2,0                Subtract 1 because 1-bits went out\n         B     RETFIX              Return fixnum\n*\nB1NF2    CLI   ##TYPE(#7),##BIGNUM Is arg 2 a bignum?\n         BNE   ERROR2              Arg 2 is not an integer\nB1B2     TM    ##VECDAT(#7),X'80'  Is arg2 bignum positive?\n         BZ    ERROR3              Then result will be too big\nB1IM2    TM    ##VECDAT(#6),X'80'  Is arg 1 integer positive?\n         LA    #15,#SFT0           Load address of 0 in case we need it\n         BZ    RET                 Arg 1 positive, all bits shifted out\nRETM1    LA    #15,#SFTM1          Load address of -1, because arg1 neg\n         B     RET                 Return to caller\n*\n         DS    0A                  Align bignum to fullword\n#MT62    DC    YL1(##BIGNUM),AL3(12),X'80000000',F'0',F'1'  -2**62\n#T31     DC    YL1(##BIGNUM),AL3(8),F'0',F'1' 2**31=bad bignum if neg\n#MT31    DC    YL1(##FIXNUM),AL3(0),F'-2147483648'  Most neg fixnum\n#W0W1    DC    F'0',F'1'  Upper two words of 2\u00ac31 bignum\n*\nERROR1   #ERR  'Argument 1 to ASH not an integer - ',(#6)\nERROR2   #ERR  'Argument 2 to ASH not an integer - ',(#7)\nERROR3   LM    #6,#7,0(#11)\n         #ERR  'Maximum integer magnitude exceeded in ASH trying to shiX\n               ft ',(#6),' by ',(#7)\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSQ": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x111\\x00;\\x00)\\x00:\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:31:00", "lines": 59, "newlines": 41, "modlines": 58, "user": "SEB1525"}, "text": "         TITLE 'ASSQ - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ASSQ: SAME AS COMMON LISP (ASSOC A B :TEST #'EQ)                    *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: THERE USED TO BE CODE TO CHECK FOR THE PRESENCE OF NIL IN     *\n*       THE MIDDLE OF THE ALIST.  THIS CODE HAS BEEN TAKEN OUT,       *\n*       SINCE WHEN IT IS REMOVED IT HAS THE SAME EFFECT ON CORRECT    *\n*       PROGRAMS.  TAKING THE \"CAR\" OF NIL RESULTS IN A POINTER THAT  *\n*       CANNOT BE EQ TO ANYTHING ELSE (EXCEPT THE CAR OF NIL, THAT    *\n*       IS, WHICH WON'T OCCUR IN A CORRECT PROGRAM), SO THE SEARCH    *\n*       ALWAYS PROCEEDS PAST NULL ELEMENTS.                           *\n*       WE'VE NEVER CHECKED FOR ATOMIC SUBLISTS ANYHOW.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 03/30/88 - Error checking added, now that ASSQ gets compiled inline.*\n*            Note that the checking is rather minimal.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nASSQ     #ZBEG MINARGS=2,MAXARGS=2,NAME='ASSQ'\n         SPACE 1\n         LM    #2,#3,0(#1)         LOAD ARG 1 (COMPARAND)\n         LR    #4,#3               LOAD ARG 2 (ALIST)\nLOOP     DS    0H\n         CR    #4,#10              COMPARE (SUB)ALIST TO NIL\n         LM    #3,#4,##CAR(#4)     #2 = SUBLISTS'S CAR, #3 = ITS CDR\n         BE    NOTFOUND            IF SUBLIST WAS NIL, RETURN NIL\n         LTR   #3,#3               If (sub)alist was an atom\n         BM    ERROR1              then error\n         C     #2,##CAR(,#3)       IF ARG 1 NOT EQ ITS CAR'S CAR\n         BNE   LOOP                THEN CONTINUE WITH SUBALIST'S CDR\n         DROP  #15\n         LR    #15,#3              ELSE RETURN WITH SUBALIST'S CAR\n         BR    #14\nNOTFOUND DS    0H\n         LR    #15,#10             NOT FOUND IN ALIST, RETURN NIL\n         BR    #14\nERROR1   LR    #3,#15\n         USING ASSQ,#3\n         L     #4,4(,#1)\n         #ERR  'Argument 2 to ASSQ not a proper list - ',(#4)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ATOM": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x111\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:31:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'ATOM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nATOM     #ZBEG MINARGS=1,MAXARGS=1,NAME='ATOM'\n         SPACE 1\n         USING ATOM,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##ATOM\n         BZ    ZXATN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXATN    LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BIGLIST": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x111\\x006\\x003\\x005\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:31:00", "lines": 54, "newlines": 51, "modlines": 53, "user": "SEB1525"}, "text": "         TITLE 'BIGLIST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* BIGLIST TAKES 1 ARGUMENT - A BIGNUM TO CONVERT TO A LIST OF FIXNUMS *\n***********************************************************************\n         SPACE\nBIGLIST  #ZBEG MINARGS=1,MAXARGS=1,NAME='BIGLIST'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ARGS=1              SAVE REGISTERS\n         SPACE\n*\n* CHECK INPUT ARGUMENT - MUST BE A BIGNUM\n*\n         L     #6,0(,#11)          GET ARG 1\n         CLI   ##TYPE(#6),##BIGNUM MUST BE A BIGNUM\n         BNE   ERROR1              OR ELSE\n* #6 -> BIGNUM\n* #3 = LENGTH OF BIGNUM DATA (# OF WORDS * 4)\n* #4 -> EACH WORD IN BIGNUM\n* #5 -> LIST BEING BUILT\n*\n* FOR EACH WORD IN THE BIGNUM, MAKE A FIXNUM OUT OF IT.\n* WE GO BACKWARDS TO FACILITATE CONSING THEM TOGETHER TO MAKE A LIST.\n*\n         XR    #3,#3               CLEAR INSERT REGISTER\n         ICM   #3,7,1(#6)          GET LENGTH OF BIGNUM DATA\n         LA    #4,##VECDAT-4(,#3)  INDEX TO LAST WORD IN BIGNUM\n         LR    #15,#10             INITIALIZE OUTPUT LIST TO NIL\n         LA    #0,20(,#11)         SET STACK POINTER FOR CONS\n         LH    #5,=H'-4'           SET UP BXLE DECREMENT\n         AR    #4,#5\nLOOP     DS    0H                  LOOP USING BXLE REGS #4, #6, #7\n         ST    #15,16(,#11)        (SETQ LIST (CONS FIXNUM LIST))\n         L     #6,0(,#11)          RELOAD BIGNUM ARG FROM STACK\n         L     #2,##VECDAT(#4,#6)  LOAD BIGNUM WORD VALUE\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         LR    #1,#15              ARG 1 TO CONS = BUILT FIXNUM\n         L     #2,16(,#11)         ARG 2 TO CONS = LIST SO FAR\n         L     #15,ZLCCONS         CALL CONS TO ADD NEW ATOM TO LIST\n         #BASR #14,#15\n         BXH   #4,#5,LOOP          CONTINUE UNTIL HIT START OF BIGNUM\nRETLIST  DS    0H\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 2\nERROR1   DS    0H\n         #ERR  'Argument to BIGLIST not a bignum - ',(#6)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BIGP": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x111\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:31:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'BIGP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nBIGP     #ZBEG MINARGS=1,MAXARGS=1,NAME='BIGP'\n         SPACE 1\n         USING BIGP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##BIGNUM\n         BNE   ZXBIGN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXBIGN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BUTLAST": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x112\\x00L\\x00I\\x00K\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:32:00", "lines": 76, "newlines": 73, "modlines": 75, "user": "SEB1525"}, "text": "         TITLE 'BUTLAST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* BUTLAST takes one required argument - a proper list - and           *\n*               one optional argument - the number of elements to     *\n*               ignore from the end of the list (default: 1).         *\n*                                                                     *\n* BUTLAST makes a copy of the first LENGTH(ARG1)-ARG2 CAR's of ARG1.  *\n*                                                                     *\n* Like LENGTH, BUTLAST will loop indefinitely if the list is circular.*\n*                                                                     *\n***********************************************************************\nBUTLAST  #ZBEG MINARGS=1,MAXARGS=2,NAME='BUTLAST'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #3,#4,0(#11)        #3 = arg1, #4 = arg2\n         CR    #4,#13              If arg2 is unsupplied\n         BNE   ARG2SUP             then\n         LA    #5,1                 set arg2 value to 1\n         B     GOTARG2             else\nARG2SUP  DS    0H                   arg2 was supplied\n         CLI   ##TYPE(#4),##FIXNUM If arg2 is not a fixnum\n         BNE   ERROR2              then error\n         ICM   #5,15,##CDR(#4)     else get value of arg2\n         BNM   GOTARG2             If negative,\n         XR    #5,#5                then set to zero\nGOTARG2  DS    0H                  #5 now equals \"ignore count\"\n         LR    #1,#3               Load arg1 for length computation\n         XR    #2,#2               Initialize (minus (length arg1))\n         SPACE 1\nLOOP1    DS    0H\n         CR    #1,#10              Loop until NIL (end of list arg1)\n         BE    ENDLOOP1\n         TM    ##TYPE(#1),##ATOM   If atom or dotted pair in arg1\n         BO    ERROR1              then arg1 is not a valid list\n         L     #1,##CDR(,#1)       Else cdr down arg1\n         BCT   #2,LOOP1            to find length thereof\nENDLOOP1 DS    0H                  #2 contains (minus (length arg1))\n         LR    #15,#10             Initialize return list to NIL\n         AR    #5,#2               Compute (minus (# elements to ret))\n         BNM   RETURN              If positive, return null list\n         LCR   #5,#5               Else make # of elements positive\n         LR    #7,#10              Initialize return list to NIL\nLOOP2    DS    0H                  Loop consing up elements\n         L     #1,##CAR(,#3)       Get a CAR of arg1\n         LR    #2,#10              CONS it with NIL\n         L     #15,ZLCCONS         Call CONS to add item to result list\n         #BASR #14,#15             (sets #15 to result of CONS)\n         CR    #7,#10              If return list is NIL\n         BNE   BNN                 then\n         LR    #7,#15               set return list to first CONS\n         LR    #6,#15               set bashee to first CONS\n         B     AFTBASH             else\nBNN      ST    #15,##CDR(,#6)       bash CDR of bashee\n         LR    #6,#15               set new bashee\nAFTBASH  DS    0H\n         L     #3,##CDR(,#3)       CDR down list\n         BCT   #5,LOOP2            CONS until count exhausted\n         LR    #15,#7              Set return value\n         SPACE 1\nRETURN   DS    0H                  #15 contains return value\n         #ZRET ,                   Return to caller\n         SPACE 1\nERROR1   DS    0H                  NOT A NUMERIC ATOM\n         #ERR  'Argument 1 to BUTLAST not a proper list - ',0(#11)\nERROR2   DS    0H                  NOT A NUMERIC ATOM\n         #ERR  'Argument 2 to BUTLAST not a fixnum - ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CAR": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00X\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x12\\x00 \\x00\\x1d\\x00\\x1f\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:12:58", "lines": 32, "newlines": 29, "modlines": 31, "user": "SEB1525"}, "text": "         TITLE 'CAR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS IS THE VERSION OF CAR FOR WHICH (CAR NIL) ==> NIL.             *\n* FOR SPEED BUT NO SUPPORT FOR (CAR NIL), USE ZCAR.                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCAR      #ZBEG MINARGS=1,MAXARGS=1,NAME='CAR'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING CAR,#3\n         SPACE 1\n         L     #15,0(,#1)          LOAD ARG 1\n         CR    #15,#10             IF ARG IS NIL\n         BER   #14                 THEN RETURN (CAR NIL) = NIL\n         TM    ##TYPE(#15),##ATOM  IF ARG IS NOT A LIST\n         BO    CARERROR            THEN ERROR\n         L     #15,##CAR(,#15)     ELSE RETURN CAR OF ARG\n         BR    #14\n         SPACE 1\nCARERROR DS    0H\n         LR    #2,#15\n         #ERR  'Argument to CAR not a list - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDR": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00(\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x13\\x00,\\x00)\\x00+\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:13:28", "lines": 44, "newlines": 41, "modlines": 43, "user": "SEB1525"}, "text": "         TITLE 'CDR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS IS THE VERSION OF CDR FOR WHICH (CDR NIL) ==> NIL.             *\n* FOR SPEED BUT NO SUPPORT FOR (CDR NIL), USE ZCDR.                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCDR      #ZBEG MINARGS=1,MAXARGS=1,NAME='CDR'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING CDR,#3\n         SPACE 1\n         L     #15,0(,#1)          LOAD ARG 1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* The check for CDR of NIL is not required, since the architecture of *\n* symbols is such that the value cell is in the same position as the  *\n* CDR cell of a CONS.                                                 *\n*                                                                     *\n* However, since a check for atomicity is required, we still have to  *\n* allow for this.                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CR    #15,#10             IF ARG IS NIL\n         BER   #14                 THEN RETURN (CDR NIL) = NIL\n         TM    ##TYPE(#15),##ATOM  IF ARG IS NOT A LIST\n         BO    CDRERROR            THEN ERROR\n         L     #15,##CDR(,#15)     ELSE RETURN CDR OF ARG\n         BR    #14\n         SPACE 1\nCDRERROR DS    0H\n         LR    #2,#15\n         #ERR  'Argument to CDR not a list - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHAR": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00E\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x13\\x005\\x002\\x004\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:13:45", "lines": 53, "newlines": 50, "modlines": 52, "user": "SEB1525"}, "text": "         TITLE 'CHAR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CHAR TAKES TWO ARGUMENTS - A STRING AND A FIXNUM.                   *\n*                                                                     *\n* IT RETURNS A FIXNUM.  INDEXING IS ZERO-BASED, UNLIKE GETCHAR(N).    *\n*                                                                     *\n* Note: Because this function does not need to CONS, it does not      *\n*       have to save anything on the stack.                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCHAR     #ZBEG MINARGS=2,MAXARGS=2,NAME='CHAR'\n         SPACE 1\n         LM    #6,#7,0(#1)         LOAD ARGS\n         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         CLI   ##TYPE(#7),##FIXNUM IF ARG 2 IS NOT A FIXNUM\n         BNE   ERROR2              THEN ERROR\n         ICM   #5,15,##CDR(#7)     GET FIXNUM VALUE\n         BM    RETNIL              IF NEGATIVE, RETURN NIL\n         XR    #4,#4               CLEAR INSERT REG\n         ICM   #4,7,1(#6)          GET STRING LENGTH\n         CR    #5,#4               IF INDEX EXCEEDS LENGTH\n         BNL   RETNIL              THEN RETURN NIL\n         XR    #2,#2               CLEAR INSERT REGISTER\n         IC    #2,##VECDAT(#5,#6)  GET STRING CHARACTER INTO REGISTER\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Point to fixnum in table\n         BR    #14                 Return with #15 pointing to fixnum\n         SPACE 1\nRETNIL   DS    0H                  INDEX OUT OF BOUNDS\n         LR    #15,#10             RETURN NIL\n         BR    #14                 Return with #15 pointing to fixnum\n         SPACE 1\n         DROP  #15\n         USING CHAR,#3\nERROR1   LR    #3,#15\n         #ERR  'Argument 1 to CHAR not a string - ',(#6)\nERROR2   LR    #3,#15\n         #ERR  'Argument 2 to CHAR not a fixnum - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHARDOWN": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x01\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x14\\x001\\x00.\\x000\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:14:01", "lines": 49, "newlines": 46, "modlines": 48, "user": "SEB1525"}, "text": "         TITLE 'CHARDOWN - BUILT-IN ZIL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CHARDOWN TAKES ONE ARGUMENT - A FIXNUM.                             *\n* THE FIXNUM IS INTERPRETED AS A CHARACTER TO BE CONVERTED TO ITS     *\n* LOWER CASE EQUIVALENT.                                              *\n*                                                                     *\n* ALIAS \"CHAR-DOWNCASE\".                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCHARDOWN #ZBEG MINARGS=1,MAXARGS=1,NAME='CHAR-DOWNCASE'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING CHARDOWN,#3\n         SPACE 1\n         L     #15,0(,#1)          GET ATOM (ARG 1 TO CHARDOWN)\n         CLI   ##TYPE(#15),##FIXNUM MUST BE A FIXNUM\n         BNE   ERROR1              OR ELSE\n         L     #4,##CDR(,#15)      GET FIXNUM CONTENTS\n         CL    #4,#SFW255          IF NOT 1-BYTE CHARACTER FIXNUM\n         BHR   #14                  THEN JUST RETURN IT AS IS\n         XR    #2,#2\n         IC    #2,TABLE(#4)        IF IN RANGE, LOAD CHAR FROM TABLE\n         CR    #2,#4               IF THE SAME\n         BER   #14                 THEN JUST RETURN\n         SLA   #2,3                Else convert number to table index\n         LA    #15,#SFT(#2)        Point to fixnum in fixnum table\n         BR    #14                  and return with it\n         SPACE 1\nTABLE    DC    256YL1(*-TABLE)     ALL CHARS TRANSLATE TO SELVES\n         ORG   TABLE+C'A'          EXCEPT UPPER CASE TO LOWER CASE\n         DC    X'818283848586878889'\n         ORG   TABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   TABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         SPACE 1\nERROR1   #ERR  'Argument to CHAR-DOWNCASE not a fixnum - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHARP": {"ttr": 1043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x885\\x1f\\x00\\x89\\x15o\\x112\\x00\\x1c\\x00\\x1b\\x00\\x1b\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-12-16T00:00:00", "modifydate": "1989-06-05T11:32:00", "lines": 28, "newlines": 27, "modlines": 27, "user": "SEB1525"}, "text": "         TITLE 'CHARP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CHARACTERP - alias CHARP - true if argument is a \"character\", which *\n* means in ZIL a fixnum between 0 and 255.  The test here is to       *\n* compare the argument with X'C0000000 000000__', since all fixnums   *\n* in character range will look like that.                             *\n*                                                                     *\n***********************************************************************\n*\nCHARP    #ZBEG MINARGS=1,MAXARGS=1,NAME='CHARACTERP'\n         SPACE 1\n         USING CHARP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLC   0(7,#2),#SFT0\n         BNE   ZXCHARN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXCHARN  LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHARUP": {"ttr": 1045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x14\\x001\\x00.\\x000\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:14:18", "lines": 49, "newlines": 46, "modlines": 48, "user": "SEB1525"}, "text": "         TITLE 'CHARUP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CHARUP TAKES ONE ARGUMENT - A FIXNUM.                               *\n* THE FIXNUM IS INTERPRETED AS A CHARACTER TO BE CONVERTED TO ITS     *\n* UPPER CASE EQUIVALENT.                                              *\n*                                                                     *\n* ALIAS \"CHAR-UPCASE\".                                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCHARUP   #ZBEG MINARGS=1,MAXARGS=1,NAME='CHAR-UPCASE'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING CHARUP,#3\n         SPACE 1\n         L     #15,0(,#1)          GET ATOM (ARG 1 TO CHAR-UPCASE)\n         CLI   ##TYPE(#15),##FIXNUM MUST BE A FIXNUM\n         BNE   ERROR1              OR ELSE\n         L     #4,##CDR(,#15)      GET FIXNUM CONTENTS\n         CL    #4,#SFW255          IF NOT 1-BYTE CHARACTER FIXNUM\n         BHR   #14                  THEN JUST RETURN IT AS IS\n         XR    #2,#2\n         IC    #2,TABLE(#4)        IF IN RANGE, LOAD CHAR FROM TABLE\n         CR    #2,#4               IF THE SAME\n         BER   #14                 THEN JUST RETURN\n         SLA   #2,3                Else convert number to table index\n         LA    #15,#SFT(#2)        Point to fixnum in fixnum table\n         BR    #14                  and return with it\n         SPACE 1\nTABLE    DC    256YL1(*-TABLE)     ALL CHARS TRANSLATE TO SELVES\n         ORG   TABLE+C'A'-X'40'    EXCEPT LOWER CASE TO UPPER CASE\n         DC    C'ABCDEFGHI'\n         ORG   TABLE+C'J'-X'40'\n         DC    C'JKLMNOPQR'\n         ORG   TABLE+C'S'-X'40'\n         DC    C'STUVWXYZ'\n         ORG\n         SPACE 1\nERROR1   #ERR  'Argument to CHAR-UPCASE not a fixnum - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLOSUREP": {"ttr": 1047, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x112\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:32:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'CLOSUREP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCLOSUREP #ZBEG MINARGS=1,MAXARGS=1,NAME='CLOSUREP'\n         SPACE 1\n         USING CLOSUREP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##CLOSUR\n         BNE   ZXCLSRN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXCLSRN  LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CODEP": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x112\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:32:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'CODEP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCODEP    #ZBEG MINARGS=1,MAXARGS=1,NAME='CODEP'\n         SPACE 1\n         USING CODEP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##CODE   ATOMIC AND COMPILED CODE OBJECT\n         BNO   ZXCODEN\n         DROP  #15\nZXCODET  LR    #15,#8\n         BR    #14\nZXCODEN  LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONS": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x112\\x00\\x0f\\x00\\x0c\\x00\\x0e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:32:00", "lines": 15, "newlines": 12, "modlines": 14, "user": "SEB1525"}, "text": "         TITLE 'CONS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCONS     #ZBEG MINARGS=2,MAXARGS=2,NAME='CONS'\n         SPACE 1\n*                                  NOTE - NO BASE REGISTER.\n         L     #15,ZLCCONS\n         LM    #1,#2,0(#1)\n         BR    #15                 ZLCCONS WILL RETURN VIA OUR #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONSP": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x113\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:33:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'CONSP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nCONSP    #ZBEG MINARGS=1,MAXARGS=1,NAME='CONSP'\n         SPACE 1\n         USING CONSP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##ATOM\n         BO    ZXCONSN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXCONSN  LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CSSIZE": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x113\\x00\\x13\\x00\\x10\\x00\\x12\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:33:00", "lines": 19, "newlines": 16, "modlines": 18, "user": "SEB1525"}, "text": "         TITLE 'CSSIZE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nCSSIZE   #ZBEG MINARGS=0,MAXARGS=0,NAME='CSSIZE'\n         #ZPDS 12                  DEFINE STACK SIZE\n         #ZSAV ARGS=0              SAVE REGISTERS\n         SPACE 1\n         L     #2,ZLCCSSIZ         GET SIZE VALUE FROM COMMON AREA\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         #ZRET ,                   RETURN WITH IT\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CURDATE": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x13\\x00\\x88\\x01_\\x01\\x00\\x10O\\x14'\\x00i\\x00_\\x00h\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-04-13T14:27:13", "lines": 105, "newlines": 95, "modlines": 104, "user": "SEB1525"}, "text": "         TITLE 'CURDATE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* CURDATE RETURNS THE CURRENT DATE AS LIST OF 3 INTEGERS, REPRESENTING\n* THE DATE AS (YEAR MONTH DAY).\n*\n***********************************************************************\n*\n* 04/13/2000 Changed for Y2K.\n*\n***********************************************************************\nCURDATE  #ZBEG MINARGS=0,MAXARGS=0,NAME='CURDATE'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ARGS=0              SAVE REGISTERS\n         SPACE\n         TIME  DEC                 GET CURRENT TIME AND DATE\n         ST    #1,DECDATE          STORE DATE IN WORK AREA\n         SPACE\n         XR    #14,#14\n         LH    #15,DECYEAR         GET DECIMAL YEAR\n         SLL   #15,4\n         LA    #15,X'C'(,#15)\n         STM   #14,#15,ZLCDBL\n         CVB   #2,ZLCDBL\n         LA    #2,1900(,#2)\n         ST    #2,YEAR\n         SPACE\n         XR    #14,#14\n         XR    #15,#15\n         ICM   #15,B'0011',DECJUL  GET DECIMAL JULIAN DAY\n         STM   #14,#15,ZLCDBL\n         CVB   #2,ZLCDBL\n         ST    #2,JULIAN\n         SPACE\n*\n* COMPUTE MONTH AND DAY FROM JULIAN DAY\n*\n* DETERMINE IF YEAR IS DIVISIBLE BY 4 (I.E. LEAP YEAR).\n* (THIS ALGORITHM WILL FAIL IN THE YEAR 2100, SO BE WARNED)\n*\n         TM    YEAR+3,B'00000011'  IF THIS YEAR IS A LEAP YEAR\n         BNZ   NOTLEAP             THEN\n         LA    #0,29                SET MONTHS TO 29\n         B     AFTLEAP             ELSE\nNOTLEAP  LA    #0,28                SET MONTHS TO 28\nAFTLEAP  DS    0H\n         ST    #0,MONTHS+4         SET # OF MONTHS IN FEBRUARY\n         LA    #15,MONTHS-4        POINT TO ARRAY OF DAYS PER MONTH\n         LA    #1,4(,#15)          POINT TO FIRST/NEXT ELEMENT\nJULLOOP  DS    0H                  DO WHILE #DAYS EXCEEDS DAYS LEFT\n         C     #2,0(,#1)           IF #DAYS > DAYS IN THIS MONTH\n         BNH   GOTMONTH            THEN\n         S     #2,0(,#1)            DECREASE #DAYS BY DAYS IN THIS MO.\n         LA    #1,4(,#1)            POINT TO NEXT MONTH'S DAYS\n         B     JULLOOP              AND CONTINUE.\nGOTMONTH DS    0H                  WHEN MONTH IS FOUND,\n         SR    #1,#15               COMPUTE THE INDEX OF THE\n         SRA   #1,2                 DAYS-IN-MONTH ENTRY WE'RE AT\n         ST    #1,MONTH             GIVING THE MONTH NUMBER\n         ST    #2,DAY               REMAINING # OF DAYS IS DAY NUMBER\nDATEDONE DS    0H\n         L     #2,DAY\n         SLA   #2,3\n         LA    #1,#SFT(#2)         FIXNUM DAY\n         LR    #2,#10\n         LA    #0,16(,#11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS DAY NIL)\n         ST    #15,12(,#11)\n         L     #2,MONTH\n         SLA   #2,3\n         LA    #1,#SFT(#2)         FIXNUM MONTH\n         L     #2,12(,#11)\n         LA    #0,16(,#11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS MONTH (CONS DAY NIL))\n         ST    #15,12(,#11)\n         L     #2,YEAR\n         LA    #0,16(,#11)\n         #MKAT FIXED               Make a new fixnum for the year\n         LR    #1,#15              FIXNUM MONTH\n         L     #2,12(,#11)\n         LA    #0,16(,#11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS YEAR (CONS MONTH (CONS DAY ...\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\nYEAR     DS    F\nMONTH    DS    F\nDAY      DS    F\nJULIAN   DS    F\nDECDATE  DS    F                   0086123F\nDECYEAR  EQU   DECDATE+0,2,C'H'    0086\nDECJUL   EQU   DECDATE+2,2,C'P'        123F\n         SPACE\nMONTHS   DC    F'31,00,31,30,31,30,31,31,30,31,30,31'\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CURJDATE": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x00\\x88\\x01_\\x01\\x00\\x10O\\x140\\x00D\\x00;\\x00C\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-04-13T14:30:31", "lines": 68, "newlines": 59, "modlines": 67, "user": "SEB1525"}, "text": "         TITLE 'CURJDATE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CURJDATE RETURNS THE CURRENT JULIAN DATE AS A LIST OF 2 INTEGERS,   *\n* REPRESENTING THE DATE AS (YEAR DAYS).                               *\n*                                                                     *\n***********************************************************************\n*\n* 04/13/2000 Changed for Y2K.\n*\n***********************************************************************\nCURJDATE #ZBEG MINARGS=0,MAXARGS=0,NAME='CURJDATE'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ARGS=0              SAVE REGISTERS\n         SPACE\n         TIME  DEC                 GET CURRENT TIME AND DATE\n         ST    #1,DECDATE          STORE DATE IN WORK AREA\n         SPACE\n         XR    #14,#14\n         LH    #15,DECYEAR         GET DECIMAL YEAR\n         SLL   #15,4\n         LA    #15,X'C'(,#15)\n         STM   #14,#15,ZLCDBL\n         CVB   #2,ZLCDBL\n         LA    #2,1900(,#2)\n         ST    #2,YEAR\n         SPACE\n         XR    #14,#14\n         XR    #15,#15\n         ICM   #15,B'0011',DECJUL  GET DECIMAL JULIAN DAY\n         STM   #14,#15,ZLCDBL\n         CVB   #2,ZLCDBL\n         ST    #2,JULIAN\n         SPACE\nDATEDONE DS    0H\n         L     #2,JULIAN\n         #MKAT FIXED               MUST CONS FIXNUM, MAY BE > 255\n         LR    #1,#15\n         LR    #2,#10\n         LA    #0,16(,#11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS JULIAN NIL)\n         ST    #15,12(,#11)\n         L     #2,YEAR\n         LA    #0,16(,#11)\n         #MKAT FIXED               Make a new fixnum for the year\n         LR    #1,#15              FIXNUM YEAR\n         L     #2,12(,#11)\n         LA    #0,16(,#11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS YEAR (CONS JULIAN NIL)\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\nYEAR     DS    F\nJULIAN   DS    F\nDECDATE  DS    F                   0086123F\nDECYEAR  EQU   DECDATE+0,2,C'H'    0086\nDECJUL   EQU   DECDATE+2,2,C'P'        123F\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CURTIME": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x113\\x00c\\x00_\\x00b\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:33:00", "lines": 99, "newlines": 95, "modlines": 98, "user": "SEB1525"}, "text": "         TITLE 'CURTIME - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* CURTIME RETURNS THE CURRENT TIME AS A LIST OF 4 INTEGERS,\n* REPRESENTING THE CURRENT TIME OF DAY AS 24-HOUR CLOCK TIME IN THE\n* FORM OF A LIST (HOUR MINUTE SECOND /* HUNDREDTHSOFASECOND */  ).\n*\n***********************************************************************\nCURTIME  #ZBEG MINARGS=0,MAXARGS=0,NAME='CURTIME'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ARGS=0              SAVE REGISTERS\n         SPACE\n         TIME  DEC                 GET CURRENT TIME\n         ST    #0,DECTIME          STORE IN WORK AREA\n         SPACE\n         XR    #14,#14\n         XR    #15,#15\n         IC    #15,DECTIME+0       GET DECIMAL # OF HOURS\n         SLL   #15,4\n         LA    #15,X'C'(,#15)\n         STM   #14,#15,ZLCDBL\n         CVB   #2,ZLCDBL\n         ST    #2,HOURS\n         SPACE\n         XR    #14,#14\n         XR    #15,#15\n         IC    #15,DECTIME+1       GET DECIMAL # OF MINUTES\n         SLL   #15,4\n         LA    #15,X'C'(,#15)\n         STM   #14,#15,ZLCDBL\n         CVB   #2,ZLCDBL\n         ST    #2,MINUTES\n         SPACE\n         XR    #14,#14\n         XR    #15,#15\n         IC    #15,DECTIME+2       GET DECIMAL # OF SECONDS\n         SLL   #15,4\n         LA    #15,X'C'(,#15)\n         STM   #14,#15,ZLCDBL\n         CVB   #2,ZLCDBL\n         ST    #2,SECONDS\n         SPACE\n***      XR    #14,#14\n***      XR    #15,#15\n***      IC    #15,DECTIME+3       GET DECIMAL # OF SECONDS/100\n***      SLL   #15,4\n***      LA    #15,X'C'(,#15)\n***      STM   #14,#15,ZLCDBL\n***      CVB   #2,ZLCDBL\n***      ST    #2,HUNSECS\n***      SPACE\n***      L     #2,HUNSECS\n***      #MKAT FIXED\n***      LR    #1,#15\n***      LR    #2,#10\n***      LA    #0,16(,#11)\n***      L     #15,ZLCCONS\n***      #BASR #14,#15             (CONS HUNDREDTHSOFASECOND NIL)\n***      ST    #15,12(,#11)\n         L     #2,SECONDS\n         SLA   #2,3\n         LA    #1,#SFT(#2)         FIXNUM SECONDS\n***      L     #2,12(,#11)         ONLY IF USING SECONDS/100...\n         LR    #2,#10              OTHERWISE START LIST OUT HERE.\n         LA    #0,16(,#11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS SECONDS ...\n         ST    #15,12(,#11)\n         L     #2,MINUTES\n         SLA   #2,3\n         LA    #1,#SFT(#2)         FIXNUM MINUTES\n         L     #2,#12(,11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS MINUTES (CONS SECONDS ...\n         ST    #15,12(,#11)\n         L     #2,HOURS\n         SLA   #2,3\n         LA    #1,#SFT(#2)         FIXNUM HOURS\n         L     #2,#12(,11)\n         L     #15,ZLCCONS\n         #BASR #14,#15             (CONS HOURS (CONS MINUTES (CONS ...\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\n         DS    0D\nDECTIME  DS    A\nHOURS    DS    A\nMINUTES  DS    A\nSECONDS  DS    A\nHUNSECS  DS    A\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DELQ": {"ttr": 1297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x007\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x14\\x00@\\x00=\\x00?\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:14:37", "lines": 64, "newlines": 61, "modlines": 63, "user": "SEB1525"}, "text": "         TITLE 'DELQ - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* DELQ: SAME AS COMMON LISP (DELETE A B :TEST #'EQ)                   *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nDELQ     #ZBEG MINARGS=2,MAXARGS=3,NAME='DELQ'\n         SPACE 1\n         LR    #7,#15              LOCAL BASE REGISTER\n         DROP  #15\n         USING DELQ,#7\n         SPACE 1\n         LM    #1,#3,0(#1)         LOAD ARGS 1, 2, 3\n         LR    #15,#2              PRESET RETURN VALUE\n         SPACE 1\n         CR    #3,#13              IF ARG 3 NOT SUPPLIED\n         BNE   ARG3SUP             THEN\n         LR    #3,#10               SET ARG 3 = NIL\n         B     ARG3OK               AND GO PROCESS\nARG3SUP  DS    0H                  ELSE\n         SPACE 1\n         CR    #3,#10              IF ARG3 (COUNT) IS NIL\n         BE    ARG3OK              THEN IT'S OK\n         CLI   ##TYPE(#3),##FIXNUM ELSE ARG3 MUST BE A FIXNUM\n         BNE   ARG3ERR             OTHERWISE ERROR\n         ICM   #6,#15,##CDR(#3)    GET FIXNUM VALUE OF ARG3 = COUNT\n         BNPR  #14                 IF NOT POSITIVE, RETURN W/O DELETES\nARG3OK   DS    0H\n         LR    #4,#10              INITIALIZE BASHEE POINTER\nLOOP     DS    0H                  DO WHILE LIST IS NOT NULL\n         CR    #2,#10              WHEN END OF LIST REACHED\n         BER   #14                 RETURN WITH VALUE IN #15\n         TM    ##TYPE(#2),##ATOM   IF LIST ENDS WITH ATOM\n         BOR   #14                 DO LIKE IT ENDED IN NIL\n         C     #1,##CAR(,#2)       IF ARG1 IS EQ TO CAR OF (SUB)LIST\n         BNE   NOTEQ               THEN...\n         L     #2,##CDR(,#2)        DROP IT FROM (SUB)LIST\n         CR    #4,#10               IF WE HAVE SOMETHING TO BASH\n         BE    NOBASH               THEN\n         ST    #2,##CDR(,#4)         BASH IT (RPLACD TO SPLICE OUT CAR)\n         B     AFTBASH              ELSE\nNOBASH   LR    #15,#2                JUST CHANGE THE RETURN VALUE PTR\nAFTBASH  DS    0H\n         CR    #3,#10               IF THERE IS A COUNT (ARG3 NOT NIL)\n         BE    LOOP                 THEN...\n         BCT   #6,LOOP               DECREMENT, THEN LOOP UNLESS COUNT\n         BR    #14                   REACHED, IN WHICH CASE RETURN\nNOTEQ    DS    0H                  ELSE THIS CAR DOESN'T MATCH\n         LR    #4,#2               SET BASHEE POINTER\n         L     #2,##CDR(,#2)       CDR DOWN (SUB)LIST\n         B     LOOP                CONTINUE LOOPING\n         SPACE 1\nARG3ERR  #ERR  'Invalid DELQ count argument - ',(#3)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DFLOATP": {"ttr": 1299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'DFLOATP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nDFLOATP  #ZBEG MINARGS=1,MAXARGS=1,NAME='DFLOATP'\n         SPACE 1\n         USING DFLOATP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##DFLOAT\n         BNE   ZXFLON\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXFLON   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIGITCP": {"ttr": 1301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00T\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x14\\x00K\\x00H\\x00J\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:14:54", "lines": 75, "newlines": 72, "modlines": 74, "user": "SEB1525"}, "text": "         TITLE 'DIGITCP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ALIAS \"DIGIT-CHAR-P\".                                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nDIGITCP  #ZBEG MINARGS=1,MAXARGS=2,NAME='DIGIT-CHAR-P'\n         LR    #7,#15\n         DROP  #15\n         USING DIGITCP,#7\n         SPACE\n         LM    #3,#4,0(#1)         GET ARGS 1 AND 2\n         CLI   ##TYPE(#3),##FIXNUM MUST BE A FIXNUM\n         BNE   ERROR1              OR ELSE ERROR\n         CR    #4,#13              IF OPTIONAL ARG 2 IS OMITTED\n         BNE   ARG2SPEC            THEN\n         LA    #5,10                SET RADIX TO 10\n         B     RADIXSET            ELSE\nARG2SPEC CLI   ##TYPE(#4),##FIXNUM  ARG 2 MUST BE A FIXNUM\n         BNE   ERROR2               ELSE ERROR\n         L     #5,##CDR(,#4)        GET VALUE OF ARG 2\n         CH    #5,=H'2'             CHECK RANGE OF RADIX\n         BL    ERROR2\n         CH    #5,=H'36'\n         BH    ERROR2\nRADIXSET DS    0H                  #5 = RADIX\n*\n* GET THE NUMERIC VALUE OF THE FIXNUM.\n*\n         L     #1,##CDR(,#3)       GET FIXNUM CONTENTS\n         CL    #1,#SFW255          MUST BE 1-BYTE CHARACTER FIX\n         BH    FALSE               ELSE NOT NUMERIC CHARACTER\n         XR    #2,#2\n         IC    #2,TABLE(#1)        IF IN RANGE, LOAD WEIGHT FROM TABLE\n         CR    #2,#5               IF WEIGHT OK WITHIN RADIX\n         BNL   FALSE               THEN...\nTRUE     DS    0H\n         SLA   #2,3                CONVERT WEIGHT TO INDEX\n         LA    #15,#SFT(#2)        LOAD FIXNUM FROM TABLE\n         BR    #14                 AND RETURN IT\n         SPACE 1\nFALSE    LR    #15,#10             NOT A DIGIT - RETURN NIL\n         BR    #14                 AND RETURN IT\n         SPACE 1\nTABLE    DC    256YL1(255)         CHARACTERS INVALID FOR ALL RADICES\n*                                  EXCEPT...\n         ORG   TABLE+C'0'\n         DC    YL1(0,1,2,3,4,5,6,7,8,9)\n         ORG   TABLE+C'A'-X'40'\n         DC    YL1(10,11,12,13,14,15,16,17,18)\n         ORG   TABLE+C'J'-X'40'\n         DC    YL1(19,20,21,22,23,24,25,26,27)\n         ORG   TABLE+C'S'-X'40'\n         DC    YL1(28,29,30,31,32,33,34,35)\n         ORG   TABLE+C'A'\n         DC    YL1(10,11,12,13,14,15,16,17,18)\n         ORG   TABLE+C'J'\n         DC    YL1(19,20,21,22,23,24,25,26,27)\n         ORG   TABLE+C'S'\n         DC    YL1(28,29,30,31,32,33,34,35)\n         ORG\n         SPACE 1\nERROR1   #ERR  'Argument 1 to DIGIT-CHAR-P not a fixnum - ',(#3)\n         SPACE 1\nERROR2   #ERR  'Argument 2 to DIGIT-CHAR-P not a valid radix - ',(#4), X\n               ' (must be a fixnum between 2 and 36)'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOWNCASE": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00l\\x00i\\x00k\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 108, "newlines": 105, "modlines": 107, "user": "SEB1525"}, "text": "         TITLE 'DOWNCASE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS IS STRING-DOWNCASE.                                            *\n*                                                                     *\n***********************************************************************\nDOWNCASE #ZBEG MINARGS=1,MAXARGS=1,NAME='STRING-DOWNCASE'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #3,0(,#11)          LOAD ARG1\n         CLI   ##TYPE(#3),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#3),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #3,##PNAME(,#3)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ST    #3,0(,#11)          STORE BACK ON STACK FOR FUTURE USE\n         ICM   #7,7,1(#3)          GET LENGTH OF STRING\n         BZ    RETSELF             IF ZERO-LENGTH STRING, RETURN SELF\n         LA    #14,##VECDAT(,#3)   POINT TO TEXT OF STRING\n         LR    #15,#7              GET LENGTH\n         LA    #0,256              SET UP CONSTANT 256\nTRTLOOP  DS    0H                  LOOP TO SCAN STRING\n         CR    #15,#0\n         BNH   SHORTTRT\n         TRT   0(256,#14),TRTTABLE SCAN FOR UPPER CASE CHARACTERS\n         BNZ   COPYIT              IF WE FOUND ONE, WE HAVE TO COPY\n         AR    #14,#0              ELSE BUMP UP POINTER TO TEXT\n         SR    #15,#0              BUMP DOWN LENGTH\n         B     TRTLOOP             AND CONTINUE SCANNING.\nSHORTTRT DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         EX    #15,EXTRT           SCAN FOR LOWER CASE CHARACTERS\n         BZ    RETSELF             IF NO BAD CHARS, RETURN SELF\nCOPYIT   DS    0H                  UPPERCASE DATA, HAVE TO COPY\n         LR    #2,#7               GET LENGTH INTO REG FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #4,#15              IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         L     #1,0(,#11)          GET POINTER TO ORIGINAL STRING\n         LA    #0,##VECDAT(,#1)    POINT TO STRING TEXT\n         LA    #14,##VECDAT(,#4)   POINT TO WHERE TO MOVE STRING TEXT\n         LR    #1,#7               GET LENGTH OF STRING TEXT TO MOVE\n         LR    #15,#7\n         MVCL  #14,#0              MOVE TEXT FROM OLD STRING TO NEW\n         LA    #14,##VECDAT(,#4)   POINT TO TEXT OF STRING\n         LR    #15,#7              GET LENGTH\n         LA    #0,256              SET UP CONSTANT 256\nTRLOOP   DS    0H                  LOOP TO TRANSLATE STRING\n         CR    #15,#0\n         BL    SHORTTR\n         TR    0(256,#14),TRTABLE  TRANSLATE TO LOWER CASE\n         AR    #14,#0              BUMP UP POINTER TO TEXT\n         SR    #15,#0              BUMP DOWN LENGTH\n         BZ    DONE\n         B     TRLOOP              AND CONTINUE TRANSLATING.\nSHORTTR  DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         EX    #15,EXTR            TRANSLATE TO LOWER CASE\nDONE     DS    0H                  ALL FINISHED\n         LR    #15,#4              POINT TO NEWLY BUILT STRING\n         B     RETURN              RETURN THE ATOM IN #15\n         SPACE 1\nRETSELF  DS    0H                  NULL STRING (OR NO UPPERCASE CHARS)\n         LR    #15,#3              RETURN THE STRING PASSED\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nEXTRT    TRT   0(*-*,#14),TRTTABLE EXECUTED: SCAN FOR UPPERCASE CHARS\nEXTR     TR    0(*-*,#14),TRTABLE  EXECUTED: TRANSLATE TO LOWERCASE\n         SPACE 1\nTRTTABLE DC    256X'00'            TABLE TO SCAN FOR UPPERCASE CHARS\n         ORG   TRTTABLE+C'A'\n         DC    9XL1'FF'\n         ORG   TRTTABLE+C'J'\n         DC    9XL1'FF'\n         ORG   TRTTABLE+C'S'\n         DC    8XL1'FF'\n         ORG   ,\n         SPACE 1\nTRTABLE  DC    256YL1(*-TRTABLE)   TABLE TO TRANSLATE TO LOWERCASE\n         ORG   TRTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   TRTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   TRTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG   ,\n         SPACE 1\nERROR1   #ERR  'Argument to STRING-DOWNCASE not a string - ',(#3)\n         SPACE 1\nERROR2   #ERR  PREFIX=NO,          NOT ENUF ROOM                       X\n               'ZIL4010 STRING-DOWNCASE: Not enough vector/string spaceX\n                to build string.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EBCDIC": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x009\\x006\\x008\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 57, "newlines": 54, "modlines": 56, "user": "SEB1525"}, "text": "         TITLE 'EBCDIC - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* EBCDIC TAKES TWO ARGUMENTS, OF WHICH THE SECOND IS OPTIONAL.        *\n* THE FIRST IS A FIXNUM TO BE CONVERTED TO A ONE-CHARACTER SYMBOL.    *\n* THE SECOND SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO INTERN THE   *\n*  GENERATED SYMBOL ON THE OBJECT LIST (NOTE DEFAULT IS NOT TO).      *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO EXTRA STACK SPACE.        *\n*                                                                     *\n* COMPARE MACLISP \"ASCII\".                                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nEBCDIC   #ZBEG MINARGS=1,MAXARGS=2,NAME='EBCDIC'\n         #ZPDS 2*4+12+0 = 20       DEFINE STACK SIZE\n         #ZSAV ARGS=2              SAVE REGISTERS\n         SPACE\n         L     #2,0(,#11)          GET ATOM (ARG 1 TO EBCDIC)\n         CLI   ##TYPE(#2),##FIXNUM MUST BE AN ATOM\n         BNE   ERROR1              OR ELSE\n*\n* GET THE NUMERIC VALUE OF THE FIXNUM.\n*\n         L     #15,##CDR(,#2)      GET FIXNUM CONTENTS\n         CL    #15,#SFW255         MUST BE 1-BYTE CHARACTER FIXNUM\n         BNH   CHAROK\n         #ERR  1,'Invalid argument to EBCDIC, substituting null - ',   X\n               (#2)\n         XR    #15,#15             IF BAD, CHANGE TO NULL\nCHAROK   DS    0H\n         STC   #15,EBWORK          STORE INTO WORK AREA\n*\n* BUILD A ONE-CHARACTER ATOM FROM IT.\n*\n         LA    #0,1                SET LENGTH = 1\n         LA    #1,EBWORK           POINT TO CHARACTER TO BE ATOMIZED\n         L     #2,4(,#11)          SET INTERN FLAG = ARG 2 TO EBCDIC\n         LR    #3,#10              SET FORMAT FLAG = NIL\n         L     #15,ZLCABLD         GET ADDRESS OF ZILABLD\n         LA    #4,20(,#11)         SET CURRENT STACK POINTER FOR CONS\n         #BASR #14,#15             CALL ZILABLD TO MAKE AN ATOM FROM IT\n*                                  (RETURNS ATOM IN #15)\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'Argument to EBCDIC not a fixnum - ',(#2)\n         SPACE 1\nEBWORK   DS    C\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ECHO": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00P\\x00M\\x00O\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 80, "newlines": 77, "modlines": 79, "user": "SEB1525"}, "text": "         TITLE 'ECHO - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ECHO SYNTAX IS AS FOLLOWS:                                          *\n*                                                                     *\n* (ECHO FILE1 &OPTIONAL FILE2 EVEN-IF-BOTH-FILES-ARE-TERMINAL-P)      *\n*                                                                     *\n* FILE1 MUST BE AN INPUT FILE.                                        *\n* FILE2 MUST BE AN OUTPUT FILE.                                       *\n*                                                                     *\n* IF FILE2 IS OMITTED, ECHO MODE IS TURNED OFF FOR FILE1.             *\n* OTHERWISE, FILE2 BECOMES THE ECHO FILE FOR FILE1.                   *\n*                                                                     *\n* IF THE THIRD ARG IS SUPPLIED AND NON-NIL, ECHOING IS ACTIVE EVEN    *\n* IF BOTH FILES HAPPEN TO BE ALLOCATED TO THE TERMINAL.  THE DEFAULT  *\n* IS FOR ECHOING TO BE DISABLED IF THE TERMINAL IS IN USE FOR BOTH.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nECHO     #ZBEG MINARGS=1,MAXARGS=3,NAME='ECHO'\n         #ZPDS 3*4+12+0            DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         #IFIL 1                   ARG 1 = INPUT FILE SPEC\n         LR    #6,#7               #6 = ADDRESS OF INPUT FILE BLOCK\n         SPACE 1\n         XR    #5,#5               CLEAR ADDRESS OF OUTPUT FILE BLOCK\n         C     #13,4(,#11)         IF ARG 2 WAS NOT SUPPLIED\n         BE    NOFILE2             THEN GO TO TURN ECHOING OFF\n         SPACE 1\n         #OFIL 2                   ARG 2 = OUTPUT FILE SPEC\n         LR    #5,#7               #5 = ADDRESS OF OUTPUT FILE BLOCK\n         SPACE 1\nNOFILE2  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FIRST OF ALL, IF FILE1 IS ALREADY BEING ECHOED, TURN OFF THE        *\n* CURRENT ECHOING MODE.                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DROP  #7\n         USING ZLFILBLK,#6         ADDRESS THE INPUT FILE BLOCK\n         SPACE 1\n         ICM   #4,15,ZLFECHO       IF FILE1 IS CURRENTLY BEING ECHOED\n         BZ    NOECHO1             THEN\n         LH    #0,ZLFECCNT-ZLFILBLK(,#4)\n         BCTR  #0,0                 DECREMENT ECHO FILE'S REFERENCE CT\n         STH   #0,ZLFECCNT-ZLFILBLK(,#4)\n*                                   (NOTE #5 = 0 BECAUSE NO FILE2)\n         ST    #5,ZLFECHO           CLEAR FILE1'S ECHO POINTER\nNOECHO1  DS    0H\n         LTR   #5,#5               IF THERE'S A FILE2 TO ECHO TO...\n         BZ    NOECHO2             THEN...\n         ST    #5,ZLFECHO           SET FILE1'S ECHO POINTER\n         LA    #0,1                 INCREMENT ECHO FILE'S REFERENCE CT\n         AH    #0,ZLFECCNT-ZLFILBLK(,#5)\n         STH   #0,ZLFECCNT-ZLFILBLK(,#5)\n         C     #13,8(,#11)         IF ARG3 IS NOT SUPPLIED\n         BE    NOETIO               OR\n         C     #10,8(,#11)           ARG3 IS NIL\n         BNE   ETIO                   THEN\nNOETIO   NI    ZLFFLAG2-ZLFILBLK(#5),255-ZLFETIO  TURN OFF ETIO FLAG\n         B     NOECHO2             ELSE\nETIO     OI    ZLFFLAG2-ZLFILBLK(#5),ZLFETIO  TURN ON ETIO FLAG\nNOECHO2  DS    0H\n         SPACE 1\n         LR    #15,#10             RETURN NIL (WHAT ELSE? T MAYBE?)\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENDP": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x15\\x8f\\x00\\x89\\x15\\x8f\\x17(\\x00(\\x00(\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-07T00:00:00", "modifydate": "1989-06-07T17:28:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "SEB1525"}, "text": "         TITLE 'ENDP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n* CLtL, p. 264:                                                       *\n*                                                                     *\n* \"The predicate ENDP is the recommended way to test for the end of a *\n* list.  It is false of conses, true of NIL, and an error for all     *\n* other arguments.\"                                                   *\n*                                                                     *\n***********************************************************************\n*\n         SPACE 1\nENDP     #ZBEG MINARGS=1,MAXARGS=1,NAME='ENDP'\n         SPACE 1\n         USING ENDP,#15\n         SPACE 1\n         L     #2,0(,#1)           Get argument 1\n         CR    #2,#10              If equal to NIL\n         BE    TRUE                then return T\n         TM    ##TYPE(#2),##ATOM   If atomic (not CONSP)\n         BO    ERROR               then error\n         DROP  #15\nFALSE    LR    #15,#10             Else return FALSE\n         BR    #14\nTRUE     LR    #15,#8\n         BR    #14\n         SPACE 1\nERROR    DS    0H\n         LR    #3,#15\n         USING ENDP,#3\n         #ERR  'Argument to ENDP not a list - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQ": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'EQ - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nEQ       #ZBEG MINARGS=2,MAXARGS=2,NAME='EQ'\n         SPACE 1\n         USING EQ,#15\n         SPACE 1\n         LM    #2,#3,0(#1)\n         CR    #2,#3\n         BNE   ZXEQN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXEQN    LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EQL": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00{\\x00x\\x00z\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 123, "newlines": 120, "modlines": 122, "user": "SEB1525"}, "text": "         TITLE 'EQL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  EQL IS LIKE EQUALP, BUT THE TYPES MUST MATCH.                      *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: SYMBOLS ARE EQL ONLY IF THEY ARE EQ, ACCORDING TO COMMON LISP *\n*       EQL.  IF SYMBOLS ARE TO BE CONSIDERED EQL IF THEIR PNAMES ARE *\n*       STRING-EQUAL, THEN DECOMMENT THE LINES MARKED *$$$$$$$.       *\n*                                                                     *\n* NOTE: STRINGS ARE EQL IF THEIR TEXTS ARE IDENTICAL, INCLUDING CASE. *\n*       FOR TRUE COMMON LISP THE CODE THAT COMPARES STRINGS SHOULD BE *\n*       REMOVED, SINCE STRINGS ARE NOT EQL UNLESS THEY ARE EQ.        *\n*                                                                     *\n*       THE PHILOSOPHY IS THAT IN ZIL PRIOR TO 1.3, STRINGS ARE       *\n*       UNMODIFIABLE OBJECTS, AND THEREFORE CAN BE COMPARED BY EQL.   *\n*       IF STRINGS CAN BE UPDATED, EQL IS NOT A VALID TEST.           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\nEQL      #ZBEG MINARGS=2,MAXARGS=2,NAME='EQL'\n         SPACE\n         USING EQL,#15\n         SPACE\n         LM    #1,#2,0(#1)         LOAD ARGUMENTS\n         CR    #1,#2               IF ARGS ARE \"EQ\"\n         BE    TRUE                THEN RETURN T\n*\n* CHECK THAT THE TYPES MATCH\n*\n         CLC   ##TYPE(1,#1),##TYPE(#2)\n         BNE   FALSE               IF TYPES DO NOT MATCH, NOT EQL.\n*\n* CHECK TYPE OF ARGS\n*\n         CLI   ##TYPE(#1),##FIXNUM FIXNUM COMPARE\n         BE    COMPFIX\n         CLI   ##TYPE(#1),##SFLOAT SINGLE-FLOAT COMPARE\n         BE    COMPSFLO\n*\n*--- DELETE THIS CODE FOR TRUE COMMON LISPNESS\n*\n         CLI   ##TYPE(#1),##STRING STRING COMPARE\n         BE    COMPSTR\n*$$$$$$$ CLI   ##TYPE(#1),##SYMBOL SYMBOL COMPARE\n*$$$$$$$ BE    COMPSYM\n*\n*--- END OF CODE TO BE DELETED\n*\n         CLI   ##TYPE(#1),##BIGNUM BIGNUM COMPARE LIKE STRING COMPARE\n         BE    COMPBIG\n         CLI   ##TYPE(#1),##DFLOAT DOUBLE-FLOAT COMPARE\n         BE    COMPDFLO\nFALSE    DS    0H                  ALL OTHER TYPES ARE EQL ONLY IF EQ\n         LR    #15,#10             THEREFORE RETURN NIL (FALSE)\n         BR    #14\n         SPACE\n         DROP  #15                 NO BASE REG ALLOWED AFTER THIS POINT\n         EJECT\nCOMPFIX  DS    0H                  ARG 1 IS FIXED OR LOGICAL\n         SPACE\n         L     #0,##CDR(,#1)       GET FIXED VALUE 1\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         C     #0,##CDR(,#2)       COMPARE FIXED VALUE 2\n         BNER  #14                 RETURN NIL IF FALSE\nTRUE     DS    0H                  ALL OTHER TYPES ARE EQL ONLY IF EQ\n         LR    #15,#8              ELSE RETURN T (TRUE)\n         BR    #14\n         EJECT\nCOMPSFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n         LE    #F0,##CDR(,#1)      GET FLOAT VALUE 1\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         CE    #F0,##CDR(,#2)      COMPARE FLOAT VALUE 2\n         BNER  #14                 RETURN NIL IF FALSE\n         LR    #15,#8              ELSE RETURN T (TRUE)\n         BR    #14\n         EJECT\nCOMPDFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F0,8(,#1)          GET FLOAT VALUE 1\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         CD    #F0,8(,#2)          COMPARE FLOAT VALUE 2\n         BNER  #14                 RETURN NIL IF FALSE\n         LR    #15,#8              ELSE RETURN T (TRUE)\n         BR    #14\n         EJECT\nCOMPSYM  DS    0H                  SYMBOL-TO-SYMBOL COMPARE\n*$$$$$$$ L     #1,##PNAME(,#1)     GET SYMBOL PRINT NAME 1\n*$$$$$$$ L     #2,##PNAME(,#2)     GET SYMBOL PRINT NAME 2\n******** B     COMPSTR             GO TO DO STRING-TO-STRING COMPARE\n         SPACE 2\n*\n* NOTE: DELETE THE \"COMPSTR\" LABEL FOR COMMON LISP\n*\nCOMPSTR  DS    0H                  STRING-TO-STRING COMPARE\nCOMPBIG  DS    0H                  BIGNUM-TO-BIGNUM COMPARE\n         SPACE 1\n         L     #5,0(,#1)           GET STRING HEADER 1\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         CL    #5,0(,#2)           TYPE AND LENGTH MUST MATCH\n         BNER  #14                 RETURN NIL (FALSE) IF THEY DON'T\n         SLL   #5,8                ERASE TYPE BITS FROM HEADER\n         SRL   #5,8                GET STRING LENGTH 1\n         LA    #4,##VECDAT(,#1)    POINT TO STRING TEXT 1\n         LA    #6,##VECDAT(,#2)    POINT TO STRING TEXT 2\n         LR    #7,#5               GET STRING LENGTH 2\n         CLCL  #4,#6               DO COMPARE\n         BNER  #14                 RETURN NIL (FALSE) IF NOT EQUAL\n         LR    #15,#8              ELSE RETURN T (TRUE)\n         BR    #14\n         SPACE\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EVENP": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x15\\x00#\\x00 \\x00\"\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:15:14", "lines": 35, "newlines": 32, "modlines": 34, "user": "SEB1525"}, "text": "         TITLE 'EVENP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* EVENP TAKES ONE ARGUMENT - AN INTEGER                               *\n*                                                                     *\n***********************************************************************\nEVENP    #ZBEG MINARGS=1,MAXARGS=1,NAME='EVENP'\n         SPACE\n         USING EVENP,#15\n         SPACE\n         L     #2,0(,#1)           LOAD FIRST (AND ONLY) ARGUMENT\n         TM    ##TYPE(#2),##INT    MUST BE INTEGER (FIXNUM OR BIGNUM)\n         BNO   ERROR\n         TM    ##CDR+3(#2),X'01'   TEST FOR EVEN\n         BO    FALSE               FALSE IF ODD\nTRUE     DS    0H\n         LR    #15,#8              TRUE... SET RESULT TO T\n         BR    #14\nFALSE    DS    0H\n         LR    #15,#10             FALSE... SET RESULT TO NIL\n         BR    #14\n         SPACE\nERROR    DS    0H                  NOT A NUMERIC ATOM\n         LR    #3,#15\n         DROP  #15\n         USING EVENP,#3\n         #ERR  'Argument to EVENP not an integer - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXIT": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00&\\x00#\\x00%\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 38, "newlines": 35, "modlines": 37, "user": "SEB1525"}, "text": "         TITLE 'EXIT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* EXIT TAKES ONE (OPTIONAL) ARGUMENT - RETURN CODE SPEC.              *\n*                                                                     *\n* IT GETS THE RETURN ADDRESS TO \"ZILMAIN\" CODE FROM THE BOTTOM OF     *\n* THE PUSH-DOWN STACK AND RETURNS TO THERE.  IF THE OPTIONAL OPERAND  *\n* IS SPECIFIED (NON-NIL) IT IS ASSUMED TO BE A FIXNUM AND THE VALUE   *\n* IS PICKED UP THEREFROM AND INSERTED INTO THE RETURN CODE FIELD.     *\n*                                                                     *\n***********************************************************************\nEXIT     #ZBEG MINARGS=0,MAXARGS=1,NAME='EXIT'\n         SPACE\n         L     #1,0(,#1)           GET ARGUMENT 1\n         CR    #1,#10              IF NOT NIL\n         BE    NOSETRC-EXIT(,#15)   AND\n         CR    #1,#13                NOT OMITTED\n         BE    NOSETRC-EXIT(,#15)     THEN...\n*\n* DON'T BOTHER CHECKING TYPE - WE GOTTA RETURN ANYHOW\n*\n         L     #1,##CDR(,#1)        GET FIXNUM VALUE ITSELF\n         ST    #1,ZLCRETCD          STORE INTO RETURN CODE VALUE\nNOSETRC  DS    0H                  OTHERWISE USE RETURN CODE AS IS\n         LR    #15,#10             SET RETURN VALUE (IRRELEVANT)\n         L     #1,ZLCPDADR         GET BOTTOM-OF-STACK ADDRESS\n         LM    #11,#12,0(#1)       RESTORE STACK AND BASE REGISTERS\n         L     #14,8(,#1)          RESTORE RETURN REGISTER\n         BR    #14                 RETURN TO MAINLINE\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIRSTN": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00Q\\x00N\\x00P\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 81, "newlines": 78, "modlines": 80, "user": "SEB1525"}, "text": "         TITLE 'FIRSTN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (FIRSTN 3 '(A B C D E))  ==> (A B C)                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note: This implementation of FIRSTN exists for Macsyma only.  It    *\n*       does not work for negative arguments, and also does not work  *\n*       exactly as the LISPM version does, in that it does not pad    *\n*       the resultant list out with NILs.  It works the way the       *\n*       PDP10/Franz definition in Macsyma's UTILS file does.          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFIRSTN   #ZBEG MINARGS=2,MAXARGS=2,NAME='FIRSTN'\n         SPACE 1\n         #ZPDS 2*4+12+4\n         #ZSAV ARGS=2\n         SPACE 1\n         LM    #3,#4,0(#11)        LOAD THE ARGUMENTS\n         SPACE 1\n         CLI   ##TYPE(#3),##FIXNUM ARG 1 MUST BE A FIXNUM\n         BNE   ERROR1              ELSE ERROR\n         L     #3,##CDR(,#3)       LOAD FIXNUM VALUE OF ARG 1\n         SPACE 1\n         CR    #4,#10              IF LIST IS NIL,\n         BE    RETNIL              THEN RETURN NIL\n         LTR   #3,#3               CHECK SIGN OF COUNT\n         BZ    RETNIL              IF ZERO, RETURN NIL\n         BM    ERROR1              IF NEGATIVE, WELL...\nARG1NN   DS    0H                  IF POSITIVE, PROCEED\n         LR    #6,#10              INITIALIZE RESULT TO NIL\n         LA    #0,24(,#11)         SET CURRENT STACK POINTER FOR CONS\n         SPACE 1\nLOOP     DS    0H\n         TM    ##TYPE(#4),##ATOM   IF (SUB)LIST NOT A LIST\n         BO    ERROR2              THEN ERROR\nINLOOP   DS    0H\n         L     #1,##CAR(,#4)       GET CAR OF (SUB)LIST\n         LR    #2,#10              GET NIL\n         L     #15,ZLCCONS         CALL CONS TO BUILD A PIECE OF THE\n         #BASR #14,#15              RESULT LIST\n         CR    #6,#10              IF NO RESULT YET,\n         BNE   BASHEND             THEN...\n         LR    #6,#15               START IT NOW FROM THIS PIECE\n         ST    #6,20(,#11)          SAVE ON STACK FOR POSSIBLE GC'ING\n         B     AFTBASH             ELSE...\nBASHEND  ST    #15,##CDR(,#5)       BASH LAST CONS OF RESULT LIST\nAFTBASH  LR    #5,#15              SET POINTER TO LAST CONS IN RESULT\n         BCT   #3,CONTINUE         DECREMENT COUNT\nRETIT    LR    #15,#6              IF ZERO, RETURN RESULT LIST SO FAR\n         B     RETURN              ELSE...\nCONTINUE DS    0H\n         L     #4,##CDR(,#4)       GO DOWN LIST\n         CR    #4,#10              IF END NOT REACHED YET\n         BNE   LOOP                THEN CONTINUE\n         LR    #15,#6              ELSE RETURN THE RESULT LIST\n         B     RETURN\n         SPACE 1\nRETNIL   LR    #15,#10             RETURN NIL\n         SPACE 1\nRETURN   DS    0H                  #15 CONTAINS RETURN VALUE\n         SPACE 1\n         #ZRET ,                   RETURN TO CALLER\n         SPACE 3\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         #ERR  'Argument 1 to FIRSTN not a nonnegative fixnum - ',     X\n               0(#11)\n         SPACE 1\nERROR2   DS    0H                  ERROR IN ARGUMENT\n         #ERR  'Argument 2 to FIRSTN not a proper list - ',            X\n               4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIXNUMP": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x114\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:34:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'FIXNUMP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFIXNUMP  #ZBEG MINARGS=1,MAXARGS=1,NAME='FIXNUMP'\n         SPACE 1\n         USING FIXNUMP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##FIXNUM\n         BNE   ZXFIXN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXFIXN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLOAT": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x115\\x00\\xa6\\x00\\xa3\\x00\\xa5\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:35:00", "lines": 166, "newlines": 163, "modlines": 165, "user": "SEB1525"}, "text": "         TITLE 'FLOAT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* FLOAT TAKES ONE REQUIRED ARGUMENT, A NUMERIC ATOM, AND ONE          *\n* OPTIONAL ARGUMENT, AN OBJECT WHOSE TYPE IS THE TYPE OF FLOAT        *\n* TO CONVERT TO.                                                      *\n*                                                                     *\n***********************************************************************\nFLOAT    #ZBEG MINARGS=1,MAXARGS=2,NAME='FLOAT'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n***********************************************************************\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS:                                    *\n*                                                                     *\n* 1. ARG INTEGER             - CONVERT TO FLOAT AND RETURN.           *\n* 2. ARG FLOAT               - RETURN FLONUM ITSELF.                  *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\n         L     #15,0(,#11)         LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#15),##FIXNUM\n         BE    CONVERT             IF FIXP, CONVERT IT AND RETURN\n         CLI   ##TYPE(#15),##SFLOAT\n         BE    SCONVERT            IF SINGLE-FLOAT, MAYBE CONVERT\n         CLI   ##TYPE(#15),##DFLOAT\n         BE    DCONVERT            IF DOUBLE-FLOAT, MAYBE CONVERT\n         CLI   ##TYPE(#15),##BIGNUM\n         BE    BCONVERT            IF BIGP, CONVERT IT AND RETURN\n         B     ERROR1\n         SPACE 1\nCONVERT  DS    0H                  MAKE A FLONUM FROM FIXED OR LOGICAL\n         SPACE 1\n         L     #1,4(,#11)          Get argument 2\n         CR    #1,#13              If arg 2 unsupplied\n         BE    CID                 then convert integer to double float\n         CR    #1,#10              If arg 2 NIL\n         BE    CID                 then convert integer to double float\n         CLI   ##TYPE(#1),##SFLOAT If arg 2 single-float\n         BE    CIS                 then convert integer to single float\n         CLI   ##TYPE(#1),##DFLOAT If arg 2 double-float\n         BE    CID                 then convert integer to double float\n         B     ERROR2              Else error\n         SPACE 1\nCIS      DS    0H                  Convert fixnum to single float\n         SPACE 1\n         L     #0,##CDR(,#15)      GET FIXED VALUE\n         #BAS  #14,FIX2FLO         CONVERT FROM FIXED TO FLOAT\n         STE   #F0,ZLCWORK         STORE IT\n         L     #2,ZLCWORK          PICK IT UP\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM ATOM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nCID      DS    0H                  Convert fixnum to double float\n         SPACE 1\n         L     #0,##CDR(,#15)      Get fixed value\n         #BAS  #14,FIX2FLO         Convert from fixed to float\n         LA    #0,20(,#11)         Set stack pointer for CONS\n         B     CDFLOAT             Go to cons up a double float\n         SPACE 1\nSCONVERT DS    0H                  Single-float\n         SPACE 1\n         L     #1,4(,#11)          Get argument 2\n         CR    #1,#13              If arg 2 unsupplied\n         BE    RETURN              then return single float as is\n         CR    #1,#10              If arg 2 NIL\n         BE    RETURN              then return single float as is\n         CLI   ##TYPE(#1),##SFLOAT If arg 2 single-float\n         BE    RETURN              then return single float as is\n         CLI   ##TYPE(#1),##DFLOAT If arg 2 double-float\n         BE    CSD                 then convert single to double\n         B     ERROR2              Else error\n         SPACE 1\nDCONVERT DS    0H                  Double-float\n         SPACE 1\n         L     #1,4(,#11)          Get argument 2\n         CR    #1,#13              If arg 2 unsupplied\n         BE    RETURN              then return double float as is\n         CR    #1,#10              If arg 2 NIL\n         BE    RETURN              then return double float as is\n         CLI   ##TYPE(#1),##SFLOAT If arg 2 single-float\n         BE    CDS                 then convert double to single\n         CLI   ##TYPE(#1),##DFLOAT If arg 2 double-float\n         BE    RETURN              then return double float as is\n         B     ERROR2              Else error\n         EJECT\nCSD      DS    0H                  Convert single to double\n         SPACE 1\n         SDR   #F0,#F0             Clear FPR\n         LE    #F0,##CDR(,#15)     Load single-float from arg 1\n         LA    #0,20(,#11)         Set stack location for CONS\n         SPACE 1\nCDFLOAT  DS    0H                  #F0 = value, build a double-float\n         SPACE 1\n         L     #15,ZLCMDF          Get address of ZILMDF\n         #BASR #14,#15             Call ZILMDF to build double float\n         B     RETURN              Return with double float\n         EJECT\nCDS      DS    0H                  Convert double to single\n         SPACE 1\n         LD    #F0,8(,#15)         Load double-float from arg 1\n         LRER  #F0,#F0             Convert to single while rounding\n         STE   #F0,ZLCWORK         Store in temp area\n         L     #2,ZLCWORK          Load into GPR\n         #MKAT FLOAT               Cons up a single-float\n         B     RETURN              Return with it\n         EJECT\nBCONVERT DS    0H                  Bignum-to-float conversion\n         SPACE 1\n         L     #1,4(,#11)          Get argument 2\n         CR    #1,#13              If arg 2 unsupplied\n         BE    CBD                 then convert integer to double float\n         CR    #1,#10              If arg 2 NIL\n         BE    CBD                 then convert integer to double float\n         CLI   ##TYPE(#1),##SFLOAT If arg 2 single-float\n         BE    CBS                 then convert integer to single float\n         CLI   ##TYPE(#1),##DFLOAT If arg 2 double-float\n         BE    CBD                 then convert integer to double float\n         B     ERROR2              Else error\n         SPACE 1\nCBS      DS    0H                  Convert bignum to single float\n         SPACE 1\n         LR    #5,#15              Get address of bignum to convert\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         #BASR #14,#15             Call ZILCVBF to convert to float\n         STE   #F0,ZLCWORK         Store flonum value result\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         L     #2,ZLCWORK          Get flonum value in register\n         #MKAT FLOAT               Make a single-precision flonum\n         B     RETURN\n         SPACE 1\nCBD      DS    0H                  Convert bignum to double float\n         LCR   #5,#15              Get address of bignum to convert\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         #BASR #14,#15             Call ZILCVBF to convert to float\n         L     #15,ZLCMDF          Get address of ZILMDF\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             Call ZILMDF to make a double float\n         B     RETURN\n         SPACE 1\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         EJECT\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION ROUTINE\n         EJECT\nERROR1   DS    0H                  NOT A NUMERIC ATOM\n         #ERR  'Argument 1 to FLOAT not a number - ',0(#11)\n         SPACE 1\nERROR2   DS    0H                  NOT A NUMERIC ATOM\n         #ERR  'Argument 2 to FLOAT not a flonum - ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLOATP": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x115\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:35:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'FLOATP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFLOATP   #ZBEG MINARGS=1,MAXARGS=1,NAME='FLOATP'\n         SPACE 1\n         USING FLOATP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##FLONUM\n         BNO   ZXFLON\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXFLON   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FUNARGP": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x115\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:35:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'FUNARGP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFUNARGP #ZBEG  MINARGS=1,MAXARGS=1,NAME='FUNARGP'\n         SPACE 1\n         USING FUNARGP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##FUNARG\n         BNE   ZXFUNN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXFUNN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FUNENV": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x06\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x16\\x00\\x1f\\x00\\x1e\\x00\\x1e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:16:06", "lines": 31, "newlines": 30, "modlines": 30, "user": "SEB1525"}, "text": "         TITLE 'FUNENV - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS RETURNS THE ENVIRONMENT COMPONENT OF AN INTERPRETED LEXICAL    *\n* CLOSURE (FUNARG).  IT OBSOLETES \"FUNCDR\".                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFUNENV   #ZBEG MINARGS=1,MAXARGS=1,NAME='FUNENV'\n         SPACE 1\n         USING FUNENV,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##FUNARG\n         BNE   FCERROR\n         L     #15,##VECDAT+4(,#2)\n         BR    #14\n         SPACE 1\nFCERROR  DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING FUNENV,#3\n         #ERR  'Argument to FUNENV not an interpreted lexical closure (X\n               \"FUNARG\") - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FUNFUN": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00$\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x16\\x00\\x1f\\x00\\x1e\\x00\\x1e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:16:24", "lines": 31, "newlines": 30, "modlines": 30, "user": "SEB1525"}, "text": "         TITLE 'FUNFUN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS RETURNS THE FUNCTION COMPONENT OF AN INTERPRETED LEXICAL       *\n* CLOSURE (FUNARG).  IT OBSOLETES \"FUNCAR\".                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFUNFUN   #ZBEG MINARGS=1,MAXARGS=1,NAME='FUNFUN'\n         SPACE 1\n         USING FUNFUN,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##FUNARG\n         BNE   FCERROR\n         L     #15,##VECDAT+0(,#2)\n         BR    #14\n         SPACE 1\nFCERROR  DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING FUNFUN,#3\n         #ERR  'Argument to FUNFUN not an interpreted lexical closure (X\n               \"FUNARG\") - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GC": {"ttr": 1810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x115\\x00$\\x00!\\x00#\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:35:00", "lines": 36, "newlines": 33, "modlines": 35, "user": "SEB1525"}, "text": "         TITLE 'GC - ZIL 1.3 FUNCTION TO FORCE A GARBAGE COLLECTION'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION FORCES A GARBAGE COLLECTION BY DESTROYING THE FREE    *\n* LIST POINTER AND THEN DOING A CONS.  THERE ARE NO ARGUMENTS.        *\n*                                                                     *\n* CURRENTLY A DUMMY CONS OF TWO NILS... (NIL) ...IS RETURNED.         *\n*                                                                     *\n* NOTE THAT THE FORMAT OF THE FREE LIST VARIES DEPENDING ON           *\n* WHETHER A GARBAGE COLLECTION HAS OCCURRED YET.  SEE ZILCONS         *\n* FOR MORE DETAILS.                                                   *\n*                                                                     *\n***********************************************************************\nGC       #ZBEG MINARGS=0,MAXARGS=0,NAME='GC'\n         #ZPDS 12                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #9,ZLCGCEND         FORCE END OF FREE LIST\n*\n* NOW DO SOME DUMMY CONS TO FORCE A GARBAGE COLLECTION TO OCCUR.\n*\n         LR    #1,#10              SET CONS ARG 1 TO NIL (CAR-TO-BE)\n         LR    #2,#10              SET CONS ARG 2 TO NIL (CDR-TO-BE)\n         L     #15,ZLCCONS         CALL CONS TO...\n         LA    #0,12(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15              FORCE A GARBAGE COLLECTION\n*                                  RETURN WITH VALUE IN REG 15\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCMSG": {"ttr": 1812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00A\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x16\\x00*\\x00'\\x00)\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:16:41", "lines": 42, "newlines": 39, "modlines": 41, "user": "SEB1525"}, "text": "         TITLE 'GCMSG - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GCMSG TAKES ONE OPTIONAL ARGUMENT - NIL OR NON-NIL.                 *\n*                                                                     *\n* IF THE ARG IS OMITTED, T OR NIL IS RETURNED, TELLING WHETHER OR     *\n* NOT GC MESSAGES ARE CURRENTLY ENABLED.                              *\n* IF THE ARG IS NIL, GC MESSAGES ARE SUPPRESSED;                      *\n* OTHERWISE, GC MESSAGES ARE ENABLED.                                 *\n*                                                                     *\n***********************************************************************\n         SPACE\nGCMSG    #ZBEG MINARGS=0,MAXARGS=1,NAME='GCMSG'\n         SPACE\n         LR    #3,#15\n         DROP  #15\n         USING GCMSG,#3\n         L     #15,0(,#1)          PICK UP ARG 1\n         CR    #15,#13             IF ARG IS OMITTED\n         BE    GCMSGQ              THEN QUERY CURRENT GCMSG SETTING\n         CR    #15,#10             IF ARG IS NIL\n         BNE   GCMSGT              THEN...\n         NI    ZLCGCFLG,255-ZLCGCMSG  SET GC MESSAGES OFF\n         BR    #14                  RETURN FALSE\nGCMSGT   DS    0H                  ELSE...\n         OI    ZLCGCFLG,ZLCGCMSG    SET GC MESSAGES ON\n         LR    #15,#8               RETURN TRUE\n         BR    #14\n         SPACE 1\nGCMSGQ   DS    0H\n         TM    ZLCGCFLG,ZLCGCMSG   IF GC MESSAGES ARE ENABLED\n         BO    TRUE                THEN RETURN T (TRUE)\n         LR    #15,#10             ELSE RETURN NIL (FALSE)\n         BR    #14\nTRUE     LR    #15,#8\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCTIME": {"ttr": 1814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x116\\x00\\x13\\x00\\x10\\x00\\x12\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:36:00", "lines": 19, "newlines": 16, "modlines": 18, "user": "SEB1525"}, "text": "         TITLE 'GCTIME - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nGCTIME   #ZBEG MINARGS=0,MAXARGS=0,NAME='GCTIME'\n         #ZPDS 12                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #2,ZLCGCTIM         GET TOTAL GC CPU TIME SO FAR\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         #ZRET ,                   RETURN WITH IT\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GENSYM": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x116\\x00\\xc6\\x00\\xb9\\x00\\xc5\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:36:00", "lines": 198, "newlines": 185, "modlines": 197, "user": "SEB1525"}, "text": "         TITLE 'GENSYM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GENSYM TAKES 1 OPTIONAL ARGUMENT.                                   *\n*                                                                     *\n* The following description is based on the one in CLtL, page 169,    *\n* 1st edition:                                                        *\n*                                                                     *\n* GENSYM creates a new, unique, uninterned symbol, consisting of a    *\n* prefix (which defaults to \"G\") followed by a decimally dumped       *\n* number, which is incremented by 1 each time GENSYM is called.       *\n*                                                                     *\n* If the optional argument is present, then:                          *\n*                                                                     *\n*   If it is an integer, then it must be non-negative, and the        *\n* internal GENSYM counter is set to that value for FUTURE use         *\n* rather than having it be incremented the normal way.                *\n*                                                                     *\n*   If it is a string, then that string is made the default GENSYM    *\n* prefix for THIS and FUTURE calls to GENSYM.                         *\n*                                                                     *\n* After handling the argument, GENSYM creates a symbol as it would    *\n* with no argument.  This means that if the optional argument is      *\n* present and is an integer, then that value becomes part of the      *\n* GENSYM name.                                                        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* For this implementation:                                            *\n*                                                                     *\n*  (1) It is illegal for the argument to be a bignum.  Sorry.         *\n*      Maybe some other day.                                          *\n*  (2) If the argument is a symbol, the print name is used as if      *\n*      a string were passed.                                          *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 05/22/89 - Set package cell to NIL.                                 *\n*                                                                     *\n***********************************************************************\n*\nGENSYM   #ZBEG MINARGS=0,MAXARGS=1,NAME='GENSYM'\n         SPACE 1\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #1,0(,#11)          Get arg 1\n         CR    #1,#13              If arg 1 is omitted,\n         BE    INCR                then go increment counter\n         CLI   ##TYPE(#1),##FIXNUM If arg 1 is a fixnum\n         BE    ARG1FIX             then go process integer arg1\n         CLI   ##TYPE(#1),##STRING If arg 1 is a string\n         BE    ARG1STR             then go process string arg1\n         CLI   ##TYPE(#1),##SYMBOL If arg 1 is a symbol\n         BE    ARG1SYM             then go process symbol arg1\n         B     ERROR1              Else invalid type for arg1\n         SPACE 1\nARG1FIX  DS    0H                  Arg 1 is a fixnum\n         ICM   #2,15,##CDR(#1)     Get fixnum value\n         BM    ERROR1              If negative, error\n         ST    #2,ZLCGSCNT         Store as new GENSYM counter\n         B     AFTINCR             Skip normal increment and go\n         SPACE 1\nARG1SYM  DS    0H                  Arg 1 is a symbol\n         L     #1,##PNAME(,#1)     Get print name and use as string\nARG1STR  DS    0H                  Arg 1 is a string\n         ST    #1,ZLCGSPRE         Store GENSYM prefix\n******** B     INCR                Go to increment GENSYM counter\n         SPACE 1\nINCR     DS    0H                  OK, increment the counter\n         LA    #2,1                Add 1 to GENSYM counter\n         A     #2,ZLCGSCNT\n         ST    #2,ZLCGSCNT\n         SPACE 1\nAFTINCR  DS    0H                  GENSYM counter updated whatever way\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Compute length of integer and length of prefix                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n* Get length of integer\n         MVC   GWORK(12),=X'F02020202020202120202020'\n         LA    #1,GWORK+7          Initialize EDMK pattern and register\n         CVD   #2,ZLCDBL           Convert incremented GENSYM counter\n         EDMK  GWORK(12),ZLCDBL+2  Edit decimal counter into pattern\n* Never allowed to be negative.  Don't even bother to check.\n         LA    #5,GWORK+12         Compute length of significant part\n         SR    #5,#1               Length of converted integer\n         LR    #6,#1               Get address of converted integer\n* Get length of prefix\n         ICM   #1,15,ZLCGSPRE      Get GENSYM prefix string\n         BZ    NOPREFIX            If there is one, then...\n         LA    #7,##VECDAT(,#1)     get address of prefix string\n         XR    #4,#4                clear insert register\n         ICM   #4,7,1(#1)           get length of GENSYM prefix\n         B     AFTPREFX            else\nNOPREFIX DS    0H                   ... no GENSYM prefix in use...\n         LA    #4,1                 get length of default GENSYM prefix\n         XR    #7,#7                clear address of GENSYM prefix\nAFTPREFX DS    0H\n*                                  #4 = length of prefix\n*                                  #7 = address of prefix\n*                                  #5 = length of converted integer\n*                                  #6 = address of converted integer\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Get storage for the entire GENSYM in one swoop. This consists of    *\n*                                                                     *\n* (1) storage for the symbol header - ##SYMLEN bytes                  *\n* (2) storage for the print name of the GENSYM, consisting of...      *\n*                                                                     *\n*     ##VECDAT + length of prefix + length of converted counter       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nREPEAT   DS    0H                  Back here in case GC was required\n         SPACE 1\n         LA    #14,3+##SYMLEN+##VECDAT(#4,#5)\n         N     #14,=X'FFFFFFFC'    Round up to fullword\n         SPACE 1\n******** L     #1,ZLCVSADR         Get address of vector/string space\n******** L     #2,ZLCVSLEN         Get length of vector/string space\n******** L     #3,ZLCVSNXT         Get address of next available slot\n         LM    #1,#3,ZLCVSADR      Get all of the above\n         AR    #14,#3              Next slot + needed length = new end\n         AR    #1,#2               Get address of end of V/S space\n         CR    #14,#1              If out of room\n         BH    NOROOM              then go try to get some more\n         LR    #0,#4               Get length of prefix string into #0\n         LR    #4,#14              Get end-pointer-to-be\n         MVC   0(##SYMLEN,#3),ZLCNSYM Init from new symbol template\n         LA    #14,##SYMLEN(,#3)   PNAME = other part of space\n         ST    #14,##PNAME(,#3)    Store into print name cell\n* Package cell remains \"uninterned\"\n         ST    #10,##PPKG(,#3)     Set package cell to NIL\n         LR    #14,#0              Get prefix string length\n         AR    #14,#5              Add integer length\n         ST    #14,##SYMLEN+0(,#3) Store print name string length\n         MVI   ##SYMLEN+0(#3),##STRING Set print name string type\n         LR    #15,#0              Destination length of prefix string\n         LTR   #0,#7               Source address of GENSYM prefix\n         BNZ   MVCLPRFX            If zero, then\n         MVI   ##SYMLEN+##VECDAT(#3),C'G'  set default prefix\n         LA    #14,##SYMLEN+##VECDAT+1(,#3)\n         B     AFTMPRFX            else\nMVCLPRFX DS    0H                   use user-set prefix\n         LR    #1,#15               Source length of GENSYM prefix\n         LA    #14,##SYMLEN+##VECDAT(,#3) Dest addr in string area\n         MVCL  #14,#0               Move prefix text to string area\nAFTMPRFX DS    0H\n* Now #14 points to where to put the rest of the text.\n         BCTR  #5,0                Adjust length of suffix for EX\n         EX    #5,MOVEINT          Move converted integer to string\n         ST    #4,ZLCVSNXT         Update next-slot VSS pointer\n         LR    #15,#3              Point to newly built GENSYM\n         SPACE 1\nRETURN   DS    0H                  RETURN WITH NEW ATOM <-- REG 15\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nMOVEINT  MVC   0(*-*,#14),0(#6)    Executed: move converted integer suf\n         SPACE 1\nGWORK    DS    CL12                Work area for converting counter\n         SPACE 1\nNOROOM   DS    0H                  WHAT IF THERE'S NO STRING SPACE?\n         LTR   #0,#0               IF THIS IS THE SECOND ATTEMPT\n         BZ    ERROR               THEN FAIL - SPACE ALL FULL\n         L     #9,ZLCGCEND         FORCE END OF FREE LIST\n         LR    #1,#10              SET DUMMY ARG 1 TO CONS = NIL\n         LR    #2,#10              SET DUMMY ARG 2 TO CONS = NIL\n*                                  #0 ALREADY POINTS TO CUR STACK LOC\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS:FORCE A GARBAGE COLLECTION\n         XR    #0,#0               CLEAR #0 TO PREVENT ANOTHER GC\n         B     REPEAT              AND TRY IT AGAIN\n         SPACE\nERROR1   DS    0H\n         #ERR  'Argument 1 to GENSYM not a string or nonnegative fixnumX\n                - ',0(#11)\n         SPACE\nERROR    DS    0H\n         #ERR  'ZIL2025 No string space available to create GENSYM.',  X\n               PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GET": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00X\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x16\\x00f\\x00c\\x00e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:16:58", "lines": 102, "newlines": 99, "modlines": 101, "user": "SEB1525"}, "text": "         TITLE 'GET - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GET TAKES TWO REQUIRED AND ONE OPTIONAL ARGUMENT.                   *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND THEREFORE USES NO STACK SPACE.     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* There should be related functions, like GETF, that do similar       *\n* things, as well as \"optimized-call-path\" ones that remove the       *\n* requirement to check argument type or inspect default value.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nGET      #ZBEG MINARGS=2,MAXARGS=3,NAME='GET'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING GET,#3\n         SPACE 1\n         LM    #5,#7,0(#1)         LOAD THE ARGUMENTS\n         CLI   ##TYPE(#5),##SYMBOL ARG 1 MUST BE A SYMBOL\n         BNE   NOTSYM\n         L     #15,##PLIST(,#5)    GET PROPERTY LIST POINTER\nPROCESS  DS    0H\n* Initial loop-bypassing test for null property list\n         CR    #15,#10             IF END OF PROPERTY LIST (NULL)\n         BE    NOTFOUND            THEN RETURN NO-PROPERTY-FOUND VALUE\n         SPACE 1\nLOOP     DS    0H\n         LM    #1,#2,##CAR(#15)    GET CAR AND CDR OF NEXT CELL\n*                                  #1 = CAR, #2 = CDR\n         CR    #6,#1               IF (CAR SUBPLIST) IS \"EQ\" TO ARG 2\n         BE    FOUND               THEN PROPERTY FOUND, GO GET VALUE\n*\n* If #15 didn't point to a CONS cell, then the high-order bit of #1\n* will be one, since it was an \"atom\" type bit.\n*\n         LTR   #1,#1               IF PROPERTY (SUB)LIST ATOMIC\n         BM    ERROR2              THEN ERROR\n*                                  ELSE NOT THE ONE - CONTINUE\n         L     #15,##CDR(,#2)      GET CDR OF PROPERTY (SUB)LIST\n         TM    ##TYPE(#2),##ATOM   IF PROPERTY (SUB)LIST WAS ATOMIC,\n         BO    ERROR2              THEN ERROR\n         CR    #15,#10             IF NOT NIL, THEN CONTINUE SEARCHING\n         BNE   LOOP                ELSE WE CAME TO THE END OF THE PLIST\nNOTFOUND DS    0H                  PROPERTY NOT FOUND\n         LR    #15,#7              LOAD ARG 3\n         CR    #7,#13              IF ARG 3 SUPPLIED\n         BNER  #14                 THEN RETURN WITH IT\n         LR    #15,#10             ELSE RETURN DEFAULT OF NIL\n         BR    #14\n         SPACE 1\nFOUND    DS    0H                  PROPERTY FOUND\n         ICM   #15,15,##CAR(#2)    SET RETURN VALUE = CAR OF SUBLIST\n         BNMR  #14                 IF VALID, RETURN TO CALLER\n         B     ERROR2              IF #2 DIDN'T POINT TO CONS, ERROR\n         SPACE 1\nNOTSYM   DS    0H                  Arg 1 not a symbol\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FOR COMPATIBILITY WITH MACLISP AND OTHER APPLICATIONS THAT USE      *\n* DISEMBODIED PROPERTY LISTS, IF ARG 1 IS A LIST THEN WE ACCEPT IT.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ##TYPE(#5),##ATOM   See if it's a list\n         BO    ERROR1              If so, then...\n         L     #15,##CDR(,#5)       get CDR and use as property list\n         B     PROCESS             Else it's an atom\n         SPACE 1\nERROR1   DS    0H                  Arg 1 not even a list...\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If arg 1 is neither a symbol nor a list, it should be an error.     *\n* However, for compatibility with Maclisp and other dialects of       *\n* LISP that run Macsyma, we allow GET to always return the specified  *\n* \"default value\" in such cases.                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #4,#14              SAVE RETURN ADDRESS\n* Issue warning message and continue\n         #ERR  1,'Argument 1 to GET not a symbol, returning default valX\n               ue of ',(#7),' - ',(#5)\n         LR    #14,#4              Restore return address\n         B     NOTFOUND            Go to return default value\n         SPACE 1\nERROR2   DS    0H                  INVALID PROPERTY LIST\n         #ERR  'ZIL4011 GET: Invalid property list found for ',(#5),   X\n               PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETCHAR": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x116\\x00M\\x00J\\x00L\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:36:00", "lines": 77, "newlines": 74, "modlines": 76, "user": "SEB1525"}, "text": "         TITLE 'GETCHAR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GETCHAR TAKES TWO ARGUMENTS - A STRING AND A FIXNUM.                *\n*                                                                     *\n* It returns an interned symbol representing the arg2'th character    *\n* of arg1.                                                            *\n*                                                                     *\n* This is a Maclisp function, not a Common Lisp function.             *\n*                                                                     *\n***********************************************************************\nGETCHAR  #ZBEG MINARGS=2,MAXARGS=2,NAME='GETCHAR'\n         #ZPDS 20\n         #ZSAV ,\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGS\n         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         CLI   ##TYPE(#7),##FIXNUM IF ARG 2 IS NOT A FIXNUM\n         BNE   ERROR2              THEN ERROR\n         ICM   #7,15,##CDR(#7)     GET FIXNUM VALUE\n         BNP   RETNIL              IF ZERO OR NEGATIVE, RETURN NIL\n         XR    #2,#2               CLEAR INSERT REG\n         ICM   #2,7,1(#6)          GET STRING LENGTH\n         CR    #7,#2               IF SUBSCRIPT EXCEEDS LENGTH\n         BH    RETNIL              THEN RETURN NIL\n         IC    #1,##VECDAT-1(#7,#6) LOAD CHARACTER FROM SUBSTRING\n         STC   #1,CHARWORK         MOVE TO TEMP AREA OUTSIDE STRING!\n*\n* We used to call ZILABLD, but why not call ZILINTN directly?\n*\n* In such a case, we MUST check for T ourselves.\n*\n         CLI   CHARWORK,C'T'       If character = T\n         BNE   NOTT                then\n         LR    #15,#8               return address of T\n         B     RETURN              else\nNOTT     DS    0H                   character other than T...\n         LA    #4,CHARWORK         GET ADDRESS OF PRINT NAME TEXT\n         LA    #5,1                GET LENGTH OF PRINT NAME TEXT\n         XR    #7,#7               INDICATE PRINT NAME TEXT SUPPLIED\n         L     #15,ZLCINTN         GET ADDRESS OF ZILINTN\n         LA    #0,20(,#11)         GET CURRENT TOP-OF-STACK POINTER\n         #BASR #14,#15             CALL ZILINTN TO INTERN THE SYMBOL\n         B     RETURN\n***      SPACE 1\n***      LA    #0,1                SET LENGTH = 1\n***      LA    #1,CHARWORK         POINT TO THIS AREA!\n***      LR    #2,#8               SET INTERN FLAG = T\n***      LR    #3,#10              SET FORMAT FLAG = NIL\n***      L     #15,ZLCABLD         GET ADDRESS OF ZILABLD\n***      LA    #4,20(,#11)         SET CURRENT STACK POINTER FOR CONS\n***      #BASR #14,#15             CALL ZILABLD TO MAKE AT ATOM FROM IT\n***      B     RETURN              RETURN THE ATOM IN #15\n         SPACE 1\nRETNIL   DS    0H                  SUBSCRIPT OUT OF BOUNDS\n         LR    #15,#10             RETURN NIL\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument 1 to GETCHAR not a string - ',(#6)\nERROR2   #ERR  'Argument 2 to GETCHAR not a fixnum - ',(#7)\n         SPACE 1\nCHARWORK DS    CL1\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETCHARN": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x116\\x003\\x000\\x002\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:36:00", "lines": 51, "newlines": 48, "modlines": 50, "user": "SEB1525"}, "text": "         TITLE 'GETCHARN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GETCHARN TAKES TWO ARGUMENTS - A STRING AND A FIXNUM.               *\n*                                                                     *\n* IT RETURNS A FIXNUM.  INDEXING IS ZERO-BASED, UNLIKE CHAR.          *\n*                                                                     *\n* This is a Maclisp function, not a Common Lisp function.             *\n*                                                                     *\n***********************************************************************\nGETCHARN #ZBEG MINARGS=2,MAXARGS=2,NAME='GETCHARN'\n         SPACE\n         LM    #6,#7,0(#1)         LOAD ARGS\n         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         CLI   ##TYPE(#7),##FIXNUM IF ARG 2 IS NOT A FIXNUM\n         BNE   ERROR2              THEN ERROR\n         ICM   #5,15,##CDR(#7)     GET FIXNUM VALUE\n         BNP   RET00               IF ZERO OR NEGATIVE, RETURN X'00'\n         XR    #3,#3               CLEAR INSERT REG\n         ICM   #3,7,1(#6)          GET STRING LENGTH\n         CR    #5,#3               IF INDEX EXCEEDS LENGTH\n         BH    RET00               THEN RETURN X'00'\n         XR    #2,#2               CLEAR INSERT REG\n         IC    #2,##VECDAT-1(#5,#6) GET STRING CHARACTER INTO REGISTER\n         SLA   #2,3                Convert to index into fixnum table\n         DROP  #15\n         LA    #15,#SFT(#2)        Point to entry in fixnum table\n         BR    #14\n         SPACE 1\nRET00    DS    0H                  INDEX OUT OF BOUNDS\n         LA    #15,#SFT0           RETURN X'00'\n         BR    #14\n         SPACE 1\n         USING GETCHARN,#2\nERROR1   LR    #2,#15\n         #ERR  'Argument 1 to GETCHARN not a string - ',(#6)\nERROR2   LR    #2,#15\n         #ERR  'Argument 2 to GETCHARN not a fixnum - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETK": {"ttr": 2060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x17\\x00D\\x00A\\x00C\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:17:14", "lines": 68, "newlines": 65, "modlines": 67, "user": "SEB1525"}, "text": "         TITLE 'GETK - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GETK TAKES TWO REQUIRED ARGUMENTS - A LIST AND A KEYWORD INDICATOR  *\n* - AND AN OPTIONAL ARGUMENT INDICATING WHETHER AN ERROR IS TO        *\n*   BE SIGNALLED IF THE LIST IS BAD.                                  *\n*                                                                     *\n* THE LIST IS NOT A \"DISEMBODIED PROPERTY LIST\"; RATHER, IT IS A      *\n* LIST OF ALTERNATING KEYWORDS AND VALUES.                            *\n*                                                                     *\n* THIS FUNCTION RETURNS THE SUBLIST OF THE PROPERTY LIST BEGINNING    *\n* WITH THE VALUE (NOT THE KEYWORD), OR NIL IF THE INDICATOR IS        *\n* NOT FOUND.                                                          *\n*                                                                     *\n* THIS FUNCTION IS DESIGNED FOR USE WITH CODE THAT ACCESSES THE       *\n* VALUE OF KEYWORDS USING A LAMBDA LIST WITH &KEY SPECIFIED.          *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND THEREFORE USES NO STACK SPACE.     *\n*                                                                     *\n* This is a ZIL-only function.                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nGETK     #ZBEG MINARGS=2,MAXARGS=3,NAME='GETK'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING GETK,#3\n         SPACE 1\n         LM    #15,#0,0(#1)        #15 = LIST, #0 = KEYWORD\n         SPACE 1\nLOOP     DS    0H\n         CR    #15,#10             IF END OF PROPERTY LIST (NULL)\n         BER   #14                 THEN RETURN NIL\n         TM    ##TYPE(#15),##ATOM  IF PROPERTY (SUB)LIST ATOMIC\n         BO    ERROR1              THEN ERROR\n         C     #0,##CAR(,#15)      IF (CAR SUBPLIST) IS \"EQ\" TO ARG 2\n         BNE   NEXT                THEN...\n         L     #15,##CDR(,#15)      GET CDR OF PROPERTY (SUB)LIST\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nNEXT     DS    0H                  ELSE NOT THE ONE - CONTINUE\n         L     #15,##CDR(,#15)      GET CDR OF PROPERTY (SUB)LIST\n         TM    ##TYPE(#15),##ATOM  IF PROPERTY (SUB)LIST ATOMIC\n         BO    ERROR1              THEN ERROR\n         L     #15,##CDR(,#15)     GET CDR OF PROPERTY (SUB)LIST\n         B     LOOP                CONTINUE PROCESSING\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         C     #13,8(,#1)          IF ARG 3 IS UNSPECIFIED\n         BE    ERROR                OR\n         C     #10,8(,#1)            ARG 3 IS NIL\n         BE    ERROR                  THEN SIGNAL AN ERROR\n         LR    #15,#10             ELSE RETURN NIL\n         BR    #14\n         SPACE 1\nERROR    DS    0H\n         L     #2,0(,#1)\n         #ERR  'ZIL4012 GETK: Improper keyword list specified - ',     X\n               (#2),PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETL": {"ttr": 2062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x000\\x00\\x88\\x01_\\x01\\x00&_\\x11\\x17\\x00f\\x00c\\x00e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:17:30", "lines": 102, "newlines": 99, "modlines": 101, "user": "SEB1525"}, "text": "         TITLE 'GETL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GETL TAKES TWO ARGUMENTS - AN ATOM AND A LIST OF PROPERTIES         *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND THEREFORE USES NO STACK SPACE.     *\n*                                                                     *\n* Note: GETL does not exist in Common LISP.  The equivalent CL        *\n*       definition might be:                                          *\n*                                                                     *\n* (defun getl (symbol indicator-list)                                 *\n*  (multiple-value-bind (found-indicator found-value plist-tail)      *\n*                       (get-properties (symbol-plist symbol)         *\n*                                       indicator-list)               *\n*                       plist-tail))                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nGETL     #ZBEG MINARGS=2,MAXARGS=2,NAME='GETL'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING GETL,#3\n         SPACE 1\n         LM    #5,#6,0(#1)         LOAD THE ARGUMENTS\n         CLI   ##TYPE(#5),##SYMBOL ARG 1 MUST BE A SYMBOL\n         BNE   NOTSYM\n         L     #15,##PLIST(,#5)    GET PROPERTY LIST POINTER\nPROCESS  DS    0H\n* Initial loop-bypassing test for null property list\n         CR    #15,#10             IF END OF PROPERTY LIST (NULL)\n         BER   #14                 THEN RETURN NIL (NO PROPS FOUND)\n         SPACE 1\nLOOP     DS    0H\n         LM    #0,#1,##CAR(#15)    GET CAR AND CDR OF NEXT CELL\n*\n* If #15 didn't point to a CONS cell, then the high-order bit of #1\n* will be one, since it was an \"atom\" type bit.\n*\n         LTR   #0,#0               IF PROPERTY (SUB)LIST ATOMIC\n         BM    ERROR2              THEN ERROR\n*                                  #0 = CAR OF (SUB)LIST = INDICATOR\n*                                  #1 = CDR OF (SUB)LIST = NEXT SUBLIST\n         LR    #4,#6               START SCANNING LIST OF PROPERTIES\nPROPLOOP DS    0H\n         TM    ##TYPE(#4),##ATOM   AT END OF ARG2\n         BO    NOTFOUND            THIS MATCHES NO PROPS IN THE LIST\n         C     #0,##CAR(,#4)       IF INDICATOR IS \"EQ\" TO PROPERTY\n         BER   #14                 THEN RETURN WITH SUBLIST\n         L     #4,##CDR(,#4)       ELSE GET CDR OF LIST OF PROPS\n         B     PROPLOOP            AND CONTINUE SEARCHING IT\nNOTFOUND DS    0H\n         TM    ##TYPE(#1),##ATOM   IF PROPERTY (SUB)LIST ATOMIC,\n         L     #15,##CDR(,#1)      GETTING CDR OF PROPERTY (SUB)LIST,\n         BO    ERROR2              THEN ERROR\n         CR    #15,#10             CHECK SUBLIST FOR NIL\n         BER   #14                 IF SUBLIST IS NIL, RETURN NIL\n         B     LOOP                IF SUBLIST NOT NIL, KEEP LOOPING\n         SPACE 1\nNOTSYM   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FOR COMPATIBILITY WITH MACLISP AND OTHER APPLICATIONS THAT USE      *\n* DISEMBODIED PROPERTY LISTS, IF ARG 1 IS A LIST THEN WE ACCEPT IT.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ##TYPE(#5),##ATOM   See if it's a list\n         BO    ERROR1              If so, then...\n         L     #15,##CDR(,#5)       get CDR and use as property list\n         B     PROCESS             Else it's an atom\n         SPACE 1\nERROR1   DS    0H                  Arg 1 not even a list...\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If arg 1 is neither a symbol nor a list, it should be an error.     *\n* However, for compatibility with Maclisp and other dialects of LISP  *\n* that run Macsyma, we allow GETL to always return the specified      *\n* \"default value\" in such cases.                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #4,#14              SAVE RETURN ADDRESS\n* Issue warning message and continue\n         #ERR  1,'Argument 1 to GETL not a symbol, returning NIL - ',  X\n               (#5)\n         LR    #15,#10             SET RETURN VALUE TO NIL\n         BR    #4                  RETURN TO CALLER\n         SPACE 1\nERROR2   DS    0H                  INVALID PROPERTY LIST\n         #ERR  'ZIL4011 GETL: Invalid property list found for ',(#5),  X\n               PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "GETPARM": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x116\\x00l\\x00V\\x00k\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:36:00", "lines": 108, "newlines": 86, "modlines": 107, "user": "SEB1525"}, "text": "         TITLE 'GETPARM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GETPARM TAKES TWO (OPTIONAL) ARGUMENTS:                             *\n*                                                                     *\n* (1) WHETHER (T) OR NOT (NIL) TO INTERN THE RESULTING ATOM.          *\n* (2) WHETHER (T) OR NOT (NIL) TO CONVERT TO NUMERIC FORMAT.          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    IF THE PARM DATA BEGINS WITH A BACKSLASH \"\\\", SKIP OVER          *\n*    ALL DATA UP TO THE NEXT BACKSLASH.  THIS IS DESIGNED TO          *\n*    ALLOW INITIALIZATION SPECS TO BE PASSED TO ZIL.                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note:  This is an MVS-dependent function.  Actually, it is kind of  *\n*        obsolete, since there should be a new function coded that    *\n*        returns the PARM stuff as a STRING rather than a symbol.     *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILTSO\n         #ZSYS\n         EJECT\nGETPARM  #ZBEG MINARGS=0,MAXARGS=2,NAME='GETPARM'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #1,4(,#13)          GET ADDRESS OF ZLBSAVE (COM'S HSA)\n         L     #1,4(,#1)           GET ADDRESS OF ZILMAIN'S SAVE AREA\n         L     #1,24(,#1)          GET ORIGINAL PARM POINTER\n         AIF   (NOT &ZILTSO).PGMCALL\n*----------------------------------------------------------------------\n* TSO ONLY\n*----------------------------------------------------------------------\n         TM    0(#1),X'80'         IF THERE IS 1 PARAMETER\n         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM\n         TM    4(#1),X'80'         IF THERE ARE 2 PARAMETERS\n         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM\n         TM    8(#1),X'80'         IF THERE ARE 3 PARAMETERS\n         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM\n*                                  ELSE WE WERE CALLED AS A COMMAND\n         USING CPPL,#1\n         L     #2,CPPLCBUF         GET ADDRESS OF COMMAND BUFFER\n         LH    #0,0(,#2)           GET LENGTH OF COMMAND BUFFER\n         AR    #0,#2               POINT TO END OF COMMAND BUFFER\n         LH    #1,2(,#2)           GET OFFSET OF COMMAND TEXT\n         LA    #1,4(#1,#2)         POINT TO START OF COMMAND TEXT\n         SR    #0,#1               GET LENGTH OF COMMAND TEXT\n         B     GOTIT\n*----------------------------------------------------------------------\n* END TSO ONLY\n*----------------------------------------------------------------------\n.PGMCALL ANOP  ,\nPGMCALL  DS    0H\n         L     #1,0(,#1)           GET ADDRESS OF PARM STRING\n         LH    #0,0(,#1)           GET LENGTH OF PARM STRING\n         LA    #1,2(,#1)           POINT TO TEXT OF PARM\nGOTIT    DS    0H                  #1 = ADDRESS, #0 = LENGTH\n* GET THE TRUE PARM, NOT INCLUDING LEADING DATA ENCLOSED IN BACKSLASHES\n         LTR   #0,#0               IF PARM LENGTH IS ALREADY ZERO\n         BZ    GOTREAL             THEN THIS IS IT\n         CLI   0(#1),C'\\'          IF PARM DOESN'T BEGIN WITH BACKSLASH\n         BNE   GOTREAL             THEN THIS IS IT\n         LA    #1,1(,#1)           ELSE SKIP OVER INITIAL BACKSLASH\n         BCTR  #0,0                DECREMENT PARM LENGTH\nBSLOOP   DS    0H                  LOOP TO FIND TERMINATING BACKSLASH\n         LTR   #0,#0               IF PARM LENGTH DOWN TO ZERO\n         BZ    GOTREAL             THEN STOP SCANNING, RETURN ||\n         CLI   0(#1),C'\\'          IF BACKSLASH FOUND\n         BE    BSEND               THEN PROCESS REMAINDER OF STRING\n         LA    #1,1(,#1)           ELSE INCREMENT POINTER\n         BCTR  #0,0                DECREMENT LENGTH\n         B     BSLOOP\nBSEND    DS    0H                  WE FOUND TERMINATING BACKSLASH\n         LA    #1,1(,#1)           POINT TO DATA FOLLOWING BACKSLASH\n         BCTR  #0,0                DECREMENT LENGTH\nGOTREAL  DS    0H                  #1 = ADDRESS, #0 = LENGTH\n* NOW WE GOT THE TRUE PARM\n         L     #2,0(,#11)          GET ARG 1 = WHETHER TO INTERN IT\n         L     #3,4(,#11)          GET ARG 2 = WHETHER TO FORMAT IT\n         L     #15,ZLCABLD         GET ADDRESS OF ZILABLD\n         LA    #4,20(,#11)         GET CURRENT STACK POINTER FOR CONS\n         #BASR #14,#15             CALL ZILABLD TO BUILD THE ATOM\n*                                   MAKING #15 POINT TO NEW ATOM\n         SPACE\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\n         LTORG\n         EJECT\n         AIF   (NOT &ZILTSO).AFTCPPL\n*----------------------------------------------------------------------\n* TSO ONLY\n*----------------------------------------------------------------------\n         IKJCPPL\n*----------------------------------------------------------------------\n* END TSO ONLY\n*----------------------------------------------------------------------\n.AFTCPPL ANOP  ,\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GREATERP": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x116\\x01t\\x01q\\x01s\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:36:00", "lines": 372, "newlines": 369, "modlines": 371, "user": "SEB1525"}, "text": "         TITLE 'GREATERP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* GREATERP TAKES TWO ARGUMENTS. BOTH MUST BE NUMERIC OR ALPHA ATOMS.  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO STACK SPACE.              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS:                                    *\n*                                                                     *\n* 1. BOTH ARGS FIXED         - PERFORM INTEGER COMPARISON.            *\n* 2. BOTH ARGS FLOAT         - PERFORM REAL COMPARISON.               *\n* 3. ONE FIXED, ONE FLOAT    - CONVERT THE FIXED ARGUMENT TO          *\n*                              FLOAT AND PERFORM REAL COMPARISON.     *\n* 4. BOTH ARGS ALPHA         - PERFORM CHARACTER COMPARISON.          *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ===> BIGNUM - FLOAT COMPARISON NOT YET IMPLEMENTED                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SUPPORT FOR STRING AND SYMBOL COMPARES.  THE FOLLOWING COMPARISONS  *\n*            ARE LEGAL:                                               *\n*                                                                     *\n*  SYMBOL TO SYMBOL                                                   *\n*  STRING TO STRING                                                   *\n*  SYMBOL TO STRING                                                   *\n*  STRING TO SYMBOL                                                   *\n*                                                                     *\n* ALL MAY BE REMOVED FOR FULL COMMON LISP.                            *\n*                                                                     *\n***********************************************************************\nGREATERP #ZBEG MINARGS=2,MAXARGS=2,NAME='GREATERP'\n         SPACE\n         LR    #3,#15\n         DROP  #15\n         USING GREATERP,#3\n         SPACE\n         LM    #1,#2,0(#1)         LOAD ARGUMENTS\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         CR    #1,#2               IF ARGS ARE \"EQ\"\n         BER   #14                 THEN RETURN NIL\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#1),##FIXNUM\n         BE    ARG1FIX\n         CLI   ##TYPE(#1),##SFLOAT\n         BE    ARG1SFLO\n         CLI   ##TYPE(#1),##BIGNUM\n         BE    ARG1BIG\n         CLI   ##TYPE(#1),##DFLOAT\n         BE    ARG1DFLO\n*\n* --- DELETE THIS CODE FOR FULL COMMON LISP\n*\n         CLI   ##TYPE(#1),##STRING\n         BE    ARG1STR\n         CLI   ##TYPE(#1),##SYMBOL\n         BE    ARG1ALF\n*\n* --- END CODE TO DELETE FOR FULL COMMON LISP\n*\n         B     ERROR\n         EJECT\nARG1FIX  DS    0H                  ARG 1 IS FIXED\n         SPACE\n         L     #0,##CDR(,#1)       GET FIXED VALUE 1\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    CFIXFIX             FIXED - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    CFIXBIG             FIXED - BIG   = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    CFIXSFLO            FIXED - FLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    CFIXDFLO            FIXED - FLOAT = OK\n         B     ERROR               ANYTHING ELSE = ERROR\nCFIXSFLO DS    0H                  FIXED VALUE 1 ALREADY IN #0\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LRER  #F2,#F0             GET SINGLE FLOAT VALUE 1\n         B     COMSFLO1\n         SPACE\nCFIXDFLO DS    0H                  FIXED VALUE 1 ALREADY IN #0\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LDR   #F2,#F0             GET DOUBLE FLOAT VALUE 1\n         B     COMDFLO1\n         SPACE\nCFIXFIX  DS    0H                  GOOD FOR FIXNUMS\n         C     #0,##CDR(,#2)       COMPARE\n         BNHR  #14\n         LR    #15,#8\n         BR    #14\n         SPACE\nARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    SFLOSFLO            SFLOAT - SFLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    SFLODFLO            SFLOAT - DFLOAT = OK\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    SFLOFIX             FLOAT - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    SFLOBIG             FLOAT - BIG   = OK\n         B     ERROR               FLOAT - NONUM = ERROR\nSFLOFIX  DS    0H\n         LE    #F2,##CDR(,#1)      GET SINGLE FLOAT VALUE 1\n         L     #0,##CDR(,#2)       GET FIXED VALUE 2\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LRER  #F4,#F0             GET SINGLE FLOAT VALUE 2\n         B     COMSFLO2\n         SPACE\nSFLODFLO DS    0H                  SINGLE FLOAT 1, DOUBLE FLOAT 2\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#1)      GET DOUBLE FLOAT VALUE 1\n         B     COMDFLO1\nSFLOSFLO DS    0H                  SINGLE FLOAT 1, SINGLE FLOAT 2\n         LE    #F2,##CDR(,#1)      GET FLOAT VALUE 1\nCOMSFLO1 DS    0H\n         LE    #F4,##CDR(,#2)      GET SINGLE FLOAT VALUE 1\nCOMSFLO2 DS    0H\n         CER   #F2,#F4             COMPARE\n         BNHR  #14\n         LR    #15,#8\n         BR    #14\n         EJECT\nARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F2,8(,#1)          GET DOUBLE FLOAT VALUE 1\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    DFLODFLO            DFLOAT - DFLOAT = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    DFLOSFLO            DFLOAT - SFLOAT = OK\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    DFLOFIX             FLOAT - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    DFLOBIG             FLOAT - BIG   = OK\n         B     ERROR               FLOAT - NONUM = ERROR\nDFLOFIX  DS    0H\n         L     #0,##CDR(,#2)       GET FIXED VALUE 2\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LDR   #F4,#F0             GET DOUBLE FLOAT VALUE 2\n         B     COMDFLO2\n         SPACE\nDFLOSFLO DS    0H                  DOUBLE FLOAT 1, SINGLE FLOAT 2\n         SDR   #F4,#F4\n         LE    #F4,##CDR(,#2)      GET DOUBLE FLOAT VALUE 2\n         B     COMDFLO2\nDFLODFLO DS    0H                  DOUBLE FLOAT 1, DOUBLE FLOAT 2\nCOMDFLO1 DS    0H\n         LD    #F4,8(,#2)          GET DOUBLE FLOAT VALUE 1\nCOMDFLO2 DS    0H\n         CDR   #F2,#F4             COMPARE\n         BNHR  #14\n         LR    #15,#8\n         BR    #14\n         EJECT\nARG1BIG  DS    0H                  ARG1 IS A BIGNUM\n         SPACE\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    CBIGFIX             FIXED - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    CBIGBIG             FIXED - BIG   = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    CBIGSFLO            FIXED - FLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    CBIGDFLO            FIXED - FLOAT = OK\n         B     ERROR               ANYTHING ELSE = ERROR\n         SPACE\nCFIXBIG  DS    0H                  COMPARE FIXNUM TO BIGNUM\n         SPACE\n         TM    ##VECDAT(#2),X'80'  TEST SIGN OF BIGNUM\n         BZR   #14                 IF BIGNUM POSITIVE, FIX NOT GT BIG\n         LR    #15,#8              IF BIGNUM NEGATIVE, FIX IS GT BIG\n         BR    #14                  SO RETURN T\n         SPACE\nCBIGFIX  DS    0H                  COMPARE BIGNUM TO FIXNUM\n         SPACE\n         TM    ##VECDAT(#1),X'80'  TEST SIGN OF BIGNUM\n         BOR   #14                 IF BIGNUM NEGATIVE, BIG NOT GT FIX\n         LR    #15,#8              IF BIGNUM POSITIVE, BIG IS GT FIX\n         BR    #14                  SO RETURN T\n         EJECT\nCBIGBIG  DS    0H                  COMPARE BIGNUM TO BIGNUM\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THE FOLLOWING CODE DEPENDS ON THESE FACTS:                          *\n*                                                                     *\n*  (1) ALL BIGNUMS ARE NORMALIZED.                                    *\n*  (2) BIGNUMS ARE STORED IN 31-BIT \"DIGITS\", EACH DIGIT OCCUPYING A  *\n*      WORD, WITH THE LEAST SIGNIFICANT WORD LEFTMOST.  I.E. THE      *\n*      BIGNUM \"DIGITS\" ARE STORED \"BACKWARDS\".                        *\n*  (3) NEGATIVE BIGNUMS ARE STORED AS THEIR ABSOLUTE VALUE, EXCEPT    *\n*      THAT THE LEAST SIGNIFICANT (LEFTMOST) WORD HAS THE HIGH-ORDER  *\n*      BIT SET TO 1 (BUT IT IS NOT TWO'S COMPLEMENT).                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   #4,15,##VECDAT(#1)  TEST SIGN OF BIGNUM 1\n         BM    B1NEG               IF BIGNUM 1 NEGATIVE, CHECK BIG# 2\n         TM    ##VECDAT(#2),X'80'  BIG 1 IS POSITIVE.  SO...\n         BO    TRUE                IF BIGNUM 2 NEGATIVE, RETURN TRUE\n*                                  ELSE COMPARE 2 POSITIVE BIGNUMS\n         XR    #5,#5               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#1)          GET BIGNUM LENGTH 1\n         ICM   #7,7,1(#2)          GET BIGNUM LENGTH 2\n         CR    #5,#7               COMPARE LENGTHS\n         BLR   #14                 IF FIRST IS SHORTER, B1 < B2\n         BH    TRUE                IF FIRST IS LONGER, B1 > B2\n         LA    #7,4                OTHERWISE WE HAVE TO COMPARE THEM.\n         LCR   #7,#7               SET INCREMENT REGISTER TO -4\n         AR    #5,#7               INIT INDEX TO BIGNUM LENGTH - 4\nBBPLOOP  DS    0H                  LOOP FROM LAST WORD THRU TO FIRST\n         L     #0,##VECDAT(#5,#1)  COMPARE WORD FROM BIGNUM 1\n         C     #0,##VECDAT(#5,#2)  WITH WORD FROM BIGNUM 2\n         BH    TRUE                IF GREATER, B1 > B2\n         BLR   #14                 IF LESS, B1 < B2\n         BXH   #5,#7,BBPLOOP       =, DECREMENT INDEX AND LOOP UNTIL...\n         BR    #14                 NO MORE WORDS: ALL =, B1 NOT GT B2\n         SPACE\nB1NEG    DS    0H                  BIGNUM 1 IS NEGATIVE\n         ICM   #6,15,##VECDAT(#2)  IF BIGNUM 2 IS POSITIVE\n         BNMR  #14                 THEN RETURN FALSE. ELSE...\n*                                  COMPARE 2 NEGATIVE BIGNUMS\n         XR    #5,#5               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#1)          GET BIGNUM LENGTH 1\n         ICM   #7,7,1(#2)          GET BIGNUM LENGTH 2\n         CR    #5,#7               COMPARE LENGTHS\n         BL    TRUE                IF FIRST IS SHORTER, B1 > B2\n         BHR   #14                 IF FIRST IS LONGER, B1 < B2\n         LA    #7,4                OTHERWISE WE HAVE TO COMPARE THEM.\n         LCR   #7,#7               SET INCREMENT REGISTER TO -4\n         AR    #5,#7               INIT INDEX TO BIGNUM LENGTH - 4\nBBNLOOP  DS    0H                  LOOP FROM LAST WORD THRU TO FIRST\n         L     #0,##VECDAT(#5,#1)  COMPARE WORD FROM BIGNUM 1\n         CL    #0,##VECDAT(#5,#2)  WITH WORD FROM B2 (IGNORE SIGN BIT)\n         BHR   #14                 IF GREATER, B1 < B2\n         BL    TRUE                IF LESS, B1 > B2\n         BXH   #5,#7,BBNLOOP       =, DECREMENT INDEX AND LOOP UNTIL...\n         BR    #14                 NO MORE WORDS: ALL =, B1 NOT GT B2\n         SPACE 1\nTRUE     DS    0H\n         LR    #15,#8              TRUE... RESULT IS T\n         BR    #14\n         EJECT\n*\n* --- DELETE THIS CODE FOR FULL COMMON LISP\n*\nARG1STR  DS    0H                  ARG 1 IS STRING\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##STRING\n         BE    COMPSS              STRING - STRING IS OK\n         CLI   ##TYPE(#2),##SYMBOL\n         BE    COMPSA              STRING - SYMBOL IS OK\n         B     ERROR               ALL OTHERS ARE NO GOOD\n         SPACE\nARG1ALF  DS    0H                  ARG 1 IS SYMBOL\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##STRING\n         BE    COMPAS              SYMBOL - STRING IS OK\n         CLI   ##TYPE(#2),##SYMBOL\n         BE    COMPAA              SYMBOL - SYMBOL IS OK\n         B     ERROR               ALL OTHERS ARE NO GOOD\n         SPACE\nCOMPAS   DS    0H                  SYMBOL-TO-STRING COMPARE\n         L     #1,##PNAME(,#1)     GET PRINT NAME OF SYMBOL 1\n         B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPSA   DS    0H                  STRING-TO-SYMBOL COMPARE\n         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL 2\n         B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPAA   DS    0H                  SYMBOL-TO-SYMBOL COMPARE\n         L     #1,##PNAME(,#1)     GET PRINT NAME OF SYMBOL 1\n         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL 2\n******** B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPSS   DS    0H                  STRING-TO-STRING COMPARE\n         SPACE 1\n         XR    #5,#5               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#1)          GET STRING LENGTH 1\n         ICM   #7,7,1(#2)          GET STRING LENGTH 2\n         LA    #4,##VECDAT(,#1)    POINT TO STRING TEXT 1\n         LA    #6,##VECDAT(,#2)    POINT TO STRING TEXT 2\n*\n*                                  #4 = ADDRESS OF ARG 1 DATA\n*                                  #5 = LENGTH OF ARG 1 DATA\n*                                  #6 = ADDRESS OF ARG 2 DATA\n*                                  #7 = LENGTH OF ARG 2 DATA\n*\n         CR    #5,#7               COMPARE LENGTHS\n         BL    SHORTCOM            IF FIRST IS SHORTER, GO HANDLE THAT\n         BH    LONGCOM             IF FIRST IS LONGER, GO HANDLE THAT\n         CLCL  #4,#6               OTHERWISE JUST DO COMPARE\n         BNHR  #14                 ARG1 LE ARG2: RETURN NIL\n         LR    #15,#8              ARG1 GT ARG2: RETURN T\n         BR    #14\n         SPACE 1\nSHORTCOM DS    0H                  ARG1 SHORTER THAN ARG2\n         LR    #7,#5               USE SHORT LENGTH FOR COMPARE\n         CLCL  #4,#6               DO COMPARE\n         BNHR  #14                 ARG1 LE ARG2: RETURN NIL\n         LR    #15,#8              ARG1 GT ARG2: RETURN T\n         BR    #14\n         SPACE 1\nLONGCOM  DS    0H                  ARG1 LONGER THAN ARG2\n         LR    #5,#7               USE SHORT LENGTH FOR COMPARE\n         CLCL  #4,#6               DO COMPARE\n         BLR   #14                 ARG1 LT ARG2: RETURN NIL\n         LR    #15,#8              ARG1 GE ARG2: RESULT IS T\n         BR    #14\n*\n* --- END CODE TO DELETE FOR FULL COMMON LISP\n*\n         EJECT\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION ROUTINE\n         EJECT\nCBIGSFLO DS    0H\nCBIGDFLO DS    0H\nSFLOBIG  DS    0H\nDFLOBIG  DS    0H\n         LR    #5,#1\n         LR    #6,#2\n         #ERR  2,'ZIL4101 GREATERP: Float-to-bignum compare not supportX\n               ed.',PREFIX=NO,SIGNAL=NO\n         B     BOMBOUT\nERROR    DS    0H                  INVALID TYPES\n         LR    #5,#1\n         LR    #6,#2\nBOMBOUT  #ERR  'Type conflict, GREATERP cannot compare ',              X\n               (#5),' and ',(#6)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HAIPART": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x116\\x02k\\x02h\\x02j\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:36:00", "lines": 619, "newlines": 616, "modlines": 618, "user": "SEB1525"}, "text": "         TITLE 'HAIPART - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS THE MACLISP \"HAIPART\" FUNCTION.  IT TAKES AN INTEGER ARG    *\n* AND RETURNS THE FIRST N BITS IN THE ABSOLUTE VALUE THEREOF,         *\n* NOT INCLUDING LEADING ZERO BITS.                                    *\n*                                                                     *\n* ARG 1 = THE NUMBER FROM WHICH THE \"HIGH PART\" IS TO BE TAKEN        *\n* ARG 2 = THE NUMBER OF BITS TO TAKE STARTING WITH THE FIRST 1-BIT.   *\n*                                                                     *\n* IF ABS(ARG 2) IS GREATER THAN 31, ABS (ARG 1) IS RETURNED.          *\n*                                                                     *\n* THIS IS COMPUTED AS FOLLOWS:                                        *\n*                                                                     *\n* IF ARG 1 IS ZERO, THE RESULT IS ALWAYS ZERO.                        *\n* IF ARG 2 IS NEGATIVE, ARG 1 IS LEFT SHIFTED AND RIGHT SHIFTED TO    *\n* RETURN THE LOW-ORDER (ABS ARG2) BITS OF ARG 1.                      *\n* OTHERWISE, ARG 1 IS LEFT SHIFTED UNTIL A 1-BIT APPEARS IN THE       *\n* LEFTMOST POSITION, AND THE VALUE IS RIGHT SHIFTED (32-ARG2) BITS.   *\n*                                                                     *\n* BIGNUMS ARE ALSO SUPPORTED AS ARG1.                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nHAIPART  #ZBEG MINARGS=2,MAXARGS=2,NAME='HAIPART'\n         #ZPDS 2*4+12+8\n         #ZSAV ,\n         SPACE 1\n         L     #15,0(,#11)         GET ARG1\n         CLI   ##TYPE(#15),##FIXNUM ARG1 MUST BE A FIXNUM OR A BIGNUM\n         BNE   NFIX1\n         L     #4,4(,#11)          GET ARG2\n         CLI   ##TYPE(#4),##FIXNUM ARG2 MUST BE A FIXNUM\n         BNE   ERROR2\n         L     #2,##CDR(,#15)      GET ARG 1 VALUE\n         XR    #3,#3               Clear second half of reg pair\n         LPR   #2,#2               GET ITS ABSOLUTE VALUE\n         BO    MAXNEG              If overflow, must be -2147483648\n         BZ    RETZERO             IF ZERO, ANSWER = ZERO,\n         ICM   #4,15,##CDR(#4)     GET ARG 2 VALUE\n         BM    ARG2NEG             IF NEGATIVE, PROCESS NEGATIVE\n         CH    #4,=H'31'           IF GREATER THAN 31\n         BH    RETABS1             THEN RETURN (ABS ARG1)\n         SPACE 1\nPROCESS  DS    0H                  OK, NOW PROCESS THE NUMERIC VALUE\n*\n* NOTE THAT #2 MUST BE POSITIVE, SINCE WE TOOK ABSOLUTE VALUE.\n*\n*                                  #2 CONTAINS THE ABSOLUTE VALUE\n*                                  #3 CONTAINS ADD'L LOW-ORDER BITS\n*                                  #4 CONTAINS BIT COUNT TO EXTRACT\n*\n         SPACE 1\nLOOP     DS    0H                  LOOP UNTIL WE GET 1-BIT IN LEFTMOST\n         SLDL  #2,1                SHIFT OUT LEFTMOST BIT\n         LTR   #2,#2               IF DIDN'T GO NEGATIVE YET\n         BNM   LOOP                THEN KEEP LOOPING\n         LA    #1,32               GET SHIFT AMOUNT = 32 MINUS ARG2\n         SR    #1,#4\n         SRL   #2,0(#1)            SHIFT RIGHT BY THAT AMOUNT\n         #MKAT FIXED               MAKE INTO A FIXNUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nARG2NEG  DS    0H                  ARG 2 IS NEGATIVE\n         SPACE 1\n         LPR   #4,#4               GET ABSOLUTE VALUE OF ARG2\n         CH    #4,=H'31'           IF GREATER THAN 31\n         BH    RETABS1             THEN RETURN (ABS ARG1)\nLOWORDER DS    0H\n         LA    #1,32               GET SHIFT AMOUNT = 32 MINUS ARG2\n         SR    #1,#4\n         SLDL  #2,0(#1)            SHIFT LEFT BY THAT AMOUNT\n         SRL   #2,0(#1)            SHIFT RIGHT BY THAT AMOUNT\nRETABS1  DS    0H                  HERE IF WE KNOW ANSWER IS (ABS ARG1)\n         #MKAT FIXED               MAKE INTO A FIXNUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nRETZERO  DS    0H                  HERE IF WE KNOW ANSWER MUST BE ZERO\n         LA    #15,#SFT0           POINT TO FIXNUM 0\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nMAXNEG   DS    0H                  Arg 1 is -2147483648\n         SPACE 1\n         LA    #15,TWOTO31         Load bignum 2147483648\n         B     ARG1BIG\n         SPACE 1\nNFIX1    DS    0H                  Arg 1 is not a fixnum\n         SPACE 1\n         CLI   ##TYPE(#15),##BIGNUM\n         BNE   ERROR1              If not an integer, error\n         SPACE 1\nARG1BIG  DS    0H                  Arg 1 is a bignum\n         SPACE 1\n         L     #4,4(,#11)          GET ARG2\n         CLI   ##TYPE(#4),##FIXNUM ARG2 MUST BE A FIXNUM\n         BNE   ERROR2\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Test arg2 - see if it is zero, negative, positive - also if > 31    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   #4,15,##CDR(#4)     Get arg 2 value\n         BZ    RETZERO             If zero, return zero\n         BM    ARG2NEGB            If negative, process negative\n         CH    #4,=H'31'           If arg2 value greater than 31\n         BH    PRETBIG             then need to return bignum\n*                                  else positive arg2 in fixnum range\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Get the 2 most significant words of (abs bignum-arg1) and shift     *\n* left until we get a 32-bit number such that the leftmost bit is 1.  *\n*                                                                     *\n* Note that if there was any sign bit, it will get shifted out anyhow *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n******** L     #15,0(,#11)         Get pointer to arg1\n         XR    #1,#1\n         ICM   #1,7,1(#15)         Get bignum length\n         LA    #14,##VECDAT-4(#1,#15) Point to most significant word\n         SH    #14,=H'4'           Bump back to 2nd most significant wd\n         L     #3,0(,#14)          Load second most significant word\n         N     #3,=X'7FFFFFFF'     Zero possible sign bit to make ABS\n         L     #2,4(,#14)          Load most significant word\n         SLL   #3,1                Bring halves together\n         SRDL  #2,1                Shift 62-bit number into reg pair\n         B     PROCESS             Go to to compute fixnum value\n         SPACE 1\nARG2NEGB DS    0H                  Bignum arg 1, negative arg 2\n         SPACE 1\n         LPR   #4,#4               Get absolute value of arg2\n         CH    #4,=H'31'           If greater than 31\n         BH    NRETBIG             then need to return bignum\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Get the least significant word of bignum arg1 and proceed as if     *\n* for fixnum arg1.                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #2,##VECDAT(,#15)   Get LSW of bignum\n         N     #2,=X'7FFFFFFF'     Zero out possible sign bit\n         XR    #3,#3               Clear second half of reg pair\n         B     ARG2NEG             Go process\n         SPACE 1\nPRETBIG  DS    0H                  HAIPART of bignum by N:N>31\n         SPACE 1\n         LA    #6,1                Set arg2 sign flag positive\n         B     RETBIG              Go to process bignum HAIPART\n         SPACE 1\nNRETBIG  DS    0H                  HAIPART of bignum by N:N>31\n         SPACE 1\n         XR    #6,#6               Set arg2 sign flag negative\n         BCTR  #6,0\n         B     RETBIG              Go to process bignum HAIPART\n         SPACE 1\nRETBIG   DS    0H                  HAIPART of bignum by N:N>31\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Logic for computing HAIPART where arg1 is a bignum and arg2 is a    *\n* positive integer greater than 31.                                   *\n*                                                                     *\n* arg2 is the number of bits in the resulting bignum.  Thus, we can   *\n* reserve space for it, knowing that the number of words in it will   *\n* be (arg2-1)/31+1.                                                   *\n*                                                                     *\n* Compute the number of SIGNIFICANT bits in arg1 (this is the same    *\n* as (HAULONG arg1).  If arg2 is greater than this value, then        *\n* return (ABS arg1), by definition per the Maclisp manual.            *\n*                                                                     *\n* Otherwise, processing diverges depending on whether arg2 is         *\n* positive or negative.                                               *\n*                                                                     *\n* If arg2 is negative, we must take the low-order arg2 bits of        *\n* bignum arg1 and return it as a bignum. So go to RETBIGN.            *\n*                                                                     *\n* Otherwise, get the most significant word of arg1 and left shift it  *\n* until the high-order bit is 1.  This tells us the number of bit     *\n* positions to shift the entire arg1 to get rid of all the leading    *\n* zero bits (note that we actually shifted 1 more than the actual     *\n* number).  So the number of positions to shift is the number we had  *\n* to shift the MSW minus 1.  Shift the MSW back by 1 to the right     *\n* to make it correct.                                                 *\n*                                                                     *\n* We then take only the number of words of arg1 necessary to build    *\n* the result.  This is at most 1 more than the number of words in     *\n* the result.  Left shift that number of bigits over by the amount    *\n* determined above (except for the MSW, which is already correctly    *\n* shifted), rippling the shifted-out bits of each word into its       *\n* more significant neighbor.  This gives a new bignum, which is       *\n* the original arg1 raised to some power of 2 (which is irrelevant,   *\n* since HAIPART will give us the same result anyhow).                 *\n*                                                                     *\n* Divide arg2 (the number of bits in the result) by 31; the remainder *\n* lets us figure out how many bit positions to right-shift the result *\n* after we compute it by taking the first N words of the result of    *\n* the previous operation, where N is the number of words of arg1      *\n* necessary to build the result minus 1 (which equals the number of   *\n* words in the result, remember?).  The number of bit positions to    *\n* right-shift is equal to 31 minus that remainder.  Thus we end up    *\n* with the proper number of leading zero bits in the MSW of the       *\n* result.                                                             *\n*                                                                     *\n* Right-shift all the words in the result by that amount, letting     *\n* the shifted-out bits of each word end up in its less significant    *\n* neighbor.  Return the resulting bignum as the value of HAIPART.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Reserve space for the resulting bignum, arg2 being the # of bits.   *\n*                                                                     *\n* The length is                                                       *\n*    (arg2-1)/31+1.                                                   *\n*                                                                     *\n*    #15 -     pointer to arg1                                        *\n*    #4  -     value of arg2 (number of bits in result)               *\n*    #5  -     pointer to result bignum                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #1,#4               Get arg2 value\n         BCTR  #1,0                Subtract 1\n         XR    #0,#0               Clear left half of dividend\n         D     #0,=F'31'           Divide by 31\n         LR    #2,#1               Get quotient\n         LA    #2,1(,#2)           Add 1 to get # of words for bignum\n         SLA   #2,2                Multiply by 4 to get length of text\n         LR    #3,#2               Save this length\n         L     #15,ZLCBIG          Get address of ZILBIG\n         LA    #2,4(,#2)           Add 4 more for length of header\n         #BASR #14,#15             Call ZILBIG to reserve bignum space\n         LR    #5,#15              #5 = address of new bignum\n         STCM  #3,7,1(#5)          Store length of bignum\n         L     #15,0(,#11)         #15 =  pointer to arg1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Compute the number of SIGNIFICANT bits in arg1 (this is the same    *\n* as (HAULONG arg1).  If this value is greater than arg2, then        *\n* return (ABS arg1), by definition per the Maclisp manual.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #14,#14             Clear insert register\n         ICM   #14,7,1(#15)        Get length of arg1 bignum text\n         SH    #14,=H'4'           Bump down by 1 word\n         L     #3,##VECDAT(#14,#15) Get most significant word of arg1\n         SRA   #14,2               Divide length by 4 to get # of bytes\n         LR    #2,#14              then to # of 31-words less M.S.W.\n         SLA   #2,5                Multiply by 31 (32X - X = 31X)\n         SR    #2,#14              to get number of bits in these words\n         LA    #2,31(,#2)          Set presumed bit count so far\n         XR    #7,#7               Clear shift count to zero\n*                                  #3 contains MSW of arg1\n*                                  #7 will tell us how many to shift\nHAULOOP  DS    0H                  Loop until we determine # of bits\n         SLL   #3,1                Shift out leftmost bit\n         LTR   #3,#3               Test sign to see if we hit a 1-bit\n*        BZ    ...                 (can never be zero, from a bignum)\n         BM    GOTIT               If 1-bit leftmost, we got it\n         LA    #7,1(,#7)           Else increment shift count\n         BCT   #2,HAULOOP          Else reduce bit count and continue\nGOTIT    DS    0H                  Now #2 contains (HAULONG arg1)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If (ABS arg2) is greater than (HAULONG arg1), return (ABS arg1).    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #4,4(,#11)          Reload arg2\n         L     #4,##CDR(,#4)       Get value of arg2\n         LPR   #4,#4               Take (abs arg2)\n         CR    #4,#2               If arg2 > (haulong arg1)\n         BH    RETABSB             then return (abs arg1)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process based on whether arg2 is positive or negative.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #6,#6\n******** BP    RETBIGP\n         BM    RETBIGN\n         SPACE 1\nRETBIGP  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Positive:  get the most significant word of arg1 and left shift it  *\n* until the high-order bit is 1.  This tells us the number of bit     *\n* positions to shift the entire arg1 to get rid of all the leading    *\n* zero bits (note that we actually shifted 1 more than the actual     *\n* number).  So the number of positions to shift is the number we had  *\n* to shift the MSW minus 1.  Shift the MSW back by 1 to the right     *\n* to make it correct.                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SRL   #3,1                Shift MSW into \"normal\" position\n*                                  #7 already contains correct # pos.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* We then take only the number of words of arg1 necessary to build    *\n* the result.  This is at most 1 more than the number of words in     *\n* the result.  Left shift that number of bigits over by the amount    *\n* determined above (except for the MSW, which is already correctly    *\n* shifted), rippling the shifted-out bits of each word into its       *\n* more significant neighbor.  This gives a new bignum, which is       *\n* the original arg1 raised to some power of 2 (which is irrelevant,   *\n* since HAIPART will give us the same result anyhow).                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*    #14 -     pointer to words in result\n*    #15 -     pointer to words in arg1\n*    #0  -     register pair for shifting\n*    #1  -     register pair for shifting\n*    #2  -     (haulong arg1)\n*    #3  -     already-shifted MSW of arg1; holder of each shifted word\n*    #4  -     value of arg2 (number of bits in result)\n*    #5  -     pointer to result bignum\n*    #6  -\n*    #7  -     number of bit positions to left shift arg1 words\n         SPACE 1\n*                                  Set 4(#14) = MSW of result\n         XR    #0,#0               Clear insert register\n         ICM   #0,7,1(#5)          Get length of result bignum\n         LA    #14,##VECDAT(,#5)\n         AR    #14,#0              Point to end of result bignum\n         SH    #14,=H'8'           Point to MSW of result bignum\n*                                  Set 0(#15) = next-to-MSW of arg1\n******** L     #15,0(,#11)\n         XR    #0,#0               Clear insert register\n         ICM   #0,7,1(#15)         Get length of arg1 bignum\n         LA    #15,##VECDAT(,#15)\n         AR    #15,#0              Point to end of arg1 bignum\n         SH    #15,=H'8'           Point to word preceding MSW of arg1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Loop decrementing #14 and #15 until #14 = #5, storing shifted       *\n* words from 0(#15) into 4(#14).  Note that #3 already contains       *\n* part of the first (most significant) word to be stored.             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nLSLOOP   DS    0H\n         CR    #14,#5              Until we hit the end of the result\n         BL    LSEND\n         XR    #0,#0               Clear left half of reg pair\n         L     #1,0(,#15)          Get next-MSW of arg1\n         SLL   #1,1                Shift out sign bit\n         SLDL  #0,0(#7)            Left shift (#7) bits into left reg\n         OR    #3,#0               Combine previous bits with shifted\n         ST    #3,4(,#14)          Store into word of result bignum\n         LR    #3,#1               Set up for next word\n         SRL   #3,1                Shift back in a zero sign bit\n         SH    #15,=H'4'           Decrement arg1 pointer\n         SH    #14,=H'4'           Decrement result pointer\n         B     LSLOOP              Loop\nLSEND    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Now we have a complete result bignum.  But we're not done yet.      *\n* If the number of bits in the result is not a multiple of 31, we     *\n* have to right shift all the words to get leading zeroes instead     *\n* of trailing zeroes.                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Divide arg2 (the number of bits in the result) by 31; the remainder *\n* lets us figure out how many bit positions to right-shift the result *\n* after we compute it by taking the first N words of the result of    *\n* the previous operation, where N is the number of words of arg1      *\n* necessary to build the result minus 1 (which equals the number of   *\n* words in the result, remember?).  The number of bit positions to    *\n* right-shift is equal to 31 minus that remainder.  Thus we end up    *\n* with the proper number of leading zero bits in the MSW of the       *\n* result.                                                             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    #0  -     register pair for shifting                             *\n*    #1  -     register pair for shifting                             *\n*    #4  -     value of arg2 (number of bits in result)               *\n*    #5  -     pointer to result bignum                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #14,#14             Clear left half of reg pair\n         LR    #15,#4              Load value of arg2 (# of bits)\n         D     #14,=F'31'          Divide by 31\n*                                  #15 = quotient, #14 = remainder\n         LTR   #14,#14             If no remainder\n         BZ    READY               then we're done, return result\n*                                  Compute amount to shift = 31-#14\n         LA    #7,31\n         SR    #7,#14              Amount to right-shift result\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Right-shift all the words in the result by that amount, letting     *\n* the shifted-out bits of each word end up in its less significant    *\n* neighbor.  Return the resulting bignum as the value of HAIPART.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*                                  Set 4(#14) = each word of result\n         XR    #0,#0               Clear insert register\n         ICM   #0,7,1(#5)          Get length of result bignum\n         LA    #14,##VECDAT(,#5)\n         AR    #14,#0              Point to end of result bignum\n         SH    #14,=H'8'           Point to MSW of result bignum\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Loop decrementing #14 until #14 = #5, storing shifted words from    *\n* result back into themselves.                                        *\n*                                                                     *\n* Note that there will be no negative sign bit; the result was built  *\n* to be positive.                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #3,#3               Clear reg for building shifted wds\n         SPACE 1\nRSLOOP   DS    0H\n         CR    #14,#5              Until we hit the end of the result\n         BL    RSEND\n         L     #0,4(,#14)          Load a word of the result bignum\n         XR    #1,#1               Clear right half of register pair\n         SRDL  #0,0(#7)            Shift right (#7) bits\n         OR    #3,#0               Combine with last shifted bits\n         ST    #3,4(,#14)          Store back into result bignum\n         LR    #3,#1               Set up for next word\n         SRL   #3,1                Shift back the sign bit\n         SH    #14,=H'4'           Decrement pointer\n         B     RSLOOP              Loop\nRSEND    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Return the result bignum, updating VSS pointer in the process.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nREADY    DS    0H\n         LR    #15,#5              Point to result bignum\n         XR    #1,#1               Clear insert register\n         ICM   #1,7,1(#15)         Get length of result bignum\n         LA    #0,##VECDAT(#1,#15) Point to end of bignum\n         ST    #0,ZLCVSNXT         Set next-available-VSS pointer\n         B     RETURN              Return\n         SPACE 1\nRETBIGN  DS    0H                  HAIPART of bignum by N:N<(-31)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Logic for (HAIPART arg1 arg2) where arg1 is a bignum and arg2 is    *\n* a negative integer less than -31:                                   *\n*                                                                     *\n* The low-order (abs arg2) bits of arg1 are returned.  To do this,    *\n* we figure out how many bignum words are required to hold the        *\n* result.   (Henceforth, let absarg2 = (abs arg2).)  The number of    *\n* result words (N) = (absarg2-1)/31+1.  Allocate a bignum of          *\n* that size, and copy the least significant N words from arg1 to      *\n* the result (this will be ##VECDAT off arg1 for a length of N*4,     *\n* making an easy move).  Zero the sign bit in the result to force     *\n* taking of (abs arg1).                                               *\n* Now, if absarg2 is not a multiple of 31, we will need to mask out   *\n* the extra leading bits.  We generate a bit mask based on the        *\n* remainder of absarg2/31, so that only that many bits are left in    *\n* the most significant word of the result bignum.                     *\n*                                                                     *\n* As a final step, remove leading zero bigits from the result.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* The bignum allocation was done already.                             *\n*                                                                     *\n* Move correct # of words of bignum arg1 to result bignum             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #15,0(,#11)         Load arg1\n         XR    #3,#3\n         ICM   #3,7,1(#5)          Load length of result bignum\n         LA    #14,##VECDAT(,#15)  Source address\n         LR    #15,#3              Source length\n         LA    #0,##VECDAT(,#5)    Destination address\n         LR    #1,#3               Destination length\n         MVCL  #0,#14              Move from arg1 to result\n         NI    ##VECDAT(#5),X'7F'  Force sign bit positive\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If absarg2 is not a multiple of 31, we will need to mask out        *\n* the extra leading bits.  We generate a bit mask based on the        *\n* remainder of absarg2/31, so that only that many bits are left in    *\n* the most significant word of the result bignum.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #1,#4               Set up regs for divide\n         XR    #0,#0\n         D     #0,=F'31'           Quotient in #1, remainder in #0\n         LTR   #0,#0               If remainder is zero\n         BZ    NREADY              then result is already OK, return\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Nonzero remainder: generate a bit mask with which to AND the MSW    *\n* of the result bignum.                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    #2,31               # of bits to zero out = ...\n         SR    #2,#0                31 minus remainder\n         L     #3,=X'7FFFFFFF'     Initialize mask to 31 1-bits\nMASKLOOP DS    0H                  Loop to turn #3 into a bit mask\n         SRL   #3,1                Shift in a zero-bit\n         BCT   #2,MASKLOOP         Do it 31-(mod absarg2 31) times\n********                           Register cleared (by BCT) for insert\n         ICM   #2,7,1(#5)          Get result bignum length\n         LA    #1,##VECDAT-4(#2,#5) Point to MSW of result bignum\n         N     #3,0(,#1)           And it with our bit mask\n         ST    #3,0(,#1)           Store back the anded MSW\n         SPACE 1\nNREADY   DS    0H                  Almost ready to return result\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Remove all leading zero bigits from the result.  It is possible for *\n* this to culminate in the return of a fixnum.                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #3,#3\n         ICM   #3,7,1(#5)          Get result bignum length\n         LA    #1,##VECDAT-4(#3,#5) Point to MSW of result bignum\n         XR    #0,#0               Make a zero\n         LA    #7,4                Make a four\nNRLOOP   DS    0H\n         CR    #3,#7               If length of bignum text down to 4\n         BNH   RNFIXNUM            then change to a fixnum\n         C     #0,0(,#1)           Else if MSW so far is zeroes\n         BNE   NREND               then...\n         SR    #3,#7                decrement bignum text length by 4\n         SR    #1,#7                decrement pointer too\n         B     NRLOOP               and continue looping.\nNREND    DS    0H\n         STCM  #3,7,1(#5)          Store corrected bignum length\n         LR    #15,#5              Get pointer to result bignum\n         LA    #1,##VECDAT(#3,#5)  Point to end of bignum\n         ST    #1,ZLCVSNXT         Update VSS pointer\n         B     RETURN              Return with result\n         SPACE 1\nRNFIXNUM DS    0H                  Result turns into a fixnum!\n         SPACE 1\n         L     #2,##VECDAT(,#5)    Get the only bigit\n         #MKAT FIXED               Make a fixnum out of it\n         B     RETURN              Return with it\n         SPACE 1\nRETABSB  DS    0H                  Return (ABS arg1), arg1 bignum\n         SPACE 1\n         TM    ##VECDAT(#15),X'80' If arg1 is already positive\n         BZ    RETURN              then just return it\n         XR    #2,#2               CLEAR INSERT REGISTER\n         ICM   #2,7,1(#15)         GET BIGNUM LENGTH\n         LA    #2,4(,#2)           PLUS LENGTH OF HEADER\n         LR    #3,#2               SAVE THIS LENGTH\n         L     #15,ZLCBIG          GET ADDRESS OF BIGNUM MAKER\n         #BASR #14,#15             CALL ZILBIG\n         LR    #4,#15              SAVE ADDRESS OF NEW BIGNUM\n         LR    #0,#4               DESTINATION ADDRESS\n         L     #14,0(,#11)         SOURCE ADDRESS = arg1\n         LR    #1,#3               DESTINATION LENGTH\n         LR    #15,#3              SOURCE LENGTH\n         MVCL  #0,#14              MOVE OLD BIGNUM TO NEW BIGNUM\n         ST    #0,ZLCVSNXT         UPDATE V/S-SPACE POINTER\n         LR    #15,#4              GET ADDRESS OF BIGNUM AGAIN\n         NI    ##VECDAT(#15),X'7F' TURN OFF SIGN BIT TO MAKE IT PLUS\n******** B     RETURN              Return with (abs bignum)\n         SPACE 1\nRETURN   DS    0H                  VALUE IS IN #15 HERE\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   #ERR  'Argument 1 to HAIPART not an integer - ',0(#11)\nERROR2   #ERR  'Argument 2 to HAIPART not a fixnum - ',4(#11)\n*RROR3   #ERR  'Cannot compute HAIPART of ',0(#11),' and ',4(#11)\n         SPACE 1\nTWOTO31  DC    YL1(##BIGNUM),AL3(8),F'0,1'  Bignum 2147483648\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HAULONG": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x00\\x00\\x88\\x11/\\x00\\x89\\x15o\\x117\\x00\\xaf\\x00[\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1988-04-21T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 175, "newlines": 91, "modlines": 0, "user": "SEB1525"}, "text": "         TITLE 'HAULONG - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* HAULONG takes one integer argument.                                 *\n*                                                                     *\n* Maclisp complete.                                                   *\n*                                                                     *\n* Idiom for (INTEGER-LENGTH (ABS n)) in Common Lisp.                  *\n*                                                                     *\n* Scalar and vector versions.                                         *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILVF\nHAULONG  #ZBEG MINARGS=1,MAXARGS=1,NAME='HAULONG'\n*---------------------------------------------------------------------*\n* Calculate the number of significant bits in the integer.  The       *\n* number of bits up to and including the lefmost \"1\" bit of the       *\n* magnitude of the integer.  This scheme results in the number 0      *\n* having a length of 0.                                               *\n*                                                                     *\n* For bignums, it's the HAULONG of the most significant word, plus 31 *\n* times the number of remaining words.                                *\n*                                                                     *\n* In the scalar version, speed is biased towards the smaller fixnums  *\n* by searching for the leftmost significant bit by searching from     *\n* the right.                                                          *\n*                                                                     *\n* The difference in speed between the vector and scalar versions      *\n* is always marginal on an IBM 3090.  For small fixnums, the scalar   *\n* version is actually a tiny bit faster, due to the bias to small     *\n* numbers, but the vector version should generally be implemented     *\n* for machines that have IBM/370 Vector Facilities because the        *\n* potential speedup of the vector hardware in future products is      *\n* greater than the speedup of the scalar instructions used to do the  *\n* job, which are already fast 1-cycle instructions on the IBM 3090.   *\n*                                                                     *\n* The vector instruction VCZVM does exactly what we want.  We should  *\n* stick to that rather than second-guessing hardware bottlenecks      *\n* and programming around them.  As an example, when going from the    *\n* IBM 3084 to the IBM 3090, the double-shift scalar instructions      *\n* speeded up from about 5 cycles to 1 cycle, while the single-shift   *\n* instructions were the same number of cycles.  Thus, anyone who      *\n* simulated certain uses of double shifts in alternate ways because   *\n* of the slow speed of the double-shift, got screwed and can't get    *\n* the benefit now that the double-shifts are speeded up on the IBM    *\n* 3090.                                                               *\n*---------------------------------------------------------------------*\n         AIF   (&ZILVF).VFIX\n*---------------------------------------------------------------------*\n* Scalar version.  Start here for all cases.                          *\n*---------------------------------------------------------------------*\n         L     #7,0(,#1)           Load argument\n         XR    #5,#5               Clear, need this for many paths\n         CLI   ##TYPE(#7),##FIXNUM Is arg a fixnum?\n         BNE   NF                  Branch if not fixed\n*\nF        L     #6,##CDR(,#7)       Load fixnum\n         LPR   #6,#6               We need only the magnitude\n         BZ    FZ                  Fixnum is zero, no count\n         BO    RET32               It's most neg fixnum, 32 bits\nFPLOOP   SRA   #6,1                Have at least one 1, pop it out\n         LA    #5,8(,#5)           Count by 1 in small fixnum table\n         BNZ   FPLOOP              We have more bits to count\n         LA    #15,#SFT(#5)        Point to correct number in SFT\n         BR    #14                 Return to caller\n*\nFZ       LA    #15,#SFT            Point to 0 in SFT\n         BR    #14                 Return to caller\n*\nRET32    LA    #15,#SFT+8*32       Point to 32 in SFT\n         BR    #14                 Return to caller\n*---------------------------------------------------------------------*\n* Scalar version.  Continue here if not a fixnum.  Note that a faulty *\n* bignum containing a leading 0 word will loop forever at label MORE. *\n*---------------------------------------------------------------------*\nNF       CLI   ##TYPE(#7),##BIGNUM Is arg a bignum?\n         BNE   ERROR1              Branch if not fixed\n         ICM   #5,B'0111',1(#7)    Load bignum length\n         LR    #2,#5               Make extra copy of bignum length\n         L     #6,##VECDAT-4(#5,#7) Get most significant word\n         SRA   #2,2                /4, change bytes to words\n         MH    #2,=H'31'           *31, words to bits, max possible\n         SLA   #6,1                Shift out a bit on the left\n         BO    COUNTED             Most significant bit shifted out\nMORE     SLA   #6,1                Shift out another bit on the right\n         BCTR  #2,0                Decrease count of bits\n         BNO   MORE                More bits need to be examined\nCOUNTED  CL    #2,ZLCSFTHI         Is answer in small fixnum table?\n         BH    FCONS               No?  Must cons up a new fixnum\n         SLL   #2,3                *8 for offset in SFT\n         LA    #15,#SFT(#2)        Calculate small fixnum table addr\n         BR    #14                 Return to caller\n*\nFCONS    LR    #6,#14              Save return address\n         #MKAT FIXED               Cons up a fixnum\n         BR    #6                  Return to caller\n*=====================================================================*\n         AGO   .CONTIN1\n.VFIX    ANOP\n*---------------------------------------------------------------------*\n*  Vector version of HAULONG.                                         *\n*                                                                     *\n*  The vector mask instructions are used to count the zeroes to the   *\n*  left of the leftmost 1 in the fixnum (highest word if bignum)      *\n*  This is then subtracted from the maximum number of bits the        *\n*  word could have contained (highest word for bignum).  (For         *\n*  bignums, the number of bits below the highest word are computed    *\n*  and added to the count.                                            *\n*---------------------------------------------------------------------*\n         L     #7,0(,#1)           Load argument\n         XR    #5,#5               Clear, need this for many paths\n         CLI   ##TYPE(#7),##FIXNUM Is arg a fixnum?\n         VRCL  0                   Clear vector interrupt index\n         BNE   NF                  Branch if not fixed\n*\nF        L     #6,##CDR(,#7)       Load fixnum\n         LPR   #6,#6               We need only the magnitude\n         LA    #4,32               Number of bits to test in vec loop\n         ST    #6,ZLCDBL           Store in temporary for VLVM\n         LA    #6,ZLCDBL           Make pointer to fixnum quantity\n         VLVCU #4                  Set vector count to # of bits\nFPZLOOP  VLVM  #6                  Load a section of bits\n         VCZVM #5                  Count the left contiguous 0-bits\n         VLVCU #4                  Update vector count\n         BC    3,FPZLOOP           More bits?\n         LCR   #5,#5               Take negative, need 32-(#5)\n         SLA   #5,3                Convert to displacement in SFT\n         LA    #15,#SFT+32*8(#5)   Add to address of 32 (total bits)\n         BR    #14                 Return position of leftmost 1\n*---------------------------------------------------------------------*\n* Vector version.  Continue here if not a fixnum.                     *\n*---------------------------------------------------------------------*\nNF       CLI   ##TYPE(#7),##BIGNUM Is arg a bignum?\n         BNE   ERROR1              Branch if not fixed\n         XR    #2,#2               Clear for loading 3-byte length\n         ICM   #2,B'0111',1(#7)    Load bignum length\n         LA    #4,32               Number of bits to examine\n         LR    #3,#2               Save bignum length for later\n         LA    #6,##VECDAT-4(#2,#7) Get most significant word\n         VLVCU #4                  Set vector count to # of bits\nBLOOP    VLVM  #6                  Load a section of bits\n         VCZVM #5                  Count the left contiguous 0-bits\n         VLVCU #4                  Update vector count\n         BC    3,BLOOP             More bits?\n         SRA   #2,2                /4, change bytes to words\n         L     #6,##VECDAT-4(#3,#7) Get most significant word\n         BCTR  #5,0                Don't include bit 0 of VCZVM count\n         MH    #2,=H'31'           *31, words to bits, max possible\n         SLL   #6,2(#5)            Shift out the leftmost 1 to left\n         SLR   #2,#5               Position of leftmost 1 in bignum\nCOUNTED  CL    #2,ZLCSFTHI         Is answer in small fixnum table?\n         BH    FCONS               No?  Must cons up a new fixnum\n         SLA   #2,3                *8 for offset in SFT\n         LA    #15,#SFT(#2)        Small fixnum\n         BR    #14                 Return to caller\n*\nFCONS    LR    #6,#14              Save return address\n         #MKAT FIXED               Cons up a fixnum\n         BR    #6                  Return to caller\n*=====================================================================*\n.CONTIN1 ANOP\n*\n         DROP  #15\n         USING HAULONG,#3\n         SPACE 1\nERROR1   LR    #3,#15\n         #ERR  'Argument to HAULONG not an integer - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFILEP": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x117\\x00 \\x00\\x1d\\x00\\x1f\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 32, "newlines": 29, "modlines": 31, "user": "SEB1525"}, "text": "         TITLE 'IFILEP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* IFILEP TAKES ONE (REQUIRED) ARGUMENT - INPUT FILE SPEC              *\n*                                                                     *\n***********************************************************************\n         SPACE\nIFILEP   #ZBEG MINARGS=1,MAXARGS=1,NAME='IFILEP'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         OI    ZLCERFLG,ZLCERCFA   INDICATE CONDITIONAL FILE ACCESS\n         #IFIL 1                   ARG 1 = INPUT FILE SPEC\n         NI    ZLCERFLG,255-ZLCERCFA TURN CONDITIONAL FILE ACCESS OFF\n         SPACE 1\n         LTR   #7,#7               IF FILE WAS FOUND\n         BZ    FALSE               THEN\n         LR    #15,#8               RETURN T\n         B     RETURN              ELSE\nFALSE    LR    #15,#10              RETURN NIL\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INDEX": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x117\\x00f\\x00c\\x00e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 102, "newlines": 99, "modlines": 101, "user": "SEB1525"}, "text": "         TITLE 'INDEX - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (INDEX ARG1 ARG2 &OPTIONAL ARG3)...                                 *\n*                                                                     *\n*  ARG1 IS A STRING          - THE STRING TO SEARCH WITHIN            *\n*  ARG2 IS A STRING          - THE VALUE TO SEARCH FOR                *\n*  ARG3 IS A FIXNUM OR NIL   - THE STARTING OFFSET FOR THE SEARCH     *\n*                                                                     *\n***********************************************************************\nINDEX    #ZBEG MINARGS=2,MAXARGS=3,NAME='STRING-INDEX'\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #5,#7,0(#11)        LOAD ARGS\n         CLI   ##TYPE(#5),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#5),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #5,##PNAME(,#5)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H                  CHECK ARG 2\n         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING\n         BE    ARG2OK              THEN OK\n         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR2              THEN\n         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR\nARG2OK   DS    0H\n         LA    #2,1                DEFAULT STARTING OFFSET IS 1\n         CR    #7,#10              IF ARG 3 IS NIL\n         BE    ARGSOK              THEN IT'S OK (OMITTED)\n         CR    #7,#13              IF ARG 3 IS NOT SUPPLIED\n         BE    ARGSOK              THEN IT'S OK (OMITTED)\n         CLI   ##TYPE(#7),##FIXNUM IF ARG 3 IS NOT A FIXNUM\n         BNE   ERROR3              THEN ERROR\n         ICM   #2,15,##CDR(#7)     IF ARG3 PROVIDED, USE ITS VALUE\n         BNP   ERROR3\nARGSOK   DS    0H                  #2 HAS 1-BASED START\n         XR    #4,#4\n         XR    #3,#3\n         ICM   #4,7,1(#6)          #4 = LENGTH OF STRING ARG 2\n         BZ    RETZERO             IF ARG2 IS NULL STRING, RETURN 0\n         ICM   #3,7,1(#5)          #3 = LENGTH OF STRING ARG 1\n         BZ    RETNIL              IF ARG1 IS NULL STRING, RETURN NIL\n         CH    #4,=H'256'          IF ARG 2 LENGTH TOO LONG FOR CLC\n         BH    DOCLCL              THEN USE CLCL TO SEARCH\n*                                  ELSE ... CLC LOOP\n         LA    #1,##VECDAT-2(#2,#5) POINT TO STARTING LOC IN ARG1 - 1\n         LA    #14,1               SET BXLE INCREMENT REGISTER\n         LA    #15,##VECDAT(#3,#5) POINT TO END OF STRING ARG 1\n         SR    #15,#4              MINUS LENGTH OF ARG 2\n         BCTR  #4,0                ADJUST ARG2 LENGTH FOR EXECUTE\nCLCLOOP  DS    0H\n         BXH   #1,#14,RETNIL       INCREMENT TO 1ST LOC...\n         EX    #4,CLC              IF SUBSTRING MATCHES...\n         BE    GOTIT               THEN WE HAVE THE OFFSET\n         LA    #2,1(,#2)           ELSE INCREMENT INDEX\n         B     CLCLOOP             AND LOOP UNTIL PAST END OF STRING\n         SPACE 1\nCLC      CLC   0(*-*,#1),##VECDAT(#6)  COMPARE ARG1 SUBTEXT WITH ARG2\n         SPACE 1\nDOCLCL   DS    0H\n         LA    #1,##VECDAT-1(#2,#5) POINT TO STARTING LOC IN ARG1\n         LA    #0,##VECDAT(#3,#5)  POINT TO END OF STRING ARG 1\n         SR    #0,#4               MINUS LENGTH OF ARG 2\n         LR    #7,#4               SAVE LENGTH OF ARG\nCLCLLOOP DS    0H\n         CR    #1,#0               IF PAST END OF SEARCHABLE STRING\n         BH    RETNIL              THEN FAILED - RETURN NIL\n         LR    #4,#1               SUBTEXT OF ARG1\n         LA    #14,##VECDAT(,#6)   TEXT OF ARG2\n         LR    #15,#7              LENGTH OF ARG2\n         LR    #5,#7               TO COMPARE\n         CLCL  #4,#14              IF IT MATCHES\n         BE    GOTIT               THEN WE GOT IT\n         LA    #2,1(,#2)           ELSE INCREMENT INDEX\n         LA    #1,1(,#1)           AND INCREMENT SUBTEXT POINTER\n         B     CLCLLOOP            AND LOOP UNTIL PAST END OF STRING\nGOTIT    DS    0H                  #2 CONTAINS INDEX OF SUBSTRING\n         LA    #0,24(,#11)         PASS CURRENT STACK POINTER TO CONS\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         B     RETURN\nRETZERO  DS    0H                  (INDEX \"FOOBAR\" \"\") ===> 0\n         LA    #15,#SFT0           RETURN FIXNUM 0\n         B     RETURN\nRETNIL   DS    0H                  SUBSCRIPT OUT OF BOUNDS\n         LR    #15,#10             RETURN NIL\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 3\nERROR1   #ERR  'Argument 1 to STRING-INDEX not a string - ',(#5)\nERROR2   #ERR  'Argument 2 to STRING-INDEX not a string - ',(#6)\nERROR3   #ERR  'Argument 3 to STRING-INDEX not a positive fixnum - ',  X\n               (#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTEGERP": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x117\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'INTEGERP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nINTEGERP #ZBEG MINARGS=1,MAXARGS=1,NAME='INTEGERP'\n         SPACE 1\n         USING INTEGERP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##INT    TRUE IF FIXNUM OR BIGNUM\n         BNO   ZXINTN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXINTN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INVOKE": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x05\\x00\\x88\\x01_\\x01\\x00&_\\x11V\\x018\\x016\\x017\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:56:05", "lines": 312, "newlines": 310, "modlines": 311, "user": "SEB1525"}, "text": "         TITLE 'INVOKE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  THIS FUNCTION CALLS A PROGRAM FOUND IN A SYSTEM LIBRARY.  UNLIKE   *\n*  THE TSO FUNCTION, IT DOES NOT REQUIRE A TSO ENVIRONMENT AND CAN    *\n*  THEREFORE BE SUCCESSFULLY EXECUTED FROM BATCH MODE.  SYNTAX IS:    *\n*  (INVOKE \"PROGRAM\" \"PARAMETERS\")                                    *\n*  WHERE \"PROGRAM\" IS A REQUIRED STRING (OR SYMBOL) AND               *\n*        \"PARAMETERS\" IS A REQUIRED STRING (OR NIL).                  *\n*  NOTE: THE OPTIONAL PARAMETER ARG MUST BE A STRING; OTHERWISE       *\n*        NIL WOULD BE PASSED AS A PARAMETER OF NIL.                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nINVOKE   #ZBEG MINARGS=1,MAXARGS=2,NAME='INVOKE'\n         #ZPDS 20\n         #ZSAV ,\n         SPACE 1\n         LM    #6,#7,0(#11)        GET ARGS\n         CLI   ##TYPE(#6),##STRING ARG1 MUST BE A STRING\n         BE    ARG1OK               OR\n         CLI   ##TYPE(#6),##SYMBOL   A SYMBOL\n         BNE   ERROR1                 ELSE ERROR\n         L     #6,##PNAME(,#6)         (IF A SYMBOL, TAKE PRINT NAME)\nARG1OK   DS    0H\n         CR    #7,#10              ARG2 MUST BE NIL\n         BE    SETNULL              OR\n         CR    #7,#13                NOT SUPPLIED\n         BE    SETNULL                OR\n         CLI   ##TYPE(#7),##STRING     A STRING\n         BNE   ERROR2\n         B     ARG2OK\nSETNULL  DS    0H                  IF ARG2 IS NIL\n         LA    #7,NULLSTR           THEN USE NULL STRING\nARG2OK   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* GET THE NAME OF THE PROGRAM AND VALIDATE IT                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVI   PROGRAM,C' '        CLEAR PROGRAM NAME TO BLANKS\n         MVC   PROGRAM+1(7),PROGRAM\n         XR    #15,#15\n         ICM   #15,7,1(#6)         GET LENGTH OF ARG1 STRING TEXT\n         BNP   ERROR3\n         CH    #15,=H'8'           LENGTH MUST BE BETWEEN 1 AND 8\n         BH    ERROR3\n         BCTR  #15,0               MOVE STRING TO PROGRAM NAME,\n         EX    #15,MVCPGM          TRANSLATING IT TO UPPER CASE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* GET THE PARAMETER STRING AND VALIDATE IT                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVI   PARM,C' '           CLEAR PARAMETER STRING TO BLANKS\n         MVC   PARM+1(L'PARM-1),PARM\n         XR    #15,#15\n         ICM   #15,7,1(#7)         GET LENGTH OF ARG2 STRING TEXT\n         STH   #15,PARMLEN         STORE PARAMETER STRING LENGTH\n         BZ    NOPARM\n         CH    #15,=H'100'         LENGTH MUST BE BETWEEN 0 AND 100\n         BH    ERROR4\n         BCTR  #15,0               MOVE STRING TO PARAMETER FIELD,\n         EX    #15,MVCPARM         TRANSLATING IT TO UPPER CASE\nNOPARM   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* CHECK TO MAKE SURE THAT THE PROGRAM REALLY EXISTS                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FIRST, SCAN THE LPA DIRECTORY TO SEE IF IT IS AN LPA MODULE.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         STM   #3,#9,32(#13)       SAVE REGS USED BY LPA SEARCH\n         LM    #0,#1,PROGRAM       GET PROGRAM NAME INTO REGS\n         L     #3,16               #3 -> CVT\n         L     #15,X'160'(,#3)     #15 -> LPA DIRECTORY SEARCH ROUTINE\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL-CODE RUNNING\n         #BASR #14,#15             CALL LPA DIRECTORY SEARCH\n*\n* IF THE PROGRAM NAME IS FOUND IN THE LPA DIRECTORY, CONTROL RETURNS\n* TO THE NEXT SEQUENTIAL INSTRUCTION AND #14 IS SET TO ZERO.\n* IF THE PROGRAM NAME HAS NOT BEEN FOUND, CONTROL RETURNS TO THE\n* INSTRUCTION AT +4 PAST HERE AND #14 IS NONZERO.\n*\n         LA    #14,0               IF SUCCESSFUL, SET #14 = 0\n         LM    #3,#9,32(#13)       RESTORE REGS USED BY LPA SEARCH\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\n         NI    ZLCIFLGS,255-ZLCISYS INDICATE ZIL CODE RUNNING AGAIN\n         LTR   #14,#14             IF PROGRAM NAME WAS FOUND,\n         BZ    DOIT                THEN GO AHEAD AND INVOKE IT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF IT IS NOT IN THE LPA, CHECK THE LINKLIST TO SEE IF IT IS THERE.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   ERRMSG5P(8),PROGRAM\n         BLDL  0,BLDLLIST          SEE IF MEMBER IS IN LINK LIST\n         LTR   #15,#15             IF NOT,\n         BNZ   ERROR5               ERROR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* NOW INVOKE THE PROGRAM                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n         MVC   ERRMSG7P(8),PROGRAM\n         MVC   ERRMSG8P(8),PROGRAM\n         XC    ABCODE,ABCODE       CLEAR ABEND CODE\n         XC    REASCODE,REASCODE   CLEAR REASON CODE\n         XC    ZLCECB,ZLCECB       CLEAR ATTACH ECB\n         LA    #1,PARMADDR\n         LA    #3,ZLCECB\n         ATTACH EPLOC=PROGRAM,ECB=(#3),SZERO=NO,SHSPV=78,              X\n               ESTAI=(STAIEXIT,STAIPARM)\n         LTR   #15,#15\n         BNZ   ERROR7\n         ST    #1,ATCHTCB          SAVE TCB ADDRESS\n         LR    #3,#1               SAVE TCB ADDRESS\n         WAIT  ECB=ZLCECB          WAIT FOR PROGRAM TO COMPLETE\n         XR    #2,#2\n         ICM   #2,7,17(#3)         GET PROGRAM RETURN CODE FROM TCB\n         LA    #1,ATCHTCB\n         DETACH (1),STAE=YES\n         CH    #15,=H'4'\n         BH    ERROR8\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SEE IF PROGRAM ABENDED AND ISSUE A MESSAGE IF SO.                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   #3,15,ABCODE\n         BZ    NOABEND\n         MVC   ABPGM,PROGRAM\n         ST    #3,ZLCDBL\n         UNPK  ABHEX(9),ZLCDBL(5)\n         TR    ABHEX(8),HEXTBL\n         MVI   ABPERIOD,C'.'\n         #TPUT ABMSG\n         LR    #15,#10             RETURN NIL IF PROGRAM ABENDED\n         B     RETURN\nNOABEND  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* NOW SET THE RETURN VALUE TO A FIXNUM CONTAINING THE RETURN CODE     *\n* WHICH IS ALREADY IN #2                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM OUT OF THE RETURN CODE\nRETURN   DS    0H\n         #ZRET ,\n         EJECT\nMVCPGM   OC    PROGRAM(*-*),##VECDAT(#6) EXECUTED: MOVE PROGRAM NAME\nMVCPARM  OC    PARM(*-*),##VECDAT(#7)    EXECUTED: MOVE PARM STRING\n         SPACE 1\nATCHTCB  DS    A                   TCB FOR ATTACHED PROGRAM\n         SPACE 1\nNULLSTR  DS    0A                  ALIGN STRING TO FULLWORD\n         DC    YL1(##STRING),AL3(0),X'00'  NULL STRING\n         SPACE 1\n         DS    0A                  ALIGN BLDL STUFF\nBLDLLIST DC    H'1',H'58'          BLDL LIST FOR PROGRAM NAME\nPROGRAM  DS    CL8                 THE PROGRAM NAME\nTTR      DS    CL3\nK        DS    CL1\nZ        DS    CL1\nC        DS    CL1\n         DS    CL44\nPARMADDR DC    A(X'80000000'+PARMLEN)\nPARMLEN  DS    H\nPARM     DS    CL100\n         SPACE 1\nERROR1   #ERR  'Argument 1 to INVOKE not a string or symbol - ',0(#11)\nERROR2   #ERR  'Argument 2 to INVOKE not a string or NIL - ',4(#11)\nERROR3   #ERR  'Argument 1 to INVOKE not a valid program name - ',     X\n               0(#11)\nERROR4   #ERR  'Argument 2 to INVOKE longer than 100 characters, the maX\n               ximum permitted by MVS - ',4(#11)\nERROR5   #TPUT 2,ERRMSG5\n         #ERR  'System program named ',0(#11),' does not exist.'\nERROR7   #TPUT ERRMSG7\n         B     FAILURE7\nERROR8   #TPUT ERRMSG8\n         B     FAILURE8\nFAILURE7 DS    0H\nFAILURE8 DS    0H\nFAILURE  #ERR  'INVOKE failed, system error processing program ',0(#11)\n         SPACE 1\nERRMSG5X DC    C'ZIL1501 PROGRAM '\nERRMSG5P DC    CL8'        '\n         DC    C' NOT FOUND IN SYSTEM LIBRARY.'\nERRMSG5  EQU   ERRMSG5X,*-ERRMSG5X,C'C'\nERRMSG7X DC    C'ZIL1502 ATTACH OF PROGRAM '\nERRMSG7P DC    CL8'        '\n         DC    C' FAILED.'\nERRMSG7  EQU   ERRMSG7X,*-ERRMSG7X,C'C'\nERRMSG8X DC    C'ZIL1503 DETACH OF PROGRAM '\nERRMSG8P DC    CL8'        '\n         DC    C' FAILED.'\nERRMSG8  EQU   ERRMSG8X,*-ERRMSG8X,C'C'\n         SPACE 1\nABMSGX   DC    C'ZIL1500 '\nABPGM    DC    CL8' '\n         DC    C' ABENDED, COMPLETION CODE '\nABHEX    DC    CL8' '\nABPERIOD DC    C' '\nABMSG    EQU   ABMSGX,*-ABMSGX,C'C'\n         SPACE 1\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         SPACE 1\n         LTORG\n         SPACE 1\nSTAIPARM DS    0H\n         SPACE 1\nABCODE   DS    A\nREASCODE DS    A\n         SPACE 1\n         DROP  #12\n         EJECT\n***********************************************************************\n*                                                                     *\n* STAI EXIT THAT GETS CONTROL IF THE ATTACHED PROGRAM ABENDS          *\n*                                                                     *\n* THE PARAMETER ON ENTRY SHOULD BE THE ADDRESS OF THE ZIL COMMON AREA *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSTAIEXIT DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ESTAI EXIT THAT GETS CONTROL IF AN ABEND OCCURS IN ATTACHED PROGRAM *\n*                                                                     *\n*  ON ENTRY TO THIS ROUTINE:                                          *\n*                                                                     *\n*  REGISTER 0 = 12 - NO SWDA AVAILABLE                                *\n*               OTHER - SDWA AVAILABLE                                *\n*                                                                     *\n*  IF REGISTER 0 = 12:                                                *\n*                                                                     *\n*     REGISTER 1  = ABEND COMPLETION CODE                             *\n*     REGISTER 2  = ADDRESS OF THE ESTAE PARAMETER LIST (PARAM)       *\n*     REGISTER 14 = RETURN ADDRESS TO RTM                             *\n*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *\n*                                                                     *\n*  OTHERWISE:                                                         *\n*                                                                     *\n*     REGISTER 1  = ADDRESS OF THE SDWA                               *\n*     REGISTER 13 = ADDRESS OF A 72-BYTE SAVE AREA                    *\n*     REGISTER 14 = RETURN ADDRESS TO RTM                             *\n*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         PUSH  USING\n         LR    #7,#15              SAVE ENTRY ADDRESS REGISTER\n         USING STAIEXIT,#7\n         LA    #3,12               CHECK IF REGISTER 0 = 12\n         CR    #0,#3               IF AN SDWA IS AVAILABLE\n         BE    NOSDWAI             THEN...\n         USING SDWA,#1\n         L     #4,SDWAPARM          #4 -> WORKAREA\n         XR    #5,#5\n         ICM   #5,7,SDWACMPC        #5 = COMPLETION CODE\n         ST    #5,ABCODE-STAIPARM(,#4)   SAVE ABEND CODE\n         L     #6,SDWAGR15          #6 = REASON CODE FROM ABEND MACRO\n         ST    #6,REASCODE-STAIPARM(,#4) STORE REASON CODE\n         SETRP RC=16               LET ABEND CONTINUE WITHOUT ESTAI\n         BR    #14                 RETURN TO ABNORMAL TERMINATION\n         SPACE 1\nNOSDWAI  DS    0H                  NO SDWA AVAILABLE...\n         LR    #4,#2                #4 -> WORKAREA\n         LR    #5,#1                #5 = COMPLETION CODE\n         ST    #5,ABCODE-STAIPARM(,#4)   SAVE ABEND CODE\n         XR    #6,#6                #6 = REASON CODE ZERO (UNKNOWN)\n         ST    #6,REASCODE-STAIPARM(,#4) STORE REASON CODE\n         LA    #15,16              LET ABEND CONTINUE WITHOUT ESTAI\n         BR    #14                 RETURN TO ABNORMAL TERMINATION\n         POP   USING\n         EJECT\n         IHASDWA\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPFP": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x117\\x00,\\x00)\\x00+\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 44, "newlines": 41, "modlines": 43, "user": "SEB1525"}, "text": "         TITLE 'ISPFP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ISPFP RETURNS T IF IT IS POSSIBLE TO INVOKE ISPF DIALOG SERVICES,   *\n* AND NIL IF IT ISN'T.  THIS CODE IS LARGELY STOLEN FROM THE IBM CODE *\n* IN ISPLINK.                                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nISPFP    #ZBEG MINARGS=0,MAXARGS=0,NAME='ISPFP'\n         SPACE 1\n         L     #1,540              Get TCB address\nTRYIT    DS    0H                  See if this TCB belongs to ISPF\n         ICM   #2,15,X'70'(#1)     Get TCBFSA - first save area\n         BZ    NOPE                If zero, not this one\n         CLI   24(#2),X'00'        If saved reg 1 is a 31-bit address\n         BNE   NOPE                then not this one\n         ICM   #2,15,24(#2)        Get saved reg 1 from save area\n         BZ    NOPE                If zero, not this one\n         CLI   0(#2),X'00'         If it's a 31-bit pointer\n         BNE   NOPE                then not this one\n         L     #2,0(,#2)           Else load where reg1 points to\n         CLC   0(3,#2),=CL3'TLD'   See if it's the TLD\n         BE    TRUE                If it is, success\nNOPE     DS    0H                  Else not this TCB...\n         L     #1,X'84'(,#1)       Get TCBOTC - mother task TCB\n         C     #1,X'7C'(,#1)       Compare with TCBJSTCB - job step TCB\n         BNE   TRYIT               If not it, try again with this TCB\n*                                  Else job step TCB - no more TCB's\n         SPACE 1\nFALSE    LR    #15,#10             ISPEXEC is not possible, return NIL\n         BR    #14\n         SPACE 1\nTRUE     LR    #15,#8              ISPEXEC is possible, return T\n         BR    #14\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "KEYWORDP": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x117\\x00\"\\x00 \\x00!\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 34, "newlines": 32, "modlines": 33, "user": "SEB1525"}, "text": "         TITLE 'KEYWORDP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This is a hack for a non-package implementation.  It returns true   *\n* if the symbol's print name begins with a colon.  The right way to   *\n* implement this is to check the package cell of the symbol; if it    *\n* points to the keyword package, the symbol is KEYWORDP.  You'll just *\n* have to wait for packages to be implemented for this to happen.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nKEYWORDP #ZBEG MINARGS=1,MAXARGS=1,NAME='KEYWORDP'\n         SPACE 1\n         USING KEYWORDP,#15\n         SPACE 1\n         L     #2,0(,#1)           GET ARG\n         CLI   ##TYPE(#2),##SYMBOL MUST BE A SYMBOL\n         BNE   FALSE               IF NOT, CAN'T BE A KEYWORD\n         L     #2,##PNAME(,#2)     GET ITS PRINT NAME\n         CLI   ##VECDAT(#2),C':'   FIRST CHAR MUST BE A COLON\n         BNE   FALSE               IF NOT, NOT A KEYWORD\n         DROP  #15\n         LR    #15,#8              TRUE - IT IS A KEYWORD\n         BR    #14\nFALSE    LR    #15,#10             FALSE - IT IS NOT A KEYWORD\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LAND": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x117\\x00#\\x00 \\x00\"\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 35, "newlines": 32, "modlines": 34, "user": "SEB1525"}, "text": "         TITLE 'LAND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* LAND TAKES TWO INTEGER ARGUMENTS.  CURRENTLY THEY MUST BE FIXNUMS.\n*\nLAND     #ZBEG MINARGS=2,MAXARGS=2,NAME='LAND'\n         #ZPDS 2*4+12+0 (= 20)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##FIXNUM FIRST ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#7),##FIXNUM SECOND ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR2\n         LM    #1,#2,##CAR(#6)     GET HEADER AND VALUE 1\n         N     #2,##CDR(,#7)       DO LOGICAL AND WITH VALUE 2\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL CONS TO MAKE A NEW FIXNUM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument 1 to logical AND not a fixnum - ',(#6)\nERROR2   #ERR  'Argument 2 to logical AND not a fixnum - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LAST": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x117\\x00&\\x00#\\x00%\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:37:00", "lines": 38, "newlines": 35, "modlines": 37, "user": "SEB1525"}, "text": "         TITLE 'LAST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LAST TAKES ONE ARGUMENT - A LIST.                                   *\n*                                                                     *\n* THIS FUNCTION IS NON-RECURSIVE AND TAKES NO STACK SPACE.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nLAST     #ZBEG MINARGS=1,MAXARGS=1,NAME='LAST'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING LAST,#3\n         SPACE 1\n         L     #15,0(,#1)          LOAD THE ARGUMENT\n* Null test subsumed by atom test.\n******** CR    #15,#10             IF ARG IS NIL\n******** BER   #14                 THEN RETURN NIL\n         TM    ##TYPE(#15),##ATOM  IF ARG 1 NOT A LIST\n         BOR   #14                 THEN RETURN IT\nLOOP     DS    0H\n         L     #2,##CDR(,#15)      LOOK AT THE CDR OF THE LIST\n* Null test subsumed by atom test.\n******** CR    #2,#10              IF IT IS NIL\n******** BER   #14                 THEN RETURN THIS CONS\n         TM    ##TYPE(#2),##ATOM   IF IT IS ATOMIC\n         BOR   #14                 THEN RETURN THIS CONS\n         LR    #15,#2              ELSE CONTINUE WITH THE CDR\n         B     LOOP\n         SPACE\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LASTCAR": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x00%\\x00\"\\x00$\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 37, "newlines": 34, "modlines": 36, "user": "SEB1525"}, "text": "         TITLE 'LASTCAR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LASTCAR TAKES ONE ARGUMENT - A LIST.                                *\n*                                                                     *\n* THIS FUNCTION IS NON-RECURSIVE AND TAKES NO STACK SPACE.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nLASTCAR  #ZBEG MINARGS=1,MAXARGS=1,NAME='LASTCAR'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING LASTCAR,#3\n         SPACE 1\n         L     #15,0(,#1)          LOAD THE ARGUMENT\n* Null test subsumed by atom test.\n******** CR    #15,#10             IF ARG IS NIL\n******** BER   #14                 THEN RETURN NIL\n         TM    ##TYPE(#15),##ATOM  IF ARG 1 NOT A LIST\n         BOR   #14                 THEN RETURN IT\nLOOP     DS    0H\n         LM    #15,#0,##CAR(#15)   #15 = CAR, #0 = CDR\n         CR    #0,#10              IF CDR IS NIL\n         BER   #14                 THEN RETURN #15 = CAR OF THIS CONS\n         LR    #15,#0              ELSE LOAD UP THE CDR\n         TM    ##TYPE(#15),##ATOM  IF IT IS ATOMIC\n         BOR   #14                 THEN RETURN IT AS THE VALUE\n         B     LOOP                ELSE CONTINUE WITH THE CDR\n         SPACE\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LENGTH": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x002\\x00/\\x001\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 50, "newlines": 47, "modlines": 49, "user": "SEB1525"}, "text": "         TITLE 'LENGTH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LENGTH TAKES ONE ARGUMENT - A PROPER LIST                           *\n*                                                                     *\n* IF THE LIST IS CIRCULAR LENGTH WILL LOOP INDEFINITELY.              *\n*                                                                     *\n* We assume that a list cannot be longer than 2147483647 elements,    *\n* and therefore that fixed-point overflow is impossible.  This        *\n* allows us to use BCT to compute the length (clever, eh?).           *\n*                                                                     *\n***********************************************************************\nLENGTH   #ZBEG MINARGS=1,MAXARGS=1,NAME='LENGTH'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ARGS=1              SAVE REGISTERS\n         SPACE\n         L     #3,0(,#11)          LOAD FIRST (AND ONLY) ARGUMENT\n         XR    #2,#2               INITIALIZE (MINUS LENGTH) TO ZERO\n         SPACE\nLOOP     DS    0H\n         CR    #3,#10              WHEN NIL FOUND, EXIT LOOP\n         BE    ENDLOOP\n         TM    ##TYPE(#3),##ATOM   IF ATOM OR DOTTED PAIR\n         BO    ERROR               THEN INVALID LIST\n         L     #3,##CDR(,#3)       (SETQ LIST (CDR LIST))\n         BCT   #2,LOOP             CONTINUE\nENDLOOP  DS    0H                  #2 contains (minus length)\n         LCR   #2,#2               Make length positive\n         CL    #2,ZLCSFTHI         If length within small fixnum range\n         BNH   SMALLFIX            then go return a small fixnum\n*                                  Else must cons up a fixnum\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN               and return with it\nSMALLFIX DS    0H                  Length is within small fixnum range\n         SLA   #2,3                Convert length to index into fixnums\n         LA    #15,#SFT(#2)        Get fixnum from table\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR    DS    0H                  NOT A NUMERIC ATOM\n         #ERR  'Argument to LENGTH not a proper list - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LESSP": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x01t\\x01q\\x01s\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 372, "newlines": 369, "modlines": 371, "user": "SEB1525"}, "text": "         TITLE 'LESSP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LESSP TAKES TWO ARGUMENTS. BOTH MUST BE NUMERIC OR ALPHA ATOMS.     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO STACK SPACE.              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS:                                    *\n*                                                                     *\n* 1. BOTH ARGS FIXED         - PERFORM INTEGER COMPARISON.            *\n* 2. BOTH ARGS FLOAT         - PERFORM REAL COMPARISON.               *\n* 3. ONE FIXED, ONE FLOAT    - CONVERT THE FIXED ARGUMENT TO          *\n*                              FLOAT AND PERFORM REAL COMPARISON.     *\n* 4. BOTH ARGS ALPHA         - PERFORM CHARACTER COMPARISON.          *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ===> BIGNUM - FLOAT COMPARISON NOT YET IMPLEMENTED                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SUPPORT FOR STRING AND SYMBOL COMPARES.  THE FOLLOWING COMPARISONS  *\n*            ARE LEGAL:                                               *\n*                                                                     *\n*  SYMBOL TO SYMBOL                                                   *\n*  STRING TO STRING                                                   *\n*  SYMBOL TO STRING                                                   *\n*  STRING TO SYMBOL                                                   *\n*                                                                     *\n* ALL MAY BE REMOVED FOR FULL COMMON LISP.                            *\n*                                                                     *\n***********************************************************************\nLESSP    #ZBEG MINARGS=2,MAXARGS=2,NAME='LESSP'\n         SPACE\n         LR    #3,#15\n         DROP  #15\n         USING LESSP,#3\n         SPACE\n         LM    #1,#2,0(#1)         LOAD ARGUMENTS\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         CR    #1,#2               IF ARGS ARE \"EQ\"\n         BER   #14                 THEN RETURN NIL\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#1),##FIXNUM\n         BE    ARG1FIX\n         CLI   ##TYPE(#1),##SFLOAT\n         BE    ARG1SFLO\n         CLI   ##TYPE(#1),##BIGNUM\n         BE    ARG1BIG\n         CLI   ##TYPE(#1),##DFLOAT\n         BE    ARG1DFLO\n*\n* --- DELETE THIS CODE FOR FULL COMMON LISP\n*\n         CLI   ##TYPE(#1),##STRING\n         BE    ARG1STR\n         CLI   ##TYPE(#1),##SYMBOL\n         BE    ARG1ALF\n*\n* --- END CODE TO DELETE FOR FULL COMMON LISP\n*\n         B     ERROR\n         EJECT\nARG1FIX  DS    0H                  ARG 1 IS FIXED\n         SPACE\n         L     #0,##CDR(,#1)       GET FIXED VALUE 1\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    CFIXFIX             FIXED - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    CFIXBIG             FIXED - BIG   = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    CFIXSFLO            FIXED - FLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    CFIXDFLO            FIXED - FLOAT = OK\n         B     ERROR               ANYTHING ELSE = ERROR\nCFIXSFLO DS    0H                  FIXED VALUE 1 ALREADY IN #0\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LRER  #F2,#F0             GET SINGLE FLOAT VALUE 1\n         B     COMSFLO1\n         SPACE\nCFIXDFLO DS    0H                  FIXED VALUE 1 ALREADY IN #0\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LDR   #F2,#F0             GET DOUBLE FLOAT VALUE 1\n         B     COMDFLO1\n         SPACE\nCFIXFIX  DS    0H                  GOOD FOR FIXNUMS\n         C     #0,##CDR(,#2)       COMPARE\n         BNLR  #14\n         LR    #15,#8\n         BR    #14\n         SPACE\nARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    SFLOSFLO            SFLOAT - SFLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    SFLODFLO            SFLOAT - DFLOAT = OK\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    SFLOFIX             FLOAT - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    SFLOBIG             FLOAT - BIG   = OK\n         B     ERROR               FLOAT - NONUM = ERROR\nSFLOFIX  DS    0H\n         LE    #F2,##CDR(,#1)      GET SINGLE FLOAT VALUE 1\n         L     #0,##CDR(,#2)       GET FIXED VALUE 2\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LRER  #F4,#F0             GET SINGLE FLOAT VALUE 2\n         B     COMSFLO2\n         SPACE\nSFLODFLO DS    0H                  SINGLE FLOAT 1, DOUBLE FLOAT 2\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#1)      GET DOUBLE FLOAT VALUE 1\n         B     COMDFLO1\nSFLOSFLO DS    0H                  SINGLE FLOAT 1, SINGLE FLOAT 2\n         LE    #F2,##CDR(,#1)      GET FLOAT VALUE 1\nCOMSFLO1 DS    0H\n         LE    #F4,##CDR(,#2)      GET SINGLE FLOAT VALUE 1\nCOMSFLO2 DS    0H\n         CER   #F2,#F4             COMPARE\n         BNLR  #14\n         LR    #15,#8\n         BR    #14\n         EJECT\nARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F2,8(,#1)          GET DOUBLE FLOAT VALUE 1\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    DFLODFLO            DFLOAT - DFLOAT = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    DFLOSFLO            DFLOAT - SFLOAT = OK\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    DFLOFIX             FLOAT - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    DFLOBIG             FLOAT - BIG   = OK\n         B     ERROR               FLOAT - NONUM = ERROR\nDFLOFIX  DS    0H\n         L     #0,##CDR(,#2)       GET FIXED VALUE 2\n         LR    #7,#14              SAVE RETURN REGISTER\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN REGISTER\n         LDR   #F4,#F0             GET DOUBLE FLOAT VALUE 2\n         B     COMDFLO2\n         SPACE\nDFLOSFLO DS    0H                  DOUBLE FLOAT 1, SINGLE FLOAT 2\n         SDR   #F4,#F4\n         LE    #F4,##CDR(,#2)      GET DOUBLE FLOAT VALUE 2\n         B     COMDFLO2\nDFLODFLO DS    0H                  DOUBLE FLOAT 1, DOUBLE FLOAT 2\nCOMDFLO1 DS    0H\n         LD    #F4,8(,#2)          GET DOUBLE FLOAT VALUE 1\nCOMDFLO2 DS    0H\n         CDR   #F2,#F4             COMPARE\n         BNLR  #14\n         LR    #15,#8\n         BR    #14\n         EJECT\nARG1BIG  DS    0H                  ARG1 IS A BIGNUM\n         SPACE\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    CBIGFIX             FIXED - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    CBIGBIG             FIXED - BIG   = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    CBIGSFLO            FIXED - FLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    CBIGDFLO            FIXED - FLOAT = OK\n         B     ERROR               ANYTHING ELSE = ERROR\n         SPACE\nCFIXBIG  DS    0H                  COMPARE FIXNUM TO BIGNUM\n         SPACE\n         TM    ##VECDAT(#2),X'80'  TEST SIGN OF BIGNUM\n         BOR   #14                 IF BIGNUM NEGATIVE, FIX NOT LT BIG\n         LR    #15,#8              IF BIGNUM POSITIVE, FIX IS LT BIG\n         BR    #14                  SO RETURN T\n         SPACE\nCBIGFIX  DS    0H                  COMPARE BIGNUM TO FIXNUM\n         SPACE\n         TM    ##VECDAT(#1),X'80'  TEST SIGN OF BIGNUM\n         BZR   #14                 IF BIGNUM POSITIVE, BIG NOT LT FIX\n         LR    #15,#8              IF BIGNUM NEGATIVE, BIG IS LT FIX\n         BR    #14                  SO RETURN T\n         EJECT\nCBIGBIG  DS    0H                  COMPARE BIGNUM TO BIGNUM\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THE FOLLOWING CODE DEPENDS ON THESE FACTS:                          *\n*                                                                     *\n*  (1) ALL BIGNUMS ARE NORMALIZED.                                    *\n*  (2) BIGNUMS ARE STORED IN 31-BIT \"DIGITS\", EACH DIGIT OCCUPYING A  *\n*      WORD, WITH THE LEAST SIGNIFICANT WORD LEFTMOST.  I.E. THE      *\n*      BIGNUM \"DIGITS\" ARE STORED \"BACKWARDS\".                        *\n*  (3) NEGATIVE BIGNUMS ARE STORED AS THEIR ABSOLUTE VALUE, EXCEPT    *\n*      THAT THE LEAST SIGNIFICANT (LEFTMOST) WORD HAS THE HIGH-ORDER  *\n*      BIT SET TO 1 (BUT IT IS NOT TWO'S COMPLEMENT).                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   #4,15,##VECDAT(#1)  TEST SIGN OF BIGNUM 1\n         BM    B1NEG               IF BIGNUM 1 NEGATIVE, CHECK BIG# 2\n         TM    ##VECDAT(#2),X'80'  BIG 1 IS POSITIVE.  SO...\n         BOR   #14                 IF BIGNUM 2 NEGATIVE, RETURN FALSE\n*                                  ELSE COMPARE 2 POSITIVE BIGNUMS\n         XR    #5,#5               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#1)          GET BIGNUM LENGTH 1\n         ICM   #7,7,1(#2)          GET BIGNUM LENGTH 2\n         CR    #5,#7               COMPARE LENGTHS\n         BHR   #14                 IF FIRST IS LONGER, B1 > B2\n         BL    TRUE                IF FIRST IS SHORTER, B1 < B2\n         LA    #7,4                OTHERWISE WE HAVE TO COMPARE THEM.\n         LCR   #7,#7               SET INCREMENT REGISTER TO -4\n         AR    #5,#7               INIT INDEX TO BIGNUM LENGTH - 4\nBBPLOOP  DS    0H                  LOOP FROM LAST WORD THRU TO FIRST\n         L     #0,##VECDAT(#5,#1)  COMPARE WORD FROM BIGNUM 1\n         C     #0,##VECDAT(#5,#2)  WITH WORD FROM BIGNUM 2\n         BHR   #14                 IF GREATER, B1 > B2\n         BL    TRUE                IF LESS, B1 < B2\n         BXH   #5,#7,BBPLOOP       =, DECREMENT INDEX AND LOOP UNTIL...\n         BR    #14                 NO MORE WORDS: ALL =, B1 NOT GT B2\n         SPACE\nB1NEG    DS    0H                  BIGNUM 1 IS NEGATIVE\n         ICM   #6,15,##VECDAT(#2)  IF BIGNUM 2 IS POSITIVE\n         BNM   TRUE                THEN RETURN TRUE. ELSE...\n*                                  COMPARE 2 NEGATIVE BIGNUMS\n         XR    #5,#5               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#1)          GET BIGNUM LENGTH 1\n         ICM   #7,7,1(#2)          GET BIGNUM LENGTH 2\n         CR    #5,#7               COMPARE LENGTHS\n         BLR   #14                 IF FIRST IS LONGER, B1 < B2\n         BH    TRUE                IF FIRST IS SHORTER, B1 > B2\n         LA    #7,4                OTHERWISE WE HAVE TO COMPARE THEM.\n         LCR   #7,#7               SET INCREMENT REGISTER TO -4\n         AR    #5,#7               INIT INDEX TO BIGNUM LENGTH - 4\nBBNLOOP  DS    0H                  LOOP FROM LAST WORD THRU TO FIRST\n         L     #0,##VECDAT(#5,#1)  COMPARE WORD FROM BIGNUM 1\n         CL    #0,##VECDAT(#5,#2)  WITH WORD FROM B2 (IGNORE SIGN BIT)\n         BLR   #14                 IF LESS, B1 > B2\n         BH    TRUE                IF GREATER, B1 < B2\n         BXH   #5,#7,BBNLOOP       =, DECREMENT INDEX AND LOOP UNTIL...\n         BR    #14                 NO MORE WORDS: ALL =, B1 NOT GT B2\n         SPACE 1\nTRUE     DS    0H\n         LR    #15,#8              TRUE... RESULT IS T\n         BR    #14\n         EJECT\n*\n* --- DELETE THIS CODE FOR FULL COMMON LISP\n*\nARG1STR  DS    0H                  ARG 1 IS STRING\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##STRING\n         BE    COMPSS              STRING - STRING IS OK\n         CLI   ##TYPE(#2),##SYMBOL\n         BE    COMPSA              STRING - SYMBOL IS OK\n         B     ERROR               ALL OTHERS ARE NO GOOD\n         SPACE\nARG1ALF  DS    0H                  ARG 1 IS SYMBOL\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##STRING\n         BE    COMPAS              SYMBOL - STRING IS OK\n         CLI   ##TYPE(#2),##SYMBOL\n         BE    COMPAA              SYMBOL - SYMBOL IS OK\n         B     ERROR               ALL OTHERS ARE NO GOOD\n         SPACE\nCOMPAS   DS    0H                  SYMBOL-TO-STRING COMPARE\n         L     #1,##PNAME(,#1)     GET PRINT NAME OF SYMBOL 1\n         B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPSA   DS    0H                  STRING-TO-SYMBOL COMPARE\n         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL 2\n         B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPAA   DS    0H                  SYMBOL-TO-SYMBOL COMPARE\n         L     #1,##PNAME(,#1)     GET PRINT NAME OF SYMBOL 1\n         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL 2\n******** B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPSS   DS    0H                  STRING-TO-STRING COMPARE\n         SPACE 1\n         XR    #5,#5               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#1)          GET STRING LENGTH 1\n         ICM   #7,7,1(#2)          GET STRING LENGTH 2\n         LA    #4,##VECDAT(,#1)    POINT TO STRING TEXT 1\n         LA    #6,##VECDAT(,#2)    POINT TO STRING TEXT 2\n*\n*                                  #4 = ADDRESS OF ARG 1 DATA\n*                                  #5 = LENGTH OF ARG 1 DATA\n*                                  #6 = ADDRESS OF ARG 2 DATA\n*                                  #7 = LENGTH OF ARG 2 DATA\n*\n         CR    #5,#7               COMPARE LENGTHS\n         BL    SHORTCOM            IF FIRST IS SHORTER, GO HANDLE THAT\n         BH    LONGCOM             IF FIRST IS LONGER, GO HANDLE THAT\n         CLCL  #4,#6               OTHERWISE JUST DO COMPARE\n         BNLR  #14                 ARG1 GE ARG2: RETURN NIL\n         LR    #15,#8              ARG1 LT ARG2: RETURN T\n         BR    #14\n         SPACE 1\nSHORTCOM DS    0H                  ARG1 SHORTER THAN ARG2\n         LR    #7,#5               USE SHORT LENGTH FOR COMPARE\n         CLCL  #4,#6               DO COMPARE\n         BHR   #14                 ARG1 GT ARG2: RETURN NIL\n         LR    #15,#8              ARG1 LE ARG2: RETURN T\n         BR    #14\n         SPACE 1\nLONGCOM  DS    0H                  ARG1 LONGER THAN ARG2\n         LR    #5,#7               USE SHORT LENGTH FOR COMPARE\n         CLCL  #4,#6               DO COMPARE\n         BNLR  #14                 ARG1 GE ARG2: RETURN NIL\n         LR    #15,#8              ARG1 LT ARG2: RETURN T\n         BR    #14\n*\n* --- END CODE TO DELETE FOR FULL COMMON LISP\n*\n         EJECT\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION ROUTINE\n         EJECT\nCBIGSFLO DS    0H\nCBIGDFLO DS    0H\nSFLOBIG  DS    0H\nDFLOBIG  DS    0H\n         LR    #5,#1\n         LR    #6,#2\n         #ERR  2,'ZIL4101 LESSP: Float-to-bignum compare not supported.X\n               ',PREFIX=NO,SIGNAL=NO\n         B     BOMBOUT\nERROR    DS    0H                  INVALID TYPES\n         LR    #5,#1\n         LR    #6,#2\nBOMBOUT  #ERR  'Type conflict, LESSP cannot compare ',                 X\n               (#5),' and ',(#6)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTP": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x00\\x17\\x00\\x14\\x00\\x16\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 23, "newlines": 20, "modlines": 22, "user": "SEB1525"}, "text": "         TITLE 'LISTP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nLISTP    #ZBEG MINARGS=1,MAXARGS=1,NAME='LISTP'\n         SPACE 1\n         USING LISTP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CR    #2,#10              IF NIL, TRUE\n         BE    TRUE\n         TM    ##TYPE(#2),##ATOM   IF ATOM, FALSE\n         BO    FALSE\n         DROP  #15\nTRUE     LR    #15,#8\n         BR    #14\nFALSE    LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LLKEYWDP": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x00\\x1a\\x00\\x17\\x00\\x19\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 26, "newlines": 23, "modlines": 25, "user": "SEB1525"}, "text": "         TITLE 'LLKEYWDP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION, ALSO KNOWN AS \"LAMBDA-LIST-KEYWORD-P\", RETURNS T IF  *\n* ITS ARGUMENT IS A SYMBOL WHOSE FIRST CHARACTER IS \"&\", ELSE NIL.    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nLLKEYWDP #ZBEG MINARGS=1,MAXARGS=1,NAME='LLKEYWDP'\n         SPACE 1\n* NO BASE REGISTER\n         L     #2,0(,#1)           GET ARG\n         LR    #15,#10             PRESUME FALSE\n         CLI   ##TYPE(#2),##SYMBOL MUST BE A SYMBOL\n         BNER  #14                 IF NOT, CAN'T BE A LAMBDA LIST KEYWD\n         L     #3,##PNAME(,#2)     GET ITS PRINT NAME\n         CLI   ##VECDAT(#3),C'&&'  FIRST CHAR MUST BE AN AMPERSAND\n         BNER  #14                 IF NOT, NOT A LAMBDA LIST KEYWORD\n         LR    #15,#8              TRUE - IT IS A LAMBDA LIST KEYWORD\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGBITP": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x10_\\x00\\x89\\x15o\\x118\\x00|\\x00y\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-04-14T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 124, "newlines": 121, "modlines": 0, "user": "SEB1525"}, "text": "         TITLE 'LOGBITP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LOGBITP takes two integer arguments.                                *\n*                                                                     *\n* Common Lisp complete.                                               *\n*                                                                     *\n***********************************************************************\nLOGBITP  #ZBEG MINARGS=2,MAXARGS=2,NAME='LOGBITP'\n         SPACE 1\n         LM    #6,#7,0(#1)         Load arguments\n         CLI   ##TYPE(#6),##FIXNUM Is first arg a fixnum?\n         BNE   NFIX1               Branch if not fixed\n         CLI   ##TYPE(#7),##FIXNUM Is second argument a fixnum?\n         BNE   NOTFIX2             Branch if not fixed\n         ICM   #2,B'1111',##CDR(#6) Get value 1 (index)\n         BM    ERROR2              If negative, error\n         CH    #2,#SFT+31*8+6      If greater than 31,\n         BH    MORE32              then check if arg 2 is neg\n         LA    #3,1                Set up word with one 1-bit\n         SLL   #3,0(#2)            Shift bit into testing position\n         LR    #15,#10             Load FALSE for return value\n         N     #3,##CDR(,#7)       Do logical AND with value 2\n         BZR   #14                 If requested bit is zero, false\n         LR    #15,#8              Load TRUE for return value\n         BR    #14                 If requested bit is one, true\n*\nMORE32   TM    ##CDR(#7),X'80'     Sign test works for all integers\n         LR    #15,#10             Get FALSE for possible return\n         BZR   #14                 Return if FALSE\n         LR    #15,#8              Get TRUE for return\n         BR    #14                 Return to caller with TRUE\n*---------------------------------------------------------------------*\n* Arg 1 is FIXNUM.  Arg 2 is not a FIXNUM.                            *\n*---------------------------------------------------------------------*\nNOTFIX2  CLI   ##TYPE(#7),##BIGNUM Is second argument a bignum?\n         BNE   ERROR3              Argument 2 is not an integer\n         ICM   #5,B'1111',##CDR(#6) Load arg1 and test sign\n         BM    ERROR2              Arg 1 should never be negative\n         XR    #4,#4               Clear high word for divide\n         D     #4,=F'31'           Divide arg 1 index by 31 (bits/word)\n         SLA   #5,2                Words x 4 = bytes\n         BZ    WORD1               Index pointing in lowest word?\n         XR    #3,#3               Clear for loading bignum length\n         ICM   #3,B'0111',1(#7)    Load 24-bit bignum length\n         CR    #5,#3               Is index pointing beyond bignum?\n         BNL   MORE32              If so, return sign as NIL/+ or T/-\n         LA    #3,1                Load test bit\n         SLL   #3,0(#4)            Slide test bit to position in word\n         TM    ##VECDAT(#7),X'80'  Test the sign of the bignum\n         BO    BIG2M               Branch if bignum is negative\n         N     #3,##VECDAT(#5,#7)  AND test bit with bignum word\n         LR    #15,#8              Prepare to return with TRUE\n         BNZR  #14                 Return with TRUE if bit is 1\n         LR    #15,#10             Load FALSE for return value\n         BR    #14                 Return with FALSE, bit was 0\n*\nBIG2M    LR    #2,#3               Copy word with test bit in it\n         BCTR  #2,0                Make mask of 1's below test bit\n         N     #2,##VECDAT(#5,#7)  Are there 1's below test bit?\n         BZ    CHKBITS             No?  Then we must check lesser word\n         N     #3,##VECDAT(#5,#7)  OK, then we can test the bit\n         LR    #15,#10             Prepare to return FALSE if needed\n         BNZR  #14                 Bit was one, return complement (NIL)\n         LR    #15,#8              Load TRUE for return value\n         BR    #14                 Return to caller with TRUE\n*\nCHKBITS  LA    #2,##VECDAT(#5,#7)  Save pointer to word with test bit\n         LA    #4,##VECDAT(,#7)    Get address of bignum LS word + byte\n         LA    #6,=X'80'           One-byte compare for CLCL\n         LA    #7,1                Compare length for CLCL\n         CLCL  #4,#6               Compare with zero pad byte\n         BE    LOWBITSZ            All the low bits are zero\nNZHBYTE  N     #3,0(,#2)           Use test bit as mask\n         LR    #15,#10             Prepare to return FALSE\n         BNZR  #14                 If test bit 1, return FALSE\n         LR    #15,#8              Test bit is 0, load TRUE\n         BR    #14                 Return with TRUE\n*\nLOWBITSZ N     #3,0(,#2)           All low bits are 0, test bit\n         LR    #15,#10             Get set to return FALSE, if needed\n         BZR   #14                 Not complementing, bit=0,==> FALSE\n         LR    #15,#8              Load up TRUE for return\n         BR    #14                 Bit was 1, return TRUE\n*\nWORD1    L     #2,##VECDAT(,#7)    Get LS word of bignum\n         LA    #3,1                Load test bit\n         LPR   #2,#2               Complement if negative\n         SLL   #3,0(#4)            Slide the test bit to index position\n         NR    #3,#2               Test the bit in index position\n         LR    #15,#10             Get set to return FALSE, if needed\n         BZR   #14                 Return FALSE, if bit is zero\n         LR    #15,#8              Load TRUE\n         BR    #14                 Bit was 1, return with TRUE\n*\nNFIX1    CLI   ##TYPE(#6),##BIGNUM Is first arg a bignum?\n         BNE   ERROR1              Arg 1 is not an integer\n         TM    ##TYPE(#7),##INT    Is second argument an integer?\n         BNO   ERROR3              Arg 2 is not an integer\nB1NF2    TM    ##CDR(#6),X'80'     Test sign of arg 1\n         BO    ERROR2              Arg 1 is negative\n         TM    ##VECDAT(#7),X'80'  Only the sign of bignum matters\n         LR    #15,#10             Prepare to return with FALSE\n         BZR   #14                 If bignum positive, return FALSE\n         LR    #15,#8              Bignum is negative, load TRUE\n         BR    #14                 Return with TRUE\n*\n         DROP  #15\n         USING LOGBITP,#3\n         SPACE 1\nERROR1   LR    #3,#15\n         #ERR  'Argument 1 to LOGBITP not an integer - ',(#6)\nERROR2   LR    #3,#15\n         #ERR  'Argument 1 to LOGBITP is negative - ',(#6)\nERROR3   LR    #3,#15\n         #ERR  'Argument 2 to LOGBITP not an integer - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGCOUNT": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x88\\x10_\\x00\\x89\\x15o\\x118\\x00\\xd5\\x00\\xd0\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-04-14T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 213, "newlines": 208, "modlines": 0, "user": "SEB1525"}, "text": "         TITLE 'LOGCOUNT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LOGCOUNT takes one integer argument.                                *\n*                                                                     *\n* Common Lisp complete.                                               *\n*                                                                     *\n* Scalar and vector versions.                                         *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILVF\nLOGCOUNT #ZBEG MINARGS=1,MAXARGS=1,NAME='LOGCOUNT'\n*---------------------------------------------------------------------*\n* Calculate the number of 1 bits in a positive fixnum, or the number  *\n* of 0 bits in a negative fixnum.  This is done in a way that works   *\n* for both cases by simply counting the number of overflows when      *\n* shifting every significant bit to the left with an arithmetic shift *\n* instruction.                                                        *\n*                                                                     *\n* A scheme using the TR instruction is probably considerably          *\n* faster, though this may involve extra time to load the cache        *\n* containing the TR table for short bignums, relatively speaking.     *\n*                                                                     *\n* For the vector facility version, the vector facility is always      *\n* used, in which case even the fixnum bit count must special-case     *\n* with regard to the sign.  For bignum calculations, the negative     *\n* bignum case adds an additional complication, since the 0 bits must  *\n* be counted as if the representation is in 2's complement, which it  *\n* is not.  The scheme is then to count zeroes from the right until    *\n* you hit a 1.  Then you count the 1's to the left of the rightmost   *\n* 1.  This involves an intermediate step for special handling of      *\n* the word containing the rightmost 1 of the bignum.                  *\n*---------------------------------------------------------------------*\n         AIF   (&ZILVF).VFIX\n*---------------------------------------------------------------------*\n* Scalar version.                                                     *\n*---------------------------------------------------------------------*\n         L     #7,0(,#1)           Load argument\n         CLI   ##TYPE(#7),##FIXNUM Is arg a fixnum?\n         BNE   NFIX                Branch if not fixed\n*\nFIX      L     #7,##CDR(,#7)       Load fixnum\n         XR    #5,#5               Clear the bit-counter\n         LA    #6,31               # of sifnificant fixnum bits\nFIXLOOP  SLA   #7,1                Shift out a bit on the left\n         BNO   NOFIXBIT            Did we get overflow?\n         LA    #5,8(,#5)           No overflow, one fewer bit to count\nNOFIXBIT BCT   #6,FIXLOOP          More bits to test?\n         LA    #15,#SFT(#5)        Compute small fixnum address\n         BR    #14                 Return with small fixnum\n*\nNFIX     CLI   ##TYPE(#7),##BIGNUM Is arg a bignum?\n         BNE   ERROR1              Branch if not integer\n         TM    ##VECDAT(#7),X'80'  Test sign of bignum\n         BO    BIGM                Branch if negative bignum\n         XR    #2,#2               Clear bit counter\n         LA    #3,##VECDAT         Starting offset of WORDLOOP\n         LA    #4,4                Increment (bytes in a word)\n         XR    #5,#5               Clear for load of 3-byte length\n         ICM   #5,B'0111',1(#7)    Load bignum length in bytes\nWORDLOOP L     #1,##VECDAT-4(#3,#7) Load word with bits to be counted\n         LA    #6,31               Number of bits in a word to test\nBITLOOP  SLA   #1,1                Shift to see if we get overflow\n         BNO   NOBIGBIT            No overflow?  Then, don't count bit\n         BCTR  #2,0                Count bit (in a negative way).\nNOBIGBIT BCT   #6,BITLOOP          More bits to check?\n         BXLE  #3,#4,WORDLOOP      More words for to bit-count?\n*\n         LCR   #2,#2               Make the count positive\n         CL    #2,ZLCSFTHI         Compare with largest SFT?\n         BH    FCONS               Not a small fixnum?\nFSMALL   SLA   #2,3                Create offset in SFT\n         LA    #15,#SFT(#2)        Get address of small fixnum\n         BR    #14\n*\nBIGM     LA    #2,##VECDAT(,#7)    Start of bignum for CLCL\n         XR    #3,#3               Clear for loading bignum length\n         ICM   #3,B'0111',1(#7)    Load the bignum length\n         LA    #4,=X'80'           Point to pattern of the minus bit\n         LA    #5,1                Pad byte=0, length=1\n         CLCL  #2,#4               Search for word with first 1 bit\n         N     #2,=X'FFFFFFFC'     Point to nonzero word\n         L     #5,0(,#2)           Load first nonzero word\n         N     #5,=X'7FFFFFFF'     Remove sign bit if LS word of bignum\n         LCR   #1,#5               Complement word with rightmost 1\n         LR    #3,#2               Make extra copy pointer to 1st 1\n         SR    #2,#7               (#2-#7-4)*31/4= number of 0 bits\n         SH    #2,=H'4'            -4, because of the 4-byte header\n         MH    #2,=H'-31'          *31, also make it negative bit count\n         SRA   #2,2                /4, number of bytes per word\n         LA    #6,31               Number of bits to test in word\nBMULOOP  SLA   #1,1                Shift out one bit, 0 will overflow\n         BNO   BMUNOBIT            Branch if no zero bit to count\n         BCTR  #2,0                Count 0-bit\nBMUNOBIT BCT   #6,BMULOOP          Not finished with all 31 bits?\n         SLR   #3,#7               Absolute address to bignum offset\n         LA    #4,4                Increment (bytes/word)\n         XR    #5,#5               Clear for load of 3-byte length\n         ICM   #5,B'0111',1(#7)    Load bignum length in bytes\n         BXLE  #3,#4,WORDLOOP      Words left of word with leftmost 1?\n*\n         LCR   #2,#2               Make the count positive\n         CL    #2,ZLCSFTHI         Compare with largest SFT?\n         BNH   FSMALL              Not a small fixnum?\n*\nFCONS    LR    #7,#14              Save return address\n         #MKAT FIXED               Make fixnum\n         BR    #7                  Return to caller\n*=====================================================================*\n         AGO   .CONTIN1\n.VFIX    ANOP\n*---------------------------------------------------------------------*\n*  Vector version of LOGCOUNT.                                        *\n*---------------------------------------------------------------------*\n         L     #7,0(,#1)           Load argument\n         VRCL  0                   Clear vector interrupt index\n         CLI   ##TYPE(#7),##FIXNUM Is arg a fixnum?\n         BNE   NFIX                Branch if not fixed\n*\nFIX      LA    #6,##CDR(,#7)       Make pointer to fixnum quantity\n         LA    #4,32               Number of bits to test in vec loop\n         XR    #5,#5               Clear the 1-bit count\n         VLVCU #4                  Set vector count to # of bits\nFIXVLOOP VLVM  #6                  Load a section of bits\n         VCOVM #5                  Count the 1-bits\n         VLVCU #4                  Update vector count\n         BC    3,FIXVLOOP          More bits?\n         SLA   #5,3                Convert to displacement in SFT\n         TM    ##CDR(#7),X'80'     Test sign of fixnum\n         LA    #15,#SFT(#5)        Load address of small fixnum\n         BNOR  #14                 Return 1-count if positive fixnum\n*\n         LCR   #5,#5               Take negative of offset in SFT\n         LA    #15,#SFT+32*8(#5)   Add to address of 32 (total bits)\n         BR    #14                 Return 0-count of negative fixnum\n*\nNFIX     CLI   ##TYPE(#7),##BIGNUM Is arg a bignum?\n         BNE   ERROR1              Branch if not integer\n         TM    ##VECDAT(#7),X'80'  Test sign of bignum\n         BO    BIGM                Bignum is negative\n         XR    #3,#3               Clear for loading bignum length\n         XR    #2,#2               Clear bit counter\n         ICM   #3,B'0111',1(#7)    Load bignum length\n         SLA   #3,3                Bytes x 8 = bits in bignum\n         LA    #4,##VECDAT(,#7)    Get address of first bignum word\n         VLVCU #3                  Set up vector loop counter\nBPLOOP   VLVM  #4                  Load a chunk of bignum bits\n         VCOVM #2                  Count the 1-bits in the chunk\n         VLVCU #3                  Decrement element count, set sec siz\n         BC    3,BPLOOP            Not done with all bits?\n         CL    #2,ZLCSFTHI         Compare with largest SFT?\n         BH    FCONS               Not a small fixnum?\n         SLA   #2,3                Create offset in SFT\n         LA    #15,#SFT(#2)        Get address of small fixnum\n         BR    #14\n*\nFCONS    LR    #7,#14              Save return address\n         #MKAT FIXED               Make fixnum\n         BR    #7                  Return to caller\n*\nBIGM     LA    #2,##VECDAT(,#7)    Start of bignum for CLCL\n         XR    #3,#3               Clear for loading bignum length\n         ICM   #3,B'0111',1(#7)    Load the bignum length\n         LA    #4,=X'80'           Point to pattern of the minus bit\n         LA    #5,1                Pad byte=0, length=1\n         CLCL  #2,#4               Search for word with first 1 bit\n         N     #2,=X'FFFFFFFC'     Point to nonzero word\n         L     #5,0(,#2)           Load first nonzero word\n         N     #5,=X'7FFFFFFF'     Remove sign bit if LS word of bignum\n         LCR   #5,#5               Complement word with rightmost 1\n         ST    #5,ZLCDBL           Store for later bit-count by VF\n         LR    #5,#2               Make extra copy pointer to 1st 1\n         SR    #2,#7               (#2-#7-4)*31/4= number of 0 bits\n         SH    #2,=H'4'            -4\n         MH    #2,=H'31'           *31\n         SRA   #2,2                /4\n         LA    #6,32               Number of bits to check\n         LA    #4,ZLCDBL           Address of complemented temp word\n         VLVCU #6                  Set section size to no. of bits\nBMWLOOP  VLCVM #4                  We count 0's, so load complement\n         VCOVM #2                   before counting, add count to #5\n         VLVCU #6                  Set section size to no. of bits\n         BC    3,BMWLOOP           More bit vector sections in word?\n         BCTR  #3,0                Round length left to lower multiple\n         N     #3,=X'FFFFFFFC'      of 4, that is, only rest of bignum\n         SLA   #3,3                Convert bytes-remaining to bits\n         LA    #5,4(,#5)           Set to word after rightmost \"1\"\n         VLVCU #3                  Set up vector loop counter\nBMLOOP   VLVM  #5                  Load a chunk of bignum bits\n         VCOVM #2                  Count the 1-bits in the chunk\n         VLVCU #3                  Decrement element count, set sec siz\n         BC    3,BMLOOP            Not done with all bits?\n         CL    #2,ZLCSFTHI         Compare with largest SFT?\n         BH    FCONS               Not a small fixnum?\n         SLA   #2,3                Create offset in SFT\n         LA    #15,#SFT(#2)        Get address of small fixnum\n         BR    #14                 Return with bit-count of neg bignum\n*=====================================================================*\n.CONTIN1 ANOP\n*\n         DROP  #15\n         USING LOGCOUNT,#3\n         SPACE 1\nERROR1   LR    #3,#15\n         #ERR  'Argument to LOGCOUNT not an integer - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGNOT": {"ttr": 3342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x88\\x11/\\x00\\x89\\x15o\\x118\\x00\\x8a\\x00\\x1a\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1988-04-21T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 138, "newlines": 26, "modlines": 0, "user": "SEB1525"}, "text": "         TITLE 'LOGNOT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LOGNOT takes one integer argument.                                  *\n*                                                                     *\n* LOGNOT is not worth vectorizing because of the sign and magnitude   *\n* implementation of bignums.  This is actually an advantage in this   *\n* case, since, on the average, most of the bignum is simply copied.   *\n* The equivalent LOGNOT operation is simply adding or subtracting     *\n* one to the magnitude and flipping the sign.  For large bignums      *\n* the most important speed operation is copying.  Note that MVCL      *\n* is not the fastest way to copy on current IBM hardware.             *\n*                                                                     *\n***********************************************************************\nLOGNOT   #ZBEG MINARGS=1,MAXARGS=1,NAME='LOGNOT'\n         #ZPDS 1*4+12+0 (= 16)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n*\n         L     #6,0(,#11)          Load argument\n         CLI   ##TYPE(#6),##FIXNUM Is arg a fixnum?\n         BNE   NF                  If not, branch to Not Fixnum\nF        L     #2,##CDR(,#6)       Get arg\n         X     #2,#SFWM1           Do logical XOR with X'FFFFFFFF'\n         #MKAT FIXED               Cons up a fixnum answer\nRET      #ZRET ,                   RESTORE REGISTERS AND RETURN\n*\nNF       CLI   ##TYPE(#6),##BIGNUM Is arg a bignum?\n         BNE   ERROR1              Arg is not an integer\nB        XR    #5,#5               Clear for inserting bignum length\n         ICM   #5,B'0111',1(#6)    Insert bignum length of arg\n         ICM   #7,B'1111',##VECDAT(#6) Get LS word and test sign\n         L     #15,ZLCBIG          Preload bignum-maker address\n         BM    BM                  Bignum is negative\nBP       LA    #2,##VECDAT+4(,#5)  May need bignum one word longer\n         #BASR #14,#15             Ask for bignum space and location\n         AH    #7,=H'1'            Pretend 2's complement, so must +1\n         BO    BPO                 Overflow, we must carry to next word\n         O     #7,=X'80000000'     Put negative sign in LS word\n         ST    #7,##VECDAT(#15)    Store LS word in result bignum\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         LA    #2,##VECDAT+4(,#15) Start of area to copy to\n         SH    #5,=H'4'            One word less to copy\n         LA    #4,##VECDAT+4(,#6)  Start of area to copy from\n         LR    #3,#5               Source and destination lengths same\n         MVCL  #2,#4               Copy unchanged part of bignum\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nBPO      ST    #7,##VECDAT(#15)    Store X'80000000' in LS word\n         XR    #2,#2               Generate 0 for storing\n         LA    #3,8                Starting index for loop\n         LA    #4,4                Word size for increment\nBPOLOOP  L     #7,##VECDAT-4(#3,#6) Load next word\n         AH    #7,=H'1'            Add the carry from previous word\n         BNO   BPNO                No overflow, stop adding\n         ST    #2,##VECDAT-4(#3,#15) Store 0 word in result bignum\n         BXLE  #3,#4,BPOLOOP       More words to examine?\n*\n         LA    #5,4(,#5)           Add 1 word to bignum length\n         LA    #7,1                1 to store\n         ST    #7,##VECDAT-4(#5,#15) Store 1 in high word\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         LA    #2,##VECDAT(#5,#15) Update availability pointer\n         ST    #2,ZLCVSNXT         Store availability pointer\n         B     RET                 Return to caller\n*\nBPNO     ST    #7,##VECDAT-4(#3,#15) Store carried-to word in result\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         SR    #5,#3               Remaining length to copy\n         LA    #4,##VECDAT(#3,#6)  Start of unchanged bignum part\n         LR    #3,#5               Remaining length to copy\n         LA    #2,##VECDAT(#3,#15) Start for storing unchanged bignum\n         MVCL  #2,#4               Copy unchanged part of bignum\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nBM       LA    #2,##VECDAT(,#5)    Size of possible required bignum\n         #BASR #14,#15             Ask for bignum space and location\n         N     #7,=X'7FFFFFFF'     Mask out the sign bit\n         SH    #7,=H'1'            Pretend 2's complement, so must -1\n         BM    BMU                 Underflow, must borrow from next wrd\n         ST    #7,##VECDAT(#15)    Store LS word in result bignum\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         LA    #2,##VECDAT+4(,#15) Start of area to copy to\n         SH    #5,=H'4'            One word less to copy\n         LA    #4,##VECDAT+4(,#6)  Start of area to copy from\n         LR    #3,#5               Source and destination lengths same\n         MVCL  #2,#4               Copy unchanged part of bignum\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nBMU      ST    #7,##VECDAT(#15)    Store X'80000000' in LS word\n         L     #2,=X'7FFFFFFF'     Generate max pos word for storing\n         LA    #3,8                Starting index for loop\n         LA    #4,4                Word size for increment\nBMOLOOP  L     #7,##VECDAT-4(#3,#6) Load next word\n         SH    #7,=H'1'            Sub the borrow from previous word\n         BNM   BMNM                No minus, stop subtracting\n         ST    #2,##VECDAT-4(#3,#15) Store 0 word in result bignum\n         BXLE  #3,#4,BMOLOOP       More words to examine?\n*\n         B     ERROR2              Severe error, should never get here\n*\nBMNM     ST    #7,##VECDAT-4(#3,#15) Store borrowed-from-word in result\n         CR    #5,#3               Remaining length to copy\n         BZ    BMNZ                Nothing more to copy with MVCL\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         SR    #5,#3               Remaining length to copy\n         LA    #4,##VECDAT(#3,#6)  Start of unchanged bignum part\n         LR    #3,#5               Remaining length to copy\n         LA    #2,##VECDAT(#3,#15) Start for storing unchanged bignum\n         MVCL  #2,#4               Copy unchanged part of bignum\n         ST    #2,ZLCVSNXT         Update availability pointer\n         B     RET                 Return to caller\n*\nBMNZ     LTR   #7,#7               Is highest word a zero?\n         BZ    BMNL                Result must be one word less\n         ST    #7,##VECDAT-4(#5,#15) Store highest word in result\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         LA    #2,##VECDAT(#5,#15) Update availability pointer\n         ST    #2,ZLCVSNXT         Store availability pointer\n         B     RET\n*\nBMNL     SH    #5,=H'4'            Length is one word less\n         STCM  #5,B'0111',1(#15)   Store bignum length in header\n         LA    #2,##VECDAT(#5,#15) Update availability pointer\n         ST    #2,ZLCVSNXT         Store availability pointer\n         B     RET\n*\nERROR1   #ERR  'Argument to LOGNOT not an integer - ',(#6)\nERROR2   #ERR  'System error in LOGNOT - defective bignum - ',(#6)\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGTEST": {"ttr": 3586, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x00\\x00\\x88\\x10_\\x00\\x89\\x15o\\x118\\x00\\x87\\x00\"\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1988-04-14T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 135, "newlines": 34, "modlines": 0, "user": "SEB1525"}, "text": "         TITLE 'LOGTEST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LOGTEST takes two integer arguments.                                *\n*                                                                     *\n* Common Lisp complete.                                               *\n*                                                                     *\n* It doesn't really pay to vectorize LOGTEST because it needs to      *\n* return only T or NIL.  If the answer is T, you don't have to look   *\n* any further.  Vector instructions always run to completion, and     *\n* may therefore take longer to determine that something is T than     *\n* a scalar version.                                                   *\n*                                                                     *\n***********************************************************************\nLOGTEST  #ZBEG MINARGS=2,MAXARGS=2,NAME='LOGTEST'\n*\n         LM    #6,#7,0(#1)         LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM Is first arg a fixnum?\n         BNE   NF1                 Branch to Not Fix 1\n         CLI   ##TYPE(#7),##FIXNUM Is second arg a fixnum?\n         BNE   F1NF2               Branch to Fix 1 Not Fix 2\nF1F2     L     #2,##CDR(,#6)       GET VALUE 1\n         N     #2,##CDR(,#7)       DO LOGICAL AND WITH VALUE 2\n         LR    #15,#8              IF ANY ARE ONES, RETURN TRUE\n         BNZR  #14                 IF ALL REQUESTED BITS ZERO, FALSE\nFALSE    LR    #15,#10             It's FALSE, load it\n         BR    #14                 Return to caller with FALSE\n*\nTRUE     LR    #15,#8              Load TRUE\n         BR    #14                 Return to caller\n*\nF1NF2    CLI   ##TYPE(#7),##BIGNUM Is arg 2 a bignum?\n         BNE   ERROR2              Arg 2 is invalid type\nF1B2     TM    ##CDR(#6),X'80'     Is arg 2 fixnum negative?\n         BO    TRUE                Always TRUE if arg 2 negative?\nFP1B2    L     #5,##VECDAT(,#7)    Lowest word of bignum\n         LPR   #5,#5               2's complement if negative\n         N     #5,##CDR(,#6)       Check for matches with fixnum\n         LR    #15,#8              Load TRUE in case we need it\n         BNZR  #14                 Match found, return with TRUE\n         LR    #15,#10             No match found, load FALSE\n         BR    #14                 Return to caller with FALSE\n*\nB1NB2    CLI   ##TYPE(#7),##FIXNUM Is arg 2 a fixnum?\n         BNE   ERROR2              Arg 2 is not a fixnum?\nB1F2     TM    ##CDR(#7),X'80'     Is arg 2 fixnum negative?\n         BO    TRUE                Always TRUE if arg 2 negative?\nB1FP2    L     #5,##VECDAT(,#6)    Lowest word of bignum\n         LPR   #5,#5               2's complement if negative\n         N     #5,##CDR(,#7)       Check for matches with fixnum\n         LR    #15,#8              Load TRUE in case we need it\n         BNZR  #14                 Match found, return with TRUE\n         LR    #15,#10             No match found, load FALSE\n         BR    #14                 Return to caller with FALSE\n*\nNF1      CLI   ##TYPE(#6),##BIGNUM Is first arg a bignum?\n         BNE   ERROR1              Arg 1 is invalid type\n         CLI   ##TYPE(#7),##BIGNUM Is second arg a bignum?\n         BNE   B1NB2               Go to Big 1 No Big 2\nB1B2     TM    ##VECDAT(#6),X'80'  Test sign of bignum 1\n         BO    BM1B2               Go to Big Minus 1 Big 2\n         TM    ##VECDAT(#7),X'80'  Test sign of bignum 2\n         BO    BP1BM2              Go to Big Positive 1 Big Minus 2\nBP1BP2   LM    #4,#5,##VECDAT(#6)  Let's examine two lowest words first\n         N     #4,##VECDAT(#7)     Any common bits in LS words?\n         BNZ   TRUE                If so, return with TRUE\n         N     #5,##VECDAT+4(#7)   Any common bits in second word?\n         BNZ   TRUE                If so, return with TRUE\n         L     #5,0(,#6)           Load type and length of arg 1\n         CL    #5,0(,#7)           Compare bignum lengths (types same)\n         BNH   OKLEN1              We want shorter length of two args\n         L     #5,0(,#7)           Load length of bignum 2\nOKLEN1   N     #5,=X'00FFFFFF'     Mask out bignum type-byte\n         CH    #5,=H'8'            Is shorter bignum only 2 words?\n         BE    FALSE               If so, we previously found no match\n         LA    #3,12               Offset of first word to check\n         LA    #4,4                Word increment amount for BXLE\nLOOP1    L     #2,##VECDAT-4(#3,#6) Load word of bignum 1\n         N     #2,##VECDAT-4(#3,#7) Check for match bits in bignum 2\n         BNZ   TRUE                Found bit match, return with TRUE\n         BXLE  #3,#4,LOOP1         More words to check?\n         LR    #15,#10             No matches found, load FALSE\n         BR    #14                 Return to caller\n*\nBP1BM2   LR    #5,#7               Switch pointers in regs\n         LR    #7,#6                so same code for pos - neg\n         LR    #6,#5                bignum combination can be used\n         B     BM1BP2              Continue with code for other case\n*\nBM1B2    TM    ##VECDAT(#7),X'80'  Test sign of bignum 2\n         BO    TRUE                Two negative integers always match\nBM1BP2   L     #3,0(,#7)           Load type and length of arg 2\n         CL    #3,0(,#6)           Compare bignum lengths (types same)\n         BH    TRUE                Leading 1 in big1 will always match\n         LA    #2,##VECDAT(,#6)    Start of data on negative bignum\n         N     #3,=X'00FFFFFF'     Mask out the type-byte\n         LA    #4,=X'80'           Compare field for neg sign and 1st b\n         LA    #5,1                Length of 1-byte compare field\n         CLCL  #2,#4               Find rightmost 1 in neg bignum\n         BNH   FALSE               No 1's in big1 within length of big2\n         N     #2,=X'FFFFFFFC'     Point to word containing rightmost 1\n         L     #3,0(,#2)           Load first nonzero word\n         N     #3,=X'7FFFFFFF'     Remove sign bit if LS word of bignum\n         LCR   #3,#3               Complement word with rightmost 1\n         SLR   #2,#6               Absolute address to bignum offset\n         N     #3,##VECDAT-4(#2,#7) Common bits in wrd w/rigthmst 1?\n         BNZ   TRUE                Yes, return with TRUE\n         XR    #5,#5               Clear for loading shorter bignum len\n         LA    #4,4                Word increment for loop\n         ICM   #5,B'0111',1(#7)    Load length of arg 2 bignum\n         BXH   #2,#4,FALSE         No match at end of short, FALSE\nLOOP2    L     #3,##VECDAT-4(#2,#6) Load next word\n         X     #3,=X'FFFFFFFF'     Flip the bits (2's-complement)\n         N     #3,##VECDAT-4(#2,#7) Match the bits\n         BNZ   TRUE                Match?  Then return with TRUE\n         BXLE  #2,#4,LOOP2         More words to check for match?\n*\n         LR    #15,#10             No matches found, load FALSE\n         BR    #14                 Return with FALSE\n*\n         DROP  #15\n         USING LOGTEST,#3\n         SPACE 1\nERROR1   LR    #3,#15\n         #ERR  'Argument 1 to LOGTEST not an integer - ',(#6)\nERROR2   LR    #3,#15\n         #ERR  'Argument 2 to LOGTEST not an integer - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOR": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x00#\\x00 \\x00\"\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 35, "newlines": 32, "modlines": 34, "user": "SEB1525"}, "text": "         TITLE 'LOR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* LOR TAKES TWO INTEGER ARGUMENTS.   CURRENTLY THEY MUST BE FIXNUMS.\n*\nLOR      #ZBEG MINARGS=2,MAXARGS=2,NAME='LOR'\n         #ZPDS 2*4+12+0 (= 20)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##FIXNUM FIRST ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#7),##FIXNUM SECOND ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR2\n         LM    #1,#2,##CAR(#6)     GET HEADER AND VALUE 1\n         O     #2,##CDR(,#7)       DO LOGICAL OR WITH VALUE 2\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL CONS TO MAKE A NEW FIXNUM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument 1 to logical OR not a fixnum - ',(#6)\nERROR2   #ERR  'Argument 2 to logical OR not a fixnum - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LSH": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x00+\\x00(\\x00*\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 43, "newlines": 40, "modlines": 42, "user": "SEB1525"}, "text": "         TITLE 'LSH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LSH TAKES TWO INTEGER ARGUMENTS.  CURRENTLY THEY MUST BE FIXNUMS.   *\n*                                                                     *\n* THIS FUNCTION DOES A LOGICAL SHIFT OPERATION.  COMPARE ASH.         *\n*                                                                     *\n***********************************************************************\nLSH      #ZBEG MINARGS=2,MAXARGS=2,NAME='LSH'\n         #ZPDS 2*4+12+0 (= 20)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#7),##FIXNUM\n         BNE   ERROR2\n         L     #2,##CDR(,#6)       GET FIXED VALUE 1\n         L     #3,##CDR(,#7)       GET FIXED VALUE 2\n         LTR   #3,#3               TEST SHIFT AMOUNT\n         BZ    NOSHIFT             IF ZERO, NO SHIFTING REQUIRED\n         BM    RSHIFT              IF NEGATIVE, RIGHT SHIFT REQUIRED\n         SLL   #2,0(#3)            ELSE POSITIVE, DO LEFT SHIFT\n         B     NOSHIFT             AND PROCESS\nRSHIFT   DS    0H\n         LPR   #3,#3               CHANGE SHIFT AMOUNT TO POSITIVE\n         SRL   #2,0(#3)            DO RIGHT SHIFT\nNOSHIFT  DS    0H                  NOW #2 CONTAINS SHIFTED VALUE\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM ATOM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument 1 to LSH not a fixnum - ',(#6)\nERROR2   #ERR  'Argument 2 to LSH not a fixnum - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LXOR": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x118\\x00#\\x00 \\x00\"\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:38:00", "lines": 35, "newlines": 32, "modlines": 34, "user": "SEB1525"}, "text": "         TITLE 'LXOR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* LXOR TAKES TWO INTEGER ARGUMENTS.  CURRENTLY THEY MUST BE FIXNUMS.\n*\nLXOR     #ZBEG MINARGS=2,MAXARGS=2,NAME='LXOR'\n         #ZPDS 2*4+12+0 (= 20)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##FIXNUM FIRST ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#7),##FIXNUM SECOND ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR2\n         LM    #1,#2,##CAR(#6)     GET HEADER AND VALUE 1\n         X     #2,##CDR(,#7)       DO LOGICAL XOR WITH VALUE 2\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL CONS TO MAKE A NEW FIXNUM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument 1 to logical XOR not a fixnum - ',(#6)\nERROR2   #ERR  'Argument 2 to logical XOR not a fixnum - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAKNUM": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'MAKNUM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* MAKNUM TAKES AN ARG OF ANY TYPE AND RETURNS ITS VIRTUAL ADDRESS.\n*\nMAKNUM   #ZBEG MINARGS=1,MAXARGS=1,NAME='MAKNUM'\n         #ZPDS 1*4+12+0 (= 16)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #2,0(,#11)          LOAD ADDRESS OF ARG 1\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAXARGS": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00+\\x00(\\x00*\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 43, "newlines": 40, "modlines": 42, "user": "SEB1525"}, "text": "         TITLE 'MAXARGS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE RETURNS THE MAXIMUM NUMBER OF ARGUMENTS DEFINED FOR A   *\n* COMPILED FUNCTION, PRIMARILY FOR THE EVALUATOR/INTERPRETER.         *\n* THE INPUT PARAMETER MUST BE CODE, I.E. THE VALUE OF THE ZILLOAD     *\n* FUNCTION OR OF THE SUBR, FSUBR, ETC. PROPERTY OF A FUNCTION ATOM.   *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAXARGS  #ZBEG MINARGS=1,MAXARGS=1,NAME='MAXARGS'\n         SPACE\n         L     #6,0(,#1)           PICK UP PARAMETER (FUNCTION CODE)\n         TM    ##TYPE(#6),##CODE   MUST BE A COMPILED CODE OBJECT\n         BNO   ERROR               (SUBR OR CLOSURE)\n         XR    #4,#4               ELSE CLEAR INSERT REGISTER\n         XR    #2,#2               CLEAR INSERT REG\n         ICM   #4,7,##CAR+1(#6)    GET POINTER TO COMPILED CODE\n         IC    #2,4(,#4)           GET LENGTH OF IDENTIFIER\n         LA    #3,5+3(#2,#4)       POINT TO MODULE CODE PAST IDENTIFIER\n         N     #3,=X'FFFFFFFC'     ROUNDING UP TO NEXT FULLWORD\n         USING ZINT,#3             TO POINT TO \"ZINT\" AREA\n         IC    #2,ZINMAXAR         PICK UP MAXARGS VALUE\n         DROP  #15\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Point to fixnum in table\n         BR    #14\n         SPACE 1\nERROR    DS    0H\n         LR    #2,#15\n         USING MAXARGS,#2\n         #ERR  'Argument to MAXARGS not a compiled code object (SUBR orX\n                closure) - ',(#6)\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZINT ,                   MAP THE CODE HEADER AREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMQ": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00&\\x00\\x88\\x01_\\x01\\x00&_\\x11W\\x00.\\x00\"\\x00-\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:57:26", "lines": 46, "newlines": 34, "modlines": 45, "user": "SEB1525"}, "text": "         TITLE 'MEMQ - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MEMQ: SAME AS COMMON LISP (MEMBER A B :TEST #'EQ)                   *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 03/30/88 - Error checking added, now that MEMQ gets compiled inline.*\n*            Note that the checking is rather minimal.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMEMQ     #ZBEG MINARGS=2,MAXARGS=2,NAME='MEMQ'\n         SPACE 1\n         LR    #2,#15\n         DROP  #15\n         USING MEMQ,#2\n         LR    #4,#14              SAVE RETURN ADDRESS\n         LM    #14,#15,0(#1)       LOAD ARGS\nLOOP     DS    0H\n         CR    #15,#10             WHEN (SUB)LIST IS NIL\n         BER   #4                  THEN RETURN NIL\n         LM    #5,#6,##CAR(#15)    #5 = CAR OF (SUB)LIST, #6 = CDR\n         LTR   #5,#5               IF (SUB)LIST CELL WAS REALLY ATOMIC\n         BM    ERROR1              THEN BAD LIST, ERROR\n         CR    #14,#5              IF ARG1 IS EQ TO CAR OF (SUB)LIST\n         BER   #4                  THEN RETURN\n         LR    #15,#6              ELSE GET CDR OF (SUB)LIST\n         B     LOOP                AND CONTINUE.\nERROR1   DS    0H\n         L     #3,4(,#1)\n         #ERR  'Argument 2 to MEMQ not a proper list - ',(#3)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MINARGS": {"ttr": 3601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00+\\x00(\\x00*\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 43, "newlines": 40, "modlines": 42, "user": "SEB1525"}, "text": "         TITLE 'MINARGS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE RETURNS THE MINIMUM NUMBER OF ARGUMENTS DEFINED FOR A   *\n* COMPILED FUNCTION, PRIMARILY FOR THE EVALUATOR/INTERPRETER.         *\n* THE INPUT PARAMETER MUST BE CODE, I.E. THE VALUE OF THE ZILLOAD     *\n* FUNCTION OR OF THE SUBR, FSUBR, ETC. PROPERTY OF A FUNCTION ATOM.   *\n*                                                                     *\n***********************************************************************\n         SPACE\nMINARGS  #ZBEG MINARGS=1,MAXARGS=1,NAME='MINARGS'\n         SPACE\n         L     #6,0(,#1)           PICK UP PARAMETER (FUNCTION CODE)\n         TM    ##TYPE(#6),##CODE   MUST BE A COMPILED CODE OBJECT\n         BNO   ERROR               (SUBR OR CLOSURE)\n         XR    #4,#4               ELSE CLEAR INSERT REGISTER\n         XR    #2,#2               CLEAR INSERT REG\n         ICM   #4,7,##CAR+1(#6)    GET POINTER TO COMPILED CODE\n         IC    #2,4(,#4)           GET LENGTH OF IDENTIFIER\n         LA    #3,5+3(#2,#4)       POINT TO MODULE CODE PAST IDENTIFIER\n         N     #3,=X'FFFFFFFC'     ROUNDING UP TO NEXT FULLWORD\n         USING ZINT,#3             TO POINT TO \"ZINT\" AREA\n         IC    #2,ZINMINAR         PICK UP MINARGS VALUE\n         DROP  #15\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Point to fixnum in table\n         BR    #14                 Return\n         SPACE 1\nERROR    DS    0H\n         LR    #3,#15\n         USING MINARGS,#3\n         #ERR  'Argument to MINARGS not a compiled code object (SUBR orX\n                closure) - ',(#6)\n         SPACE 1\n         LTORG\n         SPACE\n         #ZINT ,                   MAP THE CODE HEADER AREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MINUS": {"ttr": 3603, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00e\\x00b\\x00d\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 101, "newlines": 98, "modlines": 100, "user": "SEB1525"}, "text": "         TITLE 'MINUS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MINUS TAKES ONE ARGUMENT - A FIXNUM, FLONUM OR BIGNUM               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMINUS    #ZBEG MINARGS=1,MAXARGS=1,NAME='MINUS'\n         #ZPDS 16\n         #ZSAV ,\n         SPACE\n         L     #15,0(,#11)         GET THE ARG\n         CLI   0(#15),##FIXNUM\n         BE    MINUSFIX\n         CLI   0(#15),##SFLOAT\n         BE    MINUSSFL\n         CLI   0(#15),##BIGNUM\n         BE    MINUSBIG\n         CLI   0(#15),##DFLOAT\n         BE    MINUSDFL\n         B     ERROR\n         SPACE 1\nMINUSFIX DS    0H                  MINUS OF A FIXNUM\n         SPACE 1\n         ICM   #2,15,##CDR(#15)    GET FIXNUM VALUE\n         BZ    RETURN              IF ALREADY ZERO, RETURN ITSELF\n         LCR   #2,#2               NEGATE IT\n         BO    FIXOVFLO            IF OVERFLOW, MUST HAVE BEEN -2**31\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RETURN WITH VALUE\n         SPACE 1\nFIXOVFLO DS    0H                  HERE IF INPUT IS -2**31\n         LA    #15,P2TO31          RETURN BIGNUM +2**31\n         B     RETURN\n         SPACE 1\nMINUSSFL DS    0H                  MINUS OF A SINGLE FLOAT\n         SPACE 1\n         LE    #F2,##CDR(,#15)     GET FLONUM VALUE\n         LCER  #F2,#F2             NEGATE IT\n         BZ    RETURN              IF WAS ZERO, RETURN SELF, NOT THIS\n         STE   #F2,ZLCWORK\n         L     #2,ZLCWORK\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nMINUSDFL DS    0H                  MINUS OF A DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#15)         GET FLONUM VALUE\n         LCDR  #F0,#F0             NEGATE IT\n         BZ    RETURN              IF WAS ZERO, RETURN SELF, NOT THIS\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE A DOUBLE FLOAT\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nMINUSBIG DS    0H                  MINUS OF A BIGNUM\n         SPACE 1\n         CLC   0(12,#15),P2TO31    IF BIGNUM IS 2**31\n         BE    BIG2FIX             THEN GO TO RETURN A FIXNUM -2**31\n         XR    #2,#2               ELSE CLEAR INSERT REGISTER\n         ICM   #2,7,1(#15)         GET BIGNUM LENGTH\n         LA    #2,4(,#2)           PLUS LENGTH OF HEADER\n         LR    #3,#2               SAVE THIS LENGTH\n         L     #15,ZLCBIG          GET ADDRESS OF BIGNUM MAKER\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL ZILBIG\n         LR    #4,#15              SAVE ADDRESS OF NEW BIGNUM\n         LR    #0,#4               DESTINATION ADDRESS\n         L     #14,0(,#11)         SOURCE ADDRESS\n         LR    #1,#3               DESTINATION LENGTH\n         LR    #15,#3              SOURCE LENGTH\n         MVCL  #0,#14              MOVE OLD BIGNUM TO NEW BIGNUM\n         ST    #0,ZLCVSNXT         UPDATE V/S-SPACE POINTER\n         LR    #15,#4              GET ADDRESS OF BIGNUM AGAIN\n         XI    ##VECDAT(#15),X'80' FLIP SIGN BIT\n         B     RETURN\n         SPACE 1\nBIG2FIX  DS    0H                  HERE IF INPUT IS +2**31\n         LA    #15,M2TO31          RETURN FIXNUM -2**31\n         B     RETURN\n         SPACE 1\n         SPACE 2\nM2TO31   #IATM -2147483648         FIXNUM -2**31\n         SPACE 1\nP2TO31   DS    0A                  ALIGN BIGNUM TO FULLWORD\n         DC    YL1(##BIGNUM),AL3(8),F'0,1'   BIGNUM 2**31\n         SPACE 1\nERROR    DS    0H\n         #ERR  'Argument to MINUS not numeric - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MINUSP": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00$\\x00!\\x00#\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 36, "newlines": 33, "modlines": 35, "user": "SEB1525"}, "text": "         TITLE 'MINUSP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MINUSP TAKES ONE ARGUMENT - A NUMERIC ATOM                          *\n*                                                                     *\n***********************************************************************\nMINUSP   #ZBEG MINARGS=1,MAXARGS=1,NAME='MINUSP'\n         SPACE\n         L     #2,0(,#1)           LOAD FIRST (AND ONLY) ARGUMENT\n         CLI   ##TYPE(#2),##FLONUM MUST BE NUMERIC ATOM\n         BL    ERROR               ELSE ERROR\n         DROP  #15\n*\n* THE FOLLOWING TEST WORKS FOR FIXNUMS, FLONUMS AND BIGNUMS.\n* It works for double floats only because ZILMDF duplicates the left\n* half of the flonum when it builds one (and so does the compiler).\n* If anyone changes that behavior, this code must be changed.\n*\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         TM    ##CDR(#2),X'80'     TEST SIGN BIT OF VALUE\n         BZR   #14                 IF ZERO (POSITIVE) RETURN NIL\n         LR    #15,#8              IF ONE (NEGATIVE) RETURN T\n         BR    #14\n         SPACE 1\nERROR    DS    0H                  NOT A NUMERIC ATOM\n         LR    #3,#15\n         USING MINUSP,#3\n         #ERR  'Argument to MINUSP not numeric - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKATOM": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00K\\x00H\\x00J\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 75, "newlines": 72, "modlines": 74, "user": "SEB1525"}, "text": "         TITLE 'MKATOM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* MKATOM TAKES 3 ARGUMENTS, OF WHICH THE LAST 2 ARE OPTIONAL.         *\n* THE FIRST IS A STRING TO BE \"READ\" INTO A SINGLE ATOM.              *\n* THE SECOND SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO INTERN THE   *\n*  GENERATED ATOM ON THE OBLIST (NOTE THAT DEFAULT IS NOT TO).        *\n* THE THIRD SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO FORMAT THE    *\n*  ATOM AS NUMERIC WHERE POSSIBLE (DEFAULT IS TO ASSUME ALPHA).       *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO EXTRA STACK SPACE.        *\n***********************************************************************\n         SPACE\nMKATOM   #ZBEG MINARGS=1,MAXARGS=3,NAME='MAKE-ATOM'\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          GET FIRST ARGUMENT\n         CLI   ##TYPE(#6),##STRING MUST BE A STRING\n         BE    OK                   OR\n         CLI   ##TYPE(#6),##SYMBOL   A SYMBOL\n         BNE   ERROR1                 (IF NEITHER, ERROR)\n         L     #6,##PNAME(,#6)       IF A SYMBOL, TAKE PRINT NAME\nOK       DS    0H\n         XR    #5,#5               CLEAR REGISTER FOR INSERT\n         ICM   #5,7,1(#6)          GET LENGTH OF STRING TEXT\n         C     #5,ZLCWALEN         IF LENGTH EXCEEDS CURRENT WORKAREA\n         BNH   LENOK               THEN...\n         LA    #2,7(,#5)            GET A LARGER WORK AREA\n         N     #2,=X'FFFFFFF8'      ROUNDED UP TO MULTIPLE OF 8\n         LR    #0,#2                SAVE THE NEW WORK AREA LENGTH\n         #GETMAIN RC,LV=(0),LOC=BELOW GET A NEW WORK AREA\n         LTR   #15,#15              IF GETMAIN FAILED\n         BNZ   ERROR2               THEN ERROR - NOT ENOUGH STORAGE\n         LR    #3,#1                SAVE NEW WORKAREA ADDRESS\n         ICM   #1,15,ZLCWA          GET ADDRESS OF OLD AREA\n         BZ    NOFREE               IF NONE, THEN SKIP MOVE & FREE\n         L     #0,ZLCWALEN          GET CURRENT WORK AREA LENGTH\n         FREEMAIN R,LV=(0),A=(1)    FREE THE OLD WORK AREA\nNOFREE   DS    0H\n         ST    #3,ZLCWA             SET NEW ZIL WORKAREA ADDRESS\n         ST    #2,ZLCWALEN          SET NEW ZIL WORKAREA LENGTH\n         SPACE 1\nLENOK    DS    0H                  WORKAREA OK\n         LA    #0,##VECDAT(,#6)    SOURCE ADDRESS = STRING TEXT\n         LR    #1,#5               SOURCE LENGTH = STRING LENGTH\n         L     #14,ZLCWA           DESTINATION ADDRESS = WORKAREA\n         LR    #15,#5              DESTINATION LENGTH = SOURCE LENGTH\n         MVCL  #14,#0              MOVE STRING TEXT TO WORK AREA\n*\n         LR    #0,#5               GET LENGTH OF TEXT\n         L     #1,ZLCWA            SET POINTER = ADDRESS OF WORKAREA\n         LM    #2,#3,4(#11)        SET INTERN FLAG = ARG 2 TO MKATOM\n         LA    #4,24(,#11)         SET CURRENT STACK POINTER FOR CONS\n*                                  SET FORMAT FLAG = ARG 3 TO MKATOM\n         L     #15,ZLCABLD         CALL ZILABLD TO MAKE AN ATOM FROM IT\n         #BASR #14,#15             (RETURNS ATOM IN #15)\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'Argument to MAKE-ATOM not a string - ',0(#11)\n         SPACE 1\nERROR2   DS    0H                  ERROR - NOT ENOUGH STORAGE\n         XR    #0,#0               CLEAR WORK AREA ADDRESS AND LENGTH\n         ST    #0,ZLCWA\n         ST    #0,ZLCWALEN\n         #ERR  'ZIL2007 MAKE-ATOM: Not enough memory to build symbol.',x\n               PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MKBIGNUM": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00[\\x00X\\x00Z\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 91, "newlines": 88, "modlines": 90, "user": "SEB1525"}, "text": "         TITLE 'MKBIGNUM - ZIL 1.3 INTERNAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A BIGNUM FROM A LIST OF FIXNUMS.              *\n*                                                                     *\n* IT TAKES ONE REQUIRED ARGUMENT - A LIST OF FIXNUMS.                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMKBIGNUM #ZBEG MINARGS=1,MAXARGS=1,NAME='MAKE-BIGNUM'\n         SPACE 1\n         #ZPDS 16\n         #ZSAV ,\n         SPACE 1\n         L     #3,0(,#11)          GET ARG\n         LA    #2,4                INITIALIZE LENGTH REQUIRED FOR BIGNU\nLENLOOP  CR    #3,#10              SCAN UNTIL END OF LIST\n         BE    GOTLEN\n         TM    ##TYPE(#3),##ATOM   IF (SUB)ARG IS NOT A LIST\n         BO    ERROR1              THEN ERROR\n         LA    #2,4(,#2)           ELSE INCREMENT LENGTH FOR BIGNUM\n         L     #3,##CDR(,#3)       GET CDR OF LIST\n         B     LENLOOP\nGOTLEN   DS    0H\n         CH    #2,=H'12'           IF LESS THAN 2 FIXNUMS IN LIST\n         BL    ERROR2              THEN ERROR\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LA    #0,16(,#11)         POINT TO CURRENT STACK LOCATION\n         #BASR #14,#15             CALL ZILBIG TO GET BIGNUM SPACE\n         SH    #2,=H'4'            SET LENGTH OF BIGNUM DATA\n         STCM  #2,7,1(#15)         STORE BIGNUM LENGTH\n         L     #3,0(,#11)          GET LIST ARG AGAIN\n         LA    #4,##VECDAT(,#15)   POINT TO FIRST SLOT IN BIGNUM\n         LR    #5,#4               SAVE THIS POINTER FOR CHECKING\nFIXLOOP  CR    #3,#10              PROCESS UNTIL END OF LIST\n         BE    FIXEND\n         L     #2,##CAR(,#3)       GET CAR OF (SUB)LIST\n         CLI   ##TYPE(#2),##FIXNUM IF IT IS NOT A FIXNUM\n         BNE   ERROR1              THEN ERROR\n         ICM   #7,15,##CDR(#2)     ELSE GET FIXNUM VALUE\n*                                  IF IT IS NEGATIVE\n         BNM   FIXOK               THEN (IT IS VALID ONLY IF FIRST #)..\n         CR    #4,#5               IF WE'RE PROCESSING THE FIRST FIXNUM\n         BNE   ERROR4              IT'S OK, ELSE IT'S AN ERROR.\nFIXOK    ST    #7,0(,#4)           IF OK, STORE VALUE INTO BIGNUM\n         LA    #4,4(,#4)           INCREMENT SLOT POINTER\n         L     #3,##CDR(,#3)       GET CDR OF LIST\n         B     FIXLOOP\nFIXEND   DS    0H\n*\n* AT THIS POINT #7 CONTAINS THE LAST FIXNUM STORED INTO THE BIGNUM.\n* IF THIS VALUE IS ZERO, WE HAVE BUILT AN UNNORMALIZED BIGNUM,\n* WHICH IS AN ERROR.\n*\n         LTR   #7,#7               IF LAST WORD OF BIGNUM IS ZERO,\n         BZ    ERROR3              THEN ERROR\n         CLC   0(12,#15),BADBIG    IF A BIGNUM -2147483648 WAS CREATED\n         BE    ERROR5              THEN ERROR\n*                                  ELSE MAKE BIGNUM PERMANENT\n         ST    #4,ZLCVSNXT         STORE END PTR FOR VSS\n         SPACE 1\nRETURN   DS    0H                  #15 POINTS TO BIGNUM BUILT\n         SPACE 1\n         #ZRET ,\n         SPACE 1\n         DS    0A                  ALIGN (BAD) BIGNUM TO FULLWORD\nBADBIG   DC    YL1(##BIGNUM),AL3(8),X'80000000',F'1'  -2**31 AS BIGNUM\n         SPACE 1\nERROR1   #ERR  'Argument to MAKE-BIGNUM not a proper list of 2 or more X\n               fixnums - ',0(#11)\nERROR2   EQU   ERROR1              Too few fixnums\nERROR3   #ERR  'The last fixnum passed to MAKE-BIGNUM cannot be zero.',X\n               X'0D',              Carriage return                     X\n               'Invalid argument: ',0(#11)\nERROR4   #ERR  'All fixnums in MAKE-BIGNUM argument must be nonnegativeX\n                except for the first.',                                X\n               X'0D',              Carriage return                     X\n               'Invalid argument: ',0(#11)\nERROR5   #ERR  'Attempt to make bignum -2**31 (most negative fixnum) deX\n               tected by MAKE-BIGNUM.',                                X\n               X'0D',              Carriage return                     X\n               'Invalid argument: ',0(#11)\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKFIXNUM": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00:\\x007\\x009\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 58, "newlines": 55, "modlines": 57, "user": "SEB1525"}, "text": "         TITLE 'MKFIXNUM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* MKFIXNUM TAKES A FLONUM AND MAKES A FIXNUM OUT OF IT.\n* THE NUMBER IS *NOT* CONVERTED; RATHER, THE CONTENTS OF THE FLONUM\n* ARE STUCK INTO THE FIXNUM PART.  THIS FUNCTION IS USED, AMONG OTHER\n* THINGS, TO HELP THE COMPILER COMPILE FLONUMS MORE ACCURATELY.\n*\n* If the argument is a single float, a single fixnum is returned.\n* If the argument is a double float, a CONS (pair) of fixnums is\n* returned.\n*\n***********************************************************************\nMKFIXNUM #ZBEG MINARGS=1,MAXARGS=1,NAME='MAKE-FIXNUM'\n         #ZPDS 1*4+12+0 (= 16)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #1,0(,#11)          LOAD ADDRESS OF ARG 1\n         CLI   ##TYPE(#1),##SFLOAT If arg 1 is a single-float\n         BE    MKSF                then process single-float\n         CLI   ##TYPE(#1),##DFLOAT If arg 1 is a double-float\n         BE    MKDF                then process double-float\n         B     ERROR               Else error\n         SPACE 1\nMKSF     DS    0H                  Single-float:  make one fixnum\n         SPACE 1\n         L     #2,##CDR(,#1)       Get flonum into GPR as fixnum\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN\n         SPACE 1\nMKDF     DS    0H                  Double-float:  make pair of fixnums\n         SPACE 1\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         LM    #3,#4,8(#1)         Get both halves of double flonum\n         LR    #2,#3               Get first half\n         #MKAT FIXED               Make a fixnum\n         ST    #15,0(,#11)         Save first fixnum\n         LR    #2,#4               Get second half\n         #MKAT FIXED               Make another fixnum\n         L     #1,0(,#11)          Get first fixnum\n         LR    #2,#15              Get second fixnum\n         L     #15,ZLCCONS         Get address of CONS\n         #BASR #14,#15             Call CONS to make a pair\n         B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\nERROR    DS    0H\n         #ERR  'Argument to MAKE-FIXNUM not a flonum - ',0(#11)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKFLONUM": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00R\\x00O\\x00Q\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 82, "newlines": 79, "modlines": 81, "user": "SEB1525"}, "text": "         TITLE 'MKFLONUM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* MKFLONUM TAKES A FIXNUM AND MAKES A FLONUM OUT OF IT.\n* THE NUMBER IS *NOT* CONVERTED; RATHER, THE CONTENTS OF THE FIXNUM\n* ARE STUCK INTO THE FLONUM PART.  THIS FUNCTION MAY BE USED TO\n* GENERATE SPECIFIC KNOWN-HEX-CONTENT FLONUMS.\n*\n* IF ONE ARG IS GIVEN, A SINGLE-FLOAT IS CREATED.\n* IF 2 ARGS ARE GIVEN, A DOUBLE-FLOAT IS CREATED.\n*\n***********************************************************************\nMKFLONUM #ZBEG MINARGS=1,MAXARGS=2,NAME='MAKE-FLONUM'\n         #ZPDS 2*4+12+0 (= 20)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #1,#2,0(#11)        LOAD ARGS 1 AND 2\n         CLI   ##TYPE(#1),##FIXNUM ARG MUST BE A FIXNUM\n         BNE   ERROR1              ELSE ERROR\n         CR    #2,#13              IF ARG2 IS OMITTED\n         BE    MKSINGLE            THEN MAKE A SINGLE-FLOAT\n         CR    #2,#10              IF ARG2 IS NIL\n         BE    MKSINGLE            THEN MAKE A SINGLE-FLOAT\n         CLI   ##TYPE(#2),##FIXNUM IF ARG2 IS SUPPLIED BUT NOT A FIXNUM\n         BNE   ERROR2              THEN ERROR\n         B     MKDOUBLE            ELSE MAKE A DOUBLE-FLOAT\n         SPACE 1\nMKSINGLE DS    0H                  MAKE A SINGLE-FLOAT\n         SPACE 1\n         LE    #F2,##CDR(,#1)      GET FIXNUM PART AS FLONUM\n         AE    #F2,=E'0'           NORMALIZE\n         STE   #F2,ZLCWORK         STORE\n         L     #2,ZLCWORK          LOAD INTO REG FOR CONSING\n         CL    #2,##CDR(,#1)       IF BITS DON'T MATCH\n         BE    OK                  THEN\n*                                   WARN USER NUMBER GOT NORMALIZED\n         #ERR  1,'MAKE-FLONUM is normalizing the value generated by itsX\n                argument - ',0(#11)\nOK       DS    0H\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN\n         SPACE 1\nMKDOUBLE DS    0H                  MAKE A DOUBLE-FLOAT\n         SPACE 1\n         L     #3,##CDR(,#1)       FIXNUM VALUE 1\n         L     #4,##CDR(,#2)       FIXNUM VALUE 2\n         STM   #3,#4,ZLCWORK       STORE TWO WORDS\n         SDR   #F0,#F0             NORMALIZE WHEN WE...\n         AD    #F0,ZLCWORK         LOAD AS A FLONUM\n         STD   #F0,TEMP            STORE\n         CLC   TEMP(8),ZLCWORK     IF BITS DON'T MATCH\n         BE    OK2                 THEN\n*                                   WARN USER NUMBER GOT NORMALIZED\n         #ERR  1,'MAKE-FLONUM is normalizing the value generated by itsX\n                arguments - ',0(#11),' and ',4(#11)\nOK2      DS    0H\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         #BASR #14,#15             CALL ZILMDF TO MAKE A DOUBLE-FLOAT\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nTEMP     DS    D\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'Argument 1 to MAKE-FLONUM not a fixnum - ',0(#11)\n         SPACE 1\nERROR2   DS    0H\n         #ERR  'Argument 2 to MAKE-FLONUM not a fixnum - ',4(#11)\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKFUNARG": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00=\\x00:\\x00<\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 61, "newlines": 58, "modlines": 60, "user": "SEB1525"}, "text": "         TITLE 'MKFUNARG - ZIL 1.3 INTERNAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A FUNARG (LEXICAL CLOSURE).                   *\n*                                                                     *\n* IT TAKES TWO ARGUMENTS - THE FUNCTION AND THE ENVIRONMENT.          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*            THIS ROUTINE HAS BEEN COMPLETELY RECODED TO BUILD THE    *\n*            NEW TYPE OF FUNARG OBJECT.  THE NEW OBJECT IS BUILT IN   *\n*            VECTOR/STRING SPACE RATHER THAN CONS SPACE, AND LOOKS    *\n*            LIKE A VECTOR.                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMKFUNARG #ZBEG MINARGS=2,MAXARGS=2,NAME='MAKE-FUNARG'\n         SPACE 1\n         #ZPDS 20\n         #ZSAV ,\n         SPACE 1\n         LA    #0,20(,#11)         SET CURRENT STACK POINTER FOR GC\n         SPACE 1\nRETRY    DS    0H\n         SPACE 1\n         L     #15,ZLCVSNXT        GET ADDRESS OF CURRENT VSS SLOT\n         LA    #2,12(,#15)         POINT TO WHERE OUR END WILL BE\n         L     #3,ZLCVSADR         ADDRESS + LENGTH OF V/S SPACE\n         A     #3,ZLCVSLEN         GIVES POINTER TO END OF SPACE\n         CR    #2,#3               IF OUR END IS PAST AVAILABLE END\n         BH    NOROOM              THEN NO ROOM - TRY TO GC\n         MVI   ##TYPE(#15),##FUNARG SET TYPE\n         LA    #0,8                 SET LENGTH\n         STCM  #0,7,1(#15)          (CURRENTLY ALWAYS 2 ELEMENTS*4=8)\n         MVC   ##VECDAT(8,#15),0(#11) MOVE ARGS 1&2 TO OUR \"VECTOR\"\n         ST    #2,ZLCVSNXT         UPDATE NEXT-SLOT POINTER\n         #ZRET ,                   RETURN WITH NEW OBJECT IN #15\n         SPACE 1\nNOROOM   DS    0H                  WHAT IF THERE'S NOT ENOUGH ROOM?\n         SPACE 1\n         LTR   #0,#0               IF WE'VE TRIED TO GC BEFORE\n         BZ    ERROR               THEN GIVE UP, NO V/S SPACE AVAILABLE\n         L     #9,ZLCGCEND         ELSE CLOBBER CONS SPACE POINTER\n         LR    #1,#10              DUMMY ARG 1 TO CONS = NIL\n         LR    #2,#10              DUMMY ARG 2 TO CONS = NIL\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS TO FORCE GARB COLLECTION\n         XR    #0,#0               CLEAR #0 TO STOP RETRY OF GC\n         B     RETRY               TRY AGAIN\n         SPACE 1\nERROR    #ERR  'ZIL2133 MAKE-FUNARG: No vector/string space available fX\n               or FUNARG.',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MKLIST": {"ttr": 3855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00A\\x00>\\x00@\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 65, "newlines": 62, "modlines": 64, "user": "SEB1525"}, "text": "         TITLE 'MKLIST - ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A LIST OF A REQUESTED SIZE.                   *\n*                                                                     *\n* IT TAKES ONE REQUIRED ARGUMENT - A FIXNUM SPECIFYING THE NUMBER OF  *\n* ELEMENTS IN THE LIST - AND ONE OPTIONAL ARGUMENT - THE VALUE TO     *\n* INITIALIZE THE CARS TO, DEFAULT BEING NIL.                          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note: This is not quite the same as Common Lisp MAKE-LIST.          *\n*       Common Lisp MAKE-LIST has the following syntax:               *\n*                                                                     *\n*       (make-list <size> &key :initial-element)                      *\n*                                                                     *\n* Thus, a possible definition of MAKE-LIST could be:                  *\n*                                                                     *\n* (defun make-list (size &key (initial-element nil))                  *\n*  (mklist size initial-element))                                     *\n*                                                                     *\n* (Naturally, the compiler should transform this into a MKLIST call.) *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMKLIST   #ZBEG MINARGS=1,MAXARGS=2,NAME='MKLIST'\n         SPACE 1\n         #ZPDS 2*4+12+0\n         #ZSAV ,\n         SPACE 1\n         L     #1,0(,#11)          LOAD ARG1\n         CLI   ##TYPE(#1),##FIXNUM IF ARG1 IS NOT A FIXNUM\n         BNE   ERROR1              THEN ERROR.  ELSE...\n         SPACE 1\n         C     #13,4(,#11)         IF ARG 2 NOT SUPPLIED\n         BNE   *+8                 THEN\n         ST    #10,4(,#11)          SET ARG 2 TO NIL\n         SPACE 1\n         LR    #15,#10             INITIALIZE NEW LIST TO NIL\n         ICM   #6,15,##CDR(#1)     GET VALUE OF FIXNUM INTO REGISTER\n         BZ    RETURN              IF ZERO, RETURN WITH NULL LIST\n         BM    ERROR2              IF NEGATIVE, ERROR\nLOOP     DS    0H                  ELSE...\n         LR    #2,#15              GET CONS ARG2 = CURRENT LIST\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         L     #1,4(,#11)          GET CONS ARG1 = VALUE\n         #BASR #14,#15             CALL CONS TO CONS VALUE ONTO LIST\n         BCT   #6,LOOP             CONTINUE\n         SPACE 1\nRETURN   DS    0H                  #15 POINTS TO LIST BUILT\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   #ERR  'Argument 1 to MKLIST not a non-negative fixnum - ',    X\n               0(#11)\nERROR2   EQU   ERROR1\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKSTRUCT": {"ttr": 3857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00=\\x00:\\x00<\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 61, "newlines": 58, "modlines": 60, "user": "SEB1525"}, "text": "         TITLE 'MKSTRUCT - ZIL 1.3 INTERNAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A STRUCTURE OF A REQUESTED SIZE.              *\n*                                                                     *\n* IT TAKES TWO REQUIRED ARGUMENTS: A FIXNUM SPECIFYING THE NUMBER OF  *\n* ELEMENTS IN THE STRUCTURE, AND A SYMBOL IDENTIFYING THE TYPE OF     *\n* THE STRUCTURE.                                                      *\n*                                                                     *\n* ALL ELEMENTS IN THE STRUCTURE ARE INITIALIZED TO NIL.               *\n*                                                                     *\n* COMPARE ZMSTRUCT, WHICH TRANSFORMS A LIST INTO A STRUCTURE.         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMKSTRUCT #ZBEG MINARGS=2,MAXARGS=2,NAME='MKSTRUCT'\n         SPACE 1\n         #ZPDS 2*4+12+0\n         #ZSAV ,\n         SPACE 1\n         LM    #1,#2,0(#11)        ARG1 = LENGTH, ARG2 = TYPE\n         CLI   ##TYPE(#1),##FIXNUM IF ARG1 IS NOT A FIXNUM\n         BNE   ERROR1              THEN ERROR.  ELSE...\n         CLI   ##TYPE(#2),##SYMBOL IF ARG2 IS NOT A SYMBOL\n         BNE   ERROR2              THEN ERROR.  ELSE...\n         ICM   #7,15,##CDR(#1)     GET VALUE OF FIXNUM INTO REGISTER\n         BNP   ERROR1              IF NOT POSITIVE, ERROR\n         SLA   #7,2                MULTIPLY BY 4 FOR VECTOR LENGTH\n         LR    #2,#7               SET LENGTH TO ALLOCATE\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF STRING SPACE SERVICE\n         LA    #0,20(,#11)         SET CURRENT STACK LOCATION\n         #BASR #14,#15             CALL ZILVSS TO BUILD THE OBJECT\n         LTR   #4,#4               IF STRING BUILD FAILED\n         BZ    ERROR3              THEN ERROR\n         MVI   ##TYPE(#15),##STRUCT SET OBJECT TYPE = STRUCTURE\n         L     #2,4(,#11)          GET ARG 2 (TYPE OF STRUCTURE)\n         ST    #2,0(,#4)           SET STRUCTURE TYPE\n         LA    #6,4                SET INCREMENT REGISTER FOR BXLE\n         SH    #7,=H'5'            SET TERMINATION REGISTER FOR BXLE\n         XR    #1,#1               SET INDEX REGISTER\nINITLOOP ST    #10,4(#1,#4)        INITIALIZE EACH ELEMENT TO NIL\n         BXLE  #1,#6,INITLOOP\n         SPACE 1\nRETURN   DS    0H                  #15 POINTS TO STRUCTURE BUILT\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   #ERR  'Arg 1 to MKSTRUCT not a positive fixnum - ',0(#11)\nERROR2   #ERR  'Arg 2 to MKSTRUCT not a symbol - ',4(#11)\nERROR3   #ERR  'ZIL4010 MKSTRUCT: Not enough vector/string space to buiX\n               ld structure ',4(#11),'.',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MKVECTOR": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x119\\x00@\\x00=\\x00?\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:39:00", "lines": 64, "newlines": 61, "modlines": 63, "user": "SEB1525"}, "text": "         TITLE 'MKVECTOR - ZIL 1.3 INTERNAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A VECTOR OF A REQUESTED SIZE.                 *\n*                                                                     *\n* IT TAKES ONE REQUIRED ARGUMENT - A FIXNUM SPECIFYING THE NUMBER OF  *\n* ELEMENTS IN THE VECTOR - AND ONE OPTIONAL ARGUMENT - THE VALUE TO   *\n* INITIALIZE THE SLOTS TO, DEFAULT BEING NIL.                         *\n*                                                                     *\n* COMPARE ZMVECTOR, WHICH TRANSFORMS A LIST INTO A VECTOR.            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note: It might be desirable to have MAKE-VECTOR be a LISP function  *\n*       that takes a keyword argument, much like MAKE-LIST.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMKVECTOR #ZBEG MINARGS=1,MAXARGS=2,NAME='MKVECTOR'\n         SPACE 1\n         #ZPDS 2*4+12+0\n         #ZSAV ,\n         SPACE 1\n         L     #7,0(,#11)          LOAD ARG1 = THE REQUESTED LENGTH\n         CLI   ##TYPE(#7),##FIXNUM IF ARG1 IS NOT A FIXNUM\n         BNE   ERROR1              THEN ERROR.  ELSE...\n         L     #7,##CDR(,#7)       GET VALUE OF FIXNUM INTO REGISTER\n         SLA   #7,2                MULTIPLY BY 4 FOR VECTOR LENGTH\n         LR    #2,#7               SET LENGTH TO ALLOCATE\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF STRING SPACE SERVICE\n         LA    #0,20(,#11)         SET CURRENT STACK LOCATION\n         #BASR #14,#15             CALL ZILVSS TO BUILD THE OBJECT\n         LTR   #4,#4               IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         MVI   ##TYPE(#15),##VECTOR SET OBJECT TYPE = VECTOR\n         L     #2,4(,#11)          GET ARG 2 (INITIAL VALUE OF VECTOR)\n         SPACE 1\n         CR    #2,#13              IF ARG 2 NOT SUPPLIED\n         BNE   *+6                 THEN\n         LR    #2,#10               SET ARG 2 TO NIL\n         SPACE 1\n         LA    #6,4                SET INCREMENT REGISTER FOR BXLE\n         BCTR  #7,0                SET TERMINATION REGISTER FOR BXLE\n         XR    #1,#1               SET INDEX REGISTER\nINITLOOP ST    #2,0(#1,#4)         INITIALIZE EACH ELEMENT TO NIL\n         BXLE  #1,#6,INITLOOP\n         SPACE 1\nRETURN   DS    0H                  #15 POINTS TO VECTOR BUILT\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   #ERR  'Argument to MKVECTOR not a fixnum - ',0(#11)\nERROR2   #ERR  'ZIL4010 MKVECTOR: Not enough vector/string space to buiX\n               ld vector.',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MSGLEVEL": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x000\\x00-\\x00/\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 48, "newlines": 45, "modlines": 47, "user": "SEB1525"}, "text": "         TITLE 'MSGLEVEL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MSGLEVEL TAKES ONE (OPTIONAL) ARGUMENT - A NUMBER FROM 0 TO 3.      *\n*                                                                     *\n* IF NIL IS SPECIFIED OR DEFAULTED, THE CURRENT MSGLEVEL IS RETURNED. *\n*                                                                     *\n***********************************************************************\n         SPACE\nMSGLEVEL #ZBEG MINARGS=0,MAXARGS=1,NAME='MSGLEVEL'\n         SPACE\n         L     #7,0(,#1)           PICK UP THE ARGUMENT\n         CR    #7,#10              IF ARGUMENT IS NIL\n         BE    ISNIL                OR\n         CR    #7,#13                ARGUMENT IS NOT SUPPLIED\n         BNE   NOTNIL                 THEN\nISNIL    XR    #2,#2                PICK UP CURRENT MSG LEVEL\n         IC    #2,ZLCMSLVL          FROM THE COMMON AREA\n         SLA   #2,3                 CONVERT TO INDEX INTO FIXNUM TABLE\n         LA    #15,#SFT(#2)         POINT TO THE APPROPRIATE VALUE\n         BR    #14                  AND RETURN WITH IT\n         SPACE 1\nNOTNIL   DS    0H                  ELSE NOT NIL\n         CLI   ##TYPE(#7),##FIXNUM IF ARG IS NOT A FIXNUM\n         BNE   BADVALUE            THEN ERROR. ELSE...\n         L     #2,##CDR(,#7)       GET FIXNUM VALUE\n         CL    #2,#SFW3            IF NOT (0 <= VALUE <= 3)\n         BH    BADVALUE            THEN VALUE IS OUT OF RANGE\n         STC   #2,ZLCMSLVL         ELSE SET THE VALUE\n         LR    #15,#7              LOAD ARG INTO RETURN REG\n         BR    #14                 RETURN WITH ARG AS THE RETURN\n         SPACE 1\n         DROP  #15\n         SPACE 1\n         LTORG\n         SPACE 1\nBADVALUE DS    0H\n         LR    #2,#15\n         USING MSGLEVEL,#2\n         #ERR  'Argument to MSGLEVEL not a fixnum between 0 and 3 - ', X\n               (#7)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NCONC2": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00D\\x00\\x88\\x01_\\x01\\x00&_\\x11W\\x004\\x001\\x003\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:57:44", "lines": 52, "newlines": 49, "modlines": 51, "user": "SEB1525"}, "text": "         TITLE 'NCONC2 - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NCONC2: NCONC FOR EXACTLY TWO ARGUMENTS.                            *\n*                                                                     *\n* THE COMPILER IMPLEMENTS NCONC AS A MACRO THAT EXPANDS INTO THE      *\n* REQUISITE CALLS TO NCONC2.                                          *\n*                                                                     *\n* UNDER THE INTERPRETER, NCONC IS A FUNCTION THAT TAKES AN &REST ARG  *\n* AND INVOKES NCONC2.                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNCONC2   #ZBEG MINARGS=2,MAXARGS=2,NAME='NCONC2'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING NCONC2,#3\n         SPACE 1\n         LM    #15,#0,0(#1)        LOAD THE ARGS, INITIALIZING RESULT\n         SPACE 1\n         CR    #15,#10             IF LIST 1 IS NIL,\n         BE    ARG1NIL             THEN GO TO RETURN LIST 2. ELSE...\n         LR    #2,#15              START PROCESSING SUBLISTS OF ARG 1\n         B     GO                  SKIP 1ST CDR - JUMP INTO LOOP\n         SPACE 1\nLOOP     DS    0H\n         L     #2,##CDR(,#2)       CONTINUE GOING DOWN LIST 1\nGO       DS    0H\n         TM    ##TYPE(#2),##ATOM   IF (SUB)LIST 1 NOT A LIST\n         BO    ERROR1              THEN ERROR\n         C     #10,##CDR(,#2)      IF CDR OF (SUB)LIST IS NOT NIL\n         BNE   LOOP                THEN CONTINUE LOOPING\nBASH     DS    0H                  ELSE...\n         ST    #0,##CDR(,#2)        BASH CDR OF (SUB)LIST WITH LIST 2\n         BR    #14                  AND RETURN THE (BASHED) ARG 1\n         SPACE 1\nARG1NIL  DS    0H\n         LR    #15,#0               RETURN LIST 2\n         BR    #14\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         L     #2,0(,#1)           Reload arg 1 from stack\n         #ERR  'Argument 1 to NCONC2 not a proper list - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NCONS": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x00\\x12\\x00\\x0f\\x00\\x11\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 18, "newlines": 15, "modlines": 17, "user": "SEB1525"}, "text": "         TITLE 'NCONS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNCONS    #ZBEG MINARGS=1,MAXARGS=1,NAME='NCONS'\n         SPACE 1\n         USING NCONS,#15\n         SPACE 1\n         L     #1,0(,#1)           ARG 1 --> ARG 1 TO CONS\n         L     #15,ZLCCONS\n         DROP  #15\n         LR    #2,#10              ARG 2 = NIL\n         BR    #15                 ZLCCONS WILL RETURN VIA OUR #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NOT": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x00\\x14\\x00\\x11\\x00\\x13\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 20, "newlines": 17, "modlines": 19, "user": "SEB1525"}, "text": "         TITLE 'NOT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNOT      #ZBEG MINARGS=1,MAXARGS=1,NAME='NOT'\n         SPACE 1\n         USING NOT,#15\n         SPACE 1\n         C     #10,0(,#1)\n         BNE   ZXNOTN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXNOTN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NRECONC": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Y\\x00\\x88\\x01_\\x01\\x00&_\\x11W\\x008\\x005\\x007\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:57:59", "lines": 56, "newlines": 53, "modlines": 55, "user": "SEB1525"}, "text": "         TITLE 'NRECONC - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (NRECONC X Y) IS EQUIVALENT TO (NCONC (NREVERSE X) Y).              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNRECONC  #ZBEG MINARGS=2,MAXARGS=2,NAME='NRECONC'\n         SPACE 1\n         LR    #7,#15\n         DROP  #15\n         USING NRECONC,#7\n         SPACE 1\n         LM    #15,#0,0(#1)        #15 = ARG1, #0 = ARG2\n         CR    #15,#10             IF ARG1 IS NIL\n         BNE   GOAHEAD             THEN\n         LR    #15,#0               RETURN WITH ARG2\n         BR    #14\nGOAHEAD  DS    0H\n         SPACE 1\n         TM    ##TYPE(#15),##ATOM  IF ARGUMENT IS NOT A LIST\n         BO    ERROR1              THEN ERROR\n         SPACE 1\n         L     #2,##CDR(,#15)      LOAD OLD-CDR WITH CDR OF ARGUMENT\n         LR    #3,#0               SET OLD-CAR TO ARG2\n         B     GO                  START UP LOOP\nNOTNULL  DS    0H                  ELSE...\n         TM    ##TYPE(#2),##ATOM   IF ARGUMENT IS NOT A LIST\n         BO    ERROR2              THEN ERROR\n         ST    #3,##CDR(,#15)      BASH CDR OF LIST WITH OLD-CAR\n         LR    #3,#15              SET OLD-CAR TO LIST\n         LR    #15,#2              SET LIST TO OLD-CDR\n         L     #2,##CDR(,#2)       SET OLD-CDR TO CDR OF OLD-CDR\nGO       DS    0H\n         CR    #2,#10              IF OLD-CDR IS NULL\n         BNE   NOTNULL             THEN...\n         ST    #3,##CDR(,#15)       BASH CDR OF LIST WITH OLD-CAR\n         BR    #14                  RETURN LIST\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         L     #2,0(,#1)           Reload arg 1 from stack\n         #ERR  'Argument 1 to NRECONC not a list - ',(#2)\n         SPACE 1\nERROR2   DS    0H                  ERROR IN ARGUMENT\n         L     #2,0(,#1)           Reload arg 1 from stack\n         #ERR  'Argument 1 to NRECONC not a proper list.',             X\n               X'0D',              carriage return                     X\n               'Value may have been destroyed - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NREVERSE": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x00\\x88\\x01_\\x01\\x00&_\\x11X\\x006\\x003\\x005\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:58:14", "lines": 54, "newlines": 51, "modlines": 53, "user": "SEB1525"}, "text": "         TITLE 'NREVERSE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NREVERSE TAKES ONE ARGUMENT - A LIST TO BE REVERSED IN PLACE.       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNREVERSE #ZBEG MINARGS=1,MAXARGS=1,NAME='NREVERSE'\n         SPACE 1\n         LR    #7,#15\n         DROP  #15\n         USING NREVERSE,#7\n         SPACE 1\n         L     #15,0(,#1)          LOAD THE ARGUMENT\n         CR    #15,#10             IF ARGUMENT IS NIL\n         BER   #14                 THEN RETURN NIL\n         SPACE 1\n         TM    ##TYPE(#15),##ATOM  IF ARGUMENT IS NOT A LIST\n         BO    ERROR1              THEN ERROR\n         SPACE 1\n         L     #2,##CDR(,#15)      LOAD OLD-CDR WITH CDR OF ARGUMENT\n         LR    #3,#10              SET OLD-CAR TO NIL\n         B     GO                  START UP LOOP\nNOTNULL  DS    0H\n         TM    ##TYPE(#2),##ATOM   IF ARGUMENT IS NOT A LIST\n         BO    ERROR2              THEN ERROR\n         ST    #3,##CDR(,#15)      BASH CDR OF LIST WITH OLD-CAR\n         LR    #3,#15              SET OLD-CAR TO LIST\n         LR    #15,#2              SET LIST TO OLD-CDR\n         L     #2,##CDR(,#2)       SET OLD-CDR TO CDR OF OLD-CDR\nGO       DS    0H\n         CR    #2,#10              IF OLD-CDR IS NULL\n         BNE   NOTNULL             THEN...\n         ST    #3,##CDR(,#15)       BASH CDR OF LIST WITH OLD-CAR\n         BR    #14                  RETURN LIST\n*                                  ELSE LOOP\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         L     #2,0(,#1)           Reload arg 1 from stack\n         #ERR  'Argument 1 to NREVERSE not a list - ',(#2)\n         SPACE 1\nERROR2   DS    0H                  ERROR IN ARGUMENT\n         L     #2,0(,#1)           Reload arg 1 from stack\n         #ERR  'Argument 1 to NREVERSE not a proper list.',            X\n               X'0D',              carriage return                     X\n               'Value may have been destroyed - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NTH": {"ttr": 4111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00(\\x00\\x88\\x01_\\x01\\x00&_\\x11X\\x00.\\x00+\\x00-\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:58:28", "lines": 46, "newlines": 43, "modlines": 45, "user": "SEB1525"}, "text": "         TITLE 'NTH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NTH TAKES TWO ARGUMENTS - A NUMBER AND A LIST.                      *\n*                                                                     *\n* THIS FUNCTION IS NON-RECURSIVE AND TAKES NO STACK SPACE.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNTH      #ZBEG MINARGS=2,MAXARGS=2,NAME='NTH'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING NTH,#3\n         SPACE 1\n         LM    #15,#0,0(#1)        LOAD THE ARGUMENTS\n         LA    #2,1                PREPARE A 1\n         CLI   ##TYPE(#15),##FIXNUM IF ARG 1 NOT A FIXNUM\n         BNE   ERROR1              THEN ERROR\n         A     #2,##CDR(,#15)      GET FIXNUM VALUE + 1\n         BNP   ERROR1              IF VALUE WAS NEGATIVE, ERROR\nLOOP     DS    0H                  ELSE...\n         LR    #15,#0              LOAD NEXT ARG2\n         CR    #15,#10             IF ARG 2 IS NULL\n         BER   #14                 THEN RETURN NIL\n         LM    #15,#0,##CAR(#15)   LOAD NEXT CAR AND CDR\n         LTR   #15,#15             IF WE LOADED FROM AN ATOM\n         BM    ERROR2              THEN AN IMPROPER LIST WAS PASSED\n         BCT   #2,LOOP             DECR COUNT. IF NONZERO, CONTINUE\n         BR    #14                 ELSE RETURN THIS CAR\n         SPACE 1\nERROR1   DS    0H\n         L     #2,0(,#1)\n         #ERR  'Argument 1 to NTH not a nonnegative fixnum - ',(#2)\n         SPACE 1\nERROR2   DS    0H\n         L     #2,4(,#1)\n         #ERR  'Argument 2 to NTH not a proper list - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NTHCDR": {"ttr": 4113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x00/\\x00,\\x00.\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 47, "newlines": 44, "modlines": 46, "user": "SEB1525"}, "text": "         TITLE 'NTHCDR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NTHCDR TAKES TWO ARGUMENTS - A NUMBER AND A LIST.                   *\n*                                                                     *\n* THIS FUNCTION IS NON-RECURSIVE AND TAKES NO STACK SPACE.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNTHCDR   #ZBEG MINARGS=2,MAXARGS=2,NAME='NTHCDR'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING NTHCDR,#3\n         SPACE 1\n         LM    #5,#6,0(#1)         LOAD THE ARGUMENTS\n         CLI   ##TYPE(#5),##FIXNUM IF ARG 1 NOT A FIXNUM\n         BNE   ERROR1              THEN ERROR\n         ICM   #2,15,##CDR(#5)     GET FIXNUM VALUE\n         BM    ERROR1              IF NEGATIVE, THEN ERROR\n         LR    #15,#6\nLOOP     DS    0H\n         CR    #15,#10             IF ARG 2 IS NULL\n         BER   #14                 THEN RETURN NIL\n         TM    ##TYPE(#15),##ATOM  IF ARG 2 IS AN ATOM\n         BO    ERROR2              THEN AN IMPROPER LIST WAS PASSED\n         LTR   #2,#2               IF ZERO\n         BZR   #14                 THEN RETURN THIS PART OF LIST\n         L     #15,##CDR(,#15)     ELSE GET CDR OF LIST\n         BCTR  #2,0                SET N = N - 1\n         B     LOOP                REPEAT UNTIL N = 0 OR END OF LIST\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT 1\n         L     #2,0(,#1)\n         #ERR  'Argument 1 to NTHCDR not a nonnegative fixnum - ',(#2)\n         SPACE 1\nERROR2   DS    0H                  ERROR IN ARGUMENT 1\n         L     #2,4(,#1)\n         #ERR  'Argument 2 to NTHCDR not a proper list - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NULL": {"ttr": 4115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x00\\x14\\x00\\x11\\x00\\x13\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 20, "newlines": 17, "modlines": 19, "user": "SEB1525"}, "text": "         TITLE 'NULL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNULL     #ZBEG MINARGS=1,MAXARGS=1,NAME='NULL'\n         SPACE 1\n         USING NULL,#15\n         SPACE 1\n         C     #10,0(,#1)\n         BNE   ZXNULLN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXNULLN  LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NUMBERP": {"ttr": 4117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'NUMBERP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nNUMBERP  #ZBEG MINARGS=1,MAXARGS=1,NAME='NUMBERP'\n         SPACE 1\n         USING NUMBERP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##FLONUM\n         BL    ZXNUMN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXNUMN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OBLIST": {"ttr": 4119, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x00\\x13\\x00\\x10\\x00\\x12\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 19, "newlines": 16, "modlines": 18, "user": "SEB1525"}, "text": "         TITLE 'OBLIST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* OBLIST TAKES NO ARGUMENTS.                                          *\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND TAKES NO STACK SPACE.             *\n*                                                                     *\n***********************************************************************\n         SPACE\nOBLIST   #ZBEG MINARGS=0,MAXARGS=0,NAME='OBLIST'\n         SPACE\n         L     #15,ZLCOBLST        LOAD ADDRESS OF OBLIST\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ODDP": {"ttr": 4121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00E\\x00\\x88\\x01_\\x01\\x00&_\\x11X\\x00#\\x00 \\x00\"\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:58:45", "lines": 35, "newlines": 32, "modlines": 34, "user": "SEB1525"}, "text": "         TITLE 'ODDP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ODDP TAKES ONE ARGUMENT - AN INTEGER                                *\n*                                                                     *\n***********************************************************************\nODDP     #ZBEG MINARGS=1,MAXARGS=1,NAME='ODDP'\n         SPACE\n         USING ODDP,#15\n         SPACE\n         L     #2,0(,#1)           LOAD FIRST (AND ONLY) ARGUMENT\n         TM    ##TYPE(#2),##INT    MUST BE INTEGER (FIXNUM OR BIGNUM)\n         BNO   ERROR\n         TM    ##CDR+3(#2),X'01'   TEST FOR ODD\n         BZ    FALSE               FALSE IF EVEN\nTRUE     DS    0H\n         LR    #15,#8              TRUE... SET RESULT TO T\n         BR    #14\nFALSE    DS    0H\n         LR    #15,#10             FALSE... SET RESULT TO NIL\n         BR    #14\n         SPACE\nERROR    DS    0H                  NOT A NUMERIC ATOM\n         LR    #3,#15\n         DROP  #15\n         USING ODDP,#3\n         #ERR  'Argument to ODDP not an integer - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OFILEP": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11@\\x00 \\x00\\x1d\\x00\\x1f\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:40:00", "lines": 32, "newlines": 29, "modlines": 31, "user": "SEB1525"}, "text": "         TITLE 'OFILEP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* OFILEP TAKES ONE (REQUIRED) ARGUMENT - OUTPUT FILE SPEC             *\n*                                                                     *\n***********************************************************************\n         SPACE\nOFILEP   #ZBEG MINARGS=1,MAXARGS=1,NAME='OFILEP'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         OI    ZLCERFLG,ZLCERCFA   INDICATE CONDITIONAL FILE ACCESS\n         #OFIL 1                   ARG 1 = OUTPUT FILE SPEC\n         NI    ZLCERFLG,255-ZLCERCFA TURN CONDITIONAL FILE ACCESS OFF\n         SPACE 1\n         LTR   #7,#7               IF FILE WAS FOUND\n         BZ    FALSE               THEN\n         LR    #15,#8               RETURN T\n         B     RETURN              ELSE\nFALSE    LR    #15,#10              RETURN NIL\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PBIND": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x01\\x00\\x88\\x01_\\x01\\x00&_\\x11Y\\x00$\\x00!\\x00#\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:59:01", "lines": 36, "newlines": 33, "modlines": 35, "user": "SEB1525"}, "text": "         TITLE 'PBIND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This function loads the \"binding cell\" of a symbol.  This is        *\n* what is actually called the \"value cell\", but is being used as      *\n* a cell to contain global dynamic bindings in the current            *\n* deep-binding implementation of ZIL.  In a shallow-binding           *\n* implementation, this will be a true value cell, and this            *\n* function will disappear.                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPBIND    #ZBEG MINARGS=1,MAXARGS=1,NAME='PBIND'\n         SPACE 1\n         USING PBIND,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##SYMBOL\n         BNE   PBERROR\n         L     #15,##PVALUE(,#2)\n         BR    #14\n         SPACE 1\nPBERROR  DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING PBIND,#3\n         #ERR  'Argument to PBIND not a symbol - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSIZE": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00\\x13\\x00\\x10\\x00\\x12\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 19, "newlines": 16, "modlines": 18, "user": "SEB1525"}, "text": "         TITLE 'PDSIZE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nPDSIZE   #ZBEG MINARGS=0,MAXARGS=0,NAME='PDSIZE'\n         #ZPDS 12                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #2,ZLCPDSIZ         GET SIZE VALUE FROM COMMON AREA\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         #ZRET ,                   RETURN WITH IT\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PEEK": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00=\\x004\\x00<\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 61, "newlines": 52, "modlines": 60, "user": "SEB1525"}, "text": "         TITLE 'PEEK - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  PEEK TAKES 1 ARGUMENT, A FIXNUM, AND USES IT AS A POINTER INTO     *\n*       VIRTUAL STORAGE.  IT RETURNS A FIXNUM WHICH CONTAINS THE      *\n*       CONTENTS OF THE FULLWORD OF MEMORY AT THE SPECIFIED LOCATION. *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: THIS MODULE USES 31-BIT ADDRESSING AND REQUIRES H ASSEMBLER.  *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         SPACE 1\nPEEK     #ZBEG MINARGS=1,MAXARGS=1,NAME='PEEK'\n         #ZPDS 16\n         #ZSAV ,\n         SPACE 1\n         L     #1,0(,#11)          GET ARGUMENT 1\n         CLI   ##TYPE(#1),##FIXNUM MUST BE A FIXNUM\n         BNE   ERROR1              ELSE ERROR\n         L     #2,##CDR(,#1)       GET FIXNUM VALUE\n         SPACE 1\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 31\n         L     #1,=A(CODE31+X'80000000') ADDRESS OF THIS CODE\n         LA    #3,CODE31E          RETURN ADDRESS\n         BSM   #3,#1\nCODE31   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n*\n* WARNING: PROGRAM CHECK MAY OCCUR HERE...\n*\n         L     #2,0(,#2)           GET DATA AT POINTER LOCATION\n*\n* END OF WARNING\n*\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 31 TO CURRENT AMODE\n         BSM   0,#3\nCODE31E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         SPACE 1\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'Argument to Peek not a fixnum - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PEEKB": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\"\\x00\\x88\\x01_\\x01\\x00&_\\x11Y\\x00?\\x006\\x00>\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:59:22", "lines": 63, "newlines": 54, "modlines": 62, "user": "SEB1525"}, "text": "         TITLE 'PEEKB - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  PEEKB TAKES 1 ARGUMENT, A FIXNUM, AND USES IT AS A POINTER INTO    *\n*       VIRTUAL STORAGE.  IT RETURNS A FIXNUM WHICH CONTAINS THE      *\n*       CONTENTS OF THE BYTE AT THE SPECIFIED LOCATION.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: THIS MODULE USES 31-BIT ADDRESSING AND REQUIRES H ASSEMBLER.  *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         SPACE 1\nPEEKB    #ZBEG MINARGS=1,MAXARGS=1,NAME='PEEKB'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING PEEKB,#3\n         SPACE 1\n         L     #1,0(,#1)           GET ARGUMENT 1\n         CLI   ##TYPE(#1),##FIXNUM MUST BE A FIXNUM\n         BNE   ERROR1              ELSE ERROR\n         L     #4,##CDR(,#1)       GET FIXNUM VALUE\n         XR    #2,#2               CLEAR INSERT REGISTER\n         SPACE 1\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 31\n         L     #1,=A(CODE31+X'80000000') ADDRESS OF THIS CODE\n         LA    #7,CODE31E          RETURN ADDRESS\n         BSM   #7,#1\nCODE31   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n*\n* WARNING: PROGRAM CHECK MAY OCCUR HERE...\n*\n         IC    #2,0(,#4)           GET DATA AT POINTER LOCATION\n*\n* END OF WARNING\n*\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 31 TO CURRENT AMODE\n         BSM   0,#7\nCODE31E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         SPACE 1\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Load address of fixnum from table\n         BR    #14                 Return to caller with fixnum\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'Argument to PEEKB not a fixnum - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PLIST": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x006\\x00\\x88\\x01_\\x01\\x00&_\\x11Y\\x00\\x19\\x00\\x16\\x00\\x18\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:59:36", "lines": 25, "newlines": 22, "modlines": 24, "user": "SEB1525"}, "text": "         TITLE 'PLIST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPLIST    #ZBEG MINARGS=1,MAXARGS=1,NAME='SYMBOL-PLIST'\n         SPACE 1\n         USING PLIST,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##SYMBOL\n         BNE   PLSERROR\n         L     #15,##PLIST(,#2)\n         BR    #14\n         SPACE 1\nPLSERROR DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING PLIST,#3\n         #ERR  'Argument to SYMBOL-PLIST not a symbol - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PLUSP": {"ttr": 4365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x05\\x00\\x88\\x01_\\x01\\x00&_\\x12\\x00\\x00*\\x00'\\x00)\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T12:00:05", "lines": 42, "newlines": 39, "modlines": 41, "user": "SEB1525"}, "text": "         TITLE 'PLUSP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* PLUSP TAKES ONE ARGUMENT - A NUMERIC ATOM                           *\n*                                                                     *\n***********************************************************************\nPLUSP    #ZBEG MINARGS=1,MAXARGS=1,NAME='PLUSP'\n         SPACE 1\n         L     #2,0(,#1)           LOAD FIRST (AND ONLY) ARGUMENT\n         CLI   ##TYPE(#2),##FLONUM MUST BE NUMERIC ATOM\n         BL    ERROR               ELSE ERROR\n*\n* THE FOLLOWING TEST WORKS FOR FIXNUMS AND FLONUMS.\n* It works for double floats only because ZILMDF duplicates the left\n* half of the flonum when it builds one (and so does the compiler).\n* If anyone changes that behavior, this code must be changed.\n*\n         ICM   #0,15,##CDR(#2)     LOAD THE VALUE (WORKS FOR FIX&FLO)\n         BP    TRUE                IF VALUE POSITIVE, RETURN T\n         BM    FALSE               IF VALUE NEGATIVE, RETURN NIL\n*                                  IF VALUE ZERO, SEE IF BIGNUM\n         CLI   ##TYPE(#2),##BIGNUM IF BIGNUM AND NOT NEGATIVE\n         BE    TRUE                THEN MUST BE POSITIVE, RETURN T\n******** B     FALSE               ELSE IS ZERO, RETURN NIL\nFALSE    LR    #15,#10             RETURN NIL\n         BR    #14\nTRUE     LR    #15,#8              RETURN T\n         BR    #14\n         SPACE 1\nERROR    DS    0H                  NOT A NUMERIC ATOM\n         LR    #3,#15\n         DROP  #15\n         USING PLUSP,#3\n         #ERR  'Argument to PLUSP not numeric - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PNAME": {"ttr": 4367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x008\\x00\\x88\\x01_\\x01\\x00&_\\x12\\x02\\x00\\x19\\x00\\x16\\x00\\x18\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T12:02:38", "lines": 25, "newlines": 22, "modlines": 24, "user": "SEB1525"}, "text": "         TITLE 'PNAME - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPNAME    #ZBEG MINARGS=1,MAXARGS=1,NAME='SYMBOL-NAME'\n         SPACE 1\n         USING PNAME,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##SYMBOL\n         BNE   PNERROR\n         L     #15,##PNAME(,#2)\n         BR    #14\n         SPACE 1\nPNERROR  DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING PNAME,#3\n         #ERR  'Argument to SYMBOL-NAME not a symbol - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PREFIX": {"ttr": 4369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00P\\x00M\\x00O\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 80, "newlines": 77, "modlines": 79, "user": "SEB1525"}, "text": "         TITLE 'PREFIX - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  PREFIX RETURNS THE TSO PREFIX, OR NIL IF NON-TSO ENVIRONMENT.      *\n*                                                                     *\n*  NOTE THAT THE PREFIX MAY BE A NULL STRING.                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPREFIX   #ZBEG MINARGS=0,MAXARGS=0,NAME='PREFIX'\n         #ZPDS 12\n         #ZSAV ,\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FIRST, GET THE UPT PREFIX VALUE.                                    *\n*                                                                     *\n***********************************************************************\n         L     #3,X'21C'           GET TCB ADDRESS\n         L     #3,X'B4'(,#3)       GET JSCB ADDRESS\n         L     #3,X'15C'(,#3)      GET ACTIVE JSCB ADDRESS\n         ICM   #3,15,X'108'(#3)    GET PSCB ADDRESS\n         BZ    RETNIL              IF NONE, NON-TSO, RETURN NIL\n         USING PSCB,#3\n         L     #3,PSCBUPT          GET UPT ADDRESS\n         DROP  #3\n         USING UPT,#3              GET UPT ADDRESS\n         XR    #2,#2               CLEAR LENGTH REGISTER\n         ICM   #2,1,UPTPREFL       GET LENGTH OF UPT PREFIX\n         ST    #2,LENGTH           SAVE LENGTH\n         BZ    RETSTR              IF ZERO, BYPASS DATA MOVE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THEN, GET VECTOR/STRING SPACE TO HOLD THE PREFIX.                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n******** L     #2,LENGTH           GET LENGTH INTO REG FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,12(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #15,#15             IF STRING BUILD FAILED\n         BZ    ERROR               THEN ERROR\n         L     #2,LENGTH           GET LENGTH OF TSO PREFIX\n         BCTR  #2,0                REDUCE FOR EXECUTE\n         EX    #2,MOVEIT           MOVE DATA FROM UPT TO OUR STRING\n         B     RETURN\nRETNIL   DS    0H                  HERE IF TSO NOT ACTIVE\n         LR    #15,#10\n         B     RETURN\nRETSTR   DS    0H                  HERE IF TSO BUT NO PREFIX\n         LA    #15,NULLSTR\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         #ZRET ,\n         SPACE 1\nERROR    #ERR  PREFIX=NO,          NOT ENUF ROOM                       X\n               'ZIL4010 PREFIX: Not enough vector/string space to returX\n               n TSO prefix.'\n         SPACE 1\nMOVEIT   MVC   ##VECDAT(*-*,#15),UPTPREFX X'D: MOVE UPTPREFX TO STRING\n         SPACE 1\nNULLSTR  DS    0A                  THE NULL STRING\n         DC    YL1(##STRING),AL3(0),XL4'00'\n         SPACE 1\nLENGTH   DC    F'0'\n         SPACE 1\n         LTORG\n         SPACE 1\n         IKJPSCB\n         IKJUPT\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PUTPROP": {"ttr": 4372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00\\\\\\x00Y\\x00[\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 92, "newlines": 89, "modlines": 91, "user": "SEB1525"}, "text": "         TITLE 'PUTPROP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* PUTPROP TAKES 3 ARGUMENTS.                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPUTPROP  #ZBEG MINARGS=3,MAXARGS=3,NAME='PUTPROP'\n         SPACE 1\n         #ZPDS 3*4+12\n         #ZSAV ,\n         SPACE 1\n         LM    #5,#7,0(#11)        LOAD THE ARGUMENTS\n         CLI   ##TYPE(#5),##SYMBOL ARG 1 MUST BE A SYMBOL\n         BNE   NOTSYM\n         L     #2,##PLIST(,#5)     LOAD PROPERTY LIST OF ARG 1\nPROCESS  DS    0H\n         CR    #2,#10              IF NONEXISTENT OR NIL\n         BE    NOMORE              THEN WE HAVE TO MAKE A NEW PLIST\n         LR    #4,#2               SAVE CURRENT PROPERTY LIST ADDRESS\nLOOP     DS    0H                  ELSE SEARCH EXISTING PLIST\n         TM    ##TYPE(#4),##ATOM   CHECK VALIDITY OF PROPERTY LIST\n         BO    ERROR2\n         L     #1,##CDR(,#4)       GET READY WITH CDR OF (SUB)PLIST\n         TM    ##TYPE(#1),##ATOM   CHECK VALIDITY OF PROPERTY LIST\n         BO    ERROR2\n         C     #7,##CAR(,#4)       IF CAR OF (SUB)PLIST EQ TO INDICATOR\n         BNE   NOTEQ               THEN...\n         ST    #6,##CAR(,#1)        BASH CADR THEREOF TO REPLACE VALUE\n         B     RETURN              ELSE...\nNOTEQ    DS    0H                   (HAVEN'T FOUND IT YET)\n         L     #4,##CDR(,#1)        BUMP TO NEXT PAIR IN (SUB)PLIST\n         CR    #4,#10               IF ANY MORE PROP/VALUE PAIRS LEFT\n         BNE   LOOP                 THEN CONTINUE LOOP\nNOMORE   DS    0H                  OTHERWISE INDICATOR ISN'T THERE NOW\n*\n* AT THIS POINT ZIL USED TO STICK PROPERTY LIST STUFF ONTO THE END OF\n* THE EXISTING PROPERTY LIST.  IT'S REALLY SUPPOSED TO BE CONSED ONTO\n* THE FRONT OF IT, HOWEVER, AND THAT'S WHAT WE'RE GOING TO DO NOW.\n*\n*                                  (CONS #7 (CONS #6 OLD-PLIST))\n*                                  #2 ALREADY POINTS TO OLD PLIST\n*\n         LR    #1,#6               PROPERTY VALUE\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         LA    #0,24(,#11)         POINT TO CURRENT STACK LOCATION\n         #BASR #14,#15             CONS (PROPERTY-VALUE) NIL\n         L     #1,8(,#11)          INDICATOR (ARG 3)\n         LR    #2,#15              RESULT OF PREVIOUS CONS\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         LA    #0,24(,#11)         POINT TO CURRENT STACK LOCATION\n         #BASR #14,#15             CONS INDICATOR *\n         LM    #5,#6,0(#11)        RELOAD OTHER ARGS\n         TM    ##TYPE(#5),##ATOM   If arg 1 was a list\n         BO    BASHSYM             then\n         ST    #15,##CDR(,#5)       bash cdr of the list\n         B     RETURN              else\nBASHSYM  DS    0H\n         ST    #15,##PLIST(,#5)     BASH PLIST OF THE SYMBOL\n         SPACE 1\nRETURN   DS    0H\n         LR    #15,#6              RETURN THE PROPERTY AS VALUE\n         #ZRET ,                   RETURN TO CALLER\n         SPACE 1\nNOTSYM   DS    0H                  Arg 1 not a symbol\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FOR COMPATIBILITY WITH MACLISP AND OTHER APPLICATIONS THAT USE      *\n* DISEMBODIED PROPERTY LISTS, IF ARG 1 IS A LIST THEN WE ACCEPT IT.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ##TYPE(#5),##ATOM   See if it's a list\n         BO    ERROR1              If so, then...\n         L     #2,##CDR(,#5)        get CDR and use as property list\n         B     PROCESS\n         SPACE 1\nERROR1   DS    0H                  Arg 1 not even a list...\n         #ERR  'Argument 1 to PUTPROP not a symbol - ',0(#11)\n         SPACE 1\nERROR2   DS    0H\n         #ERR  'ZIL4011 PUTPROP: Invalid property list found for ',    X\n               0(#11),PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RANDOM": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00t\\x00q\\x00s\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 116, "newlines": 113, "modlines": 115, "user": "SEB1525"}, "text": "         TITLE 'RANDOM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS A COPY OF THE PROGRAM SHOWN BELOW, TRANSFORMED INTO A ZIL   *\n* FUNCTION BY STEVE BACHER.                                           *\n*                                                                     *\n* IF ARG 1 IS OMITTED OR NIL, THE SEED KEY IS RESET.  OTHERWISE THE   *\n* KEY IS SET BASED ON THE CURRENT COMPUTATION FOR THE NEXT CALL.      *\n*                                                                     *\n* NOTE: THE SECOND ARGUMENT, SUPPOSED TO REPRESENT A RANDOM STATE     *\n* OBJECT, IS CURRENTLY IGNORED AND OPTIONAL, BUT ESTABLISHED FOR      *\n* COMMON LISP FUNCTION-CALL-LEVEL COMPATIBILITY.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*********************************************************************\n*  PROGRAM: CS226HW1                                                *\n*  AUTHOR: DAYTON T. MARCOTT                                        *\n*  DESCRIPTION:                                                     *\n*      THIS PROGRAM WRITTEN BY HOMER PETERSON OF LINCOLN LABRATORY. *\n*  REAL FUNCTION RAN2 (SINGLE OR DOUBLE PRECISION)                  *\n*  INPUT IN CALLING SEQUENCE:  SEED  INTEGER                        *\n*  OUTPUT IN CALLING SEQUENCE: REVISED SEED  INTEGER                *\n*  OUTPUT IN FLOATING POINT REGISTER: RANDOM NUMBER BETWEEN 0 & 1   *\n*                                                                   *\n*********************************************************************\n*\nRANDOM   #ZBEG MINARGS=0,MAXARGS=2,NAME='RANDOM'\n         #ZPDS 2*4+12+0 = 20\n         #ZSAV ,\n         SPACE 1\n         C     #13,4(,#11)         If ARG 2 supplied\n         BE    ARG2OK              then warn user\n         #ERR  1,'Optional arg 2 to RANDOM currently ignored by ZIL.'\nARG2OK   DS    0H\n         L     #3,0(,#11)          GET ARGS 1 AND 2\n         XR    #4,#4               INITIALIZE FIX/FLO INDICATOR\n         CR    #3,#10              IF ARG 1 IS NIL\n         BE    ISNIL                OR\n         CR    #3,#13                ARG 1 IS OMITTED\n         BNE   NOTNIL                 THEN...\nISNIL    XC    ZLCRANDK,ZLCRANDK       RESET KEY TO INITIAL VALUE\n         L     #3,=X'7FFFFFFF'         NO LIMIT ON VALUE\n         B     RANFIX                  AND PROCESS AS RANDOM FIXNUM\nNOTNIL   DS    0H\n         CLI   ##TYPE(#3),##FIXNUM IF FIXNUM\n         BE    RANFIX              THEN PROCESS RANDOM FIXNUM\n         TM    ##TYPE(#3),##FLONUM IF FLONUM, OK\n         BNO   ERROR               ELSE NOT SUPPORTED\n         LA    #4,1                SET FLONUM INDICATOR\n         SPACE 1\nRANFIX   DS    0H\n         L     #1,ZLCRANDK     GET KEY\n         LTR   #1,#1           SEE IF POSITIVE\n         BP    OK              OK IF IT IS\n         LA    #1,3141         IF NOT CHOOSE ONE\nOK       M     #0,=F'161051'   PRIMITIVE ROOT\n         D     #0,=X'7FFFFFFF' OF 2**31-1\n         ST    #0,ZLCRANDK     RETURN KEY\n         LTR   #4,#4               IF ASKING FOR A FLONUM\n         BNZ   SETFLO              THEN GO GENERATE ONE\n         ICM   #3,15,##CDR(#3)     GET FIXNUM VALUE OF ARG 1\n         BNP   ERROR               MUST BE POSITIVE\n         SRDA  #0,32               PREPARE FOR ANOTHER DIVIDE\n         DR    #0,#3               DIVIDE TO GET REMAINDER\n         LR    #2,#0               REMAINDER IN #0, QUOTIENT IN #1\n         LA    #0,20(,#11)         PASS STACK POINTER TO CONS\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         B     RETURN\n         SPACE 1\nSETFLO   DS    0H\n         SPACE 1\n         CLI   ##TYPE(#3),##DFLOAT IF IT IS A DOUBLE FLOAT\n         BE    SETDFLO             THEN GO DO A DOUBLE\n         SPACE 1\n         ST    #0,FLOAT        PREPARE TO FLOAT\n         LD    #F0,TEMP         LOAD A NUMBER BETWEEN 0 & .5\n         AD    #F0,TEMP         DOUBLE IT AND NORMALIZE\n         ME    #F0,##CDR(,#3)      MULTIPLY BY FLONUM VALUE OF ARG 1\n         STE   #F0,ZLCWORK\n         L     #2,ZLCWORK\n         LA    #0,20(,#11)         PASS STACK POINTER TO CONS\n         #MKAT FLOAT\n         B     RETURN\n         SPACE 1\nSETDFLO  DS    0H\n         SPACE 1\n         ST    #0,FLOAT        PREPARE TO FLOAT\n         LD    #F0,TEMP         LOAD A NUMBER BETWEEN 0 & .5\n         AD    #F0,TEMP         DOUBLE IT AND NORMALIZE\n         MD    #F0,8(,#3)       MULTIPLY BY FLONUM VALUE OF ARG 1\n         LA    #0,20(,#11)         PASS CURRENT STACK POINTER TO CONS\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,\nTEMP     DS    0D             DOUBLE WORD ALIGN\nCHAR     DC    X'46000000'    CHARACTERISTIC TO FLOAT RESULT\nFLOAT    DS    F'0'\n         SPACE 1\nERROR    DS    0H\n         #ERR  'Argument 1 to RANDOM not a positive fixnum or flonum - X\n               ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMPROP": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00R\\x00\\x88\\x01_\\x01\\x00&_\\x12\\x02\\x00W\\x00T\\x00V\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T12:02:52", "lines": 87, "newlines": 84, "modlines": 86, "user": "SEB1525"}, "text": "         TITLE 'REMPROP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* REMPROP TAKES 2 ARGUMENTS.                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nREMPROP  #ZBEG MINARGS=2,MAXARGS=2,NAME='REMPROP'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING REMPROP,#3\n         SPACE 1\n         LM    #5,#6,0(#1)         LOAD THE ARGUMENTS\n         CLI   ##TYPE(#5),##SYMBOL ARG 1 MUST BE A SYMBOL\n         BNE   NOTSYM\n         L     #7,##PLIST(,#5)     LOAD PROPERTY LIST OF ARG 1\nPROCESS  DS    0H\n         CR    #7,#10              IF NULL\n         BE    RETNIL              THEN RETURN NIL\n         TM    ##TYPE(#7),##ATOM   CHECK VALIDITY OF PROPERTY LIST\n         BO    ERROR2\n         C     #6,##CAR(,#7)       IF FIRST PROPERTY ON LIST MATCHES\n         L     #7,##CDR(,#7)       (SKIP TO REST OF PLIST)\n         BNE   LOOP                THEN (REMOVE PROPERTY) ...\n         LM    #15,#0,##CAR(#7)     LOAD VALUE AND REST OF PLIST\n         LTR   #15,#15              IF IT WAS AN ATOM\n         BM    ERROR2               THEN ERROR\n         TM    ##TYPE(#5),##ATOM   IF ARG 1 WAS AN ATOM\n         BZ    BASHLIST            THEN\n         ST    #0,##PLIST(,#5)      SET PLIST TO REST OF CURRENT PLIST\n         BR    #14                 ELSE\nBASHLIST ST    #0,##CDR(,#5)        SET CDR TO REST OF CURRENT PLIST\n         BR    #14                 RETURN THE OLD PROPERTY VALUE\n         SPACE 1\nLOOP     DS    0H                  POINTING TO CELL BEFORE PAIR\n         TM    ##TYPE(#7),##ATOM   CHECK VALIDITY OF PROPERTY LIST\n         BO    ERROR2\n         L     #4,##CDR(,#7)       ELSE BUMP TO (SUB)PLIST WITH IND\n         CR    #4,#10              IF REACHED END OF PROPERTY LIST\n         BE    RETNIL              THEN RETURN NIL\n         LM    #1,#2,##CAR(#4)     #1 = CAR, #2 = CDR = VALUE\n         LTR   #1,#1               IF CON(#4) WASN'T A CONS CELL\n         BM    ERROR2              THEN ERROR\n         CR    #6,#1               IF PROPERTY INDICATOR MATCHES\n         BNE   NOMATCH             THEN...\n         LM    #15,#0,##CAR(#2)     LOAD VALUE AND REST OF PLIST\n         LTR   #15,#15              IF CON(#2) WASN'T A CONS CELL\n         BM    ERROR2               THEN ERROR\n         ST    #0,##CDR(,#7)        SPLICE IND/VALUE PAIR OUT OF PLIST\n         BR    #14                  RETURN WITH PROPERTY VALUE REMOVED\nNOMATCH  DS    0H                  ELSE...\n         LR    #7,#2                BUMP TO NEXT INDICATOR/VALUE PAIR\n         B     LOOP                 CONTINUE LOOPING\n         SPACE 1\nRETNIL   DS    0H\n         LR    #15,#10             RETURN NIL\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nNOTSYM   DS    0H                  Arg 1 not a symbol\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* FOR COMPATIBILITY WITH MACLISP AND OTHER APPLICATIONS THAT USE      *\n* DISEMBODIED PROPERTY LISTS, IF ARG 1 IS A LIST THEN WE ACCEPT IT.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ##TYPE(#5),##ATOM   See if it's a list\n         BO    ERROR1              If so, then...\n         L     #7,##CDR(,#5)        get CDR and use as property list\n         B     PROCESS\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         #ERR  'Argument 1 to REMPROP not a symbol - ',(#5)\n         SPACE 1\nERROR2   DS    0H                  ERROR IN ARGUMENT\n         #ERR  'ZIL4011 REMPROP: Invalid property list found for ',    X\n               (#5),PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REMQ": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00V\\x00S\\x00U\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 86, "newlines": 83, "modlines": 85, "user": "SEB1525"}, "text": "         TITLE 'REMQ - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* REMQ: SAME AS COMMON LISP (REMOVE A B :TEST #'EQ)                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nREMQ     #ZBEG MINARGS=2,MAXARGS=3,NAME='REMQ'\n         #ZPDS 3*4+12+4  =     28\n         #ZSAV ARGS=3\n         SPACE 1\n         LM    #6,#7,4(#11)        #6 = ARG2, #7 = ARG3\n* Arg 1 is kept on stack, since CONS might relocate it anyhow.\n         SPACE 1\n         CR    #7,#13              IF ARG 3 NOT SUPPLIED\n         BE    ARG3NULL             then process as if NIL\n         CR    #7,#10              IF ARG3 (COUNT) IS NIL\n         BE    ARG3NULL            THEN IT'S OK\n         CLI   ##TYPE(#7),##FIXNUM ELSE ARG3 MUST BE A FIXNUM\n         BNE   ARG3ERR             OTHERWISE ERROR\n         ICM   #7,#15,##CDR(#7)    GET FIXNUM VALUE OF ARG3 = COUNT\n         BP    ARG3OK              If not positive, then\n         LR    #15,#6               return arg 2\n         B     RETURN\nARG3NULL DS    0H                  Arg 3 is NIL (or unsupplied)\n         XR    #7,#7               SET ARG 3 fixnum value = 0\n*                                  This is NOT the same as specifying\n*                                  0 as arg3.  This value will be able\n*                                  to be decremented without ever going\n*                                  to zero.\nARG3OK   DS    0H                  #7 now contains fixnum value of arg3\n         ST    #10,24(,#11)        Init eventual result to NIL\n         LA    #5,24-##CDR(,#11)   Set pseudolocative for bashing list\n         CR    #6,#10              If arg 2 is NIL\n         BE    RETURNZ             then return NIL.\nLOOP     DS    0H                  Else start looping.\n         ICM   #1,15,##CAR(#6)     Get CAR of sublist\n         BM    RETURNA             If sublist wasn't a CONS, return\n         C     #1,0(,#11)          If arg1 is EQ to CAR of (sub)list\n         BNE   NOTEQ               then...\n         BCT   #7,NEXTCDR           decrement count.\n*                                   If count still nonzero, just\n*                                   continue by skipping this element.\n*                                   If count goes to zero, then...\n         L     #0,##CDR(,#6)         get CDR of remaining (sub)list\n         ST    #0,##CDR(,#5)         bash new list being built\n         B     RETURNZ               return new list\n         SPACE 1\nNOTEQ    DS    0H                  ELSE THIS CAR DOESN'T MATCH\n*                                  Include CAR in new list, already #1\n******** L     #1,##CAR(,#6)       Arg 1 to CONS = CAR of sublist\n         L     #15,ZLCCONS         Get address of ZILCONS\n         LR    #2,#10              Arg 2 to CONS = NIL\n         #BASR #14,#15             Call CONS to get new list element\n*\n* Note: We assume that #5 is not relocated by GC, being a CONS pointer.\n*       We assume that #6 is not relocated by GC, being a CONS pointer.\n*\n         ST    #15,##CDR(,#5)      Bash list being built with new cell\n         LR    #5,#15              Set new bashee pointer\n         SPACE 1\nNEXTCDR  DS    0H\n         L     #6,##CDR(,#6)       Bump down arg2 list.\n         CR    #6,#10              Until arg 2 goes to NIL\n         BNE   LOOP                 continue.\n         SPACE 1\nRETURNZ  DS    0H\n         L     #15,24(,#11)        Load return value\n         SPACE 1\nRETURN   DS    0H                  Return value is in #15\n         #ZRET ,\n         SPACE 1\nRETURNA  DS    0H                  Here only if sublist ends in atom\n*                                  (and no count argument)\n         ST    #6,##CDR(,#5)       Bash list with atomic end of list\n         B     RETURNZ             and return the return value\n         SPACE 1\nARG3ERR  #ERR  'Invalid REMQ count argument - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RESTARG": {"ttr": 4618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00/\\x00,\\x00.\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 47, "newlines": 44, "modlines": 46, "user": "SEB1525"}, "text": "         TITLE 'RESTARG - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE RETURNS T OR NIL, DEPENDING ON WHETHER THE COMPILED     *\n* FUNCTION TAKES AN &REST ARGUMENT.                                   *\n* THE INPUT PARAMETER MUST BE CODE, I.E. THE VALUE OF THE ZILLOAD     *\n* FUNCTION OR OF THE SUBR, FSUBR, ETC. PROPERTY OF A FUNCTION ATOM.   *\n*                                                                     *\n***********************************************************************\n         SPACE\nRESTARG  #ZBEG MINARGS=1,MAXARGS=1,NAME='RESTARG'\n         SPACE\n         L     #5,0(,#1)           PICK UP PARAMETER (FUNCTION CODE)\n         TM    ##TYPE(#5),##CODE   MUST BE A COMPILED CODE OBJECT\n         BNO   ERROR               (SUBR OR CLOSURE)\n         XR    #4,#4               ELSE CLEAR INSERT REGISTER\n         ICM   #4,7,##CAR+1(#5)    GET POINTER TO COMPILED CODE\n         XR    #2,#2               CLEAR INSERT REG\n         IC    #2,4(,#4)           GET LENGTH OF IDENTIFIER\n         LA    #3,5+3(#2,#4)       POINT TO MODULE CODE PAST IDENTIFIER\n         N     #3,=X'FFFFFFFC'     ROUNDING UP TO NEXT FULLWORD\n         USING ZINT,#3             TO POINT TO \"ZINT\" AREA\n         TM    ZINFLAG2,ZINGREST   IF &REST ARG IS EXPECTED\n         BO    TRUE                THEN RETURN T, ELSE RETURN NIL\nFALSE    LR    #15,#10\n         BR    #14\nTRUE     DS    0H\n         LR    #15,#8\n         BR    #14\n         SPACE 1\n         DROP  #15\n         SPACE 1\nERROR    DS    0H\n         LR    #2,#15\n         USING RESTARG,#2\n         #ERR  'Argument to RESTARG not a compiled code object (SUBR orX\n                closure) - ',(#5)\n         SPACE 1\n         LTORG\n         SPACE\n         #ZINT ,                   MAP THE CODE HEADER AREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REVAPPEN": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11A\\x00(\\x00%\\x00'\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:41:00", "lines": 40, "newlines": 37, "modlines": 39, "user": "SEB1525"}, "text": "         TITLE 'REVAPPEN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (REVAPPEND X Y) IS EQUIVALENT TO (APPEND (REVERSE X) Y).            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nREVAPPEN #ZBEG MINARGS=2,MAXARGS=2,NAME='REVAPPEND'\n         SPACE 1\n         #ZPDS 2*4+12\n         #ZSAV ARGS=2\n         SPACE 1\n         LM    #3,#4,0(#11)        LOAD THE ARGUMENTS\n         LR    #15,#4              PRESET RETURN VALUE TO ARG2\n         CR    #3,#10              IF ARG1 IS NIL\n         BE    RETURN              THEN RETURN ARG2\nLOOP     DS    0H                  ELSE...\n         ICM   #1,15,##CAR(#3)     GET CAR OF (SUB)LIST\n         BM    ERROR1              IF (SUB)LIST WASN'T A CONS, ERROR\n         LR    #2,#15              GET RESULT SO FAR\n         L     #15,ZLCCONS         CALL CONS TO ADD ITEM TO RESULT LIST\n         #BASR #14,#15             (SETS #15 TO RESULT OF CONS)\n         L     #3,##CDR(,#3)       GET CDR OF (SUB)LIST\n         CR    #3,#10              WHEN (SUB)LIST IS NIL,\n******** BE    RETURN              THEN RETURN RESULT\n         BNE   LOOP                ELSE CONTINUE\n         SPACE 1\nRETURN   DS    0H                  #15 CONTAINS RETURN VALUE\n         #ZRET ,                   RETURN TO CALLER\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         #ERR  'Argument 1 to REVAPPEND not a proper list - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REVERSE": {"ttr": 4622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11B\\x00(\\x00%\\x00'\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:42:00", "lines": 40, "newlines": 37, "modlines": 39, "user": "SEB1525"}, "text": "         TITLE 'REVERSE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* REVERSE TAKES 1 ARGUMENT.                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nREVERSE  #ZBEG MINARGS=1,MAXARGS=1,NAME='REVERSE'\n         SPACE 1\n         #ZPDS 1*4+12\n         #ZSAV ARGS=1\n         SPACE 1\n         L     #3,0(,#11)          LOAD THE ARGUMENT\n         LR    #15,#10             INITIALIZE RESULT TO NIL\n         CR    #3,#10              IF ARG IS NIL\n         BE    RETURN              THEN RETURN RESULT\nLOOP     DS    0H\n         ICM   #1,15,##CAR(#3)     GET CAR OF (SUB)LIST\n         BM    ERROR1              IF (SUB)LIST WASN'T A CONS, ERROR\n         LR    #2,#15              GET RESULT SO FAR\n         L     #15,ZLCCONS         CALL CONS TO ADD ITEM TO RESULT LIST\n         #BASR #14,#15             (SETS #15 TO RESULT OF CONS)\n         L     #3,##CDR(,#3)       GET CDR OF (SUB)LIST\n         CR    #3,#10              WHEN (SUB)LIST IS NIL,\n******** BE    RETURN              THEN RETURN RESULT\n         BNE   LOOP                CONTINUE\n         SPACE 1\nRETURN   DS    0H                  #15 CONTAINS RETURN VALUE\n         #ZRET ,                   RETURN TO CALLER\n         SPACE 1\nERROR1   DS    0H                  ERROR IN ARGUMENT\n         #ERR  'Argument to REVERSE not a proper list - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMNIL": {"ttr": 4624, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11B\\x00#\\x00 \\x00\"\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:42:00", "lines": 35, "newlines": 32, "modlines": 34, "user": "SEB1525"}, "text": "         TITLE 'RMNIL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* RMNIL TAKES NO ARGUMENTS.                                           *\n*                                                                     *\n* THIS FUNCTION RETURNS THE OBJECT \"RMNIL\", A SPECIAL ENTITY THAT     *\n* TELLS THE READ FUNCTION, WHEN IT INVOKES A READER MACRO, THAT       *\n* THE MACRO DID NOT RETURN A FORM.  IT IS INTENDED TO BE RETURNED     *\n* AS A VALUE BY READER MACRO FUNCTIONS ONLY.                          *\n*                                                                     *\n* SINCE \"RMNIL\" LOOKS LIKE A LIST WHOSE CAR AND CDR POINT TO ITSELF,  *\n* AN ATTEMPT TO PRINT IT WILL BE DISASTROUS.                          *\n*                                                                     *\n* THIS MODULE USES NO STACK SPACE AND SAVES NO REGISTERS.             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note:  Presumably this will be obsoleted by Common LISP-style       *\n*        multiple values.  A function that wants to return \"nothing\"  *\n*        to the reader can do it by issuing (values).  See CLtL.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nRMNIL    #ZBEG MINARGS=0,MAXARGS=0,NAME='RMNIL'\n         SPACE 1\n         LA    #15,ZLCRMNIL        GET ADDRESS OF RMNIL\n         BR    #14                 RETURN\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ROT": {"ttr": 4626, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11B\\x007\\x004\\x006\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:42:00", "lines": 55, "newlines": 52, "modlines": 54, "user": "SEB1525"}, "text": "         TITLE 'ROT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ROT TAKES TWO INTEGER ARGUMENTS.  CURRENTLY THEY MUST BE FIXNUMS.   *\n*                                                                     *\n* THIS FUNCTION DOES AN ARITHMETIC ROTATE OPERATION.                  *\n*                                                                     *\n***********************************************************************\nROT      #ZBEG MINARGS=2,MAXARGS=2,NAME='ROT'\n         #ZPDS 2*4+12+0 (= 20)     DEFINE STACK SIZE\n         #ZSAV ARGS=2              SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#7),##FIXNUM\n         BNE   ERROR2\n         ICM   #4,15,##CDR(#7)     GET ARG 2 VALUE = SHIFT AMOUNT\n         BZ    NOSHIFT             IF ZERO, NO SHIFTING REQUIRED\n         BM    RSHIFT              IF NEGATIVE, RIGHT SHIFT REQUIRED\n*                                  ELSE POSITIVE, DO LEFT SHIFT\n         L     #2,##CDR(,#6)       GET ARG 1 VALUE INTO REGISTER 2\n         LR    #3,#2               MAKE A COPY IN OTHER REG OF PAIR\n         SLDL  #2,0(#4)            GET IT INTO REG 3 AND CLEAR REG 2\n*                                  RESULT IS IN #2\n         B     MAKEIT              AND GO MAKE A FIXNUM OUT OF IT\nRSHIFT   DS    0H\n         LPR   #4,#4               CHANGE SHIFT AMOUNT TO POSITIVE\n         L     #2,##CDR(,#6)       GET ARG 1 VALUE INTO REGISTER 2\n         LR    #3,#2               MAKE A COPY IN OTHER REG OF PAIR\n         SRDL  #2,0(#4)            GET IT INTO REG 3 AND CLEAR REG 2\n         LR    #2,#3               GET RESULT INTO #2\n******** B     MAKEIT              AND GO MAKE A FIXNUM OUT OF IT\nMAKEIT   DS    0H                  NOW #2 CONTAINS SHIFTED VALUE\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM ATOM\n         B     RETURN\n         SPACE 1\nNOSHIFT  DS    0H\n         LR    #15,#6              NO SHIFTING - JUST RETURN ARG 1\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument 1 to ROT not a fixnum - ',0(#11)\nERROR2   #ERR  'Argument 2 to ROT not a fixnum - ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RPLACA": {"ttr": 4628, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\t\\x00\\x88\\x01_\\x01\\x00&_\\x12\\x03\\x00\\x1a\\x00\\x17\\x00\\x19\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T12:03:09", "lines": 26, "newlines": 23, "modlines": 25, "user": "SEB1525"}, "text": "         TITLE 'RPLACA - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nRPLACA   #ZBEG MINARGS=2,MAXARGS=2,NAME='RPLACA'\n         SPACE 1\n         USING RPLACA,#15\n         SPACE 1\n         LM    #2,#3,0(#1)\n         TM    ##TYPE(#2),##ATOM\n         BO    RCAERROR\n         ST    #3,##CAR(,#2)\n         LR    #15,#2\n         BR    #14\n         SPACE 1\nRCAERROR DS    0H\n         LR    #4,#15\n         DROP  #15\n         USING RPLACA,#4\n         #ERR  'Argument to RPLACA not a list - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RPLACD": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00 \\x00\\x88\\x01_\\x01\\x00&_\\x12\\x03\\x00\\x1a\\x00\\x17\\x00\\x19\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T12:03:20", "lines": 26, "newlines": 23, "modlines": 25, "user": "SEB1525"}, "text": "         TITLE 'RPLACD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nRPLACD   #ZBEG MINARGS=2,MAXARGS=2,NAME='RPLACD'\n         SPACE 1\n         USING RPLACD,#15\n         SPACE 1\n         LM    #2,#3,0(#1)\n         TM    ##TYPE(#2),##ATOM\n         BO    RCDERROR\n         ST    #3,##CDR(,#2)\n         LR    #15,#2\n         BR    #14\n         SPACE 1\nRCDERROR DS    0H\n         LR    #4,#15\n         DROP  #15\n         USING RPLACD,#4\n         #ERR  'Argument to RPLACD not a list - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RUNTIME": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11B\\x00$\\x00!\\x00#\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:42:00", "lines": 36, "newlines": 33, "modlines": 35, "user": "SEB1525"}, "text": "         TITLE 'RUNTIME - ZIL 1.3 INTERNAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* RUNTIME RETURNS THE NUMBER OF THOUSANDTHS OF A SECOND OF CPU TIME\n* USED DURING THE CURRENT SESSION.  THE VALUE IS TAKEN FROM THE\n* ASCBEJST FIELD OF THE ASCB.\n*\n* FORMERLY CALLED \"CPUTIME\", THIS FUNCTION WAS RENAMED BECAUSE MOST\n* OTHER LISPS HAVE A \"RUNTIME\" FUNCTION.\n*\nRUNTIME  #ZBEG MINARGS=0,MAXARGS=0,NAME='RUNTIME'\n         #ZPDS 12                  DEFINE STACK SIZE\n         #ZSAV ARGS=0              SAVE REGISTERS\n         SPACE\n         STIMER TASK,BINTVL=DUMS   FORCE OS TO UPDATE TIMER HERE\n         L     #2,X'224'           GET ADDRESS OF ASCB\n         LM    #2,#3,X'40'(#2)     GET JOB STEP ELAPSED TIME (ASCBEJST)\n         SRDL  #2,12               CONVERT FROM MICROSECONDS\n         D     #2,=F'1000'         TO THOUSANDTHS OF A SECOND\n         LR    #2,#3               GET RESULT INTO REGISTER\n         LA    #0,12(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\n         DS    0D\nDUMS     DC    XL8'00'\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SALIST": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11B\\x00\\x13\\x00\\x10\\x00\\x12\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:42:00", "lines": 19, "newlines": 16, "modlines": 18, "user": "SEB1525"}, "text": "         TITLE 'SALIST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SPECIAL-ALIST TAKES NO ARGUMENTS.                                   *\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND TAKES NO STACK SPACE.             *\n*                                                                     *\n***********************************************************************\n         SPACE\nSALIST   #ZBEG MINARGS=0,MAXARGS=0,NAME='SPECIAL-ALIST'\n         SPACE\n         L     #15,ZLCSALST        LOAD ADDRESS OF SPECIAL ALIST\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SAPPEND": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11B\\x00F\\x00C\\x00E\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:42:00", "lines": 70, "newlines": 67, "modlines": 69, "user": "SEB1525"}, "text": "         TITLE 'SAPPEND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* \"STRING-APPEND\"                                                     *\n*                                                                     *\n* SAPPEND TAKES AN &REST ARGUMENT - (A LIST OF) STRINGS TO BE         *\n* CONCATENATED INTO A SINGLE RESULT STRING.                           *\n*                                                                     *\n***********************************************************************\n         SPACE\nSAPPEND  #ZBEG MINARGS=0,MAXARGS=0,RESTARG=T,NAME='STRING-APPEND'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n*\n* FIRST CALL ZILVSS TO START BUILDING A STRING.\n*\n         LA    #1,4                SET ENTRY CODE FOR STRING BEGINNING\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER\n         #BASR #14,#15             CALL ZILVSS TO START BUILDING STRING\n         LTR   #4,#4               IF NO STRING SPACE AVAILABLE\n         BZ    ERROR2              THEN ERROR\n*\n* FOR EACH STRING IN THE LIST, ADD IT TO THE STRING BEING BUILT.\n*\n         XR    #5,#5               INIT LENGTH SO FAR TO ZERO\n         L     #7,0(,#11)          GET &REST ARGLIST\nLOOP     DS    0H\n         CR    #7,#10              IF END OF LIST OR NULL LIST\n         BE    NOMORE              THEN END LOOP\n         L     #2,##CAR(,#7)       GET ATOM (ARG 1 TO SAPPEND)\n         CLI   ##TYPE(#2),##STRING IF IT IS A STRING\n         BNE   NOTSTR              THEN\n         LR    #6,#2                GET POINTER TO THE STRING\n         B     DOIT                ELSE\nNOTSTR   CLI   ##TYPE(#2),##SYMBOL IF IT IS A SYMBOL\n         BNE   ERROR1              THEN (WELL, WE'LL PERMIT IT)\n         L     #6,##PNAME(,#2)      USE THE PRINT NAME\n*                                  ELSE INVALID ARG - NOT A STRING\n*                                  ANYHOW...\nDOIT     DS    0H                  #6 POINTS TO THE STRING ITSELF\n         LA    #1,16               SET ENTRY CODE FOR STRING CONCAT\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER\n*                                  CALL ZILVSS TO CONCATENATE\n         #BASR #14,#15              THAT STRING TO THIS STRING\n         LTR   #4,#4               IF NO STRING SPACE AVAILABLE\n         BZ    ERROR2              THEN ERROR\n         L     #7,##CDR(,#7)       GET REST OF LIST\n         B     LOOP                CONTINUE.\nNOMORE   DS    0H                  LIST HAS BEEN PROCESSED\n         LA    #1,8                SET ENTRY CODE FOR STRING FINISH\n         L     #15,ZLCVSS          CALL ZILVSS TO FINALIZE THE STRING\n         #BASR #14,#15             (NO GC ERRORS POSSIBLE HERE)\n*                                  RETURNED STRING IS IN #15\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument to STRING-APPEND not a string - ',(#2)\nERROR2   #ERR  'ZIL4010 STRING-APPEND: Not enough vector/string space tX\n               o build string.',PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAPPENDL": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11B\\x00\\x1b\\x00\\x18\\x00\\x1a\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:42:00", "lines": 27, "newlines": 24, "modlines": 26, "user": "SEB1525"}, "text": "         TITLE 'SAPPENDL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SAPPENDL TAKES A SINGLE ARGUMENT - (A LIST OF) STRINGS TO BE        *\n* CONCATENATED INTO A SINGLE RESULT STRING.                           *\n*                                                                     *\n* IT DOES THIS BY PASSING CONTROL TO STRING-APPEND, MAKING THIS       *\n* EQUIVALENT TO (APPLY #'STRING-APPEND ARG) BUT FASTER.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSAPPENDL #ZBEG MINARGS=1,MAXARGS=1,NAME='SAPPENDL',SUBRS=ZILSUBR\n         SPACE 1\n         L     #15,@SAPPEND\n         DROP  #15\n         BR    #15\n         SPACE 1\nZILSUBRS DS    0A\n@SAPPEND DC    V(SAPPEND)          SUBROUTINE ADDRESS\n         DC    CL8'SAPPEND'\nZILSUBRE DS    0A\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCAPITAL": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x90\\x17\\x1f\\x08P\\x00\\xcd\\x00\\xc6\\x00\\xcd\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1990-06-20T08:50:00", "lines": 205, "newlines": 198, "modlines": 205, "user": "SEB1525"}, "text": "***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         TITLE 'STRING-CAPITALIZE - MACROS'\n         MACRO\n&SYM     XTRT  &DATR,&TABLE,&LENR=,&EX=,&F256=#0\n         LCLC  &LBLA,&LBLB,&LBLC\n&LBLA    SETC  'XTRA&SYSNDX'\n&LBLB    SETC  'XTRB&SYSNDX'\n         AIF   ('&SYM' EQ '').FOO\n&LBLC    SETC  '&SYM'\n         AGO   .BAR\n.FOO     ANOP\n&LBLC    SETC  'XTRC&SYSNDX'\n.BAR     ANOP\n&LBLC    DS    0H\n         CR    &LENR,&F256          If length greater than 256\n         BNH   &LBLA                then...\n         TRT   0(256,&DATR),&TABLE   scan for desired characters\n         BNZ   &LBLB                 If we found something, exit\n         AR    &DATR,&F256           Else increment text pointer by 256\n         SR    &LENR,&F256           Decrement length by 256\n         B     &LBLC                 Continue scanning.\n&LBLA    DS    0H                  Else...\n         BCTR  &LENR,0              Reduce length for execute\n         EX    &LENR,&EX            Scan for desired characters\n&LBLB    DS    0H\n         MEND\n         TITLE 'STRING-CAPITALIZE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* STRING-CAPITALIZE                                                   *\n*                                                                     *\n* Reference:  CLtL, pp. 303-304.                                      *\n*                                                                     *\n* 06/20/90 - Fixed bug - looping during scan                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSCAPITAL #ZBEG MINARGS=1,MAXARGS=1,NAME='STRING-CAPITALIZE'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #3,0(,#11)          LOAD ARG1\n         CLI   ##TYPE(#3),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#3),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #3,##PNAME(,#3)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ST    #3,0(,#11)          STORE BACK ON STACK FOR FUTURE USE\n         ICM   #7,7,1(#3)          GET LENGTH OF STRING\n         BZ    RETSELF             IF ZERO-LENGTH STRING, RETURN SELF\n         LA    #14,##VECDAT(,#3)   POINT TO TEXT OF STRING\n         LR    #15,#7              GET LENGTH\n         LA    #0,256              SET UP CONSTANT 256\nTALOOP   DS    0H                  LOOP TO SCAN STRING\n         XTRT  #14,TRTALPHA,LENR=#15,EX=EXTRTA  Scan for any alpha's\n         BZ    RETSELF             IF NO BAD CHARS, RETURN SELF\nCOPYIT   DS    0H                  ALPHABETIC DATA, HAVE TO COPY\n         LR    #2,#7               GET LENGTH INTO REG FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #4,#15              IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         L     #1,0(,#11)          GET POINTER TO ORIGINAL STRING\n         LA    #0,##VECDAT(,#1)    POINT TO STRING TEXT\n         LA    #14,##VECDAT(,#4)   POINT TO WHERE TO MOVE STRING TEXT\n         LR    #1,#7               GET LENGTH OF STRING TEXT TO MOVE\n         LR    #15,#7\n         MVCL  #14,#0              MOVE TEXT FROM OLD STRING TO NEW\n         LA    #5,##VECDAT(,#4)    POINT TO TEXT OF STRING\n         LR    #15,#7              GET LENGTH\n         LA    #0,256              SET UP CONSTANT 256\n         LA    #3,0(#5,#7)         Preset to point to end of string\nTRTNEXT  DS    0H                  Loop to translate string\n         LR    #15,#3              End of string minus where we are now\n         SR    #15,#5              Get length of string remaining\n         XR    #1,#1               Preset in case nothing found\n         LR    #14,#5              Load pointer for extended TRT\n         XTRT  #14,TRTANUM,LENR=#15,EX=EXTRTAN   Find next alphanumeric\n         LTR   #5,#1               Point to start of found substring\n         BZ    DONE                If none, finished translating\n         LR    #1,#3               Preset to point to end of string\n         LR    #15,#3              End of string minus where we are now\n         SR    #15,#5              Get length of string remaining\n         LR    #14,#5              Load pointer for extended TRT\n         XTRT  #14,TRTNANUM,LENR=#15,EX=EXTRTNAN  Find next nonalphanum\n         LR    #2,#1               End of substring minus start thereof\n         SR    #2,#5               Get length of substring to translate\n         BNP   TRTNEXT             If not > 0, nothing to translate\n         TR    0(1,#5),TRUPPER     Translate first letter to upper case\n         LA    #5,1(,#5)           Bump to next characters\n         BCT   #2,TRLOOP           Decrement length\n         B     TRUDONE             Skip rest of translation if zero\nTRLOOP   DS    0H\n         CR    #2,#0               If longer than 256,\n         BNH   SHORTTR             then...\n         TR    0(256,#5),TRLOWER   Translate rest to lower case\n         AR    #5,#0               Bump to next 256 characters\n         SR    #2,#0               Bump down length\n         B     TRLOOP              and continue translating.\nSHORTTR  DS    0H\n         BCTR  #2,0                Reduce length for execute\n         EX    #2,EXTRL            Translate to lower case\nTRUDONE  DS    0H                  Finished translating this substring\n         LR    #5,#1               Point to next part of string\n         CR    #5,#3               As long as there's data left,\n         BL    TRTNEXT             Continue looking for data to trans\nDONE     DS    0H                  ALL FINISHED\n         LR    #15,#4              POINT TO NEWLY BUILT STRING\n         B     RETURN              RETURN THE ATOM IN #15\n         SPACE 1\nRETSELF  DS    0H                  Null string, or no alphabetics\n         LR    #15,#3              RETURN THE STRING PASSED\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nEXTRTA   TRT   0(*-*,#14),TRTALPHA EXECUTED: SCAN FOR ALPHABETICS\nEXTRTAN  TRT   0(*-*,#14),TRTANUM  EXECUTED: SCAN FOR NONALPHANUMERICS\nEXTRTNAN TRT   0(*-*,#14),TRTNANUM EXECUTED: SCAN FOR NONALPHANUMERICS\nEXTRL    TR    0(*-*,#5),TRLOWER   EXECUTED: TRANSLATE TO LOWERCASE\n         SPACE 1\nTRTALPHA DC    256X'00'            TABLE TO SCAN FOR ALPHABETIC CHARS\n         ORG   TRTALPHA+C'A'-X'40'\n         DC    9XL1'FF'\n         ORG   TRTALPHA+C'J'-X'40'\n         DC    9XL1'FF'\n         ORG   TRTALPHA+C'S'-X'40'\n         DC    8XL1'FF'\n         ORG   TRTALPHA+C'A'\n         DC    9XL1'FF'\n         ORG   TRTALPHA+C'J'\n         DC    9XL1'FF'\n         ORG   TRTALPHA+C'S'\n         DC    8XL1'FF'\n         ORG   ,\n         SPACE 1\nTRTANUM  DC    256X'00'            TABLE TO SCAN FOR ALPHANUMERICS\n         ORG   TRTANUM+C'A'-X'40'\n         DC    9XL1'FF'\n         ORG   TRTANUM+C'J'-X'40'\n         DC    9XL1'FF'\n         ORG   TRTANUM+C'S'-X'40'\n         DC    8XL1'FF'\n         ORG   TRTANUM+C'A'\n         DC    9XL1'FF'\n         ORG   TRTANUM+C'J'\n         DC    9XL1'FF'\n         ORG   TRTANUM+C'S'\n         DC    8XL1'FF'\n         ORG   TRTANUM+C'0'\n         DC    10XL1'FF'\n         ORG   ,\n         SPACE 1\nTRTNANUM DC    256X'FF'            TABLE TO SCAN FOR NON-ALPHANUMERICS\n         ORG   TRTNANUM+C'A'-X'40'\n         DC    9XL1'00'\n         ORG   TRTNANUM+C'J'-X'40'\n         DC    9XL1'00'\n         ORG   TRTNANUM+C'S'-X'40'\n         DC    8XL1'00'\n         ORG   TRTNANUM+C'A'\n         DC    9XL1'00'\n         ORG   TRTNANUM+C'J'\n         DC    9XL1'00'\n         ORG   TRTNANUM+C'S'\n         DC    8XL1'00'\n         ORG   TRTNANUM+C'0'\n         DC    10XL1'00'\n         ORG   ,\n         SPACE 1\nTRUPPER  DC    256YL1(*-TRUPPER)   TABLE TO TRANSLATE TO UPPERCASE\n         ORG   TRUPPER+C'A'-X'40'\n         DC    C'ABCDEFGHI'\n         ORG   TRUPPER+C'J'-X'40'\n         DC    C'JKLMNOPQR'\n         ORG   TRUPPER+C'S'-X'40'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         SPACE 1\nTRLOWER  DC    256YL1(*-TRLOWER)   TABLE TO TRANSLATE TO LOWERCASE\n         ORG   TRLOWER+C'A'\n         DC    C'abcdefghi'\n         ORG   TRLOWER+C'J'\n         DC    C'jklmnopqr'\n         ORG   TRLOWER+C'S'\n         DC    C'stuvwxyz'\n         ORG   ,\n         SPACE 1\nERROR1   #ERR  'Argument to STRING-CAPITALIZE not a string - ',(#3)\n         SPACE 1\nERROR2   #ERR  PREFIX=NO,          NOT ENUF ROOM                       X\n               'ZIL4010 STRING-CAPITALIZE: Not enough vector/string spaX\n               ce to build string.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCRSIZE": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x00+\\x00(\\x00*\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 43, "newlines": 40, "modlines": 42, "user": "SEB1525"}, "text": "         TITLE 'SCRSIZE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SCRSIZE returns a dotted pair (rowsize . colsize) which represents  *\n* the current terminal attributes.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nSCRSIZE  #ZBEG MINARGS=0,MAXARGS=0,NAME='SCRSIZE'\n         #ZPDS 0*4+12+0 = 16\n         #ZSAV\n         SPACE 1\n         GTSIZE ,                  Get CURRENT terminal attributes\n         LTR   #15,#15             If SVC 94 failed,\n         BNZ   RETNIL              then return no-terminal-size\n         LR    #3,#0               #0 = screen length (# of rows)\n         LR    #4,#1               #1 = line size (# of columns)\n         LR    #2,#3               Get fixnum value to cons up\n         LA    #0,16(,#11)         Stack pointer for CONS\n         #MKAT FIXED               Make a fixnum out of # of rows\n         LR    #5,#15              Save it\n         LR    #2,#4               Get fixnum value to cons up\n         #MKAT FIXED               Make a fixnum out of # of cols\n         LR    #1,#5               Get # of rows\n         LR    #2,#15              Get # of columns\n         L     #15,ZLCCONS         Get address of CONS\n         #BASR #14,#15             Call CONS to make a dotted pair\n         B     RETURN\n         SPACE 1\nRETNIL   DS    0H                  If anything went wrong, return NIL\n         LR    #15,#10\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   Return to caller\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETABEND": {"ttr": 4881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x009\\x00\\x88\\x01_\\x01\\x00&_\\x166\\x01`\\x01a\\x01_\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:36:39", "lines": 352, "newlines": 353, "modlines": 351, "user": "SEB1525"}, "text": "         TITLE 'SETABEND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SETABEND TAKES ONE REQUIRED ARGUMENT - NIL OR NON-NIL.              *\n*                                                                     *\n* IF THE ARG IS NIL, ESTAE PROCESSING IS CANCELLED;                   *\n* OTHERWISE, ESTAE PROCESSING IS ENABLED.                             *\n*                                                                     *\n* THIS FUNCTION TURNS ABEND CATCHING ON AND OFF.                      *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SUMMARY OF REGISTER USAGE FOR THIS MODULE                           *\n*                                                                     *\n*        USING SETABEND,#12                                           *\n*        USING STARETRY,#6                                            *\n*        USING STAEEXIT,#7                                            *\n*        USING SDWA,#5                                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSETABEND #ZBEG MINARGS=1,MAXARGS=1,NAME='SETABEND'\n         #ZPDS 16\n         #ZSAV\n         SPACE 1\n         L     #15,0(,#11)         PICK UP ARG 1\n         CR    #15,#10             IF ARG IS NIL\n         BNE   ABENDON             THEN...\n         TM    ZLCEFLGS,ZLCESTAE    IF ESTAE ENVIRONMENT IS ACTIVE\n         BZ    RETURN               THEN\n         ESTAE 0                    CANCEL ESTAE\n         LTR   #15,#15              IF FAILED\n         BNZ   ERROR1               THEN ERROR\n         NI    ZLCEFLGS,255-ZLCESTAE INDICATE ESTAE NOT ACTIVE\n         B     RETURN                AND RETURN OK\n         SPACE 1\nABENDON  DS    0H                  ELSE...\n         TM    ZLCEFLGS,ZLCESTAE   IF ESTAE ENVIRONMENT IS ACTIVE\n         BO    RETURN              THEN DO NOTHING\n         LA    #0,STARETRY         SET ADDRESS OF RETRY ROUTINE\n         ST    #0,STAERTRY         IN ESTAE PARAMETER LIST\n         XC    STAECOMP,STAECOMP   CLEAR COMPLETION CODE\n         ST    #13,STAEZCOM        SET ADDRESS OF ZIL COMMON AREA\n         ESTAE STAEEXIT,PARAM=STAEPARM ESTABLISH ESTAE ENVIRONMENT\n         LTR   #15,#15              IF FAILED\n         BNZ   ERROR1               THEN ERROR\n         OI    ZLCEFLGS,ZLCESTAE    INDICATE ESTAE ACTIVE\n         B     RETURN                AND RETURN OK\n         SPACE 1\nRETURN   DS    0H\n         L     #15,0(,#11)         RETURN WITH ARG AS VALUE\n         #ZRET ,\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'ZIL0040 SETABEND failed, bad return code from ESTAE.', X\n               PREFIX=NO\n         SPACE 1\nSTAEPARM DS    0A                  ESTAE PARAM AREA\nSTAEZCOM DS    A                   ADDRESS OF ZIL COMMON AREA\nSTAECOMP DS    A                   COMPLETION CODE\nSTAEREAS DS    A                   REASON CODE\nSTAERTRY DS    A                   ADDRESS OF RETRY ROUTINE\n         SPACE 1\n         DROP  #12\n         SPACE 1\n         EJECT\nSTARETRY DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* RETRY ROUTINE TO RECEIVE CONTROL WHEN ESTAE EXIT DETECTED AN ABEND  *\n* DURING ZIL PROCESSING.  THIS ROUTINE WILL ATTEMPT TO RETURN TO THE  *\n* MAINLINE CODE VIA THROW PROCESSING.                                 *\n*                                                                     *\n*  ON ENTRY TO THIS ROUTINE:                                          *\n*                                                                     *\n*  IF AN SDWA WAS AVAILABLE (REGISTER 0 = OTHER THAN 12 IN STAEEXIT)  *\n*  THEN (ASSUMING DEFAULTS OF RETREGS=NO AND FRESDWA=NO):             *\n*                                                                     *\n*    REGISTER  0 = 0                                                  *\n*    REGISTER  1 = ADDRESS OF THE SDWA                                *\n*    REGISTER 14 = ADDRESS OF AN SVC 3 INSTRUCTION (EXIT)             *\n*    REGISTER 15 = ENTRY POINT ADDRESS OF THIS RETRY ROUTINE          *\n*                                                                     *\n*  OTHERWISE (REGISTER 0 = 12 IN STAEEXIT):                           *\n*                                                                     *\n*    REGISTER  0 = 12                                                 *\n*    REGISTER  1 = ADDRESS OF THE ESTAE PARAMETER LIST (PARAM)        *\n*    REGISTER  2 = ADDRESS OF THE PURGE I/O LIST OR 0                 *\n*    REGISTER 14 = ADDRESS OF AN SVC 3 INSTRUCTION (EXIT)             *\n*    REGISTER 15 = ENTRY POINT ADDRESS OF THIS RETRY ROUTINE          *\n*                                                                     *\n*  OTHER REGISTER CONTENTS ARE UNPREDICTABLE (UNLESS RETREGS=YES      *\n*  WAS SPECIFIED IN THE ESTAE EXIT).                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #6,#15\n         USING STARETRY,#6\n         LA    #3,12               CHECK IF REGISTER 0 = 12\n         CR    #0,#3               IF AN SDWA IS AVAILABLE\n         BE    NOSDWAR             THEN...\n         LR    #5,#1\n         USING SDWA,#5\n         L     #4,SDWAPARM          #4 -> WORKAREA\n         L     #13,STAEZCOM-STAEPARM(,#4) GET ZIL COMMON FROM PARAM\n         L     #3,SDWASR12          LOAD ABENDER'S POSSIBLE CODEREG\n         B     AFTSDWAR\nNOSDWAR  DS    0H                  ELSE...\n         LR    #4,#1                #4 -> WORKAREA\n         XR    #5,#5                SHOW NO SDWA\n         XR    #3,#3                CLEAR ABENDER'S CODEREG\n**** NOT USING SDWA,#5\n         LA    #1,NOWAMSG\n         LA    #0,L'NOWAMSG\n         TPUT  (1),(0),R           LET ME KNOW THERE'S NO SDWA...\n         L     #13,STAEZCOM-STAEPARM(,#4) GET ZIL COMMON FROM PARAM\n         B     REGSNG              TRY TO RECONSTRUCT REGS\nAFTSDWAR DS    0H\n         TM    ZLCIFLGS,ZLCISVD    IF CODE IN PROGRESS ZAPPED REGS 8-11\n         BZ    REGSOK              THEN\n         LM    #8,#10,ZLCISAVE      RESTORE THEM FROM WHERE THEY SAVED\n         NI    ZLCIFLGS,255-ZLCISVD\n         B     AFTROK              ELSE\nREGSOK   DS    0H\n         TM    ZLCIFLGS,ZLCISYS    IF REGS CANNOT BE TRUSTED\n         BO    RESTREGS            THEN RESTORE CORRECTLY\n         C     #13,SDWASR13        IF #13 WAS NOT POINTING TO #ZCOM\n         BNE   REGSNG              OR\n         L     #10,ZLCNIL\n         C     #10,SDWASR10        IF #10 WAS NOT POINTING TO NIL\n         BNE   REGSNG              THEN REGS ARE NOT VALID\n         LM    #8,#10,SDWASR08     ELSE RESTORE ZIL REGS FROM SDWA\n         B     AFTROK\nRESTREGS DS    0H                  HERE IF ZLCISYS WAS ON\n         XR    #3,#3               SHOW CODEREG CANNOT BE TRUSTED\n         L     #8,ZLCT             RELOAD T\n         L     #9,ZLCISV09         RESTORE CONS POINTER AS SAVED\n         L     #10,ZLCNIL          RELOAD NIL\n         NI    ZLCIFLGS,255-ZLCISYS RESET FLAG\n         B     AFTROK\nREGSNG   DS    0H                  HERE IF REGS ARE NO GOOD\n         XR    #3,#3               SHOW CODEREG CANNOT BE TRUSTED\n         L     #8,ZLCT             RELOAD T\n         L     #9,ZLCGCEND         SET A VALUE FOR CONS POINTER\n         L     #10,ZLCNIL          RELOAD NIL\n******** B     AFTROK\nAFTROK   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* AT THIS POINT, DO NOT REFERENCE THE SDWA!  IT MAY NOT BE AVAILABLE. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #5,#5                     IF THERE IS NO SDWA AVAILABLE,\n         BNZ   GETLOC                    THEN\n         MVC   ABENDL(9),=CL9'(UNKNWN),' WE CAN'T TELL WHERE WE ABENDED\n         B     AFTGLOC                   (AT LEAST I DON'T KNOW HOW)\nGETLOC   DS    0H                        ELSE\n         LTR   #3,#3                     IF WE HAVE A POSSIBLE CODEREG\n         BZ    NOCODREG                  THEN...\n         CLC   0(3,#3),=X'47F0F0'         CHECK IF IT POINTS TO CODE\n         BNE   NOCODREG\n         L     #1,SDWANXT1               GET ABENDING ADDRESS\n         N     #1,=X'7FFFFFFF'           CLEAR AMODE BIT\n         N     #3,=X'7FFFFFFF'           CLEAR AMODE BIT\n         SR    #1,#3                     CONVERT TO OFFSET FROM CODE\n         BM    FIXUPM                    IF NEGATIVE, NOT IN THERE\n         MVI   WHEREA,C'+'\n         B     AFTFIXUP\nFIXUPM   DS    0H\n         MVI   WHEREA,C'-'\n         LCR   #1,#1\n         B     AFTFIXUP\nAFTFIXUP DS    0H\n         ST    #1,ZLCDBL\n         UNPK  WHEREA+1(9),ZLCDBL(5)\n         TR    WHEREA+1(8),HEXTBL\n         MVI   WHEREA+1+8,C' '\n         XR    #15,#15\n         IC    #15,4(,#3)                GET LENGTH OF MODULE HEADER\n         SH    #15,=H'16'                REDUCE BY LENGTH OF DATE/TIME\n         BNP   NOCODREG\n         LA    #0,L'WHEREN\n         CR    #15,#0\n         BNH   *+6\n         LR    #15,#0\n         BCTR  #15,0\n         EX    #15,MOVENAME        MOVE FUNCTION NAME TO MESSAGE\n         LA    #1,WHEREN+1(#15)\n         MVI   0(#1),C'.'\n         LA    #0,1(,#1)\n         LA    #1,WHEREM\n         SR    #0,#1\n         #TPUT 2,(1),(0)           DISPLAY ABENDED MESSAGE\n         B     NOCODREG\n         SPACE 1\nMOVENAME MVC   WHEREN(*-*),5(#3)   EXECUTED: MOVE FUNCTION NAME TO MSG\n         SPACE 1\nNOCODREG DS    0H\n         UNPK  ABENDL(9),SDWANXT1(5)     GET LOCATION FROM PSW\n         TR    ABENDL(8),HEXTBL          PUT INTO MESSAGE\n         MVI   ABENDL+8,C','\nAFTGLOC  DS    0H\n         L     #0,STAECOMP-STAEPARM(,#4) GET COMPLETION CODE\n         SLL   #0,8                SHIFT OUT HIGH ORDER BYTE\n         CL    #0,=X'000FFFFF'     IF THIS IS A USER ABEND CODE\n         BNH   ABUSER              THEN GO TO PROCESS IT. ELSE\n         MVC   ABENDT(12),=C'system code '\n         SRL   #0,4                SHIFT RIGHT 1 NIBBLE FOR EASY CONV\n         ST    #0,ZLCDBL\n*\n         CLC   ZLCDBL(2),=X'00CC'  If program check 0CC abend\n         BNE   NOT0CC              then...\n         #TPUT S0CCMSG              inform user of cause of pgm check\nNOT0CC   DS    0H\n*\n         UNPK  ABENDC(4),ZLCDBL(3)\n         TR    ABENDC(4),HEXTBL\n         MVI   ABENDC+3,C','\n         L     #0,STAEREAS-STAEPARM(,#4) GET REASON CODE\n         SLL   #0,16               ONLY CARE ABOUT LAST 3 NIBBLES\n         ST    #0,ZLCDBL\n         UNPK  ABENDR(4),ZLCDBL(3)\n         TR    ABENDR(4),HEXTBL\n         MVI   ABENDR+3,C'.'\n         LA    #0,L'ABENDMSG\n         B     THROWIT\nABUSER   DS    0H\n         MVC   ABENDT(10),=C'user code '\n         SRL   #0,8                SHIFT BACK USER ABEND CODE\n         CVD   #0,ZLCDBL\n         UNPK  ABENDT+10(4),ZLCDBL\n         OI    ABENDT+10+3,X'F0'\n         MVI   ABENDT+10+4,C'.'\n         LA    #0,ABENDT+10+5-ABENDM\nTHROWIT  DS    0H                  DISPLAY ERROR MESSAGE AND THROW\n         STCM  #0,B'0111',ABSTRING+1\n         #ERR  ABSTRING,PREFIX=NO\n         SPACE 1\nWHEREM   DC    C'ZIL0041 ZIL ABEND AT '\nWHEREA   DC    C'          '\n         DC    C'IN FUNCTION '\nWHEREN   DC    CL65' '\n         SPACE 1\n         DS    0H,XL1              Align string to non-halfword\nABSTRING DC    YL1(##STRING),AL3(ABSTREND-ABENDM)\nABENDM   DC    C'ZIL0042 ABEND in ZIL at '\nABENDL   DC    C'        '\n         DC    C', '\nABENDT   DC    CL12' '\nABENDC   DC    C'   ,'\n         DC    C' reason code '\nABENDR   DC    C'   .'\nABSTREND EQU   *\nABENDMSG EQU   ABENDM,*-ABENDM,C'C'\n         SPACE 1\nS0CCMSG  DC    C'ZIL0043 FLOATING-POINT OVERFLOW EXCEPTION OCCURRED.'\n         SPACE 1\nNOWAMSG  DC    C'ZIL: NO SDWA AVAILABLE TO ESTAE EXIT FOR THIS ABEND.'\n         SPACE 1\nHEXTBL   DC    240X'00',C'0123456789ABCDEF'\n         SPACE 1\n         DROP  #6\n         EJECT\nSTAEEXIT DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ESTAE EXIT THAT GETS CONTROL IF AN ABEND OCCURS INSIDE ZIL.         *\n*                                                                     *\n*  ON ENTRY TO THIS ROUTINE:                                          *\n*                                                                     *\n*  REGISTER 0 = 12 - NO SWDA AVAILABLE                                *\n*               OTHER - SDWA AVAILABLE                                *\n*                                                                     *\n*  IF REGISTER 0 = 12:                                                *\n*                                                                     *\n*     REGISTER 1  = ABEND COMPLETION CODE                             *\n*     REGISTER 2  = ADDRESS OF THE ESTAE PARAMETER LIST (PARAM)       *\n*     REGISTER 14 = RETURN ADDRESS TO RTM                             *\n*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *\n*                                                                     *\n*  OTHERWISE:                                                         *\n*                                                                     *\n*     REGISTER 1  = ADDRESS OF THE SDWA                               *\n*     REGISTER 13 = ADDRESS OF A 72-BYTE SAVE AREA                    *\n*     REGISTER 14 = RETURN ADDRESS TO RTM                             *\n*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #7,#15              SAVE ENTRY ADDRESS REGISTER\n         USING STAEEXIT,#7\n         LA    #3,12               CHECK IF REGISTER 0 = 12\n         CR    #0,#3               IF AN SDWA IS AVAILABLE\n         BE    NOSDWAE             THEN...\n         LR    #5,#1\n         USING SDWA,#5\n         L     #4,SDWAPARM          #4 -> WORKAREA\n         XR    #2,#2\n         ICM   #2,7,SDWACMPC        ABEND COMPLETION CODE\n         ST    #2,STAECOMP-STAEPARM(,#4) SAVE COMPLETION CODE\n         L     #2,SDWAGR15          REASON CODE FROM ABEND MACRO\n         ST    #2,STAEREAS-STAEPARM(,#4) SAVE REASON CODE\n         L     #2,STAEZCOM-STAEPARM(,#4) LOOK AT ZIL COMMON AREA\n         TM    ZLCEFLGS-ZLCOMMON(#2),ZLCETERM IF ZILTERM IN PROGRESS\n         BO    DUMPIT               THEN CANNOT RETRY, JUST ABEND\n         TM    ZLCIFLGS-ZLCOMMON(#2),ZLCISMC IF PROCESS UNINTERRUPTIBLE\n         BO    DUMPIT               THEN CANNOT RETRY, JUST ABEND\n         L     #2,STAERTRY-STAEPARM(,#4) ADDRESS OF RETRY ROUTINE\n*\n* RETURN SPECIFYING RETRY WITH NO DUMP\n*\n         SETRP WKAREA=(#5),RETADDR=(#2),DUMP=NO,RC=4\n         BR    #14                 AND RETURN\n         SPACE 1\nDUMPIT   DS    0H\n*\n* RETURN SPECIFYING CONTINUE WITH TERMINATION AND DUMP IF POSSIBLE\n*\n         SETRP WKAREA=(#5),DUMP=YES,RC=0\n         BR    #14                 AND RETURN\n         SPACE 1\nNOSDWAE  DS    0H                  NO SDWA AVAILABLE...\n         LR    #4,#2               #4 -> WORKAREA\n         ST    #1,STAECOMP-STAEPARM(,#4) SAVE ABEND COMPLETION CODE\n         XR    #0,#0               REASON CODE ZERO (UNKNOWN)\n         ST    #0,STAEREAS-STAEPARM(,#4) SAVE REASON CODE\n         L     #15,STAEZCOM-STAEPARM(,#4) LOOK AT ZIL COMMON AREA\n         TM    ZLCEFLGS-ZLCOMMON(#15),ZLCETERM IF ZILTERM IN PROGRESS\n         BO    NSDUMPIT            THEN CANNOT RETRY, JUST ABEND\n         TM    ZLCIFLGS-ZLCOMMON(#15),ZLCISMC IF UNINTERRUPTIBLE\n         BO    NSDUMPIT             THEN CANNOT RETRY, JUST ABEND\n         L     #0,STAERTRY-STAEPARM(,#4) ADDRESS OF RETRY ROUTINE\n         LA    #15,4               INDICATE RETRY TO BE ATTEMPTED\n         BR    #14                 AND RETURN\n         SPACE 1\nNSDUMPIT DS    0H\n         XR    #15,#15             INDICATE CONTINUE WITH TERMINATION\n         BR    #14                 AND RETURN\n         EJECT\n         LTORG\n         EJECT\n         IHASDWA\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETASCII": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x06\\x00\\x893_\\x01\\x00&_\\x168\\x00(\\x00\\x1d\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1989-12-01T00:00:00", "modifydate": "2000-09-21T16:38:06", "lines": 40, "newlines": 29, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'SETASCII - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SETASCII takes one optional argument - NIL or non-NIL.              *\n*                                                                     *\n* If the arg is omitted, the current ASCII mode setting is returned.  *\n* If the arg is NIL, ASCII mode is disabled;                          *\n* otherwise, ASCII mode is enabled.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nSETASCII #ZBEG MINARGS=0,MAXARGS=1,NAME='SETASCII'\n         SPACE\n         LR    #3,#15\n         DROP  #15\n         USING SETASCII,#3\n         L     #15,0(,#1)          PICK UP ARG 1\n         CR    #15,#13             IF ARG IS OMITTED\n         BE    ASCIIQ              THEN QUERY CURRENT ASCII SETTING\n         CR    #15,#10             IF ARG IS NIL\n         BNE   ASCIIT              THEN...\n         NI    ZLCLDFLG,255-ZLCLDASC SET ASCII MODE OFF\n         BR    #14\nASCIIT   DS    0H                  ELSE...\n         OI    ZLCLDFLG,ZLCLDASC    SET ASCII MODE ON\n         BR    #14\n         SPACE 1\nASCIIQ   DS    0H\n         TM    ZLCLDFLG,ZLCLDASC   IF ASCII MODE IS ON\n         BO    TRUE                THEN RETURN T (TRUE)\n         LR    #15,#10             ELSE RETURN NIL (FALSE)\n         BR    #14\nTRUE     LR    #15,#8\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETATTN": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x01\\x1c\\x01\\x13\\x01\\x1b\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 284, "newlines": 275, "modlines": 283, "user": "SEB1525"}, "text": "         TITLE 'SETATTN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SETATTN TAKES ONE REQUIRED ARGUMENT - NIL OR NON-NIL.               *\n*                                                                     *\n* IF THE ARG IS NIL, STAX PROCESSING IS CANCELLED;                    *\n* OTHERWISE, STAX PROCESSING IS ENABLED.                              *\n*                                                                     *\n* THIS FUNCTION TURNS ATTENTION HANDLING ON AND OFF.                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SUMMARY OF REGISTER USAGE FOR THIS MODULE                           *\n*                                                                     *\n*        USING SETATTN,#12                                            *\n*        USING STAXPARM,#4                                            *\n*        USING STARETRY,#6                                            *\n*        USING STAXEXIT,#7                                            *\n*        USING SDWA,#5                                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 10/19/88 - Attempts to handle being in full screen mode.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSETATTN  #ZBEG MINARGS=1,MAXARGS=1,NAME='SETATTN'\n         #ZPDS 16\n         #ZSAV ARGS=1\n         SPACE 1\n         L     #15,0(,#11)         PICK UP ARG 1\n         CR    #15,#10             IF ARG IS NIL\n         BNE   ATTNON              THEN...\n         TM    ZLCEFLGS,ZLCESTAX    IF STAX ENVIRONMENT IS ACTIVE\n         BZ    RETURN               THEN\n         STAX  ,                    CANCEL STAX\n         LTR   #15,#15              IF FAILED\n         BNZ   ERROR1               THEN ERROR\n         NI    ZLCEFLGS,255-ZLCESTAX INDICATE STAX NOT ACTIVE\n         B     RETURN                AND RETURN OK\n         SPACE 1\nATTNON   DS    0H                  ELSE...\n         TM    ZLCEFLGS,ZLCESTAX   IF STAX ENVIRONMENT IS ACTIVE\n         BO    RETURN              THEN DO NOTHING\n         STAX  STAXEXIT,               ESTABLISH STAX ENVIRONMENT      X\n               USADDR=(#13),                                           X\n               REPLACE=YES\n         LTR   #15,#15              IF FAILED\n         BNZ   ERROR1               THEN ERROR\n         OI    ZLCEFLGS,ZLCESTAX    INDICATE STAX ACTIVE\n         B     RETURN                AND RETURN OK\n         SPACE 1\nRETURN   DS    0H\n         L     #15,0(,#11)         RETURN WITH ARG AS VALUE\n         #ZRET ,\n         SPACE 1\nERROR1   DS    0H                  Error - STAX failed\n         #ERR  'ZIL0050 SETATTN failed, bad return code from STAX.',   X\n               PREFIX=NO\n         SPACE 1\n         DROP  #12\n         SPACE 1\n         EJECT\nSTAXEXIT DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* STAX EXIT THAT GETS CONTROL IF AN ATTENTION OCCURS INSIDE ZIL.      *\n*                                                                     *\n*  ON ENTRY TO THIS ROUTINE:                                          *\n*                                                                     *\n* REGISTER 0, 2-12   = IRRELEVANT                                     *\n* REGISTER 1  = THE ADDRESS OF THE ATTENTION EXIT PARAMETER LIST      *\n* REGISTER 13 = SAVE AREA ADDRESS                                     *\n* REGISTER 14 = RETURN ADDRESS                                        *\n* REGISTER 15 = ENTRY POINT ADDRESS OF THE ATTENTION HANDLING ROUTINE *\n*                                                                     *\n*  THE ATTENTION EXIT PARAMETER LIST POINTED TO BY #1 CONTAINS THE    *\n*  ADDRESS OF A TERMINAL ATTENTION INTERRUPTION ELEMENT (TAIE).       *\n*                                                                     *\n*         +0 ___________    TAIE +0 _______________                   *\n*           |           |          |      |TGET|   |                  *\n*  #1 --->  | ->TAIE ---|------->  |L'IBUF| RC |(*)|                  *\n*         +4|___________|        +4|______|____|___|                  *\n*   ATTN    |           |          |               |                  *\n*   EXIT    | -> IBUF   |          | INT'D PSW ADR |                  *\n*   PARAM +8|___________|        +8|_______________|                  *\n*   LIST    |           |          |               |                  *\n*           | -> USADDR |          | INT'D GR0-15  |                  *\n*           |___________|          |               |                  *\n*                                                                     *\n*                                                                     *\n* (*) TAIE+3 is a flag that is nonzero if a CLIST attention exit is   *\n*     in the stack.  This is valid for MVS/SP2.2 only.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         PUSH  USING\n         DROP  #13\n         LR    #7,#15              SAVE ENTRY ADDRESS REGISTER\n         USING STAXEXIT,#7\n         LR    #6,#14              SAVE RETURN ADDRESS REGISTER\n         LM    #2,#4,0(#1)         LOAD VALUES FROM PARAMETER LIST\n*                                  #2 --> TAIE\n*                                  #3 --> IBUF\n*                                  #4 --> USADDR = ZLCOMMON\n         USING TAIE,#2\n         USING ZLCOMMON,#4\n         SPACE 1\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION ALREADY IN PROGRESS\n         BOR   #6                  THEN IGNORE THIS ATTEMPT\n         TM    ZLCIFLGS,ZLCISMC    IF NON-INTERRUPTIBLE PROCESS\n         BZ    NOTSMC              THEN...\n         TPUT  SMCMSG,L'SMCMSG      WARN USER ABORTS WILL BE DEFERRED\nNOTSMC   DS    0H                  ELSE...\n         SPACE 1\n         TPUT  ATTNOUT,L'ATTNOUT   SEND ATTENTION PROMPT\n         TGET  ATTNIN,L'ATTNIN     READ RESPONSE\n         OI    ATTNIN,X'40'        FOLD TO UPPER CASE\n         LR    #5,#1               SAVE TGET COUNT\n         TCLEARQ INPUT             THROW AWAY EXTRA JUNK\n         LTR   #5,#5               IF LENGTH IS ZERO\n         BZR   #6                  THEN RESUME CURRENT PROCESS\n         CLI   ATTNIN,C' '         IF USER ENTERED A BLANK\n         BNHR  #6                  THEN RESUME CURRENT PROCESS\n         CLI   ATTNIN,C'R'         IF USER ENTERED \"R\"\n         BER   #6                  THEN RESUME CURRENT PROCESS\n         CLI   ATTNIN,C'A'         IF USER ENTERED \"A\"\n         BE    ABORT               THEN ABORT\n         CLI   ATTNIN,C'T'         IF USER ENTERED \"T\"\n         BE    TIME                THEN SHOW TIME\n         CLI   ATTNIN,C'H'         IF USER ENTERED \"H\"\n         BE    HELP                THEN SHOW HELP\n         CLI   ATTNIN,C'?'         IF USER ENTERED \"?\"\n         BE    HELP                THEN SHOW HELP\n         B     NOTSMC              ELSE REPROMPT.\n         SPACE 1\nTIME     DS    0H                  TIME - DISPLAY TIME VIA TSO TIME CMD\n         SPACE 1\n         L     #15,X'21C'          GET TCB ADDRESS\n         L     #15,X'B4'(,#15)     GET JSCB ADDRESS\n         L     #15,X'15C'(,#15)    GET ACTIVE JSCB ADDRESS\n         ICM   #15,15,X'108'(#15)  GET PSCB ADDRESS\n         ST    #15,CPPLPSCB\n         USING PSCB,#15\n         MVC   CPPLUPT,PSCBUPT      SAVE UPT ADDRESS\n         L     #15,PSCBRLGB         GET ADDRESS OF RELOGON BUFFER\n         USING RLGB,#15\n         L     #15,RLGBECT          GET ADDRESS OF ECT\n         ST    #15,CPPLECT         ADDRESS ENVIRONMENT CONTROL TABLE\n         DROP  #15\n         ICM   #15,15,TIMEADDR     GET ADDRESS OF IKJEFT25\n         BNZ   CALLTIME\n         LOAD  EP=IKJEFT25,ERRET=NOTSMC\n         LR    #15,#0\n         ST    #15,TIMEADDR\nCALLTIME DS    0H\n         LA    #1,CPPL\n         #BASR #14,#15             CALL TSO TIME COMMAND\n         B     NOTSMC\n         SPACE 1\nHELP     DS    0H                  HELP - GIVE THE USER SOME HELP\n         SPACE 1\n         LA    #14,HELPMSGS\nHELPLOOP DS    0H\n         C     #14,=A(HELPMSGE)\n         BNL   NOTSMC\n         LM    #0,#1,0(#14)\n         TPUT  (1),(0),R\n         LA    #14,8(,#14)\n         B     HELPLOOP\n         SPACE 1\nABORT    DS    0H\n         OI    ZLCIFLGS,ZLCIATTN   INDICATE ATTENTION IN PROGRESS\n         TM    ZLCIFLGS,ZLCISMC    IF NON-INTERRUPTIBLE CODE RUNNING\n         BOR   #6                  THEN JUST RETURN, CODE'LL DETECT\n         TM    ZLCIFLGS,ZLCISYS    IF NON-ZIL CODE RUNNING NOW\n         BOR   #6                  THEN JUST RETURN, CODE'LL DETECT\n         C     #4,TAIERSAV+(13*4)  IF REG 13 AT ATTN TIME = ZLCOMMON\n         BNE   REGSBAD             THEN WE'RE OK SO FAR, ELSE PROBLEM\n         L     #1,TAIEIAD          ELSE GET ADDRESS OF INSTR AT ATTN\n         B     ZAPIT               AND GO TO ZAP INSTRUCTION\nREGSBAD  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  IF REGISTER 13, AS FOUND IN THE TAIE, DOES NOT MATCH ZIL'S, THEN   *\n*  PROBABLY WE GOT INTERRUPTED WHILE WE WERE IN SOME OTHER RB'S CODE  *\n*  (AND ZLCISYS WAS NOT SET).  IN SUCH A CASE, WE SHOULD SCAN THE     *\n*  RB CHAIN FOR THE CORRECT RB.  WHEN WE FIND IT, WE SHOULD RESTORE   *\n*  REGS 8, 9 AND 10 TO THE BEST OF OUR ABILITY AND USE THE PSW FROM   *\n*  THAT RB TO STICK IN OUR \"BR 13\".                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #14,X'21C'          GET CURRENT TCB ADDRESS\n         L     #15,0(,#14)         GET CURRENT RB (IRB FOR ATTN EXIT)\nRBLOOP   DS    0H\n         CL    #15,ZLCZILRB        EXIT LOOP WHEN WE FOUND ZIL'S RB\n         BE    RBGOT\n         L     #15,X'1C'(,#15)     ELSE GET NEXT RB IN CHAIN\n         TM    X'B'(#15),X'80'     IF NO MORE RB'S\n         BO    FAILURE             THEN DISASTER\n         B     RBLOOP              ELSE KEEP SEARCHING RB CHAIN\nRBGOT    DS    0H\n         L     #1,X'14'(,#15)      GET RIGHT HALF OF RBOPSW\nZAPIT    DS    0H                  ZAP INSTRUCTION TO FORCE \"BR 13\"\n         ST    #1,ZLCINSTA         SAVE ADDRESS\n         LH    #0,0(,#1)           GET INSTRUCTION AT THAT ADDRESS\n         STH   #0,ZLCINSTR         SAVE INSTRUCTION\n         LH    #0,BR13             GET A \"BR 13\" INSTRUCTION\n         STH   #0,0(,#1)           OVERLAY INSTRUCTION WITH BR 13\n         OI    ZLCIFLGS,ZLCIOVER   INDICATE INSTRUCTION OVERLAID\n         SPACE 1\n         STATUS STOP               STOP ANY SUBTASKS FROM EXECUTING\n         SPACE 1\n         POST  ZLCECB              POST ECB IF WAITING FOR SUBTASK\n         SPACE 1\n         BR    #6                  RETURN TO SYSTEM SO ZIL CAN PROCEED\n         SPACE 1\nFAILURE  DS    0H                  DIDN'T FIND ZIL'S RB\n         SPACE 1\n         TPUT  NORB,L'NORB\n         SPACE 1\n         ABEND 0053,DUMP           ABEND\n         SPACE 1\nBR13     BR    #13                 INSTRUCTION TO ZAP INTO ZIL CODE\n         SPACE 1\nTIMEADDR DC    A(0)                ADDRESS OF IKJEFT25, TSO TIME CMD\nCPPL     DS    0A\nCPPLCBUF DC    A(FAKEBUF)      COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n         SPACE 1\nFAKEBUF  DC    X'0005000040'\n         SPACE 1\nSMCIBUF  DS    C                   FOR DUMMY TGET\n         SPACE 1\nHELPMSGS DS    0A\n         DC    A(L'HELP1),A(HELP1)\n         DC    A(L'HELP2),A(HELP2)\n         DC    A(L'HELP3),A(HELP3)\n         DC    A(L'HELP4),A(HELP4)\n         DC    A(L'HELP5),A(HELP5)\n         DC    A(L'HELP6),A(HELP6)\n         DC    A(L'HELP7),A(HELP7)\nHELPMSGE EQU   *\n         SPACE 1\nATTNOUT  DC    C'ZIL0051 ATTENTION INTERRUPT: TYPE A(BORT), R(ESUME), TX\n               (IME), H(ELP).'\nATTNIN   DC    CL1' '\nSMCMSG   DC    C'ZIL0052 NON-INTERRUPTIBLE PROCESS.  ABORTS WILL BE DEFX\n               ERRED UNTIL PROCESS IS COMPLETE.'\nNORB     DC    C'ZIL0053 UNABLE TO PROCESS ATTENTION INTERRUPT, ZIL RB X\n               NOT FOUND ON RB CHAIN.'\n         SPACE 1\nHELP1    DC    C'ZIL0055 Type one of the following and press ENTER:'\nHELP2    DC    C'          A - abort the current process and return to X\n               top level.'\nHELP3    DC    C'          R - resume processing as if nothing had happX\n               ened.'\nHELP4    DC    C'          T - display time used so far.'\nHELP5    DC    C'          H - show this information.'\nHELP6    DC    C'        Pressing ENTER is equivalent to R (resume).'\nHELP7    DC    C'        Pressing PA1 (attention) will terminate the enX\n               tire ZIL application.'\n         POP   USING\n         EJECT\n         LTORG\n         EJECT\n         IKJTAIE ,                 TERMINAL ATTENTION INTERRUPT ELEMENT\n         IKJPSCB ,\n         IKJUPT  ,\n         IKJRLGB ,\n         IKJECT ,\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETBRACK": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x00Y\\x00V\\x00X\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 89, "newlines": 86, "modlines": 88, "user": "SEB1525"}, "text": "         TITLE 'SETBRACK - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SETBRACK takes two required arguments - both must be characters -   *\n* and one optional argument.                                          *\n*                                                                     *\n* This function tells ZIL to use the specified characters as left     *\n* and right square brackets whenever writing to a file via PRINC      *\n* if tab expansion is active for that file, whether the file is a     *\n* dataset or the terminal.                                            *\n*                                                                     *\n* Argument 1 is the character to be output for left square brackets.  *\n* Argument 2 is the character to be output for right square brackets. *\n*                                                                     *\n* Argument 3, if specified and non-NIL, requests that the change be   *\n* made to the terminal output translate table as well.  This will     *\n* cause the exact characters specified to be sent to the terminal     *\n* as desired.  The default is to let ZIL try to determine the best    *\n* way of sending square brackets to the terminal, which may be        *\n* invalid for certain kinds of terminal connections.                  *\n*                                                                     *\n* Use this only when you want to force ZIL to send these characters;  *\n* they will end up being used for file output as well!                *\n*                                                                     *\n* For example, to tell ZIL to send square brackets to a VT220 which   *\n* is connected to MVS via a 7171 controller, do:                      *\n*                                                                     *\n*  (setbrack #XAD #XBD T)  ; send \"real\" brackets, even to terminal   *\n*                                                                     *\n* For a 3278 model 4, a 3279, a 3179 or a 3180:                       *\n*                                                                     *\n*  (setbrack #XAD #XBD NIL); send \"real\" brackets, let ZIL translate  *\n*                          ; to correct terminal code                 *\n*                                                                     *\n* For a 3278 model 2:                                                 *\n*                                                                     *\n*  (setbrack #XAD #XBD NIL); send \"real\" brackets.  There's no way    *\n*                          ; to print them on the terminal, so let    *\n*                          ; it display as garbage.                   *\n*                                                                     *\n* To restore default operation, which sends curly braces:             *\n*                                                                     *\n*  (setbrack #XC0 #XD0 NIL)                                           *\n*                                                                     *\n* Note: NIL may be omitted where specified in all examples above.     *\n*                                                                     *\n***********************************************************************\n         SPACE\nSETBRACK #ZBEG MINARGS=2,MAXARGS=3,NAME='SETBRACK'\n         #ZPDS 3*4+12+0 = 24\n         #ZSAV ,\n         SPACE\n         LM    #2,#4,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#2),##FIXNUM\n         BNE   ERROR1              ERROR IF ARG1 IS NOT A FIXNUM\n         CLI   ##TYPE(#3),##FIXNUM\n         BNE   ERROR2              ERROR IF ARG2 IS NOT A FIXNUM\n         L     #5,##CDR(,#2)       GET VALUE OF ARG1\n         CL    #5,#SFW255          MUST BE 0 <= X <= 255\n         BH    ERROR1\n         L     #6,##CDR(,#3)       GET VALUE OF ARG2\n         CL    #6,#SFW255          MUST BE 0 <= X <= 255\n         BH    ERROR2\n         STC   #5,ZLCLB            SET LEFT SQUARE BRACKET CHARACTER\n         STC   #6,ZLCRB            SET RIGHT SQUARE BRACKET CHARACTER\n         CR    #4,#13              IF ARG 3 SPECIFIED\n         BE    DEFAULT              AND\n         CR    #4,#10                ARG 3 NOT NIL\n         BE    DEFAULT                THEN\n         L     #14,ZLCTRMTR            GET TERMINAL OUTPUT TRANS TABLE\n         STC   #5,X'AD'(,#14)      SET LEFT SQUARE BRACKET CHARACTER\n         STC   #6,X'BD'(,#14)      SET RIGHT SQUARE BRACKET CHARACTER\nDEFAULT  DS    0H\n         LR    #15,#10             RETURN NIL\n         #ZRET ,\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'Argument 1 to SETBRACK not a valid character - ',(#2)\n         SPACE 1\nERROR2   DS    0H\n         #ERR  'Argument 2 to SETBRACK not a valid character - ',(#3)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETDEBUG": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x003\\x00\\x88\\x01_\\x01\\x00&_\\x168\\x00\\x1d\\x00\\x1a\\x00\\x1c\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:38:33", "lines": 29, "newlines": 26, "modlines": 28, "user": "SEB1525"}, "text": "         TITLE 'SETDEBUG - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SETDEBUG TAKES ONE REQUIRED ARGUMENT - NIL OR NON-NIL.              *\n*                                                                     *\n* IF THE ARG IS NIL, DEBUG MODE IS DISABLED;                          *\n* OTHERWISE, DEBUG MODE IS ENABLED.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nSETDEBUG #ZBEG MINARGS=1,MAXARGS=1,NAME='SETDEBUG'\n         SPACE\n         LR    #3,#15\n         DROP  #15\n         USING SETDEBUG,#3\n         L     #15,0(,#1)          PICK UP ARG 1\n         CR    #15,#10             IF ARG IS NIL\n         BNE   DEBUGT              THEN...\n         NI    ZLCERFLG,255-ZLCERDBG SET DEBUG MODE OFF\n         BR    #14\nDEBUGT   DS    0H                  ELSE...\n         OI    ZLCERFLG,ZLCERDBG    SET DEBUG MODE ON\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETPBIND": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00I\\x00\\x88\\x01_\\x01\\x00&_\\x168\\x00.\\x00+\\x00-\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:38:49", "lines": 46, "newlines": 43, "modlines": 45, "user": "SEB1525"}, "text": "         TITLE 'SETPBIND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This is the SETF method for PBIND, basically.                       *\n*                                                                     *\n* This function sets the \"binding cell\" of a symbol.  This is         *\n* what is actually called the \"value cell\", but is being used as      *\n* a cell to contain global dynamic bindings in the current            *\n* deep-binding implementation of ZIL.  In a shallow-binding           *\n* implementation, this will be a true value cell, and this            *\n* function will disappear.                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSETPBIND #ZBEG MINARGS=2,MAXARGS=2,NAME='SETPBIND'\n         SPACE 1\n         USING SETPBIND,#15\n         SPACE 1\n         LM    #2,#3,0(#1)\n         CLI   ##TYPE(#2),##SYMBOL\n         BNE   SPBERROR\n*\n* ... replace with code to check \"constant-p\" bit in symbol???\n*\n         CR    #2,#10              Can't set value cell of NIL\n         BE    SPBERROR\n         CR    #2,#8               Can't set value cell of T\n         BE    SPBERROR\n         ST    #3,##PVALUE(,#2)\n         LR    #15,#2\n         BR    #14\n         SPACE 1\nSPBERROR DS    0H\n         LR    #4,#15\n         DROP  #15\n         USING SETPBIND,#4\n         #ERR  'Argument to SETPBIND not a valid symbol - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETPLIST": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x01\\x00\\x88\\x01_\\x01\\x00&_\\x169\\x00\\x1a\\x00\\x17\\x00\\x19\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:39:01", "lines": 26, "newlines": 23, "modlines": 25, "user": "SEB1525"}, "text": "         TITLE 'SETPLIST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSETPLIST #ZBEG MINARGS=2,MAXARGS=2,NAME='SETPLIST'\n         SPACE 1\n         USING SETPLIST,#15\n         SPACE 1\n         LM    #2,#3,0(#1)\n         CLI   ##TYPE(#2),##SYMBOL\n         BNE   SPLERROR\n         ST    #3,##PLIST(,#2)\n         LR    #15,#2\n         BR    #14\n         SPACE 1\nSPLERROR DS    0H\n         LR    #4,#15\n         DROP  #15\n         USING SETPLIST,#4\n         #ERR  'Argument to SETPLIST not a symbol - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETSALST": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x00\\x0e\\x00\\x0b\\x00\\r\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 14, "newlines": 11, "modlines": 13, "user": "SEB1525"}, "text": "         TITLE 'SETSALST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSETSALST #ZBEG MINARGS=1,MAXARGS=1,NAME='SETSALST'\n         SPACE 1\n         L     #15,0(,#1)          GET ARG 1\n         ST    #15,ZLCSALST        STORE INTO SPECIAL ALIST\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SFLOATP": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'SFLOATP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSFLOATP  #ZBEG MINARGS=1,MAXARGS=1,NAME='SFLOATP'\n         SPACE 1\n         USING SFLOATP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##SFLOAT\n         BNE   ZXFLON\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXFLON   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLEEP": {"ttr": 5390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x00$\\x00!\\x00#\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 36, "newlines": 33, "modlines": 35, "user": "SEB1525"}, "text": "         TITLE 'SLEEP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* SLEEP PUTS ZIL TO SLEEP FOR THE SPECIFIED NUMBER OF SECONDS.\n*\n***********************************************************************\nSLEEP    #ZBEG MINARGS=1,MAXARGS=1,NAME='SLEEP'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #2,0(,#11)          GET ARG 1\n         CLI   ##TYPE(#2),##FIXNUM IF ARG 1 IS NOT A FIXNUM\n         BNE   ERROR               THEN ERROR\n         ICM   #3,15,##CDR(#2)     ELSE GET VALUE\n         BM    ERROR\n         MH    #3,=H'100'          CONVERT TO HUNDREDTHS OF A SECOND\n         ST    #3,TIME             STORE TIME VALUE FOR STIMER\n         SPACE\n         STIMER WAIT,BINTVL=TIME   GO TO SLEEP FOR N SECONDS\n         SPACE\n         LR    #15,#10             RETURN NIL\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\nERROR    #ERR  'Argument to SLEEP not a positive fixnum - ',0(#11)\n         SPACE\nTIME     DS    F\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLENGTH": {"ttr": 5392, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x00(\\x00%\\x00'\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 40, "newlines": 37, "modlines": 39, "user": "SEB1525"}, "text": "         TITLE 'SLENGTH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SLENGTH TAKES ONE ARGUMENT - A STRING                               *\n*                                                                     *\n***********************************************************************\nSLENGTH  #ZBEG MINARGS=1,MAXARGS=1,NAME='STRING-LENGTH'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #1,0(,#11)          LOAD FIRST (AND ONLY) ARGUMENT\n         XR    #2,#2               CLEAR INSERT REGISTER\n         CLI   ##TYPE(#1),##STRING ARG MUST BE A STRING OR SYMBOL\n         BE    OK                  ELSE ERROR\n         CLI   ##TYPE(#1),##SYMBOL IF SYMBOL, THEN USE PRINT NAME\n         BNE   ERROR1\n         L     #1,##PNAME(,#1)\nOK       DS    0H\n         ICM   #2,7,1(#1)          GET LENGTH OF STRING TEXT\n         CL    #2,ZLCSFTHI         If within small fixnum range\n         BNH   SMALLFIX            then go return a fixnum from table\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN\nSMALLFIX DS    0H                  If fixnum is small enough...\n         SLA   #2,3                convert to index into fixnum table\n         LA    #15,#SFT(#2)        return small fixnum from table\nRETURN   DS    0H\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 3\nERROR1   DS    0H                  INVALID ARGUMENT\n         #ERR  'Argument to STRING-LENGTH not a string - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SREVERSE": {"ttr": 5394, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11D\\x00>\\x00;\\x00=\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:44:00", "lines": 62, "newlines": 59, "modlines": 61, "user": "SEB1525"}, "text": "         TITLE 'SREVERSE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (STRING-REVERSE ARG1)                                               *\n*                                                                     *\n* THIS FUNCTION REVERSES A STRING.                                    *\n*                                                                     *\n* STRING-RIGHT-TRIM USES THIS FUNCTION.  OTHERWISE IT'S RATHER DUMB.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSREVERSE #ZBEG MINARGS=1,MAXARGS=1,NAME='STRING-REVERSE'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #15,0(,#11)         LOAD ARG1\n         CLI   ##TYPE(#15),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#15),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #15,##PNAME(,#15)    TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         XR    #2,#2               CLEAR INSERT REGISTER\n         ST    #15,0(,#11)         STORE BACK ON STACK FOR LATER USE\n         ICM   #2,7,1(#15)         GET LENGTH OF STRING FOR ZILVSS\n         BZ    RETURN              IF NULL STRING, RETURN SELF\n         CH    #2,=H'1'\n         BNH   RETURN              IF STRING LENGTH 1 OR LESS, RET SELF\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #15,#15             IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         L     #5,0(,#11)          GET POINTER TO ORIGINAL STRING\n         XR    #2,#2               CLEAR INSERT REGISTER\n         LA    #1,##VECDAT(,#5)    POINT TO FIRST CHAR IN OLD STRING\n         ICM   #2,7,1(#5)          GET LENGTH OF STRING\n         LA    #5,##VECDAT-1(#15,#2) POINT TO LAST CHAR OF NEW STRING\n         AR    #2,#1               POINT TO END OF OLD STRING\n         LA    #3,##VECDAT(,#15)   POINT TO BEGINNING OF NEW STRING\n         LA    #4,1                SET BXLE INCREMENT REGISTER\nLOOP     DS    0H\n         BCTR  #2,0                BUMP TO PREVIOUS CHAR IN OLD STRING\n         MVC   0(1,#3),0(#2)       MOVE OLD CHARACTER TO NEW CHARACTER\n         BXLE  #3,#4,LOOP\nENDLOOP  DS    0H\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   #ERR  'Argument to STRING-REVERSE not a string - ',0(#11)\nERROR2   #ERR  'ZIL4010 STRING-REVERSE: Not enough vector/string space X\n               to build string',PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SSCAN": {"ttr": 5396, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x07_\\x00\\x89\\x15o\\x11E\\x03o\\x00\\xf0\\x03o\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-03-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 879, "newlines": 240, "modlines": 879, "user": "SEB1525"}, "text": "***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         TITLE 'STRING-SCAN - MACROS'\n         MACRO\n&SYM     XTRT  &DATR,&TABLE,&LENR=,&F256=#0\n         LCLC  &LBLA,&LBLB,&LBLC,&LBLX\n&LBLA    SETC  'XTRA&SYSNDX'\n&LBLB    SETC  'XTRB&SYSNDX'\n&LBLC    SETC  'XTRC&SYSNDX'\n&LBLX    SETC  'XTRX&SYSNDX'\n&SYM     LA    &F256,256            Set up constant 256\n&LBLC    CR    &LENR,&F256          If length greater than 256\n         BNH   &LBLA                then...\n         TRT   0(256,&DATR),&TABLE   scan for desired characters\n         BNZ   &LBLB                 If we found something, exit\n         AR    &DATR,&F256           Else increment text pointer by 256\n         SR    &LENR,&F256           Decrement length by 256\n         B     &LBLC                 Continue scanning.\n&LBLX    TRT   0(*-*,&DATR),&TABLE  (Executed instruction)\n&LBLA    DS    0H                  Else...\n         BCTR  &LENR,0              Reduce length for execute\n         EX    &LENR,&LBLX          Scan for desired characters\n&LBLB    DS    0H\n         MEND\n         TITLE 'STRING-SCAN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                       ZIL 1.3 MAR88 - S. BACHER                     *\n***********************************************************************\n*                                                                     *\n* STRING-SCAN                                                         *\n*                                                                     *\n* This function takes (1) a string to be tokenized and returns a list *\n* of strings, all of which are \"words\" in the string.  The string is  *\n* parsed into words according to the following optional arguments:    *\n*                                                                     *\n* (2) the whitespace string, which is a \"bag\" of string characters    *\n*     to act as whitespace (in other words, the occurrence of any     *\n*     of the characters in the \"whitespace bag\" marks the end of a    *\n*     word).                                                          *\n*                                                                     *\n* (3) the singleton string, which is a \"bag\" of string characters     *\n*     to act as self-defined single characters.  Each of these gets   *\n*     returned as a one-character string in the resulting list.       *\n*                                                                     *\n* (4) either a null string, a one-character string, or a              *\n*     two-character string, which defines a \"quote\" character.  The   *\n*     first character of the string defines the character to be used  *\n*     to quote strings, and the second character determines the       *\n*     convention for embedding the quote character in the string.     *\n*     If a one-character string is specified, or the second character *\n*     is the same as the first, the quote character is specified by   *\n*     doubling it (e.g. 'don''t').  If the second character is a      *\n*     different character from the first, it is a \"single escape\"     *\n*     character, and any character following it is contained in the   *\n*     quoted string (e.g. \"don\\\"t\").                                  *\n*                                                                     *\n*     The string is constructed including the enclosing quotes and    *\n*     doubled embedded quotes or escape characters.  In this way the  *\n*     caller can distinguish between quoted and unquoted strings,     *\n*     but is responsible for unquoting the string him/herself.        *\n*                                                                     *\n*     An error is signalled if the ending quote of a string is not    *\n*     found, or if the escape character is not followed by something. *\n*                                                                     *\n*     If a null string is specified, no quote character is used.      *\n*     Only one quote character can be specified.                      *\n*                                                                     *\n* (5) a beginning-comment string (not a \"bag\") which signals the      *\n*     beginning of a comment.  If \"\", there is no sequence which      *\n*     starts a comment.  Comments are terminated by end-of-string     *\n*     or the ending-comment string specified in...                    *\n*                                                                     *\n* (6) an ending-comment string (not a \"bag\") which signals the        *\n*     end of a comment.  If \"\", only end-of-string can terminate      *\n*     a comment.                                                      *\n*                                                                     *\n* (7) a list of multiple-character tokens (strings of length 2 or     *\n*     more).   Default is the null list.                              *\n*                                                                     *\n* Syntax:                                                             *\n*                                                                     *\n*  (STRING-SCAN string &optional (whitespace-bag       \" \")           *\n*                                (singleton-bag        \"\" )           *\n*                                (quote-spec           \"\" )           *\n*                                (comment-start-string \"\" )           *\n*                                (comment-end-string   \"\" )           *\n*                                (token-list           NIL)           *\n*  )                                                                  *\n*                                                                     *\n* Note:  If NIL is specified for any of the arguments other than the  *\n*        last (token-list), it is treated like the string \"NIL\".      *\n*        Therefore, do not specify NIL to mean a default or           *\n*        unsupplied argument for any of those arguments!              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSSCAN    #ZBEG MINARGS=1,MAXARGS=7,NAME='STRING-SCAN'\n         #ZPDS 7*4+12+12 = 52      DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         LM    #3,#7,0(#11)        Load args 1, 2, 3, 4, 5 (not 6 yet)\n         XC    TRTDLM(256),TRTDLM  Init whitespace translate table\n         MVI   TRTNDLM,4           Init non-whitespace translate table\n         MVC   TRTNDLM+1(255),TRTNDLM\n         XC    TRTQUOTE(256),TRTQUOTE Init quoted string translate tbl\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process argument 1, the string                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   ##TYPE(#3),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#3),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #3,##PNAME(,#3)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process argument 2, the whitespace bag                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CR    #4,#13              If arg 2 is unsupplied\n         BNE   NOTDEF2             then...\n         MVI   TRTDLM+X'40',4       set space as only delimiter\n         MVI   TRTNDLM+X'40',0      set space as only delimiter\n         B     BUILTTRT             and go to check arg 3\nNOTDEF2  DS    0H                  Else...\n         CLI   ##TYPE(#4),##STRING IF ARGUMENT IS A STRING\n         BE    ARG2OK              THEN OK\n         CLI   ##TYPE(#4),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR2              THEN\n         L     #4,##PNAME(,#4)      TAKE THE PRINT NAME, ELSE ERROR\nARG2OK   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Build translate table from argument 2                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #14,#14             Clear insert register\n         ICM   #14,7,1(#4)         Get length of argument 2\n         BZ    BUILTTRT            If zero, finished\n         LA    #1,##VECDAT(,#4)    Point to text of string arg 2\n         XR    #15,#15             Clear insert register\n         LA    #0,4                Set value to stick into table\n         XR    #2,#2               Set value to stick into table\nTBLDLOOP DS    0H\n         IC    #15,0(,#1)          Get character from string arg 2\n         STC   #0,TRTDLM(#15)      Set table char to flag as delimiter\n         STC   #2,TRTNDLM(#15)     Set table char to bypass delimiters\n         LA    #1,1(,#1)           Increment character pointer\n         BCT   #14,TBLDLOOP        Continue until arg 2 exhausted\nBUILTTRT DS    0H                  Now tables are built\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process argument 3, the singleton bag                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CR    #5,#13              If arg 3 is unsupplied\n         BE    NOSINGLE            then do nothing.\n         CLI   ##TYPE(#5),##STRING IF ARGUMENT IS A STRING\n         BE    ARG3OK              THEN OK\n         CLI   ##TYPE(#5),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR3              THEN\n         L     #5,##PNAME(,#5)      TAKE THE PRINT NAME, ELSE ERROR\nARG3OK   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Modify translate tables from argument 3                             *\n*                                                                     *\n* Note that any singleton character specified overrides the same      *\n* character having been specified in the whitespace bag.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #14,#14             Clear insert register\n         ICM   #14,7,1(#5)         Get length of argument 3\n         BZ    NOSINGLE            If zero, finished\n         LA    #1,##VECDAT(,#5)    Point to text of string arg 3\n         XR    #15,#15             Clear insert register\n         LA    #0,8                Set value to stick into table\nTMODLOOP DS    0H\n         IC    #15,0(,#1)          Get character from string arg 3\n         STC   #0,TRTDLM(#15)      Set table char to flag as singleton\n         STC   #0,TRTNDLM(#15)     Set table char to flag as singleton\n         LA    #1,1(,#1)           Increment character pointer\n         BCT   #14,TMODLOOP        Continue until arg 3 exhausted\nNOSINGLE DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process argument 4, the quote bag                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CR    #6,#13              If arg 4 is unsupplied\n         BE    NOQUOTE             then do nothing.\n         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING\n         BE    ARG4OK              THEN OK\n         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR4              THEN\n         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR\nARG4OK   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Modify translate tables from argument 4                             *\n*                                                                     *\n* Note that any quote character specified overrides the same          *\n* character having been specified in a previous bag argument.         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #14,#14             Clear insert register\n         ICM   #14,7,1(#6)         Get length of argument 4\n         BZ    NOQUOTE             If zero, finished\n         XR    #15,#15             Clear insert register\n         LA    #0,12               Set value to stick into table\n         IC    #15,##VECDAT(,#6)   Get quote character from arg 4\n         STC   #0,TRTDLM(#15)      Set table char to flag as quoter\n         STC   #0,TRTNDLM(#15)     Set table char to flag as quoter\n         C     #14,#SFW1           If string length is 1,\n         BE    EMDQUOTE            then embed quotes by doubling\n         C     #14,#SFW2           If string length is not 2,\n         BNE   ERROR4A             then invalid arg 4\n         CLM   #15,1,##VECDAT+1(#6) If character 2 same as character 1\n         BE    EMDQUOTE            then embed quotes by doubling\n         LA    #0,4                Else set normal quote value\n         STC   #0,TRTQUOTE(#15)    Set table char to flag as quoter\n         LA    #0,12               Set escape value\n         IC    #15,##VECDAT+1(,#6) Get escape character from arg 4\n         STC   #0,TRTQUOTE(#15)    Set table char to flag as escape\n         B     NOQUOTE\nEMDQUOTE DS    0H\n         LA    #0,8                Set doubling quote value\n         STC   #0,TRTQUOTE(#15)    Set table char quote doubler\nNOQUOTE  DS    0H\n         SPACE 1\n         XR    #14,#14             Clear insert register\n         STH   #14,COMSLEN         Initialize start string length to 0\n         STH   #14,COMELEN         Initialize end string length to 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process argument 5, the comment start string                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CR    #7,#13              If arg 5 is unsupplied\n         BE    NOCOMM              then do nothing.\n         CLI   ##TYPE(#7),##STRING IF ARGUMENT IS A STRING\n         BE    ARG5OK              THEN OK\n         CLI   ##TYPE(#7),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR5              THEN\n         L     #7,##PNAME(,#7)      TAKE THE PRINT NAME, ELSE ERROR\nARG5OK   DS    0H\n         ST    #7,16(,#11)         Store back on stack for future use\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Modify translate tables from argument 5                             *\n*                                                                     *\n* Note that we alter the entry by adding 16 (X'10') to it.            *\n* The original function of the character, if any, is unchanged.       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   #14,7,1(#7)         Get length of argument 5\n         BZ    NOCOMM              If zero, no comment start string\n         CH    #14,=H'256'         Cannot be longer than 256\n         BH    ERROR5A             (I mean, don't be ridiculous)\n         STH   #14,COMSLEN         Save comment start string length\n         BCTR  #14,0               Reduce for CLC\n         STC   #14,CLCCOMS+1       Store into CLC instruction\n*                                  Assert #14 = X'000000__'\n         IC    #14,##VECDAT(,#7)   Get first character of string\n         LA    #1,TRTDLM(#14)      Point to position in translate table\n         OI    0(#1),X'10'         Set up for TRT\n         LA    #1,TRTNDLM(#14)     Point to position in translate table\n         OI    0(#1),X'10'         Set up for TRT\n         XC    TRTCOM(256),TRTCOM  Initialize comment translate table\n         XC    TRTCS(256),TRTCS    Initialize comment translate table\n         LA    #1,TRTCS(#14)       Point to position in translate table\n         MVI   0(#1),4             Set up for TRT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process argument 6, the comment end string                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #7,20(,#11)         Load argument 6\n         CR    #7,#13              If arg 6 is unsupplied\n         BE    NOCOMM              then do nothing.\n         CLI   ##TYPE(#7),##STRING IF ARGUMENT IS A STRING\n         BE    ARG6OK              THEN OK\n         CLI   ##TYPE(#7),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR6              THEN\n         L     #7,##PNAME(,#7)      TAKE THE PRINT NAME, ELSE ERROR\nARG6OK   DS    0H\n         ST    #7,20(,#11)         Store back on stack for future use\n         XR    #14,#14             Clear insert register\n         ICM   #14,7,1(#7)         Get length of argument 6\n         BZ    NOCOMM              If zero, no comment end string\n         CH    #14,=H'256'         Cannot be longer than 256\n         BH    ERROR6A             (I mean, don't be ridiculous)\n         STH   #14,COMELEN         Save comment end string length\n         BCTR  #14,0               Reduce for CLC\n         STC   #14,CLCCOME+1       Store into CLC instruction\n*                                  Assert #14 = X'000000__'\n         IC    #14,##VECDAT(,#7)   Get first character of string\n         LA    #1,TRTCOM(#14)      Point to position in translate table\n         MVI   0(#1),4             Set up for TRT\n         SPACE 1\nNOCOMM   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Process argument 7, the multiple-character token list               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #7,24(,#11)         Get argument 7\n         CR    #7,#13              If arg 7 is unsupplied\n         BE    NOTLIST             then do nothing.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Modify translate tables from argument 7                             *\n*                                                                     *\n* Note that we alter the entry by adding 32 (X'20') to it.            *\n* The original function of the character, if any, is unchanged.       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTLLOOP   DS    0H                  Loop through elements of list\n         CR    #7,#10\n         BE    NOTLIST             When list is null, finished\n         ICM   #2,15,##CAR(#7)     Get CAR of list\n         BM    ERROR7              If sublist was atomic, error\n         CLI   ##TYPE(#2),##STRING IF ARGUMENT IS A STRING\n         BE    ELEM7OK             THEN OK\n         CLI   ##TYPE(#2),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR7A             THEN\n         L     #2,##PNAME(,#2)      TAKE THE PRINT NAME, ELSE ERROR\nELEM7OK  DS    0H\n         ICM   #14,7,1(#2)         Get length of element\n         BZ    ELEM7NXT            If zero, skip this one\n         CH    #14,=H'256'         Cannot be longer than 256\n         BH    ERROR7B             (I mean, don't be ridiculous)\n         IC    #14,##VECDAT(,#2)   Get first character of string\n         LA    #1,TRTDLM(#14)      Point to position in translate table\n         OI    0(#1),X'20'         Set up for TRT\n         LA    #1,TRTNDLM(#14)     Point to position in translate table\n         OI    0(#1),X'20'         Set up for TRT\nELEM7NXT DS    0H\n         L     #7,##CDR(,#7)       Get CDR of list\n         B     TLLOOP              Continue\n         SPACE 1\nNOTLIST  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, all arguments processed.  Let's get moving.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ST    #3,0(,#11)          STORE BACK ON STACK FOR FUTURE USE\n         ICM   #7,7,1(#3)          GET LENGTH OF STRING\n         BZ    RETNIL              IF ZERO-LENGTH STRING, RETURN NIL\n         LA    #6,##VECDAT         Offset of substring to scan\n         LA    #7,##VECDAT(,#7)    Offset of end of string\n         LR    #15,#7              Get offset of end of string minus\n         SH    #15,COMSLEN          length of comment start string\n         ST    #15,COMSEND         Store it\n         LR    #15,#7              Get offset of end of string minus\n         SH    #15,COMELEN          length of comment end string\n         ST    #15,COMEEND         Store it\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Initialize the return list on the stack.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    #10,40(,#11)        Initialize return list to NIL\n         ST    #10,44(,#11)        Initialize return list to NIL\n         ST    #10,48(,#11)        Initialize saved MT holder to NIL\n         SPACE 1\nLOOP     DS    0H                  Loop to search for words, etc.\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*     Scan string for next non-whitespace character.                  *\n*     #6 = offset of substring to scan                                *\n*     #7 = offset of end of string                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #15,#7              Compute length to scan\n         SR    #15,#6              If not positive,\n         BNP   RETLIST              return with list\n*\n* In case a multi-character token was found in a previous scan and\n* we'd just pick it up again, this is to avoid duplicating the search\n*\n         C     #10,48(,#11)        If there's a stacked token string\n         BE    NOSTKDMT            then...\n         L     #4,48(,#11)          load it up\n         ST    #10,48(,#11)         clear stacked entry\n         XR    #14,#14              clear insert register\n         ICM   #14,7,1(#4)          get length of token string\n         ST    #14,LEN2NEXT         remember it for future bumping\n         B     CONSIT               and go add it to result list\nNOSTKDMT DS    0H\n         LR    #14,#6              Compute address in string to scan\n         A     #14,0(,#11)          from offset\n         XR    #2,#2               Clear TRT register\n         XTRT  #14,TRTNDLM,LENR=#15 Scan for constituent\n         CH    #2,=Y(32)           If X'20' bit is on from table\n         BNL   FOUNDMT             then found possible multichar token\n         B     XTRTND(#2)          Else go depending on what was found\nXTRTND   B     RETLIST             0, nothing found, return with list\n         B     FOUNDND             4, constituent found, process it\n         B     MKSINGLE            8, singleton found, make character\n         B     FOUNDQ              12, quote found, make quoted string\n         B     COMMENT             16, comment or whitespace\n         B     CFOUNDND            20, comment or constituent\n         B     CMKSINGL            24, comment or singleton\n         B     CFOUNDQ             28, comment or quote\n         SPACE 1\nFOUNDMT  DS    0H                  Found possible multicharacter token\n         SPACE 1\n         BAL   #3,TRYMT            Try to find a matching token\n         ST    #14,LEN2NEXT        Set length to bump past\n         LTR   #4,#15              If we found one, #15 -> the string\n         BNZ   CONSIT              and go add it to result list\n         SH    #2,=Y(32)           Else turn off X'20' bit\n         BNZ   XTRTND(#2)          If nonzero, proceed from table\n         LA    #6,1(,#6)           Else zero, process as whitespace\n         B     LOOP                and go back to scan again.\n         SPACE 1\nCOMMENT  DS    0H                  Either a comment or whitespace\n         SPACE 1\n         BAL   #3,TRYCOMT          See if this is really a comment\n         LTR   #15,#15             If it was,\n         BNZ   LOOP                then go back to scan again\n         LA    #6,1(,#6)           Else bump past whitespace char\n         B     LOOP                and go back to scan again.\n         SPACE 1\nCFOUNDND DS    0H                  Either a comment or constituent\n         SPACE 1\n         BAL   #3,TRYCOMT          See if this is really a comment\n         LTR   #15,#15             If it was,\n         BNZ   LOOP                 then go back to scan again\n         B     FOUNDND             Else go to process constituent\n         SPACE 1\nCMKSINGL DS    0H                  Either a comment or singleton\n         SPACE 1\n         BAL   #3,TRYCOMT          See if this is really a comment\n         LTR   #15,#15             If it was,\n         BNZ   LOOP                 then go back to scan again\n         B     MKSINGLE            Else go to process singleton\n         SPACE 1\nCFOUNDQ  DS    0H                  Either a comment or quote\n         SPACE 1\n         BAL   #3,TRYCOMT          See if this is really a comment\n         LTR   #15,#15             If it was,\n         BNZ   LOOP                 then go back to scan again\n         B     FOUNDQ              Else go to process quote\n         SPACE 1\nMKSINGLE DS    0H                  #1 -> single character\n         SPACE 1\n         LR    #6,#1               Get pointer to substring\n         S     #6,0(,#11)          Convert to offset\n         LA    #3,1                Set length of substring\n         ST    #3,LEN2NEXT         Save it\n*                                  Assert #2 = X'00000008'\n         IC    #2,0(,#1)           Get singleton character\n         LR    #1,#2               Get singleton character\n         SLA   #2,3                Convert to index into SINGTAB\n         L     #4,=A(SINGTAB)\n         ALR   #4,#2               Get address of SINGTAB entry\n         CLI   0(#4),##STRING      If there's already a string there\n         BE    CONSIT              then use it.\n         SLL   #1,24               Else shift character over string\n         L     #0,STRHDR           Set up string header with contents\n         STM   #0,#1,0(#4)         Initialize string\n         B     CONSIT              Go add it to list\n         SPACE 1\nFOUNDQ   DS    0H                  Start of a quoted string\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*     Scan quoted string, processing either doubled quotes or         *\n*     escape characters.                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #6,#1               Save address of first quote\n         S     #6,0(,#11)          Convert to offset within string\n         LA    #3,1(,#6)           Next character is first to scan\nQLOOP    DS    0H\n         LR    #15,#7              Compute length remaining to scan\n         SR    #15,#3\n         BNP   ERROR4B             If not positive, missing end quote\n         LR    #14,#3              Compute address in string to scan\n         A     #14,0(,#11)          from offset\n         XR    #2,#2               Clear TRT register\n         XTRT  #14,TRTQUOTE,LENR=#15 Scan quoted string\n         B     XTRTQ(#2)           Branch depending on what found\nXTRTQ    B     ERROR4B             0, nada found, missing quote error\n         B     QEND                4, normal quote found, ends string\n         B     QQUOTE              8, doubling quote found, check it\n         B     QESCAPE             12, escape char found, process it\n         SPACE 1\nQEND     DS    0H                  Found quote that marks end of string\n         SPACE 1\n         LA    #3,1(,#1)           Get address of char following quote\n         S     #3,0(,#11)          Convert to offset\n         B     QWORDEND            Go to process complete quoted string\n         SPACE 1\nQQUOTE   DS    0H                  Found quote.  Check for double\n         SPACE 1\n         LA    #3,1(,#1)           Get address of char following quote\n         S     #3,0(,#11)          Convert to offset\n         LR    #15,#7              Compute length remaining to scan\n         SR    #15,#3\n         BNP   QWORDEND            If zero, this is an ending quote\n         CLC   0(1,#1),1(#1)       If quote is not doubled\n         BNE   QWORDEND            then this is an ending quote\n         LA    #3,1(,#3)           Else bump past second quote\n         B     QLOOP               and continue scanning\n         SPACE 1\nQESCAPE  DS    0H                  Found escape character.\n         SPACE 1\n         LA    #3,1(,#1)           Get address of char following escape\n         S     #3,0(,#11)          Convert to offset\n         LR    #15,#7              Compute length remaining to scan\n         SR    #15,#3\n         BNP   ERROR4C             If zero, dangling escape character\n         LA    #3,1(,#3)           Else bump past char following escape\n         B     QLOOP               and continue scanning\n         SPACE 1\nQWORDEND DS    0H\n         SPACE 1\n         ST    #6,WORDPTR          Store offset of start of \"word\"\n         B     ENDWORDQ            Go to process complete quoted string\n         SPACE 1\nFOUNDND  DS    0H                  #1 -> constituent character\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*     Scan string for first delimiter following constituents found,   *\n*     or else end of string delimits this word.                       *\n*     The substring from constituent to here is used to construct a   *\n*     new string to be added at the end of the list being built.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #6,#1               Save address of first constituent\n         S     #6,0(,#11)          Convert to offset within string\n         ST    #6,WORDPTR          Save it\n         LA    #6,1(,#6)           Bump to next character\nWORDLOOP DS    0H\n         LR    #1,#7               Preset end-of-word to end-of-string\n         A     #1,0(,#11)           from offset\n         LR    #15,#7              Compute length remaining to scan\n         SR    #15,#6              If zero, end of word\n         BNP   ENDWORD\n         LR    #14,#6              Compute address in string to scan\n         A     #14,0(,#11)          from offset\n         XR    #2,#2               Preset anything-found TRT register\n         XTRT  #14,TRTDLM,LENR=#15 Scan for end of word\n         CH    #2,=Y(32+16)        If multichar-token-or-comment-or-\n         BE    DTRYMT               constituent, then check it.\n         CH    #2,=Y(32)           If multichar-token-or-constituent\n         BE    DTRYMT               then check it.\nTRYNOTMT DS    0H\n         CH    #2,=Y(16)           If comment-or-constituent,\n         BE    DTRYCOM              then check it.\n         B     ENDWORD             Else always end of word.\n         SPACE 1\nDTRYCOM  DS    0H                  Possible comment\n         BAL   #3,TRYCOMT          See if this is a comment\n         LTR   #15,#15              Get address of start of comment\n         BNZ   ENDWORDC             If it was a comment, it ends word\n         LA    #6,1(,#6)           Else bump past constituent char\n         B     WORDLOOP            and continue scan.\n         SPACE 1\nENDWORDC DS    0H                  Word ended by comment string\n         SPACE 1\n*                                  #6 = offset of end of comment\n         S     #6,WORDPTR          Subtract offset of start of word\n         ST    #6,LEN2NEXT         Save length to get to next word\n         LR    #3,#15              Get address of start of comment\n         S     #3,0(,#11)          Convert to offset\n         L     #6,WORDPTR          Get offset of start of word\n         SR    #3,#6               Compute length of word substring\n         B     MAKEIT\n         SPACE 1\nDTRYMT   DS    0H                  Possible multi-character token\n         BAL   #3,TRYMT            See if this is a token\n         LTR   #15,#15             Get address of token string\n         BNZ   ENDWORDM            If it was a token, it ends word\n         SH    #2,=Y(32)           Else turn off token flag in TRT reg\n         BNZ   TRYNOTMT            If still something, try again\n         LA    #6,1(,#6)           Else bump past constituent char\n         B     WORDLOOP            and continue scan.\n         SPACE 1\nENDWORDM DS    0H                  Word ended by multi-char token\n         SPACE 1\n         ST    #15,48(,#11)        Save ptr to token string on stack\n         LR    #3,#6               Get offset of start of new token\n         L     #6,WORDPTR          Get offset of start of old word\n         SR    #3,#6               Compute length of word substring\n         ST    #3,LEN2NEXT         Save it\n         B     MAKEIT              Go to make the word\n         SPACE 1\nENDWORD  DS    0H                  Found end of word or substring\n         SPACE 1\n         LR    #3,#1               Get pointer past end of word\n         S     #3,0(,#11)          Convert to offset\nENDWORDQ DS    0H                  #3 = offset of end of word\n         L     #6,WORDPTR          Get offset of start of word\n         SR    #3,#6               Compute length of word substring\n         ST    #3,LEN2NEXT         Save it\nMAKEIT   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Make a string out of the substring just scanned.                    *\n*                                                                     *\n* #1 -> position past last constituent character in word just scanned *\n* #2 tells what was found                                             *\n* #3 is offset of where we scanned to                                 *\n* #6 is offset of start of word within string                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #2,#3               Get length into reg for ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,52(,#11)         SET CURRENT STACK POINTER FOR GC\n         BALR  #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #4,#15              IF STRING BUILD FAILED\n         BZ    ERRORG              THEN ERROR\n         LR    #0,#6               Get offset of substring to build\n         A     #0,0(,#11)          Convert to address in string arg 1\n         LA    #14,##VECDAT(,#4)   Point to where to move string text\n         LR    #1,#3               Get length of string text to move\n         LR    #15,#3\n         MVCL  #14,#0              Move text from substring to new\nCONSIT   DS    0H                  Add new string to list\n*                                  #3 = length of new string\n*                                  #4 = address of new string\n*                                  #6 = offset of new string in arg 1\n         LR    #1,#4               Arg 1 to CONS = new string\n         LR    #2,#10              Arg 2 to CONS= NIL\n         L     #15,ZLCCONS         Get address of ZILCONS\n         LA    #0,52(,#11)         SET CURRENT STACK POINTER FOR GC\n         BALR  #14,#15             Call ZILCONS to (cons string NIL)\n         C     #10,44(,#11)        If no list so far yet,\n         BNE   OLDLIST              then...\n         ST    #15,40(,#11)         set the list to this\n         B     AFTLIST\nOLDLIST  DS    0H                  else...\n         L     #14,44(,#11)         get address of last-cons-to-bash\n         ST    #15,##CDR(,#14)      bash into list\nAFTLIST  DS    0H\n         ST    #15,44(,#11)        Set cons-to-bash to latest cons\n         A     #6,LEN2NEXT         Reset string scanning offset\n         B     LOOP                Continue looking for words\n         SPACE 1\nRETNIL   DS    0H                  Null string, or only whitespace\n         LR    #15,#10             Return a null list\n         B     RETURN\nRETLIST  DS    0H\n         L     #15,40(,#11)        Return the list built\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nTRYCOMT  DS    0H                  Subroutine to check for comment\n         SPACE 1\n         LR    #6,#1               Get pointer to substring\n         S     #6,0(,#11)          Convert to offset\n         XR    #15,#15             Preset return value to \"NO\"\n         C     #6,COMSEND          If past place where there can be\n         BHR   #3                   a comment starter, return \"NO\"\n         L     #14,16(,#11)        Get address of comment start string\n*\n* Note: The CLC length field was filled in when arg 5 was processed.\n*\nCLCCOMS  CLC   0(*-*,#1),##VECDAT(#14) If this isn't comment start\n         BNER  #3                   then return \"NO\"\n         ST    #1,CCSADDR          Else save address of comment start\n         AH    #6,COMSLEN          Bump past end of comment string\nTRYLOOP  DS    0H                  Else...\n         LR    #15,#7              Compute length remaining to scan\n         SR    #15,#6\n         BNP   TRYCOMTE            If zero, hit end of string\n         LR    #14,#6              Compute address in string to scan\n         A     #14,0(,#11)          from offset\n         XTRT  #14,TRTCOM,LENR=#15 Scan for comment end string\n         BZ    TRYCOMTE            If hit end of string, so be it\n         LR    #6,#1               Get pointer to substring\n         S     #6,0(,#11)          Convert to offset\n         C     #6,COMEEND          If past place where there can be\n         BH    TRYCOMTE             a comment ender, go end of string\n         L     #14,20(,#11)        Get address of comment start string\n*\n* Note: The CLC length field was filled in when arg 6 was processed.\n*\nCLCCOME  CLC   0(*-*,#1),##VECDAT(#14) If this isn't comment start\n         BNE   TRYCONT              then keep scanning\n         AH    #6,COMELEN          Bump past comment end string\n         L     #15,CCSADDR         Indicate end-of-comment found\n         BR    #3                  Return\nTRYCONT  DS    0H                  Comment ender didn't match\n         LA    #6,1(,#6)           Bump to next character\n         B     TRYLOOP             Continue scanning\nTRYCOMTE DS    0H                  Hit end of string\n         LR    #6,#7               Set offset past string end\n         L     #15,CCSADDR         Indicate comment ended at string end\n         BR    #3                  Return\n         SPACE 1\nTRYMT    DS    0H                  Subroutine to find multi-char token\n         SPACE 1\n         ST    #3,SAVEMTR\n         LR    #6,#1               Get address of character found\n         S     #6,0(,#11)          Convert to offset in string\n         LR    #0,#7               Get length of remainder of string\n         SR    #0,#6\n         XR    #14,#14             Clear register for inserts\n         L     #3,24(,#11)         Get address of token list\nMTLOOP   DS    0H\n         CR    #3,#10              When null list,\n         BE    NOTMT               no matching token\n         L     #15,##CAR(,#3)      Get element of list\n         CLI   ##TYPE(#15),##SYMBOL If it's actually a symbol\n         BNE   MTNOTSYM            then\n         L     #15,##PNAME(,#15)    get its print name\nMTNOTSYM DS    0H\n         ICM   #14,7,1(#15)        Get string length\n         BZ    MTSKIP              If zero, skip this one\n         CR    #0,#14              Compare remaining length\n         BL    MTSKIP              If less than string length, skip\n         BCTR  #14,0               Reduce string length for execute\n         EX    #14,CLCMT           Compare substring to token\n         BE    MTFOUND             If this is it, go process it\nMTSKIP   DS    0H                  Else token not found yet\n         L     #3,##CDR(,#3)       Get CDR of list\n         B     MTLOOP              and continue.\nMTFOUND  DS    0H                  We think we found a token, but...\n*\n* Check that the comment start string isn't embedded in the substring\n*\n* #7 = remaining length in substring\n* #14 = token length - 1\n* COMSLEN = length of defined comment start string if any\n* #15 -> the string that defines the token\n*\n         LH    #4,COMSLEN          Get length of comment start string\n         LTR   #0,#4               If zero\n         BZ    MTREALLY             then no comment string, this is OK\n         AR    #0,#14              Get tokenlength+comslen-1\n         CR    #7,#0               If remaining length too short to\n         BL    MTREALLY             be a comment, then this MT is OK\n         STM   #14,#2,SAVEEM       Save regs across TRT, etc.\n         LA    #0,1(#14,#1)        Get address of end of MT substr\n         BCTR  #4,0                Reduce CSS length for future EX's\nMTXLOOP  DS    0H\n         LR    #14,#0               Get length to scan\n         SR    #14,#1               If zero, no more to scan,\n         BNP   MTLMREAL              this MT must be OK\n         BCTR  #14,0                Adjust for execute\n         EX    #14,MTTRT            See if comment may begin here\n         BZ    MTLMREAL             If not, that's all\n         L     #2,16(,#11)          Get address of comment string\n         EX    #4,CLCCOM            If it matches\n         BE    MTLMSKIP             then this isn't one...\n         LA    #1,1(,#1)\n         B     MTXLOOP              then keep trying\nMTLMSKIP DS    0H                  Not the one because we found comment\n         LM    #14,#2,SAVEEM        start string, so reload registers\n         B     MTSKIP               and try the next token in list\nMTLMREAL DS    0H                  OK, we really found the token\n         LM    #14,#2,SAVEEM       (restoring regs across TRT)\nMTREALLY DS    0H                  OK, we really found the token\n         LA    #14,1(,#14)         Restore string token length\n         L     #3,SAVEMTR\n         BR    #3                  Return to caller\nNOTMT    DS    0H                  No matching token found\n         XR    #15,#15             Indicate nothing found\n         L     #3,SAVEMTR\n         BR    #3                  Return to caller\n         SPACE 1\nCLCMT    CLC   0(*-*,#1),##VECDAT(#15) Executed: compare string token\nMTTRT    TRT   0(*-*,#1),TRTCS     Executed: scan for comment start\nCLCCOM   CLC   0(*-*,#1),##VECDAT(#2) Executed: compare string comment\n         SPACE 1\nWORDPTR  DS    F                   Offset of start of word scanned\nLEN2NEXT DS    F                   Offset of next place to scan\nSAVEMTR  DS    A                   Return address\nSAVEEM   DS    5A                  Save\nCCSADDR  DS    F                   Address of start of comment string\nCOMSEND  DS    F                   Offset of last place to see c.s.s.\nCOMEEND  DS    F                   Offset of last place to see c.e.s.\nCOMSLEN  DS    H                   Length of comment start string\nCOMELEN  DS    H                   Length of comment end string\n         SPACE 1\nSTRHDR   DS    0F\n         DC    YL1(##STRING),AL3(1) Header for single-character strings\n         SPACE 1\n         LTORG\n         SPACE 1\nTRTDLM   DC    256X'00'            Table to scan for delimiters\n         SPACE 1\nTRTNDLM  DC    256X'00'            Table to scan for non-delimiters\n         SPACE 1\nTRTQUOTE DC    256X'00'            Table to scan quoted strings\n         SPACE 1\nTRTCOM   DC    256X'00'            Table to scan comment strings\n         SPACE 1\nTRTCS    DC    256X'00'            Table to scan comment strings\n         SPACE 1\nERROR1   LA    #2,1\n         LR    #7,#3\n         B     ERROR\nERROR2   LA    #2,2\n         LR    #7,#4\n         B     ERROR\nERROR3   LA    #2,3\n         LR    #7,#5\n         B     ERROR\nERROR4   LA    #2,4\n         LR    #7,#6\n         B     ERROR\nERROR5   LA    #2,5\n         B     ERROR\nERROR6   LA    #2,6\n         B     ERROR\nERROR    #ERR  'Argument ',#2,' to STRING-SCAN not a string - ',(#7)\nERROR7   #ERR  'Argument 7 to STRING-SCAN not a proper list - ',       X\n               24(#11)\nERROR4A  #ERR  'Argument 4 to STRING-SCAN longer than 2 characters - ',X\n               (#6)\nERROR4B  #ERR  'Missing end quote found by STRING-SCAN while scanning -X\n                ',0(#11)\nERROR4C  #ERR  'Dangling escape found by STRING-SCAN while scanning - 'X\n               ,0(#11)\nERROR5A  #ERR  'Argument 5 to STRING-SCAN longer than 256 characters - X\n               ',(#7)\nERROR6A  #ERR  'Argument 6 to STRING-SCAN longer than 256 characters - X\n               ',(#7)\nERROR7A  #ERR  'Non-string element found in argument 7 to STRING-SCAN -X\n                ',(#2)\nERROR7B  #ERR  'Argument 7 to STRING-SCAN contains an element longer thX\n               an 256 characters - ',(#2)\nERRORG   #ERR  PREFIX=NO,          NOT ENUF ROOM                       X\n               'ZIL4010 STRING-SCAN: Not enough vector/string space to X\n               build string.'\n         SPACE 1\nSINGTAB  DC    256D'0'             Single-character string table\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x882\\x1f\\x00\\x89\\x15o\\x11E\\x00B\\x00?\\x00A\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 66, "newlines": 63, "modlines": 65, "user": "SEB1525"}, "text": "         TITLE 'STRING - ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This is the Common Lisp STRING function (CLtL p. 304).              *\n*                                                                     *\n* (string x)                                                          *\n*                                                                     *\n* If x is a string, it is returned.                                   *\n* If x is a symbol, its print name is returned.                       *\n* If x is a string character (a fixnum between 0 and 255 in ZIL),     *\n* then a string containing that one character is returned.            *\n* In any other situation, an error is signalled.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSTRING   #ZBEG MINARGS=1,MAXARGS=1,NAME='STRING'\n         SPACE 1\n         #ZPDS 1*4+12+0\n         #ZSAV ,\n         SPACE 1\n         L     #15,0(,#11)         Load arg1\n         SPACE 1\n         CLI   ##TYPE(#15),##STRING  If arg1 is a string\n         BE    RETURN                then just return it\n         CLI   ##TYPE(#15),##SYMBOL  If arg1 is a symbol\n         BE    SYMBOL                then process symbol\n         CLI   ##TYPE(#15),##FIXNUM  If arg1 is a fixnum\n         BNE   ERROR1                then\n         L     #5,##CDR(,#15)        get numeric value\n         CL    #5,#SFW255            If not 1-byte character fixnum\n         BH    ERROR1                then error\nDUMPST   DS    0H                    else dump into 1-character string\n         LA    #2,1                Get length of string to create\n         LA    #6,##CDR+3(#15)     Get address of character to dump\n         XR    #1,#1               Entry code 0 = allocate new space\n         L     #15,ZLCVSS          Get address of ZILVSS\n         LA    #0,16(,#11)         Set current stack pointer\n         #BASR #14,#15             Call ZILVSS to build the string\n         LTR   #4,#4               If string build failed\n         BZ    ERROR2              then error\n         STC   #5,##VECDAT(,#15)   Store character into string\n         B     RETURN\n         SPACE 1\nSYMBOL   DS    0H                  Here if arg1 is a symbol\n         L     #15,##PNAME(,#15)   Get the print name\n*******  B     RETURN              and return that\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   LR    #2,#15\n         #ERR  'Argument to STRING not a string, symbol or character - X\n               ',0(#11)\n         SPACE 1\nERROR2   #ERR  'ZIL4010 STRING: Not enough vector/string space to buildX\n                string.',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRINGP": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'STRINGP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSTRINGP  #ZBEG MINARGS=1,MAXARGS=1,NAME='STRINGP'\n         SPACE 1\n         USING STRINGP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##STRING\n         BNE   ZXSTRN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXSTRN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRUCTP": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'STRUCTP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSTRUCTP  #ZBEG MINARGS=1,MAXARGS=1,NAME='STRUCTP'\n         SPACE 1\n         USING STRUCTP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##STRUCT\n         BNE   ZXNSTR\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXNSTR   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBRP": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'SUBRP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSUBRP    #ZBEG MINARGS=1,MAXARGS=1,NAME='SUBRP'\n         SPACE 1\n         USING SUBRP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##SUBR\n         BNE   ZXSUBRN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXSUBRN  LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUBSTR": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00n\\x00k\\x00m\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 110, "newlines": 107, "modlines": 109, "user": "SEB1525"}, "text": "         TITLE 'SUBSTR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (SUBSTR ARG1 ARG2 &OPTIONAL ARG3)...                                *\n*                                                                     *\n*  ARG1 IS A STRING                                                   *\n*  ARG2 IS A FIXNUM OR NIL   - THE 1-BASED STARTING INDEX             *\n*  ARG3 IS A FIXNUM OR NIL   - THE LENGTH                             *\n*                                                                     *\n* IF ARG2 IS NEGATIVE, START AT -ARG2 FROM THE END OF THE STRING.     *\n*                                                                     *\n* ANY OUT-OF-BOUNDS ARGS RESULT IN A NULL STRING.                     *\n*                                                                     *\n* ARG2 MAY BE NIL (RESULTING IN A NULL STRING).  THIS FACILITATES     *\n* THE USE OF SUBSTR IN CONJUNCTION WITH POSITIONING STRING FUNCTIONS  *\n* (LIKE INDEX) WHICH MAY RETURN EITHER A FIXNUM OR NIL.               *\n*                                                                     *\n***********************************************************************\nSUBSTR   #ZBEG MINARGS=1,MAXARGS=3,NAME='STRING-SUBSTR'\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ARGS=3              SAVE REGISTERS\n         SPACE\n         LM    #5,#7,0(#11)        LOAD ARGS\n         CLI   ##TYPE(#5),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#5),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #5,##PNAME(,#5)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         XR    #4,#4\n         ST    #5,0(,#11)          STORE BACK ON STACK FOR LATER USE\n         CR    #6,#13              IF ARG 2 IS NOT SUPPLIED\n         BE    RETNULL             THEN IT'S OK, RETURN NULL STRING\n         CR    #6,#10              IF ARG 2 IS NIL\n         BE    RETNULL             THEN IT'S OK, RETURN NULL STRING\n         CLI   ##TYPE(#6),##FIXNUM IF ARG 2 IS NOT A FIXNUM\n         BNE   ERROR2              THEN ERROR\n         CR    #7,#13              IF ARG 3 IS NOT SUPPLIED\n         BE    ARGSOK              THEN IT'S OK (OMITTED)\n         CR    #7,#10              IF ARG 3 IS NIL\n         BE    ARGSOK              THEN IT'S OK (OMITTED)\n         CLI   ##TYPE(#7),##FIXNUM IF ARG 3 IS NOT A FIXNUM\n         BNE   ERROR3              THEN ERROR\nARGSOK   DS    0H\n         ICM   #4,7,1(#5)          GET LENGTH OF STRING\n         ICM   #6,15,##CDR(#6)     GET FIXNUM VALUE\n         BZ    RETNULL             IF ZERO, RETURN NULL STRING\n         BP    NORMSUB             IF POSITIVE, NORMAL SUBSTRING\n         AR    #6,#4               IF NEGATIVE, TAKE LENGTH MINUS ABS\n         BM    RETNULL             (IF ABS GT LENGTH, RETURN NULL)\n         LA    #6,1(,#6)           AND ADJUST TO MAKE IT CORRECT...\nNORMSUB  DS    0H\n         CR    #6,#4               IF VALUE GT STRING LENGTH\n         BH    RETNULL             THEN RETURN NULL STRING\n         BCTR  #6,0                CONVERT FROM 1-BASED TO 0-BASED\n         LR    #3,#4               GET LENGTH OF STRING\n         SR    #3,#6               MINUS STARTING = MAX SUBSTR LENGTH\n         CR    #7,#13              IF ARG 3 IS NOT SUPPLIED\n         BNE   ARG3SUP             THEN\n         LR    #7,#3                TAKE MAX SUBSTR LENGTH\n         B     GOTLEN3             ELSE\nARG3SUP  CR    #7,#10              IF ARG 3 IS NIL\n         BNE   ARG3NNIL            THEN...\n         LR    #7,#3                TAKE MAX SUBSTR LENGTH\n         B     GOTLEN3\nARG3NNIL DS    0H                  ELSE ARG 3 SUPPLIED...\n         ICM   #7,15,##CDR(#7)     GET FIXNUM VALUE\n         BM    RETNULL             IF NEGATIVE, RETURN NULL STRING\nGOTLEN3  DS    0H                  NOW #7 = LENGTH OF STRING TO EXTRACT\n         CR    #7,#3               IF REQUESTED LENGTH EXCEEDS MAX\n         BNH   *+6                  THEN...\n         LR    #7,#3                 SET IT TO MAX\n         LR    #2,#7               GET IT INTO REG FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,24(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #4,#15              IF STRING BUILD FAILED\n         BZ    ERROR4              THEN ERROR\n         L     #1,0(,#11)          GET POINTER TO ORIGINAL STRING\n         LA    #0,##VECDAT(#6,#1)  POINT TO STRING TEXT + START OFFSET\n         LA    #14,##VECDAT(,#4)   POINT TO WHERE TO MOVE STRING TEXT\n         LR    #1,#7               GET LENGTH OF STRING TEXT TO MOVE\n         LR    #15,#7              DESTINATION LENGTH SAME\n         MVCL  #14,#0              MOVE TEXT FROM OLD STRING TO NEW\n         LR    #15,#4              POINT TO NEWLY BUILT STRING\n         B     RETURN              RETURN THE ATOM IN #15\n         SPACE 1\nRETNULL  DS    0H                  SUBSCRIPT OUT OF BOUNDS\n         LA    #15,NULLSTR         RETURN NULL STRING\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nNULLSTR  DS    0A                  ALIGN NULL STRING TO FULLWORD\n         DC    YL1(##STRING),AL3(0),XL4'00'  STRING \"\"\n         SPACE 1\nERROR1   #ERR  'Argument 1 to STRING-SUBSTR not a string - ',0(#11)\nERROR2   #ERR  'Argument 2 to STRING-SUBSTR not a fixnum - ',4(#11)\nERROR3   #ERR  'Argument 3 to STRING-SUBSTR not a fixnum - ',8(#11)\nERROR4   #ERR  'ZIL4010 STRING-SUBSTR: Not enough vector/string space tX\n               o build string.',PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUB1": {"ttr": 5903, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00k\\x00h\\x00j\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 107, "newlines": 104, "modlines": 106, "user": "SEB1525"}, "text": "         TITLE 'SUB1 - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SUB1 TAKES ONE ARGUMENT - A NUMERIC ATOM                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nSUB1     #ZBEG MINARGS=1,MAXARGS=1,NAME='SUB1',SUBRS=ZILSUBR\n         SPACE\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #1,0(,#11)          LOAD FIRST (AND ONLY) ARGUMENT\n         CLI   ##TYPE(#1),##FIXNUM SEE IF FIXNUM\n         BNE   NOTFIX              IF NOT FIXNUM, GO SOMEWHERE ELSE\n         L     #2,##CDR(,#1)       Get value of fixnum\n         CL    #2,ZLCSFTHI         If within small fixnum table range\n         BNH   SMALLFIX            then go to decrement small fixnum\n         S     #2,#SFW1            ELSE SUBTRACT 1 FROM FIXNUM\n         BO    OVERFLOW            IF OVERFLOW, MUST BE -2**31\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A NEW FIXNUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nSMALLFIX DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Fixnum between lowest and highest small fixnum from table           *\n* (inclusive).  We load the address of the next lower fixnum          *\n* from the table.                                                     *\n*                                                                     *\n* Note that if the value is zero, bumping back in the table will get  *\n* us -1, which was put there for this purpose (among others), even    *\n* though -1 is strictly not part of the small fixnum table.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SLA   #2,3                Multiply fixval by 8 for an index\n         LA    #15,#SFT-8(#2)      Get address of (fixval-1)th fixnum\n******** B     RETURN               from table and return with it\n         SPACE 1\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nNOTFIX   DS    0H                  IF NOT FIXNUM, MUST BE...\n         CLI   ##TYPE(#1),##SFLOAT  SINGLE-FLOAT\n         BE    SUB1SFLO              OR\n         CLI   ##TYPE(#1),##DFLOAT  DOUBLE-FLOAT\n         BE    SUB1DFLO              OR\n         CLI   ##TYPE(#1),##BIGNUM    BIGNUM\n         BE    SUB1BIG                 ELSE\n         B     ERROR1                   ERROR\n         SPACE\nSUB1SFLO DS    0H                  SINGLE FLOAT\n         SPACE\n         LE    #F0,##CDR(,#1)      LOAD FLOAT VALUE\n         SE    #F0,=E'1'           SUBTRACT 1\n         STE   #F0,ZLCWORK         PUT RESULT IN ATOM-MAKING REGISTER\n         L     #2,ZLCWORK\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE\nSUB1DFLO DS    0H                  DOUBLE FLOAT\n         SPACE\n         LD    #F0,8(,#1)          LOAD FLOAT VALUE\n         SD    #F0,=D'1'           SUBTRACT 1\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE A DOUBLE FLOAT\n         B     RETURN              AND RETURN WITH IT\n         SPACE\nOVERFLOW DS    0H                  FIXED-POINT OVERFLOW OCCURRED\n         SPACE\n         LA    #15,MNFM1           GET MOST NEGATIVE FIXNUM MINUS 1\n         B     RETURN              AND RETURN WITH IT\n         SPACE\nSUB1BIG  DS    0H                  ARG IS A BIGNUM\n         SPACE\n         LA    #2,#SFTM1           GET ADDRESS OF FIXNUM -1\n         L     #15,@ZILADD         GET ADDRESS OF ZILADD\n         LR    #1,#11              RESTORE STACK POINTER\n         LM    #11,#12,4(#1)       RESTORE REGS AS IF RETURNING\n         L     #14,12(,#1)\n         ST    #2,4(,#1)           SET ARG 2 TO ZILADD\n         BR    #15                 GO TO ZILADD TO ADD -1 TO BIGNUM\n         SPACE\n         DS    0A                  ALIGN BIGNUM TO FULLWORD\nMNFM1    DC    YL1(##BIGNUM),AL3(8),F'-2147483647,1' BIGNUM -2147483649\n         SPACE 1\nZILSUBRS DS    0A\n@ZILADD  DC    V(ZILADD)           ADDRESS OF SUBROUTINE\n         DC    CL8'ZILADD'\nZILSUBRE EQU   *\n         SPACE 1\nERROR1   DS    0H                  NOT A NUMERIC ATOM\n         #ERR  'Argument to SUB1 not a number - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYMBOLP": {"ttr": 5906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'SYMBOLP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSYMBOLP  #ZBEG MINARGS=1,MAXARGS=1,NAME='SYMBOLP'\n         SPACE 1\n         USING SYMBOLP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##SYMBOL\n         BNE   ZXSYMN\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXSYMN   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TABS": {"ttr": 5908, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00&\\x00#\\x00%\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 38, "newlines": 35, "modlines": 37, "user": "SEB1525"}, "text": "         TITLE 'TABS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION SETS TABS MODE ON OR OFF FOR AN OUTPUT FILE.          *\n* THIS CONTROLS WHETHER TABS, NEWLINES AND CARRIAGE RETURNS ARE TO    *\n* BE PROCESSED FOR A FILE OR OUTPUT AS HEX CHARACTERS.                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TABS TAKES TWO ARGUMENTS:    ARGUMENT 1 = T OR NIL                  *\n*                              ARGUMENT 2 = OUTPUT FILE SPEC (OPT.)   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTABS     #ZBEG MINARGS=1,MAXARGS=2,NAME='TABS'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         #OFIL 2                   ARG 2 = OUTPUT FILE SPEC\n         SPACE 1\n         L     #15,0(,#11)         GET ARG 1\n         CR    #15,#10             IF ARG 1 IS NIL\n         BNE   NOTNIL              THEN\n         NI    ZLFFLAG2,255-ZLFTABS SET TABS MODE OFF\n         B     AFTNIL              ELSE\nNOTNIL   OI    ZLFFLAG2,ZLFTABS     SET TABS MODE ON\nAFTNIL   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "THROW": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00\\x1b\\x00\\r\\x00\\x1a\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 27, "newlines": 13, "modlines": 26, "user": "SEB1525"}, "text": "         TITLE 'THROW - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* THIS IS A KLUDGEY INTERFACE TO THE ZILTHROW ROUTINE, PENDING        *\n* DIRECT SUPPORT IN THE COMPILER FOR THROW.                           *\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n* This routine is actually obsolete, and does not belong in ZIL,      *\n* since THROW is a special form.  However, it is kept around for      *\n* compatibility - more accurately, to permit the relinking of code    *\n* that was compiled by ZIL when THROW was a function.  THROW was      *\n* changed to a special form because of multiple values.               *\n*                                                                     *\n***********************************************************************\n*\nTHROW    #ZBEG MINARGS=2,MAXARGS=2,NAME='THROW'\n         LM    #1,#2,0(#1)         LOAD ARGUMENTS FROM STACK.\n         L     #15,ZLCTHROW        GET ADDRESS OF ZILTHROW ROUTINE.\n         BR    #15                 GO TO ZILTHROW.\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TOSTRING": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11E\\x00\\x7f\\x00|\\x00~\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:45:00", "lines": 127, "newlines": 124, "modlines": 126, "user": "SEB1525"}, "text": "         TITLE 'TOSTRING - ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A STRING FROM ANY (VALID) LISP OBJECT.        *\n*                                                                     *\n* IT TAKES ONE REQUIRED ARGUMENT AND ONE OPTIONAL ARGUMENT.           *\n*                                                                     *\n* ARG1: THE OBJECT TO MAKE A STRING OUT OF (NOT A LIST OR VECTOR).    *\n* ARG2: NIL = DON'T SLASHIFY, T = SLASHIFY.                           *\n*                                                                     *\n* NOTE: IF THE ARGUMENT IS ALREADY A STRING IT JUST RETURNS THE       *\n*       SAME STRING.  THIS IS MAKE-STRING, NOT COPY-STRING.           *\n*       IF THE ARGUMENT IS A SYMBOL, THE PRINT NAME IS RETURNED.      *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note: This used to be called MKSTRING (and even MAKE-STRING),       *\n*        but the name was changed to avoid conflict with the          *\n*       Common Lisp function MAKE-STRING.                             *\n*       Common Lisp MAKE-STRING has the following syntax:             *\n*                                                                     *\n*       (make-string <size> &key :initial-element)                    *\n*                                                                     *\n* Thus, TOSTRING cannot be used to implement MAKE-STRING.             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTOSTRING #ZBEG MINARGS=1,MAXARGS=2,NAME='TOSTRING'\n         SPACE 1\n         #ZPDS 2*4+12+0\n         #ZSAV ,\n         SPACE 1\n         LM    #15,#0,0(#11)       LOAD ARG1 AND ARG2\n         SPACE 1\n         CR    #0,#13              IF ARG2 NOT SUPPLIED\n         BE    QUICKCK              OR\n         CR    #0,#10                ARG2 = NIL (NO SLASHIFICATION)\n         BNE   DUMPST               THEN...\nQUICKCK  CLI   ##TYPE(#15),##STRING  IF ARG1 IS ALREADY A STRING\n         BE    RETURN                THEN JUST RETURN IT. ELSE...\n         CLI   ##TYPE(#15),##SYMBOL  IF ARG1 IS A SYMBOL\n         BNE   SETARG2               THEN...\n         L     #15,##PNAME(,#15)      GET THE PRINT NAME\n         B     RETURN                 AND RETURN THAT\n         SPACE 1\nSETARG2  DS    0H\n         LR    #0,#10              SET ARG 2 TO NIL\n         SPACE 1\nDUMPST   DS    0H\n*\n* MAKE SURE THE OBJECT IS A TYPE THAT ZILADMP CAN HANDLE.\n* WE DON'T WANT TO GET AN ERROR MESSAGE FROM ZILADMP, DO WE?\n*\n         TM    ##TYPE(#15),##ATOM  IF THIS IS A LIST,\n         BZ    MAYBJUNK            THEN CHECK FOR ZILUNBND, ETC.\n         TM    ##TYPE(#15),##VEC   IF THIS IS A VECTOR-TYPE OBJECT\n         BO    ERROR1              (VECTOR, FUNARG OR STRUCTURE), ERROR\n*\n* INVOKE ZILADMP TO GET THE \"FLAT\" REPRESENTATION OF THE ARGUMENT.\n*\n         LR    #1,#0               SET #1 FOR ZILADMP FROM ARG2\n         LR    #2,#15              GET THE ATOM TO BE DUMPED\n         L     #15,ZLCADMP         GET ADDRESS OF ATOM DUMPING ROUTINE\n         OI    ZLCDFLGS,ZLCDCOPY   SET ALWAYS-COPY BIT ON\n         #BASR #14,#15             CALL ZILADMP\n         LR    #5,#0               GET LENGTH OF DUMPED DATA\n         LR    #6,#1               GET ADDRESS OF DUMPED DATA\n         LR    #2,#5               SET LENGTH OF OBJECT TO CREATE\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF STRING SPACE SERVICE\n         LA    #0,20(,#11)         SET CURRENT STACK LOCATION\n         #BASR #14,#15             CALL ZILVSS TO BUILD THE OBJECT\n         LTR   #4,#4               IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         LR    #7,#5               LENGTH OF DUMPED DATA\n         MVCL  #4,#6               MOVE DUMPED DATA INTO STRING DATA\n         SPACE 1\nRETURN   DS    0H                  #15 POINTS TO STRING BUILT\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nMAYBJUNK DS    0H\n         SPACE 1\n         CR    #15,#13             If equal to #13\n         BE    ISUOA               then it's unsupplied optional arg\n         C     #15,ZLCUNBND        If equal to the unbound object\n         BE    ISUNB               then it's the unbound object\n         C     #15,ZLCRMNIL        If equal to RMNIL\n         BE    ISRMN               then it's RMNIL\n         B     ERROR1              Else error\n         SPACE 1\nISUOA    DS    0H                  Unsupplied optional argument\n         LA    #15,$UOA\n         B     RETURN\nISUNB    DS    0H                  The unbound object\n         LA    #15,$UNBOUND\n         B     RETURN\nISRMN    DS    0H                  RMNIL\n         LA    #15,$RMNIL\n         B     RETURN\n         SPACE 1\nERROR1   LR    #2,#15\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2122 TOSTRING: Cannot convert argument to string - 'X\n               ,                                                       X\n               (#2),                                                   X\n               X'0D',              carriage return                     X\n               '(it''s a list, vector, funarg, or structure).'\n         SPACE 1\nERROR2   #ERR  'ZIL4010 TOSTRING: Not enough vector/string space to buiX\n               ld string.',PREFIX=NO\n         SPACE 1\n         DS    0A\n$UOA     #SATM '#<UNSUPPLIED OPTIONAL ARGUMENT>'\n         DS    0A\n$UNBOUND #SATM '#<UNBOUND>'\n         DS    0A\n$RMNIL   #SATM '#<RMNIL>'\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSO": {"ttr": 6150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\"\\x00\\x88\\x02\\x7f\\x01\\x00&_\\x16A\\x06\\xcc\\x05\\xe8\\x06\\xcc\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1988-01-27T00:00:00", "modifydate": "2000-09-21T16:41:22", "lines": 1740, "newlines": 1512, "modlines": 1740, "user": "SEB1525"}, "text": "***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    INSYS\n&NAME    OI    ZLCIFLGS,ZLCISYS    Indicate non-ZIL code running\n         MEND\n         MACRO\n&NAME    OUTSYS\n&NAME    NI    ZLCIFLGS,255-ZLCISYS Indicate non-ZIL code running\n         TM    ZLCIFLGS,ZLCIATTN    If attention interrupt occurred\n         BOR   #13                  then go to handle it\n         MEND\n         TITLE 'TSO - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n* TSO TAKES AN &REST ARG - LIST OF ATOMS TO BE CONCATENATED INTO A    *\n* SINGLE CHARACTER STRING, WHICH IS THEN EXECUTED AS A TSO COMMAND.   *\n*  SPECIFICATION OF AN ATOM OR OF A LIST CONTAINING NESTED LISTS IS   *\n*  ERRONEOUS AND WILL BE FLAGGED AS AN ERROR.                         *\n*                                                                     *\n* TSO RETURNS A FIXNUM CONTAINING THE RETURN CODE AS RETURNED BY      *\n* THE TSO COMMAND INVOKED.                                            *\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO EXTRA STACK SPACE.        *\n***********************************************************************\n*                                                                     *\n* ZILADMP IS CALLED TO DUMP EACH ATOM IN THE LIST INTO OUR WORK AREA. *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* 01/27/88 - CHANGED TO INVOKE TSO COMMAND ITSELF RATHER THAN USING   *\n*            THE DRAPER \"XCLIST\" UTILITY.                             *\n*                                                                     *\n* 05/02/89 - TSO/E Version 2 support.                                 *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA,&ZILTSO\n         #ZSYS ,\n         SPACE\nTSO      #ZBEG MINARGS=0,MAXARGS=0,RESTARG=T,NAME='TSO'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          GET &REST ARGUMENT\n         LA    #5,4                INIT LENGTH REQUIRED SO FAR TO 4\n*                                  (for command buffer prefix)\nLOOP     DS    0H\n         CR    #6,#10              IF END OF LIST OR NULL LIST\n         BE    NOMORE              THEN END LOOP\n         L     #2,##CAR(,#6)       GET ATOM (ARG 1 TO TSO)\n         TM    ##TYPE(#2),##ATOM   IF IT'S NOT AN ATOM\n         BZ    BADLIST             THEN ERROR\n         TM    ##TYPE(#2),##VEC    IF IT'S SOME KIND OF VECTOR\n         BO    BADLIST             THEN ERROR\n         L     #15,ZLCADMP         GET ADDRESS OF ZILADMP\n         LR    #1,#10              SET #1 FOR ZILADMP\n         #BASR #14,#15             CALL ZILADMP TO DUMP ATOM\n         LR    #7,#1               SAVE ADDRESS OF DUMPED ATOM\n         LTR   #4,#0               GET LENGTH OF DUMPED ATOM\n         BNP   AFTMOVE             IF ZERO LENGTH, SKIP THIS ONE\n         AR    #0,#5               GET DUMPED-ATOM LENGTH PLUS TOTAL\n         C     #0,ZLCWALEN         IF EXCEEDS CURRENT WORKAREA LENGTH\n         BNH   LENOK               THEN...\n*\n* (1) GETMAIN A NEW WORKAREA WHOSE SIZE IS >= #0.\n* (2) COPY CONTENTS OF OLD WORKAREA TO THE NEW WORKAREA, LENGTH = #5.\n* (3) FREEMAIN THE OLD WORKAREA.\n*\n* #0 = TOTAL LENGTH NEEDED SO FAR, INCLUDING DUMPED-BUT-NOT-ADDED-YET\n* #1 = NOT IN USE\n* #2 = NOT IN USE, WILL CONTAIN NEW WORK AREA LENGTH\n* #3 = NOT IN USE, WILL CONTAIN NEW WORK AREA ADDRESS\n* #4 = LENGTH OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON\n* #5 = TOTAL LENGTH DUMPED SO FAR, NOT INCLUDING THIS STUFF\n* #6 = ADDRESS OF THE SUBLIST CURRENTLY BEING PROCESSED\n* #7 = ADDRESS OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON\n*\n         LR    #2,#0                SAVE LENGTH TO BE NEEDED\n         LA    #2,7(,#2)            GET A LARGER WORK AREA\n         N     #2,=X'FFFFFFF8'      ROUNDED UP TO MULTIPLE OF 8\n         LR    #0,#2                SAVE THE NEW WORK AREA LENGTH\n         #GETMAIN RC,LV=(0),LOC=BELOW GET A NEW WORK AREA\n         LTR   #15,#15              IF GETMAIN FAILED\n         BNZ   ERROR3               THEN ERROR - NOT ENOUGH STORAGE\n         LR    #3,#1                SAVE NEW WORKAREA ADDRESS\n         ICM   #14,15,ZLCWA         #14 = ADDRESS OF OLD AREA\n         BZ    NOFREE               IF NONE, THEN SKIP MOVE & FREE\n         LR    #0,#3                #0 = ADDRESS OF NEW AREA\n         LR    #1,#5                #1 = LENGTH OF DUMPED TEXT\n         LR    #15,#5               #15 = LENGTH OF DUMPED TEXT\n         MVCL  #0,#14               COPY DATA FROM OLD AREA TO NEW AREA\n         L     #1,ZLCWA             GET CURRENT WORK AREA ADDRESS\n         L     #0,ZLCWALEN          GET CURRENT WORK AREA LENGTH\n         FREEMAIN R,LV=(0),A=(1)    FREE THE OLD WORK AREA\nNOFREE   DS    0H\n         ST    #3,ZLCWA             SET NEW ZIL WORKAREA ADDRESS\n         ST    #2,ZLCWALEN          SET NEW ZIL WORKAREA LENGTH\n         SPACE 1\nLENOK    DS    0H                  OTHERWISE - STILL ROOM\n         L     #0,ZLCWA            WORKAREA ADDRESS + WORK AREA LENGTH\n         AR    #0,#5               POINTS TO WHERE TO MOVE DUMPED ATOM\n         LR    #1,#4               SOURCE LENGTH = DUMPED ATOM LENGTH\n         LR    #15,#4              TARGET LENGTH = DUMPED ATOM LENGTH\n         LR    #14,#7              SOURCE ADDRESS = WHERE DUMPED ATOM\n         MVCL  #0,#14              MOVE DUMPED ATOM TO WORK AREA\n         AR    #5,#4               INCREMENT TOTAL LENGTH SO FAR\nAFTMOVE  DS    0H\n         L     #6,##CDR(,#6)       GET REST OF LIST\n         B     LOOP                CONTINUE.\nNOMORE   DS    0H                  LIST HAS BEEN PROCESSED\n*\n* CHECK THAT THE ARGUMENT IS NOT LONGER THAN 32K.\n*\n         L     #1,ZLCWA            GET ADDRESS OF COMMAND WORK AREA\n         CH    #5,=H'32767'        IF BUFFER LENGTH TOO LONG FOR TSO\n         BH    TOOLONG             THEN ERROR\n         SPACE\n* To solve problem of single % picking up residual byte afterwards,\n* we blank the byte following the end of the active buffer.\n         SPACE\n         C     #5,ZLCWALEN         Do only if active length is less\n         BNL   NONONONO             than length of buffer.\n         LA    #15,0(#5,#1)        Point to end of buffer\n         MVI   0(#15),C' '         Blank it out to fix \"%\" problem\nNONONONO DS    0H\n         SPACE\n         SLL   #5,16               ELSE SHIFT INTO LEFT HALF OF WORD\n         ST    #5,0(,#1)           STORE COMMAND BUFFER PREFIX\n         LR    #5,#1               Load command buffer pointer\n         SPACE\n         LA    #3,4095(,#12)       Set up second base register\n         USING TSO+4095,#3\n         SPACE\n***********************************************************************\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n*   #3  -->  SECOND BASE REGISTER                                     *\n*   #4  -->  ECT (ENVIRONMENT CONTROL TABLE)                          *\n*   #5  -->  CBUF (COMMAND BUFFER)                                    *\n*   #6  -->  (AVAILABLE)                                              *\n*   #7  -->  ADDRESS OF OUR INPUT STACK                               *\n*                                                                     *\n* NOTE: REGISTER USAGE IN EXIT ROUTINES MAY DEVIATE FROM THE ABOVE.   *\n*                                                                     *\n***********************************************************************\n*\n* BUILD CPPL FROM SYSTEM CONTROL BLOCKS\n*\n         USING PSA,0\n         L     #15,PSATOLD          GET TCB ADDRESS\n         USING TCB,#15\n         L     #15,TCBJSCB          GET JSCB ADDRESS\n         USING IEZJSCB,#15\n         L     #15,JSCBACT          GET ADDRESS OF ACTIVE JSCB\n         L     #15,JSCBPSCB         GET ADDRESS OF PSCB\n         LTR   #15,#15             IF THERE'S NO PSCB\n         BZ    NOTSO               THEN TSO NOT ACTIVE\n         ST    #15,CPPLPSCB         SAVE PSCB ADDRESS\n         USING PSCB,#15\n         MVC   CPPLUPT,PSCBUPT      SAVE UPT ADDRESS\n         L     #15,PSCBRLGB         GET ADDRESS OF RELOGON BUFFER\n         USING RLGB,#15\n         L     #4,RLGBECT           GET ADDRESS OF ECT\n         ST    #4,CPPLECT          ADDRESS ENVIRONMENT CONTROL TABLE\n         USING ECT,#4\n         SPACE 2\n*\n* Locate the LWA (logon work area) to find the addresses of the TSO\n* tables that define which TSO commands can be accessed and how.\n*\n         XR    #0,#0               Clear the list of...\n         ST    #0,ZTE2ADDR          TSO commands that run authorized\n         L     #15,PSAAOLD         Get ASCB address\n         USING ASCB,#15\n         L     #15,ASCBASXB        Get ASXB address\n         USING ASXB,#15\n         ICM   #2,15,ASXBLWA       Get LWA address\n         BZ    NOTTSOE             If none, probably not TSO/E\n         USING LWA,#2\n         ICM   #15,15,LWAPECT      Get LWA's ECT address\n         BZ    NOTTSOE             If none, probably not TSO/E\n         C     #15,CPPLECT         Check that ECT addresses match\n         BE    ECTSOK\n         #ERR  2,                                                      X\n               'The ECT addresses in the LWA (logon work area) and the X\n               RLGB (relogon buffer) do not match.  TSO is using the ECX\n               T address from the RLGB.'\nECTSOK   DS    0H\n         L     #15,LWATE2          Get address of IKJEFTE2\n         ST    #15,ZTE2ADDR        (TSO commands that run authorized)\nNOTTSOE  DS    0H\n         EJECT\n***********************************************************************\n* INITIALIZE WORK AREAS                                               *\n***********************************************************************\n         SPACE\n         L     #14,CPPLUPT\n         L     #15,CPPLECT\n         LA    #0,ZTECB\n         STM   #14,#0,IOPLUPT      SET UP IKJPUTL PARAMETER LIST\n         LA    #1,ZTCSFLG\n         LA    #2,CSOA\n         STM   #14,#2,CSPL         SET UP IKJSCAN PARAMETER LIST\n         L     #1,CPPLPSCB\n         LA    #2,DAPB2C\n         STM   #14,#2,DAPLUPT      SET UP IKJDAIR PARAMETER LIST\n         LA    #0,X'2C'            DAIR ENTRY CODE TO MARK NOT IN USE\n         SLL   #0,16               SHIFT INTO LEFT HALF FOR DAIR CB\n         STCM  #0,15,DA2CCD        AND PUT ZEROES INTO FLAG FIELD\n         MVI   DA2CDDN,C' '        CLEAR DDNAME TO BLANKS\n         MVC   DA2CDDN+1(7),DA2CDDN\n         MVC   ZTBLDL(4),=Y(1,12)  INITIALIZE BLDL LIST FOR CMDCHK\n         LA    #0,1\n         LA    #1,ZTMSGHDR\n         XR    #2,#2\n         STM   #0,#2,ZTMSGOLD      INITIALIZE PUTLINE WORK AREA\n         LA    #1,ZTPGHDR\n         STM   #0,#1,ZTPGOLD       INITIALIZE PUTGET MODE MSG AREA\n         LA    #1,ZTPGOLD\n         ST    #1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK\n         LA    #1,ZTMSGOLD\n         ST    #1,PTPBOPUT         STORE ADDR OF O.L.D. IN PARM BLOCK\n         LA    #0,ZTCMDECB\n         LA    #1,ZTATNECB\n         STM   #0,#1,ZTECBLST      INITIALIZE ECB LIST\n         OI    ZTECBLST+4,X'80'\n*** NOTE: #2 CONTAINS ZEROES FROM ABOVE INSTRUCTIONS.\n         ST    #2,DA2CTCB          TCB ADDRESS TO MARK DSE'S NOT IN USE\n         ST    #2,ZTRETCD          INITIALIZE RETURN CODE TO ZERO\n         MVI   ZTCSFLG,0           PREPARE TO SYNTAX CHECK COMMAND\n         MVI   ZTSTATUS,ZTNORMAL   Initialize command status\n         L     #2,ECTIOWA          GET ADDRESS OF ORIGINAL INPUT STACK\n         ST    #2,ZTSVIOA          SAVE INPUT STACK IN OUR WORK AREA\n         MVC   ZTCMDS,ECTPCMD      SAVE ORIGINAL PRIMARY & SUBCOMMAND\n*\n* Use LINKLIST DCB with BLDL to find system stuff only\n* (not stuff in a task library)\n*\n         L     #15,16              Get CVT address\n         L     #0,CVTLINK-CVT(,#15) Get address of LINKLIST DCB\n         ST    #0,LINKDCB          Save it\n         SPACE 2\n***********************************************************************\n* SET UP ESTAE (ABEND) AND STAX (ATTENTION) EXIT ROUTINES.            *\n***********************************************************************\n         SPACE\n         LA    #14,STAEEXIT\n         ESTAE (#14),PARAM=(#12),MF=(E,ZTESTAE)\n         LTR   #15,#15             IF ESTAE FAILED,\n         BZ    ESTAEOK             THEN\n         LA    #1,=C'ESTAE'         BLOW UP\n         LA    #0,5\n         B     ERROR\nESTAEOK  OI    ZTFLAGS,ZTESTON     ELSE INDICATE ESTAE IS ACTIVE\n         SPACE\n         L     #14,=A(STAXEXIT)\n         STAX  (#14),USADDR=(#12),REPLACE=NO,MF=(E,ZTSTAX)\n         CH    #15,=H'4'           IF STAX FAILED,\n         BNH   STAXOK              THEN\n         LA    #1,=C'STAX'          BLOW UP\n         LA    #0,4\n         B     ERROR\nSTAXOK   OI    ZTFLAGS,ZTSTXON     ELSE INDICATE STAX IS ACTIVE\n         EJECT\n***********************************************************************\n* Determine which version of TSO/Extensions is active.                *\n* Reference: TSO/Extensions Version 2 Programming Services (SC28-1875 *\n*            Chapter 2. Considerations for Using TSO/E Services       *\n*            Determining the Version and Release of TSO/E Installed   *\n***********************************************************************\n         SPACE 1\n         MVI   ZTTSOE,C'0'         Initialize TSO/E version to (none)\n         L     #15,X'10'           Get address of CVT\n         L     #15,CVTTVT-CVT(,#15) Get address of TSVT\n         LTR   #15,#15             If there is none,\n         BZ    TSOEV0              then don't change it\n         USING TSVT,#15            Else set it...\n         MVC   ZTTSOE,TSVTLVER     C'1' = version 1, C'2' = version 2\n         SPACE 1\nTSOEV0   DS    0H\n         SPACE 1\n***********************************************************************\n* PREPARE TO INVOKE COMMANDS BY SAVING THE CURRENT INPUT STACK AND    *\n* INITIALIZING IT TO A TERMINAL ELEMENT (A LA ISPF).                  *\n***********************************************************************\n         SPACE\n         CLI   ZTTSOE,C'2'         If TSO/E Version 2 or later,\n         BNL   INITSTK2            then do it the TSO/E Version 2 way\n*                                  else do it the TSO/E Version 1 way\n         OI    ZTFLAGS,ZTSTKMOD    INDICATE INPUT STACK ADDR ALTERED\n         XR    #0,#0               MAKE A ZERO\n         ST    #0,ECTIOWA          CLEAR INPUT STACK ADDRESS\n         ST    #0,ZTECB            CLEAR ECB FOR STACK\n*\n* SET UP A TERMINAL ELEMENT AS THE BOTTOM ELEMENT OF NEW INPUT STACK\n*\n         INSYS\n         STACK PARM=STKINIT,MF=(E,IOPL)\n         OUTSYS\n         LTR   #15,#15             IF STACK FAILED,\n         BZ    STACKOK             THEN...\n         L     #2,ZTSVIOA           GET SAVED INPUT STACK ADDRESS\n         ST    #2,ECTIOWA           RESTORE ORIGINAL INPUT STACK\n         NI    ZTFLAGS,255-ZTSTKMOD INDICATE INPUT STACK ADDR RESTORED\n         LA    #1,=C'STACK DATASET=*' BLOW UP\n         LA    #0,15\n         B     ERROR\n         SPACE\nSTACKOK  DS    0H\n         SPACE\n***********************************************************************\n* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA TSO FUNCTION IN THE    *\n* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *\n* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *\n* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *\n* NOTE THAT WE CAN'T DO THIS \"LEGALLY\" BY USING THE STACK MACRO TO    *\n* SET UP SYSTSPRT AS THE BOTTOM ELEMENT, SINCE THAT WOULD CAUSE IT    *\n* TO BE REOPENED FOR OUTPUT AND PREVIOUS TSO OUTPUT WOULD BE LOST.    *\n***********************************************************************\n         SPACE\n         L     #2,ZTSVIOA          Get address of original input stack\n         L     #7,ECTIOWA          GET ADDRESS OF OUR NEW INPUT STACK\n         L     #14,4(,#7)          GET ADDRESS OF OUR BOTTOM ELEMENT\n         L     #15,4(,#2)          GET ADDRESS OF THEIR BOTTOM ELEMENT\n         MVC   0(4,#14),0(#15)     MOVE THEIR ELEMENT TO OUR ELEMENT\n         B     AINITSTK            Else...\n         SPACE 1\nINITSTK2 DS    0H                  Set input stack for TSO/E Version 2\n*\n***********************************************************************\n* Make a new input stack by issuing STACK ENVIRON=CREATE, which makes *\n* a new ECT and a new IOWA.  We don't use the new ECT, but we do use  *\n* the new IOWA, altering the current ECT to point to it.              *\n***********************************************************************\n*\n         XC    ZTECB,ZTECB         Clear ECB\n         INSYS\n         STACK PARM=STKECREA,MF=(E,IOPL) Stack ENVIRON=CREATE\n         OUTSYS\n         LTR   #15,#15             If STACK failed,\n         BZ    ENVCREOK            then blow up\n         LA    #1,=C'STACK ENVIRON=CREATE'\n         LA    #0,20\n         B     ERROR\nENVCREOK DS    0H                  STACK created new ECT...\n*\n***********************************************************************\n* IN ORDER TO INSURE THAT COMMANDS INVOKED VIA XCLIST FUNCTION IN THE *\n* BACKGROUND, WE CAUSE OUR STACK TO HAVE THE SAME BOTTOM ELEMENT AS   *\n* THE ORIGINAL STACK.  THIS WOULD JUST BE THE TERMINAL IN THE         *\n* FOREGROUND, BUT IT WILL BE THE SYSTSPRT DATASET IN THE BACKGROUND.  *\n***********************************************************************\n*\n         OI    ZTFLAGS,ZTSTKMOD    Indicate input stack addr altered\n         L     #15,STKECREA+STPBECTA-STPB Get address of new ECT\n         ST    #15,ZTNEWECT               Save it\n         MVC   ECTIOWA(4),ECTIOWA-ECT(#15) Copy IOWA pointer to ours\n*\n* Put a barrier element on the stack.\n*\n         XC    ZTECB,ZTECB         Clear ECB\n         INSYS\n         STACK PARM=STKBARR,MF=(E,IOPL) STACK BARRIER=*\n         OUTSYS\n         LTR   #15,#15             IF STACK UNSUCCESSFUL,\n         BZ    BARRIERD            THEN TERMINATE OUR PROCESSING.\n         LA    #1,=C'STACK BARRIER=*'\n         LA    #0,15\n         B     ERROR\nBARRIERD DS    0H\n*\n* Use PUTGET SUBSTACK=YES in conjunction with the barrier.\n*\n         MVC   PGPB(PGPBSUBL),PGPBSUB Set up PUTGET SUBSTACK=YES form\n         LA    #1,ZTPGOLD\n         ST    #1,PGPB+4           STORE ADDR OF O.L.D. IN PARM BLOCK\n         SPACE 1\nAINITSTK DS    0H                  ECT ready with new stack\n         SPACE\n***********************************************************************\n* THE COMMAND BUFFER PASSED TO US IS SCANNED AS A TSO COMMAND, THE    *\n* FIRST OPERAND IS CHECKED TO SEE IF IT IS A VALID TSO COMMAND OR     *\n* CLIST, AND IF SO, IT IS THEN INVOKED.                               *\n***********************************************************************\n         SPACE\n         ST    #5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS\n         MVC   ZTOFFSET,2(#5)      SAVE POSSIBLE CLIST NAME OFFSET\n         LR    #1,#5               POINT TO COMMAND BUFFER\n         #BAS  #14,SCAN            SCAN NEXT OPERAND IN COMMAND BUFFER\n         B     GOSCAN(#15)         BRANCH BASED ON RETURN CODE\nGOSCAN   B     SCAN0               RC=0 - VALID COMMAND NAME\n         B     RETURN              RC=4 - NO COMMAND NAME, RETURN NIL\n         B     SCAN8               RC=8 - INVALID COMMAND NAME\n         LH    #15,ZTSCANRC        RC=12 - SCAN ERROR\n         LA    #1,=C'SCAN'          IN WHICH CASE, BLOW UP\n         LA    #0,4\n         B     ERROR\n         SPACE\nSCAN8    DS    0H                  COMMAND IS SYNTACTICALLY INVALID\n         LA    #1,SYNMSG\n         LA    #0,L'SYNMSG\n         #BAS  #14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    #1,FLUSHALL\n         #BAS  #14,FLUSH           AND FLUSH THE INPUT STACK\n         B     RETURN\n         SPACE\nSCAN0    DS    0H                  COMMAND NAME IS SYNTACTICALLY OK\n         #BAS  #14,CKCMD           CHECK EXISTENCE OF COMMAND\n         TM    ZTFLAGS,ZTSUBER     IF SEVERE ERROR OCCURRED,\n         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE\n         LTR   #15,#15             IF COMMAND IS NOT SUPPORTED\n         BNZ   RETURN              THEN RETURN WITHOUT INVOKING IT\n         #BAS  #14,ATTACH          ELSE ATTACH THE COMMAND\n         TM    ZTFLAGS,ZTSUBER     IF SEVERE ERROR OCCURRED,\n         BO    ERROR               THEN GO DISPLAY ERROR MESSAGE\n         B     PROCXC              GO PROCESS ADDITIONAL STACKED CMD'S\n         EJECT\nRETURN   DS    0H\n         SPACE\n***********************************************************************\n*           *** RETURN TO CALLING PROGRAM ***                         *\n*         CLEAR OUR STACK, RESTORE ORIGINAL ONE,                      *\n*                 FREE STORAGE AND EXIT                               *\n***********************************************************************\n         SPACE\n         TM    ZTFLAGS,ZTSTKMOD    IF INPUT STACK ADDRESS WAS ALTERED,\n         BZ    AFTSTKRS            THEN\n         CLI   ZTTSOE,C'2'         If TSO/E Version 2 or later\n         BNL   FREESTK2            then unstack the new way\n*                                  else unstack the old way\nSTKCHECK DS    0H                   CHECK CURRENT INPUT STACK\n         CLC   0(4,#7),4(#7)        IF TOP ELEMENT NOT = BOTTOM ELEMENT\n         BE    STKCLRD              THEN\n         LA    #1,FLUSHTOP           CALL STACK TO FLUSH TOP ELEMENT\n         #BAS  #14,FLUSH             UNTIL\n         B     STKCHECK              ALL STACK ELEMENTS ARE CLEARED.\nSTKCLRD  DS    0H                  WHEN STACK IS CLEARED...\n*\n* NOTE THAT WE DON'T PROCESS THE BOTTOM ELEMENT OF OUR STACK VIA STACK!\n* IT CANNOT BE DELETED IF IT IS A TERMINAL ELEMENT, AND IF IT IS A\n* DATASET ELEMENT WE DEFINITELY DON'T WANT TO CLOSE IT, SO WE JUST\n* LET IT DISAPPEAR (UN)NATURALLY.\n*\n         B     AFTSTKRS\n         SPACE 1\nFREESTK2 DS    0H                  Unstack the TSO/E Version 2 way...\n         XC    ZTECB,ZTECB\n         INSYS\n         STACK PARM=STKDELB,MF=(E,IOPL) STACK DELETE=BARRIER\n         OUTSYS\n         LTR   #15,#15\n         BZ    AFTSTKDB\n         LA    #1,=C'STACK DELETE=BARRIER'\n         LA    #0,20\n         B     ERROR\n         SPACE 1\nAFTSTKDB DS    0H\n*\n***********************************************************************\n* Clear things out by issuing STACK ENVIRON=DESTROY.  This SHOULD     *\n* have the effect of deleting all the elements from the IOWA that     *\n* we have been using.  Then restore the old IOWA pointer to the ECT.  *\n***********************************************************************\n*\n         L     #15,ZTNEWECT               Get address of new ECT\n         ST    #15,STKEDEST+STPBECTA-STPB Store into stack parm list\n         ST    #15,IOPLECT         Store into IOPL for STACK to see\n         XC    ZTECB,ZTECB         Clear ECB\n         INSYS\n         STACK PARM=STKEDEST,MF=(E,IOPL) Stack ENVIRON=DESTROY\n         OUTSYS\n         LTR   #15,#15             If STACK failed,\n         BZ    ENVDESOK            then blow up\n         LA    #1,=C'STACK ENVIRON=DESTROY'\n         LA    #0,20\n         B     ERROR\nENVDESOK DS    0H                  STACK back to normal, almost...\n         MVC   IOPLECT,CPPLECT     Restore our ECT pointer\n         SPACE 1\nAFTSTKRS DS    0H\n         MVC   ECTIOWA(4),ZTSVIOA   RESTORE ORIGINAL INPUT STACK ADDR\n         NI    ZTFLAGS,255-ZTSTKMOD INDICATE INPUT STACK RESTORED\n         TM    ZTFLAGS,ZTECTMOD    IF ECTPCMD OR ECTSCMD WAS ALTERED,\n         BZ    AFTCMDRS            THEN\n         MVC   ECTPCMD(16),ZTCMDS   RESTORE ECTPCMD AND ECTSCMD.\nAFTCMDRS DS    0H\n         TM    ZTFLAGS,ZTSTXON     IF STAX IS ACTIVE\n         BNO   OFFSTAX             THEN\n         STAX  ,                    CANCEL STAX\nOFFSTAX  DS    0H\n         TM    ZTFLAGS,ZTESTON     IF ESTAE IS ACTIVE\n         BNO   OFFESTAE            THEN\n         ESTAE 0                    CANCEL ESTAE\nOFFESTAE DS    0H\n         SPACE\nFINALRET DS    0H\n         CLI   ZTSTATUS,ZTABEND    If command terminated abnormally,\n         BE    RABEND              then handle abending command\n         CLI   ZTSTATUS,ZTATTN     If command interrupted,\n         BE    RATTN               then handle attentioned command\nRNORMAL  DS    0H                  Else return with last return code\n*\n* CONVERT THE RETURN CODE FROM THE COMMAND INTO A FIXNUM\n*\n         L     #2,ZTRETCD          Get return code into reg for fixnum\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               USING CONTENTS OF #15, MAKE FIXNUM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         EJECT\nNOTSO    DS    0H                  HERE IF LINK FAILS\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2121 TSO: Command feature not available, TSO is not X\n               active - ',                                             X\n               0(#11)              (try to print out list of strings)\n         SPACE 1\nBADLIST  DS    0H\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2122 TSO: Cannot convert argument to string - ',    X\n               (#2),                                                   X\n               X'0D',              carriage return                     X\n               '(it''s a list, vector, funarg, or structure).'\n         SPACE 1\nTOOLONG  DS    0H                  Error - command string too long\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2120 TSO: Command exceeds maximum length of 32763 - X\n               ',                                                      X\n               0(#11)              (try to print out list of strings)\n         SPACE\nRABEND   DS    0H                  Error - command string too long\n         #BAS  #14,FAKESTR         Generate string for error message\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2124 TSO: Requested command was abnormally terminateX\n               d - ',(#2)\n         SPACE\nRATTN    DS    0H                  Error - command string too long\n         #BAS  #14,FAKESTR         Generate string for error message\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2125 TSO: Requested command terminated due to attentX\n               ion - ',(#2)\n         SPACE\nERROR3   DS    0H                  ERROR - NOT ENOUGH STORAGE\n         XR    #0,#0               CLEAR WORK AREA ADDRESS AND LENGTH\n         ST    #0,ZLCWA\n         ST    #0,ZLCWALEN\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2123 TSO: Not enough memory to build TSO command - 'X\n               ,0(#11)             (try to print out list of strings)\n         EJECT\nFAKESTR  DS    0H                  Subroutine to fake out a string\n*                                  for ZIL error messages\n         L     #2,ZLCWA            Get address of original command\n         LH    #0,0(,#2)           Get length of command buffer\n         SH    #0,=H'4'            Convert to length of command string\n         ST    #0,0(,#2)           Turn into ZIL string length\n         MVI   0(#2),##STRING      Set string type\n         BR    #14\n         EJECT\nPROCXC   DS    0H\n         SPACE\n***********************************************************************\n*               STACKED COMMAND PROCESSING                            *\n*                                                                     *\n* FOR THIS ROUTINE, ALL COMMANDS PLACED ON THE INPUT STACK BY THE     *\n* CURRENT COMMAND (E.G. A CLIST) ARE EXECUTED FROM THIS INTERFACE.    *\n* THE END OF THE CLIST OR STACK ELEMENT IS DETERMINED BY REACHING     *\n* THE BOTTOM LEVEL OF THE INPUT STACK.                                *\n*                                                                     *\n* NOTE: WHEN THE END OF A CLIST IS REACHED, THE PUTGET SERVICE        *\n* ROUTINE AUTOMATICALLY GOES TO THE NEXT LOWER ELEMENT ON THE STACK   *\n* TO RETRIEVE THE NEXT COMMAND.  NO NOTIFICATION IS RECEIVED BY THE   *\n* CALLER OF PUTGET THAT THIS HAS HAPPENED.  TO GET AROUND THIS        *\n* PROBLEM, WE ISSUE A PUTGET WITH A BAD MODE MESSAGE SO THAT THE      *\n* PUTGET WILL COMPLETE SUCCESSFULLY AS LONG AS IT GETS A COMMAND FROM *\n* A CLIST, BUT NOT WHEN IT TRIES TO GET A COMMAND FROM THE TERMINAL   *\n* (IT WILL RETURN A CODE OF 24 IN THIS CASE).  (THIS IDEA CAME        *\n* ORIGINALLY FROM ISPF MODULE ISPCAT (OR CAT).) WHEN THIS SITUATION   *\n* IS DETECTED, THE RETURN CODE FROM PUTGET IS CHECKED; IF THE INPUT   *\n* WAS OBTAINED FROM THE TERMINAL BUT NOT FROM THE BOTTOM LEVEL OF     *\n* THE INPUT STACK, THE PROBABLE EXPLANATION IS THAT A \"TERMIN\"        *\n* COMMAND PROCEDURE STATEMENT HAS BEEN EXECUTED, SO THE PUTGET IS     *\n* REISSUED WITH A GOOD MODE MESSAGE TO PERMIT TERMIN FUNCTIONING.     *\n* OTHERWISE WE KNOW THAT THE CLIST HAS COME TO AN END AND WE EXIT.    *\n*                                                                     *\n* THIS GIVES RISE TO A PROBLEM IN CLISTS THAT CONTAIN TERMIN          *\n* STATEMENTS:  IF CONTROL IS RETURNED TO THE CLIST BY THE USER'S      *\n* ENTRY OF A TERMIN STRING, AND THE CLIST ISSUES NO MORE TSO COMMANDS *\n* BUT DOES SOME CLIST PROCESSING AND TERMINATES, THIS SUBROUTINE HAS  *\n* NO WAY OF KNOWING THAT THE COMMAND RETRIEVED FOLLOWING THE TERMIN   *\n* STATEMENT CAME FROM OUTSIDE THE CLIST UNTIL IT HAS ALREADY BEEN     *\n* RETRIEVED, BY WHICH TIME IT IS TOO LATE TO DO ANYTHING ABOUT IT.    *\n* THEREFORE, CLISTS SHOULD CONTAIN AT LEAST ONE COMMAND (A NULL       *\n* COMMAND IS SUFFICIENT) FOLLOWING RETURN FROM A TERMIN STATEMENT.    *\n* (ISPF AVOIDS THIS PROBLEM BY REFUSING TO SUPPORT TERMIN ENTIRELY.)  *\n*                                                                     *\n***********************************************************************\n         SPACE\n***********************************************************************\n* RETRIEVE COMMANDS USING PUTGET, SCAN THEM AND ATTACH THE COMMANDS   *\n* WHEN VALID.  NOTE THAT STACK FLUSHING MAY CAUSE THE CURRENT STACK   *\n* LEVEL TO REVERT TO THE ORIGINAL LEVEL, TERMINATING OUR PROCESSING   *\n* OF COMMANDS; THIS IS A NORMAL WAY OF CLIST TERMINATION UNDER TSO.   *\n***********************************************************************\n         SPACE\n         LTR   #1,#5               GET ADDRESS OF PUTGET BUFFER\n         BZ    XCGET               IF A PUTGET BUFFER EXISTS,\n         C     #1,ZLCWA            AND IT'S NOT OUR OWN WORKAREA,\n         BE    XCGET                THEN...\n         LA    #0,1                 GET SUBPOOL NUMBER\n         SLL   #0,24                SHIFT INTO HIGH-ORDER BYTE\n         AH    #0,0(,#5)            ADD IN LENGTH OF PUTGET BUFFER\n         FREEMAIN R,LV=(0),A=(1)    FREE THE PUTGET INPUT BUFFER\n         XR    #5,#5                CLEAR PUTGET BUFFER POINTER\n         SPACE\nXCGET    DS    0H\n         SPACE\n         CLI   ZTTSOE,C'2'         If TSO/E Version 2 or later\n         BNL   PROC2               then process commands the new way\n*                                  else process commands the old way\n         SPACE\n***********************************************************************\n* AT THIS POINT WE ARE READY TO GET THE NEXT COMMAND, BUT ONLY IF A   *\n* NEW ELEMENT HAS BEEN PLACED ON THE INPUT STACK, I.E. THE STACK      *\n* LEVEL AT THIS POINT IS NOT THE SAME AS THE BOTTOM ELEMENT.  SUCH    *\n* CAN OCCUR IF WE HAVE EXECUTED A CLIST OR IF WE HAVE INVOKED A       *\n* COMMAND THAT STACKS OTHER COMMANDS.  WE KEEP PROCESSING COMMANDS    *\n* UNTIL THE STACK LEVEL REACHES THE BOTTOM AGAIN.  NOTE THAT ANY      *\n* ERROR ENCOUNTERED DURING A PREVIOUS PASS THROUGH THIS LOOP WILL     *\n* HAVE CAUSED US TO ISSUE A STACK FLUSH, WHICH WILL RESULT IN         *\n* TERMINATION OF NEW STACK ELEMENTS (AND EXIT FROM LOOP) UNLESS THE   *\n* ELEMENT IS A CLIST WITH CONTROL MAIN OR CONTROL NOFLUSH ACTIVE.     *\n***********************************************************************\n         SPACE\n         CLC   0(4,#7),4(#7)       IF TOP STK ELEMENT = BOTTOM ELEMENT\n         BE    ENDCMDS             THEN END OUR PROCESSING.\n         SPACE\n***********************************************************************\n* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *\n***********************************************************************\n         SPACE\n         XC    ZTPGHDR(4),ZTPGHDR  SET UP BAD (NULL) MODE MESSAGE\n         #BAS  #14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    ZTFLAGS,ZTSUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE\n         CH    #15,=H'24'          IF INVALID PARAMETERS ON PUTGET,\n         BNE   PUTGETOK            THEN (TERMINAL IS CURRENT ELEMENT)..\n         CLC   0(4,#7),4(#7)        IF TOP STK ELEMENT = BOTTOM ELEMENT\n         BE    ENDCMDS              THEN END OUR PROCESSING.\n         SPACE\n***********************************************************************\n* ELSE WE ASSUME A TERMIN STATEMENT WAS EXECUTED AND WE ACCEPT INPUT. *\n***********************************************************************\n         SPACE\n         MVC   ZTPGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE\n         #BAS  #14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    ZTFLAGS,ZTSUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG                OR\n         CH    #15,=H'24'            INVALID PARAMETERS ON PUTGET,\n         BE    BADPG                  THEN REALLY BAD PUTGET, BLOW UP.\n         CLC   0(4,#7),4(#7)       ELSE IF TOP ELEMENT = BOTTOM ELEMENT\n         BNE   PUTGETOK            THEN (TERMIN ENVIRONMENT NOT VALID)\n         LA    #1,TERMMSG           DISPLAY MESSAGE TELLING USER THAT\n         LA    #0,L'TERMMSG         THE COMMAND WAS NOT EXECUTED SINCE\n         #BAS  #14,PUTLINE          IT WASN'T SUPPOSED TO BE RETRIEVED\n         B     ENDCMDS              AND THEN RETURN TO CALLING PGM.\n         SPACE 1\nPROC2    DS    0H                  Process commands the TSO/E V.2 way\n         SPACE 1\n***********************************************************************\n* At this point we are ready to get the next command, but only if a   *\n* new element has been placed on the input stack, I.E. the stack      *\n* level at this point is not the barrier element.  Such can occur if  *\n* we have executed a CLIST or if we have invoked a command that       *\n* stacks other commands.  We keep processing commands until the stack *\n* barrier element is reached.  Note that any error encountered during *\n* a previous pass through this loop will have caused us to issue a    *\n* stack flush, which will result in termination of new stack elements *\n* (and exit from loop) unless the element is a CLIST with             *\n* CONTROL MAIN or CONTROL NOFLUSH active.                             *\n***********************************************************************\n* RETRIEVE ADDITIONAL COMMANDS FROM INPUT STACK ELEMENT.              *\n***********************************************************************\n         SPACE\n         MVC   ZTPGHDR(MODELEN),MODEDATA  SET UP GOOD MODE MESSAGE\n         #BAS  #14,PUTGET          GET A LINE OF COMMAND INPUT\n         TM    ZTFLAGS,ZTSUBER     IF A PUTGET ERROR OCCURRED,\n         BO    BADPG               THEN GO TO DISPLAY ERROR MESSAGE\n         CH    #15,=H'40'          IF BARRIER HIT,\n         BE    ENDCMDS             then no more command\n******** B     PUTGETOK            else process command\n         SPACE 1\nPUTGETOK DS    0H\n         CLI   ZTSTATUS,ZTATTN     IF ATTENTION INTERRUPT OCCURRED,\n         BNE   PGNOATTN            THEN\n         LA    #1,FLUSHTOP          FLUSH THE STACK (EVEN IF\n         #BAS  #14,FLUSH             CONTROL NOFLUSH IS ACTIVE)\n         B     PROCXC               AND CONTINUE\n         SPACE\nPGNOATTN DS    0H                  ELSE GO AHEAD AND PROCESS THIS LINE\n         ST    #5,CPPLCBUF         SET CPPL COMMAND BUFFER ADDRESS\n         XC    ZTOFFSET,ZTOFFSET   SET COMMAND BUFFER OFFSET TO ZERO\n         LR    #1,#5               POINT TO THE COMMAND BUFFER\n         #BAS  #14,SCAN            SCAN NEXT OPERAND OF THE COMMAND\n         B     GOSCANX(#15)        BRANCH BASED ON RETURN CODE\nGOSCANX  B     SCANX0              RC=0 - VALID COMMAND NAME\n         B     PROCXC              RC=4 - NO COMMAND NAME\n         B     SCANX8              RC=8 - INVALID COMMAND NAME\n         LH    #15,ZTSCANRC        RC=12 - SCAN ERROR\n         LA    #1,=C'SCAN'          IN WHICH CASE, BLOW UP\n         LA    #0,4\n         B     ERROR\n         SPACE\nSCANX8   DS    0H                  COMMAND IS SYNTACTICALLY INVALID\n         LA    #1,SYNMSG\n         LA    #0,L'SYNMSG\n         #BAS  #14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    #1,FLUSHALL\n         #BAS  #14,FLUSH           AND FLUSH THE INPUT STACK\n         B     PROCXC\n         SPACE\nSCANX0   DS    0H                  COMMAND IS SYNTACTICALLY OK\n         #BAS  #14,CKCMD           CHECK VALIDITY OF COMMAND\n         LTR   #15,#15             IF COMMAND IS NOT VALID,\n         BNZ   PROCXC              THEN CONTINUE WITH THE NEXT ONE\n         #BAS  #14,ATTACH          ELSE INVOKE THE COMMAND\n         TM    ZTFLAGS,ZTSUBER     IF SUBROUTINE ERROR,\n         BO    ERROR               THEN GO TO DISPLAY MESSAGE\n         B     PROCXC              ELSE GO TO GET THE NEXT COMMAND\n         SPACE 2\nBADPG    LA    #1,=C'PUTGET'       FATAL PUTGET ERROR\n         LA    #0,6\n         B     ERROR\n         EJECT\nENDCMDS  DS    0H                  NO MORE COMMANDS TO PROCESS\n         XR    #15,#15\n         ICM   #15,7,ECTRTCD       PICK UP RETURN CODE FROM ECT\n         ST    #15,ZTRETCD         SAVE THE RETURN CODE\n         SPACE\n***********************************************************************\n* AT THIS POINT, TO INSURE CORRECT COMMAND STATISTICAL RECORDING, WE  *\n* DO VARIOUS STUFF FOR TSO/MON.  SINCE TSO/MON IS NOT INSTALLED AT    *\n* DRAPER, I HAVE OMITTED THIS CODE, BUT MAY ADD SVC109 INTERFACE SOON.*\n***********************************************************************\n         SPACE\n         B     RETURN              RETURN TO CALLING PROGRAM\n         EJECT\nERROR    DS    0H                  DISPLAY ERROR MESSAGE AND END\n         SPACE\n***********************************************************************\n* MISCELLANEOUS ERROR DISPLAY.                                        *\n* #0 CONTAINS LENGTH OF NAME OF FUNCTION THAT FAILED                  *\n* #1 CONTAINS ADDRESS OF NAME OF FUNCTION THAT FAILED                 *\n* #15 CONTAINS RETURN CODE FROM FAILED FUNCTION                       *\n***********************************************************************\n         SPACE\n         MVC   ZTMSG(L'ERRMSG1),ERRMSG1  SET UP FIRST PART OF MESSAGE\n         LTR   #14,#0              GET LENGTH OF FUNCTION TYPE\n         BNP   AFTFUNC             IF NONE, BYPASS\n         BCTR  #14,0               ELSE REDUCE LENGTH FOR EXECUTE\n         EX    #14,MOVEFUNC        MOVE FUNCTION NAME TO ERROR MESSAGE\nAFTFUNC  LA    #1,ZTMSG+L'ERRMSG1+1(#14)  POINT TO NEXT PART OF MESSAGE\n         MVC   0(L'ERRMSG2,#1),ERRMSG2    SET UP SECOND PART OF MESSAGE\n         CVD   #15,ZTDOUBLE               CONVERT ERROR CODE TO DISPLAY\n         UNPK  L'ERRMSG2(2,#1),ZTDOUBLE\n         OI    L'ERRMSG2+1(#1),X'F0'\n         LA    #0,L'ERRMSG1+L'ERRMSG2+3(#14)  GET LENGTH OF MSG IN #0\n         XR    #1,#1               INDICATE MESSAGE ALREADY IN WORKAREA\n         #BAS  #14,PUTLINE         DISPLAY THE MESSAGE\n         LA    #1,FLUSHALL\n         #BAS  #14,FLUSH           FLUSH THE INPUT STACK\n         B     RETURN              RETURN TO CALLING PROGRAM\n         SPACE\nMOVEFUNC MVC   ZTMSG+L'ERRMSG1(0),0(#1)  MOVE FUNCTION TO ERROR MESSAGE\n         EJECT\n***********************************************************************\n* THE SCAN SUBROUTINE INVOKES THE IKJSCAN TSO SERVICE ROUTINE TO      *\n* DETERMINE THE NATURE OF THE NEXT OPERAND IN THE TSO COMMAND         *\n* BUFFER.  ON ENTRY #1 CONTAINS THE ADDRESS OF THE COMMAND BUFFER TO  *\n* BE SCANNED.  ON RETURN THE FIELD ZTCOMMND CONTAINS THE OPERAND,     *\n* BLANK PADDED AND JUSTIFIED LEFT, UNLESS THE OPERAND IS MISSING OR   *\n* SYNTACTICALLY INVALID.  #15 IS SET TO ZERO IF THE OPERAND IS A      *\n* SYNTACTICALLY VALID COMMAND NAME, 4 IF IT IS MISSING, 8 IF IT IS    *\n* SYNTACTICALLY INVALID, 12 IF AN ERROR RETURN CODE IS PASSED BACK    *\n* FROM IKJSCAN.  IF THE OPERAND WAS PRECEDED BY A PERCENT SIGN (%),   *\n* THE FLAG ZTEXEC IS SET ON; OTHERWISE IT IS SET OFF.  IF THERE ARE   *\n* NO FURTHER OPERANDS IN THE TSO COMMAND BUFFER FOLLOWING THE         *\n* CURRENT ONE, THE ECTNOPD FLAG IN THE ECT IS SET ON.                 *\n***********************************************************************\n         SPACE\nSCAN     DS    0H\n         ST    #14,ZTSCAN14        SAVE RETURN REGISTER\n         MVI   ZTCOMMND,C' '       SET COMMAND NAME FIELD TO BLANKS\n         MVC   ZTCOMMND+1(7),ZTCOMMND\n         NI    ZTFLAGS,255-ZTEXEC  ASSUME NOT AN IMPLICIT EXEC FOR NOW\n         NI    ECTSWS,255-ECTNOPD  SET ECT NO-OPERANDS BIT OFF\n         ST    #1,CSPLCBUF         SET COMMAND BUFFER ADDRESS FROM PARM\n         XC    ZTECB,ZTECB         CLEAR ECB\n         INSYS\n         CALLTSSR EP=IKJSCAN,MF=(E,CSPL)  CALL IKJSCAN TO SCAN BUFFER\n         OUTSYS\n         STH   #15,ZTSCANRC        SAVE IKJSCAN RETURN CODE\n         LTR   #15,#15             IF SCAN FAILED,\n         BZ    SCANOK              THEN...\n         LA    #15,12               INDICATE SCAN FAILURE\n         B     SCANRET              AND RETURN. ELSE...\nSCANOK   DS    0H                  CHECK RESULTS OF SCAN\n         TM    CSOAFLG,CSOAQM+CSOABAD IF ANY SYNTAX ERROR\n         BNZ   SCANBAD             THEN RETURN INDICATING BAD SYNTAX\n         TM    CSOAFLG,CSOANOC     IF NO COMMAND NAME WAS FOUND,\n         BNO   NOTNOC              THEN...\n         OI    ECTSWS,ECTNOPD       INDICATE ECT NO OPERANDS\n         LA    #15,4                RETURN INDICATING NOTHING FOUND\n         B     SCANRET             ELSE...\nNOTNOC   DS    0H                  (AN OPERAND EXISTS)\n         LH    #1,CSOALNM          PICK UP LENGTH OF OPERAND\n         LTR   #1,#1               IF LENGTH IS ZERO,\n         BNP   SCANBAD             THEN...\n         L     #15,CSOACNM         GET ADDRESS OF OPERAND\n         BCTR  #1,0                REDUCE OPERAND LENGTH FOR EXECUTE\n         EX    #1,MOVECMD          MOVE OPERAND TO COMMAND NAME AREA\n         XR    #15,#15             INDICATE VALID COMMAND NAME\n         TM    CSOAFLG,CSOAEXEC    IF COMMAND PRECEDED BY % SIGN,\n         BZ    *+8                 THEN...\n         OI    ZTFLAGS,ZTEXEC       INDICATE IMPLICIT EXEC\n         TM    CSOAFLG,CSOAVNP     IF THERE ARE NO FURTHER OPERANDS,\n         BNO   *+8                 THEN...\n         OI    ECTSWS,ECTNOPD       SAY SO IN ECT\n         B     SCANRET             RETURN\nSCANBAD  DS    0H                  SYNTAX ERROR\n         LA    #15,8               RETURN INDICATING BAD SYNTAX\n******** B     SCANRET\nSCANRET  L     #14,ZTSCAN14        RESTORE RETURN REGISTER\n         BR    #14                 RETURN\n         SPACE 2\nMOVECMD  MVC   ZTCOMMND(0),0(#15)  MOVE COMMAND NAME TO NAME AREA\n         SPACE\n         LTORG\n         EJECT\nCKCMD    DS    0H\n         SPACE\n         ST    #14,ZTCKCM14        SAVE RETURN REGISTER\n         NI    ZTFLAGS,255-ZTSUBER TURN OFF ERROR INDICATOR\n         NI    ZTFLAGS,255-ZTAUTH  Also assume not APF authorized\n         TM    ZTFLAGS,ZTEXEC      IF IMPLICIT %CLIST,\n         BO    IMPLICIT            THEN PROCESS AS ONE. ELSE...\n         CLC   ZTCOMMND(8),=CL8'ISPEXEC '  IF COMMAND = ISPEXEC\n         BE    NGCMD                       THEN REJECT\n*\n******** BE    PROCESS_ISPEXEC_COMMAND future enhancement...\n*\n         MVC   ZTMODULE,ZTCOMMND   ELSE SET COMMAND NAME = SAME NAME\n         OI    ZTFLAGS,ZTECTMOD    INDICATE ECT HAS BEEN CHANGED\n         MVC   ECTPCMD,ZTMODULE    SET UP ECT COMMAND NAME\n         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS\n         MVC   ECTSCMD+1(7),ECTSCMD\n         CLC   =C'TIME ',ZTMODULE  IF COMMAND = TIME\n         BNE   NOTTIME             THEN\n         MVC   ZTMODULE,=CL8'IKJEFT25' SET MODULE NAME = IKJEFT25\n         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING\nNOTTIME  CLC   =C'CALL ',ZTMODULE  IF COMMAND = CALL\n         BNE   NOTCALL             THEN\n******** MVC   ZTMODULE,=CL8'ISPCALL ' SET MODULE NAME = ISPCALL\n         MVC   ZTMODULE,=CL8'IKJEFG00' SET MODULE NAME = IKJEFG00\n         B     TSEVENT                 AND PROCESS WITHOUT SEARCHING\nNOTCALL  CLC   =C'TEST ',ZTMODULE  If command = TEST\n         BNE   NOTTEST             then\n         ICM   #15,15,ZTE2ADDR      If we don't have addr of IKJEFTE2\n         BZ    NGCMD                then not TSO/E, can't invoke TEST\n         OI    ZTFLAGS,ZTAUTH       Else indicate APF authorization req\n         B     TSEVENT              and process without searching.\nNOTTEST  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Before searching for the command, search the table of authorized    *\n* TSO commands to see if it requires APF authorization.  If it does,  *\n* indicate so.  We will still have to search for it.                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   #15,15,ZTE2ADDR     Get address of IKJEFTE2\n         BZ    NOTAUTH             If none, not TSO/E, not authorized\n         LA    #1,16(,#15)         Point to first entry\nE2LOOP   DS    0H                  Loop\n         CLI   0(#1),C' '           until blank entry found\n         BE    NOTAUTH              at which point it's not authorized\n         CLC   0(8,#1),ZTMODULE     but if we found the module name\n         BE    NEEDAUTH             then mark it authorized\n         LA    #1,8(,#1)            else bump to next entry\n         B     E2LOOP               and continue.\nNEEDAUTH DS    0H                  Here if module is in E2 table\n         OI    ZTFLAGS,ZTAUTH      Indicate APF authorization required\n*\n* ... we should probably bypass the search - TSO service'll do it NEhow\n*\nNOTAUTH  DS    0H                  Here if module is not authorized\n         SPACE 1\n***********************************************************************\n* NOTE: AT THIS POINT IT IS POSSIBLE TO INSERT SOME ALTERNATE COMMAND *\n* VALIDATION CODE SUCH AS AN ACF2 COMMAND VALIDATION SVC.  HOWEVER,   *\n* WE WILL EMULATE THE TMP AND ISPF COMMAND SEARCH CODE INSTEAD.       *\n***********************************************************************\n         SPACE\n         STM   #8,#11,ZLCISAVE     Save ZIL registers\n         LM    #0,#1,ZTMODULE      LOAD COMMAND NAME INTO PARM REGS\n         STM   #3,#9,32(#13)       SAVE REGISTERS USED BY LPA SEARCH\n         L     #3,16               #3 = CVT ADDRESS\n         L     #15,X'160'(,#3)     #15 -> LPA DIRECTORY SEARCH ROUTINE\n         INSYS\n         #BASR #14,#15             CALL LPA DIRECTORY SEARCH\n***********************************************************************\n* IF THE COMMAND NAME IS FOUND IN THE LPA DIRECTORY, CONTROL RETURNS  *\n* TO THE NEXT SEQUENTIAL INSTRUCTION AND #14 IS SET TO ZERO.  IF THE  *\n* COMMAND NAME HAS NOT BEEN FOUND, CONTROL RETURNS TO THE INSTRUCTION *\n* AT +4 PAST HERE AND #14 IS NONZERO.                                 *\n***********************************************************************\n         LA    #14,0               IF SUCCESSFUL, SET #14 = 0\n         LM    #3,#9,32(#13)       RESTORE REGISTERS USED BY LPA SEARCH\n         LM    #8,#11,ZLCISAVE     Restore ZIL registers\n         OUTSYS\n         LTR   #14,#14             IF COMMAND NAME WAS FOUND,\n         BZ    TSEVENT             THEN GO AHEAD AND USE IT. ELSE...\n*\n* Don't use command in JPA - probably a ZIL subroutine!\n*\n******** LA    #0,ZTMODULE         SET EPLOC PARAMETER FOR IDENTIFY\n******** XR    #1,#1               SET ENTRY ADDRESS PARM FOR IDENTIFY\n******** IDENTIFY ENTRY=(1),EPLOC=(0) SEE IF ENTRY NAME IS AROUND\n******** CH    #15,=H'8'           IF RC=8, COMMAND IS IN JPA\n******** BE    TSEVENT             SO GO USE IT\n******** CH    #15,=H'20'          IF RC=20, COMMAND IS IN JPA\n******** BE    TSEVENT             SO GO USE IT\n         MVC   ZTBLDNAM,ZTMODULE   If none of the above, try BLDL\n         L     #0,LINKDCB          Get address of link list DCB\n         BLDL  (0),ZTBLDL          Find member in linklist, not ZIL lib\n         LTR   #15,#15             SEE IF BLDL SUCCESSFUL\n         BZ    TSEVENT             IF BLDL SUCCESSFUL, IT IS A COMMAND\n******** BNZ   IMPLICIT            IF BLDL FAILED, IT MUST BE A CLIST\n         SPACE\nIMPLICIT DS    0H                  LOAD MODULE NOT FOUND, MUST BE CLIST\n         MVC   ZTMODULE,=CL8'EXEC' SET COMMAND NAME = \"EXEC\"\n         NI    ZTFLAGS,255-ZTAUTH  Show not APF authorized after all\n         LH    #15,ZTOFFSET        PICK UP OFFSET OF CLIST NAME\n         LTR   #15,#15             IF ZERO OFFSET, THEN IGNORE\n         BNP   AFTBLNKX\n         BCTR  #15,0               REDUCE FOR EXECUTE\n         BCTR  #15,0               AND FOR MOVE CHARACTERS\n         MVI   4(#5),C' '          SET BUFFER PRECEDING CLIST NAME\n         EX    #15,MVCBLANK         TO BLANKS\nAFTBLNKX XC    2(2,#5),2(#5)       SET COMMAND BUFFER OFFSET = ZERO\n         OI    ZTFLAGS,ZTECTMOD    INDICATE ECT HAS BEEN CHANGED\n         MVC   ECTPCMD,ZTMODULE    SET UP ECT COMMAND NAME\n         MVI   ECTSCMD,C' '        CLEAR ECT SUBCOMMAND NAME TO BLANKS\n         MVC   ECTSCMD+1(7),ECTSCMD\n         SPACE\nTSEVENT  DS    0H                  NOW WE ARE READY TO ISSUE COMMAND\n         SPACE\n***********************************************************************\n* ISSUE TSVENT (SYSEVENT 0) TO TELL SYSTEM ABOUT COMMAND.             *\n* NOTE: SVC 109 INTERFACE IS A POSSIBILITY HERE. HOWEVER, EXISTING    *\n* TSO MONITORING PRODUCTS USE THE SVC 95 INTERFACE ONLY, EVEN THOUGH  *\n* THE SVC 109 INTERFACE IS PARTICULARLY SUITED FOR APPLICATIONS SUCH  *\n* AS THIS ROUTINE WHICH CREATE STACKS OF NESTED COMMAND INVOCATIONS.  *\n***********************************************************************\n         SPACE\n         L     #1,ECTPCMD\n         L     #15,ECTPCMD+4\n         TSEVENT PPMODE            TELL SRM ABOUT THE COMMAND\n         XR    #15,#15             INDICATE COMMAND IS OK\n         B     CKCMDRET            AND RETURN\n         SPACE\nNGCMD    DS    0H                  COMMAND NOT VALID (TEST, ISPEXEC)\n         MVC   ZTMSG(L'TESTMSG1),TESTMSG1  MOVE BEGINNING OF MESSAGE\n         MVC   ZTMSG+L'TESTMSG1(8),ZTCOMMND  MOVE IN COMMAND NAME\n         LA    #1,ZTMSG+L'TESTMSG1 POINT TO BEGINNING OF NAME\n         LA    #14,8               MAX COUNT FOR NAME LENGTH\nNGLOOP   CLI   0(#1),C' '          SCAN FOR FIRST BLANK\n         BE    NGBLANK              FOLLOWING COMMAND NAME\n         LA    #1,1(,#1)             UNTIL\n         BCT   #14,NGLOOP             LENGTH OF NAME EXHAUSTED\nNGBLANK  DS    0H\n         MVC   0(L'TESTMSG2,#1),TESTMSG2  MOVE END OF MESSAGE\n         LA    #0,L'TESTMSG2(,#1)  END OF MESSAGE\n         LA    #14,ZTMSG           MINUS BEGINNING OF MESSAGE\n         SLR   #0,#14              GIVES LENGTH OF MESSAGE\n         XR    #1,#1               INDICATE MESSAGE ALREADY BUILT\n         #BAS  #14,PUTLINE         DISPLAY ERROR MESSAGE\n         LA    #1,12               SET ECT RETURN CODE TO 12\n         STCM  #1,7,ECTRTCD        AS IF COMMAND NOT FOUND\n         LA    #1,FLUSHALL\n         #BAS  #14,FLUSH           AND FLUSH THE INPUT STACK\n         LA    #15,8               INDICATE COMMAND INVALID\nCKCMDRET L     #14,ZTCKCM14        RESTORE RETURN REGISTER\n         BR    #14                 RETURN\n         SPACE\nMVCBLANK MVC   5(0,#5),4(#5)       FINISH MOVING BLANKS INTO CMD BUFFER\n         SPACE\nTESTMSG1 DC    C'ZILTSO02 ZIL TSO DOES NOT SUPPORT THE '\nTESTMSG2 DC    C' COMMAND'\n         SPACE\n         LTORG\n         EJECT\nATTACH   DS    0H\n         SPACE\n***********************************************************************\n*                                                                     *\n* This subroutine does one of the following:                          *\n*                                                                     *\n* (1) If the command requires APF authorization, invokes the TSO      *\n*     Authorized Service Facility to invoke it.                       *\n* (2) Otherwise, attaches the command as a subtask directly.          *\n*                                                                     *\n***********************************************************************\n         SPACE\n         ST    #14,ZTATT14         SAVE RETURN REGISTER\n         SPACE\n         TM    ZTFLAGS,ZTAUTH      If command requires authorization\n         BO    ATTTSF              then go invoke TSO service facility\n         SPACE\n         XC    ZTCMDECB,ZTCMDECB   CLEAR ATTACH ECB\n         XC    ZTATNECB,ZTATNECB   CLEAR ATTENTION ECB\n         NI    ZTFLAGS,255-ZTSUBER CLEAR ERROR FLAG\n         MVI   ZTSTATUS,ZTNORMAL   CLEAR COMMAND STATUS FLAG\n         NI    ECTSWS2,255-ECTNOQPR ENABLE \"? PROMPT HELP\"\n         L     #2,LINKDCB          Get address of linklist DCB\n         LOAD  EPLOC=ZTMODULE,DCB=(#2) Make sure we load the right one.\n         LA    #1,CPPL             POINT TO CPPL\n         ATTACH EPLOC=ZTMODULE,SF=(E,ZTATTACH),ECB=ZTCMDECB,           X\n               DCB=(#2),                                               X\n               ESTAI=(STAIEXIT,(#12))     ATTACH THE COMMAND\n         LTR   #15,#15             IF ATTACH FAILED,\n         BZ    ATTACHOK            THEN\n         LA    #1,=C'ATTACH'        BLOW UP\n         LA    #0,6\n         OI    ZTFLAGS,ZTSUBER\n         B     ATTRET\nATTACHOK DS    0H\n         LR    #2,#1               SAVE TCB ADDRESS\n         USING TCB,#2\n         WAIT  1,ECBLIST=ZTECBLST  WAIT FOR COMPLETION OR ATTENTION\n         MVC   ECTRTCD,TCBCMPC     MOVE TCB COMPLETION CODE TO ECT\n         MVI   ECTRCDF,0           INIT ECT CP = NOT ABENDED\n         ST    #2,DA2CTCB          SAVE TCB ADDRESS FOR DAIR\n         XC    ZTECB,ZTECB         CLEAR ECB\n         INSYS\n         CALLTSSR EP=IKJDAIR,MF=(E,DAPL)  MARK DATA SETS NOT IN USE\n         OUTSYS\n         ST    #15,ZTDAIRRC        SAVE DAIR RETURN CODE\n         OI    ZTFLAGS,ZTDETACH    INDICATE DETACH IN PROGRESS\n         LA    #1,DA2CTCB          POINT TO TCB ADDRESS\n         DETACH (1),STAE=YES       DETACH THE COMMAND\n         NI    ZTFLAGS,255-ZTDETACH INDICATE DETACH NOT IN PROGRESS\n         CH    #15,=H'4'           IF DETACH FAILED,\n         BNH   DETACHOK\n         LA    #1,=C'DETACH'        BLOW UP\n         LA    #0,6\n         OI    ZTFLAGS,ZTSUBER\n         B     ATTRET\n         DROP  #2\nDETACHOK DS    0H                  NOW, CHECK DAIRRC AFTER DETACH\n         DELETE EPLOC=ZTMODULE     Delete what we loaded before.\n         ICM   #15,15,ZTDAIRRC     IF DAIR RETURN CODE NOT ZERO,\n         BZ    DAIROK              THEN...\n         LA    #1,=C'DAIR'          BLOW UP\n         LA    #0,4\n         OI    ZTFLAGS,ZTSUBER\n         B     ATTRET\nDAIROK   DS    0H\n         SPACE\n         CLI   ZTSTATUS,ZTATTN     IF COMMAND TERMINATED BY ATTENTION,\n         BE    ATTFLUSH            THEN FLUSH THE INPUT STACK\n         CLI   ZTSTATUS,ZTABEND    ELSE IF THE COMMAND ABENDED,\n         BNE   ATTRET              THEN\nABFLUSH  OI    ECTRCDF,X'80'        INDICATE CP ABENDED IN ECT\n         LA    #1,FLUSHALL          FOR ABEND, DO NORMAL STACK FLUSH\n         B     FLUSHCMD             AND FLUSH THE INPUT STACK.\nATTFLUSH LA    #1,FLUSHTOP         FOR ATTN, DO EVEN IF CONTROL=NOFLUSH\nFLUSHCMD #BAS  #14,FLUSH           FLUSH THE INPUT STACK\nATTRET   L     #14,ZTATT14         RESTORE RETURN REGISTER\n         BR    #14                 RETURN\n         SPACE\nATTTSF   DS    0H                  Here if command is APF authorized\n         SPACE\n         XR    #0,#0               Make a zero\n         ST    #0,ZTTSFRC          Initialize TSO command return code\n         ST    #0,ZTTSFRS          Initialize TSO command reason code\n         ST    #0,ZTTSFAC          Initialize TSO command abend code\n         LA    #1,TSFFLAGS         Point to flags\n         ST    #1,ZTTSFP1          Store parameter 1\n         L     #2,CPPLCBUF         Get address of command buffer\n         LA    #1,4(,#2)           Point to command buffer text\n         ST    #1,ZTTSFP2          Store parameter 2\n         LH    #1,0(,#2)           Get length of command buffer\n         SH    #1,=H'4'            Adjust length to length of text\n         ST    #1,ZTTSFLEN         Store length\n         LA    #1,ZTTSFLEN         Get address of length\n         ST    #1,ZTTSFP3          Store parameter 3\n         LA    #1,ZTTSFRC          Point to where to store return code\n         ST    #1,ZTTSFP4          Store parameter 4\n         LA    #1,ZTTSFRS          Point to where to store reason code\n         ST    #1,ZTTSFP5          Store parameter 5\n         LA    #1,ZTTSFAC          Point to where to store abend code\n         ST    #1,ZTTSFP6          Store parameter 6\n         OI    ZTTSFP6,X'80'       Set VL bit\n         LA    #1,ZTTSFP1          Point to parameter list\n         L     #15,X'10'           Get address of CVT\n         L     #15,CVTTVT-CVT(,#15) Get address of TSVT\n         L     #15,TSVTASF-TSVT(,#15) Get address of IKJEFTSR\n         INSYS\n         #BASR #14,#15             Call IKJEFTSR\n         OUTSYS\n         SPACE\n* OK, now process all those godawful return codes.  Who designed this!\n         SPACE\n         B     TSFRC(#15)          Branch depending on return code\nTSFRC    B     TSFRC0              0 = OK\n         B     TSFRC4              4 = nonzero return code from command\n         B     TSFRC8              8 = attention interrupt\n         B     TSFRC12             12 = abend\n         B     TSFRC16             16 = parm address in protected stg.\n         B     TSFRC20             20 = error in parameter list\n         B     TSFRC24             24 = unexpected TSO failure\n         B     TSFRC28             28 = AMODE 24 but parms are AMODE 31\n         SPACE\nTSFRC0   EQU   ATTRET              0 = OK\nTSFRC4   EQU   ATTRET              4 = nonzero return code from command\n         SPACE\nTSFRC8   DS    0H                  8 = attention interrupt\n         SPACE\n         MVI   ZTSTATUS,ZTATTN     INDICATE ATTENTION INTERRUPT\n         MVC   ZTMSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   ZTMSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE\n         LA    #0,L'ATNMSGID+8+L'ATTNMSG    GET LENGTH OF ATTENTION MSG\n         XR    #1,#1               INDICATE MESSAGE SET UP\n         #BAS  #14,PUTLINE         CALL PUTLINE TO DISPLAY THE MESSAGE\n         B     ATTFLUSH            Return to flush stack for attn & ret\n         SPACE\nTSFRC12  DS    0H                  12 = abend\n         SPACE\n         MVI   ZTSTATUS,ZTABEND    INDICATE COMMAND ABENDED\n         MVC   ZTABCODE(3),ZTTSFAC+1 STORE ABEND CODE\n         SPACE\n***********************************************************************\n* DISPLAY \"ENDED DUE TO ERROR\" MESSAGE                                *\n***********************************************************************\n         SPACE\n         MVC   ZTMSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   ZTMSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE\n         CLC   ZTABCODE,=X'000FFF'          IF CODE GREATER THAN 4095\n         BNH   TSFUSRAB                     THEN MUST BE A SYSTEM ABEND\n         MVC   ZTMSG2(6),=C'SYSTEM'         SO SAY SO\n         MVC   ZTMSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         UNPK  ZTSYSTEM(3),ZTABCODE(2)      PUT ABEND CODE IN HEX IN\n         MVZ   ZTSYSTEM(3),=X'000000'\n         TR    ZTSYSTEM(3),=C'0123456789ABCDEF'\n         LA    #0,ZTSYSL                    GET LENGTH OF MESSAGE\n         B     TSFANYAB                     GO TO DISPLAY IT\nTSFUSRAB MVC   ZTMSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND\n         MVC   ZTMSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         XR    #0,#0\n         ICM   #0,7,ZTABCODE                GET NUMERIC USER ABEND CODE\n         CVD   #0,ZTDOUBLE                  CONVERT TO DISPLAY\n         UNPK  ZTUSER(4),ZTDOUBLE\n         OI    ZTUSER+3,X'F0'\n         LA    #0,ZTUSERL                   GET LENGTH OF MESSAGE\nTSFANYAB DS    0H\n         XR    #1,#1               INDICATE MESSAGE SET UP\n         #BAS  #14,PUTLINE         CALL PUTLINE TO DISPLAY THE MESSAGE\n         B     ABFLUSH\nTSFRC16  DS    0H                  16 = parm address in protected stg.\nTSFRC20  DS    0H                  20 = error in parameter list\nTSFRC24  DS    0H                  24 = unexpected TSO failure\nTSFRC28  DS    0H                  28 = AMODE 24 but parms are AMODE 31\n         LA    #1,=C'IKJEFTSR'     FATAL TSO SERVICE FACILITY ERROR\n         LA    #0,8\n         B     ERROR\n         SPACE\nTSFFLAGS DS    0F                  First parm to IKJEFTSR (flags)\n         DC    X'0000'             First 2 bytes must be zeroes\n         DC    X'01'               Take a dump in case of ABEND\n         DC    X'01'               Invoke as command, not as CLIST\n*                                  (so stacked commands are handled\n*                                   by us instead of IKJEFTSR)\n         EJECT\n***********************************************************************\n* THIS SUBROUTINE ISSUES A PUTGET MACRO INSTRUCTION TO DISPLAY A MODE *\n* MESSAGE (WHERE APPROPRIATE) AND RETRIEVE A COMMAND LINE FROM THE    *\n* CURRENT SOURCE OF INPUT.  IF THE PUTGET RETURNS WITH A CODE OF 12   *\n* (MEANING THAT A SECOND-LEVEL MESSAGE CHAIN IS AVAILABLE BUT THE     *\n* USER IS IN A CLIST AND THE \"NOPAUSE\" PROFILE OPTION IS ACTIVE), IT  *\n* IS RETRIED AFTER SETTING THE BIT IN THE ECT WHICH PURGES            *\n* SECOND-LEVEL MESSAGES.  IF IT RETURNS WITH A CODE OF 24 (INVALID    *\n* PARAMETERS), CONTROL IS RETURNED WITHOUT AN ERROR INDICATION - THIS *\n* IS USED TO DETERMINE IF A CLIST HAS TERMINATED.  THIS \"TRICK\" WAS   *\n* USED IN ISPF MODULE ISPCAT TO DETERMINE THE END OF A CLIST.         *\n*                                                                     *\n* UPON RETURN, #5 CONTAINS THE ADDRESS OF THE INPUT BUFFER RETURNED   *\n* BY PUTGET IF THE RETURN CODE IS 0 OR 4, ELSE #5 CONTAINS ZERO.      *\n*                                                                     *\n***********************************************************************\n         SPACE\nPUTGET   DS    0H\n         ST    #14,ZTPG14          SAVE RETURN REGISTER\nPGRETRY  DS    0H\n         MVI   ZTSTATUS,ZTNORMAL   CLEAR COMMAND STATUS FLAG\n         XR    #5,#5               SET PUTGET BUFFER ADDRESS TO ZERO\n         ST    #5,ZTECB            CLEAR ECB\n         INSYS\n         PUTGET PARM=PGPB,MF=(E,IOPL)  ISSUE PUTGET\n         OUTSYS\n         CH    #15,=H'24'          IF RETURN CODE GREATER THAN 24,\n         BH    PGERROR              THEN BLOW UP\n         B     PGGO(#15)           ELSE PROCESS EACH POSSIBLE R.C.\nPGGO     B     PGGOTLN         0 = LINE CAME FROM TERMINAL\n         B     PGGOTLN         4 = LINE CAME FROM IN-STORAGE LIST\n         B     PUTGET8         8 = ATTENTION INTERRUPTION\n         B     PUTGET12       12 = NO LINE DUE TO SECOND-LEVEL MESSAGE\n         B     PGERROR        16 = ERROR\n         B     PGERROR        20 = ERROR\n         B     PGRETURN       24 = BAD MODE MESSAGE - TERMINAL INPUT\n         SPACE\nPUTGET8  MVI   ZTSTATUS,ZTATTN     RC=8: INDICATE ATTENTION INTERRUPT\n         B     PGRETURN              AND RETURN\nPUTGET12 TM    ECTMSGF,X'80'       RC=12: IF 2ND-LVL MSGS ALRDY PURGED,\n         BO    PGERROR                    THEN UNRECOVERABLE ERROR\n         OI    ECTMSGF,X'80'         ELSE PURGE 2ND-LEVEL MESSAGE CHAIN\n         B     PGRETRY                AND REISSUE PUTGET\nPGERROR  DS    0H                  BAD RETURN CODE?\n         CH    #15,=H'40'          If RC = 40 (SUBSTACK found barrier)\n         BE    PGRETURN            then return OK, caller will handle\n         OI    ZTFLAGS,ZTSUBER     Else bad RC, unrecoverable error\n         B     PGRETURN            SO JUST RETURN.\nPGGOTLN  L     #5,PGPBIBUF         GET ADDRESS OF PUTGET INPUT BUFFER\nPGRETURN L     #14,ZTPG14          RESTORE RETURN REGISTER\n         BR    #14                 RETURN\n         EJECT\n***********************************************************************\n* THIS ROUTINE DISPLAYS MESSAGES TO THE TSO USER USING THE TSO        *\n* PUTLINE SERVICE ROUTINE.  AT ENTRY #1 CONTAINS THE ADDRESS OF THE   *\n* MESSAGE TO BE DISPLAYED, AND #0 CONTAINS THE LENGTH OF THE MESSAGE. *\n* IF #1 IS ZERO, THE MESSAGE HAS ALREADY BEEN BUILT IN THE WORKAREA   *\n* ZTMSG.  THE MESSAGE IS ASSUMED TO BEGIN WITH A MESSAGE ID UNLESS    *\n* THE FIRST CHARACTER IS BLANK, IN WHICH CASE THE INITIAL BLANK IS    *\n* STRIPPED OFF BY PUTLINE ANYHOW.                                     *\n* NOTE THAT THIS SUBROUTINE ESTABLISHES ITS OWN BASE REGISTER.  THIS  *\n* IS BECAUSE THIS SUBROUTINE IS REFERENCED BY INTERCEPT ROUTINES      *\n* WHERE THE NORMAL BASE REGISTER IS UNAVAILABLE.                      *\n***********************************************************************\n         SPACE\nPUTLINE  DS    0H\n         ST    #14,ZTPUTL14        SAVE RETURN REGISTER\n         LTR   #15,#0              LOAD LENGTH VALUE\n         BNP   PUTLRET             IF ZERO, DON'T DO ANYTHING\n         BCTR  #15,0               ELSE REDUCE LENGTH FOR EXECUTE\n         LTR   #1,#1               IF #1 IS ZERO,\n         BZ    PUTIT               THEN MESSAGE ALREADY SET UP. ELSE...\n         EX    #15,MOVEPUT         MOVE MESSAGE TO WORK AREA\nPUTIT    DS    0H\n         LA    #15,5(,#15)         RESTORE LENGTH + 4 FOR HEADER\n         SLL   #15,16              SHIFT LENGTH INTO LEFT HALF OF HDR\n         STCM  #15,15,ZTMSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR\n         XC    ZTECB,ZTECB         CLEAR ECB\n         INSYS\n         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE\n         OUTSYS\n         LTR   #15,#15             IF PUTLINE OK\n         BZ    PUTLRET             THEN RETURN\n         CH    #15,=H'8'           ELSE IF ATTENTION INTERRUPT\n         BNE   PUTERROR            THEN\n         MVI   ZTSTATUS,ZTATTN      INDICATE SO\n         B     PUTLRET             ELSE PUTLINE ERROR\nPUTERROR LA    #1,BADPUT\n         LA    #0,L'BADPUT\n         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT\n         LA    #1,ZTMSG\n         LH    #0,ZTMSGHDR\n         SH    #0,=H'4'\n         TPUT  (1),(0),R           DISPLAY MESSAGE VIA TPUT\nPUTLRET  L     #14,ZTPUTL14        RESTORE RETURN REGISTER\n         BR    #14                 RETURN\n         SPACE\nMOVEPUT  MVC   ZTMSG(0),0(#1)      MOVE MESSAGE TO WORK AREA\nBADPUT   DC    C'ZILTSO08: PUTLINE FAILURE, FOLLOWING MESSAGE IS BEING X\n               ISSUED VIA TPUT:'\n         EJECT\n***********************************************************************\n* THIS ROUTINE DELETES ELEMENTS FROM THE INPUT STACK.  IT IS USED     *\n* WHEN AN ERROR OCCURS THAT WOULD REQUIRE THAT NO MORE COMMANDS IN A  *\n* CLIST BE EXECUTED.  IT ALSO CLEARS THE TERMINAL INPUT QUEUE SO THAT *\n* ADDITIONAL COMMANDS \"STACKED\" WITH FIELD MARKS ARE NOT EXECUTED.    *\n* ON ENTRY TO THIS SUBROUTINE #1 POINTS TO THE LIST FORM OF THE STACK *\n* MACRO INSTRUCTION TO BE EXECUTED.  NORMALLY STACK DELETE=ALL WILL   *\n* BE USED; THIS FLUSHES ALL ELEMENTS FROM THE STACK EXCEPT (1) THE    *\n* BOTTOM ELEMENT, (2) ANY CLISTS WHICH HAVE CONTROL NOFLUSH OR        *\n* CONTROL MAIN ACTIVE.  FOR ATTENTION-PROVOKED FLUSHES, WE USE STACK  *\n* DELETE=TOP.  THIS DELETES THE TOP ELEMENT FROM THE STACK UNLESS IT  *\n* IS A CLIST WITH CONTROL MAIN ACTIVE.                                *\n***********************************************************************\n         SPACE\nFLUSH    DS    0H\n         ST    #14,ZTFLSH14        SAVE RETURN REGISTER\n         LR    #2,#1               GET STACK LIST FORM\n         TCLEARQ INPUT             CLEAR TERMINAL INPUT QUEUE\n         XC    ZTECB,ZTECB         CLEAR ECB\n         INSYS\n         STACK PARM=(#2),MF=(E,IOPL)  FLUSH THE STACK\n         OUTSYS\n         LTR   #15,#15             IF STACK FAILED\n         BZ    FLUSHRET            THEN SAY SO\n         LA    #1,BADSTACK\n         LA    #0,L'BADSTACK\n         #BAS  #14,PUTLINE\nFLUSHRET LA    #14,12              SET RETURN CODE TO 12 WHEN FLUSHING\n         ST    #14,ZTRETCD\n         L     #14,ZTFLSH14        RESTORE RETURN REGISTER\n         BR    #14                 RETURN\n         SPACE\nBADSTACK DC    C'ZILTSO07 TSO ERROR FLUSHING STACK'\n         SPACE\n         LTORG\n         SPACE\n         TITLE 'TSO - STAI EXIT FOR ABENDING COMMANDS'\nSTAIEXIT DS    0H\n         DROP  #3,#12\n         USING STAIEXIT,#15\n         LA    #10,12              CHECK IF REGISTER 0 = \"12\"\n         CR    #0,#10              IF AN SDWA IS AVAILABLE,\n         BE    NOSDWA              THEN...\n         L     #12,0(,#1)           #12 -> WORKAREA\n         L     #11,4(,#1)           #11 = ABEND COMPLETION CODE\n         B     AFTSDWA             ELSE...\nNOSDWA   LR    #12,#2               #12 -> WORKAREA\n         LR    #11,#1               #11 = ABEND COMPLETION CODE\n         XR    #1,#1                Clear SDWA address - ain't none\nAFTSDWA  DS    0H\n         LA    #3,4095(,#12)\n         DROP  #15\n         USING TSO,#12\n         USING TSO+4095,#3\n         ST    #1,ZTSDWA           Save address of SDWA\n         ST    #14,ZTSTAI14        SAVE RETURN REGISTER\n         L     #4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT\n         TM    ZTFLAGS,ZTDETACH    IF DETACH IN PROGRESS\n         BZ    NOT33E               AND\n         CLM   #11,7,=X'33E000'      ABEND CODE IS S33E\n         BNE   NOT33E                 THEN...\n         MVC   ZTMSG(L'ATNMSGID),ATNMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   ZTMSG1+8(L'ATTNMSG),ATTNMSG  SET UP NEXT PART OF MESSAGE\n         LA    #15,L'ATNMSGID+8+L'ATTNMSG   GET LENGTH OF ATTENTION MSG\n         B     ANYABEND                GO TO DISPLAY THE MESSAGE\nNOT33E   DS    0H\n         MVI   ZTSTATUS,ZTABEND    INDICATE COMMAND ABENDED\n         STCM  #11,7,ZTABCODE      STORE ABEND CODE\n         SPACE\n***********************************************************************\n* DISPLAY \"ENDED DUE TO ERROR\" MESSAGE                                *\n***********************************************************************\n         SPACE\n         MVC   ZTMSG(L'ABEMSGID),ABEMSGID   SET UP BEGINNING OF MESSAGE\n         MVC   ZTMSG1(8),ECTPCMD            PUT COMMAND NAME IN MESSAGE\n         MVC   ZTMSG1+8(L'ABEMSG1),ABEMSG1  SET UP NEXT PART OF MESSAGE\n         CLC   ZTABCODE,=X'000FFF'          IF CODE GREATER THAN 4095\n         BNH   USRABEND                     THEN MUST BE A SYSTEM ABEND\n         MVC   ZTMSG2(6),=C'SYSTEM'         SO SAY SO\n         MVC   ZTMSG2+6(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         UNPK  ZTSYSTEM(3),ZTABCODE(2)      PUT ABEND CODE IN HEX IN\n         MVZ   ZTSYSTEM(3),=X'000000'\n         TR    ZTSYSTEM(3),=C'0123456789ABCDEF'\n         LA    #15,ZTSYSL                   GET LENGTH OF MESSAGE\n         B     ANYABEND                     GO TO DISPLAY IT\nUSRABEND MVC   ZTMSG2(4),=C'USER'           ELSE SAY IT'S A USER ABEND\n         MVC   ZTMSG2+4(L'ABEMSG2),ABEMSG2  FINISH UP MESSAGE\n         XR    #0,#0\n         ICM   #0,7,ZTABCODE                GET NUMERIC USER ABEND CODE\n         CVD   #0,ZTDOUBLE                  CONVERT TO DISPLAY\n         UNPK  ZTUSER(4),ZTDOUBLE\n         OI    ZTUSER+3,X'F0'\n         LA    #15,ZTUSERL                  GET LENGTH OF MESSAGE\nANYABEND DS    0H\n         LA    #15,4(,#15)         ADD 4 TO LENGTH FOR HEADER\n         SLL   #15,16              SHIFT LENGTH INTO LEFT HALF OF HDR\n         STCM  #15,15,ZTMSGHDR     PUT ZEROES INTO RIGHT HALF OF HDR\n         XC    ZTECB,ZTECB         CLEAR ECB\n         PUTLINE PARM=PTPB,MF=(E,IOPL)  ISSUE PUTLINE\n         LTR   #15,#15             IF PUTLINE OK\n         BZ    STAIPTRT            THEN RETURN\n         CH    #15,=H'8'           ELSE IF ATTENTION INTERRUPT\n         BNE   STAIPTER            THEN\n         MVI   ZTSTATUS,ZTATTN      INDICATE SO\n         B     STAICONT\nSTAIPTER LA    #1,BADPUT           ELSE PUTLINE ERROR\n         LA    #0,L'BADPUT\n         TPUT  (1),(0),R           TELL USER PUTLINE FAILED VIA TPUT\n         LA    #1,ZTMSG\n         LH    #0,ZTMSGHDR\n         SH    #0,=H'4'\n         TPUT  (1),(0),R           DISPLAY MESSAGE VIA TPUT\nSTAIPTRT DS    0H\n         SPACE\nSTAICONT L     #2,ZTSTAI14         Get return register\n         LA    #15,16              Set return code in case no SDWA\n         ICM   #10,15,ZTSDWA       Get SDWA address\n         BZR   #2                  If none, just branch back w/rc=16\n         SETRP WKAREA=(#10),RC=16  Let ABEND continue without ESTAI\n         BR    #2                  Return to caller\n         SPACE\nABEMSGID DC    C'ZILTSO03 '\nABEMSG1  DC    C' ENDED DUE TO ERROR, '\nABEMSG2  DC    C' ABEND CODE '\n         SPACE\nATNMSGID DC    C'ZILTSO04 '\nATTNMSG  DC    C' TERMINATED BY ATTENTION INTERRUPTION'\n         SPACE\n         LTORG\n         SPACE\n         TITLE 'TSO - STAE EXIT FOR INTERNAL ABEND'\nSTAEEXIT DS    0H\n         DROP  #3,#12\n         USING STAEEXIT,#15\n         LA    #10,12              CHECK IF REGISTER 0 = \"12\"\n         CR    #0,#10              IF AN SDWA IS AVAILABLE,\n         BE    NOSDWAE             THEN...\n         L     #12,0(,#1)           #12 -> WORKAREA\n         B     AFTSDWAE            ELSE...\nNOSDWAE  LR    #12,#2               #12 -> WORKAREA\nAFTSDWAE DS    0H\n         LA    #3,4095(,#12)\n         DROP  #15\n         USING TSO,#12\n         USING TSO+4095,#3\n         L     #4,CPPLECT          ESTABLISH ADDRESSABILITY TO ECT\n         MVC   ECTIOWA(4),ZTSVIOA  RESTORE ECT INPUT STACK ADDRESS\n         MVC   ECTPCMD(16),ZTCMDS  RESTORE ECT COMMAND/SUBCOMMAND NAMES\n         XR    #15,#15             CONTINUE WITH ABNORMAL TERMINATION\n         BR    #14                 AND RETURN\n         SPACE\n         LTORG\n         SPACE\n         TITLE 'TSO - STAX EXIT FOR ATTENTION INTERRUPT'\nSTAXEXIT DS    0H\n         SPACE\n         DROP  #3,#12\n         USING STAXEXIT,#15\n         L     #12,8(,#1)          GET ADDRESS OF USER PARAMETER LIST\n         LA    #3,4095(,#12)\n         DROP  #15\n         USING TSO,#12\n         USING TSO+4095,#3\n         LR    #9,#14              SAVE RETURN ADDRESS\n         STATUS STOP               MAKE SUBTASK NONDISPATCHABLE\n         MVI   ZTSTATUS,ZTATTN     INDICATE ATTENTION OCCURRED\n         POST  ZTECB,0             POST SERVICE ROUTINES ECB\n         POST  ZTATNECB,0          POST ECB FOR COMMAND ATTACH\n         BR    #9                  RETURN TO SYSTEM\n         SPACE\n         LTORG\n         SPACE\n         TITLE 'TSO - DATA AREAS'\n         SPACE\nZTDOUBLE DS    D                   FOR NUMERIC CONVERSIONS\nZTSCAN14 DS    A                   SAVE AREA FOR SCAN SUBROUTINE\nZTCKCM14 DS    A                   SAVE AREA FOR CKCMD SUBROUTINE\nZTATT14  DS    A                   SAVE AREA FOR ATTACH SUBROUTINE\nZTPUTL14 DS    A                   SAVE AREA FOR PUTLINE SUBROUTINE\nZTPG14   DS    A                   SAVE AREA FOR PUTGET SUBROUTINE\nZTFLSH14 DS    A                   SAVE AREA FOR FLUSH SUBROUTINE\nZTSTAI14 DS    A                   SAVE AREA FOR STAI EXIT ROUTINE\nZTECB    DS    F                   ECB FOR TSO SERVICE ROUTINES\nZTCMDECB DS    F                   ECB FOR ATTACHED COMMANDS\nZTATNECB DS    F                   ECB FOR ATTENTION INTERRUPTIONS\nZTECBLST DS    2A                  ECB LIST\nZTE2ADDR DS    A                   Address of IKJEFTE2\nZTSDWA   DS    A                   Address of SDWA\nLINKDCB  DS    A                   Address of SYS1.LINKLIB DCB\n         SPACE\nCPPL     DS    0F                  COMMAND PROCESSOR PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJCPPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *\n*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *\n***********************************************************************\n         SPACE\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n         SPACE 2\nIOPL     DS    0F                  I/O SERVICE ROUTINE PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJIOPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n         SPACE\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n         SPACE 2\nDAPL     DS    0F                  DYNAMIC ALLOCATION PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJDAPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *\n*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *\n*    VIA REGISTER 1\n***********************************************************************\n         SPACE\nDAPLUPT  DS    A        PTR TO UPT\nDAPLECT  DS    A        PTR TO ECT\nDAPLECB  DS    A        PTR TO CP'S ECB\nDAPLPSCB DS    A        PTR TO PSCB\nDAPLDAPB DS    A        PTR TO DAIR PARAMETER BLOCK\n         SPACE\nDAPB2C   DS    0F                  DAIR PARAMETER LIST FOR CODE 2C\n         SPACE\n***********************************************************************\n* COPIED FROM SYS1.MACLIB(IKJDAP2C) BECAUSE THE MACRO FORCES A DSECT  *\n***********************************************************************\n* THIS OPERATION CODE ALLOWS FOR RE-USE  OF TIOT ENTRIES              *\n* IT IS USED BY THE TMP BEFORE DETACHING A TASK, AND BY ANY  TASK     *\n* WHICH ATTACHES SUB-TASKS                                            *\n***********************************************************************\n         SPACE\nDA2CCD   DS    CL2      DAIR ENTRY CODE\nDA2CFLG  DS    H        FLAG FIELD\nDA2CTCB  DS    A        TCB ADDR OF DSE ENTRIES MARKED NOT IN USE\nDA2CDDN  DS    CL8        DDNAME\n         SPACE\nZTNEWECT DS    A                   @ of ECT created by ENVIRON=CREATE\nZTRETCD  DS    F                   RETURN CODE FROM COMMAND\nZTDAIRRC DS    F                   RETURN CODE FROM IKJDAIR\nZTSVIOA  DS    F                   SAVE INPUT STACK ADDRESS\nZTSCANRC DS    H                   RETURN CODE FROM IKJSCAN\nZTOFFSET DS    H                   SAVED OFFSET OF POSSIBLE CLIST NAME\nZTCMDS   DS    CL16                SAVED ECT COMMAND AND SUBCOMMAND\nZTCOMMND DS    CL8                 COMMAND NAME FROM SCAN\nZTMODULE DS    CL8                 MODULE NAME FOR COMMAND\nZTBLDL   DS    F                   BLDL LIST FOR COMMAND CHECK\nZTBLDNAM DS    CL8                 MODULE NAME FOR COMMAND\n         DS    XL4                 FILLER FOR BLDL\nZTABCODE DS    XL3                 ABEND CODE STORED BY STAI EXIT\nZTFLAGS  DS    X                   FLAGS\nZTEXEC   EQU   B'10000000'          1 = IMPLICIT EXEC COMMAND (%)\nZTSTKMOD EQU   B'01000000'          1 = ECT INPUT STACK ADDR ALTERED\nZTECTMOD EQU   B'00100000'          1 = ECT PCMD/SCMD WAS ALTERED\nZTESTON  EQU   B'00010000'          1 = ESTAE SUCCESSFUL\nZTSTXON  EQU   B'00001000'          1 = STAX SUCCESSFUL\nZTSUBER  EQU   B'00000100'          1 = SEVERE ERROR IN SUBROUTINE\nZTDETACH EQU   B'00000010'          1 = DETACH IN PROGRESS\nZTAUTH   EQU   B'00000001'          1 = command requires authorization\nZTSTATUS DS    X                   COMMAND STATUS FLAG\nZTNORMAL EQU   0                    COMMAND COMPLETED NORMALLY\nZTATTN   EQU   1                    ATTENTION INTERRUPT OCCURRED\nZTABEND  EQU   2                    ABNORMAL TERMINATION OCCURRED\nZTTSOE   DS    X                   Level of TSO/Extensions active\n         SPACE\nPTPB     PUTLINE MF=L,OUTPUT=(*-*,TERM,SINGLE,INFOR)\n         ORG   PTPB                PUTLINE PARAMETER BLOCK\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJPTPB)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE PUTLINE PARAMETER BLOCK (PTPB) IS POINTED TO BY THE PARAM.   *\n*    LIST PASSED TO PUTLINE.  IT IS USED TO RETURN PERTINENT INFO.    *\n*    AS WELL AS CONTROL PUTLINE FUNCTIONS                             *\n***********************************************************************\n         SPACE\n         DS    0F\n         DS    CL4      INTERNAL PUTLINE USAGE\nPTPBOPUT DS    A        ADDRESS OF OUTPUT LINE DESCRIPTOR OR DATA LINE\nPTPBFLN  DS    A        PTR TO FORMATTED LINE RETURNED WHEN OUTPUT=\n*                       ADDR,FORMAT) IS SPECIFIED\n         ORG\n         SPACE\nPGPB     PUTGET  MF=L,OUTPUT=(*-*,,MODE)\nPGPBL    EQU   *-PGPB\nPGPBSUB  PUTGET  MF=L,OUTPUT=(*-*,,MODE),SUBSTACK=YES\nPGPBSUBL EQU   *-PGPBSUB\n         ORG   PGPB                PUTGET PARAMETER BLOCK\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJPGPB)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE PUTGET PARAMETER BLOCK (PGPB) IS POINTED TO BY THE LIST      *\n*    PASSED TO PUTGET.  PUTGET USES IT FOR CONTROL AS WELL AS         *\n*    RETURNING INFORMATION.                                           *\n***********************************************************************\n         SPACE\n         DS    0F\n         DS    CL12     INTERNAL TO GETLINE/PUTLINE\nPGPBIBUF DS    A        PTR TO OBTAINED INPUT LINE\n         ORG\n         SPACE\nSTKINIT  STACK MF=L,DATASET=*      STACK TERMINAL ELEMENT LIST FORM\nFLUSHALL STACK MF=L,DELETE=ALL     NORMAL STACK FLUSH LIST FORM\nFLUSHTOP STACK MF=L,DELETE=TOP     ATTN STACK FLUSH LIST FORM\nSTKECREA STACK MF=L,ENVIRON=CREATE  TSO/E Version 2 ECT builder\nSTKEDEST STACK MF=L,ENVIRON=DESTROY TSO/E Version 2 ECT remover\nSTKBARR  STACK MF=L,BARRIER=*\nSTKDELB  STACK MF=L,DELETE=BARRIER\nZTATTACH ATTACH SF=L,SHSPV=78,SZERO=NO\nZTESTAE  ESTAE MF=L\nZTSTAX   STAX  MF=L,REPLACE=NO\n         SPACE\nMODEDATA DC    Y(MODELEN,0)\nMODEMSG  DC    C' TSO'             LEADING BLANK REQUIRED - NO MSGID\nMODELEN  EQU   *-MODEDATA\n         SPACE\n***********************************************************************\n* MESSAGES                                                            *\n***********************************************************************\n         SPACE\nSYNMSG   DC    C'ZILTSO01 INVALID COMMAND SYNTAX'\nTERMMSG  DC    C'ZILTSO05 COMMAND INPUT IGNORED, CLIST HAS TERMINATED'\nERRMSG1  DC    C'ZILTSO06 TSO FAILED, '\nERRMSG2  DC    C' ERROR CODE '\n         SPACE\n         LTORG\n         EJECT\n         SPACE\n***********************************************************************\n* Fields used by the TSO Authorized Service Facility                  *\n***********************************************************************\n         SPACE\nZTTSFP1  DS    A                   TSO Service Facility parameter 1\nZTTSFP2  DS    A                   TSO Service Facility parameter 2\nZTTSFP3  DS    A                   TSO Service Facility parameter 3\nZTTSFP4  DS    A                   TSO Service Facility parameter 4\nZTTSFP5  DS    A                   TSO Service Facility parameter 5\nZTTSFP6  DS    A                   TSO Service Facility parameter 6\nZTTSFRC  DS    A                   Return code from TSO command\nZTTSFRS  DS    A                   Reason code from TSO command\nZTTSFAC  DS    A                   Abend code from TSO command\nZTTSFLEN DS    A                   Length of command\n         SPACE\n***********************************************************************\n* PUTGET MODE MESSAGE AREA                                            *\n***********************************************************************\n         SPACE\nZTPGOLD  DS    A(1)                NUMBER OF MESSAGE SEGMENTS\nZTPGPTR  DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT\nZTPGHDR  DS    2Y                  MESSAGE HEADER\nZTPGMODE DS    CL(L'MODEMSG)       MESSAGE TEXT\n         SPACE\n***********************************************************************\n* WORKAREA FOR CONSTRUCTING PUTLINE MESSAGES                          *\n* NOTE: THIS IS SET UP FOR SINGLE-LEVEL INFORMATIONAL MESSAGES ONLY.  *\n***********************************************************************\n         SPACE\nZTMSGOLD DS    A(1)                NUMBER OF MESSAGE SEGMENTS\nZTMSGPTR DS    A                   ADDRESS OF THE ONLY MESSAGE SEGMENT\nZTMSGHDR DS    2Y                  MESSAGE HEADER\nZTMSG    DS    CL128               MESSAGE TEXT\nZTMSG1   EQU   ZTMSG+L'ABEMSGID    OFFSET OF \"ENDED DUE TO ERROR\"\nZTMSG2   EQU   ZTMSG1+8+L'ABEMSG1  OFFSET OF \"SYSTEM\" OR \"USER\"\nZTSYSTEM EQU   ZTMSG2+6+L'ABEMSG2  OFFSET OF SYSTEM ABEND CODE\nZTUSER   EQU   ZTMSG2+4+L'ABEMSG2  OFFSET OF USER ABEND CODE\nZTSYSL   EQU   ZTSYSTEM+3-ZTMSG    LENGTH OF SYSTEM ABEND MESSAGE\nZTUSERL  EQU   ZTUSER+4-ZTMSG      LENGTH OF USER ABEND MESSAGE\n         SPACE 2\nCSPL     DS    0D                  COMMAND SCAN PARAMETER LIST\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJCSPL)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE COMMAND SCAN PARAMETER LIST (CSPL) IS A LIST OF ADDRESSES    *\n*    PASSED FROM THE INVOKER TO COMMAND SCAN VIA REGISTER 1           *\n***********************************************************************\n         SPACE\nCSPLUPT  DS    A        PTR TO  UPT\nCSPLECT  DS    A        PTR TO  ECT\nCSPLECB  DS    A        PTR TO  CP'S ECB\nCSPLFLG  DS    A        PTR TO  FLAG WORD WHICH IS OBTAINED & FREED\n*                       BY CALLER. BIT 0 SET TO 0= SYNTAX CHECKING OF\n*                       COMMAND NAME.\nCSPLOA   DS    A        PTR TO OUTPUT AREA (CSOA DSECT)\nCSPLCBUF DS    A        PTR TO COMMAND BUFFER\n         SPACE\nCSOA     DS    0H                  COMMAND SCAN OUTPUT AREA\n         SPACE\n***********************************************************************\n* COPIED FROM 'SYS1.MACLIB(IKJCSOA)' BECAUSE THE MACRO FORCES A DSECT *\n***********************************************************************\n*    THE COMMAND SCAN OUTPUT AREA (CSOA) IS AN AREA POINTED TO        *\n*    BY THE CSPL.  IT IS USED BY COMMAND SCAN TO INDICATE ITS         *\n*    FINDINGS.  IT IS OBTAINED AND FREED BY THE INVOKER               *\n***********************************************************************\n         SPACE\nCSOACNM  DS    A        PTR TO COMMAND NAME-IF 0 INVALID CMD NAME\nCSOALNM  DS    H        LENGTH OF CMD NAME\nCSOAFLG  DS    X        FLAGS\nCSOAVWP  EQU   X'80'    VALID WITH PARAMETERS\nCSOAVNP  EQU   X'40'    VALID NO   PARAMS\nCSOAQM   EQU   X'20'    QUESTION MARK\nCSOANOC  EQU   X'10'    NO COMMAND\nCSOABAD  EQU   X'08'    BAD CMD NAME\nCSOAEXEC EQU   X'04'    IMPLICIT EXEC COMMAND NAME\n         DS    CL1      RESERVED\n         SPACE\nZTCSFLG  DS    F                   COMMAND SCAN FLAG WORD\n         SPACE 2\n         EJECT\n         SPACE 1\n         LTORG\n         EJECT\n         IKJECT\n         EJECT\n         IKJPSCB\n         EJECT\n         IKJRLGB\n         EJECT\n         IKJEFLWA\n         EJECT\n         IKJTSVT\n         EJECT\n         IKJSTPB\n         EJECT\n         PRINT NOGEN\n         IHASDWA\n         IEZJSCB\n         IKJTCB\n         IHAASCB\n         IHAASXB\n         IHAPSA\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNEBCDIC": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11F\\x00(\\x00%\\x00'\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:46:00", "lines": 40, "newlines": 37, "modlines": 39, "user": "SEB1525"}, "text": "         TITLE 'UNEBCDIC - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* UNEBCDIC TAKES ONE ARGUMENT - A ONE-CHARACTER SYMBOL OR STRING      *\n* TO BE CONVERTED TO A FIXNUM (USED AS A \"CHARACTER OBJECT\").         *\n* THIS IS USED BY THE #/ AND #\\ READER MACROS.                        *\n***********************************************************************\n         SPACE\nUNEBCDIC #ZBEG MINARGS=1,MAXARGS=1,NAME='UNEBCDIC'\n         SPACE\n         L     #7,0(,#1)           GET ARG 1\n         CLI   ##TYPE(#7),##STRING IF ARG IS A STRING\n         BE    PROCESS             THEN GO AHEAD AND PROCESS IT\n         CLI   ##TYPE(#7),##SYMBOL IF ARG 1 IS A SYMBOL\n         BNE   ERROR1              THEN OK, ELSE ERROR\n         L     #7,##PNAME(,#7)     IF A SYMBOL, GET THE PRINT NAME\nPROCESS  DS    0H\n         XR    #2,#2               CLEAR INSERT REGISTER\n         CLC   1(3,#7),=AL3(1)     IF LENGTH IS NOT 1\n         BNE   ERROR1              THEN ERROR\n         IC    #2,##VECDAT(,#7)    PICK UP CHARACTER TO BE NUMBERIZED\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Load address of fixnum from table\n         BR    #14\n         SPACE 1\n         DROP  #15\n         SPACE 1\nERROR1   DS    0H                  IF NOT 1, ERROR\n         LR    #2,#15\n         USING UNEBCDIC,#2\n         L     #7,0(,#1)           GET ARG 1\n         #ERR  'Argument to UNEBCDIC not a 1-character string - ',     X\n               (#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNWORD": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11F\\x00#\\x00 \\x00\"\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:46:00", "lines": 35, "newlines": 32, "modlines": 34, "user": "SEB1525"}, "text": "         TITLE 'UNWORD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* UNWORD TAKES ONE ARGUMENT - A FOUR-CHARACTER SYMBOL OR STRING       *\n* TO BE CONVERTED TO A FIXNUM (USED AS A \"CHARACTER OBJECT\").         *\n***********************************************************************\n         SPACE\nUNWORD   #ZBEG MINARGS=1,MAXARGS=1,NAME='UNWORD'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #1,0(,#11)          GET ARG 1\n         CLI   ##TYPE(#1),##STRING IF ARG IS A STRING\n         BE    PROCESS             THEN GO AHEAD AND PROCESS IT\n         CLI   ##TYPE(#1),##SYMBOL IF ARG 1 IS A SYMBOL\n         BNE   ERROR1              THEN OK, ELSE ERROR\n         L     #1,##PNAME(,#1)     IF A SYMBOL, GET THE PRINT NAME\nPROCESS  DS    0H\n         CLC   1(3,#1),=AL3(4)     IF LENGTH IS NOT 4\n         BNE   ERROR1              THEN ERROR\n         L     #2,##VECDAT(,#1)    PICK UP CHARACTER TO BE NUMBERIZED\n         LA    #0,16(,#11)         PASS CURRENT STACK POINTER TO CONS\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   DS    0H                  IF NOT 1, ERROR\n         #ERR  'Argument to UNWORD not a 4-character string - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UPCASE": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11F\\x00l\\x00i\\x00k\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:46:00", "lines": 108, "newlines": 105, "modlines": 107, "user": "SEB1525"}, "text": "         TITLE 'UPCASE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS IS STRING-UPCASE.                                              *\n*                                                                     *\n***********************************************************************\nUPCASE   #ZBEG MINARGS=1,MAXARGS=1,NAME='STRING-UPCASE'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #3,0(,#11)          LOAD ARG1\n         CLI   ##TYPE(#3),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#3),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #3,##PNAME(,#3)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ST    #3,0(,#11)          STORE BACK ON STACK FOR FUTURE USE\n         ICM   #7,7,1(#3)          GET LENGTH OF STRING\n         BZ    RETSELF             IF ZERO-LENGTH STRING, RETURN SELF\n         LA    #14,##VECDAT(,#3)   POINT TO TEXT OF STRING\n         LR    #15,#7              GET LENGTH\n         LA    #0,256              SET UP CONSTANT 256\nTRTLOOP  DS    0H                  LOOP TO SCAN STRING\n         CR    #15,#0\n         BNH   SHORTTRT\n         TRT   0(256,#14),TRTTABLE SCAN FOR LOWER CASE CHARACTERS\n         BNZ   COPYIT              IF WE FOUND ONE, WE HAVE TO COPY\n         AR    #14,#0              ELSE BUMP UP POINTER TO TEXT\n         SR    #15,#0              BUMP DOWN LENGTH\n         B     TRTLOOP             AND CONTINUE SCANNING.\nSHORTTRT DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         EX    #15,EXTRT           SCAN FOR LOWEE CASE CHARACTERS\n         BZ    RETSELF             IF NO BAD CHARS, RETURN SELF\nCOPYIT   DS    0H                  LOWERCASE DATA, HAVE TO COPY\n         LR    #2,#7               GET LENGTH INTO REG FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #4,#15              IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         L     #1,0(,#11)          GET POINTER TO ORIGINAL STRING\n         LA    #0,##VECDAT(,#1)    POINT TO STRING TEXT\n         LA    #14,##VECDAT(,#4)   POINT TO WHERE TO MOVE STRING TEXT\n         LR    #1,#7               GET LENGTH OF STRING TEXT TO MOVE\n         LR    #15,#7\n         MVCL  #14,#0              MOVE TEXT FROM OLD STRING TO NEW\n         LA    #14,##VECDAT(,#4)   POINT TO TEXT OF STRING\n         LR    #15,#7              GET LENGTH\n         LA    #0,256              SET UP CONSTANT 256\nTRLOOP   DS    0H                  LOOP TO TRANSLATE STRING\n         CR    #15,#0\n         BL    SHORTTR\n         TR    0(256,#14),TRTABLE  TRANSLATE TO UPPER CASE\n         AR    #14,#0              ELSE BUMP UP POINTER TO TEXT\n         SR    #15,#0              BUMP DOWN LENGTH\n         BZ    DONE\n         B     TRLOOP              AND CONTINUE TRANSLATING.\nSHORTTR  DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         EX    #15,EXTR            TRANSLATE TO UPPER CASE\nDONE     DS    0H                  ALL FINISHED\n         LR    #15,#4              POINT TO NEWLY BUILT STRING\n         B     RETURN              RETURN THE ATOM IN #15\n         SPACE 1\nRETSELF  DS    0H                  NULL STRING (OR NO LOWERCASE CHARS?)\n         LR    #15,#3              RETURN THE STRING PASSED\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nEXTRT    TRT   0(*-*,#14),TRTTABLE EXECUTED: SCAN FOR LOWERCASE CHARS\nEXTR     TR    0(*-*,#14),TRTABLE  EXECUTED: TRANSLATE TO UPPERCASE\n         SPACE 1\nTRTTABLE DC    256X'00'            TABLE TO SCAN FOR LOWERCASE CHARS\n         ORG   TRTTABLE+C'A'-X'40'\n         DC    9XL1'FF'\n         ORG   TRTTABLE+C'J'-X'40'\n         DC    9XL1'FF'\n         ORG   TRTTABLE+C'S'-X'40'\n         DC    8XL1'FF'\n         ORG   ,\n         SPACE 1\nTRTABLE  DC    256YL1(*-TRTABLE)   TABLE TO TRANSLATE TO UPPERCASE\n         ORG   TRTABLE+C'A'-X'40'\n         DC    C'ABCDEFGHI'\n         ORG   TRTABLE+C'J'-X'40'\n         DC    C'JKLMNOPQR'\n         ORG   TRTABLE+C'S'-X'40'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         SPACE 1\nERROR1   #ERR  'Argument to STRING-UPCASE not a string - ',(#3)\n         SPACE 1\nERROR2   #ERR  PREFIX=NO,          NOT ENUF ROOM                       X\n               'ZIL4010 STRING-UPCASE: Not enough vector/string space tX\n               o build string.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USERID": {"ttr": 6922, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11F\\x003\\x000\\x002\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:46:00", "lines": 51, "newlines": 48, "modlines": 50, "user": "SEB1525"}, "text": "         TITLE 'USERID - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  USERID RETURNS THE TSO USERID, OR NIL IF NON-TSO ENVIRONMENT.      *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: THIS ROUTINE NEED NOT CONS UP A NEW STRING, SINCE THE         *\n*       USERID IS THE SAME THROUGHOUT THE ENTIRE ZIL SESSION.         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nUSERID   #ZBEG MINARGS=0,MAXARGS=0,NAME='USERID'\n         SPACE 1\n         TM    FLAG,X'80'          IF USERID WAS ALREADY SET\n         BO    RETSTR              THEN RETURN IT\n         L     #3,X'21C'           GET TCB ADDRESS\n         L     #3,X'B4'(,#3)       GET JSCB ADDRESS\n         L     #3,X'15C'(,#3)      GET ACTIVE JSCB ADDRESS\n         ICM   #3,15,X'108'(#3)    GET PSCB ADDRESS\n         BZ    RETNIL              IF NONE, NON-TSO, RETURN NIL\n         XR    #2,#2               CLEAR LENGTH REGISTER\n         ICM   #2,1,7(#3)          GET LENGTH OF PSCB USERID\n         STCM  #2,7,LENGTH         STORE INTO OUR STRING\n         BZ    RETSTR              IF ZERO, BYPASS DATA MOVE\n         BCTR  #2,0                REDUCE FOR EXECUTE\n         EX    #2,MOVEIT           MOVE DATA FROM PSCB TO OUR STRING\n         OI    FLAG,X'80'          INDICATE USERID SET\nRETSTR   DS    0H\n         LA    #15,STRING\n         BR    #14\nRETNIL   DS    0H\n         LR    #15,#10\n         BR    #14\n         SPACE 1\nMOVEIT   MVC   USERVAL(*-*),0(#3)  EXECUTED: MOVE PSCBUSER TO STRING\n         SPACE 1\nSTRING   DS    0A\n         DC    YL1(##STRING)\nLENGTH   DC    AL3(0)\nUSERVAL  DC    XL8'00'\n         SPACE 1\nFLAG     DC    X'00'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VALUES": {"ttr": 6924, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x15?\\x00\\x89\\x15o\\x11F\\x00+\\x00(\\x00*\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-06-01T00:00:00", "modifydate": "1989-06-05T11:46:00", "lines": 43, "newlines": 40, "modlines": 42, "user": "SEB1525"}, "text": "         TITLE 'VALUES - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* \"VALUES\"                                                            *\n*                                                                     *\n* VALUES takes an &REST argument - (a list of) forms to be returned   *\n* as multiple values.  It does this by passing control to the         *\n* ZILVALS function to perform the multiple value operation.           *\n*                                                                     *\n***********************************************************************\n         SPACE\nVALUES   #ZBEG MINARGS=0,MAXARGS=0,RESTARG=T,NAME='VALUES'\n         SPACE 1\n         USING VALUES,#15\n         SPACE 1\n         LA    #3,4(,#1)           Point to where to store values\n         L     #5,0(,#1)           Load list of values from stack\n         XR    #2,#2               Initialize value counter\nLOOP     DS    0H\n         CR    #5,#10              Until list is null,\n         BE    DONE\n         LA    #0,4(,#3)           Get stack pointer\n         #ZPDS (0)                 Check for stack overflow\n         LM    #4,#5,##CAR(#5)     Get CAR and CDR of list\n         ST    #4,0(,#3)           Store form on stack\n         LA    #2,1(,#2)           Increment value counter\n         LR    #3,#0               Increment stack pointer\n         B     LOOP\nDONE     DS    0H                  Done, #1 still points to argument\n         LA    #1,4(,#1)           Point to values on stack\n         XR    #0,#0               Signify normal VALUES operation\n         L     #15,ZLCVALS         Get address of ZILVALS\n         BR    #15                 Pass control to ZILVALS to do it\n         SPACE 1\n         #ZRET ,                   Restore registers and return\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VALUESL": {"ttr": 6926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x15?\\x00\\x89\\x15o\\x11F\\x007\\x00*\\x006\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-06-01T00:00:00", "modifydate": "1989-06-05T11:46:00", "lines": 55, "newlines": 42, "modlines": 54, "user": "SEB1525"}, "text": "         TITLE 'VALUES-LIST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* \"VALUES-LIST \"                                                      *\n*                                                                     *\n* VALUESL takes one argument - a list of forms to be returned         *\n* as multiple values.  It does this by passing control to the         *\n* ZILVALS function to perform the multiple value operation.           *\n*                                                                     *\n* CLtL, p. 135:  (values-list <list>) == (apply #'values <list>)      *\n*                                                                     *\n***********************************************************************\n         SPACE\nVALUESL  #ZBEG MINARGS=1,MAXARGS=1,NAME='VALUES-LIST'\n         SPACE 1\n         USING VALUESL,#15\n         SPACE 1\n         LA    #3,4(,#1)           Point to where to store values\n         L     #5,0(,#1)           Load list of values from stack\n         XR    #2,#2               Initialize value counter\nLOOP     DS    0H\n         CR    #5,#10              Until list is null,\n         BE    DONE\n         LA    #0,4(,#3)           Get stack pointer\n         #ZPDS (0)                 Check for stack overflow\n         LM    #4,#5,##CAR(#5)     Get CAR and CDR of list\n*                                  ...Note: This check isn't in VALUES!\n         LTR   #4,#4               If it was actually an atom,\n         BM    ERROR               then error\n         ST    #4,0(,#3)           Store form on stack\n         LA    #2,1(,#2)           Increment value counter\n         LR    #3,#0               Increment stack pointer\n         B     LOOP\nDONE     DS    0H                  Done, #1 still points to argument\n         LA    #1,4(,#1)           Point to values on stack\n         XR    #0,#0               Signify normal VALUES operation\n         L     #15,ZLCVALS         Get address of ZILVALS\n         BR    #15                 Pass control to ZILVALS to do it\n         SPACE 1\n         #ZRET ,                   Restore registers and return\n         SPACE 1\nERROR    DS    0H\n         DROP  #15\n         USING VALUESL,#3\n         LR    #3,#15\n         L     #2,0(,#1)\n         #ERR  'Argument to VALUES-LIST not a proper list - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VCOPY": {"ttr": 6928, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11F\\x002\\x00/\\x001\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:46:00", "lines": 50, "newlines": 47, "modlines": 49, "user": "SEB1525"}, "text": "         TITLE 'VCOPY - ZIL 1.3 INTERNAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This function copies a vector-type object.  Syntax:                 *\n*                                                                     *\n*  (VCOPY arg1)                                                       *\n*                                                                     *\n* The one required argument is a vector-type object to be copied.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nVCOPY    #ZBEG MINARGS=1,MAXARGS=1,NAME='VCOPY'\n         SPACE 1\n         #ZPDS 1*4+12+0\n         #ZSAV ,\n         SPACE 1\n         L     #7,0(,#11)          Get arg1\n         TM    ##TYPE(#7),##VEC    If arg1 is not a vectorish object\n         BNO   ERROR1              then error\n         XR    #2,#2               Clear insert register\n         ICM   #2,7,1(#7)          Get length of current object\n         XR    #1,#1               Entry code 0 = allocate new space\n         L     #15,ZLCVSS          Get address of string space service\n         LA    #0,16(,#11)         Set current stack location\n         #BASR #14,#15             Call ZILVSS to build new vec-object\n         LTR   #4,#4               If vector build failed\n         BZ    ERROR2              then error\n         LR    #0,#15              Get address of new object\n         L     #2,0(,#11)          Get address of old object from stack\n         XR    #3,#3               (in case it got moved by GC)\n         ICM   #3,7,1(#2)          Get length of old object\n         LA    #3,4(,#3)           Add prefix length\n         LR    #1,#3               Same as length of new object\n         MVCL  #0,#2               Copy old object to new object\nRETURN   DS    0H                  #15 points to object built\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   #ERR  'Argument to VCOPY not a vector or structure - ',0(#11)\nERROR2   #ERR  'ZIL4010 VCOPY: Not enough vector/string space to copy vX\n               ector.',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VECP": {"ttr": 6930, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11G\\x00\\x1a\\x00\\x17\\x00\\x1a\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:47:00", "lines": 26, "newlines": 23, "modlines": 26, "user": "SEB1525"}, "text": "         TITLE  'VECP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* VECP RETURNS TRUE IF ITS ARG IS A VECTOR, FUNARG OR STRUCTURE;      *\n* I.E. ANY OBJECT FORMATTED LIKE A VECTOR.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nVECP     #ZBEG MINARGS=1,MAXARGS=1,NAME='VECP'\n         SPACE 1\n         USING VECP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##VECTOR\n         BNO   ZXNVEC\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXNVEC   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VECTORP": {"ttr": 6932, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11G\\x00\\x15\\x00\\x12\\x00\\x14\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:47:00", "lines": 21, "newlines": 18, "modlines": 20, "user": "SEB1525"}, "text": "         TITLE 'VECTORP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nVECTORP  #ZBEG MINARGS=1,MAXARGS=1,NAME='VECTORP'\n         SPACE 1\n         USING VECTORP,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##VECTOR\n         BNE   ZXNVEC\n         DROP  #15\n         LR    #15,#8\n         BR    #14\nZXNVEC   LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VERIFY": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x00\\x8c\\x00\\x89\\x00\\x8b\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 140, "newlines": 137, "modlines": 139, "user": "SEB1525"}, "text": "         TITLE 'VERIFY - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (VERIFY ARG1 ARG2 &OPTIONAL ARG3)...                                *\n*                                                                     *\n*  ARG1 IS A STRING          - THE STRING TO SEARCH WITHIN            *\n*  ARG2 IS A STRING          - THE STRING OF CHARACTERS TO MATCH      *\n*  ARG3 IS A FIXNUM OR NIL   - THE STARTING OFFSET FOR THE SEARCH     *\n*                                                                     *\n* THIS IS, LIKE, REALLY A PL/1 FUNCTION, MAN.  I MEAN, TAKEN          *\n* STRAIGHT FROM THE COMPILER OBJECT CODE LISTINGS, RIGHT?             *\n*                                                                     *\n***********************************************************************\nVERIFY   #ZBEG MINARGS=2,MAXARGS=3,NAME='STRING-VERIFY'\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #5,#7,0(#11)        LOAD ARGS\n         CLI   ##TYPE(#5),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#5),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #5,##PNAME(,#5)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H                  CHECK ARG 2\n         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING\n         BE    ARG2OK              THEN OK\n         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR2              THEN\n         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR\nARG2OK   DS    0H\n         LA    #2,1                DEFAULT STARTING OFFSET IS 1\n         CR    #7,#13              IF ARG 3 IS NOT SUPPLIED\n         BE    ARGSOK              THEN IT'S OK (OMITTED)\n         CR    #7,#10              IF ARG 3 IS NIL\n         BE    ARGSOK              THEN IT'S OK\n         CLI   ##TYPE(#7),##FIXNUM IF ARG 3 IS NOT A FIXNUM\n         BNE   ERROR3              THEN ERROR\n         ICM   #2,15,##CDR(#7)     IF ARG3 PROVIDED, USE ITS VALUE\n         BNP   ERROR3\nARGSOK   DS    0H                  #2 HAS 1-BASED START\n         XR    #3,#3\n         XR    #4,#4\n         ICM   #3,7,1(#5)          #3 = LENGTH OF STRING ARG 1\n         LA    #3,1(,#3)           ADJUST FOR ONE-BASEDNESS AND\n         SR    #3,#2               ADJUST FOR OFFSET\n         BNP   RETNIL              IF ARG1 IS NULL STRING, RETURN NIL\n         ICM   #4,7,1(#6)          #4 = LENGTH OF STRING ARG 2\n         BZ    RET1                IF ARG2 IS NULL STRING, RETURN 1\n*\n* #2 - 1-BASED START OF WHERE TO SCAN ARG1\n* #3 - LENGTH OF STRING ARG1 MINUS OFFSET\n* #4 - LENGTH OF STRING ARG2\n* #5 - THE STRING ARG1\n* #6 - THE STRING ARG2\n*\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* BUILD TRANSLATE TABLE FROM STRING ARG2                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVI   TRTBL,X'FF'         INITIALIZE TABLE TO STOP AT ALL\n         MVC   TRTBL+1(255),TRTBL   CHARACTERS BY SETTING TO FF\n         LA    #1,##VECDAT(,#6)    POINT TO TEXT OF STRING ARG2\n         XR    #15,#15             CLEAR INSERT REGISTER\n         XR    #0,#0               SET VALUE TO STICK INTO TABLE\n         LR    #14,#4              GET LENGTH OF STRING ARG2 (NOT 0)\nTBLDLOOP DS    0H\n         IC    #15,0(,#1)          GET CHARACTER FROM STRING ARG2\n         STC   #0,TRTBL(#15)       SET TABLE CHARACTER TO FLAG AS \"OK\"\n         LA    #1,1(,#1)           INCREMENT CHARACTER POINTER\n         BCT   #14,TBLDLOOP        CONTINUE UNTIL ARG2 EXHAUSTED\nTBLDEND  DS    0H                  NOW THE TABLE IS BUILT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SCAN THE STRING ARG1 USING THE TABLE                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    #14,##VECDAT-1(#2,#5) POINT TO TEXT OF STRING + OFFSET\n         LR    #15,#3              GET LENGTH OF STRING ARG1 - OFFSET\n         LA    #0,256              SET UP CONSTANT 256\nTRTLOOP  DS    0H                  LOOP TO SCAN STRING\n         CR    #15,#0\n         BNH   SHORTTRT\n         TRT   0(256,#14),TRTBL    SCAN FOR CHARACTERS NOT IN ARG2\n         BNZ   FOUNDONE            IF WE FOUND ONE, SET RESULT\n         AR    #14,#0              ELSE BUMP UP POINTER TO TEXT\n         SR    #15,#0              BUMP DOWN LENGTH\n         B     TRTLOOP             AND CONTINUE SCANNING.\nSHORTTRT DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         EX    #15,EXTRT           SCAN FOR CHARACTERS NOT IN ARG2\n         BZ    RETNIL              IF NO BAD CHARS, RETURN NIL\nFOUNDONE DS    0H                  FOUND A CHAR NOT IN ARG2\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* SET BY TRT:                                                         *\n*                                                                     *\n* #1 CONTAINS THE ADDRESS OF THE \"BAD\" CHARACTER                      *\n* #2 CONTAINS THE BYTE FROM THE TABLE, BUT WE DON'T CARE ABOUT THAT   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    #2,0(,#1)           GET POINTER TO BAD CHAR FROM TRT\n         LA    #0,##VECDAT-1(,#5)  GET ADDRESS OF ARG1 TEXT, ADJUSTED\n         SR    #2,#0               TO CONVERT TO 1-BASED INDEX THEREOF\n         SPACE 1\nGOTIT    DS    0H                  #2 CONTAINS INDEX OF \"BAD\" CHAR\n         LA    #0,24(,#11)         PASS CURRENT STACK POINTER TO CONS\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         B     RETURN\nRET1     DS    0H                  ALL CHARACTERS ARE \"BAD\"\n         LA    #15,#SFT1           SO RETURN FIXNUM 1\n         B     RETURN\nRETNIL   DS    0H                  NO \"BAD\" CHARACTERS IN STRING\n         LR    #15,#10             RETURN NIL\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nEXTRT    TRT   0(*-*,#14),TRTBL    SCAN FOR CHARACTERS NOT IN ARG2\n         SPACE 1\nTRTBL    DS    XL256               AREA TO BUILD TRANSLATE TABLE\n         SPACE 1\nERROR1   #ERR  'Argument 1 to STRING-VERIFY not a string - ',0(#11)\nERROR2   #ERR  'Argument 2 to STRING-VERIFY not a string - ',4(#11)\nERROR3   #ERR  'Argument 3 to STRING-VERIFY not a positive fixnum - ', X\n               8(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VFILL": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x07\\x00\\x88\\x01_\\x01\\x00&_\\x16B\\x00*\\x00'\\x00)\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:42:07", "lines": 42, "newlines": 39, "modlines": 41, "user": "SEB1525"}, "text": "         TITLE 'VFILL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE FILLS A VECTOR WITH A SPECIFIED ELEMENT.            *\n*                                                                     *\n* IT TAKES TWO REQUIRED ARGUMENTS - A VECTOR AND A FILL VALUE - AND   *\n* INITIALIZES THE SLOTS OF THE VECTOR TO THAT VALUE.                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nVFILL    #ZBEG MINARGS=2,MAXARGS=2,NAME='VFILL'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING VFILL,#3\n         SPACE 1\n         LM    #15,#0,0(#1)        LOAD ARGS\n         XR    #7,#7               CLEAR INSERT REG\n         CLI   ##TYPE(#15),##VECTOR  IF ARG1 IS NOT A VECTOR\n         BNE   ERROR1              THEN ERROR.  ELSE...\n         ICM   #7,7,1(#15)         GET LENGTH OF VECTOR\n         BZR   #14                 IF NULL VECTOR, DO NOTHING\n         LA    #4,##VECDAT(,#15)   POINT TO VECTOR ELEMENTS\n         LA    #6,4                SET INCREMENT REGISTER FOR BXLE\n         XR    #1,#1               SET INDEX REGISTER\n         BCTR  #7,0                SET TERMINATION REGISTER FOR BXLE\nFILLLOOP ST    #0,0(#1,#4)         INITIALIZE EACH ELEMENT TO ARG2\n         BXLE  #1,#6,FILLLOOP\n         BR    #14                 #15 POINTS TO VECTOR FILLED\n         SPACE 1\nERROR1   DS    0H\n         LR    #2,#15\n         #ERR  'Argument 1 to VFILL not a vector - ',(#2)\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VLENGTH": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x00&\\x00#\\x00%\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 38, "newlines": 35, "modlines": 37, "user": "SEB1525"}, "text": "         TITLE 'VLENGTH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* VLENGTH TAKES ONE ARGUMENT - A VECTOR-TYPE OBJECT.                  *\n*                                                                     *\n***********************************************************************\nVLENGTH  #ZBEG MINARGS=1,MAXARGS=1,NAME='VLENGTH'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ARGS=1              SAVE REGISTERS\n         SPACE\n         L     #1,0(,#11)          LOAD FIRST (AND ONLY) ARGUMENT\n         XR    #2,#2               CLEAR INSERT REGISTER\n         TM    ##TYPE(#1),##VEC    IF ARGUMENT IS NOT A VECTOR\n         BNO   ERROR1              THEN ERROR\n         ICM   #2,7,1(#1)          GET LENGTH OF VECTOR TEXT\n         SRA   #2,2                DIVIDE BY 4 TO GET # OF ELEMENTS\n         CL    #2,ZLCSFTHI         If within small fixnum range\n         BNH   SMALLFIX            then go to return fixnum from table\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXED ATOM\n         B     RETURN\nSMALLFIX DS    0H                  Return small fixnum from table\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Return small fixnum from table\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   DS    0H                  INVALID ARGUMENT\n         #ERR  'Argument to VLENGTH not a vector - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VLIST": {"ttr": 7176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x002\\x00/\\x001\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 50, "newlines": 47, "modlines": 49, "user": "SEB1525"}, "text": "         TITLE 'VLIST - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* VLIST TAKES 1 ARGUMENT - A VECTOR TO CONVERT TO A LIST              *\n***********************************************************************\n         SPACE\nVLIST    #ZBEG MINARGS=1,MAXARGS=1,NAME='VLIST'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n*\n* CHECK INPUT ARGUMENT - MUST BE A VECTOR-TYPE OBJECT\n*\n         L     #6,0(,#11)          GET ARG 1\n         TM    ##TYPE(#6),##VEC    MUST BE A VECTOR\n         BNO   ERROR1              OR ELSE\n*\n* FOR EACH WORD IN THE VECTOR, ADD IT TO THE LIST.\n* WE GO BACKWARDS TO FACILITATE CONSING THEM TOGETHER TO MAKE A LIST.\n*\n         XR    #3,#3               CLEAR INSERT REGISTER\n         ST    #10,16(,#11)        INITIALIZE OUTPUT LIST TO NIL\n         ICM   #3,7,1(#6)          GET LENGTH OF VECTOR DATA\n         BZ    RETLIST             IF ZERO, RETURN NIL\n         LA    #5,##VECDAT-4(,#3)  INDEX TO LAST WORD IN VECTOR\n         LA    #0,20(,#11)         SET STACK POINTER FOR CONS\n         LA    #4,4\nLOOP     DS    0H\n         L     #6,0(,#11)          RELOAD VECTOR ARG FROM STACK\n         L     #1,0(#5,#6)         LOAD VECTOR ELEMENT\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         L     #2,16(,#11)         ARG 2 TO CONS = LIST SO FAR\n         #BASR #14,#15             CALL CONS TO ADD NEW ATOM TO LIST\n         ST    #15,16(,#11)        (SETQ LIST (CONS ELEMENT LIST))\n         SR    #5,#4\n         BNZ   LOOP                CONTINUE UNTIL HIT START OF VECTOR\nRETLIST  DS    0H\n         L     #15,16(,#11)        RETURN THE LIST\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nERROR1   DS    0H\n         #ERR  'Argument to VLIST not a vector - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VREF": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x00+\\x00(\\x00*\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 43, "newlines": 40, "modlines": 42, "user": "SEB1525"}, "text": "         TITLE 'VREF - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nVREF     #ZBEG MINARGS=2,MAXARGS=2,NAME='VREF'\n         SPACE 1\n         USING VREF,#15\n         LM    #2,#3,0(#1)         LOAD ARGUMENTS\n         TM    ##TYPE(#2),##VEC    IF ARG1 IS NOT A VECTOR\n         BNO   ERROR1              THEN ERROR.  ELSE...\n         CLI   ##TYPE(#3),##FIXNUM IF ARG2 IS NOT A FIXNUM\n         BNE   ERROR2              THEN ERROR.  ELSE...\n         L     #4,##CDR(,#3)       GET VALUE OF FIXNUM INTO REGISTER\n         XR    #0,#0               CLEAR INSERT REGISTER\n         SLA   #4,2                MULTIPLY BY 4 TO CONVERT TO OFFSET\n         BM    ERROR3              IF LESS THAN ZERO, OUT OF RANGE\n         ICM   #0,7,1(#2)          GET LENGTH OF VECTOR TEXT\n         CR    #4,#0               IF NOT LESS THAN TOTAL VECTOR LENGTH\n         BNL   ERROR3              THEN OUT OF RANGE\n         L     #15,##VECDAT(#4,#2) ELSE LOAD ELEMENT N OF VECTOR\n         BR    #14                 AND RETURN TO CALLER\n         SPACE 1\n         DROP  #15\n         SPACE 1\n         USING VREF,#7\n         SPACE 1\nERROR1   DS    0H\n         LR    #7,#15\n         #ERR  'Argument 1 to VREF not a vector - ',(#2)\nERROR2   DS    0H\n         LR    #7,#15\n         #ERR  'Argument 2 to VREF not a fixnum - ',(#3)\nERROR3   DS    0H\n         LR    #7,#15\n         #ERR  'VREF index ',(#3),' out of range for vector ',(#2)\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSET": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x00,\\x00)\\x00+\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 44, "newlines": 41, "modlines": 43, "user": "SEB1525"}, "text": "         TITLE 'VSET - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nVSET     #ZBEG MINARGS=3,MAXARGS=3,NAME='VSET'\n         SPACE 1\n         USING VSET,#15\n         LM    #2,#4,0(#1)         LOAD ARGUMENTS\n         TM    ##TYPE(#2),##VEC    IF ARG1 IS NOT A VECTOR\n         BNO   ERROR1              THEN ERROR.  ELSE...\n         CLI   ##TYPE(#3),##FIXNUM IF ARG2 IS NOT A FIXNUM\n         BNE   ERROR2              THEN ERROR.  ELSE...\n         L     #5,##CDR(,#3)       GET VALUE OF FIXNUM INTO REGISTER\n         XR    #0,#0               CLEAR INSERT REGISTER\n         SLA   #5,2                MULTIPLY BY 4 TO CONVERT TO OFFSET\n         BM    ERROR3              IF LESS THAN ZERO, OUT OF RANGE\n         ICM   #0,7,1(#2)          GET LENGTH OF VECTOR TEXT\n         CR    #5,#0               IF NOT LESS THAN TOTAL VECTOR LENGTH\n         BNL   ERROR3              THEN OUT OF RANGE\n         ST    #4,##VECDAT(#5,#2)  ELSE STORE ARG 3 INTO ELEMENT N\n         LR    #15,#4               OF VECTOR AND RETURN IT AS VALUE\n         BR    #14                 AND RETURN TO CALLER\n         SPACE 1\n         DROP  #15\n         SPACE 1\n         USING VSET,#7\n         SPACE 1\nERROR1   DS    0H\n         LR    #7,#15\n         #ERR  'Argument 1 to VSET not a vector - ',(#2)\nERROR2   DS    0H\n         LR    #7,#15\n         #ERR  'Argument 2 to VSET not a fixnum - ',(#3)\nERROR3   DS    0H\n         LR    #7,#15\n         #ERR  'VSET index ',(#3),' out of range for vector ',(#2)\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSSIZE": {"ttr": 7182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x00\\x13\\x00\\x10\\x00\\x12\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 19, "newlines": 16, "modlines": 18, "user": "SEB1525"}, "text": "         TITLE 'VSSIZE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nVSSIZE   #ZBEG MINARGS=0,MAXARGS=0,NAME='VSSIZE'\n         #ZPDS 12                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #2,ZLCVSLEN         GET SIZE VALUE FROM COMMON AREA\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         #ZRET ,                   RETURN WITH IT\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WORD": {"ttr": 7184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x00,\\x00)\\x00+\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 44, "newlines": 41, "modlines": 43, "user": "SEB1525"}, "text": "         TITLE 'WORD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* WORD TAKES TWO ARGUMENTS, OF WHICH THE SECOND IS OPTIONAL.          *\n* THE FIRST IS A FIXNUM TO BE CONVERTED TO A FOUR-CHARACTER SYMBOL.   *\n* THE SECOND SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO INTERN THE   *\n*  GENERATED SYMBOL ON THE OBJECT LIST (NOTE DEFAULT IS NOT TO).      *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO EXTRA STACK SPACE.        *\n*                                                                     *\n***********************************************************************\n         SPACE\nWORD     #ZBEG MINARGS=1,MAXARGS=2,NAME='WORD'\n         #ZPDS 2*4+12+0 = 20       DEFINE STACK SIZE\n         #ZSAV ARGS=2              SAVE REGISTERS\n         SPACE\n         L     #2,0(,#11)          GET ATOM (ARG 1 TO WORD)\n         CLI   ##TYPE(#2),##FIXNUM MUST BE AN ATOM\n         BNE   ERROR1              OR ELSE\n*\n* BUILD A FOUR-CHARACTER ATOM FROM IT.\n*\n         MVC   WORDWORK(4),##CDR(#2) MOVE FIXNUM CONTENTS TO WORK AREA\n         LA    #0,4                SET LENGTH = 4\n         LA    #1,WORDWORK         POINT TO WORD TO BE ATOMIZED\n         L     #2,4(,#11)          SET INTERN FLAG = ARG 2 TO WORD\n         LR    #3,#10              SET FORMAT FLAG = NIL\n         LA    #4,20(,#11)         SET CURRENT STACK POINTER FOR CONS\n         L     #15,ZLCABLD         CALL ZILABLD TO MAKE AN ATOM FROM IT\n         #BASR #14,#15             (RETURNS ATOM IN #15)\n         SPACE 2\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 2\nERROR1   DS    0H\n         #ERR  'Argument to WORD not a fixnum - ',0(#11)\n         SPACE 1\nWORDWORK DS    CL4\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XCONS": {"ttr": 7186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x00\\x12\\x00\\x0f\\x00\\x11\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 18, "newlines": 15, "modlines": 17, "user": "SEB1525"}, "text": "         TITLE 'XCONS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nXCONS    #ZBEG MINARGS=2,MAXARGS=2,NAME='XCONS'\n         SPACE 1\n         USING XCONS,#15\n         SPACE 1\n         LM    #2,#3,0(#1)         ARG 1 --> ARG 2 TO CONS\n         L     #15,ZLCCONS\n         DROP  #15\n         LR    #1,#3               ARG 2 --> ARG 1 TO CONS\n         BR    #15                 ZLCCONS WILL RETURN VIA OUR #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XLATE": {"ttr": 7188, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x880\\x1f\\x00\\x89\\x15o\\x11H\\x00\\x92\\x00\\x8f\\x00\\x91\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-10-27T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 146, "newlines": 143, "modlines": 145, "user": "SEB1525"}, "text": "         TITLE 'XLATE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This is STRING-TRANSLATE.  This function is analogous to the PL/1   *\n* TRANSLATE built-in function.  Syntax:                               *\n*                                                                     *\n*  (string-translate \"any-string\" \"to-chars-bag\" \"from-chars-bag\")    *\n*                                                                     *\n*  where the second and third arguments must be the same in length.   *\n*                                                                     *\n***********************************************************************\nXLATE    #ZBEG MINARGS=3,MAXARGS=3,NAME='STRING-TRANSLATE'\n         #ZPDS 3*4+12+0 = 24       DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #5,#7,0(#11)        LOAD ARGS\n         CLI   ##TYPE(#5),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#5),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #5,##PNAME(,#5)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H                  CHECK ARG 2\n         CLI   ##TYPE(#6),##STRING IF ARGUMENT IS A STRING\n         BE    ARG2OK              THEN OK\n         CLI   ##TYPE(#6),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR2              THEN\n         L     #6,##PNAME(,#6)      TAKE THE PRINT NAME, ELSE ERROR\nARG2OK   DS    0H\n         CLI   ##TYPE(#7),##STRING IF ARGUMENT IS A STRING\n         BE    ARG3OK              THEN OK\n         CLI   ##TYPE(#7),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR3              THEN\n         L     #7,##PNAME(,#7)      TAKE THE PRINT NAME, ELSE ERROR\nARG3OK   DS    0H\n         ST    #5,0(,#11)          Store string ptr back on stack\n         XR    #2,#2\n         XR    #3,#3\n         XR    #4,#4\n         ICM   #2,7,1(#5)          #2 = LENGTH OF STRING ARG 1\n         BZ    RETSELF             If zero-length string, return self\n         ICM   #3,7,1(#6)          #3 = LENGTH OF STRING ARG 2\n         ICM   #4,7,1(#7)          #4 = LENGTH OF STRING ARG 3\n         CR    #3,#4               If lengths of to-bag and from-bag\n         BNE   ERROR4               don't match, then error\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* BUILD TRANSLATE TABLE FROM STRINGS ARG2 and ARG3                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #14,#3              Get length of character bags\n         BNP   RETSELF             If zero, return untranslated string\n         MVC   TRTBL(256),TRINIT   Initialize translate table to ident.\n         XC    TRTTBL(256),TRTTBL  Initialize scanning table\n         LA    #1,##VECDAT(,#6)    Point to text of \"to\" char bag arg2\n         LA    #4,##VECDAT(,#7)    Point to text of \"from\"    bag arg3\n         XR    #15,#15             Clear insert register\nTBLDLOOP DS    0H\n         IC    #0,0(,#1)           Get \"to\" character from arg2\n         IC    #15,0(,#4)          Get \"from\" character from arg3\n         STC   #0,TRTBL(#15)       Set translate table character\n         STC   #14,TRTTBL(#15)     Set scanning table character nonzero\n         LA    #1,1(,#1)           Increment \"to\" character pointer\n         LA    #4,1(,#4)           Increment \"from\" character pointer\n         BCT   #14,TBLDLOOP        Continue until bags exhausted\nTBLDEND  DS    0H                  Now the table is built\n         SPACE 1\n         LA    #14,##VECDAT(,#5)   Point to text of string arg1\n         LR    #7,#2               Get arg1 string length into good reg\n         LR    #15,#2              Get length of string arg1\n         LA    #0,256              Set up constant 256\nTRTLOOP  DS    0H                  Loop to scan string\n         CR    #15,#0\n         BNH   SHORTTRT\n         TRT   0(256,#14),TRTTBL   Scan for translatable characters\n         BNZ   COPYIT              If we found one, we have to copy\n         AR    #14,#0              Else bump up pointer to string text\n         SR    #15,#0              Bump down string length\n         B     TRTLOOP             And continue scanning.\nSHORTTRT DS    0H\n         BCTR  #15,0               Reduce length for execute\n         EX    #15,EXTRT           Scan for translatable characters\n         BZ    RETSELF             If no such chars, return self\nCOPYIT   DS    0H                  Translatable chars, have to copy\n         LR    #2,#7               GET LENGTH INTO REG FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,24(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #4,#15              IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         L     #1,0(,#11)          GET POINTER TO ORIGINAL STRING\n         LA    #0,##VECDAT(,#1)    POINT TO STRING TEXT\n         LA    #14,##VECDAT(,#4)   POINT TO WHERE TO MOVE STRING TEXT\n         LR    #1,#7               GET LENGTH OF STRING TEXT TO MOVE\n         LR    #15,#7\n         MVCL  #14,#0              MOVE TEXT FROM OLD STRING TO NEW\n         LA    #14,##VECDAT(,#4)   POINT TO TEXT OF STRING\n         LR    #15,#7              GET LENGTH\n         LA    #0,256              SET UP CONSTANT 256\nTRLOOP   DS    0H                  LOOP TO TRANSLATE STRING\n         CR    #15,#0\n         BL    SHORTTR\n         TR    0(256,#14),TRTBL    TRANSLATE\n         AR    #14,#0              BUMP UP POINTER TO TEXT\n         SR    #15,#0              BUMP DOWN LENGTH\n         BZ    DONE\n         B     TRLOOP              AND CONTINUE TRANSLATING.\nSHORTTR  DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         EX    #15,EXTR            TRANSLATE\nDONE     DS    0H                  ALL FINISHED\n         LR    #15,#4              POINT TO NEWLY BUILT STRING\n         B     RETURN              RETURN THE ATOM IN #15\n         SPACE 1\nRETSELF  DS    0H                  Null string, or no chars to xlate\n         LR    #15,#5              Return string 1 passed\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nEXTRT    TRT   0(*-*,#14),TRTTBL   EXECUTED: Scan for xlatable chars\nEXTR     TR    0(*-*,#14),TRTBL    EXECUTED: Translate the string\n         SPACE 1\nTRINIT   DC    256YL1(*-TRINIT)    Used to initialize translate table\n         SPACE 1\nTRTBL    DS    XL256               AREA TO BUILD TRANSLATE TABLE\nTRTTBL   DS    XL256               AREA TO BUILD SCANNING TABLE\n         SPACE 1\nERROR1   #ERR  'Argument 1 to STRING-TRANSLATE not a string - ',0(#11)\nERROR2   #ERR  'Argument 2 to STRING-TRANSLATE not a string - ',4(#11)\nERROR3   #ERR  'Argument 3 to STRING-TRANSLATE not a string - ',8(#11)\nERROR4   #ERR  'Lengths of args 2 and 3 to STRING-TRANSLATE unequal - 'X\n               ,4(#11),' and ',8(#11)\nERRORGC  #ERR  PREFIX=NO,          Not enough room even after GC       X\n               'ZIL4010 STRING-TRANSLATE: Not enough vector/string spacX\n               e to build string.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Z": {"ttr": 7427, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x15o\\x00\\x89\\x15o\\x11&\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-06-05T00:00:00", "modifydate": "1989-06-05T11:26:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "SEB1525"}, "text": "***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCAR": {"ttr": 7429, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00!\\x00\\x88\\x01_\\x01\\x00&_\\x16B\\x00\\x1f\\x00\\x1c\\x00\\x1e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:42:21", "lines": 31, "newlines": 28, "modlines": 30, "user": "SEB1525"}, "text": "         TITLE 'ZCAR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS VERSION OF CAR DOES NOT SUPPORT (CAR NIL).                     *\n* IT IS INTENDED FOR SPEED, AND EXISTS FOR PARALLELISM WITH THE       *\n* ZCAR FUNCTION USED FOR COMPILATION.                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZCAR     #ZBEG MINARGS=1,MAXARGS=1,NAME='ZCAR'\n         SPACE 1\n         USING ZCAR,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##ATOM\n         BO    CARERROR\n         L     #15,##CAR(,#2)\n         BR    #14\n         SPACE 1\nCARERROR DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING ZCAR,#3\n         #ERR  'Argument to ZCAR is an atom - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCDR": {"ttr": 7431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x005\\x00\\x88\\x01_\\x01\\x00&_\\x16B\\x00\\x1f\\x00\\x1c\\x00\\x1e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:42:35", "lines": 31, "newlines": 28, "modlines": 30, "user": "SEB1525"}, "text": "         TITLE 'ZCDR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS VERSION OF CDR DOES NOT SUPPORT (CDR NIL).                     *\n* IT IS INTENDED FOR SPEED, AND EXISTS FOR PARALLELISM WITH THE       *\n* ZCDR FUNCTION USED FOR COMPILATION.                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZCDR     #ZBEG MINARGS=1,MAXARGS=1,NAME='ZCDR'\n         SPACE 1\n         USING ZCDR,#15\n         SPACE 1\n         L     #2,0(,#1)\n         TM    ##TYPE(#2),##ATOM\n         BO    CDRERROR\n         L     #15,##CDR(,#2)\n         BR    #14\n         SPACE 1\nCDRERROR DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING ZCDR,#3\n         #ERR  'Argument to ZCDR is an atom - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZCPRINT": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11H\\x001\\x00.\\x000\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:48:00", "lines": 49, "newlines": 46, "modlines": 48, "user": "SEB1525"}, "text": "         TITLE 'ZCPRINT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZCPRINT is the ZIL \"current printer\", called by PRINC, PRIN1,       *\n*    CTERPRI, TERPRI and TYO.                                         *\n*                                                                     *\n* ZCPRINT takes 3 arguments:                                          *\n*                                                                     *\n* arg 1 = the object to be printed, if applicable.                    *\n* arg 2 = the file to print it on.                                    *\n* arg 3 = a fixnum built from the following boolean values:           *\n*                                                                     *\n*      ..00  =  print a character object (TYO)                        *\n*      ..01  =  print a LISP object (PRINC/PRIN1)                     *\n*      ..10  =  control, not print (CTERPRI/TERPRI)                   *\n*      .x..  =  0 = don't slashify, 1 = slashify                      *\n*      x...  =  0 = unconditional, 1 = conditional                    *\n*                                                                     *\n* EXAMPLE CALLING SEQUENCES:                                          *\n*                                                                     *\n*  (DEFUN TYO   (X &OPTIONAL F) (ZCPRINT X F #b0000))   0             *\n*  (DEFUN PRINC (X &OPTIONAL F) (ZCPRINT X F #b0001))   1             *\n*  (DEFUN PRIN1 (X &OPTIONAL F) (ZCPRINT X F #b0101))   5             *\n*  (DEFUN TERPRI  (&OPTIONAL F) (ZCPRINT X F #b0010))   2             *\n*  (DEFUN CTERPRI (&OPTIONAL F) (ZCPRINT X F #b1010))  10             *\n*                                                                     *\n* ZCPRINT is very simple: it merely passes its arguments to the       *\n* function whose address is in the common area field ZLCCPRT,         *\n* which is the compiled (or assembled) ZIL function which is          *\n* currently doing the printing.  That function is initialized         *\n* to ZDPRINT (the DEFAULT ZIL printer), but any compiled function     *\n* that processes its arguments similarly may have its address         *\n* inserted into that field to become the current ZIL printer.         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZCPRINT  #ZBEG MINARGS=3,MAXARGS=3,NAME='ZCPRINT'\n         SPACE 1\n         DROP  #15\n         SPACE 1\n         L     #15,ZLCCPRT         Get address of current ZIL printer.\n         BR    #15                 Go to it.\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZCREAD": {"ttr": 7435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x881?\\x00\\x89\\x15o\\x11I\\x00>\\x007\\x00=\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-11-08T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 62, "newlines": 55, "modlines": 61, "user": "SEB1525"}, "text": "         TITLE 'ZCREAD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZCREAD is the ZIL \"current reader\", called by READ, TYI, TYIPEEK,   *\n*        and many other routines.                                     *\n*                                                                     *\n* ZCREAD takes 6 arguments:                                           *\n*                                                                     *\n* arg 1 = the file to read from.                                      *\n* arg 2 = a fixnum built from the boolean values listed below.        *\n* arg 3 = miscellaneous function-dependent data (e.g. char operand).  *\n* arg 4 = eof-error-p.                                                *\n* arg 5 = eofval.                                                     *\n* arg 6 = recursive-p.                                                *\n*                                                                     *\n* Arg 2 values are made up from the following bit settings:           *\n*                                                                     *\n*  .......0  =  Read an S-expression (READ)                           *\n*  .......1  =  Read a character (TYI/TYIPEEK)                        *\n*  ......1.  =  Peek flag                                             *\n*  .....1..  =  READCH/PEEKCH flag                                    *\n*  ....1...  =  EOF request                                           *\n*  ...1....  =  EOL (newline) request                                 *\n*  ..1.....  =  1 = set EOF/EOL, 0 = test EOF/EOL                     *\n*  .1......  =  Read a line of data (READLINE)                        *\n*  1.......  =  Readtable functions                                   *\n*  1......1  =  Set reader macro                                      *\n*  1.....1.  =  Set MACLISP readtable                                 *\n*  1....1..  =  Return reader macro character                         *\n*                                                                     *\n* Sample calling sequence:                                            *\n*                                                                     *\n*  (defun read (&optional file eoferp eofval recurp)                  *\n*         (zcread file #b0000000 nil eoferp eofval recurp))           *\n*                                                                     *\n* There are many others, not listed here.  Note that even the one     *\n* above may not be the one in use in the present ZIL, depending on    *\n* whether we want the Maclisp READ or the Common Lisp READ.           *\n*                                                                     *\n* ZCREAD is very simple: it merely passes its arguments to the        *\n* function whose address is in the common area field ZLCCRDR,         *\n* which is the compiled (or assembled) ZIL function which is          *\n* currently doing the reading.   That function is initialized         *\n* to ZDREAD (the DEFAULT ZIL reader), but any compiled function       *\n* that processes its arguments similarly may have its address         *\n* inserted into that field to become the current ZIL reader.          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZCREAD   #ZBEG MINARGS=6,MAXARGS=6,NAME='ZCREAD'\n         SPACE 1\n         DROP  #15\n         SPACE 1\n         L     #15,ZLCCRDR         Get address of current ZIL reader.\n         BR    #15                 Go to it.\n         SPACE 1\n         END\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZDPRINT": {"ttr": 7437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x04\\x00\\x88\\x01_\\x01\\x00&_\\x16C\\x00\\xfe\\x00e\\x00\\xfd\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:43:04", "lines": 254, "newlines": 101, "modlines": 253, "user": "SEB1525"}, "text": "         TITLE 'ZDPRINT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZDPRINT is the ZIL \"default printer\", called by PRINC, PRIN1,       *\n*    CTERPRI, TERPRI and TYO.                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* Updated 11/02/88 to handle ZGETFPO, ZPUTFPO and CLRSCRN requests.   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* ZDPRINT takes 3 arguments:                                          *\n*                                                                     *\n* arg 1 = the object to be printed, if applicable.                    *\n* arg 2 = the file to print it on.                                    *\n* arg 3 = a fixnum built from the following boolean values:           *\n*                                                                     *\n*    ....00  =  print a character object (TYO)                        *\n*    ....01  =  print a LISP object (PRINC/PRIN1)                     *\n*    ....10  =  control, not print (CTERPRI/TERPRI)                   *\n*    ...x..  =  0 = don't slashify, 1 = slashify                      *\n*    ..x...  =  0 = unconditional, 1 = conditional                    *\n*    .1....  =  CHARPOS request (ZGETFPO/ZPUTFPO)                     *\n*    1.....  =  CLRSCRN request                                       *\n*                                                                     *\n* EXAMPLE CALLING SEQUENCES: (NOT the ones really used)               *\n*                                                                     *\n*  (DEFUN TYO     (X &OPTIONAL F) (ZDPRINT X   F #b000000))   0       *\n*  (DEFUN PRINC   (X &OPTIONAL F) (ZDPRINT X   F #b000001))   1       *\n*  (DEFUN PRIN1   (X &OPTIONAL F) (ZDPRINT X   F #b000101))   5       *\n*  (DEFUN TERPRI    (&OPTIONAL F) (ZDPRINT NIL F #b000010))   2       *\n*  (DEFUN CTERPRI   (&OPTIONAL F) (ZDPRINT NIL F #b001010))  10       *\n*  (DEFUN ZGETFPO   (&OPTIONAL F) (ZDPRINT NIL F #b010000))  16       *\n*  (DEFUN ZPUTFPO (X &OPTIONAL F) (ZDPRINT X   F #b010000))  16       *\n*  (DEFUN CLRSCRN ()              (ZDPRINT NIL T #b101010))  42       *\n*                                                                     *\n* Note that a CLRSCRN request acts like a CTERPRI for a file which is *\n* not the terminal.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMODEB3   EQU   ##CDR+3\nBPRINC   EQU   B'00000001'         1 = PRINx, 0 = TYO\nBTERPRI  EQU   B'00000010'         1 = TERPRI, 0 = PRINx/TYO\nBSLASHFY EQU   B'00000100'         1 = SLASHIFY, 0 = DON'T\nBCONDNEW EQU   B'00001000'         1 = CONDITIONAL FOR NEWLINE\nBCHARPOS EQU   B'00010000'         1 = CHARPOS request\nBCLRSCRN EQU   B'00100000'         1 = CLRSCRN request\n         SPACE 1\nZDPRINT  #ZBEG MINARGS=3,MAXARGS=3,NAME='ZDPRINT',SUBRS=ZILSUBR\n         #ZPDS 3*4+12+12 = 36\n         #ZSAV ,\n*\n* If arg 2 is a symbol, then assume that it is an output file and\n* process it accordingly.  Otherwise, assume that it is a \"stream\"\n* (in whatever format that may be) and pass control to ZCPEXEC to\n* handle the stream operation.\n*\n         L     #7,4(,#11)          Get arg 2\n         CLI   ##TYPE(#7),##SYMBOL If file argument is not a symbol\n         BNE   ZDSTREAM            then must be a stream, process so\n*                                  Else must be an output file...\n*                                  This sets #7 based on 4(,#11)\n         #OFIL 2                   Arg 2 = output file spec\n         SPACE 1\n         L     #2,8(,#11)          Get arg 3\n         TM    MODEB3(#2),BTERPRI  If TERPRI bit is 1,\n         BO    ZDTERPRI            then go to process (C)TERPRI/CLRSCRN\n         TM    MODEB3(#2),BCHARPOS If CHARPOS bit is 1,\n         BO    ZDCHARPO            then go to process CHARPOS\n*                                  Else either TYO or PRINx...\n         TM    MODEB3(#2),BPRINC   If PRINx bit is 0,\n         BZ    ZDTYO               then go to process TYO\n*                                  Else this is a PRINC/PRIN1\n         NI    ZLCPFLGS,255-ZLCPSLSH Initialize slashification bit\n         TM    MODEB3(#2),BSLASHFY If slashification required\n         BE    *+8                 then\n         OI    ZLCPFLGS,ZLCPSLSH    set slashify bit on\n         L     #15,ZLCPRIN         Get address of ZILPRIN\n         L     #4,0(,#11)          Get argument 1\n         #BASR #14,#15             Call printing routine\n         L     #15,0(,#11)         Set return value to arg1\n         B     RETURN              Return\n         SPACE 1\nZDTERPRI DS    0H                  Process CTERPRI / TERPRI / CLRSCRN\n         SPACE 1\n         TM    MODEB3(#2),BCLRSCRN If CLRSCRN bit is 1,\n         BZ    ZDTERPNC             and\n         TM    ZLFFLAG1,ZLFTERM      this is a terminal file,\n         BO    ZDCLRSCR               then go to do screen clear\nZDTERPNC DS    0H                  Else non-screen-clearing (C)TERPRI\n         LR    #15,#10             Preset return value to NIL, but...\n         TM    MODEB3(#2),BCONDNEW If TERPRI request (non-conditional)\n         BZ    JUSTTERP             or\n         TM    ZLFFLAG1,ZLFNEWLN     data already on current line\n         BZ    RETURN                 then\nJUSTTERP DS    0H                      do it...\n         L     #15,ZLCTERP          Get address of ZILTERP\n         #BASR #14,#15              Call ZILTERP\n         LR    #15,#8               Return T\n         B     RETURN\n         SPACE 1\nZDTYO    DS    0H                  Process TYO\n         SPACE 1\n         L     #1,0(,#11)          Get arg 1\n         CLI   ##TYPE(#1),##FIXNUM Must be character\n         BNE   TYOERROR\n         L     #2,##CDR(,#1)       Get fixnum value\n         CL    #2,#SFW255          Must be between 0 and 255\n         BH    TYOERROR\n         STC   #2,FAKECHAR         Store character in fake string\n         NI    ZLCPFLGS,255-ZLCPSLSH Set no-slashify option\n         L     #15,ZLCPRIN         Get address of ZILPRIN\n         LA    #4,FAKESTR          Get argument 1\n         #BASR #14,#15             Call printing routine\n         L     #15,0(,#11)         Set return value to arg1\n******** B     RETURN              Return\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   Return to caller\n         EJECT\nZDSTREAM DS    0H                  Here if arg1 not a \"file\"\n         SPACE 1\n         LM    #14,#0,0(#11)        Args 1-3\n         STM   #14,#0,24(#11)       Store on stack\n         ICM   #15,15,@ZCPEXEC     Get address of ZCPEXEC\n         BZ    LOADZCP             If zero, not loaded yet\n         LA    #1,24(,#11)         Point to args\n         #BASR #14,#15             Call whatever you put in #15\n         B     RETURN              and return with its result value(s)\n         SPACE 1\nLOADZCP  DS    0H                  Here when ZCPEXEC isn't loaded yet\n         SPACE 1\n         LA    #1,SZCPEXEC         Address of \"ZCPEXEC\" name\n         ST    #1,24(,#11)         Store on stack\n         L     #15,@ZILLOAD        Get address of ZILLOAD\n         LA    #1,24(,#11)         Point to args\n         #BASR #14,#15             Call ZILLOAD to load ZCPEXEC\n         XR    #1,#1               Clear insert register\n         CR    #15,#10             If module could not be loaded\n         BE    ERRLOAD             then error - load failure\n         ICM   #1,7,##CAR+1(#15)   Else get address of compiled code\n         ST    #1,@ZCPEXEC         Store it into our address constant\n         B     ZDSTREAM            Go to retry\n         SPACE 1\nERRLOAD  DS    0H\n         #ERR  PREFIX=NO,                                              X\n               'ZIL1016 Unable to load ZCPEXEC, stream operations imposX\n               sible.'\n         SPACE 1\nSZCPEXEC DC    YL1(##STRING),AL3(8),CL8'ZCPEXEC '    String \"ZCPEXEC\"\n         SPACE 1\n*\n* The adcon for ZCPEXEC is not within the ZILSUBRS area because it\n* is loaded on demand, not resolved at linkedit time.\n*\n@ZCPEXEC DC    A(0)                ADDRESS OF ZCPEXEC\n         SPACE 1\nZILSUBRS DS    0A                  EXTERNAL SUBROUTINES\n@ZILLOAD DC    V(ZILLOAD)          ADDRESS OF ZILLOAD\n         DC    CL8'ZILLOAD'\nZILSUBRE DS    0A                  END OF SUBROUTINES\n         EJECT\nZDCHARPO DS    0H                  Process CHARPOS request\n         SPACE 1\n         L     #15,0(,#11)         Get argument 1\n         CR    #15,#10             If argument 1 is NIL\n         BE    ZDGETFPO            then process ZGETFPO\n         SPACE 1\nZDPUTFPO DS    0H                  Process ZPUTFPO request\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION UPDATES THE CURRENT CHARACTER POSITION OF THE         *\n* SPECIFIED OUTPUT FILE FROM A FIXNUM ATOM, AND RETURNS THAT VALUE.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   ##TYPE(#15),##FIXNUM IF NOT A FIXNUM\n         BNE   ZDPERROR            THEN ERROR\n         ICM   #14,15,##CDR(#15)   GET FIXNUM VALUE\n         BM    ZDPERROR            IF NEGATIVE, ERROR\n         ST    #14,ZLFCHAR         SET CURRENT CHARACTER POINTER\n         B     RETURN              Return\n         SPACE 1\nZDGETFPO DS    0H                  Process ZGETFPO request\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION RETURNS THE CURRENT CHARACTER POSITION OF THE         *\n* SPECIFIED OUTPUT FILE AS A FIXNUM ATOM.                             *\n*                                                                     *\n***********************************************************************\n         SPACE\n         L     #2,ZLFCHAR          GET CURRENT CHARACTER POINTER\n         CL    #2,ZLCSFTHI         IF WITHIN SMALL FIXNUM RANGE\n         BNH   SMALLFIX            THEN GO TO RETURN FIXNUM FROM TABLE\n         LA    #0,24(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXED ATOM OUT OF IT\n         B     RETURN\nSMALLFIX DS    0H\n         SLA   #2,3                CONVERT TO INDEX INTO FIXNUM TABLE\n         LA    #15,#SFT(#2)        RETURN SMALL FIXNUM FROM TABLE\n         B     RETURN              Return\n         SPACE 1\nZDCLRSCR DS    0H                  Process CLRSCRN request\n         SPACE 1\n         STFSMODE INITIAL=YES      SET FULL SCREEN MODE FOR VTAM\n         SPACE 1\n         LTR   #15,#15             IF NOT A VTAM TERMINAL\n         BNZ   TCAMCLR             THEN DO A TCAM SCREEN CLEAR\n         SPACE 1\n******** STLINENO LINE=1           ELSE DO A VTAM SCREEN CLEAR\n         TPUT  CLR,L'CLR,FULLSCR,,HOLD\n         SPACE 1\n         STLINENO LINE=1           INSURE LINE MODE OUTPUT GOES TO TOP\n         SPACE 1\n         STFSMODE OFF              SET FULL SCREEN MODE OFF\n         SPACE 1\n         TCLEARQ INPUT\n         SPACE 1\n         LR    #15,#10             RETURN NIL\n         B     RETURN\n         SPACE 1\nTCAMCLR  DS    0H                  NOT VTAM - DO TCAM SCREEN CLEAR\n         SPACE 1\n         TPUT  FSON,L'FSON,FULLSCR,,HOLD\n         TPUT  FSOFF,L'FSOFF,FULLSCR,,HOLD\n         SPACE 1\n         LR    #15,#10             RETURN NIL\n         B     RETURN\n         SPACE 1\nFAKESTR  DC    YL1(##STRING),AL3(1) String header\nFAKECHAR DC    XL4'00'             Place to insert character\nCLR      DC    X'401140403C40400013'\nFSON     DC    X'40115D7F1140403C40400013'\nFSOFF    DC    X'40115D7E1140403C40400013'\n         SPACE 1\nTYOERROR #ERR  'Argument 1 to TYO not a character fixnum - ',0(#11)\nZDPERROR #ERR  'Argument 1 to ZPUTFPO not a non-negative fixnum - ',   X\n               0(#11)\n*LRERROR #ERR  'Argument 1 to ZPUTFPO exceeds output file length - ',  X\n               0(#11)\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZDREAD": {"ttr": 7681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00I\\x00\\x882?\\x01\\x00&_\\x16C\\x07\\xa1\\x06[\\x07\\xa0\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "2000-09-21T16:43:49", "lines": 1953, "newlines": 1627, "modlines": 1952, "user": "SEB1525"}, "text": "         TITLE 'ZDREAD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZDREAD is the ZIL \"default reader\", called by READ, TYI, TYIPEEK,   *\n* and many other routines.                                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* ZDREAD takes 6 arguments:                                           *\n*                                                                     *\n* arg 1 = the file to read from.                                      *\n* arg 2 = a fixnum built from the boolean values listed below.        *\n* arg 3 = miscellaneous function-dependent data (e.g. char operand).  *\n* arg 4 = eof-error-p.                                                *\n* arg 5 = eofval.                                                     *\n* arg 6 = recursive-p.                                                *\n*                                                                     *\n* Arg 2 values are made up from the following bit settings:           *\n*                                                                     *\n*  00000000  =  Read an S-expression (READ)                           *\n*  .....001  =  Read a character (TYI)                                *\n*  .....010  =  Unread a character (UNTYI)                            *\n*  .....011  =  Peek a character (TYIPEEK)                            *\n*  .....100  =  Intern a character (READCH)                           *\n*  .....110  =  Intern a character (PEEKCH)                           *\n*  ....1...  =  EOF request                                           *\n*  ...1....  =  EOL (newline) request                                 *\n*  ..1.....  =  1 = set EOF/EOL, 0 = test EOF/EOL                     *\n*  .1......  =  Read a line of data (READLINE)                        *\n*  1.......  =  Readtable functions                                   *\n*  1......1  =  Set reader macro                                      *\n*  1.....1.  =  Set MACLISP readtable                                 *\n*  1....1..  =  Return reader macro character                         *\n*                                                                     *\n* Sample calling sequence:                                            *\n*                                                                     *\n*  (defun read (&optional file eoferp eofval recurp)                  *\n*         (zcread file #b0000000 nil eoferp eofval recurp))           *\n*                                                                     *\n* There are many others, not listed here.  Note that even the one     *\n* above may not be the one in use in the present ZIL, depending on    *\n* whether we want the Maclisp READ or the Common Lisp READ.           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 02/28/90 - Fixed GC errors by setting ZLCGCBLD flag.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMODEB3   EQU   ##CDR+3\nBTYI     EQU   B'00000001'         1 = TYI/TYIPEEK, 0 = READ\nBPEEK    EQU   B'00000010'         1 = peek request\nBINTERN  EQU   B'00000100'         1 = READCH/PEEKCH, 0 = TYI/TYIPEEK\nBEOF     EQU   B'00001000'         1 = EOF request\nBEOL     EQU   B'00010000'         1 = EOL (newline) request\nBSET     EQU   B'00100000'         1 = set EOF/EOL, 0 = test EOF/EOL\nBREADLIN EQU   B'01000000'         1 = READLINE\nBRM      EQU   B'10000000'         1 = Readtable functions\nBRMBITS  EQU   B'01111111'         Other bits used with readtable funx\nBRMSRM   EQU   B'00000001'         1 = set reader macro\nBRMMACRT EQU   B'00000010'         1 = set MACLISP readtable\nBRMCHAR  EQU   B'00000100'         1 = return reader macro character\n         SPACE 1\nZDREAD   #ZBEG MINARGS=6,MAXARGS=6,NAME='ZDREAD',SUBRS=ZILSUBR\n         #ZPDS 60\n         #ZSAV ,\n*\n* If arg 1 is a symbol, then assume that it is an input file and\n* process it accordingly.  Otherwise, assume that it is a \"stream\"\n* (in whatever format that may be) and pass control to ZCREXEC to\n* handle the stream operation.\n*\n         L     #7,0(,#11)          Get arg 1\n         CLI   ##TYPE(#7),##SYMBOL If file argument is not a symbol\n         BNE   ZDSTREAM            then must be a stream, process so\n*                                  Else must be an input file...\n*                                  This sets #7 based on 0(,#11)\n         #IFIL 1                   Arg 1 = input file spec\n         SPACE 1\n         L     #2,4(,#11)          Get arg 2\n         TM    MODEB3(#2),BRM      If readtable bit is on\n         BO    DOREADTB            then process readtable requests\n         CLI   MODEB3(#2),0        If all bits are off\n         BE    DOREAD              then process READ request\n         TM    MODEB3(#2),BTYI     If TYI/TYIPEEK bit is on\n         BO    DOTYI               then process TYI/TYIPEEK request\n         TM    MODEB3(#2),BINTERN  If READCH/PEEKCH bit is on\n         BO    DOINTERN            then process READCH/PEEKCH request\n         TM    MODEB3(#2),BPEEK    If PEEK but not TYI\n         BO    DOUNTYI             then process UNTYI request\n         TM    MODEB3(#2),BEOF     If EOF bit is on\n         BO    DOEOF               then process EOF set/test request\n         TM    MODEB3(#2),BEOL     If EOL bit is on\n         BO    DOEOL               then process EOL set/test request\n         TM    MODEB3(#2),BREADLIN If READLINE bit is on\n         BO    DOREADLI            then process READLINE request\n         B     UNKNOWN             else unknown\n         EJECT\nDOREAD   DS    0H                  This is READ\n         #BAS  #14,CKRDTBL         Initialize read table if necessary\n         L     #0,0(,#11)\n         ST    #0,36(,#11)         Arg 1 = file\n         L     #0,8(,#11)\n         ST    #0,40(,#11)         Arg 2 = preserving-whitespace-p\n         L     #0,12(,#11)\n         ST    #0,44(,#11)         Arg 3 = eof-error-p\n         L     #0,16(,#11)\n         ST    #0,48(,#11)         Arg 4 = eofval\n         L     #0,20(,#11)\n         ST    #0,52(,#11)         Arg 5 = recursive-p\n         L     #15,=A(ZILREAD)     Get address of ZILREAD\n         LA    #1,36(,#11)         Point to args\n         B     BASR1415            Go to call it.\n         EJECT\nDOTYI    DS    0H                  This is TYI or TYIPEEK\n         TM    MODEB3(#2),BPEEK    If PEEK bit is off\n         BO    DOTYIPK             then\n         L     #15,=A(ZILTYI)       get address of ZILTYI\n         B     BASR1415             go to call it\nDOTYIPK  DS    0H                  Else peeking...\n*\n* Because (TYIPEEK T ...) needs to check whitespacity of characters,\n* the readtable may be necessary.\n*\n         #BAS  #14,CKRDTBL          Initialize read table if necessary\n         L     #15,=A(ZILTYIPK)     get address of ZILTYIPK\n         B     BASR1415             go to call it\n         SPACE\nDOUNTYI  DS    0H                  This is UNTYI\n         L     #15,=A(ZILUNTYI)    Get address of ZILUNTYI\n         B     BASR1415            go to call it\n         SPACE\nDOINTERN DS    0H                  This is READCH or PEEKCH\n         TM    MODEB3(#2),BPEEK    If PEEK bit is off\n         BO    DOPEEKCH            then\n         L     #15,=A(READCH)       get address of READCH\n         B     BASR1415             go to call it\nDOPEEKCH DS    0H                  Else peeking...\n         L     #15,=A(PEEKCH)       get address of PEEKCH\n         B     BASR1415             go to call it\n         SPACE\nDOREADLI DS    0H                  READLINE request\n         L     #15,=A(READLINE)\n         B     BASR1415            Go to call it.\n         SPACE\nDOEOF    DS    0H                  This is EOF or QUIT\n         TM    MODEB3(#2),BSET     If set bit is off\n         BO    DOSETEOF            then\n*\n* EOF - return TRUE or FALSE depending on whether EOF has been reached\n*\n         TM    ZLFFLAG,ZLFEOF      Test EOF flag\n         BZ    FALSE               If off, not EOF\n         B     TRUE                If on, EOF\nDOSETEOF DS    0H                  Else set EOF...\n*\n* QUIT - force EOF on the file\n*\n         OI    ZLFFLAG,ZLFEOF      Set EOF flag\n         B     FALSE               Return NIL\n         SPACE\nDOEOL    DS    0H                  This is NEWLINEP or ENDREAD\n         TM    MODEB3(#2),BSET     If set bit is off\n         BO    DOSETEOL            then\n*\n* NEWLINEP - return TRUE or FALSE depending on if EOL has been reached\n*\n         TM    ZLFFLAG,ZLFNEWLN    Test newline flag\n         BZ    FALSE               If off, not newline\n         B     TRUE                If on, newline\nDOSETEOL DS    0H                  Else set newline...\n*\n* ENDREAD - force next line to be read.  This isn't really the same as\n*           setting NEWLINE.  But it sort of fits with the bit setting\n*           configurations for ZCREAD/ZDREAD, so here it is.\n*\n         NI    ZLFFLAG2,255-ZLFTGT12 Reset incomplete-TGET indicator\n         XR    #3,#3\n         BCTR  #3,0\n         ST    #3,ZLFCHAR          Force newline condition on file\n         B     FALSE               Return NIL\n         SPACE\nDOREADTB DS    0H                  This is RMINIT or something\n         TM    MODEB3(#2),BRMBITS  If all other bits are off\n         BZ    DORMINIT            then this is an initialization\n         TM    MODEB3(#2),BRMSRM   If set-reader-macro bit is on\n         BO    DORDRMAC            then this is set-reader-macro\n         TM    MODEB3(#2),BRMMACRT If set-maclisp-reader bit is on\n         BO    DORMMAC             then set MACLISP readtable\n         TM    MODEB3(#2),BRMCHAR  If reader-macro-character bit on\n         BO    DORMCHAR            then return reader macro character\n         B     UNKNOWN             Else we don't know what it is yet\nDORMINIT DS    0H                  Else RMINIT request...\n         L     #15,@ZRMINIT        Get address of ZRMINIT\n         B     BASR1415            Go to call it.\nDORDRMAC DS    0H                  RDRMACRO request...\n         #BAS  #14,CKRDTBL         Initialize read table if necessary\n         L     #15,=A(RDRMACRO)    Get address of RDRMACRO\n         B     BASR1415            Go to call it.\nDORMMAC  DS    0H                  Else RMMAC request...\n         #BAS  #14,CKRDTBL         Initialize read table if necessary\n         L     #4,ZLCRDTBL         Get read table address\n         MVI   C'/'(#4),##ESCAPE   Set syntax of slash like backslash\n         MVI   C'\\'(#4),##NORMAL   Set normal syntax for backslash\n         B     FALSE               Return NIL\nDORMCHAR DS    0H                  RMCHAR request...\n         #BAS  #14,CKRDTBL         Initialize read table if necessary\n         L     #15,=A(RMCHAR)      Get address of RMCHAR\n         B     BASR1415            Go to call it.\n         SPACE\nUNKNOWN  DS    0H\n         #ERR  'Unknown ZDREAD request, code ',4(#11)\n         SPACE\nFALSE    DS    0H                  Come here to return FALSE\n         LR    #15,#10             Set return value to NIL\n         B     RETURN\n         SPACE\nTRUE     DS    0H                  Come here to return TRUE\n         LR    #15,#8              Set return value to T\n         B     RETURN\n         SPACE\nZDSTREAM DS    0H                  Here if arg1 not a \"file\"\n         SPACE 1\n         LM    #14,3,0(#11)        Args 1-6\n         STM   #14,3,36(#11)       Store on stack\n         ICM   #15,15,@ZCREXEC     Get address of ZCREXEC\n         BZ    LOADZCR             If zero, not loaded yet\n         LA    #1,36(,#11)         Point to args\n******** B     BASR1415            Go to call it.\n         SPACE 1\nBASR1415 DS    0H                  Come here to call a subroutine\n         #BASR #14,#15             Call whatever you put in #15\n******** B     RETURN              and return with its result value(s)\n         SPACE\nRETURN   DS    0H                  Return to caller\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nLOADZCR  DS    0H                  Here when ZCREXEC isn't loaded yet\n         SPACE 1\n         LA    #1,SZCREXEC         Address of \"ZCREXEC\" name\n         ST    #1,36(,#11)         Store on stack\n         L     #15,@ZILLOAD        Get address of ZILLOAD\n         LA    #1,36(,#11)         Point to args\n         #BASR #14,#15             Call ZILLOAD to load ZCREXEC\n         XR    #1,#1               Clear insert register\n         CR    #15,#10             If module could not be loaded\n         BE    ERRLOAD             then error - load failure\n         ICM   #1,7,##CAR+1(#15)   Else get address of compiled code\n         ST    #1,@ZCREXEC         Store it into our address constant\n         B     ZDSTREAM            Go to retry\n         SPACE 1\nSZCREXEC DC    YL1(##STRING),AL3(8),CL8'ZCREXEC '    String \"ZCREXEC\"\n         SPACE 1\nERRLOAD  DS    0H\n         #ERR  PREFIX=NO,                                              X\n               'ZIL1015 Unable to load ZCREXEC, stream operations imposX\n               sible.'\n         EJECT\nCKRDTBL  DS    0H                  Routine to check for read table\n*\n* If no read table exists yet, create it.\n* This also insures the existence of the ZIL work area.\n* Note that ZRMINIT alters only registers 15,0,1,and 2.\n*\n         ICM   #15,15,ZLCRDTBL     Get address of read table\n         BNZR  #14                 If it's there, OK\n         L     #15,@ZRMINIT        If not, allocate one\n         BR    #15                 Call ZRMINIT to initialize table\n*                                  and return via #14\n         SPACE 1\n*\n* The adcon for ZCREXEC is not within the ZILSUBRS area because it\n* is loaded on demand, not resolved at linkedit time.\n*\n@ZCREXEC DC    A(0)                ADDRESS OF ZCREXEC\n         SPACE 1\nZILSUBRS DS    0A                  EXTERNAL SUBROUTINES\n@ZRMINIT DC    V(ZRMINIT)          ADDRESS OF ZRMINIT\n         DC    CL8'ZRMINIT'\n@ZILLOAD DC    V(ZILLOAD)          ADDRESS OF ZILLOAD\n         DC    CL8'ZILLOAD'\nZILSUBRE DS    0A                  END OF SUBROUTINES\n         SPACE\n*                                                                     *\n*               0(#11) --> arg3    misc. function-dependent data\n*               4(#11) --> arg4    eof-error-p\n*               8(#11) --> arg5    eofval\n*              12(#11) --> arg6    recursive-p\n*                                                                     *\n         SPACE\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* ZILREAD - This code is taken from the original ZIL \"READ\" module.   *\n* #7 contains the file pointer on entry.  The arguments on the stack  *\n* are as in the following pseoducall:                                 *\n*                                                                     *\n* (zilread file whitespace-p eof-error-p eofval recursive-p)          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This isn't quite Common LISP READ yet.  First of all, the syntax    *\n* for READ in Common LISP is:                                         *\n*                                                                     *\n* (defun read                                                         *\n*        (&optional input-stream eof-error-p eof-value recursive-p)...*\n*                                                                     *\n* whereas this READ currently uses the Maclisp syntax                 *\n*                                                                     *\n* (defun read (&optional file eofval) ...                             *\n*   which maps into, kind of,                                         *\n* (zilread nil nil eofval nil) as a default mode of operation.        *\n*                                                                     *\n* Second of all, this READ doesn't handle packages yet, which is to   *\n* say that it doesn't do anything different about colons, among other *\n* things.                                                             *\n*                                                                     *\n* Third of all, this READ treats # as a terminating macro rather      *\n* than a non-terminating macro.  The current architecture of the      *\n* read table does not have any way of representing a non-terminating  *\n* reader macro.                                                       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1    file, needed by reader macros      *\n*               4(#11) --> arg3    T if preserving-whitespace-p       *\n*               8(#11) --> arg4    eof-error-p                        *\n*              12(#11) --> arg5    eofval                             *\n*              16(#11) --> arg6    recursive-p                        *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILREAD  #ZBEG MINARGS=5,MAXARGS=5,NAME='ZILREAD',MAIN=NO\n         #ZPDS 5*4+12  =  32       DEFINE STACK SIZE\n         ST    #14,28(,#1)\n         STM   #11,#12,20(#1)\n         LR    #11,#1\n         LR    #12,#15\n         DROP  #15\n         USING ZILREAD,#12\n         SPACE\n         TM    ZLFFLAG,ZLFEOF      IF END OF FILE ALREADY HIT\n         BO    RDAFTEOF            THEN ERROR - READ AFTER EOF\n         SPACE\n         L     #3,ZLFCHAR          GET CURRENT CHARACTER POINTER\nGOTINPUT DS    0H\n         LTR   #3,#3               CHECK FOR EOF OR NEWLINE\n         BP    INPUTOK             IF POSITIVE, WE HAVE GOOD STUFF\n         BZ    R0EOF               IF ZERO, EOF ENCOUNTERED\n******** BM    R0NEWLN             IF NEGATIVE, NEWLINE ENCOUNTERED\nR0NEWLN  DS    0H                  (READ NEVER RETURNS A NEWLINE)\n         #GETC ,                   READ ANOTHER CHARACTER\n         B     GOTINPUT            UNTIL NO MORE NEWLINE\n         SPACE\nRDAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM\n         #ERR  'ZIL2003 READ: Read after end of file ',                X\n               (#2),PREFIX=NO\n         SPACE\nINPUTOK  DS    0H\n         SPACE\n         MVI   SYNFLAGS,0          CLEAR SYNTAX FLAGS\n         LA    #1,32(,#11)         SET STACK POINTER\n         #BAS  #14,READ1           GO GET AN S-EXPRESSION INTO #15\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         B     R0GO(#2)            BRANCH DEPENDING ON WHAT RETURNED\nR0GO     B     R0STUFF             0...WE GOT SOMETHING\n         B     R0BADRP             4...RIGHT PARENTHESIS FOUND\n         B     R0BADDOT            8...PERIOD FOUND\n         B     R0EOF               12...EOF ENCOUNTERED\n         SPACE\nR0EOF    DS    0H                  NO DATA RETURNED, EOF HIT\n         OI    ZLFFLAG,ZLFEOF      SET EOF FLAG ON IN FILE BLOCK\n         C     #10,8(,#11)         If eof-error-p is NIL,\n         BNE   R0EOFERR            then...\n         L     #15,12(,#11)         set return value to eofval\n         CR    #15,#13              if eofval is unsupplied &optional\n         BNE   R0RETURN             then\n         LR    #15,#10               set return value to nil\n         B     R0RETURN\nR0EOFERR DS    0H                  Else eof-error-p is true...\n         L     #2,ZLFATOM          Load file atom for error message.\n         #ERR  'ZIL2006 READ: End of file encountered - file ',       ,X\n               (#2),PREFIX=NO\n         SPACE\nR0BADRP  DS    0H                  BAD RIGHT PAREN\n         L     #2,ZLFATOM          Load file atom for error message.\n         #ERR  'ZIL2020 READ: Unmatched right parenthesis \")\" - file ',X\n               (#2),PREFIX=NO\n         SPACE\nR0BADDOT DS    0H                  BAD PERIOD\n         L     #2,ZLFATOM          Load file atom for error message.\n         #ERR  'ZIL2020 READ: Period \".\" not in dotted pair - file ',  X\n               (#2),PREFIX=NO\n         SPACE\nR0STUFF  DS    0H                  WE GOT SOMETHING, BUT...\n         SPACE 1\n         TM    SYNFLAGS,SYNERROR   IF A SYNTAX ERROR WAS FOUND\n         BZ    R0RETURN            THEN...\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2001 READ: Syntax error reading file ',             X\n               (#2),PREFIX=NO\n         SPACE 1\nR0RETURN DS    0H\n         SPACE\n         LR    #1,#11\n         LM    #11,#12,20(#1)\n         L     #14,28(,#1)\n         BR    #14\n         EJECT\nREAD1    DS    0H\n         SPACE\n***********************************************************************\n* THIS SUBROUTINE IS THE SECOND-LEVEL READ ROUTINE.  IT RETURNS SOME  *\n* S-EXPRESSION THAT IT FINDS IN THE INPUT STREAM.  THIS ROUTINE IS    *\n* INVOKED RECURSIVELY.  LOGIC IS AS FOLLOWS:                          *\n*   SCAN UNTIL NON-WHITESPACE CHARACTER (BLANK IS A WHITESPACE)       *\n*   IF LEFT PAREN FOUND, GET READY TO START A LIST, CALL READ1 UNTIL  *\n*   A RIGHT PARENTHESIS IS FOUND.  BUILD LIST FROM ATOMS FROM READ1.  *\n*   IF RIGHT PARENTHESIS IS FOUND, RETURN TO CALLER WITH CODE 4.      *\n*   IF PERIOD IS FOUND, RETURN TO CALLER WITH CODE 8.                 *\n*   IF READER MACRO CHAR, INVOKE MACRO AND RETURN WITH ITS VALUE.     *\n*   IF END OF FILE REACHED, RETURN TO CALLER WITH CODE 12.            *\n*   IF ANY OTHER CHARACTER IS FOUND, BUILD AN ATOM AND RETURN WITH IT *\n***********************************************************************\n         SPACE\n         #ZPDS 32                  MAKE SURE WE HAVE ENOUGH STACK SPACE\n         L     #15,0(,#11)         PICK UP FILE SPEC\n         ST    #15,0(,#1)          SAVE FILE POINTER\n         ST    #14,4(,#1)          SAVE RETURN REGISTER ON STACK\n         ST    #11,8(,#1)          SAVE STACK POINTER ON STACK\n         LR    #11,#1              SET NEW STACK POINTER\n         LR    #15,#10             INITIALIZE VALUE TO NIL\n         MVI   FLAGS,X'00'         CLEAR FLAGS\n         B     R1GO                SKIP OVER CHARACTER GET\n         SPACE\nCONTINUE DS    0H\n         #GETC ,                   GET A CHARACTER\n         SPACE\nR1GO     DS    0H\n         LTR   #6,#3               GET CURRENT CHARACTER POINTER\n         BP    R1NOTEOF            IF WE GOT A CHAR, PROCESS IT\n         BM    CONTINUE            IF NEWLINE, GET NEXT CHARACTER\n         LA    #2,12               ELSE EOF - SET RETURN TO 12\n         B     READ1RET             AND RETURN\nR1NOTEOF DS    0H\n         BCTR  #6,0                CONVERT FROM RELATIVE COLUMN\n         A     #6,ZLFCARD          TO ABSOLUTE OFFSET IN RECORD\n         L     #4,ZLCWA            SET ADDRESS OF WHERE TO PUT CHARS\n         XR    #5,#5               SET LENGTH OF ATOM SO FAR\n         L     #14,ZLCRDTBL        GET ADDRESS OF READ TABLE\n         XR    #1,#1               CLEAR TRT REG\n         XR    #2,#2               CLEAR TRT REG\n         LA    #0,X'80'            SET UP TO COMPARE FOR MACRO CHAR\n         TRT   0(1,#6),0(#14)      SEE WHAT KIND OF CHARACTER THIS IS\n         CR    #2,#0               IF MACRO BIT WAS ON IN READTABLE\n         BNL   GMACRO              THEN IT'S A MACRO CHAR, PROCESS\n         B     GO(#2)              ELSE BRANCH ON CHARACTER TYPE\nGO       B     GALOOP              CHARACTER THAT CAN OCCUR IN ATOM\n         B     CONTINUE            BLANK\n         B     GLEFTP              LEFT PARENTHESIS\n         B     GRIGHTP             RIGHT PARENTHESIS\n         B     GSEMI               SEMICOLON\n         B     GPERIOD             PERIOD\n         B     GCONT               CONTINUATION CHARACTER\n         B     GESCAPE1            SINGLE ESCAPE BACKSLASH (HEX E0)\n         B     GESCAPE2            DOUBLE ESCAPE VERTICAL BAR (|)\n         B     GSTRING             DOUBLE QUOTE MARK (\")\n         EJECT\nGCONT    DS    0H                  It's a line continuation character\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If the last character of a line (RECFM=F or RECFM=V) is the         *\n* \"continuation character\" (which defaults to cent sign in the        *\n* readtable), then ignore the following newline and process the       *\n* characters in the next line as if it was all on one line.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal\n         BO    GALOOP              then process like ordinary char\n         LA    #0,1(,#6)           If address following this character\n         C     #0,ZLFEND           doesn't point to end of record\n         BL    GALOOP              then handle this like ordinary char\n         #GETC ,                   Otherwise get next character\n         LTR   #3,#3               which should be newline,\n         BNM   GABEND               or else cent sign\n         B     CONTINUE            and then go read the next one.\n         EJECT\n         SPACE\nGALOOP   DS    0H                  A NORMAL ATOM\n         C     #5,ZLCWALEN         IF LENGTH HAS ALREADY REACHED MAX\n         BL    NOT2LONG            THEN\n         #BAS  #14,INCRWA           ENLARGE THE WORK AREA\nNOT2LONG DS    0H                  ELSE\n         LTR   #4,#4               SKIP IF NO STORAGE WAS AVAILABLE\n         BZ    RSTSLASH\n         MVC   0(1,#4),0(#6)       MOVE CHARACTER TO ATOM AREA\n         TM    FLAGS,INBAR+SLASHED IF NOT ESCAPED IN EITHER WAY\n         BNZ   AFTASIS             THEN\n         TR    0(1,#4),UPTBL        FOLD TO UPPER CASE\nAFTASIS  DS    0H\n         LA    #4,1(,#4)           BUMP OUTPUT POINTER\n         LA    #5,1(,#5)           INCREMENT LENGTH\nRSTSLASH DS    0H\n         NI    FLAGS,255-SLASHED   RESET SINGLE-ESCAPE FLAG\nAFT2LONG DS    0H\n         #GETC ,                   GET THE NEXT CHARACTER\n         LTR   #3,#3               CHECK FOR EOF OR NEWLINE\n         BP    WHATISIT            IF NEITHER, PROCESS CHARACTER\n         BZ    GAFINISH            IF EOF, THEN END OF ATOM\n         TM    FLAGS,INBAR         IF NEWLINE, THEN IF WITHIN |  ... |\n         BO    AFT2LONG            THEN SKIP OVER IT, GET NEXT CHAR\n         B     GAFINISH            ELSE (NON-ESCAPED NEWLINE) END ATOM\n         SPACE 1\nWHATISIT DS    0H\n         L     #14,ZLCRDTBL        GET ADDR OF READ TABLE TO SCAN CHAR\n         TRT   0(1,#6),0(#14)      IF IT IS NOT A DELIMITER\n         BZ    GALOOP              THEN CONTINUE BUILDING ATOM TEXT\n         CLM   #2,1,=YL1(##PERIOD) IF IT IS A PERIOD\n         BE    GALOOP              THEN IT'S A NORMAL CHAR, CONTINUE\n         CLM   #2,1,=YL1(##ESCAPE) IF IT IS A BACKSLASH\n         BE    GESCAPE1            THEN PROCESS SINGLE ESCAPE CHAR\n         CLM   #2,1,=YL1(##BAR)    IF IT IS A VERTICAL BAR\n         BE    GESCAPE2            THEN PROCESS DOUBLE ESCAPE CHAR\n         CLM   #2,1,=YL1(##CONT)   IF IT IS A CONTINUATION CHARACTER\n         BE    GCONT1              THEN PROCESS DOUBLE ESCAPE CHAR\n* ELSE OTHER CHARACTER (PARENTHESIS, PERIOD, ETC.)\n         TM    FLAGS,INBAR         IF WE'RE ALREADY WITHIN BARS\n         BO    GALOOP              THEN PROCESS AS NORMAL CHARACTER\n         B     GAFINISH            ELSE TERMINATE ATOM\n         SPACE 1\nGESCAPE1 DS    0H                   PROCESS SINGLE ESCAPE CHAR\n         OI    FLAGS,NONUM          SHOW THIS CAN'T BE A NUMERIC ATOM\n         #GETC ,                    READ NEXT CHARACTER FOR ATOM\n         LTR   #3,#3                SEE IF EOF OR NEWLINE HIT\n         BZ    ESCERROR             IF EOF, FLAG AS SYNTAX ERROR\n         BP    ESCDOIT              IF NEWLINE, THEN\n         LA    #6,FAKECR             SET CHAR TO FAKE CARRIAGE RETURN\nESCDOIT  OI    FLAGS,SLASHED        CAUSE THIS CHAR NOT TO BE UPCASED\n         B     GALOOP               AND PROCESS AS REGULAR CHAR\n         SPACE 1\nGESCAPE2 DS    0H                  PROCESS VERTICAL BAR\n         TM    FLAGS,INBAR         IF ALREADY WITHIN BARS\n         BZ    NOTINBAR            THEN\n         NI    FLAGS,255-INBAR      SET BAR MODE OFF\n         B     AFT2LONG             GO TO PROCESS THE NEXT CHAR\nNOTINBAR DS    0H                  ELSE NOT IN BARS YET...\n         OI    FLAGS,INBAR+NONUM    INDICATE WITHIN BARS & NOT NUMERIC\n         B     AFT2LONG             GO TO PROCESS THE NEXT CHAR\n         SPACE 1\nGCONT1   DS    0H                  It's a line continuation character\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If the last character of a line (RECFM=F or RECFM=V) is the         *\n* \"continuation character\" (which defaults to cent sign in the        *\n* readtable), then ignore the following newline and process the       *\n* characters in the next line as if it was all on one line.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal\n         BO    GALOOP              then process like ordinary char\n         LA    #0,1(,#6)           If address following this character\n         C     #0,ZLFEND           doesn't point to end of record\n         BL    GALOOP              then handle this like ordinary char\n         #GETC ,                   Otherwise get next character\n         LTR   #3,#3                which should be newline,\n         BNM   GABEND                or elsecent sign\n         B     AFT2LONG            and then go read the next one.\n         SPACE 1\nSEOFERR  DS    0H                  NO CLOSING DELIMITER AT EOF\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2005 READ: Missing closing delimiter at end of file X\n               ',(#2),PREFIX=NO\n         SPACE 1\nESCERROR DS    0H                  ERROR - BACKSLASH FOLLOWED BY EOF\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2019 READ: No character following escape character -X\n                file ',(#2),PREFIX=NO\n         EJECT\nGAFINISH DS    0H                  ELSE END OF ATOM, NOW CREATE IT\n*\n*** CHECK FOR STORAGE ALLOCATION FAILURE\n*\n         LTR   #4,#4\n         BZ    AFAIL\n*\n*** CHECK ATOM TYPE - MAY BE NUMERIC - OR WE MAY HAVE TO BUILD SYMBOL\n*** STORE CURRENT CHARACTER POINTER IN CASE WE ERROR OUT BELOW...\n*\n         ST    #3,ZLFCHAR          STORE CURRENT CHARACTER POINTER\n         STM   #3,#7,SAVE37        SAVE VOLATILE REGS\n         LR    #0,#5               SET LENGTH OF ATOM TEXT\n         L     #1,ZLCWA            POINT TO AREA CONTAINING ATOM TEXT\n         LR    #2,#8               SET FLAG = T TO INTERN THE ATOM\n         TM    FLAGS,NONUM         IF AN ESCAPED ATOM\n         BNZ   DONTFMT             THEN MUST BE SYMBOL. ELSE NOT ESCD..\n         LR    #3,#8                SET FLAG = T TO FORMAT IF NUMERIC\n         B     AFTFMT              IF DELIMITED...\nDONTFMT  MVI   FLAGS,X'00'          TURN OFF FLAGS\n         LR    #3,#10               SET FLAG = NIL TO TREAT AS SYMBOL\nAFTFMT   DS    0H\n         L     #15,ZLCABLD         CALL ZILABLD TO BUILD NEW ATOM\n         LA    #4,12(,#11)         SET CURRENT STACK POINTER FOR CONS\n         #BASR #14,#15             AND PLACE IT ON OBLIST IF SYMBOL\n         LM    #3,#7,SAVE37        RESTORE VOLATILE REGS\n         XR    #2,#2               SET RETURN TO 0\n         B     READ1RET            RETURN TO CALLER WITH ATOM\n         EJECT\nGSTRING  DS    0H                  FOUND DOUBLE QUOTE \"\n         SPACE 1\n*\n* START A STRING.  READ CHARACTERS, BACKSLASHIFICATION INCLUDED,\n* UNTIL ANOTHER DOUBLE QUOTE MARK IS ENCOUNTERED.  BUILD THE STRING\n* DIRECTLY IN VECTOR/STRING SPACE (IF WE RUN OUT OF SPACE, SIGNAL\n* AN ERROR BUT NOT UNTIL WE READ TO THE END OF THE STRING).\n*\n* REGISTER USAGE:\n*\n* #4 --> CURRENT LOCATION IN VECTOR/STRING SPACE WHERE WE'RE BUILDING\n* #5 = STRING LENGTH AS WE GO\n*\n         L     #4,ZLCVSNXT         GET PTR TO AVAILABLE STRING SPACE\n         ST    #4,VSSTRING         SAVE CURRENT STRING POINTER\nSTRY     DS    0H\n         L     #0,ZLCVSADR         ADDR(VSSPACE)+LENGTH(VSSPACE)\n         A     #0,ZLCVSLEN         GIVES POINTER TO END OF STRING SPACE\n         XR    #5,#5               CLEAR STRING LENGTH SO FAR\n         LA    #1,4(,#4)           POINT TO WHERE TEXT IS GONNA GO\n         ST    #0,VSEND            SAVE POINTER TO END OF STRING SPACE\n         CR    #1,#0               IF PAST THE END\n         BL    SOK1                THEN\n         #BAS  #2,SNOROOM           NO ROOM, TRY TO MAKE SOME\n         LTR   #4,#4                IF STILL NO ROOM\n         BZ    SLOOP                THEN READ THROUGH W/O BUILDING\n         L     #4,VSSTRING          ELSE GET TRUE NEW STRING POINTER\n         B     STRY                 IF SUCCESSFUL, TRY AGAIN\nSOK1     DS    0H\n         ST    #5,0(,#4)           ELSE CLEAR STRING PREFIX\n         MVI   0(#4),##STRING      SET ATOM AND STRING TYPE BITS\n         LR    #4,#1               START POINTING TO STRING AREA\nSLOOP    DS    0H\n         #GETC ,                   GET AN INPUT CHARACTER\n         LTR   #3,#3               CHECK FOR EOF/NEWLINE\n         BP    SGOTCHAR            IF OK, PROCESS THE CHARACTER\n         BZ    SEOFERR             IF EOF, SIGNAL ERROR\n         LA    #6,FAKECR           IF NEWLINE, POINT TO FAKE CR\n         B     SCHAR               GO TO MOVE THE STRING\nSGOTCHAR DS    0H\n         L     #14,ZLCRDTBL        GET ADDRESS OF READ TABLE\n         TRT   0(1,#6),0(#14)      CHECK WHAT KIND OF CHARACTER WE GOT\n         BZ    SCHAR               IF NORMAL ONE, PROCESS IT\n         CLM   #2,1,=YL1(##DQUOTE) IF A DOUBLE QUOTE\n         BE    SDQUOTE             THEN PROCESS TERMINATING \"\n         CLM   #2,1,=YL1(##ESCAPE) IF SINGLE ESCAPE (BACKSLASH)\n         BE    SBSLASH             THEN PROCESS AS ESCAPE CHARACTER\n         CLM   #2,1,=YL1(##CONT)   IF CONTINUATION CHARACTER\n         BE    SCONT               THEN PROCESS AS ESCAPE CHARACTER\nSCHAR    DS    0H                  ELSE NORMAL CHARACTER\n         C     #4,VSEND            IF WE'RE AT THE END OF VSSPACE\n         BL    SOK2                THEN\n         #BAS  #2,SNOROOM           NO ROOM FOR STRING RIGHT NOW\n         C     #4,VSEND            IF WE'RE STILL AT THE END OF VSSPACE\n         BL    SOK2                THEN\n         #BAS  #2,SBOMB             PREPARE TO SIGNAL OUT-OF-SPACE\nSOK2     DS    0H                   TRY TO GET SOME\n         LTR   #4,#4               IF STRING CAN'T BE BUILT\n         BZ    SLOOP               THEN CONTINUE WITHOUT BUILDING\n         MVC   0(1,#4),0(#6)       ELSE MOVE CHAR INTO STRING SPACE\n         LA    #4,1(,#4)           INCREMENT POINTER\n         LA    #5,1(,#5)           INCREMENT LENGTH\n         B     SLOOP               CONTINUE\n         SPACE 1\nSBSLASH  DS    0H                  PROCESS BACKSLASHIFIED CHARACTER\n         #GETC ,                   GET THE NEXT CHARACTER\n         LTR   #3,#3               CHECK FOR NEWLINE/EOF\n         BZ    SEOFERR             IF EOF, SIGNAL ERROR\n         BP    SCHAR               IF POSITIVE, NORMAL CHARACTER\n         LA    #6,FAKECR           ELSE POINT TO FAKE CARRIAGE RETURN\n         B     SCHAR               AND PROCESS AS NORMAL CHARACTER\n         SPACE 1\nSCONT    DS    0H                  It's a line continuation character\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If the last character of a line (RECFM=F or RECFM=V) is the         *\n* \"continuation character\" (which defaults to cent sign in the        *\n* readtable), then ignore the following newline and process the       *\n* characters in the next line as if it was all on one line.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal\n         BO    SCHAR               then process like ordinary char\n         LA    #0,1(,#6)           If address following this character\n         C     #0,ZLFEND           doesn't point to end of record\n         BL    SCHAR               then handle this like ordinary char\n         #GETC ,                   Otherwise get next character\n         LTR   #3,#3                which should be newline,\n         BNM   GABEND                or elsecent sign\n         B     SLOOP               and then go read the next one.\n         SPACE 1\nSDQUOTE  DS    0H                  PROCESSING TERMINATING DOUBLE QUOTE\n         LTR   #4,#4               IF STRING ERROR OCCURRED\n         BZ    SFAIL               THEN FAIL\n         L     #15,VSSTRING        ELSE POINT TO STRING WE JUST BUILT\n         STCM  #5,7,1(#15)         SET STRING LENGTH\n         LTR   #5,#5               IF NULL STRING\n         BP    SNZERO              THEN\n         LA    #4,1(,#4)            INSURE AT LEAST A FULLWORD OF SPACE\nSNZERO   DS    0H\n         LA    #4,3(,#4)           ROUND END-POINTER UP TO FULLWORD\n         N     #4,=X'FFFFFFFC'     TO INSURE VSSPACE ALIGNMENT\n         ST    #4,ZLCVSNXT         SET NEW NEXT-AVAILABLE-VSSPACE-SLOT\n         #GETC ,                   PRIME READER WITH NEXT CHARACTER\n         XR    #2,#2               RETURN CODE(ZERO)\n         B     READ1RET            RETURN WITH SOMETHING FOUND\n         SPACE 1\nSFAIL    DS    0H                  FAILED TO MAKE A STRING\n         #GETC ,                   PRIME READER WITH NEXT CHARACTER\nAFAIL    DS    0H                  FAILED TO MAKE A SYMBOL\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #4,VSERROR          Get error message address\n         L     #2,ZLFATOM          Load file atom for message\n         #ERR  (#4),(#2),PREFIX=NO Signal error\n         SPACE 1\nSNOROOM  DS    0H                  WHAT HAPPENS IF OUT OF STRING SPACE\n         SPACE 1\n*\n* ATTEMPT A GARBAGE COLLECTION, WHICH MAY FREE UP SOME STRING SPACE.\n* THIS SHOULD CAUSE THE CURRENT SPACES TO BE FLIPPED, BUT WE WILL\n* STILL BE POINTING INTO THE ORIGINAL (NOW OLD) SPACE. SO, AFTER THE\n* GARBAGE COLLECTION, IF THERE'S ROOM IN THE NEW SPACE, WE MOVE THE\n* STRING WE'RE BUILDING INTO THE NEW SPACE AND KEEP GOING.\n*\n         L     #9,ZLCGCEND         FORCE END OF FREE LIST\n         ST    #2,VSSAVE2          SAVE RETURN REGISTER\n         LR    #1,#10              SET DUMMY ARG 1 TO CONS = NIL\n         LR    #2,#10              SET DUMMY ARG 1 TO CONS = NIL\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         LA    #0,12(,#11)         SET POINTER TO (NO) ARGS ON STACK\n         #BASR #14,#15             CALL CONS 2 FORCE GARBAGE COLLECTION\n         L     #2,VSSAVE2          RESTORE RETURN REGISTER\n         L     #0,ZLCVSADR         ADDR(NEW_VSSPACE)\n         A     #0,ZLCVSLEN         + LENGTH(NEW_VSSPACE)\n         S     #0,ZLCVSNXT         - ADDR(NEW_AVAILABLE_SLOT)\n         CH    #0,=H'8'            ALWAYS NEED AT LEAST 8 BYTES\n         BL    SBOMB               OR ELSE DIE\n         LA    #15,4(,#5)          GET LENGTH OF STRING SO FAR + 4\n         CR    #0,#15              COMPARE TO NEW AVAILABLE LENGTH\n         BL    SBOMB               IF STILL NOT LONG ENOUGH, DIE.\n         L     #14,VSSTRING        ELSE GET POINTER TO OLD STRING\n         L     #0,ZLCVSNXT         GET POINTER TO NEW STRING LOC\n         ST    #0,VSSTRING         SAVE IT\n         LR    #1,#15              GET LENGTH TOO\n         MVCL  #0,#14              MOVE STRING TO ITS NEW HOME\n         LR    #4,#0               SET NEW OUTPUT POINTER\n         L     #0,ZLCVSADR         ADDR(VSSPACE)+LENGTH(VSSPACE)\n         A     #0,ZLCVSLEN         GIVES POINTER TO END OF STRING SPACE\n         ST    #0,VSEND            SAVE NEW POINTER TO END OF SPACE\n         BR    #2                  AND RETURN\nSBOMB    DS    0H\n         LA    #1,ZIL2022          SIGNAL \"NO STRING SPACE\" ERROR\n         ST    #1,VSERROR\n         XR    #4,#4               STOP BUILDING THE STRING\n         BR    #2                  RETURN\n         EJECT\nGLEFTP   DS    0H                  FOUND A LEFT PARENTHESIS (\n         SPACE\n*\n* START A LIST.  REPEATEDLY CALL READ1 RECURSIVELY, RETURNING\n* AN S-EXPRESSION FOR EACH CALL AND CONSING THEM ALL TOGETHER.\n* FINISH WHEN A RIGHT PARENTHESIS IS ENCOUNTERED.\n*\n         ST    #10,12(,#11)        INITIALIZE LIST TO NIL\n         LA    #1,12-##CDR(,#11)   @ PSEUDO-CONS TO STORE THE 1ST CELL\n         ST    #1,16(,#11)         SAVE POINTER TO WHERE TO PUT IT\n         #GETC ,                   PRIME WITH NEXT CHARACTER\nGLGO     DS    0H\n         LA    #1,20(,#11)         SET STACK POINTER\n         #BAS  #14,READ1           GO GET AN ELEMENT OF THE LIST\n         B     R1BR(#2)            BRANCH DEPENDING ON RETURN CODE\nR1BR     B     R1GOTIT             0...WE GOT SOMETHING\n         B     R1ENDIT             4...RIGHT PARENTHESIS FOUND\n         B     R1DOT               8...PERIOD FOUND\n         B     R1EOF               12...EOF ENCOUNTERED\n         EJECT\nR1GOTIT  DS    0H                  READ1 RETURNED SOMETHING GOOD\n         SPACE\n         LR    #1,#15              ARG 1 TO CONS = WHAT READ1 FOUND\n         LR    #2,#10              ARG 2 TO CONS = NIL\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL CONS TO CONTINUE BUILDING LIST\n         L     #1,16(,#11)         GET PTR TO CELL TO RPLACD THIS INTO\n         ST    #15,##CDR(,#1)      SAVE THIS CELL OF LIST\n         ST    #15,16(,#11)        CELL TO RPLACD NEXT LIST CELL INTO\n         B     GLGO                GO GET ANOTHER S-EXPRESSION\n         EJECT\nR1ENDIT  DS    0H                  RIGHT PAREN FOUND - END THE LIST\n         SPACE\n         L     #15,12(,#11)        PICK UP POINTER TO LIST\n         XR    #2,#2               SET NORMAL RETURN\n         B     READ1RET            THEN RETURN\n         EJECT\nR1DOT    DS    0H                  PERIOD FOUND - BUILD A DOTTED PAIR\n         SPACE\n*\n* IF A DOT FOLLOWS A LEFT PARENTHESIS WITH NO INTERVENING S-EXPRESSION\n* THEN FLAG AS SYNTAX ERROR AND ACCEPT IT ANYWAY.\n*\n         C     #10,12(,#11)        IF LIST BUILT SO FAR IS NIL\n         BNE   R1DOTOK             THEN\nR1DOTERR DS    0H                  SYNTAX ERROR IN DOTTED PAIR\n         #ERR  1,'ZIL2009 READ: Syntax error in dotted pair',          X\n               PREFIX=NO           REPORT IT BUT CONTINUE ANYWAY\n         OI    SYNFLAGS,SYNERROR   AND INDICATE A SYNTAX ERROR\n         SPACE 1\nR1DOTOK  DS    0H\n         LA    #1,20(,#11)         SET STACK POINTER\n         #BAS  #14,READ1           GO GET AN ELEMENT OF THE LIST\n         B     R2GO(#2)            BRANCH DEPENDING ON RETURN CODE\nR2GO     B     R2GOTIT             0...WE GOT SOMETHING\n         B     R1ERR               4...RIGHT PARENTHESIS FOUND\n         B     R2ERR               8...PERIOD FOUND\n         B     R1EOF               12...EOF ENCOUNTERED\n         EJECT\nR2GOTIT  DS    0H\n         SPACE\n*\n* THIS IS AN S-EXPRESSION THAT FOLLOWS THE DOT IN A DOTTED PAIR\n* PROCESS ATOM BY MAKING IT THE CDR OF THE CURRENT CONS\n*\n         L     #1,16(,#11)         PTR TO CELL TO RPLACD WITH THIS ONE\n         ST    #15,##CDR(,#1)      PUT THIS CELL AS CDR OF PREV CELL\n*\n* THE NEXT THING WE SHOULD SEE IS A RIGHT PARENTHESIS.\n* ANYTHING ELSE IS AN ERROR AND IS IGNORED UNTIL WE SEE THAT ) .\n*\nDOTCLNUP DS    0H\n         LA    #1,20(,#11)         SET STACK POINTER\n         #BAS  #14,READ1           GO GET AN ELEMENT OF THE LIST\n         B     R3GO(#2)            BRANCH DEPENDING ON RETURN CODE\nR3GO     B     R2EXTRA             0...WE GOT SOMETHING\n         B     R1ENDIT             4...RIGHT PARENTHESIS FOUND\n         B     R2ERR               8...PERIOD FOUND\n         B     R1EOF               12...EOF ENCOUNTERED\n         EJECT\nR1EOF    DS    0H                  EOF IN MIDDLE OF LIST - NO GOOD\n         SPACE\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2002 READ: Missing right paren(s) at end of file ', X\n               (#2),PREFIX=NO\n         SPACE\nR2EXTRA  DS    0H                  EXTRA STUFF TO IGNORE UNTIL )\n         SPACE\n         #ERR  1,'ZIL2004 READ: Extraneous data in dotted pair',       X\n               PREFIX=NO\n         OI    SYNFLAGS,SYNERROR   INDICATE A SYNTAX ERROR\n         B     DOTCLNUP            KEEP LOOKING FOR RIGHT PAREN\n         SPACE\nR2ERR    DS    0H                  EXTRA DOT IN DOTTED PAIR - NO GOOD\n         SPACE\n         #ERR  1,'ZIL2009 READ: Syntax error in dotted pair',          X\n               PREFIX=NO\n         OI    SYNFLAGS,SYNERROR   INDICATE A SYNTAX ERROR\n         B     DOTCLNUP            KEEP LOOKING FOR RIGHT PAREN\n         SPACE\nR1ERR    DS    0H\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2009 READ: Syntax error in dotted pair - file ',    X\n               (#2),PREFIX=NO\n         EJECT\nGRIGHTP  DS    0H                  FOUND A RIGHT PARENTHESIS )\n         SPACE\n         #GETC ,                   NEXT CHAR WILL FOLLOW IT\n         LA    #2,4                SET RETURN TO 4\n         B     READ1RET            AND RETURN WITH IT\n         EJECT\nGSEMI    DS    0H                  FOUND A SEMICOLON ;\n         SPACE\n         LA    #3,1                ALL WE WANT TO DO IS...\n         AH    #3,ZLFLRECL         FORCE END OF RECORD\n         B     CONTINUE            SKIP REST OF RECORD, CONTINUE\n         EJECT\nGPERIOD  DS    0H                  FOUND A PERIOD .\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* TENTATIVELY START BUILDING AN ATOM WITH THIS CHARACTER IN CASE THIS *\n* TURNS OUT TO BE PART OF ONE RATHER THAN A TRUE PERIOD.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   0(1,#4),0(#6)       MOVE THE PERIOD TO THE ATOM AREA\n         LA    #5,1                SET LENGTH SO FAR TO 1\n         LA    #4,1(,#4)           BUMP ATOM POINTER\nGPGET    DS    0H\n         #GETC ,                   LOOK AT NEXT CHAR\n         LTR   #3,#3               CHECK FOR EOF OR NEWLINE\n         BZ    R1DOTERR            IF EOF HIT, FLAG AS ERROR\n         BM    GISADOT             IF NEWLINE HIT, IT REALLY IS A DOT\n         L     #14,ZLCRDTBL        GET ADDR OF READ TABLE TO SCAN CHAR\n         TRT   0(1,#6),0(#14)      CHECK WHAT KIND OF CHARACTER THIS IS\n         BZ    GALOOP              IF NORMAL, PERIOD IS PART OF AN ATOM\n         CLM   #2,1,=YL1(##PERIOD) IF PERIOD, PERIOD IS PART OF AN ATOM\n         BE    GALOOP\n         CLM   #2,1,=YL1(##ESCAPE) IF ESCAPE, PERIOD IS PART OF AN ATOM\n         BE    GESCAPE1\n         CLM   #2,1,=YL1(##BAR)    IF BAR, PERIOD IS PART OF AN ATOM\n         BE    GESCAPE2\n         CLM   #2,1,=YL1(##CONT)   IF CONTINUATION, DON'T KNOW...\n         BE    GCONTP\nGISADOT  DS    0H                  ELSE IT'S A DOTTED PAIR PERIOD\n         LA    #2,8                SET RETURN TO 8\n         B     READ1RET            AND RETURN WITH IT\n         SPACE 1\nGCONTP   DS    0H                  It's a line continuation character\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* If the last character of a line (RECFM=F or RECFM=V) is the         *\n* \"continuation character\" (which defaults to cent sign in the        *\n* readtable), then ignore the following newline and process the       *\n* characters in the next line as if it was all on one line.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ZLFFLAG1,ZLFTERM    If this is from the terminal\n         BO    GALOOP              then process like ordinary char\n         LA    #0,1(,#6)           If address following this character\n         C     #0,ZLFEND           doesn't point to end of record\n         BL    GALOOP              then handle this like ordinary char\n         #GETC ,                   Otherwise get next character\n         LTR   #3,#3                which should be newline,\n         BNM   GABEND                or elsecent sign\n         B     GPGET               and then go read the next one.\n         SPACE 1\n         EJECT\nGMACRO   DS    0H                  PROCESS READER MACRO CHARACTER\n         SPACE\n         ICM   #4,15,ZLCRMCHN      START SEARCHING READER MACRO CHAIN\nGMLOOP   DS    0H\n         BZ    NOMACDEF            IF NO MACRO DEFINED, ERROR\n         CLC   0(1,#4),0(#6)       IF MACRO CHARACTER MATCHES\n         BE    GMMATCH             THEN WE HAVE IT\n         ICM   #4,15,##CDR(#4)     ELSE GET NEXT MACRO FORM IN CHAIN\n         B     GMLOOP              AND CONTINUE CHECKING.\nGMMATCH  DS    0H                  MACRO FOUND\n         MVC   ZLCRMCHR,0(#6)      SET MACRO CHAR FOR RMCHAR FUNCTION\n         #GETC ,                   BUMP TO NEXT CHARACTER\n         ST    #3,ZLFCHAR          UPDATE CHARACTER POINTER\n         ST    #7,20(,#11)         SAVE FILE SPEC\n         L     #14,0(,#11)         GET FILE ARGUMENT\n         XR    #15,#15             CLEAR INSERT REGISTER\n         ST    #14,28(,#11)        SET ARG 1 TO MACRO FUNCTION = FILE\n         ICM   #15,7,1(#4)         GET ADDRESS OF MACRO PROCESSOR\n         LA    #1,28(,#11)         POINT TO ARGUMENT ON STACK\n******** LA    #2,1*4              SET # OF ARGS * 4 FOR FUNCTION\n*\n* The following code imitates the code sequence generated by the\n* MULTIPLE-VALUE-LIST function to return a list of multiple values.\n*\n         ST    #11,24(,#11)        Prime for multiple value receiving\n         #BASR #14,#15             CALL THE MACRO PROCESSOR\n         C     #11,24(,#11)        Test for multiple value list\n         L     #7,20(,#11)         RESTORE FILE SPEC\n         L     #3,ZLFCHAR          PICK UP UPDATED CHARACTER POINTER\n         LA    #2,ZLCRMNIL         GET ADDRESS OF \"RMNIL\" OBJECT\n         L     #14,ZLCRDTBL        RESET READ TABLE POINTER\n         BE    RMMV1               If multiple value list ret'd, then\n         L     #15,24(,#11)        load up the multiple value list\n         CR    #15,#10             if null value list (VALUES) ret'd\n         BE    R1GO                then go read another form.\n         L     #15,##CAR(,#15)     else load the first value\nRMMV1    DS    0H                  #15 = the one and only value\n         CR    #15,#2              IF THE READER MACRO RETURNED (RMNIL)\n         BE    R1GO                THEN GO READ ANOTHER FORM. ELSE\n         XR    #2,#2               RETURN WITH NORMAL VALUE IN #15\n         B     READ1RET\nNOMACDEF DS    0H\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2018 READ: Internal error in reader macro processingX\n                - file ',(#2),PREFIX=NO\n         EJECT\nREAD1RET DS    0H                  RETURN FROM READ1\n         LR    #1,#11              RESTORE STACK POINTER\n         L     #11,8(,#1)\n         L     #14,4(,#1)\n         BR    #14\n         EJECT\nINCRWA   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE IS CALLED WHEN THE ATOM BEING BUILT EXCEEDS THE     *\n* SIZE OF THE CURRENT WORKAREA.  IT ALLOCATES A LARGER WORKAREA,      *\n* COPIES THE OLD INTO THE NEW, FREES THE OLD AND RESETS THE POINTER   *\n* IN #4 TO THE NEW.  RETURN REGISTER IS #14.  THIS SUBROUTINE ALTERS  *\n* REGISTERS #0, #1 AND #15.                                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #4,#4               IF POINTER ALREADY ZERO\n         BZR   #14                 THEN RETURN WITHOUT TRYING\n         ST    #14,INCRSAVE        ELSE SAVE RETURN REGISTER\n         L     #4,ZLCWA            GET ADDRESS OF NEW WORKAREA\n         L     #14,ZLCWALEN        GET CURRENT WORKAREA LENGTH\n         ST    #14,INCRSAVL        SAVE IT FOR FUTURE FREEMAIN\n         LA    #0,512(,#14)        COMPUTE NEW WORKAREA LENGTH\n         ST    #0,ZLCWALEN         SET NEW WORKAREA LENGTH\n         #GETMAIN RC,LV=(0),LOC=BELOW SET A NEW LARGER WORKAREA\n         LTR   #15,#15             IF GETMAIN FAILED (NO MEMORY)\n         BNZ   INCRERR             THEN ERROR\n         ST    #1,ZLCWA            SAVE NEW WORKAREA ADDRESS\n         LR    #0,#1               ADDRESS OF NEW WORKAREA\n         L     #1,ZLCWALEN         LENGTH OF NEW WORKAREA\n         LR    #14,#4              ADDRESS OF OLD WORKAREA\n         L     #15,INCRSAVL        LENGTH OF OLD WORKAREA\n         MVCL  #0,#14              COPY OLD WORKAREA TO NEW WORKAREA\n         LR    #1,#4               GET ADDRESS OF OLD WORKAREA\n         L     #0,INCRSAVL         GET LENGTH OF OLD WORKAREA\n         FREEMAIN R,LV=(0),A=(1)   FREE THE OLD WORKAREA\n         L     #4,ZLCWA            GET ADDRESS OF NEW WORKAREA\n         ALR   #4,#5               SET POINTER TO NEW PORTION OF AREA\n         L     #14,INCRSAVE        RESTORE RETURN REGISTER\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nINCRERR  DS    0H\n         LA    #1,ZIL2007          SIGNAL \"NOT ENOUGH CORE\" ERROR\n         ST    #1,VSERROR          SAVE FOR FUTURE ERROR FLAGGING\n         XR    #4,#4               ZERO OUT WORKAREA POINTER\n         XR    #5,#5               ZERO OUT WORKAREA LENGTH\n         LA    #0,512              GET ANOTHER 256-BYTE AREA\n         ST    #0,ZLCWALEN         TO REINITIALIZE WORK AREA\n         #GETMAIN RU,LV=(0),LOC=BELOW (IT'S GOT TO BE AVAILABLE OR ELSE\n         ST    #1,ZLCWA            STORE ITS ADDRESS AND LENGTH\n         L     #14,INCRSAVE        RESTORE RETURN REGISTER\n         BR    #14                 RETURN TO CALLER\n         EJECT\nGABEND   #ERR  'ZIL2018 READ: Expected newline not found following contX\n               inuation character.'\n         EJECT\nSAVE37   DS    5A                  SAVE AREAS\nINCRSAVE DS    A\nINCRSAVL DS    A\n         SPACE\n*\n* FIELDS USED BY STRING PROCESSING\n*\nVSSTRING DS    A                   POINTER TO STRING BEING BUILT\nVSEND    DS    A                   POINTER TO END OF AVAILABLE VSSPACE\nVSSAVE2  DS    A                   REGISTER SAVE\nVSERROR  DS    A                   ERROR MESSAGE ADDRESS\n         SPACE\nFAKECR   DC    X'0D'               CHARACTER TO BE USED AS FAKE CR\n         SPACE\nFLAGS    DC    X'00'               FLAGS FOR ATOM PROCESSING\nNONUM    EQU   X'80'               1 = ESCAPE FOUND, ATOM NOT NUMERIC\nINBAR    EQU   X'40'               1 = WITHIN VERTICAL BARS\nSLASHED  EQU   X'20'               1 = PRECEDED BY BACKSLASH\nSYNFLAGS DC    X'00'               FLAGS FOR ENTIRE S-EXPRESSION\nSYNERROR EQU   X'80'               1 = SYNTAX ERROR ENCOUNTERED\nDLM      DS    C                   DELIMITER CHARACTER\n         SPACE\n         DS    0H,XL1              Align string to non-halfword\nZIL2007  #SATM 'ZIL2007 READ: Not enough memory to build symbol name - X\n               file '\n         DS    0H,XL1              Align string to non-halfword\nZIL2022  #SATM 'ZIL2022 READ: Not enough vector/string space to build sX\n               tring - file '\n         SPACE\nUPTBL    DC    256YL1(*-UPTBL)     TABLE TO FOLD TO UPPER CASE\n         ORG   UPTBL+X'81'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+X'91'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+X'A2'\n         DC    C'STUVWXYZ'\n         ORG\n         SPACE 1\n         DROP  #12\n         SPACE 1\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n* (tyi &optional file eofval newlineval)                              *\n*  is sort of like                                                    *\n* (zdread file #b1 nil eof-error-p eofval newlineval)                 *\n*                                                                     *\n* reads a character from file and returns eofval if EOF hit,          *\n* newlineval if NEWLINE hit,                                          *\n* and a character (fixnum) if a character hit.                        *\n*                                                                     *\n* The default value returned for eof is -1.                           *\n*                                                                     *\n* The default value returned for newline is X'0D' (#\\CR).             *\n*                                                                     *\n* This is like the Maclisp syntax, but extended with an additional    *\n* optional argument for ZIL, whose 370 environment has to worry       *\n* about what to do with those pesky newline conditions.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*               8(#11) --> arg3    not used by TYI                    *\n*              12(#11) --> arg4    eof-error-p                        *\n*              16(#11) --> arg5    eofval                             *\n*              20(#11) --> arg6    newlineval                         *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILTYI   DS    0D                  This is TYI\n         SPACE\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING ZILTYI,#12\n         SPACE\n*\n* If there was a character restored by UNTYI, then return that char.\n*\n*                                  Check status of unread character\n         CLI   ZLFUNRST,ZLFSTINV   If the unread character is invalid\n         BE    TYNUNCH             then don't process it\n         CLI   ZLFUNRST,ZLFSTVLD   If the unread character is invalid\n         BE    TYRUNCH             then return unread character\n******** CLI   ZLFUNRST,ZLFSTEOL   If the unread character is newline\n******** BE    TYRUNEOL            then return newline\n         CLI   ZLFUNRST,ZLFSTEOF   If the unread character is EOF\n         BE    TYRUNEOF            then return EOF\nTYRUNEOL DS    0H                  Return UNTYI'd newline\n         L     #15,20(,#11)        Get newlineval\n         B     TYUNRET             Return it\nTYRUNEOF DS    0H                  Return UNTYI'd EOF\n         L     #15,16(,#11)        Get eofval\n         B     TYUNRET             Return it\nTYRUNCH  DS    0H                  Return UNTYI'd character\n         XR    #2,#2               Clear insert register\n         IC    #2,ZLFUNRCH         Get character into register\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Get address of fixnum from table\n******** B     TYUNRET             Return it\nTYUNRET  DS    0H                  Return unread stuff\n         MVC   ZLFLSTST,ZLFUNRST   Last char status = this char status\n         MVI   ZLFUNRST,ZLFSTINV   Invalidate unread character\n         B     TYRETNOC            and return with it.\n         SPACE\nTYNUNCH  DS    0H                  Else no unread character valid...\n         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT\n         BO    TYAFTEOF            THEN ERROR - READ AFTER EOF\n         SPACE\n         L     #3,ZLFCHAR          GET CURRENT POSITION\nTYGOTINP DS    0H\n         LTR   #3,#3               CHECK INPUT POINTER\n         BP    TYINPTOK            IF POSITIVE, WE HAVE GOOD STUFF\n         BM    TYINL               IF NEGATIVE, RETURN AS A NEWLINE\n******** BZ    TYIEOF              IF ZERO, EOF ENCOUNTERED\n         SPACE\nTYIEOF   DS    0H                  EOF HIT ON LAST READ\n         OI    ZLFFLAG1,ZLFEOF     INDICATE EOF FOR NEXT CALL\n         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE OFF\n         MVI   ZLFLSTST,ZLFSTEOF   Indicate last char read was EOF\n         L     #15,16(,#11)        Get eofval\n         B     TYRETURN            and return it\n         SPACE\nTYINL    DS    0H                  NEWLINE HIT ON LAST READ\n*\n* THE FOLLOWING IS TO PREVENT AN EXTRA KEYBOARD UNLOCK WHEN THE\n* INPUT FILE IS A TERMINAL AND END-OF-LINE HAS BEEN ENCOUNTERED.\n* REMEMBER THAT \"READ\" IGNORES END-OF-LINE IT IT IS THE FIRST\n* THING THAT IT SEES - IF THIS WERE NOT THE CASE, READ WOULD\n* HAVE TO BE CHANGED AS WELL.\n*\n         TM    ZLFFLAG1,ZLFNEWLN   IF WE ALREADY RETURNED NEWLINE/NIL,\n         BZ    TYNLNEW1            THEN...\n         NI    ZLFFLAG1,255-ZLFNEWLN SET IT OFF AGAIN\n         #GETC ,                    READ IN THE NEXT CHARACTER\n         B     TYGOTINP             AND TRY TO PROCESS IT\nTYNLNEW1 DS    0H                  ELSE...\n         OI    ZLFFLAG1,ZLFNEWLN   INDICATE NEWLINE\n         MVI   ZLFLSTST,ZLFSTEOL   Indicate last char read was newline\n         L     #15,20(,#11)        Get newlineval\n         B     TYRETURN            and return it\n         SPACE\nTYINPTOK DS    0H                  REG 3 LOCATES CURRENT CHARACTER\n         SPACE\n         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE INDICATOR OFF\n         LR    #4,#3               CONVERT RELATIVE COLUMN TO\n         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE\n         A     #4,ZLFCARD          Get address of character\n         XR    #2,#2               Clear insert register\n         IC    #2,0(,#4)           Get character into register\n         STC   #2,ZLFLSTCH         Set last-read-character\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Get address of fixnum from table\n         MVI   ZLFLSTST,ZLFSTVLD   Indicate last char read is valid\n         L     #3,ZLFCHAR          RELOAD CHARACTER POINTER\n         #GETC ,                   GET NEXT CHARACTER BEFORE RETURN\n         SPACE\nTYRETURN DS    0H\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\nTYRETNOC DS    0H\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE\nTYAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 TYI: Read after end of file ',(#2),            X\n               PREFIX=NO\n         SPACE\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n* (tyipeek &optional junk file eofval newlineval)                     *\n*  is sort of like                                                    *\n* (zdread file #b11 junk eof-error-p eofval newlineval)               *\n*                                                                     *\n* peeks at a character from file and returns eofval if EOF hit,       *\n* newlineval if NEWLINE hit,                                          *\n* and a character (fixnum) if a character hit.                        *\n*                                                                     *\n* This is like the Maclisp syntax, but extended with an additional    *\n* optional argument for ZIL, whose 370 environment has to worry       *\n* about what to do with those pesky newline conditions.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*               8(#11) --> arg3    NIL, T, or a character             *\n*              12(#11) --> arg4    eof-error-p                        *\n*              16(#11) --> arg5    eofval                             *\n*              20(#11) --> arg6    newlineval                         *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILTYIPK DS    0D                  This is TYIPEEK\n         SPACE\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING ZILTYIPK,#12\n         SPACE\n         L     #6,8(,#11)          Get arg 1 to TYIPEEK\n         CR    #6,#10              If NIL\n         BE    TPARGNIL            then OK\n         CR    #6,#8               If T\n         BE    TPARGT              then OK\n         CLI   ##TYPE(#6),##FIXNUM If a character\n         BNE   TPARG1ER            then\n         L     #2,##CDR(,#6)        Get the character\n         CL    #2,#SFW255           Must be between 0 and 255\n         BH    TPARG1ER             otherwise error\n         B     TPARG1OK            If not NIL, T or character, error\n         SPACE\nTPARGNIL DS    0H                  Arg 1 to TYIPEEK is NIL\nTPARGT   DS    0H                  Arg 1 to TYIPEEK is T\nTPARG1OK DS    0H                  #6 = NIL, T or pointer to fixnum\n*\n* If there was a character restored by UNTYI, then return that char.\n*\n*                                  Check status of unread character\n         CLI   ZLFUNRST,ZLFSTINV   If the unread character is invalid\n         BE    TPNUNCH             then don't process it\n         MVC   ZLFLSTST,ZLFUNRST   Last char status = this char status\n         CLI   ZLFUNRST,ZLFSTVLD   If the unread character is real\n         BE    TPRUNCH             then return unread character\n         CLI   ZLFUNRST,ZLFSTEOL   If the unread character is newline\n         BE    TPCKEOL             then return newline\n         CLI   ZLFUNRST,ZLFSTEOF   If the unread character is EOF\n         BE    TPRETEOF            then return EOF\nTPRUNCH  DS    0H                  Return UNTYI'd character\n         XR    #2,#2               Clear insert register\n         IC    #2,ZLFUNRCH         Get character into register\n         B     TPCKCHAR            Go to check it\nTPNUNCH  DS    0H                  Else no unread character valid...\n         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT\n         BO    TPAFTEOF            THEN ERROR - READ AFTER EOF\nTPCHKIT  DS    0H\n         ICM   #3,15,ZLFCHAR       GET CURRENT POSITION\n         BP    TPINPOK             IF POSITIVE, WE HAVE GOOD STUFF\n         BM    TPEEKNL             IF NEGATIVE, RETURN AS A NEWLINE\n******** BZ    TPEEKEOF            IF ZERO, EOF ENCOUNTERED\n         SPACE 1\nTPEEKEOF DS    0H\n         MVI   ZLFLSTST,ZLFSTEOF   Indicate last char read was EOF\nTPRETEOF DS    0H\n         L     #15,16(,#11)        Get eofval\n         B     TPRETURN            and return with it\n         SPACE\nTPEEKNL  DS    0H\n*\n* #3 is negative, meaning a newline condition.  If ZLFNEWLN has not\n* been set on, this means that TYI has not yet seen a newline, so\n* return the newline parameter.  Otherwise, TYI has already seen a\n* newline, so get another character, bump the pointer back, and\n* return that character.\n*\n         TM    ZLFFLAG1,ZLFNEWLN   If newline bit is already on,\n         BZ    TPNNLYET            then...\n         NI    ZLFFLAG1,255-ZLFNEWLN turn newline bit off\n         #GETC ,                    get character from next line\n         L     #6,8(,#11)           reload arg 1 to TYIPEEK\n         B     TPCHKIT              and check it again. Else...\nTPNNLYET DS    0H                  No newline yet, return newline parm\n         MVI   ZLFLSTST,ZLFSTEOL   Indicate last char read was newline\nTPCKEOL  DS    0H\n         L     #15,20(,#11)        Get newlineval\n         CR    #6,#10              If (TYIPEEK NIL ...)\n         BE    TPRETURN            then accept this\n         CR    #6,#8               If (TYIPEEK T ...)\n         BE    TPSKIP              then always consider this whitespace\n*                                  Else (TYIPEEK character ...)\n         CLC   0(8,#6),0(#15)      If character not EQL to newlineval\n         BNE   TPSKIP              then skip this character\n         B     TPRETURN            else accept it.\n         SPACE\nTPINPOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER\n         SPACE\n         LR    #4,#3               CONVERT RELATIVE COLUMN TO\n         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE\n         A     #4,ZLFCARD          Get address of character\n         XR    #2,#2               Clear insert register\n         IC    #2,0(,#4)           Get character into register\n         STC   #2,ZLFLSTCH         Set last-read-character\n         MVI   ZLFLSTST,ZLFSTVLD   Indicate last char read is valid\nTPCKCHAR DS    0H\n         CR    #6,#10              If (TYIPEEK NIL ...)\n         BE    TPRETCHR            then accept this character\n         CR    #6,#8               If (TYIPEEK T ...)\n         BE    TPCKWSP             then do whitespace test\n         C     #2,##CDR(,#6)       If character not EQL to UNTYI'd char\n         BNE   TPSKIP              then skip this character\n         B     TPRETCHR            else accept this character\nTPCKWSP  DS    0H                  Do whitespace test for character\n         L     #14,ZLCRDTBL        Get address of read table\n         AR    #14,#2              Point to syntax bits for character\n         CLI   0(#14),##BLANK      If this is a whitespace character\n         BE    TPSKIP              then skip.\n******** B     TPRETCHR            Else accept.\nTPRETCHR DS    0H                  Return character in #2\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Get address of fixnum from table\n******** B     TPRETURN            and return with it\n         SPACE\nTPRETURN DS    0H                  #15 points to character\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE 1\nTPSKIP   DS    0H                  (TYIPEEK T/char ...) rejected this\n         L     #3,ZLFCHAR          Reload current character pointer\n         #GETC ,                   Get next character\n         ST    #3,ZLFCHAR          Reload current character pointer\n         L     #6,8(,#11)          Reload arg 1 to TYIPEEK\n         B     TPCHKIT             Check it again\nTPARG1ER DS    0H\n         #ERR  'Argument 1 to TYIPEEK not NIL, T or a character - ',   X\n               8(#11)\nTPAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 TYIPEEK: Read after end of file ',(#2),        X\n               PREFIX=NO\n         SPACE 1\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n* (untyi char &optional file eofval newlineval)                       *\n*  is sort of like                                                    *\n* (zdread file #b10 char eof-error-p eofval newlineval)               *\n*                                                                     *\n* \"unreads\" a character from file.  If the last thing read from file  *\n* was EOF, eofval is returned; if EOL, newlineval is returned;        *\n* else a character (fixnum) if a character hit.                       *\n*                                                                     *\n* This is like the Maclisp syntax, but extended with an additional    *\n* optional argument for ZIL, whose 370 environment has to worry       *\n* about what to do with those pesky newline conditions.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*               8(#11) --> arg3    the character to be unread         *\n*              12(#11) --> arg4    eof-error-p                        *\n*              16(#11) --> arg5    eofval                             *\n*              20(#11) --> arg6    newlineval                         *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILUNTYI DS    0D                  This is UNTYI\n         SPACE\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING ZILUNTYI,#12\n         SPACE\n         L     #5,8(,#11)          Get arg 1 to UNTYI\n         CLI   ZLFUNRST,ZLFSTINV   If unread char is still valid\n         BNE   TUTWICE             then error\n         CLI   ZLFLSTST,ZLFSTEOF   If last char read was EOF,\n         BE    TURETEOF            then return eofval\n         CLI   ZLFLSTST,ZLFSTEOL   If last char read was newline,\n         BE    TURETEOL            then return newlineval\n         CLI   ZLFLSTST,ZLFSTVLD   If last-char-read is not valid\n         BNE   TUBAD               then error\n         CLI   ##TYPE(#5),##FIXNUM Check arg 1 to UNTYI\n         BNE   TUERROR             Must be a fixnum\n         L     #3,##CDR(,#5)       Get the character\n         CL    #3,#SFW255          Must be between 0 and 255\n         BH    TUERROR\n         XR    #2,#2               Clear insert register\n         IC    #2,ZLFLSTCH         Get last read char into register\n         LR    #4,#2               Get last read char into register\n         SLA   #2,3                Convert to index into fixnum table\n         LA    #15,#SFT(#2)        Get address of fixnum from table\n         CR    #3,#4               If last char read doesn't match\n         BNE   TUWRONG             then error\n         STC   #4,ZLFUNRCH         Set unread-character\n         MVI   ZLFUNRST,ZLFSTVLD   Indicate unread char valid\n         SPACE\nTURETURN DS    0H                  #15 points to character\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE 1\nTURETEOF DS    0H                  Last char read was EOF\n         L     #15,16(,#11)        Get eofval\n         CLC   0(8,#5),0(#15)      If no match\n         BNE   TUWRONG             then error\n         MVI   ZLFUNRST,ZLFSTEOF   Indicate unread char is EOF\n         B     TURETURN            else return with it.\nTURETEOL DS    0H                  Last char read was newline\n         L     #15,20(,#11)        Get newlineval\n         CLC   0(8,#5),0(#15)      If no match\n         BNE   TUWRONG             then error\n         MVI   ZLFUNRST,ZLFSTEOL   Indicate unread char is newline\n         B     TURETURN            else return with it.\n         SPACE 1\nTUERROR  DS    0H\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 UNTYI: Invalid character specified for file ', X\n               (#2),' - ',(#5),PREFIX=NO\nTUWRONG  DS    0H\n         LR    #4,#15              Load true character pointer\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 UNTYI: Specified character ',(#5),' does not maX\n               tch character ',(#4),' from file ',(#2),PREFIX=NO\nTUBAD    DS    0H\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 UNTYI: Sequence error - no previously read charX\n               acter ',(#5),' for file ',(#2),PREFIX=NO\n         SPACE 1\nTUTWICE  DS    0H\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 UNTYI: Sequence error - issued twice without reX\n               ading another character from file ',(#2),PREFIX=NO\n         SPACE 1\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n* (readch &optional file eofval newlineval)                           *\n*  is sort of like                                                    *\n* (zdread file #b100 nil eof-error-p eofval newlineval)               *\n*                                                                     *\n* reads a character from file and returns eofval if EOF hit,          *\n* newlineval if NEWLINE hit,                                          *\n* and an interned symbol if a character hit.                          *\n*                                                                     *\n* This is like the Maclisp syntax, but extended with an additional    *\n* optional argument for ZIL, whose 370 environment has to worry       *\n* about what to do with those pesky newline conditions.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*               8(#11) --> arg3    not used by READCH                 *\n*              12(#11) --> arg4    eof-error-p                        *\n*              16(#11) --> arg5    eofval                             *\n*              20(#11) --> arg6    newlineval                         *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE\nREADCH   DS    0D                  This is READCH\n         SPACE\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING READCH,#12\n         SPACE\n         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT\n         BO    RCAFTEOF            THEN ERROR - READ AFTER EOF\n         SPACE\n         L     #3,ZLFCHAR          GET CURRENT POSITION\nRCGOTINP DS    0H\n         LTR   #3,#3               CHECK INPUT POINTER\n         BP    RCINPOK             IF POSITIVE, WE HAVE GOOD STUFF\n         BM    RCNL                IF NEGATIVE, RETURN AS A NEWLINE\n******** BZ    RCEOF               IF ZERO, EOF ENCOUNTERED\n         SPACE\nRCEOF    DS    0H                  EOF HIT ON LAST READ\n         OI    ZLFFLAG1,ZLFEOF     INDICATE EOF FOR NEXT CALL\n         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE OFF\n         L     #15,16(,#11)        Get eofval\n         B     RCRETURN            and return it\n         SPACE\nRCNL     DS    0H                  NEWLINE HIT ON LAST READ\n*\n* THE FOLLOWING IS TO PREVENT AN EXTRA KEYBOARD UNLOCK WHEN THE\n* INPUT FILE IS A TERMINAL AND END-OF-LINE HAS BEEN ENCOUNTERED.\n* REMEMBER THAT \"READ\" IGNORES END-OF-LINE IT IT IS THE FIRST\n* THING THAT IT SEES - IF THIS WERE NOT THE CASE, READ WOULD\n* HAVE TO BE CHANGED AS WELL.\n*\n         TM    ZLFFLAG1,ZLFNEWLN   IF WE ALREADY RETURNED NEWLINE/NIL,\n         BZ    RCNLNEW1            THEN...\n         NI    ZLFFLAG1,255-ZLFNEWLN SET IT OFF AGAIN\n         #GETC ,                    READ IN THE NEXT CHARACTER\n         B     RCGOTINP             AND TRY TO PROCESS IT\nRCNLNEW1 DS    0H                  ELSE...\n         OI    ZLFFLAG1,ZLFNEWLN   INDICATE NEWLINE\n         L     #15,20(,#11)        Get newlineval\n         B     RCRETURN            and return with it\n         SPACE\nRCINPOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER\n         SPACE\n         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE INDICATOR OFF\n         LR    #4,#3               CONVERT RELATIVE COLUMN TO\n         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE\n         A     #4,ZLFCARD            AND PASS IT TO INTERN ROUTINE\n*\n* Since we are calling ZILINTN directly to intern the character,\n* we MUST check for T ourselves.\n*\n         CLI   0(#4),C'T'          If character = T\n         BNE   RCNOTT              then\n         LR    #15,#8               return address of T\n         B     RCGETNXT            else not T...\nRCNOTT   DS    0H                  #4 points to print name text\n         LR    #3,#7               Save file pointer across ZILINTN\n         LA    #5,1                Get length of print name text\n         XR    #7,#7               Indicate print name must be built\n         L     #15,ZLCINTN         Get address of ZILINTN\n         LA    #0,44(,#11)         Get current top-of-stack pointer\n         #BASR #14,#15             Call ZILINTN to intern the symbol\n         LR    #7,#3               Restore file pointer\nRCGETNXT DS    0H                  Time to pre-read next character\n         L     #3,ZLFCHAR          RELOAD CHARACTER POINTER\n         #GETC ,                   GET NEXT CHARACTER BEFORE RETURN\n         SPACE\nRCRETURN DS    0H\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE\nRCAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 READCH: Read after end of file ',(#2),         X\n               PREFIX=NO\n         SPACE\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n* (peekch &optional file eofval newlineval)                           *\n*  is sort of like                                                    *\n* (zdread file #b110 nil eof-error-p eofval newlineval)               *\n*                                                                     *\n* peeks at a character from file and returns eofval if EOF hit,       *\n* newlineval if NEWLINE hit,                                          *\n* and an interned symbol if a character hit.                          *\n*                                                                     *\n* This is like the Maclisp syntax, but extended with an additional    *\n* optional argument for ZIL, whose 370 environment has to worry       *\n* about what to do with those pesky newline conditions.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*               8(#11) --> arg3    not used by PEEKCH                 *\n*              12(#11) --> arg4    eof-error-p                        *\n*              16(#11) --> arg5    eofval                             *\n*              20(#11) --> arg6    newlineval                         *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE\nPEEKCH   DS    0D                  This is PEEKCH\n         SPACE\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING PEEKCH,#12\n         SPACE\n         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT\n         BO    PCAFTEOF            THEN ERROR - READ AFTER EOF\nPCCHKIT  DS    0H\n         ICM   #3,15,ZLFCHAR       GET CURRENT POSITION\n         BP    PCINPOK             IF POSITIVE, WE HAVE GOOD STUFF\n         BM    PCPEEKNL            IF NEGATIVE, RETURN AS A NEWLINE\n*                                  If zero, eof encountered\n         L     #15,16(,#11)        Get eofval\n         B     PCRETURN            and return with it\n         SPACE\nPCPEEKNL DS    0H\n*\n* #3 is negative, meaning a newline condition.  If ZLFNEWLN has not\n* been set on, this means that TYI has not yet seen a newline, so\n* return the newline parameter.  Otherwise, TYI has already seen a\n* newline, so get another character, bump the pointer back, and\n* return that character.\n*\n         TM    ZLFFLAG1,ZLFNEWLN   If newline bit is already on,\n         BZ    PCNNLYET            then...\n         NI    ZLFFLAG1,255-ZLFNEWLN turn newline bit off\n         #GETC ,                    get character from next line\n         B     PCCHKIT              and check it again. Else...\nPCNNLYET DS    0H                  No newline yet, return newline parm\n         L     #15,20(,#11)        Get newlineval\n         B     PCRETURN            and return with it.\n         SPACE\nPCINPOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER\n         SPACE\n         LR    #4,#3               CONVERT RELATIVE COLUMN TO\n         BCTR  #4,0                 ABSOLUTE LOCATION IN LINE\n         A     #4,ZLFCARD            AND PASS IT TO INTERN ROUTINE\n*\n* Since we are calling ZILINTN directly to intern the character,\n* we MUST check for T ourselves.\n*\n         CLI   0(#4),C'T'          If character = T\n         BNE   PCNOTT              then\n         LR    #15,#8               return address of T\n         B     PCRETURN            else not T...\nPCNOTT   DS    0H                  #4 points to print name text\n         LA    #5,1                Get length of print name text\n         XR    #7,#7               Indicate print name must be built\n         L     #15,ZLCINTN         Get address of ZILINTN\n         LA    #0,44(,#11)         Get current top-of-stack pointer\n         #BASR #14,#15             Call ZILINTN to intern the symbol\n         SPACE\nPCRETURN DS    0H\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE\nPCAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 PEEKCH: Read after end of file ',(#2),         X\n               PREFIX=NO\n         SPACE\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n         SPACE\n***********************************************************************\n*                                                                     *\n* READLINE - returns a line from an input file as a string.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*               8(#11) --> arg3    not used by READLINE               *\n*              12(#11) --> arg4    eof-error-p                        *\n*              16(#11) --> arg5    eofval                             *\n*              20(#11) --> arg6    newlineval                         *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nREADLINE DS    0D                  This is READLINE\n         SPACE\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING READLINE,#12\n         SPACE\n         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT\n         BO    RLAFTEOF            THEN ERROR - READ AFTER EOF\n         SPACE\n         L     #3,ZLFCHAR          GET CURRENT CHARACTER POINTER\n         LTR   #3,#3               TEST IT\n         BZ    RLEOF               IF ZERO, END OF FILE\n         BM    RLFORCNL            IF NEWLINE, FORCE ANOTHER READ\n         TM    ZLFFLAG1,ZLFNEWLN   IF NEWLINE CONDITION CURRENT\n         BZ    RLNNEWLN            THEN...\nRLFORCNL XR    #3,#3                SET CHARACTER POINTER TO\n         BCTR  #3,0                 FORCE A NEWLINE CONDITION TO\n         #GETC ,                    FORCE A READ\nRLNNEWLN DS    0H\n         SPACE 1\n         LTR   #3,#3               TEST CURRENT CHARACTER POINTER\n         BZ    RLEOF               IF ZERO, END OF FILE\n         XR    #3,#3               SET CHARACTER POINTER TO\n         BCTR  #3,0                FORCE A NEWLINE FOR NEXT READ\n         XR    #1,#1               ENTRY CODE FOR ZILVSS = 0\n         LH    #2,ZLFLRECL         GET LENGTH OF INPUT DATA LINE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER\n         OI    ZLCGCFLG,ZLCGCBLD   Turn on trust-#0 flag for GC\n         #BASR #14,#15             CALL ZILVSS TO GET SPACE\n         NI    ZLCGCFLG,255-ZLCGCBLD Turn off trust-#0 flag for GC\n         LTR   #15,#15             IF NO SPACE\n         BZ    RLNOSPC             THEN ERROR\n         LA    #0,##VECDAT(,#15)   DESTINATION ADDRESS = STRING TEXT\n         LH    #1,ZLFLRECL         DESTINATION LENGTH = INPUT LRECL\n         L     #4,ZLFCARD          SOURCE ADDRESS = INPUT RECORD\n         LR    #5,#1               SOURCE LENGTH = INPUT LRECL\n         MVCL  #0,#4               MOVE INPUT DATA TO STRING TEXT\n         B     RLRETURN            RETURN WITH STRING\n         SPACE\nRLEOF    DS    0H                  EOF HIT ON LAST READ\n         OI    ZLFFLAG1,ZLFEOF     INDICATE EOF FOR NEXT CALL\n         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE OFF\n         L     #15,16(,#11)        Return eofval\n         B     RLRETURN\n         SPACE\nRLAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM          Get file atom for error message\n         #ERR  'ZIL2003 READLINE: Read after end of file ',(#2),       X\n               PREFIX=NO\n         SPACE\nRLNOSPC  DS    0H\n         #ERR  'ZIL4010 READLINE: Not enough vector/string space to buiX\n               ld string.',PREFIX=NO\n         SPACE\nRLRETURN DS    0H\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n* RDRMACRO - takes two arguments, both required:                      *\n*                                                                     *\n*   (1) The single character to be defined as a reader macro.         *\n*       This can be a string, symbol or character fixnum.             *\n*   (2) The compiled code SUBR to be executed.                        *\n*                                                                     *\n* Note that (2) MUST be a SUBR!  Even a closure is not acceptable.    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*               8(#11) --> arg3    character arg to RDRMACRO          *\n*              12(#11) --> arg4    subr arg to RDRMACRO               *\n*              16(#11) --> arg5    not used                           *\n*              20(#11) --> arg6    not used                           *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE\nRDRMACRO DS    0D                  This is RDRMACRO\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING RDRMACRO,#12\n         SPACE\n         L     #4,ZLCRDTBL         Get readtable address\n         LM    #2,#3,8(#11)        Get args: #2 = CHAR, #3 = SUBR\n         CLI   ##TYPE(#2),##FIXNUM IF ARG1 IS A FIXNUM\n         BE    RMA1CHAR            THEN OK (IT'S A CHARACTER)\n         CLI   ##TYPE(#2),##STRING IF ARG1 IS A STRING\n         BE    RMA1OK              THEN OK (AS LONG AS LENGTH = 1)\n         CLI   ##TYPE(#2),##SYMBOL IF ARG1 IS NOT A SYMBOL\n         BNE   RMERROR1            THEN ERROR\n         L     #2,##PNAME(,#2)     ELSE GET SYMBOL PRINT NAME\nRMA1OK   DS    0H\n         XR    #6,#6               CLEAR INSERT REG\n         CLC   1(3,#2),=AL3(1)     STRING/SYMBOL NAME LENGTH MUST BE 1\n         BNE   RMERROR1            ELSE ERROR\n         IC    #6,##VECDAT(,#2)    GET READER MACRO CHARACTER IN REG\n         B     RMCKARG2\nRMA1CHAR DS    0H                  IT'S A FIXNUM...\n         L     #6,##CDR(,#2)       GET FIXNUM VALUE\n         CL    #6,#SFW255          MUST BE BETWEEN 0 AND 255\n         BH    RMERROR1            ELSE ERROR\nRMCKARG2 DS    0H\n         CR    #3,#10              IF ARG2 IS NIL\n         BE    RMA2OK              THEN OK (MEANS DELETE THIS MACRO)\n         CLI   ##TYPE(#3),##SUBR   IF ARG2 IS NOT A COMPILED SUBR\n         BNE   RMERROR2            THEN ERROR\nRMA2OK   DS    0H\n*\n* PREPARE TO BUILD NEW READER MACRO CELL.  FIRST SEARCH THE EXISTING\n* CHAIN FOR (1) A CELL WITH OUR CHARACTER, OR (2) THE END.\n*\n         L     #1,ZLCRMCHN         PICK UP READER MACRO CHAIN\n         LA    #5,ZLCRMCHN-##CDR   FAKE OUT INITIAL POINTER\nRMLOOP   DS    0H\n         LTR   #1,#1\n         BZ    RMNOMAC\n         LR    #5,#1\n         CLM   #6,B'0001',0(#5)    SEE IF READER MACRO CHARACTERS MATCH\n         BE    RMGOTMAC            IF SO, GO TO PROCESS\n         L     #1,##CDR(,#5)       IF NOT, GET NEXT CELL IN CHAIN\n         B     RMLOOP\nRMNOMAC  DS    0H                  DOES NOT EXIST - CREATE NEW ONE\n         SPACE 1\n         CR    #3,#10              IF ARG2 IS NIL\n         BE    RMRETURN            THEN DO NOTHING, NO MACRO TO DELETE\n*\n* CONS UP A NEW CELL\n*\n         XR    #1,#1               ARG1 TO CONS\n         XR    #2,#2               ARG2 TO CONS\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         LA    #0,44(,#11)         PASS CURRENT STACK POINTER TO CONS\n         OI    ZLCGCFLG,ZLCGCBLD   Turn on trust-#0 flag for GC\n         #BASR #14,#15             CALL CONS TO GET A CELL\n         NI    ZLCGCFLG,255-ZLCGCBLD Turn off trust-#0 flag for GC\n         STC   #6,##TYPE(,#15)     SET MACRO CHARACTER IN CELL\n         ST    #15,##CDR(,#5)      CHAIN IT TO PREVIOUS CELL\n         LR    #5,#15              SET POINTER TO IT\nRMGOTMAC DS    0H                  NOW WE HAVE A CELL\n         CR    #3,#10              IF ARG2 IS NIL\n         BNE   RMNEWMAC            THEN...\n         LA    #1,0(#6,#4)          POINT TO CHAR POS IN READTABLE\n         NI    0(#1),X'7F'          RESTORE NON-MACRO STATUS FOR CHAR\n         B     RMRETURN            ELSE...\nRMNEWMAC DS    0H                  UPDATE READER MACRO CELL\n         L     #1,##CAR(,#3)       GET COMPILED CODE PTR FOR SUBR ARG2\n         STCM  #1,7,##CAR+1(#5)    SET SUBR PTR IN READER MACRO CELL\n         LA    #1,0(#6,#4)         POINT TO CHARACTER POS IN READTABLE\n         OI    0(#1),X'80'         SET CHARACTER TO BE A MACRO CHAR\n         SPACE 1\nRMRETURN DS    0H\n         LR    #15,#10             RETURN NIL (WHAT ELSE IS THERE?)\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE\nRMERROR1 #ERR  'ZIL2030 RDRMACRO: Invalid reader macro character - ',  X\n               8(#11),PREFIX=NO\nRMERROR2 #ERR  'Argument 2 to RDRMACRO not a compiled code SUBR - ',   X\n               12(#11)\n         SPACE\n         DROP  #12\n         SPACE\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n* RMCHAR TAKES NO ARGUMENTS.                                          *\n*                                                                     *\n* THIS FUNCTION RETURNS THE CURRENT READER MACRO CHARACTER AS SET BY  *\n* THE READ FUNCTION WHEN IT INVOKES A READER MACRO.                   *\n*                                                                     *\n* THE ATOM IS ALWAYS INTERNED, SINCE WHAT GOOD WOULD IT BE OTHERWISE? *\n*                                                                     *\n* THIS FUNCTION IS MEANT TO BE ISSUED BY READER MACRO FUNCTIONS.      *\n* IF EXECUTED OTHERWISE, RESULT WILL BE UNPREDICTABLE.                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*               0(#11) --> arg1                                       *\n*               4(#11) --> arg2                                       *\n*              18(#11) --> arg3    not used                           *\n*              12(#11) --> arg4    not used                           *\n*              16(#11) --> arg5    not used                           *\n*              20(#11) --> arg6    not used                           *\n*                                                                     *\n*               #7 already contains the input file pointer.           *\n*                                                                     *\n***********************************************************************\n         SPACE\nRMCHAR   DS    0D                  This is RMCHAR\n         ST    #12,36(,#11)        Save caller's regs\n         ST    #14,40(,#11)\n         LR    #12,#15\n         USING RMCHAR,#12\n         SPACE\n         CLI   ZLCRMCHR,C'T'       If reader macro character is T\n         BNE   RKNOTT              (not likely, but...) then...\n         LR    #15,#8               return T\n         B     RKRETURN            else..\nRKNOTT   DS    0H\n         LA    #5,1                Length of atom to be built = 1\n         LA    #4,ZLCRMCHR         Get current reader macro character\n         XR    #7,#7               Indicate print name must be built\n         L     #15,ZLCINTN         Get address of ZILINTN\n         LA    #0,44(,#11)         Get current top-of-stack pointer\n         #BASR #14,#15             Call ZILINTN to intern the symbol\nRKRETURN DS    0H\n         L     #12,36(,#11)        Restore caller's regs\n         L     #14,40(,#11)\n         BR    #14                 Return\n         SPACE\n         DROP  #12\n         SPACE\n         LTORG\n         END\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZEROP": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x10\\x00\\x88\\x01_\\x01\\x00&_\\x16D\\x00+\\x00(\\x00*\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:44:10", "lines": 43, "newlines": 40, "modlines": 42, "user": "SEB1525"}, "text": "         TITLE 'ZEROP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZEROP TAKES ONE ARGUMENT - A NUMERIC ATOM                           *\n*                                                                     *\n***********************************************************************\nZEROP    #ZBEG MINARGS=1,MAXARGS=1,NAME='ZEROP'\n         SPACE 1\n         L     #2,0(,#1)           LOAD FIRST (AND ONLY) ARGUMENT\n         CLI   ##TYPE(#2),##FIXNUM TEST TYPE BITS\n         BE    PROCESS             OK IF FIXNUM\n         BH    FALSE               ONLY A BIGNUM CAN BE HIGHER IN TYPE\n*                                  AND A BIGNUM CAN NEVER BE ZERO\n*                                  SO IF IT'S A BIGNUM, RETURN FALSE\n         TM    ##TYPE(#2),##FLONUM OK IF FLONUM\n         BNO   ERROR               ALL OTHERS: ERROR\nPROCESS  DS    0H\n*\n* THE FOLLOWING TEST WORKS FOR FIXNUMS AND FLONUMS.\n* It works for double floats only because ZILMDF duplicates the left\n* half of the flonum when it builds one (and so does the compiler).\n* If anyone changes that behavior, this code must be changed.\n*\n         ICM   #1,15,##CDR(#2)     GET FIXNUM OR FLONUM VALUE\n         BZ    TRUE                IF NONZERO RETURN NIL\nFALSE    LR    #15,#10             IF NONZERO, RETURN NIL\n         BR    #14\nTRUE     LR    #15,#8              IF ZERO, RETURN T\n         BR    #14\n         SPACE 1\nERROR    DS    0H                  NOT A NUMERIC ATOM\n         LR    #3,#15\n         DROP  #15\n         USING ZEROP,#3\n         #ERR  'Argument to ZEROP not numeric - ',(#2)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZGETFPI": {"ttr": 8454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11I\\x00'\\x00$\\x00&\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 39, "newlines": 36, "modlines": 38, "user": "SEB1525"}, "text": "         TITLE 'ZGETFPI - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION RETURNS THE CURRENT CHARACTER POSITION OF THE         *\n* SPECIFIED INPUT FILE AS A FIXNUM ATOM.                              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZGETFPI TAKES ONE (OPTIONAL) ARGUMENT - INPUT FILE SPEC             *\n*                                                                     *\n***********************************************************************\n         SPACE\nZGETFPI  #ZBEG MINARGS=0,MAXARGS=1,NAME='ZGETFPI'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         #IFIL 1                   ARG 1 = INPUT FILE SPEC\n         SPACE\n         L     #2,ZLFCHAR          GET CURRENT CHARACTER POINTER\n         CL    #2,ZLCSFTHI         IF WITHIN SMALL FIXNUM RANGE\n         BNH   SMALLFIX            THEN GO TO RETURN FIXNUM FROM TABLE\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXED ATOM OUT OF IT\n         B     RETURN\nSMALLFIX DS    0H\n         SLA   #2,3                CONVERT TO INDEX INTO FIXNUM TABLE\n         LA    #15,#SFT(#2)        RETURN SMALL FIXNUM FROM TABLE\nRETURN   DS    0H\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFACOS": {"ttr": 8456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11I\\x00\\x95\\x00\\x92\\x00\\x94\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 149, "newlines": 146, "modlines": 148, "user": "SEB1525"}, "text": "         TITLE 'ZIFACOS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ACOS TAKES ONE ARGUMENT, A FLONUM.                                  *\n*                                                                     *\n***********************************************************************\nZIFACOS  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFACOS'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD               ELSE...\n         SPACE 1\nTRYBIG   DS    0H                  Not float or fixed...\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Bignum arg invalid for ACOS because |value| must be <= 1, of course *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         B     ERROR1              All other types: ERROR\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H                  Do it to a single float\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR ACOS    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPER  #F2,#F0             GET ABSOLUTE VALUE OF ARG\n         CE    #F2,=E'1'           IF GREATER THAN 1\n         BH    ERROR1              THEN ERROR\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL ACOS                ADDRESS OF SUBROUTINE ACOS IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  Do it to a double float\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR ACOS    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPDR  #F2,#F0             GET ABSOLUTE VALUE OF ARG\n         CD    #F2,=D'1'           IF GREATER THAN 1\n         BH    ERROR1              THEN ERROR\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DACOS               ADDRESS OF SUBROUTINE DACOS IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nERROR1   #ERR  'Argument to ACOS not a number between -1 and 1 - ',    X\n               0(#11)\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFASIN": {"ttr": 8459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11I\\x00\\x95\\x00\\x92\\x00\\x94\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 149, "newlines": 146, "modlines": 148, "user": "SEB1525"}, "text": "         TITLE 'ZIFASIN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ASIN TAKES ONE ARGUMENT, A FLONUM.                                  *\n*                                                                     *\n***********************************************************************\nZIFASIN  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFASIN'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD\n         SPACE 1\nTRYBIG   DS    0H                  Not float or fixed...\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Bignum arg invalid for ASIN because |value| must be <= 1, of course *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         B     ERROR1              All other types: ERROR\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR ASIN    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPER  #F2,#F0             GET ABSOLUTE VALUE OF ARG\n         CE    #F2,=E'1'           IF GREATER THAN 1\n         BH    ERROR1              THEN ERROR\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL ASIN                ADDRESS OF SUBROUTINE ASIN IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  DO IT FOR A DOUBLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR ASIN    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPDR  #F2,#F0             GET ABSOLUTE VALUE OF ARG\n         CD    #F2,=D'1'           IF GREATER THAN 1\n         BH    ERROR1              THEN ERROR\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DASIN               ADDRESS OF SUBROUTINE DASIN IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nERROR1   #ERR  'Argument to ASIN not a number between -1 and 1 - ',    X\n               0(#11)\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFATAN": {"ttr": 8462, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11I\\x00\\xc9\\x00\\xc6\\x00\\xc8\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 201, "newlines": 198, "modlines": 200, "user": "SEB1525"}, "text": "         TITLE 'ZIFATAN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ATAN TAKES TWO ARGUMENTS.                                           *\n*                                                                     *\n***********************************************************************\nZIFATAN  #ZBEG MINARGS=2,MAXARGS=2,NAME='ZIFATAN'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT1\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT1\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG1             THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN1             IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN1 DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         CLI   ##TYPE(#7),##SFLOAT  IF OTHER ARG IS SINGLE\n         BNE   CHKARG2              THEN\n         LRER  #F0,#F0               CONVERT FROM DOUBLE TO SINGLE\n         B     CHKARG2\n         SPACE 1\nTRYBIG1  CLI   ##TYPE(#6),##BIGNUM IF BIG,\n         BE    ERRORB1             THEN (CAN'T DO IT YET)\n         B     ERROR1              ELSE ERROR\n         SPACE 1\nSFLOAT1  DS    0H                  ARG 1 IS SINGLE\n         SDR   #F0,#F0\n         LE    #F0,##CDR(,#6)\n         B     CHKARG2\n         SPACE 1\nDFLOAT1  DS    0H\n         LD    #F0,8(,#6)\n         B     CHKARG2\n         SPACE 1\nCHKARG2  DS    0H\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    SFLOAT2\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    DFLOAT2\n         CLI   ##TYPE(#7),##FIXNUM IF FIXED,\n         BNE   TRYBIG2             THEN...\n         ICM   #1,15,##CDR(#7)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN2             IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN2 DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F2,#F2              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F2,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         CLI   ##TYPE(#6),##SFLOAT  IF OTHER ARG IS SINGLE\n         BNE   DOITD                THEN\n         LRER  #F2,#F2              CONVERT FROM DOUBLE TO SINGLE\n         B     DOIT                ELSE...\n         SPACE 1\nTRYBIG2  CLI   ##TYPE(#7),##BIGNUM IF BIG,\n         BE    ERRORB2             THEN (CAN'T DO IT YET)\n         B     ERROR2              ELSE ERROR\n         SPACE 1\nSFLOAT2  DS    0H\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#7)\n         CLI   ##TYPE(#6),##DFLOAT IF OTHER ARG IS DOUBLE\n         BE    DOITD               THEN DO DOUBLE\n         B     DOIT                ELSE DO SINGLE\n         SPACE 1\nDFLOAT2  DS    0H\n         LD    #F2,8(,#7)\n         B     DOITD\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - HARD TO DO FOR ATAN    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTER  #F0,#F0             IF ARG 1 IS ZERO\n         BNZ   ARGSOK               AND\n         LTER  #F2,#F2               ARG 2 IS ZERO\n         BZ    ERROR3                 THEN ERROR\nARGSOK   DS    0H\n         SPACE 1\n         STE   #F0,ARGVAL1         STORE FLO ARG INTO PARAMETER AREA\n         STE   #F2,ARGVAL2         STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL ATAN                ADDRESS OF SUBROUTINE ATAN IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDOITD    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - HARD TO DO FOR ATAN    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTDR  #F0,#F0             IF ARG 1 IS ZERO\n         BNZ   ARGSOKD              AND\n         LTDR  #F2,#F2               ARG 2 IS ZERO\n         BZ    ERROR3                 THEN ERROR\nARGSOKD  DS    0H\n         SPACE 1\n         STD   #F0,ARGVAL1         STORE FLO ARG INTO PARAMETER AREA\n         STD   #F2,ARGVAL2         STORE FLO ARG INTO PARAMETER AREA\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DATAN               ADDRESS OF SUBROUTINE DATAN2 IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL1)\n         DC    A(ARGVAL2+X'80000000')\nARGVAL1  DS    D                   STORE THE FLONUM ARG HERE\nARGVAL2  DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nERROR1   #ERR  'Argument 1 to ATAN not numeric - ',0(#11)\nERROR2   #ERR  'Argument 2 to ATAN not numeric - ',4(#11)\nERROR3   #ERR  'Arguments to ATAN cannot both be zero.'\nERRORB1  LR    #2,#6\n         B     ERRORB\nERRORB2  LR    #2,#7\n*******  B     ERRORB\nERRORB   #ERR  'ZIL4100 ATAN: Conversion of bignum ',                  X\n               (#2),' to float not supported',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFCOS": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11I\\x00\\xa2\\x00\\x9f\\x00\\xa1\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 162, "newlines": 159, "modlines": 161, "user": "SEB1525"}, "text": "         TITLE 'ZIFCOS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* COS TAKES ONE ARGUMENT, A FLONUM.                                   *\n*                                                                     *\n***********************************************************************\nZIFCOS   #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFCOS'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD               ELSE...\n         SPACE 1\nTRYBIG   DS    0H                  Not fixed or float...\n         SPACE 1\n         CLI   ##TYPE(#6),##BIGNUM\n         BNE   ERROR1\n         B     ERRORB              Bignums not supported\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPER  #F2,#F0             Get absolute value of flonum arg\n         CE    #F2,MAXARGVL        If |arg| greater than 823549.5625\n         BH    ERROR2              then error\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL COS                 ADDRESS OF SUBROUTINE COS IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  DO IT FOR A DOUBLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPDR  #F2,#F0             Get absolute value of flonum arg\n         CD    #F2,MAXARGVD        If |arg| greater than max dbl val\n         BH    ERROR2D             then error\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DCOS                ADDRESS OF SUBROUTINE DCOS IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nMAXARG   DS    0A                  Maximum flonum arg value possible\n         DC    YL1(##SFLOAT),AL3(0)\nMAXARGVL DC    X'45C90FD9'         (I found this by trial and error)\n         SPACE 1\nMAXARGD  DS    0A                  Maximum flonum arg value possible\n         DC    YL1(##DFLOAT),AL3(0)\n         DC    X'4DC90FDA'\nMAXARGVD DC    X'4DC90FDAA22168C2' (I found this by trial and error)\n         SPACE 1\nERROR1   #ERR  'Argument to COS not numeric - ',0(#11)\nERROR2   #ERR  'COS of ',0(#11),' cannot be computed, absolute value ofX\n                argument is greater than ',MAXARG\nERROR2D  #ERR  'COS of ',0(#11),' cannot be computed, absolute value ofX\n                argument is greater than ',MAXARGD\nERRORB   #ERR  'ZIL4100 COS: Conversion of bignum ',                   X\n               0(#11),' to float not supported',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFEXP": {"ttr": 8712, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11I\\x00\\xa4\\x00\\xa1\\x00\\xa3\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 164, "newlines": 161, "modlines": 163, "user": "SEB1525"}, "text": "         TITLE 'ZIFEXP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* EXP TAKES ONE ARGUMENT, A FLONUM.                                   *\n*                                                                     *\n***********************************************************************\nZIFEXP   #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFEXP'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD               ELSE...\n         SPACE 1\nTRYBIG   CLI   ##TYPE(#6),##BIGNUM IF BIG,\n         BNE   ERROR1               then...\n         TM    ##VECDAT(#6),X'80'    if a negative bignum\n         BZ    NOTNEGB                then\n         LA    #15,FLOZERO             assume (EXP value) is 0.0\n         B     RETURN                 else\nNOTNEGB  B     ERROR2D                 value out of range\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CE    #F0,MAXARGVL        If arg greater than 174.whatever...\n         BH    ERROR2              then error\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL EXP                 ADDRESS OF SUBROUTINE EXP IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  DO IT FOR A DOUBLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CD    #F0,MAXARGVD        If arg greater than whatever...\n         BH    ERROR2D             then error\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DEXP                ADDRESS OF SUBROUTINE DEXP IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nMAXARG   DS    0A                  MAXIMUM FLONUM ARG VALUE POSSIBLE\n         DC    YL1(##SFLOAT),AL3(0)\nMAXARGVL DC    X'42AEAC4F'         (I found this by trial and error)\nMAXARGD  DS    0A                  MAXIMUM FLONUM ARG VALUE POSSIBLE\n         DC    YL1(##DFLOAT),AL3(0)\n         DC    X'42AEAC4F'         (I found this by trial and error)\nMAXARGVD DC    X'42AEAC4F97F2883B' (I found this by trial and error)\nFLOZERO  DS    0A                  0.0D0\n         DC    YL1(##DFLOAT),AL3(0)\n         DC    3F'0'\n         SPACE 1\nERROR1   #ERR  'Argument to EXP not numeric - ',0(#11)\nERROR2   #ERR  'EXP of ',0(#11),' cannot be computed, argument is greatX\n               er than ',MAXARG\nERROR2D  #ERR  'EXP of ',0(#11),' cannot be computed, argument is greatX\n               er than ',MAXARGD\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFINIT": {"ttr": 8716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11I\\x00O\\x00L\\x00O\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:49:00", "lines": 79, "newlines": 76, "modlines": 79, "user": "SEB1525"}, "text": "***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         TITLE 'ZIFINIT - MACROS'\n         MACRO\n&SYM     SETCON &FUN,&FORTFUN=\n         LCLC  &FUN2,&REALFUN\n&FUN2    SETC  '&FORTFUN'\n&REALFUN SETC  '&FUN    '(1,4)\n         AIF   ('&FUN2' NE '').OK\n&FUN2    SETC  '&FUN'\n.OK      ANOP\n&SYM     L     0,=V(&FUN2)\n         ST    0,ZIF@&REALFUN\n         MEND\n         TITLE 'ZIFINIT - ZIL 1.3 FORTRAN INITIALIZATION ROUTINE'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  THIS ROUTINE IS LOADED BY ZILFINT AND BRANCHED TO TO INITIALIZE    *\n*  THE FORTRAN INTERFACE.  IT IS LINKEDITED WITH THE APPROPRIATE      *\n*  FORTRAN INITIALIZATION MODULE - FOR VS FORTRAN RELEASE 4 AND       *\n*  SUBSEQUENT RELEASES, THIS IS VFEIN#.                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  !!!! NOTE !!!!  THIS MODULE MUST BE ASSEMBLED/LINKEDITED WITH      *\n*  THE FORTRAN LIBRARY - E.G. SYS1.FORTLIB - NOT NCAL!!!              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZIFINIT  CSECT\n         SPACE 1\n         STM   14,12,12(13)        SAVE REGS\n         LR    12,15\n         USING ZIFINIT,12\n*                                  AT ENTRY #4 ALREADY POINTS TO ZIFSA\n         ST    13,4(,4)\n         ST    4,8(,13)\n         LR    13,4                CHAIN SAVE AREAS TOGETHER\n         SPACE 1\n         LR    4,1                 REGISTER 1 POINTS TO ZIL INTERFACE\n         USING ZIF,4                CONTROL BLOCK - SET POINTER TO IT\n******** L     15,FORTVCON\n******** #BASR 14,15\n         SPACE 1\n         SETCON SQRT\n         SETCON LOG\n         SETCON EXP\n         SETCON SIN\n         SETCON COS\n         SETCON TAN\n         SETCON ASIN\n         SETCON ACOS\n         SETCON ATAN,FORTFUN=ATAN2\n         SPACE 1\n         SETCON DSQRT\n         SETCON DLOG\n         SETCON DEXP\n         SETCON DSIN\n         SETCON DCOS\n         SETCON DTAN\n         SETCON DASIN\n         SETCON DACOS\n         SETCON DATAN,FORTFUN=DATAN2\n         SPACE 1\n         L     13,4(,13)\n         LM    14,12,12(13)\n         BR    14\n         SPACE 1\n*ORTVCON DC    V(VFEIN#)           !!! THIS IS THE FORTRAN INIT RTE !!!\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF  ,                   MAP THE ZIL INTERFACE CONTROL BLOCK\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFLOG": {"ttr": 8961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11P\\x00\\x93\\x00\\x90\\x00\\x92\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:50:00", "lines": 147, "newlines": 144, "modlines": 146, "user": "SEB1525"}, "text": "         TITLE 'ZIFLOG - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LOG TAKES ONE ARGUMENT, A FLONUM.                                   *\n*                                                                     *\n***********************************************************************\nZIFLOG   #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFLOG'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD               ELSE...\n         SPACE 1\nTRYBIG   CLI   ##TYPE(#6),##BIGNUM IF NOT AT LEAST A BIGNUM,\n         BNE   ERROR1              THEN ERROR\n         TM    ##VECDAT(#6),X'80'  IF A NEGATIVE BIGNUM,\n         BO    ERROR1              THEN OBVIOUSLY WE CAN'T HANDLE IT\n         B     ERRORB              OTHERWISE, NEED TO HANDLE BIGNA\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR LOG     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTER  #F0,#F0             ARG MUST BE POSITIVE\n         BNP   ERROR1              ELSE ERROR\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL LOG                 ADDRESS OF SUBROUTINE LOG IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  DO IT FOR A DOUBLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR LOG     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTDR  #F0,#F0             ARG MUST BE POSITIVE\n         BNP   ERROR1              ELSE ERROR\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DLOG                ADDRESS OF SUBROUTINE DLOG IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nERROR1   #ERR  'Argument to LOG not a positive number - ',0(#11)\nERRORB   #ERR  'ZIL4100 LOG: Conversion of bignum ',                   X\n               0(#11),' to float not supported',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFSIN": {"ttr": 8964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11P\\x00\\xa2\\x00\\x9f\\x00\\xa1\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:50:00", "lines": 162, "newlines": 159, "modlines": 161, "user": "SEB1525"}, "text": "         TITLE 'ZIFSIN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SIN TAKES ONE ARGUMENT, A FLONUM.                                   *\n*                                                                     *\n***********************************************************************\nZIFSIN   #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFSIN'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD               ELSE...\n         SPACE 1\nTRYBIG   DS    0H                  Not fixed or float...\n         SPACE 1\n         CLI   ##TYPE(#6),##BIGNUM\n         BNE   ERROR1\n         BE    ERRORB\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPER  #F2,#F0             Get absolute value of flonum arg\n         CE    #F2,MAXARGVL        If |arg| greater than 823549.5625\n         BH    ERROR2              then error\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL SIN                 ADDRESS OF SUBROUTINE SIN IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  DO IT FOR A DOUBLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPDR  #F2,#F0             Get absolute value of flonum arg\n         CD    #F2,MAXARGVD        If |arg| greater than max dbl val\n         BH    ERROR2D             then error\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DSIN                ADDRESS OF SUBROUTINE DSIN IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nMAXARG   DS    0A                  Maximum flonum arg value possible\n         DC    YL1(##SFLOAT),AL3(0)\nMAXARGVL DC    X'45C90FD9'         (I found this by trial and error)\n         SPACE 1\nMAXARGD  DS    0A                  Maximum flonum arg value possible\n         DC    YL1(##DFLOAT),AL3(0)\n         DC    X'4DC90FDA'\nMAXARGVD DC    X'4DC90FDAA22168C2' (I found this by trial and error)\n         SPACE 1\nERROR1   #ERR  'Argument to SIN not numeric - ',0(#11)\nERROR2   #ERR  'SIN of ',0(#11),' cannot be computed, absolute value ofX\n                argument is greater than ',MAXARG\nERROR2D  #ERR  'SIN of ',0(#11),' cannot be computed, absolute value ofX\n                argument is greater than ',MAXARGD\nERRORB   #ERR  'ZIL4100 SIN: Conversion of bignum ',                   X\n               0(#11),' to float not supported',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFSQRT": {"ttr": 8968, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11P\\x00\\x90\\x00\\x8d\\x00\\x8f\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:50:00", "lines": 144, "newlines": 141, "modlines": 143, "user": "SEB1525"}, "text": "         TITLE 'ZIFSQRT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SQRT TAKES ONE ARGUMENT, A FLONUM.                                  *\n*                                                                     *\n***********************************************************************\nZIFSQRT  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFSQRT'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD               ELSE...\n         SPACE 1\nTRYBIG   CLI   ##TYPE(#6),##BIGNUM IF NOT AT LEAST A BIGNUM,\n         BNE   ERROR1              THEN ERROR\n         TM    ##VECDAT(#6),X'80'  IF A NEGATIVE BIGNUM,\n         BO    ERROR1              THEN OBVIOUSLY WE CAN'T HANDLE IT\n         B     ERRORB              OTHERWISE, NEED TO HANDLE BIGNA\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H                  DO IT FOR A SINGLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR SQRT    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTER  #F0,#F0             IF ARG IS NEGATIVE\n         BM    ERROR1              THEN ERROR\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL SQRT                GET ADDR OF SQRT SUBROUTINE IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  DO IT FOR A DOUBLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE - EASY TO DO FOR SQRT    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTDR  #F0,#F0             IF ARG IS NEGATIVE\n         BM    ERROR1              THEN ERROR\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DSQRT               GET ADDR OF DSQRT SUBROUTINE IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nERROR1   #ERR  'Argument to SQRT not a nonnegative number - ',0(#11)\nERRORB   #ERR  'ZIL4100 SQRT: Conversion of bignum ',                  X\n               0(#11),' to float not supported',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIFTAN": {"ttr": 8971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11P\\x00\\x9f\\x00\\x9c\\x00\\x9e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:50:00", "lines": 159, "newlines": 156, "modlines": 158, "user": "SEB1525"}, "text": "         TITLE 'ZIFTAN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TAN TAKES ONE ARGUMENT, A FLONUM.                                   *\n*                                                                     *\n***********************************************************************\nZIFTAN   #ZBEG MINARGS=1,MAXARGS=1,NAME='ZIFTAN'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          LOAD ARGUMENT\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    SFLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    DFLOAT\n         CLI   ##TYPE(#6),##FIXNUM IF FIXED,\n         BNE   TRYBIG              THEN...\n         ICM   #1,15,##CDR(#6)      GET FIXNUM VALUE\n         LA    #0,X'4E'             PREPARE CHARACTERISTIC\n         BNM   FX2FLNN              IF VALUE IS NEGATIVE, THEN...\n         LPR   #1,#1                USE ABSOLUTE VALUE\n         LA    #0,X'CE'             SET SIGN IN CHARACTERISTIC\nFX2FLNN  DS    0H\n         SLL   #0,24                GET CHARACTERISTIC INTO POSITION\n         SDR   #F0,#F0              MAKE A NORMALIZED ZERO\n         STM   #0,#1,ZLCDBL+0       STORE CHARACTERISTIC AND MANTISSA\n         AD    #F0,ZLCDBL           ADD UNNORMALIZED FLOAT, NORMALIZING\n         B     DOITD               ELSE...\n         SPACE 1\nTRYBIG   CLI   ##TYPE(#6),##BIGNUM IF BIG,\n         BE    ERRORB              THEN CAN'T HANDLE\n         B     ERROR1              ELSE ERROR\n         SPACE 1\nSFLOAT   DS    0H                  SINGLE FLOAT\n         LE    #F0,##CDR(,#6)      LOAD SINGLE FLOAT VALUE 1\n******** B     DOIT\n         SPACE 1\nDOIT     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPER  #F2,#F0             Get absolute value of flonum arg\n         CE    #F2,MAXARGVL        If |arg| greater than 823549.5625\n         BH    ERROR2              then error\n         SPACE 1\n         STE   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL TAN                 ADDRESS OF SUBROUTINE TAN IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         STE   #F0,ZLCWORK         GET ANSWER FROM FORTRAN ROUTINE\n         L     #2,ZLCWORK          GET INTO REG FOR CONSING FLONUM\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM AND RETURN WITH IT\n         SPACE 1\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDFLOAT   DS    0H                  DOUBLE FLOAT\n         SPACE 1\n         LD    #F0,8(,#6)          LOAD DOUBLE FLOAT VALUE 1\n******** B     DOITD\n         SPACE 1\nDOITD    DS    0H                  DO IT FOR A DOUBLE FLOAT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ARG CHECK TO PREVENT ABEND IN FORTRAN CODE                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LPDR  #F2,#F0             Get absolute value of flonum arg\n         CD    #F2,MAXARGVD        If |arg| greater than 823549.5625\n         BH    ERROR2D             then error\n         SPACE 1\n         STD   #F0,ARGVAL          STORE FLO ARG INTO PARAMETER AREA\n*\n* AT THIS POINT FP REG 0 CONTAINS THE ARGUMENT\n*\n*\n* FORTRAN INTERFACE INITIALIZATION\n*\n         #ZIFL DTAN                ADDRESS OF SUBROUTINE DTAN IN #15\n         SPACE 1\n         LA    #1,ARGLIST          POINT TO FORTRAN ARG LIST\n         SPACE 1\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         L     #13,ZLCFTCBA        GET ADDRESS OF FTCB = SAVE AREA\n*\n         #BASR #14,#15             CALL THE FORTRAN SUBROUTINE\n*\n         L     #13,4(,#13)         RESTORE OUR COMMON AREA POINTER\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   IF ATTENTION INTERRUPT DETECTED\n         BOR   #13                 THEN GO HANDLE IT\n*\n* VALUE RETURNED FROM FORTRAN CODE IN FP REG 0\n*\n         L     #15,ZLCMDF          GET ADDRESS OF ZILMDF\n         LA    #0,16(,#11)         SET STACK LOCATION FOR CONS\n         #BASR #14,#15             CALL ZILMDF TO MAKE DOUBLE FLOAT\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nARGLIST  DS    0A                  ARG LIST FOR FORTRAN SUBROUTINE\n         DC    A(ARGVAL+X'80000000')\nARGVAL   DS    D                   STORE THE FLONUM ARG HERE\n         SPACE 1\nMAXARG   DS    0A                  Maximum flonum arg value possible\n         DC    YL1(##SFLOAT),AL3(0)\nMAXARGVL DC    X'45C90FD9'         (I found this by trial and error)\nMAXARGD  DS    0A                  Maximum flonum arg value possible\n         DC    YL1(##DFLOAT),AL3(0)\n         DC    X'4DC90FDA'\nMAXARGVD DC    X'4DC90FDAA22168C2' (I found this by trial and error)\n         SPACE 1\nERROR1   #ERR  'Argument to TAN not numeric - ',0(#11)\nERROR2   #ERR  'TAN of ',0(#11),' cannot be computed, absolute value ofX\n                argument is greater than ',MAXARG\nERROR2D  #ERR  'TAN of ',0(#11),' cannot be computed, absolute value ofX\n                argument is greater than ',MAXARGD\nERRORB   #ERR  'ZIL4100 TAN: Conversion of bignum ',                   X\n               0(#11),' to float not supported',PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZIF\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILABLD": {"ttr": 9219, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x00\\x88\\x01_\\x01\\x00&_\\x16D\\x02\\xc0\\x02\\xbd\\x02\\xbf\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:44:31", "lines": 704, "newlines": 701, "modlines": 703, "user": "SEB1525"}, "text": "         TITLE 'ZILABLD - ZIL 1.3 ATOM CONSTRUCTOR MODULE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS INVOKED VIA BALR FROM ASSEMBLER LANGUAGE FUNCTIONS   *\n* WHICH DESIRE TO CREATE ATOM FROM IN-STORAGE CHARACTER AREAS.        *\n*                                                                     *\n* ONLY SYMBOLS, FIXNUMS AND FLONUMS ARE BUILT BY THIS ROUTINE, WHICH  *\n* IS USED BY READ (FOR EXAMPLE) WHEN IT SEES AN UNDELIMITED STRING.   *\n*                                                                     *\n* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *\n*                                                                     *\n* INPUTS ARE AS FOLLOWS:                                              *\n*                                                                     *\n* REGISTER 1 CONTAINS THE ADDRESS OF THE AREA CONTAINING THE TEXT OF  *\n*  THE ATOM.                                                          *\n* REGISTER 0 CONTAINS THE LENGTH OF THE AREA ADDRESSED BY REGISTER 1. *\n*                                                                     *\n* REGISTER 2 CONTAINS NIL, IF THE ATOM IS NOT TO BE INTERNED,         *\n* OR ANY OTHER VALUE (TYPICALLY T) IF THE ATOM IS TO BE INTERNED      *\n* (I.E. PLACED ON THE OBLIST).                                        *\n*                                                                     *\n* REGISTER 3 CONTAINS NIL, IF THE ATOM IS TO BE A SYMBOL,             *\n* OR ANY OTHER VALUE (TYPICALLY T) IF THE ATOM IS TO BE FORMATTED     *\n* AS NUMERIC WHERE POSSIBLE.                                          *\n*                                                                     *\n* REGISTER 4 CONTAINS THE CURRENT STACK POINTER TO BE PASSED TO CONS. *\n*                                                                     *\n* ON RETURN REGISTER 15 CONTAINS THE ADDRESS OF THE RETURNED ATOM.    *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* WARNING: DO NOT PASS DATA TO THIS MODULE THAT RESIDES IN            *\n*          VECTOR/STRING SPACE!!!                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 1\nZILABLD  #ZBEG NAME='ZILABLD'\n         SPACE ,\n         STM   #12,#14,ABLDSAVE    SAVE REGISTERS\n         ST    #7,SAVE7            SAVE FILE POINTER REGISTER IF USED\n         LR    #12,#15             SET UP BASE REGISTER\n         DROP  #15\n         USING ZILABLD,#12         ESTABLISH ADDRESSABILITY\n         EJECT\n*                                  REG 3 = FORMAT OR NIL\n         LR    #7,#4               REG 7 = CURRENT STACK POINTER\n         LR    #4,#1               REG 4 --> CHARACTER TEXT AREA\n         LR    #5,#0               REG 5 = LENGTH OF CHARACTER AREA\n         MVI   BITS,0              CLEAR LOCAL OPTION FLAGS\n         CR    #2,#10              IF INTERN PARAMETER IS NOT NIL\n         BE    DONTINT              OR\n         CR    #2,#13                INTERN PARAMETER IS \"NOT SUPPLIED\"\n         BE    DONTINT                THEN...\n         OI    BITS,DOINTERN           SET INTERN FLAG TRUE\nDONTINT  DS    0H\n*\n* WE MAY NEED ONE MORE STACK SLOT.\n*\n         LA    #0,4(,#7)           POINT TO CURRENT STACK LOC + 4\n         #ZPDS (0)                 CHECK THAT WE HAVE ROOM\n*\n* BEGIN PROCESSING\n*\n         OI    ZLCGCFLG,ZLCGCBLD   TURN ON SPECIAL CONSING FLAG\n         STM   #4,#5,ATOMREGS      SAVE THE ADDRESS AND LENGTH\n         MVI   SIGN,C'+'           INITIALIZE SIGN IF REQUIRED\n*\n* CHECK FORMAT PARAMETER TO SEE IF WE NEED TO FORMAT THE ATOM.\n*\n         CR    #3,#10              IF FORMAT PARM = NIL\n         BE    NOTNUM               OR\n         CR    #3,#13                FORMAT PARM = \"NOT SUPPLIED\"\n         BE    NOTNUM                 THEN ASSUME ALPHA, DON'T SCAN IT\n         SPACE\n*\n* SCAN THE ATOM TO DETERMINE WHAT TYPE IT IS.\n* IF IT TURNS OUT TO BE ALPHA, SEARCH THE OBJECT LIST IF INTERN = TRUE.\n* IF IT IS NUMERIC, DON'T INTERN IT - JUST MAKE A NUMERIC ATOM.\n*\n         LA    #14,0(#4,#5)        GET ADDRESS OF END OF ATOM AREA\n         CLI   0(#4),C'+'          IF ATOM STARTS WITH A PLUS SIGN\n         BE    ASIGN               THEN KEEP SIGN AS IS\n         CLI   0(#4),C'-'          IF ATOM STARTS WITH A MINUS SIGN\n         BNE   NOSIGN              THEN\n         MVI   SIGN,C'-'            SET MINUS SIGN\nASIGN    DS    0H                  SINCE WE HAVE A SIGN...\n         LA    #4,1(,#4)           BUMP POINTER PAST SIGN\n         BCTR  #5,0                DECREMENT LENGTH ACCORDINGLY\nNOSIGN   DS    0H\n         LTR   #15,#5              IF ZERO LENGTH (SOLITARY + OR -)\n         BNP   NOTNUM              THEN CANNOT BE NUMERIC\n         LA    #6,256\nSCANLOOP DS    0H\n         CR    #15,#6              IF LENGTH IS 256 OR LESS\n         BNH   DOTRT               THEN WE CAN SCAN EASILY\n         LR    #1,#14              PRIME TRT END-POINTER\n         LR    #2,#4               PRIME SCANNING POINTER\n         TRT   0(256,#2),NUMTBL    SCAN 256 CHARS FOR NON-NUMERIC CHAR\n         BNZ   AFTTRT              IF WE GOT SOMETHING, GO CHECK IT\n         AR    #2,#6               BUMP UP SCANNING POINTER\n         SR    #15,#6              BUMP DOWN SCANNING LENGTH\n         BNP   AFTTRT              WHEN ZERO, GO CHECK RESULT OF TRT\n         B     SCANLOOP            IF STILL POSITIVE, CONTINUE SCANNING\nDOTRT    DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         LR    #1,#14              PRIME TRT END-POINTER\n         LR    #2,#4               PRIME SCANNING POINTER\n         EX    #15,TRTNUM          SCAN NUMERIC PORTION OF ATOM\nAFTTRT   DS    0H\n         LR    #2,#1               GET ADDRESS OF FIRST NON-NUMERIC\n         SR    #2,#4               GET LENGTH OF NUMERIC PORTION\n         BP    ISANUM              IF NONE,\n         CLI   0(#1),C'.'           THEN IF IT BEGINS W/DECIMAL POINT\n         BE    DECPT                     THEN IT IS A FRACTIONAL NUMBER\n         B     NOTNUM                    ELSE IT MUST BE ALPHA\nISANUM   DS    0H\n         CR    #1,#14              IF ATOM IS TOTALLY NUMERIC\n         BE    MAKEFIX             THEN MAKE A FIXNUM ATOM\n         CLI   0(#1),C'.'          IF A DECIMAL POINT\n         BE    DECPT               THEN PROCESS SOME MORE\n         CLI   0(#1),C'E'          IF E\n         BE    MAKEFLTE            THEN MAKE A FLONUM ATOM\n         CLI   0(#1),C'D'          IF D\n         BE    MAKEFLTD            THEN MAKE A FLONUM ATOM\n         CLI   0(#1),C'F'          IF S\n         BE    MAKEFLTF            THEN MAKE A FLONUM ATOM\n         CLI   0(#1),C'S'          IF S\n         BE    MAKEFLTS            THEN MAKE A FLONUM ATOM\n         CLI   0(#1),C'e'          IF e\n         BE    MAKEFLTE            THEN MAKE A FLONUM ATOM\n         CLI   0(#1),C'd'          IF d\n         BE    MAKEFLTD            THEN MAKE A FLONUM ATOM\n         CLI   0(#1),C'f'          IF s\n         BE    MAKEFLTF            THEN MAKE A FLONUM ATOM\n         CLI   0(#1),C's'          IF s\n         BE    MAKEFLTS            THEN MAKE A FLONUM ATOM\n***********************************************************************\n***      CLI   0(#1),C'B'          ELSE CHECK TYPE QUALIFIER. IF B\n***      BE    MAKEBIN             THEN MAKE A FIXNUM ATOM (BINARY)\n***      CLI   0(#1),C'Q'          IF Q\n***      BE    MAKEOCT             THEN MAKE A FIXNUM ATOM (OCTAL)\n***********************************************************************\n         B     NOTNUM              ANYTHING ELSE IS INVALID, IS ALPHA\n         EJECT\nMAKEFIX  DS    0H\n*\n* AT THIS POINT #2 CONTAINS THE LENGTH OF THE STRING OF DIGITS\n* (EXCEPT FOR ANY LEADING SIGN), AND #4 POINTS TO THE FIRST DIGIT\n* (AGAIN, PAST ANY LEADING SIGN).  NOW WE SCAN OFF LEADING ZEROES.\n*\nLZLOOP   CLI   0(#4),C'0'          IF 1ST CHAR SO FAR IS ZERO\n         BNE   FIRSTNZ             THEN...\n         LA    #4,1(,#4)            SKIP TO NEXT CHAR\n         BCT   #2,LZLOOP            DECREMENT LENGTH UNTIL OTHER OR...\n         LA    #15,#SFT0            IT'S ONLY ZEROES, RETURN FIXNUM 0\n         B     RETURN               AND RETURN. ELSE...\nFIRSTNZ  DS    0H                  GOT FIRST NONZERO DIGIT\n*\n* NOW #2 CONTAINS LENGTH OF DIGITS OTHER THAN LEADING ZEROES,\n* AND #4 POINTS TO THE FIRST NONZERO DIGIT.  NOW CHECK FOR BIGNESS.\n*\n         CH    #2,=H'10'           MAX NUM LENGTH IS 10\n         BH    MUSTBBIG            ANY HIGHER, MUST BE BIGNUM\n         BL    MFIXLNOK            LOWER, IS OK\n         CLC   0(10,#4),=C'2147483648'  CHECK AGAINST MAX VALUE\n         BH    MUSTBBIG            HIGHER, MUST BE BIGNUM\n         BL    MFIXLNOK            LOWER, FIXNUM\n         CLI   SIGN,C'-'           EQUAL, FIXNUM ONLY IF NEGATIVE\n         BNE   MUSTBBIG            IF NEGATIVE, THEN...\n         LA    #15,FIXMNEG         POINT TO FIXNUM -2147483648\n         B     RETURN              AND RETURN WITH IT.  ELSE...\nMFIXLNOK DS    0H                  OK - #2 CONTAINS LENGTH OF NUMERICS\n         BCTR  #2,0                REDUCE FOR EXECUTE\n         EX    #2,PACKNUM          PACK INTO DOUBLE WORD\n         CVB   #2,ZLCDBL           GET BINARY VALUE INTO REGISTER\n         CLI   SIGN,C'-'           IF A MINUS SIGN WAS SPECIFIED\n         BNE   MFIXCHK             THEN\n         LCR   #2,#2                MAKE VALUE NEGATIVE\n         B     MFIXCONS             AND GO TO DEFINITELY CONS IT UP\nMFIXCHK  DS    0H                  ELSE POSITIVE, SEE IF IT'S IN TABLE\n         CL    #2,ZLCSFTHI         IF FIXNUM IS IN TABLE\n         BH    MFIXCONS            THEN\n         SLA   #2,3                 CONVERT FIXNUM TO TABLE INDEX\n         LA    #15,#SFT(#2)         GET ADDRESS OF FIXNUM IN TABLE\n         B     RETURN               AND RETURN WITH IT\nMFIXCONS DS    0H                  ELSE CONS UP THE FIXNUM\n         LR    #0,#7               PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE FIXED ATOM USING #2, RET'G #15\n         B     RETURN              RETURN TO CALLER WITH ATOM\n*\n* NUMERIC ATOMS ARE NOT INTERNED ON THE OBJECT LIST.\n*\n* ON ENTRY TO EACH ONE OF THESE LITTLE ROUTINES...\n* #4 --> THE ATOM WITHOUT THE SIGN, IF THERE WAS ONE\n* #5 = LENGTH OF THE ATOM (WITHOUT THE SIGN)\n* #1 --> THE DELIMITING CHARACTER THAT WE SAW\n* #2 = THE LENGTH OF THE NUMERIC UP TO THE DELIMITER <- #1 (W/O SIGN)\n* #14 --> THE END OF THE ATOM (JUST PAST THE LAST CHARACTER THEREIN)\n* #15 = LENGTH OF THE ATOM (WITHOUT THE SIGN) MINUS 1 FOR EXECUTE\n*\n         EJECT\n***********************************************************************\n*MAKEBIN DS    0H                  SAW A 'B'\n*        SPACE 1\n*        STM   #14,#1,SAVEREGS     Save volatile register\n*        #TPUT 1,ERR2015           Tell user about old-style constant\n*        LM    #14,#1,SAVEREGS     Restore volatile register\n*        SPACE 1\n*        CH    #2,=H'32'           MAX LENGTH FOR BINARY CONSTANT IS 32\n*        BH    NUM2LONG\n*        #BAS  #15,GETEXP          GET EXPONENT, IF ANY, INTO #0\n*        LA    #1,1                SET UP MASK TO INSERT BINARY BITS\n*        XR    #15,#15             CLEAR REG TO HOLD RESULT\n*BLOOP   DS    0H                  LOOP TO GET BINARY DIGITS\n*        SLL   #15,1               SHIFT OVER TO MAKE ROOM\n*        CLI   0(#4),C'0'          IF A 0\n*        BE    B0                  THEN PROCESS BINARY 0\n*        CLI   0(#4),C'1'          IF A 1\n*        BE    B1                  THEN PROCESS BINARY 1\n*        #TPUT 1,ERR2011           INVALID BINARY DIGIT\n*        B     NOTNUM              ASSUME SYMBOL\n*B1      DS    0H\n*        OR    #15,#1              INSERT A 1-BIT\n*B0      DS    0H                  INSERT A 0-BIT (I.E. DO NOTHING)\n*        LA    #4,1(,#4)\n*        BCT   #2,BLOOP            UNTIL END OF NUMERICS\n*        CLI   SIGN,C'-'           IF A MINUS SIGN WAS ENTERED\n*        BNE   BNOTMIN             THEN\n*        LCR   #15,#15              MAKE IT NEGATIVE\n*BNOTMIN DS    0H\n*        LTR   #5,#0               CHECK EXPONENT\n*        BZ    BNOSHIFT            SKIP IF NONE\n*        BM    BRSHIFT             IF POSITIVE, THEN\n*        SLA   #15,0(#5)            SHIFT LEFT BY (EXPONENT) BITS\n*        B     BNOSHIFT            IF NEGATIVE, THEN\n*BRSHIFT LPR   #5,#5                MAKE EXPONENT POSITIVE AND\n*        SRA   #15,0(#5)            SHIFT RIGHT BY (EXPONENT) BITS\n*BNOSHIFTDS    0H\n*        LR    #2,#15              GET NUMERIC VALUE\n*        LR    #0,#7               PASS CURRENT STACK LOCATION TO CONS\n*        #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n*        B     RETURN              RETURN WITH IT\n*        SPACE\n*MAKEOCT DS    0H                  SAW AN 'O'\n*        SPACE 1\n*        STM   #14,#1,SAVEREGS     Save volatile register\n*        #TPUT 1,ERR2016           Tell user about old-style constant\n*        LM    #14,#1,SAVEREGS     Restore volatile register\n*        SPACE 1\n*        CH    #2,=H'11'           MAX LENGTH FOR OCTAL CONSTANT IS 11\n*        BH    NUM2LONG\n*        BL    OOK\n*        CLI   0(#4),C'3'          IF 11 POSITIONS, FIRST MUST BE 0XX\n*        BH    NUM2LONG\n*OOK     DS    0H\n*        #BAS  #15,GETEXP          GET EXPONENT, IF ANY, INTO #0\n*        XR    #15,#15             CLEAR REG TO HOLD RESULT\n*OLOOP   DS    0H                  LOOP TO GET BINARY DIGITS\n*        SLL   #15,3               SHIFT OVER TO MAKE ROOM\n*        CLI   0(#4),C'0'          IF BETWEEN 0 AND 7\n*        BL    OERR                THEN\n*        CLI   0(#4),C'7'           PROCESS OCTAL DIGIT\n*        BNH   OD                  ELSE\n*OERR    #TPUT 1,ERR2012            INVALID OCTAL DIGIT\n*        B     NOTNUM               ASSUME SYMBOL\n*OD      DS    0H\n*        IC    #1,0(,#4)           PICK UP OCTAL DIGIT\n*        SLL   #1,28               CLEAR OUT JUNK\n*        SRL   #1,28\n*        OR    #15,#1              INSERT OCTAL BITS\n*        LA    #4,1(,#4)           BUMP CHARACTER POINTER\n*        BCT   #2,OLOOP            UNTIL END OF NUMERICS\n*        CLI   SIGN,C'-'           IF A MINUS SIGN WAS ENTERED\n*        BNE   ONOTMIN             THEN\n*        LCR   #15,#15              MAKE IT NEGATIVE\n*ONOTMIN DS    0H\n*        LTR   #5,#0               CHECK EXPONENT\n*        BZ    ONOSHIFT            SKIP IF NONE\n*        BM    ORSHIFT             IF POSITIVE, THEN\n*        MH    #5,=H'3'            CONVERT EXPONENT TO SHIFT AMOUNT\n*        SLA   #15,0(#5)            SHIFT LEFT BY (EXPONENT*3) BITS\n*        B     ONOSHIFT            IF NEGATIVE, THEN\n*ORSHIFT LPR   #5,#5                MAKE EXPONENT POSITIVE AND\n*        MH    #5,=H'3'            CONVERT EXPONENT TO SHIFT AMOUNT\n*        SRA   #15,0(#5)            SHIFT RIGHT BY (EXPONENT*3) BITS\n*ONOSHIFTDS    0H\n*        LR    #2,#15              GET NUMERIC VALUE\n*        LR    #0,#7               PASS CURRENT STACK LOCATION TO CONS\n*        #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n*        B     RETURN              RETURN WITH IT\n***********************************************************************\n         EJECT\nMAKEFLTD DS    0H                  SAW A 'D'\nMAKEFLTE DS    0H                  SAW AN 'E'\n         OI    BITS,DEXP           Indicate building double float\n         B     MAKEFLT             Go start building it\n         SPACE 1\nMAKEFLTF DS    0H                  SAW AN 'F'\nMAKEFLTS DS    0H                  SAW AN 'S'\n         NI    BITS,255-DEXP       Indicate building single float\n******** B     MAKEFLT             Go start building it\n         SPACE 1\nMAKEFLT  DS    0H                  MAKE A SINGLE-PRECISION FLONUM\n         SPACE 1\n         #BAS  #15,GETEXP          GET EXPONENT, IF ANY, INTO #0\n         LD    #F0,=D'0'           INITIALIZE REG TO HOLD RESULT\n         XC    ZLCDBL(8),ZLCDBL    CLEAR TEMP FLOAT IN STORAGE\n         CLI   SIGN,C'-'           DEPENDING ON SIGN OF INPUT...\n         BE    NEGFLOAT\n         MVI   ZLCDBL,X'42'        X'420_0000 00000000'\n         B     AFTNEGFL\nNEGFLOAT MVI   ZLCDBL,X'C2'        X'C20_0000 00000000'\nAFTNEGFL DS    0H\nFLOOP    DS    0H\n         MVN   ZLCDBL+1(1),0(#4)   MOVE IN NUMERIC PART OF DIGIT\n         MD    #F0,=D'10'          MULTIPLY WHAT WE HAVE SO FAR BY 10\n         AD    #F0,ZLCDBL          ADD FP VERSION OF DIGIT\n         LA    #4,1(,#4)           BUMP DIGIT POINTER\n         BCT   #2,FLOOP            CONTINUE UNTIL ALL DIGITS USED UP\n         LTR   #0,#0               NOW GET EXPONENT\n         BZ    FNOEXP              IF ZERO, DO NO MORE\n         BM    FMINEXP             IF NEGATIVE, DIVIDE BY POWER OF 10\nFEXPLOOP MD    #F0,=D'10'          IF POSITIVE, MULTIPLY BY POWER OF 10\n         BCT   #0,FEXPLOOP         BY REPEATEDLY MULTIPLYING BY 10\n         B     FNOEXP              UNTIL EXPONENT IS EXHAUSTED\nFMINEXP  LPR   #0,#0               IF NEGATIVE, MAKE EXPONENT POSITIVE\nFMINLOOP DD    #F0,=D'10'          AND REPEATEDLY DIVIDE BY 10\n         BCT   #0,FMINLOOP         UNTIL EXPONENT IS EXHAUSTED.\nFNOEXP   DS    0H\n         B     DPNOEXP             Go build single or double float\n         EJECT\nDECPT    DS    0H                  SAW A '.'\n         OI    BITS,DEXP           Default is double float if no exp.\n         LA    #15,1(,#1)          POINT TO CHARACTER FOLLOWING '.'\n         CR    #15,#14             IF AT END (I.E. LAST CHAR IS '.')\n         BL    MAKEFLO              THEN...\n         LTR   #2,#2                 IF IT HAS A NUMERIC (INTEGER) PART\n         BNZ   MAKEFIX                THEN TREAT IT AS A FIXNUM\n         BZ    NOTNUM                 ELSE NOT NUMERIC\nMAKEFLO  DS    0H                  ELSE DECIMAL POINT NOT AT END: FLOAT\n         LD    #F0,=D'0'           INITIALIZE REG TO HOLD RESULT\n         LTR   #2,#2               IF ZERO-LENGTH NUMERIC (.NNN...)\n         BZ    DPNOINT             THEN INTEGER PART IS ZERO\n         XC    ZLCDBL(8),ZLCDBL    CLEAR TEMP FLOAT IN STORAGE\n         CLI   SIGN,C'-'           DEPENDING ON SIGN OF INPUT...\n         BE    NEGDECPT\n         MVI   ZLCDBL,X'42'        X'420_0000 00000000'\n         B     AFTDECFL\nNEGDECPT MVI   ZLCDBL,X'C2'        X'C20_0000 00000000'\nAFTDECFL DS    0H\nDPLOOP   DS    0H\n         MVN   ZLCDBL+1(1),0(#4)   MOVE IN NUMERIC PART OF DIGIT\n         MD    #F0,=D'10'          MULTIPLY WHAT WE HAVE SO FAR BY 10\n         AD    #F0,ZLCDBL          ADD FP VERSION OF DIGIT\n         LA    #4,1(,#4)           BUMP DIGIT POINTER\n         BCT   #2,DPLOOP           CONTINUE UNTIL ALL DIGITS USED UP\nDPNOINT  DS    0H                  GOT INTEGER, NOW GET FRACTION PART\n         XR    #0,#0               INITIALIZE EXPONENT TO ZERO\n         LA    #4,1(,#1)           POINT TO CHAR FOLLOWING DEC POINT\n         LR    #15,#14             POINT TO END OF ATOM\n         SR    #15,#4              COMPUTE LENGTH OF DATA FOLLOWING \".\"\n         BNP   DPNOEXP             IF NONE, THAT'S IT, WE GOT THE VALUE\n         LA    #6,256\nFLSCANLP DS    0H\n         CR    #15,#6              IF LENGTH IS 256 OR LESS\n         BNH   FLDOTRT             THEN WE CAN SCAN EASILY\n         LR    #1,#14              PRIME TRT END-POINTER\n         LR    #2,#4               PRIME SCANNING POINTER\n         TRT   0(256,#2),NUMTBL    SCAN 256 CHARS FOR E OR OTHER \u00acNUM\n         BNZ   FLAFTTRT            IF WE GOT SOMETHING, GO CHECK IT\n         AR    #2,#6               BUMP UP SCANNING POINTER\n         SR    #15,#6              BUMP DOWN SCANNING LENGTH\n         BNP   FLAFTTRT            WHEN ZERO, GO CHECK RESULT OF TRT\n         B     FLSCANLP            IF STILL POSITIVE, CONTINUE SCANNING\nFLDOTRT  DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         LR    #1,#14              PRIME TRT END-POINTER\n         LR    #2,#4               PRIME SCANNING POINTER\n         EX    #15,TRTNUM          SCAN NUMERIC PORTION OF ATOM\nFLAFTTRT DS    0H\n         ST    #1,SAVEX            SAVE END-OF-FRACTION POINTER\n         BZ    DPFRAC              IF GOT TO THE END, PROCESS FRACTION\n         CLI   0(#1),C'E'          IF \"E\" FOUND\n         BE    PENUM               THEN THIS IS STILL A NUMBER\n         CLI   0(#1),C'D'          IF \"D\" FOUND\n         BE    PDNUM               THEN THIS IS STILL A NUMBER\n         CLI   0(#1),C'F'          IF \"F\" FOUND\n         BE    PFNUM               THEN THIS IS STILL A NUMBER\n         CLI   0(#1),C'S'          IF \"S\" FOUND\n         BE    PSNUM               THEN THIS IS STILL A NUMBER\n         CLI   0(#1),C'e'          IF \"e\" FOUND\n         BE    PENUM               THEN THIS IS STILL A NUMBER\n         CLI   0(#1),C'd'          IF \"d\" FOUND\n         BE    PDNUM               THEN THIS IS STILL A NUMBER\n         CLI   0(#1),C'f'          IF \"f\" FOUND\n         BE    PFNUM               THEN THIS IS STILL A NUMBER\n         CLI   0(#1),C's'          IF \"s\" FOUND\n         BE    PSNUM               THEN THIS IS STILL A NUMBER\n         B     NOTNUM              ELSE THIS CAN'T BE A NUMBER\n         SPACE 1\nPDNUM    DS    0H                  n.nDn\nPENUM    DS    0H                  n.nEn\n         OI    BITS,DEXP           Indicate we're building a double flt\n         B     PNUM                Go starting building it\n         SPACE 1\nPSNUM    DS    0H                  n.nSn\nPFNUM    DS    0H                  n.nFn\n         NI    BITS,255-DEXP       Indicate we're building a single flt\n******** B     PNUM                Go starting building it\n         SPACE 1\nPNUM     DS    0H\n         #BAS  #15,GETEXP          GET THE EXPONENT INTO #0\n* #4 STILL POINTS TO THE FRACTIONAL PART OF THE NUMBER.\nDPFRAC   DS    0H                  PROCESS FRACTIONAL PART\n         LD    #F2,=D'0'           INITIALIZE REG TO HOLD RESULT\n         LD    #F4,=D'1'           INITIALIZE REG TO HOLD POWER OF 10\n         L     #2,SAVEX            GET ADDRESS OF END OF FRACTION\n         SR    #2,#4               COMPUTE ITS LENGTH.  IF ZERO (N.EN)\n         BZ    DFNOINT             THEN INTEGER PART IS ZERO. ELSE\n         MVC   ZLCDBL(8),=X'4200000000000000'\nDFLOOP   DS    0H\n         MVN   ZLCDBL+1(1),0(#4)   MOVE IN NUMERIC PART OF DIGIT\n         MD    #F2,=D'10'          MULTIPLY WHAT WE HAVE SO FAR BY 10\n         MD    #F4,=D'10'          MULTIPLY WHAT WE HAVE SO FAR BY 10\n         AD    #F2,ZLCDBL          ADD FP VERSION OF DIGIT\n         LA    #4,1(,#4)           BUMP DIGIT POINTER\n         BCT   #2,DFLOOP           CONTINUE UNTIL ALL DIGITS USED UP\nDFNOINT  DS    0H\n         DDR   #F2,#F4             DIVIDE BY 10**(#PLACES) FOR FRACTION\n         CLI   SIGN,C'-'           IF NUMBER IS NOT NEGATIVE\n         BE    DFSUB               THEN\n         ADR   #F0,#F2              ADD FRACTION TO INTEGER PART\n         B     DFAFT               ELSE\nDFSUB    SDR   #F0,#F2              SUBTRACT FRACTION FROM INTEGER PART\nDFAFT    DS    0H\n         LTR   #0,#0               NOW GET EXPONENT\n         BZ    DPNOEXP             IF ZERO, DO NO MORE\n         BM    DPMINEXP            IF NEGATIVE, DIVIDE BY POWER OF 10\nDPEXLOOP MD    #F0,=D'10'          IF POSITIVE, MULTIPLY BY POWER OF 10\n         BCT   #0,DPEXLOOP         BY REPEATEDLY MULTIPLYING BY 10\n         B     DPNOEXP             UNTIL EXPONENT IS EXHAUSTED\nDPMINEXP LPR   #0,#0               IF NEGATIVE, MAKE EXPONENT POSITIVE\nDPMILOOP DD    #F0,=D'10'          AND REPEATEDLY DIVIDE BY 10\n         BCT   #0,DPMILOOP         UNTIL EXPONENT IS EXHAUSTED.\nDPNOEXP  DS    0H                  Build single or double float\n         TM    BITS,DEXP           If this is a double float,\n         BO    BUILDDBL            then go to build double float.\n         LRER  #F0,#F0             Else round double to single\n         STE   #F0,ZLCDBL          STORE FINAL RESULT\n         L     #2,ZLCDBL           LOAD INTO GPR\n         LR    #0,#7               PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FLOAT               MAKE A FLOATING POINT ATOM\n         B     RETURN              RETURN WITH IT\n         SPACE 1\nBUILDDBL DS    0H                  Build a double float\n         LR    #0,#7               Pass current stack location to CONS\n         L     #15,ZLCMDF          Get address of ZILMDF\n         #BASR #14,#15             Call ZILMDF to cons up a flonum\n         B     RETURN              Return with the flonum\n         EJECT\nMUSTBBIG DS    0H                  LONG NUMERIC - MUST BE A BIGNUM\n         SPACE 1\n***********************************************************************\n* INTEGER LARGER THAN MAXIMUM FIXNUM - MAKE A BIGNUM OUT OF IT.       *\n* #2 CONTAINS THE LENGTH OF THE DIGITS (SIGN AND LEADING 0'S EXCLUDED)*\n* #4 POINTS TO THE STRING OF DIGITS (SIGN AND LEADING ZEROES EXCLUDED)*\n* THE FIELD \"SIGN\" CONTAINS \"+\" OR \"-\", DEPENDING ON THE SIGN         *\n* THIS ROUTINE SHOULD MAKE A BIGNUM, PUT ITS ADDRESS IN #15, AND      *\n* BRANCH TO \"RETURN\".                                                 *\n* THROUGHOUT THIS BIGNUM CONVERSION CODE THE REGISTERS ARE USED FOR   *\n* THE FOLLOWING PURPOSES.                                             *\n* R0 = CONS POINTER; MOST SIGNIFICANT WORD OF MACHINE MULTIPLY        *\n* R1 = MULITPLICAND; LEAST SIGNIFICANT WORD OF MULTIPLY RESULT        *\n* R2 = 9 (DIGIT CHARACTER CHUNK SIZE); 1,000,000,000 LARGEST POWER OF *\n*      10 REPRESENTABLE IN 2**31 RADIX                                *\n* R3 = POINTER TO THE END OF THE DIGIT CHARACTERS TO BE CONVERTED;    *\n*      LATER MOVED BACK BY 9 FOR PROPER BXLE TERMINATION CONDITION.   *\n* R4 = POINTER TO THE BEGINNING OF THE DIGIT CHARACTER STRING;        *\n* R5 = INCREMENTED TO ALWAYS POINT TO THE NEXT 9 DIGIT-CHARACTER CHUNK*\n* R6 = 4 - USEFUL GENERALLY, ALSO FOR BIGNUM POINTER BXLE INCREMENT   *\n* R7 = POINTER TO THE END OF THE BIGNUM (THIS GROWS AS MORE CHUNKS ARE*\n*      CONVERTED, ITS FINAL VALUE IS THE SIZE OF THE BIGNUM)          *\n* R14= MULTIPLY CARRY REGISTER, DOVETAILS BEAUTIFULLY WITH THE ADD    *\n*      REQUIRED TO THE BIGNUM AFTER EVERY CONVERSION - SIMPLY PRETEND *\n*      IT'S A CARRY INTO THE FIRST MULTIPLY                           *\n* R15= POINTER TO RESULTING BIGNUM                                    *\n***********************************************************************\n         SPACE 1\n         LR    #0,#7               PASS CURRENT STACK LOCATION TO CONS\n         LA    #3,0(#2,#4)         CALCULATE POINTER TO END OF STRING\n         S     #3,=F'9'            POINT TO LAST 9-DIGIT CHUNK\n         LR    #7,#2               SAVE STRING LENGTH\n         XR    #6,#6               CLEAR FOR DIVIDE\n         D     #6,=F'9'            DIVIDE BY CHUNK SIZE\n         LR    #5,#4               SAVE POINTER TO BEGINNING OF STRING\n         SLL   #7,2                # OF 9-DIGITS CHUNKS * 4\n         LA    #2,##VECDAT+4(,#7)  ADD CONSTANT FOR REMAINDER ( <9 )\n         L     #15,ZLCBIG          GET ADDRESS OF BIGNUM MAKER\n         #BASR #14,#15             CALL BIGNUM MAKER\n*\n         LR    #4,#5               GET POINTER TO BEGINNING OF STRING\n         LTR   #6,#6               IS REMAINDER = 0\n         BZ    GET9I               YES, THEN WE HAVE EXACT 9-MULTIPLE\n         BCTR  #6,0\n         EX    #6,EXPACK           PACK #6 AMOUNT OF BYTES\n         LA    #4,1(#6,#4)\n*\nFIRSTCVB CVB   #1,ZLCDBL           CONVERT INTO ONE BINARY WORD\n         ST    #1,##VECDAT(,#15)   STORE INTO BIGNUM - PRIME THE MULT\n*\n         LA    #6,4                GENERATE 4 FOR GENERAL USE\n         LR    #7,#6               PRIME THE BIGNUM LENGTH\nNXTCVB   LR    #5,#6               RESET OFFSET IN BIGNUM TO 4\n         PACK  ZLCDBL(8),0(9,#4)   PACK ANOTHER 9 EBCDIC DIGITS\n         CVB   #14,ZLCDBL          CONVERT - WILL BE LESS THAN BILLION\n         L     #2,=F'1000000000'   PREP FOR DIVIDING BY A BILLION\nBFLOOP   L     #1,##VECDAT-4(#5,#15) LOAD NEXT BIGNUM WORD\n         MR    #0,#2               MULTIPLY BY A BILLION\n         ALR   #1,#14              ADD THE CARRY WORD FROM LAST LOOP\n         BC    12,BFLOOPNC         CAN WE SKIP THE CARRY BIT TO NEXT?\n         A     #0,=F'1'            ADD IN CARRY BIT *OPTIMIZE*\nBFLOOPNC SLDL  #0,1                CONVERT TO 31-BIT RADIX\n         SRL   #1,1                RESTORE LOWER WORD\n         ST    #1,##VECDAT-4(#5,#15) RESULT BIGNUM OVERLAYS OLD\n         LR    #14,#0              SAVE MS WORD AS A CARRY\n         BXLE  #5,#6,BFLOOP        CONTINUE TO END OF OLD BIGNUM\n*\n         LTR   #0,#0               TEST HIGHEST WORD OF BIGNUM RESULT\n         BZ    HWORD0              IF 0 THEN SKIP THIS EXTRA STORE\n         ST    #0,##VECDAT-4(#5,#15) STORE NEW HIGHEST WORD\n         LR    #7,#5               STORE NEW LENGTH IN LIMIT REGISTER\nHWORD0   LA    #2,9                NEED 9 TEMPORARILY AS INC FOR BXLE\n         BXLE  #4,#2,NXTCVB        WE HAVE ANOHTER 9-CHARACTER CHUNK?\n*\n         STCM  #7,7,1(#15)         SET BIGNUM LENGTH FIELD\n         LA    #1,##VECDAT(#7,#15) POINT TO END OF BIGNUM\n         ST    #1,ZLCVSNXT         STORE POINTER TO AVAILABLE VSS\n         CLI   SIGN,C'-'           TEST SIGN OF BIGNUM\n         BNE   RETURN              BIGNUM IS NOT MINUS\n         OI    ##VECDAT(#15),X'80' SET BIGNUM SIGN TO NEGATIVE\n         B     RETURN\n*\nGET9I    PACK  ZLCDBL(8),0(9,#4)\n         LA    #4,9(,#4)           BUMP CHAR POINTER TO NEXT CHUNK\n         B     FIRSTCVB\n*\nEXPACK   PACK  ZLCDBL(8),0(0,#4)   USED BY EXECUTE FOR VARIABLE LEN\n*--------------------------------------------------------------------\n         EJECT\nNOTNUM   DS    0H                  ATOM MUST BE ALPHA\n         SPACE 1\n         LM    #4,#5,ATOMREGS      PICK UP TEXT ADDRESS AND LENGTH\n         TM    BITS,DOINTERN       IF INTERN PARM = NIL\n         BZ    NOINTERN            THEN DON'T INTERN ATOM\n*\n* SEARCH FOR ATOM ON OBJECT LIST.  IF IT IS THERE, RETURN POINTER TO\n* EXISTING ATOM.  IF IT IS NOT THERE, BUILD A NEW ONE AND CONS IT TO\n* THE OBJECT LIST.\n*\n* CHECK IF THE LENGTH IS SUCH THAT THE SYMBOL COULD BE T OR NIL.\n*\n         CH    #5,=H'1'            IF LENGTH = 1\n         BNE   OBNOTT               AND\n         CLI   0(#4),C'T'           AND TEXT = \"T\"\n         BNE   OBSEARCH              THEN...\n         LR    #15,#8                 POINT TO T\n         B     RETURN                  AND RETURN\nOBNOTT   DS    0H                  ELSE LENGTH NOT 1\n         CH    #5,=H'3'            IF LENGTH = 3\n         BNE   OBSEARCH             AND\n         CLC   0(3,#4),=C'NIL'       TEXT = \"NIL\"\n         BNE   OBSEARCH               THEN...\n         LR    #15,#10                 POINT TO NIL\n         B     RETURN                   AND RETURN\nOBSEARCH DS    0H                  OTHERWISE SEARCH THE OBLIST FOR IT\n         LA    #0,0(,#7)           SET STACK POINTER FOR CONSING\n         L     #15,ZLCINTN         GET ADDRESS OF ZILINTN\n         XR    #7,#7               INDICATE THAT WE NEED A NEW CELL\n         #BASR #14,#15             CALL ZILINTN TO INTERN SYMBOL\n         B     RETURN              RETURN WITH INTERNED SYMBOL\n         SPACE 1\nNOINTERN DS    0H                  NOT TO BE INTERNED, BUILD SYMBOL\n         LA    #2,##SYMLEN+3(,#5)  GET LENGTH OF STRING + OF SYMBOL\n         LR    #3,#4               GET PNAME TEXT PTR INTO SAFE REG\n         N     #2,=X'FFFFFFFC'     ROUND LEN UP TO FULLWORD BOUNDARY\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         XR    #1,#1               SET ENTRY CODE 0 FOR ZILVSS\n         #BASR #14,#15             CALL ZILVSS TO ALLOCATE SPACE\n         LTR   #4,#4               IF NOT ENOUGH SPACE\n         BZ    NOROOM              THEN ERROR\n*                                  Else R4 -> where to build the text\n*                                  and R15 -> the string object\n         LA    #2,##SYMLEN(,#15)   GET ADDRESS OF PNAME STRING\n         ST    #5,0(,#2)           STORE STRING LENGTH\n         MVI   0(#2),##STRING      SET STRING TYPE\n         MVC   0(##SYMLEN,#15),ZLCNSYM INITIALIZE SYMBOL FROM TEMPLATE\n         ST    #2,##PNAME(,#15)    STORE PRINT NAME CELL OF SYMBOL\n* Package cell remains \"uninterned\"\n         LA    #4,##VECDAT(,#2)    #4 = POINTER TO STRING TEXT DEST\n*                                  #5 = LENGTH OF PNAME TEXT\n         LR    #0,#3               GET POINTER TO OUR PNAME TEXT\n         LR    #1,#5               GET LENGTH FOR MVCL\n         MVCL  #4,#0               MOVE PNAME TEXT INTO THE STRING\n         SPACE\nRETURN   DS    0H                  RETURN WITH NEW OBJECT IN #15\n         NI    ZLCGCFLG,255-ZLCGCBLD TURN OFF SPECIAL CONSING FLAG\n         L     #7,SAVE7            RESTORE REGISTERS\n         LM    #12,#14,ABLDSAVE    RESTORE REGISTERS\n         BR    #14                 RETURN TO CALLER\n         EJECT\nNOROOM   DS    0H                  NO V/S SPACE TO BUILD SYMBOL\n         #ERR  'ZIL2100 ZILABLD: No vector/string space available, symbX\n               ol not built.',PREFIX=NO\n         EJECT\nGETEXP   DS    0H\n*\n* THIS SUBROUTINE EXTRACTS AN EXPONENT FROM A FLOAT, BINARY OR OCTAL.\n* #0 CONTAINS THE EXPONENT VALUE (ZERO IF NONE).\n* #1 POINTS TO THE DELIMITING CHARACTER B/O/E AND IS DESTROYED.\n* #2 IS DESTROYED BY TRT.\n* #14 POINTS TO THE END OF THE ATOM AND IS DESTROYED.\n* #15 IS THE RETURN ADDRESS.\n* NOTE THAT IF THE EXPONENT IS INVALID, THEN THE ENTIRE NUMBER IS\n* CONSIDERED NON-NUMERIC AND CONTROL DOES NOT RETURN BUT GOES TO\n* ALPHA PROCESSING.\n*\n         XR    #0,#0               CLEAR EXPONENT TO ZERO\n         LA    #6,1(,#1)           POINT TO EXPONENT IF ANY\n         LR    #3,#6               SAVE ADDRESS OF EXPONENT\n         SR    #14,#6              GET LENGTH OF EXPONENT IF ANY\n         BNPR  #15                 IF ZERO, NO EXPONENT\n         CLI   0(#6),C'+'          SEE IF EXPONENT HAS A SIGN\n         BE    EXPSIGN\n         CLI   0(#6),C'-'\n         BNE   EXPNOSGN\nEXPSIGN  LA    #6,1(,#6)           IF IT DOES, ADJUST REGS FOR IT\n         BCTR  #14,0\nEXPNOSGN LTR   #14,#14             IF NO NUMERIC PART, THEN\n         BNP   NOTNUM              THIS IS NOT A NUMBER AT ALL\n         CH    #14,=H'256'         IF NUMERIC PART LONGER THAN 256\n         BH    NOTNUM              THEN DEFINITELY NOT A VALID EXPONENT\n         BCTR  #14,0               REDUCE LENGTH FOR EXECUTE\n         EX    #14,TRTEXP          SCAN EXPONENT FOR NUMERICS\n         BNZ   NOTNUM              IF NON-NUMERIC, NOT A NUMBER AT ALL\n         CH    #14,=H'3'           IF NUMERIC PART LONGER THAN 4 DIGITS\n         BH    BADEXP              THEN NOT A VALID EXPONENT\n         EX    #14,PACKEXP         ELSE PACK EXPONENT INTO WORKAREA\n         CVB   #0,ZLCDBL           GET EXPONENT INTO REGISTER 0\n         CLI   0(#3),C'-'          IF MINUS\n         BNER  #15                 THEN\n         LCR   #0,#0                SET EXPONENT NEGATIVE\n         BR    #15                 RETURN TO CALLER\n         SPACE 1\nBADEXP   EQU   NOTNUM              TREAT VALUE AS ALPHA\n*******  #TPUT 1,ERR2013           TELL USER EXPONENT IS NO GOOD\n*******  B     NOTNUM              TREAT VALUE AS ALPHA\n         SPACE 1\n***********************************************************************\n*NUM2LONGDS    0H                  NUMERIC OUT OF PERMISSIBLE RANGE\n*        #TPUT 1,ERR2010           TELL USER NUMBER IS TOO LONG\n*        B     NOTNUM              TREAT VALUE AS ALPHA\n***********************************************************************\n         EJECT\nTRTNUM   TRT   0(0,#2),NUMTBL      SCAN NUMERIC PORTION OF ATOM\nPACKNUM  PACK  ZLCDBL(8),0(0,#4)   PACK ATOM INTO DOUBLE WORD\nTRTEXP   TRT   0(0,#6),NUMTBL      SCAN NUMERIC PORTION OF ATOM\nPACKEXP  PACK  ZLCDBL(8),0(0,#6)   PACK ATOM INTO DOUBLE WORD\n         SPACE 2\nABLDSAVE DS    3A                  SAVE AREA FOR REGISTERS\nSAVE7    DS    A                   SAVE\nSAVEX    DS    A                   SAVE\nSAVEREGS DS    5A                  MORE SAVE\n         SPACE\nATOMREGS DS    2A                  THE ADDRESS AND LENGTH OF ATOM TEXT\n         SPACE\nSIGN     DS    X                   + OR -\nBITS     DS    X                   FLAGS\nDOINTERN EQU   X'80'               1 = INTERN THE SYMBOL\nDEXP     EQU   X'40'               1 = DOUBLE FLOAT\n         SPACE\nFIXMNEG  #IATM -2147483648         MOST NEGATIVE FIXNUM (X'80000000')\n         SPACE\n***2013  DC    C'ZIL2013 INVALID EXPONENT, ASSUMING SYMBOL.'\n***2010  DC    C'ZIL2010 NUMERIC TOO LARGE, ASSUMING SYMBOL.'\n***2011  DC    C'ZIL2011 INVALID BINARY CONSTANT, ASSUMING SYMBOL.'\n***2012  DC    C'ZIL2012 INVALID OCTAL CONSTANT, ASSUMING SYMBOL.'\n***2015  DC    C'ZIL2015 OLD STYLE LISP BINARY CONSTANT ASSUMED.'\n***2016  DC    C'ZIL2016 OLD STYLE LISP OCTAL CONSTANT ASSUMED.'\n         SPACE\nNUMTBL   DC    256YL1(1)           TABLE TO SCAN FOR NUMERICS\n         ORG   NUMTBL+C'0'\n         DC    10YL1(0)            ONLY VALID CHARACTERS\n         ORG   ,                   END OF TABLE\n         SPACE\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILADD": {"ttr": 9476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11P\\x02\\x88\\x02\\x85\\x02\\x87\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:50:00", "lines": 648, "newlines": 645, "modlines": 647, "user": "SEB1525"}, "text": "         TITLE 'ZILADD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILADD TAKES TWO ARGUMENTS. BOTH MUST BE NUMERIC ATOMS.             *\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS:                                    *\n*                                                                     *\n* 1. BOTH ARGS INTEGER       - PERFORM INTEGER ADDITION.              *\n* 2. BOTH ARGS FLOAT         - PERFORM REAL ADDITION.                 *\n* 3. ONE FIXED, ONE FLOAT    - CONVERT THE FIXED ARGUMENT TO          *\n*                              FLOAT AND PERFORM REAL ADDITION.       *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n* For future consideration:                                           *\n*                                                                     *\n* ===> Make short path for FIXNUM + FIXNUM = FINXUM such that there   *\n*      is no stack saving or restoring.                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILADD   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILADD'\n         SPACE\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM\n         BNE   NFIX1\n         CLI   ##TYPE(#7),##FIXNUM\n         BNE   FX1NFX2\n*---------------------------------------------------------------------*\n*                      FIXNUM TO FIXNUM ADD                           *\n*---------------------------------------------------------------------*\n         L     #2,##CDR(,#6)       GET FIXED VALUE 1\n         A     #2,##CDR(,#7)       ADD THEM\n         BO    OVERFIX             OVERFLOW OCCURRED, MUST BE BIGNUM\n         #MKAT FIXED               MAKE A FIXNUM\n******** B     RETURN              AND RETURN WITH IT\n         SPACE 1\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n*\n*---------------------------------------------------------------------*\n*         FIXNUM ADD OVERFLOWED - MUST RESULT IN BIGNUM               *\n*---------------------------------------------------------------------*\nOVERFIX  LCR   #3,#2               EXAMINE RESULT, ALSO #3 MAY BE NICE\n         BP    FFBIGP              RESULT IS POSITIVE BIGNUM\n         BM    FFBIGM              RESULT IS NEGATIVE BIGNUM\n         BZ    FFBIGM32            RESULT IS NEG BIGNUM -2**32\n         LA    #15,#TWO31          OVERFLOW, BIGNUM IS 2**31\n         B     RETURN\n*\nFFBIGM32 LA    #15,#MTWO32         POINT TO -2**32\n         B     RETURN\n*\nFFBIGP   LR    #3,#2               SAVE IN #3, #2 USED BY ZILBIG\n         N     #3,=X'7FFFFFFF'     MASK OUT CARRY BIT\nFFBIGM   L     #15,ZLCBIG          ADDRESS OF BIGNUM MAKER\n         LA    #2,12               LENGTH OF BIGNUM NEEDED FOR RESULT\n         #BASR #14,#15             MAKE BIGNUMS, NOT WAR\n         MVC   0(12,#15),#TWO31    USEFUL TEMPLATE, SAVES WORK\n         ST    #3,##VECDAT(,#15)   STORE LS WORD IN RESULT\n         AR    #2,#15              POINT TO END OF RESULT\n         ST    #2,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nNFIX1    CLI   ##TYPE(#6),##BIGNUM\n         BNE   NFXBG1              ARG1 NOT FIXED NOR BIG\n*\n* ARG 1 IS A BIGNUM\n*\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    BIGFIX              ARG1 IS BIGNUM, ARG2 IS FIXNUM\n         CLI   ##TYPE(#7),##BIGNUM\n         BE    BIGBIG              ARG1 IS BIGNUM, ARG2 IS BIGNUM\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    BIGSFLO             ARG1 IS BIGNUM, ARG2 IS SINGLE-FLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    BIGDFLO             ARG1 IS BIGNUM, ARG2 IS DOUBLE-FLOAT\n         B     ERROR2\nBIGSFLO  DS    0H                  Bignum and single-float\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LR    #5,#6               Arg1 is bignum, arg2 is float\n         #BASR #14,#15             Convert bignum to float\n         LER   #F2,#F0             Get float value for arg1\n         B     ADDSFLO1            Go to add arg1 to float arg2\nBIGDFLO  DS    0H                  Bignum and double-float\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LNR   #5,#6               Arg1 is bignum, arg2 is float\n         #BASR #14,#15             Convert bignum to float\n         LDR   #F2,#F0             Get float value for arg1\n         B     ADDDFLO1            Go to add arg1 to float arg2\n*---------------------------------------------------------------------*\n*                      BIGNUM TO BIGNUM ADD                           *\n*---------------------------------------------------------------------*\nBIGBIG   XR    #5,#5               CLEAR FOR LOADING BIGNUM LENGTH ARG1\n         XR    #3,#3               CLEAR FOR LOADING BIGNUM LENGTH ARG2\n         ICM   #5,7,1(#6)          LOAD LENGTH OF ARG1\n         ICM   #3,7,1(#7)          LOAD LENGTH OF ARG2\n         CR    #5,#3               COMPARE LENGTHS\n         BH    BBNEXCH             DON'T EXCHANGE POINTERS\n         BE    BBEQLN              SAME LENGTHS - BETTER CHECK SIGNS\n         ST    #7,0(,#11)          STORE #7 IN PLACE OF OLD #6\n         ST    #6,4(,#11)          STORE #6 IN PLACE OF OLD #7\n         LR    #6,#5               EXCHANGE LENGTHS IN #3 AND #5\n         LR    #5,#3                           \"\n         LR    #3,#6                           \"\nBBNEXCH  L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LA    #2,##VECDAT+4(,#5)  ASSUME ARG1 IS GREATER OR EQ IN LEN.\n         #BASR #14,#15             SET UP A BIGNUM\n         LM    #6,#7,0(#11)        GC MAY HAVE MOVED POINTERS\n         LA    #2,4                INCREMENT AMOUNT FOR BXLE(WORD SIZE)\n         ICM   #0,15,##VECDAT(#6)  GET LS WORD OF ARG1\n         BM    BMB                 BIGNUM1 IS NEGATIVE\n         ICM   #1,15,##VECDAT(#7)  GET LS WORD OF ARG2\n         BM    BPBM                BIGNUM1 POSITIVE, BIGNUM2 NEGATIVE\nBPBP     ALR   #0,#1               ADD LS WORDS OF BIGNUMS\n         SRDL  #0,31               SHIFT CARRY BIT TO #0, 31 BIT RADIX\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\nBMBMCONT ST    #1,##VECDAT(,#15)   STORE LS WORD OF SUM\n         LA    #4,8                SET OFFSET POINTER FOR LOOP\nBPBPL1   AL    #0,0(#4,#6)         ADD NEXT WORD OF ARG1 TO CARRY\n         AL    #0,0(#4,#7)         ADD NEXT WORD OF ARG2 TO THIS SUM\n         SRDL  #0,31               SHIFT RIGHT ALL BUT CARRY BIT\n         SRL   #1,1                RIGHT JUSTIFY 31 BIT NUMBER IN #1\n         ST    #1,0(#4,#15)        STORE INTO RESULT BIGNUM\n         BXLE  #4,#2,BPBPL1        NOT DONE WITH SHORTER BIGNUM\n         CR    #3,#5               COMPARE TWO LENGTHS\n         BE    BPBPSTOP            RAN OUT OF LONGER BIGNUM TOO\n         LR    #3,#5               PUT LENGTH OF LONGER BIGNUM IN LIMIT\nBPBPL2   AL    #0,0(#4,#6)         ADD NEXT WORD OF ARG1 TO CARRY\n         SRDL  #0,31               SHIFT RIGHT ALL BUT CARRY BIT\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         ST    #1,0(#4,#15)        STORE INTO RESULT BIGNUM\n         BXLE  #4,#2,BPBPL2        NOT DONE WITH SHORTER BIGNUM\nBPBPSTOP LTR   #0,#0               CARRY BIT LEFT OVER?\n         BNZ   BPBPXC              YES, THERE IS AN EXTRA CARRY\n         STCM  #3,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         AR    #4,#15              CHANGE WHEN ##VECDAT CHANGES\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBPBPXC   STCM  #4,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         ST    #0,0(#4,#15)        STORE CARRY (WHICH MUST BE 1)\n         LA    #4,##VECDAT(#4,#15) CALCULATE POINTER TO END\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBMBM     ALR   #0,#1               ADD LS WRDS OF BIGNUMS,SIGNS CANCEL\n         SRDL  #0,31               SHIFT CARRY BIT TO #0, 31 BIT RADIX\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         O     #1,=X'80000000'     SET NEGATIVE SIGN ON LS RESULT WORD\n         B     BMBMCONT            CAN SHARE THE REST OF CODE WITH BPBP\n*\nBBEQLN   TM    ##VECDAT(#6),X'80'  CHECK SIGN OF BIGNUM 1\n         BO    EBMB                BIGNUM1 IS NEGATIVE\n         TM    ##VECDAT(#7),X'80'  CHECK SIGN OF BIGNUM 2\n         BNO   BBNEXCH             BIG 1 IS POS, BIG 2 IS POS\nEBPBM    LA    #3,4                4 FOR BXH INDEX\n         LR    #4,#5               POINT OFFSET TO MS WORD\n         LCR   #2,#3               -4 IS BXH INCREMENT AMOUNT\nEBPBML   L     #1,##VECDAT-4(#4,#6) GET WORD OF BIG1 FOR COMPARE\n         C     #1,##VECDAT-4(#4,#7) COMPARE WITH WORD OF BIG2\n         BH    B1B2SUB             OK BIG1 MUST BE BIGGER IN SIZE\n         BL    B2B1SUB             OK BIG2 MUST BE BIGGER IN SIZE\n         BXH   #4,#2,EBPBML        THIS WORD SAME, TRY NEXT\n         L     #2,##VECDAT(,#6)    MADE IT HERE - MUST BE FIXNUM\n         S     #2,##VECDAT(,#7)    DO SUBTRACTION OF LS PARTS\n         X     #2,=X'80000000'     toggle out the sign bit from big2\n         #MKAT FIXED               MAKE FIXNUM\n         B     RETURN\n*\nEBMB     TM    ##VECDAT(#7),X'80'  CHECK SIGN OF BIGNUM 2\n         BO    BBNEXCH             BOTH BIGNUMS ARE NEGATIVE\n         ST    #7,0(,#11)          STORE #7 IN PLACE OF OLD #6\n         LR    #14,#6              EXCHANGE REGS 6 AND 7\n         LR    #6,#7               EXCHANGE REGS 6 AND 7\n         LR    #7,#14              EXCHANGE REGS 6 AND 7\n         STM   #6,#7,0(#11)        SAVE POINTERS FOR GC\n         B     EBPBM               BIGNUMS SWITCHED, PROCEED\n*\nB1B2SUB  LR    #5,#4               SAVE MAX LENGTH OF RESULT\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LA    #2,##VECDAT(,#5)    CALC MAXIMUM LENGTH FOR RESULT VECT\n         #BASR #14,#15             SET UP A BIGNUM\n         LM    #6,#7,0(#11)        GC MAY HAVE MOVED POINTERS\n         LR    #4,#3               4 INTO REG 4 (ASSUMED FROM ABOVE)\n         AR    #3,#3               8 INTO REG 3 (STARTING OFFSET)\n         L     #0,##VECDAT(,#6)\n         S     #0,##VECDAT(,#7)\n         X     #0,=X'80000000'     TOGGLE UPPER BIT (CAUSED BY NEG)\n         SRDA  #0,31               SHIFT RIGHT ALL BUT BORROW BIT\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         ST    #1,##VECDAT(,#15)   STORE INTO RESULT BIGNUM\nB1B2SUBL A     #0,##VECDAT-4(#3,#6) ADD TO BORROW FROM PREVIOUS SUBTRCT\n         S     #0,##VECDAT-4(#3,#7)\n         SRDA  #0,31               LEAVE BORROW IN REG 0\n         SRL   #1,1                PUT REMAINING 31 BITS IN REG 1\n         ST    #1,##VECDAT-4(#3,#15) STORE WORD INTO RESULT VECTOR\n         BXLE  #3,#4,B1B2SUBL\n         LTR   #1,#1               TEST FOR MS RESULT WORD BEING ZERO\n         BZ    B1B2SUBX            OOPS, NEED TO WIPE OUT LEADING ZEROS\n         AR    #3,#15              CALCULATE NEXT AVAILABLE VSS LOC.\n         STCM  #5,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         CLC   0(12,#15),MTWO31X   COMPARE NUMERIC PART AGAINST -2**31\n         BE    MTWO31\n         ST    #3,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER\n         B     RETURN\n*\nB1B2SUBX LR    #3,#5               WIPING OUT LEADING ZEROS, DATA LEN.\n         LR    #5,#4               GENERATE 4 FOR BXH LIMIT\n         LCR   #4,#4               GENERATE -4 FOR BXH DECREMENT\n         AR    #3,#4               DECREMENT POINTER\n         CR    #3,#5               COMPARE AGAINST LS WORD OFFSET\n         BE    B1B2SUBF            MUST BE FIXNUM RESULT\nB1B2SUBM L     #0,##VECDAT-4(#3,#15) ONLY SOME LEADING ZEROS\n         LTR   #0,#0               IS IT ZERO?\n         BNZ   B1B2SUBZ            FOUND NONZERO WORD, STOP LOOP\n         BXH   #3,#4,B1B2SUBM      GO AND TEST NEXT LESS SIGNIF WORD\nB1B2SUBF L     #2,##VECDAT(,#15)   LS WORD OF BIGNUM NEEDS TO BE FIXNUM\n         LA    #0,20(,#11)         RESTORE TOP-OF-STACK POINTER\n         #MKAT FIXED               FORGET BIGNUM, IT'S FIXED\n         B     RETURN\n*\nB1B2SUBZ LA    #1,##VECDAT(#3,#15) CALCULATE NEXT AVAILABLE VSS LOC.\n         STCM  #3,7,1(#15)         STORE BIGNUM LENGTH IN HEADER\n         CLC   0(12,#15),MTWO31X   COMPARE NUMERIC PART AGAINST -2**31\n         BE    MTWO31\n         ST    #1,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nB2B1SUB  ST    #7,0(,#11)          STORE #7 IN PLACE OF OLD #6\n         ST    #6,4(,#11)          STORE #6 IN PLACE OF OLD #7\n         LR    #5,#4               SAVE MAX LENGTH OF RESULT\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LA    #2,##VECDAT(,#5)    CALC MAXIMUM LENGTH FOR RESULT VECT\n         #BASR #14,#15             SET UP A BIGNUM\n         LM    #6,#7,0(#11)        GC MAY HAVE MOVED POINTERS\n         LR    #4,#3               4 INTO REG 4 (ASSUMED FROM ABOVE)\n         AR    #3,#3               8 INTO REG 3 (STARTING OFFSET)\n         L     #0,##VECDAT(,#6)    LOAD LS WORD FOR FIRST SUBTRACT\n         S     #0,##VECDAT(,#7)    SUBTRACT LS WORD OF OTHER BIGNUM\n         X     #0,=X'80000000'     TOGGLE UPPER BIT (CAUSED BY NEG)\n         SRDA  #0,31               SHIFT RIGHT ALL BUT BORROW BIT\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         LR    #14,#1              SAVE LS WORD OF BIGNUM\nB2B1SUBL A     #0,##VECDAT-4(#3,#6) ADD TO BORROW FROM PREVIOUS SUBTRCT\n         S     #0,##VECDAT-4(#3,#7) SUBTRACT SMALLER BIGNUM\n         SRDA  #0,31               LEAVE BORROW IN REG 0\n         SRL   #1,1                PUT REMAINING 31 BITS IN REG 1\n         ST    #1,##VECDAT-4(#3,#15) STORE WORD INTO RESULT VECTOR\n         BXLE  #3,#4,B2B1SUBL      NOT AT HIGHEST DIFFERENT WORD YET\n         LTR   #1,#1               TEST FOR MS RESULT WORD BEING ZERO\n         BZ    B2B1SUBX            OOPS, NEED TO WIPE OUT LEADING ZEROS\n         O     #14,=X'80000000'    PUT NEGATIVE SIGN ON RESULT LS WORD\n         ST    #14,##VECDAT(,#15)  STORE LS WORD OF RESULT BIGNUM\n         AR    #3,#15              CALCULATE NEXT AVAILABLE VSS LOC.\n         STCM  #5,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         CLC   0(12,#15),MTWO31X   COMPARE NUMERIC PART AGAINST -2**31\n         BE    MTWO31\n         ST    #3,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER\n         B     RETURN\n*\nB2B1SUBX LR    #3,#5               WIPING OUT LEADING ZEROS, DATA LEN.\n         LR    #5,#4               GENERATE 4 FOR BXH LIMIT\n         LCR   #4,#4               GENERATE -4 FOR BXH DECREMENT\n         AR    #3,#4               DECREMENT POINTER\n         CR    #3,#5               COMPARE AGAINST LS WORD OFFSET\n         BE    B2B1SUBF            MUST BE FIXNUM RESULT\nB2B1SUBM L     #0,##VECDAT-4(#3,#15) ONLY SOME LEADING ZEROS\n         LTR   #0,#0               IS IT ZERO?\n         BNZ   B2B1SUBZ            FOUND NONZERO WORD, STOP LOOP\n         BXH   #3,#4,B2B1SUBM      GO AND TEST NEXT LESS SIGNIF WORD\nB2B1SUBF LCR   #2,#14              GET LS WORD OF RESULT AND COMPLEMENT\n         LA    #0,20(,#11)         RESTORE TOP-OF-STACK POINTER\n         #MKAT FIXED               FORGET BIGNUM, IT'S FIXED\n         B     RETURN\n*\nB2B1SUBZ LA    #1,##VECDAT(#3,#15) CALCULATE NEXT AVAILABLE VSS LOC.\n         O     #14,=X'80000000'    PUT NEGATIVE SIGN ON RESULT LS WORD\n         ST    #14,##VECDAT(,#15)  STORE LS WORD OF RESULT BIGNUM\n         STCM  #3,7,1(#15)         STORE BIGNUM LENGTH IN HEADER\n         CLC   0(12,#15),MTWO31X   COMPARE NUMERIC PART AGAINST -2**31\n         BE    MTWO31\n         ST    #1,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBPBM     N     #1,=X'7FFFFFFF'     mask out the sign\n         SR    #0,#1               subtract lowest words\n         SRDA  #0,31               leave only subtract carry in #0\n         SRL   #1,1                right justify the ls result word\n         LA    #4,##VECDAT+4       set index for first iteration\n         LR    #14,#1              save for fixnum or end of bignum\nBPBML1   A     #0,##VECDAT-4(#4,#6) add carry to next word in big1\n         S     #0,##VECDAT-4(#4,#7) subtract the word in big2\n         SRDA  #0,31               leave only subtract carry in #0\n         SRL   #1,1                right justify the ls result word\n         ST    #1,##VECDAT-4(#4,#15) store the result word\n         BXLE  #4,#2,BPBML1        any more words in big2?\n         LR    #3,#5               LENGTH1 INTO LIMIT REGISTER\nBPBML2   A     #0,##VECDAT-4(#4,#6) add carry to next word in big1\n         SRDA  #0,31               no big2 left, keep carry in #0\n         SRL   #1,1                right justify difference in #1\n         ST    #1,##VECDAT-4(#4,#15) store the result word\n         BXLE  #4,#2,BPBML2        any more words in big1?\n         LR    #5,#2               GENERATE 4 FOR BXH LIMIT\n         LCR   #4,#2               GENERATE -4 FOR BXH DECREMENT\nBPBMSUBM L     #0,##VECDAT-4(#3,#15) ONLY SOME LEADING ZEROS\n         LTR   #0,#0               IS IT ZERO?\n         BNZ   BPBMSUBZ            FOUND NONZERO WORD, STOP LOOP\n         BXH   #3,#4,BPBMSUBM      GO AND TEST NEXT LESS SIGNIF WORD\n         LR    #2,#14              LS WORD OF BIGNUM NEEDS TO BE FIXNUM\n         LA    #0,20(,#11)         RESTORE TOP-OF-STACK POINTER\n         #MKAT FIXED               FORGET BIGNUM, IT'S FIXED\n         B     RETURN\n*\nBPBMSUBZ LA    #1,##VECDAT(#3,#15) CALCULATE NEXT AVAILABLE VSS LOC.\n         STCM  #3,7,1(#15)         STORE BIGNUM LENGTH IN HEADER\n         ST    #14,##VECDAT(,#15)  STORE LS WORD with no (pos) sign\n         ST    #1,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBMB      ICM   #1,15,##VECDAT(#7)  GET LS WORD OF ARG2\n         BM    BMBM                BOTH BIGNUMS NEGATIVE, DIFF LENGTHS\nBMBP     N     #0,=X'7FFFFFFF'     mask out the sign\n         SR    #0,#1               subtract lowest words\n         SRDA  #0,31               leave only subtract carry in #0\n         SRL   #1,1                right justify the ls result word\n         LA    #4,##VECDAT+4       set index for first iteration\n         LR    #14,#1              save for fixnum or end of bignum\nBMBPL1   A     #0,##VECDAT-4(#4,#6) add carry to next word in big1\n         S     #0,##VECDAT-4(#4,#7) subtract the word in big2\n         SRDA  #0,31               leave only subtract carry in #0\n         SRL   #1,1                right justify the ls result word\n         ST    #1,##VECDAT-4(#4,#15) store the result word\n         BXLE  #4,#2,BMBPL1        any more words in big2?\n         LR    #3,#5               LENGTH1 INTO LIMIT REGISTER\nBMBPL2   A     #0,##VECDAT-4(#4,#6) add carry to next word in big1\n         SRDA  #0,31               no big2 left, keep carry in #0\n         SRL   #1,1                right justify difference in #1\n         ST    #1,##VECDAT-4(#4,#15) store the result word\n         BXLE  #4,#2,BMBPL2        any more words in big1?\n         LR    #5,#2               GENERATE 4 FOR BXH LIMIT\n         LCR   #4,#2               GENERATE -4 FOR BXH DECREMENT\nBMBPSUBM L     #0,##VECDAT-4(#3,#15) ONLY SOME LEADING ZEROS\n         LTR   #0,#0               IS IT ZERO?\n         BNZ   BMBPSUBZ            FOUND NONZERO WORD, STOP LOOP\n         BXH   #3,#4,BMBPSUBM      GO AND TEST NEXT LESS SIGNIF WORD\n         LCR   #2,#14              LS WORD OF BIGNUM NEEDS TO BE FIXNUM\n         LA    #0,20(,#11)         RESTORE TOP-OF-STACK POINTER\n         #MKAT FIXED               FORGET BIGNUM, IT'S FIXED\n         B     RETURN\n*\nBMBPSUBZ LA    #1,##VECDAT(#3,#15) CALCULATE NEXT AVAILABLE VSS LOC.\n         O     #14,=X'80000000'    INSERT NEGATIVE SIGN\n         STCM  #3,7,1(#15)         STORE BIGNUM LENGTH IN HEADER\n         ST    #14,##VECDAT(,#15)  STORE LS WORD WITH NEGATIVE SIGN\n         CLC   0(12,#15),MTWO31X   COMPARE NUMERIC PART AGAINST -2**31\n         BE    MTWO31\n         ST    #1,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nMTWO31   LA    #15,#MTWO31         RETURN MOST NEG FIXNUM AS ANSWER\n         B     RETURN\n*\nFX1NFX2  CLI   ##TYPE(#7),##BIGNUM\n         BNE   FX1NBF2             ARG1 IS FIXED, ARG2 NOT BIG NOR FIX\n*---------------------------------------------------------------------*\n*                      FIXNUM TO BIGNUM ADD                           *\n*---------------------------------------------------------------------*\nFIXBIG   ST    #7,0(,#11)          EXCHANGE POINTERS IN #6 AND #7\n         ST    #6,4(,#11)          -AND ALSO IN THE STACK\nBIGFIX   L     #6,0(,#11)          GET POINTER TO ARG1, MAY BE SWITCHED\n         XR    #3,#3               CLEAR FOR ICM OF LENGTH\n         ICM   #3,7,1(#6)          GET BIGNUM LENGTH\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LA    #2,##VECDAT+4(,#3)  GET SIZE TO PASS TO ZILBIG\n         #BASR #14,#15             CALL ZILBIG\n         LM    #6,#7,0(#11)        GC MAY HAVE MOVED POINTERS\n         ICM   #0,15,##VECDAT(#6)  GET LS WORD OF BIGNUM\n         BM    BIGMFIX             NEGATIVE BIGNUM + FIXNUM\n         A     #0,##CDR(,#7)       ONLY POSITIVE OVERFLOW IS POSSIBLE\n         BM    BPFMINUS            LS RESULT IS NEG - FIX UP\n         SRDL  #0,31               SHIFT TO #1 ALL BUT CARRY BIT\n         SRL   #1,1                NORMALIZE SUM IN #1\n         ST    #1,##VECDAT(,#15)   STORE FIRST SUM RESULT\n         LA    #2,4                INIT. WORD SIZE FOR BXLE\n         LA    #4,8                INITIALIZE OFFSET FOR BXLE\nBFLOOP   AL    #0,0(#4,#6)         ADD NEXT WORD TO PREVIOUS CARRY\n         SRDL  #0,31               SHIFT RIGHT ALL BUT CARRY BIT\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         ST    #1,0(#4,#15)        STORE INTO RESULT BIGNUM\n         BXLE  #4,#2,BFLOOP        NOT DONE WITH SHORTER BIGNUM\n         LTR   #0,#0               CARRY BIT LEFT OVER?\n         BNZ   BPFXC               YES, THERE IS AN EXTRA CARRY\n         STCM  #3,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         AR    #4,#15              CHANGE WHEN ##VECDAT CHANGES\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBPFXC    STCM  #4,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         ST    #0,0(#4,#15)        STORE CARRY (WHICH MUST BE 1)\n         LA    #4,##VECDAT(#4,#15) CALCULATE POINTER TO END\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBPFMINUS SRDA  #0,31               SHIFT TO #1 ALL BUT BORROW BIT\n         SRL   #1,1                NORMALIZE SUM IN #1\n         ST    #1,##VECDAT(,#15)   STORE FIRST SUM RESULT\n         LA    #2,4                INIT. WORD SIZE FOR BXLE\n         LA    #4,8                INITIALIZE OFFSET FOR BXLE\nBPFMLOOP AL    #0,0(#4,#6)         ADD NEXT WORD TO PREVIOUS BORROW\n         SRDA  #0,31               SHIFT RIGHT ALL BUT BORROW BIT\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         ST    #1,0(#4,#15)        STORE INTO RESULT BIGNUM\n         BXLE  #4,#2,BPFMLOOP      NOT DONE WITH BIGNUM\n         LTR   #0,#0               BORROW BIT LEFT OVER?\n         BZ    BPFMIN0             HIGH WORD ZERO - MUST BACKTRACK\n         BM    BUG1                HIGH WORD SHOULD NEVER BE NEGATIVE\n         STCM  #3,7,1(#15)         STORE LENGTH AND RESULT INTO HEADER\n         AR    #4,#15              POINT TO END OF RESULT\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBPFMIN0  LCR   #0,#2               -4 INCREMENT FOR BXH\n         LR    #1,#2               4 LIMIT FOR BXH\nBPFMIN0L L     #2,##VECDAT-4(#3,#15) EXAMINE FOR ZERO\n         LTR   #2,#2               TEST WORD\n         BNZ   BPFMIN1             STOP - FOUND NONZERO WORD\n         BXH   #3,#0,BPFMIN0L      LOOP TO NEXT LOWER WORD\n         L     #2,##VECDAT(,#15)   LOAD LS WORD - THIS IS THE FIXNUM\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN\n*\nBPFMIN1  STCM  #3,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         AR    #4,#15              POINT TO END, (CHANGE WITH ##VECDAT)\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBIGMFIX  N     #0,=X'7FFFFFFF'     MASK OUT MINUS BIT OF BIGNUM LSWRD\n         S     #0,##CDR(,#7)       ONLY POSITIVE OVERFLOW IS POSSIBLE\n         BM    BMFMINUS            LS RESULT IS NEG - FIX UP\n         SRDL  #0,31               SHIFT TO #1 ALL BUT CARRY BIT\n         SRL   #1,1                NORMALIZE SUM IN #1\n         O     #1,=X'80000000'     SET MINUS BIT FOR BIGNUM\n         ST    #1,##VECDAT(,#15)   STORE FIRST SUM RESULT\n         LA    #2,4                INIT. WORD SIZE FOR BXLE\n         LA    #4,8                INITIALIZE OFFSET FOR BXLE\nBMFLOOP  AL    #0,0(#4,#6)         ADD NEXT WORD TO PREVIOUS CARRY\n         SRDL  #0,31               SHIFT RIGHT ALL BUT CARRY BIT\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         ST    #1,0(#4,#15)        STORE INTO RESULT BIGNUM\n         BXLE  #4,#2,BMFLOOP       NOT DONE WITH SHORTER BIGNUM\n         LTR   #0,#0               CARRY BIT LEFT OVER?\n         BNZ   BMPFXC              YES, THERE IS AN EXTRA CARRY\n         STCM  #3,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         CLC   0(12,#15),MTWO31X   COMPARE NUMERIC PART AGAINST -2**31\n         BNE   BMFNOT31            NO, IT CAN'T BE -2**31\n         LA    #15,#MTWO31         RETURN MOST NEG FIXNUM AS ANSWER\n         B     RETURN\n*\nBMFNOT31 AR    #4,#15              CHANGE WHEN ##VECDAT CHANGES\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBMPFXC   STCM  #4,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         ST    #0,0(#4,#15)        STORE CARRY (WHICH MUST BE 1)\n         LA    #4,##VECDAT(#4,#15) CALCULATE POINTER TO END\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBMFMINUS SRDA  #0,31               SHIFT TO #1 ALL BUT BORROW BIT\n         SRL   #1,1                NORMALIZE SUM IN #1\n         O     #1,=X'80000000'     SET BIGNUM MINUS BIT\n         ST    #1,##VECDAT(,#15)   STORE FIRST SUM RESULT\n         LA    #2,4                INIT. WORD SIZE FOR BXLE\n         LA    #4,8                INITIALIZE OFFSET FOR BXLE\nBMFMLOOP AL    #0,0(#4,#6)         ADD NEXT WORD TO PREVIOUS BORROW\n         SRDA  #0,31               SHIFT RIGHT ALL BUT BORROW BIT\n         SRL   #1,1                RESTORE SHIFTED WORD, HIGH BIT NOW 0\n         ST    #1,0(#4,#15)        STORE INTO RESULT BIGNUM\n         BXLE  #4,#2,BMFMLOOP      NOT DONE WITH BIGNUM\n         LTR   #0,#0               BORROW BIT LEFT OVER?\n         BZ    BMFMIN0             HIGH WORD ZERO - MUST BACKTRACK\n         BM    BUG1                HIGH WORD SHOULD NEVER BE NEGATIVE\n         STCM  #3,7,1(#15)         STORE LENGTH AND RESULT INTO HEADER\n         AR    #4,#15              POINT TO END OF RESULT\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nBMFMIN0  LCR   #0,#2               -4 INCREMENT FOR BXH\n         LR    #1,#2               4 LIMIT FOR BXH\nBMFMIN0L L     #2,##VECDAT-4(#3,#15) EXAMINE FOR ZERO\n         LTR   #2,#2               TEST WORD\n         BNZ   BMFMIN1             STOP - FOUND NONZERO WORD\n         BXH   #3,#0,BMFMIN0L      LOOP TO NEXT LOWER WORD\n         L     #2,##VECDAT(,#15)   LOAD LS WORD - THIS IS THE FIXNUM\n         N     #2,=X'7FFFFFFF'     MASK OUT SIGN BIT\n         LCR   #2,#2               SINCE IT'S SUPPOSED TO BE NEG.\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN\n*\n*\nBMFMIN1  STCM  #3,7,1(#15)         STORE LENGTH INTO RESULT HEADER\n         AR    #4,#15              POINT TO END, (CHANGE WITH ##VECDAT)\n         ST    #4,ZLCVSNXT         UPDATE AVAILABILITY POINTER\n         B     RETURN\n*\nNFXBG1   DS    0H                  ARG 1 IS NOT INTEGER\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    ARG1SFLO            ARG 1 IS SINGLE FLOAT\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    ARG1DFLO            ARG 1 IS DOUBLE FLOAT\n         B     ERROR1\n         SPACE\nFX1NBF2  DS    0H                  ARG 1 IS FIXED BUT ARG2 IS NOT\n         SPACE\n*                                                                     *\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    FIXSFLO             FIXED + SFLOAT = SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    FIXDFLO             FIXED + DFLOAT = DFLOAT\n         B     ERROR2              FIXED + NONUM = ERROR\nFIXSFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F2,#F0             GET SINGLE FLOAT VALUE 1\n         B     ADDSFLO1\nFIXDFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F2,#F0             GET DOUBLE FLOAT VALUE 1\n         B     ADDDFLO1\n         SPACE\nARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    SADDSFLO            SFLOAT + SFLOAT = SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    SADDDFLO            SFLOAT + DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    SFLOPFIX            SFLOAT + FIXED = SFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BNE   ERROR2              SFLOAT + NONUM = ERROR\n         LE    #F2,##CDR(,#6)      Get single float value 1\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LR    #5,#7               Arg1 is float, arg2 is bignum\n         #BASR #14,#15             Convert bignum to float\n         LER   #F4,#F0             Get float value for arg2\n         B     ADDSFLO2            Go to add float arg1 to arg2\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO SINGLE FLOAT                         *\n*---------------------------------------------------------------------*\nSFLOPFIX LE    #F2,##CDR(,#6)      Get single float value 1\n         L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F4,#F0             GET FLOAT VALUE 2\n         B     ADDSFLO2            FLOAT + FIXED = FLOAT\n         SPACE\nARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F2,8(,#6)          GET FLOAT VALUE 1\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    ADDDFLO1            DFLOAT + DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    DADDSFLO            DFLOAT + SFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    DFLOPFIX            DFLOAT + FIXED = DFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BNE   ERROR2              DFLOAT + NONUM = ERROR\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LNR   #5,#7               Arg1 is float, arg2 is bignum\n         #BASR #14,#15             Convert bignum to float\n         LDR   #F4,#F0             Get float value for arg2\n         B     ADDDFLO2            Go to add float arg1 to arg2\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO DOUBLE FLOAT                         *\n*---------------------------------------------------------------------*\nDFLOPFIX L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F4,#F0             GET FLOAT VALUE 2\n         B     ADDDFLO2            FLOAT + FIXED = FLOAT\n         SPACE\n*---------------------------------------------------------------------*\n*                       SINGLE FLOAT ADD                              *\n*---------------------------------------------------------------------*\nSADDSFLO DS    0H\n         LE    #F2,##CDR(,#6)      Get single float value 1\nADDSFLO1 DS    0H\n         LE    #F4,##CDR(,#7)      Get single float value 2\nADDSFLO2 DS    0H\n         AER   #F2,#F4             ADD THEM\n         STE   #F2,ZLCWORK         PUT RESULT IN REG FOR ATOM-MAKING\n         L     #2,ZLCWORK\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\n*---------------------------------------------------------------------*\n*                       DOUBLE FLOAT ADD                              *\n*---------------------------------------------------------------------*\nDADDSFLO DS    0H\n         SDR   #F4,#F4\n         LE    #F4,##CDR(,#7)      Get double float value 2\n         B     ADDDFLO2\nSADDDFLO DS    0H\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#6)      Get double float value 1\nADDDFLO1 DS    0H\n         LD    #F4,8(,#7)          Get double float value 2\nADDDFLO2 DS    0H\n         ADR   #F2,#F4             ADD THEM\n         LDR   #F0,#F2\n         L     #15,ZLCMDF          Get address of ZILMDF\n         #BASR #14,#15             Call ZILMDF to make a double-float\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION ROUTINE\n         SPACE 1\n         DS    0A                  ALIGN BIGNUM TO FULLWORD\n#TWO31   DC    YL1(##BIGNUM),AL3(8),F'0,1'    2**31 SMALLEST BIGNUM\n#MTWO31  DC    YL1(##FIXNUM),AL3(0),F'-2147483648'  MOST NEG FIXNUM\n#MTWO32  DC    YL1(##BIGNUM),AL3(8),X'80000000',F'2'   -2**32\nMTWO31X  DC    YL1(##BIGNUM),AL3(8),X'80000000',F'1' -2**31=BAD BIGNUM\n         SPACE 1\nERROR1   #ERR  'Argument 1 to add not a number - ',0(#11)\nERROR2   #ERR  'Argument 2 to add not a number - ',4(#11)\nBUG1     #ERR  'Internal bug in ZILADD - MS word of bignum negative addX\n               ing ',0(#11),' to ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILADMP": {"ttr": 9732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x88\\x01_\\x01\\x00&_\\x16E\\x05'\\x05\\x1c\\x05'\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:45:00", "lines": 1319, "newlines": 1308, "modlines": 1319, "user": "SEB1525"}, "text": "***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         TITLE 'ZILADMP - LOCAL MACRO DEFINITION'\n         MACRO\n&SYM     DMPER &MSG\n&SYM     L     #1,=A(&MSG)\n         LA    #0,L'&MSG\n         B     SIGNALER\n         MEND\n         TITLE 'ZILADMP - ZIL 1.3 ATOM DECONSTRUCTOR MODULE'\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS INVOKED VIA BALR FROM ASSEMBLER LANGUAGE FUNCTIONS   *\n* WHICH DESIRE TO DUMP ATOMS INTO IN-STORAGE CHARACTER AREAS, OR      *\n* JUST RETURN THE ALPHA TEXT PORTION OF THE ATOM WHERE RELEVANT.      *\n*                                                                     *\n* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *\n*                                                                     *\n* INPUTS ARE AS FOLLOWS:                                              *\n*                                                                     *\n* REGISTER 1 CONTAINS THE SLASHIFICATION INDICATOR:                   *\n*   NIL - DON'T SLASHIFY.                                             *\n*   OTHER - SLASHIFY.                                                 *\n* REGISTER 2 POINTS TO THE ATOM TO BE DUMPED.                         *\n*                                                                     *\n* ALSO, THE CALLER MAY SET THE \"ALWAYS-COPY\" BIT ON IF DESIRED...     *\n*       OI ZLCDFLGS,ZLCDCOPY                                          *\n* IF IT IS REQUIRED THAT THE RETURNED TEXT NOT BE IN V/S SPACE.       *\n* THIS IS USED BY EXPLODE.                                            *\n*                                                                     *\n* OUTPUTS ARE AS FOLLOWS:                                             *\n*                                                                     *\n* REGISTER 0 CONTAINS THE LENGTH OF THE DUMPED ATOM.                  *\n* REGISTER 1 CONTAINS THE ADDRESS OF THE (DUMPED ATOM) TEXT.          *\n* REGISTER 2 IS UNCHANGED.                                            *\n*                                                                     *\n* NON-ALPHA TYPE ATOMS WILL BE CONVERTED APPROPRIATELY.               *\n* HOWEVER, LISTS ARE INVALID AS INPUT.                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THE INTERFACE HAS CHANGED SLIGHTLY, IN THAT ZILADMP NOW RETURNS     *\n* THE ADDRESS OF THE WORKAREA IN REGISTER 1.  THIS IS NECESSARY FOR   *\n* STRINGS, WHICH HAVE THEIR ACTUAL DATA AREA RETURNED, NOT COPIED.    *\n* THUS ALL CALLERS OF THIS MODULE MUST BE ALTERED TO USE THIS VALUE.  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*                    BIGNUM DUMPING CODE BY KJELD HVATUM.             *\n*                                                                     *\n*  Binary to decimal conversion can be done by using the obvious      *\n*  (from Knuth (vol 2, 2nd ed., page 302)                             *\n*                                                                     *\n*  ( {} is the integer function)                                      *\n*                                                                     *\n*                                                                     *\n*       U  = u mod B                                                  *\n*        0                                                            *\n*                                                                     *\n*       U  = {u/B} mod B                                              *\n*        1                                                            *\n*                                                                     *\n*       U  = {{u/B}/B} mod B                                          *\n*        2                                                            *\n*                                                                     *\n*       ...                                                           *\n*                                                                     *\n*                                                                     *\n*  etc. stopping when {...{{u/B}B}.../B} = 0.                         *\n*  This would be done in radix-b arithmetic.  The result in radix B   *\n*                                                                     *\n*  is (U ...U U ).                                                    *\n*       M    0 1                                                      *\n*                                          31           9             *\n*  In our application the radices are b = 2   and B = 10 .            *\n*  This will allow efficient use of machine instructions.  It implies *\n*  that the binary to decimal conversion will use the bignum/fixnum   *\n*  (bignum divided by fixnum) routine which is included inline        *\n*  here.                                                              *\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 04/27/88 - Fixed bug with slashification not reset after error.     *\n*                                                                     *\n***********************************************************************\n         EJECT 1\nZILADMP  #ZBEG NAME='ZILADMP'\n         SPACE 1\n         NI    ZLCDFLGS,255-ZLCDSLSH INITIALIZE SLASHIFICATION FLAG\n         CR    #1,#10              IF SLASHIFICATION REQUESTED\n         BE    DONTSLSH            OR\n         CR    #1,#13              IF SLASHIFICATION REQUESTED\n         BE    DONTSLSH            THEN...\n         OI    ZLCDFLGS,ZLCDSLSH    INDICATE SLASHIFICATION REQUEST\nDONTSLSH DS    0H\n         SPACE 1\n         TM    ZLCDFLGS,ZLCDCOPY+ZLCDSLSH IF SLASHIFY OR COPY REQUESTED\n         BNZ   NOPRECHK            THEN NO PRE-CHECK IS POSSIBLE\n*\n* QUICK PRE-CHECK FOR STRING/SYMBOL IS POSSIBLE ONLY IF WE ARE NOT\n* SLASHIFYING AND NOT ALWAYS-COPYING THE TEXT.\n*\n* QUICK PRE-CHECK FOR STRINGS.  WE WANT TO RETURN INFO FOR STRINGS\n* WITH MAXIMUM SPEED AND EFFICIENCY AND LOWEST OVERHEAD.\n*\n         XR    #0,#0                  CLEAR INSERT REGISTER\n         CLI   ##TYPE(#2),##STRING IF ARG IS A STRING\n         BNE   NOTASTR               THEN...\n         ICM   #0,7,1(#2)             SET STRING LENGTH\n         LA    #1,##VECDAT(,#2)       SET STRING TEXT POINTER\n         BR    #14                    RETURN\nNOTASTR  DS    0H\n*\n* QUICK PRE-CHECK FOR SYMBOLS.\n*\n         CLI   ##TYPE(#2),##SYMBOL IF ARG IS A SYMBOL\n         BNE   NOTASYM               THEN...\n         L     #1,##PNAME(,#2)        GET POINTER TO PRINT NAME\n         ICM   #0,7,1(#1)             SET STRING LENGTH\n         LA    #1,##VECDAT(,#1)       SET STRING TEXT POINTER\n         BR    #14                    RETURN\n         SPACE 1\nNOPRECHK DS    0H                  SLASHIFICATION OR COPY REQUESTED\n         SPACE 1\n         STM   #12,#7,ADMPSAVE     SAVE REGISTERS\n         LR    #12,#15             SET UP BASE REGISTER\n         SPACE 1\n         DROP  #15\n         USING ZILADMP,#12         ESTABLISH ADDRESSABILITY\n         SPACE 1\n         CLI   ##TYPE(#2),##STRING IF IT IS A STRING\n         BE    SLSTRING            THEN GO TO SLASHIFY THE STRING\n         CLI   ##TYPE(#2),##SYMBOL IF IT IS A SYMBOL\n         BE    SLSYMBOL            THEN GO TO SLASHIFY THE SYMBOL\n         B     CHKATOM             ELSE NOT STRING OR SYMBOL\n         SPACE 1\nDOCOPY   DS    0H\n         SPACE 1\nNOTASYM  DS    0H                  NOT STRING OR SYMBOL...\n         SPACE 1\n         DROP  #12\n         USING ZILADMP,#15         ESTABLISH ADDRESSABILITY\n         SPACE 1\n         STM   #12,#7,ADMPSAVE     SAVE REGISTERS\n         LR    #12,#15             SET UP BASE REGISTER\n         SPACE 1\n         DROP  #15\n         USING ZILADMP,#12         ESTABLISH ADDRESSABILITY\n         SPACE 1\nCHKATOM  DS    0H\n         EJECT\n*\n* CHECK INPUT PARAMETERS\n*\n         TM    ##TYPE(#2),##ATOM   IF INPUT IS NOT AN ATOM\n         BZ    ERROR0              THEN ERROR\n*\n* BEGIN PROCESSING\n*\n         LA    #3,ATOMAREA         REG 3 --> CHARACTER BUFFER AREA\n         LR    #4,#2               REG 4 --> ATOM TO BE DUMPED\n         XR    #5,#5               CLEAR LENGTH REGISTER\n         SPACE 1\n         TM    ##TYPE(#4),##CCO    IF THIS IS A COMPILED CODE OBJECT\n         BZ    NOTSUBR             THEN...\n         XR    #1,#1\n         ICM   #1,7,##CAR+1(#4)    GET POINTER TO COMPILED CODE\n         LA    #2,0(,#3)           POINT TO OUTPUT AREA\n         MVI   0(#2),C'#'\n         MVI   1(#2),C'<'\n         TM    ##TYPE(#4),##CLOS   IF THIS IS A CLOSURE\n         BZ    NOTACLOS            THEN\n         MVC   2(8,#2),=C'CLOSURE ' IDENTIFY AS CLOSURE\n         LA    #2,2+8(,#2)          BUMP OUTPUT POINTER\n         B     AFTACLOS\nNOTACLOS DS    0H                  ELSE...\n* IN FUTURE THIS COULD ALSO BE FSUBR, MSUBR, OR LSUBR...\n         MVC   2(5,#2),=C'SUBR '    IDENTIFY AS SUBR\n         LA    #2,2+5(,#2)          BUMP OUTPUT POINTER\nAFTACLOS DS    0H\n         XR    #6,#6               CLEAR INSERT REGISTER\n         IC    #6,4(,#1)           GET LENGTH OF MODULE IDENTIFIER\n         LA    #0,L'ATOMAREA(,#3)  POINT TO END OF OUTPUT WORKAREA\n         SR    #0,#2               GET LENGTH OF REMAINING AREA\n         CR    #6,#0               IF MODULE ID LENGTH EXCEEDS IT\n         BNH   *+6                 THEN\n         LR    #6,#0               USE SHORTER LENGTH\n         BCTR  #6,0                REDUCE LENGTH FOR EXECUTE\n         LTR   #6,#6               IF LENGTH WAS ZERO,\n         BM    AFTAMOV             THEN SKIP MVC\n         EX    #6,MOVID            ELSE MOVE MODULE ID TO OUTPUT AREA\nAFTAMOV  LA    #2,1(#6,#2)         BUMP TO END OF MODULE ID OUTPUT\n         MVI   0(#2),C'>'          FINISH UP\n         LA    #0,1(,#2)           POINT TO END OF OUTPUT STUFF\n         SR    #0,#3               GET THE LENGTH OF THE STUFF\n         LR    #1,#3               GET THE ADDRESS OF THE STUFF\n         B     RETURN              RETURN (IT'S DONE)\n         SPACE 1\nMOVID    MVC   0(*-*,#2),5(#1)     EXECUTED: MOVE MODULE ID TO OUTPUT\n         EJECT\nNOTSUBR  DS    0H                  ELSE (NOT CODE OBJECT)...\n         SPACE 1\n         TM    ##TYPE(#4),##FLOAT  IF A FLOATING POINT ATOM\n         BZ    NOTFLOAT            THEN\n         SPACE 1\n         TM    ##TYPE(#4),##VSS    If double float\n         BO    DFDUMP              then go to dump double float\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Single-precision floating point dump.                               *\n*                                                                     *\n* Two floating-point formats are possible: \"human\" format and         *\n* scientific-notation E-format.                                       *\n*                                                                     *\n* If we can represent the absolute value of the flonum without loss   *\n* of significance, we use human format.  Otherwise we use E format.   *\n*                                                                     *\n* In either case a leading plus sign is NOT output; a leading minus   *\n* sign will be output whenever required.                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LD    #F0,=D'0'            CLEAR FPR0\n         LE    #F0,##CDR(,#4)       GET FLOAT VALUE (SINGLE PRECISION)\n         LPDR  #F2,#F0              GET ABSOLUTE VALUE THEREOF\n         BZ    PRINT0P0             IF ZERO, PRINT 0.0F0\n         SPACE 1\n         STE   #F0,ZLCWORK          Store flonum into workarea\n         NI    ZLCWORK,X'7F'        Turn off sign bit\n         XR    #6,#6                Clear insert register\n         ST    #6,ZLCWORK+4         Clear right half of workarea\n         IC    #6,ZLCWORK           Get characteristic\n         SH    #6,=H'64'            Convert from excess-64 notation\n         BP    GTZERO               If characteristic was X'40' or less\n         MVI   1(#3),C'0'            Make integer part print as zero\n         LA    #2,2(,#3)             Point to where to put decimal pt\n         MVI   0(#2),C'.'            Move in decimal point\n*\n* In cases where the fractional part times 10\u00ac9 is still less than 1,\n* the only characteristics we can handle without loss of significance\n* are as follows:\n*\n* Original characteristic  Value of #6   Possible flonum values\n*\n* 40                       0             40xxxxxx\n* 3F                       -1            3Fxxxxx0\n* 3E                       -2            3Exxxx00\n* 3D                       -3            3Dxxx000\n* 3C                       -4            3Cxx0000\n* 3B                       -5            3Bx00000\n*\n* Anything else and we have to switch to E notation.\n*\n         LPR   #15,#6              Convert #6 to an index\n         CH    #15,=H'5'           If characteristic just too small\n         BH    EDUMP               then use E-format\n         SLA   #15,2               Index into table of flonum masks\n         L     #0,ZLCWORK           Get flonum contents\n         N     #0,FRMASK(#15)       And it with mask\n         BNZ   EDUMP                If any 1-bits in bad place, use E\n         B     CVFRAC               Else go to convert fractional part\n         SPACE 1\nGTZERO   DS    0H                   Else flonum > 0\n         CH    #6,=H'6'             If more than 6 hex positions\n         BH    EDUMP                then give up - use E-notation\n         XR    #4,#4                Set up register pair\n         ICM   #5,15,ZLCWORK+1      Load integer part of flonum\n         SLA   #6,2                 Multiply characteristic by 4\n         SLDL  #4,0(#6)             Shift integer by # of hex places\n* Now #4 contains the integer part of the flonum.\n         CVD   #4,ZLCDBL            GET DECIMAL NUMERIC VALUE\n         MVC   NUMAREA(12),PATTERN  INITIALIZE EDIT PATTERN\n         LA    #1,NUMAREA+11        INITIALIZE MARK REGISTER\n         EDMK  NUMAREA(12),ZLCDBL+2 EDIT PACKED DATA INTO PATTERN\n         BNM   *+10                 IF RESULT IS NEGATIVE, THEN...\n         BCTR  #1,0                 BUMP BACK TO PREVIOUS POSITION\n         MVI   0(#1),C'-'           AND MOVE A MINUS SIGN IN FRONT.\n         LA    #15,NUMAREA+12       COMPUTE LENGTH OF SIGNIFICANT PART\n         SR    #15,#1               LENGTH OF CONVERTED INTEGER\n         BCTR  #15,0                REDUCE FOR EXECUTE\n         EX    #15,MVCNUMI          MOVE OUR DATA TO CALLER'S AREA\n*\n* Now the dumped integer part of the flonum is at #3%+1.\n* #15 contains the length thereof minus 1.\n*\n         LA    #2,2(#15,#3)        Point past dumped integer part\n         MVI   0(#2),C'.'          Move in a decimal point\n         STCM  #5,14,ZLCWORK+1     Store fractional part back\n         MVI   ZLCWORK,X'40'       Set characteristic of fraction\n         SPACE 1\nCVFRAC   DS    0H\n         SPACE 1\n*\n* Convert fractional part of flonum to a decimal representation by\n* multiplying it by 10000000.  If the fraction's magnitude is so small\n* that this would result in loss of significance, then switch to\n* E notation.\n*\n         SDR   #F4,#F4             Clear FP reg\n         LE    #F4,ZLCWORK         Load fractional part of flonum\n         LTER  #F4,#F4             If zero\n         BZ    FRAC0               then print a zero fractional part\n         BM    FLOBARF             If less than zero, error - lose\n         MD    #F4,=D'10E7'        Multiply by 10**7 (for 8 places)\n         AD    #F4,=D'5'           Add rounding factor\n         CD    #F4,=D'10E7'        If this makes it too big\n         BNL   EDUMP               then use E notation\n         DD    #F4,=D'10'          Down to 10**7 for 8 places\n*\n* Now convert fraction to decimal following decimal point in workarea\n*\n         STD   #F4,ZLCWORK          Store flonum into workarea\n         XR    #6,#6                Clear insert register\n         IC    #6,ZLCWORK           Get characteristic\n         SH    #6,=H'64'            Convert from excess-64 notation\n         BM    FLOBARF              If frac lt 1, lose\n         BP    FRGTZERO             If characteristic was X'40', then\n         MVI   1(#2),C'0'            make fractional part zero\n         LA    #4,1(,#2)             point to end of dumped value\n         B     FLOREADY              go to finish up flonum\n         SPACE 1\nFRGTZERO DS    0H                   Else flonum > 0\n         CH    #6,=H'6'             If more than 6 hex positions\n         BH    EDUMP                then give up, use E notation\n         XR    #4,#4                Set up register pair\n         ICM   #5,15,ZLCWORK+1      Load integer part of flonum\n         SLA   #6,2                 Multiply characteristic by 4\n         SLDL  #4,0(#6)             Shift integer by # of hex places\n* Now #4 contains the integer part of the flonum.\n         CVD   #4,ZLCDBL            Get decimal numeric value\n         UNPK  1(7,#2),ZLCDBL(8)    Unpack following decimal point\n         OI    7(#2),X'F0'          Fix up zone\n*\n* Now the dumped fractional part of the flonum is at #2%+1.\n* #15 contains the length thereof minus 1.\n*\n         LA    #4,7(,#2)           Point to last digit in dumped no.\n         LA    #0,1(,#2)           Point to first digit following \".\"\nFRBSLOOP DS    0H                  Back scan off trailing zeroes\n         CR    #4,#0               Finished when hit first frac digit\n         BNH   FRDONE\n         CLI   0(#4),C'0'          If a nonzero digit found, done\n         BNE   FRDONE\n         BCT   #4,FRBSLOOP         Else continue backscan\nFRDONE   DS    0H                  Now #4 points to last nonzero digit\n*                                  (or single digit following \".\")\n         B     FLOREADY\n         SPACE 1\nFRAC0    DS    0H                  Here if fractional part is zero\n         SPACE 1\n         MVI   1(#2),C'0'          Make it xxx.0\n         LA    #4,1(,#2)           Compute total length\n******** B     FLOREADY\n         SPACE 1\nFLOREADY DS    0H                  Flonum converted except for sign\n         SPACE 1\n         MVC   1(2,#4),=C'F0'      Move in single-float marker\n         LA    #4,2(,#4)\n         SR    #4,#3               Compute length\n* If it starts with a plus sign, remove the plus sign.\n         LTER  #F0,#F0             If original number was negative\n         BNM   FNMINUS             then\n         MVI   0(#3),C'-'           add a minus sign\n         LA    #0,1(,#4)            adjust length accordingly\n         LR    #1,#3                point to minus sign\n         B     RETURN\nFNMINUS  DS    0H                  else\n         LA    #1,1(,#3)            point to data\n         LR    #0,#4                adjust length accordingly\n         B     RETURN\n         SPACE 1\nPRINT0P0 DS    0H                  Print a floating-point zero\n         LA    #1,=C'0.0F0'\n         LA    #0,5\n         B     RETURN\n         SPACE 1\nEDUMP    DS    0H                  Print flonum using E notation\n*                                  FP reg 2 contains absolute value\n         SPACE 1\n         XR    #6,#6                INIT DECIMAL EXPONENT TO ZERO\nCOMP10   DS    0H                   MAKE IT BETWEEN 0.1 AND 1.0\n         LTDR  #F2,#F2              IF ZERO,\n         BZ    OKNOW                 OK FOR FORMATTING\n         CD    #F2,=D'1.'           IF GREATER THAN 1\n         BNL   GE1                   THEN MUST DIVIDE UNTIL < 1\n         CD    #F2,=D'.1'           IF LESS THAN .1\n         BL    LTP1                  THEN MUST MULTIPLY UNTIL >= .1\n         B     OKNOW                ELSE OK FOR FORMATTING\nGE1      DS    0H\n         DD    #F2,=D'10'           DIVIDE UNTIL LT 1.0\n         AH    #6,=H'1'             INCREMENT DECIMAL EXPONENT\n         B     COMP10               CONTINUE TESTING\nLTP1     DS    0H\n         MD    #F2,=D'10'           MULTIPLY UNTIL GE 0.1\n         BCTR  #6,0                 DECREMENT DECIMAL EXPONENT\n         B     COMP10               CONTINUE TESTING\nOKNOW    DS    0H                   NUMBER IS READY TO FORMAT\n         MD    #F2,=D'10E8'         MULTIPLY BY 10**9 (FOR 9 PLACES)\n         AD    #F2,=D'5'            ADD ROUNDING FACTOR (SHOW 8 PLACES)\n         CD    #F2,=D'10E8'         IF THIS MAKES IT BIGGER AGAIN\n         BL    RNDEDOK              THEN\n         DD    #F2,=D'10'            DIVIDE BY 10 AGAIN\n         AH    #6,=H'1'              AND ADJUST EXPONENT ACCORDINGLY.\nRNDEDOK  DS    0H\n         AW    #F2,=X'4E00000000000000' UNNORMALIZE TO GET INTEGER PART\n         STD   #F2,ZLCDBL           STORE RESULT IN WORK AREA\n         L     #1,ZLCDBL+4          PICK UP FIXED PORTION, NOW ISOLATED\n         LTDR  0,0                  IF NUMBER WAS NEGATIVE\n         BM    OUTMINUS             THEN PUT A MINUS SIGN\n         MVI   0(#3),C'+'           ELSE PUT A PLUS SIGN\n         B     AFTMINUS\nOUTMINUS MVI   0(#3),C'-'\nAFTMINUS DS    0H\n*\n* 10/87 - Convert representation from .mmmF+nn to m.mmF+(nn-1)\n*\n         BCTR  #6,0                 Adjust exponent for this rep.\n******** MVI   1(#3),C'.'           DECIMAL POINT\n         CVD   #1,ZLCDBL            MANTISSA OF DECIMAL NUMBER\n         UNPK  2(9,#3),ZLCDBL       CONVERT INTO USER AREA\n* IGNORE LAST DIGIT (USED FOR ROUNDING ONLY)\n         MVC   1(1,#3),2(#3)        Slide leftmost digit over\n         MVI   2(#3),C'.'           Insert decimal point\n         LA    #1,3(,#3)            Point to digit following \".\"\n         LA    #15,9(,#3)           Point to last dumped digit\nEBS1     DS    0H                   Scan off trailing zeroes\n         CR    #15,#1               Loop until we have to stop\n         BNH   EBS2                  or\n         CLI   0(#15),C'0'            until we find a nonzero digit\n         BNE   EBS2                    at which point go finish up\n         BCT   #15,EBS1             Decrement and continue\nEBS2     DS    0H\n         MVI   1(#15),C'F'          OVERLAY ROUNDING DIGIT WITH EXP CHR\n         LTR   #6,#6                CHECK SIGN OF DECIMAL EXPONENT\n         BM    EXPMINUS\n         MVI   2(#15),C'+'\n         B     AFTEXPMN\nEXPMINUS MVI   2(#15),C'-'\nAFTEXPMN DS    0H\n         CVD   #6,ZLCDBL           DECIMAL CHARACTERISTIC\n         UNPK  3(2,#15),ZLCDBL     CONVERT INTO USER AREA\n         OI    4(#15),X'F0'\n* If it starts with a plus sign, remove the plus sign.  This is the\n* least we can do to make Macsyma users happy for now.\n         CLI   0(#3),C'+'          IF STARTS WITH PLUS SIGN\n         BNE   FNOTPLUS            THEN\n         LA    #1,1(,#3)            POINT PAST PLUS SIGN\n         B     FAFTPLUS             FLOAT NUMBER LOOKS LIKE ABOVE\nFNOTPLUS DS    0H                  ELSE\n         LR    #1,#3                GET POINTER TO THE STUFF\nFAFTPLUS DS    0H\n         LA    #0,5(,#15)          LENGTH OF DUMPED FLONUM\n         SR    #0,#1               = END - START\n         B     RETURN\n         EJECT\nDFDUMP   DS    0H                  Dump double float\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Double-precision floating point dump.                               *\n*                                                                     *\n* Two floating-point formats are possible: \"human\" format and         *\n* scientific-notation E-format.                                       *\n*                                                                     *\n* If we can represent the absolute value of the flonum without loss   *\n* of significance, we use human format.  Otherwise we use E format.   *\n*                                                                     *\n* In either case a leading plus sign is NOT output; a leading minus   *\n* sign will be output whenever required.                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LD    #F0,8(,#4)           Get value of double precision float\n         LPDR  #F2,#F0              Get absolute value thereof\n         BZ    DPRINT00             If zero, print 0.0\n         SPACE 1\n         STD   #F0,ZLCWORK          Store flonum into workarea\n         NI    ZLCWORK,X'7F'        Turn off sign bit\n         XR    #6,#6                Clear insert register\n         IC    #6,ZLCWORK           Get characteristic\n         SH    #6,=H'64'            Convert from excess-64 notation\n         BP    DGTZERO              If GT X'40', go do integer part\n*                                   Characteristic X'40' or less...\n*                                   there is only a fractional part\n         MVI   1(#3),C'0'            Make integer part print as zero\n         LA    #2,2(,#3)             Point to where to put decimal pt\n         MVI   0(#2),C'.'            Move in decimal point\n*\n* In cases where the fractional part times 10\u00ac16 is still less than 1,\n* the only characteristics we can handle without loss of significance\n* are as follows:\n*\n* Original characteristic  Value of #6   Possible flonum values\n*\n* 40                       0             40xxxxxx xxxxxxxx\n* 3F                       -1            3Fxxxxxx xxxxxxx0\n* 3E                       -2            3Exxxxxx xxxxxx00\n* 3D                       -3            3Dxxxxxx xxxxx000\n* 3C                       -4            3Cxxxxxx xxxx0000\n* 3B                       -5            3Bxxxxxx xxx00000\n* 3A                       -6            3Axxxxxx xx000000\n* 39                       -7            39xxxxxx x0000000\n* 38                       -8            38xxxxxx 00000000\n* 37                       -9            37xxxxx0 00000000\n* 36                       -10           36xxxx00 00000000\n* 35                       -11           35xxx000 00000000\n* 34                       -12           34xx0000 00000000\n* 33                       -13           33x00000 00000000\n*\n* Anything else and we have to switch to scientific notation.\n*\n* Some hacking required here.  More than just this test is required.\n*\n         LPR   #15,#6              Convert #6 to an index\n         CH    #15,=H'12' <==      If characteristic just too small\n         BH    DEDUMP              then use scientific notation\n         SLA   #15,3               Index into table of flonum masks\n         LA    #15,DFRMASK(#15)    Get address of appropriate mask\n         MVC   DWORK(8),ZLCWORK    Move flonum contents to work area\n         NC    DWORK(8),0(#15)     And it with mask\n         BNZ   DEDUMP              If any 1-bits in bad place, use sci.\n         B     DCVFRAC             Else go to convert fractional part\n         SPACE 1\nDGTZERO  DS    0H                   Else flonum > 0\n         SPACE 1\n         CH    #6,=H'14'            If more than 14 hex positions\n         BH    DEDUMP               then give up - use sci-notation\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* (1) Isolate integer part of flonum and convert to decimal.          *\n*     #6 = adjusted characteristic (number of nibbles of integer)     *\n*                                                                     *\n* To do the conversion, we load the integer part of the flonum        *\n* (isolated by the old trick of adding an unnormalized zero)          *\n* into a register pair and do a fixed-point divide by 10\u00ac9 to get the *\n* left half of the converted decimal, then convert the remainder to   *\n* get the right half.  Subsequently we scan off leading blanks.       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LDR   #F4,#F2             Get that (abs flonum) again\n         AW    #F4,=X'4E00000000000000' Unnormalize to get integer part\n         STD   #F4,DWORK            Store it\n         CLI   DWORK,X'4E'          If characteristic isn't what we\n         BNE   FLOBARF               expected, then go blow up.\n         MVI   DWORK,X'00'          Clear characteristic\n         LM    #4,#5,DWORK          Load integer part of flonum\n         D     #4,=F'1000000000'    Divide by 10\u00ac9\n* We know that the quotient cannot be greater than 2147483647, so\n* a program check is not possible.\n*                                   #4 = remainder\n*                                   #5 = quotient\n         CVD   #5,ZLCDBL            Convert quotient to decimal\n         UNPK  DNUMAREA(9),ZLCDBL   Get 9 digits of decimal number\n         OI    DNUMAREA+8,X'F0'     Fix up sign\n         CVD   #4,ZLCDBL            Convert remainder to decimal\n         UNPK  DNUMAREA+9(9),ZLCDBL Get 9 digits of decimal number\n         OI    DNUMAREA+9+8,X'F0'   Fix up sign\n*\n* Now the dumped integer part of the flonum is at DNUMAREA.\n* We have 18 digits.  Now get rid of leading blanks.  We know\n* that the entire number will not be zero.\n*\n         LA    #1,DNUMAREA         Start pointer at start of digits\n         LA    #15,18              Set loop count\nDLZLOOP  CLI   0(#1),C'0'          Loop until nonzero digit found\n         BNE   DLZEND\n         LA    #1,1(,#1)\n         BCT   #15,DLZLOOP\nDLZEND   DS    0H\n*                                  #15 contains # of significant\n*                                  decimal digits, #1 points to num\n         BCTR  #15,0               Reduce length for execute\n         EX    #15,MVCNUMI         Move dumped integer part\n         LA    #2,2(#15,#3)        Point past dumped integer part\n         MVI   0(#2),C'.'          Move in a decimal point\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* (2) Isolate the fractional part of the flonum and convert that.     *\n*     To get it, we simply subtract the integer part from the         *\n*     original (abs flonum).                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         AD    #F4,=D'0'           Normalize integer flonum\n         SDR   #F2,#F4             Set FPR2 = fractional part\n         STD   #F2,ZLCWORK         Store fractional part in workarea\n         SPACE 1\nDCVFRAC  DS    0H\n         SPACE 1\n*\n* Convert fractional part of flonum to a decimal representation by\n* multiplying it by 10\u00ac15.  If the fraction's magnitude is so small\n* that this would result in loss of significance, then switch to\n* scientific notation.\n*\n         LTDR  #F2,#F2             If zero\n         BZ    DFRAC0              then print a zero fractional part\n         BM    FLOBARF             If less than zero, error - lose\n         MD    #F2,=D'10E16'       Multiply by 10**16 (for 16 places)\n         AD    #F2,=D'5'           Add rounding factor\n         CD    #F2,=D'10E16'       If this makes it too big\n         BNL   DEDUMP              then use scientific notation\n         DD    #F2,=D'10'          Down to 10**15 for 16 places\n*\n* Now convert fraction to decimal following decimal point in workarea\n*\n         AW    #F2,=X'4E00000000000000' Unnormalize to get integer part\n         STD   #F2,DWORK            Store it\n         CLI   DWORK,X'4E'          If characteristic isn't what we\n         BNE   FLOBARF               expected, go blow up.\n         MVI   DWORK,X'00'          Clear characteristic\n         LM    #4,#5,DWORK         Load integer part of flonum\n         D     #4,=F'1000000000'   Divide by 10\u00ac9\n* We know that the quotient cannot be greater than 2147483647, so\n* a program check is not possible.\n*                                  #4 = remainder\n*                                  #5 = quotient\n         CVD   #5,ZLCDBL           Convert quotient to decimal\n         UNPK  DNUMAREA(9),ZLCDBL  Get 9 digits of decimal number\n         OI    DNUMAREA+8,X'F0'    Fix up sign\n         CVD   #4,ZLCDBL           Convert remainder to decimal\n         UNPK  DNUMAREA+9(9),ZLCDBL Get 9 digits of decimal number\n         OI    DNUMAREA+9+8,X'F0'  Fix up sign\n*\n* Now the dumped fractional part of the flonum is at DNUMAREA.\n* We have 18 digits.  However, we expect a maximum of 16 digits\n* to be significant.  Plus, get rid of trailing blanks.  We know\n* that the entire number will not be zero.\n*\n         LA    #1,DNUMAREA+9+8     Start pointer at end of digits\n         LA    #15,16              Set loop count\nDTZLOOP  CLI   0(#1),C'0'          Loop until nonzero digit found\n         BNE   DTZEND\n         BCTR  #1,0\n         BCT   #15,DTZLOOP\nDTZEND   DS    0H\n*                                  #15 contains # of significant\n*                                  decimal digits\n         LA    #1,DNUMAREA+2\n         BCTR  #15,0               Reduce length for execute\n         EX    #15,MVCNUMF         Move dumped fractional part\n         LA    #4,2(#15,#2)        Point to end of dumped value\n         B     DFLORDY             Go to finish up flonum\n         SPACE 1\nDFRAC0   DS    0H                  Here if fractional part is zero\n         SPACE 1\n         MVI   1(#2),C'0'          Make it xxx.0\n         LA    #4,2(,#2)           Point to the end\n******** B     DFLORDY\n         SPACE 1\nDFLORDY  DS    0H                  Flonum converted except for sign\n*                                  and double-float marker\n*******  MVC   0(2,#4),=C'D0'      DON'T Move in double-float marker\n*******  LA    #4,1(,#4)           Add to length\n         BCTR  #4,0\n         SR    #4,#3               Compute length\n         LTER  #F0,#F0             If original number was negative\n         BNM   DFNMINUS            then\n         MVI   0(#3),C'-'           add a minus sign\n         LA    #0,1(,#4)            adjust length accordingly\n         LR    #1,#3                point to minus sign\n         B     RETURN\nDFNMINUS DS    0H                  else\n         LA    #1,1(,#3)            point to data\n         LR    #0,#4                adjust length accordingly\n         B     RETURN\n         SPACE 1\nDPRINT00 DS    0H                  Print a double-float zero\n         LA    #1,=C'0.0'\n         LA    #0,3\n         B     RETURN\n         SPACE 1\nDEDUMP   DS    0H                  Print flonum using sci. notation\n*                                  FP reg 2 contains absolute value\n         SPACE 1\n         XR    #6,#6               Initial decimal exponent to zero\nDCOMP10  DS    0H                  Make value between 0.1 and 1.0\n         LTDR  #F2,#F2             If value is zero,\n         BZ    DOKNOW               then it's ok for formatting\n         CD    #F2,=D'1.'          If value greater than 1\n         BNL   DGE1                 then we must divide until LT 1\n         CD    #F2,=D'.1'          If less than 0.1\n         BL    DLTP1                then we must multiply until GE 0.1\n         B     DOKNOW              Else ok for formatting\nDGE1     DS    0H\n         DD    #F2,=D'10'          Divide until LT 1.0\n         AH    #6,=H'1'            Increment decimal exponent\n         B     DCOMP10             Continue testing\nDLTP1    DS    0H\n         MD    #F2,=D'10'          Multiply until GE 0.1\n         BCTR  #6,0                Decrement decimal exponent\n         B     DCOMP10             Continue testing\nDOKNOW   DS    0H                  Now number is ready to format\n         MD    #F2,=D'10E15'       Multiply by 10**15 (for 16 places)\n         AD    #F2,=D'5'           Add rounding factor (show 16 places)\n         CD    #F2,=D'10E15'       If this makes it bigger again\n         BL    DRNDEDOK            then\n         DD    #F2,=D'10'           divide by 10 again\n         AH    #6,=H'1'             and adjust exponent accordingly.\nDRNDEDOK DS    0H\n         AW    #F2,=X'4E00000000000000' Unnormalize to get integer part\n         STD   #F2,ZLCDBL          Store result in work area\n         CLI   ZLCDBL,X'4E'        If characteristic isn't what we\n         BNE   FLOBARF              expected, go blow up.\n         MVI   ZLCDBL,X'00'        Clear characteristic\n         LM    #4,#5,ZLCDBL        Pick up integer part, now isolated\n         LTDR  #F0,#F0             If original flonum was negative\n         BM    DOUTMNUS            then put a minus sign\n         MVI   0(#3),C'+'          else put a plus sign\n         B     DAFTMNUS\nDOUTMNUS MVI   0(#3),C'-'\nDAFTMNUS DS    0H\n*\n* 10/87 - Convert representation from .mmmF+nn to m.mmF+(nn-1)\n*\n         BCTR  #6,0                Adjust exponent for this rep.\n******** MVI   1(#3),C'.'          Put decimal point\n         D     #4,=F'1000000000'   Divide by 10\u00ac9\n* We know that the quotient cannot be greater than 2147483647, so\n* a program check is not possible.\n*                                  #4 = remainder\n*                                  #5 = quotient\n         CVD   #5,ZLCDBL           Convert quotient to decimal\n         UNPK  2(7,#3),ZLCDBL      Get 9 digits of decimal number\n         OI    8(#3),X'F0'         Fix up sign\n         CVD   #4,ZLCDBL           Convert remainder to decimal\n         UNPK  9(9,#3),ZLCDBL      Get 9 digits of decimal number\n         OI    17(#3),X'F0'        Fix up sign\n* Ignore last digit (used for rounding only)\n         MVC   1(1,#3),2(#3)        Slide leftmost digit over\n         MVI   2(#3),C'.'           Insert decimal point\n         LA    #1,3(,#3)            Point to digit following \".\"\n         LA    #15,16(,#3)          Point to last dumped digit\nDBS1     DS    0H                   Scan off trailing zeroes\n         CR    #15,#1               Loop until we have to stop\n         BNH   DBS2                  or\n         CLI   0(#15),C'0'            until we find a nonzero digit\n         BNE   DBS2                    at which point go finish up\n         BCT   #15,DBS1             Decrement and continue\nDBS2     DS    0H\n         MVI   1(#15),C'D'         Overlay rounding digit with exp chr\n         LTR   #6,#6               Check sign of decimal exponent\n         BM    DEXPMNUS\n         MVI   2(#15),C'+'\n         B     DAFTEXPM\nDEXPMNUS MVI   2(#15),C'-'\nDAFTEXPM DS    0H\n         CVD   #6,ZLCDBL           Decimal characteristic\n         UNPK  3(2,#15),ZLCDBL     Convert into user area\n         OI    4(#15),X'F0'\n* If it starts with a plus sign, remove the plus sign.\n         CLI   0(#3),C'+'          If it starts with plus sign\n         BNE   DFNPLUS             then\n         LA    #1,1(,#3)            point past plus sign\n         B     DFAPLUS\nDFNPLUS  DS    0H                  else\n         LR    #1,#3                get pointer to the stuff\nDFAPLUS  DS    0H\n         LA    #0,5(,#15)          Get length of dumped flonum\n         SR    #0,#1               = end - start\n         B     RETURN\n         EJECT\nNOTFLOAT DS    0H\n         SPACE\n         CLI   ##TYPE(#4),##FIXNUM IF FIXNUM\n         BNE   NOTFIXED            THEN...\n         SPACE\n         L     #1,##CDR(,#4)       GET THE FIXED VALUE OF THE ATOM\n         CVD   #1,ZLCDBL           GET DECIMAL NUMERIC VALUE\n         MVC   NUMAREA(12),PATTERN INITIALIZE EDIT PATTERN\n         LA    #1,NUMAREA+11       INITIALIZE MARK REGISTER\n         EDMK  NUMAREA(12),ZLCDBL+2 EDIT PACKED DATA INTO PATTERN\n         BNM   *+10                IF RESULT IS NEGATIVE, THEN...\n         BCTR  #1,0                 BUMP BACK TO PREVIOUS POSITION\n         MVI   0(#1),C'-'           AND MOVE A MINUS SIGN IN FRONT.\n         LA    #0,NUMAREA+12       COMPUTE LENGTH OF SIGNIFICANT PART\n         SR    #0,#1               LENGTH OF CONVERTED FIXNUM\n         LR    #15,#0              SET LENGTH OF CONVERTED NUMBER\n         BCTR  #15,0               REDUCE FOR EXECUTE\n         EX    #15,MVCNUMA         MOVE OUR DATA TO CALLER'S AREA\n         LR    #1,#3               GET POINTER TO THE STUFF\n         B     RETURN\n         SPACE\nMVCNUMA  MVC   0(0,#3),0(#1)       MOVE CHAR TEXT TO USER AREA\nMVCNUMI  MVC   1(0,#3),0(#1)       MOVE CHAR TEXT TO USER AREA\nMVCNUMF  MVC   1(0,#2),0(#1)       MOVE CHAR TEXT TO USER AREA\n         EJECT\nNOTFIXED DS    0H                  IT'S NOT A FIXNUM\n         SPACE\n         CLI   ##TYPE(#4),##BIGNUM IF A BIGNUM\n         BNE   NOTBIG              THEN...\n         SPACE\n***********************************************************************\n*ON ENTRY                                                             *\n*     R3 = POINTER TO SMALL WORK AREA                                 *\n*     R4 = POINTER TO BIGNUM                                          *\n***********************************************************************\n*ON RETURN                                                            *\n*     R4 = ACTUAL OBJECT ON RETURN (MUST INCLUDE MINUS SIGN, IF ANY)  *\n*     R5 = IS LENGTH (EXACT NUMER OF BYTES)                           *\n* POSITIVE BIGNUM RETURNED WITH A FEW LEADING ZEROS                   *\n* NEGATIVE BIGNUM RETURNED WITH MINUS SIGN A POSSIBLE LEADING ZEROES  *\n***********************************************************************\n* REGISTER USAGE - DURING PROCESSING                                  *\n*     R0 = 1,000,000,000                                              *\n*     R1 = USED AS TEMPORARY JUNK REGISTER                            *\n*     R2 = LENGTH OF BIGNUM, LENGTH OF BIGNUM - 1                     *\n*     R3 = POINTER TO BEGINNING OF WORK AREA                          *\n*     R4 = BIGNUM POINTER                                             *\n*     R5 = -4 (SIZE OF WORD, GENERAL USE)                             *\n*     R6 = UPPER DIVIDEND REGISTER, REMAINDER AFTER DIVIDE            *\n*     R7 = LOWER DIVIDEND REGISTER, QUOTIENT AFTER DIVIDE             *\n*     R14 = OFFSET POINTER WITHIN BIGNUM                              *\n*     R15 = CVD RESULT POINTER (LONGBIG ONLY)                         *\n***********************************************************************\n         EJECT\n         TM    3(#4),B'00000011'   TEST FOR UNMULTIPLE OF 4\n         BNZ   NOMULT4             BIGNUM LENGTH IS NOT MULTIPLE OF 4\n         XR    #2,#2               NEED 0 IN HIGH ORDER BYTE OF REG 2\n         ICM   #2,7,1(#4)          GET THREE BYTE LENGTH OF BIGNUM\n         LA    #5,4                BYTE SIZE OF ONE WORD\n         SR    #2,#5               ZERO-ORIGIN THE BIGNUM BYTE-LENGTH\n         CR    #2,#5               IS BIGNUM TWO WORDS LONG?\n         BH    LONGBIG             TWO WORD BIGNUM -NO WORK AREA NEEDED\n         BL    SIZEBAD             ****TAKE THIS OUT AFTER DEBUGGING\n         L     #0,=F'1000000000'   ONE BILLION, DO TWO WORD BIGNUM\n******** L     #6,8(,#4)           MS WORD INTO LS DIVIDEND\n         ICM   #6,15,8(#4)         *** DELETE AFTER DEBUGGING\n         BM    BIGBAD              *** DELETE AFTER DEBUGGING\n         BZ    BADZERO             *** DELETE AFTER DEBUGGING\n         CR    #6,#0               MS WORD GREATER THAN BILLION (RARE)?\n         BNL   BIG2                NEED TWO DIVIDES FOR TWO WORD BIGNUM\n         CLC   0(12,#4),BADTWO31   IS BIGNUM -2**31 ?\n         BE    BAD31MSG            YES, ISSUE MESSAGE\n         L     #7,4(,#4)           MS WORD OF 2-WORD BIGNUM\n         SLL   #7,1                MASH OUT SIGN BIT (31-BIT-RADIX)\n         SRDL  #6,1                SQUEEZE HIGHER WORD DOWN\n         DR    #6,#0               DIVIDE TO GET REMAINDER\n         CVD   #6,ZLCDBL           PACKED DECIMAL INTO WORK AREA\n         UNPK  11(9,#3),ZLCDBL+3(5) UNPACK LS 9 DIGITS\n         OI    19(#3),X'F0'        GET RID OF DUMB UNPK SIGN\n         CVD   #7,ZLCDBL           DECIMALIZE QUOT. TO GIVE MS 10 DIG\n         UNPK  1(10,#3),ZLCDBL+2(6) UNPACK MS 10 DIGS,19TH=0,1,2\n         OI    10(#3),X'F0'        GET RID OF DUMB UNPK SIGN\n         LR    #1,#3               POINTER TO BEGINNING OF STRING\n         LA    #15,20(,#3)         POINTER PAST END OF TEXT\n         B     BIGDONE             GO SCAN FOR LEADING ZEROES\n*\nBIG2     SRDL  #6,32               DIV IN RIGHT REG, CLEAR LEFT\n         DR    #6,#0               DIVIDE MS WORD BY BILLION\n         LR    #15,#7              STORE QUOTIENT (CAN ONLY BE 1 OR 2)\n         L     #7,4(,#4)           MS WORD OF 2-WORD BIGNUM\n         SLL   #7,1                MASH OUT SIGN BIT (31-BIT-RADIX)\n         SRDL  #6,1                SQUEEZE HIGHER WORD DOWN\n         DR    #6,#0               DIVIDE TO GET REMAINDER\n         CVD   #6,ZLCDBL           PACKED DECIMAL INTO WORK AREA\n         UNPK  11(9,#3),ZLCDBL+3(5) UNPACK LS 9 DIGITS\n         OI    19(#3),X'F0'        GET RID OF DUMB UNPK SIGN\n         LR    #6,#15\n         SLL   #7,1                MASH OUT JUNK BIT (31-BIT-RADIX)\n         SRDL  #6,1                SQUEEZE HIGHER WORD DOWN\n         DR    #6,#0\n         CVD   #6,ZLCDBL           DECIMALIZE QUOT. TO GIVE MS 10 DIG\n         UNPK  2(9,#3),ZLCDBL+3(5) UNPACK 9 DIGITS\n         OI    10(#3),X'F0'         GET RID OF DUMB UNPK SIGN\n         CR    #7,#5               ****DELETE AFTER DEBUGGING\n         BH    DIG19ERR            ****DELETE AFTER DEBUGGING\n         LA    #7,C'0'(,#7)        19TH DIGIT IS 2,3,4, PREP FOR EBCDIC\n         STC   #7,1(,#3)           STORE 19TH DIGIT IN EBCDIC\n         LR    #1,#3               POINTER TO BEGINNING TEXT\n         LA    #15,20(,#3)         POINTER PAST END OF TEXT\n         B     BIGDONE             GO SCAN FOR LEADING ZEROES\n         SPACE 1\nLONGBIG  DS    0H\n         LA    #7,24(#2,#2)        R7 = 24 + 2*R2\n         AR    #7,#2               NOW R7 = 24 + 3*R2\n         C     #7,ZLCDWALN         IF IT IS TOO BIG FOR CURRENT W/A\n         BNH   WALENOK             THEN\n         ICM   #1,15,ZLCDWA         GET CURRENT WORKAREA ADDRESS\n         BZ    NOFREE               IF NONE, SKIP FREEMAIN\n         L     #0,ZLCDWALN          GET LENGTH OF CURRENT WORKAREA\n         FREEMAIN R,LV=(0),A=(1)    FREE IT\nNOFREE   DS    0H                  NOW PREPARE TO GET A BIGGER ONE\n******** LA    #7,7(,#7)           ROUND (DOWN) TO DOUBLEWORD BOUNDARY\n         N     #7,=X'FFFFFFF8'     (IT'S ALREADY >=4 MORE THAN WE NEED)\n         #GETMAIN RC,LV=(#7),LOC=BELOW GET NEW WORKAREA\n         LTR   #15,#15             IF STORAGE NOT AVAILABLE\n         BNZ   ERROR2              THEN ERROR\n         ST    #7,ZLCDWALN         SAVE NEW WORKAREA LENGTH\n         ST    #1,ZLCDWA           SAVE NEW WORKAREA ADDRESS\nWALENOK  L     #3,ZLCDWA           OK, GET WORKAREA ADDRESS\n         LCR   #5,#5               GENERATE -4\n         L     #0,=F'1000000000'   ONE BILLION\n*\n         LR    #14,#3              START AT NEXT LEAST SIG WORD\n         LA    #15,4(,#2)          PREP TO COPY WHOLE LENGTH OF BIGNUM\n         LA    #6,##VECDAT(,#4)    START AT LEAST SIGNFICANT WORD\n         LR    #7,#15              LENGTH OF BIGNUM\n         MVCL  #14,#6              MOVE BIGNUM TO WORK AREA\n*                                  THE SIGN WILL GET SQUEEZED OUT\n*\n         L     #1,ZLCDWALN         GET LENGTH OF WORKAREA\n         AR    #1,#3               POINT PAST END OF WORKAREA\n         AR    #2,#5               #2 IS 8 LESS THAN DIVIDEND LENGTH\n         LR    #15,#1              SAVE POINTER PAST END OF WORKAREA\n*\nCVDLOOP  LA    #14,4(,#2)          #14 SHOULD ONLY BE 4 LESS THAN LEN\n         LA    #6,9                WE DO 9 DECIMAL DIGITS AT A TIME\n         SR    #1,#6               BUMP DOWN THE UNPACK POINTER\n*\n         L     #6,0(#14,#3)        GET MS WORD OF DIVIDEND\n         LTR   #6,#6               *** DELETE AFTER DEBUGGING\n         BM    BIGBAD              *** DELETE AFTER DEBUGGING\n         BZ    BADZERO             *** DELETE AFTER DEBUGGING\n         CR    #6,#0               LESS THAN A BILLION?\n         BL    NODIV               YUP, WE KNOW QUOTIENT WILL BE 0\n         SRDL  #6,32               NOP, PUT IT IN #7 AND CLEAR #6\n         DR    #6,#0               DIVIDE BY A BILLION\n         ST    #7,0(#14,#3)        STORE QUOTIENT IN SAME PLACE\n         SR    #2,#5               BUMP UP SO IT'S SAME AFTER BXH\n*\nNODIV    DS    0H\n         AR    #14,#5              DECREMENT TO NEXT DIVIDEND WORD\n*\nDIVLOOP  L     #7,0(#14,#3)        GET NEXT DIVIDEND WORD\n         SLL   #7,1                MASH OUT SIGN BIT\n         SRDL  #6,1                MASH BOTH WORDS RIGHT\n         DR    #6,#0               DIVIDE BY A BILLION\n         ST    #7,0(#14,#3)        STORE QUOTIENT IN SAME PLACE\n         BXH   #14,#5,DIVLOOP      DO WE HAVE ANOTHER DIVIDEND WORD?\n*\n         CVD   #6,ZLCDBL           CONVERT REMAINDER TO GEN 9 DIGITS\n         UNPK  0(9,#1),ZLCDBL+3(5) UNPACK INTO EBCDIC\n         OI    8(#1),X'F0'         STAMP OUT DUMB SIGN CODE\n         BXH   #2,#5,CVDLOOP       IS THE QUOTIENT 2 OR MORE WORDS?\n*\n         LA    #6,11               ROOM FOR 10 DIGITS AND 1 SIGN\n         SR    #1,#6               BUMP DOWN POINTER BY THAT AMOUNT\n*\n         CVD   #7,ZLCDBL           LAST ONE, SIMPLY CVD QUOTIENT\n         UNPK  1(10,#1),ZLCDBL+2(6) UNPACK INTO EBCDIC\n         OI    10(#1),X'F0'        STAMP OUT DUMB SIGN CODE\n*\n******** B     BIGDONE             GO SCAN FOR LEADING ZEROES\n         SPACE 1\nBIGDONE  DS    0H                  OK, NOW CHOP OFF LEADING ZEROES\n*                                  #1 POINTS TO SIGN + CVD'D STRING\n*                                  #15 POINT PAST END OF STRING\nLZLOOP   CLI   1(#1),C'0'          IS IT A ZERO CHARACTER?\n         BNE   GOTFNZ              NOP, WE GOT THE FIRST REAL DIGIT\n         LA    #1,1(,#1)           BUMP UP THE POINTER\n         B     LZLOOP              GO BACK AND SEE IF THIS IS ZERO\nGOTFNZ   DS    0H\n         TM    ##VECDAT(#4),X'80'  WHAT'S THE SIGN OF THE BIGNUM?\n         BZ    BNOTM               IT'S NOT MINUS\n         MVI   0(#1),C'-'          IT'S MINUS, PUT IN THE MINUS SIGN\n         LR    #0,#15              POINTER PAST END OF STRING\n         SR    #0,#1               SUBTRACT BEGINNING TO GET LENGTH\n         B     RETURN\nBNOTM    DS    0H\n         LR    #0,#15              POINTER PAST END OF STRING\n         LA    #1,1(,#1)           NO SIGN, BUMP UP BEGINNING POINTER\n         SR    #0,#1               SUBTRACT BEGINNING TO GET LENGTH\n         B     RETURN\n         SPACE 1\n***********************************************************************\n         EJECT\nNOTBIG   DS    0H                  ELSE NOT A BIGNUM...\n         SPACE 1\n         TM    ##TYPE(#4),##VEC    IF THIS IS A VECTOR-TYPE OBJECT\n         BO    ERRORV              (VECTOR, FUNARG OR STRUCTURE), ERROR\n*                                  ELSE NONE OF THE ABOVE\n         LA    #1,DUMPUNK          POINT TO UNKNOWN-OBJECT IDENTIFIER\n         LA    #0,L'DUMPUNK        SET LENGTH\n         B     RETURN\n         EJECT\nSLSTRING DS    0H                  SLASHIFY OR COPY A STRING\n         SPACE 1\n         #BAS  #14,GETSLWA         GET SLASHIFICATION WORK AREA\n         TM    ZLCDFLGS,ZLCDSLSH   IF SLASHIFICATION NOT REQUESTED\n         BZ    STRCOPY             THEN JUST DO STRING COPY\n*                                  ELSE SLASHIFY THE STRING\n         MVI   0(#3),C'\"'          START OUT WITH A DOUBLE QUOTE\n         LA    #14,1(,#3)          BUMP OUTPUT POINTER\n         LTR   #7,#7               GET LENGTH OF STRING DATA\n         BZ    SLSTREND            SKIP DUMP IF NULL STRING\n         LA    #15,##VECDAT(,#4)   POINT TO PRINT NAME TEXT\nSLSTRLOP DS    0H\n         CLI   0(#15),C'\"'         IF THIS CHARACTER NEEDS TO BE\n         BE    SLSTRBS              SLASHED BECAUSE IT IS A\n         CLI   0(#15),C'\\'           DOUBLE QUOTE OR A BACKSLASH,\n         BNE   SLSTRNS                THEN...\nSLSTRBS  MVI   0(#14),C'\\'          ADD A BACKSLASH (SINGLE ESCAPE)\n         LA    #14,1(,#14)          AND BUMP OUTPUT POINTER\nSLSTRNS  MVC   0(1,#14),0(#15)     MOVE STRING CHARACTER\n         LA    #14,1(,#14)         BUMP OUTPUT POINTER\n         LA    #15,1(,#15)         BUMP INPUT POINTER\n         BCT   #7,SLSTRLOP         CONTINUE UNTIL STRING LENGTH ZERO\nSLSTREND DS    0H\n         MVI   0(#14),C'\"'         END UP WITH A DOUBLE QUOTE\n         LR    #1,#3               GET POINTER TO START OF OUTPUT TEXT\n         LA    #0,1(,#14)          GET POINTER TO END OF OUTPUT TEXT\n         SR    #0,#1               DIFFERENCE GIVES LENGTH OF TEXT\n         B     RETURN\n         EJECT\nSLSYMBOL DS    0H                  SLASHIFY OR COPY A SYMBOL\n         SPACE 1\n         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL\n         LA    #2,0(,#2)           CLEAR HIGH ORDER BITS\n         #BAS  #14,GETSLWA         GET SLASHIFICATION WORK AREA\n         TM    ZLCDFLGS,ZLCDSLSH   IF SLASHIFICATION NOT REQUESTED\n         BZ    STRCOPY             THEN JUST DO SYMBOL COPY\n*                                  ELSE SLASHIFY THE STRING\n*\n* SLASHIFY THE ATOM TEXT.  POTENTIALLY PUT VERTICAL BARS AROUND IT.\n*\n         LTR   #7,#7               CHECK LENGTH OF PRINT NAME\n         BZ    SLSYM               IF NULL PRINT NAME, GO SLASHIFY IT\n         LA    #14,##VECDAT(,#4)   POINT TO BEGINNING OF STRING TEXT\n         LR    #15,#7              GET SYMBOL PRINT NAME LENGTH\n         LA    #5,256\nSCANLOOP DS    0H\n         CR    #15,#5              IF LENGTH IS 256 OR LESS\n         BNH   DOTRT               THEN WE CAN SCAN EASILY\n         TRT   0(256,#14),SYMTR0   ELSE SCAN FIRST 256 CHARACTERS\n         BNZ   SLSYM               IF WE GOT ANY, PREPARE TO SLASHIFY\n         SR    #15,#5              BUMP LENGTH DOWN\n         BNP   TRTCHAR1            IF ALL SCANNED OK, GO CK 1ST CHAR\n         LA    #14,256(,#14)       BUMP UP POINTER TO DATA TO SCAN\n         B     SCANLOOP\nDOTRT    DS    0H\n         BCTR  #15,0               REDUCE LENGTH FOR EXECUTE\n         EX    #15,SYMTR           SCAN FOR FUNNY CHARACTERS\n         BNZ   SLSYM               IF WE GOT ANY, PREPARE TO SLASHIFY\nTRTCHAR1 DS    0H\n         TRT   ##VECDAT(1,#4),SYMTR1 SCAN FIRST CHAR FOR FUNNINESS\n         BZ    NOSLSYM             IF NOT FUNNY, NO NEED TO SLASHIFY\n* AT THIS POINT ALL CHARACTERS ARE OK BUT FIRST MAY SIGNAL NUMERIC.\n* IF THIS IS STILL OK, WE MAY NOT HAVE TO SLASHIFY.\n         CH    #7,=H'1'            IF LENGTH OF ATOM IS 1\n         BH    CHECK$              THEN\n         CLI   ##VECDAT(#4),C'0'    IF OFFENDING 1ST/ONLY CHAR NUMERIC\n         BNL   SLSYM                 OR\n         CLI   ##VECDAT(#4),C'.'      IT IS A PERIOD\n         BE    SLSYM                   THEN WE MUST SLASHIFY\n         B     NOSLSYM              ELSE NO NEED TO SLASHIFY\nCHECK$   DS    0H                  ELSE LENGTH OF ATOM GREATER THAN 1\n         CLI   ##VECDAT(#4),C'$'   IF STARTS WITH $,\n         BNE   SL1NOT$             THEN...\n         CLI   ##VECDAT+1(#4),C'$' IF STARTS WITH $$,\n         BE    SLSYM               THEN MUST SLASHIFY\n         B     NOSLSYM             ELSE $X, DON'T HAVE TO SLASHIFY\nSL1NOT$  DS    0H\n         CLI   ##VECDAT+1(#4),C'+' IF _+, NO NEED TO SLASHIFY\n         BE    NOSLSYM\n         CLI   ##VECDAT+1(#4),C'-' IF _-, NO NEED TO SLASHIFY\n         BE    NOSLSYM\nSLSYM    DS    0H                  SLASHIFY THE SYMBOL PRINT NAME\n         MVI   0(#3),C'|'          START OUT WITH A DOUBLE ESCAPE\n         LA    #14,1(,#3)          BUMP OUTPUT POINTER\n         LTR   #7,#7               GET LENGTH OF STRING DATA\n         BZ    SLSYMEND            SKIP DUMP IF NULL PRINT NAME\n         LA    #15,##VECDAT(,#4)   POINT TO PRINT NAME TEXT\nSLSYMLOP DS    0H\n         CLI   0(#15),C'|'         IF THIS CHARACTER NEEDS TO BE\n         BE    SLSYMBS              SLASHED BECAUSE IT IS A\n         CLI   0(#15),C'\\'           DOUBLE OR SINGLE ESCAPE,\n         BNE   SLSYMNS                THEN...\nSLSYMBS  MVI   0(#14),C'\\'          ADD A BACKSLASH (SINGLE ESCAPE)\n         LA    #14,1(,#14)          AND BUMP OUTPUT POINTER\nSLSYMNS  MVC   0(1,#14),0(#15)     MOVE PRINT NAME CHARACTER\n         LA    #14,1(,#14)         BUMP OUTPUT POINTER\n         LA    #15,1(,#15)         BUMP INPUT POINTER\n         BCT   #7,SLSYMLOP         CONTINUE TILL PRINT NAME LENGTH ZERO\nSLSYMEND DS    0H\n         MVI   0(#14),C'|'         END UP WITH A DOUBLE ESCAPE\n         LR    #1,#3               GET POINTER TO START OF OUTPUT TEXT\n         LA    #0,1(,#14)          GET POINTER TO END OF OUTPUT TEXT\n         SR    #0,#1               DIFFERENCE GIVES LENGTH OF TEXT\n         B     RETURN\n         SPACE 1\nNOSLSYM  DS    0H                  STRING IS NOT TO BE SLASHIFIED\n         SPACE 1\n         LA    #1,##VECDAT(,#4)    POINT TO STRING TEXT\n         XR    #0,#0\n         ICM   #0,7,1(#4)          GET STRING LENGTH\n         B     RETURN\n         SPACE 1\nSYMTR    TRT   0(*-*,#14),SYMTR0   SCAN SYMBOL PRINT NAME\n         EJECT\nSTRCOPY  DS    0H                  COPY STRING OR SYMBOL PRINT NAME\n         SPACE 1\n         LA    #14,##VECDAT(,#4)   SOURCE ADDRESS = STRING TEXT\n         XR    #15,#15\n         ICM   #15,7,1(#4)         SOURCE LENGTH = STRING TEXT LEN\n         LR    #0,#3               DESTINATION ADDRESS = SL WORK AREA\n         LR    #1,#15              DESTINATION LENGTH = STRING TEXT LEN\n         MVCL  #0,#14              MOVE STRING TEXT TO WORK AREA\n         LR    #1,#3               GET POINTER TO START OF OUTPUT TEXT\n         SR    #0,#1               COMPUTE LENGTH OF OUTPUT TEXT\n         B     RETURN\n         EJECT\nGETSLWA  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE INSURES A WORKAREA FOR THE STRING POINTED TO BY #4.    *\n* THE ADDRESS OF THE WORKAREA IS RETURNED IN #3 AND THE LENGTH OF     *\n* THE INPUT STRING IS IN #7.  THE ADDRESS OF THE INPUT STRING IS      *\n* PUT IN #4.                                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #4,#2               GET STRING ADDRESS\n         XR    #7,#7\n         ICM   #7,7,1(#4)          GET STRING LENGTH\n         LR    #6,#7               COMPUTE MAXIMUM LENGTH OF\n         SLA   #6,2                 SLASHIFIED STRING =\n         LA    #6,2(,#6)             (2 * LENGTH) + 2\n         C     #6,ZLCDWALN         IF LENGTH NOT AVAILABLE\n         BNH   SLWALOK             THEN\n         ICM   #1,15,ZLCDWA         GET CURRENT WORKAREA ADDRESS\n         BZ    NOSLFREE             IF NONE, SKIP FREEMAIN\n         L     #0,ZLCDWALN          GET LENGTH OF CURRENT WORKAREA\n         FREEMAIN R,LV=(0),A=(1)    FREE IT\nNOSLFREE DS    0H                  NOW PREPARE TO GET A BIGGER ONE\n         LA    #6,7(,#6)           ROUND UP TO DOUBLEWORD BOUNDARY\n         N     #6,=X'FFFFFFF8'\n         #GETMAIN RC,LV=(#6),LOC=BELOW GET NEW WORKAREA\n         LTR   #15,#15             IF STORAGE NOT AVAILABLE\n         BNZ   ERROR8              THEN ERROR\n         ST    #6,ZLCDWALN         SAVE NEW WORKAREA LENGTH\n         ST    #1,ZLCDWA           SAVE NEW WORKAREA ADDRESS\nSLWALOK  L     #3,ZLCDWA           OK, GET WORKAREA ADDRESS\n         BR    #14\n         EJECT\nRETURN   DS    0H\n*\n* AT THIS POINT #1 POINTS TO THE TEXT TO BE RETURNED, #0 IS ITS LENGTH\n*\n         NI    ZLCDFLGS,255-ZLCDCOPY-ZLCDSLSH  TURN OFF FLAGS\n         LM    #2,#7,ADMPSAVE+24   RESTORE REGISTERS\n         LM    #12,#15,ADMPSAVE    RESTORE REGISTERS\n         BR    #14                 RETURN TO CALLER\n         EJECT\nBAD31MSG DS    0H                  ILLEGAL BIGNUM DETECTED -2**31\n         DMPER ERR2209              SHOULD BE A FIXNUM\n         SPACE 2\nERROR0   DS    0H                  ERROR - A LIST\n         DMPER ERR2200\n         SPACE 2\nERRORV   DS    0H                  ERROR - A VECTOR\n         DMPER ERR2201\n         SPACE 2\nERROR2   DS    0H                  ERROR - NOT ENOUGH MEMORY\n         XR    #0,#0               CLEAR WORK AREA FIELDS\n         ST    #0,ZLCDWA           SO THAT NEXT ATTEMPT GETS NEW W/A\n         ST    #0,ZLCDWALN\n         DMPER ERR2202\n         SPACE 2\nERROR8   DS    0H                  ERROR - NOT ENOUGH MEMORY\n         XR    #0,#0               CLEAR WORK AREA FIELDS\n         ST    #0,ZLCDWA           SO THAT NEXT ATTEMPT GETS NEW W/A\n         ST    #0,ZLCDWALN\n         DMPER ERR2208\n         SPACE 2\nNOMULT4  DS    0H                  BUG - BIGNUM LENGTH IS NOT MULTIPLE\n         DMPER ERR2210             OF 4\n         SPACE 2\nSIZEBAD  DS    0H                  BUG - BIGNUM LENGTH LESS THAN 2\n         DMPER ERR2203\n         SPACE 2\nDIG19ERR DS    0H                  BUG - 1ST DD OF 2WD BIG > 4Q\n         DMPER ERR2204\n         SPACE 2\nBIGBAD   DS    0H                  BUG - WORD OTHER THAN LSW NOT +\n         DMPER ERR2205\n         SPACE 2\nBADZERO  DS    0H                  BUG - WORD OTHER THAN LSW NOT +\n         DMPER ERR2206\n         SPACE 2\nFLOBARF  DS    0H                  BUG - FLONUM FRACTIONAL PART BAD\n         DMPER ERR2211\n         SPACE 2\nSIGNALER DS    0H\n         TM    ZLCPFLGS,ZLCPRINT   IF CALLED BY ZILPRIN\n         BZ    ZERROR              THEN...\n         #TPUT 2,(1),(0)            DISPLAY ERROR MESSAGE\n         LA    #1,DUMPERR           POINT TO ERROR-OBJECT IDENTIFIER\n         LA    #0,L'DUMPERR         SET LENGTH\n         B     RETURN               RETURN WITH UNKNOWN OBJECT\nZERROR   L     #15,ZLCERR          ELSE ERROR OUT\n         BR    #15                 BY BRANCHING TO ZILERR\n         SPACE 2\nADMPSAVE DS    12A                 SAVE AREA FOR REGISTERS\n         SPACE\nATOMAREA DS    CL64                AREA TO DUMP NON-STRING ATOMS\n         SPACE\nDUMPUNK  DC    C'#<?>'             HOW TO DUMP UNKNOWN ATOMS\nDUMPERR  DC    C'#<ERROR>'         HOW TO DUMP ERRORS\n         SPACE\nPATTERN  DC    X'F02020202020202020202020'  PATTERN MASK FOR EDITS\nNUMAREA  DS    CL12                TEMP TO HOLD CONVERTED NUMBER\nDNUMAREA DS    CL40                Temp to hold converted doubles\n         SPACE\nDWORK    DS    D                   Area for double float conversions\n         SPACE\nSYMTR0   DC    256YL1(0)           TABLE TO SCAN FOR SLASHIFIABILITY\n         ORG   SYMTR0+C' '\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C','\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'`'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'|'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'#'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'('\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C')'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'\\'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C';'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'\"'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C''''\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'\u00a2'\n         DC    YL1(1)              INVALID - MUST BE SLASHED\n*\n* The following 2 table entries are to be activated when\n* packages and rationals (respectively) are implemented.\n*\n*        ORG   SYMTR0+C':'         (for packages)\n*        DC    YL1(1)              INVALID - MUST BE SLASHED\n*        ORG   SYMTR0+C'/'         (for rationals)\n*        DC    YL1(1)              INVALID - MUST BE SLASHED\n*\n         ORG   SYMTR0+C'A'-X'40'\n         DC    9YL1(1)             INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'J'-X'40'\n         DC    9YL1(1)             INVALID - MUST BE SLASHED\n         ORG   SYMTR0+C'S'-X'40'\n         DC    8YL1(1)             INVALID - MUST BE SLASHED\n         ORG\n         SPACE\nSYMTR1   DC    256YL1(0)           TRANSLATE TABLE TO SCAN FOR FIRST CH\n         ORG   SYMTR1+C'+'\n         DC    1YL1(1)             BEGINS WITH PLUS SIGN - SUSPICIOUS\n         ORG   SYMTR1+C'-'\n         DC    1YL1(1)             BEGINS WITH MINUS SIGN - SUSPICIOUS\n         ORG   SYMTR1+C'.'\n         DC    1YL1(1)             BEGINS WITH PERIOD - SUSPICIOUS\n         ORG   SYMTR1+C'$'\n         DC    1YL1(1)             BEGINS WITH DOLLAR SIGN - SUSPICIOUS\n         ORG   SYMTR1+C'0'\n         DC    10YL1(1)            BEGINS WITH NUMERIC - SUSPICIOUS\n         ORG\n         SPACE\nBADTWO31 DC    YL1(##BIGNUM),AL3(8),X'80000000',F'1'\n         SPACE\nFRMASK   DS    0F\n         DC    X'00000000'         40xxxxxx\n         DC    X'0000000F'         3Fxxxxx0\n         DC    X'000000FF'         3Exxxx00\n         DC    X'00000FFF'         3Dxxx000\n         DC    X'0000FFFF'         3Cxx0000\n         DC    X'000FFFFF'         3Bx00000\n         SPACE 1\nDFRMASK  DS    0F\n         DC    X'0000000000000000' 40xxxxxx xxxxxxxx\n         DC    X'000000000000000F' 3Fxxxxxx xxxxxxx0\n         DC    X'00000000000000FF' 3Exxxxxx xxxxxx00\n         DC    X'0000000000000FFF' 3Dxxxxxx xxxxx000\n         DC    X'000000000000FFFF' 3Cxxxxxx xxxx0000\n         DC    X'00000000000FFFFF' 3Bxxxxxx xxx00000\n         DC    X'0000000000FFFFFF' 3Axxxxxx xx000000\n         DC    X'000000000FFFFFFF' 39xxxxxx x0000000\n         DC    X'00000000FFFFFFFF' 38xxxxxx 00000000\n         DC    X'0000000FFFFFFFFF' 37xxxxx0 00000000\n         DC    X'000000FFFFFFFFFF' 36xxxx00 00000000\n         DC    X'00000FFFFFFFFFFF' 35xxx000 00000000\n         DC    X'0000FFFFFFFFFFFF' 34xx0000 00000000\n         DC    X'000FFFFFFFFFFFFF' 33x00000 00000000\n         SPACE 1\n         LTORG\n         SPACE 1\nERR2200  DC    C'ZIL2200 ZILADMP: OBJECT TO BE DUMPED IS A LIST, NOT ANX\n                ATOM.'\nERR2201  DC    C'ZIL2201 ZILADMP: OBJECT TO BE DUMPED IS A VECTOR, FUNAX\n               RG (LEXICAL CLOSURE) OR STRUCTURE.'\nERR2202  DC    C'ZIL2202 ZILADMP: NOT ENOUGH MEMORY TO DUMP BIGNUM.'\nERR2203  DC    C'ZIL2203 ZILADMP: BIGNUM LENGTH LESS THAN 2 WORDS.'\nERR2204  DC    C'ZIL2204 ZILADMP: SEVERE LOSSAGE IN 2-WORD BIGNUM CODE.X\n               '\nERR2205  DC    C'ZIL2205 ZILADMP: A WORD OTHER THAN THE LEAST SIGNIFICAX\n               NT WORD OF A BIGNUM IS NEGATIVE.'\nERR2206  DC    C'ZIL2206 ZILADMP: THE MOST SIGNIFICANT WORD OF A BIGNUMX\n                IS ZERO (I.E. NOT NORMALIZED).'\nERR2208  DC    C'ZIL2208 ZILADMP: NOT ENOUGH MEMORY TO DUMP STRING TEXTX\n               .'\nERR2209  DC    C'ZIL2209 ZILADMP: THE MOST NEGATIVE FIXNUM, -2**31, WASX\n                REPRESENTED AS A BIGNUM - SERIOUS BUG, PLEASE REPORT.'\nERR2210  DC    C'ZIL2210 ZILADMP: BIGNUM LENGTH NOT A MULTIPLE OF 4.'\nERR2211  DC    C'ZIL2211 ZILADMP: INTERNAL ERROR FORMATTING FLONUM.'\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILBIG": {"ttr": 10246, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11Q\\x00l\\x00i\\x00k\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:51:00", "lines": 108, "newlines": 105, "modlines": 107, "user": "SEB1525"}, "text": "         TITLE 'ZILBIG - ZIL 1.3 BIGNUM ALLOCATION ROUTINES'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE HANDLES REQUESTS FROM ASSEMBLER LANGUAGE PROGRAMS   *\n* FOR BIGNUM SPACE.                                                   *\n*                                                                     *\n* THIS ROUTINE PERFORMS THE FOLLOWING FUNCTIONS:                      *\n*                                                                     *\n*  INSURES THAT SUFFICIENT SPACE IS PRESENT IN VECTOR/STRING SPACE.   *\n*  IF NOT, FORCES A GARBAGE COLLECTION AND RECHECKS.                  *\n*                                                                     *\n*  MINIMALLY FORMATS THE SPACE WITH TYPE BITS ONLY.                   *\n*                                                                     *\n*  THIS ROUTINE DOES NOT FILL IN ANY OF THE REST OF THE BIGNUM AREA,  *\n*  NOR DOES IT UPDATE THE END-OF-USED-VSS POINTER.  IT IS THE         *\n*  RESPONSIBILITY OF THE CALLER TO FILL IN THE LENGTH AND SET THE     *\n*  \"ZLCVSNXT\" FIELD AS SOON AS THE TRUE LENGTH IS KNOWN.  THIS ALSO   *\n*  GIVES THE CALLER THE OPPORTUNITY OF USING THE BIGNUM AREA AS A     *\n*  TEMPORARY WORK AREA WHICH WILL NEVER BECOME A PERMANENT OBJECT.    *\n*                                                                     *\n*  THIS ROUTINE WILL SIGNAL AN ERROR IF NO SPACE IS AVAILABLE TO      *\n*  BUILD THE BIGNUM.  FOR SPEED, NO VALIDITY CHECKING OF THE INPUT    *\n*  IS DONE.                                                           *\n*                                                                     *\n*  ON ENTRY:                                                          *\n*                                                                     *\n*  REGISTER 0 POINTS TO THE CURRENT STACK LOCATION.                   *\n*  REGISTER 1 IS NOT USED.                                            *\n*  REGISTER 2 CONTAINS THE LENGTH IN BYTES OF THE BIGNUM SPACE.       *\n*             THAT INCLUDES THE 4-BYTE HEADER!!!                      *\n*             THIS FIGURE MUST ALLOW FOR THE MAXIMUM POSSIBLE SPACE   *\n*             THAT THE BIGNUM MAY OCCUPY (THERE IS NO \"SLUSH FUND\").  *\n*                                                                     *\n*  REGISTERS 14 AND 15 HAVE THEIR STEREOTYPICAL VALUES ON ENTRY.      *\n*                                                                     *\n*  ON RETURN:                                                         *\n*                                                                     *\n*  REGISTER 15 POINTS TO THE HEADER OF THE BIGNUM OBJECT, WHICH HAS   *\n*              THE BIGNUM TYPE BITS SET AND NOTHING ELSE.             *\n*                                                                     *\n*  THIS ROUTINE CLOBBERS REGISTERS 1 AND 4.  HOWEVER, REGISTERS       *\n*  0 AND 2 ARE THE SAME UPON RETURN.                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILBIG   CSECT\n         SPACE 1\n         LR    #4,#15\n         USING ZILBIG,#4\n         USING ZLCOMMON,#13\n         SPACE 1\nRETRY    DS    0H\n         L     #1,ZLCVSADR         GET ADDRESS OF V/S SPACE\n         L     #15,ZLCVSNXT        GET ADDRESS OF AVAILABLE SLOT\n         A     #1,ZLCVSLEN         ADD LENGTH TO POINT TO END OF SPACE\n         SR    #1,#15              GET LENGTH OF SPACE NOW AVAILABLE\n         CR    #2,#1               IF SPACE REQUESTED IS LARGER\n         BH    ZBIGGC              THEN GO TO GC AND RETRY. ELSE\nDOIT     DS    0H\n         MVI   0(#15),##BIGNUM     SET TYPE BITS = BIGNUM\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nZBIGGC   DS    0H                  HERE IF NO ROOM FOR OBJECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS EXECUTED WHEN THERE ISN'T ENOUGH ROOM TO            *\n* PERFORM THE REQUESTED OPERATION AND A GARBAGE COLLECTION IS TO      *\n* BE ATTEMPTED SO THAT ENOUGH ROOM WILL BE AVAILABLE.                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #9,ZLCGCEND         FORCE END OF FREE LIST\n*\n* NOW DO SOME DUMMY CONS TO FORCE A GARBAGE COLLECTION TO OCCUR.\n*\n         STM   #14,#2,ZBIGSAVE     SAVE VOLATILE REGS\n         LR    #1,#10              SET CONS ARG 1 TO NIL (CAR-TO-BE)\n         LR    #2,#10              SET CONS ARG 1 TO NIL (CAR-TO-BE)\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS TO DO GARBAGE COLLECTION\n         LM    #14,#2,ZBIGSAVE     RESTORE VOLATILE REGS\n*\n* START OVER...\n*\n         L     #1,ZLCVSADR         GET ADDRESS OF V/S SPACE\n         L     #15,ZLCVSNXT        GET ADDRESS OF AVAILABLE SLOT\n         A     #1,ZLCVSLEN         ADD LENGTH TO POINT TO END OF SPACE\n         SR    #1,#15              GET LENGTH OF SPACE NOW AVAILABLE\n         CR    #2,#1               IF SPACE REQUESTED IS LARGER\n         BNH   DOIT                THEN FAIL. ELSE WE GOT IT, GO TO IT\n         SPACE 1\n         #ERR  'ZIL3101 ZILBIG: No vector/string space available for biX\n               gnum.',PREFIX=NO\n         SPACE 1\nZBIGSAVE DS    5A                  SAVE REGS ACROSS GC\n         SPACE 1\n         LTORG\n         SPACE 1\n         #ZEQU ,\n         SPACE 1\n         #ZCOM ,\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILBOOL": {"ttr": 10249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11Q\\x00\\xab\\x00\\xa8\\x00\\xaa\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:51:00", "lines": 171, "newlines": 168, "modlines": 170, "user": "SEB1525"}, "text": "         TITLE 'ZILBOOL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*\n* ZILBOOL TAKES 3 INTEGER ARGUMENTS. CURRENTLY THEY MUST BE FIXNUMS.\n*\n***********************************************************************\nZILBOOL  #ZBEG MINARGS=3,MAXARGS=3,NAME='ZILBOOL'\n         #ZPDS 3*4+12+0 (= 24)     DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #5,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#5),##FIXNUM FIRST ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#6),##FIXNUM SECOND ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR2\n         CLI   ##TYPE(#7),##FIXNUM THIRD ARGUMENT MUST BE A FIXNUM\n         BNE   ERROR3\n         ICM   #14,15,##CDR(#5)    GET VALUE OF ARG1\n         BM    ERROR1              IF LESS THAN ZERO, ERROR\n         CH    #14,=H'15'          IF GREATER THAN 15, ERROR\n         BH    ERROR1\n         SLA   #14,2               CONVERT TO BRANCH INDEX\n         B     GO(#14)\nGO       DS    0H\n         B     BOOLE0\n         B     BOOLE1\n         B     BOOLE2\n         B     BOOLE3\n         B     BOOLE4\n         B     BOOLE5\n         B     BOOLE6\n         B     BOOLE7\n         B     BOOLE8\n         B     BOOLE9\n         B     BOOLE10\n         B     BOOLE11\n         B     BOOLE12\n         B     BOOLE13\n         B     BOOLE14\n         B     BOOLE15\n         EJECT\nBOOLE0   DS    0H                  (BOOLE 0 X Y) = 0\n         SPACE 1\n         LA    #15,#SFT0            RETURN CONSTANT FIXNUM ZERO\n         B     RETURN\n         SPACE 1\nBOOLE1   DS    0H                  (BOOLE 1 X Y) = (LOGAND X Y)\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         N     #2,##CDR(,#7)       DO LOGICAL AND WITH VALUE 2\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE2   DS    0H                  (BOOLE 2 X Y) =\n*                                   (LOGAND (LOGNOT X) Y)\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         X     #2,NOT              DO LOGICAL NOT OF VALUE 1\n         N     #2,##CDR(,#7)       DO LOGICAL AND WITH VALUE 2\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE3   DS    0H                  (BOOLE 3 X Y) = Y\n         SPACE 1\n         LR    #15,#7              GET ARG 2\n         B     RETURN\n         SPACE 1\nBOOLE4   DS    0H                  (BOOLE 4 X Y) =\n*                                   (LOGAND X (LOGNOT Y))\n         SPACE 1\n         L     #2,##CDR(,#7)       GET VALUE 2\n         X     #2,NOT              DO LOGICAL NOT OF VALUE 2\n         N     #2,##CDR(,#6)       DO LOGICAL AND WITH VALUE 1\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE5   DS    0H                  (BOOLE 5 X Y) = X\n         SPACE 1\n         LR    #15,#6              GET ARG 1\n         B     RETURN\n         SPACE 1\nBOOLE6   DS    0H                  (BOOLE 6 X Y) = (LOGXOR X Y)\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         X     #2,##CDR(,#7)       DO LOGICAL XOR WITH VALUE 2\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE7   DS    0H                  (BOOLE 7 X Y) = (LOGIOR X Y)\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         O     #2,##CDR(,#7)       DO LOGICAL OR WITH VALUE 2\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE8   DS    0H                  (BOOLE 8 X Y) =\n*                                   (LOGNOT (LOGIOR X Y))\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         O     #2,##CDR(,#7)       DO LOGICAL OR WITH VALUE 2\n         X     #2,NOT              DO LOGICAL NOT\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE9   DS    0H                  (BOOLE 9 X Y) =\n*                                   (LOGNOT (LOGXOR X Y))\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         X     #2,##CDR(,#7)       DO LOGICAL XOR WITH VALUE 2\n         X     #2,NOT              DO LOGICAL NOT\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE10  DS    0H                  (BOOLE 10 X Y) = (LOGNOT X)\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         X     #2,NOT              DO LOGICAL NOT\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE11  DS    0H                  (BOOLE 11 X Y) =\n*                                   (LOGIOR (LOGNOT X) Y)\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         X     #2,NOT              DO LOGICAL NOT OF VALUE 1\n         O     #2,##CDR(,#7)       DO LOGICAL OR WITH VALUE 2\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE12  DS    0H                  (BOOLE 12 X Y) = (LOGNOT Y)\n         SPACE 1\n         L     #2,##CDR(,#7)       GET VALUE 2\n         X     #2,NOT              DO LOGICAL NOT\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE13  DS    0H                  (BOOLE 13 X Y) =\n*                                   (LOGIOR X (LOGNOT Y))\n         SPACE 1\n         L     #2,##CDR(,#7)       GET VALUE 2\n         X     #2,NOT              DO LOGICAL NOT\n         O     #2,##CDR(,#6)       DO LOGICAL OR WITH VALUE 1\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE14  DS    0H                  (BOOLE 14 X Y) =\n*                                   (LOGNOT (LOGAND X Y))\n         SPACE 1\n         L     #2,##CDR(,#6)       GET VALUE 1\n         N     #2,##CDR(,#7)       DO LOGICAL AND WITH VALUE 2\n         X     #2,NOT              DO LOGICAL NOT\n         B     MAKEIT              GO MAKE A FIXNUM\n         SPACE 1\nBOOLE15  DS    0H                  (BOOLE 15 X Y) = -1\n         SPACE 1\n         LA    #15,#SFTM1          RETURN CONSTANT FIXNUM -1\n         B     RETURN\n         SPACE 1\n         EJECT\nMAKEIT   DS    0H                  OK, #2 CONTAINS RESULT TO RETURN\n         SPACE 1\n         LA    #0,24(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nNOT      EQU   #SFWM1              HEX FFFFFFFF\n         SPACE 1\nERROR1   #ERR  'Argument 1 to ZILBOOL not a fixnum between 0 and 15 - 'X\n               ,(#5)\nERROR2   #ERR  'Argument 2 to ZILBOOL not a fixnum - ',(#6)\nERROR3   #ERR  'Argument 3 to ZILBOOL not a fixnum - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILCLOSE": {"ttr": 10253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11Q\\x00\\xce\\x00\\xc5\\x00\\xcd\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:51:00", "lines": 206, "newlines": 197, "modlines": 205, "user": "SEB1525"}, "text": "         TITLE 'ZILCLOSE - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILCLOSE TAKES TWO ARGUMENTS - (1) FILE NAME, (2) FIXNUM-MODE.      *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         SPACE 1\nZILCLOSE #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILCLOSE'\n         #ZPDS 2*4+12              DEFINE STACK SIZE\n         #ZSAV ARGS=2              SAVE REGISTERS\n         SPACE 1\n         LM    #2,#3,0(#11)        LOAD ARGUMENTS\n         TM    ##CDR+##MODEB3(#3),##OUTPUT  If output mode\n         BO    SETOUT              then go to close output file\n******** BZ    SETIN               else go to close input file\n         SPACE 1\nSETIN    DS    0H                  INDICATE INPUT MODE\n         MVI   DDCHAR,C'I'         SET FILE NAME TO ZILI....\n         L     #7,ZLCIFBAD         START SEARCHING INPUT FILE CHAIN\n         B     CHKFILE\nSETOUT   DS    0H                  INDICATE OUTPUT MODE\n         MVI   DDCHAR,C'O'         SET FILE NAME TO ZILO....\n         L     #7,ZLCOFBAD         START SEARCHING INPUT FILE CHAIN\n******** B     CHKFILE\n         EJECT\nCHKFILE  DS    0H\n*\n* GET THE FILE NAME.\n*\n         CR    #2,#10              IF FILE NAME IS NIL\n         BE    NILERROR            THEN ERROR - CANNOT CLOSE NIL\n         CR    #2,#8               IF FILE NAME IS T\n         BE    NILERROR            THEN ERROR - CANNOT CLOSE T\n         SPACE 1\nNOTNIL   DS    0H\n         CLI   ##TYPE(#2),##SYMBOL IF NOT A SYMBOL\n         BNE   INVALID             THEN ERROR - INVALID ARGUMENT\n         XR    #4,#4               CLEAR PREVIOUS-FILE-BLOCK POINTER\n*\n* GET THE FILE BLOCK TO CLOSE (RETURNED IN #7).\n*\n         USING ZLFILBLK,#7\nFILLOOP  DS    0H\n         LTR   #7,#7               IF AT END OF FILE BLOCK CHAIN\n         BZ    NOTFOUND            THEN FILE DOES NOT EXIST\n         C     #2,ZLFATOM          IF FILE ATOMS ARE EQ\n         BE    GOTIT               THEN THIS IS THE ONE\n         LR    #4,#7               ELSE SAVE ADDR OF PREV FILE BLOCK\n         L     #7,ZLFCHAIN         GET NEXT FILE BLOCK\n         B     FILLOOP             AND CONTINUE\n         SPACE 1\nGOTIT    DS    0H                  #7 -> FILE, #4 -> PREV\n         EJECT\n*\n* CLOSE THE FILE.\n*\n         TM    ZLFFLAG1,ZLFTERM    IF IT'S A TERMINAL FILE\n         BO    NOCLOSE             THEN DON'T ISSUE CLOSE\n         TM    ZLFFLAG2,ZLFOPEN    IF IT'S NOT OPEN (SOMEHOW?)\n         BZ    NOCLOSE             THEN DON'T ISSUE CLOSE\n         LA    #1,ZLFDCB           GET ADDRESS OF DCB FOR FILE\n         TM    X'30'(#1),X'10'     IF DCB OPEN BIT IS NOT ON\n         BZ    NOCLOSE             THEN DON'T ISSUE CLOSE\n         ST    #1,CLOSEL           STORE ADDRESS OF DCB\n         MVI   CLOSEL,X'80'        IN CLOSE PARAMETER LIST\n         SPACE 1\n         CLI   DDCHAR,C'O'         IF AN OUTPUT FILE\n         BNE   AFTUNPUT            THEN...\n*\n* IF THERE IS ANY DATA PRINTED TO THE CURRENT LINE THAT HAS NOT BEEN\n* SENT TO THE DATA SET BY TERPRI, WRITE OUT THE LINE NOW.\n* OTHERWISE BUMP BACK THE DCB POINTER, A LA COBOL, SO THAT A LINE\n* OF GARBAGE DOESN'T GET WRITTEN OUT.\n*\n* NOTE: THIS DOESN'T WORK FOR RECFM=V FILES - AT LEAST I HAVEN'T\n* FIGURED OUT HOW TO MAKE IT WORK.  SO WE LET THE LAST RECORD\n* (HOPEFULLY A NULL RECORD) GET WRITTEN OUT IN THAT CASE.\n*\n         TM    ZLFFLAG1,ZLFNEWLN   IF NO UNPROCESSED OUTPUT DATA\n         BO    NOUNPUT              AND\n         TM    ZLFFLAG2,ZLFRECV      THIS IS A RECFM=F FILE\n         BO    AFTUNPUT               THEN\n         L     #1,ZLFDCB+76          TAKE CURRENT RECORD POINTER\n         SH    #1,ZLFDCB+82          SUBTRACT ONE LRECL\n         ST    #1,ZLFDCB+76          RESET CURRENT RECORD POINTER\n         B     AFTUNPUT             ELSE\nNOUNPUT  DS    0H                  THERE IS UNPROCESSED OUTPUT DATA\n         TM    ZLFFLAG2,ZLFRECV    IF THIS IS A RECFM=V FILE\n         BZ    AFTUNPUT            THEN\n         L     #1,ZLFCARD           GET ADDRESS OF START OF RECORD\n         SH    #1,=H'4'             BUMP BACK TO RDW\n         L     #2,ZLFCHAR           GET CURRENT CHARACTER POINTER\n         LA    #2,4-1(,#2)          ADJUST BY 1, ADD 4 TO INCLUDE RDW\n         SLL   #2,16                SHIFT LENGTH INTO LEFT HALF\n         ST    #2,0(,#1)            STORE THE RDW\nAFTUNPUT DS    0H\n         SPACE 1\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,CODE24           ADDRESS OF THIS CODE\n         LA    #2,CODE24E          RETURN ADDRESS\n         BSM   #2,#1\nCODE24   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n         SPACE 1\n         LA    #1,CLOSEL\n         CLOSE MF=(E,(1))          CLOSE THE FILE\n*\n* FOR LIBRARY FILE, INSTEAD OF FREEPOOL FREE THE READ BUFFER.\n* THAT IS, WHEN WE HAVE SUPPORT FOR LIBRARY FILES.\n*\n         LA    #1,ZLFDCB\n         FREEPOOL (1)\n         SPACE 1\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nCODE24E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\nNOCLOSE  DS    0H\n         EJECT\n*\n* NOW UNCHAIN AND FREE THIS FILE BLOCK\n*\n         NI    ZLFFLAG2,255-ZLFOPEN MARK FILE NOT OPEN\n         ICM   #2,15,ZLFECHO       GET POINTER TO ECHO FILE BLOCK\n         BZ    NOECHO              IF THERE IS ONE, THEN...\n         LH    #0,ZLFECCNT-ZLFILBLK(,#2)\n         BCTR  #0,0                 DECREMENT ITS ECHO REFERENCE COUNT\n         STH   #0,ZLFECCNT-ZLFILBLK(,#2)\nNOECHO   DS    0H\n         ICM   #0,B'0011',ZLFECCNT IF ECHO REFERENCE COUNT NONZERO\n         BNZ   NOFREE              THEN DON'T FREE THIS FILE BLOCK\n*\n* MOVE FILE CHAIN POINTER TO PREVIOUS FILE BLOCK TO CONNECT THEM\n*\n         L     #2,ZLFCHAIN         GET CURRENT CHAIN POINTER\n         LTR   #4,#4               IF THIS WAS 1ST FILE IN CHAIN\n         BNZ   RECHAIN             THEN...\n         CLI   DDCHAR,C'I'          IF THIS IS AN INPUT FILE\n         BNE   CHNOTIN              THEN...\n         ST    #2,ZLCIFBAD           UPDATE FILE BLOCK CHAIN HEADER\n         L     #4,ZLCSTDIN           POINT TO STANDARD INPUT BLOCK\n         L     #6,ZLCIFTRM           POINT TO \"TRUE\" TERMINAL FILBLK\n         B     RECHAIN              ELSE...\nCHNOTIN  DS    0H                   (THIS IS AN OUTPUT FILE)...\n         ST    #2,ZLCOFBAD           UPDATE FILE BLOCK CHAIN HEADER\n         L     #4,ZLCSTDOU           POINT TO STANDARD INPUT BLOCK\n         L     #6,ZLCOFTRM           POINT TO \"TRUE\" TERMINAL FILBLK\nRECHAIN  DS    0H\n         ST    #2,ZLFCHAIN-ZLFILBLK(,#4) CONNECT NEXT TO PREVIOUS\n         LR    #1,#7               GET ADDR OF FILE BLOCK TO BE FREED\n         CR    #1,#6               IF THIS IS THE \"REAL\" TERM FIL BLK\n         BE    NOFREE              THEN DON'T FREE IT\n         LH    #0,ZLCFBLEN         GET LENGTH OF FILE BLOCK\n         FREEMAIN R,LV=(0),A=(1)   FREE THE FILE BLOCK\nNOFREE   DS    0H\n         SPACE 1\n         LR    #15,#10             RETURN NIL\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nNILERROR DS    0H\n         SPACE 1\n         #ERR  'ZIL0022 CLOSE: File is not closable - ',0(#11),PREFIX=NX\n               O\n         SPACE 1\nINVALID  DS    0H\n         SPACE 1\n         #ERR  'ZIL0009 CLOSE: File name not a 1-4 character symbol - 'X\n               ,0(#11),PREFIX=NO\n         SPACE 1\nNOTFOUND DS    0H\n         SPACE 1\n         CLI   DDCHAR,C'I'\n         BNE   ERRNOTCI\n         LA    #2,$INPUT\n         B     ERR23\nERRNOTCI LA    #2,$OUTPUT\nERR23    #ERR  'ZIL0023 CLOSE: Not a currently open ',                 X\n               (#2),                                                   X\n               ' file - ',                                             X\n               0(#11),                                                 X\n               PREFIX=NO\n         DS    0H,XL1              Align string to non-halfword\n$INPUT   #SATM 'input'\n         DS    0H,XL1              Align string to non-halfword\n$OUTPUT  #SATM 'output'\n         EJECT\nDDCHAR   DC    C' '                I (FOR INPUT), OR O (FOR OUTPUT)\n         SPACE 2\nCLOSEL   CLOSE (*-*),MF=L          LIST FORM FOR CLOSE\n         EJECT\n         LTORG\n         EJECT\n         #ZMODES ,                 Equate OPEN/CLOSE file modes\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILCONS": {"ttr": 10500, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00%\\x00\\x88\\x01_\\x01\\x00&_\\x16E\\x08\\xd3\\x08\\xba\\x08\\xd2\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:45:25", "lines": 2259, "newlines": 2234, "modlines": 2258, "user": "SEB1525"}, "text": "         TITLE 'ZILCONS (ZIL 1.3) - CONS PLUS GARBAGE COLLECTOR'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 02/10/90 - SEB1525 - Fixed bug when lots of memory asked for.       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SOURCE MODULE CONTAINS CONDITIONAL ASSEMBLY CODE WHICH         *\n* UTILIZES THE IBM SYSTEM/370 VECTOR FACILITY FOR ENHANCED            *\n* PERFORMANCE.  SUCH CODE IS ACTIVATED VIA INVOCATION OF THE          *\n* ASSEMBLER WITH THE FOLLOWING SPECIFIED:                             *\n*                                                                     *\n* 'SYSPARM(VECTOR)'                                                   *\n*                                                                     *\n***********************************************************************\n         TITLE 'ZILCONS (ZIL 1.3) - INTERNAL MACROS'\n         MACRO\n&SYM     MARK  &REG\n.*\n.* THIS MACRO SETS THE GARBAGE COLLECTION MARK ON IN THE CELL POINTED\n.* TO BY THE SPECIFIED REGISTER.\n.*\n&SYM     OI    3(&REG),B'00000001'  SET GARBAGE COLLECTION MARK\n         MEND\n         EJECT\n         MACRO\n&SYM     MARK2 &REG\n.*\n.* THIS MACRO SETS THE TEMPORARY COLLECTION MARK ON IN THE CELL POINTED\n.* TO BY THE SPECIFIED REGISTER.  THIS IS USED IN THE POINTER-REVERSAL\n.* ALGORITHM TO PREVENT DOUBLE SCANNING OF CIRCULAR AND STRANGE LISTS.\n.*\n&SYM     OI    3(&REG),B'00000010'  SET TEMP COLLECTION MARK\n         MEND\n         EJECT\n         MACRO\n&SYM     UNMK  &REG\n.*\n.* THIS MACRO SETS THE GARBAGE COLLECTION MARKS OFF IN THE CELL POINTED\n.* TO BY THE SPECIFIED REGISTER.\n.*\n&SYM     NI    3(&REG),B'11111100'  SET GARBAGE COLLECTION MARKS OFF\n         MEND\n         EJECT\n         MACRO\n&SYM     IFMK1 &REG,&YES=,&NO=\n.*\n.* THIS MACRO TESTS ONE GARBAGE COLLECTION MARK IN THE CELL POINTED\n.* TO BY THE SPECIFIED REGISTER.\n.* IT IS USED ONLY IN THE POINTER-REVERSAL ALGORITHM WHEN CLIMBING\n.* BACK UP A CHAIN OF REVERSED POINTERS.\n.*\n&SYM     TM    3(&REG),B'00000001'  TEST GARBAGE COLLECTION MARK\n         AIF   ('&YES' EQ '').NOYES\n         BO    &YES                 IF MARKED, BRANCH TO LABEL\n         MEXIT\n.NOYES   ANOP\n         BZ    &NO                  IF NOT MARKED, BRANCH TO LABEL\n         MEND\n         EJECT\n         MACRO\n&SYM     IFMK  &REG,&YES=,&NO=\n.*\n.* THIS MACRO TESTS TWO GARBAGE COLLECTION MARKS IN THE CELL POINTED\n.* TO BY THE SPECIFIED REGISTER.\n.*\n&SYM     TM    3(&REG),B'00000011'  TEST GARBAGE COLLECTION MARKS\n         AIF   ('&YES' EQ '').NOYES\n         BNZ   &YES                 IF MARKED, BRANCH TO LABEL\n         MEXIT\n.NOYES   ANOP\n         BZ    &NO                  IF NOT MARKED, BRANCH TO LABEL\n         MEND\n         EJECT\n         MACRO\n&SYM     GCDR  &VALREG,&CONSREG\n.*\n.* THIS MACRO LOADS THE FIRST SPECIFIED REGISTER WITH THE CONTENTS OF\n.* THE \"CDR\" FIELD OF THE SECOND SPECIFIED REGISTER.\n.*\n&SYM     L     &VALREG,##CDR(,&CONSREG)     (SETQ REG1 (CDR REG2))\n         MEND\n         EJECT\n         MACRO\n&SYM     GCAR  &VALREG,&CONSREG\n.*\n.* THIS MACRO LOADS THE FIRST SPECIFIED REGISTER WITH THE CONTENTS OF\n.* THE \"CAR\" FIELD OF THE SECOND SPECIFIED REGISTER.\n.*\n.* NOTE THAT THIS IS NOT A SIMPLE LOAD OPERATION.  THE \"CAR\" FIELD\n.* MAY HAVE HAD GARBAGE COLLECTION MARKS SET IN IT, AND THEREFORE\n.* WE MUST \"AND\" OUT THE MARKS TO PRESERVE A VALID ADDRESS.\n.*\n&SYM     L     &VALREG,##CAR(,&CONSREG)     (SETQ REG1 (CAR REG2))\n         N     &VALREG,=X'FFFFFFFC'         REMOVE GC MARK IF ANY\n         MEND\n         MACRO\n&SYM     RCDR  &CONSREG,&VALREG\n.*\n.* THIS MACRO DOES A \"RPLACD\" OPERATION.  THE CONTENTS OF THE SECOND\n.* SPECIFIED REGISTER ARE STORED INTO THE \"CDR\" FIELD OF THE CELL\n.* POINTED TO BY THE FIRST SPECIFIED REGISTER.\n.*\n&SYM     ST    &VALREG,##CDR(,&CONSREG)      (RPLACD REG1 REG2)\n         MEND\n         EJECT\n         MACRO\n&SYM     RCAR  &CONSREG,&VALREG\n.*\n.* THIS MACRO DOES A \"RPLACA\" OPERATION.  THE CONTENTS OF THE SECOND\n.* SPECIFIED REGISTER ARE STORED INTO THE \"CAR\" FIELD OF THE CELL\n.* POINTED TO BY THE FIRST SPECIFIED REGISTER.\n.*\n.* NOTE THAT THIS IS NOT A SIMPLE STORE OPERATION.  THE \"CAR\" FIELD\n.* MAY HAVE HAD GARBAGE COLLECTION MARKS SET IN IT, AND THEREFORE\n.* WE MUST SET THE FIELD IN SUCH A WAY THAT THESE MARKS ARE PRESERVED.\n.*\n.* NOTE USE OF REGISTER 0 AS A WORK REGISTER.\n.*\n&SYM     LA    #0,3\n         N     #0,##CAR(,&CONSREG)   GET GC MARKS INTO REG\n         OR    #0,&VALREG            COMBINE WITH ARGUMENT REG\n         ST    #0,##CAR(,&CONSREG)   (RPLACA REG1 REG2)\n         MEND\n         EJECT\n         MACRO\n&SYM     RCHK  &REG,&LBL\n.*\n.* THIS MACRO IMPLEMENTS A \"RANGE CHECK\" TO SEE IF THE CELL POINTED\n.* TO BY THE SPECIFIED REGISTER LIES WITHIN CONS SPACE (THE FREE LIST).\n.* IF IT DOES NOT (MEANING THAT IT MAY NOT BE MARKED), A BRANCH TO\n.* THE SPECIFIED LABEL IS DONE.  THE LABEL MAY BE A PARENTHESIZED\n.* REGISTER NUMBER, IN WHICH CASE A BRANCH TO THE ADDRESS IN THE\n.* REGISTER IS EFFECTED.\n.*\n.* 11/84 - CHECKING IS NOW DONE TO VERIFY THAT THE REGISTER\n.* REFERENCES A CELL ON A DOUBLEWORD BOUNDARY.  THE READ FUNCTION\n.* PUTS SUCH NON-ALIGNED QUANTITIES ON THE STACK.\n.* THIS IS IMPORTANT IF THE ARCHITECTURE LEAVES OPEN THE RISK\n.* OF NUMERIC QUANTITIES WHICH MAY FALL INTO THE CONS SPACE RANGE.\n.*\n.* 07/85 - THAT CHECKING HAS BEEN TAKEN OUT, SINCE WE CAN'T\n.* GUARANTEE A SIMILAR CONSISTENCY FOR POINTERS INTO VECTOR/STRING\n.* SPACE.  INSTEAD, ALL ZIL CODE MUST PROMISE NOT TO PUT VALUES ON\n.* THE STACK THAT ARE EITHER ABSOLUTE NUMERIC VALUES OR POINTERS\n.* INTO ONE OF THE GCABLE SPACES THAT DON'T POINT TO THE BEGINNING\n.* OF AN OBJECT.  THE ONLY CULPRIT WAS \"READ\", AND WE FIXED HIM.\n.*\n.* IN ANY CASE, THIS MACRO NOW GENERATES A BAL TO THE ROUTINE THAT\n.* DOES THE CHECKING FOR BOTH SPACES, AND DOES A RELOCATION PLUS\n.* FORWARDING IF THE OBJECT ACTUALLY IS IN VECTOR/STRING SPACE.\n.*\n         AIF   ('&REG' EQ '#0' OR '&REG' EQ '0').SKIPLR\n         LR    #0,&REG               GET OBJECT TO BE TESTED\n.SKIPLR  ANOP\n         #BAS  #14,RCHECK            CALL RANGE CHECKER\n         AIF   ('&LBL'(1,1) EQ '(').BREG\n         B     &LBL                  BRANCH WHEN NOT IN CONS SPACE\n         AGO   .MEND\n.BREG    ANOP\n         BR    &LBL(1)               BRANCH WHEN NOT IN CONS SPACE\n         NOPR  0                     FILLER\n.MEND    MEND\n         EJECT\n         MACRO\n&SYM     MARKOBJ &OBJECT\n.*\n.* THIS MACRO INVOKES THE GC MARKING ROUTINE ON A SINGLE OBJECT WHOSE\n.* POINTER IS CONTAINED IN THE COMMON AREA.  THIS RESULTS IN ALL THE\n.* LISP OBJECTS POINTED TO BY THAT OBJECT BEING MARKED.\n.*\n         LA    #15,&OBJECT         POINT TO COMMON AREA OBJECT\n         L     #1,0(,#15)          GET ADDRESS OF IT\n         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT\n         MEND\n         TITLE 'ZILCONS - ZIL 1.3 CONS PROCESSOR AND GARBAGE COLLECTOR'\n         GBLB  &ZILXA,&ZILVF\n         #ZSYS\nZILCONS  CSECT ,\n         USING CONS,#15\n         USING ZLCOMMON,#13\n         SPACE\n***********************************************************************\n*\n* CONS TAKES TWO ARGUMENTS.  NO STACK SPACE IS REQUIRED.\n*\n* REG 1 CONTAINS THE CAR-TO-BE, REG 2 THE CDR-TO-BE.\n*\n* REG 15 RETURNS WITH THE NEWLY ALLOCATED CELL.  IF NO CELLS ARE\n* AVAILABLE A GARBAGE COLLECTION IS DONE, EXCEPT WHEN CONS IS BEING\n* CALLED BY ZILINIT TO PERFORM INITIALIZATION FUNCTIONS - IN THIS\n* CASE REG 15 IS SET TO ZERO TO INDICATE NOT ENOUGH CELLS AVAILABLE\n* FOR INITIALIZATION.\n*\n* THE FREE LIST IS ACCESSED SEQUENTIALLY UNTIL A GARBAGE COLLECTION\n* IS DONE, AT WHICH POINT IT IS CONVERTED TO A CHAINED STRUCTURE AND\n* THE ENTRY POINT FOR CONS (STORED IN COMMON) IS ALTERED TO POINT TO\n* THE CODE WHICH ACCESSES THE NEW STRUCTURE.\n*\n* BE CAREFUL WITH REG 15!!! IT IS THE BASE REGISTER AS WELL AS RETURN.\n*\n* NOTE THAT REG 12 AT ENTRY IS THE BASE REGISTER FOR THE FUNCTION\n* THAT INVOKED CONS.  THIS IS USED BY THE GARBAGE COLLECTOR TO\n* VERIFY THE CURRENT STACK POINTER ENVIRONMENT.\n*\n***********************************************************************\n         EJECT\n         #ZEQU\n         EJECT\n         #ZCOM\n         EJECT\n         #ZHDR\n         EJECT\nZILCONS  CSECT ,\n         SPACE\n***********************************************************************\n*\n* VIRGIN ENTRY POINT - NO GARBAGE COLLECTIONS HAVE OCCURRED\n*\n***********************************************************************\n         SPACE\nCONS     DS    0H\n         CR    #9,#10              IF END OF FREE LIST\n         BNL   GARBCOLL-CONS(,#15) THEN DO GARBAGE COLLECTION\n         LR    #15,#9              ALLOCATE CURRENT CELL IN FREE LIST\n         LA    #9,8(,#9)           ELSE GET NEXT SEQUENTIAL LIST\n         STM   #1,#2,##CAR(#15)    STORE CAR AND CDR IN NEW CELL\n         BR    #14                 RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*\n* ENTRY POINT AFTER GARBAGE COLLECTION HAS ORDERED THE FREE LIST\n*\n***********************************************************************\n         SPACE\nGCCONS   DS    0H\n         LTR   #9,#9               IF FREE LIST IS EXHAUSTED\n         BZ    GARBCOLL-GCCONS(,#15) THEN DO GARBAGE COLLECTION\n         LR    #15,#9              ALLOCATE CURRENT CELL IN FREE LIST\n         L     #9,##CDR(,#9)       GET NEXT CELL IN FREE LIST\n         STM   #1,#2,##CAR(#15)    STORE CAR AND CDR IN NEW CELL\n         BR    #14                 RETURN TO CALLER\n         EJECT\n***********************************************************************\n*\n* GARBAGE COLLECTION REQUIRED - NO MORE FREE CELLS\n*\n***********************************************************************\n         SPACE\nGARBCOLL DS    0H                  GARBAGE COLLECTION\n         XR    #15,#15             PRELIMINARILY SET RETURN TO ZEROES\n         TM    ZLCGCFLG,ZLCGCINT   IF CONS CALLED BY ZILINIT\n         BOR   #14                 THEN RETURN WITH VALUE OF ZEROES\n*                                   TO INDICATE INITIALIZATION FAILURE\n         BALR  #15,0               ELSE BOOTSTRAP ADDRESSABILITY\n         USING GCBASE,#15\nGCBASE   EQU   *\n         STM   #0,#14,ZSAVREGS     SAVE ALL REGISTERS BUT USELESS #15\n         LR    #12,#15             SET NEW BASE REGISTER\n         DROP  #15\n         USING GCBASE,#12\n         SPACE\n***********************************************************************\n*\n* THE ALGORITHM USED HERE IS BASICALLY FLOYD'S MARK-AND-SWEEP\n* NON-RECURSIVE POINTER-CLOBBERING TECHNIQUE AS ILLUSTRATED IN\n* \"LISP\" (FIRST EDITION), BY WINSTON AND HORN, PAGE 117.\n*\n* SOME MODIFICATION HAD TO BE MADE TO SUPPORT THE COLLECTING OF\n* PROPERTY LISTS OF ATOMS, AS WELL AS CLOSURES.  THIS IS DONE\n* BASICALLY BY TREATING SYMBOLS AND CLOSURES AS EQUIVALENT TO CONSES\n* OF SOME NON-LIST ENTITY (WHICH IS THE PRINT NAME OR COMPILED CODE\n* OBJECT) WITH A PROPERTY LIST OR ALIST, SO THAT THE SYMBOL OR\n* CLOSURE GETS TO PARTICIPATE IN THE COLLECTION AS IF IT WERE A LIST.\n*\n* NOTE THAT IN-LINE LISTS MAY NOT PARTICIPATE IN THE COLLECTION\n* PROCESS.  THIS MEANS THAT IF AN IN-LINE LIST WAS MODIFIED AT RUN\n* TIME, THE OBJECTS IN CONS SPACE THAT ARE REFERENCED ONLY BY IN-LINE\n* STRUCTURES WILL NOT BE COLLECTED!  THIS CAN CAUSE EGREGIOUS FAILURES\n* AND IT IS THEREFORE STRESSED THAT IN-LINE LISTS, CREATED BY COMPILING\n* THE CONSTRUCT '(FORM FORM FORM ...), SHOULD NOT BE USED IF THERE IS\n* ANY CHANCE THAT THEY MIGHT BE MODIFIED DURING EXECUTION OF THE CODE.\n*\n* AN EXCEPTION TO THIS IS THAT IN-LINE ATOMS DO PARTICIPATE IN THE\n* GARBAGE COLLECTION PROCESS, SINCE THEIR PROPERTY LISTS MUST BE\n* COLLECTED.  SINCE ALL IN-LINE ATOMS ARE INTERNED ON THE OBLIST, IT\n* IS SUFFICIENT TO GO THROUGH THE OBLIST AND PROCESS ALL ATOMS\n* THEREON TO EFFECT THIS.  THE PRINT NAMES AND OTHER PIECES OF ATOMS\n* THAT RESIDE IN COMPILED CODE CANNOT BE COLLECTED; HOWEVER, SINCE\n* THESE GENERALLY DO NOT POINT TO OTHER LISP OBJECTS, THIS NORMALLY\n* PRESENTS NO PROBLEM UNLESS YOU DO \"ILLEGAL\" THINGS TO ATOMS.\n*\n* THE ALGORITHM ALSO HAD TO BE SLIGHTLY MODIFIED TO HANDLE LISTS WITH\n* ELEMENTS THAT POINT TO THEMSELVES (AN UNUSUAL CASE, ADMITTEDLY).\n* TO DO THIS, WE HAD TO GO BACK TO THE USE OF TWO MARKING BITS.  NOTE\n* THAT IT IS NOT NECESSARY TO UNDO BOTH OF THE MARKING BITS, SINCE\n* THE SWEEP PHASE WILL RESET BOTH OF THEM.\n*\n* THE MARKING BITS ARE THE TWO LOW-ORDER BITS OF THE CAR CELL, WHICH\n* ARE ALWAYS AVAILABLE SINCE ALL POINTERS ARE GUARANTEED TO BE AT\n* LEAST ON A FULLWORD BOUNDARY, MAKING THE ADDRESSES CONTAINED\n* THEREIN END IN TWO ZERO BITS.\n*\n* OBJECTS IN VECTOR/STRING SPACE ARE TREATED SPECIALLY (THEY ARE\n* HANDLED AS NON-POINTERS IN THE MAIN MARKING ALGORITHM) BY THE\n* COMPONENT OF THE GC WHICH DOES RELOCATION AND FORWARDING.  THE\n* FINAL PHASE OF THE GC (BEFORE THE SWEEP) IS THE COLLECTION OF\n* OBJECTS IN VECTOR/STRING SPACE THAT POINT TO OTHER OBJECTS, AND\n* SWAPPING OF THE OLD AND NEW SPACES.\n*\n* SPECIAL THANKS TO GEORGE J. CARRETTE OF NIL AND LMI FAME FOR HIS\n* TECHNICAL ASSISTANCE AND ENCOURAGEMENT WRT THE RELOCATING GC.\n*\n***********************************************************************\n         SPACE\n***********************************************************************\n*\n* REGISTER USAGE IN THIS ROUTINE IS AS FOLLOWS:\n*\n* #0  - WORK REGISTER\n* #1  - TO PASS OBJECTS TO INTERNAL GC SUBROUTINES\n* #2  - WORK REGISTER\n* #3  - LOWER BOUND OF CONS SPACE\n* #4  - UPPER BOUND OF CONS SPACE\n* #5  - THE \"N\" VARIABLE FROM FLOYD'S ALGORITHM AS IN WINSTON & HORN\n* #6  - THE \"P\" VARIABLE FROM FLOYD'S ALGORITHM AS IN WINSTON & HORN\n* #7  - THE \"Q\" VARIABLE FROM FLOYD'S ALGORITHM AS IN WINSTON & HORN\n* #8  - THE ATOM T, AS IN THE REAL WORLD\n* #9  - USED TO REBUILD THE FREE LIST\n* #10 - THE ATOM NIL, AS IN THE REAL WORLD\n* #11 - POSSIBLY BUT NOT NECESSARILY USED FOR STACK PROCESSING\n* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE\n* #13 - THE COMMON AREA, AS IN THE REAL WORLD\n* #14 - BRANCH AND LINK REGISTER FOR GC SUBROUTINES\n* #15 - POINTER TO PLACES TO STORE RELOCATED-OBJECT POINTERS\n*\n***********************************************************************\n         SPACE\n***********************************************************************\n*                                                                     *\n* SEQUENCE OF PROCESSING IS AS FOLLOWS:                               *\n*                                                                     *\n* (1) GC THE READER MACRO CHAIN.  NOTE THAT NO OTHER LISP OBJECTS     *\n*     MAY POINT TO READER MACRO CELLS, SINCE THEY DO NOT HAVE         *\n*     STANDARD TYPE CONFIGURATIONS INSIDE THEM.                       *\n*                                                                     *\n* (2) GC GLOBAL OBJECTS POINTED TO BY THE COMMON AREA.  THESE INCLUDE *\n*     * THE OBLIST AND ALL ATOMS THEREON, INCLUDING THEIR PLISTS.     *\n*     * THE ALISTS AND THE OBJECTS TO WHICH THEY POINT.               *\n*     * THE GENSYM PREFIX, IF ONE IS IN USE.                          *\n*                                                                     *\n* (2.5) GC THE OBJECTS POINTED TO BY THE CELLS OF THE T AND NIL       *\n*       SYMBOLS.                                                      *\n*                                                                     *\n* (3) GC THE INLINE COMPILED CODE OBJECTS POINTED TO BY THE HEADERS   *\n*     OF THE LOADED COMPILED CODE MODULES REFERENCED BY THE COMMON    *\n*     \"MASTER VECTOR\" OF INLINE COMPILED CODE HEADERS.                *\n*                                                                     *\n* (4) GC THE ATOMS REFERENCED BY THE FILE BLOCK CHAINS.               *\n*                                                                     *\n* (5) GC OVER ALL VALID THINGS POINTED TO BY THE CURRENT STACK.       *\n*     HOPEFULLY REGISTER 0 AT ENTRY TO CONS POINTED TO THE CURRENT    *\n*     STACK OFFSET.  IF NOT, WE'LL TRY TO APPROXIMATE IT.             *\n*                                                                     *\n* (6) GC THE THINGS POINTED TO BY REGISTERS 1 AND 2 AT ENTRY TO CONS  *\n*     (WHICH WE WERE TRYING TO USE IN THE FIRST PLACE).               *\n*                                                                     *\n* (7) THEN, GO OVER THE RELOCATED (NEW) VECTOR/STRING SPACE,          *\n*     COLLECTING EVEN MORE OBJECTS.  WHEN THIS IS FINISHED,           *\n*     SWAP THE OLD AND NEW VECTOR/STRING SPACES, FOR ALL OBJECTS      *\n*     THEREIN WILL HAVE BEEN RELOCATED.                               *\n*                                                                     *\n* (8) GO THROUGH THE OBLIST HASH ARRAY AND RELOCATE ALL THE NONZERO   *\n*     SYMBOL POINTERS THEREIN.  SINCE ALL OF SYMBOLS HAVE ALREADY     *\n*     BEEN COLLECTED (WHEN THE OBLIST ITSELF WAS COLLECTED), WE KNOW  *\n*     THEY'VE ALL BEEN FORWARDED, SO JUST LOAD THE FORWARDING PTRS.   *\n*                                                                     *\n* (9) WHEN ALL IS DONE, GO THROUGH THE FREE LIST AND CHAIN ALL THE    *\n*     UNMARKED CELLS INTO A LINKED LIST.  THIS WILL BE THE NEW CONS   *\n*     FREE LIST.  CHANGE THE ENTRY POINT OF CONS TO REFLECT THE NEW   *\n*     FREE LIST ACCESS TECHNIQUE.                                     *\n*                                                                     *\n*(10) IF STILL NO FREE CELLS ARE AVAILABLE, THERE IS NO HOPE. ERROR.  *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n* LET THE USER KNOW WHAT'S GOING ON\n*\n         TM    ZLCGCFLG,ZLCGCMSG   IF MESSAGES ARE TO BE SHOWN,\n         BZ    AFTMSG1             THEN...\n         L     #3,ZSAVED12         GET BASE REG OF FUN THAT CALLED US\n         CLC   0(3,#3),=X'47F0F0'  CHECK VALID LISP CODE\n         BNE   DUNNO               CAN'T VERIFY REG 0 IF WRONG CODE\n         MVI   ZIL1100B,C' '       CLEAR FUNCTION NAME TO BLANKS\n         MVC   ZIL1100B+1(L'ZIL1100B-1),ZIL1100B\n         XR    #15,#15             CLEAR INSERT REGISTER\n         IC    #15,4(,#3)          GET LENGTH OF MODULE IDENTIFIER\n         SH    #15,=H'16'          REDUCE BY LENGTH OF DATE/TIME INFO\n         BNP   DUNNO               IF NO NAME, SKIP\n         CH    #15,=Y(L'ZIL1100B)  NOT BLOODY LIKELY, BUT JUST IN CASE\n         BNH   *+8                  LIMIT TO (NAMELEN) CHARACTERS\n         LA    #15,L'ZIL1100B\n         BCTR  #15,0               REDUCE FOR EXECUTE\n         EX    #15,MVCNAME         MOVE FUNCTION NAME TO MESSAGE\n         LA    #2,ZIL1100B+1(#15)  POINT PAST FUNCTION NAME\n         B     SET1100\nMVCNAME  MVC   ZIL1100B(0),5(#3)   EXECUTED: MOVE FUNCTION NAME TO MSG\nZIL1100U DC    C'SOMEWHERE IN ZIL'\nDUNNO    DS    0H\n         MVC   ZIL1100B(L'ZIL1100U),ZIL1100U\n         LA    #2,ZIL1100B+L'ZIL1100U\nSET1100  DS    0H\n         MVI   0(#2),C'.'          MOVE IN A PERIOD\n         LA    #0,1(,#2)           POINT TO END OF MESSAGE\n         LA    #1,ZIL1100A         POINT TO BEGINNING OF MESSAGE\n         SR    #0,#1               GET LENGTH OF MESSAGE\n         #TPUT *,(1),(0)           SAY GARBAGE COLLECTION IN PROGRESS\nAFTMSG1  DS    0H\n*\n* RECORD CURRENT CPU TIME\n*\n         STIMER TASK,BINTVL=DUMS   DO DUMMY TO FORCE OS TIMER UPDATE\n         L     #2,X'224'           GET ADDRESS OF ASCB\n         MVC   GCTIME1,X'40'(#2)   GET JOB STEP ELAPSED TIME (ASCBEJST)\n*\n* SET BOUNDS OF CONS SPACE FOR RANGE CHECKING\n*\n         L     #3,ZLCGCACP         Address of bottom of active cons sp\n         LR    #4,#10              Address of top of active cons space\n         AIF   (NOT &ZILXA).NOSER1\n*\n* Pre-load virtual pages of spaces to be collected.\n*\n* Note: We specify an ECB to get asynchronous processing, but we\n*       don't actually wait for the page loading to complete.\n*       Why should we?  (maybe we should...?)\n*\n         XC    PGSERECB,PGSERECB   Clear ECB\n         PGSER R,LOAD,A=(#3),EA=(#4),ECB=PGSERECB\n*                                  Load CONS pages and page with NIL\n         XC    PGSERVSA,PGSERVSA   Preset page address to zero\n         L     #1,ZLCVSADR         Bottom of active V/S space\n         L     #15,ZLCVSNXT        Pointer past last used object\n         BCTR  #15,0               Adjust to last byte in used area\n         LA    #0,4095(,#1)\n         CR    #15,#0              Skip unless at least 4k bytes in use\n         BNH   NOVSPGLD\n         ST    #1,PGSERVSA         Save addresses for subsequent\n         ST    #15,PGSERVSE         page release operation\n         XC    PGSERECB,PGSERECB   Clear ECB\n         PGSER R,LOAD,A=(1),EA=(15),ECB=PGSERECB\n*                                  Load vector/string space pages\nNOVSPGLD DS    0H\n.NOSER1  ANOP\n*\n* SET VECTOR/STRING SPACE POINTER\n*\n         L     #1,ZLCVSOTH         GET POINTER TO \"NEW\" V/S SPACE\n         ST    #1,VSPTR            THIS IS WHERE WE'LL RELOCATE TO.\n*\n* START NON-INTERRUPTIBLE PART OF CODE\n*\n         OI    ZLCIFLGS,ZLCISMC    SET NON-INTERRUPTIBLE PROCESS\n*\n* MARK ALL CELLS ON THE READER MACRO CHAIN.\n*\n         LA    #15,ZLCRMCHN        @ HEADER OF READER MACRO CHAIN\n         L     #2,0(,#15)          GET HEADER OF READER MACRO CHAIN\nGCRMLOOP DS    0H                  NOTE #15 -> WHAT'S POINTING.\n         LTR   #2,#2               UNTIL END OF CHAIN\n         BZ    GCENDRM             (WHETHER ZEROES OR NIL)\n         CR    #2,#10\n         BE    GCENDRM\n         LA    #2,0(,#2)           POINT TO OBJECT, CLEARING HIGH BYTE\n         RCHK  #2,GCRMNEXT         CHECK RANGE\n         MARK  #2                  MARK IT\nGCRMNEXT DS    0H\n         LR    #15,#2              SAVE POINTER TO THIS ELEMENT\n         GCDR  #2,#15              GET NEXT ELEMENT IN CHAIN\n         LA    #15,##CDR(,#15)     POINT TO WHAT'S POINTING\n         B     GCRMLOOP            AND CONTINUE.\nGCENDRM  DS    0H\n*\n* MARK OBJECTS POINTED TO BY THE COMMON AREA.\n*\n         MARKOBJ ZLCOBLST          MARK THE OBLIST\n         MARKOBJ ZLCSALST          MARK THE SPECIAL ALIST\n         MARKOBJ ZLCFALST          MARK THE FLUID ALIST\n         MARKOBJ ZLCGSPRE          MARK THE GENSYM PREFIX IF ANY\n*\n* GO OVER THE T AND NIL SYMBOLS AND MARK THEIR CONTENTS.\n*\n         LA    #2,##VECDAT(,#8)    POINT TO FIRST CELL OF T\n         LA    #0,##SYMLEN(,#8)    POINT TO END OF T\n         ST    #0,ENDVEC           SAVE IT\nTLOOP    DS    0H\n         C     #2,ENDVEC           LOOP OVER CELLS OF T\n         BNL   TEND\n         LA    #15,0(,#2)          POINT TO CELL\n         L     #1,0(,#15)          LOAD CELL\n         #BAS  #14,MARKLIST        MARK IT\n         LA    #2,4(,#2)           BUMP TO NEXT CELL\n         B     TLOOP\nTEND     DS    0H\n         LA    #2,##VECDAT(,#10)   POINT TO FIRST CELL OF NIL\n         LA    #0,##SYMLEN(,#10)   POINT TO END OF NIL\n         ST    #0,ENDVEC           SAVE IT\nNILLOOP  DS    0H\n         C     #2,ENDVEC           LOOP OVER CELLS OF NIL\n         BNL   NILEND\n         LA    #15,0(,#2)          POINT TO CELL\n         L     #1,0(,#15)          LOAD CELL\n         #BAS  #14,MARKLIST        MARK IT\n         LA    #2,4(,#2)           BUMP TO NEXT CELL\n         B     NILLOOP\nNILEND   DS    0H\n*\n* MARK ALL INLINE COMPILED CODE OBJECTS.  NOTE THAT OBJECTS WHICH ARE\n* PHYSICALLY IN INLINE COMPILED CODE ARE NOT MARKED, BUT ANY OBJECTS\n* IN A COLLECTIBLE SPACE TO WHICH THEY POINT DO GET MARKED.  THESE\n* ARE CREATED (PRIMARILY) IN TWO WAYS:\n* (1) INTERNMENT OF SYMBOLS\n* (2) BASHING OF CONSTANTS\n*\n* Note: If GC is invoked while ZILSINT is calling ZILINTN, there are a\n*       pair of pointers to inline-code-pointers-set-so-far-while-\n*       processing-this-compiled-function that we must check, because\n*       no inline-code-vector has yet been built for them.\n*\n         ICM   #2,15,ZLCSIN1       Get pointer to ZILSINT temp stuff\n         BZ    SINEND              If none, skip\nSINLOOP  DS    0H\n         C     #2,ZLCSIN2          Loop until end of these pointers\n         BNL   SINEND\n         LA    #15,0(,#2)          Point to pointer\n         L     #1,0(,#15)          Load pointer\n         #BAS  #14,MARKLIST        Call main GC routine on it\n         LA    #2,4(,#2)           Bump to next pointer\n         B     SINLOOP             Continue\nSINEND   DS    0H\n*\n* OK, now process all the inline code vectors.\n*\n         L     #2,ZLCICPA          GET ADDRESS OF \"MASTER VECTOR\"\n         L     #0,ZLCICPU          GET LENGTH OF USED PORTION\n         AR    #0,#2               COMPUTE POINTER TO END OF USED\n         ST    #0,ENDICP           SAVE IT\nICPLOOP  DS    0H\n         C     #2,ENDICP           LOOP UNTIL END OF \"MASTER VECTOR\"\n         BNL   ICPEND\n         ST    #2,SAVEICP          SAVE WHERE WE ARE IN \"MASTER VECTOR\"\n         L     #1,0(,#2)           GET COMPILED CODE HEADER POINTER\n         ST    #1,SAVEHDR          SAVE IT\n         USING ZLHEADER,#1\n         ICM   #2,15,ZLHATOMA      GET POINTER TO INLINE ATOMS VECTOR\n         BZ    ILAEND              IF NONE, SKIP\n         LA    #2,0(,#2)           CLEAR HIGH ORDER BIT\n         L     #0,ZLHATOME         GET POINTER TO END THEREOF\n         ST    #0,ILEND            SAVE IT\nILALOOP  DS    0H\n         C     #2,ILEND            LOOP UNTIL END OF INLINE ATOMS\n         BNL   ILAEND\n         LA    #15,0(,#2)          POINT TO POINTER\n         L     #1,0(,#15)          LOAD POINTER\n         #BAS  #14,MARKLIST        CALL MAIN GC ROUTINE ON IT\n         LA    #2,4(,#2)           BUMP TO NEXT INLINE ATOM\n         B     ILALOOP             CONTINUE\nILAEND   DS    0H\n         L     #1,SAVEHDR          RELOAD HEADER PTR FOR ADDR'BILITY\n         ICM   #2,15,ZLHLISTA      GET POINTER TO INLINE LISTS VECTOR\n         BZ    ILLEND              IF NONE, SKIP\n         LA    #2,0(,#2)           CLEAR HIGH ORDER BIT\n         L     #0,ZLHLISTE         GET POINTER TO END THEREOF\n         ST    #0,ILEND            SAVE IT\nILLLOOP  DS    0H\n         C     #2,ILEND            LOOP UNTIL END OF INLINE LISTS\n         BNL   ILLEND\n         LA    #15,0(,#2)          POINT TO POINTER\n         L     #1,0(,#15)          LOAD POINTER\n         #BAS  #14,MARKLIST        CALL MAIN GC ROUTINE ON IT\n         LA    #2,4(,#2)           BUMP TO NEXT INLINE LIST\n         B     ILLLOOP             CONTINUE\nILLEND   DS    0H\n         L     #2,SAVEICP          GET \"MASTER VECTOR\" PLACEHOLDER\n         LA    #2,4(,#2)           BUMP TO NEXT ENTRY THEREIN\n         B     ICPLOOP             CONTINUE LOOPING THRU IT\n         DROP  #1\n         SPACE 1\n* Constants used by this loop are here for locality of reference.\n         SPACE 1\nENDICP   DS    A                   PTR TO END OF USED \"MASTER VECTOR\"\nSAVEICP  DS    A                   \"MASTER VECTOR\" PLACEHOLDER\nSAVEHDR  DS    A                   COMPILED CODE HEADER POINTER\nILEND    DS    A                   PTR TO END OF STUFF BEING SCANNED\n         SPACE 1\nICPEND   DS    0H                  FINISHED COLLECTING ALL INLINE STUFF\n*\n* MARK ATOMS CONTAINED IN FILE BLOCK POINTERS.\n*\n         L     #2,ZLCIFBAD         GET ADDRESS OF 1ST INPUT FILE BLOCK\nIFLOOP   DS    0H\n         LTR   #2,#2               LOOP UNTIL NO MORE FILE BLOCKS\n         BZ    IFEND\n         LA    #15,ZLFATOM-ZLFILBLK(,#2) POINT TO POINTER TO FILE ATOM\n         L     #1,0(,#15)          GET POINTER TO FILE ATOM\n         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT\n         L     #2,ZLFCHAIN-ZLFILBLK(,#2) GET POINTER TO NEXT FILE BLOCK\n         B     IFLOOP              CONTINUE\nIFEND    DS    0H\n         L     #2,ZLCOFBAD         GET ADDRESS OF 1ST OUTPUT FILE BLOCK\nOFLOOP   DS    0H\n         LTR   #2,#2               LOOP UNTIL NO MORE FILE BLOCKS\n         BZ    OFEND\n         LA    #15,ZLFATOM-ZLFILBLK(,#2) POINT TO POINTER TO FILE ATOM\n         L     #1,0(,#15)          GET POINTER TO FILE ATOM\n         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT\n         L     #2,ZLFCHAIN-ZLFILBLK(,#2) GET POINTER TO NEXT FILE BLOCK\n         B     OFLOOP              CONTINUE\nOFEND    DS    0H\n*\n* LOOP OVER ALL STACK LOCATIONS.\n*\n         L     #11,ZLCPDADR        POINT TO BOTTOM OF PUSH DOWN STACK\n         L     #0,ZSAVED0          GET REG 0 AT ENTRY TO CONS\n         TM    ZLCGCFLG,ZLCGCBLD   IF WE WERE TOLD TO RELY ON #0\n         BO    REG0OK              THEN WE HAVE TO ASSUME REG0 IS OK.\n         L     #1,ZSAVED12         GET BASE REG OF FUN THAT CALLED US\n         CLC   0(3,#1),=X'47F0F0'  CHECK VALID LISP CODE\n         BNE   GCERR               CAN'T VERIFY REG 0 IF WRONG CODE\n         XR    #2,#2\n         IC    #2,3(,#1)           GET B2D2 OF INITIAL BRANCH INSTR.\n         AR    #1,#2               POINT TO NEXT EXECUTABLE INSTR.\n         CLC   0(2,#1),=X'4100'    CHECK VALID (EXPECTED) LISP CODE\n         BNE   MAYBLEX             IF NOT WHAT IS EXPECTED, MAYBE LEXPR\n         LH    #2,2(,#1)           GET B2D2 OF STACK SIZE LA INSTR.\n         SLA   #2,20               SHIFT OUT BASE REG AND\n         SRA   #2,20               ISOLATE THE MAXIMUM STACK SIZE\n         L     #1,ZSAVED11         GET STACK PTR AT ENTRY TO CONS\n         AR    #2,#1               ADD TO GET MAX STACK ADDRESS\n         CR    #0,#1               IF REG 0 LESS THAN CURRENT STACK PTR\n         BL    BADREG0             THEN CAN'T USE IT\n         CR    #0,#2               IF REG 0 GREATER THAN MAX STACK PTR\n         BH    BADREG0             THEN CAN'T USE IT\n         B     REG0OK              OTHERWISE USE REG 0 AS TOP OF STACK\nMAYBLEX  DS    0H                  MAYBE IT'S A LEXPR...\n         CLC   0(L'LCODE,#1),LCODE SEE IF IT'S COMPILED LEXPR PROLOGUE\n         BNE   GCERR               IF NOT, CAN'T VERIFY #0, WRONG CODE\n         LH    #2,L'LCODE(,#1)     GET B2D2 OF STACK SIZE LA INSTR.\n         SLA   #2,20               SHIFT OUT BASE REG AND\n         SRA   #2,20               ISOLATE THE MAXIMUM STACK SIZE\n         SH    #2,=H'4'            ADJUST IT\n         L     #1,ZSAVED11         ELSE GET STACK PTR AT ENTRY TO CONS\n         AR    #2,#1               ADD TO GET MAX STACK ADDRESS\n         CR    #0,#1               IF REG 0 LESS THAN CURRENT STACK PTR\n         BL    BADREG0             THEN CAN'T USE IT\n         CR    #0,#2               IF REG 0 GREATER THAN MAX STACK PTR\n******** BH    BADREG0             THEN CAN'T USE IT\n         BNH   REG0OK              OTHERWISE USE REG 0 AS TOP OF STACK\nBADREG0  DS    0H\n***********************************************************************\n*        TM    ZLCGCFLG,ZLCGCMSG   IF MESSAGES ARE TO BE SHOWN,\n*        BZ    AFTMSG0              AND MSGLEVEL IS < 1, THEN...\n*        #TPUT 0,ZIL1103             TELL USER REG 0 NO GOOD\n*FTMSG0  DS    0H                  --- naaah, don't bother with this\n***********************************************************************\n         LR    #11,#2              CONTINUE, USING MAX STACK ADDR\n         B     GOSTACK\nREG0OK   DS    0H\n         LR    #11,#0              PUT INTO A USEABLE REGISTER\nGOSTACK  DS    0H\n         L     #2,ZLCPDADR         LOAD UP BOTTOM OF STACK AGAIN\nGCPDLOOP DS    0H\n         CR    #2,#11              UNTIL END OF CURRENT STACK\n         BNL   GCENDPD\n         LR    #15,#2              POINT TO WHAT'S DOING THE POINTING\n         L     #1,0(,#15)          GET ITEM POINTED TO BY STACK\n         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT\nNOMKPD   DS    0H\n         LA    #2,4(,#2)           BUMP TO NEXT STACK LOCATION\n         B     GCPDLOOP            AND CONTINUE.\nGCENDPD  DS    0H\n*\n* NOW PROCESS INPUT PARAMETERS TO CONS.\n*\n* SINCE THIS IS A CONS-TO-BE, WE DON'T MARK IT AS SUCH, BUT WE\n* PROCESS IT AS IF IT IS ALREADY A CONS.\n*\n         LA    #15,ZSAVED1          POINT TO SAVED REG 1 ON ENTRY\n         CLI   ##TYPE(#15),##FLONUM IF IT IS A NUMBER\n         BNL   GCVS                 THEN SKIP, NO POINTERS TO MARK\n         L     #1,0(,#15)           ELSE GET CAR-TO-BE\n         #BAS  #14,MARKLIST         INVOKE MAIN GC ROUTINE ON IT\n         LA    #15,ZSAVED2          POINT TO SAVED REG 2 ON ENTRY\n         L     #1,0(,#15)           GET CDR-TO-BE\n         #BAS  #14,MARKLIST         INVOKE MAIN GC ROUTINE ON IT\n******** B     GCVS\n         EJECT\nGCVS     DS    0H\n*\n* NOW WE GO THROUGH ALL THE OBJECTS THAT HAVE BEEN RELOCATED (SO FAR)\n* FROM THE OLD VECTOR/STRING SPACE TO THE NEW VECTOR/STRING SPACE.\n* SINCE THERE MAY BE VECTORS OR OTHER SIMILAR OBJECTS HERE THAT\n* POINT TO STILL OTHER OBJECTS, WE HAVE TO GO THROUGH THEM (THEY MAY\n* EVEN RELOCATE OTHER VECTOR/STRING SPACE OBJECTS THAT WILL END UP\n* PAST THE END OF WHERE WE ARE, SO WE'RE CONSTANTLY CHASING A MOVING\n* END-OF-SPACE POINTER).  WHEN WE FINALLY REACH THE END (PANT PANT),\n* WE'RE FINISHED, SO SWAP SPACES - THE FIRST ONE NOW WILL LATER BE\n* LAST, 'CAUSE THE GARBAGE IT IS COLLECTED.\n*\n* ZLCVSOTH POINTS TO NEW SPACE (WILL BECOME THE OLD SPACE)\n* VSPTR POINTS TO THE END OF RELOCATED NEW SPACE (IT'S VOLATILE)\n*\n         L     #2,ZLCVSOTH         GET POINTER TO NEW V/S SPACE\nGCVSLOOP DS    0H\n         C     #2,VSPTR            DO UNTIL NO MORE NEW V/S OBJECTS\n         BNL   GCVSEND\n         CLI   ##TYPE(#2),##SYMBOL IF OBJECT IS A SYMBOL\n         BE    SYMCOLL             THEN GO COLLECT LIKE A VECTOR\n         CLI   ##TYPE(#2),##DFLOAT IF OBJECT IS A DOUBLE-FLOAT\n         BE    DFCOLL              THEN GO COLLECT LIKE A STRING\n         TM    ##TYPE(#2),##ATOM+##VSS IF ATOM AND VSS BITS NOT ON\n         BNO   BADVSOBJ            THEN FORWARDED OBJECT OR WORSE ERROR\n         TM    ##TYPE(#2),##VEC    IF THIS IS NOT A VECTOR-TYPE OBJECT\n         BNO   GCVSSTR             THEN COLLECT AS A STRING ONLY\n         B     VECCOLL             ELSE GO COLLECT LIKE A VECTOR\n         SPACE 1\nSYMCOLL  DS    0H                  COLLECT SYMBOL IN V/S SPACE\n*                                  USE SYMBOL LENGTH (IGNORE LEN FLD)\n         LA    #0,##SYMLEN(,#2)    PASS ADDRESS OF END OF SYMBOL\n         B     VECSCAN             AND COLLECT LIKE A VECTOR\n         SPACE 1\nDFCOLL   DS    0H                  COLLECT DOUBLE FLOAT IN V/S SPACE\n*                                  USE OBJECT LENGTH (IGNORE LEN FLD)\n         LA    #2,16(,#2)          BUMP PAST END OF DOUBLE FLOAT\n         B     GCVSLOOP            SKIP OVER IT, NO POINTERS TO COLLECT\n         SPACE 1\nVECCOLL  DS    0H                  COLLECT VECTOR IN V/S SPACE\n*\n* COLLECT VECTOR OR SYMBOL BY PROCESSING ALL ITEMS POINTED TO THEREIN.\n*\n         XR    #1,#1               CLEAR INSERT REGISTER\n         ICM   #1,7,1(#2)          GET VECTOR LENGTH\n         BNZ   *+8                 IF ZERO (YOU NEVER KNOW), THEN\n         LA    #1,1                 FORCE POSITIVE LENGTH\n         LA    #0,4+3(#1,#2)       LENGTH + 4 FOR PREFIX AND...\n         N     #0,=X'FFFFFFFC'      ROUND UP TO FULLWORD BOUNDARY\nVECSCAN  DS    0H                  #0 POINTS TO END OF OBJECT\n*******  LA    #15,##VECDAT(,#2)   <== this was a bug!!!!  fixed below\n         LA    #2,##VECDAT(,#2)    POINT TO START OF VECTOR DATA\n         ST    #0,ENDVEC           STORE ADDRESS OF END OF VECTOR\nVECLOOP  DS    0H                  LOOP FOR ALL ELEMENTS OF VECTOR\n         C     #2,ENDVEC           UNTIL LAST VECTOR SLOT\n         BNL   VECEND\n         LR    #15,#2              POINT TO POINTER TO LISP OBJECT\n         L     #1,0(,#15)          LOAD POINT TO OBJECT\n         #BAS  #14,MARKLIST        INVOKE MAIN GC ROUTINE ON IT\n         LA    #2,4(,#2)           BUMP TO NEXT VECTOR ELEMENT\n         B     VECLOOP             CONTINUE LOOPING\nVECEND   EQU   GCVSLOOP            END OF VECTOR, GO TO NEXT STRING\n         SPACE 1\nGCVSSTR  DS    0H                  GC THIS (RELOCATED) STRING\n*                                  (WE DON'T DO NUTHIN WITH IT)\nGCVSNXT  DS    0H                  OK, TIME FOR THE NEXT OBJECT\n         XR    #1,#1               CLEAR INSERT REGISTER\n         ICM   #1,7,1(#2)          GET LENGTH OF THIS OBJECT\n         BNZ   GCVSADIT            IF POSITIVE, NO PROBLEM\n         LA    #1,1                IF ZERO, ASSUME SOME LENGTH\nGCVSADIT DS    0H                  ADD LENGTH TO ADDRESS OF OBJECT\n         LA    #2,4+3(#1,#2)       + 4 FOR PREFIX AND...\n         N     #2,=X'FFFFFFFC'      ROUND UP TO FULLWORD BOUNDARY\n         B     GCVSLOOP            CONTINUE LOOPING\nGCVSEND  DS    0H                  FINISHED, NOW SWAP V/S SPACES\n         L     #1,VSPTR            END-OF-USED-SPACE POINTER\n         ST    #1,ZLCVSNXT         WILL BE @ AVAILABLE SLOT\n         L     #1,ZLCVSADR\n         L     #2,ZLCVSOTH\n         ST    #2,ZLCVSADR         OLD BECOMES NEW\n         ST    #1,ZLCVSOTH         AND NEW BECOMES OLD\n*\n* NOTE THAT WE HAVEN'T CLOBBERED THE OLD (NOW NEW) SPACE, AT LEAST\n* THE PART FOLLOWING THE OLD ZLCVSNXT POINTER (ADMITTEDLY, WE DID\n* RELEASE THE PAGES OF THE OLD VECTOR/STRING SPACE).  THIS IS VERY\n* IMPORTANT, SINCE STRING-BUILDING CODE MAY BE IN THE MIDDLE OF\n* SOMETHING THERE AND WE WANT TO LET THEM START OVER AGAIN.  SEE READ.\n*\n         EJECT\nFIXHASH  DS    0H\n*                                                                     *\n*   GO THROUGH THE OBLIST HASH ARRAY AND RELOCATE ALL THE NONZERO     *\n*   SYMBOL POINTERS THEREIN.  SINCE ALL OF SYMBOLS HAVE ALREADY       *\n*   BEEN COLLECTED (WHEN THE OBLIST ITSELF WAS COLLECTED), WE KNOW    *\n*   THEY'VE ALL BEEN FORWARDED, SO JUST LOAD THE FORWARDING POINTERS. *\n*\n*----------------------------------------------------------------------\n         AIF   (&ZILVF).VFH\n*----------------------------------------------------------------------\n         L     #2,ZLCOBHSH         Get address of oblist hash array\n         L     #0,ZLCOBDIM         Get # of slots in array\n         SLA   #0,2                Convert to size of hash array\n         AR    #0,#2               Convert to address of end of array\n         ST    #0,ENDVEC           Store address of end\nFHLOOP   DS    0H                  Loop through hash table entries\n         CR    #2,#0               until end of hash array\n         BNL   FHEND\n         ICM   #15,15,0(#2)        Get symbol pointer from hash array\n         BZ    FHCONT              If zero, skip\n         TM    ##TYPE(#2),##ATOM   If atom bit on,\n         BO    FHERROR             then symbol wasn't forwarded, error\n         L     #14,##VECDAT(,#15)  else get forwarding pointer\n         ST    #14,0(,#2)          and store back into hash array\nFHCONT   LA    #2,4(,#2)           Bump to next hash table entry\n         B     FHLOOP              Continue looping\nFHEND    DS    0H                  End of hasl table loop\n*----------------------------------------------------------------------\n         AGO   .VFHEND\n*----------------------------------------------------------------------\n.VFH     ANOP\n*----------------------------------------------------------------------\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                 *** SEB vector code here! ***                       *\n*                                                                     *\n* This code relocates all the symbol pointers in the oblist hash      *\n* array by replacing each nonzero pointer with the contents of        *\n* the symbol forwarding pointer.  Currently the VLI (load indirect)   *\n* instruction is used to perform the pointer loading.                 *\n*                                                                     *\n* The method of handling zero entries in the (usually sparse) array   *\n* (since VLI doesn't honor the vector mask mode or otherwise have a   *\n* means of not processing certain elements) is currently to compare   *\n* the vector elements with zero, generating a vector mask, and doing  *\n* a LOAD MATCHED that replaces the zero elements in the vector with   *\n* a special hack value that, when relocated by VLI, does the \"right   *\n* thing\", i.e. puts a zero back into the vector.  This value is the   *\n* address of a field in this module whose ##VECDAT offset has a zero  *\n* in it.  (We could do a STORE MATCHED, I suppose, but that might be  *\n* slower (???), and besides, we don't want to depend on the data      *\n* pointed to by zero being available.)                                *\n*                                                                     *\n* A better approach might be to build a 65536-bit bit vector, use     *\n* VLBIX to create a mask describing nonzero hash array elements, and  *\n* use another VLI to load offsets of the nonzero elements.  In other  *\n* words, we'd be using a VLI in its intended mode followed by a VLI   *\n* in its unintended mode.  But I don't feel like allocating yet       *\n* another chunk of storage for a bit vector.                          *\n*                                                                     *\n* Also:  VLVCU could be used to control the looping through the       *\n* vector processing, but we use CR because it might conceivably       *\n* be faster (is that why SKH does it that way in the sweep???),       *\n* and we don't need the functionality because we know that the        *\n* oblist hash array, like the section size, will always be a power    *\n* of 2 in length.                                                     *\n*                                                                     *\n* Note: No validity checking of symbol forwardedness done in this     *\n* code.  Hopefully this was adequately checked out while we were      *\n* operating with the scalar version of the algorithm!                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #2,ZLCOBHSH         Get address of oblist hash array\n         L     #0,ZLCOBDIM         Get # of slots in array\n         LR    #5,#2               Another copy of address\n         SLA   #0,2                Convert to size of hash array\n         AR    #0,#2               Convert to address of end of array\n         LA    #1,##VECDAT         Constant offset to get forwardg ptrs\n         LA    #14,VFHFAKE         Constant fakeout to relocate zero's\n         XR    #15,#15             Constant zero\n         VSVMM 0                   Set vector mask mode off (for VSRL)\n         VLVCA 512                 Set maximum section size\nVFHLOOP  DS    0H\n         VL    #V0,#2              Load 128 hash array elements\n         VCQ   #VE,#15,#V0         Vector mask = 1's for zero elements\n         VLMQ  #V0,#14             Replace zeroes with \"fake\" in vector\n         VSRL  #V1,#V0,2           Convert addresses to offsets (/ 4)\n         VLI   #V2,#V1,0(#1)       Load symbol forwarding pointers\n         VST   #V2,#5              Store 128 ptrs back into hash array\n         CR    #2,#0               Loop through hash table entries\n         BL    VFHLOOP             until end of hash array\n         B     VFHEND              End loop (branch around data)\n         SPACE 1\nVFHZERO  DC    A(0)                VLI will load a zero from here\nVFHFAKE  EQU   VFHZERO-##VECDAT    Fakeout for relocating zero elements\n         SPACE 1\nVFHEND   DS    0H                  End of hasl table loop\n         SPACE 1\n*----------------------------------------------------------------------\n.VFHEND  ANOP\n*----------------------------------------------------------------------\n         EJECT\n         SPACE 1\n         AIF   (NOT &ZILXA).NOSER2\n***********************************************************************\n*                                                                     *\n* Now we can page-release the old vector/string space, or at least as *\n* much as we care to.                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ICM   #1,15,PGSERVSA      If there was enough old VSS to\n         BZ    NOPGREL              pageload, now release it.\n         L     #15,PGSERVSE          Get addresses for PGSER\n         PGSER R,RELEASE,A=(1),EA=(15) Release old used space\nNOPGREL  DS    0H\n.NOSER2  ANOP\n         EJECT\nSWEEP    DS    0H\n*\n* NOW WE ARE FINISHED WITH THE MARKING PHASE.  NOW BUILD NEW FREE LIST\n*\n*----------------------------------------------------------------------\n         AIF   (&ZILVF).VSWEEP\n*----------------------------------------------------------------------\n         XR    #5,#5               CLEAR FREE CELL COUNT\n         XR    #6,#6               CLEAR FREE LIST POINTER\n         LR    #7,#3               GET ADDRESS OF CONS SPACE\nSWLOOP   DS    0H\n         CR    #7,#4               DO UNTIL END OF CONS SPACE\n         BNL   ENDSW\n         IFMK  #7,NO=SWFREE        IF THIS CELL IS MARKED, THEN...\n         UNMK  #7                  REMOVE MARK\n         B     SWINCR              ELSE\nSWFREE   DS    0H\n         LA    #5,1(,#5)           INCREASE COUNT OF FREE CELLS\n         LTR   #6,#6               IF FREE LIST POINTER NOT SET YET\n         BNZ   SWFRESET            THEN...\n         LR    #9,#7                SET INITIAL FREE CELL POINTER\n         B     SWARESET            ELSE...\nSWFRESET ST    #7,##CDR(,#6)        SET LINK IN LAST FREE CELL POINTER\nSWARESET DS    0H\n         L     #0,=X'FF404040'     PUT JUNK IN FIRST HALF 4 DEBUGGING\n         XR    #1,#1               SET LINK TO ZERO\n         STM   #0,#1,##CAR(#7)     INITIALIZE FREE CELL CONTENTS\n         LR    #6,#7               NEW LATEST FREE CELL = THIS ONE\nSWINCR   DS    0H\n         LA    #7,8(,#7)\n         B     SWLOOP\nENDSW    DS    0H\n*\n* Code to expand dynamically growing CONS space in SCALAR assembly\n*\n*---------------------------------------------------------------------*\n* If the amount of free space remaining is below the threshold        *\n* (currently 1/2), then we dynamically expand the cons space by       *\n* bringing in another section of allocated-but-not-active cons        *\n* space (equal in size to what we already have active) and            *\n* chaining it to the existing free list.                              *\n*                                                                     *\n* At this point, register 3 = ZLCGCACP which is the pointer to the    *\n* bottom of the active CONS space.                                    *\n*---------------------------------------------------------------------*\n         STM   #14,#11,VSAVE       Store registers\n         L     #7,ZLCGCACD         Total # of CONS cells in active\n         SRL   #7,1                Divide this number by 2\n         CR    #5,#7               Compare free # found with 1/2 total\n         BH    SCNOMORE            More than half is still free?\n         C     #3,ZLCCSADR         Compare with absolute bottom\n         BNH   SCNOMORE            Can't expand if it's already max\n         SLL   #7,5                8*2*2*(# cells/2) = 2*size in bytes\n         LR    #8,#4               Compute address of bottom of new\n         SR    #8,#7                active size (top - new length)\n         C     #8,ZLCCSADR         If less than total CS allocated\n         BNL   SCEXPOK             then\n         L     #8,ZLCCSADR          use total allocated\nSCEXPOK  ST    #8,ZLCGCACP         Save new active CS pointer\n         ST    #8,VSAVE+5*4        Set saved #3 to CONS lower bound\n         LR    #7,#4               (don't change live #3, -> old)\n         SR    #7,#8               Recompute true length of new active\n         SRL   #7,3                 CONS space and convert to number of\n         ST    #7,ZLCGCACD           doublewords, and save this value\n*\n         LR    #7,#3               Get old bottom-of-CONS address\n         SR    #7,#8               Subtract new lower bottom-of-CONS\n         SRL   #7,3                Divide by 8 to get cnt of new cells\n         AR    #5,#7               Add count to existing free count\n         LR    #1,#8               Point to first cell in new block\n         L     #14,=X'FF404040'    PUT JUNK IN FIRST HALF 4 DEBUGGING\nSCFLOOP  DS    0H\n         CR    #1,#3               Loop until end of new block\n         BNL   SCFEND\n         LA    #15,8(,#1)          Get pointer to just-initialized cell\n         STM   #14,#15,##CAR(#1)   Initialize free cell contents\n         LR    #1,#15              Get next cell to be made free\n         B     SCFLOOP             Continue for all cells in block\nSCFEND   DS    0H                  #1 points to end of new block\n         SH    #1,=H'8'            Bump back to last cell in new block\n         XR    #2,#2               Set chain pointer to zero\n         ST    #2,##CDR(,#1)        (i.e. will be end of new free list)\n         L     #1,ZLCGCACP         Get ptr to new active space again\n         LTR   #6,#6               Get pointer to old last free cell\n         BZ    SCXNFREE            If there was one, then\n         ST    #8,##CDR(,#6)        hook new free list to end of old\n         B     SCXAF               else (no free cells in old space)\nSCXNFREE ST    #8,VSAVE+11*4        set saved #9 to 1st new free cell\nSCXAF    DS    0H                  Now we have one good free list.\n         ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)\n*\n* Not required, but in case we ever use ZLCGCACF...\n*\n         ST    #5,ZLCGCACF         Save last-uncovered # of free cells\n*\n* End of code that sets ZLCGCACF\n*\n         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5\n*              #9 now points to the beginning of the free list.\n         B     GCCHECK\n*\nSCNOMORE ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)\n         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5\n         LTR   #5,#5\n         BNZ   GCCHECK\n         L     #9,ZLCGCEND         NO CELLS FOUND, ZERO REG 9\n         B     GCCHECK             Jump out of here\n*----------------------------------------------------------------------\n         AGO   .ASWEEP\n*----------------------------------------------------------------------\n.VSWEEP  ANOP  ,\n*---------------------------------------------------------------------*\n*   VECTOR PROCESSOR OPTION FOR THE GARBAGE COLLECTOR SWEEP PHASE     *\n*                                                                     *\n*  There are three versions so far of the sweep phase for this        *\n*  version of the garbage collector.  Version A is very innefficient  *\n*  even though it runs very fast.  It creates a free-list which       *\n*  jumps in multiples of 128 words, which results in catastrophic     *\n*  degeneration of the cache updating algorithm in the hardware.      *\n*  This might be remedied by using 127-word vectors, but the other    *\n*  algorithms are cleaner and at least almost as fast.                *\n*                                                                     *\n*  Vector algorithm B is a precursor to vector algorithm C.           *\n*  Algorithm B first does the sweep, and then creates the free-list.  *\n*  This requires going through the CONS space twice.  Algorithm C     *\n*  improves on this by sweeping only about as far as is necessary     *\n*  to create a full vector section of 128 free-cells.  This results   *\n*  in a sweep phase speed improvement of about 20%.                   *\n*  Another advantage of algorithm C over A is that it leaves the      *\n*  free-list in the same form as the scalar version does, which is    *\n*  the best, namely, ascending and contiguous when possible.          *\n*                                                                     *\n*  Algorithm C can be improved on slightly by eliminating the use     *\n*  of the bit vector and simply buffering up a dozen or so sections   *\n*  of pointers to free cells, and then doing indirect stores          *\n*  (creating the free-list).  This may become Version D.              *\n*                                                                     *\n*  But we drop work on Version D to explore more interesting          *\n*  mark and copy, mark and compact, straight copy and update,         *\n*  and threaded copying and updating GC possibilities for the         *\n*  Vector Facility.                                                   *\n*---------------------------------------------------------------------*\n         AGO   .VECTORC\n         B     VBSTART             ---TEMPORARY---\n*\n         STM   #14,#7,VSAVE\n         SR    #4,#3\n         SRL   #4,4\n         CL    #4,LASTFREE\n         BH    BVA\n         LM    #14,#7,VSAVE\n         B     VBSTART\nBVA      LM    #14,#7,VSAVE\n         EJECT\n*---------------------------------------------------------------------*\n*      VECTOR SWEEP \"A\" ROUTINE                                       *\n*                                                                     *\n*  IN THE FOLLOWING DISCUSSION AND CODE COMMENTS, THE NUMBER          *\n*  128 REFERS TO THE SECTION SIZE OF A 3090 VECTOR FACILITY WITH      *\n*  A SECTION SIZE OF 128.  ACCORDING TO THE IBM SYSTEM/370 VECTOR     *\n*  OPERATIONS MANUAL, THE SECTION SIZE MAY VARY DEPENDING ON THE      *\n*  MODEL FROM 8 TO 512.  ANY REFERENCE HERE TO A SECTION SIZE OF      *\n*  128 CAN BE SUBSTITUTED WITH THE SECTION SIZE OF A PARTICULAR       *\n*  MODEL OF THE VECTOR FACILITY.  THE VECTOR SWEEP ALGORITHMS ARE     *\n*  DESIGNED TO BE INDEPENDENT OF SECTION SIZE.                        *\n*                                                                     *\n*  THIS VECTOR SWEEP ALGORITHM IS PERFORMED IN ONE PASS.  MARKED      *\n*  CELLS ARE UNMARKED 128 ELEMENTS AT A TIME, THE VECTOR MASK IS      *\n*  SET TO INDICATE WHICH CELLS ARE FREE AND CONDITIONAL, VECTOR-      *\n*  MASK-CONTROLLED INSTRUCTIONS STORE INTO THE FREE CELLS THE         *\n*  ADDRESSES OF THE LAST ENCOUNTERED FREE CELLS.  THEN                *\n*  THE ADDRESSES OF THE CURRENT FREE CELLS ARE GENERATED AND          *\n*  ARE USED TO UPDATE THE ADDRESSES OF THE \"LAST ENCOUNTERED\"         *\n*  FREE CELLS.  THESE OPERATIONS WILL TYPICALLY CONSTITUTE THE        *\n*  MAJORITY OF THE PROCESSING TIME WHEN THERE IS MOSTLY COLLECTIBLE   *\n*  MATERIAL.  A SIMPLE EXAMPLE OF THE FORM THE FREE LIST MIGHT TAKE   *\n*  IS ILLUSTRATED HERE.                                               *\n*                                                                     *\n*  A VECTOR SECTION SIZE OF 4 IS ASSUMED FOR ILLUSTRATIVE             *\n*  CONVENIENCE.  CELLS MARKED WITH A CAR AND A CDR WERE               *\n*  FOUND TO HAVE THEIR GC BITS OF THE CAR SET, INDICATING THAT THEY   *\n*  CANNOT BE ADDED TO THE FREE LIST.  THE REST WERE COLLECTED INTO    *\n*  A FREE LIST WHICH MAKES \"RASTER SCAN\" THROUGH MEMORY.  THAT IS,    *\n*  FIRST ALL FREE CELLS AT MULTIPLES OF SECTION SIZE ARE LINKED       *\n*  TOGETHER FROM TOP TO BOTTOM OF THE CONS SPACE.  THE LAST CELL      *\n*  IN THIS CHAIN IS LINKED TO THE HIGHEST FREE CELL WHICH IS AT       *\n*  A LOCATION WHICH IS A MULTIPLE OF THE SECTION SIZE + 1.  THE       *\n*  LINKED LIST BELOW ILLUSTRATES THIS.  REGISTER 9 IN THIS CASE       *\n*  WOULD CONTAIN 296, THE LOCATION OF THE FIRST FREE CELL.  THE       *\n*  CONS CELL AT LOCATION 288 IS THE LAST CELL IN THE FREE LIST.       *\n*                                                                     *\n*  IN THIS EXAMPLE, YOU CAN THINK OF THE VECTOR FACILITY AS SWEEPING  *\n*  DOWN ACROSS THESE CELLS THE WAY A HORIZONTAL RULER PULLED DOWN     *\n*  THE PAGE WOULD SWEEP OVER THESE CELLS.  THE INDIVIDUAL INCH        *\n*  MARKERS ON THE RULER COULD CORRESPOND TO THE VECTOR ELEMENTS.      *\n*  EACH ELEMENT IN THE VECTOR PROCESSOR IS RESPONSIBLE FOR            *\n*  PROCESSING ONE COLUMN.  HENCE, ONE ROW IS PROCESSED BY THE         *\n*  VECTOR FACILITY FOR EVERY PASS THROUGH THE LOOP.                   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  REG 9                                                              *\n*  +---+                                                              *\n*  |296|                                                              *\n*  +---+                                                              *\n*                                                                     *\n*                                                                     *\n*  200 204          208 212          216 220          224 228         *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*  |CAR|CDR|        |   |312|        |CAR|CDR|        |CAR|CDR|       *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  232 236          240 244          248 252          256 260         *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*  |CAR|336|        |CAR|CDR|        |CAR|CDR|        |CAR|CDR|       *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  264 268          272 276          280 284          288 292         *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*  |CAR|CDR|        |   |208|        |CAR|CDR|        |CAR|CDR|       *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  296 300          304 308          312 316          320 324         *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*  |   |232|        |   |272|        |   |352|        |   |  0|       *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  328 332          336 340          344 348          352 356         *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*  |CAR|CDR|        |   |304|        |CAR|CDR|        |   |320|       *\n*  +---+---+        +---+---+        +---+---+        +---+---+       *\n*                                                                     *\n*  THE MAIN LOOP (VA3) IN THE THIS VECTOR ALGORITHM IS RATHER SHORT,  *\n*  CONSISTING OF ONLY 6 MAIN VECTOR INSTRUCTIONS AND SOME FASTER      *\n*  ONES WHICH DON'T OPERATE OVER VECTOR ELEMENTS.  THIS, COMBINED     *\n*  WITH THE FACT THAT THIS ALGORITHM MAKES ONLY ONE PASS (MINIMIZING  *\n*  LOAD ON THE CACHE), MAKES IT QUITE FAST.                           *\n*                                                                     *\n*  MOST OF THE COMPLEXITY OF THE ALGORITHM STEMS FROM                 *\n*  THE NEED TO KEEP TRACK OF THE BEGINNING AND END OF EVERY           *\n*  FREE LIST (ONE MADE BY EACH ELEMENT AFTER A FULL SWEEP) AND        *\n*  LINKING THE ENDS TOGETHER TO MAKE ONE FREE LIST.  SOME OF THE      *\n*  SHORTER FREE LISTS MAY HAVE ONLY ONE ELEMENT, OR SOME ELEMENTS MAY *\n*  HAVE FAILED TO ENCOUNTER ANY FREE CELLS.  HENCE A LINK MUST BE     *\n*  MADE TO JUMP ACROSS SUCH A COLUMN.  THIS IS CONVENIENTLY DONE VIA  *\n*  STORE-COMPRESSED VECTOR INSTRUCTIONS (VSTK).                       *\n*                                                                     *\n* REGISTER USAGE FOR VECTOR SWEEP \"A\":                                *\n*                                                                     *\n* #0  - POINTER FOR VNS VECTOR INSSTRUCTION                           *\n* #1  - POINTER FOR VC VECTOR INSTRUCTION                             *\n* #2  - POINTER FOR VST VECTOR INSTRUCTION                            *\n* #3  - POINTER FOR VSTMD VECTOR INSTRUCTION                          *\n* #4  - UPPER BOUND OF CONS SPACE                                     *\n* #5  - FREE CELL COUNT                                               *\n* #6  - CONSTANT 2 = STRIDE OF CONS CELL IN 4-BYTE WORDS              *\n* #7  - POINTER FOR VLINT VECTOR INSTRUCTION                          *\n* #8  - (SEC SIZE - 1) CELLS LESS THAN TOP OF CONS SPACE              *\n*       TO HELP DETECT WHEN THE END OF SECTIONING LOOP OCCURS         *\n* #9  - USED TO REBUILD THE FREE LIST                                 *\n* #10 - ONE LESS THAN THE SECTION SIZE (127 ON IBM 3090)              *\n* #11 - POSSIBLY BUT NOT NECESSARILY USED FOR STACK PROCESSING        *\n* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE                          *\n* #13 - THE COMMON AREA, AS IN THE REAL WORLD                         *\n* #14 - CONSTANT 8 = STRIDE OF CONS CELL BYTES                        *\n* #15 -                                                               *\n*                                                                     *\n* VECTOR REGISTER USAGE                                               *\n*                                                                     *\n* #V0 - MASKED CARS OF CONS CELLS                                     *\n* #V1 - ADDRESSES OF CARS OF CONS CELLS                               *\n* #V2 - PATTERN X'FF404040' STORED AS CAR OF FREE LIST CELLS          *\n* #V3 - ADDRESS OF LAST FREE CELL FOUND BY VECTOR ELEMENT             *\n* #V4 - (NOT USED)                                                    *\n* #V5 - ADDRESS OF FIRST FREE CELL FOUND BY VECTOR ELEMENT            *\n*---------------------------------------------------------------------*\nVASTART  DS    0H\n         SPACE 1\n*\n* ===> SEB1525 - GET WORKAREA\n*\n         ICM   #1,15,ZLCGCBVA      GET ADDRESS OF GC SWEEP WORK AREA\n         BNZ   VAGOTWA             IF ZERO, THEN...\n         L     #0,VAWALEN           GET LENGTH OF WORK AREA NEEDED\n         ST    #0,ZLCGCBVL          SAVE LENGTH\n         #GETMAIN RC,LV=(0),LOC=ANY TRY TO GET IT\n         LTR   #15,#15              IF FAILED\n         BNZ   GERROR               THEN DISASTER\n         ST    #1,ZLCGCBVA          ELSE STORE ADDRESS OF GC WA\nVAGOTWA  DS    0H\n         SPACE 1\n         STM   #14,#7,VSAVE        SAVE REGISTERS DURING VECTOR SWEEP\n         VSVMM 0                   VECTOR MASK MODE NOT WANTED\n*\n         VSTVP #10                 GET SECTION SIZE (= MAX VEC COUNT)\n         SRL   #10,16              RIGHT JUSTIFY THE SECTION SIZE\n         BCTR  #10,0               WE NEED ONE LESS THAN MULTIPLE OF\n         VLVCA 0(#10)              SET VECTOR COUNT TO MAX-1\n*\n         L     #1,=X'FF404040'     FREE-LIST CAR PATTERN FOR DEBUGGING\n         VRCL  B'11111111'         CLEAR ALL VECTOR REGS, ZERO THE VIX\n         VLQ   #V2,#1              SPREAD PATTERN TO VECTOR OF CARS\n         LR    #0,#3               ADDRESS OF FRST CAR TO LOAD AND MASK\n         LR    #1,#3               ADDRESS OF FIRST CAR TO COMPARE\n         LR    #2,#3               ADDRESS OF FIRST CAR TO STORE\n         XR    #5,#5               CLEAR COUNT OF FREE CELLS\n         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS\n         LR    #7,#3               ADDRESS FOR GENERATING VEC OF POINTR\n*\n         SLL   #10,3               VECTOR COUNT IN EQUIV. CONS BYTES\n         LR    #8,#4               GET TOP OF CONS SPACE\n         SR    #8,#10              REDUCE BY LENGTH OF ONE SECTION\n         SRL   #10,3               RESTORE VECTOR COUNT TO # OF ELEMNTS\n*\n         L     #9,=X'FFFFFFFC'     AND-MASK FOR CLEARING GC BITS\n         LA    #14,8               CONS-CELL-STRIDE IN BYTES\n         LA    #15,VMASK           ADDRESS FOR VECTOR MASK\n*---------------------------------------------------------------------*\n*      PROCESS THE FIRST VECTOR SECTION OF CONS CELLS                 *\n*---------------------------------------------------------------------*\n         VNS   #V0,#9,#0(#6)       LOAD 128 CDRS & CLEAR GC BITS\n         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS\n         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CDRS\n         VSTMD #V2,#3              NOT MUCH STORED, BUT UPDATES #3\n         VCOVM #5                  UPDATE COUNT OF FREE CELLS\n         VLINT #V1,#7(#14)         LOAD ADDRESSES OF THESE 128 CELLS\n         VLMR  #V3,#V1             UPDATE ONLY FREED POINTER ELEMENTS\n         VLMR  #V5,#V1             UPDATE POINTERS TO FIRST FREE CELLS\n         BO    VA3GO               FREE CELL FOUND IN ALL ELEMENTS\n         VCVM                      CONVERT BITS OF FOUND TO NOT FOUND\n         VSTVM #15                 STORE BIT MASK OF NOT FOUND FREE\n         CLR   #0,#4               COMPARE WITH END OF CONS SPACE\n         BNL   VAEND               ALL CONS CELLS PROCESSED\n*---------------------------------------------------------------------*\n*      CONTINUE CLEARING GC BITS AND FINDING FIRST FREE CELLS         *\n*---------------------------------------------------------------------*\nVA2LOOP  LA    #15,VMASK           ADDRESS FOR VECTOR MASK\n         VNS   #V0,#9,#0(#6)       LOAD 128 CDRS & CLEAR GC BITS\n         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS\n         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CDRS\n         VSTMD #V2,#3              STORE PATTERN, UPDATE POINTERS LATER\n         VCOVM #5                  UPDATE COUNT OF FREE CELLS\n         VLINT #V1,#7(#14)         LOAD ADDRESSES OF THESE 128 CELLS\n         VLMR  #V3,#V1             UPDATE ONLY FREED POINTER ELEMENTS\n         VNVM  #15                 AND FREE-FOUND WITH NOT-FOUND\n         LA    #15,VMASK           REINITIALIZE FOR VECTOR MASK\n         VLMR  #V5,#V3             UPDATE POINTERS TO FIRST FREE CELLS\n         VXVM  #15                 EXCLUSIVE OR SAVE-FREE WITH NO-FOUND\n         LA    #15,VMASK           REINITIALIZE FOR VECTOR MASK\n         VTVM                      TEST VECTOR BIT MASK\n         BZ    VA3GO               FREE CELLS FOUND IN ALL ELEMENTS\n         VSTVM #15                 STORE NEW MASK OF NOT-FOUND FREE\n         CLR   #0,#4               COMPARE WITH END OF CONS SPACE\n         BL    VA2LOOP             MORE CONS CELLS LEFT, CONTINUE\n*---------------------------------------------------------------------*\n*      TERMINATE WITH AN INCOMPLETE SECTION SET OF FREE CELLS AND     *\n*      LINK TOGETHER AN INCOMPLETE SET OF FREE LISTS                  *\n*---------------------------------------------------------------------*\n         VCVM                      MAKE MASK \"FOUND FREE CELLS\"\n* ===> SEB1525\n         L     #1,ZLCGCBVA         POINT TO \"VTEMP\" WORK AREA\n         VSTK  #V3,#1              STORE ALL FIRST FREE-CELL ADDRESSES\n*\n* ===> SEB1525 - MAYBE YOU CAN LR #2,#1 BEFORE VSTK, THEN L #9,0(,#2)?\n*\n         L     #1,ZLCGCBVA         POINT TO \"VTEMP\" WORK AREA\n         L     #9,0(,#1)           SAVE ADDRESS OF FIRST FREE CELL\n*\n* ===> SEB1525 CHANGED THE XC - YOU CAN CHANGE IT BACK IF YOU WANT\n*\n******** XC    0(4,#1),0(#1)       LAST ONE FREE-CELL WILL BE 0\n         XR    #2,#2               CLEAR TO FOR COUNT-ALL-ONES\n         ST    #2,0(,#1)           LAST ONE FREE-CELL WILL BE 0\n         VCOVM #2                  COUNT LISTS WITH FREE CELLS\n         BZ    VABZERO9            NO FREE CELLS FOUND\n*\n* ===> SEB1525 ASSUMES #1 STILL POINTS TO \"VTEMP\" HERE.  IS THIS TRUE?\n*\n         LA    #1,4(,#1)           OFFSET 1 WORD FOR ELEMENT-SHIFT\n         VLVCA 0(#2)\n         VL    #V3,#1\n* ===> SEB1525\n         L     #1,ZLCGCBVA\n         VLVCA 512\n         VSTK  #V5,#1\n* ===> SEB1525\n         L     #1,ZLCGCBVA\n         VLVCA 0(#2)\n         VL    #V5,#1\n         VSRL  #V5,#V5,3\n         VSTID #V2,#V5,0\n         B     VARETURN\n*---------------------------------------------------------------------*\n*  CLEAR GC BITS AND LINK FREE CELLS IN ALL ELEMENTS OF SECTION       *\n*  IN MOST CASES, MOST OF THE TIME IS SPENT IN THIS LOOP              *\n*---------------------------------------------------------------------*\nVA3GO    CLR   #0,#4               ---THIS PATH HARD TO TEST---\n         BH    VAEND\n*\nVA3LOOP  VNS   #V0,#9,#0(#6)       LOAD 128 CDRS & CLEAR GC BITS\n         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS\n         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CDRS\n         VSTMD #V2,#3              STORE PATTERN & POINTER TO LAST FREE\n         VCOVM #5                  UPDATE COUNT OF FREE CELLS\n         VLINT #V1,#7(#14)         LOAD ADDRESSES OF THESE 128 CELLS\n         VLMR  #V3,#V1             UPDATE ONLY FREED POINTER ELEMENTS\n         CLR   #0,#4\n         BL    VA3LOOP\n*---------------------------------------------------------------------*\n*  TERMINATION - LINK TOGETHER ALL THE FREE LISTS                     *\n*---------------------------------------------------------------------*\nVAEND    DS    0H\n* ===> SEB1525\n         L     #1,ZLCGCBVA\n         VST   #V3,#1\n*\n* ===> SEB1525 - MAYBE YOU CAN LR #2,#1 BEFORE VST, THEN L #9,0(,#2)?\n*\n         L     #1,ZLCGCBVA\n         L     #9,0(,#1)           SAVE POINTER TO FIRST FREE CELL\n         XC    0(4,#1),0(#1)       LAST FREE CELL MUST HAVE CDR=0\n* ===> SEB1525\n         LA    #1,4(,#1)           OFFSET 1 WORD FOR ELEMENT-SHIFT\n         VL    #V3,#1\n         VSRL  #V5,#V5,3\n         VSTID #V2,#V5,0\n         B     VARETURN\n*\n.VECTORB ANOP\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* REGISTER USAGE FOR VECTOR SWEEP \"B\":                                *\n*                                                                     *\n* #0  - POINTER FOR VNS VECTOR INSTRUCTION                            *\n* #1  - POINTER FOR VC VECTOR INSTRUCTION                             *\n* #2  - POINTER FOR VST VECTOR INSTRUCTION                            *\n* #3  - LOWER BOUND OF CONS SPACE                                     *\n* #4  - UPPER BOUND OF CONS SPACE                                     *\n* #5  - FREE CELL COUNT                                               *\n* #6  - CONSTANT 2 = STRIDE OF CONS CELL IN 4-BYTE WORDS              *\n* #7  - TEMPORARY                                                     *\n* #8  - ADDRESS OF BIT VECTOR                                         *\n* #9  - FFFFFFFC MASK, POINTER TO FREE LIST                           *\n* #10 - NIL (NOT USED HERE)                                           *\n* #11 - POSSIBLY BUT NOT NECESSARILY USED FOR STACK PROCESSING        *\n* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE                          *\n* #13 - THE COMMON AREA, AS IN THE REAL WORLD                         *\n* #14 - INDEX FOR VLBIX VECTOR INSTRUCTION                            *\n* #15 - BITVECTOR STORE POINTER, COUNT FOR VLBIX VECTOR INSTRUCTION   *\n*                                                                     *\n* VECTOR REGISTER USAGE                                               *\n*                                                                     *\n* #V0 - MASKED CARS OF CONS CELLS                                     *\n* #V1 - FREE CELL ELEMENT COUNTS * 8                                  *\n* #V2 - PATTERN X'FF404040' STORED AS CAR OF FREE LIST CELLS          *\n* #V3 - ADDRESS OF LAST FREE CELL FOUND BY VECTOR ELEMENT             *\n*---------------------------------------------------------------------*\nVBSTART  DS    0H\n         ICM   #1,15,ZLCGCBVA      GET ADDRESS OF GC SWEEP WORK AREA\n         BNZ   VBGOTWA             IF ZERO, THEN...\n*---------------------------------------------------------------------*\n* COMPUTE SIZE OF BIT VECTOR NEEDED.  THIS IS ONE BIT PER CONS CELL,  *\n* WHERE EACH CONS CELL IS A DOUBLEWORD.  THUS, THE TOTAL NUMBER OF    *\n* BYTES IN CONS SPACE, DIVIDED BY 8 TO GET # OF DOUBLEWORDS, AND      *\n* DIVIDED AGAIN BY 8 TO GET # OF BYTES TO HOLD THAT MANY BITS,        *\n* GIVES THE REQUIRED LENGTH OF THE BIT VECTOR IN BYTES.               *\n*---------------------------------------------------------------------*\n         VSTVP ZLCGCBVL             Store vector parameters\n         LA    #1,1                 An extra double-word for tie\n         AH    #1,ZLCGCBVL          Add the section sizen size\n         SLL   #1,3                 Multiply by 8 - bytes for VTEMP\n         ST    #1,VTEMPSZ           Stor VTEMP size\n         L     #0,ZLCNFREE          get size of CONS space in dblwrds\n*                                   the same as # of bits in bitvector\n         SRL   #0,3                 Convert to # of bytes in bitvector\n         ALR   #1,#0                Add for total length required\n*\n         LA    #0,7(,#1)\n         N     #0,=X'FFFFFFF8'      ROUND UPWN TO NEXT DOUBLEWORD\n         ST    #0,ZLCGCBVL          SAVE LENGTH\n         #GETMAIN RC,LV=(0),LOC=ANY TRY TO GET IT\n         LTR   #15,#15              IF FAILED\n         BNZ   GERROR               THEN DISASTER\n         ST    #1,ZLCGCBVA          ELSE STORE ADDRESS OF GC WA\nVBGOTWA  STM   #14,#8,VSAVE        SAVE REGISTERS DURING VECTOR SWEEP\n         VSVMM 0                   VECTOR MASK MODE NOT WANTED\n         VLVCA 512                 SET VECTOR COUNT TO MAXIMUM\n*\n         L     #8,ZLCGCBVA         GET ADDRESS OF GC WORK AREA\n         AL    #8,VTEMPSZ          POINT TO OFFSET OF LONG BIT-VECTOR\n*\n         L     #1,=X'FF404040'     FREE-LIST CAR PATTERN FOR DEBUGGING\n         VRCL  B'11111111'         CLEAR ALL VECTOR REGS, ZERO THE VIX\n         VLQ   #V2,#1              SPREAD PATTERN TO VECTOR OF CARS\n         L     #9,=X'FFFFFFFC'     AND-MASK FOR CLEARING GC BITS\n         LR    #0,#3               ADDRESS OF FRST CAR TO LOAD AND MASK\n         LR    #1,#3               ADDRESS OF FIRST CAR TO COMPARE\n         LR    #2,#3               ADDRESS OF FIRST CAR TO STORE\n         XR    #5,#5               CLEAR COUNT OF FREE CELLS\n         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS\n         LR    #15,#8              GET ADDRESS OF LONG BIT-VECTOR\n*\nVB1LOOP  VNS   #V0,#9,#0(#6)       LOAD 128 CARS & CLEAR GC BITS\n         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS\n         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CARS\n         VCOVM #5                  UPDATE COUNT OF FREE CELLS\n         CLR   #0,#4               COMPARE WITH END OF CONS SPACE\n         VSTVM #15                 STORE BIT MASK OF NOT FOUND FREE\n         BL    VB1LOOP             NOT ALL CONS CELLS CLEARED\n*\n         XR    #14,#14             CLEAR BIT INDEX\n         L     #15,ZLCNFREE        Get number of cons cells\n         VLBIX #V0,#14,0(#8)       GENERATE OFFSET NUMBERS FOR SET BITS\n         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS\n         L     #1,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         LR    #9,#1               Save address of first element\n         VST   #V1,#1              STORE FREE POINTERS IN TEMP AREA\n         L     #9,0(,#9)           LOAD OFFSET TO FIRST FREE CELL\n         LA    #9,0(#9,#3)         ADD TO BOTTOM TO GET ACTUAL POINTER\n         BO    VB2ONCE             ONLY ONE SECTION OF FREE CELLS\n         BZ    VABZERO9            NO FREE CELLS FOUND\n*\nVB2LOOP  L     #7,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         SH    #1,=H'4'            BACK UP ONE POINTER\n         LA    #0,4(,#7)           GET SKEWED (BY 1) POINTER OFFSETS\n         L     #7,0(,#1)           OFFSET OF FREE CELL TO BE UPDATED\n         VAS   #V3,#3,#0           ADD TO BOTTOM TO GET ACTUAL POINTERS\n         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST\n         VLBIX #V0,#14,0(#8)       GEN MORE OFFSET NUMBERS OF SET BITS\n         BZ    VB2ZERO             NO 1 bits found\n         L     #1,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS\n         LR    #2,#1               Get pointer to temp free pointers\n         VST   #V1,#1              STORE FREE POINTERS IN TEMP AREA\n         L     #2,0(,#2)           GET OFFSET TO STORE IN FREE CELL\n         LA    #2,0(#2,#3)         CALCULATE ADDRESS TO STORE IN CELL\n         ST    #2,##CDR(#7,#3)     STORE INTO LINK FROM PREV VECTOR\n         BP    VB2LOOP             (COND CODE FROM VLBIX) ANOTHER SECT\n*\nVB2ONCE  SH    #1,=H'4'            BACK UP ONE POINTER\n         L     #2,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         L     #7,0(,#1)           OFFSET OF FREE CELL TO BE UPDATED\n         LA    #0,4(,#2)           GET SKEWED (BY 1) POINTER OFFSETS\n         VAS   #V3,#3,#0           ADD TO BOTTOM TO GET ACTUAL POINTERS\n         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST\n*\nVB2ZERO  XR    #2,#2               GENERATE 0\n         ST    #2,##CDR(#7,#3)     STORE 0 IN CDR OF LAST FREE CELL\n*\n         B     VBRETURN\nVABZERO9 L     #9,ZLCGCEND         NO CELLS FOUND, ZERO REG 9\n*\nVBRETURN DS    0H\nVARETURN ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)\n         LM    #14,#8,VSAVE        RELOAD SAVED REGS AND UPDATED #5\n         AGO   .ASWEEP\n*----------------------------------------------------------------------\n* VECTOR-C algorithm\n*----------------------------------------------------------------------\n.VECTORC ANOP\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* REGISTER USAGE FOR VECTOR SWEEP \"C\":                                *\n*                                                                     *\n* #0  - POINTER FOR VNS VECTOR INSTRUCTION                            *\n* #1  - POINTER FOR VC VECTOR INSTRUCTION                             *\n* #2  - POINTER FOR VST VECTOR INSTRUCTION                            *\n* #3  - LOWER BOUND OF CONS SPACE                                     *\n* #4  - UPPER BOUND OF CONS SPACE                                     *\n* #5  - FREE CELL COUNT                                               *\n* #6  - CONSTANT 2 = STRIDE OF CONS CELL IN 4-BYTE WORDS              *\n* #7  - TEMPORARY                                                     *\n* #8  - ADDRESS OF BIT VECTOR                                         *\n* #9  - FFFFFFFC MASK, POINTER TO FREE LIST                           *\n* #10 - Count of free cells to reach before VLBIX can go              *\n* #11 - Bitvector store pointer                                       *\n* #12 - LOCAL BASE REGISTER FOR THIS ROUTINE                          *\n* #13 - THE COMMON AREA, AS IN THE REAL WORLD                         *\n* #14 - INDEX FOR VLBIX VECTOR INSTRUCTION                            *\n* #15 - Count for VLBIX vector instruction                            *\n*                                                                     *\n* VECTOR REGISTER USAGE                                               *\n*                                                                     *\n* #V0 - MASKED CARS OF CONS CELLS, also free cell index in VLBIX      *\n* #V1 - FREE CELL ELEMENT COUNTS * 8                                  *\n* #V2 - PATTERN X'FF404040' STORED AS CAR OF FREE LIST CELLS          *\n* #V3 - ADDRESS OF LAST FREE CELL FOUND BY VECTOR ELEMENT             *\n*                                                                     *\n* COMPUTE SIZE OF BIT VECTOR NEEDED.  THIS IS ONE BIT PER CONS CELL,  *\n* WHERE EACH CONS CELL IS A DOUBLEWORD.  THUS, THE TOTAL NUMBER OF    *\n* BYTES IN CONS SPACE, DIVIDED BY 8 TO GET # OF DOUBLEWORDS, AND      *\n* DIVIDED AGAIN BY 8 TO GET # OF BYTES TO HOLD THAT MANY BITS,        *\n* GIVES THE REQUIRED LENGTH OF THE BIT VECTOR IN BYTES.               *\n*                                                                     *\n* Here are the first 130 words of the GETMAINED area.  All words      *\n* starting at #8 pointer (130th word = 129 by zero-based count).      *\n* Some of the address pointer storages are indicated below.  The      *\n* \"@\" sign indicates exactly where these storage locations point.     *\n*                                                                     *\n* +-----+-----+-----+-----+-----+-----+-----//-----+-----+-----+-----+*\n* |   0 |   1 |   2 |   3 |   4 |   5 |   6    126 | 127 |blank|bitv>|*\n* +-----+-----+-----+-----+-----+-----+-----//-----+-----+-----+-----+*\n* @ ZLCGCBVA                                       @ VTEMPTOP  @ #8   *\n*       @ VTEMP4                                                      *\n*                                                                     *\n* In this version of the sweep phase, washing of the cache is         *\n* reduced by doing all the work in one pass through the memory.       *\n* The innermost loop, VC3LOOP, is performed only as many times        *\n* as is needed by the outer loop, VC2LOOP, so that it will have       *\n* another 128 free-cells to chain.  When the free cells are sparse,   *\n* the inner loop will spin many times for each iteration of the       *\n* outer loop with the VLBIX instruction.  In areas where almost all   *\n* cells are free, the inner loop will probably execute just once,     *\n* such that there is no extra looping in VC3LOOP when compared with   *\n* VC2LOOP.  VC3LOOP only spins extra when the outer loop is not       *\n* getting enough free cells.                                          *\n*---------------------------------------------------------------------*\nVCSTART  ICM   #1,15,ZLCGCBVA      GET ADDRESS OF GC SWEEP WORK AREA\n         BNZ   VCGOTWA             IF ZERO, THEN...\n*\n         VSTVP VGCVP                Store vector parameters\n         LA    #1,1                 An extra word for tie\n         AH    #1,VGCVP             Add the section size in elements\n         SLL   #1,2                 Multiply by 4 - bytes for VTEMP\n         ST    #1,VTEMPSZ           Stor VTEMP size\n         L     #0,ZLCNFREE          get size of CONS space in dblwrds\n*                                   the same as # of bits in bitvector\n         SRL   #0,3                 Convert to # of bytes in bitvector\n         ALR   #1,#0                Add for total length required\n*\n         LA    #0,7(,#1)\n         N     #0,=X'FFFFFFF8'      ROUND UP TO NEXT DOUBLEWORD\n         ST    #0,ZLCGCBVL          SAVE LENGTH\n         #GETMAIN RC,LV=(0),LOC=ANY TRY TO GET IT\n         LTR   #15,#15              IF FAILED\n         BNZ   GERROR               THEN DISASTER\n         ST    #1,ZLCGCBVA          ELSE STORE ADDRESS OF GC WA\nVCGOTWA  STM   #14,#11,VSAVE       SAVE REGISTERS DURING VECTOR SWEEP\n*\n         VSVMM 0                   VECTOR MASK MODE NOT WANTED\n         VLVCA 512                 SET VECTOR COUNT TO MAXIMUM\n         L     #8,ZLCGCBVA         GET ADDRESS OF GC WORK AREA\n         LA    #7,4(,#8)           generate address for VTEMP4\n         AL    #8,VTEMPSZ          Point to address of long bitvector\n         ST    #7,VTEMP4           Store address for temporary load\n*\n         L     #1,=X'FF404040'     FREE-LIST CAR PATTERN FOR DEBUGGING\n         VRCL  B'11111111'         CLEAR ALL VECTOR REGS, ZERO THE VIX\n         VLQ   #V2,#1              SPREAD PATTERN TO VECTOR OF CARS\n         L     #9,=X'FFFFFFFC'     AND-MASK FOR CLEARING GC BITS\n         LR    #0,#3               ADDRESS OF FRST CAR TO LOAD AND MASK\n         LR    #1,#3               ADDRESS OF FIRST CAR TO COMPARE\n         LR    #2,#3               ADDRESS OF FIRST CAR TO STORE\n         XR    #5,#5               CLEAR COUNT OF FREE CELLS\n         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS\n         LH    #10,VGCVP           First half of VGCVP is section size\n         LR    #11,#8              GET ADDRESS OF LONG BIT-VECTOR\n*\nVC1LOOP  VNS   #V0,#9,#0(#6)       LOAD 128 CARS & CLEAR GC BITS\n         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS\n         VST   #V0,#2(#6)          STORE ALL 128 GC-BIT-CLEARED CARS\n         VCOVM #5                  UPDATE COUNT OF FREE CELLS\n         CLR   #0,#4               COMPARE WITH END OF CONS SPACE\n         VSTVM #11                 STORE BIT MASK OF NOT FOUND FREE\n         BNL   VC1DONE             NOT ALL CONS CELLS CLEARED\n         CLR   #5,#10              Not 128 free cells found?\n         BL    VC1LOOP             Try to find enough for at least 128\n*\nVC1DONE  XR    #14,#14             CLEAR BIT INDEX\n         L     #15,ZLCGCACD        Get number of cons cells\n         VLBIX #V0,#14,0(#8)       GENERATE OFFSET NUMBERS FOR SET BITS\n         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS\n         L     #2,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         VST   #V1,#2              STORE FREE POINTERS IN TEMP AREA\n         L     #6,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         L     #6,0(,#6)           LOAD OFFSET TO FIRST FREE CELL\n         LA    #6,0(#6,#3)         ADD TO BOTTOM TO GET ACTUAL POINTER\n         ST    #6,VSAVE+11*4       Pointer to first free cell ret in #9\n         BO    VC2ONCE             ONLY ONE SECTION OF FREE CELLS\n         BZ    VCZERO9             NO FREE CELLS FOUND\n*\nVC2LOOP  L     #7,VTEMP4           LOAD ADDRESS OF TEMP FREE POINTERS\n         SH    #2,=H'4'            Back up to pointer to last free cell\n         VAS   #V3,#3,#7           ADD TO BOTTOM TO GET ACTUAL POINTERS\n         L     #7,0(,#2)           Get offset pointer to last free cell\n         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST\n         AH    #10,VGCVP           Add section size\nVC3LOOP  CLR   #0,#4               COMPARE WITH END OF CONS SPACE\n         BNL   VC3DONE             NOT ALL CONS CELLS CLEARED\n         LA    #6,2                STRIDE TO SAME HALF OF NEXT CONS\n         VNS   #V0,#9,#0(#6)       LOAD 128 CARS & CLEAR GC BITS\n         LR    #0,#1               Reload same address for VST\n         VC    #VE,#V0,#1(#6)      SET MASK BITS AT UNMARKED CELLS\n         VST   #V0,#0(#6)          STORE ALL 128 GC-BIT-CLEARED CARS\n         VCOVM #5                  UPDATE COUNT OF FREE CELLS\n         VSTVM #11                 STORE BIT MASK OF NOT FOUND FREE\n         CLR   #5,#10              Not 128 free cells found?\n         BL    VC3LOOP             Try to get enough for at least 128\nVC3DONE  VLBIX #V0,#14,0(#8)       GEN MORE OFFSET NUMBERS OF SET BITS\n         BZ    VC2ZERO             No 1 bits found, vector count=0\n         L     #2,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         VSLL  #V1,#V0,3           ELEMENT OFFSETS X 8 = BYTE OFFSETS\n         VST   #V1,#2              STORE FREE POINTERS IN TEMP AREA\n         L     #6,ZLCGCBVA         LOAD ADDRESS OF TEMP FREE POINTERS\n         L     #6,0(,#6)           GET OFFSET TO STORE IN FREE CELL\n         LA    #6,0(#6,#3)         CALCULATE ADDRESS TO STORE IN CELL\n         ST    #6,##CDR(#7,#3)     STORE INTO LINK FROM PREV VECTOR\n         BP    VC2LOOP             (COND CODE FROM VLBIX) ANOTHER SECT\n*                               ***BZ could be moved down here?\n*\nVC2ONCE  L     #7,VTEMP4           LOAD ADDRESS OF TEMP FREE POINTERS\n         SH    #2,=H'4'            Back up to pointer to last free cell\n         VAS   #V3,#3,#7           ADD TO BOTTOM TO GET ACTUAL POINTERS\n         L     #7,0(,#2)           Get offset pointer to last free cell\n         VSTID #V2,#V0,0(#3)       CREATE A SECTION OF THE FREE LIST\nVC2ZERO  XR    #2,#2               GENERATE 0\n         ST    #2,##CDR(#7,#3)     STORE 0 IN CDR OF LAST FREE CELL\n         LA    #0,0(#7,#3)         Point to that there last free cell\n         ST    #0,LASTFREE         Save pointer thereto\n         B     VCEXPCHK\nVCZERO9  DS    0H\n         XR    #7,#7               Originally no free, so last new=0\n         ST    #7,VSAVE+11*4       Set saved #9 to zeroes\n         ST    #7,LASTFREE         Pointer to last free cell = null\n*---------------------------------------------------------------------*\n* If the amount of free space remaining is below the threshold        *\n* (currently 1/2), then we dynamically expand the cons space by       *\n* bringing in another section of allocated-but-not-active cons        *\n* space (equal in size to what we already have active) and            *\n* chaining it to the existing free list.                              *\n*                                                                     *\n* At this point, register 3 = ZLCGCACP which is the pointer to the    *\n* bottom of the active CONS space.                                    *\n*---------------------------------------------------------------------*\nVCEXPCHK L     #7,ZLCGCACD         Total # of CONS cells in active\n         SRL   #7,1                Divide this number by 2\n         CR    #5,#7               Compare free # found with 1/2 total\n         BH    VCNOMORE            More than half is still free?\n         C     #3,ZLCCSADR         Compare with absolute bottom\n         BNH   VCNOMORE            Can't expand if it's already max\n         SLL   #7,5                8*2*2*(# cells/2) = 2*size in bytes\n         LR    #8,#4               Compute address of bottom of new\n         SR    #8,#7                active size (top - new length)\n         C     #8,ZLCCSADR         If less than total CS allocated\n         BNL   VCEXPOK             then\n         L     #8,ZLCCSADR          use total allocated\nVCEXPOK  ST    #8,ZLCGCACP         Save new active CS pointer\n         ST    #8,VSAVE+5*4        Set saved #3 to CONS lower bound\n         LR    #7,#4               (don't change live #3, -> old)\n         SR    #7,#8               Recompute true length of new active\n         SRL   #7,3                 CONS space and convert to number of\n         ST    #7,ZLCGCACD           doublewords, and save this value\n*\n         LR    #7,#3               Get old bottom-of-CONS address\n         SR    #7,#8               Subtract new lower bottom-of-CONS\n         SRL   #7,3                Divide by 8 to get cnt of new cells\n         AR    #5,#7               Add count to existing free count\n*\n         VLVCA 512                 Get section size\n         LR    #1,#8               Get address of new active CS block\n         LA    #8,8                Set stride for doublewords\n         LA    #0,8(,#1)           Set pointer to first indirect value\nVCFREE   VLINT #V3,#0(#8)          Load a vector of pointers to cells\n         VSTD  #V2,#1              Store CARs (pattern) & CDRs (chain)\n         CLR   #1,#3               Loop until we hit previously active\n         BL    VCFREE               CS block (i.e. end of new block)\n         SH    #1,=H'8'            Bump back to last cell in new block\n         XR    #2,#2               Set chain pointer to zero\n         ST    #2,##CDR(,#1)        (i.e. will be end of new free list)\n         L     #1,ZLCGCACP         Get ptr to new active space again\n         ICM   #2,15,LASTFREE      Get pointer to old last free cell\n         BZ    VCXNFREE            If there was one, then\n         ST    #1,##CDR(,#2)        hook new free list to end of old\n         B     VCXAF               else (no free cells in old space)\nVCXNFREE ST    #1,VSAVE+11*4        set saved #9 to 1st new free cell\nVCXAF    DS    0H                  Now we have one good free list.\n         ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)\n*\n* Not required, but in case we ever use ZLCGCACF...\n*\n         ST    #5,ZLCGCACF         Save last-uncovered # of free cells\n*\n* End of code that sets ZLCGCACF\n*\n         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5\n*              #9 now points to the beginning of the free list.\n         B     GCCHECK\n*\nVCNOMORE ST    #5,VSAVE+7*4        SET NEW VALUE OF #5 (FREE COUNT)\n         LM    #14,#11,VSAVE       RELOAD SAVED REGS AND UPDATED #5\n         LTR   #5,#5\n         BNZ   GCCHECK\n         L     #9,ZLCGCEND         NO CELLS FOUND, ZERO REG 9\n         B     GCCHECK             Jump out of here\n         EJECT\n*----------------------------------------------------------------------\n.ASWEEP  ANOP  ,\n*----------------------------------------------------------------------\n*---------------------------------------------------------------------*\n*  Optional test code for doing a thorough check on the structure of  *\n*  the free-list.  Use for debugging and system testing only.         *\n*                                                                     *\n* To activate, decomment the code following GCCHECK and comment out   *\n* the \"GCCCHECK EQU GCDONE\" statement.                                *\n*                                                                     *\n* Currently, we activate this check for scalar code only.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n*----------------------------------------------------------------------\n         AIF   (&ZILVF).NOGCCK\n         AGO   .NOGCCK             Actually, always bypass the check.\n*----------------------------------------------------------------------\n         SPACE 1\nGCCHECK  DS    0H\n         CL    #9,ZLCGCEND         Are we at the end\n         BE    GCDONE              OK, the first one is the last.\n         STM   #14,#11,VSAVE       More work needed, save registers\n         XR    #2,#2               Clear toggle for free-list check\n         LA    #6,1                We have one free cell so far\nCHKMORE  CLR   #9,#3               Free cell higher than space bottom?\n         BL    CHKERR1             No, then error in free list\n         CLR   #9,#4               Free cell lower than top of space?\n         BNL   CHKERR2             No, then error in free list\n         LR    #7,#9               Make extra copy of pointer to cell\n         N     #7,=X'00000007'     Leave only the 3 least sig. bits\n         BNZ   CHKERR3             They better be zero, or we go to err\n         LR    #7,#9               Save pointer to free list cell\n         L     #9,##CDR(,#9)       Chain down free list one more\n         LTR   #9,#9               Is it the end?\n         BZ    CHKEND              If zero, yes it is end of free list\n         LA    #6,1(,#6)           Passed most checks, add one to count\n         CLR   #6,#5               Is count higher than reported?\n         BH    CHKERR4             Count can't be higher, report error\n         CLR   #9,#7               This cell higher in mem than last?\n         BH    CHKMORE             Good, check next cell in free list\n         X     #2,=F'1'            Toggle free-list drop-down flag\n         BNZ   CHKMORE             Toggling it set it, right?\n         B     CHKERR5             Oops, free list downwards twice!\nCHKERR1  LA    #2,1111\n         B     CHKERR\nCHKERR2  LA    #2,1112\n         B     CHKERR\nCHKERR3  LA    #2,1113\n         B     CHKERR\nCHKERR4  LA    #2,1114\n         B     CHKERR\nCHKERR5  LA    #2,1115\n         B     CHKERR\nCHKERR6  LA    #2,1116\n         B     CHKERR\nCHKERR   ST    #2,VSAVE+4*4\n         LM    #14,#11,VSAVE\n         NI    ZLCIFLGS,255-ZLCISMC\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         LA    #1,FLERR\n         LA    #0,L'FLERR\n         TPUT  (1),(0),R\n         L     #2,VSAVE+4*4\n         ABEND (2),DUMP\n         SPACE 1\nFLERR    DC    C'ZILCONS VECTOR-C FREE LIST ERROR!!!'\n         SPACE 1\nCHKEND   CLR   #6,#5\n         BNE   CHKERR6\n         LM    #14,#11,VSAVE\n         B     GCDONE\n*----------------------------------------------------------------------\n         AGO   .ENDGCCK\n*----------------------------------------------------------------------\n*----------------------------------------------------------------------\n.NOGCCK  ANOP\n*----------------------------------------------------------------------\nGCCHECK  EQU   GCDONE              No free list checking done.\n*----------------------------------------------------------------------\n.ENDGCCK ANOP\n*----------------------------------------------------------------------\n         EJECT\nGCDONE   DS    0H                  GARBAGE COLLECTION COMPLETE\n         OI    ZLCGCFLG,ZLCGCDNE   SAY A GARBAGE COLLECTION WAS DONE\n*\n* CHANGE ENTRY POINT OF CONS TO REFER TO POST-COLLECTION ROUTINE\n*\n         XR    #0,#0               SET NEW END-OF-FREE-LIST POINTER\n         ST    #0,ZLCGCEND         TO ZERO\n         L     #15,=A(GCCONS)      LOAD POST-GARB-COLL ENTRY POINT\n         ST    #15,ZLCCONS         UPDATE CONS POINTER IN COMMON\n*\n* RECORD CURRENT CPU TIME\n*\n         STIMER TASK,BINTVL=DUMS   DO DUMMY TO FORCE OS TIMER UPDATE\n         L     #2,X'224'           GET ADDRESS OF ASCB\n         MVC   GCTIME2,X'40'(#2)   GET JOB STEP ELAPSED TIME (ASCBEJST)\n*\n* UPDATE TOTAL GC TIME SO FAR FROM RECORDED CPU TIMES\n*\n         LM    #2,#3,GCTIME1       GET ELAPSED TIME AT START OF GC\n         SRDL  #2,12               CONVERT FROM MICROSECONDS\n         D     #2,=F'1000'         TO THOUSANDTHS OF A SECOND\n         LR    #0,#3               GET RESULT INTO REGISTER\n         LM    #2,#3,GCTIME2       GET ELAPSED TIME AT END OF GC\n         SRDL  #2,12               CONVERT FROM MICROSECONDS\n         D     #2,=F'1000'         TO THOUSANDTHS OF A SECOND\n         LR    #1,#3               GET RESULT INTO REGISTER\n         SR    #1,#0               SUBTRACT TO GET CPU TIME FOR THIS GC\n         A     #1,ZLCGCTIM         ADD TO TOTAL GC TIME SO FAR\n         ST    #1,ZLCGCTIM         UPDATE TOTAL GC TIME SO FAR\n*\n* END NON-INTERRUPTIBLE PART OF CODE\n*\n         NI    ZLCIFLGS,255-ZLCISMC    INTERRUPTIBLE NOW\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n*\n* TELL USER HOW MANY FREE CELLS ARE NOW AVAILABLE\n*\n         LTR   #5,#5               IF NO FREE CELLS FOUND\n         BZ    GCFULL              THEN SIGNAL ERROR\n         SPACE 1\n******** #TPUT 1,ZIL1102 ***********\n         SPACE 1\n         TM    ZLCGCFLG,ZLCGCMSG   IF MESSAGES ARE NOT TO BE SHOWN,\n         BZ    AFTMSG2             THEN SKIP THIS SECTION\n         SPACE 1\n         MVC   ZIL1102(L'ZIL1102A),ZIL1102A   FIRST PART OF MESSAGE\n         CVD   #5,ZLCDBL                      NUMBER OF FREE CELLS\n         UNPK  ZIL1102+L'ZIL1102A(10),ZLCDBL  INTO MESSAGE AREA\n         OI    ZIL1102+L'ZIL1102A+9,X'F0'\n         LA    #1,ZIL1102+L'ZIL1102A  POINT TO CONVERTED # AREA\n         LA    #2,9                INITIALIZE DECREMENT REGISTER\nLOOP1102 DS    0H                  SEARCH FOR FIRST NONZERO\n         CLI   0(#1),C'0'\n         BNE   END1102\n         LA    #1,1(,#1)\n         BCT   #2,LOOP1102\nEND1102  DS    0H                  #2 = NUMBER LENGTH - 1\n         EX    #2,MVC1102          LEFT JUSTIFY THE NUMBER IN PLACE\n         LA    #3,ZIL1102+L'ZIL1102A+1(#2)  POINT PAST END OF NUMBER\n         MVI   0(#3),C'/'          MOVE IN A SLASH\n         L     #0,ZLCGCACD         GET NUMBER OF ACTIVE DOUBLEWORDS\n         CVD   #0,ZLCDBL\n         UNPK  1(10,#3),ZLCDBL\n         OI    10(#3),X'F0'\n         LA    #1,1(,#3)           POINT TO CONVERTED # AREA\n         LA    #2,9                INITIALIZE DECREMENT REGISTER\nLOOQ1102 DS    0H                  SEARCH FOR FIRST NONZERO\n         CLI   0(#1),C'0'\n         BNE   ENE1102\n         LA    #1,1(,#1)\n         BCT   #2,LOOQ1102\nENE1102  DS    0H                  #2 = NUMBER LENGTH - 1\n         EX    #2,MVD1102          LEFT JUSTIFY THE NUMBER IN PLACE\n         LA    #1,2(#3,#2)         POINT PAST END OF NUMBER\n         MVC   0(L'ZIL1102B,#1),ZIL1102B    MOVE IN REST OF MESSAGE\n         LA    #15,L'ZIL1102B(,#1)  POINT TO NEXT SEGMENT OF MESSAGE\n         LR    #1,#15\n         L     #2,ZLCVSADR         ADDRESS OF START OF V/S SPACE...\n         A     #2,ZLCVSLEN         PLUS LENGTH OF V/S SPACE...\n         S     #2,ZLCVSNXT         MINUS ADDRESS OF AVAILABLE SLOT...\n         CVD   #2,ZLCDBL           GIVES LENGTH OF AVAILABLE V/S SPACE\n         UNPK  0(10,#1),ZLCDBL     CONVERT TO DISPLAY\n         OI    9(#1),X'F0'\n         LA    #2,9                INITIALIZE DECREMENT REGISTER\nLP1102C  CLI   0(#1),C'0'          SEARCH FOR FIRST NONZERO\n         BNE   END1102C\n         LA    #1,1(,#1)\n         BCT   #2,LP1102C\nEND1102C DS    0H                  #2 = NUMBER LENGTH - 1\n         EX    #2,MVC1102C         LEFT JUSTIFY THE NUMBER IN PLACE\n         LA    #1,1(#15,#2)        POINT PAST END OF NUMBER\n         MVC   0(L'ZIL1102C,#1),ZIL1102C  MOVE IN REST OF MESSAGE\n         LA    #0,L'ZIL1102C(,#1)  GET TOTAL LENGTH OF MESSAGE\n         LA    #1,ZIL1102           BY SUBTRACTING END OF MESSAGE\n         SR    #0,#1                 FROM BEGINNING OF MESSAGE\n         #TPUT *,(1),(0)              ISSUE THE MESSAGE\nAFTMSG2  DS    0H\n         SPACE 1\n*\n* RELOAD PARAMETER REGISTERS\n*\n         LM    #0,#8,ZSAVED0       DON'T RESTORE REGISTER 15\n         LM    #10,#14,ZSAVED10    DON'T RESTORE REGISTER 9\n         L     #15,ZLCCONS         GET ADDRESS OF NEW CONS ROUTINE\n         BR    #15                 START OVER\n         SPACE 2\nMVC1102  MVC   ZIL1102+L'ZIL1102A(0),0(#1)  EXECUTED\nMVD1102  MVC   1(*-*,#3),0(#1)              EXECUTED\nMVC1102C MVC   0(*-*,#15),0(#1)             EXECUTED\n         SPACE 2\n*\n* GARBAGE COLLECTION SEVERE ERROR - CANNOT RECOVER\n*\nGCERR    DS    0H\n         #TPUT ZIL1104\n         ABEND 1104,DUMP\n         SPACE\n*\n* GARBAGE COLLECTION FOUND NO FREE CELLS - CANNOT RECOVER\n*\nGCFULL   DS    0H                  NO MORE FREE CELLS\n*        #TPUT ZIL1101\n*        ABEND 1101,DUMP\n         XR    #9,#9               SET NEXT-CONS-CELL POINTER TO\n*                                   \"NO MORE CONS CELLS\" VALUE\n         #ZERR ZIL1101             DON'T ABEND; SIGNAL AN ERROR\n         SPACE\n*\n* INVALID OBJECT FOUND IN VECTOR/STRING SPACE\n*\nBADVSOBJ DS    0H\n         #TPUT ZIL1107\n         ABEND 1107,DUMP\n         EJECT\n*\n* NON-FORWARDED SYMBOL POINTER FOUND IN OBLIST HASH ARRAY\n*\nFHERROR  DS    0H\n         #TPUT ZIL1110\n         ABEND 1110,DUMP\n         EJECT\n         AIF   (NOT &ZILVF).NOGERR\n*\n* UNABLE TO GETMAIN GC WORK AREA\n*\nGERROR   DS    0H\n         #TPUT ZIL1109\n         ABEND 1109,DUMP\n.NOGERR  ANOP\n         EJECT\nMARKLIST DS    0H\n         SPACE\n***********************************************************************\n*                                                                     *\n* THIS IS THE MAIN ROUTINE TO GO THROUGH A LISP OBJECT AND MARK ALL   *\n* PARTS OF IT.  FOR THE PURPOSES OF THIS ROUTINE A SYMBOL IS TREATED  *\n* AS A LIST WHOSE CAR IS A STRING (I.E. THE PRINT NAME) AND WHOSE CDR *\n* IS A LIST, NAMELY THE PROPERTY LIST.  SIMILARLY, A CLOSURE IS       *\n* TREATED AS A LIST WHOSE CAR IS A SPECIAL OBJECT (ACTUALLY A PIECE   *\n* OF COMPILED CODE) AND WHOSE CDR IS A LIST, NAMELY THE ALIST.  NOTE  *\n* THAT IN CASES WHERE THE PROPERTY LIST POINTER IS ZEROES, OR WHERE   *\n* THE ALIST POINTER IS ZEROES (I.E. SUBR NOT A CLOSURE), THIS WILL    *\n* FAIL THE \"IN-CONS-SPACE-RANGE\" TEST AND STILL WORK WITHIN THE LOGIC *\n* OF THIS ROUTINE.  NOTE ALSO THAT OTHER TYPES OF CONSED ATOMS (I.E.  *\n* FIXNUMS AND FLONUMS) ARE NOT CONSIDERED LISTS IN THIS FASHION;      *\n* INSTEAD, THEY ARE SPECIALLY COLLECTED (THEY CONSIST OF 1 CONS WHICH *\n* IS INDIVIDUALLY MARKED), SO NO PROBLEM THERE.                       *\n*                                                                     *\n* ON ENTRY REGISTER 1 POINTS TO THE OBJECT TO BE COLLECTED.           *\n*          REGISTER 15 POINTS TO THE CELL TO BE UPDATED IF THAT CELL  *\n*          POINTS TO AN OBJECT WHICH IS RELOCATED.                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nN        EQU   #5                  SEE WINSTON & HORN 2ND ED. P. 148\nP        EQU   #6                  SEE WINSTON & HORN 2ND ED. P. 148\nQ        EQU   #7                  SEE WINSTON & HORN 2ND ED. P. 148\n         SPACE 1\n*\n* INITIAL CHECK FOR NULL MOVED UP TO EXPEDITE DEGENERATE-CASE HANDLING\n*\n         CR    #1,#10              IF (NULL P)\n         BER   #14                 THEN RETURN, NOTHING TO DO\n         SPACE 1\n         ST    #14,MARKSAVE        SAVE RETURN ADDRESS\n         LR    P,#1                INIT P = ENTRY VALUE\n         LR    N,#10               INIT N = NIL\n         LR    Q,#10               INIT Q = NIL\n         LA    #0,0(,P)            CLEAR HIGH ORDER BYTE OF P\n         RCHK  #0,MARKRET          IF NOT IN CONS SPACE, SKIP COLLECT\n         CLI   ##TYPE(P),##FLONUM  IF P IS A NUMBER\n         BL    ISALIST             THEN...\n         MARK  P                    IT'S A NUMERIC ATOM - MARK IT\n         B     MARKRET              AND RETURN DOING NO MORE.\nISALIST  DS    0H                  ELSE INVOKE LIST MARKING ALGORITHM\n         SPACE\nLOOPCAR  DS    0H                  TRACK DOWN CAR.\n         SPACE\n* NOTE THIS IS THE ONLY POINT WHERE IT IS NECESSARY TO TURN ON THE\n* SECONDARY MARKING BIT.  THIS INDICATES THAT THIS CELL, WHILE NOT\n* YET OFFICIALLY MARKED, IS NOW PARTICIPATING IN THE COLLECTION\n* PROCESS AND SHOULD NOT BE PROCESSED IF ENCOUNTERED WHILE GOING\n* THROUGH THIS OR ANOTHER LIST LOOKING FOR COLLECTIBLE CONS CELLS.\n         SPACE\n         MARK2 P                                    SET TEMP GC MARK\n         CLI   ##TYPE(P),##ATOM    IF NOT A SYMBOL OR A LIST\n         BH    LOOPCDR             THEN CONTENTS OF CAR CELL NOT VALID\n         GCAR  Q,P                 (SETQ Q (CAR P))\n         LR    #15,P                                POINT TO POINTER\n         LA    #0,0(,Q)                             CLEAR TYPE BITS\n         CR    #0,#10              IF (NULL Q)\n         BE    LOOPCDR                              THEN DO NOTHING\n         RCHK  #0,LOOPCDR          IF NOT IN CONS SPACE, DO NOTHING\n         IFMK  Q,YES=LOOPCDR       IF (MARKEDP Q)   THEN DO NOTHING\n         CLI   ##TYPE(Q),##FLONUM  IF Q IS A NUMBER\n         BL    REVCAR              THEN...\n         MARK  Q                    IT'S A NUMERIC ATOM - MARK IT\n         B     LOOPCDR              AND DO NOTHING (AS IF NULL).\nREVCAR   DS    0H                  ELSE...\n         RCAR  P,N                 (RPLACA P N)     REVERSE POINTER.\n         LR    N,P                 (SETQ N P)\n         LR    P,Q                 (SETQ P Q)\n         B     LOOPCAR             (GO LOOPCAR)     CONTINUE DOWN CAR.\n         SPACE\nLOOPCDR  DS    0H                  TRACK DOWN CDR.\n         SPACE\n         MARK  P                   (MARKIT P)\n         GCDR  Q,P                 (SETQ Q (CDR P)) TRACK DOWN CDR.\n         LA    #15,##CDR(,P)                        POINT TO POINTER\n         LA    #0,0(,Q)                             CLEAR TYPE BITS\n         CR    #0,#10              IF (NULL Q)\n         BE    LOOPCONS                             THEN DO NOTHING.\n         RCHK  #0,LOOPCONS         IF NOT IN CONS SPACE, DO NOTHING\n         IFMK  Q,YES=LOOPCONS      IF (MARKEDP Q)   THEN DO NOTHING\n         CLI   ##TYPE(Q),##FLONUM  IF Q IS A NUMBER\n         BL    REVCDR              THEN...\n         MARK  Q                    IT'S A NUMERIC ATOM - MARK IT\n         B     LOOPCONS             AND DO NOTHING (AS IF NULL).\nREVCDR   DS    0H                  ELSE...\n         RCDR  P,N                 (RPLACD P N)     REVERSE POINTER.\n         LR    N,P                 (SETQ N P)\n         LR    P,Q                 (SETQ P Q)\n         B     LOOPCAR             (GO LOOPCAR)\n         SPACE\nLOOPCONS DS    0H\n         SPACE\n         LA    #0,0(,N)                             CLEAR TYPE BITS\n         CR    #0,#10              IF (NULL N)      FINISHED MARKING?\n         BE    MARKRET             THEN (RETURN)    THEN END. ELSE...\n         LR    Q,N                 (SETQ Q N)       WAS CAR OF THIS\n         IFMK1 Q,NO=REVCON         IF (MARKEDP Q)    DONE? IF SO...\n         GCDR  N,Q                 (SETQ N (CDR Q)) UNDO\n         RCDR  Q,P                 (RPLACD Q P)      POINTER\n         LR    P,Q                 (SETQ P Q)         REVERSAL.\n         B     LOOPCONS            (GO LOOPCONS)    CONTINUE UPWARDS.\nREVCON   DS    0H                                   ELSE...\n         MARK  Q                   (MARKIT Q)\n         GCAR  N,Q                 (SETQ N (CAR Q)) UNDO\n         RCAR  Q,P                 (RPLACA Q P)      POINTER\n         LR    P,Q                 (SETQ P Q)         REVERSAL.\n         B     LOOPCDR             (GO LOOPCDR)     STILL GOTTA DO CDR.\n         SPACE 1\nMARKRET  DS    0H\n         L     #14,MARKSAVE        RESTORE RETURN ADDRESS\n         BR    #14                 RETURN\n         EJECT\nRCHECK   DS    0H\n*\n* THIS ROUTINE CHECKS THE OBJECT PASSED IN #0 TO SEE IF IT IS IN\n* CONS SPACE, AND RETURNS TO +0 IF IT ISN'T.  IF IT IS IN CONS\n* SPACE, IT IS TO BE COLLECTED, AND THIS ROUTINE RETURNS +4.\n*\n* ONE THING, THOUGH: IF THE THING IS IN VECTOR/STRING SPACE, IT\n* IS PULLED THROUGH THE RELOCATING/FORWARDING GC BEFORE WE RETURN\n* SAYING THAT IT AIN'T IN CONS SPACE.  IN THIS WAY THINGS IN V/S\n* SPACE GET GC'D WITHOUT MARKLIST KNOWING OR CARING.\n*\n* REGISTER 14 IS THE RETURN ADDRESS.\n* REGISTER 15 POINTS TO THE POINTER TO BE UPDATED IF RELOCATION.\n*\n         CR    #0,#3               IF LT LOWER BOUND OF CONS SPACE\n         BL    RTRYVS              THEN NOT IN CONS SPACE\n         CR    #0,#4               IF GE UPPER BOUND OF CONS SPACE\n         BNL   RTRYVS              THEN NOT IN CONS SPACE\n         B     4(,#14)             ELSE IN CONS SPACE, RETURN SO.\nRTRYVS   DS    0H                  NOT IN CONS SPACE, TRY V/S SPACE\n         S     #0,ZLCVSADR         SEE IF LESS THAN V/S SPACE ADDRESS\n         BMR   #14                 IF SO, IN NO SPACE, RETURN SO\n         C     #0,ZLCVSLEN         SEE IF WITHIN USED V/S SPACE\n         BNLR  #14                 IF NOT, IN NO SPACE, RETURN SO\n* IT'S IN VECTOR/STRING SPACE - COLLECT IT.\n         STM   #1,#4,VSSAVE        SAVE REGISTERS USED HERE\n         LR    #2,#0\n         A     #2,ZLCVSADR         POINT TO THE OBJECT AGAIN\n         TM    ##TYPE(#2),##ATOM   IF OBJECT HAS ALREADY BEEN RELOCATED\n         BO    RNOTREL             THEN...\n*                                   STORE FORWARDED PTR INTO PLACE\n         LA    #0,3                 UPDATE POINTER WITH FORWARDED ONE:\n         N     #0,0(,#15)            GET POSSIBLE GC MARKS INTO REG\n         O     #0,##VECDAT(,#2)      COMBINE WITH POINTER VALUE\n         ST    #0,0(,#15)           STORE BACK IN WITH GC MARKS INTACT\n*\n         L     #2,VSSAVE+4          RESTORE THE ONLY CLOBBERED REGISTER\n         BR    #14                  RETURN\nRNOTREL  DS    0H                  ELSE OBJECT NOT REFERENCED YET...\n         LA    #1,##SYMLEN         Get length of a symbol\n*                                  (in case it is a symbol.  If it\n*                                  isn't a symbol, then at least we've\n*                                  cleared the high-order byte, which\n*                                  is good for loading the length)\n         CLI   ##TYPE(#2),##SYMBOL If this is a symbol,\n         BE    RGOTLEN             then we have the length.  Else...\n         LA    #1,16               length would be 16 if double float\n         CLI   ##TYPE(#2),##DFLOAT If this is a double float,\n         BE    RGOTLEN             then we have the length.  Else...\n*                                  Not a symbol - a VEC-type obj\n         ICM   #1,7,1(#2)          GET LENGTH OF DATA OF THIS OBJECT\n         BNZ   RADDIT              IF POSITIVE, NO PROBLEM\n         LA    #1,1                IF ZERO, ASSUME SOME LENGTH\nRADDIT   LA    #1,4+3(,#1)         ADD 4 FOR PREFIX AND...\n         N     #1,=X'FFFFFFFC'     ROUND UP TO FULLWORD\nRGOTLEN  DS    0H\n         LR    #3,#1               THIS GIVES LENGTH TO MOVE\n*                                  STORE RELOCATED PTR INTO PLACE\n         LA    #0,3                UPDATE POINTER WITH RELOCATED ONE:\n         N     #0,0(,#15)           GET POSSIBLE GC MARKS INTO REG\n         O     #0,VSPTR             COMBINE WITH POINTER VALUE\n         ST    #0,0(,#15)           STORE BACK IN WITH GC MARKS INTACT\n*\n         L     #0,VSPTR            PLACE TO MOVE IT TO IN NEW SPACE\n         LR    #15,#2              SAVE ADDRESS OF OLD OBJECT\n         LR    #4,#0               SAVE ADDRESS OF NEW OBJECT\n         MVCL  #0,#2               MOVE FROM OLD SPACE TO NEW SPACE\n*\n* CODE ADDED TO CHECK IF VSPTR SHOULD GO PAST END OF VSSPACE AREA\n*\n         L     #1,ZLCVSOTH\n         A     #1,ZLCVSLEN         GET ADDRESS OF END OF NEW SPACE\n         CR    #0,#1               IF WE PASSED IT\n         BH    ABEND0C3            THEN SOMETHING'S WRONG.\n*\n* END CODE ADDED TO CHECK IF VSPTR SHOULD GO PAST END OF VSSPACE AREA\n*\n         ST    #0,VSPTR            UPDATE NEW VSSPACE SLOT\n         NI    ##TYPE(#15),255-##ATOM INDICATE OBJECT FORWARDED\n         ST    #4,##VECDAT(,#15)   SET OBJECT'S FORWARDING POINTER\n         LM    #1,#4,VSSAVE        RESTORE REGISTERS\n         BR    #14                 RETURN\n         SPACE 1\nABEND0C3 EX    0,*                 FORCE 0C3 ABEND IF WE REALLY BLEW IT\n         EJECT\n*\n* DATA AREAS USED BY THE GC\n*\nVSPTR    DS    A                   @ AVAILABLE SLOT IN NEW V/S SPACE\nVSSAVE   DS    4A                  REGISTER SAVE AREA\nMARKSAVE DS    A                   REGISTER SAVE AREA\nENDVEC   DS    A                   @ END OF VECTOR BEING PROCESSED\n         SPACE 1\nZSAVREGS DS    15A\n*\n* THE FOLLOWING EQUATES ARE USED TO RELOAD PASSED REGISTER VALUES.\n*\nZSAVED0  EQU   ZSAVREGS+0\nZSAVED1  EQU   ZSAVREGS+4\nZSAVED2  EQU   ZSAVREGS+8\nZSAVED3  EQU   ZSAVREGS+12\nZSAVED4  EQU   ZSAVREGS+16\nZSAVED5  EQU   ZSAVREGS+20\nZSAVED6  EQU   ZSAVREGS+24\nZSAVED7  EQU   ZSAVREGS+28\nZSAVED8  EQU   ZSAVREGS+32\nZSAVED9  EQU   ZSAVREGS+36\nZSAVED10 EQU   ZSAVREGS+40\nZSAVED11 EQU   ZSAVREGS+44\nZSAVED12 EQU   ZSAVREGS+48\nZSAVED13 EQU   ZSAVREGS+52\nZSAVED14 EQU   ZSAVREGS+56\n         EJECT\nLCODE1   DS    0A\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  THE CODE THAT FOLLOWS IS USED TO COMPARE WITH LEXPR HEADER CODE.   *\n*  SEE ZCGBEGIN.  IF THIS CODE IS CHANGED IN ZCGBEGIN IT MUST ALSO    *\n*  BE CHANGED HERE.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #2,0(,#1)           GET POINTER TO LEXPR ARG ON STACK\n         L     #2,##CDR(,#2)       GET FIXNUM VALUE THEREOF\n         SLA   #2,2                MULTIPLY IT BY 4 TO GET STACK LENGTH\n         LA    #0,*-*(#2,#1)       HALF OF THE EXPECTED LA INSTRUCTION\n         ORG   *-2                 THROW AWAY THE OTHER HALF\nLCODE    EQU   LCODE1,*-LCODE1     LENGTH OF THIS CODE\n         SPACE 1\nGCTIME1  DS    D                   CPU TIME AT START OF GC\nGCTIME2  DS    D                   CPU TIME AT END OF GC\nDUMS     DC    D'0'                TIME INTERVAL FOR DUMMY STIMER\nVMASK    DS    8D\nVSAVE    DS    8D                  SAVE AREA FOR REG 14 THROUGH 8\nTESTTEMP DS    1D\nLASTFREE DS    1F\nFREE1ST  DS    1F\n         AIF   (NOT &ZILVF).NOVDS\nVTEMPSZ  DS    1F                  Size of vector of free pointers + 8\nVGCVP    DS    1F                  Vector section size & partial sum #\nVTEMP4   DS    1F\nVTEMPTOP DS    1F\n.NOVDS   ANOP\n         AIF   (NOT &ZILXA).NOPDS\nPGSERECB DS    F                   ECB for PGSER requests\nPGSERVSA DS    F                   Address of VS pages to be released\nPGSERVSE DS    F                   Address of end of above\n.NOPDS   ANOP\n         EJECT\n         LTORG\n         EJECT\n         AIF   (&ZILVF).VEC1100\nZIL1100A DC    C'ZIL1100 SCALAR GARBAGE COLLECTION INVOKED FROM '\n         AGO   .AFT1100\n.VEC1100 ANOP  ,\nZIL1100A DC    C'ZIL1100 GARBAGE COLLECTION (VECTOR-C) INVOKED FROM '\n.AFT1100 ANOP  ,\nZIL1100B DC    CL64' '\n         DS    C                   FILLER\nZIL1101  DC    C'ZIL1101 GARBAGE COLLECTION FAILED. NO MORE CONS CELLS X\n               AVAILABLE.'\nZIL1102A DC    C'ZIL1102 GARBAGE COLLECTED, '\nZIL1102B DC    C' CONS CELLS AND '\nZIL1102C DC    C' VSS BYTES FREE.'\nZIL1102  DS    CL(L'ZIL1102A+11+L'ZIL1102B+11+L'ZIL1102C)\nZIL1104  DC    C'ZIL1104 SEVERE ERROR, GARBAGE COLLECTION CANNOT CONTINX\n               UE.'\nZIL1107  DC    C'ZIL1107 INVALID OBJECT IN VECTOR/STRING SPACE, GARBAGEX\n                COLLECTION TERMINATED.'\n         AIF   (NOT &ZILVF).NO1109\nZIL1109  DC    C'ZIL1109 NOT ENOUGH MEMORY FOR VECTOR SWEEP WORK AREA, X\n               GARBAGE COLLECTION TERMINATED.'\n.NO1109  ANOP\nZIL1110  DC    C'ZIL1110 NON-FORWARDED SYMBOL IN OBLIST HASH ARRAY, GARX\n               BAGE COLLECTION TERMINATED.'\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Obsolete (at least no longer used) messages                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*ZIL1103 DC    C'ZIL1103 REGISTER 0 NOT SET ON ENTRY TO CONS FOR GARBAGX\n               E COLLECTION.'\n*ZIL1105 DC    C'ZIL1105 OBJECT ON OBLIST NOT A SYMBOL, GARBAGE COLLECTX\n               ION TERMINATED.'\n*ZIL1108 DC    C'ZIL1108 SYMBOL PRINT NAME IS NOT A STRING, GARBAGE COLX\n               LECTION TERMINATED.'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILCVBF": {"ttr": 11521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00F\\x00\\x88\\x01_\\x01\\x00&_\\x16E\\x01Q\\x01N\\x01P\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T16:45:46", "lines": 337, "newlines": 334, "modlines": 336, "user": "SEB1525"}, "text": "         TITLE 'ZILCVBF - ZIL 1.3 BIGNUM-TO-FLOAT CONVERSION ROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This subroutine is invoked from arithmetic functions that need      *\n* to convert a bignum to a flonum.  The interface is:                 *\n*                                                                     *\n*    L  #5,<pointer to bignum>                                        *\n*    L  #15,ZLCCVBF                                                   *\n*    BALR #14,#15                                                     *\n*    <flonum value is in FPR0)                                        *\n*                                                                     *\n* On entry #5 points to the bignum to be converted.                   *\n* The flonum value is returned in FPR0 (no consing of flonums).       *\n*                                                                     *\n* If #5 is negative, a double-float is to be built; otherwise a       *\n* single-float will be built.                                         *\n*                                                                     *\n* This routine saves, uses and restores regs 0 thru 4.  Regs 14 and   *\n* 15 are the \"branch and link\" registers.                             *\n*                                                                     *\n* Note:  #15 is the base reg throughout, except when an error must    *\n*        be signalled for floating-point overflow.                    *\n*                                                                     *\n* Logic:  See the similar routine in the FLOAT function.              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILCVBF  #ZBEG NAME='ZILCVBF'\n         SPACE 1\n         USING ZILCVBF,#15\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* See if a single-float or a double-float is required.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #5,#5               If negative\n         BM    B2D                 then go process double-float code\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Bignum to float conversion routine.                                 *\n*                                                                     *\n* This code is based on the observation that a single-precision       *\n* flonum has only 24 bits of actual precision in it.  Therefore,      *\n* we need only take the high-order 24 bits of the bignum (well,       *\n* maybe we should consider the 25th bit for rounding purposes)        *\n* and set the exponent of the flonum to represent the bit size        *\n* of the bignum.  To do this, we need the following 2 pieces          *\n* of information:                                                     *\n*                                                                     *\n* (a) the number of significant bits in the bignum (HAULONG)          *\n* (b) the high-order 24 bits of the bignum (HAIPART)                  *\n*                                                                     *\n* We then determine the characteristic of the flonum to be (a)/4,     *\n* except that a is a multiple of 31.  Therefore, we may have to       *\n* shift (b) over to the right by (4-remainder) bits to make it        *\n* a valid mantissa for the flonum whose exponent is that many bits    *\n* short of representing (a).                                          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* First, get the number of significant bits in the bignum (HAULONG).  *\n* At the same time we extract the high-order 24 bits (HAIPART).       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         STM   #0,#4,ZSAVE         Save regs\n         SPACE 1\n         XR    #4,#4               Clear insert register\n         ICM   #4,7,1(#5)          Get length of bignum text\n         SH    #4,=H'8'            Bump down by 2 words\n         LA    #0,4(,#4)           Save length of bignum minus 4\n         LA    #4,##VECDAT(#4,#5)  Point to 2 MSW's of bignum\n         L     #2,4(,#4)           Get most significant word of bignum\n         L     #3,0(,#4)           Get next most sig. word of bignum\n         N     #3,=X'7FFFFFFF'     Zero possible sign bit to make ABS\n         SLL   #3,1                Bring halves together\n         SRDL  #2,1                Shift 62-bit number into reg pair\n         SRA   #0,2                Divide length by 4 to get # of bytes\n         LR    #1,#0               then to # of bigits less M.S.W.\n         SLA   #1,5                Multiply by 31 (32X - X = 31X)\n         SR    #1,#0               to get number of bits in these words\n         LA    #1,32(,#1)          Set presumed bit count so far,\n*                                   plus 1 because we shifted #2 right\nHAULOOP  DS    0H                  Loop until we determine # of bits\n         SLDL  #2,1                Shift out leftmost bit\n         LTR   #2,#2               Test sign to see if we hit a 1-bit\n*        BZ    ...                 (can never be zero, from a bignum)\n         BM    GOTIT               If 1-bit leftmost, we got it\n         BCT   #1,HAULOOP          Reduce bit count and continue\nGOTIT    DS    0H                  Now #1 contains (HAULONG bignum)\n*             and #2 contains (HAIPART bignum 24) in high-order 24 bits\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* We then determine the characteristic of the flonum to be (#1)/4,    *\n* except that a is a multiple of 31.  Therefore, we may have to       *\n* shift (#2) over to the right by (4-remainder) bits to make it       *\n* a valid mantissa for the flonum whose exponent is that many bits    *\n* short of representing (#1).                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SRL   #2,8                Make 24-bit HAIPART value = mantissa\n         LA    #4,4                 compute shift amount\n*                                  #1 contains (HAULONG bignum)\n         XR    #0,#0               Clear other half of reg pair\n         DR    #0,#4               #0 = remainder, #1 = quotient\n         LTR   #0,#0               If remainder is nonzero,\n         BZ    RZERO               then...\n         LA    #1,1(,#1)            bump quotient (represents exponent)\n         SR    #4,#0                = 4 minus remainder\n         SRL   #2,0(#4)             shift mantissa right by that amount\nRZERO    DS    0H\n         CH    #1,=H'63'           If exponent too high, error\n         BH    ERROR\n         LA    #1,64(,#1)          Convert characteristic to excess-64\n         SLL   #1,24               Shift into high-order 8 bits\n         OR    #2,#1               Combine characteristic with mantissa\n         ST    #2,ZLCWORK          Store into work area\n         TM    ##VECDAT(#5),X'80'  If original bignum was negative\n         BZ    BNOTNEG             then\n         OI    ZLCWORK,X'80'        make flonum negative\nBNOTNEG  DS    0H\n         LE    #F0,ZLCWORK         Load single-precision float value\n         LM    #0,#4,ZSAVE         Restore saved regs\n         BR    #14                 Return with it in FPR0\n         EJECT\nB2D      DS    0H                  Convert bignum to double-float\n         SPACE 1\n         LPR   #5,#5               Make address good\n         SPACE 1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This routine is similar to the single-float conversion routine,     *\n* except (of course) that we need to extract the first 56 bits, not   *\n* the first 24.  This makes things slightly more complicated in that  *\n* we must manage a register \"triple\" (3-register \"pair\") to hold      *\n* (HAIPART bignum 56).  However, we can simplify things somewhat by   *\n* breaking down the processing into 3 cases:                          *\n*                                                                     *\n*   Case 1  -  a 2-word bignum with (HAULONG bignum) <= 56 bits       *\n*                                                                     *\n*              For this case, we can take the bits and make a         *\n*              flonum out of them directly, after converting          *\n*              the bigits to a 63-bit (actually 56-bit) doubleword.   *\n*                                                                     *\n*   Case 2  -  a 2-word bignum with (HAULONG bignum) > 56 bits        *\n*                                                                     *\n*   Case 3  -  a 3-word bignum.  (HAULONG bignum) will be > 62 bits.  *\n*                                                                     *\n* In both case 2 and case 3, we extract (HAIPART bignum 56) and       *\n* then process the contents of the register triple by finding the     *\n* proper amount(s) to shift as for the single-float algorithm         *\n* described above.                                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         STM   #0,#4,ZSAVE         Save registers used in this code\n         XR    #4,#4               Clear insert register\n         ICM   #4,7,1(#5)          Get length of bignum\n         CH    #4,=H'8'            If length greater than 8\n         BH    CASE3               then more than 2 words in bignum\n         TM    ##VECDAT+4(#5),B'01111110' If more than 31+25=56 bits on\n         BNZ   CASE2               then process slightly-long bignum\n*                                  Else 56 bits or less in bignum\n         L     #2,##VECDAT+4(,#5)  Load MSW\n         L     #3,##VECDAT+0(,#5)  Load (M-1)SW\n         N     #3,=X'7FFFFFFF'     Clear sign bit\n         SLL   #3,1                Convert from bigits\n         SRDL  #2,1                to 62-bit value in register pair\n*                                  Note hi-order 8 bits of #2 must be 0\n         STM   #2,#3,ZLCWORK       Store 56-bit mantissa-to-be\n         MVI   ZLCWORK,X'4E'       Assign characteristic\n         TM    ##VECDAT(#5),X'80'  If original bignum negative\n         BZ    C1NM                then...\n         OI    ZLCWORK,X'80'        set flonum negative\nC1NM     DS    0H\n         SDR   #F0,#F0             Normalize flonum value\n         AD    #F0,ZLCWORK          by adding to normalized double zero\n         LM    #0,#4,ZSAVE         Restore caller's registers\n         BR    #14                 Return with value in #F0\n         SPACE 1\nCASE2    DS    0H                  2-word bignum with more than 56 bits\n         SPACE 1\n         STM   #0,#7,ZSAVE         Save registers used in this code\n         LA    #0,4                Set length of bignum minus 4\n         L     #2,##VECDAT+4(,#5)  Load MSW\n         L     #3,##VECDAT+0(,#5)  Load (M-1)SW\n         N     #3,=X'7FFFFFFF'     Clear sign bit\n         XR    #7,#7               Set (M-2)SW to zeroes\n         B     C3PROC              Process like a Case 3 bignum\n         SPACE 1\nCASE3    DS    0H                  Bignum of 3 words or more\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* First, get the number of significant bits in the bignum (HAULONG).  *\n* At the same time we extract the high-order 56 bits (HAIPART).       *\n* To manage this in a register \"triple\", we do some clever shifting.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         STM   #0,#7,ZSAVE         Save regs\n         SPACE 1\n         XR    #4,#4               Clear insert register\n         ICM   #4,7,1(#5)          Get length of bignum text\n         SH    #4,=H'12'           Bump down by 3 words\n         LA    #0,8(,#4)           Save length of bignum minus 4\n         LA    #4,##VECDAT(#4,#5)  Point to 3 MSW's of bignum\n         L     #2,8(,#4)           Get most significant word of bignum\n         L     #3,4(,#4)           Get next most sig. word of bignum\n         L     #7,0(,#4)           Get third most sig. word of bignum\n         N     #7,=X'7FFFFFFF'     Zero possible sign bit to make ABS\nC3PROC   DS    0H                  Cases 2 and 3 come together here\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Convert bigits in register triple #2+#3+#7 to 93-bit number.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #6,#3               Set up auxiliary register pair\n         SLL   #7,1\n         SRDL  #6,1\n         LR    #3,#6\n         SLL   #3,2\n         SRDL  #2,2\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Now register triple #2+#3+#7 (also #2+#6+#7) has 93-bit bigit.      *\n* Compute HAULONG value while tracking how much to shift all words.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #6,#3               Prepare for HAIPART computation\n         SRA   #0,2                Divide length by 4 to get # of bytes\n         LR    #1,#0               then to # of bigits less M.S.W.\n         SLA   #1,5                Multiply by 31 (32X - X = 31X)\n         SR    #1,#0               to get number of bits in these words\n         LA    #1,33(,#1)          Set presumed bit count so far,\n*                                   plus 2 because of 3 leading 0-bits\n         XR    #4,#4               Clear shift counter\nC3HAULP  DS    0H                  Loop until we determine # of bits\n         LA    #4,1(,#4)           while increment shift counter\n         SLDL  #2,1                Shift out leftmost bit\n         LTR   #2,#2               Test sign to see if we hit a 1-bit\n*        BZ    ...                 (can never be zero, from a bignum)\n         BM    C3GOTIT             If 1-bit leftmost, we got it\n         BCT   #1,C3HAULP          Reduce bit count and continue\nC3GOTIT  DS    0H                  Now #1 contains (HAULONG bignum)\n*             and #4 contains amount to shift to complete HAIPART oper.\n         SLDL  #6,0(#4)            Shift rest of triple by that amount\n         LR    #3,#6               Get all registers in triple correct\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Now #2+#3+#7 (or #2+#6+#7) contains (HAIPART bignum 56) in the      *\n* high-order 56 bits.  This means that we no longer care about        *\n* what's in #7, so we have a register pair #2+#3 that contains        *\n* what we need.                                                       *\n*                                                                     *\n* We then determine the characteristic of the flonum to be (#1)/4,    *\n* except that a is a multiple of 31.  Therefore, we may have to       *\n* shift (#2+#3) over to the right by (4-remainder) bits to make it    *\n* a valid mantissa for the flonum whose exponent is that many bits    *\n* short of representing (#1).                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         SRDL  #2,8                Make 56-bit HAIPART value = mantissa\n         LA    #4,4                 compute shift amount\n*                                  #1 contains (HAULONG bignum)\n         XR    #0,#0               Clear other half of reg pair\n         DR    #0,#4               #0 = remainder, #1 = quotient\n         LTR   #0,#0               If remainder is nonzero,\n         BZ    C3RZERO             then...\n         LA    #1,1(,#1)            bump quotient (represents exponent)\n         SR    #4,#0                = 4 minus remainder\n         SRDL  #2,0(#4)             shift mantissa right by that amount\nC3RZERO  DS    0H\n         CH    #1,=H'63'           If exponent too high, error\n         BH    ERROR\n         LA    #1,64(,#1)          Convert characteristic to excess-64\n         SLL   #1,24               Shift into high-order 8 bits\n         OR    #2,#1               Combine characteristic with mantissa\n         STM   #2,#3,ZLCWORK       Store into work area\n         TM    ##VECDAT(#5),X'80'  If original bignum was negative\n         BZ    C3NOTNEG            then\n         OI    ZLCWORK,X'80'        make flonum negative\nC3NOTNEG DS    0H\n         SDR   #F0,#F0             Normalize (just in case we f*ed up)\n         AD    #F0,ZLCWORK         Load double-precision float value\n         LM    #0,#7,ZSAVE         Restore saved regs\n         BR    #14                 Return with it in FPR0\n         EJECT\nERROR    DS    0H                  Floating-point overflow would occur\n         SPACE 1\n         USING ZILCVBF,#15\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* For the purposes of this routine (and laziness), we assume that     *\n* the only callers thereof will have a \"normal\" function header       *\n* and a function name of reasonable length (i.e. 8 bytes or less).    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   Z+4(8),5(#12)       Move caller's name to fake string\n         XR    #0,#0\n         IC    #0,4(,#12)          Get length of function name\n         SH    #0,=H'16'\n         STCM  #0,7,Z+1            Store length of function name\n         LR    #4,#15\n         DROP  #15\n         USING ZILCVBF,#4\n         #ERR  'ZIL4102 ',Z,': Floating-point overflow converting ',   X\n               (#5),' to float.',PREFIX=NO\n         SPACE 1\nZSAVE    DS    8A                  Register save area\n         SPACE 1\n         DS    0H,XL1              Align to non-halfword boundary\nZ        DC    YL1(##STRING),AL3(0) Place to build function name string\n         DS    CL12\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILDIV": {"ttr": 11527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11Q\\x04P\\x04N\\x04O\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:51:00", "lines": 1104, "newlines": 1102, "modlines": 1103, "user": "SEB1525"}, "text": "         TITLE 'ZILDIV - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*      ZILDIV takes two arguments. Both must be numeric atoms         *\n*                                                                     *\n* Conversion rules are as follows:                                    *\n*                                                                     *\n* 1. Both args fixed         - perform integer division.              *\n* 2. Both args float         - perform real division                  *\n* 3. Bne fixed, one float    - convert the fixed argument to          *\n*                              float and perform real division.       *\n*                                                                     *\n* Division by 0 causes an error.                                      *\n*                                                                     *\n* Extended precision divide not used for bignum operations because    *\n* it is very slow on the 3090 hardware.                               *\n*                                                                     *\n*                                                                     *\n* Future improvements:                                                *\n*                                                                     *\n* ===> Optimization for lower zero bigits in the divisor.             *\n*                                                                     *\n* ===> Optimization with fast check on remainder (see Knuth).         *\n*      Actually, since addition is much faster than multiplication    *\n*      on typical hardware, the fast check is probably slower than    *\n*      a full \"quotient-bigit x divisor\" correction which can be      *\n*      done by addition or subtraction when the quotient-bigit        *\n*      correction is an increment or decrement of 1.  Thus the        *\n*      fast check is probably only faster for bignums of length       *\n*      10 bigits and more.                                            *\n*                                                                     *\n* ===> Eliminate the paths that check the remainder to see if it's    *\n*      larger than the divisor so that the quotient must be           *\n*      incremented.  It will never need to be incremented, as proven  *\n*      in Knuth.  You will also understand it intuivitely if you try  *\n*      to construct a counterexample.                                 *\n***********************************************************************\n         SPACE 1\nZILDIV   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILDIV'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM IS ARG 1 A FIXNUM?\n         BNE   NFX1                BRANCH IF NOT A FIXNUM\n         CLI   ##TYPE(#7),##FIXNUM IS ARG 2 A FIXNUM?\n         BNE   FX1NFX2             BRANCH IF 1 IS FIXNUM AND 2 NOT\n*=====================================================================*\n*            FIXNUM BY FIXNUM DIVIDE                                  *\n*=====================================================================*\n         ICM   #1,15,##CDR(#7)     CHECK ARGUMENT 2\n         L     #2,##CDR(,#6)       GET ARG1\n         BZ    FFDIVBY0            IF ZERO, ERROR\n         LCR   #3,#2               TEST COMPLEMENT OF NUMBER\n         BO    FFTM31              RESULT WILL BE BIG IF DIVISOR -1\nFFTM31NO SRDA  #2,32               SHIFT INTO REGISTERS FOR DIVIDE\n         DR    #2,#1               DIVIDE THEM\n         LR    #2,#3               GET QUOTIENT INTO REGISTER\n         #MKAT FIXED               MAKE A FIXNUM\n******** B     RETURN\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n*\nFFTM31   CH    #1,=H'-1'           WE MUST CHECK FOR -2\u00ac31/-1\n         BNE   FFTM31NO            IT'S NOT, CONTINUE WITH FIXNUM WORK\n         LA    #15,TWO31           IT IS -2\u00ac31/-1, RETURN 2\u00ac31 BIGNUM\n         B     RETURN\n*\nFX1NFX2  DS    0H\n*---------------------------------------------------------------------*\n*            ARG 1 IS A FIXNUM, ARG 2 IS NOT A FIXNUM                 *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##BIGNUM IS ARG 2 A BIGNUM?\n         BNE   FX1NBF2             IF NOT, BRANCH TO FLONUM CHECK\n*=====================================================================*\n*            FIXNUM BY BIGNUM DIVIDE                                  *\n*=====================================================================*\n         L     #1,##CDR(,#6)       GET ARG 1\n         LCR   #1,#1               CHECK FOR -2**31\n         BO    FT31MB              LOOK AT BIGNUM TOO\n         LA    #15,#SFT0           FIX/BIG MUST BE 0\n         B     RETURN\n*\nFT31MB   CLC   TWO31,0(#7)         IS BIGNUM DIVIDEND = 2\u00ac31 /\n         BE    M1                  YES, BRANCH TO MAKE -1\n         LA    #15,#SFT0           ELSE QUOTIENT IS 0\n         B     RETURN\n*\nM1       LA    #15,#SFTM1          RESULT IS -1\n         B     RETURN\n*\nNFX1     DS    0H\n*---------------------------------------------------------------------*\n*            ARG 1 IS NOT A FIXNUM                                    *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#6),##BIGNUM WELL, IS IT A BIGNUM?\n         BNE   NBFX1               IT'S NEITHER FIXED NOR BIG\n*---------------------------------------------------------------------*\n*            ARG 1 IS A BIGNUM                                        *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##BIGNUM\n         BE    BIGBIG              WE HAVE BIGNUM BY BIGNUM\n         CLI   ##TYPE(#7),##FIXNUM\n         BNE   BG1NBF2             ARG 2 NEITHER FIXNUM NOR BIGNUM\n*=====================================================================*\n*            BIGNUM BY FIXNUM DIVIDE                                  *\n*=====================================================================*\n         L     #7,##CDR(#7)        LOAD FIXNUM\n         XR    #2,#2               CLEAR FOR ICM OF LENGTH\n         CH    #7,=H'1'            DIVIDING BY 1?\n         BE    RETURN6             THEN RETURN POINTER TO DIVIDEND\n         CH    #7,=H'-1'           DIVIDING BY -1?\n         BE    BFM1                YES, THEN CHECK SPECIAL CASE\n         ST    #7,FDIVISOR         STORE DIVISOR WITH ORIGINAL SIGN\n         LPR   #7,#7               TAKE POSITIVE VALUE FOR DIVISOR\n         LA    #3,4                MULTIPURPOSE CONSTANT 4\n         BZ    BFDIVBY0            ATTEMPTED TO DIVIDE BIGNUM BY 0\n         BO    BFMT31              DIVISOR IS MOST NEGATIVE FIXNUM\n         ICM   #2,7,1(#6)          GET BIGNUM LENGTH\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         AR    #2,#3               ASK FOR BIGNUM LENGTH + ##VECDAT\n         #BASR #14,#15             CALL ZILBIG\n         L     #6,0(#11)           GC MAY HAVE MOVED BIGNUM POINTER\n         LR    #1,#2               SAVE BIGNUM LENGTH + 1 WORD\n         LCR   #3,#3               GENERATE MULTIPURPOSE -4\n         AR    #1,#3               #1 = LENGTH\n         L     #4,##VECDAT-4(#1,#6) LOAD MS WORD OF BIGNUM\n         SRDL  #4,32               SHIFT RIGHT AND CLEAR\n         DR    #4,#7               DO FIRST DIVIDE INTO HI WORD\n         LTR   #5,#5               IS FIRST QUOTIENT 0?\n         BZ    BF1LESS             RESULT IS ONE WORD SHORTER\n         ST    #5,##VECDAT-4(#1,#15) STORE MS WORD OF QUOTIENT\n         STCM  #1,7,1(#15)         SET LENGTH IN RESULT HEADER\n         AR    #1,#3               #1 = LENGTH - 1 WORD\n         AR    #1,#3               #1 = LENGTH - 2 WORDS\nBFLOOP   L     #5,##VECDAT(#1,#6)  LOAD NEXT WORD OF DIVIDEND\n         SLL   #5,1                SQUEEZE OUT (SIGN) JUNK BIT\n         SRDL  #4,1                RIGHT JUSTIFY 64-BIT DIVIDEND\n         DR    #4,#7               DIVIDE FOR THIS SIGNIFICANCE\n         ST    #5,##VECDAT(#1,#15) STORE THIS INTO RESULT BIGNUM\n         BXH   #1,#3,BFLOOP        ANY MORE DIVIDEND WORDS LEFT?\n         AR    #2,#15              POINT TO END OF BIGNUM\n         L     #7,FDIVISOR         get divisor with sign\n         X     #7,##VECDAT(,#6)    combine with sign of dividend\n         N     #7,=X'80000000'     retain only the sign\n         O     #7,##VECDAT(,#15)   combine with least word of bignum\n         ST    #7,##VECDAT(,#15)   store sign and least bignum word\n         CLC   TWO31MX,0(#15)      check for illegal bignum -2\u00ac31\n         BE    RETT31M             if it's there, issue -2\u00ac31 fixnum\n         ST    #2,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER\n         B     RETURN\n*\nBFM1     CLC   TWO31,0(#6)         IS SITUATION 2\u00ac31/(-1)=-2\u00ac31?\n         BE    RETT31M             YES, THEN RETURN MOST NEG FIXNUM\n         ICM   #2,7,1(#6)          OTHERWISE IT'S BIGNUM, GET LEN\n         L     #15,ZLCBIG          GET ADDRESS OF SPACE SERVICE ROUTINE\n         LA    #2,##VECDAT(,#2)    MUST ASK FOR HEADER SPACE TOO\n         #BASR #14,#15             ALLOCATE THE RESULT BIGNUM SPACE\n         L     #6,0(#11)           RELOAD POINTER (IN CASE OF GC)\n         LR    #7,#2               LENGTH OF SOURCE FOR MVCL\n         LR    #4,#15              DESTINATION START FOR MVCL\n         LR    #5,#2               LENGTH OF DESTINATION FOR MVCL\n         MVCL  #4,#6               MOVE THE BIGNUM\n         XI    ##VECDAT(#15),X'80' FLIP THE SIGN IN THE RESULT\n         ST    #4,ZLCVSNXT\n         B     RETURN\n*\nBFMT31   CLC   0(4,#6),BIG8        CHECK IF RESULT WILL BE FIXNUM\n         BE    BFMT31F             RESULT MUST BE A FIXNUM\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         ICM   #2,7,1(#6)          GET BIGNUM LENGTH\n         #BASR #14,#15             CALL ZILBIG\n         L     #6,0(#11)           GC MAY HAVE MOVED BIGNUM POINTER\n         LA    #0,##VECDAT+4(,#6)  STARTING POINT FOR MVCL COPY\n         LR    #1,#2               put source length into reg 1\n         SLR   #1,#3               subtract 1 word from source length\n         LA    #4,##VECDAT(,#15)   DESTINATION FOR MVCL\n         STCM  #1,7,1(#15)         SET LENGTH IN RESULT HEADER\n         LR    #5,#1               COPY LENGTH\n         MVCL  #4,#0               COPY TO ANSWER\n         TM    ##VECDAT(#6),X'80'  TEST DIVIDEND FOR MINUS SIGN\n         BZ    BMFP                MAKE THE RESULT BIGNUM NEGATIVE\n         ST    #4,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER\n         B     RETURN\n*\nRETT31M  LA    #15,TWO31M          ANSWER MUST BE -2\u00ac31, A FIXNUM\n         B     RETURN\n*\nBFMT31F  L     #2,##VECDAT+4(,#6)  GET UPPER WORD WHICH WILL BE ANSWER\n         TM    ##VECDAT(#6),X'80'  TEST DIVISOR FOR MINUS SIGN\n         BO    NOCOMPL             DON'T NEED TO COMPLEMENT FIXNUM\n         LCR   #2,#2               NEED TO COMPLEMENT FIXNUM\nNOCOMPL  #MKAT FIXED               CONS UP A FIXNUM FOR ANSWER\n         B     RETURN\n*\nBMFP     OI    ##VECDAT(#15),X'80' PUT MINUS SIGN INTO ANSWER\n         CLC   TWO31MX,0(#15)      check for illegal bignum -2\u00ac31\n         BE    RETT31M             if it's there, issue -2\u00ac31 fixnum\n         ST    #4,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER\n         B     RETURN\n*\nRETURN6  LR    #15,#6              RETURN DIVIDEND AS RESULT\n         B     RETURN\n*\nBF1LESS  AR    #1,#3               #1 = LENGTH - 1 WORD\n         STCM  #1,7,1(#15)         SET LENGTH IN HEADER OF RESULT\n         AR    #1,#3               #1 = LENGTH - 2 WORDS\n         BNZ   BFLOOP              is result not going to be fixnum?\n         L     #7,FDIVISOR         PICK UP DIVISOR WITH SIGN\n         ICM   #5,15,##VECDAT(#6)  GET LS WORD OF ARG1, TEST SIGN\n         BNM   BF1LFXNM            RESULT WILL NOT BE MINUS FIXNUM\n         LCR   #7,#7               THIS WILL ENSURE THAT SIGN COMES OUT\nBF1LFXNM SLL   #5,1                SQUEEZE OUT SIGN BIT\n         SRDL  #4,1                RIGHT JUSTIFY 64-BIT DIVIDEND\n         DR    #4,#7               DIVIDE TO GET FIXNUM RESULT\n         LR    #2,#5               POSITION QUOTIENT FOR FIXNUM CONS\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN\n*=====================================================================*\n*            BIGNUM BY BIGNUM DIVIDE                                  *\n*=====================================================================*\nBIGBIG   CLC   1(3,#6),1(#7)       COMPARE LENGTHS IN BIGNUM HEADERS\n         BH    B1B2                QUOTIENT COULD BE EITHER FIX OR BIG\n         BL    RETURN0             LENGTH OF ARG1 IS SMALLER, RETURN 0\n         XR    #5,#5               CLEAR FOR INSERTION OF 3-BYTE LENGTH\n         ICM   #5,7,1(#6)          GET BIGNUM LENGTHS - BOTH SAME NOW\n         L     #0,##VECDAT-4(#5,#7) LOAD MS WORD OF ARG2 BIGNUM\n         CL    #0,##VECDAT-4(#5,#6) COMPARE WITH MS WORD OF ARG1 BIGNUM\n         BH    RETURN0             ARG1 MAGNITUDE SMALLER, RETURN 0\n         BE    MSE                 MOST SIGNIFICANT WORDS ARE EQUAL\n*---------------------------------------------------------------------*\n*    MS WORD OF DIVIDEND IS LARGER, SAME LENGTH, ONLY 1 TRIAL DIVIDE  *\n*    NEEDED BECAUSE RESULT WILL BE A FIXNUM                           *\n*---------------------------------------------------------------------*\n         SH    #5,=H'8'            FINDING OUT MORE ABOUT THE LENGTH\n         BZ    MSH2                it must be 2 2-word bignums\n         #BAS  #14,LJSHIFT         get negative of left justify amount\n*\n         L     #0,##VECDAT+4(#5,#7) GET MS WORD OF DIVISOR\n         L     #1,##VECDAT(#5,#7)  GET NEXT MS WORD OF DIVISOR\n         SLL   #1,1                SQUEEZE OUT JUNK BIT\n         SRDL  #0,32(#4)           LEFT JUSTIFY 31 DIVISOR BITS IN #1\n*\n         L     #2,##VECDAT+4(#5,#6) GET MS WORD OF DIVIDEND\n         L     #3,##VECDAT(#5,#6)  GET NEXT WORD OF DIVIDEND\n         SLL   #3,1                SQUEEZE OUT JUNK BIT\n         SRDL  #2,32(#4)           ALIGN DIVIDEND WITH DIVISOR IN #1\n*\n         DR    #2,#1               TRIAL DIVISION\n*---------------------------------------------------------------------*\n* Compute required size of work area.  Then if more space is needed,  *\n* ask for about 1024 bytes more.  This will insure that many requests *\n* for progressively slightly larger spaces will not often require     *\n* a new FREEMAIN-GETMAIN combination.                                 *\n*                                                                     *\n* The workarea is here only needed for the remainder.  Since only     *\n* one quotient bigit is used, only one remainder is computed, and     *\n* is only needed for comparison with the divisor.  This workarea      *\n* is actually not needed if we depend on Knuth's observation the      *\n* quotient bigit will never be estimated too low.  If it is too high  *\n* there will always be a borrow left over when computing the          *\n* remainder, which tells us it's too high.                            *\n*---------------------------------------------------------------------*\n         LA    #14,16(,#5)         Required size of work area\n         C     #14,ZLCWALEN        If current workarea is big enough\n         BNH   WAOK1               then go use it\n         L     #1,ZLCWA            Else get address of current workarea\n         L     #0,ZLCWALEN         Get current workarea size\n         FREEMAIN R,LV=(0),A=(1)   Free the old workarea\n         LA    #14,1023(,#14)      Round up and ask for extra\n         N     #14,=X'FFFFFFF8'     to next multiple of 8\n         LR    #0,#14              Get that length ready for GETMAIN\n         #GETMAIN RC,LV=(0),LOC=BELOW Get a new work area\n         LTR   #15,#15             If getmain failed\n         BNZ   GERROR              then error - not enough storage\n         ST    #1,ZLCWA            Else store new work area address\n         ST    #14,ZLCWALEN        and store new work area length\nWAOK1    DS    0H                  Big enough workarea now available\n         L     #14,ZLCWA           Get address of workarea\n*\n         STM   #8,#11,ZLCISAVE     NEED MORE REGISTERS (NOT #12,#13)\n         OI    ZLCIFLGS,ZLCISVD    INDICATE THERE ARE REGISTERS SAVED\n*\n         EJECT\n*---------------------------------------------------------------------*\n*    MS WORD OF DIVIDEND IS LARGER, SAME LENGTH, ONLY 1 TRIAL DIVIDE  *\n*    NEEDED BECAUSE RESULT WILL BE A FIXNUM                           *\n*                                                                     *\n*                                                    quotient         *\n*                                                    +------+         *\n*                                                    |  #3  |         *\n*                                                    +------+         *\n*                    divisor         +-----------------------         *\n*             +------+------+s-----+ | +------+------+s-----+         *\n*             |      |      |#1    | | |      |      |#8    | dividend*\n*             +------+------+------+ | +------+------+------+         *\n*                               +------+------+------+                *\n*                             + |      |      |    #8|        carry   *\n*                               +------+------+------+                *\n*                               +------+------+------+                *\n*                             - |      |      |  #0  |        mult hi *\n*                               +------+------+------+                *\n*                                      +------+------+------+         *\n*                                    - |      |      |  #1  | mult lo *\n*                                      +------+------+------+         *\n*                              -------------------------------        *\n*                                      +------+------+------+         *\n*                                      |      |      |  #8  | remaindr*\n*                                      +------+------+------+         *\n*                                                                     *\n* Inclusive range of possible results are indicated for operations    *\n* where it is important to track the possibility of overflow.         *\n* For example, a result can be known to be limited to a certain       *\n* range between A and B inclusive, would be indicated by {A,B}        *\n* in the comment field.  {0,2\u00ac31-1}, for example, is the full         *\n* range of positive, 32-bit signed integers in two's complement       *\n* notation.                                                           *\n*---------------------------------------------------------------------*\nMSHCHK   L     #1,##VECDAT(,#7)    load divisor least-significant word\n         N     #1,=X'7FFFFFFF'     {0,2\u00ac31-1} mask out the sign bit\n         MR    #0,#3               multiply quotient and divisor word\n         SLDL  #0,1                {0,2\u00ac31-2} shift for 31-bit radix\n         SRL   #1,1                {0,2\u00ac31-1} restore lower word\n         L     #8,##VECDAT(,#6)    load dividend word\n         N     #8,=X'7FFFFFFF'     {0,2\u00ac31-1} mask out the sign bit\n         SR    #8,#1               {-(2\u00ac31-1),2\u00ac31-1} subtract mult hi\n         SRDA  #8,31               {-1,0} shift out all but carry\n         SRL   #9,1                {0,2\u00ac31-1} right-justify the 31 bits\n         ST    #9,##VECDAT(,#14)   store remainder in word in work area\n         EJECT\n*---------------------------------------------------------------------*\n* When we enter here, reg 0 contains the hi word from the previous    *\n* multiplication, and reg 8 holds the carry from the previous         *\n* remainder word computation.                                         *\n*                                                    quotient         *\n*                                                    +------+         *\n*                                                    |  #3  |         *\n*                                                    +------+         *\n*                    divisor         +-----------------------         *\n*             +------+------+s-----+ | +------+------+s-----+ (#2,#6) *\n*    (#2,#7)  |      |#1    |      | | |      |      |      | dividend*\n*             +------+------+------+ | +------+------+------+         *\n*                               +------+------+------+                *\n*                             + |      |    #8|#8    |        carry   *\n*                               +------+------+------+                *\n*                               +------+------+------+                *\n*                             - |      |  #0  |#0    |        mult hi *\n* BXLE registers:               +------+------+------+                *\n*   #4 = increment                     +------+------+------+         *\n*   #5 = length - 8                  - |      |  #1  |      | mult lo *\n*                                      +------+------+------+         *\n*                              -------------------------------        *\n*                                      +------+------+------+         *\n*                             (#2,#14) |      |  #8#9| done | remaindr*\n*                                      +------+------+------+         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         XR    #2,#2               INITIALIZE INDUCTION BXLE COUNTER\n         LA    #4,4                INCREMENT AMOUNT OF BXLE LOOP\nMSHLOOPM L     #1,##VECDAT+4(#2,#7) load divisor word\n         SLR   #8,#0               {-(2\u00ac31-1),0} sub hi-mul from carry\n         MR    #0,#3               multiply quotient and divisor words\n         SLDL  #0,1                {0,2\u00ac31-2} shift for 31-bit radix\n         SRL   #1,1                {0,2\u00ac31-1} restore lower word\n         A     #8,##VECDAT+4(#2,#6) {-(2\u00ac31-1),2\u00ac31-1} add dividend wrd\n         SR    #8,#1               {-(2\u00ac32-2),2\u00ac31-1} sub lo-mul\n         BO    MSHMC               double carry if overflow\n         SRDA  #8,31               {-1,0} shift all but carry amount\n         SRL   #9,1                {0,2\u00ac31-1} right-justify the 31 bits\n         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area\n         BXLE  #2,#4,MSHLOOPM      iterate to next word?\n*---------------------------------------------------------------------*\n* Compare remainder to divisor.  Remainder should be positive but     *\n* less than the divisor.  If it's negative, we decrement the quotient.*\n* If it's positive, we increment the quotient.                        *\n*---------------------------------------------------------------------*\n         CR    #8,#0               carry off the end?\n         BNE   MSHDQ               if not, then quotient is too high\n*---------------------------------------------------------------------*\n* The comparison with the divisor below can theoretically be          *\n* eliminated, since the quotient bigit can never bee too low (see     *\n* Knuth, Vol 2).  However, we keep it in here a little longer to      *\n* catch any bugs in the code that leads to this point.  At the same   *\n* time, this provides a more reliable divide since it has such a      *\n* self check.                                                         *\n*                                                                     *\n* That is, all paths below which never lead to an MSHDQ can simply    *\n* be replaced by a direct branch to MSHOK.                            *\n*---------------------------------------------------------------------*\n         C     #9,##VECDAT(#2,#7)  is highest word of remainder to big?\n         BH    MSHIQ               if so, inc quotient & check it again\n         LCR   #1,#4               generate a -4 for the BXH\n         LR    #2,#5               initialize the count to the top\nMSHCMPR  L     #9,##VECDAT+4(#2,#14) get remainder word\n         C     #9,##VECDAT+4(#2,#7) compare with dividend word\n         BH    MSHIQ               remainder to high, inc. quotient\n         BL    MSHOK               remainder is lower than divisor, ok\n         BXH   #2,#1,MSHCMPR       not reached next to last word?\n*\n         L     #9,##VECDAT(,#7)    least significant word of divisor\n         N     #9,=X'7FFFFFFF'     mask out the sign bit\n         C     #9,##VECDAT(,#14)   compare these words\n         BH    MSHOK               divisor is bigger than remainder, ok\n*\n***MSHIQ AH    #3,=H'1'            increment the quotient\n***      BP    MSHCHK              check the incremented quotient\nMSHIQ    B     BUG3                MSHIQ should never happen, see Knuth\n*\n*                                  really part of MSHLOOPM above\nMSHMC    SRDA  #8,31               {-1,0} shift all but carry amount\n         BM    BUG5             DIVSRDA,BM,SRL,SH>LR #9,#8;LH #8,=H'-2'\n         SRL   #9,1                {0,2\u00ac31-1} right-justify the 31 bits\n         SH    #8,=H'2'            subtract the double carry\n         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area\n         BXLE  #2,#4,MSHLOOPM      iterate to next word?\n*\nMSHDQ    BCT   #3,MSHCHK           decrement quotient and check it\n         B     BUG4                can't happen! quotient always > 0\n*\nMSHOK    LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS\n         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED\n         LR    #2,#3               get result into register for #MKAT\n         TM    ##VECDAT(#6),X'80'  test sign of dividend\n         BNO   *+6\n         LCR   #2,#2               incorporate sign into answer\n         TM    ##VECDAT(#7),X'80'  test sign of divisor\n         BNO   *+6\n         LCR   #2,#2               incorporate sign into answer\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               create the fixnum answer\n         B     RETURN\n*---------------------------------------------------------------------*\n*    MS WORD OF DIVIDEND AND DIVISOR ARE THE SAME, ANSWER WILL BE     *\n*    -1, 0, OR 1.  TRIAL DIVISION NOT NECESSARY                       *\n*---------------------------------------------------------------------*\nMSE      SH    #5,=H'12'           SETUP COUNT FOR BXH\n         BM    MSE2                2-WORD/2-WORD DIVIDE\n         LH    #3,=H'-4'           DECREMENT COUNT FOR BXH\nMSEBXH   L     #0,##VECDAT+4(#5,#6) GET WORD OF DIVIDEND FOR COMPARE\n         CL    #0,##VECDAT+4(#5,#7) COMPARE WITH SAME WORD IN DIVISOR\n         BNE   MSEBXHNE            STOP LOOP IF PAIR IS NOT EQUAL\n         BXH   #5,#3,MSEBXH        CHECK NEXT PAIR OF WORDS?\n*\nMSE2     L     #0,##VECDAT(,#6)    DOWN TO LAST PAIR OF WORDS\n         L     #1,##VECDAT(,#7)    GET THE DIVISOR LS WORD\n         LR    #2,#0               SAVE FOR COMPUTATION OF SIGN\n         XR    #2,#1               COMPUTE SIGN OF RESULT\n         SLL   #0,1                SHIFT OUT THE SIGN BIT\n         SLL   #1,1                SHIFT OUT THE SIGN BIT\n         CLR   #0,#1               COMPARE THE TWO LS WORDS\n         BL    RETURN0             DIVIDEND IS LESS, RETURN 0\n         LTR   #2,#2               TEST SIGN OF RESULT\n         BM    MSEFM1              RESULT IS -1 /\n         LA    #15,#SFT1           RESULT IS 1\n         B     RETURN\nMSEFM1   LA    #15,#SFTM1          RESULT IS -1\n         B     RETURN\n*\nMSEBXHNE BL    RETURN0             NUMERATOR SMALLER, RETURN 0\n         L     #0,##VECDAT(,#6)    GET SIGN OF DIVIDEND\n         X     #0,##VECDAT(,#7)    COMBINE WITH SIGN OF DIVISOR\n         LTR   #0,#0               TEST SIGN OF RESULT\n         BM    MSEFM1              RESULT IS -1\n         LA    #15,#SFT1           RESULT IS 1\n         B     RETURN\n         SPACE\nRETURN0  LA    #15,#SFT0           RETURN POINTER TO 0\n         B     RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*    We know the answer will be a fixnum when we get here, because    *\n*    the bignums are of the same length in terms of 31-bit \"bigits\".  *\n*---------------------------------------------------------------------*\nMSH2     #BAS  #14,LJSHIFT         GET NEGATIVE OF LEFT JUSTIFY AMOUNT\n*\n         L     #0,##VECDAT+4(,#7)  GET MS WORD OF DIVISOR\n         L     #1,##VECDAT(,#7)    GET LS WORD OF DIVISOR\n         SLL   #1,1                SQUEEZE OUT SIGN BIT\n         SRDL  #0,32(#4)           LEFT JUSTIFY 31 DIVISOR BITS IN #1\n*\n         L     #2,##VECDAT+4(,#6)  GET MS WORD OF DIVIDEND\n         L     #3,##VECDAT(,#6)    GET LS WORD OF DIVIDEND\n         SLL   #3,1                SQUEEZE OUT SIGN BIT\n         SRDL  #2,32(#4)           ALIGN DIVIDEND WITH DIVISOR IN #1\n*\n         DR    #2,#1               TRIAL DIVISION\n*\nMSH2CHK  L     #5,##VECDAT(,#7)    GENERATE TRIAL QUOTIENT * DIVISOR\n         N     #5,=X'7FFFFFFF'     MASK OUT THE SIGN BIT\n         MR    #4,#3               QUOTIENT * LS WORD OF DIVISOR\n         L     #1,##VECDAT+4(,#7)  GET MS WORD OF DIVISOR\n         MR    #0,#3               QUOTIENT * MS WORD OF DIVISOR\n         SLDL  #4,1                MOVE OVER 1 BIT FOR 31-BIT RADIX\n         SLDL  #0,1                MOVE OVER 1 BIT FOR 31-BIT RADIX\n         SRL   #5,1                RESTORE POSITION OF LS WORD\n         SRL   #1,1                RESOTRE POSITION OF LS WORD\n*                                  SUBTRACT FROM DIVISOR\n         LTR   #0,#0               TEST MS WORD OF HIGHER PRODUCT\n         BNZ   MSH2DQ              GO AND DECREMENT QUOTIENT IF NOT 0\n         LR    #2,#1\n         L     #1,##VECDAT(,#6)    GET LS WORD OF DIVIDEND\n         N     #1,=X'7FFFFFFF'     MASK OUT SIGN BIT\n         SR    #1,#5               COMPUTE LS WORD OF REMAINDER\n         XR    #0,#0               CLEAR REG\n         SLDL  #0,1                SLIP IN THE SUBTRACT CARRY BIT\n         SRL   #1,1                RESTORE LS WORD OF REM IN 31 RADIX\n         L     #14,##VECDAT+4(,#6) GET MS WORD OF DIVIDEND\n         SR    #14,#0              SUBTRACT THE CARRY BIT\n         SR    #14,#4              SUBTRACT MS WORD OF LOWER PRODUCT\n         BM    MSH2DQ              SUBTRACTING TOO MUCH, DECREMENT QUO\n         SR    #14,#2              SUBTRACT LS WORD OF HIGHER PRODUCT\n         BM    MSH2DQ              SUBTRACTING TOO MUCH, DECREMENT QUO\n*\n         CL    #14,##VECDAT+4(,#7) COMPARE REMAINDER AND DIVISOR MS WRD\n         BH    MSH2IQ              REMAINDER TOO BIG, INCREMENT QUO\n         BL    RETURNR3            QUOTIENT IS GOOD, IT'S IN REGISTER 3\n         L     #5,##VECDAT(,#7)    GET LS WORD OF DIVISOR\n         N     #5,=X'7FFFFFFF'     MASK OUT THE SIGN BIT\n         CLR   #1,#5               COMPARE REMAINDER AND DIVISOR LS WRD\n         BNL   MSH2IQ       DIV    REMAINDER TOO BIG, INCREMENT QUO\n*\nRETURNR3 LR    #2,#3               SETUP FOR REAL RETURN\n         TM    ##VECDAT(#6),X'80'  test sign of dividend\n         BNO   *+6\n         LCR   #2,#2               incorporate sign into answer\n         TM    ##VECDAT(#7),X'80'  test sign of divisor\n         BNO   *+6\n         LCR   #2,#2               incorporate sign into answer\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               create the fixnum answer\n         B     RETURN\n*\nMSH2DQ   BCT   #3,MSH2CHK\n         B     BUG1                #3 should never decrement to 0\n*\n**MSH2IQ AH    #3,=H'1'            increment the quotient\n**       BP    MSH2CHK\nMSH2IQ   B     BUG2                MSH2IQ will never happen, see Knuth\n*=====================================================================*\n*  General bignum by bignum divide.  Here we know the indicated       *\n*  length of the dividend is one word longer than the divisor.        *\n*  So the magnitude of the answer must be 1 or greater.               *\n*=====================================================================*\nB1B2     XR    #3,#3               clear registers for next operations\n         XR    #5,#5               \"\n         ICM   #3,B'0111',1(#6)    get length of dividend bignum\n         ICM   #5,B'0111',1(#7)    get length of divisor bignum\n         LA    #2,8(,#3)           result may be 8 greater than diff\n         L     #15,ZLCBIG          get address ZILBIG\n         SLR   #2,#5               subtract the two bignum lengths (+8)\n         #BASR #14,#15             get space for possible bignum\n         LM    #6,#7,0(#11)        reload args - moved if there was GC\n*---------------------------------------------------------------------*\n* Compute required size of work area.  Then if more space is needed,  *\n* ask for about 1024 bytes more.  This will insure that many requests *\n* for progressively slightly larger spaces will not often require     *\n* a new FREEMAIN-GETMAIN combination.                                 *\n*                                                                     *\n* The workarea is here needed for both the remainder at each quotient *\n* bigit but also for the continually updated full remainder, which    *\n* is the new dividend for each new quotient bigit calculation.        *\n*---------------------------------------------------------------------*\n         LA    #14,16(#3,#5)       Required size of work area\n         C     #14,ZLCWALEN        If current workarea is big enough\n         BNH   WAOK2               then go use it\n         STM   #15,#0,SAVE1500     Else save regs that'll get clobbered\n         L     #1,ZLCWA            Else get address of current workarea\n         L     #0,ZLCWALEN         Get current workarea size\n         FREEMAIN R,LV=(0),A=(1)   Free the old workarea\n         LA    #14,1023(,#14)      Round up and get extra to stop trash\n         N     #14,=X'FFFFFFF8'     to next multiple of 8\n         LR    #0,#14              Get that length ready for GETMAIN\n         #GETMAIN RC,LV=(0),LOC=BELOW Get a new work area\n         LTR   #15,#15             If getmain failed\n         BNZ   GERROR              then error - not enough storage\n         ST    #1,ZLCWA            Else store new work area address\n         ST    #14,ZLCWALEN        and store new work area length\n         LM    #15,#0,SAVE1500     Restore regs that got clobbered\nWAOK2    DS    0H                  Big enough workarea now available\n         L     #14,ZLCWA           Address of workarea - divident pntr\n*\n         STM   #8,#11,ZLCISAVE     NEED MORE REGISTERS (NOT #12,#13)\n         OI    ZLCIFLGS,ZLCISVD    INDICATE THERE ARE REGISTERS SAVED\n*\n         LR    #11,#3              we need reg 3 for other purposes\n*\n         LA    #0,##VECDAT(,#6)    source starting point of dividend\n         LR    #1,#3               length to copy from source\n         LA    #2,##VECDAT(,#14)   destination\n         LA    #3,4(,#3)           pad an extra word=0 at end\n         MVCL  #2,#0               make a copy of the dividend\n         NI    ##VECDAT(#14),X'7F' mask sign in work area dividend\n*\n         SH    #11,=H'8'           dividend offset the length by 8\n         ST    #2,REMPTR           REMAINDER work area (left by MVCL)\n         LR    #10,#11             get set to compute dividend offset\n         SH    #5,=H'8'            divisor offset the length by 8\n         SLR   #10,#5              dividend offset\n         ST    #10,BIGLDIFF        save the length difference for later\n*\n         L     #0,##VECDAT+4(#5,#7) DIVcheck that reg 0 clobber OK\n         #BAS  #14,LJSHIFT         call bit-justification routine\n         ST    #4,RSHIFT           store the shift amount (negative)\n*\n         L     #0,##VECDAT+4(#5,#7) highest word of divisor\n         L     #1,##VECDAT(#5,#7)  next most highest word\n         SLL   #1,1                sqeeze out junk bit\n         SRDL  #0,32(#4)           justify all 64 bits\n         ST    #1,FDIVISOR\n*\n         L     #6,ZLCWA            load dividend pointer\n         L     #2,##VECDAT+4(#11,#6) highest word of dividend\n         L     #3,##VECDAT(#11,#6) next most highest word\n         SLL   #3,1                squeeze out junk bit\n         SRDL  #2,32(#4)           do shift amount\n*\n         DR    #2,#1               divide to get best guess\n*\n         LA    #6,0(#10,#6)        offset to fake dividend\n         L     #14,REMPTR          load pointer to remainder\n         B     BBCHK               check the quotient bigit\n*---------------------------------------------------------------------*\n* Start processing for next bigit.                                    *\n*---------------------------------------------------------------------*\nQBIGIT   L     #6,ZLCWA            load dividend pointer\n         L     #4,RSHIFT           recall shift amount\n         LA    #6,0(#10,#6)        offset to fake dividend\n*\n         L     #0,##VECDAT+8(#5,#6) highest word of dividend\n         L     #2,##VECDAT+4(#5,#6) next word of dividend\n         L     #3,##VECDAT(#5,#6)  next word of dividend\n         LR    #1,#2               to avoid another memory load\n         SLL   #3,1                squeeze out junk bit\n         SLL   #1,1                squeeze out junk bit\n         SRDL  #2,31(#4)           do shift amount\n         SRDL  #0,32(#4)           do shift amount\n         LR    #2,#1               put together the two parts\n         CL    #1,FDIVISOR         is division going to overflow?\n         BL    QDIV                no, go ahead and divide\n         L     #3,=X'7FFFFFFF'     overflow, ok, just put in max\n         B     BBCHK               then check this as if we divided\n*\nQDIV     SRDL  #2,1                final shift\n         D     #2,FDIVISOR         divide to get best guess\n         EJECT\n*---------------------------------------------------------------------*\n* Register usage:                                                     *\n*                                                                     *\n*   #0 = stack pointer and misc                                       *\n*   #1 = misc                                                         *\n*   #2 = misc                                                         *\n*   #3 = quotient bigit                                               *\n*   #4 = 4                                                            *\n*   #5 = L2 (Length of B2 - the divisor)                              *\n*   #6 = (fake B1) - full remainder (dividend for next bigit)         *\n*   #7 = (B2)                                                         *\n*   #8 = misc                                                         *\n*   #9 = misc                                                         *\n*  #10 = offset in dividend = (L1 - L2) or less                       *\n*  #11 = L1 (length of B1 - the dividend)                             *\n*  #12 = --base register for this module--                            *\n*  #13 = --common area pointer--                                      *\n*  #14 = temporary remainder (remainder by from bigit times divisor)  *\n*  #15 = pointer to result vector                                     *\n*                                                                     *\n*  The temporary registers are used as follows in the first part      *\n*  of the code below.                                                 *\n*                                                    quotient         *\n*                                             +------+                *\n*                                             |    #3|                *\n*                                             +------+                *\n*                    divisor         +-----------------------         *\n*                    +------+s-----+ | +------+------+------+ (#2,#6) *\n*   (#2,#7)          |      |#1    | | |      |#8    |      | dividend*\n*                    +------+------+ | +------+------+------+         *\n*                               +------+------+                       *\n*                             + |      |    #8|               carry   *\n*                               +------+------+                       *\n*                               +------+------+                       *\n* BXLE registers:             - |      |  #0  |               mult hi *\n*   #4 = increment              +------+------+                       *\n*   #5 = length - 8                    +------+------+                *\n*                                    - |      |  #1  |        mult lo *\n*                                      +------+------+                *\n*                              -------------------------------        *\n*                                      +------+------+                *\n*            (#2,#14)    new dividend  |      |  #8  |        remaindr*\n*                                      +------+------+                *\n*                                                                     *\n* Inclusive range of possible results are indicated for operations    *\n* where it is important to track the possibility of overflow.         *\n* For example, a result can be known to be limited to a certain       *\n* range between A and B inclusive, would be indicated by {A,B}        *\n* in the comment field.  {0,2\u00ac31-1}, for example, is the full         *\n* range of positive, 32-bit signed integers in two's complement       *\n* notation.                                                           *\n*---------------------------------------------------------------------*\n         EJECT\nBBCHK    L     #1,##VECDAT(,#7)    load divisor least-significant word\n         N     #1,=X'7FFFFFFF'     {0,2\u00ac31-1} mask out the sign bit\n         MR    #0,#3               multiply quotient and divisor word\n         SLDL  #0,1                {0,2\u00ac31-2} shift for 31-bit radix\n         SRL   #1,1                {0,2\u00ac31-1} restore lower word\n         L     #8,##VECDAT(,#6)    load dividend word\n         SR    #8,#1               {-(2\u00ac31-1),2\u00ac31-1} subtract mult lo\n         SRDA  #8,31               {-1,0} shift out all but carry\n         SRL   #9,1                {0,2\u00ac31-1} right-justify the 31 bits\n         ST    #9,##VECDAT(,#14)   store remainder in word in work area\n*---------------------------------------------------------------------*\n* When we enter here, reg 0 contains the hi word from the previous    *\n* multiplication, and reg 8 holds the carry from the previous         *\n* remainder word computation.                                         *\n*---------------------------------------------------------------------*\n         XR    #2,#2               INITIALIZE INDUCTION BXLE COUNTER\n         LA    #4,4                INCREMENT AMOUNT OF BXLE LOOP\nBBLOOPM  L     #1,##VECDAT+4(#2,#7) load divisor word\n         SLR   #8,#0               {-(2\u00ac31-1),0} sub hi-mul from carry\n         MR    #0,#3               multiply quotient and divisor words\n         SLDL  #0,1                {0,2\u00ac31-2} shift for 31-bit radix\n         SRL   #1,1                {0,2\u00ac31-1} restore lower word\n         A     #8,##VECDAT+4(#2,#6) {-(2\u00ac31-1),2\u00ac31-1} add dividend wrd\n         SR    #8,#1               {-(2\u00ac32-2),2\u00ac31-1} sub lo-mul\n         BO    BBMC                double carry if overflow\n         SRDA  #8,31               {-1,0} shift all but carry amount\n         SRL   #9,1                {0,2\u00ac31-1} right-justify the 31 bits\n         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area\n         BXLE  #2,#4,BBLOOPM       iterate to next word?\n         EJECT\n*---------------------------------------------------------------------*\n* Compare remainder to divisor.  Remainder should be positive but     *\n* less than the divisor.  If it's negative, we decrement the quotient.*\n* The remainder will never be greater than the divisor.  However,     *\n* traps (BUG# labels) have been inserted to catch instances where this*\n* appears to happen.  Then it must be assumed that there is a bug     *\n* in the algorithm which generated the trial divisor, or in the code  *\n* that determined that it was greater than the divisor.               *\n*                                                                     *\n* The comparison with the divisor below can theoretically be          *\n* eliminated, since the quotient bigit can never be too low (see      *\n* Knuth, Vol 2).  However, we keep it in here a little longer to      *\n* catch any bugs in the code that leads to this point.  At the same   *\n* time, this provides a more reliable divide since it has such a      *\n* self check.                                                         *\n*                                                                     *\n* That is, all paths below which never lead to an BBDQ can simply     *\n* be replaced by a direct branch to BBQOK.                            *\n*---------------------------------------------------------------------*\nBBENDCHK SLR   #8,#0               {-(2\u00ac31-1),0} sub hi-mul from carry\n         A     #8,##VECDAT+4(#2,#6) {-(2\u00ac31-1),2\u00ac31-1} add dividend wrd\n         BM    BBDQ                if not, then quotient is too high\n         BP    BBIQ                if not, then quotient is too low\n*\n         C     #9,##VECDAT(#2,#7)  is highest word of remainder to big?\n         BH    BBIQ                if so, inc quotient & check it again\n         LCR   #1,#4               generate a -4 for the BXH\n         LR    #2,#5               initialize the count to the top\nBBCMPR   L     #9,##VECDAT+4(#2,#14) get remainder word\n         C     #9,##VECDAT+4(#2,#7) compare with dividend word\n         BH    BBIQ                remainder to high, inc. quotient\n         BL    BBQOK               remainder is lower than divisor, ok\n         BXH   #2,#1,BBCMPR        not reached next to last word?\n*\n         L     #9,##VECDAT(,#7)    least significant word of divisor\n         N     #9,=X'7FFFFFFF'     mask out the sign bit\n         C     #9,##VECDAT(,#14)   compare these words\n         BH    BBQOK               divisor is bigger than remainder, ok\n*\n***BBIQ  AH    #3,=H'1'            increment the quotient\n***      BP    BBCHK               check the incremented quotient\nBBIQ     B     BUG6                BBIQ should never happen, see Knuth\n*\n*                                  really part of BBLOOPM above\nBBMC     SRDA  #8,31               {-1,0} shift all but carry amount\n         BM    BUG8             DIVSRDA,BM,SRL,SH>LR #9,#8;LH #8,=H'-2'\n         SRL   #9,1                {0,2\u00ac31-1} right-justify the 31 bits\n         SH    #8,=H'2'            subtract the double carry\n         ST    #9,##VECDAT+4(#2,#14) store remainder word in work area\n         BXLE  #2,#4,BBLOOPM       iterate to next word?\n         B     BBENDCHK            check the carry position at end\n*\nBBDQ     SH    #3,=H'1'            decrement quotient\n         BNM   BBCHK\n         B     BUG7                can't happen! quotient never < 0\n*\nBBQOK    ST    #3,##VECDAT(#10,#15) store result quotient\n         LA    #0,##VECDAT(,#14)   address of remainder for MVCL\n         LA    #1,8(,#5)           length of temp remainder\n         LA    #2,##VECDAT(,#6)    destination - fake dividend\n         LA    #3,12(,#5)          pad out higest rem word to 0\n         MVCL  #2,#0               stuff remainder into dividend\n         SR    #10,#4              any more quotient bigits to calc?\n         BNM   QBIGIT              go compute another quotient bigit\n*\n         LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS\n         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED\n         L     #1,BIGLDIFF         length is this or 4 more\n         CR    #1,#4\n         L     #0,##VECDAT(#1,#15) Get higest word of result\n         BNE   BBLONG              Result may be a long bignum\n         LTR   #0,#0               Leading bigit=0?  then fixnum\n         BNZ   BB2WRD              Result is a two-word bignum\n         L     #2,##VECDAT(,#15)   get ls word of bignum-to-be-fixnum\n         L     #6,0(,#11)          load address of original dividend\n         TM    ##VECDAT(#6),X'80'  test sign of dividend\n         BNO   *+6                 not negative, don't include sign\n         LCR   #2,#2               incorporate sign into answer\n         TM    ##VECDAT(#7),X'80'  test sign of divisor\n         BNO   *+6                 not negative, don't include sign\n         LCR   #2,#2               incorporate sign into answer\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               create the fixnum answer\n         B     RETURN\n*\nBB2WRD   L     #2,##VECDAT(,#7)    load signed word of divisor\n         L     #6,0(#11)           Get pointer to real dividend\n         MVC   1(3,#15),=X'000008' Insert length of two word bignum\n         X     #2,##VECDAT(,#6)    combine with sign of dividend\n         N     #2,=X'80000000'     retain only the sign\n         O     #2,##VECDAT(,#15)   combine with least word of bignum\n         LA    #1,##VECDAT+8(,#15) point to end of bignum in storage\n         ST    #2,##VECDAT(,#15)   store sign and least bignum word\n         CLC   TWO31MX,0(#15)      check for illegal bignum -2\u00ac31\n         BE    RETT31M             if it's there, issue -2\u00ac31 fixnum\n         ST    #1,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER\n         B     RETURN\n*\nBBLONG   LTR   #0,#0               Leading bigit=0?\n         L     #2,##VECDAT(,#7)    load signed word of divisor\n         L     #6,0(#11)           Get pointer to real dividend\n         BZ    BBLONG0             Bignum length in #1 is correct\n         LA    #1,4(,#1)           Length is one more word\nBBLONG0  X     #2,##VECDAT(,#6)    combine with sign of dividend\n         STCM  #1,B'0111',1(#15)   Store bignum length into header\n         N     #2,=X'80000000'     retain only the sign\n         O     #2,##VECDAT(,#15)   combine with least word of bignum\n         LA    #1,##VECDAT(#1,#15) point to end of bignum in storage\n         ST    #2,##VECDAT(,#15)   store sign and least bignum word\n         CLC   TWO31MX,0(#15)      check for illegal bignum -2\u00ac31\n         BE    RETT31M             if it's there, issue -2\u00ac31 fixnum\n         ST    #1,ZLCVSNXT         UPDATE VSS AVAILABILITY POINTER\n         B     RETURN\n*=====================================================================*\n*  SUBROUTINE TO CALCULATE THE LEFT JUSTIFICATION SHIFT FOR TRIAL     *\n*  DIVISION.  ANSWER IN REG 4 IS NEGATIVE, REG 0 IS DESTROYED.        *\n*  The shift amount in reg 4 can be from -30 to 0.                    *\n*=====================================================================*\nLJSHIFT  LTR   #0,#0\n         BM    BUG9                leading bignum bigit is 0, error!\n         CL    #0,=X'000000FF'     ASSUMES HIGH TWO WORDS IN #0,#1\n         BNH   BYTE0               ALL BITS ARE IN BYTE 0\n         CL    #0,=X'0000FFFF'     ALL BITS IN LOWER HALF?\n         BNH   BYTE1               YES, ALL BITS IN LOWER HALF\n         CL    #0,=X'00FFFFFF'     ALL BITS IN LOWER THREE BYTES?\n         BNH   BYTE2               YES, ALLB ITS IN LOWER 3 BYTES\n*\n         XR    #4,#4               SET INITIAL SHIFT NEGATIVE COUNT\n         SLA   #0,1                DO FIRST SHIFT AND TEST HIGH BIT\n         BOR   #14                 HIGH BIT IS A ONE\nAGAIN3   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT\n         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT\n         BNO   AGAIN3              HIGH BIT IS NOT A ONE\n         BR    #14                 RETURN TO CALLING POINT\n*\nBYTE2    LH    #4,=H'-7'           SET INITIAL SHIFT NEGATIVE COUNT\n         SLA   #0,8                DO FIRST SHIFT AND TEST HIGH BIT\n         BOR   #14                 HIGH BIT IS A ONE\nAGAIN2   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT\n         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT\n         BNO   AGAIN2              HIGH BIT IS NOT A ONE\n         BR    #14                 RETURN TO CALLING POINT\n*\nBYTE1    LH    #4,=H'-15'          SET INITIAL SHIFT NEGATIVE COUNT\n         SLA   #0,16               DO FIRST SHIFT AND TEST HIGH BIT\n         BOR   #14                 HIGH BIT IS A ONE\nAGAIN1   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT\n         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT\n         BNO   AGAIN1              HIGH BIT IS NOT A ONE\n         BR    #14                 RETURN TO CALLING POINT\n*\nBYTE0    LH    #4,=H'-23'          SET INITIAL SHIFT NEGATIVE COUNT\n         SLA   #0,24               DO FIRST SHIFT AND TEST HIGH BIT\n         BOR   #14                 HIGH BIT IS A ONE\nAGAIN0   BCTR  #4,0                INCREMENT SHIFT NEGATIVE COUNT\n         SLA   #0,1                SHIFT ONE MORE AND TEST HIGH BIT\n         BNO   AGAIN0              HIGH BIT IS NOT A ONE\n         BR    #14                 RETURN TO CALLING POINT\n         EJECT\n*=====================================================================*\n* ARG 1 IS A BIGNUM                                                   *\n* ARG 2 IS NOT A BIGNUM OR A FIXNUM                                   *\n*=====================================================================*\nBG1NBF2  DS    0H\n         CLI   ##TYPE(#7),##SFLOAT IS ARG 2 A SINGLE FLOAT?\n         BE    BIGSFLO\n         CLI   ##TYPE(#7),##DFLOAT IS ARG 2 A DOUBLE FLOAT?\n         BE    BIGDFLO\n         B     ERROR2              IF NEITHER, ERROR\nBIGSFLO  DS    0H                  Bignum / single-float\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LR    #5,#6               Arg1 is bignum, arg2 is float\n         #BASR #14,#15             Convert bignum to float\n         LER   #F2,#F0             Get float value for arg1\n         B     DIVSFLO1            Go to divide arg1 by float arg2\nBIGDFLO  DS    0H                  Bignum / double-float\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LNR   #5,#6               Arg1 is bignum, arg2 is float\n         #BASR #14,#15             Convert bignum to float\n         LDR   #F2,#F0             Get float value for arg1\n         B     DIVDFLO1            Go to divide arg1 by float arg2\n*\n* ARG 1 IS NEITHER A FIXNUM NOR A BIGNUM\n*\nNBFX1    DS    0H\n         CLI   ##TYPE(#6),##SFLOAT IS ARG 1 A SINGLE FLOAT?\n         BE    ARG1SFLO\n         CLI   ##TYPE(#6),##DFLOAT IS ARG 1 A DOUBLE FLOAT?\n         BE    ARG1DFLO\n         B     ERROR1              IF NOT, ERROR\n*\n*\n* ARG 1 IS A FIXNUM\n* ARG 2 IS NEITHER A FIXNUM NOR A BIGNUM\n*\nFX1NBF2  DS    0H                  ARG 1 IS FIXED BUT ARG2 IS NOT\n         SPACE\n*                                                                     *\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    FIXSFLO             FIXED / SFLOAT = SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    FIXDFLO             FIXED / DFLOAT = DFLOAT\n         B     ERROR2              FIXED / NONUM = ERROR\nFIXSFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F2,#F0             GET SINGLE FLOAT VALUE 1\n         B     DIVSFLO1\nFIXDFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F2,#F0             GET DOUBLE FLOAT VALUE 1\n         B     DIVDFLO1\n         SPACE\nARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    SDIVSFLO            SFLOAT / SFLOAT = SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    SDIVDFLO            SFLOAT / DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    SFLOPFIX            SFLOAT / FIXED = SFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BNE   ERROR2              SFLOAT / NONUM = ERROR\n         LE    #F2,##CDR(,#6)      Get single float value 1\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LR    #5,#7               Arg1 is float, arg2 is bignum\n         #BASR #14,#15             Convert bignum to float\n         LER   #F4,#F0             Get float value for arg2\n         B     DIVSFLO2\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO SINGLE FLOAT                         *\n*---------------------------------------------------------------------*\nSFLOPFIX LE    #F2,##CDR(,#6)      Get single float value 1\n         L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F4,#F0             GET FLOAT VALUE 2\n         B     DIVSFLO2            FLOAT / FIXED = FLOAT\n         SPACE\nARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F2,8(,#6)          GET FLOAT VALUE 1\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    DIVDFLO1            DFLOAT / DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    DDIVSFLO            DFLOAT / SFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    DFLOPFIX            DFLOAT / FIXED = DFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BNE   ERROR2              DFLOAT / NONUM = ERROR\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LNR   #5,#7               Arg1 is float, arg2 is bignum\n         #BASR #14,#15             Convert bignum to float\n         LDR   #F4,#F0             Get float value for arg2\n         B     DIVDFLO2            Go to DIV float arg1 to arg2\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO DOUBLE FLOAT                         *\n*---------------------------------------------------------------------*\nDFLOPFIX L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F4,#F0             GET FLOAT VALUE 2\n         B     DIVDFLO2            FLOAT / FIXED = FLOAT\n         SPACE\n*---------------------------------------------------------------------*\n*                       SINGLE FLOAT DIV                              *\n*---------------------------------------------------------------------*\nSDIVSFLO DS    0H\n         LE    #F2,##CDR(,#6)      Get single float value 1\nDIVSFLO1 DS    0H\n         LE    #F4,##CDR(,#7)      Get single float value 2\nDIVSFLO2 DS    0H\n         LTER  #F4,#F4             CHECK ARGUMENT 2\n         BZ    FLDIVBY0            IF ZERO, ERROR\n         DER   #F2,#F4             DIVIDE THEM\n         STE   #F2,ZLCWORK         PUT RESULT IN REG FOR ATOM-MAKING\n         L     #2,ZLCWORK\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\n*---------------------------------------------------------------------*\n*                       DOUBLE FLOAT DIV                              *\n*---------------------------------------------------------------------*\nDDIVSFLO DS    0H\n         SDR   #F4,#F4\n         LE    #F4,##CDR(,#7)      Get double float value 2\n         B     DIVDFLO2\nSDIVDFLO DS    0H\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#6)      Get double float value 1\nDIVDFLO1 DS    0H\n         LD    #F4,8(,#7)          Get double float value 2\nDIVDFLO2 DS    0H\n         LTDR  #F4,#F4             CHECK ARGUMENT 2\n         BZ    FLDIVBY0            IF ZERO, ERROR\n         DDR   #F2,#F4             DIVIDE THEM\n         LDR   #F0,#F2\n         L     #15,ZLCMDF          Get address of ZILMDF\n         #BASR #14,#15             Call ZILMDF to make a double-float\n         B     RETURN              AND RETURN WITH IT\n         SPACE\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION SUBROUTINE\n         SPACE\nFDIVISOR DS    F                   TEMPORARY STORAGE FOR FIXNUM DIVISOR\nRSHIFT   DS    F                   TEMPORARY STORAGE FOR SHIFT AMOUNT\nREMPTR   DS    F                   TEMPORARY STORAGE REMAINDER POINTER\nBIGLDIFF DS    F                   difference in lengths of two bignums\nSAVE1500 DS    2A                  Regs saved across FREEMAIN/GETMAIN\n         DS    0A\nTWO31M   #IATM -2147483648         IN-LINE MOST NEGATIVE FIXNUM (-2\u00ac31)\n*        DS    0A                  ALIGN FIXNUM TO FULLWORD\n*TWO31M  DC    YL1(##FIXNUM),AL3(0),F'-2147483648'  MOST NEG FIXNUM\n         DS    0A                  ALIGN BIGNUM TO FULLWORD\nZTWO31   DC    YL1(##BIGNUM),AL3(8),F'0,1' 2**31 BIGNUM\nTWO31    EQU   ZTWO31,*-ZTWO31     LABEL AND LENGTH FOR TWO31\nZTWO31MX DC    YL1(##BIGNUM),AL3(8),X'80000000',F'1' -2**31 bad BIGNUM\nTWO31MX  EQU   ZTWO31MX,*-ZTWO31MX LABEL AND LENGTH FOR two31mx\nBIG8     DC    YL1(##BIGNUM),AL3(8) LENGTH OF SHORT BIGNUM\n         SPACE\nFFDIVBY0 EQU   *\nFLDIVBY0 EQU   *\nBFDIVBY0 EQU   *\n         #ERR  'Attempted to divide ',0(#11),' by ',4(#11)\nERROR1   #ERR  'Argument 1 to divide not a number - ',0(#11)\nERROR2   #ERR  'Argument 2 to divide not a number - ',4(#11)\nBUG1     LA    #2,1\n         B     BUGERR\nBUG2     LA    #2,2\n         B     BUGERR\nBUG3     LA    #2,3\n         B     BUGERR\nBUG4     LA    #2,4\n         B     BUGERR\nBUG5     LA    #2,5\n         B     BUGERR\nBUG6     LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS\n         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED\n         LA    #2,6\n         B     BUGERR\nBUG7     LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS\n         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED\n         LA    #2,7\n         B     BUGERR\nBUG8     LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS\n         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED\n         LA    #2,8\n         B     BUGERR\nBUG9     LA    #2,9\n******** B     BUGERR\nBUGERR   #ERR  'Bignum/bignum divide, internal bug #',#2,' for ',      X\n               0(#11),' and ',4(#11),' - please report.'\n         SPACE 1\nGERROR   DS    0H                  Error - not enough work area\n         XR    #0,#0               Clear work area address and length\n         ST    #0,ZLCWA\n         ST    #0,ZLCWALEN\n         #ERR  PREFIX=NO,                                              X\n               'ZIL3102 ZILDIV: Not enough memory to perform trial diviX\n               sion.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILDSNI": {"ttr": 12038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x12\\x00\\x88\\x02\\x7f\\x01\\x00&_\\x16U\\x00j\\x004\\x00i\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-27T00:00:00", "modifydate": "2000-09-21T16:55:12", "lines": 106, "newlines": 52, "modlines": 105, "user": "SEB1525"}, "text": "         TITLE 'ZILDSNI - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (ZILDSNI inputfilespec) returns the actual data set name to which   *\n* the input file spec inputfilespec is allocated.  If inputfilespec   *\n* is the terminal, * is returned.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILDSNI  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILDSNI'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         #IFIL 1                   ARG 1 = INPUT FILE SPEC\n         SPACE 1\n         USING ZLFILBLK,#7\n         TM    ZLFFLAG1,ZLFTERM    If this is a terminal file\n         BO    RETTERM             then return \"*\" for dsname\n         TM    ZLFDCB+X'30',X'10'  If DCB is not open\n         BNO   NOTOPEN             then error - this shouldn't happen\n         XR    #3,#3               Clear register for insert\n         ICM   #3,B'0011',ZLFDCB+X'28'  Get TIOT offset\n         L     #15,540             Get TCB address\n         L     #15,12(,#15)        Get TIOT address\n         ALR   #3,#15              Add TIOT offset\n         USING TIOENTRY,#3         Address the TIOT entry\n         TM    TIOELINK,TIOTTERM   If this is a terminal\n         BO    RETTERM             then return \"*\" for terminal\n*\n* The following will not work if SWA is above the line in an\n* MVS/SP2.2 system.\n*\n         XR    #5,#5               Prepare register for 24-bit address\n         ICM   #5,7,TIOEJFCB       Get address of JFCB\n         LA    #5,16(,#5)          Point past SWA prefix\n         MVI   DSNAME,C' '         Clear dsname(member) to blanks\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DSNAME(44),0(#5)    Copy data set name\n         CLI   DSNAME,C' '         If it is all blank\n         BE    RETNULL             (very unlikely, but) return \"\"\n         LA    #1,DSNAME+44-1      Search for last nonblank\nDSNLOOP  CLI   0(#1),C' '\n         BNE   DSNLEND\n         BCT   #1,DSNLOOP\nDSNLEND  DS    0H                  #1 -> last nonblank in DSN\n         LA    #2,1(,#1)           Point where to put possible member\n         CLI   44(#5),C' '         If there is a member name\n         BE    NOMEMBER            then...\n         MVI   0(#2),C'('           put a left paren there\n         MVC   1(8,#2),44(#5)       move member name in\n         LA    #1,8-1(,#2)          Search for last nonblank\nMEMLOOP  CLI   0(#1),C' '\n         BNE   MEMLEND\n         BCT   #1,MEMLOOP\nMEMLEND  DS    0H                   #1 -> last nonblank in DSN\n         MVI   1(#1),C')'           put a right paren there\n         LA    #2,2(,#1)           Point to end of dsname(member)\nNOMEMBER DS    0H                  #2 -> end of name\n         LA    #0,DSNAME\n         SR    #2,#0               Length of string\n         XR    #1,#1               Set ZILVSS entry code for new space\n         L     #15,ZLCVSS          Get address of ZILVSS\n         LA    #0,16(,#11)         Set current stack pointer\n         #BASR #14,#15             Call ZILVSS to create a string\n         LTR   #15,#15             If string build failed\n         BZ    ERROR               then error\n         LH    #2,2(,#15)          Get length (from built string)\n         BCTR  #2,0                Reduce for execute\n         EX    #2,MOVEIT           Move dsname to our string\n         B     RETURN              Return with string\n         SPACE 1\nMOVEIT   MVC   ##VECDAT(*-*,#15),DSNAME Executed: move data to string\n         SPACE 1\nRETNULL  DS    0H\n         LA    #15,NULLSTR\n         B     RETURN\nRETTERM  DS    0H\n         LA    #15,STAR\n         B     RETURN\n         SPACE\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDSNAME   DS    CL(44+8+1+1)        Space to build dsname(member)\nNULLSTR  #SATM ''                  String \"\"\nSTAR     #SATM '*'                 String \"*\"\n         SPACE 1\nNOTOPEN  DS    0H\n         L     #2,ZLFATOM\n         #ERR  'ZILDSNI: Input file is not open - ',(#2)\n         SPACE 1\nERROR    #ERR  PREFIX=NO,'ZIL4010 ZILDSNI: Not enough vector/string spaX\n               ce to build string.'\n         SPACE 1\n         LTORG\n         SPACE 1\nDUMDEDUM DSECT ,\n         IEFTIOT1\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILDSNO": {"ttr": 12041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00'\\x00\\x88\\x02\\x7f\\x01\\x00&_\\x16V\\x00j\\x00f\\x00i\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-27T00:00:00", "modifydate": "2000-09-21T16:56:27", "lines": 106, "newlines": 102, "modlines": 105, "user": "SEB1525"}, "text": "         TITLE 'ZILDSNO - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (ZILDSNO outputfilespec) returns the actual data set name to which  *\n* the output file spec outputfilespec is allocated. If outputfilespec *\n* is the terminal, * is returned.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILDSNO  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILDSNO'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         #OFIL 1                   ARG 1 = OUTPUT FILE SPEC\n         SPACE 1\n         USING ZLFILBLK,#7\n         TM    ZLFFLAG1,ZLFTERM    If this is a terminal file\n         BO    RETTERM             then return \"*\" for dsname\n         TM    ZLFDCB+X'30',X'10'  If DCB is not open\n         BNO   NOTOPEN             then error - this shouldn't happen\n         XR    #3,#3               Clear register for insert\n         ICM   #3,B'0011',ZLFDCB+X'28'  Get TIOT offset\n         L     #15,540             Get TCB address\n         L     #15,12(,#15)        Get TIOT address\n         ALR   #3,#15              Add TIOT offset\n         USING TIOENTRY,#3         Address the TIOT entry\n         TM    TIOELINK,TIOTTERM   If this is a terminal\n         BO    RETTERM             then return \"*\" for terminal\n*\n* The following will not work if SWA is above the line in an\n* MVS/SP2.2 system.\n*\n         XR    #5,#5               Prepare register for 24-bit address\n         ICM   #5,7,TIOEJFCB       Get address of JFCB\n         LA    #5,16(,#5)          Point past SWA prefix\n         MVI   DSNAME,C' '         Clear dsname(member) to blanks\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         MVC   DSNAME(44),0(#5)    Copy data set name\n         CLI   DSNAME,C' '         If it is all blank\n         BE    RETNULL             (very unlikely, but) return \"\"\n         LA    #1,DSNAME+44-1      Search for last nonblank\nDSNLOOP  CLI   0(#1),C' '\n         BNE   DSNLEND\n         BCT   #1,DSNLOOP\nDSNLEND  DS    0H                  #1 -> last nonblank in DSN\n         LA    #2,1(,#1)           Point where to put possible member\n         CLI   44(#5),C' '         If there is a member name\n         BE    NOMEMBER            then...\n         MVI   0(#2),C'('           put a left paren there\n         MVC   1(8,#2),44(#5)       move member name in\n         LA    #1,8-1(,#2)          Search for last nonblank\nMEMLOOP  CLI   0(#1),C' '\n         BNE   MEMLEND\n         BCT   #1,MEMLOOP\nMEMLEND  DS    0H                   #1 -> last nonblank in DSN\n         MVI   1(#1),C')'           put a right paren there\n         LA    #2,2(,#1)           Point to end of dsname(member)\nNOMEMBER DS    0H                  #2 -> end of name\n         LA    #0,DSNAME\n         SR    #2,#0               Length of string\n         XR    #1,#1               Set ZILVSS entry code for new space\n         L     #15,ZLCVSS          Get address of ZILVSS\n         LA    #0,16(,#11)         Set current stack pointer\n         #BASR #14,#15             Call ZILVSS to create a string\n         LTR   #15,#15             If string build failed\n         BZ    ERROR               then error\n         LH    #2,2(,#15)          Get length (from built string)\n         BCTR  #2,0                Reduce for execute\n         EX    #2,MOVEIT           Move dsname to our string\n         B     RETURN              Return with string\n         SPACE 1\nMOVEIT   MVC   ##VECDAT(*-*,#15),DSNAME Executed: move data to string\n         SPACE 1\nRETNULL  DS    0H\n         LA    #15,NULLSTR\n         B     RETURN\nRETTERM  DS    0H\n         LA    #15,STAR\n         B     RETURN\n         SPACE\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nDSNAME   DS    CL(44+8+1+1)        Space to build dsname(member)\nNULLSTR  #SATM ''                  String \"\"\nSTAR     #SATM '*'                 String \"*\"\n         SPACE 1\nNOTOPEN  DS    0H\n         L     #2,ZLFATOM\n         #ERR  'ZILDSNO: Output file is not open - ',(#2)\n         SPACE 1\nERROR    #ERR  PREFIX=NO,'ZIL4010 ZILDSNO: Not enough vector/string spaX\n               ce to build string.'\n         SPACE 1\n         LTORG\n         SPACE 1\nDUMDEDUM DSECT ,\n         IEFTIOT1\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILEDIT": {"ttr": 12044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11Q\\x00\\xd0\\x00\\xcc\\x00\\xd0\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:51:00", "lines": 208, "newlines": 204, "modlines": 208, "user": "SEB1525"}, "text": "***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         TITLE 'ZILEDIT - MACROS'\n         MACRO\n&SYM     $SPFC\n&SYM     DS    0H\n         L     #15,@ISPLINK          GET ADDRESS OF ISPLINK\n         OI    ZLCIFLGS,ZLCISYS      INDICATE NON-ZIL CODE RUNNING\n         #BASR #14,#15               CALL ISPLINK\n         TM    ZLCIFLGS,ZLCIATTN     IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                   THEN GO TO HANDLE IT\n         NI    ZLCIFLGS,255-ZLCISYS  INDICATE ZIL CODE RUNNING AGAIN\n         MEND\n         TITLE 'ZILEDIT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION INVOKES THE ISPF EDITOR ON A SPECIFIED DATASET.       *\n*                                                                     *\n* ZILEDIT TAKES ONE ARGUMENT: THE STRING CONTAINING THE NAME OF THE   *\n* DATA SET TO BE EDITED.                                              *\n*                                                                     *\n* RESULT IS BASED ON THE RETURN CODE FROM THE ISPF DIALOG SERVICE.    *\n*                                                                     *\n*   0 - RETURN T (DATASET WAS SAVED)                                  *\n*   4 - RETURN NIL (DATASET WAS NOT SAVED)                            *\n*   OTHER - SIGNAL ERROR                                              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE THAT THE MAXIMUM LENGTH OF A DSNAME FOR ISPF EDIT IS 56.       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILEDIT  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILEDIT'\n         #ZPDS 1*4+12+0            DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         MVI   $DSNAME,C' '        CLEAR DSNAME TO BLANKS\n         MVC   $DSNAME+1(55),$DSNAME\n         L     #2,0(,#11)          LOAD ARG 1 = THE ATOM TO BE DUMPED\n         CLI   ##TYPE(#2),##STRING IF IT IS A STRING, OK\n         BE    OK\n         CLI   ##TYPE(#2),##SYMBOL IF IT IS A SYMBOL - WELL, OK\n         BNE   ERROR1              ANYTHING ELSE - BAD DSNAME\n         L     #2,##PNAME(,#2)     IF A SYMBOL, GET THE PRINT NAME\nOK       DS    0H\n         XR    #3,#3               CLEAR INSERT REGISTER\n         ICM   #3,7,1(#2)          GET LENGTH OF STRING\n         BZ    ERROR1              IF ZERO, BAD DSNAME\n         CH    #3,=H'56'           IF GREATER THAN MAXIMUM LENGTH\n         BH    ERROR1              THEN BAD DSNAME\n         BCTR  #3,0                ELSE REDUCE FOR EXECUTE\n         EX    #3,MOVEDSN          MOVE DATA SET NAME TO AREA\n         EX    #3,TRDSN            TRANSLATE TO UPPER CASE\n*\n* GET ISPLINK\n*\n         LOAD  EPLOC==CL8'ISPLINK',ERRET=ERROR2\n         ST    #0,@ISPLINK\n*\n* SAVE ZIL REGS IN CASE OF ABEND OR OTHER INTERRUPT\n*\n         ST    #9,ZLCISV09\n*\n* ISPEXEC CONTROL ERRORS RETURN\n*\n         LA    #1,ISPCRET          POINT TO PARAMETER LIST FOR ISPLINK\n         $SPFC ,                   CALL ISPLINK\n         LTR   #15,#15             IF IT FAILED (ISPF SERVICES N/A)\n         BZ    CERROK              THEN...\n         DELETE EPLOC==CL8'ISPLINK'\n         B     ERROR2               BLOW UP\nCERROK   DS    0H\n*\n* ISPEXEC CONTROL DISPLAY REFRESH\n*\n         LA    #1,ISPCREF          POINT TO PARAMETER LIST FOR ISPLINK\n         $SPFC ,                   CALL ISPLINK\n*\n* ISPEXEC EDIT DATASET(...)\n*\n         LA    #1,ISPEDIT          POINT TO PARAMETER LIST FOR ISPLINK\n         $SPFC ,                   CALL ISPLINK\n         LTR   #15,#15             IF RC=0 (DATA SET SAVED)\n         BZ    RETT                THEN PREPARE TO RETURN T\n         CH    #15,=H'4'           IF RC=4 (DATA SET NOT SAVED)\n         BE    RETNIL              THEN PREPARE TO RETURN NIL\n*\n* ELSE EDIT FAILED - REPORT TO USER\n*\n*\n* ISPEXEC CONTROL ERRORS CANCEL\n*\n         LA    #1,ISPCCAN          POINT TO PARAMETER LIST FOR ISPLINK\n         $SPFC ,                   CALL ISPLINK\n*\n* ISPEXEC DISPLAY PANEL(ISPTERM)\n*\n         LA    #1,ISPTERM          POINT TO PARAMETER LIST FOR ISPLINK\n         $SPFC ,                   CALL ISPLINK\n*\n* ISPEXEC CONTROL DISPLAY LINE START(1)\n*\n         LA    #1,ISPCLIN          POINT TO PARAMETER LIST FOR ISPLINK\n         $SPFC ,                   CALL ISPLINK\n         SPACE 1\n         DELETE EPLOC==CL8'ISPLINK'\n         SPACE 1\n         B     ERROR3              GO BLOW UP\n*\n* EVERYTHING OK - RETURN A DECENT RETURN VALUE\n*\nRETT     DS    0H\n         LR    #4,#8               RETURN T\n         B     CLEANUP\nRETNIL   DS    0H\n         LR    #4,#10              RETURN NIL\n         B     CLEANUP\n*\n* CLEAN UP ISPF PROCESSING\n*\nCLEANUP  DS    0H\n*\n* ISPEXEC CONTROL DISPLAY LINE START(1)\n*\n         LA    #1,ISPCLIN          POINT TO PARAMETER LIST FOR ISPLINK\n         $SPFC ,                   CALL ISPLINK\n*\n* RELEASE ISPLINK\n*\n         DELETE EPLOC==CL8'ISPLINK'\n*\n*\n* RESTORE REGISTERS AND COMMON AREA POINTER\n*\nRETURN   DS    0H\n         LR    #15,#4              LOAD RETURN VALUE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 3\nMOVEDSN  MVC   $DSNAME(*-*),##VECDAT(#2) MOVE STRING TO DSNAME AREA\nTRDSN    TR    $DSNAME(*-*),UPTBL  TRANSLATE TO UPPER CASE\n         SPACE 3\nERROR1   #ERR  'Argument to ZILEDIT not a valid dataset name - ',0(#11)\nERROR2   #ERR  'ZIL0025 ZILEDIT: ISPF dialog services not available, caX\n               nnot edit dataset - ',0(#11),PREFIX=NO\nERROR3   #ERR  'ZIL0026 ZILEDIT: Error detected by ISPF EDIT, could notX\n                edit dataset - ',0(#11),PREFIX=NO\n         SPACE 3\nISPCRET  DS    0A\n         DC    A($CONTROL)\n         DC    A($ERRORS)\n         DC    A($RETURN+X'80000000')\n         SPACE 1\nISPCCAN  DS    0A\n         DC    A($CONTROL)\n         DC    A($ERRORS)\n         DC    A($CANCEL+X'80000000')\n         SPACE 1\nISPCREF  DS    0A\n         DC    A($CONTROL)\n         DC    A($DISPLAY)\n         DC    A($REFRESH+X'80000000')\n         SPACE 1\nISPCLIN  DS    0A\n         DC    A($CONTROL)\n         DC    A($DISPLAY)\n         DC    A($LINE)\n         DC    A($START+X'80000000')\n         SPACE 1\nISPEDIT  DS    0A\n         DC    A($EDIT)\n         DC    A($DSNAME+X'80000000')\n         SPACE 1\nISPTERM  DS    0A\n         DC    A($DISPLAY)\n         DC    A($ISPTERM+X'80000000')\n         SPACE 1\n@ISPLINK DS    A                   ADDRESS OF ISPLINK (NOT IN SUBRS!)\n         SPACE 1\n$CONTROL DC    CL8'CONTROL'\n$ERRORS  DC    CL8'ERRORS'\n$RETURN  DC    CL8'RETURN'\n$CANCEL  DC    CL8'CANCEL'\n$DISPLAY DC    CL8'DISPLAY'\n$ISPTERM DC    CL8'ISPTERM'\n$REFRESH DC    CL8'REFRESH'\n$LINE    DC    CL8'LINE'\n$START   DC    F'1'\n$EDIT    DC    CL8'EDIT'\n$DSNAME  DC    CL56' '\n         SPACE 1\nUPTBL    DC    256YL1(*-UPTBL)     TABLE TO TRANSLATE TO UPPER CASE\n         ORG   UPTBL+X'00'\n         DC    C' '                (ALSO NULLS TO BLANKS)\n         ORG   UPTBL+C'A'-X'40'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+C'J'-X'40'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+C'S'-X'40'\n         DC    C'STUVWXYZ'\n         ORG\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILEQUAL": {"ttr": 12292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11Q\\x01\\x10\\x01\\r\\x01\\x0f\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:51:00", "lines": 272, "newlines": 269, "modlines": 271, "user": "SEB1525"}, "text": "         TITLE 'ZILEQUAL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS IS THE \"=\" FUNCTION.                                           *\n*                                                                     *\n* \"EQUALP\" CALLS THIS FUNCTION TO COMPARE ATOMS.                      *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS:                                    *\n*                                                                     *\n* 1. BOTH ARGS FIXED         - PERFORM INTEGER COMPARISON.            *\n* 2. BOTH ARGS FLOAT         - PERFORM REAL COMPARISON.               *\n* 3. ONE FIXED, ONE FLOAT    - CONVERT THE FIXED ARGUMENT TO          *\n*                              FLOAT AND PERFORM REAL COMPARISON.     *\n* 7. BOTH ARGS ALPHA         - PERFORM CHARACTER COMPARISON.          *\n* 8. ONE ALPHA, ONE NUMERIC  - SIGNALS AN ERROR.                      *\n*                                                                     *\n* ANY OTHER TYPES SIGNAL AN ERROR.                                    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS NOT RECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SUPPORT FOR STRING AND SYMBOL COMPARES.  THE FOLLOWING COMPARISONS  *\n*            ARE LEGAL:                                               *\n*                                                                     *\n*  SYMBOL TO SYMBOL                                                   *\n*  STRING TO STRING                                                   *\n*  SYMBOL TO STRING                                                   *\n*  STRING TO SYMBOL                                                   *\n*                                                                     *\n* ALL MAY BE REMOVED FOR FULL COMMON LISP.                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILEQUAL #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILEQUAL'\n         SPACE\n         LR    #3,#15\n         DROP  #15\n         USING ZILEQUAL,#3\n         SPACE\n         LM    #1,#2,0(#1)         LOAD ARGUMENTS\n         CR    #1,#2               IF ARGS ARE \"EQ\"\n         BE    TRUE                THEN RETURN T\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#1),##FIXNUM\n         BE    ARG1FIX\n         CLI   ##TYPE(#1),##SFLOAT\n         BE    ARG1SFLO\n         CLI   ##TYPE(#1),##BIGNUM\n         BE    ARG1BIG\n         CLI   ##TYPE(#1),##DFLOAT\n         BE    ARG1DFLO\n*\n*--- DELETE THIS CODE FOR FULL COMMON LISP\n*\n         CLI   ##TYPE(#1),##STRING\n         BE    ARG1STR\n         CLI   ##TYPE(#1),##SYMBOL\n         BE    ARG1ALF\n*\n*--- END OF CODE TO BE DELETED FOR FULL COMMON LISP\n*\n         B     ERROR               ALL OTHER TYPES SIGNAL ERROR.\n         SPACE\nARG1FIX  DS    0H                  ARG 1 IS FIXED\n         SPACE\n         L     #0,##CDR(,#1)       GET FIXED VALUE 1\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    COMFIX              FIXED - FIXED = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    FIXPSFLO            FIXED - SFLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    FIXPDFLO            FIXED - DFLOAT = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    FALSE               FIXED - BIGNUM = FALSE\n         CR    #2,#10              Special case for Macsyma:\n         BE    FALSE               FIXED - NIL = FALSE\n         B     ERROR               ALL OTHERS - ALWAYS ERROR\n         SPACE\nCOMFIX   DS    0H                  COMPARE TWO FIXNUMS\n         C     #0,##CDR(,#2)       TEST FOR EQUALITY\n         BE    TRUE\n         B     FALSE\n         SPACE\nFIXPSFLO DS    0H                  FIXED VALUE 1 ALREADY IN #0\n         LR    #7,#14              SAVE RETURN ADDRESS\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN ADDRESS\n         LRER  #F2,#F0             GET FLOAT VALUE 1\n         B     COMSFLO1            COMPARE FIXED TO SINGLE FLOAT\n         SPACE\nFIXPDFLO DS    0H                  FIXED VALUE 1 ALREADY IN #0\n         LR    #7,#14              SAVE RETURN ADDRESS\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN ADDRESS\n         LDR   #F2,#F0             GET FLOAT VALUE 1\n         B     COMDFLO1            COMPARE FIXED TO DOUBLE FLOAT\n         SPACE\nARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    SCOMSFL1            SFLOAT - SFLOAT = OK\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    SCOMDFL1            SFLOAT - DFLOAT = OK\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    SFLOPFIX            SFLOAT - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    WARNBF              SFLOAT - BIGNUM = ???\n         CR    #2,#10              Special case for Macsyma:\n         BE    FALSE               SFLOAT - NIL = FALSE\n         B     ERROR               ALL OTHERS - ALWAYS ERROR\nSFLOPFIX LE    #F2,##CDR(,#1)      GET FLOAT VALUE 1\n         L     #0,##CDR(,#2)       GET FIXED VALUE 2\n         LR    #7,#14              SAVE RETURN ADDRESS\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN ADDRESS\n         LRER  #F4,#F0             GET FLOAT VALUE 2\n         B     COMSFLO2            FLOAT - FIXED = FLOAT\n         EJECT\nARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F2,8(,#1)          GET FLOAT VALUE 1\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##DFLOAT\n         BE    COMDFLO1            DFLOAT - DFLOAT = OK\n         CLI   ##TYPE(#2),##SFLOAT\n         BE    DCOMSFL1            DFLOAT - SFLOAT = OK\n         CLI   ##TYPE(#2),##FIXNUM\n         BE    DFLOPFIX            DFLOAT - FIXED = OK\n         CLI   ##TYPE(#2),##BIGNUM\n         BE    WARNBF              DFLOAT - BIGNUM = ???\n         CR    #2,#10              Special case for Macsyma:\n         BE    FALSE               DFLOAT - NIL = FALSE\n         B     ERROR               ALL OTHERS - ALWAYS ERROR\nDFLOPFIX L     #0,##CDR(,#2)       GET FIXED VALUE 2\n         LR    #7,#14              SAVE RETURN ADDRESS\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LR    #14,#7              RESTORE RETURN ADDRESS\n         LDR   #F4,#F0             GET FLOAT VALUE 2\n         B     COMDFLO2            GO COMPARE FLONUMS IN REGISTERS\n         SPACE\nSCOMDFL1 DS    0H                  LOAD DOUBLE FROM SINGLE FLOAT ARG 1\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#1)\n         B     COMDFLO1\nDCOMSFL1 DS    0H                  LOAD DOUBLE FROM SINGLE FLOAT ARG 2\n         SDR   #F4,#F4\n         LE    #F4,##CDR(,#2)\n         B     COMDFLO2\nCOMDFLO1 DS    0H                  LOAD DOUBLE FROM DOUBLE FLOAT ARG 2\n         LD    #F4,8(,#2)\nCOMDFLO2 DS    0H\n         CDR   #F2,#F4             TEST FOR EQUALITY\n         BE    TRUE\n         B     FALSE\n         SPACE\nSCOMSFL1 DS    0H                  LOAD SINGLE FROM SINGLE FLOAT ARG 1\n         LE    #F2,##CDR(,#1)\nCOMSFLO1 DS    0H                  LOAD SINGLE FROM SINGLE FLOAT ARG 2\n         LE    #F4,##CDR(,#2)\nCOMSFLO2 DS    0H\n         CER   #F2,#F4             TEST FOR EQUALITY\n         BE    TRUE\n         B     FALSE\n         EJECT\nARG1BIG  DS    0H\n         SPACE\n         CLI   ##TYPE(#2),##BIGNUM BOTH MUST BE BIGNUMS\n         BE    COMPSS              IF SO, COMPARE THEM\n         CLI   ##TYPE(#2),##FIXNUM BIGNUM - FIXNUM = FALSE\n         BE    FALSE\n         TM    ##TYPE(#2),##FLONUM BIGNUM - ?FLOAT = ???\n         BO    WARNBF\n         CR    #2,#10              Special case for Macsyma:\n         BE    FALSE               BIGNUM - NIL = FALSE\n         B     ERROR               ALL OTHERS - ALWAYS ERROR\n         EJECT\n*\n* DELETE THIS CODE FOR FULL COMMON LISP\n*\nARG1STR  DS    0H                  ARG 1 IS STRING\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##STRING\n         BE    COMPSS              STRING - STRING = OK\n         CLI   ##TYPE(#2),##SYMBOL\n         BE    COMPSA              STRING - SYMBOL = OK\n         B     ERROR               ALL OTHERS - ALWAYS ERROR\n         SPACE\nARG1ALF  DS    0H                  ARG 1 IS SYMBOL\n*\n* CHECK TYPE OF ARG 2\n*\n         CLI   ##TYPE(#2),##SYMBOL\n         BE    COMPAA              SYMBOL - SYMBOL = OK\n         CLI   ##TYPE(#2),##STRING\n         BE    COMPAS              SYMBOL - STRING = OK\n         CR    #1,#10              Special case for Macsyma:\n         BE    FALSE               NIL - NUMBER = FALSE\n         B     ERROR               ALL OTHERS - ALWAYS ERROR\n         SPACE\nCOMPAS   DS    0H                  SYMBOL-TO-STRING COMPARE\n         L     #1,##PNAME(,#1)     GET PRINT NAME OF SYMBOL 1\n         B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPSA   DS    0H                  STRING-TO-SYMBOL COMPARE\n         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL 2\n         B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPAA   DS    0H                  SYMBOL-TO-SYMBOL COMPARE\n         L     #1,##PNAME(,#1)     GET PRINT NAME OF SYMBOL 1\n         L     #2,##PNAME(,#2)     GET PRINT NAME OF SYMBOL 2\n*\n*--- END OF CODE TO BE DELETED FOR FULL COMMON LISP\n*\n******** B     COMPSS              COMPARE STRINGS\n         SPACE\nCOMPSS   DS    0H                  STRING-TO-STRING COMPARE\n         SPACE 1\n         L     #5,0(,#1)           GET STRING HEADER 1\n         CL    #5,0(,#2)           TYPE AND LENGTH MUST MATCH\n         BNE   FALSE                TO DO COMPARE, ELSE NOT EQUAL\n         N     #5,=X'00FFFFFF'     ISOLATE STRING LENGTH 1\n         LA    #4,##VECDAT(,#1)    POINT TO STRING TEXT 1\n         LA    #6,##VECDAT(,#2)    POINT TO STRING TEXT 2\n         LR    #7,#5               GET STRING LENGTH 2\n         CLCL  #4,#6               DO COMPARE\n         BNE   FALSE               NOT EQUAL: RETURN NIL\n******** B     TRUE                EQUAL: RETURN T\n         EJECT\nTRUE     DS    0H\n         LR    #15,#8              TRUE... RESULT IS T\n         BR    #14\n         SPACE\nFALSE    DS    0H\n         LR    #15,#10             FALSE... RESULT IS NIL\n         BR    #14\n         SPACE\nWARNBF   DS    0H                  Bignums and floats can't be compared\n         SPACE\n         #ERR  2,'ZIL4101 ZILEQUAL: Float-to-bignum compare not supportX\n               ed.',PREFIX=NO,SIGNAL=NO\n         B     FALSE               So return false for them.\n         EJECT\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION ROUTINE\n         SPACE\nERROR    LR    #5,#1\n         LR    #6,#2\n         #ERR  'Type conflict, ZILEQUAL cannot compare ',              X\n               0(#5),' and ',0(#6)\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILERR": {"ttr": 12297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x006\\x00\\x88\\x01_\\x01\\x00&_\\x11\\t\\x01\\x00\\x00\\xfd\\x00\\xff\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T11:09:36", "lines": 256, "newlines": 253, "modlines": 255, "user": "SEB1525"}, "text": "         TITLE 'ZILERR - ZIL 1.3 ERROR PROCESSOR'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS INVOKED FROM ASSEMBLER LANGUAGE SUBROUTINES THAT    *\n* DETECT AN ERROR.  IT DISPLAYS AN ERROR MESSAGE AND THEN ISSUES A    *\n* THROW TO THE TAG NIL, WHICH IS CAUGHT BY THE INTERPRETER; IF NO NIL *\n* TAG EXISTS THEN THROW WILL ABEND THE PROGRAM WITH A USER CODE       *\n* SPECIFIED BY THE MESSAGE PREFIX, IF THE MESSAGE BEGINS WITH THE     *\n* CHARACTERS ZIL FOLLOWED BY 4 NUMERICS.                              *\n*                                                                     *\n* ON ENTRY TO THIS SUBROUTINE, REGISTER 1 CONTAINS THE ADDRESS OF     *\n* THE MESSAGE TO BE DISPLAYED; REGISTER 0 CONTAINS ITS LENGTH.        *\n*                                                                     *\n* THIS ROUTINE USES NO STACK SPACE.  FURTHERMORE, SINCE IT WILL NEVER *\n* RETURN TO WHENCE IT CAME, REGISTER 14 NEED NOT BE SAVED.            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* 11/18/86 - A NEW INTERFACE HAS BEEN ADDED TO THIS MODULE.           *\n*                                                                     *\n* IF REGISTER 1 IS ZERO, THEN REGISTER 0 IS A POINTER TO A            *\n* PARAMETER LIST.  THIS PARAMETER LIST IDENTIFIES A LIST OF LISP      *\n* OBJECTS TO BE PRINTED IN SUCCESSION TO THE STANDARD OUTPUT FILE,    *\n* WHICH WILL CONSTITUTE THE ERROR MESSAGE.                            *\n*                                                                     *\n* TO BE MORE SPECIFIC:                                                *\n*                                                                     *\n* REGISTER 0 -->+0 |-----------|                                      *\n*                  |SIGNAL BIT |   X'80' MEANS SIGNAL AN ERROR        *\n*               +1 |           |                                      *\n*                  | SEV CODE  |   0,1,2,3,4                          *\n*               +2 |-----------|                                      *\n*                  |-> OBJECT3 |  FOR EACH OBJECT, IF ITS ADDRESS IS  *\n*               +4 |-----------|  ON AN ODD BOUNDARY (NON-HALFWORD-   *\n*                  |-> OBJECT2 |  ALIGNED), IT IS PRINTED WITHOUT     *\n*               +6 |-----------|  SLASHIFICATION; OTHERWISE IT IS     *\n*                  |-> OBJECT3 |  SLASHIFICATION.                     *\n*               ...|-----------|                                      *\n*                  |    ...    |                                      *\n*                  |-----------|                                      *\n*                  |  X'0FFF'  |                                      *\n*                  |-----------|                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILERR   #ZBEG NAME='ZILERR'\n         SPACE 1\n         LTR   #1,#1               IF REGISTER 1 = ZERO\n         BZ    MULTERR             THEN GO TO PROCESS NEW INTERFACE\n         SPACE 1\n         LR    #12,#15\n         DROP  #15\n         USING ZILERR,#12\n         SPACE 1\n         LR    #3,#1               SAVE MESSAGE ADDRESS\n         LR    #4,#0               SAVE MESSAGE LENGTH\n         SPACE 1\n         MVI   ZLCDFLGS,0          CLEAR ALL ZILADMP FLAGS\n         SPACE 1\n         SPACE 1\n         L     #15,X'224'          ASCB ADDRESS\n         ICM   #15,15,X'3C'(#15)   TSB ADDRESS\n         BZ    NOTTSO              IF NO TSB, NOT UNDER TSO\n* ON TSO, SEND MESSAGE TO TERMINAL REGARDLESS OF OUTPUT DEST.\n* THE SEVERITY LEVEL IS 2 (ERROR).\n         #TPUT 2,(1),(0)            USE TPUT TO DISPLAY THE MESSAGE\n         B     AFTTSO\n         SPACE 1\nNOTTSO   DS    0H                  ELSE...\n         SPACE 1\n* IN BATCH, ISSUE WRITE-TO-PROGRAMMER MESSAGE.\n         SPACE 1\n         MVI   WTPTEXT,C' '        CLEAR MESSAGE TEXT TO BLANKS\n         MVC   WTPTEXT+1(WTPLEN-1),WTPTEXT\n         LR    #15,#0              GET LENGTH OF MESSAGE\n         CH    #15,WTPLEN          IF LONGER THAN MAX WTP LENGTH\n         BNH   *+8                  THEN\n         LA    #15,WTPLEN            USE MAXIMUM LENGTH\n         BCTR  #15,0               REDUCE THIS LENGTH FOR EXECUTE\n         EX    #15,WTPMOVE         MOVE MESSAGE TEXT\n         WTO   MF=(E,WTPMSG),ROUTCDE=11 WRITE TO PROGRAMMER MESSAGE\n         SPACE 1\nAFTTSO   DS    0H                  WHICHEVER WAY IT WAS DISPLAYED...\n         SPACE 1\n*\n* TRY TO EXTRACT MESSAGE ID FROM MESSAGE TEXT (ZILNNNN...)\n* THIS WILL BE PASSED TO THROW, WHICH MAY USE IT AS AN ABEND CODE.\n*\n         XR    #1,#1               INITIALIZE THROW NUMBER TO ZERO\n         CH    #4,=H'7'            IF LENGTH IS AT LEAST 7\n         BL    THROW                AND\n         CLC   0(3,#3),=C'ZIL'      MESSAGE BEGINS WITH ZIL....\n         BNE   THROW                 THEN\n         LA    #2,3(,#3)            POINT TO NEXT 4 POSITIONS\n         LA    #0,4\nTNUMLOOP DS    0H                  TEST FOR 4 NUMERICS\n         CLI   0(#2),X'F0'\n         BL    THROW\n         CLI   0(#2),X'F9'\n         BH    THROW\n         LA    #2,1(,#2)\n         BCT   #0,TNUMLOOP\n         PACK  ZLCDBL(8),3(4,#3)   CONVERT MESSAGE NUMBER TO DECIMAL\n         CVB   #1,ZLCDBL           AND THEN TO BINARY\nTHROW    DS    0H                  NOW WE HAVE NUMBER TO PASS\n         STH   #1,ZLCABEND         STORE INTO USER ABEND CODE NUMBER\n         OI    ZLCERFLG,ZLCERSET   INDICATE USER ABEND CODE SET\n         SPACE 1\n         LR    #1,#10              SET THROW TAG TO NIL\n         LR    #2,#10              SET THROW RESULT TO NIL\n         L     #15,ZLCTHROW        GET ADDRESS OF THROW PROCESSOR\n         BR    #15                 INVOKE THROW TO TAG NIL\n         SPACE 1\nWTPMOVE  MVC   WTPTEXT(*-*),0(#1)  EXECUTED = MOVE ERROR TO MSG TEXT\nWTPMSG   WTO   '                                                       X\n                                                                       X\n                              ',ROUTCDE=11,MF=L\nWTPEND   EQU   *\nWTPTEXT  EQU   WTPMSG+4\nWTPLEN   EQU   WTPEND-WTPTEXT\n         SPACE 1\nMULTERR  DS    0H                  THIS IS THE NEW INTERFACE\n*                                  #0 -> PARAMETER LIST\n         LR    #1,#15\n         DROP  #12\n         USING ZILERR,#1\n         STM   #0,#14,MSAVE        SAVE ALL REGISTERS ON ENTRY\n         LR    #12,#1              SET UP OUR BASE REGISTER\n         DROP  #1\n         USING ZILERR,#12\n         LR    #3,#0               POINT TO BEGINNING OF PARAMETER LIST\n         XR    #6,#6\n         IC    #6,1(,#3)           #4 = SEVERITY LEVEL\n         STC   #6,MSEV             SAVE SEVERITY LEVEL\n         SPACE 1\n         LA    #5,2(,#3)           POINT TO BEGINNING OF PARAMETER LIST\n         L     #7,ZLCSTDOU         GET STANDARD OUTPUT FILE POINTER\n         USING ZLFILBLK,#7\n         TM    ZLFFLAG1,ZLFNEWLN   IF OUTPUT DATA WAITING ON THIS LINE\n         BZ    SKIPTERP            THEN...\n         ST    #3,SAVEPARM          SAVE #3 ACROSS CALL TO TERPRI\n         L     #15,ZLCTERP          GET ADDRESS OF ZILTERP\n         #BASR #14,#15              CALL ZILTERP TO GET A NEW LINE\n         L     #3,SAVEPARM          RESTORE #3\nSKIPTERP DS    0H\n         CLC   MSEV(1),ZLCMSLVL    IF SEVERITY CODE LESS THAN MSGLEVEL\n         BL    MSKIP               THEN SKIP PRINTING THIS ITEM\n         CLI   MSEV,X'FF'          IF SEVERITY CODE IS *\n         BE    NOHEADER            THEN DON'T PREFIX MESSAGE HEADER\n         TM    0(#3),X'40'         IF SUPPRESS-PREFIX BIT IS ON\n         BO    NOHEADER            THEN DON'T PREFIX MESSAGE HEADER\n         SLA   #6,2                CONVERT SEVERITY CODE TO INDEX\n         L     #4,MSTRINGS(#6)     LOAD APPROPRIATE MESSAGE HEADER\n         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE\n         L     #15,ZLCPRIN         GET ADDRESS OF ZILPRIN\n         #BASR #14,#15             CALL ZILPRIN TO PRINT MESSAGE HEADER\nNOHEADER DS    0H\nMLOOP    DS    0H                  PROCESS EACH PARAMETER\n         CLI   0(#5),X'0F'         IF THIS IS THE END OF THE LIST\n         BE    MLOOPEND            THEN EXIT LOOP\n         SPACE 1\n         CLC   MSEV(1),ZLCMSLVL    IF SEVERITY CODE LESS THAN MSGLEVEL\n         BL    MSKIP               THEN SKIP PRINTING THIS ITEM\n         SPACE 1\n         XR    #2,#2               START GENERATING ADDRESS OF THE\n         XR    #3,#3                DATA TO BE PRINTED\n         ICM   #3,B'1100',0(#5)    #2 = X'00000000', #3 = X'BDDD0000'\n         SLDL  #2,4                #2 = X'0000000B', #3 = X'DDD00000'\n         SRL   #3,20               #2 = X'0000000B', #3 = X'00000DDD'\n         STC   #2,MBASE            SAVE BASE REGISTER\n         LTR   #2,#2               IF BASE REGISTER IS ZERO\n         BNE   NOTZERO             THEN...\n         SLA   #3,2                 CONVERT DISPLACEMENT (REG) TO INDEX\n         L     #4,MSAVE(#3)         LOAD CONTENTS OF THAT REGISTER\n         ST    #4,MFIXNUM+4         SAVE INTO PHONY FIXNUM\n         LA    #4,MFIXNUM           POINT TO PHONY FIXNUM\n         B     AFTSETSL             AND PRINT (SLASHIFIC'N IRRELEVANT)\nNOTZERO  DS    0H                  ELSE...\n         SLA   #2,2                 CONVERT TO INDEX INTO MSAVE\n         L     #4,MSAVE(#2)         LOAD CONTENTS OF THAT BASE REGISTER\n         ALR   #4,#3                ADD DISPLACEMENT\n         CLI   MBASE,11             IF BASE REGISTER IS 11\n         BNE   NOT11                THEN IT'S AN INDIRECT STACK POINTER\n         L     #4,0(,#4)            SO GET WHAT IT POINTS TO\nNOT11    DS    0H\n         ST    #4,MADDRESS          SAVE ADDRESS OF DATA\n         TM    MADDRESS+3,X'01'     IF OBJECT IS ON ODD BOUNDARY\n         BZ    DOSETSL              THEN\n         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE\n         B     AFTSETSL             ELSE\nDOSETSL  OI    ZLCPFLGS,ZLCPSLSH    REQUEST SLASHIFICATION BE DONE\nAFTSETSL DS    0H                  #4 POINTS TO DATA TO BE PRINTED\n         L     #15,ZLCPRIN         GET ADDRESS OF ZILPRIN\n         #BASR #14,#15             CALL ZILPRIN TO PRINT THE THING\nMSKIP    DS    0H\n         LA    #5,2(,#5)           ELSE BUMP TO NEXT PARAMETER\n         B     MLOOP               AND CONTINUE\nMLOOPEND DS    0H\n         TM    ZLFFLAG1,ZLFNEWLN   IF OUTPUT DATA WAITING ON THIS LINE\n         BZ    SKIPTER2            THEN...\n         L     #15,ZLCTERP         GET ADDRESS OF ZILTERP\n         #BASR #14,#15             CALL ZILTERP TO TERPRI THE LINE\nSKIPTER2 DS    0H\n         SPACE 1\n         L     #1,MSAVE0           GET POINTER TO ORIGINAL PLIST\n         TM    0(#1),X'80'         IF WE ARE TO SIGNAL AN ERROR\n         BNO   MDONE               THEN...\n         XR    #1,#1                SET ABEND CODE TO 000\n         B     THROW                GO TO THROW TO SIGNAL ERROR\nMDONE    DS    0H                  ELSE...\n         LA    #15,2(,#5)          RETURN ADDRESS AFTER LAST PARAMETER\n         LM    #0,#14,MSAVE        RESTORE ALL REGS THAT WERE SAVED\n         BR    #15                 RETURN TO CALLER\n         SPACE 2\nMSAVE    DS    14A                 SAVE AREA FOR REGS 0-14\n         ORG   MSAVE\nMSAVE0   DS    A\n         DS    A                   (ACTUALLY REG 1 WASN'T SAVED)\nMSAVE2   DS    A\nMSAVE3   DS    A\nMSAVE4   DS    A\nMSAVE5   DS    A\nMSAVE6   DS    A\nMSAVE7   DS    A\nMSAVE8   DS    A\nMSAVE9   DS    A\nMSAVE10  DS    A\nMSAVE11  DS    A\nMSAVE12  DS    A\nMSAVE13  DS    A\nMSAVE14  DS    A\n         ORG   ,\nMFIXNUM  #IATM 0                   PHONY FIXNUM FOR PRINTING VALUES\nMADDRESS DS    A                   ADDRESS OF DATA TO BE PRINTED\nSAVEPARM DS    A                   PLACE TO SAVE REGISTER\nMSEV     DS    X                   SEVERITY CODE\nMBASE    DS    X                   BASE REGISTER FROM S-CONSTANT\n         SPACE 1\nMSTRINGS DC    A(MSTRING0,MSTRING1,MSTRING2,MSTRING3,MSTRING4)\n         SPACE 1\nMSTRING0 #SATM 'ZIL4000 '\nMSTRING1 #SATM 'ZIL4001 Warning: '\nMSTRING2 #SATM 'ZIL4002 Error: '\nMSTRING3 #SATM 'ZIL4003 '\nMSTRING4 #SATM 'ZIL4004 '\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILEXPL": {"ttr": 12548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11Q\\x00h\\x00e\\x00g\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:51:00", "lines": 104, "newlines": 101, "modlines": 103, "user": "SEB1525"}, "text": "         TITLE 'ZILEXPL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* ZILEXPL TAKES 3 ARGUMENTS, OF WHICH ONLY THE 1ST IS REQUIRED.       *\n* THE FIRST IS THE ATOM TO BE EXPLODED (SPECIFICATION OF A LIST IS    *\n*  ERRONEOUS AND WILL BE FLAGGED AS AN ERROR).                        *\n* THE SECOND SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO INTERN THE   *\n*  GENERATED ATOMS ON THE OBJECT LIST (NOTE DEFAULT IS NOT TO).       *\n* THE THIRD SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO SLASHIFY THE  *\n*  OUTPUT AS PRIN1 WOULD.                                             *\n*                                                                     *\n* THE SECOND ARG MAY BE T, NIL OR A FIXNUM; IF IT IS A FIXNUM, THE    *\n* EXPLOSION WILL BE A LIST OF FIXNUMS (CHARACTERS) RATHER THAN        *\n* SYMBOLS.  THIS IS TO SUPPORT EXPLODEN.                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILEXPL  #ZBEG MINARGS=1,MAXARGS=3,NAME='ZILEXPL'\n         #ZPDS 28                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n*\n* CHECK INPUT ARGUMENT - MUST BE AN ATOM\n*\n         L     #2,0(,#11)          GET ATOM (ARG 1 TO ZILEXPL)\n         TM    ##TYPE(#2),##ATOM   MUST BE AN ATOM\n         BZ    ERROR1              OR ELSE\n         TM    ##TYPE(#2),##VEC    MUST NOT BE A VECTOR-TYPE OBJECT\n         BO    ERROR1              OR ELSE\n*\n* CALL ZILADMP TO DUMP THE ENTIRE ATOM INTO OUR WORK AREA.\n* NOTE #2 POINTS TO OUR ATOM.\n*\n         OI    ZLCDFLGS,ZLCDCOPY   FORCE COPY OF TEXT DATA\n         L     #15,ZLCADMP         GET ADDRESS OF ZILADMP\n         L     #1,8(,#11)          SET SLASHIFY OPTION FROM ARG 3\n         #BASR #14,#15             CALL ZILADMP TO DUMP ATOM\n*\n* FOR EACH CHARACTER IN THE DUMPED TEXT, MAKE AN ATOM OUT OF IT.\n* WE GO BACKWARDS TO FACILITATE CONSING THEM TOGETHER TO MAKE A LIST.\n*\n         LR    #15,#10             INITIALIZE RETURN VALUE TO NIL\n         LTR   #4,#0               SAVE LENGTH OF DUMPED ATOM\n         BNP   RETURN              IF ZERO, RETURN NIL\n         XR    #6,#6\n         LR    #7,#1               POINT TO RETURNED ATOM AREA\n         BCTR  #6,0                SET BXLE INCREMENT REG = -1\n         BCTR  #7,0                SET UP BXLE STOP REG\n         AR    #4,#7               POINT TO LAST CHAR OF DUMPED ATOM\n         SPACE 1\n         L     #3,4(,#11)          GET ARG 2 TO ZILEXPL\n         CLI   ##TYPE(#3),##FIXNUM IF ARG 2 IS A FIXNUM\n         BNE   LOOPC               THEN THIS IS EXPLODEN, ELSE EXPLODEC\n         LA    #0,28(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         SPACE 1\nLOOPN    DS    0H                  LOOP USING BXLE REGS #4, #6, #7\n         XR    #3,#3               CLEAR INSERT REGISTER FOR CHARACTERS\n         IC    #3,0(,#4)           GET CHARACTER FROM DUMPED ATOM\n         LR    #2,#15              ARG 2 TO CONS = LIST SO FAR\n         SLA   #3,3                PREPARE TO MAKE A FIXNUM OUT OF IT\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         LA    #1,#SFT(#3)         ARG 1 TO CONS = CHARACTER FIXNUM\n         #BASR #14,#15             CALL CONS TO ADD NEW FIXNUM TO LIST\n         BXH   #4,#6,LOOPN         CONTINUE UNTIL HIT START OF ATOM\n         B     RETURN              THEN RETURN THE LIST\n*\n*                                  ELSE EXPLODE(C)\n*\nLOOPC    DS    0H                  LOOP USING BXLE REGS #4, #6, #7\n         LR    #5,#15              SAVE POINTER TO OUTPUT LIST SO FAR\n         ST    #15,24(,#11)        PUT LIST PTR ON STACK IN CASE OF GC!\n         STM   #4,#7,SAVE47        SAVE VOLATILE REGS\n         LA    #0,1                SET LENGTH = 1\n         LR    #1,#4               POINT TO CHARACTER TO BE ATOMIZED\n         L     #2,4(,#11)          SET INTERN FLAG = ARG 2 TO ZILEXPL\n         LR    #3,#10              SET FORMAT FLAG = NIL\n         L     #15,ZLCABLD         GET ADDRESS OF ZILABLD\n         LA    #4,28(,#11)         SET CURRENT STACK POINTER FOR CONS\n         #BASR #14,#15             CALL ZILABLD TO MAKE AN ATOM FROM IT\n         LM    #4,#7,SAVE47        RESTORE VOLATILE REGS\n         LR    #1,#15              ARG 1 TO CONS = BUILT ATOM\n         LR    #2,#5               ARG 2 TO CONS = LIST SO FAR\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         LA    #0,28(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #BASR #14,#15             CALL CONS TO ADD NEW ATOM TO LIST\n         BXH   #4,#6,LOOPC         CONTINUE UNTIL HIT START OF ATOM\n******** B     RETURN              THEN RETURN THE LIST\n         SPACE\nRETURN   DS    0H\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 2\nERROR1   DS    0H\n         #ERR  'Argument to be exploded by ZILEXPL cannot be a list or X\n               vector-type structure - ',(#2)\n         SPACE 2\nSAVE47   DS    4A                  SAVE AREA\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILFBND": {"ttr": 12551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11R\\x009\\x006\\x008\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:52:00", "lines": 57, "newlines": 54, "modlines": 56, "user": "SEB1525"}, "text": "         TITLE 'ZILFBND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS FUNCTION IS CALLED BY ALL COMPILED ZIL PROGRAMS WHICH HAVE TO *\n*  PUT THEIR LOCALLY BOUND LEXICAL VARIABLES ON THE LEXICAL ALIST.    *\n*                                                                     *\n*  This function, along with ZILSBND, replaces the old ZIL 1.2        *\n*  \"ZILVPUT\" function.                                                *\n*                                                                     *\n*  REGISTER 1 IS THE ATOM WHICH IS TO BE BOUND.                       *\n*  REGISTER 2 IS THE VALUE WHICH IS BOUND TO ATOM 1.                  *\n*  REGISTER 1 ON RETURN IS THE CONS CELL WHICH HOLDS THE BINDING.     *\n*                                                                     *\n*  The corresponding LISP definition would look something like this:  *\n*                                                                     *\n* (defun zilfbnd (a b)                                                *\n*  (let ((x (cons a b)))                                              *\n*        (push x (lexical-alist))  ; except that this doesn't exist!  *\n*        x))                                                          *\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO STACK SPACE.              *\n* IN ADDITION, IT NEEDS NO BASE REGISTER.                             *\n*                                                                     *\n* NOTE: THE INTERFACE TO THIS ROUTINE IS NONSTANDARD.                 *\n*       COMPILED CODE INVOKES IT AS FOLLOWS:                          *\n*                                                                     *\n*  LA   0,CURRENT STACK LOCATION FOR CONS                             *\n*  L    1,ADDRESS OF FREE VARIABLE SYMBOL                             *\n*  L    2,STACK LOCATION OF VALUE                                     *\n*  L    15,=A(ZILFBND)                                                *\n*  BALR 3,15                                                          *\n*  ST   1,STACK LOCATION OF VALUE                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILFBND  CSECT ,\n         SPACE 1\n         USING ZLCOMMON,#13\n         SPACE 1\n         L     #15,ZLCCONS         CALL CONS TO CONS ARGS TOGETHER\n         #BASR #14,#15             GIVING A VARIABLE BINDING\n         LR    #1,#15              ARG1=RESULT OF CONS (ALSO RETURNED)\n         L     #15,ZLCCONS         GET ADDRESS OF CONS ROUTINE\n         L     #2,ZLCFALST         ARG2=CURRENT LEXICAL ALIST\n         #BASR #14,#15             CALL CONS TO CONS THEM TOGETHER\n         ST    #15,ZLCFALST        UPDATE ALIST WITH NEW BINDING\n         BR    #3                  RETURN WITH (CAR BINDING) IN REG 1\n         SPACE 1\n         #ZEQU ,\n         SPACE 1\n         #ZCOM ,\n         END\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILFGET": {"ttr": 12553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x001\\x00\\x88\\x01_\\x01\\x00&_\\x17\\x06\\x03r\\x03Z\\x03q\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:06:31", "lines": 882, "newlines": 858, "modlines": 881, "user": "SEB1525"}, "text": "         PUNCH ' ALIAS ZILFGETI,ZILFGETO'\n         TITLE 'ZILFGET - ZIL 1.3 FILE LOCATOR MODULE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS INVOKED VIA BALR FROM ASSEMBLER-LANGUAGE FUNCTIONS   *\n* WHICH REQUIRE THE USE OF FILES.  TWO ENTRY POINTS EXIST:            *\n*                                                                     *\n*  ZILFGETI - LOCATES A FILE BLOCK ON THE CHAIN OF INPUT FILE BLOCKS. *\n*  ZILFGETO - LOCATES A FILE BLOCK ON THE CHAIN OF OUTPUT FILE BLOCKS.*\n*                                                                     *\n* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *\n*                                                                     *\n* ON ENTRY REG 1 CONTAINS THE PASSED (ATOMIC) ARGUMENT SPECIFYING THE *\n* FILE TO BE ACCESSED, AND REG 7 IS SET ON RETURN TO POINT TO THE     *\n* APPROPRIATE FILE BLOCK.                                             *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         EJECT\nZILFGET  CSECT\n         ENTRY ZILFGETI\n         ENTRY ZILFGETO\n         USING ZLCOMMON,#13\nZILFGETI DS    0H\n         L     #2,ZLCIFBAD         USE INPUT FILE BLOCK CHAIN\n         L     #7,ZLCSTDIN         SET STANDARD INPUT IN CASE OF NIL\n         LA    #3,INPUT            SET TYPE = INPUT\n         B     START-ZILFGETI(,#15)\nZILFGETO DS    0H\n         L     #2,ZLCOFBAD         USE OUTPUT FILE BLOCK CHAIN\n         L     #7,ZLCSTDOU         SET STANDARD OUTPUT IN CASE OF NIL\n         LA    #3,OUTPUT           SET TYPE = OUTPUT\n         B     START-ZILFGETO(,#15)\n         EJECT\nZILFGET  #ZBEG NAME='ZILFGET'\n         SPACE 1\nSTART    #BASR #15,0               SET BASE REGISTER\n         USING *,#15\nUSING15  EQU   *\n         CR    #1,#10              IF FILE SPEC IS NIL\n         BER   #14                 THEN RETURN WITH STANDARD FILE\n         CR    #1,#13              IF FILE SPEC IS UNSUPPLIED OPTIONAL\n         BER   #14                 THEN RETURN WITH STANDARD FILE\nNOTNIL   DS    0H                  ELSE NON-NIL FILE SPECIFIED\n         CLI   ##TYPE(#1),##SYMBOL IF NOT A SYMBOL\n         BNE   INVALID             THEN ERROR - INVALID ARGUMENT\n         LTR   #7,#2               ELSE TRY FIRST FILE IN CHAIN\n         USING ZLFILBLK,#7\nFILLOOP  DS    0H\n         BZ    ERROR1              IF NO MORE FILES IN CHAIN, ERROR\n         C     #1,ZLFATOM          IF FILE NAMES MATCH\n         BE    FOUNDIT             THEN RETURN WITH FILE BLOCK POINTER\n         LR    #2,#7               SAVE ADDRESS OF PREVIOUS FILE BLOCK\n         ICM   #7,15,ZLFCHAIN      ELSE GET NEXT FILE BLOCK\n         BNZ   FILLOOP             AND CONTINUE\n         B     ERROR1              IF NO MORE, THEN FILE NOT FOUND\n         SPACE 1\nFOUNDIT  DS    0H                  FOUND FILE BLOCK (FOR NON-NIL ONLY)\n         TM    ZLFFLAG1,ZLFTERM    SEE IF THIS IS A TERMINAL FILE\n         BO    GETTERM             IF SO, DON'T CHECK DCB\n         TM    ZLFDCB+48,X'10'     IF FILE IS OPEN\n         BOR   #14                 THEN OK\n         B     UNUSABLE            ELSE FILE IS UNUSABLE.\n         SPACE\nGETTERM  DS    0H                  FILE IS A TERMINAL FILE\n         L     #7,ZLFTFPTR         GET POINTER TO TRUE FILE BLOCK\n         BR    #14                 AND RETURN WITH IT.\n         SPACE 1\n         DROP  #15\n         SPACE 1\nINVALID  DS    0H                  File arg is invalid\n         SPACE 1\n         LR    #4,#15\n         USING USING15,#4\n         LR    #6,#1               Save file argument\n         STC   #3,TYPE             Set file type\n         LR    #1,#12              Get pointer to calling function\n         #BAS  #14,GETCALR         Get name of calling function\n         #ERR  PREFIX=NO,          FILE NAME INVALID                   X\n               'ZIL0009 ',CALLER,': ',TYPESTR,                         X\n               ' file name not a 1-4 character symbol - ',(#6)\n         SPACE 1\nUNUSABLE DS    0H                  FILE IS PRESENT BUT NOT OPEN\n         SPACE 1\n         LR    #4,#15\n         USING USING15,#4\n         LR    #6,#1               Save file argument\n         STC   #3,TYPE             Set file type\n         LR    #1,#12              Get pointer to calling function\n         #BAS  #14,GETCALR         Get name of calling function\n         #ERR  PREFIX=NO,          FILE NAME INVALID                   X\n               'ZIL0031 ',CALLER,': ',TYPESTR,                         X\n               ' file ',(#6),                                          X\n               ' is not usable.  Try closing it first.'\n         SPACE 1\nERROR1   DS    0H                  FILE NOT FOUND\n         SPACE 1\n         DROP  #4\n         USING USING15,#15\n         SPACE 1\n* VALIDATE FILE NAME\n         ST    #1,FILEATOM         SAVE FILE ATOM\n         L     #1,##PNAME(,#1)     GET POINTER TO SYMBOL PRINT NAME\n         XR    #4,#4               CLEAR INSERT REGISTER\n         ICM   #4,7,1(#1)          GET LENGTH OF PRINT NAME\n         BZ    INVALID             IF ZERO, ERROR - BAD FILE NAME\n         CH    #4,=H'4'            MUST BE 1-4 IN LENGTH\n         BH    INVALID             ELSE ERROR - BAD FILE NAME\n         MVC   FNAME,=CL4' '       PRESET BLANKS\n         BCTR  #4,0                REDUCE LENGTH FOR EXECUTE\n         EX    #4,MVCFNAME         MOVE FILE NAME TO FNAME\n         B     AROUNDEX            BRANCH AROUND EXECUTED INSTR\n         SPACE\nMVCFNAME MVC   FNAME(*-*),##VECDAT(#1)   MOVE PRINT NAME TO FILE NAME\n         SPACE\nAROUNDEX DS    0H\n         SPACE\n***********************************************************************\n*\n* IF A FILE NAME IS NOT FOUND, WE SEARCH THE TIOT TO SEE IF IT IS\n* CURRENTLY ALLOCATED.  IF SO, WE BUILD A FILE BLOCK FOR IT AND\n* ATTEMPT TO OPEN IT (FOR INPUT OR OUTPUT, DEPENDING ON THE REQUEST\n* TYPE).  IF WE ARE SUCCESSFUL, WE RETURN WITH THE ADDRESS OF THE\n* NEWLY OPENED FILE BLOCK.  IF WE FAIL, AN ERROR IS SIGNALLED.\n*\n***********************************************************************\n         SPACE\n         STM   #14,#12,ZLCSAVE2    SAVE REGISTERS\n         LR    #1,#12              Save caller's register 12\n         #BASR #12,0\nUSING12  EQU   *\n         DROP  #15\n         USING USING12,#12\n         SPACE 1\n         STC   #3,TYPE             STORE TYPE (INPUT OR OUTPUT)\n         LR    #6,#2               Save file block pointer\n********                           #1 = caller's #12\n         #BAS  #14,GETCALR         Get calling function name\n         MVC   DDNAME(3),=C'ZIL'   SET UP DDNAME\n         STC   #3,DDNAME+3         MAKE ZILI... OR ZILO...\n         MVC   DDNAME+4(4),FNAME   LAST 4 CHARS = FILE NAME\n         LA    #4,DDNAME+7         Loop searching for last nonblank\n         LA    #0,8\nDDSLOOP  DS    0H\n         CLI   0(#4),C' '\n         BNE   DDSEND\n         BCTR  #4,0\n         BCT   #0,DDSLOOP\nDDSEND   DS    0H\n         STCM  #0,7,DDLEN          Set length of DDNAME in fake string\n*\n* NOW LOCATE A USER SPECIFIED FILE ALLOCATION, CREATE A FILE BLOCK\n* FOR IT AND OPEN IT.\n* SEARCH THE TASK INPUT/OUTPUT TABLE (TIOT) FOR A FILE ALLOCATION OF\n* THE DDNAME ZILI____ (FOR INPUT FILES) AND ZILO____ (FOR OUTPUT FILES)\n*\n         XR    #4,#4               CLEAR INSERT REGISTER\n         L     #3,540              TCB ADDRESS\n         L     #3,12(,#3)          TIOT ADDRESS\n         LA    #3,24(,#3)          POINT TO FIRST TIOT ENTRY\nTIOTLOOP DS    0H\n         TM    1(#3),X'80'         IF THIS ENTRY IS NOT IN USE\n         BO    TIOTNEXT            THEN SKIP IT\n         CLC   4(8,#3),DDNAME      IF THIS IS OUR FILE\n         BE    TIOTFILE            THEN PROCESS IT\nTIOTNEXT IC    #4,0(,#3)           ELSE GET LENGTH OF THIS ENTRY\n         ALR   #3,#4               BUMP TO NEXT ENTRY\n         CLI   0(#3),0             IF NOT END OF TIOT YET\n         BNE   TIOTLOOP            THEN CONTINUE LOOPING THRU TIOT\nNOTFOUND DS    0H                  ELSE END OF TIOT - FILE NOT FOUND\n         XR    #3,#3               INDICATE NO TIOT ENTRY FOR FILE\n         C     #8,FILEATOM         IF REQUESTED FILE IS NOT T\n         BNE   TIOTEND             THEN ERROR - FILE DOES NOT EXIST\n*                                  ELSE FILE IS T - ASSUME TERMINAL\n         CLI   DDNAME+3,C'I'       IF THIS IS SUPPOSED TO BE INPUT FILE\n         BNE   FNDTRMOU            THEN...\n         ICM   #7,15,ZLCIFTRM       GET @ OF INPUT TERMINAL FILE BLOCK\n         BNZ   TIOTEND              IF THERE IS ONE, THEN USE IT\n         B     TIOTFILE             IF THERE ISN'T ONE, BUILD ONE NOW\nFNDTRMOU DS    0H                  ELSE...\n         ICM   #7,15,ZLCOFTRM       GET @ OF OUTPUT TERMINAL FILE BLOCK\n         BNZ   TIOTEND              IF THERE IS ONE, THEN USE IT\n*\n* Experimental addition 08/27/87.  If this is file T, and DDname ZILOT\n* isn't allocated, and there's no terminal file block, and this is a\n* batch environment (no wonder there's no terminal file block!), then\n* let file T be identical to file NIL (standard output).\n*\n         L     #15,X'224'          ASCB address\n         ICM   #15,15,X'3C'(#15)   TSB address\n         BNZ   TIOTFILE            If exists, TSO env., use terminal\n         L     #7,ZLCSTDOU         Get @ of standard output file block\n         B     TIOTEND             and use that.\n         SPACE 1\nTIOTFILE DS    0H                  WE FOUND OUR FILE TO PROCESS\n         LH    #0,ZLCFBLEN         GET LENGTH OF A FILE BLOCK\n         #GETMAIN RC,LV=(0),LOC=BELOW GET STORAGE FOR A FILE BLOCK\n         LTR   #15,#15             IF GETMAIN FAILED,\n         BNZ   FBERROR             THEN ERROR\n         LR    #7,#1               POINT TO FILE BLOCK\n         LH    #1,ZLCFBLEN         GET LENGTH OF A FILE BLOCK\n         BCTR  #1,0\n         EX    #1,CLRFB            CLEAR FILE BLOCK TO ZEROES\n         MVC   ZLFPDDN(8),DDNAME   SET UP DDNAME\n         MVC   ZLFATOM(4),FILEATOM SET UP FILE ATOM FOR ZIL TO USE\n         LTR   #3,#3               IF FILE NOT IN TIOT (MEANS TERMINAL)\n         BZ    ISTERM               OR\n         TM    3(#3),X'20'           IF TIOT ENTRY SAYS IT'S A TERMINAL\n         BZ    NOTTERM                THEN\nISTERM   OI    ZLFFLAG,ZLFTERM         INDICATE SO IN FILE BLOCK\nNOTTERM  DS    0H\n* FOUND THE FILE - NOW CHAIN IT ONTO THE FILE BLOCK\n         LTR   #2,#6               IF NO FILE BLOCK CHAIN EXISTED,\n         BNZ   CHAINIT             THEN...\nNOCURFIL DS    0H                  START A NEW CHAIN\n         CLI   TYPE,INPUT          IF TYPE IS INPUT\n         BNE   CHNOTIN             THEN...\n         ST    #7,ZLCIFBAD          MAKE NEW INPUT FILE BLOCK CHAIN\n         L     #2,ZLCSTDIN          CHAIN THIS TO STANDARD INPUT\n         B     CHAINIT             ELSE...\nCHNOTIN  ST    #7,ZLCOFBAD          MAKE NEW OUTPUT FILE BLOCK CHAIN\n         L     #2,ZLCSTDOU          CHAIN THIS TO STANDARD OUTPUT\nCHAINIT  DS    0H\n         ST    #7,ZLFCHAIN-ZLFILBLK(,#2)  CHAIN THIS TO PREV FILE BLOCK\nCHAINED  DS    0H\n         CLI   TYPE,INPUT          IF TYPE IS INPUT\n         BNE   NOTINPUT            THEN...\n         OI    ZLFFLAG,ZLFINPUT    FLAG AS AN INPUT FILE\n         XR    #1,#1               SET CHARACTER POSITION = -1\n         BCTR  #1,0                 (NEGATIVE SO FIRST READ(CH)\n         ST    #1,ZLFCHAR            WILL FORCE READ OF FIRST RECORD)\n         TM    ZLFFLAG,ZLFTERM     IF THIS IS NOT A TERMINAL FILE\n         BO    FITERM              THEN...\n         MVC   ZLFDCB(96),INDDDCB   SET UP DCB\n         MVI   OPENL,X'80'          SET TO OPEN FOR INPUT\n         B     OPENIT               GO TO OPEN THE FILE\n         SPACE 1\nCLRFB    XC    ZLFILBLK(*-*),ZLFILBLK  EXECUTED: CLEAR BLOCK TO ZEROES\n         SPACE 1\nFITERM   DS    0H                  ELSE (TERMINAL FILE)...\n         ICM   #1,15,ZLCIFTRM       GET @ OF INPUT TERMINAL FILE BLOCK\n         BNZ   GOTIFTRM             IF NONE YET, THEN...\n         ST    #7,ZLCIFTRM           THIS IS THE FIRST. SET IT NOW\n         LR    #1,#7                 FOR FUTURE TERMINAL FILES\nGOTIFTRM DS    0H                  ANYHOW...\n         ST    #1,ZLFTFPTR          SET INDIRECT POINTER TO TRUE FILBLK\n         OI    ZLFFLAG2,ZLFTABS     SET TABS MODE ON BY DEFAULT\n         LA    #0,80                SET RECORD LENGTH TO 80\n         STH   #0,ZLFLRECL          SET LINE LENGTH\n         LA    #1,ZLFLINE\n         ST    #1,ZLFCARD           SET POINTER TO RECORD AREA\n         ALR   #1,#0                AREA + LENGTH = END\n         ST    #1,ZLFEND            SET END-OF-RECORD ADDRESS\n         B     FILOPEND             CONSIDER THE FILE OPEN\nNOTINPUT DS    0H                  ELSE THIS IS AN OUTPUT FILE...\n         LA    #1,1\n         ST    #1,ZLFCHAR          CHARACTER POSITION = 1\n         TM    ZLFFLAG,ZLFTERM     IF THIS IS NOT A TERMINAL FILE\n         BO    FOTERM              THEN...\n         MVC   ZLFDCB(96),OUTDDDCB  SET UP DCB\n         MVI   OPENL,X'8F'          SET TO OPEN FOR OUTPUT\n         B     OPENIT               GO TO OPEN THE FILE\nFOTERM   DS    0H                  ELSE (TERMINAL FILE)...\n         ICM   #1,15,ZLCOFTRM       GET @ OF OUTPUT TERMINAL FILE BLOCK\n         BNZ   GOTOFTRM             IF NONE YET, THEN...\n         ST    #7,ZLCOFTRM           THIS IS THE FIRST. SET IT NOW\n         LR    #1,#7                 FOR FUTURE TERMINAL FILES\nGOTOFTRM DS    0H                  ANYHOW...\n         ST    #1,ZLFTFPTR          SET INDIRECT POINTER TO TRUE FILBLK\n         LA    #0,78                SET RECORD LENGTH TO 78\n         LA    #1,ZLFLINE           (NO PRINT CONTROL CHARACTER)\n         B     NOTRECFA             GO TO SET UP FILE PARAMETERS\nOPENIT   DS    0H\n         MVC   ZLFDCB+40(8),ZLFPDDN SET DDNAME IN DCB\n         SPACE 1\n         LA    #0,STARETRY         SET ADDRESS OF RETRY ROUTINE\n         ST    #0,STAERTRY\n         XC    STAECOMP,STAECOMP   CLEAR COMPLETION CODE\n         STM   #7,#13,STAEREGS     SAVE REGISTERS FOR ESTAE RETRY\n         ESTAE STAEEXIT,PARAM=STAEPARM ESTABLISH ESTAE EXIT\n         LTR   #15,#15             IF ESTAE FAILED\n         BNZ   ESTAEERR            THEN ERROR\n         OI    STAEOK,X'FF'        ELSE SET ESTAE-SET FLAG ON\nESTAEERR DS    0H\n         SPACE 1\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,OPEN24           ADDRESS OF THIS CODE\n         LA    #2,OPEN24E          RETURN ADDRESS\n         BSM   #2,#1\nOPEN24   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n         SPACE 1\n         LA    #1,ZLFDCB           POINT TO DCB\n         STCM  #1,7,OPENL+1        SET UP OPEN LIST FORM\n         OPEN  MF=(E,OPENL)        OPEN THE INPUT OR OUTPUT FILE\n         SPACE 1\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nOPEN24E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         SPACE 1\n         TM    STAEOK,X'FF'        IF ESTAE WAS SUCCESSFULLY SET\n         BNO   NOESTOFF            THEN\n         ESTAE 0                   CANCEL ESTAE EXIT\nNOESTOFF DS    0H\n         SPACE 1\n         TM    ZLFDCB+48,X'10'     IF FILE SUCCESSFULLY OPENED\n         BO    FITSTNUM            THEN PROCEED. ELSE...\nOPENFAIL DS    0H\n         L     #6,FILEATOM         Get file argument\n         L     #1,ZLCSAVE2+56      Load saved #12\n         #ERR  3,PREFIX=NO,SIGNAL=NO,                                  X\n               'ZIL0007 ',CALLER,': ',TYPESTR,                         X\n               ' file ',(#6),' open failed.'\n         EJECT\n         XR    #7,#7               CLEAR FILE BLOCK POINTER - ERROR\n         B     TIOTEND             RETURN\n         SPACE 1\nFBERROR  DS    0H                  FILE BLOCK ALLOCATION ERROR\n         #ERR  3,PREFIX=NO,SIGNAL=NO,                                  X\n               'ZIL0032 ZILFGET: Not enough memory available for file bX\n               lock.'\n         B     OPENFAIL            FILE OPEN FAILED\n         SPACE 1\nFITSTNUM DS    0H\n*\n* IF FILE IS OPEN FOR INPUT AND NOT THE TERMINAL, IT MAY BE NUMBERED\n* OR UNNUMBERED. DETERMINE THIS DYNAMICALLY BY READING THE FIRST\n* RECORD FROM THE FILE AND CHECKING THE SEQUENCE NUMBER FIELD.\n*\n         TM    ZLFFLAG,ZLFINPUT    IF THIS IS AN INPUT FILE,\n         BZ    FNOUTPUT            THEN\n         TM    ZLFFLAG,ZLFTERM      IF THIS IS NOT THE TERMINAL\n         BO    TIOTNEXT             THEN\n         TM    ZLFDCB+36,X'C0'       IF RECFM = U\n         BNO   NRECFMU               THEN...\n         OI    ZLFFLAG2,ZLFRECU       INDICATE A RECFM=U FILE\n         B     RECFMF                ELSE...\nNRECFMU  DS    0H\n         TM    ZLFDCB+36,X'80'       IF RECFM = V...\n         BO    RECFMF                THEN...\n         OI    ZLFFLAG2,ZLFRECV       INDICATE A RECFM=V FILE\nRECFMF   DS    0H\n         LA    #1,FIRSTEOF           SET TEMPORARY EODAD ROUTINE ADDR\n         STCM  #1,7,ZLFDCB+33        IN DCB\n         AIF   (NOT &ZILXA).SKIP3\n         LA    #15,EOFCONT           GET ADDR OF EOF CONTINUATION\n         BSM   #15,0                 AND ADD CURRENT AMODE TO IT\n         ST    #15,AEOFCONT          STORE THIS VALUE\n.SKIP3   ANOP\n         AIF   (NOT &ZILXA).SKIP4\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,GET24            ADDRESS OF THIS CODE\n         LA    #2,GET24E           RETURN ADDRESS\n         BSM   #2,#1\nGET24    DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP4   ANOP\n         ST    #9,ZLCISV09            SAVE ZIL REGISTERS\n         OI    ZLCIFLGS,ZLCISYS       INDICATE NON-ZIL CODE RUNNING\n         GET   ZLFDCB                DO INITIAL GET\n         NI    ZLCIFLGS,255-ZLCISYS\n         AIF   (NOT &ZILXA).SKIP5\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nGET24E   DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP5   ANOP\n         TM    ZLCIFLGS,ZLCIATTN      IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                    THEN GO TO HANDLE IT\n         OI    ZLFFLAG1,ZLFSTART      SHOW FIRST FILE READ DONE\n         ST    #1,ZLFREC1            SAVE ADDR OF LOGICAL RECORD READ\n         XR    #0,#0\n         BCTR  #0,0\n         ST    #0,ZLFCHAR            SET CHARACTER POINTER TO -1 (NL)\n         TM    ZLFFLAG2,ZLFRECV      IF RECFM = V...\n         BZ    NOTRECV               THEN...\n         LH    #0,0(,#1)              GET LRECL FROM RDW OF RECORD\n         LA    #15,4\n         AR    #1,#15                 BUMP RECORD POINTER UP 4\n         SR    #0,#15                 DECREASE LENGTH BY 4\n         ST    #1,ZLFCARD             SET RECORD POINTER\n         LR    #14,#1\n         AR    #14,#0                 SET END-OF-RECORD POINTER\n         CH    #0,=H'8'               IF RECORD SHORTER THAN 8 BYTES\n         BL    VCHKREC                THEN CAN'T BE LINE NUMBERED\n         TRT   0(8,#1),NUMTBL         SCAN FOR NUMERICS\n         BNZ   VCHKREC                IF ALL NUMERICS, IT'S NUMBERED\nVNUMBERD DS    0H                    RECFM=V WITH LINE NUMBERS\n         OI    ZLFFLAG2,ZLFNUM       SHOW THAT FILE IS LINE NUMBERED\n         LA    #1,8(,#1)             POINT TO TEXT (TRT DIDN'T BASH R1)\n         ST    #1,ZLFCARD            SET RECORD POINTER\n         SH    #0,=H'8'\nVCHKREC  DS    0H                    OK, NOW CHECK FOR NULL RECORD\n         LTR   #0,#0                 IF RECLEN ZERO OR NEGATIVE\n         BP    SETINFIL              THEN\n         XR    #1,#1                  SET CHAR PTR TO -1\n         BCTR  #1,0\n         ST    #1,ZLFCHAR\n         B     SETINFIL\nNOTRECV  DS    0H                    RECFM NOT V, MUST BE F OR U\n         TM    ZLFFLAG2,ZLFRECU      IF RECFM = U\n         BZ    NOTRECU               THEN...\n         ST    #1,ZLFCARD             SET RECORD POINTER\n         LH    #14,ZLFDCB+82          GET DCBLRECL\n         LTR   #0,#14                 USE IT AS RECORD LENGTH\n         BNZ   ULRECLOK               UNLESS IT'S ZERO, IN WHICH CASE\n         LH    #14,ZLFDCB+52          GET DCB BLOCKSIZE\n         LR    #0,#14                 USE IT AS RECORD LENGTH\nULRECLOK DS    0H\n         AR    #14,#1                 COMPUTE END OF RECORD ADDRESS\n         B     SETINFIL               AND GO USE THEM\nNOTRECU  DS    0H                    RECFM NOT U, MUST BE F\n         ST    #1,ZLFCARD            SET RECORD POINTER\n         LH    #0,ZLFDCB+82          GET LRECL FROM DCB\n         LR    #14,#1\n         AR    #14,#0                POINT TO END OF RECORD\n         SH    #14,=H'8'             BUMP BACK TO SEQUENCE NUMBER FIELD\n         TRT   0(8,#14),NUMTBL       SCAN FOR NUMERICS\n         BZ    NUMBERED              IF ALL NUMERICS, IT'S NUMBERED\nNOTNUMBD DS    0H                    ELSE ASSUME UNNUMBERED\n         LA    #14,8(,#14)           SET END-OF-RECORD POINTER\n         B     SETINFIL\nNUMBERED DS    0H                   OTHERWISE\n         OI    ZLFFLAG2,ZLFNUM       SHOW THAT FILE IS LINE NUMBERED\n         SH    #0,=H'8'              ASSUME NUMBERED, DECR REC LENGTH\nSETINFIL DS    0H                   NOW RESET FILE FIELDS ACCORDINGLY\n         STH   #0,ZLFLRECL          SET REVISED RECORD AREA LENGTH\n         ST    #14,ZLFEND           SET END-OF-RECORD ADDRESS\n         B     FILOPEND             FILE IS NOW OK\n         SPACE 2\nFIRSTEOF DS    0H                  HERE IF EOF ON INPUT FILE (EMPTY)\n*                                  NOTE: THIS GETS CONTROL IN AMODE24!\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE-RUNNING FLAG\n         AIF   (NOT &ZILXA).SKIP6\n         L     #15,AEOFCONT        GET ADDRESS OF EOF CONTINUATION\n         BSM   0,#15               GO TO IT IN CALLER'S AMODE\nAEOFCONT DS    A\n.SKIP6   ANOP\nEOFCONT  DS    0H\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\n         XR    #1,#1               INDICATE END OF FILE BY\n         ST    #1,ZLFCARD          SETTING RECORD POINTER TO ZERO AND\n         ST    #1,ZLFCHAR          SETTING CHARACTER POINTER TO ZERO\n         LH    #0,ZLFDCB+82        PICK UP LRECL (IN CASE SOMEONE ASKS)\n         STH   #0,ZLFLRECL          SET REVISED RECORD AREA LENGTH\n         AR    #1,#0                POINT TO END OF RECORD\n         ST    #1,ZLFEND            SET END-OF-RECORD ADDRESS\n         B     FILOPEND             FILE IS NOW OK\n         SPACE 2\nFNOUTPUT DS    0H                  THIS IS AN OPEN OUTPUT FILE...\n         TM    ZLFDCB+36,X'40'     IF RECFM = V...\n         BZ    FNOUTOK             THEN...\n         TM    ZLFDCB+36,X'80'\n         BO    FNOUTOK\n         OI    ZLFFLAG2,ZLFRECV     INDICATE SO IN FILE BLOCK\nFNOUTOK  DS    0H\n         AIF   (NOT &ZILXA).SKIP7\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,PUT24            ADDRESS OF THIS CODE\n         LA    #2,PUT24E           RETURN ADDRESS\n         BSM   #2,#1\nPUT24    DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP7   ANOP\n         ST    #9,ZLCISV09         SAVE ZIL REGISTERS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL CODE RUNNING\n         LA    #1,ZLFDCB           DO THE INITIAL PUT LOCATE\n         PUT   (1)                 (SETS #1 TO CURRENT LINE)\n         NI    ZLCIFLGS,255-ZLCISYS\n         AIF   (NOT &ZILXA).SKIP8\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nPUT24E   DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP8   ANOP\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\n         LH    #0,ZLFDCB+82        GET DCB LRECL\n         TM    ZLFFLAG2,ZLFRECV    IF RECFM=V FILE\n         BZ    NOTRECVO            THEN...\n         TM    ZLFDCB+36,X'04'      IF RECFM = V.A\n         BZ    NOTRECVA             THEN...\n         STH   #0,0(,#1)             INITIALIZE RDW\n         XC    2(2,#1),2(#1)\n         MVI   4(#1),C'1'            INITIALIZE PRINT CONTROL CHAR\n         LA    #1,5(,#1)             BUMP PAST RDW TO TEXT\n         SH    #0,=H'5'              SET LENGTH OF ACTUAL TEXT\n         B     NOTRECFA\nNOTRECVA DS    0H                   RECFM = V(B), NOT A\n         STH   #0,0(,#1)            INITIALIZE RDW\n         XC    2(2,#1),2(#1)\n         LA    #1,4(,#1)            BUMP PAST RDW TO TEXT\n         SH    #0,=H'4'             SET LENGTH OF ACTUAL TEXT\n         B     NOTRECFA\nNOTRECVO DS    0H\n         TM    ZLFDCB+36,X'04'     IF RECFM = ..A\n         BZ    NOTRECFA            THEN...\n         MVI   0(#1),C'1'           INITIALIZE PRINT CONTROL CHAR\n         LA    #1,1(,#1)            BUMP POINTER PAST CONTROL CHAR\n         BCTR  #0,0                 SUBTRACT 1 FOR PRINT CONTROL CHAR\nNOTRECFA DS    0H\n         STH   #0,ZLFLRECL         STORE RECORD LENGTH\n         ST    #1,ZLFCARD          STORE CURRENT RECORD ADDRESS\n         ALR   #1,#0               RECORD ADDRESS + LRECL GIVES...\n         ST    #1,ZLFEND           NEW END-OF-RECORD POINTER\n         LA    #15,X'40'           SOURCE LENGTH = 0\n         SLL   #15,24              FILL = BLANK\n         L     #0,ZLFCARD          TARGET = OUTPUT AREA\n         LH    #1,ZLFLRECL         LENGTH = LENGTH OF OUTPUT AREA\n         XR    #14,#14             SOURCE = NULL\n         MVCL  #0,#14              CLEAR OUTPUT AREA TO BLANKS\nFILOPEND DS    0H                  FILE OPEN COMPLETE...\n         OI    ZLFFLAG2,ZLFOPEN    INDICATE FILE OPEN\n         CLI   ZLCMSLVL,0\n         BH    NONOTIFY\n         MVI   ZIL0006,C' '        CLEAR MESSAGE TO BLANKS\n         MVC   ZIL0006+1(L'ZIL0006-1),ZIL0006\n         MVC   ZIL0006(L'FM1MSG),FM1MSG\n         MVC   FM1NAME(4),FNAME    SET FILE NAME IN MESSAGE\n         LA    #1,FM1NAME          SEARCH FOR TERMINATING WHITESPACE\n         LA    #0,4                IN FILE NAME\nGETFM1   CLI   0(#1),X'40'\n         BNH   GOTFM1\n         LA    1,1(,#1)\n         BCT   #0,GETFM1\nGOTFM1   DS    0H\n         MVC   0(L'FM1REST,#1),FM1REST\n         CLI   TYPE,INPUT\n         BNE   FM1NOTIN\n         MVC   L'FM1REST(6,#1),=CL6'INPUT.'\n         B     FM1AFTIN\nFM1NOTIN MVC   L'FM1REST(7,#1),=CL7'OUTPUT.'\nFM1AFTIN DS    0H\n         #TPUT 0,ZIL0006           FILE OPEN SUCCESSFUL\nNONOTIFY DS    0H\n         SPACE 1\n         TM    ZLFFLAG1,ZLFTERM    IF THIS IS A TERMINAL FILE\n         BZ    TIOTEND             THEN\n         L     #7,ZLFTFPTR          LOAD PTR TO TRUE TERMINAL FILBLK\n         SPACE\nTIOTEND  DS    0H                  TIOT SEARCH OVER\n         SPACE\n         LM    #14,#6,ZLCSAVE2     RESTORE REGISTERS\n         LM    #8,#12,ZLCSAVE2+40  EXCEPT FOR REGISTER 7\n         DROP  #12\n         SPACE 1\n         LTR   #7,#7               IF A FILE BLOCK SUCCESSFULLY FOUND\n         BNZR  #14                 THEN RETURN WITH IT. ELSE ERROR\n         SPACE 1\n***********************************************************************\n*\n* FILE NOT FOUND, SIGNAL ERROR\n*\n***********************************************************************\n         SPACE 1\n         #BASR #4,0\n         USING *,#4\n         TM    ZLCERFLG,ZLCERCFA   IF THIS FILE ACCESS IS CONDITIONAL\n         BZ    FNFERROR            THEN...\n         XR    #7,#7                SET FILE BLOCK POINTER TO ZERO\n         BR    #14                  AND RETURN\nFNFERROR DS    0H                  ELSE FILE-NOT-FOUND ERROR\n         L     #6,FILEATOM         Get file argument\n         #ERR  PREFIX=NO,'ZIL0008 ',CALLER,': ',TYPESTR,               X\n               ' file ',(#6),' does not exist (DDNAME ',               X\n               DDSTR,' not found).'\n         SPACE 1\n         DROP  #4\n         EJECT\nGETCALR  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This subroutine extracts the name of the calling function, as       *\n* pointed to by register 12 on entry, and builds a \"fake string\"      *\n* out of it to pass to the error message handler.                     *\n*                                                                     *\n* It also sets the file type string to INPUT or OUTPUT.               *\n*                                                                     *\n* On entry register 1 points to the compiled function code (#12).     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         PUSH  USING\n         #BASR #2,0\n         USING *,#2\n         SPACE 1\n         CLI   TYPE,C'I'           IF FILE TYPE IS INPUT\n         BNE   GETCNI              then\n         MVC   TYPESTR(L'STRINPUT),STRINPUT\n         B     AFTGCETS            else\nGETCNI   MVC   TYPESTR(L'STROUTPT),STROUTPT\nAFTGCETS DS    0H\n         SPACE 1\n         XR    #15,#15             Clear insert register\n         IC    #15,4(,#1)          Get length of module identifier\n         SH    #15,=H'16'          Reduce by length of date/time info\n         BNP   DUNNO               If no name, generate dummy name\n         CH    #15,=Y(L'CALLTEXT)  If name longer than our text area\n         BNH   *+8                 then\n         LA    #15,L'CALLTEXT       use our maximum length\n         STCM  #15,7,CALLLEN       Store length of function name\n         BCTR  #15,0               Reduce length for execute\n         EX    #15,MVCCALL         Move caller's name to fake string\n         BR    #14                 Return to caller\nDUNNO    DS    0H                  Can't figure out function name?\n         MVC   CALLER(CALLDUML),CALLDUM Then use this...\n         BR    #14                 Return to caller\n         SPACE 1\nMVCCALL  MVC   CALLTEXT(*-*),5(#1) Executed: Move caller name to string\n         SPACE 1\n         DS    0H,XL1              Align string to non-halfword\nCALLER   DC    YL1(##STRING)       Fake string header\nCALLLEN  DC    AL3(0)              Fake string length\nCALLTEXT DS    CL64                Fake string text\n         DS    0H,XL1              Align string to non-halfword\nTYPESTR  #SATM '      '            Room for file type\n         SPACE 1\n         DS    0H,XL1              Align string to non-halfword\nSTRINPS  #SATM 'Input'             Possible file type\nSTRINPUT EQU   STRINPS,*-STRINPS\n         DS    0H,XL1              Align string to non-halfword\nSTROUPS  #SATM 'Output'            Possible file type\nSTROUTPT EQU   STROUPS,*-STROUPS\n         SPACE 1\n         DS    0H,XL1              Align string to non-halfword\nCALLDUM  #SATM 'ZILFGET'           Use this if can't figure out caller\nCALLDUML EQU   *-CALLDUM\n         SPACE 1\nFM1MSG   DC    C'ZIL0006 FILE '\nFM1REST  DC    C' OPEN FOR '\nFM1TYPE  DC    C'       '\nZIL0006  DS    CL(L'FM1MSG+4+L'FM1REST+7)\nFM1NAME  EQU   ZIL0006+L'FM1MSG,4,C'C'\n         SPACE 1\n         DC    C'0123456789ABCDEF'\nHEXTBL   EQU   *-256\n         SPACE 1\n         POP   USING\n         EJECT\nSTAEOK   DC    X'00'               Flag set if ESTAE successful\n         SPACE 1\nSTAEPARM DS    0A                  ESTAE PARAM AREA\nSTAECOMP DS    A                   COMPLETION CODE\nSTAEREAS DS    A                   REASON CODE\nSTAERTRY DS    A                   ADDRESS OF RETRY ROUTINE\nSTAEREGS DS    7A                  SAVE AREA FOR REGS 7-13\n         EJECT\nSTARETRY DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* RETRY ROUTINE TO RECEIVE CONTROL WHEN ESTAE EXIT DETECTED AN ABEND  *\n* IN THE OPEN ROUTINE.  THIS ROUTINE WILL ATTEMPT TO RETURN TO THE    *\n* MAINLINE CODE FOR THE PURPOSE OF DISPLAYING AN ERROR MESSAGE.       *\n*                                                                     *\n*  ON ENTRY TO THIS ROUTINE:                                          *\n*                                                                     *\n*  IF AN SDWA WAS AVAILABLE (REGISTER 0 = OTHER THAN 12 IN STAEEXIT)  *\n*  THEN (ASSUMING DEFAULTS OF RETREGS=NO AND FRESDWA=NO):             *\n*                                                                     *\n*    REGISTER  0 = 0                                                  *\n*    REGISTER  1 = ADDRESS OF THE SDWA                                *\n*    REGISTER 14 = ADDRESS OF AN SVC 3 INSTRUCTION (EXIT)             *\n*    REGISTER 15 = ENTRY POINT ADDRESS OF THIS RETRY ROUTINE          *\n*                                                                     *\n*  OTHERWISE (REGISTER 0 = 12 IN STAEEXIT):                           *\n*                                                                     *\n*    REGISTER  0 = 12                                                 *\n*    REGISTER  1 = ADDRESS OF THE ESTAE PARAMETER LIST (PARAM)        *\n*    REGISTER  2 = ADDRESS OF THE PURGE I/O LIST OR 0                 *\n*    REGISTER 14 = ADDRESS OF AN SVC 3 INSTRUCTION (EXIT)             *\n*    REGISTER 15 = ENTRY POINT ADDRESS OF THIS RETRY ROUTINE          *\n*                                                                     *\n*  OTHER REGISTER CONTENTS ARE UNPREDICTABLE (UNLESS RETREGS=YES      *\n*  WAS SPECIFIED IN THE ESTAE EXIT).                                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #6,#15\n         USING STARETRY,#6\n         LA    #3,12               CHECK IF REGISTER 0 = 12\n         CR    #0,#3               IF AN SDWA IS AVAILABLE\n         BE    NOSDWAR             THEN...\n         USING SDWA,#1\n         L     #4,SDWAPARM          #4 -> WORKAREA\n         B     AFTSDWAR\nNOSDWAR  DS    0H                  ELSE...\n         LR    #4,#1                #4 -> WORKAREA\nAFTSDWAR DS    0H\n         ESTAE 0                   CANCEL ESTAE\n         LM    #7,#13,STAEREGS-STAEPARM(#4)  RELOAD REGISTERS\n         DROP  #6\n         USING USING12,#12\n         MVC   ABENDF(4),FNAME\n         L     #0,STAECOMP-STAEPARM(,#4)      GET COMPLETION CODE\n         SLL   #0,4                SHIFT OUT HIGH ORDER BYTE\n         ST    #0,ZLCDBL\n         UNPK  ABENDC(4),ZLCDBL(3)\n         TR    ABENDC(4),HEXTBL\n         MVI   ABENDC+3,C','\n         L     #0,STAEREAS-STAEPARM(,#4)      GET REASON CODE\n         SLL   #0,16               ONLY CARE ABOUT LAST 3 NIBBLES\n         ST    #0,ZLCDBL\n         UNPK  ABENDR(4),ZLCDBL(3)\n         TR    ABENDR(4),HEXTBL\n         MVI   ABENDR+3,C'.'\n         #ERR  PREFIX=NO,          FILE NAME INVALID                   X\n               'ZIL0030 ',CALLER,': ',TYPESTR,                         X\n               ' file ',ABENDFS,' open failed, ABEND code ',ABENDCS,   X\n               ' reason code ',ABENDRS\n         SPACE 1\n         DS    0H,XL1\nABENDFS  #SATM '    '\nABENDF   EQU   ABENDFS+4,4,C'C'\n         DS    0H,XL1\nABENDCS  #SATM '   ,'\nABENDC   EQU   ABENDCS+4,4,C'C'\n         DS    0H,XL1\nABENDRS  #SATM '   .'\nABENDR   EQU   ABENDRS+4,4,C'C'\n         SPACE 1\n         DROP  #12\n         SPACE 1\n         EJECT\nSTAEEXIT DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ESTAE EXIT THAT GETS CONTROL IF AN ABEND OCCURS DURING OPEN.        *\n*                                                                     *\n*  ON ENTRY TO THIS ROUTINE:                                          *\n*                                                                     *\n*  REGISTER 0 = 12 - NO SWDA AVAILABLE                                *\n*               OTHER - SDWA AVAILABLE                                *\n*                                                                     *\n*  IF REGISTER 0 = 12:                                                *\n*                                                                     *\n*     REGISTER 1  = ABEND COMPLETION CODE                             *\n*     REGISTER 2  = ADDRESS OF THE ESTAE PARAMETER LIST (PARAM)       *\n*     REGISTER 14 = RETURN ADDRESS TO RTM                             *\n*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *\n*                                                                     *\n*  OTHERWISE:                                                         *\n*                                                                     *\n*     REGISTER 1  = ADDRESS OF THE SDWA                               *\n*     REGISTER 13 = ADDRESS OF A 72-BYTE SAVE AREA                    *\n*     REGISTER 14 = RETURN ADDRESS TO RTM                             *\n*     REGISTER 15 = ENTRY POINT ADDRESS OF THIS ESTAE EXIT ROUTINE    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         PUSH  USING\n         LR    #7,#15              SAVE ENTRY ADDRESS REGISTER\n         USING STAEEXIT,#7\n         LA    #3,12               CHECK IF REGISTER 0 = 12\n         CR    #0,#3               IF AN SDWA IS AVAILABLE\n         BE    NOSDWAE             THEN...\n         USING SDWA,#1\n         L     #4,SDWAPARM          #4 -> WORKAREA\n         XR    #5,#5\n         ICM   #5,7,SDWACMPC        #5 = COMPLETION CODE\n         ST    #5,STAECOMP-STAEPARM(,#4) STORE COMPLETION CODE\n         L     #6,SDWAGR15          #6 = REASON CODE FROM ABEND MACRO\n         ST    #6,STAEREAS-STAEPARM(,#4) STORE REASON CODE\n         L     #2,STAERTRY-STAEPARM(,#4) ADDRESS OF RETRY ROUTINE\n         SETRP RETADDR=(#2),DUMP=NO,RC=4  INDICATE RETRY\n         BR    #14                 AND RETURN\n         SPACE 1\nNOSDWAE  DS    0H                  NO SDWA AVAILABLE...\n         LR    #4,#2                #4 -> WORKAREA\n         LR    #5,#1                #5 = COMPLETION CODE\n         ST    #5,STAECOMP-STAEPARM(,#4) STORE COMPLETION CODE\n         XR    #6,#6                #6 = REASON CODE ZERO (UNKNOWN)\n         ST    #6,STAEREAS-STAEPARM(,#4) STORE REASON CODE\n         L     #0,STAERTRY-STAEPARM(,#4) ADDRESS OF RETRY ROUTINE\n         LA    #15,4               INDICATE RETRY TO BE ATTEMPTED\n         BR    #14                 AND RETURN\n         POP   USING\n         EJECT\nOUTEXIT  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DCB OPEN EXIT FOR ALL OUTPUT FILES.  THIS FILLS IN DCB INFO.        *\n*                                                                     *\n* NOTE: THIS ROUTINE EXECUTES IN AMODE 24 (I THINK).                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING DCBSTUFF,#1\nDCBSTUFF DSECT\nDSORG    EQU   DCBSTUFF+X'1A',2,C'X'\nRECFM    EQU   DCBSTUFF+X'24',1,C'X'\nLRECL    EQU   DCBSTUFF+X'52',2,C'H'\nBLKSIZE  EQU   DCBSTUFF+X'3E',2,C'H'\n         SPACE 1\nZILFGET  CSECT\n         SPACE 1\n         USING OUTEXIT,#15\n         OC    DSORG,DSORG         IF NO DSORG PRESENT\n         BNZ   OXGOTDS             THEN\n         MVI   DSORG,X'40'          SET DSORG = PS\nOXGOTDS  DS    0H\n         CLI   RECFM,X'00'         IF NO RECFM PRESENT\n         BNE   OXGOTRF             THEN\n         MVI   RECFM,X'90'          SET RECFM = FB\n         B     OXFIXED              AND PROCESS FIXED LRECL.\nOXGOTRF  DS    0H                  ELSE THERE IS A RECFM\n         TM    RECFM,X'80'         IF RECFM = V..\n         BO    OXFIXED             THEN\n         OC    LRECL,LRECL          IF THERE'S NO LRECL\n         BNZ   OXGOTLR              THEN\n         LA    #15,255               SET LRECL = 255\n         STH   #15,LRECL\n         LA    #15,4095\n         LA    #15,6233-4095(,#15)   SET BLKSIZE = 6233\n         STH   #15,BLKSIZE\n         BR    #14                   AND RETURN.\nOXFIXED  DS    0H\n         OC    LRECL,LRECL         IF LRECL IS ZERO\n         BZ    OXSETF              THEN SET LRECL AND BLKSIZE\nOXGOTLR  OC    BLKSIZE,BLKSIZE     IF BLOCK SIZE EXISTS\n         BNZR  #14                 THEN WE ARE ALL SET\n         LA    #15,6160/80         ELSE GET DEFAULT BLOCKING FACTOR\n         MH    #15,LRECL           MULTIPLY BY LRECL\n         STH   #15,BLKSIZE         SET BLOCKSIZE\n         BR    #14\nOXSETF   LA    #15,80               SET LRECL = 80\n         STH   #15,LRECL\n         LA    #15,4095\n         LA    #15,6160-4095(,#15)  SET BLKSIZE = 6160\n         STH   #15,BLKSIZE\n         BR    #14                  AND RETURN.\n         SPACE 1\n         DROP  #1,#15\n         EJECT\nINPUT    EQU   C'I'\nOUTPUT   EQU   C'O'\n         SPACE 1\n         DS    0H,XL1              Align fake string to non-halfword\nDDSTR    DC    YL1(##STRING)\nDDLEN    DC    AL3(8)\nDDNAME   DS    CL8\nTYPE     EQU   DDNAME+3,1,C'C'\nFILEATOM DS    A\nFNAME    DS    CL4\n         SPACE 1\nOPENL    OPEN  (*-*),MF=L\n         SPACE 1\nXLOUT    DC    0F'0',X'85',AL3(OUTEXIT) EXIT LIST FOR OUTPUT DCB\n         EJECT\nNUMTBL   DC    256YL1(1)           TABLE TO SCAN FOR NUMERICS\n         ORG   NUMTBL+C'0'\n         DC    10YL1(0)\n         ORG\n         EJECT\nINDDDCB  DCB   DDNAME=X,                                               X\n               MACRF=GL,                                               X\n               DSORG=PS   NOTE - NO EODAD. THIS IS SET DYNAMICALLY.\n         EJECT\nOUTDDDCB DCB   DDNAME=X,                                               X\n               MACRF=PL,                                               X\n               DSORG=PS,                                               X\n               EXLST=XLOUT\n         EJECT\n         #ZHDR ,\n         EJECT\n         IHASDWA  ,\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILFINT": {"ttr": 13057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11R\\x00{\\x00x\\x00z\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:52:00", "lines": 123, "newlines": 120, "modlines": 122, "user": "SEB1525"}, "text": "         TITLE 'ZILFINT - ZIL 1.3 FORTRAN INTERFACE SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  THIS ROUTINE, LINKEDITED WITH ZILSUBS AND ACCESSIBLE VIA THE       *\n*  ZLCFINT POINTER IN THE ZIL COMMON AREA, EFFECTS THE FORTRAN        *\n*  INTERFACE.  THIS ROUTINE IS CALLED THE FIRST TIME ANY ZIL          *\n*  FUNCTION THAT REQUIRES THE FORTRAN INTERFACE GETS EXECUTED,        *\n*  E.G. SQRT.  IT SHOULD NOT BE CALLED MORE THAN ONCE PER SUCH        *\n*  FUNCTION, BUT MAY BE CALLED FOR SEVERAL FUNCTIONS.                 *\n*                                                                     *\n*  THE FIRST TIME THIS ROUTINE IS CALLED BY ANYBODY, IT SETS UP       *\n*  THE FORTRAN INTERFACE BY ALLOCATING THE FORTRAN INTERFACE          *\n*  CONTROL BLOCK AND PLACING ITS ADDRESS IN THE ZIL COMMON AREA.      *\n*                                                                     *\n*  ON ENTRY TO THIS ROUTINE:                                          *\n*                                                                     *\n*  #1  CONTAINS ZERO IF THIS ROUTINE IS BEING CALLED TO TERMINATE     *\n*      THE FORTRAN INTERFACE;                                         *\n*  #1  NONZERO IF A FORTRAN SUBROUTINE IS TO BE LOADED                *\n*                                                                     *\n*  ON EXIT FROM THIS ROUTINE:                                         *\n*                                                                     *\n*  #15 CONTAINS THE ADDRESS OF THE FORTRAN INTERFACE CONTROL BLOCK.   *\n*                                                                     *\n*  SAVE AREA CONVENTIONS:                                             *\n*                                                                     *\n*  THIS ROUTINE SETS UP A SPECIAL SAVE AREA FOR FORTRAN CALLS.        *\n*  FUNCTIONS THAT CALL FORTRAN CODE SHOULD SET REGISTER 13 TO         *\n*  POINT TO THIS SAVE AREA BY DOING THE FOLLOWING:                    *\n*                                                                     *\n*       ST   #9,ZLCISV09            SAVE CONS POINTER IN CASE OF ATTN *\n*       OI   ZLCIFLGS,ZLCISYS       INDICATE NON-ZIL CODE RUNNING     *\n*       L    #13,ZLCFTCBA           POINT TO FORTRAN SAVE AREA        *\n*                                                                     *\n*  SINCE THE FIRST 18 WORDS OF THE FORTRAN INTERFACE CONTROL BLOCK    *\n*  ARE THE SAVE AREA FOR USE BY FORTRAN CODE.  TO RESTORE #13 AFTER   *\n*  THE CALL, DO:                                                      *\n*                                                                     *\n*       L    #13,4(,#13)            POINT BACK TO ZIL COMMON AREA     *\n*       NI   ZLCIFLGS,255-ZLCISYS   TURN OFF NON-ZIL-CODE FLAG        *\n*       TM   ZLCIFLGS,ZLCIATTN      IF ATTENTION INTERRUPT OCCURRED   *\n*       BOR  #13                    THEN GO TO HANDLE IT              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILFINT  #ZBEG NAME='ZILFINT'\n         DROP  #15\n         STM   #12,#7,SAVEREGS-ZILFINT(#15) SAVE REGS IN OUR OWN PLACE\n         LR    #12,#15\n         USING ZILFINT,#12\n         SPACE 1\n         LTR   #3,#1               SAVE INPUT PARAMETER\n         BZ    CLEANUP             IF ZERO, IT'S A TERMINATION REQUEST\n         SPACE 1\n         L     #4,ZLCFTCBA         GET ADDRESS OF FORTRAN INTERFACE CB\n         LTR   #4,#4               IF WE AIN'T GOT ONE YET,\n         BNZ   GOTIT               THEN...\n         #GETMAIN RC,LV=ZIFLEN,LOC=BELOW GET ONE\n         LTR   #15,#15              IF WE COULDN'T GET ONE\n         BNZ   ERRORG               THEN BARF\n         ST    #1,ZLCFTCBA          STORE ITS ADDRESS\n         LR    #4,#1                ESTABLISH ADDRESSABILITY\n         USING ZIF,#4\n*\n* FILL IN FORTRAN INTERFACE CONTROL BLOCK FIELDS\n*\n         LOAD  EP=ZIFINIT,ERRET=ERRORI LOAD FORTRAN INTERFACE PROCESSOR\n         LR    #5,#0               SAVE ENTRY POINT\n         ST    #13,ZIFSA+4         SET HSA POINTER IN FTCB SAVE AREA\n         SPACE 1\n         ST    #13,ZIFSA+4         SET HSA POINTER IN FTCB SAVE AREA\n         SPACE 1\n         LR    #15,#5              GET ADDRESS OF ZIFINIT\n         LR    #1,#4               POINT TO ZIF AREA\n         OI    ZLCIFLGS,ZLCISMC    CAN'T INTERRUPT WHILE INIT'ING FTN\n         #BASR #14,#15             CALL ZIFINIT TO INITIALIZE FTN ENV\n         NI    ZLCIFLGS,255-ZLCISMC\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         SPACE 1\nGOTIT    DS    0H\n         SPACE 1\n         ST    #4,SAVEREGS+12      SAVE IN WHAT WILL BE RETURNED #15\n         SPACE 1\nRETURN   DS    0H\n         LM    #12,#7,SAVEREGS     RESTORE REGS\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nCLEANUP  DS    0H\n         ICM   #4,15,ZLCFTCBA      GET FTCB ADDRESS\n         BZ    NOCLN               IF NONE, NO CLEANUP TO DO\n         DELETE EP=ZIFINIT\n         LR    #1,#4\n         LA    #0,ZIFLEN\n         FREEMAIN R,LV=(0),A=(1)   FREE THE CONTROL BLOCK\nNOCLN    DS    0H\n         LM    #12,#7,SAVEREGS     RESTORE REGS (RETURN VALUE IRRELEV.)\n         BR    #14                 RETURN TO CALLER\n         SPACE 2\nSAVEREGS DS    12A                 REGISTER SAVE AREA\n         SPACE 2\nERRORG   #ERR  PREFIX=NO,                                              X\n               'ZIL0060 ZILFINT: No storage available for FORTRAN interX\n               face.'\n         SPACE 1\nERRORI   #ERR  PREFIX=NO,                                              X\n               'ZIL0061 ZILFINT: FORTRAN interface initialization faileX\n               d, module ZIFINIT could not be loaded.'\n         SPACE 1\n         LTORG\n         EJECT\n         #ZIF  ,                   FORTRAN INTERFACE CONTROL BLOCK\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILFIX": {"ttr": 13060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11R\\x01\\xf0\\x01\\xed\\x01\\xef\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:52:00", "lines": 496, "newlines": 493, "modlines": 495, "user": "SEB1525"}, "text": "         TITLE 'ZILFIX - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILFIX TAKES TWO ARGUMENTS:  (1) a number, (2) a fixnum.            *\n*                                                                     *\n* Arg 2 determines which kind of conversion-to-integer to perform,    *\n* as follows:                                                         *\n*                                                                     *\n*             0   ==>  TRUNCATE                                       *\n*             4   ==>  FLOOR                                          *\n*             8   ==>  CEILING                                        *\n*            12   ==>  ROUND                                          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS:                                    *\n*                                                                     *\n* 1. ARG FIXED               - RETURN FIXNUM ITSELF.                  *\n* 2. ARG BIG                 - RETURN BIGNUM ITSELF.                  *\n* 3. ARG FLOAT               - CONVERT TO FIXED AND RETURN.           *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILFIX   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILFIX'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #15,0(,#11)         Load argument 1\n         TM    ##TYPE(#15),##INT   IF FIXNUM OR BIGNUM, RETURN SELF\n         BO    RETURN\n         CLI   ##TYPE(#15),##SFLOAT IF SINGLE FLOAT, CONVERT IT\n         BE    SCONVERT\n         CLI   ##TYPE(#15),##DFLOAT IF DOUBLE FLOAT, CONVERT IT\n         BE    DCONVERT\n         B     ERROR1              ALL OTHER TYPES: ERROR\n         SPACE 1\nSCONVERT DS    0H                  FLOAT TO BE CONVERTED TO FIX\n         SPACE 1\n         SDR   #F0,#F0\n         LE    #F0,##CDR(,#15)     GET FLONUM VALUE\n         B     CONVERT\nDCONVERT DS    0H                  FLOAT TO BE CONVERTED TO FIX\n         SPACE 1\n         LD    #F0,8(,#15)         GET FLONUM VALUE\nCONVERT  DS    0H                  FLOAT TO BE CONVERTED TO FIX\n         L     #14,4(,#11)         Load argument 2\n         L     #14,##CDR(,#14)     Get value of arg2\n         LPDR  #F2,#F0             Get absolute value of flonum\n         B     PROCESS1(#14)       Branch based on request\nPROCESS1 B     TRUNC1               0 = TRUNCATE\n         B     FLOOR1               4 = FLOOR\n         B     CEIL1                8 = CEILING\n         B     ROUND1              12 = ROUND\n         SPACE 1\nTRUNC1   DS    0H                  Adjust for TRUNCATE...\n         SPACE 1\n         AW    #F2,W0              UNNORMALIZE TO GET INTEGER PART\n         BZ    RET0                IF INTEGER PART ZERO, RETURN ZERO\n         B     NOADJUST            otherwise don't adjust\n         SPACE 1\nROUND1   DS    0H                  Adjust for ROUND\n         SPACE 1\n         AD    #F2,DHALF           Add 0.5 to it\n         LDR   #F4,#F2             Save this value\n         AW    #F2,W0              Unnormalize to get integer part\n         BZ    RET0                If integer part zero, return zero\n         STD   #F2,ZLCWORK         Store into workarea\n         CLC   ZLCWORK(4),W0       IF DOESN'T START WITH 4E000000\n         BNE   FLT2BIG             THEN DO FLOAT-TO-BIGNUM CONVERSION\n         LDR   #F6,#F2             Get normalized version of un...\n         CDR   #F4,#F6             If adding 0.5 made this an integer\n         BNE   NOADJUSR             and\n         TM    ZLCWORK+7,X'01'       this is an odd integer\n         BZ    NOADJUSR               then\n         SW    #F2,W1                  subtract an unnormalized 1\n         BZ    RET0                If integer part zero, return zero\n         B     NOADJUST            Else process adjusted number\n         SPACE 1\nCEIL1    DS    0H                  Adjust for CEILING\n         SPACE 1\n         AW    #F2,W0              UNNORMALIZE TO GET INTEGER PART\n         BZ    CEIL2               IF INTEGER PART ZERO, RETURN ZERO\n         LTDR  #F0,#F0             If number is positive\n         BNP   NOADJUST             and\n         CDR   #F0,#F2               integer part not equal to orig $\n         BE    NOADJUST               then (neg with fractional part)\n         AW    #F2,W1                  adjust for CEILING by +1\n         B     NOADJUST\n         SPACE 1\nFLOOR1   DS    0H                  Adjust for FLOOR\n         SPACE 1\n         AW    #F2,W0              UNNORMALIZE TO GET INTEGER PART\n         BZ    FLOOR2              IF INTEGER PART ZERO, RETURN ZERO\n         LTDR  #F0,#F0             If number is negative\n         BNM   NOADJUST             and\n         LPDR  #F4,#F0               the absolute value's\n         CDR   #F4,#F2               integer part not equal to orig $\n         BE    NOADJUST               then (neg with fractional part)\n         AW    #F2,W1                  adjust for FLOOR by -1\n******** B     NOADJUST\n         SPACE 1\nNOADJUST DS    0H\n         STD   #F2,ZLCWORK         STORE INTO WORKAREA\n         CLC   ZLCWORK(4),W0       IF DOESN'T START WITH 4E000000\n         BNE   FLT2BIG             THEN DO FLOAT-TO-BIGNUM CONVERSION\nNOADJUSR DS    0H\n         ICM   #2,15,ZLCWORK+4     ELSE GET INTEGER PART INTO REGISTER\n         BM    FLT2BIG             IF GT 7FFFFFFF, MUST BE BIGNUM\n         LTDR  #F0,#F0             IF ORIGINAL NUMBER WAS NEGATIVE\n         BNM   CVFIX               THEN\n         LCR   #2,#2                MAKE THIS ONE NEGATIVE\n         SPACE 1\nCVFIX    DS    0H                  MAKE A FIXNUM FROM FLOAT\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FIXED               MAKE A FIXED ATOM\n         B     RETURN              RETURN IT\n         SPACE 1\nCEIL2    DS    0H                  Process zero for CEILING\n         LTDR  #F0,#F0             If original flonum was not positive\n         BNP   RET0                then return fixnum zero\n         LA    #15,#SFT1           Else get fixnum 1\n         B     RETURN              and return it\n         SPACE 1\nFLOOR2   DS    0H                  Process zero for FLOOR\n         LTDR  #F0,#F0             If original flonum was not negative\n         BNM   RET0                then return fixnum zero\n         LA    #15,#SFTM1          Else get fixnum -1\n         B     RETURN              and return it\n         SPACE 1\nRET0     DS    0H                  Process zero for TRUNCATE and ROUND\n         LA    #15,#SFT0           Get fixnum zero\n         B     RETURN              and return it\n         SPACE 1\nFLT2BIG  DS    0H                  Float-to-bignum conversion\n         SPACE 1\n         LTDR  #F0,#F0             If original float negative\n         BNM   NOTMNFIX            and\n         CLC   ZLCWORK(8),=X'4E00000080000000' abs(val) = 2147483648\n         BNE   NOTMNFIX            then\n         LA    #15,MTWO31           get fixnum -2147483648\n         B     RETURN               and return with it.\nNOTMNFIX DS    0H                  Else a real bignum\n         SPACE 1\n         CLI   ##TYPE(#15),##DFLOAT\n         BE    DFLT2BIG            If double, go convert double to big\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Single-float-to-bignum conversion logic:  Since we are dealing with *\n* single-precision flonums, a flonum that is larger than the          *\n* maximum fixnum has only the high-order 24 bits of precision in it.  *\n* Therefore, we view the equivalent (bignum) integer as a number of N *\n* bits where N is 4*(characteristic-64), of which the leftmost 24     *\n* bits are the mantissa and the remainder can only be assumed zero.   *\n*                                                                     *\n* Logically, we add 0-bits on the left until the number of bits is a  *\n* multiple of 31.  In reality, we accomplish this by loading the      *\n* 24-bit mantissa into a register pair, left justified, and right     *\n* shifting it by the difference between N and the next higher         *\n* multiple of 31.                                                     *\n*                                                                     *\n* Call the new number of bits B.  We allocate a bignum of B/31 words  *\n* and make the register pair the 2 most significant words thereof.    *\n*                                                                     *\n* Then check the sign of the original flonum, and pass it on to       *\n* the bignum.                                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*\n*                                  #15 -> arg 1\n*                                  #F0 = single float value\n*\n         LPER  #F2,#F0             #F2 = abs (single float value)\n         STE   #F2,ZLCWORK         Store flonum value\n         XR    #0,#0               Clear register pair\n         XR    #1,#1\n         XR    #6,#6               Clear register pair\n         XR    #7,#7\n         ICM   #6,B'1110',ZLCWORK+1 Load mantissa into register pair\n         SRL   #6,2                Pretend it's a 62-bit register pair\n         IC    #1,ZLCWORK          Get characteristic\n         SH    #1,=H'64'           Convert from excess-64 notation\n         SLA   #1,2                Multiply by 4 to get # of bits\n         D     #0,=F'31'           #0 = remainder, #1 = quotient\n*                                  (#1 will be number of bignum words)\n         LTR   #0,#0               If remainder is zero,\n         BZ    NOREM                then bypass shift\n         LA    #1,1(,#1)           Else increment quotient by 1\n         LA    #14,31              Compute shift amount\n         SR    #14,#0               = 31 minus remainder\n         SRDL  #6,0(#14)           Shift mantissa right by this amount\nNOREM    DS    0H\n         SLDL  #6,1                Convert 62-bit register pair to\n         SRL   #7,1                 a pair of bigits\n         LTR   #6,#6               If leftmost bigit is zero,\n         BNZ   NBZERO              then...\n         SLDL  #6,32                set #6 = #7, #7 = zeroes\n         BCTR  #1,0                 and reduce bignum word count by 1\nNBZERO   DS    0H\n         LTR   #1,#1               Check bignum word count\n         BNP   DISASTER            Must be at least 1, else bug\n         CH    #1,=H'1'            If count = 1\n         BNE   BNOT1               then...\n         LTR   #7,#7                we must have at least 1 clear reg\n         BNZ   DISASTER             else disaster\n         LR    #2,#6                load value\n         #MKAT FIXED                make a fixnum out of it\n         B     RETURN               and return\nBNOT1    DS    0H\n         LR    #2,#1               Get number of words for bignum\n         SLA   #2,2                Multiply by 4 to get # of bytes\n         LR    #3,#2               Save this length\n         LA    #2,##VECDAT(,#2)    Add header length\n         L     #15,ZLCBIG          Get address of ZILBIG\n         #BASR #14,#15             Call ZILBIG to allocate a bignum\n         STCM  #3,7,1(#15)         Store length\n*\n* We can use an EX here because, at least for single-precision\n* flonums, the bignum length won't ever get anywhere near 256 bytes.\n*\n         LR    #14,#3              Get bignum text length\n         BCTR  #14,0               Reduce for execute\n         EX    #14,CLEARBIG        Clear bignum text to zeroes\n         LA    #1,##VECDAT(#3,#15) Point to end of bignum\n         SH    #1,=H'8'            Bump back to two MSW's\n         ST    #6,4(,#1)           Store left half of reg into MSW\n         ST    #7,0(,#1)           Store right half of reg into (M-1)SW\n         SPACE 1\n         LTER  #F0,#F0             If original bignum was negative\n         BNM   BRETURN             then...\n         CLC   0(12,#15),TWO31      if bignum so far is 2**31\n         BNE   BNEG                 then...\nMNFIX    DS    0H\n         LA    #15,MTWO31            return -2147483648\n         B     RETURN\nBNEG     DS    0H                  else\n         OI    ##VECDAT(#15),X'80'  turn on negative sign bit\nBRETURN  DS    0H\n         LA    #1,##VECDAT(#3,#15) Get address of end of bignum\n         ST    #1,ZLCVSNXT         Update VSS pointer\n         B     RETURN              Return with it\n         EJECT\nDFLT2BIG DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Double-float-to-bignum conversion logic:  This is similar to        *\n* the single-float-to-bignum conversion above, but is different       *\n* in that, first of all, since there are up to 56 bits of precision   *\n* in a double-float, it is possible for there to be a fractional part *\n* with an integer part that is more than 31 bits.  Therefore, we must *\n* work with the unnormalized-zero-added value.  We can break this     *\n* into two cases, then.                                               *\n*                                                                     *\n* In case 1, the value after adding unnormalized zero has an X'4E'    *\n* characteristic, meaning that the entire contents of the floating    *\n* point register is the integer part as is.  If so, we can just build *\n* a two-word bignum and dump the mantissa into it.                    *\n*                                                                     *\n* In case 2, the characteristic is greater than X'4E', meaning that   *\n* there are implied low-order zero bits in the integer part.  We must *\n* compute the shift value to get the number of bits to be a multiple  *\n* of 31, as above, but in this case we have to process 3 words of     *\n* integer instead of 2.  For a single-precision flonum, the maximum   *\n* number of \"visible\" bits is 24+30 = 54, which fits into 2 words;    *\n* for a double-precision flonum, the maximum number of \"visible\" bits *\n* is 56+30 = 86, which fits into 3 words.  Therefore, we have to      *\n* simulate a triple shift.                                            *\n*                                                                     *\n* Note that a characteristic less than X'4E' is not possible, due to  *\n* the unnormalized zero add.                                          *\n*                                                                     *\n* As above, we view the equivalent (bignum) integer as a number of N  *\n* bits where N is 4*(characteristic-64), of which the leftmost 56     *\n* bits are the mantissa and the rest can only be assumed zero.        *\n*                                                                     *\n* Logically, we add 0-bits on the left until the number of bits is a  *\n* multiple of 31.  In reality, we accomplish this by loading the      *\n* 56-bit mantissa into a register triple, left justified, and right   *\n* shifting it by the difference between N and the next higher         *\n* multiple of 31.  We can implement the triple shift by using two     *\n* register pairs, with the middle word providing the overlap.         *\n*                                                                     *\n* Call the new number of bits B.  We allocate a bignum of B/31 words  *\n* and make the register triple the 3 most significant words thereof.  *\n*                                                                     *\n* If the high-order word of the bignum ends up zero, reduce the       *\n* length of the bignum by 1 word.                                     *\n*                                                                     *\n* Then check the sign of the original flonum, and pass it on to       *\n* the bignum.                                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*\n*                                  #F0 = single float value\n*                                  #F2 = abs. unnormalized integer part\n*                                  ZLCWORK = contents of #F2\n         SPACE 1\n         CLI   ZLCWORK,X'4E'\n         BE    CASE1               If 4E, simple 56-bit bignum\n         BH    CASE2               If higher, time to shift\n         BL    DISASTER            Can't be lower - can it???\n         SPACE 1\nCASE1    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* In case 1, the value after adding unnormalized zero has an X'4E'    *\n* characteristic, meaning that the entire contents of the floating    *\n* point register is the integer part as is.  If so, we can just build *\n* a two-word bignum and dump the mantissa into it.                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n* Note that the case of -2**31 was handled above.\n* (Not to mention fixnums.)\n         SPACE 1\n         LM    #6,#7,ZLCWORK       Load mantissa parts\n         SLDL  #6,8                Shift out characteristic\n         SRDL  #6,7                Shift back, but not sign bit of #7\n         SRL   #7,1                Shift right register correctly\nC1BIGNUM DS    0H\n         LA    #2,##VECDAT+8       Set size for a 2-word bignum\n         L     #15,ZLCBIG          Get address of ZILBIG\n         #BASR #14,#15             Call ZILBIG to allocate a bignum\n         MVC   1(3,#15),=AL3(8)    Set bignum length\n         ST    #7,##VECDAT+0(#15)  Store low-order word\n         ST    #6,##VECDAT+4(#15)  Store high-order word\n         LTDR  #F0,#F0             If original bignum was negative\n         BNM   C1RETURN            then...\n         OI    ##VECDAT(#15),X'80'  turn on negative sign bit\nC1RETURN DS    0H\n         LA    #1,##VECDAT+8(,#15) Get address of end of bignum\n         ST    #1,ZLCVSNXT         Update VSS pointer\n         B     RETURN              Return with new bignum\n         SPACE 1\nCASE2    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* In case 2, the characteristic is greater than X'4E', meaning that   *\n* there are implied low-order zero bits in the integer part.          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*\n* If the flonum has 62 bits or less in it already, make a 2-word bignum\n*\n         CD    #F2,=X'503FFFFFFFFFFFFF'\n         BH    C2WORD3\n         LM    #6,#7,ZLCWORK       Load mantissa into register pair\n         SLDL  #6,8                Shift out characteristic\n*\n* We know that the characteristic is greater than X'4E', so it can be\n* only X'4F' or X'50'.  If it is X'50', we already shifted left 8 bits\n* to get rid of the characteristic.  If it is X'4F', we counteract\n* that by shifting right 4, because we want a shifted-left-by-4 value.\n*\n         CLI   ZLCWORK,X'4F'\n         BNE   C22SHIFT\n         SRDL  #6,4\nC22SHIFT DS    0H\n         SLDL  #6,1                Convert to bigits\n         SRL   #7,1\n         B     C1BIGNUM            Go make a 2-word bignum\n         SPACE 1\nC2WORD3  DS    0H                  Will be at least a 3-word bignum...\n         SPACE 1\n         XR    #0,#0               Clear register pair\n         XR    #1,#1\n*\n* First we construct a 93-bit number, since that will transform into\n* a 3-bigit bignum.  Thus we left-justify the mantissa in 93 bits.\n*\n         LM    #6,#7,ZLCWORK       Load mantissa into register pair\n         SLDL  #6,8                Shift out characteristic\n         SRDL  #6,3                Leave 3 high-order zero bits\n         IC    #1,ZLCWORK          Get characteristic\n         SH    #1,=H'64'           Convert from excess-64 notation\n         SLA   #1,2                Multiply by 4 to get # of bits\n         D     #0,=F'31'           #0 = remainder, #1 = quotient\n*                                  (#1 will be number of bignum words)\n         LTR   #0,#0               If remainder is zero,\n         BZ    C2NOREM              then bypass shift\n         LA    #1,1(,#1)           Else increment quotient by 1\n         LA    #14,31              Compute shift amount\n         SR    #14,#0               = 31 minus remainder\n*\n* Shift mantissa right by the amount indicated.  Simulate a\n* \"register triple\" shift, where the triple is contained in\n* registers #6+#7+#5.\n*\n         LR    #4,#7               Load into second register pair\n         XR    #5,#5               Clear other half of register pair\n         SRDL  #6,0(#14)           Shift right by amount\n         SRDL  #4,0(#14)           Shift right by amount\nC2NOREM  DS    0H\n*\n* Convert 93-bit register triple to 3 \"bigits\".\n*\n         SLDL  #6,2\n         SRL   #7,2\n         LR    #4,#7\n         SLDL  #4,1\n         SRL   #5,1\n         LR    #3,#6\n*\n* The bigits are contained in the register triple #3+#4+#5.\n*\n         LTR   #3,#3               If leftmost bigit is zero,\n         BNZ   C2NZERO             then...\n         LR    #3,#4                set #3 = #4\n         SLDL  #4,32                set #4 = #5, #5 = zeroes\n         BCTR  #1,0                 reduce bignum length by 1\nC2NZERO  DS    0H\n         CH    #1,=H'3'            If bignum length is not at least 3\n         BL    DISASTER            then something is wrong.\n         STM   #3,#5,C2SAVE        Store contents\n         LR    #2,#1               Get number of words for bignum\n         SLA   #2,2                Multiply by 4 to get # of bytes\n         LR    #3,#2               Save this length\n         LA    #2,##VECDAT(,#2)    Add header length\n         L     #15,ZLCBIG          Get address of ZILBIG\n         #BASR #14,#15             Call ZILBIG to allocate a bignum\n         STCM  #3,7,1(#15)         Store length\n*\n* We can use an EX here because, at least for double-precision\n* flonums, the bignum length won't ever get anywhere near 256 bytes.\n*\n         LR    #14,#3              Get bignum text length\n         BCTR  #14,0               Reduce for execute\n         EX    #14,CLEARBIG        Clear bignum text to zeroes\n         LA    #1,##VECDAT(#3,#15) Point to end of bignum\n         LM    #5,#7,C2SAVE        Get bignum contents\n         SH    #1,=H'12'            Bump back to three MSW's\n         ST    #5,8(,#1)            Store MSW\n         ST    #6,4(,#1)           Store (M-1)SW\n         ST    #7,0(,#1)           Store (M-2)SW\nC2CKSIGN DS    0H\n         LTDR  #F0,#F0             If original bignum was negative\n         BNM   C2RETURN            then...\n         OI    ##VECDAT(#15),X'80'  turn on negative sign bit\nC2RETURN DS    0H\n         LA    #1,##VECDAT(#3,#15) Get address of end of bignum\n         ST    #1,ZLCVSNXT         Update VSS pointer\n******** B     RETURN              Return with it\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nC2SAVE   DS    3A\n         SPACE 1\nCLEARBIG XC    ##VECDAT(*-*,#15),##VECDAT(#15) Executed: clear bignum\n         SPACE 1\n         DS    0D\nW0       DC    X'4E00000000000000' Unnormalized double float zero\nW1       DC    X'4E00000000000001' Unnormalized double float one\nDHALF    DC    D'0.5'              1/2 to add for rounding\n         SPACE 1\nMTWO31   #IATM -2147483648         Most negative fixnum\n         SPACE 1\nTWO31    DC    YL1(##BIGNUM),AL3(8),F'0,1'  Bignum 2**31\n         SPACE 1\nERROR1   DS    0H                  NOT A NUMERIC ATOM\n         L     #14,4(,#11)\n         L     #14,##CDR(,#14)\n         L     #2,FUNNAME(#14)\n         #ERR  'Argument 1 to ',0(#2),' not a number - ',0(#11)\n         SPACE 1\nDISASTER DS    0H\n         #ERR  'Internal error in ZILFIX computing bignum value for ', X\n               0(#11)\n         SPACE 1\nFUNNAME  DC    A(MSGTRUNC,MSGFLOOR,MSGCEIL,MSGROUND)\n         SPACE 1\n         DS    0H,XL1              Align string to non-halfword\nMSGTRUNC #SATM 'TRUNCATE'\n         DS    0H,XL1              Align string to non-halfword\nMSGFLOOR #SATM 'FLOOR'\n         DS    0H,XL1              Align string to non-halfword\nMSGCEIL  #SATM 'CEILING'\n         DS    0H,XL1              Align string to non-halfword\nMSGROUND #SATM 'ROUND'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILGCD": {"ttr": 13313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11R\\x00\\x8c\\x00\\x89\\x00\\x8b\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:52:00", "lines": 140, "newlines": 137, "modlines": 139, "user": "SEB1525"}, "text": "         TITLE 'ZILGCD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This is fixnum-by-fixnum GCD, implemented in assembler for speed.   *\n*                                                                     *\n* Called by GCD2 when both arguments are fixnums only.                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILGCD TAKES TWO ARGUMENTS. BOTH MUST BE INTEGERS.                  *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n* ===> BIGNUM ARGUMENTS NOT YET IMPLEMENTED                           *\n*                                                                     *\n*  ALGORITHM FOR FIXNUM ARGUMENTS IS EUCLID'S ALGORITHM.              *\n*  SPECIAL BRANCHES ARE NECESSARY TO HANDLE SPECIAL CASES INVOLVING   *\n*  NEGATIVE ARGUMENTS, ZERO ARGUMENTS, AND THE FACT THAT THE          *\n*  ABSOLUTE VALUE OF THE MOST NEGATIVE FIXNUM BECOMES A POSITIVE      *\n*  BIGNUM.                                                            *\n*                                                                     *\n*  BASIC IDEA OF EUCLIDS ALGORITHM:                                   *\n*                                                                     *\n*  REM  = MOD(ARG ,ARG )                                              *\n*     1          1    2                                               *\n*                                                                     *\n*  REM  = MOD(ARG ,REM )                                              *\n*     2          2    1                                               *\n*                                                                     *\n*  REM  = MOD(REM ,REM )                                              *\n*     3          1    2                                               *\n*                                                                     *\n*  REM  = MOD(REM ,REM )                                              *\n*     4 .        2    3                                               *\n*       .                                                             *\n*       .                                                             *\n*  (UNTIL REM  = 0, THEN ANSWER IS REM   )                            *\n*            N                        N-1                             *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILGCD   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILGCD'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #2,#3,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#2),##FIXNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#3),##FIXNUM\n         BNE   ERROR2\n*---------------------------------------------------------------------*\n*           FIXNUM BY FIXNUM GCD                                      *\n*---------------------------------------------------------------------*\n         ICM   #4,15,##CDR(#2)     LOAD ARG2 AND FIND OUT SIGN\n         BZ    FIXFIX0             ARG2 IS ZERO\n         L     #6,##CDR(,#3)       GET ARG1\n         SRDA  #6,32               CLEAR REG 6 BEFORE DIVIDE\n         DR    #6,#4               DO FIRST DIVIDE\n         LPR   #7,#6               TEST FOR ZERO\n         BZ    FFD0                RESULT OF FIRST DIVIDE IS ZERO\n         SRDA  #4,32               EXTEND SIGN AND CLEAR FOR NEXT DIV\n         DR    #4,#7               DIVIDE SECOND TIME\n         LPR   #5,#4               TEST FOR ZERO\n         BZ    FFX                 ANSWER IN REG 7\n         XR    #6,#6               CLEAR FOR NEXT DIVIDE\n         DR    #6,#5               ANOTHER GCD STEP\n         SRDA  #6,32               REG 6 ==> REG 7, CLEAR 6 FOR NXT DIV\n         BZ    FFY                 ANSWER IN REG 5\n         XR    #4,#4               ANSWER IN REG 5\n         DR    #4,#7               ANOTHER GCD STEP\n         SRDA  #4,32               REG 4 ==> REG 5, CLEAR 4 FOR NXT DIV\n         BZ    FFX                 ANSWER IN REG 7\nMORE     DR    #6,#5               ANOTHER GCD STEP\n         SRDA  #6,32               REG 6 ==> REG 7, CLEAR 6 FOR NXT DIV\n         BZ    FFY                 ANSWER IN REG 5\n         DR    #4,#7               ANOTHER GCD STEP\n         SRDA  #4,32               REG 4 ==> REG 5, CLEAR 4 FOR NXT DIV\n         BZ    FFX                 ANSWER IN REG 7\n         DR    #6,#5               ANOTHER GCD STEP\n         SRDA  #6,32               REG 6 ==> REG 7, CLEAR 6 FOR NXT DIV\n         BZ    FFY                 ANSWER IN REG 5\n         DR    #4,#7               ANOTHER GCD STEP\n         SRDA  #4,32               REG 4 ==> REG 5, CLEAR 4 FOR NXT DIV\n         BZ    FFX                 ANSWER IN REG 7\n         DR    #6,#5               ANOTHER GCD STEP\n         SRDA  #6,32               REG 6 ==> REG 7, CLEAR 6 FOR NXT DIV\n         BZ    FFY                 ANSWER IN REG 5\n         DR    #4,#7               ANOTHER GCD STEP\n         SRDA  #4,32               REG 4 ==> REG 5, CLEAR 4 FOR NXT DIV\n         BNZ   MORE                MUST DO MORE, BUT LET'S SAVE SPACE\nFFX      LR    #2,#7\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN              AND RETURN WITH IT\n*\nFFY      LR    #2,#5\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN              AND RETURN WITH IT\n*\nFIXFIX0  ICM   #7,15,##CDR(#3)     LOAD ARG1 AND TEST SIGN\n         BM    FIXMFIX0            ARG2 IS NEGATIVE\n         LR    #15,#3              JUST RETURN ARG1\n         B     RETURN\n*\nFIXMFIX0 LCR   #2,#7               TAKE POS VALUE AND PREP FOR MKAT\n         BO    TWO31               ANSWER MUST BE POSITIVE 2**31 BIGNUM\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN\n*\nFFD0     LCR   #4,#4\n         BC    3,FFD0PO            POSITIVE OR OVERFLOW\n         LR    #15,#2              RETURN WITH ARG2\n         B     RETURN\n*\nFFD0PO   BO    TWO31               ANSWER MUST BE POSITIVE 2**31 BIGNUM\n         LR    #2,#4               MAKE POSITIVE VERSION OF ARG1\n         #MKAT FIXED               MAKE A FIXNUM\n         B     RETURN\n*\nTWO31    LA    #15,#TWO31          RETURN POINTER TO INLINE BIGNUM\n******** B     RETURN\n*\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n*\n         DS    0A                  ALIGN BIGNUM TO FULLWORD\n#TWO31   DC    YL1(##BIGNUM),AL3(8),F'0,1'    2**31 SMALLEST BIGNUM\n         SPACE 1\nERROR1   DS    0H                  NOT A FIXNUM\n         #ERR  'Argument 1 to ZILGCD not a fixnum - ',0(#11)\n         SPACE 1\nERROR2   DS    0H                  NOT A FIXNUM\n         #ERR  'Argument 2 to ZILGCD not a fixnum - ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILGETC": {"ttr": 13316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11R\\x01f\\x01H\\x01e\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:52:00", "lines": 358, "newlines": 328, "modlines": 357, "user": "SEB1525"}, "text": "         TITLE 'ZILGETC - INTERNAL ZIL 1.3 ROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS INVOKED BY READ AND READCH.  THE INTERFACE IS       *\n* NON-STANDARD, AS FOLLOWS:                                           *\n*                                                                     *\n*     L    2,=V(ZILGETC)                                              *\n*     BALR 14,2                                                       *\n*                                                                     *\n* ZILGETC RETURNS ONE CHARACTER FROM THE INPUT FILE POINTED TO BY     *\n* REGISTER 7.  IT HANDLES ALL INPUT FILE I/O.  ON ENTRY REGISTER 3    *\n* CONTAINS THE CURRENT CHARACTER POINTER (CONTENTS OF ZLFCHAR),       *\n* AND ON RETURN REGISTER 6 CONTAINS THE ADDRESS OF THE ACTUAL         *\n* CHARACTER RETURNED, UNLESS NEWLINE OR EOF IS ENCOUNTERED.           *\n*                                                                     *\n* ON RETURN REGISTER 3 CONTAINS ONE OF THE FOLLOWING:                 *\n*                                                                     *\n*    LT 0 ... NEWLINE ENCOUNTERED                                     *\n*    EQ 0 ... EOF ENCOUNTERED                                         *\n*    GT 0 ... CURRENT CHARACTER POINTER (REGISTER 6 POINTS TO IT)     *\n*                                                                     *\n* NOTE THAT FOR EFFICIENCY'S SAKE, THIS ROUTINE DOES NOT UPDATE       *\n* ZLFCHAR ITSELF (UNLESS A NEW LINE IS READ).  THE CALLER IS          *\n* RESPONSIBLE FOR MAINTAINING THE CORRESPONDENCE BETWEEN REGISTER 3   *\n* AND ZLFCHAR AT ALL TIMES.                                           *\n*                                                                     *\n* ALSO NOTE THAT THIS ROUTINE DOES NOT SET THE ZLFEOF AND ZLFNEWLN    *\n* BITS.  THESE ARE SET BY THE READ AND READCH ROUTINES.  THE STATUS   *\n* OF THE VALUE TO RETURN TO THE CALLER IS DETERMINED BY THE SIGN OF   *\n* ZLFCHAR, I.E. REGISTER 3.                                           *\n*                                                                     *\n* THIS ROUTINE USES REGS 2 (RETURN), 3, 6.                            *\n* NOTE THAT REG 15 MUST BE PRESERVED ACROSS A CALL TO THIS ROUTINE,   *\n* SINCE THE CALLERS MAY BE HOLDING A RETURN VALUE IN IT.              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*            NOW THAT WE HAVE SUPPORT FOR COMMONALITY OF TERMINAL I/O *\n*            WE CAN IMPLEMENT THIS ENHANCEMENT:  IF THERE IS PENDING  *\n*            TERMINAL OUTPUT (PRIN1), WE DO A TPUT ASIS TO SEND IT    *\n*            OUT WITHOUT A CARRIAGE RETURN.  GIVES NICE PROMPT DATA.  *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n*  11/16/88 - Fix problem of putting out TPUT ASIS prompts even when  *\n*             an input-longer-than-80-characters situation exists.    *\n*                                                                     *\n***********************************************************************\n*\n         GBLB  &ZILXA\n         #ZSYS\n         EJECT\n         #ZEQU ,\n         EJECT\n         #ZCOM ,\n         #ZSFT ,\n         EJECT\n         USING ZILGETC,#2          ESTABLISH BASE REGISTER\n         USING ZLFILBLK,#7         ESTABLISH ADDRESSABILITY TO FILE\n         #ZUSING ,                 ESTABLISH ADDR'Y TO COMMON & SFT\n         EJECT\nZILGETC  CSECT ,\n         SPACE 1\n         LTR   #6,#3               TEST CURRENT CHARACTER POINTER\n         BM    GET                 IF NEWLINE, READ A NEW RECORD\n         BZR   #14                 IF EOF, RETURN WITHOUT READING\n*                                  ELSE CONVERT CHARACTER POINTER\n         A     #6,ZLFCARD          FROM RELATIVE COLUMN TO ABSOLUTE\n         LA    #3,1(,#3)           ADDRESS WHILE BUMPING IT BY 1\n         C     #6,ZLFEND           IF NOT AT END OF RECORD YET\n         BLR   #14                 THEN PROCESS THIS CHAR. ELSE...\nGATEND   DS    0H                  END OF RECORD REACHED...\n         TM    ZLFFLAG2,ZLFTGT12   IF TERMINAL AND LAST TGET INCOMPLETE\n         BO    GET                 THEN DO ANOTHER READ (NO NEWLINES)\n         XR    #3,#3               ELSE SET CHARACTER POINTER TO -1\n         BCTR  #3,0                (NEGATIVE VALUE MEANS NEWLINE)\n         BR    #14                 AND RETURN WITH THAT VALUE.\n         SPACE 2\nGET      DS    0H                  GET AN INPUT RECORD\n         SPACE 1\n         STM   #14,#7,ZLCSAVE2     SAVE VOLATILE REGISTERS\n         TM    ZLFFLAG1,ZLFTERM    IF INPUT IS FROM TERMINAL\n         BZ    NOTTERM             THEN\n*\n* ABOUT TO READ INPUT FROM THE TERMINAL.  IF THERE IS ANY PENDING\n* TERMINAL OUTPUT THEN WE SEND IT TO THE TERMINAL WITHOUT A CARRIAGE\n* RETURN SO THAT THE FOLLOWING READ HAS THE CURSOR POSITIONED ON THE\n* SAME LINE.\n*\n         TM    ZLFFLAG2,ZLFTGT12   If completing an incomplete TGET\n         BO    NOWRITEA            then skip\n         LR    #5,#7               SAVE OUR FILE BLOCK ADDRESS\n         ICM   #7,15,ZLCOFTRM      @ TERMINAL OUTPUT FILE BLOCK\n         BZ    NOWRITE             IF NONE, SKIP\n         TM    ZLFFLAG1,ZLFNEWLN   IF NO DATA WAITING TO BE PRINTED\n         BZ    NOWRITE             THEN SKIP\n         L     #1,ZLFCARD          GET ADDRESS OF OUTPUT BUFFER\n         L     #14,ZLFCHAR         GET CURRENT CHARACTER POSITION\n         BCTR  #14,0               SUBTRACT 1 TO CONVERT TO LENGTH\n         LTR   #0,#14              IF LENGTH ZERO OR LESS\n         BNP   NOWRITE             THEN SKIP\n         BCTR  #14,0               ELSE REDUCE LENGTH FOR EXECUTE\n         L     #15,ZLCTRMTR        GET TERMINAL OUTPUT TRANSLATE TABLE\n         EX    #14,TRANS           TRANSLATE THE OUTPUT LINE\n         #TPUT *,(1),(0),ASIS      TPUT WITHOUT CARRIAGE RETURN\n         LA    #0,1                SET CHARACTER POSITION\n         ST    #0,ZLFCHAR          TO ONE\n         NI    ZLFFLAG1,255-ZLFNEWLN CLEAR NEW LINE INDICATION\n         LA    #15,X'40'           SOURCE LENGTH = 0\n         SLL   #15,24              FILL = BLANK\n         XR    #14,#14             SOURCE = NULL\n         LH    #1,ZLFLRECL         LENGTH = LENGTH OF OUTPUT AREA\n         L     #0,ZLFCARD          TARGET = OUTPUT AREA\n         MVCL  #0,#14              CLEAR OUTPUT AREA TO BLANKS\nNOWRITE  DS    0H\n         LR    #7,#5               RESTORE OUR FILE BLOCK ADDRESS\nNOWRITEA DS    0H\n*\n* OK, GO AHEAD AND READ FROM THE TERMINAL.\n*\n         NI    ZLFFLAG2,255-ZLFTGT12 CLEAR INCOMPLETE-TGET FLAG\nTGETRTRY DS    0H\n*\n* The following XC necessary due to bug in PIE/Sessions PA2 processing\n*\n         XC    ZLFLINE(80),ZLFLINE  CLEAR TGET INPUT BUFFER\n*\n         TGET  ZLFLINE,80           DO A TGET\n         CH    #15,=H'8'            IF TGET RC WAS 8 (ATTENTION)\n         BE    TGETRTRY             THEN RETRY THE TGET\n         STH   #1,ZLFLRECL          STORE COUNT OF TGOTTEN INPUT DATA\n         LTR   #1,#1                IF DATA LENGTH IS NONZERO,\n         BNP   NOTGTRAN             THEN...\n         BCTR  #1,0                  REDUCE LENGTH FOR EXECUTE\n         EX    #1,INTRANS            TRANSLATE TERMINAL INPUT\nNOTGTRAN DS    0H\n         CH    #15,=H'12'           IF TGET RC WAS 12 (DATA PENDING)\n         BNE   NOTRC12              THEN\n         OI    ZLFFLAG2,ZLFTGT12     INDICATE INCOMPLETE TGET\nNOTRC12  DS    0H                   ELSE ASSUME TGET WAS OK\n         ICM   #1,15,ZLCDRIBL       IF THERE'S A DRIBBLE FILE\n         BZ    NODRIBI              THEN...\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #15,PUT24           ADDRESS OF THIS CODE\n         LA    #4,PUT24E           RETURN ADDRESS\n         BSM   #4,#15\nPUT24    DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n         ST    #9,ZLCISV09           SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS      INDICATE NON-ZIL CODE RUNNING\n         PUT   (1)                   DO PUT LOCATE\n         NI    ZLCIFLGS,255-ZLCISYS\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#4\nPUT24E   DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\n         MVC   0(80,#1),ZLFLINE      MOVE DATA TO DRIBBLE OUTPUT BUFFER\nNODRIBI  DS    0H\n         LA    #1,ZLFLINE           SAVE BUFFER ADDRESS\n         LH    #0,ZLFLRECL          CHECK LENGTH OF INPUT FROM TERMINAL\n         LTR   #0,#0                IF INPUT FROM TERMINAL IS NULL\n         BNP   NULLREC              THEN RETURN NEWLINE (NULL INPUT)\n         LA    #3,1                 ELSE SET CHARACTER COLUMN = 1\n         B     GETSET               GO SET REST OF FILE PARAMETERS\nNOTTERM  DS    0H                  ELSE\n         TM    ZLFFLAG1,ZLFSTART    IF FIRST RECORD ALREADY WAS READ\n         BZ    NOTGOT1              THEN SKIP THIS GET\n         NI    ZLFFLAG1,255-ZLFSTART TURN OFF FIRST-RECORD-READ FLAG\n         L     #1,ZLFREC1            GET ADDRESS OF THAT RECORD\n         B     GOT1                 AND SKIP THIS GET.\nNOTGOT1  DS    0H                  ELSE...\n         LA    #1,GETEODAD          ADDRESS OF END-OF-FILE ROUTINE\n         STCM  #1,7,ZLFDCB+33       SET EODAD ROUTINE ADDRESS IN DCB\n         AIF   (NOT &ZILXA).SKIP3\n         LA    #15,GETSET           GET ADDRESS OF EOF CONTINUATION\n         BSM   #15,0                ROUTINE AND ADD THE CURRENT AMODE\n         ST    #15,AGETSET          STORE THIS VALUE\n.SKIP3   ANOP\n         AIF   (NOT &ZILXA).SKIP4\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #15,GET24           ADDRESS OF THIS CODE\n         LA    #4,GET24E           RETURN ADDRESS\n         BSM   #4,#15\nGET24    DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP4   ANOP\n         ST    #9,ZLCISV09          SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS     INDICATE NON-ZIL CODE RUNNING\n         LA    #1,ZLFDCB            DO A GET LOCATE\n         GET   (1)                  GET A RECORD, GET LOCATE MODE\n         NI    ZLCIFLGS,255-ZLCISYS\n         AIF   (NOT &ZILXA).SKIP5\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#4\nGET24E   DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP5   ANOP\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\nGOT1     DS    0H\n         LA    #3,1                 SET CHARACTER COLUMN = 1\n         TM    ZLFFLAG2,ZLFRECV     IF RECFM=V(B)...\n         BZ    SEEIFU               THEN...\n         LH    #0,0(,#1)             PICK UP CURRENT RECORD LENGTH\n         LA    #15,4                 LENGTH OF RDW TO SUBTRACT\n         TM    ZLFFLAG2,ZLFNUM       IF FILE IS LINE NUMBERED\n         BZ    NOTLN                 THEN...\n         LA    #15,8(,#15)            ADD 8 FOR LINE NUMBER FIELD\nNOTLN    SR    #0,#15                COMPUTE LENGTH OF TEXT IN RECORD\n         STH   #0,ZLFLRECL           SET RECORD LENGTH\n         BNP   NULLREC               IF NO TEXT, IGNORE THIS RECORD\n         AR    #1,#15                BUMP POINTER UP TO TEXT\n         B     GETSET                GO TO SET FILE PARAMETERS\nNULLREC  DS    0H                   VARIABLE-LENGTH RECORD TOO SHORT...\n         L     #3,#SFWM1            SET CURRENT CHARACTER POINTER TO -1\n*                                   (NEGATIVE VALUE MEANS NEWLINE)\n         B     GETSET              GO SET REST OF FILE PARAMETERS\n         SPACE 1\nSEEIFU   DS    0H                  RECFM NOT V, MAYBE IT'S U\n         TM    ZLFFLAG2,ZLFRECU    IF RECFM = U\n         BZ    GETSET              THEN...\n         LH    #0,ZLFDCB+82         GET DCB LRECL\n         STH   #0,ZLFLRECL          USE AS CURRENT LRECL\n         B     GETSET\n         SPACE 1\nGETEODAD DS    0H                  END OF FILE ON READ\n*                                  NOTE: THIS GETS CONTROL IN AMODE24!\n         NI    ZLCIFLGS,255-ZLCISYS RESET NON-ZIL-CODE RUNNING FLAG\n         XR    #1,#1               CLEAR RECORD POINTER\n         XR    #3,#3               CLEAR CHARACTER POINTER\n         AIF   (NOT &ZILXA).SKIP6\n         L     #15,AGETSET         GO SET REST OF FILE PARAMETERS\n         BSM   0,#15               (RETURNING TO AMODE OF CALLER)\nAGETSET  DS    A                   POINTER DEFINED LINKAGE FOR GETSET\n.SKIP6   ANOP\n         SPACE 1\nGETSET   DS    0H                  GET EITHER WORKED OR DIDN'T\n         SPACE 1\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\n         SPACE 1\n* AT THIS POINT #1 = CURRENT RECORD ADDRESS\n* AT THIS POINT #3 = CURRENT CHARACTER POINTER (0=EOF, -1=NEWLINE)\n         SPACE 1\n         LR    #6,#1               SET ABSOLUTE CHARACTER ADDRESS\n         ST    #6,ZLFCARD          SET ADDRESS OF RECORD\n         ST    #3,ZLFCHAR          SET ADDRESS OF RECORD\n         LH    #0,ZLFLRECL         GET RECORD LENGTH\n         ALR   #0,#6               ADD RECORD ADDRESS\n         ST    #0,ZLFEND           GIVING ADDRESS OF END OF RECORD\n         SPACE 1\n*\n* CODE ADDED 11/17/86 TO SUPPORT ECHO FILES\n*\n         LTR   #6,#6               IF NO INPUT RECORD (E.G. EOF)\n         BNP   NOECHO              THEN NO ECHO\n         ICM   #0,15,ZLFECHO       GET ECHO FILE BLOCK\n         BZ    NOECHO              IF NONE, NO ECHO\n         LR    #5,#7               SAVE OUR FILE BLOCK ADDRESS\n         LR    #7,#0               GET ECHO FILE BLOCK ADDRESS\n         TM    ZLFFLAG2,ZLFOPEN    IF ECHO FILE IS NOT OPEN\n         BZ    NOECHO2             THEN DON'T ECHO\n         TM    ZLFFLAG1,ZLFTERM    IF OUTPUT IS TO TERMINAL\n         BZ    OKTOECHO             AND\n         TM    ZLFFLAG1-ZLFILBLK(#5),ZLFTERM  INPUT IS FROM TERMINAL\n         BZ    OKTOECHO               THEN\n         TM    ZLFFLAG2,ZLFETIO        IF NOT OK TO ECHO TERM-TO-TERM\n         BZ    NOECHO2                  THEN DON'T ECHO\nOKTOECHO DS    0H\n         LH    #1,ZLFLRECL         GET OUTPUT RECORD LENGTH\n         L     #0,ZLFCHAR          GET CURRENT OUTPUT CHAR POSITION\n         BCTR  #0,0                CONVERT FROM COLUMN TO OFFSET\n         SR    #1,#0               OUTPUT LENGTH REMAINING\n         A     #0,ZLFCARD          ADD RECORD AREA LOCATION\n         TM    ZLFFLAG1,ZLFNEWLN   IF THERE'S ALREADY DATA IN OUTPUT\n         BZ    NOASIS              THEN\n         AH    #0,=H'1'             BUMP OUTPUT DESTINATION UP BY 1\n         BCTR  #1,0                 BUMP OUTPUT LENGTH DOWN BY 1\nNOASIS   DS    0H\n         LR    #14,#6              INPUT ADDRESS\n         LA    #15,X'40'           FILL CHARACTER\n         SLL   #15,24\n         AH    #15,ZLFLRECL-ZLFILBLK(,#5) INPUT LENGTH\nMOVELOOP DS    0H\n         LTR   #1,#1               IF LENGTH TO BE MOVED NOT POSITIVE\n         BNP   SKIPMVCL            THEN SKIP MOVE. ELSE\n         MVCL  #0,#14              MOVE DATA FROM INPUT TO OUTPUT\n         S     #0,ZLFCARD          ADDRESS OF END OF MOVED DATA MINUS\n         AH    #0,=H'1'             START PLUS 1\n         ST    #0,ZLFCHAR            GIVES NEW CHARACTER POSITION\nSKIPMVCL DS    0H\n         CLM   #15,B'0111',=X'000000' IF ALL TO BE MOVED WAS MOVED\n         BE    MOVEDONE            THEN FINISHED. ELSE...\n         STM   #14,#15,SAVEMVCL    SAVE OTHER PARAMETERS\n         L     #15,ZLCTERP         GET ADDRESS OF ZILTERP\n         #BASR #14,#15             CALL ZILTERP TO PRINT THE NEW LINE\n         L     #2,ZLCSAVE2+16      RELOAD BASE REGISTER\n         LM    #14,#15,SAVEMVCL    GET MVCL REGISTERS\n         L     #0,ZLFCARD          GET NEXT NEW OUTPUT ADDRESS\n         LH    #1,ZLFLRECL         GET NEXT NEW OUTPUT LENGTH\n         B     MOVELOOP            GO MOVE SOME MORE DATA\nMOVEDONE DS    0H                  WHEN FINISHED MOVING DATA...\n         L     #15,ZLCTERP         GET ADDRESS OF ZILTERP\n         #BASR #14,#15             CALL ZILTERP TO PRINT THE NEW LINE\n         L     #2,ZLCSAVE2+16      RELOAD BASE REGISTER\nNOECHO2  DS    0H\n         LR    #7,#5               RESTORE OUR FILE BLOCK ADDRESS\n         L     #6,ZLFCARD          GET ADDRESS OF RECORD\n         L     #3,ZLFCHAR          GET ADDRESS OF RECORD\nNOECHO   DS    0H\n*\n* END ECHO CODE\n*\n         SPACE 1\n         LM    #14,#2,ZLCSAVE2     RESTORE VOLATILE REGISTERS\n         LM    #4,#5,ZLCSAVE2+24   EXCEPT #3 AND #6\n         L     #7,ZLCSAVE2+36      WHICH MUST BE RETURNED TO CALLER\n         SPACE 1\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nTRANS    TR    0(*-*,#1),0(#15)    TRANSLATE OUTPUT LINE\nINTRANS  TR    ZLFLINE(*-*),INTRANTB  TRANSLATE INPUT LINE\n         SPACE 1\n*\n* TERMINAL INPUT TRANSLATE TABLE.  THE ONLY PURPOSE OF THIS TABLE IS\n* REALLY TO INSURE THAT VARIOUS KINDS OF INPUT GET INTERPRETED AS\n* SQUARE BRACKETS.\n*\nINTRANTB DC    256YL1(*-INTRANTB)\n         ORG   INTRANTB+X'41'\n         DC    X'AD'               LEFT BRACKET\n         ORG   INTRANTB+X'42'\n         DC    X'BD'               RIGHT BRACKET\n         ORG   INTRANTB+X'BA'\n         DC    X'AD'               LEFT BRACKET\n         ORG   INTRANTB+X'BB'\n         DC    X'BD'               RIGHT BRACKET\n         ORG   ,\n         SPACE 1\nSAVEMVCL DS    4A                  MVCL REGISTER SAVE AREA\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILHASH": {"ttr": 13322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11R\\x00d\\x00a\\x00c\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:52:00", "lines": 100, "newlines": 97, "modlines": 99, "user": "SEB1525"}, "text": "         TITLE 'ZILHASH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS IS THE PRIMITIVE ATOM-HASHER USED BY SXHASH.                   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note: This calls the hashing algorithm used by ZILINTN to           *\n*       hash symbol names and strings.  The hash code returned by     *\n*       this interface is a raw hash code, unadjusted for the size    *\n*       of any hash table.                                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILHASH  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILHASH'\n         #ZPDS 16\n         #ZSAV ARGS=1\n         SPACE 1\n*\n* CHECK TYPE OF ARG 1\n*\n         L     #6,0(,#1)           LOAD ARG\n         CLI   ##TYPE(#6),##SYMBOL\n         BE    ARG1SYM\n         CLI   ##TYPE(#6),##STRING\n         BE    ARG1STR\n         CLI   ##TYPE(#6),##FIXNUM\n         BE    ARG1FIX\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    ARG1SFL\n         CLI   ##TYPE(#6),##BIGNUM\n         BE    ARG1BIG\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    ARG1DFL\n         CLI   ##TYPE(#6),##SUBR\n         BE    ARG1SUB\n         CLI   ##TYPE(#6),##CLOSUR\n         BE    ARG1CLO\n         B     ERROR               ALL OTHER TYPES ARE INVALID.\n         SPACE 1\nARG1SYM  DS    0H                  ARG 1 IS SYMBOL\n         SPACE 1\n         L     #6,##PNAME(,#6)     GET POINTER TO PRINT NAME\n******** B     ARG1STR             DO LIKE STRING\n         SPACE 1\nARG1STR  DS    0H                  ARG 1 IS STRING\n         SPACE 1\n         XR    #5,#5               Clear length register\n         LA    #4,##VECDAT(,#6)    Set address of string text\n         ICM   #5,7,1(#6)          Set length of string text\n         L     #7,#SFWM1           Set #7 to a negative value to\n*                                   tell ZILINTN to return hash code\n         L     #15,ZLCINTN         Get address of ZILINTN\n         #BASR #14,#15             Call ZILINTN to get hash code\n         LR    #2,#15              Get hash code into register\n         B     RETURN\n         SPACE 1\nARG1FIX  DS    0H                  ARG 1 IS FIXNUM\n         SPACE 1\n         L     #2,##CDR(,#6)       GET FIXNUM OR FLONUM VALUE\n         B     RETURN\n         SPACE 1\nARG1SFL  EQU   ARG1FIX             ARG 1 IS SINGLE FLOAT\n         SPACE 1\nARG1DFL  DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE 1\n         L     #2,8(,#6)           (XOR WORD1 WORD2)\n         X     #2,12(,#6)\n         B     RETURN\n         SPACE 1\nARG1BIG  EQU   ARG1STR             ARG 1 IS BIGNUM\n         SPACE 1\n*                                  DO LIKE STRING\n         SPACE 1\nARG1CLO  EQU   ARG1SUB             ARG 1 IS CLOSURE\n         SPACE 1\nARG1SUB  DS    0H                  ARG 1 IS SUBR\n         SPACE 1\n         L     #2,CODEHASH         WHAT ELSE CAN I DO?\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H                  HAS NUMBER IS IN #2\n         SPACE 1\n         N     #2,=X'7FFFFFFF'     FORCE NON-NEGATIVE\n         #MKAT FIXED               MAKE A FIXNUM OUT OF IT\n         #ZRET ,\n         EJECT\n         DS    0F\nCODEHASH DC    XL4'7FFFFFFF'       SOMETHING UNLIKELY FOR COMPILED CODE\n         SPACE 1\nERROR    DS    0H\n         #ERR  'Invalid type of object passed to ZILHASH - ',(#6)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILIMPL": {"ttr": 13569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11R\\x00x\\x00u\\x00w\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:52:00", "lines": 120, "newlines": 117, "modlines": 119, "user": "SEB1525"}, "text": "         TITLE 'ZILIMPL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* ZILIMPL TAKES 3 ARGUMENTS, OF WHICH THE LAST 2 ARE OPTIONAL.        *\n* THE FIRST IS A LIST OF ATOMS TO BE IMPLODED INTO A SINGLE ATOM.     *\n*  SPECIFICATION OF AN ATOM OR OF A LIST CONTAINING NESTED LISTS IS   *\n*  ERRONEOUS AND WILL BE FLAGGED AS AN ERROR BY ZILADMP OR ZILABLD.   *\n* THE SECOND SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO INTERN THE   *\n*  GENERATED ATOM ON THE OBLIST (NOTE THAT DEFAULT IS NOT TO).        *\n* THE THIRD SPECIFIES WHETHER (NON-NIL) OR NOT (NIL) TO FORMAT THE    *\n*  ATOM AS NUMERIC WHERE POSSIBLE (DEFAULT IS TO ASSUME ALPHA).       *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO EXTRA STACK SPACE.        *\n***********************************************************************\n*                                                                     *\n* ZILADMP IS CALLED TO DUMP EACH ATOM IN THE LIST INTO OUR WORK AREA. *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILIMPL  #ZBEG MINARGS=1,MAXARGS=3,NAME='ZILIMPL'\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          GET FIRST ARGUMENT\n         XR    #5,#5               INIT LENGTH SO FAR TO ZERO\n         CR    #6,#10              IF END OF LIST OR NULL LIST\n         BE    NOMORE              THEN END LOOP\nLOOP     DS    0H\n         ICM   #2,15,##CAR(#6)     GET EACH CAR OF ARG 1 TO ZILIMPL\n         BM    ERROR1              IF ARG 1 WAS AN ATOM, ERROR\n         TM    ##TYPE(#2),##ATOM   IF IT'S NOT AN ATOM\n         BZ    ERROR2              THEN ERROR\n         TM    ##TYPE(#2),##VEC    IF IT'S A VECTOR\n         BO    ERROR2              THEN ERROR\n         L     #15,ZLCADMP         GET ADDRESS OF ZILADMP\n         LR    #1,#10              SET #1 FOR ZILADMP\n         #BASR #14,#15             CALL ZILADMP TO DUMP ATOM\n         LR    #7,#1               SAVE ADDRESS OF DUMPED ATOM\n         LTR   #4,#0               GET LENGTH OF DUMPED ATOM\n         BNP   AFTMOVE             IF ZERO LENGTH, SKIP THIS ONE\n         AR    #0,#5               GET DUMPED-ATOM LENGTH PLUS TOTAL\n         C     #0,ZLCWALEN         IF EXCEEDS CURRENT WORKAREA LENGTH\n         BNH   LENOK               THEN...\n*\n* (1) GETMAIN A NEW WORKAREA WHOSE SIZE IS >= #0.\n* (2) COPY CONTENTS OF OLD WORKAREA TO THE NEW WORKAREA, LENGTH = #5.\n* (3) FREEMAIN THE OLD WORKAREA.\n*\n* #0 = TOTAL LENGTH NEEDED SO FAR, INCLUDING DUMPED-BUT-NOT-ADDED-YET\n* #1 = NOT IN USE\n* #2 = NOT IN USE, WILL CONTAIN NEW WORK AREA LENGTH\n* #3 = NOT IN USE, WILL CONTAIN NEW WORK AREA ADDRESS\n* #4 = LENGTH OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON\n* #5 = TOTAL LENGTH DUMPED SO FAR, NOT INCLUDING THIS STUFF\n* #6 = ADDRESS OF THE SUBLIST CURRENTLY BEING PROCESSED\n* #7 = ADDRESS OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON\n*\n         LR    #2,#0                SAVE LENGTH TO BE NEEDED\n         LA    #2,7(,#2)            GET A LARGER WORK AREA\n         N     #2,=X'FFFFFFF8'      ROUNDED UP TO MULTIPLE OF 8\n         LR    #0,#2                SAVE THE NEW WORK AREA LENGTH\n         #GETMAIN RC,LV=(0),LOC=BELOW GET A NEW WORK AREA\n         LTR   #15,#15              IF GETMAIN FAILED\n         BNZ   ERROR3               THEN ERROR - NOT ENOUGH STORAGE\n         LR    #3,#1                SAVE NEW WORKAREA ADDRESS\n         ICM   #14,15,ZLCWA         #14 = ADDRESS OF OLD AREA\n         BZ    NOFREE               IF NONE, THEN SKIP MOVE & FREE\n         LR    #0,#3                #0 = ADDRESS OF NEW AREA\n         LR    #1,#5                #1 = LENGTH OF DUMPED TEXT\n         LR    #15,#1               #15 = LENGTH OF DUMPED TEXT\n         MVCL  #0,#14               COPY DATA FROM OLD AREA TO NEW AREA\n         L     #1,ZLCWA             GET CURRENT WORK AREA ADDRESS\n         L     #0,ZLCWALEN          GET CURRENT WORK AREA LENGTH\n         FREEMAIN R,LV=(0),A=(1)    FREE THE OLD WORK AREA\nNOFREE   DS    0H\n         ST    #3,ZLCWA             SET NEW ZIL WORKAREA ADDRESS\n         ST    #2,ZLCWALEN          SET NEW ZIL WORKAREA LENGTH\n         SPACE 1\nLENOK    DS    0H                  OTHERWISE - STILL ROOM\n         L     #0,ZLCWA            WORKAREA ADDRESS + WORK AREA LENGTH\n         AR    #0,#5               POINTS TO WHERE TO MOVE DUMPED ATOM\n         LR    #1,#4               SOURCE LENGTH = DUMPED ATOM LENGTH\n         LR    #15,#4              TARGET LENGTH = DUMPED ATOM LENGTH\n         LR    #14,#7              SOURCE ADDRESS = WHERE DUMPED ATOM\n         MVCL  #0,#14              MOVE DUMPED ATOM TO WORK AREA\n         AR    #5,#4               INCREMENT TOTAL LENGTH SO FAR\nAFTMOVE  DS    0H\n         L     #6,##CDR(,#6)       GET REST OF LIST\n         CR    #6,#10              WHILE LIST IS NOT NIL,\n         BNE   LOOP                CONTINUE.\nNOMORE   DS    0H                  LIST HAS BEEN PROCESSED\n         L     #1,ZLCWA            POINT TO GIANT ATOM DATA\n         LR    #0,#5               SET LENGTH OF GIANT ATOM\n         LM    #2,#3,4(#11)        SET INTERN FLAG = ARG 2 TO ZILIMPL\n         LA    #4,24(,#11)         SET CURRENT STACK POINTER FOR CONS\n*                                  SET FORMAT FLAG = ARG 3 TO ZILIMPL\n         L     #15,ZLCABLD         CALL ZILABLD TO MAKE AN ATOM FROM IT\n         #BASR #14,#15             (RETURNS ATOM IN #15)\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nSAVE56   DS    2A                  SAVE AREA\n         SPACE 1\nERROR1   #ERR  'Argument 1 to ZILIMPL not a proper list - ',0(#11)\nERROR2   #ERR  'Argument 1 to ZILIMPL contains nested list or vector-tyX\n               pe structure - ',(#2),X'0D',                            X\n               'Cannot implode list - ',0(#11)\nERROR3   DS    0H                  ERROR - NOT ENOUGH STORAGE\n         XR    #0,#0               CLEAR WORK AREA ADDRESS AND LENGTH\n         ST    #0,ZLCWA\n         ST    #0,ZLCWALEN\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2007 ZILIMPL: Not enough memory to build symbol nameX\n                from list - ',0(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILINIT": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x01\\x00\\x88\\x01_\\x01\\x00&_\\x17\\x16\\x05\\xc2\\x05\\x87\\x05\\xc1\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:16:01", "lines": 1474, "newlines": 1415, "modlines": 1473, "user": "SEB1525"}, "text": "         TITLE 'ZILINIT - ZIL 1.3 INITIALIZATION MODULE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS INVOKED VIA LINK FROM THE MAINLINE MODULE ZILMAIN    *\n* WHENEVER A COMPILED ZIL MODULE IS STARTED.  IT ALLOCATES STORAGE    *\n* FOR ALL REQUIRED USAGES, PROCESSES OPTION SPECIFICATIONS IF ANY,    *\n* AND HANDLES THE OPENING OF ANY RELEVANT FILES.  NOTE THAT ZILTERM   *\n* UNDOES ALL THESE THINGS.                                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MODIFIED 09/84 SO THAT IT DOES NOT OPEN ALL FILES.  IT STILL LOOKS  *\n* FOR ALL FILE NAMES OF THE ZIL FORMAT, SO THAT IT KNOWS HOW MUCH     *\n* SYSTEM MEMORY TO RESERVE, BUT IT DOES NOT ACTUALLY OPEN THEM.       *\n* THE ZILFGETI/ZILFGETO ROUTINE DOES THE ACTUAL OPEN WHEN ACCESS TO   *\n* THE FILE IS REQUESTED (VIA READ, PRINT, ETC.).                      *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* MODIFIED 11/86.  CONS SPACE SIZE MINIMUM IS NOW IN FIELD MINCSS,    *\n* WHICH IS CURRENTLY SET TO 12K TO ALLOW FOR OPTIMAL CODING OF THE    *\n* VECTORIZED GARBAGE COLLECTOR.  ALSO, THE CONS SPACE SIZE IS ROUNDED *\n* UP TO THE NEXT 4K BOUNDARY, NOT THE NEXT DOUBLEWORD AS BEFORE;      *\n* HOWEVER, CODE TO INSURE THAT WE REALLY END UP WITH A MULTIPLE OF    *\n* 4K FOR CONS SPACE HAS NOT BEEN ADDED YET.                           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* 06/01/88 - Added ZILVALS.  See #ZCOM and #ZSUB.                     *\n* 11/23/88 - New file block support for UNTYI-stuff.  See #ZCOM.      *\n* 05/22/89 - Package cell defaults to NIL for uninterned symbols.     *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA,&ZILVF,&ZILTSO\n         #ZSYS\n         EJECT\n         #ZEQU ,                   DEFINE ALL EQUATES HERE\n         EJECT\nZILINIT  CSECT\n         AIF   (NOT &ZILXA).NOMODES\nZILINIT  RMODE 24\nZILINIT  AMODE 31\n.NOMODES ANOP\n         B     ZLAROUND-*(,#15)\n         DC    YL1(ZLAR-*-1),C'ZILINIT &SYSDATE &SYSTIME'\nZLAR     EQU   *                   END OF IDENTIFIER\nZLAROUND DS    0H                  START OF CODE\n         USING ZILINIT,#12\n         USING ZLHEADER,#11\n         USING ZLHOPTS,#2\n         USING ZLFILBLK,#7\n         STM   #14,#12,12(#13)     SAVE REGISTERS\n         LR    #12,#15             SET UP BASE REGISTER\n         LA    #11,4(,#1)          INPUT PARM +4 --> HEADER OF POINTERS\n         L     #2,ZLHOPTA          POINT TO OPTIONS LIST\n         ST    #11,HDRPTR          SAVE ADDRESS OF PROGRAM HEADER\n         ST    #2,OPTPTR           SAVE ADDRESS OF OPTIONS\n         ST    #1,MODPTR           SAVE ADDRESS OF MAIN MODULE\n         EJECT\n*\n* SET UP A TEMPORARY SAVE AREA FOR SYSTEM FUNCTIONS\n*\n         LA    #1,TEMPSAVE\n         ST    #1,8(,#13)\n         ST    #13,4(,#1)\n         LR    #13,#1\n         EJECT\n***********************************************************************\n*                                                                     *\n* MAP OF 24-BIT STORAGE IS AS FOLLOWS:                                *\n*                                                                     *\n*        ....................................................         *\n*        .                                                  .         *\n*        . AREA RETURNED TO OPERATING SYSTEM                .         *\n*        .                                                  .         *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | THE PRINT NAME OF THE ATOM \"NIL\" (8 BYTES)       |         *\n*        |                                                  |         *\n*        |--------------------------------------------------|         *\n*        |                                                  |         *\n*        | THE PRINT NAME OF THE ATOM \"T\" (8 BYTES)         |         *\n*        |                                                  |         *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | COMMON AREA (ADDRESSED BY REG 13, INCLUDES SA)   |         *\n*        |                                                  |         *\n* #13 -->|--------------------------------------------------|         *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* MAP OF 31-BIT STORAGE IS AS FOLLOWS:                                *\n*                                                                     *\n*                                                                     *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | OBLIST HASH ARRAY                                |         *\n*        |                                                  |         *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | PRINT STACK                                      |         *\n*        |                                                  |         *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | THE SYMBOL \"NIL\" (24 BYTES RESERVED FOR IT)      |         *\n*        |                                                  |         *\n* #10 -->|==================================================|         *\n*        |                                                  |         *\n*        | CONS SPACE (REG 9 FLOATS AROUND IN HERE)         |         *\n*        |                                                  |         *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | STRING AND VECTOR SPACE SECOND AREA (FOR GC)     |         *\n*        |__________________________________________________|         *\n*        |                                                  |         *\n*        | STRING AND VECTOR SPACE (ADDRESSED BY ZLCVSADR)  |         *\n*        |                                                  |         *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | SMALL FIXNUM TABLE (256*8=2048 BYTES)            |         *\n*        |                                                  |         *\n*        |==================================================|         *\n*        |                                                  |         *\n*        | THE SYMBOL \"T\" (24 BYTES RESERVED FOR IT)        |         *\n*        |                                                  |         *\n*  #8 -->|==================================================|         *\n*        |                                                  |         *\n*        | PUSH DOWN STACK (REG 11 FLOATS AROUND IN HERE)   |         *\n*        |                                                  |         *\n*        |--------------------------------------------------|         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* NOTE:  ALL STORAGE IS ACQUIRED ONLY AFTER SPACE NEEDS HAVE BEEN     *\n* DETERMINED FOR ALL FILES.  IN THIS WAY THE STORAGE REQUIREMENTS     *\n* FOR I/O ARE INDEPENDENT OF THE MAIN PROGRAM'S SPECIFICATIONS.       *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n* LOCATE ALL USER SPECIFIED FILE ALLOCATIONS AND RESERVE 32K FOR\n* EACH OF THEM.  THEY WILL NOT BE OPENED AT THIS TIME:  THE FILE ACCESS\n* ROUTINES WILL OPEN THEM WHEN THEY ARE REFERENCED.  IN THIS WAY WE\n* AVOID CLOBBERING UNUSED OUTPUT FILES, AND ALSO PROVIDE A KLUDGEY\n* MECHANISM FOR RESERVING CHUNKS OF 32K SYSTEM STORAGE.\n*\n* *** Eliminate this code as soon as we can get major spaces like VSS\n*     above the line and we overhaul the ancient file system! ***\n*\n* SEARCH THE TASK INPUT/OUTPUT TABLE (TIOT) FOR FILE ALLOCATIONS OF\n* THE DDNAME ZILI____ (FOR INPUT FILES) AND ZILO____ (FOR OUTPUT FILES)\n*\n         XR    #6,#6               INITIALIZE I/O MEMORY SIZE REQUIRED\n         XR    #4,#4               CLEAR INSERT REGISTER\n         L     #3,540              TCB ADDRESS\n         L     #3,12(,#3)          TIOT ADDRESS\n         LA    #3,24(,#3)          POINT TO FIRST TIOT ENTRY\nTIOTLOOP DS    0H\n         TM    1(#3),X'80'         IF THIS ENTRY IS NOT IN USE\n         BO    TIOTNEXT            THEN SKIP IT\n         CLC   4(4,#3),=C'ZILI'    IF THIS IS A ZIL INPUT FILE\n         BE    TIOTFILE            THEN PROCESS IT\n         CLC   4(4,#3),=C'ZILO'    IF THIS IS A ZIL OUTPUT FILE\n         BE    TIOTFILE            THEN PROCESS IT\n         CLC   4(8,#3),DRIBLDD     IF THIS IS THE ZIL DRIBBLE FILE\n         BE    DRIBLFIL            THEN PROCESS IT\nTIOTNEXT IC    #4,0(,#3)           ELSE GET LENGTH OF THIS ENTRY\n         ALR   #3,#4               BUMP TO NEXT ENTRY\n         CLI   0(#3),0             IF END OF TIOT\n         BE    TIOTEND             THEN WE'RE THROUGH (NO MORE FILES)\n         B     TIOTLOOP            ELSE CONTINUE LOOPING THRU TIOT\nTIOTFILE DS    0H                  WE FOUND A FILE TO PROCESS\n         CLI   8(#3),C' '          IF NOT DDNAMES \"ZILI\" AND \"ZILO\"\n         BNE   ADD32K              (STANDARD FILES), RESERVE STORAGE\n         CLI   7(#3),C'I'          IF THIS IS DDNAME ZILI\n         BNE   NOTZILI             THEN\n         ST    #3,TIOTZILI          SAVE TIOT ENTRY POINTER FOR ZILI\n         B     TIOTNEXT\nNOTZILI  DS    0H\n         CLI   7(#3),C'O'          IF THIS IS DDNAME ZILO\n         BNE   TIOTNEXT            THEN\n         ST    #3,TIOTZILO          SAVE TIOT ENTRY POINTER FOR ZILO\n         B     TIOTNEXT\n         SPACE 1\nDRIBLFIL DS    0H                  IF THIS IS THE DRIBBLE DDNAME\n         ST    #3,TIOTDRIB         INDICATE DRIBBLE FILE PRESENT\n******** B     ADD32K              AND RESERVE STORAGE TO PROCESS IT\n         SPACE 1\nADD32K   DS    0H                  OTHERWISE NOT A STANDARD FILE...\n         A     #6,=F'32768'        ADD APPROXIMATE MEMORY REQUIRED\n         B     TIOTNEXT            GO GET THE NEXT DD ENTRY\n         SPACE 2\nTIOTEND  DS    0H                  ALL DDNAMES PROCESSED\n         EJECT\n*\n* INITIALIZE FILE BLOCKS FOR ZILIN AND ZILOUT\n*\n         SPACE 1\n*\n* OPEN THE STANDARD OUTPUT FILE\n*\n         LA    #0,ZLFBLEN          GET LENGTH OF AN INPUT FILE BLOCK\n         #GETMAIN RU,LV=(0),LOC=BELOW\n         LR    #7,#1\n         ST    #7,OFPTR            STORE PTR TO FIRST OUTPUT FILE BLOCK\n         XC    ZLFILBLK(ZLFBLEN),ZLFILBLK\n         OI    ZLFFLAG,ZLFSYSPR\n         MVC   ZLFPDDN(8),OUTDD\n         LA    #1,1\n         ST    #1,ZLFCHAR          CHARACTER POSITION = 1\n         MVC   ZLFDCB(96),OUTDDDCB SET UP DCB\n         ICM   #15,15,TIOTZILO     GET ADDRESS OF TIOT ENTRY FOR ZILO\n         BZ    TERMZILO            IF NONE, USE TERMINAL OUTPUT\n         TM    3(#15),X'20'        IF TIOT ENTRY SAYS IT'S A TERMINAL\n         BO    TERMZILO            IF NONE, USE TERMINAL OUTPUT\n         LA    #1,ZLFDCB\n         ST    #1,OPENL\n         MVI   OPENL,X'8F'         OPEN FOR OUTPUT\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,OPENO24          ADDRESS OF THIS CODE\n         LA    #2,OPENO24E         RETURN ADDRESS\n         BSM   #2,#1\nOPENO24  DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n         LA    #1,OPENL\n         OPEN  MF=(E,(1))\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nOPENO24E DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         TM    ZLFDCB+X'30',X'10'\n         BZ    OUTNOPEN\n*                                  CHECK RECFM OF OPEN OUTPUT FILE\n         TM    ZLFDCB+36,X'40'     IF RECFM = V....\n         BZ    FNOUTOK             THEN...\n         TM    ZLFDCB+36,X'80'\n         BO    FNOUTOK\n         OI    ZLFFLAG2,ZLFRECV     INDICATE SO IN FILE BLOCK\nFNOUTOK  DS    0H\n         AIF   (NOT &ZILXA).SKIP3\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,PUTO24           ADDRESS OF THIS CODE\n         LA    #2,PUTO24E          RETURN ADDRESS\n         BSM   #2,#1\nPUTO24   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP3   ANOP\n         LA    #1,ZLFDCB\n         PUT   (1)                 DO THE INITIAL PUT LOCATE\n         AIF   (NOT &ZILXA).SKIP4\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nPUTO24E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP4   ANOP\n         LH    #0,ZLFDCB+82        GET DCB LRECL\n         TM    ZLFFLAG2,ZLFRECV    IF RECFM=V FILE\n         BZ    NOTRECVO            THEN...\n         TM    ZLFDCB+36,X'04'      IF RECFM = V.A\n         BZ    NOTRECVA             THEN...\n         STH   #0,0(,#1)            INITIALIZE RDW\n         XC    2(2,#1),2(#1)\n         MVI   4(#1),C'1'           INITIALIZE PRINT CONTROL CHAR\n         LA    #1,5(,#1)            BUMP PAST RDW TO TEXT\n         SH    #0,=H'5'             SET LENGTH OF ACTUAL TEXT\n         B     NOTRECFA\nNOTRECVA DS    0H                  RECFM = V(B), NOT A\n         STH   #0,0(,#1)            INITIALIZE RDW\n         XC    2(2,#1),2(#1)\n         LA    #1,4(,#1)            BUMP PAST RDW TO TEXT\n         SH    #0,=H'4'             SET LENGTH OF ACTUAL TEXT\n         B     NOTRECFA\nNOTRECVO DS    0H\n         TM    ZLFDCB+36,X'04'     IF RECFM = F.A\n         BZ    NOTRECFA            THEN...\n         MVI   0(#1),C'1'           INITIALIZE PRINT CONTROL CHAR\n         LA    #1,1(,#1)            BUMP POINTER PAST CONTROL CHAR\n         BCTR  #0,0                 SUBTRACT 1 FOR PRINT CONTROL CHAR\nNOTRECFA DS    0H\n         ST    #1,ZLFCARD          STORE CURRENT RECORD ADDRESS\n         STH   #0,ZLFLRECL         STORE RECORD LENGTH\n         B     CLEAROUT\nTERMZILO DS    0H                  (STANDARD OUTPUT FROM THE TERMINAL)\n         L     #15,X'224'          ASCB ADDRESS\n         ICM   #15,15,X'3C'(#15)   TSB ADDRESS\n         BZ    OUTNOPEN            IF NO TSB, NOT UNDER TSO, NEED FILE\n         OI    ZLFFLAG,ZLFTERM     INDICATE SO IN FILE BLOCK\n         OI    ZLFFLAG2,ZLFTABS    SET TABS MODE ON FOR FILE\n         LA    #1,ZLFLINE          (NO PRINT CONTROL CHARACTER)\n         ST    #1,ZLFCARD          RESET ADDRESS OF RECORD\n         LA    #0,78               RESET RECORD LENGTH TO 78\n         STH   #0,ZLFLRECL         RESET LINE LENGTH\nCLEAROUT DS    0H\n         ALR   #1,#0               ZLFCARD + ZLFLRECL ...\n         ST    #1,ZLFEND           RESET END-OF-RECORD POINTER\n         LA    #15,X'40'           SOURCE LENGTH = 0\n         SLL   #15,24              FILL = BLANK\n         XR    #14,#14             SOURCE = NULL\n         L     #0,ZLFCARD          TARGET = OUTPUT AREA\n         LH    #1,ZLFLRECL         LENGTH = LENGTH OF OUTPUT AREA\n         MVCL  #0,#14              CLEAR OUTPUT AREA TO BLANKS\nSTDOUNT  DS    0H\n         OI    ZLFFLAG2,ZLFOPEN    MARK FILE OPEN\n         EJECT\n*\n* OPEN THE STANDARD INPUT FILE\n*\n         LA    #0,ZLFBLEN          GET LENGTH OF AN INPUT FILE BLOCK\n         #GETMAIN RU,LV=(0),LOC=BELOW\n         LR    #7,#1\n         ST    #7,IFPTR            STORE PTR TO FIRST INPUT FILE BLOCK\n         XC    ZLFILBLK(ZLFBLEN),ZLFILBLK\n         OI    ZLFFLAG,ZLFINPUT+ZLFSYSIN\n         MVC   ZLFPDDN(8),INDD\n         XR    #1,#1               TO ENABLE ZILGETC TO READ THE\n         BCTR  #1,0                FIRST RECORD WHEN CALLED FIRST,\n         ST    #1,ZLFCHAR          SET CHARACTER POSITION = -1\n         MVC   ZLFDCB(96),INDDDCB  SET UP DCB\n         ICM   #15,15,TIOTZILI     GET ADDRESS OF TIOT ENTRY FOR ZILI\n         BZ    TERMZILI            IF NONE, USE TERMINAL INPUT\n         TM    3(#15),X'20'        IF TIOT ENTRY SAYS IT'S A TERMINAL\n         BO    TERMZILI            IF NONE, USE TERMINAL INPUT\n         LA    #1,ZLFDCB\n         ST    #1,OPENL\n         MVI   OPENL,X'80'         OPEN FOR INPUT\n         AIF   (NOT &ZILXA).SKIP5\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,OPENI24          ADDRESS OF THIS CODE\n         LA    #2,OPENI24E         RETURN ADDRESS\n         BSM   #2,#1\nOPENI24  DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP5   ANOP\n         LA    #1,OPENL\n         OPEN  MF=(E,(1))\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         AIF   (NOT &ZILXA).SKIP6\n         BSM   0,#2\nOPENI24E DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP6   ANOP\n         TM    ZLFDCB+X'30',X'10'\n         BNO   INNOPEN\n         LH    #0,ZLFDCB+82        SET LINE LENGTH TO DCB LRECL - 8\n         SH    #0,=H'8'            SUBTRACT 8 FOR LINE NUMBER FIELD\n*                                  (ZLFCARD/ZLFEND NOT SET UNTIL READ)\n         B     STDINNT\nTERMZILI DS    0H                  (STANDARD INPUT IS TO THE TERMINAL)\n         L     #15,X'224'          ASCB ADDRESS\n         ICM   #15,15,X'3C'(#15)   TSB ADDRESS\n         BZ    INNOPEN             IF NO TSB, NOT UNDER TSO, NEED FILE\n         OI    ZLFFLAG,ZLFTERM     INDICATE SO IN FILE BLOCK\n         LA    #0,80               SET LINE LENGTH TO 80\n         LA    #1,ZLFLINE          FOR TERMINAL, RECORD AREA EXISTS\n         ST    #1,ZLFCARD          SO POINT TO RECORD AREA\n         ALR   #1,#0               ADD LINE LENGTH\n         ST    #1,ZLFEND           SET END-OF-RECORD POINTER\nSTDINNT  DS    0H\n         STH   #0,ZLFLRECL         SET RECORD LENGTH FOR FILE\n         OI    ZLFFLAG2,ZLFOPEN    MARK FILE OPEN\n         EJECT\n*\n* OPEN THE DRIBBLE FILE IF PRESENT\n*\n         ICM   #1,15,TIOTDRIB      IF THERE IS A DRIBBLE FILE,\n         BZ    NODRIB              THEN...\n         LA    #0,96               GET LENGTH OF A DCB\n         #GETMAIN RU,LV=(0),LOC=BELOW\n         ST    #1,TIOTDRIB         SAVE DCB ADDRESS\n         MVC   0(96,#1),DRIBLDCB   SET UP DCB\n         ST    #1,OPENL\n         MVI   OPENL,X'8F'         OPEN FOR OUTPUT\n         AIF   (NOT &ZILXA).SKIP7\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,DRIB24           ADDRESS OF THIS CODE\n         LA    #2,DRIB24E          RETURN ADDRESS\n         BSM   #2,#1\nDRIB24   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP7   ANOP\n         LA    #1,OPENL\n         OPEN  MF=(E,(1))\n         AIF   (NOT &ZILXA).SKIP8\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nDRIB24E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP8   ANOP\n         SPACE 1\nNODRIB   DS    0H\n         SPACE 1\n         L     #13,4(,#13)         RELEASE TEMPORARY SAVEAREA\n         EJECT\n***********************************************************************\n*                                                                     *\n* COMPUTE THE AMOUNT OF STORAGE NEEDED FOR THE FOLLOWING AREAS:       *\n*    PUSH-DOWN STACK                                                  *\n*    CONS SPACE                                                       *\n*    VECTOR/STRING SPACE                                              *\n*    OTHER MISCELLANEOUS SPACES (FIXED IN SIZE)                       *\n* LEAVE SOME OVER FOR THE OPERATING SYSTEM (AT LEAST 32K)             *\n*                                                                     *\n* FIRST, AS MUCH STORAGE AS WILL BE NEEDED IS ALLOCATED BELOW 16MB.   *\n* THIS STORAGE IS DIVIDED UP AS FOLLOWS:                              *\n*    (1) COMMON AREA - LENGTH IS THE CONSTANT VALUE \"ZLCCOMLN\"        *\n*    (2) THE PRINT NAME OF THE ATOM \"T\" - LENGTH IS 8 BYTES           *\n*    (3) THE PRINT NAME OF THE ATOM \"NIL\" - LENGTH IS 8 BYTES         *\n*    (4) AREA RETURNED TO OPERATING SYSTEM - MINIMUM LENGTH IS 32K    *\n*   THE VALUE IN (4) IS SUBTRACTED FROM THE TOTAL GETMAINED LENGTH    *\n* AND FREEMAINED.  THEN THE LENGTHS OF THE COMMON AREA AND THE PRINT  *\n* NAMES ARE SUBTRACTED FROM THE REMAINING TOTAL AND ADDRESSES ARE     *\n* ASSIGNED.  THE REMAINDER IS THE LENGTH OF VECTOR/STRING SPACE.      *\n*                                                                     *\n* THEN, AS MUCH STORAGE AS WILL BE NEEDED IS ALLOCATED ABOVE 16MB.    *\n* THIS STORAGE IS DIVIDED UP AS FOLLOWS:                              *\n*    (1) PUSH DOWN STACK - LENGTH IS FROM OPTIONS, DEFAULT IS (DEFPDS)*\n*    (2) THE SYMBOL \"T\" - WE RESERVE (TSIZE) BYTES                    *\n*    (3) CONS SPACE - MINIMUM LENGTH IS (MINCSS), DEFAULT IS (DEFCSS) *\n*    (4) THE SYMBOL \"NIL\" - WE RESERVE (##SYMLEN) BYTES               *\n*    (5) PRINT STACK - LENGTH IS VALUE OF \"PSSIZE\"                    *\n*    (6) OBLIST HASH ARRAY - LENGTH IS 64K*4 = 256K                   *\n*    (7) SMALL FIXNUM TABLE - LENGTH IS 256*8 = 2048 (2K)             *\n*    (8) VECTOR/STRING SPACES (2) - MINIMUM LENGTH OF EACH IS 4K      *\n* THEN THE LENGTHS OF THE PUSH DOWN STACK AND THE FIXED-SIZE AREAS    *\n* ARE SUBTRACTED FROM THE REMAINING TOTAL AND ADDRESSES ARE ASSIGNED. *\n* THE REMAINDER IS THE LENGTH OF CONS SPACE, WHICH IS NOT             *\n* INITIALIZED UNTIL GARBAGE COLLECTION TIME.                          *\n*                                                                     *\n* NOTE THAT THE LENGTH OF ALL AREAS MUST BE ROUNDED UP TO MULTIPLES   *\n* OF 8 TO INSURE A VALID FREE LIST.                                   *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* PROCESS INITIALIZATION SPECS FROM PARM FIELD                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #1,4(,#13)          GET ADDRESS OF ZILMAIN'S SAVE AREA\n         L     #1,24(,#1)          GET ORIGINAL PARM POINTER\n         AIF   (NOT &ZILTSO).PGMCALL\n*----------------------------------------------------------------------\n* TSO ONLY\n*----------------------------------------------------------------------\n         TM    0(#1),X'80'         IF THERE IS 1 PARAMETER\n         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM\n         TM    4(#1),X'80'         IF THERE ARE 2 PARAMETERS\n         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM\n         TM    8(#1),X'80'         IF THERE ARE 3 PARAMETERS\n         BO    PGMCALL              THEN WE WERE CALLED AS A PROGRAM\n*                                  ELSE WE WERE CALLED AS A COMMAND\n         USING CPPL,#1\n         L     #2,CPPLCBUF         GET ADDRESS OF COMMAND BUFFER\n         LH    #0,0(,#2)           GET LENGTH OF COMMAND BUFFER\n         AR    #0,#2               POINT TO END OF COMMAND BUFFER\n         LH    #1,2(,#2)           GET OFFSET OF COMMAND TEXT\n         LA    #1,4(#1,#2)         POINT TO START OF COMMAND TEXT\n         SR    #0,#1               GET LENGTH OF COMMAND TEXT\n         B     GOTIT\n*----------------------------------------------------------------------\n* END TSO ONLY\n*----------------------------------------------------------------------\n.PGMCALL ANOP\nPGMCALL  DS    0H\n         L     #1,0(,#1)           GET ADDRESS OF PARM STRING\n         LH    #0,0(,#1)           GET LENGTH OF PARM STRING\n         LA    #1,2(,#1)           POINT TO TEXT OF PARM\nGOTIT    DS    0H                  #1 = ADDRESS, #0 = LENGTH\n* GET THE TRUE PARM, NOT INCLUDING LEADING DATA ENCLOSED IN BACKSLASHES\n         LTR   #0,#0               IF PARM LENGTH IS ALREADY ZERO\n         BZ    NOPARM              THEN NOTHING TO PROCESS\n         CLI   0(#1),C'\\'          IF PARM DOESN'T BEGIN WITH BACKSLASH\n         BNE   NOPARM              THEN NOTHING TO PROCESS\n         AR    #0,#1               MAKE #0 POINT TO END OF PARM STRING\n         LA    #1,1(,#1)           POINT TO FIRST CHARACTER IN SPECS\n         LR    #2,#1               SET KEYWORD POINTER\n         XR    #3,#3               SET KEYWORD LENGTH TO ZERO\n         XR    #4,#4               SET VALUE POINTER TO ZERO\n         XR    #5,#5               SET VALUE LENGTH TO ZERO\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* START SCANNING FOR INITIALIZATION PARAMETERS.                       *\n*                                                                     *\n* NOTE: DON'T USE REGISTER 6!                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nPLOOP    DS    0H\n         CR    #1,#0               IF END OF PARM STRING\n         BNL   PFINISH             THEN GO TO FINISH UP PARM SPECS\n         CLI   0(#1),C'\\'          IF END OF PARM\n         BE    PFINISH             THEN GO TO FINISH UP PARM SPECS\n         CLI   0(#1),C','          IF COMMA\n         BE    PCOMMA              THEN PROCESS COMMA\n         CLI   0(#1),C'='          IF EQUAL SIGN\n         BE    PEQUAL              THEN PROCESS EQUAL SIGN\n         CH    #3,=Y(L'PKEY)       IF KEYWORD LENGTH EXCEEDS MAX\n         BH    PERROR              THEN ERROR\n         LA    #3,1(,#3)            INCREMENT KEYWORD LENGTH\n         LA    #1,1(,#1)\n         B     PLOOP               CONTINUE SCAN\nPEQUAL   DS    0H                  EQUAL SIGN - PROCESS VALUE\n         LTR   #3,#3               IF KEYWORD LENGTH IS ZERO (NO KWD)\n         BZ    PERROR              THEN SYNTAX ERROR\n         BCTR  #3,0                ELSE REDUCE LENGTH FOR EXECUTE\n         MVI   PKEY,C' '           CLEAR KEYWORD AREA TO BLANKS\n         MVC   PKEY+1(L'PKEY-1),PKEY\n         EX    #3,MVCPKEY          MOVE KEYWORD FROM PARM FIELD TO OURS\n         LA    #14,PTABLE          POINT TO KEYWORD TABLE\nPTLOOP   DS    0H\n         CLI   0(#14),X'FF'        IF KEYWORD NOT FOUND IN TABLE\n         BE    PERROR              THEN SYNTAX ERROR\n         EX    #3,CLCPKEY          COMPARE KEYWORD WITH TABLE ENTRY\n         BE    PKGOT               IF MATCH, THEN GOT IT\n         LA    #14,12(,#14)        ELSE TRY NEXT TABLE ENTRY\n         B     PTLOOP\nPKGOT    DS    0H                  FOUND THE RIGHT KEYWORD\n         L     #14,8(,#14)         LOAD POINTER TO WHERE TO STORE VAL\n         LA    #1,1(,#1)           POINT TO CHARACTER FOLLOWING =\n         XR    #2,#2               CLEAR KEYWORD POINTER\n         XR    #3,#3               CLEAR KEYWORD LENGTH\n         LR    #4,#1               SET VALUE POINTER\n         XR    #5,#5               SET VALUE LENGTH\nPLOOP2   DS    0H                  NOW SCAN VALUE\n         CR    #1,#0               IF END OF PARM STRING\n         BNL   PFINISH             THEN GO TO FINISH UP PARM SPECS\n         CLI   0(#1),C'\\'          IF END OF PARM\n         BE    PFINISH             THEN GO TO FINISH UP PARM SPECS\n         CLI   0(#1),C','          IF COMMA\n         BE    PCOMMA              THEN PROCESS COMMA\n         CH    #5,=Y(L'PVAL)       IF VALUE LENGTH EXCEEDS MAX\n         BH    PERROR              THEN ERROR\n         LA    #5,1(,#5)           ELSE INCREMENT LENGTH\n         LA    #1,1(,#1)\n         B     PLOOP2              CONTINUE SCAN\nPFINISH  DS    0H\n         LR    #1,#0               MAKE IT LOOK LIKE WE'RE FINISHED\nPCOMMA   DS    0H                  COMMA - PROCESS KEYWORD=VALUE PAIR\n         LTR   #3,#3               IF WE ARE CURRENTLY IN A KEYWORD\n         BNZ   PERROR              THEN SYNTAX ERROR - K W/O VALUE\n         LTR   #5,#5               IF THERE IS NO VALUE\n         BZ    PAFTCOM             THEN JUST SKIP THIS\n         BCTR  #5,0                ELSE REDUCE LENGTH FOR EXECUTE\n         MVI   PVAL,C' '           CLEAR VALUE AREA TO BLANKS\n         MVC   PVAL+1(L'PVAL-1),PVAL\n         EX    #5,MVCPVAL          MOVE VALUE FROM PARM FIELD TO OURS\n         XR    #3,#3               SET MULTIPLIER SHIFT TO 0: 2**0=1\n         LA    #15,PVAL+1-1(#5)    POINT TO LAST CHARACTER OF VALUE\n         CLI   0(#15),C'K'         IF VALUE ENDS IN K\n         BNE   PNOTK               THEN\n         LA    #3,10               SET MULTIPLIER SHIFT TO 10: 2**10=1K\n         BCTR  #5,0                DECREMENT LENGTH\n         B     PAFTM               ELSE\nPNOTK    CLI   0(#15),C'M'         IF VALUE ENDS IN M\n         BNE   PAFTM               THEN\n         LA    #3,20               SET MULTIPLIER SHIFT TO 20: 2**20=1M\n         BCTR  #5,0                DECREMENT LENGTH\n         B     PAFTM               ELSE\nPAFTM    DS    0H                  #5 = LENGTH OF ACTUAL NUM LESS 1\n         LTR   #5,#5               GET (LENGTH-1) OF NUMERIC\n         BM    PERROR              IF LESS THAN ZERO, ERROR\n         CH    #5,=H'9'            IF GREATER THAN 2**31-1, ERROR\n         BH    PERROR\n         BL    PNCHECK\n         CLC   PVAL(10),=C'2147483647'\n         BH    PERROR\nPNCHECK  EX    #5,TRTVAL           CHECK FOR ALL NUMERICS\n         BNZ   PERROR\n         EX    #5,PACKVAL          CONVERT TO PACKED DECIMAL\n         CVB   #4,PDBL             AND THEN TO BINARY\n         SLA   #4,0(#3)            SHIFT FOR POSSIBLE K OR M MULTIPLIER\n         BO    PERROR              IF OVERFLOW, ERROR\n         ST    #4,0(,#14)          SET XXSIZE VALUE ACCORDING TO TABLE\nPAFTCOM  DS    0H                  FINISHED PROCESSING COMMA, PROCEED\n         LA    #2,1(,#1)           SET KEYWORD POINTER\n         XR    #3,#3               CLEAR KEYWORD LENGTH\n         MVI   PVAL,C' '           CLEAR VALUE AREA TO BLANKS\n         MVC   PVAL+1(L'PVAL-1),PVAL\n         LA    #4,PVAL             SET VALUE POINTER\n         XR    #5,#5               SET VALUE LENGTH\n         B     PNEXT               CONTINUE SCAN\nPNEXT    DS    0H                  CONTINUE SCAN\n         CR    #1,#0               IF AT END\n         BNL   NOPARM              THEN FINISHED\n         LA    #1,1(,#1)           ELSE GET NEXT CHARACTER\n         B     PLOOP\n         SPACE 1\nPERROR   DS    0H                  ERROR IN PARM FIELD\n         L     #1,=A(ZIL0002)\n         WTO   MF=(E,(1)),ROUTCDE=11\n         B     NOPARM\n         SPACE 2\nMVCPKEY  OC    PKEY(*-*),0(#2)     MOVE KEYWORD FROM PARM FIELD TO OURS\nMVCPVAL  OC    PVAL(*-*),0(#4)     MOVE VALUE FROM PARM FIELD TO OURS\nCLCPKEY  CLC   PKEY(*-*),0(#14)    COMPARE KEYWORD WITH TABLE ENTRY\nTRTVAL   TRT   PVAL(*-*),PTRTTBL   EXECUTED: SCAN FOR ALL NUMERICS\nPACKVAL  PACK  PDBL(8),PVAL(*-*)   EXECUTED: CONVERT TO PACKED DECIMAL\n         SPACE 2\nPDBL     DS    D                   PLACE TO CONVERT NUMERICS\nPKEY     DS    CL8                 PLACE TO STORE KEYWORD\nPVAL     DS    CL11                PLACE TO STORE VALUE\n         SPACE 1\nPTABLE   DS    0A                  TABLE OF KEYWORDS\n         DC    C'PDSIZE  ',A(PDSIZE)\n         DC    C'CSSIZE  ',A(CSSIZE)\n         DC    C'VSSIZE  ',A(VSSIZE)\n         DC    C'ACSIZE  ',A(ACSIZE)\n         DC    X'FF'               END OF TABLE\n         SPACE 2\nPTRTTBL  DC    256YL1(1)\n         ORG   PTRTTBL+C'0'\n         DC    10YL1(0)\n         ORG   ,\nNOPARM   DS    0H\n         EJECT\n***********************************************************************\n* COMPUTE STORAGE FOR:  AREA24 = COMMON + PNAME(T) + PNAME(NIL)       *\n*                       AREA31 = STACK + SYMBOL(T) + CONS + FIXNUMS + *\n*                                VSS(1) + VSS(2) +                    *\n*                                SYMBOL(NIL) + PRINTSTACK + OBHASH    *\n***********************************************************************\n         SPACE 1\n         A     #6,=F'32768'        TOTAL AMOUNT RESERVED FOR OS\n         L     #2,OPTPTR           GET ADDRESS OF OPTIONS\n         LA    #8,COMLEN           GET LENGTH OF COMMON AREA\n         LA    #4,LMODELT+LMODELNL(#6,#8) ADD LENGTHS OF T/NIL PNAMES\n*                                  PLUS OS SIZE\n*                                  THAT GIVES THE LENGTH OF AREA24\n         SPACE 1\n         #GETMAIN RC,LV=(#4),LOC=BELOW GET 24-BIT STORAGE\n         LTR   #15,#15\n         BNZ   ERR0001\n         ST    #1,AREA24A          STORE ADDRESS OF 24-BIT AREA\n         ST    #4,AREA24L          STORE ADDRESS OF 24-BIT AREA\n         LR    #9,#1               SAVE ADDRESS OF 24-BIT AREA (COMMON)\n         LR    #14,#4              PICK UP LENGTH OF 24-BIT AREA\n         SR    #14,#6              SUBTRACT AMOUNT RESERVED FOR OS\n         AR    #1,#14              POINT TO AREA TO BE GIVEN BACK TO OS\n         LR    #0,#6               LOAD LENGTH TO BE FREED\n         FREEMAIN RU,LV=(0),A=(1)  FREE THE AREA FOR THE OS\n         ST    #14,AREA24L         ADJUST LENGTH, NO MORE OS MEM ALLOC\n*\n* CLEAR THE COMMON AREA TO ZEROES\n*\n         LR    #14,#9              MVCL ADDRESS OF COMMON AREA\n         LR    #15,#8              MVCL LENGTH OF COMMON AREA\n         XR    #0,#0               MVCL ADDRESS OF DATA TO MOVE (NONE)\n         XR    #1,#1               MVCL LENGTH OF DATA TO MOVE (NONE)\n         MVCL  #14,#0              MOVE HEX ZEROES TO COMMON AREA\n*\n* CHAIN THE COMMON AREA SAVE AREA.   NOW WE CAN CALL SYSTEM FUNCTIONS\n*\n         ST    #9,8(,#13)          CHAIN SAVE AREAS TOGETHER\n         ST    #13,4(,#9)\n         LR    #13,#9\n         USING ZLCOMMON,#13\n*\n* NOW GET AREA31: MINIMUM SIZE = PDSIZE + 16 + MINCSS + PRINTSTACKSIZE\n*                                + VSSIZE\n*                                + 256K FOR OBLIST HASH ARRAY\n*                                + 2K FOR SMALL FIXNUM TABLE\n*                 MAXIMUM SIZE = PDSIZE + 16 + CSSIZE + PRINTSTACKSIZE\n*                                + VSSIZE\n*                                + 256K FOR OBLIST HASH ARRAY\n*                                + 2K FOR SMALL FIXNUM TABLE\n*\n         ICM   #6,15,PDSIZE        GET INIT PUSH DOWN STACK SIZE\n         BNZ   USEPD               IF SPECIFIED, USED IT\n         ICM   #6,15,ZLHPDSIZ      ELSE GET MODULE PUSH DOWN STACK SIZE\n         BNZ   USEPD               IF SPECIFIED, USED IT\n         L     #6,DEFPDS           ELSE USE DEFAULT FOR PDSIZE\nUSEPD    LA    #6,7(,#6)           ROUND UP TO DOUBLEWORD BOUNDARY\n         N     #6,=X'FFFFFFF8'\n         LA    #3,##SYMLEN+TSIZE(,#6) STACK SIZE + LENGTHS OF T, NIL\n         A     #3,PSSIZE            + PRINT STACK SIZE\n         A     #3,OHSIZE            + OBLIST HASH ARRAY SIZE\n         A     #3,SFSIZE            + SMALL FIXNUM TABLE SIZE\n*\n* NOW COMPUTE MINIMUM AND MAXIMUM BY ADDING VSSIZE AND CSSIZE...\n*\n         L     #4,MINVSS           ADD 2 TIMES 4K FOR MINIMUM VSS\n         A     #4,MINCSS           ADD MINIMUM CONS SPACE SIZE\n         AR    #4,#3               THAT'S MINIMUM LEN OF AREA31\n*\n* ADD REQUESTED VSSIZE AND CSSIZE TO AMOUNT SO FAR TO GET MAXIMUM\n*\n         ICM   #1,15,VSSIZE        GET INIT VECTOR/STRING SPACE SIZE\n         BNZ   USEVS               IF SPECIFIED, USED IT\n         ICM   #1,15,ZLHVSSIZ      ELSE GET MODULE VECTOR/STRING SIZE\n         BNZ   USEVS               IF SPECIFIED, USED IT\n         L     #1,=A(1024*1024)    ELSE USE DEFAULT OF 1M\nUSEVS    LA    #14,7(,#1)          ROUND UP TO DOUBLEWORD BOUNDARY\n         N     #14,=X'FFFFFFF8'\n         SLA   #14,1               MULTIPLY BY 2 FOR TWO SPACES\n         AR    #3,#14              ADD TO TOTAL SIZE SO FAR\n         SRA   #14,1               GET LENGTH OF SINGLE V/S SPACE\n         ST    #14,VSSIZE          SET TOTAL VECTOR/STRING SPACE SIZE\n         ICM   #1,15,CSSIZE        GET INIT CONS SPACE SIZE\n         BNZ   USECS               IF SPECIFIED, USED IT\n         ICM   #1,15,ZLHCSSIZ      ELSE GET MODULE CONS SPACE SIZE\n         BNZ   USECS               IF SPECIFIED, USED IT\n         L     #1,DEFCSS           ELSE USE DEFAULT FOR CSSIZE\nUSECS    LA    #1,4095(,#1)        ROUND UP TO 4K BOUNDARY\n         N     #1,=F'-4096'\n         LA    #5,0(#1,#3)         SET MAX LEN OF AREA31\n         #GETMAIN VRC,LV=((#5),(#4)),LOC=ANY GET STORAGE ABOVE 16MB\n         LTR   #15,#15\n         BNZ   ERR0001\n         ST    #1,AREA31A          SAVE ADDRESS OF 31-BIT AREA\n         ST    #0,AREA31L          SAVE LENGTH OF 31-BIT AREA\n         LR    #3,#0               COMPUTE SIZE LEFT FOR CONSES =\n         SR    #3,#6               AREA31 LENGTH MINUS STACK SIZE\n         SH    #3,=Y(##SYMLEN+TSIZE) MINUS LENGTHS OF SYMBOLS T, NIL\n         S     #3,PSSIZE            MINUS LENGTH OF PRINT STACK\n         S     #3,OHSIZE            MINUS LENGTH OF OBLIST HASH ARRAY\n         S     #3,SFSIZE            MINUS LENGTH OF SMALL FIXNUM TABLE\n         S     #3,VSSIZE            MINUS LENGTH OF V/S SPACE REQUESTED\n         S     #3,VSSIZE            (TWO TIMES, ONE FOR EACH SPACE)\n*\n* NOW #3 CONTAINS WHATEVER IS LEFT OVER FOR CSSIZE.\n*\n* IF THE LENGTH OF CONS SPACE (AFTER ALL THE OTHER LENGTHS HAVE BEEN\n* SUBTRACTED) IS NOT A MULTIPLE OF 4K, THEN WE MUST ADJUST IT TO A\n* MULTIPLE OF 4K (REQUIRED BY VECTOR GC ALGORITHM).  THEREFORE, WE\n* REMOVE THE EXCESS AND GIVE IT TO SOMEONE ELSE - NAMELY,\n* THE CONTROL STACK.\n*\n         LR    #14,#3              SAVE UNROUNDED CSSIZE\n         N     #3,=F'-4096'        ROUND CSSIZE DOWN TO 4K BOUNDARY\n         SR    #14,#3              GET THE EXCESS AMOUNT (USUALLY ZERO)\n         AR    #6,#14              ADD IT TO PUSH DOWN STACK SIZE\n*\n* NOW #3 CONTAINS CSSIZE ROUNDED DOWN TO MULTIPLE OF 4K.\n*\n* MAKE SURE TRUE CSSIZE IS ENOUGH.  AS LONG AS IT IS, STORE IT.\n*\n         C     #3,MINCSS           IF THIS IS LESS THAN MINIMUM LEN\n         BL    ERR0001             THEN ERROR\n         ST    #3,CSSIZE           ELSE SAVE TRUE CONS SPACE SIZE\n*\n* CLEAR PUSH DOWN STACK- NEEDED TO PREVENT POTENTIAL GC ANOMALIES\n*\n         DROP  #2,#11\n         LR    #11,#1              ADDRESS OF 31-BIT AREA = STACK ADDR\n         LR    #14,#1              MVCL ADDRESS OF PUSHDOWN STACK\n         LR    #15,#6              MVCL LENGTH OF PUSHDOWN STACK\n         XR    #0,#0               MVCL ADDRESS TO MOVE FROM = NONE\n         XR    #1,#1               MVCL LENGTH TO MOVE = ZERO\n         MVCL  #14,#0              SET PUSH DOWN STACK TO ZEROES\n*\n* NOW THAT WE KNOW WHERE THE COMMON AREA IS, STORE ALL OUR VALUES THERE\n*\n         L     #2,HDRPTR           GET ADDRESS OF HEADER\n         ST    #2,ZLCHDADR         STORE ADDRESS OF HEADER\n         L     #2,OPTPTR           GET ADDRESS OF OPTIONS\n         ST    #2,ZLCOPADR         STORE ADDRESS OF OPTIONS\n         LM    #0,#1,AREA24A       GET ADDRESS & LENGTH OF 24-BIT AREA\n         STM   #0,#1,ZLC24ADR      STORE IN COMMON AREA\n         LM    #0,#1,AREA31A       GET ADDRESS & LENGTH OF 31-BIT AREA\n         STM   #0,#1,ZLC31ADR      STORE IN COMMON AREA\n         ST    #13,ZLCCMADR        STORE ADDRESS OF COMMON AREA\n         ST    #8,ZLCCMSIZ         STORE SIZE OF COMMON AREA\n         ST    #6,ZLCPDSIZ         STORE SIZE OF PUSH DOWN STACK\n         ST    #11,ZLCPDADR        STORE ADDRESS OF PUSH DOWN STACK\n*\n* HAVING STORED REGISTERS, WE CAN NOW SET ADDRESSES OF STANDARD ATOMS\n*\n         LA    #8,0(#11,#6)        COMPUTE ADDRESS OF ATOM T =\n*                                   PUSH DOWN ADDR + PUSH DOWN SIZE\n         LA    #7,TSIZE(,#8)       COMPUTE ADDRESS OF FIXNUM TABLE =\n*                                   ADDRESS OF T + LENGTH OF T + JUNK\n         LR    #1,#7               COMPUTE ADDRESS OF VSS #1 =\n         A     #1,SFSIZE            ADDRESS OF SMALL FIXNUM TABLE\n         ST    #1,ZLCVSADR          + LENGTH OF SMALL FIXNUM TABLE\n         ST    #1,ZLCVSNXT         SET PTR TO FIRST AVAILABLE SLOT\n         L     #0,VSSIZE           GET LENGTH OF ONE HALF OF IT\n         ST    #0,ZLCVSLEN         SET LENGTH\n         AR    #1,#0               COMPUTE ADDRESS OF VSS #2 =\n         ST    #1,ZLCVSOTH          ADDRESS OF VSS #1 +\n         AR    #1,#0                + LENGTH OF VSS #1\n         LR    #9,#1               COMPUTE ADDRESS OF CONS SPACE =\n*                                   ADDRESS OF VSS #2 +\n*                                   + LENGTH OF VSS #2\n         LA    #10,0(#9,#3)        COMPUTE ADDRESS OF ATOM NIL =\n*                                   ADDRESS OF CONS SPACE + ITS LENGTH\n         ST    #7,ZLCSFTBL         STORE ADDRESS OF SMALL FIXNUM TABLE\n         ST    #8,ZLCT             STORE ADDRESS OF ATOM T\n         ST    #9,ZLCCSADR         STORE ADDRESS OF CONS SPACE\n         ST    #10,ZLCNIL          STORE ADDRESS OF ATOM NIL\n*\n* SET OTHER STUFF\n*\n         LA    #1,##SYMLEN(,#10)   POINT TO JUST ABOVE NIL\n         ST    #1,ZLCPSADR         THAT'S ADDRESS OF PRINT STACK\n         L     #1,PSSIZE           GET LENGTH OF PRINT STACK\n         ST    #1,ZLCPSSIZ         THAT'S SIZE OF PRINT STACK\n         A     #1,ZLCPSADR         ADD IN THE ADDRESS\n         ST    #1,ZLCPSEND         THAT'S THE END OF THE PRINT STACK\n         ST    #1,ZLCOBHSH         AND THE @ OF THE OBLIST HASH ARRAY\n         L     #1,OHSIZE           GET SIZE OF OBLIST HASH ARRAY\n         SRA   #1,2                DIVIDE BY 4 TO GET...\n         ST    #1,ZLCOBDIM         COUNT OF ENTRIES IN OBHASH\n         ST    #3,ZLCCSSIZ         STORE SIZE OF CONS SPACE\n         SRA   #3,3                DIVIDE BY 8 TO GET...\n         ST    #3,ZLCNFREE         TOTAL CONS CELL COUNT\n*\n* CLEAR OBLIST HASH ARRAY\n*\n         L     #14,ZLCOBHSH        MVCL ADDRESS OF OBLIST HASH ARRAY\n         L     #15,OHSIZE          MVCL LENGTH OF OBLIST HASH ARRAY\n         XR    #0,#0               MVCL ADDRESS TO MOVE FROM = NONE\n         XR    #1,#1               MVCL LENGTH TO MOVE = ZERO\n         MVCL  #14,#0              SET OBLIST HASH ARRAY TO ZEROES\n*\n* Initialize small fixnum table\n*\n         USING #SFTD,#8\n*----------------------------------------------------------------------\n         AIF   (&ZILVF).VFIX\n*----------------------------------------------------------------------\n         LA    #14,##FIXNUM        Get fixnum type bit code\n         SLL   #14,24              Shift into high-order byte\n         LA    #0,1                Get BXLE increment\n         XR    #15,15              Initialize fixnum value to zero\n         ST    #15,ZLCSFTLO        Save lowest value\n         LA    #7,#SFTPFX          Get address of fixnum before table\n         BCTR  #15,0               Initialize fixnum value to -1\n         LA    #1,255              Get highest fixnum to be generated\nSFLOOP   DS    0H\n         STM   #14,#15,0(#7)       Store fixnum words into table\n         LA    #7,8(,#7)           Bump fixnum table pointer\n         BXLE  #15,#0,SFLOOP       Do for I = 0 to 255\n         ST    #1,ZLCSFTHI         Save highest value\n*----------------------------------------------------------------------\n         AGO   .VFIXEND\n*----------------------------------------------------------------------\n.VFIX    ANOP\n*----------------------------------------------------------------------\n         SPACE 1\n*\n* This code initializes the small fixnum table with a series of\n* contiguous fixnums (8-byte entries) from -1 to 255.  The code\n* assumes a section size of 128, meaning that the process takes\n* 2 vector operations (if the section size were 256, we could do\n* it in 1 vector operation).  Fixnums -1 through 254 are created\n* through vector operations (making use of the VLINT instruction\n* to create a vector of consecutive integer values), and fixnum\n* 255 is created scalarly afterward.\n*\n         SPACE 1\n         VLVCA 128                 Section size to 128 (not maximum)\n         LA    #14,##FIXNUM        Get fixnum type bit code\n         SLL   #14,24              Shift into high-order byte\n         XR    #15,15              Initialize fixnum value to zero\n         ST    #15,ZLCSFTLO        Save lowest value\n         BCTR  #15,0               Make first fixnum value = -1\n         LA    #7,#SFTPFX          Address table location for -1\n         VLQ   #V0,#14             Left vector = all fixnum left halves\n         VLINT #V1,#15             Right vector = integers -1 thru 126\n         VSTD  #V0,#7              Store vector doublewords in table\n*                                  #7 now points to next part of table\n*                                  #15 now contains (-1+128) = 127\n         VLINT #V1,#15             Right vector = integers 127 thru 254\n         VSTD  #V0,#7              Store the next 128 table doublewords\n*                                  #7 now points to next slot in table\n*                                  #15 now contains (127+128) = 255\n         STM   #14,#15,0(#7)       Store last entry in fixnum table\n         ST    #15,ZLCSFTHI        Save highest fixnum value\n*----------------------------------------------------------------------\n.VFIXEND ANOP\n*----------------------------------------------------------------------\n*\n* THE FREE LIST IS INITIALIZED ONLY WHEN A GARBAGE COLLECTION OCCURS.\n* OTHERWISE IT IS ACCESSED SEQUENTIALLY BY CONS.\n* THIS ELIMINATES THE FIRST-TIME OVERHEAD OF CHAINING CELLS TOGETHER.\n*\n* INITIALIZE FILE BLOCK POINTERS\n* (NOTE INPUT AND OUTPUT TERMINAL FILE BLOCK POINTERS REMAIN ZERO)\n*\n         L     #7,OFPTR            GET ADDRESS OF STD OUTPUT FILE BLOCK\n         ST    #7,ZLCSTDOU         SET ADDRESS OF STD OUTPUT FILE BLOCK\n         L     #7,ZLFCHAIN         GET ADDRESS OF FIRST OUTPUT FILE BLK\n         ST    #7,ZLCOFBAD         SET ADDRESS OF FIRST OUTPUT FILE BLK\n         L     #7,IFPTR            GET ADDRESS OF STD INPUT FILE BLOCK\n         ST    #7,ZLCSTDIN         SET ADDRESS OF STD INPUT FILE BLOCK\n         L     #7,ZLFCHAIN         GET ADDRESS OF FIRST INPUT FILE BLK\n         ST    #7,ZLCIFBAD         SET ADDRESS OF FIRST INPUT FILE BLK\n         L     #7,ZLCSTDIN         GET ADDR OF STANDARD INPUT FILE BLK\n         TM    ZLFFLAG1,ZLFTERM    IF STANDARD INPUT IS A TERMINAL FILE\n         BZ    *+8                 THEN\n         ST    #7,ZLCIFTRM          SET INPUT TERMINAL FILE BLK PTR\n         L     #7,ZLCSTDOU         GET ADDR OF STANDARD OUTPUT FILE BLK\n         TM    ZLFFLAG1,ZLFTERM    IF STANDARD OUTPUT IS A TERM FILE\n         BZ    *+8                 THEN\n         ST    #7,ZLCOFTRM          SET OUTPUT TERMINAL FILE BLK PTR\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* The following section of code has been removed, because we think    *\n* that we WILL be able to run ZIL applications under themselves       *\n* (e.g. via the TSO function) if we omit this check.                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         AGO   .NCKSUBS\n*----------------------------------------------------------------------\n         SPACE 1\n*\n* SEE IF ZILSUBS IS ALREADY LOADED.  IF SO, ZIL ALREADY ACTIVE\n*\n* NOTE: THIS WON'T WORK IF ZILSUBS IS IN THE LPA, WHICH IT CAN'T BE\n*       'CAUSE IT'S NOT REENTRANT ANYHOW.\n*\n         L     #15,X'21C'          ADDRESS OF CURRENT TCB\n         L     #15,X'7C'(,#15)     TCBJSTCB: CURRENT JOB STEP TCB\n         ICM   #14,15,X'2C'(#15)   TCBJPQ: ADDRESS OF JOB PACK QUEUE\nJPQLOOP  DS    0H                  IF NO MORE JOB PACK ENTRIES\n         BZ    NOTLDED             THEN ZILSUBS IS NOT IN STORAGE\n         CLC   8(8,#14),$ZILSUBS   IF CDE NAME IS ZILSUBS\n         BE    INSTOR              THEN ZILSUBS IS ALREADY IN STORAGE\n         ICM   #14,15,0(#14)       ELSE GET NEXT JOB PACK QUEUE ENTRY\n         B     JPQLOOP             AND CONTINUE SEARCH\nNOTLDED  DS    0H                  ZILSUBS NOT LOADED...\n         SPACE 1\n*----------------------------------------------------------------------\n.NCKSUBS ANOP  ,\n         SPACE 1\n*\n* SET UP INTERFACES TO RESIDENT ROUTINES\n*\n         LOAD  EPLOC=$ZILSUBS      LOAD SUBROUTINE MODULE\n         ST    #0,ZLCSUBS          SAVE ITS ADDRESS\n         LR    #15,#0\n         L     #15,0(,#15)         GET POINTER TO SUBROUTINE ADDRESSES\n         USING ZSASUBS,#15\n         L     #0,ZSACONS          CONS PLUS GARBAGE COLLECTOR\n         ST    #0,ZLCCONS\n         L     #0,ZSAFGETI         INPUT FILE BLOCK ACCESSOR\n         ST    #0,ZLCFGETI\n         L     #0,ZSAFGETO         OUTPUT FILE BLOCK ACCESSOR\n         ST    #0,ZLCFGETO\n         L     #0,ZSAPDSO          STACK OVERFLOW ERROR ROUTINE\n         ST    #0,ZLCPDSO\n         L     #0,ZSAERR           GENERAL ERROR ROUTINE\n         ST    #0,ZLCERR\n         L     #0,ZSATHROW         THROW PROCESSOR\n         ST    #0,ZLCTHROW\n         L     #0,ZSATPUT          TPUT PROCESSOR\n         ST    #0,ZLCTPUT\n         L     #0,ZSABIG           BIGNUM ALLOCATION ROUTINE\n         ST    #0,ZLCBIG\n         L     #0,ZSAINTN          SYMBOL INTERNMENT ROUTINE\n         ST    #0,ZLCINTN\n         L     #0,ZSAABLD          ATOM BUILDING ROUTINE\n         ST    #0,ZLCABLD\n         L     #0,ZSAADMP          ATOM DUMPING ROUTINE\n         ST    #0,ZLCADMP\n         L     #0,ZSAVSS           VECTOR/STRING SPACE ALLOCATOR\n         ST    #0,ZLCVSS\n         L     #0,ZSAGETC          CHARACTER INPUT ROUTINE\n         ST    #0,ZLCGETC\n         L     #0,ZSAPRIN          PRINT ROUTINE\n         ST    #0,ZLCPRIN\n         L     #0,ZSATERP          TERPRI ROUTINE\n         ST    #0,ZLCTERP\n         L     #0,ZSAFINT          FORTRAN INTERFACE ROUTINE\n         ST    #0,ZLCFINT\n         L     #0,ZSAKERR          &KEY KEYWORD ERROR HANDLER\n         ST    #0,ZLCKERR\n         L     #0,ZSACVBF          BIGNUM-TO-FLOAT CONVERSION\n         ST    #0,ZLCCVBF\n         L     #0,ZSASINT          COMPILED CODE OBJECT INITIALIZATION\n         ST    #0,ZLCSINT\n         L     #0,ZSASBND          SPECIAL VARIABLE BINDING\n         ST    #0,ZLCSBND\n         L     #0,ZSAFBND          LEXICAL VARIABLE BINDING\n         ST    #0,ZLCFBND\n         L     #0,ZSAMDF           DOUBLE FLOAT CONSING\n         ST    #0,ZLCMDF\n         L     #0,ZSAVALS          Multiple value returning\n         ST    #0,ZLCVALS\n         DROP  #15\n*\n* SET UP INTERFACE TO PUSHDOWN STACK OVERFLOW ROUTINE\n*\n         MVC   0(4,#13),PDSCODE1\n         MVC   ZLCCALPO(ZLCCALPL),PDSCODE2\n*\n* SET UP INTERFACE TO ZIL MODULES TABLE\n*\n         L     #15,HDRPTR\n         USING ZLHEADER,#15\n         L     #15,ZLHMODS         GET ADDRESS OF ZILMODS\n         DROP  #15\n         ST    #15,ZLCMODS         STORE ADDRESS OF ZILMODS\n*\n* DEFINE DEFAULTS FOR DISPLAYING SQUARE BRACKETS WHEN PRINC IS DONE\n* TO A FILE IN TABS MODE.  USED BY MACSYMA.\n*\n         MVI   ZLCLB,X'C0'         USE LEFT CURLY BRACE \"{\"\n         MVI   ZLCRB,X'D0'         USE RIGHT CURLY BRACE \"}\"\n*\n* THE TRANSLATION POINTS DEFINED IN THE TABLE BELOW ARE USED WHEN A\n* PRIN1 IS DONE TO THE TERMINAL, OR WHEN A PRINC IS DONE TO THE\n* TERMINAL AND TABS MODE HAS BEEN TURNED OFF.\n*\n* ALLOCATE THE TERMINAL OUTPUT TRANSLATE TABLE\n*\n         LA    #0,256              GET A 256-BYTE BUFFER\n         GETMAIN R,LV=(0)\n         LR    #14,#1\n         ST    #14,ZLCTRMTR        SET ADDRESS OF TRANSLATE TABLE\n         MVC   0(256,#14),TRMTRTBL SET UP THE DEFAULT TRANSLATE TABLE\n         MVI   X'AD'(#14),X'41'     DISPLAY LEFT BRACKET AS HEX 41\n         MVI   X'BD'(#14),X'42'     DISPLAY RIGHT BRACKET AS HEX 42\n         GTSIZE ,                  GET TERMINAL LINE SIZE\n         LTR   #15,#15             SKIP TRANSLATE TABLE ALTERATION IF\n         BNZ   NOTRCHG              SVC 94 CALL FAILED\n         CH    #0,=H'32'           IF THIS IS A 32-LINE TERMINAL\n         BNE   NOTRCHG             THEN (ASSUME 3179, NOT 3279)\n         MVI   X'AD'(#14),X'BA'     DISPLAY LEFT BRACKET AS HEX BA\n         MVI   X'BD'(#14),X'BB'     DISPLAY RIGHT BRACKET AS HEX BB\nNOTRCHG  DS    0H\n*\n* CREATE THE \"RMNIL\" OBJECT RETURNED BY THE (RMNIL) FUNCTION\n*\n         LA    #15,ZLCRMNIL\n         LR    #0,#15\n         STM   #15,#0,ZLCRMNIL     (CAR(RMNIL))=(CDR(RMNIL))=(RMNIL)\n*\n* CREATE THE \"UNBOUND\" OBJECT\n*\n         LA    #15,ZLCUNBND\n         LR    #0,#15\n         STM   #15,#0,ZLCUNBND     (CAR(UNBND))=(CDR(UNBND))=(UNBND)\n*\n* INITIALIZE GARBAGE COLLECTION FLAGS\n*\n         MVI   ZLCGCFLG,ZLCGCINT+ZLCGCMSG\n*\n* INITIALIZE OTHER COMMON AREA FIELDS\n* NOTE THAT ZLCMSLVL (MESSAGE LEVEL) IS INITIALLY ONE\n* (I.E. INITIALLY DISPLAY ALL BUT INFORMATIONAL MESSAGES)\n*\n         MVI   ZLCMSLVL,1          SET MSGLEVEL TO 1\n         L     #1,TIOTDRIB\n         ST    #1,ZLCDRIBL         SET ADDRESS OF DRIBBLE DCB IF ANY\n         ST    #10,ZLCGCEND        SET END-OF-FREE-LIST POINTER\n         L     #1,X'21C'           GET CURRENT TCB ADDRESS\n         L     #1,0(,#1)           GET CURRENT PRB ADDRESS\n         ST    #1,ZLCZILRB         SAVE RB ADDRESS (USED BY ATTN EXIT)\n         AIF   (&ZILXA).IPM\n*\n* In a non-XA system there is no IPM instruction, so to access the\n* program mask we just look at the PSW.\n*\n         BALR  #1,0                INSERT PROGRAM MASK FROM PSW\n         AGO   .AFTIPM\n.IPM     ANOP\n*\n* In an XA system BALR won't get the PSW, but we have this neat\n* instruction to access the program mask.\n*\n         IPM   #1                  INSERT PROGRAM MASK FROM PSW\n.AFTIPM  ANOP\n         STCM  #1,8,ZLCPMASK       SAVE INITIAL PROGRAM MASK\n         MVC   ZLCOBCNT,OBTHRESH   INITIALIZE OBHASH THRESHOLD COUNT\n         LA    #1,ZLFBLEN          GET LENGTH OF A FILE BLOCK\n         STH   #1,ZLCFBLEN         STORE FILE BLOCK LENGTH\n*\n* DETERMINE THE VALUE OF ACTIVE CONS SPACE SIZE TO USE\n*\n*\n         L     #2,OPTPTR           ADDRESS ZIL HEADER OPTIONS\n         USING ZLHOPTS,#2\n         ICM   #6,15,ACSIZE        GET INIT ACTIVE CONS SPACE SIZE\n         BNZ   USEAC               IF SPECIFIED, USED IT\n         ICM   #6,15,ZLHACSIZ      ELSE GET MODULE ACTIVE CONS SIZE\n         BNZ   USEAC               IF SPECIFIED, USED IT\n         L     #6,DEFACS           ELSE USE DEFAULT FOR ACSIZE\nUSEAC    LA    #6,7(,#6)           ROUND UP TO DOUBLEWORD BOUNDARY\n         N     #6,=X'FFFFFFF8'\n         C     #6,ZLCCSSIZ         IF ACSIZE EXCEEDS TOTAL CSSIZE\n         BNH   ACSIZOK             THEN\n         L     #6,ZLCCSSIZ          SET ACSIZE TO TOTAL CSSIZE\nACSIZOK  DS    0H\n         DROP  #2\n*\n* RESET #9 TO POINT TO BOTTOM OF ACTIVE CONS SPACE RATHER THAN\n* BOTTOM OF TOTAL CONS SPACE.  ALSO SET OTHER FIELDS RELATING TO\n* DYNAMICALLY EXPANDING CONS SPACE.\n*\n         LR    #9,#10              GET NIL, WHICH IS AT TOP OF CONS SP\n         SR    #9,#6               BUMP DOWN TO BOTTOM OF ACTIVE CONSES\n         C     #9,ZLCCSADR         IF THIS PASSES BOTTOM OF TOTAL CS\n         BNL   CSGE1M              THEN\n         L     #9,ZLCCSADR          USE TOTAL CSSIZE BOTTOM POINTER\nCSGE1M   ST    #9,ZLCGCACP         THAT'S NOW POINTER TO FIRST FREE\n         LR    #0,#6               GET INITIAL ACTIVE CONS SPACE SIZE\n         SRL   #0,3                MINIMUM NUMBER OF CONS CELLS\n         ST    #0,ZLCGCACD         STORE MINIMUM NUMBER OF DOUBLEWORDS\n         ST    #0,ZLCGCACF         THIS IS ALSO THE FREE COUNT\n         EJECT\n*\n* INITIALIZE NEW-SYMBOL TEMPLATE\n*\n* ##PNAME IS NOT SET - MUST ALWAYS BE FILLED BY CREATOR\n*\n         MVI   ZLCNSYM+##TYPE,##SYMBOL SET SYMBOL TYPE BITS\n         MVI   ZLCNSYM+3,##SYMLEN      SET SYMBOL LENGTH (REST IS X'')\n         ST    #10,ZLCNSYM+##PLIST     SET PROPERTY LIST TO NIL\n         LA    #0,ZLCUNBND             GET THE UNBOUND OBJECT\n         ST    #0,ZLCNSYM+##PVALUE     SET VALUE CELL TO UNBOUND\n         ST    #0,ZLCNSYM+##PFUNC      SET FUNCTION CELL TO UNBOUND\n*                                      DEFAULT PACKAGE = UNINTERNED\n         ST    #10,ZLCNSYM+##PPKG      SET PACKAGE CELL TO NIL\n*\n* BUILD ATOMS T AND NIL\n*\n         MVC   PNAMET(LMODELT,#13),MODELT       BUILD T'S PRINT NAME\n         MVC   PNAMENIL(LMODELNL,#13),MODELNIL  BUILD NIL'S PRINT NAME\n         MVC   0(##SYMLEN,#8),ZLCNSYM MOVE NEW SYMBOL TEMPLATE TO T\n         MVC   0(##SYMLEN,#10),ZLCNSYM MOVE NEW SYMBOL TEMPLATE TO NIL\n         LA    #0,PNAMET(,#13)     POINT TO WHERE T'S PRINT NAME'LL BE\n         ST    #0,##PNAME(,#8)     SET PRINT NAME POINTER OF T\n         LA    #0,PNAMENIL(,#13)   POINT TO WHERE NIL'S PNAME WILL BE\n         ST    #0,##PNAME(,#10)    SET PRINT NAME POINTER OF NIL\n*\n* VERY IMPORTANT THAT ##PVALUE AND ##CDR ARE IDENTICAL, BECAUSE IN THE\n* CASE OF NIL BOTH (SYMBOL-VALUE NIL) AND (CDR NIL) MUST BE NIL!!!!!!!\n*\n         ST    #10,##PVALUE(,#10)  VALUE CELL OF NIL POINTS TO NIL\n         ST    #8,##PVALUE(,#8)    VALUE CELL OF T POINTS TO T\n* T and NIL are interned - set package cell to T for now (see ZILSPKG)\n         ST    #8,##PPKG(,#8)      SET T'S PACKAGE CELL\n         ST    #8,##PPKG(,#10)     SET NIL'S PACKAGE CELL\n*\n*\n* SET FILE ATOMS TO NIL FOR STANDARD INPUT AND OUTPUT\n*\n         L     #7,ZLCSTDIN\n         ST    #10,ZLFATOM\n         L     #7,ZLCSTDOU\n         ST    #10,ZLFATOM\n*\n* INITIALIZE STANDARD VARIABLES\n*\n         ST    #10,ZLCSALST        SET INITIAL SPECIAL ALIST TO NIL\n         ST    #10,ZLCFALST        SET INITIAL LEXICAL ALIST TO NIL\n         ST    #10,ZLCOBLST        SET INITIAL OBLIST TO NIL\n         LR    #6,#10              GET ADDRESS OF OBLIST\n         EJECT\n*\n* OBJECT LIST INITIALIZATION\n*\n* NOTE THAT ALTHOUGH WE ARE ADDING SYMBOLS TO THE OBLIST, THESE\n* SYMBOLS DO NOT GET ENTERED IN THE HASH TABLE.  THIS MUST BE\n* TAKEN INTO ACCOUNT WHEN USING THE VALUE IN ZLCOBCNT, WHICH\n* REPRESENTS THE MAXIMUM NUMBER OF HASH ENTRIES AVAILABLE FOR\n* INTERNING MORE SYMBOLS.\n*\n* (SETQ OBLIST (CONS NIL OBLIST)\n*\n         LR    #1,#10              GET ADDRESS OF NIL\n         LR    #2,#6               GET ADDRESS OF OBLIST\n         L     #15,ZLCCONS\n         #BASR #14,#15\n         LTR   #6,#15              LOAD NEW OBLIST POINTER\n         BZ    IACONSNG\n*\n* (SETQ OBLIST (CONS T OBLIST)\n*\n         LR    #1,#8               GET ADDRESS OF T\n         LR    #2,#6               GET ADDRESS OF OBLIST\n         L     #15,ZLCCONS\n         #BASR #14,#15\n         LTR   #6,#15              LOAD NEW OBLIST POINTER\n         BZ    IACONSNG\n         ST    #6,ZLCOBLST         SET NEW OBLIST POINTER\n*\n* Initialize the current ZIL printer to \"ZDPRINT\", the default\n* ZIL printer, and the current ZIL reader to \"ZDREAD\", the default\n* ZIL reader.\n*\n         L     #15,ZLCMODS         Get address of ZILMODS\n         USING ZMOD,#15\n         L     #14,Z@ZDPRIN        Get address of ZDPRINT pointer\n         L     #14,0(,#14)         Get address of ZDPRINT\n         ST    #14,ZLCCPRT         Set current printer address\n         L     #14,Z@ZDREAD        Get address of ZDREAD pointer\n         L     #14,0(,#14)         Get address of ZDREAD\n         ST    #14,ZLCCRDR         Set current reader address\n         DROP  #15\n*\n* INITIALIZE ALL OBJECT POINTERS IN THE LOAD MODULE.\n*\n* Note that since ZILSINT expects #12 to be the entry point of the\n* module we're using to relocate objects, we must set #12 to be the\n* entry point of the main program function.  This means that we can\n* not use #12 as a base register in this segment of code.\n*\n         ST    #12,SAVEBASE        Save base register\n         L     #12,MODPTR          Get address of code's entry point\n         DROP  #12\n         L     #1,ZLCHDADR         Get address of compiled code header\n         L     #15,ZLCSINT         Get address of ZILSINT\n         XR    #0,#0               Can't have CONS GC from this env.\n         #BASR #14,#15             Call ZILSINT to init code objects\n         USING *,#14               ON return #14 points here, right?\n         L     #12,SAVEBASE        Restore base register\n         DROP  #14\n         USING ZILINIT,#12\n*\n* OBJECT LIST INITIALIZATION IS COMPLETE.\n*\n* IF THERE'S ANYTHING ELSE TO DO, DO IT HERE.\n*\n         NI    ZLCGCFLG,255-ZLCGCINT TURN OFF ZILINIT FLAG\n*\n* NOW PERFORM MISCELLANEOUS ZIL INITIALIZATION.\n*\n         L     #15,ZLCMODS         Get address of ZILMODS\n         USING ZMOD,#15\n         L     #15,Z@ZEVINI        Get address of ZEVINIT pointer\n         DROP  #15\n         L     #15,0(,#15)         Get address of ZEVINIT\n         LA    #1,0(,#11)          Point to bottom of stack\n         #BASR #14,#15             Call ZEVINIT\n*\n* ZIL INITIALIZATION IS COMPLETE.\n*\n         EJECT\nZLRETURN DS    0H                  RETURN TO MAIN LINE\n         SPACE 1\n         L     #13,4(,#13)         RESTORE SAVE AREA\n         DROP  #13\n         SAVE  (8,11)              STORE REQUIRED ZIL REGS IN SAVEAREA\n         LM    #14,#12,12(#13)\n         XR    #15,#15             SET RETURN CODE TO ZERO\n         BR    #14                 RETURN WITH RC IN REG 15\n         EJECT\nIACONSNG DS    0H                  WHAT HAPPENS WHEN FREE LIST USED UP\nERR0001  DS    0H                  NOT ENOUGH STORAGE TO GET BY\n         L     #1,=A(ZIL0001)\n         WTO   MF=(E,(1)),ROUTCDE=11\n         ABEND 0001,DUMP\n         EJECT\nOUTNOPEN DS    0H                  STANDARD OUTPUT (ZILO) NOT THERE\n         SPACE 1\n         L     #1,=A(ZIL0005)\n         WTO   MF=(E,(1)),ROUTCDE=11\n         ABEND 0005,DUMP\n         SPACE 1\nINNOPEN  DS    0H                  STANDARD INPUT (ZILI) NOT THERE\n         L     #1,=A(ZIL0004)\n         WTO   MF=(E,(1)),ROUTCDE=11\n         ABEND 0004,DUMP\n         SPACE 1\nINSTOR   DS    0H                  ZILSUBS ALREADY LOADED...\n         L     #1,=A(ZIL0003)\n         WTO   MF=(E,(1)),ROUTCDE=11\n         ABEND 0003,DUMP\n         SPACE 1\n         DROP  #12\n         EJECT\nOUTEXIT  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* DCB OPEN EXIT FOR ZIL OUTPUT FILE.  THIS FILLS IN DCB INFO.         *\n*                                                                     *\n* NOTE: THIS EXECUTES IN AMODE 24 (I THINK).                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         PUSH  USING\n         USING DCBSTUFF,#1\nDCBSTUFF DSECT\nDSORG    EQU   DCBSTUFF+X'18',2,C'X'\nRECFM    EQU   DCBSTUFF+X'24',1,C'X'\nLRECL    EQU   DCBSTUFF+X'52',2,C'H'\nBLKSIZE  EQU   DCBSTUFF+X'3E',2,C'H'\n         SPACE 1\nZILINIT  CSECT\n         SPACE 1\n         USING OUTEXIT,#15\n         OC    DSORG,DSORG         IF NO DSORG PRESENT\n         BNZ   OXGOTDS             THEN\n         MVI   DSORG,X'40'          SET DSORG = PS\nOXGOTDS  DS    0H\n         CLI   RECFM,X'00'         IF NO RECFM PRESENT\n         BNE   OXGOTRF             THEN\n         MVI   RECFM,X'94'          SET RECFM = FBA\n         B     OXFIXED              AND PROCESS FIXED LRECL.\nOXGOTRF  DS    0H                  ELSE THERE IS A RECFM\n         TM    RECFM,X'80'         IF RECFM = V..\n         BO    OXFIXED             THEN\n         OC    LRECL,LRECL          IF THERE'S NO LRECL\n         BNZ   OXGOTLR              THEN\n         LA    #15,255               SET LRECL = 255\n         STH   #15,LRECL\n         LA    #15,3120              SET BLKSIZE = 3120\n         STH   #15,BLKSIZE\n         BR    #14                   AND RETURN.\nOXFIXED  DS    0H\n         OC    LRECL,LRECL         IF LRECL IS ZERO\n         BZ    OXSETF              THEN SET LRECL AND BLKSIZE\nOXGOTLR  OC    BLKSIZE,BLKSIZE     IF BLOCK SIZE EXISTS\n         BNZR  #14                 THEN WE ARE ALL SET\n         LA    #15,3120/80         ELSE GET DEFAULT BLOCKING FACTOR\n         MH    #15,LRECL           MULTIPLY BY LRECL\n         STH   #15,BLKSIZE         SET BLOCKSIZE\n         BR    #14\nOXSETF   DS    0H                  SET LRECL AND BLOCKSIZE\n         TM    RECFM,X'04'         IF RECFM = ..A\n         BO    OXSETFA             THEN GO TO SET VALUES FOR RECFM=FBA\n         LA    #15,80              ELSE SET LRECL = 80\n         STH   #15,LRECL\n         LA    #15,3120            AND SET BLKSIZE = 3120\n         STH   #15,BLKSIZE\n         BR    #14\nOXSETFA  DS    0H                  SET LRECL AND BLKSIZE FOR ASA CC\n         LA    #15,81               SET LRECL = 81\n         STH   #15,LRECL\n         LA    #15,3078             SET BLKSIZE = 3078\n         STH   #15,BLKSIZE\n         BR    #14                  AND RETURN.\n         SPACE 1\n         POP   USING\n         EJECT\n*\n* CONSTANTS, ETC.\n*\nPDSIZE   DC    A(0)                SIZE OF PUSH DOWN STACK\nVSSIZE   DC    A(0)                SIZE OF EACH STRING/VECTOR SPACE\nCSSIZE   DC    A(0)                SIZE OF CONS SPACE\nACSIZE   DC    A(0)                SIZE OF ACTIVE CONS SPACE\nPSSIZE   DC    A(8192)             SIZE OF PRINT STACK\nOHSIZE   DC    A(64*1024*4)        SIZE OF OBLIST HASH ARRAY, 64K WORDS\nSFSIZE   DC    A(256*8)            SIZE OF SMALL FIXNUM TABLE, 256 #'S\nOBTHRESH DC    A(50000)            MAX # OF SYMBOLS YOU CAN INTERN\nMINCSS   DC    A(1024*1024)        MINIMUM CONS SPACE SIZE = 12K\nMINVSS   DC    A(2*4096)           MINIMUM V/S SPACE SIZE * 2 = 2*4K\nDEFCSS   DC    A(4*1024*1024)      DEFAULT CONS SPACE SIZE = 4M\nDEFPDS   DC    A(64*1024)          DEFAULT PUSH DOWN STACK SIZE = 64K\nDEFACS   DC    A(2*1024*1024)      DEFAULT ACTIVE CONS SIZE = 2M\nIFPTR    DC    A(0)                ADDRESS OF INPUT FILE BLOCK CHAIN\nOFPTR    DC    A(0)                ADDRESS OF OUTPUT FILE BLOCK CHAIN\nHDRPTR   DS    A                   ADDRESS OF PROGRAM HEADER\nOPTPTR   DS    A                   ADDRESS OF OPTIONS\nMODPTR   DS    A                   ADDRESS OF MAIN MODULE\nSAVEBASE DS    A                   Place to store base reg\nTIOTZILI DC    A(0)                ADDRESS OF TIOT ENTRY FOR DD ZILI\nTIOTZILO DC    A(0)                ADDRESS OF TIOT ENTRY FOR DD ZILO\nTIOTDRIB DC    A(0)                ADDRESS OF TIOT ENTRY FOR DRIBBLE\nAREA24A  DS    A                   ADDRESS OF 24-BIT MEMORY AREA\nAREA24L  DS    A                   LENGTH OF 24-BIT MEMORY AREA\nAREA31A  DS    A                   ADDRESS OF 31-BIT MEMORY AREA\nAREA31L  DS    A                   LENGTH OF 31-BIT MEMORY AREA\n$ZILSUBS DC    CL8'ZILSUBS'\n         SPACE 1\n         DS    0F                  Model print name string for T\nMODELT   DC    YL1(##STRING),AL3(1),C'T',XL3'00'\nLMODELT  EQU   *-MODELT            Length of model print name string\n         SPACE 1\n         DS    0F                  Model print name string for NIL\nMODELNIL DC    YL1(##STRING),AL3(3),C'NIL',X'00'\nLMODELNL EQU   *-MODELNIL          Length of model print name string\n         SPACE 1\nTNILLEN  EQU   LMODELT+LMODELNL\n         SPACE 1\nXLOUT    DC    0F'0',X'85',AL3(OUTEXIT) EXIT LIST FOR OUTPUT DCB\n         SPACE 1\nOPENL    OPEN  (*-*),MF=L\n         SPACE 1\n         USING ZLCOMMON,#13\nPDSCODE1 B     ZLCCALPO            FIRST-LEVEL INTERFACE TO STACK OVFLO\nPDSCODE2 L     #2,ZLCPDSO          SECOND-LEVEL INTERFACE TO\n         BR    #2                   PUSH DOWN STACK OVERFLOW ROUTINE\n         DROP  #13\n         SPACE 1\n         LTORG\n         SPACE 1\nTEMPSAVE DS    18F                 TEMPORARY SAVE AREA\n         SPACE 1\n*\n* DEFAULT TERMINAL OUTPUT TRANSLATE TABLE\n* NOTE: THIS IS COPIED INTO A BUFFER ACCESSIBLE FROM THE\n* COMMON AREA. IT MAY BE MODIFIED AT ANY TIME.\n*\nTRMTRTBL DC    X'007A7A7A7A7A7A7A7A7A7A7A7A7A7A7A'\n         DC    X'7A7A7A7A7A7A7A7A7A7A7A7A7A7A1E7A'\n         DC    X'7A7A7A7A247A7A7A7A7A7A7A7A7A7A7A'\n         DC    X'7A7A7A7A7A7A7A7A7A7A7A7A7A7A7A7A'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'808182838485868788898A8B8C8D8E8F'\n         DC    X'909192939495969798999A9B9C9D9E9F'\n         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCD7A7A'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDC7A7A7A'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBEC7A7A7A'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFD7A7A'\n         SPACE 1\nINDDDCB  DCB   DDNAME=ZILI,                                            X\n               MACRF=GL,                                               X\n               DSORG=PS,                                               X\n               RECFM=FB\n*                         NOTE - NO EODAD. THIS IS SET BY EXEC MODULES.\nOUTDDDCB DCB   DDNAME=ZILO,                                            X\n               MACRF=PL,                                               X\n               DSORG=PS,                                               X\n               EXLST=XLOUT\nDRIBLDCB DCB   DDNAME=ZILDRIBL,                                        X\n               MACRF=PL,                                               X\n               DSORG=PS,                                               X\n               RECFM=FB,                                               X\n               LRECL=80,                                               X\n               BLKSIZE=6160\nINDD     EQU   INDDDCB+40,8,C'C'   DDNAME OF STANDARD INPUT FILE\nOUTDD    EQU   OUTDDDCB+40,8,C'C'  DDNAME OF STANDARD OUTPUT FILE\nDRIBLDD  EQU   DRIBLDCB+40,8,C'C'  DDNAME OF STANDARD DRIBBLE FILE\n         SPACE 1\nZIL0001  WTO   ROUTCDE=11,MF=L,                                        X\n               'ZIL0001 NO STORAGE AVAILABLE FOR ZIL INITIALIZATION.'\nZIL0002  WTO   ROUTCDE=11,MF=L,                                        X\n               'ZIL0002 SYNTAX ERROR IN PARAMETER FIELD, INITIALIZATIONX\n                PARAMETERS IGNORED.'\nZIL0003  WTO   ROUTCDE=11,MF=L,                                        X\n               'ZIL0003 ZIL ALREADY LOADED, RECURSIVE INVOCATION NOT ALX\n               LOWED.'\nZIL0004  WTO   ROUTCDE=11,MF=L,                                        X\n               'ZIL0004 STANDARD INPUT FILE \"ZILI\" NOT AVAILABLE, CANNOX\n               T BE OPENED.'\nZIL0005  WTO   ROUTCDE=11,MF=L,                                        X\n               'ZIL0005 STANDARD OUTPUT FILE \"ZILO\" NOT AVAILABLE, CANNX\n               OT BE OPENED.'\n         SPACE 1\n         #ZCOM   ,                 MAP THE COMMON AREA\n         #ZSFT   ,                 MAP THE SMALL FIXNUM TABLE\n         #ZHDR   ,                 MAP THE HEADER OF THE MAIN PROCEDURE\n         #ZSUB   ,                 MAP THE SUBROUTINE POINTERS\n         #ZMOD   ,                 MAP THE ZIL MODULES TABLE\n         EJECT\n* MORE EQUATES\nCOMLEN   EQU   (ZLCCOMLN+7)/8*8    LENGTH OF COMMON AREA UP TO DOUBLEWD\nPNAMET   EQU   COMLEN              OFFSET OF PRINT NAME OF T\nPNAMENIL EQU   PNAMET+LMODELT      OFFSET OF PRINT NAME OF NIL\nVSSOFF   EQU   PNAMENIL+LMODELNL   OFFSET OF VECTOR/STRING SPACE\nMIN24    EQU   VSSOFF+2*4096       MINIMUM LENGTH FOR 24-BIT STORAGE\nTSIZE    EQU   #SFT-#SFTD          BETWEEN ADDR OF T AND SMALL FIXNUMS\n         EJECT\n         AIF   (NOT &ZILTSO).NOCPPL\n         IKJCPPL ,\n.NOCPPL  ANOP\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILINTLN": {"ttr": 14088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x88\\x11\\x0f\\x00\\x89\\x15o\\x11S\\x00\\xdb\\x00\\xbf\\x00\\xdb\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1988-04-19T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 219, "newlines": 191, "modlines": 219, "user": "SEB1525"}, "text": "         TITLE 'ZILINTLN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILINTLN takes one integer argument.  Alias for INTEGER-LENGTH.     *\n*                                                                     *\n* Common Lisp complete.                                               *\n*                                                                     *\n* Scalar and vector versions.                                         *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILVF\nZILINTLN #ZBEG MINARGS=1,MAXARGS=1,NAME='INTEGER-LENGTH'\n*---------------------------------------------------------------------*\n* Calculate the number of significant bits in the integer.  For       *\n* positive integers, this is the number of bits up to and including   *\n* the leftmost \"1\" bit.  For negative numbers in 2's complement, it   *\n* is the number of bits up to and including the leftmost \"0\" bit.     *\n* In this scheme, the integers 0 and -1 are held to have 0 length.    *\n*                                                                     *\n* In the scalar version, speed is biased towards the smaller fixnums  *\n* by searching for the leftmost significant bit by searching from     *\n* the right.                                                          *\n*                                                                     *\n* Two observations will explain some of the shortcuts in the code.    *\n* First, by inverting all the bits in a negative 2's complement       *\n* number, the problem is converted into a positive number which will  *\n* always have the same INTEGER-LENGTH.  Second, the INTEGER-LENGTH    *\n* of a negative number can be determined from the sign-and-magnitude  *\n* representation if you note the simple exception that a number that  *\n* is a power of 2 has an INTEGER-LENGTH one less than the positive    *\n* number of the same magnitude.                                       *\n*                                                                     *\n* The difference in speed between the vector and scalar versions      *\n* is always marginal on an IBM 3090.  For small fixnums, the scalar   *\n* version is actually a tiny bit faster, due to the bias to small     *\n* numbers, but the vector version should generally be implemented     *\n* for machines that have IBM/370 Vector Facilities because the        *\n* potential speedup of the vector hardware in future products is      *\n* greater than the speedup of the scalar instructions used to do the  *\n* job, which are already fast 1-cycle instructions on the IBM 3090.   *\n*                                                                     *\n* The vector instruction VCZVM does exactly what we want.  We should  *\n* stick to that rather than second-guessing hardware bottlenecks      *\n* and programming around them.  As an example, when going from the    *\n* IBM 3084 to the IBM 3090, the double-shift scalar instructions      *\n* speeded up from about 5 cycles to 1 cycle, while the single-shift   *\n* instructions were the same number of cycles.  Thus, anyone who      *\n* simulated certain uses of double shifts in alternate ways because   *\n* of the slow speed of the double-shift, got screwed and can't get    *\n* the benefit now that the double-shifts are speeded up on the IBM    *\n* 3090.                                                               *\n*---------------------------------------------------------------------*\n         AIF   (&ZILVF).VFIX\n*---------------------------------------------------------------------*\n* Scalar version.                                                     *\n*---------------------------------------------------------------------*\n         L     #7,0(,#1)           Load argument\n         XR    #5,#5               Clear, need this for many paths\n         CLI   ##TYPE(#7),##FIXNUM Is arg a fixnum?\n         BNE   NF                  Branch if not fixed\n*\nF        ICM   #6,B'1111',##CDR(#7) Load fixnum and check sign\n         BP    FPLOOP              Go fixnum-positive processing\n         BZ    FZ                  Fixnum is zero, no count\nFM       X     #6,#SFWM1           It's negative, invert bits\n         BZ    FZ                  Fixnum is -1, no count\nFPLOOP   SRA   #6,1                Have at least one 1, pop it out\n         LA    #5,8(,#5)           Count by 1 in small fixnum table\n         BNZ   FPLOOP              We have more bits to count\n         LA    #15,#SFT(#5)        Point to correct number in SFT\n         BR    #14                 Return to caller\n*\nFZ       LA    #15,#SFT            Point to 0 in SFT\n         BR    #14                 Return to caller\n*---------------------------------------------------------------------*\n* Scalar version.  Continue here if not a fixnum.  Note that a faulty *\n* bignum with a leading 0 word will loop forever at label MORE.       *\n*---------------------------------------------------------------------*\nNF       CLI   ##TYPE(#7),##BIGNUM Is arg a bignum?\n         BNE   ERROR1              Branch if not fixed\n         ICM   #5,B'0111',1(#7)    Load bignum length\n         LR    #2,#5               Make extra copy of bignum length\n         L     #6,##VECDAT-4(#5,#7) Get most significant word\n         SRA   #2,2                /4, change bytes to words\n         MH    #2,=H'31'           *31, words to bits, max possible\n         SLA   #6,1                Shift out a bit on the left\n         BO    COUNTED             Most significant bit shifted out\nMORE     SLA   #6,1                Shift out another bit on the right\n         BCTR  #2,0                Decrease count of bits\n         BNO   MORE                More bits need to be examined\nCOUNTED  TM    ##VECDAT(#7),X'80'  Test sign of bignum\n         BZ    RETNUM              Bignum is positive, continue\n         LTR   #6,#6               Was 1-bit the only 1-bit?\n         BZ    BMPOWER2            Negative bignum is power of 2\n*\nRETNUM   CL    #2,ZLCSFTHI         Is answer in small fixnum table?\n         BH    FCONS               No?  Must cons up a new fixnum\n         SLL   #2,3                *8 for offset in SFT\n         LA    #15,#SFT(#2)        Calculate small fixnum table addr\n         BR    #14                 Return to caller\n*\nFCONS    LR    #6,#14              Save return address\n         #MKAT FIXED               Cons up a fixnum\n         BR    #6                  Return to caller\n*\nBMPOWER2 LA    #4,##VECDAT(,#7)    Address of bignum data area\n         SH    #5,=H'4'            Bignum length less highest word\n         LA    #6,=X'80'           First byte for compare\n         LA    #7,1                Length of first byte before 0 pad\n         CLCL  #4,#6               Are all lower words 0 in bignum?\n         BNE   RETNUM              Was 1-bit found below highest word?\n         BCTR  #2,0                Decrease count by 1 if power of 2\n         B     RETNUM              OK, compensated for power of 2\n*=====================================================================*\n         AGO   .CONTIN1\n.VFIX    ANOP\n*---------------------------------------------------------------------*\n*  Vector version of ZILINTLN.                                        *\n*                                                                     *\n*  The vector mask instructions are used to count the zeroes to the   *\n*  left of the leftmost 1 in the fixnum (highest word if bignum)      *\n*  This is then subtracted from the maximum number of bits the        *\n*  word could have contained (highest word for bignum).  (For         *\n*  bignums, the number of bits below the highest word are computed    *\n*  and added to the count.  For negative bignums, a check is made in  *\n*  the same was as in the scalar version, for an exact multiple of 2, *\n*  in which case the bit count must be reduced by 1.  For negative    *\n*  fixnums, the vector mask is complemented as it is loaded, to       *\n*  convert the problem to being the same as the positive case.        *\n*---------------------------------------------------------------------*\n         L     #7,0(,#1)           Load argument\n         XR    #5,#5               Clear, need this for many paths\n         CLI   ##TYPE(#7),##FIXNUM Is arg a fixnum?\n         VRCL  0                   Clear vector interrupt index\n         BNE   NF                  Branch if not fixed\n*\nF        TM    ##CDR(#7),X'80'     Test sign of fixnum\n         LA    #4,32               Number of bits to test in vec loop\n         LA    #6,##CDR(,#7)       Make pointer to fixnum quantity\n         BO    FM                  Special processing if fixnum negativ\n         VLVCU #4                  Set vector count to # of bits\nFPZLOOP  VLVM  #6                  Load a section of bits\n         VCZVM #5                  Count the left contiguous 0-bits\n         VLVCU #4                  Update vector count\n         BC    3,FPZLOOP           More bits?\n         LCR   #5,#5               Take negative, need 32-(#5)\n         SLA   #5,3                Convert to displacement in SFT\n         LA    #15,#SFT+32*8(#5)   Add to address of 32 (total bits)\n         BR    #14                 Return position of leftmost 1\n*\nFM       VLVCU #4                  Set vector count to # of bits\nFMLOOP   VLCVM #6                  Load complement of section of bits\n         VCZVM #5                  Count the left contiguous 0-bits\n         VLVCU #4                  Update vector count\n         BC    3,FMLOOP            More bits?\n         LCR   #5,#5               Take negative, need 32-(#5)\n         SLA   #5,3                Convert to displacement in SFT\n         LA    #15,#SFT+32*8(#5)   Add to address of 32 (total bits)\n         BR    #14                 Return position of leftmost 0\n*\nNF       CLI   ##TYPE(#7),##BIGNUM Is arg a bignum?\n         BNE   ERROR1              Branch if not fixed\n         XR    #2,#2               Clear for loading 3-byte length\n         ICM   #2,B'0111',1(#7)    Load bignum length\n         LA    #4,32               Number of bits to examine\n         LR    #3,#2               Save bignum length for later\n         LA    #6,##VECDAT-4(#2,#7) Get most significant word\n         VLVCU #4                  Set vector count to # of bits\nBLOOP    VLVM  #6                  Load a section of bits\n         VCZVM #5                  Count the left contiguous 0-bits\n         VLVCU #4                  Update vector count\n         BC    3,BLOOP             More bits?\n         SRA   #2,2                /4, change bytes to words\n         L     #6,##VECDAT-4(#3,#7) Get most significant word\n         BCTR  #5,0                Don't include bit 0 of VCZVM count\n         MH    #2,=H'31'           *31, words to bits, max possible\n         SLL   #6,2(#5)            Shift out the leftmost 1 to left\n         SLR   #2,#5               Position of leftmost 1 in bignum\nCOUNTED  TM    ##VECDAT(#7),X'80'  Test sign of bignum\n         BZ    RETNUM              Bignum is positive, continue\n         LTR   #6,#6               Was leftmost 1-bit the only 1-bit?\n         BZ    BMPOWER2            Is negative bignum power of 2?\n*\nRETNUM   CL    #2,ZLCSFTHI         Is answer in small fixnum table?\n         BH    FCONS               No?  Must cons up a new fixnum\n         SLA   #2,3                *8 for offset in SFT\n         LA    #15,#SFT(#2)        Small fixnum\n         BR    #14                 Return to caller\n*\nFCONS    LR    #6,#14              Save return address\n         #MKAT FIXED               Cons up a fixnum\n         BR    #6                  Return to caller\n*\nBMPOWER2 LA    #4,##VECDAT(,#7)    Address of bignum data area\n         LR    #5,#3               Get bignum length for CLCL\n         ICM   #5,B'0111',1(#7)    Load bignum length\n         SH    #5,=H'4'            Bignum length less highest word\n         LA    #6,=X'80'           First byte for compare\n         LA    #7,1                Length of first byte before 0 pad\n         CLCL  #4,#6               Are all lower words 0 in bignum?\n         BNE   RETNUM              Was 1-bit found below highest word?\n         BCTR  #2,0                Decrease count by 1 if power of 2\n         B     RETNUM              OK, compensated for power of 2\n*=====================================================================*\n.CONTIN1 ANOP\n*\n         DROP  #15\n         USING ZILINTLN,#3\n         SPACE 1\nERROR1   LR    #3,#15\n         #ERR  'Argument to INTEGER-LENGTH not an integer - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILINTN": {"ttr": 14337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x88\\x01_\\x00\\x910/ S\\x02\\n\\x01\\x8c\\x02\\n\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1991-10-29T20:53:00", "lines": 522, "newlines": 396, "modlines": 522, "user": "SEB1525"}, "text": "          TITLE 'ZILINTN - ZIL 1.3 SYMBOL INTERNMENT SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS SUBROUTINE INTERNS SYMBOLS ON THE OBLIST.                     *\n*                                                                     *\n*  THERE ARE SEVERAL CALLERS OF THIS ROUTINE IN ZIL:                  *\n*     ZILSINT                                                         *\n*     ZILABLD                                                         *\n*     MAKE-SYMBOL (?)                                                 *\n*  EACH HAS ITS OWN REQUIREMENTS FOR THIS ROUTINE.                    *\n*                                                                     *\n*  ENHANCED WITH AN EXTERNAL HASH TABLE AS A PERMANENT SOLUTION       *\n*  TO THE EXCEEDINGLY LONG INTERNING TIME.  THE TABLE HAS 65536       *\n*  ENTRIES.  SPACE IS FOUND FOR NEW ITEMS BY SIMPLY INCREMENTING      *\n*  UNTIL A FREE SLOT IS FOUND. ALSO, THE A SEARCH IS STOPPED AT THE   *\n*  FIRST FREE SLOT.  THIS WORKS BECAUSE ITEMS ARE ADDED TO THE TABLE  *\n*  BUT NEVER REMOVED.                                                 *\n*                                                                     *\n*  ===> INCLUDE MORE IN RETURNST, UPDATE COUNT BEFORE STORE           *\n*                                                                     *\n*  ===> INCLUDE MAXIMUM INITIAL COUNT IN ERROR MESSAGE                *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 05/22/89 - New bit in compiled code symbol header means that the    *\n*            symbol is not to be interned.  This routine will skip    *\n*            the interning process for such symbols.                  *\n*                                                                     *\n* 10/29/91 - Fix bug causing invalid object in VSS.  Occurs when GC   *\n*            required when building symbol after print name has been  *\n*            consed up.  The fix involves a novel technique for       *\n*            insuring that the print name pointer gets relocated,     *\n*            since it would be a hassle to come up with a stack slot. *\n*                                                                     *\n***********************************************************************\n*\nZILINTN  #ZBEG NAME='ZILINTN'\n         DROP  #15\n         STM   #12,#7,SAVEREGS-ZILINTN(#15) SAVE REGS IN OUR OWN PLACE\n         LR    #12,#15\n         USING ZILINTN,#12\n         OI    ZLCGCFLG,ZLCGCBLD   TELL CONS WE'RE OK\n*---------------------------------------------------------------------*\n* CHECK PARAMETER REGISTERS.                                          *\n*                                                                     *\n* #0 IS ASSUMED TO BE SET UP PROPERLY FOR CONSING AT ENTRY.           *\n*                                                                     *\n* IF #7 IS <= 0, THEN:  #4 --> TEXT OF STRING TO BE INTERNED          *\n*                       #5 = LENGTH OF STRING TO BE INTERNED          *\n*                                                                     *\n* IF #7 IS NEGATIVE, THEN JUST RETURN THE PRINT NAME'S HASH CODE.     *\n* IF #7 IS ZERO, THEN ACTUALLY INTERN THE SYMBOL, MAKING A COPY OF    *\n* THE PRINT NAME AS A STRING.                                         *\n*                                                                     *\n* (THAT'S HOW ZILABLD CALLS ME)                                       *\n*                                                                     *\n* OTHERWISE, #7 POINTS TO A PAIR OF FULLWORDS IN MEMORY, OF WHICH     *\n*            THE SECOND COULD CONTAIN A PRESET HASH CODE IF THE       *\n*            APPROPRIATE FLAG IN THE FIRST WORD IS ON.                *\n*                                                                     *\n*            #6 --> THE ALREADY-PRPEPARED PRINT NAME                  *\n*                                                                     *\n* (THAT'S HOW ZILSINT CALLS ME)                                       *\n*                                                                     *\n* RETURN WITH POINTER TO SYMBOL IN #15 (OR HASH CODE IN #15)          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         LTR   #7,#7               If called with prepared print name\n         BNP   HASH                then...\n         XR    #5,#5                 CLEAR INSERT REGISTER\n         LA    #4,##VECDAT(,#6)      SET ADDRESS-OF-TEXT REGISTER\n         ICM   #5,7,1(#6)            SET LENGTH-OF-TEXT REGISTER\n         TM    ##FWBYTE(#7),##FWGSYM If this symbol not to be interned\n         BO    NOINTERN              then skip interning procedure\n         TM    ##FWBYTE(#7),##FWHASH if there's a preset hash code\n         BZ    HASH                  then\n*\n* Wait! Don't you have to check the version number of the hashing\n* algorithm first?\n*\n         L     #6,##FWWD2(,#7)        load it\n         B     COOKHASH               and go use it\nHASH     DS    0H                  #4 AND #5 SET UP FOR PRINT NAME HASH\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This is the hashing algorithm.  Note that the compiler may be using *\n* this by calling SXHASH, which MUST call ZILINTN to get the correct  *\n* hash value for a print name.  Therefore, don't change this hashing  *\n* algorithm unless a mechanism exists for checking the version of the *\n* algorithm that generated the hash code, so that code compiled with  *\n* hash algorithm A can still work with a ZILINTN using algorithm B.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LH    #15,=H'-4'          DECREMENT AMOUNT FOR BXH\n         LR    #2,#5               MAKE ANOTHER COPY OF STR LENGTH\n         AR    #2,#15              INDEX TO LAST WORD IN STRING\n         LR    #14,#5              COMPUTE STRING LENGTH * 32\n         SLL   #14,5                SO THAT IF LENGTH IS 4 OR LESS WE\n         BNP   LEN01234(#14)         DO COMPUTED BRANCH BASED ON LENGTH\n         L     #6,0(#2,#4)         ELSE GET LAST 4 BYTES OF STRING\n         NR    #2,#15              MAKE LENGTH A MULTIPLE OF 4\n         SLL   #6,1                SO THAT XORING WITH ITSELF NOT 0\nXLOOP    X     #6,0(#2,#4)         XOR NEXT WORD\n         BXH   #2,#15,XLOOP        HAVEN'T REACHED FIRST WORD?\n         LR    #2,#6               MAKE ANOTHER COPY\n         SRL   #2,12               MOVE DOWN MOST SIGNIFICANT CHARS.\n         SLL   #6,2                MAKE IT A MULTIPLE OF 4\n         XR    #6,#2               COMBINE CHAR 0,1 AND 2,3\n         B     COOKHASH            #6 HAS RAW HASH CODE, GO FIX IT UP\n*\n* COMPUTED BRANCH AREAS 32 BYTES APART\n*\nLEN01234 DS    0H\nE0       DS    0H                  SYMBOL NAME LENGTH = 0\n*\n         XR    #6,#6               MAKE HASH CODE 0 FOR NO LENGTH\n         B     COOKHASH            THE SIMPLEST HASH CODE OF ALL!\n*\n         ORG   LEN01234+32\nE1       DS    0H                  SYMBOL NAME LENGTH = 1\n*\n         XR    #6,#6               CLEAR FOR INSERT OF SINGLE LETTER\n         ICM   #6,B'0010',0(#4)    ONLY POSITION THAT WORKS\n         B     COOKHASH            HASH CODE GENERATED, SIMPLE EH?\n*\n         ORG   LEN01234+64\nE2       DS    0H                  SYMBOL NAME LENGTH = 2\n*\n         L     #6,0(,#4)           LOAD TWO BYTES\n         SRL   #6,16               SQUEEZE OUT UNKNOWN BYTES\n         SLL   #6,2                MUST BE MULTIPLE OF 4\n         B     COOKHASH            HASH CODE GENERATED, STRAIGHT VALUE\n*\n         ORG   LEN01234+96\nE3       DS    0H                  SYMBOL NAME LENGTH = 3\n*\n         L     #6,0(,#4)           CLEAR FOR INSERT OF 3 LETTERS\n         SRL   #6,8                MUST BE MULT OF 4 AND < 2**18\n         LR    #14,#6              MAKE TEMPORARY COPY\n         SRL   #14,11              SHIFT BY STRANGE AMOUNT\n         XR    #6,#14              COMBINE UPPER CHAR WITH LOW CHARS\n         SLL   #6,2                MAKE IT A MULTIPLE OF 4\n         B     COOKHASH\n*\n         ORG   LEN01234+128\nE4       DS    0H                  SYMBOL NAME LENGTH = 4\n*\n         L     #6,0(,#4)           LOAD ALL 4 LETTERS\n         LR    #2,#6               MAKE ANOTHER COPY FOR XOR OVERLAY\n         SRL   #2,14               SHIFT UPPER 2 BYTES TO LOWER POS.\n         XR    #6,#2               HASH THE TWO\n         SLL   #6,2                MAKE IT A MULTIPLE OF 4\n*\n* #6 CONTAINS THE RAW HASH CODE. MUST BE MULTIPLE OF 4 AND < 2**18\n*\nCOOKHASH DS    0H\n         LTR   #7,#7               If #7<0 (called for hash code only)\n         BNM   NOTJUSTH            then...\n         LR    #15,#6               put raw hash code in #15\n         B     RETURN               and return with it\nNOTJUSTH DS    0H                  Else using hash code\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Before proceeding, check that the size of the hash array is what    *\n* we are assuming it to be.  If not, then this system is bogus.       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLC   =F'65536',ZLCOBDIM  DO WE AGREE WITH COMMON AREA?\n         BNE   ERROR2              ERROR IF WE DON'T AGREE\n         N     #6,=X'0003FFFC'     Make it modulo 64K, assuming obsize\n         L     #7,ZLCOBHSH         GET BEGINNING OF HASH TABLE\n         TM    ZLCGCFLG,ZLCGCINT   IF CALLED BY ZILINIT\n         BO    CONSIT2             THEN NO SEARCH REQUIRED\n*\n*---------------------------------------------------------------------*\n* #4 -> TEXT                                                          *\n* #5 = LENGTH                                                         *\n*                                                                     *\n* NOTE: NO PRE-CHECK FOR T OR NIL REQUIRED.  WE ARE GUARANTEED NEVER  *\n*       TO BE CALLED TO INTERN T OR NIL.                              *\n*---------------------------------------------------------------------*\n         LR    #14,#5              GET LENGTH OF TEXT TO SEARCH FOR\n         ICM   #14,B'1000',=YL1(##STRING) MAKE #14 LOOK LIKE PNAME HDR\n         CH    #5,=H'256'          IF LENGTH GREATER THAN 256\n         BH    OBLOOP2             THEN DO CLCL-BASED SEARCH\n         LTR   #15,#5              TEST LENGTH OF TEXT TO SEARCH FOR\n         BZ    OBLOOP0             IF ZERO, DO SEARCH FOR NULL SYMBOL\n         BCTR  #15,0               ELSE REDUCE LENGTH FOR CLC INSTR.\n         STC   #15,CLCPNAME+1      ZAP CLC INSTRUCTION WITH THAT LENGTH\n         B     OBLOOP1             GO DO CLC LOOP FOR OBLIST SEARCH\n*\nOBLOOP0X LA    #6,4(,#6)           GET NEXT SYMBOL POINTER\n         N     #6,=X'0003FFFC'     ENSURE ARRAY WRAPAROUND\nOBLOOP0  L     #15,0(#6,#7)        LOAD SYMBOL POINTER FROM HASH ARRAY\n         LTR   #15,#15             ZERO INDICATES SEARCH CAN STOP\n         BZ    NOTONOB             THEN THIS ATOM IS NOT INTERNED YET\n         L     #2,##PNAME(,#15)    GET PRINT NAME OF THAT SYMBOL\n         CL    #14,0(,#2)          TEST LENGTH OF THE PRINT NAME\n         BNE   OBLOOP0X            THEN SKIP THIS ONE, CONTINUE\n         B     RETURN              IF = OURS, NULL SYMBOL IS INTERNED\n*\nOBLOOP1X LA    #6,4(,#6)           INCREMENT HASH ARRAY POINTER\n         N     #6,=X'0003FFFC'     ENSURE ARRAY WRAPAROUND\nOBLOOP1  L     #15,0(#6,#7)        LOAD SYMBOL POINTER FROM HASH ARRAY\n         LTR   #15,#15             ZERO INDICATES SEARCH CAN STOP\n         BZ    NOTONOB             THEN THIS ATOM IS NOT INTERNED YET\n         L     #2,##PNAME(,#15)    GET PRINT NAME OF THAT SYMBOL\n         CL    #14,0(,#2)          IF LENGTH DOESN'T MATCH OURS\n         BNE   OBLOOP1X            THEN SKIP THIS ONE, CONTINUE\nCLCPNAME CLC   ##VECDAT(*-*,#2),0(#4) COMPARE PRINT NAME TEXT\n         BNE   OBLOOP1X            PRINT NAME WASN'T IDENTICAL\n         B     RETURN              IF EQUAL, SYMBOL ALREADY INTERNED\n*\nOBLOOP2X LA    #6,4(,#6)           INCREMENT HASH ARRAY POINTER\n         N     #6,=X'0003FFFC'     ENSURE ARRAY WRAPAROUND\nOBLOOP2  L     #15,0(#6,#7)        LOAD SYMBOL POINTER FROM HASH ARRAY\n         LTR   #15,#15             ZERO INDICATES SEARCH CAN STOP\n         BZ    NOTONOB             THEN THIS ATOM IS NOT INTERNED YET\n         L     #2,##PNAME(,#15)    GET PRINT NAME OF THAT SYMBOL\n         CL    #14,0(,#2)          IF LENGTH DOESN'T MATCH OURS\n         BNE   OBLOOP2X            THEN SKIP THIS ONE, CONTINUE\n         LR    #3,#5               GET LENGTH FOR CLCL\n         LA    #2,##VECDAT(,#2)    ELSE POINT TO TEXT OF SYMBOL'S NAME\n         LR    #1,#3               GET LENGTH FOR CLCL\n         LR    #0,#4               GET ADDRESS FOR CLCL\n         CLCL  #2,#0               COMPARE PRINT NAMES\n         BNE   OBLOOP2X            PRINT NAMES WEREN'T IDENTICAL\n         B     RETURN              IF EQUAL, SYMBOL ALREADY INTERNED\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* This section of code gets executed when it is determined that no    *\n* search for an existing symbol is required (i.e. call is during      *\n* ZILINIT processing).  Just find the first zero slot in the hash     *\n* table starting from the location determined by the hash code.       *\n* A new symbol will always have to be consed up.                      *\n*                                                                     *\n* Note: The branch-in is to CONSIT2; CONSIT2X is looped back to only. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*---------------------------------------------------------------------*\n* FIND FIRST EMPTY SLOT IN HASH ARRAY AT OR AFTER THE HASH INDEX      *\n* LOCATION.                                                           *\n*---------------------------------------------------------------------*\nCONSIT2X LA    #6,4(,#6)           GET NEXT HASH ARRAY LOCATION\n         N     #6,=X'0003FFFC'     ENSURE HASH ARRAY WRAPAROUND\nCONSIT2  L     #15,0(#6,#7)        LOAD SYMBOL POINTER FROM HASH ARRAY\n         LTR   #15,#15             ZERO INDICATES EMPTY SLOT FOUND\n         BNZ   CONSIT2X            NOT AN EMPTY SLOT, CHECK NEXT ONE\n*                                  When empty slot found, use it\nNOTONOB  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Symbol determined to be not on oblist - build a new symbol          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*---------------------------------------------------------------------*\n* IF #3 (I.E.#7 ON INPUT) = 0, WE MUST CONS UP A STRING AND A SYMBOL. *\n* OTHERWISE, WE MUST CONS UP A SYMBOL ONLY - THE STRING EXISTS.       *\n*---------------------------------------------------------------------*\n         ICM   #3,B'1111',SAVER7   #3 = #7 on input\n         BP    GETPNAME            If positive, we have a print name\n*                                  Otherwise we must build a print name\n*---------------------------------------------------------------------*\n* MAKE A NEW PRINTNAME                                                *\n* CONS UP A PRINT NAME STRING. REQUIRED LENGTH (#5)+4,ROUNDED UP BY 4.*\n*---------------------------------------------------------------------*\nNEWPNAME L     #0,SAVER0           GET #0, STACK POINTER FOR CONS\n         LTR   #5,#5               IF TEXT IS NULL\n         BNZ   GETPNLEN            THEN...\n         LA    #3,4                 SET STRING LENGTH TO 8\n         B     GOTPNLEN            ELSE...\nGETPNLEN LA    #3,3(,#5)           GET LENGTH NEEDED FOR STRING\n         N     #3,=X'FFFFFFFC'     ROUND UP TO FULLWORD BOUNDARY\nGOTPNLEN L     #15,ZLCVSADR        GET ADDRESS OF VECTOR/STRING SPACE\n         A     #15,ZLCVSLEN        PLUS LENGTH = ADDR OF END OF IT\n         L     #2,ZLCVSNXT         GET ADDRESS OF NEXT AVAILABLE SLOT\n         LA    #1,4(#3,#2)         GET POINTER TO WHERE OURS WILL END\n         CR    #1,#15              IF OURS GOES PAST AVAILABLE AREA\n         BH    NOROOM              THEN NO ROOM - GO TO FIND SOME MORE\n         ST    #14,0(,#2)          SET TYPE AND LENGTH OF NEW STRING\n         ST    #1,ZLCVSNXT         ELSE UPDATE SLOT POINTER TO AFT OURS\n         LA    #14,##VECDAT(,#2)   POINT TO TEXT OF NEW STRING\n         LR    #15,#3              GET LENGTH OF NEW STRING AREA\n         MVCL  #14,#4              MOVE OUR TEXT TO NEW STRING\n         LR    #4,#2               Make #4 point to print name string\n         B     GOTPNAME            Go with newly built print name\n         SPACE 1\nGETPNAME DS    0H                  Here if PNAME provided by caller\n         L     #4,SAVER6           Load address of caller's print name\nGOTPNAME DS    0H                  Now we have PNAME <- #4\n         L     #0,SAVER0           Get stack pointer for consing\nGOTPN2   DS    0H                  Retry point in case GC necessary\n         L     #15,ZLCVSADR        Get address of vector/string space\n         A     #15,ZLCVSLEN        plus length = address of end of it\n         L     #2,ZLCVSNXT         Get address of next available slot\n         LA    #5,##SYMLEN(,#2)    Get pointer to slot + symbol length\n         CR    #5,#15              If available area not big enough\n         BH    NOROOM2             then no room - go to find some more\n         MVC   0(##SYMLEN,#2),ZLCNSYM Initialize symbol from template\n         ST    #4,##PNAME(,#2)     PNAME word = address of PNAME string\n*\n* debug\n*\n*        CLI   0(#4),##STRING      If print name is not a string\n*        BNE   BADPNAM2            then error\n*\n* end debug\n*\n*\n* (Eventually the package pointer must be passed to ZILINTN somehow!)\n*\n         ST    #8,##PPKG(,#2)      Set package cell to T (interned)\n*\n* Also, if it's the keyword package, set value cell to self (#2)\n*\n* For the current implementation, if the print name of the smnbol\n* begins with a colon, assume it's a \"keyword\" and set the binding\n* cell of the symbol to itself, so that it will be constant.\n* Don't know who, if anyone, checks for this, but it could be\n* useful for somebody.\n*\n         CLI   ##VECDAT(#4),C':'   If symbol is a \"\"keyword\"\"\n         BNE   NOTKWD              then\n         ST    #2,##PVALUE(,#2)     set binding (value) cell to self\nNOTKWD   DS    0H\n         ST    #5,ZLCVSNXT         Update slot ptr to past symbol\n         LR    #1,#2               Arg 1 to CONS = new symbol\n         L     #2,ZLCOBCNT         Get count of hash slots left\n         BCT   #2,RETCONS          Go to add to oblist if count nonzero\n         B     ERROR3              If count went to 0, error - no slots\n*---------------------------------------------------------------------*\n*                 ADD NEW SYMBOL TO THE \"OBLIST\"\n*---------------------------------------------------------------------*\nRETCONS  ST    #2,ZLCOBCNT         STORE DECREMENTED SLOT-AVAIL COUNT\n         L     #0,SAVER0           Get stack pointer for consing\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         L     #2,ZLCOBLST         ARG 2 TO CONS = CURRENT OBLIST\n         #BASR #14,#15             CALL CONS TO ADD SYMBOL TO OBLIST\n         ST    #15,ZLCOBLST        (SETQ OBLIST (CONS SYMBOL OBLIST))\n         ST    #1,0(#6,#7)         STORE NEW SYMBOL IN HASH ARRAY\n         LR    #15,#1              GET POINTER TO SYMBOL BACK AS RETVAL\n*---------------------------------------------------------------------*\n*                 PREPARE FOR RETURN TO CALLER\n*---------------------------------------------------------------------*\nRETURN   DS    0H\n         NI    ZLCGCFLG,255-ZLCGCBLD TURN OFF SPECIAL FLAG FOR CONS\n         ST    #15,SAVER15         RESTORE REGS EXCEPT FOR #15,\n         LM    #12,#7,SAVEREGS      WHICH POINTS TO THE INTERNED SYMBOL\n         BR    #14                 RETURN TO CALLER\n*\n* debug - replace above 2 lines with:\n*\n*        ST    #15,ZLCDBL\n*        UNPK  MESSAGEX(9),ZLCDBL(5)\n*        TR    MESSAGEX(8),HEXTBL\n*        MVI   MESSAGEX+8,C'.'\n*        L     #0,##PNAME(,#15)\n*        ST    #0,ZLCDBL\n*        UNPK  MESSAGEQ(9),ZLCDBL(5)\n*        TR    MESSAGEQ(8),HEXTBL\n*        MVI   MESSAGEQ+8,C'.'\n*        LA    #1,MESSAGE\n*        LA    #0,MESSAGEL\n*        #TPUT *,(1),(0)\n*        L     #15,SAVER15\n*\n* end debug\n*\n*        LM    #12,#7,SAVEREGS      WHICH POINTS TO THE INTERNED SYMBOL\n*        BR    #14                 RETURN TO CALLER\n*\n* debug\n*\n*MESSAGE  DC    C'ZILINTN: Symbol created at '\n*MESSAGEX DC    C'XXXXXXXX'\n*         DC    C' '\n*MESSAGEP DC    C' Print name at '\n*MESSAGEQ DC    C'XXXXXXXX'\n*         DC    C' '\n*MESSAGEL EQU   *-MESSAGE\n*         DC    C'0123456789ABCDEF'\n*HEXTBL   EQU   *-256\n*\n* end debug\n*\n*---------------------------------------------------------------------*\n* Here when a symbol is to be built but not interned...               *\n*---------------------------------------------------------------------*\nNOINTERN DS    0H\n         ICM   #3,B'1111',SAVER7   #3 = #7 on input\n         L     #4,SAVER6           Load address of caller's print name\n         L     #0,SAVER0           Get stack pointer for consing\nGOTPN3   DS    0H                  Retry point in case GC necessary\n         L     #15,ZLCVSADR        Get address of vector/string space\n         A     #15,ZLCVSLEN        plus length = address of end of it\n         L     #2,ZLCVSNXT         Get address of next available slot\n         LA    #5,##SYMLEN(,#2)    Get pointer to slot + symbol length\n         CR    #5,#15              If available area not big enough\n         BH    NOROOM3             then no room - go to find some more\n         MVC   0(##SYMLEN,#2),ZLCNSYM Initialize symbol from template\n         ST    #4,##PNAME(,#2)     PNAME word = address of PNAME string\n*\n* debug\n*\n*        CLI   0(#4),##STRING      If print name is not a string\n*        BNE   BADPNAM3            then error\n*\n* end debug\n*\n         ST    #10,##PPKG(,#2)     Set package cell = NIL\n         ST    #5,ZLCVSNXT         Update slot ptr to past symbol\n         LR    #15,#2              Get address of new symbol\n         B     RETURN              Go to return with newly built symbol\n*---------------------------------------------------------------------*\n*           BUT WHAT IF THERE'S NO ROOM FOR NEW STRING?               *\n*---------------------------------------------------------------------*\nNOROOM   LTR   #0,#0               IF GC ALREADY TRIED\n         BZ    ERROR1              THEN ERROR - NO V/S SPACE AVAILABLE\n         L     #9,ZLCGCEND         FORCE GC\n         LR    #1,#10              DUMMY ARG 1 TO CONS = NIL\n         LR    #2,#10              DUMMY ARG 2 TO CONS = NIL\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS TO FORCE A GC\n         XR    #0,#0               CLEAR STACK POINTER TO PREVENT RETRY\n         LR    #14,#5              GET LENGTH OF TEXT\n         ICM   #14,B'1000',=YL1(##STRING) MAKE #14 LOOK LIKE PNAME HDR\n         B     GOTPNLEN            GO TRY AGAIN\n*---------------------------------------------------------------------*\n*           BUT WHAT IF THERE'S NO ROOM FOR NEW SYMBOL?               *\n* Note that we use the print name pointer in #4 as part of the dummy  *\n* argument, to insure that it gets updated by GC if necessary.        *\n*---------------------------------------------------------------------*\nNOROOM2  LTR   #0,#0               IF GC ALREADY TRIED\n         BZ    ERROR1              THEN ERROR - NO V/S SPACE AVAILABLE\n         L     #9,ZLCGCEND         FORCE GC\n         LR    #1,#4               DUMMY ARG 1 TO CONS = PRINT NAME\n         LR    #2,#10              DUMMY ARG 2 TO CONS = NIL\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS TO FORCE A GC\n         XR    #0,#0               CLEAR STACK POINTER TO PREVENT RETRY\n         L     #4,0(,#15)          RELOAD POSSIBLY-RELOCATED PRINT NAME\n         B     GOTPN2              GO TRY AGAIN\n*---------------------------------------------------------------------*\n*           BUT WHAT IF THERE'S NO ROOM FOR NEW UNINTERNED SYMBOL?    *\n*---------------------------------------------------------------------*\nNOROOM3  LTR   #0,#0               IF GC ALREADY TRIED\n         BZ    ERROR1N             THEN ERROR - NO V/S SPACE AVAILABLE\n         L     #9,ZLCGCEND         FORCE GC\n         LR    #1,#10              DUMMY ARG 1 TO CONS = NIL\n         LR    #2,#10              DUMMY ARG 2 TO CONS = NIL\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS TO FORCE A GC\n         XR    #0,#0               CLEAR STACK POINTER TO PREVENT RETRY\n         B     GOTPN3              GO TRY AGAIN\n*\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT FOR EFF.\n         SPACE 1\nSAVEREGS DS    12A                 REGISTER SAVE AREA\n         ORG   SAVEREGS\nSAVER12  DS    A                   REGISTER SAVE AREA\nSAVER13  DS    A                   REGISTER SAVE AREA\nSAVER14  DS    A                   REGISTER SAVE AREA\nSAVER15  DS    A                   REGISTER SAVE AREA\nSAVER0   DS    A                   REGISTER SAVE AREA\nSAVER1   DS    A                   REGISTER SAVE AREA\nSAVER2   DS    A                   REGISTER SAVE AREA\nSAVER3   DS    A                   REGISTER SAVE AREA\nSAVER4   DS    A                   REGISTER SAVE AREA\nSAVER5   DS    A                   REGISTER SAVE AREA\nSAVER6   DS    A                   REGISTER SAVE AREA\nSAVER7   DS    A                   REGISTER SAVE AREA\n         ORG   ,\n*\nERROR1   #ERR  PREFIX=NO,                                              X\n               'ZIL2300 ZILINTN: No vector/string space available to inX\n               tern symbol.'\nERROR1N  #ERR  PREFIX=NO,                                              X\n               'ZIL2300 ZILINTN: No vector/string space available to buX\n               ild uninterned symbol.'\nERROR2   L     #2,ZLCOBDIM\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2301 ZILINTN: Internal error, can''t handle oblist hX\n               ash table size of ',#2,'.'\nERROR3   #ERR  PREFIX=NO,                                              X\n               'ZIL2302 ZILINTN: More than 50,000 interned symbols.',  X\n               X'0D',                                                  X\n               'New symbol not interned, oblist hash table limit reacheX\n               d.'\n*\n* debug\n*\n*ADPNAM2 #ERR  PREFIX=NO,                                              X\n               'ZIL2303 ZILINTN: Print name of interned symbol is not aX\n                string - ',#4\n*ADPNAM3 #ERR  PREFIX=NO,                                              X\n               'ZIL2303 ZILINTN: Print name of uninterned symbol is notX\n                a string - ',#4\n*\n* end debug\n*\n*\n         LTORG\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILKERR": {"ttr": 14345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x00y\\x00v\\x00y\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 121, "newlines": 118, "modlines": 121, "user": "SEB1525"}, "text": "         TITLE 'ZILKERR - ZIL 1.3 KEYWORD ERROR HANDLING SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS MODULE IS INVOKED FROM COMPILED CODE TO HANDLE ERRORS THAT    *\n*  ARE DETECTED WHILE PROCESSING & KEY KEYWORD LISTS.                 *\n*                                                                     *\n*  REGISTERS ARE SET UP AS FOLLOWS ON ENTRY TO THIS ROUTINE:          *\n*                                                                     *\n*  #0 - ONE OF THE FOLLOWING:                                         *\n*       ZERO - IF THIS ROUTINE WAS CALLED TO SIGNAL AN INVALID LIST   *\n*              (I.E. ODD NUMBER OF VALUES IN &REST ARG)               *\n*       OTHERWISE, THE ADDRESS OF THE :ALLOW-OTHER-KEYS SYMBOL.       *\n*  #1 - IRRELEVANT EXCEPT THAT ITS CONTENTS MUST BE PRESERVED!        *\n*  #2 - THE ADDRESS OF THE KEYWORD SYMBOL THAT WAS NOT RECOGNIZED     *\n*  #3 - THE ADDRESS OF THE &REST ARG PASSED TO THE FUNCTION.          *\n*                                                                     *\n* REGISTERS #4 THROUGH #7 SHOULD NOT BE ALTERED.  IN THIS WAY THE     *\n* COMPILER NEED NOT RELOAD BASE REGISTERS FOLLOWING A GENERATED       *\n* CALL TO THIS ROUTINE.                                               *\n*                                                                     *\n* LOGIC:                                                              *\n*                                                                     *\n* IF #0 IS ZERO, AN \"INVALID KEYWORD LIST PASSED\" ERROR IS SIGNALLED. *\n* CONTROL NEVER RETURNS.                                              *\n*                                                                     *\n* IF #0 IS NONZERO, THEN THE &REST LIST IS SEARCHED A LA GETK FOR     *\n* THE :ALLOW-OTHER-KEYS KEYWORD.  IF THE VALUE OF THIS KEYWORD IS     *\n* FOUND AND IS NON-NIL, THE ERROR IS IGNORED AND CONTROL IS RETURNED  *\n* TO THE CALLER TO PROCEED.  OTHERWISE AN ERROR IS SIGNALLED AND      *\n* CONTROL NEVER RETURNS.                                              *\n*                                                                     *\n* NOTE: THE LATTER CASE WILL NEVER INVOKE THIS ROUTINE IF THE         *\n* LAMBDA LIST OF THE COMPILED FUNCTION CONTAINED &ALLOW-OTHER-KEYS.   *\n* THE COMPILER DOES NOT GENERATE A CALL TO THIS ROUTINE IN THAT CASE. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILKERR  #ZBEG NAME='ZILKERR'\n         SPACE 1\n         USING ZILKERR,#15\n         SPACE 1\n         LTR   #0,#0               IF CALLED BECAUSE OF BAD &REST LIST\n         BZ    ERROR2              THEN GO SIGNAL THAT KIND OF ERROR\n         SPACE 1\n*                                  #3 = LIST, #0 = KEYWORD\n         SPACE 1\nLOOP     DS    0H\n         CR    #3,#10              IF END OF KEYWORD LIST (NULL)\n         BE    ERROR1              THEN :ALLOW-OTHER-KEYS NOT FOUND\n         TM    ##TYPE(#3),##ATOM   IF KEYWORD (SUB)LIST ATOMIC\n         BO    ERROR2              THEN ERROR - BAD KEYWORD LIST\n         C     #0,##CAR(,#3)       IF (CAR SUBLIST) IS \"EQ\" TO KEYWORD\n         BNE   NEXT                THEN...\n         L     #3,##CDR(,#3)        GET CDR OF KEYWORD (SUB)LIST\n         TM    ##TYPE(#3),##ATOM   IF KEYWORD (SUB)LIST ATOMIC\n         BO    ERROR2              THEN ERROR - BAD KEYWORD LIST\n         C     #10,##CAR(,#3)      IF (CAR SUBLIST) IS NIL\n         BE    ERROR1              THEN OTHER KEYS NOT ALLOWED\n*                                  ELSE OTHER KEYS ARE ALLOWED, SO...\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nNEXT     DS    0H                  ELSE NOT THE ONE - CONTINUE\n         L     #3,##CDR(,#3)        GET CDR OF KEYWORD (SUB)LIST\n         TM    ##TYPE(#3),##ATOM   IF KEYWORD (SUB)LIST ATOMIC\n         BO    ERROR2              THEN ERROR - BAD KEYWORD LIST\n         L     #3,##CDR(,#3)       GET CDR OF KEYWORD (SUB)LIST\n         B     LOOP                CONTINUE PROCESSING\n         SPACE 1\nERROR1   DS    0H\n         XR    #14,#14             Indicate error number 1\n         B     ERRORS\nERROR2   DS    0H\n         LA    #14,4               Indicate error number 2\n******** B     ERRORS\nERRORS   DS    0H\n         DROP  #15\n         LR    #3,#15\n         USING ZILKERR,#3\n*\n* DUMP THE FUNCTION NAME\n*\n         XR    #1,#1               Clear insert register\n         STCM  #1,7,FUNLEN         Initialize fake string length to 0\n         IC    #1,4(,#12)          Get length of module identifier\n         SH    #1,=H'16'           Subtract length of date/time info\n         BNP   SKIPNAME            If no name, skip move\n         CH    #1,=Y(L'FUNTEXT)    If longer than maximum\n         BNH   *+8                 then\n         LA    #1,L'FUNTEXT         use maximum length\n         STCM  #1,7,FUNLEN         Store length into fake string\n         BCTR  #1,0                Reduce for execute\n         EX    #1,MVCNAME          Move function name to fake string\nSKIPNAME DS    0H\n         B     THEERROR(#14)\nTHEERROR B     THEERR1\n         B     THEERR2\n         SPACE 1\nTHEERR1  #ERR  'ZIL1304 Undefined keyword ',(#2),' passed to function 'X\n               ,FUNSTR,'.',PREFIX=NO\nTHEERR2  #ERR  'ZIL1305 Invalid keyword list passed to function ',     X\n               FUNSTR,'.',PREFIX=NO\n*\n* Sorry, can't display the bad keyword list at this time.  To do so\n* requires adding stuff to the generated compiled code.\n*\n         SPACE 1\n         SPACE 1\nMVCNAME  MVC   FUNTEXT(*-*),5(#12) Executed: move function name to str\n         SPACE 1\n         DS    0H,XL1\nFUNSTR   DC    YL1(##STRING)\nFUNLEN   DS    AL3\nFUNTEXT  DS    CL64\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILLOAD": {"ttr": 14595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00T\\x00\\x88\\x01_\\x01\\x00&_\\x17\\x19\\x01\\xae\\x01\\xa5\\x01\\xad\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:19:54", "lines": 430, "newlines": 421, "modlines": 429, "user": "SEB1525"}, "text": "         TITLE 'ZILLOAD - ZIL 1.3 SUBROUTINE LOADER'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS INVOKED BY THE EVAL/APPLY PROCESS WHEN A FUNCTION    *\n* NAME DOES NOT HAVE A FUNCTION DEFINITION ASSOCIATED WITH IT.  IT    *\n* ISSUES A SYSTEM LOAD FOR THE FUNCTION OUT OF THE TASK LIBRARY       *\n* ASSOCIATED WITH IT AND RETURNS A COMPILED CODE OBJECT AS THE VALUE  *\n* (THIS IS A SPECIAL TYPE OF LISP ENTITY WHICH IS PROCESSED VIA THE   *\n* ZILXSUB AND ZILXFUN FUNCTIONS AND IS GENERALLY STORED AS THE VALUE  *\n* OF THE \"SUBR\" PROPERTY).                                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TWO ALTERNATE ENTRY POINTS EXIST FOR THIS MODULE (THESE ARE ONLY    *\n* INTERNAL AND ARE THEREFORE NOT REQUIRED TO BE MADE KNOWN TO THE     *\n* LINKAGE EDITOR):                                                    *\n*                                                                     *\n* ZILLOADN - USED WHEN AN 8-CHARACTER MODULE NAME IS PASSED AND THE   *\n*            LOAD MODULE MUST BE LOADED.                              *\n*                                                                     *\n* ZILLOADA - USED WHEN THE LOAD MODULE ADDRESS IS KNOWN AND THE       *\n*            EXTERNAL REFERENCES MUST BE RESOLVED.                    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS RECURSIVE AND THEREFORE USES STACK SPACE.           *\n*                                                                     *\n* IT IS NOT REENTRANT, BUT IT IS REUSABLE.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* A vector table of commonly used functions (most likely to be linked *\n* in with the interpreter) used to be incorporated into this module.  *\n* It is now a separate module ZILMODS.                                *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILVPS\n         #ZSYS\n         EJECT\nZILLOAD  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILLOAD'\n         #ZPDS 16                  DEFINE INITIAL STACK SPACE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #1,0(,#11)          GET FIRST PARM\n         ST    #1,16(,#11)         STORE AS ARG\n         L     #15,@LOAD1          GET ADDRESS OF MAIN LOADER\n         LA    #1,16(,#11)         POINT TO ARG ON STACK\n         OI    ZLCIFLGS,ZLCISMC    INDICATE NON-INTERRUPTIBLE ZIL CODE\n         #BASR #14,#15             CALL THE MAIN LOADER\n         NI    ZLCIFLGS,255-ZLCISMC TURN OFF NON-INTERRUPTIBILITY FLAG\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         SPACE 1\n         CR    #15,#10             IF WE'RE RETURNING NIL,\n         BE    JUSTRET             THEN DON'T CONS UP ANYTHING.\n         LR    #1,#15              ARG 1 TO CONS = POINTER TO CODE\n         XR    #2,#2               ARG 2 TO CONS = ZEROES\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         LA    #0,16(,#11)         SET CURRENT STACK POINTER FOR CONS\n         #BASR #14,#15             CALL CONS TO MAKE A SUBR OBJECT\n         MVI   ##TYPE(#15),##SUBR  SET TYPE = ATOMIC AND SUBR\n*\n* IN FUTURE, SET OTHER TYPE BITS BASED ON WHETHER THE COMPILED CODE\n* OBJECT IS SUBR, FSUBR, MSUBR, OR LSUBR.  IGNORE FOR NOW.\n*\nJUSTRET  DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 2\n@LOAD1   DC    A(ZILLOAD1)         ADDRESS OF MAIN LOADER\n         EJECT\nZILLOAD1 DS    0H\n         NI    ZLCLDFLG,255-ZLCLDGAD-ZLCLDGNM INDICATE NORMAL ENTRY\n         LR    #15,#12             COPY BASE REG FROM FIRST LEVEL\n         B     START-ZILLOAD(,#15)\n         SPACE 2\nZILLOADN DS    0H\n         OI    ZLCLDFLG,ZLCLDGNM   INDICATE ENTRY VIA ZILLOADN W.NAME\n         NI    ZLCLDFLG,255-ZLCLDGAD\n         LR    #15,#12             COPY BASE REG FROM FIRST LEVEL\n         B     START-ZILLOAD(,#15)\n         SPACE 2\nZILLOADA DS    0H\n         OI    ZLCLDFLG,ZLCLDGAD   INDICATE ENTRY VIA ZILLOADA W.ADDR\n         NI    ZLCLDFLG,255-ZLCLDGNM\n         LR    #15,#12             COPY BASE REG FROM FIRST LEVEL\n         B     START-ZILLOAD(,#15)\n         EJECT\nSTART    DS    0H                  NOTE REG 15 -> TRUE ENTRY POINT\n         DROP  #12                 (RESTORED BY #ZSAV MACRO)\n         USING *,15 DUMMY DUMMY... DUMMY USING FOR #ZSAV MACRO\n         #ZPDS 32                  DEFINE STACK SPACE REQUIRED\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 2\n         TM    ZLCLDFLG,ZLCLDGAD   IF ENTRY VIA ZILLOADA (GOT ADDRESS)\n         BO    GOTADDR1            THEN PARM 1 -> LOAD ADDRESS\n         TM    ZLCLDFLG,ZLCLDGNM   IF ENTRY VIA ZILLOADN (GOT NAME)\n         BO    GOTNAME2            THEN PARM 1 -> NAME\n         SPACE\n         L     #2,0(,#11)          GET ADDRESS OF ARG 1 = ALPHA ATOM\n         CLI   ##TYPE(#2),##STRING IF ARG 1 IS A STRING\n         BE    ISALPHA             THEN OK\n         CLI   ##TYPE(#2),##SYMBOL IF ARG 1 IS A SYMBOL\n         BNE   BADARG1             THEN\n         L     #2,##PNAME(,#2)      GET ITS PRINT NAME\nISALPHA  DS    0H\n         XR    #15,#15             CLEAR INSERT REGISTER\n         MVI   LNAME,C' '          CLEAR LOAD MODULE NAME TO BLANKS\n         MVC   LNAME+1(7),LNAME\n         ICM   #15,7,1(#2)         GET LENGTH OF STRING\n         BZ    FINDIT              IF ZERO, USE ALL-BLANK NAME\n         CH    #15,=H'8'           IF MORE THAN 8 CHARACTER\n         BH    BADNAME             THEN ERROR\n         BCTR  #15,0               REDUCE FOR EXECUTE\n         EX    #15,MOVENAME        MOVE STRING TO LOAD MODULE NAME\n         B     FINDIT\n         SPACE 1\nMOVENAME MVC   LNAME(0),##VECDAT(#2) EXECUTED - MOVE STRING TO NAME\n         SPACE 1\nBADARG1  DS    0H                  ARG NOT A STRING OR SYMBOL\n         #TPUT 1,ZIL1009\n         LR    #15,#10\n         B     RETURN\n         SPACE 1\nBADNAME  DS    0H                  NAME WRONG LENGTH\n         #TPUT 0,ZIL1005\n         LR    #15,#10\n         B     RETURN\n         SPACE 1\nGOTNAME2 DS    0H                  ENTRY VIA ZILLOADN - PARM1 -> NAME\n         L     #2,0(,#11)          GET POINTER TO NAME\n         MVC   LNAME(8),0(#2)      MOVE NAME TO BLDL LIST\n         SPACE 1\nFINDIT   DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n* FIRST SEARCH THE TABLE OF IN-LINE CODE AND LINKED-IN MODULES TO SEE *\n* IF THE REQUESTED MODULE IS THERE.                                   *\n*                                                                     *\n* Note: This is a binary search that assumes that the length of each  *\n*       table entry is 16.                                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         XR    #3,#3               Clear entry table pointer\n         L     #0,=X'FFFFFFF0'     Constant to AND addresses with\n         L     #15,ZLCMODS         Address of ZILMODS table\n         USING ZMOD,#15\n         L     #1,ZMODSTB          Address of first module table entry\n         L     #15,ZMODETB         Address of end of module table\n         DROP  #15\nMODLOOP  DS    0H\n         LR    #2,#15              Get number of entries being searched\n         SR    #2,#1               Get distance between first & last\n         BM    MODNF               If negative, search over, not found\n         SRL   #2,1                Halve it\n         NR    #2,#0               Round down to multiple of 16\n         BZ    MODCOMP             If zero, only 1 entry, compare it\n         AR    #2,#1               Convert to address of middle entry\n         CLC   LNAME(8),4(#2)      Compare our name with entry\n         BE    MODGOT              If equal, we got the module already\n******** BL    MODLT               If less, repeat with lower half\n         BH    MODGT               If greater, repeat with upper half\nMODLT    DS    0H                  Here if our name less than entry\n         LR    #15,#2              Reset upper bound of search\n         B     MODLOOP             Continue search\nMODGT    DS    0H                  Here if our name greater than entry\n         LR    #1,#2               Reset lower bound of search\n         B     MODLOOP             Continue search\nMODCOMP  DS    0H                  Here if only one entry in table\n         LR    #2,#1               Point to the only entry\n         CLC   LNAME(8),4(#2)      Compare our name with only entry\n         BNE   MODNF               If not equal, it's not found\nMODGOT   DS    0H                  FOUND IN TABLE - WE MIGHT HAVE IT\n         ICM   #4,15,0(#2)         PICK UP ADDRESS OF CODE\n         BNZ   RESOLVE             IF RESOLVED, GO PROCESS IT.  ELSE...\n* Entry found but no module loaded...\n         LR    #3,#2               Set pointer to entry to be filled in\nMODNF    DS    0H                  NOT FOUND IN TABLE - SEARCH SYSTEM\n         EJECT\n***********************************************************************\n*                                                                     *\n* THEN, SEARCH THE LOAD LIST OF THE CURRENT TASK TO SEE IF THE MODULE *\n* IS ALREADY LOADED.                                                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* In the future, we should maintain our own queue of loaded ZIL       *\n* modules instead.  In that way we can invoke a ZIL process           *\n* recursively without fear of failure, even if not subtasking.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #15,X'21C'          ADDRESS OF CURRENT TCB\n         ICM   #15,15,X'24'(#15)   TCBLLS: ADDRESS OF LOAD LIST\nLLSLOOP  DS    0H                  IF NO MORE LOAD LIST ENTRIES\n         BZ    NOTLDED             THEN EXIT - NOT IN STORAGE\n         L     #14,4(,#15)         GET ADDRESS OF CDE FOR LLS ENTRY\n         CLC   8(8,#14),LNAME      IF MODULE NAME MATCHES\n         BE    INSTOR              THEN MODULE IS IN STORAGE\n         ICM   #15,15,0(#15)       ELSE GET NEXT LOAD LIST ENTRY\n         B     LLSLOOP\nINSTOR   DS    0H                  #14 -> CDE ENTRY FOR MODULE\n         L     #4,X'10'(,#14)      PICK UP ENTRY POINT\n         B     RESOLVE             GO TO RESOLVE EXTERNAL REFERENCES\nNOTLDED  DS    0H                  NOT IN LOAD LIST - TRY BLDL\n*\n* DO BLDL TO SEE IF IT EXISTS IN LIBRARY.  NOTE THAT THE MODULE\n* MUST BE FOUND IN THE CURRENT TASK LIBRARY (OR STEPLIB IN BATCH).\n* ON TSO THIS WILL BE THE LIBRARY SPECIFIED ON THE CALL COMMAND.\n*\n         BLDL  0,BLDLLIST\n         B     BLDLRET(#15)\nBLDLRET  B     BLDL0\n         B     BLDL4\n* BLDL RETURN CODE 8 - SOMETHING IS WRONG\n         NI    ZLCIFLGS,255-ZLCISMC  CAN'T BE NONINTERRUPTIBLE ANYMORE\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         LR    #2,#0               GET REASON CODE IN REG 2\n         B     BLDL8(#2)\nBLDL8    B     BLDL8R0\n         B     BLDL8R4\n         #TPUT 2,ZIL1008           BLDL RC=8, REASON=8\n         B     BLOWUP\nBLDL8R0  #TPUT 2,ZIL1006           BLDL RC=8, REASON=0\n         B     BLOWUP\nBLDL8R4  #TPUT 2,ZIL1007           BLDL RC=8, REASON=4\n         B     BLOWUP\n         SPACE 1\nBLDL4    DS    0H                  BLDL RC=4 - LOAD MODULE NOT FOUND\n         TM    ZLCLDFLG,ZLCLDGNM   IF  ENTRY VIA ZILLOADN W.NAME\n         BNO   NBYNAME             THEN\n         MVC   ZIL1002+8(8),LNAME  MOVE FUNCTION NAME INTO MESSAGE\n         #TPUT 2,ZIL1002           SAY FUNCTION NOT FOUND\n         B     RETNIL              ELSE\nNBYNAME  DS    0H\n         MVC   ZIL1001+8(8),LNAME  MOVE FUNCTION NAME INTO MESSAGE\n         #TPUT 1,ZIL1001           SAY FUNCTION NOT FOUND\n         B     RETNIL              RETURN NIL\nBLDL0    DS    0H\n         AIF   (&ZILVPS).NCLIZ2\n         CLI   Z,2                 MODULE MUST BE IN JOB-/STEP-/TASKLIB\n         BNE   BLDL4               OTHERWISE PRETEND IT WASN'T FOUND\n.NCLIZ2  ANOP\n         LOAD  DE=LNAME,ERRET=LOADERR\n         LR    #4,#0               GET ENTRY POINT\n* DISPLAY MESSAGE UPON SUCCESSFUL LOADING\n         MVC   NAME1010(8),LNAME\n         STCM  #4,15,ADDR1010\n         NI    ADDR1010,B'01111111' CLEAR HIGH ORDER BIT OF ADDRESS\n         UNPK  ADDR1010(9),ADDR1010(5)\n         TR    ADDR1010(8),TRTBL\n         MVI   ADDR1010+8,C'.'\n         #TPUT 0,ZIL1010           DISPLAY \"LOADED AT...\" MESSAGE\n         B     RESOLVE             GO TO RESOLVE EXTERNAL REFERENCES\n         SPACE\nGOTADDR1 DS    0H                  ENTRY VIA ZILLOADA - ALREADY HAVE IT\n         L     #4,0(,#11)          PARM IS POINTER TO CODE\n******** B     RESOLVE             GO TO RESOLVE EXTERNAL REFERENCES\n         SPACE\nRESOLVE  DS    0H                  RESOLVE EXTERNAL REFERENCES\n         STCM  #4,B'1000',TESTBYTE TEST HIGH-ORDER BYTE OF LOAD MODULE\n         NI    TESTBYTE,X'7F'      TURN OFF AMODE BIT\n         BNZ   BADRMODE            IF RMODE=ANY, ERROR\n         SPACE 1\n         LTR   #3,#3               If there is a module entry to fill\n         BZ    NOFILLEN            then\n         ST    #4,0(,#3)            store address into our table\nNOFILLEN DS    0H\n         SPACE 1\n*\n* FOR EACH LOADED MODULE, IF THERE ARE ANY UNRESOLVED EXTERNAL\n* REFERENCES THEY ARE TO BE RESOLVED DYNAMICALLY.  THIS IS A\n* RECURSIVE PROCESS.  THE HIGH-ORDER BIT OF THE ADDRESS OF THE\n* LIST OF SUBROUTINE ADDRESSES IS SET ON TO PREVENT INFINITE\n* RECURSION IN THE CASE OF MODULES THAT REFER TO EACH OTHER OR\n* TO THEMSELVES DIRECTLY OR INDIRECTLY.\n*\n         XR    #14,#14             CLEAR INSERT REG\n         IC    #14,4(,#4)          GET LENGTH OF IDENTIFIER\n         LA    #5,5+3(#14,#4)      POINT TO MODULE CODE PAST IDENTIFIER\n         N     #5,=X'FFFFFFFC'     ROUNDING UP TO NEXT FULLWORD\n         USING ZINT,#5             TO POINT TO \"ZINT\" AREA\n         TM    ZINFLAGS,ZINGSUBR   IF NO SUBRS ARE PRESENT\n         BZ    NORES               THEN EXIT WITHOUT RESOLVING\n         TM    ZINSUBRA,X'80'      ELSE IF MODULE ALREADY RESOLVED\n         BO    NORES               THEN EXIT WITHOUT RESOLVING\n         L     #3,ZINSUBRA         ELSE POINT TO START&END OF SUBRS\n         OI    ZINSUBRA,X'80'      INDICATE THIS SUBR IS PROCESSED\nRESLOOP  DS    0H                  DO FOR EACH SUBR IN LIST\n         C     #3,ZINSUBRE         UNTIL FINISHED WITH LIST\n         BNL   ENDRES\n         ICM   #2,15,0(#3)         GET ADDRESS OF SUBROUTINE\n         BZ    MUSTLOAD            IF ZERO, IT MUST BE LOADED\n         LA    #15,ZILLOADA        ELSE GET ADDRESS OF ZILLOADA\n         B     RESCALL             GO TO CALL IT\nMUSTLOAD DS    0H                  EXTERNAL MODULE MUST BE LOADED\n         LA    #2,4(,#3)           POINT TO THE NAME OF THE MODULE\n         LA    #15,ZILLOADN        GET ADDRESS OF ZILLOADN\nRESCALL  DS    0H\n         STM   #3,#5,16(#11)       PUSH CURRENT POINTERS ONTO STACK\n         ST    #2,28(,#11)         PUT ARGUMENT ON STACK\n         LA    #1,28(,#11)         POINT TO NEW STACK LOCATION\n         #BASR #14,#15             RECURSIVE INVOCATION TO RESOLVE\n         LM    #3,#5,16(#11)       RESTORE VALUES FROM STACK\n         CR    #15,#10             IF NOT RESOLVED (RESULT = NIL),\n         BNE   STOREIT             THEN\n         L     #15,=A(ZLERR)        SET ADDRESS OF ERROR ROUTINE\nSTOREIT  DS    0H                  ELSE (RESOLVED)...\n         ST    #15,0(,#3)           SET ADDRESS OF SUBROUTINE\n         LA    #3,12(,#3)          BUMP TO NEXT IN LIST\n         B     RESLOOP             CONTINUE\nENDRES   DS    0H                  END RESOLVING CODE\nNORES    DS    0H                  NO RESOLVING CODE\n         SPACE\nFINISHED DS    0H\n         LR    #15,#4              GET ENTRY POINT INTO RETURN REG\n         B     RETURN              RETURN WITH IT AS VALUE\n         SPACE\nLOADERR  DS    0H\n         CH    #1,=Y(X'106')       IF ABEND CODE WAS 106\n         BNE   NOT106C             AND\n         CH    #15,=H'12'          REASON CODE WAS C\n         BNE   NOT106C             THEN\n         LA    #1,ZIL1003           ERROR = INSUFFICIENT STORAGE\n         LA    #0,L'ZIL1003\n         B     SHOWERR\nNOT106C  DS    0H                  ELSE\n         LA    #1,ZIL1004           ERROR = SOMETHING ELSE\n         LA    #0,L'ZIL1004\n         B     SHOWERR\nBADRMODE DS    0H                  MODULE LOADED ABOVE 16MB LINE\n         LA    #1,ZIL1012           ERROR = SOMETHING ELSE\n         LA    #0,L'ZIL1012\nSHOWERR  DS    0H\n         MVC   8(8,#1),LNAME       MOVE FUNCTION NAME INTO MESSAGE\n         #TPUT 3,(1),(0)           DISPLAY SEVERE ERROR\nRETNIL   DS    0H\n         LR    #15,#10             SET RETURN TO NIL\n******** B     RETURN\n         SPACE\nRETURN   DS    0H\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\nBLOWUP   DS    0H\n         NI    ZLCIFLGS,255-ZLCISMC Turn off non-interruptibility flag\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         MVC   NAMETXT,LNAME\n         #ERR  'ZIL1014 ZILLOAD: Unable to load compiled function ',   X\n               NAMESTR,PREFIX=NO\n         SPACE 1\n         DS    0H,XL1\nNAMESTR  DC    YL1(##STRING),AL3(8)\nNAMETXT  DS    CL8\n         SPACE 1\nBLDLLIST DC    H'1',H'58'          BLDL LIST FOR FUNCTION NAME\nLNAME    DC    CL8' '              NAME OF FUNCTION FOR BLDL AND LOAD\nTTR      DS    CL3\nK        DS    CL1\nZ        DS    CL1\nC        DS    CL1\n         DS    CL44\n         DC    C'0123456789ABCDEF'\nTRTBL    EQU   *-256\n         SPACE 1\nTESTBYTE DS    C\n         SPACE 1\nZIL1001  DC    C'ZIL1001 ________ NOT FOUND ON ZIL LOAD MODULE LIBRARY.X\n               '\nZIL1002  DC    C'ZIL1002 ________ NOT FOUND, FUNCTION REFERENCE NOT RESX\n               OLVED.'\nZIL1003  DC    C'ZIL1003 ________ LOAD FAILED, NOT ENOUGH SYSTEM STORAGX\n               E.'\nZIL1004  DC    C'ZIL1004 ________ LOAD FAILED, CHECK SYSTEM MESSAGES FOX\n               R REASON.'\nZIL1005  DC    C'ZIL1005 CANNOT LOAD FUNCTION, NAME LONGER THAN 8 CHARAX\n               CTERS.'\nZIL1006  DC    C'ZIL1006 BLDL ERROR - INVALID TASK LIBRARY OR STEPLIB DX\n               D SPECIFICATION.'\nZIL1007  DC    C'ZIL1007 BLDL ERROR - NOT ENOUGH SYSTEM STORAGE.'\nZIL1008  DC    C'ZIL1008 BLDL ERROR - RETURN CODE 8, REASON CODE 8.'\nZIL1009  DC    C'ZIL1009 CANNOT LOAD FUNCTION, NAME NOT A STRING OR SYMX\n               BOL.'\nZIL1012  DC    C'ZIL1012 ________ LOAD FAILED, RMODE=ANY MODULE LOADED X\n               ABOVE 16 MB LINE.'\nMSG1010  DC    C'ZIL1010 '\nNAME1010 DC    CL8'________'\n         DC    C' LOADED AT ADDRESS '\nADDR1010 DC    CL8'________'\n         DC    C'.'\nZIL1010  EQU   MSG1010,*-MSG1010,C'C'\n         EJECT\n         LTORG\n         EJECT\nZLERR    DS    0A\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS IS A ROUTINE WHOSE ADDRESS GETS PLUGGED INTO COMPILED CODE     *\n* WHEREVER AN UNRESOLVED COMPILED CODE FUNCTION REFERENCE OCCURS.     *\n* IT DISPLAYS AN ERROR MESSAGE AND ISSUES A THROW TO TAG NIL.         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         B     ZLERR2-*(,#15)\n         DC    YL1(ZLERR1-*-1)\n         DC    C'#<UNRESOLVED COMPILED FUNCTION>'\n         DC    CL16' '\nZLERR1   EQU   *\nZLERR2   DS    0H\n         LR    #3,#15\n         DROP  #12\n         USING ZLERR,#3\n         #ERR  'ZIL1200 Call to unresolved compiled function.',        X\n               PREFIX=NO\n         SPACE 1\n         DROP  #3\n         EJECT\n         #ZINT\n         EJECT\n         #ZMOD\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILMDF": {"ttr": 14602, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00!\\x00\\x88\\x01_\\x01\\x00&_\\x17 \\x00e\\x00b\\x00d\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:20:21", "lines": 101, "newlines": 98, "modlines": 100, "user": "SEB1525"}, "text": "         TITLE 'ZILMDF - ZIL 1.3 DOUBLE FLOAT CONSING ROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This subroutine conses up a double-float.                           *\n* On entry, FPR0 contains the double-float value.                     *\n*           GPR0 is set for CONS as usual (stack pointer).            *\n* On exit, GPR15 points to the newly consed flonum object.            *\n*                                                                     *\n* This routine uses and destroys registers 14 thru 4.                 *\n*                                                                     *\n* Note:  #15 is the base reg throughout, except when an error must    *\n*        be signalled for floating-point overflow, or when CONSing.   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* The format of a double-float is:                                    *\n*                                                                     *\n*  (assuming a flonum with hex contents 4218ababcdcdefef)             *\n*                                                                     *\n*  A8000000 4218abab 4218abab cdcdefef                                *\n*                                                                     *\n* Note that the left half of the flonum is duplicated in the second   *\n* word (word 1) of the object.  This enables fast MINUSP/ZEROP hacks. *\n* If you ever decide to stop doing that, you'll have to change the    *\n* functions like MINUSP that depend on that hack.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         #ZEQU\n         #ZCOM\n         USING ZLCOMMON,#13\nZILMDF   CSECT\n         SPACE 1\n         USING ZILMDF,#15\n         SPACE 1\nFDFRETRY DS    0H\n         SPACE 1\n         LM    #1,#3,ZLCVSADR      #1 = ADR, #2 = LEN, #3 = NXT\n         LA    #4,16(,#3)          Point past end of new object\n         AR    #2,#1               Compute address of end of VSS\n         CR    #4,#2               If we don't have room\n         BH    FDFNORM             then we can't build it just yet\n         MVC   0(4,#3),HEADER      Set type bits and zeroes in word 0\n         STE   #F0,4(,#3)          Store sign info, etc. in word 1\n         STD   #F0,8(,#3)          Store double-float\n         LR    #15,#3              Else get pointer to slot\n         ST    #4,ZLCVSNXT         Update next-VSS-slot pointer\n         BR    #14                 Return with double float\n         SPACE 1\n         DS    0A\nHEADER   DC    YL1(##DFLOAT),AL3(0) Header for double float\n         SPACE 1\nFDFNORM  DS    0H                  No room to cons up new object yet\n         SPACE 1\n         LTR   #0,#0               If we already tried to get more room\n         BZ    ERRORG              then error\n         L     #9,ZLCGCEND         Else force end of \"free list\"\n         LR    #1,#10              Set dummy arg 1 to CONS = NIL\n         LR    #2,#10              Set dummy arg 2 to CONS = NIL\n         LR    #3,#15              Save base register\n         LR    #4,#14              Save return register\n         L     #15,ZLCCONS         Get address of ZILCONS\n         #BASR #14,#15             Call CONS to force a GC\n         LR    #15,#3              Restore base register\n         LR    #14,#4              Restore return register\n         XR    #0,#0               Clear #0 to prevent another GC\n         B     FDFRETRY            and try it again\n         SPACE 1\nERRORG   DS    0H                  Not enougn VSS to cons up flo-obj\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* For the purposes of this routine (and laziness), we assume that     *\n* the only callers thereof will have a \"normal\" function header       *\n* and a function name of reasonable length (i.e. 24 bytes or less).   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MVC   Z+4(24),5(#12)      Move caller's name to fake string\n         XR    #0,#0\n         IC    #0,4(,#12)          Get length of function name\n         SH    #0,=H'16'\n         STCM  #0,7,Z+1            Store length of function name\n         LR    #4,#15\n         DROP  #15\n         USING ZILMDF,#4\n         #ERR  'ZIL4103 ',Z,': Not enough vector/string space to build X\n               double-float.',PREFIX=NO\n         SPACE 1\n         DS    0H,XL1              Align to non-halfword boundary\nZ        DC    YL1(##STRING),AL3(0) Place to build function name string\n         DS    CL24\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILMODS": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x00\\x00\\x88\\x01_\\x00\\x893o\\x10X\\x02\\x06\\x01\\xd2\\x02\\x05\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-12-02T10:58:00", "lines": 518, "newlines": 466, "modlines": 517, "user": "SEB1525"}, "text": "         TITLE 'ZILMODS - ZIL 1.3 SUBROUTINE MODULE TABLE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         TITLE 'ZILMODS - INSTREAM MACROS'\n         MACRO\n&SYM     MODEXT &NAME\n         WXTRN &NAME\n&SYM     DC    V(&NAME),CL8'&NAME',F'0'\n         MEND\n         SPACE 2\n         MACRO\n&SYM     MODINT &NAME\n&SYM     DC    V(&NAME),CL8'&NAME',F'0'\n         MEND\n         TITLE 'ZILMODS - ZIL 1.3 SUBROUTINE MODULE TABLE'\n***********************************************************************\n*                                                                     *\n* A VECTOR TABLE OF COMMONLY USED FUNCTIONS (MOST LIKELY TO BE LINKED *\n* IN WITH THE INTERPRETER) IS INCORPORATED AS A \"LOOKASIDE\" LIST IN   *\n* ORDER TO PREVENT LOADING OF DUPLICATE CODE AND WASTING OF OPERATING *\n* SYSTEM MEMORY.                                                      *\n*                                                                     *\n* The in-line table of subroutines has been extended with most        *\n* built-in ZIL functions, whether or not they are actually linked     *\n* with the mainline.  This is done by means of weak external          *\n* references for those which we don't want resolved unless they're    *\n* already there.  A binary search is done by ZILLOAD to locate        *\n* entries in this table.                                              *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 11/08/88 - Support for enhanced ZIL reader.  See macro #ZMOD.       *\n*                                                                     *\n***********************************************************************\n*\n         EJECT\nZILMODS  CSECT\n         DC    A(STABLE)           Address of start of table\n         DC    A(ETABLE)           Address of end of table\n         SPACE 1\n*\n* Pointers into the table to locate commonly needed modules follow.\n*\n         SPACE 1\n@@ZEVINI DC    A(@ZEVINIT)         Pointer to address of ZEVINIT\n@@ZDPRIN DC    A(@ZDPRINT)         Pointer to address of ZDPRINT\n@@ZDREAD DC    A(@ZDREAD)          Pointer to address of ZDREAD\n         SPACE 1\nSTABLE   DS    0A                  Start of table\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IN-LINE CODE MODULE TABLE                                           *\n*                                                                     *\n* THIS TABLE IS A LIST OF MODULES WHICH ARE, IN GENERAL, LINKEDITED   *\n* WITH THIS MODULE (E.G. AS PART OF THE INTERPRETER) AND SHOULD BE    *\n* RESOLVED WITH THE ADDRESSES OF CODE THAT IS ALREADY IN MEMORY.      *\n*                                                                     *\n* EXTERNAL REFERENCES WHICH MUST BE RESOLVED ARE                      *\n* IDENTIFIED BY \"MODINT\" MACROS.                                      *\n*                                                                     *\n* WEAK EXTERNAL REFERENCES (WHICH MAY OR MAY NOT BE RESOLVED) ARE     *\n* IDENTIFIED BY \"MODEXT\" MACROS.                                      *\n*                                                                     *\n* NOTE: THIS TABLE *MUST* BE IN ALPHABETICAL ORDER!!!                 *\n*                                                                     *\n* SOME MODULES ARE INCLUDED EVEN THOUGH THEY WOULD NOT BE PART OF     *\n* THE INTERPRETER OTHERWISE, EITHER TO PREVENT MASSIVE LOADING OF     *\n* EVALUATOR MODULES (APPLY), BECAUSE OF FREQUENT OR QUICK USE         *\n* (QUIT, EXIT), OR BECAUSE THEY ARE \"INLINE-CODED\" (CAR, ETC).        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         MODEXT ABS\n         MODEXT ACSIZE\n         MODINT ADD1\n         MODEXT ALPHACP\n         MODINT APPEND\n         MODINT APPEND2\n         MODEXT APPLY\n         MODEXT APROPOS\n         MODEXT ARGS\n         MODEXT ASH\n         MODEXT ASSOC\n         MODINT ASSQ\n         MODEXT ASSQL\n         MODEXT ASSQUAL\n         MODINT ATOM\n         MODEXT BIGLIST\n         MODEXT BIGNUM\n         MODINT BIGP\n         MODEXT BOOLE\n         MODEXT BOUNDP\n         MODEXT BUTLAST\n         MODINT CAR\n         MODINT CDR\n         MODEXT CEILING\n         MODEXT CHAR\n         MODEXT CHARDOWN\n         MODINT CHARP\n         MODEXT CHARUP\n         MODINT CLOSE\n         MODINT CLOSUREP\n         MODEXT CLRSCRN\n         MODINT CODEP\n         MODEXT CONCAT\n         MODINT CONS\n         MODINT CONSP\n         MODEXT COPYENV\n         MODEXT COPYSYM\n         MODEXT COPYTREE\n         MODEXT CSSIZE\n         MODINT CTERPRI\n         MODEXT CURDATE\n         MODEXT CURJDATE\n         MODEXT CURTIME\n         MODEXT DEFRDMAC\n         MODEXT DELQ\n         MODEXT DELQL\n         MODEXT DELQUAL\n         MODINT DFLOATP\n         MODEXT DIGITCP\n         MODEXT DOWNCASE\n         MODINT EBCDIC\n         MODEXT ECHO\n         MODEXT ED\n         MODEXT ENDP\n         MODEXT ENDREAD\n         MODINT EOF\n         MODINT EQ\n         MODINT EQL\n         MODINT EQUAL\n         MODEXT EQUALP\n         MODEXT ERROR\n         MODEXT EVAL\n         MODINT EVENP\n         MODEXT EVERY\n         MODINT EXIT\n         MODEXT EXPLODE\n         MODEXT EXPLODEC\n         MODEXT EXPLODEN\n         MODEXT EXPT\n         MODEXT FBOUNDP\n         MODEXT FEATUREP\n         MODEXT FEXPAND\n         MODEXT FIRSTN\n         MODEXT FIX\n         MODINT FIXNUMP\n         MODEXT FLOAT\n         MODINT FLOATP\n         MODEXT FLOOR\n         MODEXT FMAKUNBO\n         MODEXT FORMAT\n         MODINT FUNARGP\n         MODINT FUNCALL\n         MODINT FUNENV\n         MODINT FUNFUN\n         MODEXT GC\n         MODEXT GCD2\n         MODEXT GCMSG\n         MODEXT GCTIME\n         MODINT GENSYM\n         MODEXT GENTEMP\n         MODINT GET\n         MODEXT GETCHAR\n         MODEXT GETCHARN\n         MODINT GETK\n         MODEXT GETL\n         MODEXT GETPARM\n         MODINT GREATERP\n         MODEXT HAIPART\n         MODEXT HAULONG\n         MODEXT IFILEP\n         MODEXT IMPLODE\n         MODEXT INDEX\n         MODINT INTEGERP\n         MODEXT INTERSEC\n         MODEXT INTRPRET\n         MODEXT INTRQ\n         MODEXT INVOKE\n         MODEXT ISPFP\n         MODINT KEYWORDP\n         MODEXT KWDIFY\n         MODEXT LAND\n         MODEXT LAST\n         MODEXT LASTCAR\n         MODEXT LDIFF\n         MODINT LENGTH\n         MODINT LESSP\n         MODINT LIST\n         MODINT LISTP\n         MODEXT LLKEYWDP\n         MODEXT LLVARS\n         MODINT LOAD\n         MODEXT LOG\n         MODEXT LOGBITP\n         MODEXT LOGCOUNT\n         MODEXT LOGNOT\n         MODEXT LOGTEST\n         MODEXT LOR\n         MODEXT LSH\n         MODEXT LXOR\n         MODEXT MAKNAM\n         MODEXT MAKNUM\n         MODEXT MAKUNBOU\n         MODEXT MAPAND\n         MODEXT MAPC\n         MODEXT MAPCAN\n         MODEXT MAPCAR\n         MODEXT MAPCON\n         MODEXT MAPL\n         MODEXT MAPLIST\n         MODEXT MAPOR\n         MODEXT MAXARGS\n         MODEXT MAX2\n         MODEXT MEMBER\n         MODINT MEMQ\n         MODEXT MEMQL\n         MODEXT MEMQUAL\n         MODEXT MEXPAND\n         MODEXT MEXPAND1\n         MODEXT MINARGS\n         MODINT MINUS\n         MODINT MINUSP\n         MODEXT MIN2\n         MODEXT MKATOM\n         MODEXT MKBIGNUM\n         MODEXT MKFIXNUM\n         MODEXT MKFLONUM\n         MODEXT MKFUNARG\n         MODEXT MKLIST\n         MODEXT MKNEWENV\n         MODEXT MKSTRUCT\n         MODEXT MKVECTOR\n         MODINT MSGLEVEL\n         MODINT NCONC\n         MODINT NCONC2\n         MODEXT NEWLINEP\n         MODINT NOT\n         MODEXT NOTANY\n         MODEXT NOTEVERY\n         MODEXT NRECONC\n         MODINT NREVERSE\n         MODEXT NTH\n         MODEXT NTHCDR\n         MODINT NULL\n         MODINT NUMBERP\n         MODINT OBLIST\n         MODINT ODDP\n         MODEXT OFILEP\n         MODINT OPEN\n         MODEXT PAIRLIS\n         MODEXT PARSBODY\n         MODINT PBIND\n         MODEXT PDSIZE\n         MODEXT PEEK\n         MODEXT PEEKB\n         MODEXT PEEKC\n         MODEXT PEEKCH\n         MODEXT PEEKL\n         MODINT PLIST\n         MODINT PLUSP\n         MODEXT PM\n         MODEXT PM1\n         MODINT PNAME\n         MODEXT PPDATE\n         MODEXT PPRINT\n         MODEXT PPTIME\n         MODEXT PREFIX\n         MODINT PRINC\n         MODINT PRINT\n         MODEXT PRINTC\n         MODEXT PRINTS\n         MODINT PRIN1\n         MODEXT PROBEF\n         MODINT PUTPROP\n         MODINT QUIT\n         MODEXT RANDOM\n         MODEXT RDRMACRO\n         MODINT READ\n         MODEXT READCH\n         MODEXT READLINE\n         MODEXT REMDUPQ\n         MODEXT REMDUPQL\n         MODEXT REMDUPQU\n         MODINT REMPROP\n         MODEXT REMQ\n         MODEXT REMQL\n         MODEXT REMQUAL\n         MODEXT RESTARG\n         MODEXT REVAPPEN\n         MODEXT REVERSAL\n         MODEXT REVERSE\n         MODEXT RMCHAR\n         MODEXT RMINIT\n         MODEXT RMMAC\n         MODINT RMNIL\n         MODEXT ROT\n         MODEXT ROUND\n         MODINT RPLACA\n         MODINT RPLACD\n         MODEXT RUNTIME\n         MODINT SALIST\n         MODEXT SAPPEND\n         MODEXT SAPPENDL\n         MODEXT SCAPITAL\n         MODEXT SCRSIZE\n         MODEXT SET\n         MODEXT SETABEND\n         MODEXT SETASCII\n         MODEXT SETATTN\n         MODEXT SETBRACK\n         MODEXT SETDEBUG\n         MODEXT SETFEAT\n         MODEXT SETNFEAT\n         MODINT SETPBIND\n         MODINT SETPLIST\n         MODEXT SETPRT\n         MODEXT SETREAD\n         MODINT SETSALST\n         MODEXT SETSYNTA\n         MODINT SFLOATP\n         MODEXT SLEEP\n         MODEXT SLENGTH\n         MODEXT SLTRIM\n         MODEXT SOME\n         MODEXT SORT\n         MODEXT SORTCAR\n         MODEXT SREMOVE\n         MODEXT SREVERSE\n         MODEXT SRTRIM\n         MODEXT SSCAN\n         MODEXT STRIM\n         MODEXT STRING\n         MODINT STRINGP\n         MODINT STRUCTP\n         MODEXT STRUCTUR\n         MODEXT SUBLIS\n         MODEXT SUBLISQ\n         MODINT SUBRP\n         MODEXT SUBSTQ\n         MODEXT SUBSTQL\n         MODEXT SUBSTQUA\n         MODEXT SUBSTR\n         MODINT SUB1\n         MODEXT SXHASH\n         MODINT SYMBOLP\n         MODEXT SYMEVAL\n         MODEXT TABS\n         MODINT TERPRI\n         MODEXT TOSTRING\n         MODEXT TRUNCATE\n         MODEXT TSO\n         MODEXT TYI\n         MODEXT TYIPEEK\n         MODEXT TYO\n         MODEXT TYPEP\n         MODEXT UCONCAT\n         MODINT UNEBCDIC\n         MODEXT UNION\n         MODEXT UNIONQ\n         MODEXT UNKWDIFY\n         MODEXT UNTYI\n         MODEXT UNWORD\n         MODEXT UPCASE\n         MODEXT USERID\n         MODEXT VALUES\n         MODEXT VALUESL\n         MODEXT VCOPY\n         MODINT VECP\n         MODEXT VECTOR\n         MODINT VECTORP\n         MODEXT VERIFY\n         MODEXT VFILL\n         MODEXT VLENGTH\n         MODEXT VLIST\n         MODINT VREF\n         MODINT VSET\n         MODEXT VSSIZE\n         MODEXT WARN\n         MODEXT WORD\n         MODEXT XCONS\n         MODEXT XINCLUDE\n         MODEXT XLATE\n         MODINT ZCAR\n         MODINT ZCPRINT\n         MODINT ZCREAD\n         MODEXT ZCREXEC\n         MODEXT ZCSRDL\n         MODEXT ZCSRFS\n@ZDPRINT MODINT ZDPRINT\n@ZDREAD  MODINT ZDREAD\n         MODINT ZEROP\n         MODINT ZERROR\n         MODINT ZEVAUTO\n         MODINT ZEVDEFLD\n         MODINT ZEVDEFUN\n         MODINT ZEVDSUB\n         MODEXT ZEVDVAR\n@ZEVINIT MODINT ZEVINIT\n         MODEXT ZEVLIST\n         MODEXT ZEVMAPP\n         MODEXT ZEVSET\n         MODEXT ZEVSYM\n         MODINT ZEVXVAR\n         MODEXT ZFMEXEC\n         MODEXT ZFMPARS\n         MODEXT ZFSEXEC\n         MODEXT ZGETFPI\n         MODEXT ZGETFPO\n         MODEXT ZIFACOS\n         MODEXT ZIFASIN\n         MODEXT ZIFATAN\n         MODEXT ZIFCOS\n         MODEXT ZIFEXP\n         MODEXT ZIFLOG\n         MODEXT ZIFSIN\n         MODEXT ZIFSQRT\n         MODEXT ZIFTAN\n         MODINT ZILADD\n         MODEXT ZILAPPLY\n         MODEXT ZILBOOL\n         MODINT ZILCLOSE\n         MODINT ZILDIV\n         MODEXT ZILDSNI\n         MODEXT ZILDSNO\n         MODEXT ZILDUMP\n         MODEXT ZILEDIT\n         MODINT ZILEQUAL\n         MODEXT ZILEVAL\n         MODEXT ZILEXPL\n         MODEXT ZILFIX\n         MODEXT ZILFLAT\n         MODEXT ZILGCD\n         MODEXT ZILHASH\n         MODEXT ZILHELP\n         MODEXT ZILIMPL\n         MODEXT ZILINTLN\n         MODINT ZILLOAD\n         MODINT ZILMUL\n         MODINT ZILOPEN\n         MODEXT ZILPKCH\n         MODEXT ZILPP\n         MODEXT ZILPROGV\n         MODEXT ZILRDCH\n         MODINT ZILREM\n         MODEXT ZILSPAD\n         MODEXT ZILSPKG\n         MODEXT ZILSPRT\n         MODEXT ZILSRD\n         MODINT ZILSUB\n         MODEXT ZILTEST\n         MODEXT ZILTRACE\n         MODEXT ZILTSO\n         MODINT ZILUNBND\n         MODEXT ZILVSET\n         MODEXT ZILVSYM\n         MODEXT ZILVTOS\n         MODINT ZILXCLO\n         MODINT ZILXDEF\n         MODINT ZILXFUN\n         MODEXT ZILXLFY\n         MODINT ZILXSUB\n         MODEXT ZISEXEC\n         MODEXT ZISGET\n         MODEXT ZISPUT\n         MODEXT ZMADD\n         MODEXT ZMDIV\n         MODEXT ZMGCD\n         MODEXT ZMMAX\n         MODEXT ZMMIN\n         MODEXT ZMMUL\n         MODEXT ZMREM\n         MODEXT ZMSALTP            Hack for Macsyma\n         MODEXT ZMSASCII           Hack for Macsyma\n         MODEXT ZMSASSQ            Hack for Macsyma\n         MODEXT ZMSBREAK           Hack for Macsyma\n         MODEXT ZMSCLOS            Hack for Macsyma\n         MODEXT ZMSCURS            Hack for Macsyma\n         MODEXT ZMSDELQ            Hack for Macsyma\n         MODEXT ZMSDOW             Hack for Macsyma\n         MODEXT ZMSDREM            Hack for Macsyma\n         MODEXT ZMSEQ              Hack for Macsyma\n         MODEXT ZMSERROR           Hack for Macsyma\n         MODEXT ZMSLOAD            Hack for Macsyma\n         MODEXT ZMSMEMQ            Hack for Macsyma\n         MODEXT ZMSMMOD            Hack for Macsyma\n         MODEXT ZMSOPEN            Hack for Macsyma\n         MODEXT ZMSPRINT           Hack for Macsyma\n         MODEXT ZMSRCH             Hack for Macsyma\n         MODEXT ZMSREADL           Hack for Macsyma\n         MODEXT ZMSREMQ            Hack for Macsyma\n         MODEXT ZMSTRUCT\n         MODEXT ZMSTRUE            Hack for Macsyma\n         MODEXT ZMSTYPF            Hack for Macsyma\n         MODEXT ZMSUB\n         MODEXT ZMVECTOR\n         MODEXT ZPUTFPI\n         MODEXT ZPUTFPO\n         MODEXT ZRMAPPLY\n         MODEXT ZRMBQ\n         MODEXT ZRMCOMMA\n         MODEXT ZRMINIT\n         MODEXT ZRMQUOTE\n         MODEXT ZRMSELF\n         MODEXT ZRMSHARP\n         SPACE 1\nETABLE   DS    0A                  End of table\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILMUL": {"ttr": 14857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x02\\x95\\x02\\x93\\x02\\x94\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 661, "newlines": 659, "modlines": 660, "user": "SEB1525"}, "text": "         TITLE 'ZILMUL - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILMUL TAKES TWO ARGUMENTS. BOTH MUST BE NUMERIC ATOMS.             *\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS: (INTEGERS ARE FIXNUMS AND BIGNUMS) *\n*                                                                     *\n* 1. BOTH ARGS INTEGER       - PERFORM INTEGER MULTIPLICATION.        *\n* 2. BOTH ARGS FLOAT         - PERFORM REAL MULTIPLICATION.           *\n* 3. ONE INTEGER, ONE FLOAT  - CONVERT INTEGER ARGUMENT TO            *\n*                              FLOAT AND PERFORM REAL MULTIPLICATION. *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILMUL   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILMUL'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM\n         BNE   ARG1NFIX\n         CLI   ##TYPE(#7),##FIXNUM\n         BNE   FX1NFX2\n*---------------------------------------------------------------------*\n*           FIXNUM BY FIXNUM MULTIPLY                                 *\n*---------------------------------------------------------------------*\n         L     #3,##CDR(,#6)       GET FIXED VALUE 1\n         M     #2,##CDR(,#7)       MULTIPLY THEM\n         SLDA  #2,32               SQUEEZE TO SIGNED 32 BITS\n         BO    FFBIG               FIXNUM OVERFLOW? THEN MAKE BIGNUM\n         #MKAT FIXED               MAKE A FIXNUM\n******** B     RETURN              AND RETURN WITH IT\n         SPACE\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*       FIXNUM MULTIPLICATION OVERFLOWS AND CREATES A BIGNUM          *\n*---------------------------------------------------------------------*\nFFBIG    LTR   #2,#2               TEST FOR SIGN\n         BM    FFBIGM              IT'S A NEGATIVE BIGNUM\n         L     #7,##CDR(,#7)       LOAD ARG2\n         M     #6,##CDR(,#6)       MULTIPLY BY ARG1\n         SLDA  #6,1                ALIGN #6 FOR 31-BIT RADIX\n         BO    FFBIG3              MUST BE 2**62, 3-WORD BIGNUM!\n         SRL   #7,1                RESTORE #7 AFTER #6 ALIGNMENT\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LA    #2,##VECDAT+8       GET SIZE TO PASS TO ZILBIG\n         #BASR #14,#15             GET BIGNUM SPACE FROM STRING SPACE\n         L     #4,BIG8             PREP TYPE AND LENGTH WORD\n         LR    #5,#7               PREP LEAST SIGNIFICANT WORD FOR STM\n         LA    #1,##VECDAT+8(,#15) POINT TO END OF BIGNUM\n         STM   #4,#6,0(#15)        STORE WHOLE WORD\n         ST    #1,ZLCVSNXT         MAKE IT A PERMANENT OBJECT\n         B     RETURN\n         SPACE\nFFBIGM   L     #5,##CDR(,#6)       GET FIRST MULTIPLICAND\n         L     #7,##CDR(,#7)       GET SECOND MULTIPLICAND\n         LNR   #5,#5               MAKE SURE WE CAN MULT THESE\n         LNR   #7,#7               BUT WE DONT KNOW WHICH IS NEG\n         MR    #6,#5               MULTIPLY TO GET POS RESULT\n         SLDA  #6,1                SHIFT TO RADIX-31\n         SRL   #7,1                RESTORE LS WORD\n         O     #7,=X'80000000'     IF 0 WE REALLY WANT -0\n         L     #15,ZLCBIG          GET ADDRESS FOR ZILBIG\n         LA    #2,##VECDAT+8       GET SIZE TO PASS TO ZILBIG\n         #BASR #14,#15             CALL ZILBIG\n         LM    #4,#5,BIG8M         LOAD HEADER AND MINUS SIGN\n         OR    #5,#7               MOVE LS WORD TO #5 AND SET SIGN\n         LA    #1,##VECDAT+8(,#15) POINT TO END OF BIGNUM\n         STM   #4,#6,0(#15)        STORE BIGNUM, INCLUDING HEADER\n         ST    #1,ZLCVSNXT         MAKE IT A PERMANENT OBJECT\n         B     RETURN\n         SPACE\nFFBIG3   LA    #15,TWO62           GET ADDRESS OF IN-LINE 2**62 BIGNUM\n         B     RETURN              RETURN WITH IT\n         SPACE 1\n*---------------------------------------------------------------------*\n* ARG 1 IS FIXED BUT ARG 2 IS NOT                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nFX1NFX2  CLI   ##TYPE(#7),##BIGNUM\n******** BE    FIXBIG              FIXED * BIG   = BIG\n         BNE   FX1NBF2\n         SPACE\n*---------------------------------------------------------------------*\n* FIXNUM BY BIGNUM MULTIPLY                                           *\n*---------------------------------------------------------------------*\nFIXBIG   ST    #7,0(,#11)          EXCHANGE POINTERS IN #6 AND #7\n         ST    #6,4(,#11)           AND ALSO IN THE STACK\n         LM    #6,#7,0(#11)        LOAD EXCHANGED REGS FROM STACK\n*\nBIGFIX   ICM   #7,15,##CDR(#7)     LOAD FIXNUM AND SIGN TEST\n         BZ    BIGFIX0             RESULT IS 0\n         BM    BIGFIXM             IT'S A BIGNUM * NEG FIXNUM\n         XR    #5,#5               CLEAR FOR ICM OF LENGTH\n         ICM   #5,7,1(#6)          GET BIGNUM LENGTH\n*\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LA    #2,##VECDAT+4(,#5)  GET SIZE TO PASS TO ZILBIG\n         #BASR #14,#15             CALL ZILBIG\n*\n         L     #6,0(,#11)          GC MAY HAVE MOVED BIGNUM POINTER\n         ICM   #3,15,##VECDAT(#6)  GET LS WORD OF BIGNUM\n         BM    BIGMFIXP            IT'S A NEG BIGNUM AND POS FIXNUM\n*\nPBIGFIX  LA    #4,4                WORD SIZE - BXLE INCREMENT SIZE\n         MR    #2,#7\n         SLDL  #2,1\n         SRL   #3,1\n         LR    #1,#4               SHOULD BE SET TO ##VECDAT\nBFCONT   ST    #3,##VECDAT-4(#1,#15)\n         LR    #14,#2\n         AR    #1,#4\n         LA    #0,1                USEFUL FOR FAST CARRY\nBFLOOP   L     #3,##VECDAT-4(#1,#6)\n         MR    #2,#7\n         ALR   #3,#14              ADD IN PREVIOUS CARRY\n         BC    12,BFNCARRY         NO CARRY NEEDED\n         AR    #2,#0               ADD 1 TO HIGHER WORD\nBFNCARRY SLDA  #2,1                SHIFT TO 31-RADIX\n         BO    BFBUG        *****  SHOULDN'T OVERFLOW HERE\n         SRL   #3,1                RESTORE POSITION OF LS WORD\n         ST    #3,##VECDAT-4(#1,#15) STORE RESULT WORD\n         LR    #14,#2              STORE CARRY WORD\n         BXLE  #1,#4,BFLOOP        ANOTHER WORD TO DO?\n*\n         LTR   #2,#2\n         BZ    BFRETURN\n         ST    #2,##VECDAT-4(#1,#15)\n         LA    #2,##VECDAT(#1,#15) A(BIGNUM) + L'BIGNUM + L'HEADER\n         STCM  #1,7,1(#15)         STORE BIGNUM LENGTH\n         ST    #2,ZLCVSNXT         MAKE IT PERMANENT\n         B     RETURN\nBFRETURN LA    #2,##VECDAT-4(#1,#15)\n         SR    #1,#4\n         STCM  #1,7,1(#15)\n         ST    #2,ZLCVSNXT\n         B     RETURN\n         SPACE\nBIGFIX0  L     #15,4(,#11)         GET POINTER TO 0 FROM STACK\n         B     RETURN              RETURN WITH POINTER TO 0\n         SPACE\nBIGFIXM  LPR   #7,#7\n         BO    BIGFIXMC\n         CL    #7,=F'1'\n         BE    BIGFIXM1            (* 2**31 -1) IS FIXNUM\n         XR    #5,#5\n         ICM   #5,7,1(#6)\n         L     #15,ZLCBIG\n         LA    #2,##VECDAT+4(,#5)  GET SIZE TO PASS TO ZILBIG\n         #BASR #14,#15\n         L     #6,0(,#11)\n         ICM   #3,15,##VECDAT(#6)\n         BM    BIGMFIXM\n         LA    #4,4\n         MR    #2,#7\n         SLDL  #2,1\n         SRL   #3,1\n         LR    #1,#4\n         O     #3,=X'80000000'\n         B     BFCONT\n*\nBIGFIXM1 CLC   TWO31(12),0(#6)     COMPARE BIGNUM TO 2**31\n         BE    MTWO31M             ANSWER IS MOST NEG FIXNUM\n*\n         ICM   #7,7,1(#6)          GET BIGNUM LENGTH\n         LA    #7,##VECDAT(,#7)    TOTAL LENGTH OF RESULT BIGNUM\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG\n         LR    #2,#7               DESIRED LENGTH FOR ZILBIG\n         #BASR #14,#15             CALL ZILBIG\n*\n         L     #6,0(,#11)          RESTORE BIGNUM POINTER AFTER GC\n         LR    #4,#15              PREP DESTINATION FOR MVCL\n         LR    #5,#7               PUT LENGTH IN BOTH FIELDS FOR MVCL\n         MVCL  #4,#6               MOVE BIGNUM\n         XI    ##VECDAT(#15),X'80' TOGGLE SIGN OF RESULT\n         ST    #4,ZLCVSNXT         BUMP UP BIGNUM AVAILABILITY POINTER\n         B     RETURN\nMTWO31M  LA    #15,TWO31M          RETURN MOST NEGATIVE FIXNUM\n         B     RETURN\n         SPACE\nBIGMFIXP N     #3,=X'7FFFFFFF'\n         LA    #4,4\n         MR    #2,#7\n         SLDL  #2,1\n         SRL   #3,1\n         LR    #1,#4\n         O     #3,=X'80000000'\n         B     BFCONT\n         SPACE\nBIGMFIXM N     #3,=X'7FFFFFFF'\n         B     PBIGFIX\n         SPACE\nBIGFIXMC XR    #5,#5               CLEAR FOR GETTING 3-BYTE LENGTH\n         ICM   #5,7,1(#6)          GET LENGTH OF BIGNUM\n         L     #15,ZLCBIG          RESULT MUST BE ONE WORD LONGER\n         LA    #2,##VECDAT+4(,#5)  GET SIZE TO PASS TO ZILBIG\n         #BASR #14,#15             MAKE NEW BIGNUM SPACE\n         L     #6,0(,#11)          RECOVER BIGNUM ARG IN CASE OF GC\n         L     #2,=X'80000000'     PREP TO MASK ALL BUT SIGN OF BIGNUM\n         L     #3,##VECDAT(,#6)    BRING IN THE BIGNUM LS WORD + SIGN\n         NR    #2,#3               EXTRACT SIGN FROM BIGNUM LS WORD\n         LA    #1,4(,#5)           CALCULATE LENGTH OF RESULT BIGNUM\n         X     #2,=X'80000000'     COMPLEMENT THE SIGN\n         STCM  #1,7,1(#15)         STORE NEW BIGNUM LENGTH\n         N     #3,=X'7FFFFFFF'     MASK OUT THE SIGN IN THE LS WORD\n         STM   #2,#3,##VECDAT(#15) STORE LS AND 2ND LS WORDS OF RESULT\n         LA    #4,##VECDAT+8(,#15) POINT TO NEXT WORD IN RESULT TO FILL\n         LA    #6,##VECDAT+4(,#6)  POINT TO NEXT WORD IN ARG TO COPY\n         SH    #5,=H'4'            PREPARE TO MOVE ALL BUT 2 LS WRDS OF\n         LR    #7,#5                OLD BIGNUM TO NEW BIGNUM\n         MVCL  #4,#6               COPY BIGNUM TO ONE WORD MORE SIGNIF.\n         ST    #4,ZLCVSNXT         BUMP UP BIGNUM AVAILABILITY POINTER\n         B     RETURN\n         SPACE\nARG1NFIX CLI   ##TYPE(#6),##SFLOAT\n         BE    ARG1SFLO\n         CLI   ##TYPE(#6),##BIGNUM\n         BE    ARG1BIG\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    ARG1DFLO\n         B     ERROR1\nARG1BIG  DS    0H\n*\n* ARG 1 IS A BIGNUM - NOW CHECK ARG2\n*\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    BIGFIX              BIGNUM * FIXNUM\n         CLI   ##TYPE(#7),##BIGNUM\n         BE    BIGBIG              BIGNUM * BIGNUM\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    BIGSFLO             BIGNUM * SINGLE FLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    BIGDFLO             BIGNUM * DOUBLE FLOAT\n         B     ERROR2\n         SPACE 1\nBIGBIG   DS    0H\n         SPACE 1\n***********************************************************************\n* BIGNUM BY BIGNUM MULTIPLY ROUTINE.  31-BIT RADIX IS ASSUMED         *\n* FOR THE \"DIGITS\" OF THE BIGNUM (EACH DIGIT IS A 31-BIT WORD).       *\n* BIGNUMS ARE REPRESENTED BY SIGN AND MAGNITUDE.                      *\n* THE SIGN IS REPRESENTED BY THE LEFTMOST BIT OF THE LS WORD.         *\n*                                                                     *\n* ASSUME VECTOR STRUCTURE IS WORD INDICATING LENGTH OF VECTOR, WHICH  *\n* STARTS IN THE NEXT WORD.  A THREE WORD VECTOR WOULD BE REPRESENTED  *\n* IN 4 WORDS (32 BITS/WORD) AS FOLLOWS:                               *\n*                                                                     *\n*       ---------------------------------------------------------     *\n*       | C8 00 00 0C | 7F FF 00 FF | 72 34 56 78 | 7F FF FF 23 |     *\n*       --==-========--------------------------------------------     *\n*        TYPE LENGTH      LS WORD       NEXT WORD     MS WORD         *\n*                                                                     *\n* HELPFUL DIAGRAM WITH REGISTER LABELLED (NUMBERS REFER TO REGISTERS  *\n* WHICH ARE POINTING TO THESE LOCATIONS). \"===\" LINES INDICATE        *\n* SIZE WHICH AN INDEX (OFFSET) REGISTER WILL NEVER GO UNDER.          *\n* \"---\" LINES INDICATE INDEX (OFFSET) VALUES WHICH INDEX REGISTERS    *\n* WILL TRAVERSE. \"...\" INDICATES AREAS WHICH ABSOLUTE POINTERS        *\n* (BASE REGISTERS) WILL TRAVERSE IN THE COURSE OF THE COMPUTATION.    *\n* REGISTERS WITH ONLY \"====\" OR NO OTHER PUNCTUATION ON THE SAME      *\n* LINE ARE EITHER CONSTANT INDEX VALUES OR ABSOLUTE POINTERS          *\n* WHICH DO NOT CHANGE IN THE COURSE OF THE COMPUTATION.  E.G.,        *\n* THE FOLLOWING DIAGRAM INDICATES THAT REGISTER 11 IS A CONSTANT      *\n* BASE POINTER, REGISTER 6 IS A MOVING BASE POINTER, REGISTER         *\n* 5 IS A FIXED INDEX REGISTER, REGISTER 14 IS A MOVING INDEX          *\n* REGISTER, ETC.  THE NOTATION IS NOT LOGICALLY COMPLETE AND IS       *\n* INTENDED ONLY AS A VISUAL AID IN UNDERSTANDING THE ASSEMBLER        *\n* CODE WHICH FOLLOWS.                                                 *\n*                                                                     *\n*                                                                     *\n*               11                                                    *\n* 6....6....6....6                                                    *\n* ---------------------                                               *\n* |    | LS |    | MS |                           BIGNUM1             *\n* ---------------------                                               *\n*                                                                     *\n*                                                                     *\n* ==========-------------14>                                          *\n* ========================5>                                          *\n* 7                                                                   *\n* -------------------------------                                     *\n* |    | LS |    |    |    | MS |                 BIGNUM2             *\n* -------------------------------                                     *\n*                                                                     *\n*                                                                     *\n* 1....1....1=========-------------14>                                *\n* 15                                                                  *\n* ----------------------------------------------                      *\n* |    | LS |    |    |    |    |    |    | ?? |  RESULT BIGNUM       *\n* ----------------------------------------------                      *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                 ------                              *\n*                                 |  0 |                              *\n*                                 ------                              *\n*                                 ------                              *\n*                            X    |  3 |                              *\n*                                 ------                              *\n*                          -------------                              *\n*                          ------ ------                              *\n*                          |  2 | |  3 |                              *\n*                          ------ ------                              *\n*                                                                     *\n* PROOF THAT CARRY TO NEXT LOOP IS NEVER GREATER THAN 2 OUT OF        *\n* EACH ITERATION OF THE INNER LOOP (THE AL RIGHT AFTER ILOOP):        *\n*                                                                     *\n* ASSUME     B = 2**31 (WORD RADIX)                                   *\n*            C = MAXIMUM CARRY                                        *\n*                                                                     *\n* THEN       B - 1  = MAXIMUM POSSIBLE WORD VALUE                     *\n*            B - 2  = MAXIMUM POSSIBLE VALUE FOR MOST SIGNIFICANT     *\n*                     WORD IN A MULTIPLY SINCE (B-1)(B-1)=(B-2)B+1    *\n*                                                                     *\n*  SINCE THE LARGEST POSSIBLE SUM IN EACH ITERATION OF THE INNER      *\n*  LOOP CAN ONLY OCCUR WHEN EACH COMPONENT OF THE SUM HAS ITS         *\n*  MAXIMUM POSSIBLE VALUE, WE TRY IT AND SEE WHAT THE RESULT          *\n*  WOULD BE.  WE MUST SUM THE CARRY FROM THE PREVIOUS COLUMN,         *\n*  THE MOST SIGNIFICANT WORD FROM THE PREVIOUS MULTIPLY, THE          *\n*  LEAST SIGNIFICANT WORD FROM THE PRESENT MULTIPLY, AND THE          *\n*  WORD REPRESENTING THE SUM (FOR THIS PLACE OF SIGNIFICANCE) OF      *\n*  ALL PREVIOUS ITERATIONS (THIS SITS IN THE RESULT BIGNUM AND        *\n*  BECOMES THE CORRECT ANSWER WHEN ALL ITERATIONS HAVE COMPLETED).    *\n*  WE THEN HAVE:                                                      *\n*                                                                     *\n*     C + (B - 2) + (B - 1) + (B - 1)                                 *\n*                                                                     *\n*  =  C + 3 B - 4                                                     *\n*                                                                     *\n*  =  C + 2 B + (B - 4)                                               *\n*                                                                     *\n*  =  (2)B + (B - 4 + C)                                              *\n*                                                                     *\n*  WE CAN SEE THAT THIS WILL BE CONSISTENT AND NOT OVERFLOW IF        *\n*  C = 2 (EVEN THOUGH C = 3 WOULD NOT HAVE CAUSED AN OVERFLOW IN THIS *\n*  CASE.  BUT WE CONCLUDE THAT C = 2 IS THE MAXIMUM CARRY BECAUSE     *\n*  IT APPEARS AS THE COEFFICIENT TO \"B\" IN THE LAST EQUATION.  THE    *\n*  B IN (B-4+C) IS REQUIRED TO MAKE THAT TERM A POSITIVE VALUE SINCE  *\n*  WE ARE ASSUMING THAT REGISTERS WILL ONLY HOLD POSITIVE TWO'S       *\n*  COMPLEMENT NUMBERS OF 32 BITS - RESULTING IN THE UPPER BIT ALWAYS  *\n*  BEING ZERO AND EFFECTIVELY BECOMING A 31-BIT RADIX.  31-BIT RADIX  *\n*  IS USED FOR BIGNUM REPRESENTATION PRIMARILY BECAUSE OF HARDWARE    *\n*  LIMITATIONS IN THE DIVIDE AND MULTIPLY INSTRUCTIONS (THERE IS NO   *\n*  UNSIGNED MULTIPLY AND DIVIDE ON THE IBM/370.)  ADD LOGICAL IS      *\n*  USED IN THE INNER LOOP HERE TO CONVENIENTLY USE THE UPPER BIT      *\n*  AS A CARRY POSITION FOR THE LOWER ORDER BIT OF THE POSSIBLE TWO-   *\n*  BIT CARRY.                                                         *\n*                                                                     *\n*  AN ADDITIONAL REFINEMENT IN ANALYZING THE MAXIMUM VALUES THAT      *\n*  CAN BE CARRIED IS TO OBSERVE THAT IF THE HIGHER ORDER WORD         *\n*  OF A MULTIPLY (AFTER 31-BIT RADIX NORMALIZATION) IS (B-2) THEN     *\n*  THE LOWER ORDER WORD FROM SAME MULTIPLY MUST BE 1, SINCE THE       *\n*  PROBLEM MUST HAVE BEEN THE MULTIPLICATION (B-1) * (B-1).           *\n***********************************************************************\n         XR    #3,#3               ZERO LEFT BYTE FOR ICM\n         XR    #5,#5               ZERO LEFT BYTE FOR ICM\n         ICM   #3,7,1(#6)          GET LENGTH OF FIRST BIGNUM\n         ICM   #5,7,1(#7)          GET LENGTH OF SECOND BIGNUM\n         L     #15,ZLCBIG          GET ADDRESS OF ZILBIG SERVICE\n         LA    #2,##VECDAT(#3,#5)  PRODUCT MAY BE SUM OF LENGTHS\n         #BASR #14,#15             CALL ZILBIG - GET SPACE FOR RESULT\n*\n         STM   #8,#11,ZLCISAVE     NEED MORE REGISTERS (NOT #12,#13)\n         OI    ZLCIFLGS,ZLCISVD    INDICATE THERE ARE REGISTERS SAVED\n*\n         LR    #1,#15              SET UP BASE POINTER IN RESULT\n         LM    #6,#7,0(#11)        RESTORE BIGNUM POINTERS MOVED BY GC\n         LA    #11,##VECDAT-4(#3,#6) POINT TO LAST WORD OF BIGNUM1\n         LA    #4,4                NEED QUANTITY 4 FOR GENERAL USE\n         LA    #8,1                NEED QUANTITY 1 FOR CARRY\n         LR    #10,#4              NEED QUANTITY 4 FOR FOR BXLE\n         LA    #14,##VECDAT+4      PREPARE INDEX FOR 2ND LS WORD\n         LA    #6,##VECDAT(,#6)    #6 POINTS TO LS WORD OF BIGNUM1\n*---------------------------------------------------------------------*\n*    INITIALIZATION COMPLETE - NOW PROCESS LS WORD OF BOTH BIGNUMS    *\n*---------------------------------------------------------------------*\nBBGO     ICM   #0,15,0(#6)         LOAD LS WORD OF BIGNUM1, CHECK SIGN\n         BM    BBM1                BIGNUM1 IS NEGATIVE\n         ICM   #3,15,##VECDAT(#7)  LOAD LS WORD OF BIGNUM2, CHECK SIGN\n         BM    BBP1M2              BIGNUM2 IS NEGATIVE, BIGNUM1 IS +\n         MR    #2,#0               MULTIPLY TWO POSITIVE LS WORDS\n         SLDL  #2,1                MAKE UPPER WORD 31-RADIX\n         SRL   #3,1                BRING BACK LS WORD OF PRODUCT\n         LR    #9,#2               SAVE CARRY WORD\n         ST    #3,##VECDAT(,#15)   STORE IN LS WORD OF RESULT\n*---------------------------------------------------------------------*\n*    FIRST TIME LOOP - NO PREVIOUS ROW TO ADD IN                      *\n*---------------------------------------------------------------------*\nILOOP1   L     #3,0(#14,#7)        GET NEXT WORD OF BIGNUM2\n         MR    #2,#0               MULTIPLY BY LS WORD OF BIGNUM1\n         ALR   #3,#9               INCLUDE CARRY WORD FROM LAST MULT\n         BC    12,NCI1             BRANCH IF NO CARRY\n         AR    #2,#8               ADD 1 IF THERE WAS A CARRY\nNCI1     SLDL  #2,1                IT'S RADIX 31, YOU KNOW\n         SRL   #3,1                MOVE 31 BITS BACK TO THE RIGHT\n         LR    #9,#2               CARRY HIGHER WORD TO NEXT ITERATION\n         ST    #3,0(#14,#1)        STORE RESULT\n         BXLE  #14,#4,ILOOP1       DO NEXT WORD IN BIGNUM2?\n         ST    #2,0(#14,#1)        STORE LAST RESULT USING BIGNUM1 LS\n*\n         AR    #6,#4               INCREMENT BIGNUM1 INDEX POINTER\n         B     OLOOP\n*---------------------------------------------------------------------*\n*    SPECIAL INITIALIZATIONS FOR SIGNS BEFORE THE FIRST TIME LOOP     *\n*---------------------------------------------------------------------*\nBBM1     ICM   #3,15,##VECDAT(#7)  GET LS WORD OF BIGNUM2\n         BNM   BBM1P2              BIGNUM2 IS POSITIVE (0 MEANS + TOO)\n         N     #0,=X'7FFFFFFF'     MAKE BOTH BIGNUM LS WORDS POSITIVE\n         N     #3,=X'7FFFFFFF'     MAKE BOTH BIGNUM LS WORDS POSITIVE\n         MR    #2,#0               MULTIPLY LS WORDS\n         SLDL  #2,1                CONVERT TO 31-BIT RADIX\n         SRL   #3,1                CONVERT TO 31-BIT RADIX\n         LR    #9,#2               SAVE CARRY WORD\n         ST    #3,##VECDAT(,#15)   STORE LS WORD IN RESULT VECTOR\n         B     ILOOP1              GO TO FIRST TIME THROUGH LOOP\n*\nBBP1M2   N     #3,=X'7FFFFFFF'     TAKE POSITIVE VALUE FOR MULTIPLY\n         MR    #2,#0               MULT TWO POSITIVE NUMBERS\n         SLDL  #2,1                CONVERT TO 31-RADIX\n         SRL   #3,1                CONVERT TO 31-RADIX\n         LR    #9,#2               SAVE CARRY WORD\n         O     #3,=X'80000000'     SET LS WORD TO NEGATIVE\n         ST    #3,##VECDAT(,#15)   STORE IN LS WORD OF RESULT\n         B     ILOOP1              GO TO FIRST PART OF LOOP\n*\nBBM1P2   N     #0,=X'7FFFFFFF'     TAKE POSITIVE VALUE FOR MULTIPLY\n         MR    #2,#0               MULT TWO POSITIVE NUMBERS\n         SLDL  #2,1                CONVERT TO 31-RADIX\n         SRL   #3,1                CONVERT TO 31-RADIX\n         LR    #9,#2               SAVE CARRY WORD\n         O     #3,=X'80000000'     SET LS WORD TO NEGATIVE\n         ST    #3,##VECDAT(,#15)   STORE IN LS WORD OF RESULT\n         B     ILOOP1              GO TO FIRST PART OF LOOP\n*---------------------------------------------------------------------*\n*    MAIN OUTER LOOP FOR BIGNUM X BIGNUM MULTIPLY                     *\n*---------------------------------------------------------------------*\nOLOOP    AR    #1,#4               INCREMENT BASE FOR RESULT BIGNUM\n         LA    #14,##VECDAT+4      PREPARE INDEX FOR 2ND LS WORD\n         L     #3,4(,#7)           GET LS WORD OF BIGNUM2\n         L     #0,0(,#6)           GET NEXT WORD OF BIGNUM1\n         N     #3,=X'7FFFFFFF'     TAKE POSITIVE VALUE\n         MR    #2,#0               DO THE MULTIPLICATION\n         AL    #3,4(,#1)           ADD FROM PREVIOUS ROW\n         BC    12,NCO              NO CARRY?\n         AR    #2,#8               YES, ADD 1 TO HIGHER WORD\nNCO      SLDL  #2,1                31-BIT RADIX, YOU KNOW\n         SRL   #3,1                RESTORE LEFT 31 BITS\n         LR    #9,#2               CARRY WORD TO NEXT ITERATION\n         ST    #3,4(,#1)           STORE RESULT\n*---------------------------------------------------------------------*\n*    INNER LOOP FOR BIGNUM X BIGNUM MULTIPLY - OPTIMIZED FOR SPEED    *\n*---------------------------------------------------------------------*\nILOOP    L     #3,0(#14,#7)        GET NEXT WORD IN BIGNUM2\n         AL    #9,0(#14,#1)        CARRY+LAST ROW, WON'T OVERFLOW!\n         BC    3,BUG2        ***** NOT EXPECTED - DELETE WHEN DEBUGGED\n         MR    #2,#0               MULTIPLY, NO NEGATIVES ENCOUNTERED\n         ALR   #3,#9               ADD TO PRESENT MULT RESULT\n         BC    12,NCI              NO CARRY?\n         AR    #2,#8               ADD 1 TO WORD TO BE CARRIED\nNCI      SLDL  #2,1                31-BIT RADIX, YOU KNOW\n         SRL   #3,1                RESTORE 31 BITS IN RIGHT WORD\n         LR    #9,#2               SO CARRY WON'T BE BASHED BY MR\n         ST    #3,0(#14,#1)        STORE RESULT\n         BXLE  #14,#4,ILOOP        NOT AT END OF BIGNUM2 YET?\n*\n         ST    #2,0(#14,#1)        STORE MS WORD IN THIS ROW OF SUM\n         BXLE  #6,#10,OLOOP        NOT END OF BIGNUM1 YET?\n*---------------------------------------------------------------------*\n*      END OF INNER AND OUTER LOOPS FOR BIGNUM X BIGNUM MULTIPLY      *\n*---------------------------------------------------------------------*\n*\n         LTR   #2,#2               IF HIGHEST WORD IS 0\n         BNZ   BBEXTRA             THEN...\n         AR    #14,#1               REDUCE BY 4 TO CHOP OFF LEADING 0\n         ST    #14,ZLCVSNXT        STORE ADDRESS FOR NEXT VSS OBJ\n         SR    #14,#15             CALCULATE LENGTH OF BIGNUM\n         SR    #14,#4              IT'S ONE WORD SHORTER HERE\n         STCM  #14,7,1(#15)        STORE INTO LENGTH FIELD OF RESULT\n         B     LRETURN             ===>interruptability exposure above\n*\nBBEXTRA  AR    #14,#1               MAKE THE BIGNUM PERMANENT\n         AR    #4,#14\n         SR    #14,#15\n         STCM  #14,7,1(#15)        STORE LENGTH OF DATA PORTION\n         ST    #4,ZLCVSNXT\n*\nLRETURN  LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS\n         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED\n         B     RETURN\n         SPACE 1\nBIGSFLO  DS    0H                  BIGNUM * SINGLE FLOAT\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LR    #5,#6               Arg1 is bignum, arg2 is float\n         #BASR #14,#15             Convert bignum to float\n         LER   #F2,#F0             Get float value for arg1\n         B     MULSFLO1            Go to multiply arg1 by float arg2\nBIGDFLO  DS    0H                  BIGNUM * DOUBLE FLOAT\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LNR   #5,#6               Arg1 is bignum, arg2 is float\n         #BASR #14,#15             Convert bignum to float\n         LDR   #F2,#F0             Get float value for arg1\n         B     MULDFLO1            Go to multiply arg1 by float arg2\n         SPACE 1\nFX1NBF2  DS    0H                  ARG 1 IS FIXED BUT ARG2 IS NOT\n         SPACE\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    FIXSFLO             FIXED * SFLOAT = SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    FIXDFLO             FIXED * DFLOAT = DFLOAT\n         B     ERROR2              FIXED * NONUM = ERROR\nFIXSFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F2,#F0             GET SINGLE FLOAT VALUE 1\n         B     MULSFLO1\nFIXDFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F2,#F0             GET DOUBLE FLOAT VALUE 1\n         B     MULDFLO1\n         SPACE\nARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    SMULSFLO            SFLOAT * SFLOAT = SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    SMULDFLO            SFLOAT * DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    SFLOPFIX            SFLOAT * FIXED = SFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BNE   ERROR2              SFLOAT * NONUM = ERROR\n         LE    #F2,##CDR(,#6)      Get single float value 1\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LR    #5,#7               Arg1 is float, arg2 is bignum\n         #BASR #14,#15             Convert bignum to float\n         LER   #F4,#F0             Get float value for arg2\n         B     MULSFLO2            Go to MUL float arg1 to arg2\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO SINGLE FLOAT                         *\n*---------------------------------------------------------------------*\nSFLOPFIX LE    #F2,##CDR(,#6)      Get single float value 1\n         L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F4,#F0             GET FLOAT VALUE 2\n         B     MULSFLO2            FLOAT * FIXED = FLOAT\n         SPACE\nARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F2,8(,#6)          GET FLOAT VALUE 1\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    MULDFLO1            DFLOAT * DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    DMULSFLO            DFLOAT * SFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    DFLOPFIX            DFLOAT * FIXED = DFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BNE   ERROR2              DFLOAT * NONUM = ERROR\n         L     #15,ZLCCVBF         Get address of ZILCVBF\n         LNR   #5,#7               Arg1 is float, arg2 is bignum\n         #BASR #14,#15             Convert bignum to float\n         LDR   #F4,#F0             Get float value for arg2\n         B     MULDFLO2            Go to MUL float arg1 to arg2\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO DOUBLE FLOAT                         *\n*---------------------------------------------------------------------*\nDFLOPFIX L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F4,#F0             GET FLOAT VALUE 2\n         B     MULDFLO2            FLOAT * FIXED = FLOAT\n         SPACE\n*---------------------------------------------------------------------*\n*                       SINGLE FLOAT MULTIPLY                         *\n*---------------------------------------------------------------------*\nSMULSFLO DS    0H\n         LE    #F2,##CDR(,#6)      Get single float value 1\nMULSFLO1 DS    0H\n         LE    #F4,##CDR(,#7)      Get single float value 2\nMULSFLO2 DS    0H\n*\n* Warning: result of single-precision multiply is DOUBLE PRECISION...\n*\n         MER   #F2,#F4             MULTIPLY THEM\n         LRER  #F2,#F2             ROUND DOUBLE DOWN TO SINGLE\n         STE   #F2,ZLCWORK         PUT RESULT IN REG FOR ATOM-MAKING\n         L     #2,ZLCWORK\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\n*---------------------------------------------------------------------*\n*                       DOUBLE FLOAT MULTIPLY                         *\n*---------------------------------------------------------------------*\nDMULSFLO DS    0H\n         SDR   #F4,#F4\n         LE    #F4,##CDR(,#7)      Get double float value 2\n         B     MULDFLO2\nSMULDFLO DS    0H\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#6)      Get double float value 1\nMULDFLO1 DS    0H\n         LD    #F4,8(,#7)          Get double float value 2\nMULDFLO2 DS    0H\n         MDR   #F2,#F4             MULTIPLY THEM\n         LDR   #F0,#F2\n         L     #15,ZLCMDF          Get address of ZILMDF\n         #BASR #14,#15             Call ZILMDF to make a double-float\n         B     RETURN              AND RETURN WITH IT\n         EJECT\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION SUBROUTINE\n         EJECT\n         PUSH  PRINT\n         PRINT DATA\n         SPACE 1\n         DS    0A                  ALIGN FIXNUM TO FULLWORD\nTWO31M   DC    YL1(##FIXNUM),AL3(0),F'-2147483648'  MOST NEG FIXNUM\n         SPACE 1\n         DS    0A                  ALIGN BIGNUM TO FULLWORD\nTWO31    DC    YL1(##BIGNUM),AL3(8),F'0,1'    2**31 SMALLEST BIGNUM\n         SPACE 1\n         DS    0A                  ALIGN BIGNUM TO FULLWORD\nTWO62    DC    YL1(##BIGNUM),AL3(12),F'0,0,1' 2**62 BIGNUM\n         SPACE 1\n         DS    0A                  ALIGN BIGNUM TO FULLWORD\nBIG8M    DC    YL1(##BIGNUM),AL3(8),X'80000000'\nBIG8     EQU   BIG8M,4\n         SPACE 1\n         POP   PRINT\n         SPACE 1\nERROR1   #ERR  'Argument 1 to multiply not a number - ',0(#11)\nERROR2   #ERR  'Argument 2 to multiply not a number - ',4(#11)\nBFBUG    #ERR  'Internal bug in ZILMUL BLFOOP routine multiplying ',   X\n               0(#11),' and ',4(#11)\nBUG2     DS    0H                  BUG\n         LM    #8,#11,ZLCISAVE     RESTORE THE SAVED REGISTERS\n         NI    ZLCIFLGS,255-ZLCISVD  INDICATE THAT REGISTERS RESTORED\n         #ERR  'Internal bug in ZILMUL',                               X\n               X'0D',              carriage return                     X\n               'Overflow on add logical when adding previous sum to carX\n               ry while multiplying ',                                 X\n               0(#11),' and ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILOPEN": {"ttr": 15361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x02\\xf6\\x02\\xf5\\x02\\xf5\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 758, "newlines": 757, "modlines": 757, "user": "SEB1525"}, "text": "         TITLE 'ZILOPEN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILOPEN TAKES TWO ARGUMENTS - (1) DATA SET NAME, (2) TYPE.          *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILOPEN  #ZBEG MINARGS=1,MAXARGS=2,NAME='ZILOPEN'\n         #ZPDS 2*4+12              DEFINE STACK SIZE\n         #ZSAV ARGS=2              SAVE REGISTERS\n         SPACE 1\n         NI    FLAGS,255-PROBEFLG-APPFLAG INITIALIZE FLAGS\n         LM    #1,#2,0(#11)        LOAD ARGUMENTS\n*                           Assume arg 2 is fixnum and check mode bits.\n         TM    ##CDR+##MODEB3(#2),##PROBE\n         BO    SETPROBE            PROBE mode, don't open, just probe\n         TM    ##CDR+##MODEB3(#2),##APPEND\n         BO    SETAPP              APPEND mode, open for append\n         TM    ##CDR+##MODEB3(#2),##OUTPUT\n         BO    SETOUT              OUTPUT mode, open for output\n******** B     SETIN               Open for input\nSETIN    DS    0H                  INDICATE INPUT MODE\n         MVI   DDCHAR,C'I'         SET FILE NAME TO ZILI....\n         MVI   STATUS99,X'08'      SET SVC 99 DISP = SHR\n         MVI   DISP99,X'08'        SET SVC 99 DISP = KEEP\n         B     MODESET\nSETOUT   DS    0H                  INDICATE OUTPUT MODE\n         MVI   DDCHAR,C'O'         SET FILE NAME TO ZILO....\n         MVI   STATUS99,X'01'      SET SVC 99 DISP = OLD\n         MVI   DISP99,X'08'        SET SVC 99 DISP = KEEP\n         B     MODESET\nSETAPP   DS    0H                  INDICATE OUTPUT MODE\n         OI    FLAGS,APPFLAG       SET APPEND FLAG\n         MVI   DDCHAR,C'O'         SET FILE NAME TO ZILO....\n         MVI   STATUS99,X'02'      SET SVC 99 DISP = MOD\n         MVI   DISP99,X'02'        SET SVC 99 DISP = CATLG\n         B     MODESET\nSETPROBE DS    0H                  INDICATE OUTPUT MODE\n         OI    FLAGS,PROBEFLG      SET NO FILE NAME, JUST PROBE\n         MVI   DDCHAR,C'I'         TREAT AS IF INPUT FILE\n         MVI   STATUS99,X'08'      SET SVC 99 DISP = SHR\n         MVI   DISP99,X'08'        SET SVC 99 DISP = KEEP\n******** B     MODESET\n         SPACE 1\nMODESET  DS    0H\n         NI    FLAGS,255-ALFLAG    INITIALIZE ALLOCATION FLAG\n*\n* SET THE FILE NAME WE WILL BE USING FOR THIS OPEN.\n*\n         LH    #3,ZLCFILNO         GET CURRENT FILE NUMBER\n         LA    #3,1(,#3)           ADD 1\n         STH   #3,ZLCFILNO         UPDATE FILE NUMBER\n         CVD   #3,ZLCDBL           CONVERT TO DECIMAL\n         UNPK  FILENAME(4),ZLCDBL\n         OI    FILENAME+3,X'F0'    MAKE IT PRINTABLE\n*\n* EXTRACT ARG 1 = DSNAME. #1 ALREADY CONTAINS ATOM TO BE DUMPED.\n*\n         CLI   ##TYPE(#1),##STRING IF ARG1 IS ALREADY A STRING\n         BE    GOODARG1            THEN JUST USE IT.  ELSE...\n         CLI   ##TYPE(#1),##SYMBOL IF ARG1 IS A SYMBOL\n         BNE   BADARG1             THEN...\n         L     #1,##PNAME(,#1)      GET THE PRINT NAME\nGOODARG1 DS    0H                  (ELSE ERROR - BAD DSNAME ARG)\n         XR    #6,#6\n         ICM   #6,7,1(#1)          GET LENGTH OF ATOM (DSNAME)\n         LA    #1,##VECDAT(,#1)    POINT TO TEXT OF DSNAME\n*\n* PARSE DSNAME AND INSERT IN SVC99 FIELDS.\n* NOTE #1 POINTS TO DSNAME.\n*\n         NI    FLAGS,255-MEMFLAG-FREEFLAG  INITIALIZE FLAGS\n         LA    #15,TUPLALLC        SET TEXT UNIT PTRS FOR ALLOCATION\n         ST    #15,S99TXTPP        STORE ADDR OF TEXT UNIT POINTERS\n         MVI   S99VERB,S99VRBAL    INDICATE ALLOCATION\n         MVI   DALMEMBR+1,X'00'    INITIALLY DON'T ALLOCATE MEMBER\n         MVI   DALTRK+1,X'00'       AND\n         MVI   DALPRIME+1,X'00'      NO\n         MVI   DALSECND+1,X'00'       SPACE\n         MVI   DALDIR+1,X'00'          SPECIFICATIONS\n         XC    MEMLEN99,MEMLEN99   SET MEMBER LENGTH TO ZERO\n         MVI   MEMBER99,C' '       SET MEMBER NAME TO BLANKS\n         MVC   MEMBER99+1(7),MEMBER99\n         XC    DSLEN99,DSLEN99     SET DSNAME LENGTH TO ZERO\n         MVI   DSNAME99,C' '       SET DSNAME TO BLANKS\n         MVC   DSNAME99+1(43),DSNAME99\n         XC    DSNSLEN,DSNSLEN     CLEAR FAKE STRING LENGTHS\n         XC    MEMSLEN,MEMSLEN     CLEAR FAKE STRING LENGTHS\n         LA    #7,DSNAME           POINT TO WHERE TO MOVE DSNAME\n         LA    #4,0(#1,#6)         POINT TO END OF DUMPED NAME\n         BCTR  #4,0                POINT TO LAST CHARACTER IN NAME\n         CLI   0(#1),C''''         SEE IF NAME IS QUOTED\n         BNE   NOQUOTE             IF IT STARTS WITH A QUOTE, THEN...\n         LA    #5,1(,#1)           POINT TO START OF TRUE DSNAME\n         BCTR  #6,0                TAKE 1 FROM LENGTH 4 INITIAL QUOTE\n         CLI   0(#4),C''''         IF IT DOES NOT END WITH A QUOTE\n         BNE   AFTQUOTE            AND IF THE LAST CHARACTER =  QUOTE\n         BCTR  #6,0                THEN MINUS 1 TO ALLOW FOR THAT ONE\n         B     AFTQUOTE            (THAT'S HOW LAST QUOTE IS OPTIONAL)\nNOQUOTE  DS    0H                  ELSE IF DSNAME HAS NO QUOTES\n         LR    #5,#1               POINT TO START OF TRUE DSNAME\n         L     #15,540             GET TCB ADDRESS\n         L     #15,X'B4'(,#15)     JSCB ADDRESS\n         L     #15,X'15C'(,#15)    CURRENT JSCB ADDRESS\n         L     #15,X'108'(,#15)    PSCB ADDRESS\n         LTR   #15,#15             IF NO PSCB\n         BZ    AFTQUOTE            THEN NO TSO ENV, ASSUME NO PREFIX\n         USING PSCB,#15\n         L     #15,PSCBUPT         UPT ADDRESS\n         DROP  #15\n         USING UPT,#15\n         XR    #14,#14             CLEAR INSERT REG\n         ICM   #14,1,UPTPREFL      GET LENGTH OF TSO PREFIX\n         BZ    AFTQUOTE            IF NONZERO, THEN...\n         BCTR  #14,0                REDUCE LENGTH\n         EX    #14,MVCPREF          MOVE PREFIX TO SVC99 DSNAME AREA\n         DROP  #15\n         LA    #7,DSNAME+1(#14)     POINT TO WHERE TO MOVE REST OF NAME\n         MVI   0(#7),C'.'           MOVE IN A PERIOD\n         LA    #7,1(,#7)            POINT TO WHERE TO MOVE DSNAME\nAFTQUOTE DS    0H\n*\n* NOW #5 --> DSNAME WITHOUT QUOTES\n*     #6 IS ITS LENGTH             (POSSIBLE (MEMBER) INCLUDED)\n*     #7 IS WHERE TO MOVE THE NAME (IN \"DSNAME\")\n*\n         LTR   #6,#6               IF LENGTH OF DSNAME IS ZERO\n         BNP   BADARG1             THEN SYNTAX ERROR\n         CH    #6,=H'56'           IF TOO LONG\n         BH    BADARG1             THEN SYNTAX ERROR\n         BCTR  #6,0                ELSE REDUCE FOR EXECUTE\n         EX    #6,MVCNAME          MOVE IT, MEMBER NAME & ALL\n         EX    #6,TRNAME           TRANSLATE TO UPPER CASE\n         LA    #4,0(#7,#6)         POINT TO LAST CHARACTER OF DSNAME\n         CLI   0(#4),C')'          IF DSNAME ENDS IN RIGHT PARENTHESIS\n         BE    EXTRACTM            THEN EXTRACT MEMBER NAME\n         LA    #4,1(,#4)           ELSE POINT TO TRUE END\n         NI    FLAGS,255-MEMFLAG   SHOW NO MEMBER REQUESTED\n         B     SETDSN\n         SPACE 1\nEXTRACTM DS    0H                  GET MEMBER: #7 -> START OF DSNAME\n         LA    #2,0(,#4)           POINT TO ) TERMINATING MEMBER NAME\nMEMLOOP  CR    #4,#7               IF NO ( FOUND, OR 1ST CHAR IS (,\n         BNH   BADARG1             THEN SYNTAX ERROR IN DSNAME\n         CLI   0(#4),C'('          SEARCH FOR LEFT PARENTHESIS\n         BE    GOTMEM\n         BCT   #4,MEMLOOP\nGOTMEM   DS    0H                  GOT MEMBER NAME, #4 --> (\n         LA    #6,1(,#4)           POINT TO MEMBER NAME ITSELF\n         SR    #2,#6               GET LENGTH OF MEMBER NAME\n         BNP   BADARG1             IF ZERO, SYNTAX ERROR\n         CH    #2,=H'8'            IF TOO LONG, SYNTAX ERROR\n         BH    BADARG1\n         STH   #2,MEMLEN99         ELSE SET MEMBER NAME LENGTH\n         STCM  #2,B'0111',MEMSLEN  STORE MEMBER LENGTH FOR FAKE STRING\n         BCTR  #2,0                ELSE REDUCE FOR EXECUTE\n         EX    #2,MVCMEM           MOVE MEMBER NAME TO S99 AREA\n         MVC   MEMSTXT(8),MEMBER99 MOVE MEMBER NAME TO FAKE STRING\n         OI    FLAGS,MEMFLAG       SHOW A MEMBER IS BEING REQUESTED\n         CLI   DDCHAR,C'O'         IF THIS IS AN OUTPUT REQUEST\n         BNE   NOMEMAL             THEN...\n         TM    FLAGS,APPFLAG        IF THIS IS AN APPEND REQUEST\n         BO    BADAPP               THEN WE CAN'T HONOR IT\n         MVI   DALMEMBR+1,X'03'     SET UP TO ALLOCATE THE MEMBER\nNOMEMAL  DS    0H                  ELSE ALLOCATE WITHOUT MEMBER FIRST\n         SPACE 1\nSETDSN   DS    0H\n         LA    #0,DSNAME\n         SR    #4,#0               #4 = LENGTH OF ACTUAL DSNAME\n         BNP   BADARG1\n         CH    #4,=H'44'\n         BH    BADARG1\n         STCM  #4,B'0111',DSNSLEN  STORE DSNAME LENGTH FOR FAKE STRING\n         BCTR  #4,0                REDUCE FOR EXECUTE\n         EX    #4,MVCDSN           MOVE TO SVC99 DSNAME AREA\n         LA    #4,1(,#4)           MAKE IT THE ACTUAL LENGTH\n         STH   #4,DSLEN99          SET DSNAME LENGTH\n         EJECT\n*\n* PERFORM DYNAMIC ALLOCATION.\n*\nTRYIT    DS    0H\n         SPACE 1\n         LA    #1,S99RBP           POINT TO SVC 99 PARAMETER LIST\n         DYNALLOC ,                DYNAMICALLY ALLOCATE THE DATASET\n         SPACE 1\n         LTR   #15,#15             IF ALLOCATION FAILED,\n         BZ    CHKDSORG            THEN\n*\n* ALLOCATION FAILURE...\n*  IF OUTPUT REQUEST AND NOT-CATALOGED, TRY AS NEW DATASET.\n*   IF FILE IN USE, FREE FILE AND RETRY REQUEST.\n*   OTHERWISE REPORT ERROR.\n*\n         ST    #15,DRETCODE         STORE SVC 99 RETURN CODE\n         MVC   DERROR,S99ERROR      STORE SVC 99 ERROR CODE\n         MVC   DINFO,S99INFO        STORE SVC 99 INFO CODE\n         CLC   DRETCODE(6),ERNOTCAT  IF ERROR = DATA SET NOT CATALOGED\n         BE    DFNOTCAT              THEN HANDLE IT\n         CLC   DRETCODE(8),ERBADDSN  IF ERROR = SYNTAX ERROR IN DSNAME\n         BE    DFBADDSN              THEN HANDLE IT\n         CLC   DRETCODE(8),ERBADMEM  IF ERROR = SYNTAX ERROR IN MEMBER\n         BE    DFBADMEM              THEN HANDLE IT\n         CLC   DRETCODE(6),ERFINUSE  IF ERROR = FILE NAME IN USE\n         BE    DFFINUSE              THEN HANDLE IT\n         B     TRUERROR             ELSE TRUE ERROR - CALL DAIRFAIL\n         SPACE 1\nDFNOTCAT DS    0H                  DATA SET NOT CATALOGED\n         TM    FLAGS,PROBEFLG      IF PROBE ONLY\n         BO    RETNIL              THEN RETURN NIL FROM THIS FUNCTION\n         CLI   DDCHAR,C'O'         IF TYPE IS NOT OUTPUT,\n         BNE   TRUERROR            THEN IT'S A TRUE ERROR\n         MVI   STATUS99,X'04'      ELSE RESET STATUS AND DISPOSITION\n         MVI   DISP99,X'02'         TO DISP=(NEW,CATLG)\n         MVI   DALTRK+1,X'07'        AND\n         MVI   DALPRIME+1,X'0A'       DEFINE\n         MVI   DALSECND+1,X'0B'        SPACE\n         MVI   DALDIR+1,X'00'           SPECIFICATIONS\n         TM    FLAGS,MEMFLAG       IF A MEMBER NAME WAS SPECIFIED\n         BZ    TRYIT               THEN...\n         MVI   DALDIR+1,X'0C'       SET NUMBER OF DIRECTORY BLOCKS\n         B     TRYIT               AND TRY DYNAMIC ALLOCATION AGAIN\n         SPACE 1\nDFFINUSE DS    0H                  FILE NAME ALREADY IS USE\n*\n* RESET THE FILE NAME WE WILL BE USING FOR THIS OPEN.\n*\n         LH    #1,ZLCFILNO         GET CURRENT FILE NUMBER\n         LA    #1,1(,#1)           ADD 1\n         STH   #1,ZLCFILNO         UPDATE FILE NUMBER\n         CVD   #1,ZLCDBL           CONVERT TO DECIMAL\n         UNPK  FILENAME(4),ZLCDBL\n         OI    FILENAME+3,X'F0'    MAKE IT PRINTABLE\n         B     TRYIT               AND TRY THE NEXT FILE NUMBER\n         EJECT\nTRUERROR DS    0H\n         LA    #1,DFPARMS           POINT TO DAIRFAIL PARAMETER LIST\n         LINK  EP=IKJEFF18          CALL DAIRFAIL\n         LTR   #0,#15               CHECK RETURN CODE\n         BNZ   ERROR14              IF OK, SHOW MESSAGE\nDFOK     DS    0H\n         L     #15,X'224'          ASCB ADDRESS\n         ICM   #15,15,X'3C'(#15)   TSB ADDRESS\n         BZ    NOTTSO              IF NO TSB, NOT UNDER TSO\n* ON TSO, SEND MESSAGE TO TERMINAL REGARDLESS OF OUTPUT DEST.\n         LA    #1,DFBUF1+4\n         LH    #2,DFBUF1+0\n         SH    #2,=H'4'\n         LR    #0,#2\n         #TPUT *,(1),(0)            USE TPUT TO DISPLAY 1ST MESSAGE\n         OC    DFBUF2(2),DFBUF2     IF THERE IS A SECOND MESSAGE\n         BZ    ERROR12              THEN\n         LA    #1,DFBUF2+4\n         LH    #2,DFBUF2+0\n         SH    #2,=H'4'\n         LR    #0,#2\n         #TPUT *,(1),(0)            USE TPUT TO DISPLAY 2ND MESSAGE\n         B     ERROR12\n         SPACE 1\nNOTTSO   DS    0H                  ELSE...\n*\n* IN BATCH, ISSUE WRITE-TO-PROGRAMMER MESSAGE.\n*\n         WTO   MF=(E,DFBUF1),ROUTCDE=11 SHOW MESSAGE 1\n         OC    DFBUF2(2),DFBUF2     IF THERE IS A SECOND MESSAGE\n         BZ    ERROR12              THEN\n         WTO   MF=(E,DFBUF2),ROUTCDE=11 SHOW IT\n         B     ERROR12              THEN\n         EJECT\nCHKDSORG DS    0H                  ALLOC OK, NOW CHECK DSORG\n         TM    FLAGS,FREEFLAG      IF THIS WAS A FREE REQUEST\n         BZ    SETALLCD            THEN\n         NI    FLAGS,255-ALFLAG     INDICATE DATASET UNALLOCATED\n         B     AFTALLCD            ELSE\nSETALLCD OI    FLAGS,ALFLAG         INDICATE DATASET ALLOCATED\nAFTALLCD DS    0H\n*\n* IF DSORG = PS THEN IF MEMBER WAS SPECIFIED, ERROR\n* IF DSORG - PO THEN IF MEMBER WAS OMITTED, ERROR\n* ELSE, FOR INPUT FILE, CHECK THAT MEMBER REALLY EXISTS\n*\n         TM    FLAGS,FREEFLAG      IF THIS WAS AN UNALLOCATION\n         BO    FREEDONE            THEN PROCEED.\n         TM    DSORG99,X'40'       IF DSORG = PS (SEQUENTIAL)\n         BO    DSORGPS             THEN HANDLE IT\n         TM    DSORG99,X'02'       IF DSORG = PO (PARTITIONED)\n         BO    DSORGPO             THEN HANDLE IT\n         CLI   DDCHAR,C'I'         IF THIS IS AN INPUT REQUEST\n         BE    ERROR20             THEN ERROR - INVALID DSORG\n         OC    DSORG99,DSORG99     IF THIS IS AN OUTPUT REQUEST\n         BNZ   ERROR20             THEN ERROR IF DSORG IS NOT NULL\nDSORGPS  DS    0H                  ELSE ASSUME PS (AT LEAST NOT PO)\n         TM    FLAGS,MEMFLAG       IF A MEMBER NAME WAS SPECIFIED\n         BO    ERROR16             THEN ERROR - MEMBER BUT NOT PDS\n         B     OK                  ELSE FINISHED CHECKING DSORG\n         SPACE 1\nDSORGPO  DS    0H\n         CLI   DDCHAR,C'O'         IF THIS IS AN OUTPUT REQUEST\n         BE    POOUT               THEN HANDLE IT\n         CLI   DALMEMBR+1,X'00'    IF WE ALREADY ALLOCATED THE MEMBER\n         BNE   OK                  THEN WE'VE CHECKED ALREADY - OK\n         TM    FLAGS,MEMFLAG       IF A MEMBER NAME WAS NOT SPECIFIED\n         BZ    ERROR17             THEN ERROR - MEMBER REQUIRED\n         MVC   PODCB+X'28'(8),DDNAME ELSE MOVE DDNAME TO OUR DCB\n         OPEN  PODCB               OPEN IT\n         TM    PODCB+X'30',X'10'   IF OPEN FAILED\n         BZ    ERROR19             THEN REPORT ERROR\n         MVC   BLDLMEM,MEMBER99    SET UP BLDL LIST TO CHECK MEMBER\n         BLDL  PODCB,BLDLLIST      SEE IF MEMBER NAME EXISTS\n         LR    #2,#15              SAVE RETURN CODE\n         CLOSE PODCB               CLOSE DATA SET\n         LTR   #2,#2               IF BLDL FAILED\n         BNZ   ERROR18             THEN ASSUME MEMBER NOT FOUND\n         LA    #1,TUPLUNAL         SET TEXT UNIT POINTERS FOR\n         ST    #1,S99TXTPP          UNALLOCATION\n         MVI   S99VERB,S99VRBUN    INDICATE UNALLOCATION\n         MVC   UNDDNAME,DDNAME     MOVE DDNAME TO TEXT UNIT FIELDS\n         OI    FLAGS,FREEFLAG      INDICATE WE'RE DOING AN UNALLOCATION\n         B     TRYIT               GO TO DO THE FREE\n         SPACE 1\nPOOUT    DS    0H                  PDS ALLOCATED FOR OUTPUT\n         SPACE 1\n         TM    FLAGS,MEMFLAG       IF A MEMBER NAME WAS NOT SPECIFIED\n         BZ    ERROR17             THEN ERROR - MEMBER REQUIRED\n         B     OK                  ELSE PROCEED\n         SPACE 1\nFREEDONE DS    0H                  FINISHED FREE, NOW REALLOC W/MEMBER\n         SPACE 1\n         TM    FLAGS,PROBEFLG      IF THIS WAS A PROBE\n         BO    OPENED              THEN PROCEED.\n         NI    FLAGS,255-FREEFLAG  INDICATE ALLOCATION THIS TIME\n         LA    #1,TUPLALLC         SET TEXT UNIT POINTERS FOR\n         ST    #1,S99TXTPP          ALLOCATION\n         MVI   S99VERB,S99VRBAL    INDICATE ALLOCATION\n         MVI   DALMEMBR+1,X'03'    SET UP TO ALLOCATE THE MEMBER\n         B     TRYIT               AND RE-ALLOCATE THE DATA SET\n         EJECT\nOK       DS    0H\n         TM    FLAGS,PROBEFLG      IF THIS WAS A PROBE\n         BO    OPENED              THEN PROCEED.\n*\n* MAKE AN ATOM OUT OF THE FILE NAME\n*\n         LA    #0,4                SET LENGTH OF 4-CHARACTER FILENAME\n         LA    #1,FILENAME         POINT TO ZIL FILE NAME FOR ATOM\n         LR    #2,#8               INTERN IT\n         LR    #3,#10              KEEP IT A SYMBOL\n         LA    #4,20(,#11)         SET CURRENT STACK POINTER FOR CONS\n         L     #15,ZLCABLD         CALL ZILABLD TO MAKE AN ATOM FROM IT\n         #BASR #14,#15             (RETURNS ATOM IN #15)\n         ST    #15,0(,#11)         STORE INTO STACK FOR #_FIL MACRO\n*\n* ALLOCATE THE REQUESTED DATA SET TO THE FILE\n*\n         CLI   DDCHAR,C'I'\n         BNE   OPENOUT\n         #IFIL 1                   CALL ZILFGET TO OPEN INPUT FILE\n         B     OPENED\nOPENOUT  DS    0H\n         #OFIL 1                   CALL ZILFGET TO OPEN OUTPUT FILE\n         SPACE 1\nOPENED   DS    0H                  FILE IS NOW OPEN\n*\n* RETURN WITH FILE ATOM IN REG 15\n*\n* IF PROBE, THIS WILL STILL CONTAIN THE INPUT ARG 1.\n*\n         TM    FLAGS,PROBEFLG+ALFLAG IF PROBE AND DATASET ALLOCATED\n         BNO   RETTNA              THEN\n         #BAS  #14,PFREE            FREE THE PROBED DATASET\nRETTNA   DS    0H\n         L     #15,0(,#11)         PICK UP FILE ATOM WE STORED\n         B     RETURN\n         SPACE 1\nRETNIL   DS    0H                  HERE IF PROBE AND FILE NOT FOUND\n         SPACE 1\n         TM    FLAGS,ALFLAG        IF DATASET STILL ALLOCATED\n         BZ    RETNILNA            THEN\n         #BAS  #14,PFREE            FREE THE PROBED DATASET\nRETNILNA DS    0H\n         LR    #15,#10             RETURN NIL\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         EJECT\nBADARG1  DS    0H                  ELSE...\n         SPACE 1\n         TM    FLAGS,PROBEFLG      IF PROBE\n         BO    RETNIL              THEN TREAT AS FILE NOT FOUND\n         SPACE 1\n         #ERR  'ZIL0010 OPEN: Invalid data set name - ',0(#11),        X\n               PREFIX=NO\n         SPACE 1\nBADAPP   DS    0H                  ELSE...\n         SPACE 1\n         #ERR  'ZIL0015 OPEN: Cannot process partitioned data set ',   x\n               0(#11),' in APPEND mode.',PREFIX=NO\n         SPACE 1\nBADDSN   DS    0H                  DSNAME SYNTAX ERROR\n         SPACE 1\n         TM    FLAGS,PROBEFLG      IF PROBE\n         BO    RETNIL              THEN TREAT AS FILE NOT FOUND\n         SPACE 1\n         #ERR  'ZIL0013 OPEN: Syntax error in data set name ',DSNSTR,  X\n               PREFIX=NO\n         SPACE 1\nBADMEM   DS    0H                  MEMBER NAME SYNTAX ERROR\n         SPACE 1\n         TM    FLAGS,PROBEFLG      IF PROBE\n         BO    RETNIL              THEN TREAT AS FILE NOT FOUND\n         SPACE 1\n         #ERR  'ZIL0013 OPEN: Syntax error in member name ',           X\n               DSNSTR,'(',MEMSTR,')',PREFIX=NO\n         SPACE 1\nDFBADDSN EQU   BADDSN              SYNTAX ERROR IN DATA SET NAME\n         SPACE 1\nDFBADMEM EQU   BADMEM              SYNTAX ERROR IN MEMBER NAME\n         SPACE 1\nERROR14  DS    0H                  REPORT HORRIBLE DISASTER\n         SPACE 1\n         #ERR  3,'ZIL0014 IKJEFF18 (DAIRFAIL) error - unable to displayX\n                allocation failure message.',SIGNAL=NO,PREFIX=NO\n******** B     ERROR12\n         SPACE 1\nERROR12  DS    0H                  ALLOCATION FAILED\n         SPACE 1\n         #ERR  'ZIL0012 OPEN: Allocation failed for ',DSNSTR,          X\n               PREFIX=NO\n         SPACE 1\nERROR16  DS    0H                  ERROR INSIDE OS STUFF\n         SPACE 1\n         #BAS  #14,PFREE           FREE DATASET IF ALLOCATED\n         SPACE 1\n         TM    FLAGS,PROBEFLG      IF PROBE\n         BO    RETNIL              THEN TREAT AS FILE NOT FOUND\n         SPACE 1\n         #ERR  'ZIL0016 OPEN: Member ',MEMSTR,                         X\n               ' specified but data set ',                             X\n               DSNSTR,' not partitioned.',PREFIX=NO\n         SPACE 1\nERROR17  DS    0H                  ERROR INSIDE OS STUFF\n         SPACE 1\n         #BAS  #14,PFREE           FREE DATASET IF ALLOCATED\n         SPACE 1\n         #ERR  'ZIL0017 OPEN: A member name must be specified for data X\n               set ',DSNSTR,PREFIX=NO\n         SPACE 1\nERROR18  DS    0H                  ERROR INSIDE OS STUFF\n         SPACE 1\n         TM    FLAGS,PROBEFLG      IF PROBE\n         BO    RETNIL              THEN TREAT AS FILE NOT FOUND\n         SPACE 1\n         #BAS  #14,PFREE           FREE DATASET IF ALLOCATED\n         SPACE 1\n         #ERR  'ZIL0018 OPEN: Member ',MEMSTR,                         X\n               ' not found in data set ',DSNSTR,PREFIX=NO\n         SPACE 1\nERROR19  DS    0H                  ERROR INSIDE OS STUFF\n         SPACE 1\n         #BAS  #14,PFREE           FREE DATASET IF ALLOCATED\n         SPACE 1\n         #ERR  'ZIL0019 OPEN: Unable to open ',DSNSTR,' to verify membeX\n               r ',MEMSTR,PREFIX=NO\n         SPACE 1\nERROR20  DS    0H                  ERROR INSIDE OS STUFF\n         SPACE 1\n         #BAS  #14,PFREE           FREE DATASET IF ALLOCATED\n         SPACE 1\n         #ERR  'ZIL0020 OPEN: Data set ',DSNSTR,' not sequential or parX\n               titioned, or is empty.',PREFIX=NO\n         EJECT\nPFREE    DS    0H                   FREE PROBED DATASET\n         SPACE 1\n         LA    #1,TUPLUNAL          SET TEXT UNIT POINTERS FOR\n         ST    #1,S99TXTPP           UNALLOCATION\n         MVI   S99VERB,S99VRBUN     INDICATE UNALLOCATION\n         MVC   UNDDNAME,DDNAME      MOVE DDNAME TO TEXT UNIT FIELDS\n         LA    #1,S99RBP           POINT TO SVC 99 PARAMETER LIST\n         DYNALLOC ,                DYNAMICALLY UNALLOCATE THE DATASET\n*                                  (IGNORE FREE ERRORS FOR NOW)\n         BR    #14\n         EJECT\n*\n* EXECUTED INSTRUCTIONS\n*\nMVCNAME  MVC   0(*-*,#7),0(#5)     MOVE ATOM TO DSNAME AREA\nTRNAME   TR    0(*-*,#7),TRTBL     FOLD DSNAME TO UPPER CASE\n         USING UPT,#15\nMVCPREF  MVC   0(*-*,#7),UPTPREFX  MOVE TSO PREFIX TO DSNAME AREA\n         DROP  #15\nMVCDSN   MVC   DSNAME99(*-*),DSNAME MOVE DSNAME TO SVC 99 AREA\nMVCMEM   MVC   MEMBER99(*-*),0(#6)  MOVE MEMBER TO SVC 99 AREA\n         EJECT\n*\n* CONSTANTS FOR COMPARING DYNAMIC ALLOCATION ERRORS.\n*\nERNOTCAT DC    FL4'04',X'1708'         DATA SET NOT CATALOGED\nERBADDSN DC    FL4'12',X'035C',X'0002' SYNTAX ERROR IN DATA SET NAME\nERBADMEM DC    FL4'12',X'035C',X'0003' SYNTAX ERROR IN MEMBER NAME\nERFINUSE DC    FL4'04',X'0410'         FILE NAME IN USE\n         EJECT\n*\n* CHARACTER WORK AREAS\n*\n         DS    0H,XL1              Align to non-halfword boundary\nDSNSTR   DC    YL1(##STRING)       String header\nDSNSLEN  DC    AL3(0)              String length\nDSNAME   DC    CL64' '             String text\n         DS    0H,XL1              Align to non-halfword boundary\nMEMSTR   DC    YL1(##STRING)       String header\nMEMSLEN  DC    AL3(0)              String length\nMEMSTXT  DC    CL8' '              String text\n         EJECT\n***********************************************************************\n* DYNAMIC ALLOCATION CONTROL BLOCKS                                   *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n* *** COPIED FROM 'SYS1.MACLIB(IEFZB4D0)' *************************** *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                SVC 99 INPUT REQUEST BLOCK\n***********************************************************************\n         SPACE 1\nS99RBP   DS    0D\nS99RBPTR DC    A(S99RB+X'80000000')    REQUEST BLOCK POINTER\nS99RB    DS    0D                      REQUEST BLOCK\nS99RBLN  DC    YL1(20)                 LENGTH OF REQUEST BLOCK\nS99VERB  DC    YL1(S99VRBAL)           VERB CODE = ALLOCATION\n*              YL1(S99VRBUN)           VERB CODE = ALLOCATION\nS99VRBAL EQU   X'01'                    ALLOCATION\nS99VRBUN EQU   X'02'                    UNALLOCATION\nS99FLAG1 DS    0CL2                    FLAGS\nS99FLG11 DC    XL1'00'                 FIRST FLAGS BYTE\nS99FLG12 DC    XL1'00'                 SECOND BYTE OF FLAGS\nS99RSC   DS    0CL4                    REASON CODE FIELDS\nS99ERROR DC    XL2'0000'               ERROR REASON CODE\nS99INFO  DC    XL2'0000'               INFORMATION REASON CODE\nS99TXTPP DC    A(TUPLALLC)             ->LIST OF ALLOC TEXT UNIT PTRS\n*              A(TUPLUNAL)             ->LIST OF UNALC TEXT UNIT PTRS\n*              A(TUPLALLP)             ->LIST OF PROBE TEXT UNIT PTRS\nS99RSV01 DC    F'0'                    RESERVED\nS99FLAG2 DS    0CL4                    FLAGS FOR AUTHORIZED FUNCTIONS\nS99FLG21 DC    XL1'00'                 FIRST BYTE OF FLAGS\nS99FLG22 DC    XL1'00'                 SECOND BYTE OF FLAGS\nS99FLG23 DC    XL1'00'                 THIRD BYTE OF FLAGS\nS99FLG24 DC    XL1'00'                 FOURTH BYTE OF FLAGS\nS99RBEND EQU    *                      END MARKER\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT POINTER LIST FOR ALLOCATION FUNCTIONS\n***********************************************************************\n         SPACE 1\nTUPLALLC DS    0F                      TEXT UNIT POINTER LIST FOR OPEN\n         DC    A(DALDDNAM)             DDNAME\n         DC    A(DALDSNAM)             DSNAME\n         DC    A(DALMEMBR)             MEMBER NAME\n         DC    A(DALSTATS)             STATUS\n         DC    A(DALNDISP)             NORMAL DISPOSITION\n         DC    A(DALTRK)               ALLOCATION IN TRACKS\n         DC    A(DALPRIME)             PRIMARY SPACE QUANTITY\n         DC    A(DALSECND)             SECONDARY SPACE QUANTITY\n         DC    A(DALDIR)               NUMBER OF DIRECTORY BLOCKS\n         DC    A(DALRTORG+X'80000000') RETURN DSORG\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT POINTER LIST FOR UNALLOCATION FUNCTIONS\n***********************************************************************\n         SPACE 1\nTUPLUNAL DS    0F                      TEXT UNIT POINTER LIST\n         DC    A(DUNDDNAM+X'80000000') DDNAME\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR ALLOCATION OF A DDNAME FOR DSNAME\n***********************************************************************\n         SPACE 1\nDALDDNAM DS    0H                      TEXT UNIT\n         DC    XL2'0001'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0008'               LENGTH OF DDNAME\nDDNAME   DC    CL8'ZIL     '\n         ORG   DDNAME\n         DS    CL3\nDDCHAR   DC    C' '                I OR O\nFILENAME DS    CL4\n         ORG\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR ALLOCATION BY DSNAME\n***********************************************************************\n         SPACE 1\nDALDSNAM DS    0H                      TEXT UNIT\n         DC    XL2'0002'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\nDSLEN99  DC    XL2'0000'               LENGTH OF DSNAME\nDSNAME99 DC    CL44' '                 DSNAME\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR ALLOCATION OF MEMBER NAME\n***********************************************************************\n         SPACE 1\nDALMEMBR DS    0H                      TEXT UNIT\n         DC    XL2'0003'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\nMEMLEN99 DC    XL2'0000'               LENGTH OF MEMBER NAME\nMEMBER99 DC    CL8' '                  MEMBER NAME\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR DATA SET STATUS\n***********************************************************************\n         SPACE 1\nDALSTATS DS    0H                      TEXT UNIT\n         DC    XL2'0004'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0001'               LENGTH OF STATUS\nSTATUS99 DC    X'08'                   STATUS = SHR\n*              X'04'                   STATUS = NEW\n*              X'02'                   STATUS = MOD\n*              X'01'                   STATUS = OLD\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR NORMAL DISPOSITION\n***********************************************************************\n         SPACE 1\nDALNDISP DS    0H                      TEXT UNIT\n         DC    XL2'0005'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0001'               LENGTH OF NORMAL DISPOSITION\nDISP99   DC    X'08'                   DISP = KEEP\n*              X'04'                   STATUS = DELETE\n*              X'02'                   STATUS = CATALOG\n*              X'01'                   STATUS = UNCATALOG\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR ALLOCATION IN TRACKS\n***********************************************************************\n         SPACE 1\nDALTRK   DS    0H                      TEXT UNIT\n         DC    XL2'0007'               KEY\n         DC    XL2'0000'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0000'               LENGTH\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR PRIMARY SPACE ALLOCATION\n***********************************************************************\n         SPACE 1\nDALPRIME DS    0H                      TEXT UNIT\n         DC    XL2'000A'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0003'               LENGTH\n         DC    AL3(10)                 DEFAULT PRIMARY # OF TRACKS\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR SECONDARY SPACE ALLOCATION\n***********************************************************************\n         SPACE 1\nDALSECND DS    0H                      TEXT UNIT\n         DC    XL2'000B'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0003'               LENGTH\n         DC    AL3(10)                 DEFAULT SECONDARY # OF TRACKS\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR NUMBER OF DIRECTORY BLOCKS\n***********************************************************************\n         SPACE 1\nDALDIR   DS    0H                      TEXT UNIT\n         DC    XL2'000C'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0003'               LENGTH\n         DC    AL3(35)                 DEFAULT # OF DIRECTORY BLOCKS\n*                                  (NOTE: NOT THE SAME AS IBM DEFAULT)\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR RETURN DSORG\n***********************************************************************\n         SPACE 1\nDALRTORG DS    0H                      TEXT UNIT\n         DC    XL2'0057'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0002'               LENGTH OF DSORG\nDSORG99  DS    XL2                     DSORG\n         SPACE 1\n***********************************************************************\n* SVC 99 TEXT UNIT FOR UNALLOCATION OF A DDNAME\n***********************************************************************\n         SPACE 1\nDUNDDNAM DS    0H                      TEXT UNIT\n         DC    XL2'0001'               KEY\n         DC    XL2'0001'               # OF LENGTH+PARAMETER ENTRIES\n         DC    XL2'0008'               LENGTH OF DDNAME\nUNDDNAME DS    CL8\n         EJECT\n***********************************************************************\n* DAIRFAIL (IKJEFF18) PARAMETER LIST                                  *\n***********************************************************************\n         SPACE 1\nDFPARMS  DS    0A\n         SPACE 1\nDFS99RBP DC    A(S99RB)            ADDRESS OF SVC 99 REQUEST BLOCK\nDFRCP    DC    A(DRETCODE)         ADDRESS OF SVC 99 RETURN CODE\nDFJEFF02 DC    A(ZEROES)           ADDRESS OF EP OF IKJEFF02 OR ZEROES\nDFIDP    DC    A(DFID)             ADDRESS OF 2-BYTE ID AREA\nDFCPPLP  DC    A(0)                ADDRESS OF CPPL NOT NEEDED\nDFBUFP   DC    A(DFBUFS)           ADDRESS OF BUFFER FOR MSG EXTRACTION\n         SPACE 1\nDFBUFS   DS    0A                  AREA FOR EXTRACTED MESSAGE\nDFBUF1   DS    2H,CL251            FIRST LEVEL MESSAGE AREA\nDFBUF2   DS    2H,CL251            SECOND LEVEL MESSAGE AREA\n         EJECT\n*\n* OTHER FIELDS\n*\n         DS    0A\nDRETCODE DS    XL4                 RETURN CODE FROM SVC99\nDERROR   DS    XL2                 COPY OF S99ERROR\nDINFO    DS    XL2                 COPY OF S99INFO\nZEROES   DC    F'0'\nDFID     DC    B'01000000',X'32'   EXTRACT MSG ONLY, CALLER = SVC99\n         SPACE 1\nBLDLLIST DC    Y(1,12)             BLDL LIST TO CHECK ONE MEMBER\nBLDLMEM  DS    CL8\n         DS    CL4\n         SPACE 1\nFLAGS    DS    X\nMEMFLAG  EQU   B'10000000'         1 = A MEMBER WAS REQUSTED\nFREEFLAG EQU   B'01000000'         1 = UNALLOCATION TO BE DONE\nPROBEFLG EQU   B'00100000'         1 = JUST PROBING\nALFLAG   EQU   B'00010000'         1 = DATASET IS ALLOCATED\nAPPFLAG  EQU   B'00001000'         1 = APPEND SPECIFIED\n         EJECT\nTRTBL    DC    256YL1(*-TRTBL)     TABLE TO FOLD TO UPPER CASE\n         ORG   TRTBL+X'81'\n         DC    C'ABCDEFGHI'\n         ORG   TRTBL+X'91'\n         DC    C'JKLMNOPQR'\n         ORG   TRTBL+X'A2'\n         DC    C'STUVWXYZ'\n         ORG\n         EJECT\nPODCB    DCB   DDNAME=X,DSORG=PO,MACRF=R\n         EJECT\n         LTORG\n         EJECT\n         #ZMODES ,                 Define OPEN/CLOSE file modes\n         EJECT\n         IKJPSCB\n         EJECT\n         IKJUPT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILPDSO": {"ttr": 15620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x00\\xd4\\x00\\xd1\\x00\\xd3\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 212, "newlines": 209, "modlines": 211, "user": "SEB1525"}, "text": "         TITLE 'ZILPDSO - ZIL 1.3 MISCELLANEOUS ERROR HANDLER'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* PDSO originally stood for \"PUSH DOWN STACK OVERFLOW\".               *\n*                                                                     *\n* THIS MODULE IS INVOKED WHEN A COMPILED ZIL FUNCTION DISCOVERS THAT  *\n* THERE IS NOT ENOUGH ROOM ON THE PUSH DOWN STACK TO EXECUTE.  THIS   *\n* CATCHES INFINITE RECURSION ERRORS.                                  *\n*                                                                     *\n* NOTE: ENTRY TO THIS MODULE IS NOT VIA REGISTER 15, BUT VIA          *\n*       REGISTER 2.  THIS INSURES THAT THE ENTRY POINT OF THE         *\n*       FUNCTION WHICH DETECTED THE STACK OVERFLOW CONDITION          *\n*       IS RETAINED.                                                  *\n*                                                                     *\n* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* FOR ZIL 1.1, THIS MODULE TRAPS TWO KINDS OF ERRORS:                 *\n*                                                                     *\n*   IF REGISTER 1 IS NON-NIL, A PUSH-DOWN-STACK OVERFLOW ERROR.       *\n*   IF REGISTER 1 IS NIL, AN UNBOUND-VARIABLE ERROR.                  *\n*                                                                     *\n* BOTH OF THESE ARE DETECTED BY CODE GENERATED BY THE COMPILER.       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* FOR ZIL 1.2, THIS MODULE TRAPS THREE KINDS OF ERRORS - THE TWO      *\n* DESCRIBED ABOVE, PLUS ATTENTION INTERRUPTS, WHICH ARE DETECTED BY   *\n* VIRTUE OF THE ZLCIATTN BIT BEING ON.                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILPDSO  CSECT\n         USING ZLCOMMON,#13\n         BALR  #3,0                SET UP LOCAL BASE REGISTER\n         USING *,#3\n         SPACE 1\n         TM    ZLCIFLGS,ZLCIATTN   IF CALLED FOR ATTENTION INTERRUPT\n         BO    ATTN                THEN GO DEAL WITH IT\n         SPACE 1\n         LR    #2,#15              SAVE EP OF CALLER\n         LR    #4,#1               SAVE REGISTER 1\n         CR    #4,#10              IF REGISTER 1 = NIL\n         BNE   EPIN15              THEN...\n         LR    #2,#12               EP OF CALLER IS IN REG 2\nEPIN15   DS    0H\n         SPACE 1\n*\n* Extract function name for insertion into message\n*\n         SPACE 1\n         XR    #1,#1               Clear insert register\n         STCM  #1,7,FUNLEN         Initialize fake string length to 0\n         IC    #1,4(,#2)           Get length of module identifier\n         SH    #1,=H'16'           Subtract length of date/time info\n         BNP   SKIPNAME            If no name, skip move\n         CH    #1,=Y(L'FUNTEXT)    If longer than our maximum\n         BNH   *+8                 then\n         LA    #1,L'FUNTEXT         use our maximum length\n         STCM  #1,7,FUNLEN         Store length into fake string\n         BCTR  #1,0                Reduce for execute\n         EX    #1,MVCNAME          Move function name to fake string\nSKIPNAME DS    0H\n*\n* Determine what kind of error this was\n*\n         CR    #4,#10              IF REGISTER 1 IS ZERO\n         BE    UVERROR             THEN THIS IS UNBOUND-VARIABLE ERROR\n*                                  ELSE THIS IS STACK OVERFLOW ERROR\n         #ERR  PREFIX=NO,          DISPLAY ERROR MESSAGE               X\n               'ZIL1000 ',FUNSTR,': Control stack overflow.  Possible iX\n               nfinite recursion.'\n         SPACE 1\nUVERROR  DS    0H                  UNBOUND VARIABLE ERROR\n*                                  TRY TO FIND WHICH VARIABLE IT IS\n*                                  #2 -> START OF MODULE CODE\n         XR    #15,#15\n         IC    #15,4(,#2)          GET LENGTH OF MODULE HEADER ID\n         LA    #2,5+3(#15,#2)      POINT PAST MODULE HEADER\n         N     #2,=X'FFFFFFFC'     ROUND UP TO FULLWORD BOUNDARY\n         LA    #2,12(,#2)          POINT PAST ZINT INFO\n         LA    #0,4\nGETATOMS L     #15,0(,#2)          LOAD POSSIBLE POINTER TO ATOMS\n         N     #15,=X'7FFFFFFF'    CLEAR HIGH ORDER BIT\n         LTR   #15,#15             IF POINTER IS NONZERO,\n         BNZ   GOTATOMS            THEN THIS POINTS TO SYMBOLS\n         LA    #2,4(,#2)           ELSE TRY NEXT ONE\n         BCT   #0,GETATOMS         OUT OF 4 POSSIBLE POINTERS\n         B     GIVEUP              IF NONE, JUST GIVE UP\nGOTATOMS DS    0H                  NOW #15 POINTS TO ATOM POINTERS\nFINDSYM  DS    0H                  BUT WE GOTTA BUMP TO 1ST SYMBOL PTR\n         L     #1,0(,#15)\n         CLI   ##TYPE(#1),##SYMBOL\n         BE    GOTSYM\n         LA    #15,4(,#15)\n         B     FINDSYM\nGOTSYM   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IT IS ASSUMED THAT THE SYMBOL POINTERS START OUT WITH THE SYMBOLS   *\n* REPRESENTING FREE VARIABLES, IN THE SAME ORDER AS THE CODE TRIES    *\n* TO FILL THEM IN.  THE COMPILER INSURES THIS.                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nFINDXC   CR    #2,#15              GOT TO STOP SEARCHING SOMEWHERE\n         BNL   GIVEUP              SO ABANDON ALL HOPE WHEN AT ZLBPTRS\n         CLI   0(#2),X'D7'         WHEN WE FOUND ONE\n         BE    GOTXC               THEN CHECK IT OUT\n         LA    #2,2(,#2)           ELSE BUMP BY 2 EACH TIME\n         B     FINDXC\nGOTXC    DS    0H                  NOW #2 -> AN XC INSTRUCTION\n         LA    #1,X'FFF'           EXTRACT THE DISPLACEMENT OF THE\n         N     #1,0(,#2)           STACK POINTERS TO FREE VARIABLES\n         AR    #1,#11              CONVERT TO POINTER TO STACK SLOTS\n         XR    #0,#0\n         IC    #0,1(,#2)           GET LENGTH OF STACK FROM XC INSTR\n         AR    #0,#1               CONVERT TO END-1 OF STACK SLOTS\nFINDUV   CR    #1,#0\n         BNL   GIVEUP              IF NOT FOUND, GIVE UP\n         ICM   #14,15,0(#1)        CHECK THIS STACK SLOT\n         BZ    GOTUV               IF ZERO, THIS IS THE UNBOUND VAR\n         LA    #15,4(,#15)         ELSE BUMP TO NEXT SYMBOL POINTER\n         LA    #1,4(,#1)           TRY NEXT STACK SLOT\n         B     FINDUV\nGOTUV    DS    0H\n         L     #6,0(,#15)          GET POINTER TO SYMBOL\nGIVEUP   DS    0H\n         #ERR  PREFIX=NO,          DISPLAY ERROR MESSAGE               X\n               'ZIL1300 ',FUNSTR,': Unbound lexical variable - ',(#6)\n         EJECT\nMVCNAME  MVC   FUNTEXT(*-*),5(#2)  Executed: Move function name to str\n         SPACE 1\n         DS    0H,XL1              Align fake string to non-halfword\nFUNSTR   DC    YL1(##STRING)\nFUNLEN   DS    AL3\nFUNTEXT  DS    CL64\n         EJECT\nATTN     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE RECEIVES CONTROL WHEN THE ZIL USER HITS ATTENTION AND  *\n* PROCESSING IS FORCED THROUGH THIS PATH VIA THE INSERTION OF A       *\n* \"BR 13\" INSTRUCTION INTO THE CODE WHERE THE ATTENTION WAS DETECTED, *\n* OR VIA AN EXPLICIT CHECK IN A LOW-LEVEL ZIL ROUTINE.  PROCESSING:   *\n*                                                                     *\n*     IF THE ZLCISYS BIT IS ON, INDICATING THAT ATTENTION WAS HIT     *\n*     WHILE NON-ZIL CODE WAS RUNNING, THEN ZIL REGISTERS HAVE TO BE   *\n*     RESTORED - AND REMEMBER TO SET ZLCISYS OFF.  OTHERWISE, IF      *\n*     AN INSTRUCTION HAD TO BE OVERLAID TO GET US UP HERE, THEN       *\n*     RESTORE THE ORIGINAL INSTRUCTION.  THEN ISSUE A NOP (BC 0,0)    *\n*     TO SYNCHRONIZE THE PROCESSOR JUST IN CASE THE OVERLAID          *\n*     INSTRUCTION WAS, LIKE, REAL CLOSE TO THIS CODE.  THEN PROCEED   *\n*     TO THROW TO THE APPROPRIATE CATCH TAG (I.E. T) TO RETURN THE    *\n*     ZIL USER TO PERCEIVED \"TOP LEVEL\".  WHILE AN INSTRUCTION IS     *\n*     OVERLAID, BIT ZLCIOVER WILL BE ON TO INDICATE THIS; SET IT OFF  *\n*     RIGHT AFTER RESTORING THE INSTRUCTION.  THIS BIT IS USED TO     *\n*     PREVENT THE OVERLAYING OF CODE IN THIS RECOVERY ROUTINE ITSELF  *\n*     IN CASE ATTENTION SHOULD BE HIT DURING IT.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    ZLCIFLGS,ZLCISYS    IF NON-ZIL CODE WAS RUNNING\n         BZ    NOTSYS              THEN...\n         NI    ZLCIFLGS,255-ZLCISYS RESTORE THE BIT\n         L     #8,ZLCT              RESTORE #8\n         L     #9,ZLCISV09          RESTORE #9\n         L     #10,ZLCNIL           RESTORE #10\n         B     ATTNDOIT            ELSE...\nNOTSYS   DS    0H                   (ZIL CODE WAS RUNNING)\n         TM    ZLCIFLGS,ZLCISVD    IF CODE IN PROGRESS ZAPPED REGS 8-11\n         BZ    REGSOK              THEN\n         LM    #8,#10,ZLCISAVE      RESTORE THEM FROM WHERE THEY SAVED\n         NI    ZLCIFLGS,255-ZLCISVD\nREGSOK   DS    0H\n         TM    ZLCIFLGS,ZLCIOVER   IF AN INSTRUCTION WAS OVERLAID\n         BZ    ATTNDOIT            THEN...\n         L     #1,ZLCINSTA         POINT TO OVERLAID INSTRUCTION\n         LH    #0,ZLCINSTR         GET ORIGINAL PIECE OF INSTRUCTION\n         STH   #0,0(,#1)           RESTORE ORIGINAL INSTRUCTION\n         BC    0,0                 SYNCHRONIZE INSTRUCTION PREFETCH\n         NI    ZLCIFLGS,255-ZLCIOVER RESET ZAPPED-INSTRUCTION FLAG\nATTNDOIT DS    0H\n         NI    ZLCIFLGS,255-ZLCIATTN RESET ATTN-IN-PROGRESS FLAG\n*\n* WE DON'T REALLY NEED THIS DUMB MESSAGE, BUT...\n*\n         #TPUT *,ATTNMSG           ISSUE MESSAGE\n         SPACE 1\n         LR    #1,#8               SET THROW TAG TO T\n         LR    #2,#10              SET THROW RESULT TO NIL\n         L     #15,ZLCTHROW        GET ADDRESS OF THROW PROCESSOR\n         BR    #15                 INVOKE THROW TO TAG T\n         SPACE 1\nATTNMSG  DC    C'ZIL0054 ATTENTION ABORT TO TOP LEVEL.'\n         SPACE\n         LTORG\n         SPACE\n         #ZEQU\n         SPACE\n         #ZCOM\n         SPACE\n         #ZINT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILPKCH": {"ttr": 15624, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x00R\\x00O\\x00Q\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 82, "newlines": 79, "modlines": 81, "user": "SEB1525"}, "text": "         TITLE 'ZILPKCH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILPKCH TAKES THREE (OPTIONAL) ARGUMENTS:                           *\n*                                                                     *\n* (1) INPUT FILE SPECIFICATION                                        *\n* (2) WHETHER (T) OR NOT (NIL) TO INTERN THE RESULTING ATOM.          *\n* (3) WHETHER (T) OR NOT (NIL) TO FOLD THE CHARACTER TO UPPER CASE.   *\n*                                                                     *\n* ZILPKCH IS IDENTICAL TO READCH EXCEPT THAT IT DOES NOT ADVANCE THE  *\n* CURRENT CHARACTER POINTER.  COMPARE COMMON LISP PEEK-CHAR.          *\n*                                                                     *\n* THIS FUNCTION IS INTENDED FOR USE IN SYSTEMS WHERE FUNCTIONS LIKE   *\n* TYIPEEK ARE REQUIRED.                                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* In ZIL 1.2 this function was called PEEKCH.  The syntax of PEEKCH   *\n* has been changed to be compatible with Maclisp READCH (READCH was   *\n* changed to ZILRDCH similarly).  Common LISP READ-CHAR and PEEK-CHAR *\n* should be used instead of these functions.  Also TYI and TYIPEEK.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILPKCH  #ZBEG MINARGS=0,MAXARGS=3,NAME='ZILPKCH'\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         #IFIL 1                   ARG 1 = INPUT FILE SPEC\n         SPACE\n         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT\n         BO    RDAFTEOF            THEN ERROR - READ AFTER EOF\n         SPACE\n         ICM   #3,15,ZLFCHAR       GET CURRENT POSITION\n         BP    INPUTOK             IF POSITIVE, WE HAVE GOOD STUFF\n         LR    #15,#10             RETURN NIL IF EOF OR NEWLINE\n         B     RETURN\n         SPACE\nINPUTOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER\n         SPACE\n         LR    #1,#3               CONVERT RELATIVE COLUMN TO\n         BCTR  #1,0                 ABSOLUTE LOCATION IN LINE\n         A     #1,ZLFCARD            AND PASS IT TO ATOM BUILD RTE\n         C     #10,8(,#11)         IF ARG 3 IS NOT NIL\n         BE    DONTFOLD             OR\n         C     #13,8(,#11)           ARG 3 IS NOT SUPPLIED\n         BE    DONTFOLD               THEN\n         TR    0(1,#1),UPTBL        FOLD CHARACTER TO UPPER CASE.\nDONTFOLD DS    0H\n         ST    #3,ZLFCHAR          SAVE CHARACTER POINTER\n         LA    #0,1                LENGTH OF ATOM TO BE BUILT = 1\n         L     #2,4(,#11)          GET ARG 2 = WHETHER TO INTERN IT\n         LR    #3,#10              SET FORMAT FLAG = NIL\n         L     #15,ZLCABLD         GET ADDRESS OF ZILABLD\n         LA    #4,24(,#11)         SET CURRENT STACK POINTER FOR CONS\n         #BASR #14,#15             CALL ZILABLD TO BUILD THE ATOM\n         SPACE\nRETURN   DS    0H                   MAKING #15 POINT TO NEW ATOM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nRDAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 ZILPKCH: Read after end of file ',(#2),        X\n               PREFIX=NO\n         SPACE 1\n         LTORG\n         SPACE 1\nUPTBL    DC    256YL1(*-UPTBL)     TABLE TO FOLD TO UPPER CASE\n         ORG   UPTBL+X'81'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+X'91'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+X'A2'\n         DC    C'STUVWXYZ'\n         ORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILPRIN": {"ttr": 15627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x02\\x17\\x02\\x14\\x02\\x16\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 535, "newlines": 532, "modlines": 534, "user": "SEB1525"}, "text": "         TITLE 'ZILPRIN - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE HANDLES ALL PRINTING REQUESTS.                      *\n*                                                                     *\n* ON ENTRY THE CALLER MUST SET THE FOLLOWING REGISTERS:               *\n*                                                                     *\n*   #4 -> THE S-EXPRESSION TO BE PRINTED.                             *\n*   #7 = THE FILE POINTER TO BE USED FOR THE PRINTING.                *\n*                                                                     *\n* THE CALLER MUST ALSO SET THE FOLLOWING BITS IN ZLCPFLGS:            *\n*                                                                     *\n*     ZLCPSLSH = 1 IF SLASHIFICATION IS REQUESTED, ELSE 0             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILPRIN  #ZBEG NAME='ZILPRIN'\n         USING ZILPRIN,#15\n         USING ZLFILBLK,#7\n         SPACE 1\n         OI    ZLCPFLGS,ZLCPRINT   INDICATE ZILPRIN ACTIVE\n         SPACE 1\n         L     #6,ZLCPSADR         SET INITIAL PRINT STACK POINTER\n         ST    #14,0(,#6)          SAVE REGISTER 14 (RETURN ADDRESS)\n         ST    #5,4(,#6)           SAVE REGISTER 5 (PARAMETER REGISTER)\n         ST    #12,8(,#6)          SAVE REGISTER 12 (BASE REGISTER)\n         LA    #6,12(,#6)          BUMP UP STACK POINTER\n         LA    #12,ZPCALL          CALL PRINTING ROUTINE\n         #BASR #14,#12\n         DROP  #15\n         SPACE 1\n         NI    ZLCPFLGS,255-ZLCPRINT NO MORE ZILPRIN ACTIVE\n         SPACE 1\n         LA    #14,12\n         SR    #6,#14              BUMP DOWN STACK POINTER\n         L     #14,0(,#6)          RESTORE REGISTER 14\n         L     #5,4(,#6)           RESTORE REGISTER 5\n         L     #12,8(,#6)          RESTORE REGISTER 12\n         LR    #15,#4              SET RETURN VALUE TO THING PRINTED\n         BR    #14                 RELOAD REGISTERS AND RETURN\n         SPACE 1\nZP14     DS    A\n         EJECT\nZPCALL   DS    0H                  THIS IS WHERE RECURSIVE CALLS GO\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* #3 = THE CURRENT CHARACTER OFFSET                                   *\n* #4 = THE THING TO BE PRINTED                                        *\n* #5 = NOTHING MUCH                                                   *\n* #6 = THE CURRENT CHARACTER POINTER                                  *\n* #7 = THE FILE POINTER                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING ZPCALL,#12\n         LA    #0,12(,#6)          MAKE SURE WE HAVE ENOUGH STACK SPACE\n         C     #0,ZLCPSEND         IF NOT,\n         BNL   STKOVFLO            THEN CANNOT PRINT THIS\n         ST    #14,0(,#6)          SAVE RETURN ADDRESS\n         SPACE 1\n         CR    #4,#13              IF EQUAL TO #13\n         BE    ISUOA               THEN IT'S UNSUPPLIED OPTIONAL ARG\n         C     #4,ZLCUNBND         IF EQUAL TO THE UNBOUND OBJECT\n         BE    ISUNB               THEN IT'S THE UNBOUND OBJECT\n         C     #4,ZLCRMNIL         IF EQUAL TO RMNIL\n         BE    ISRMN               THEN IT'S RMNIL\n         TM    ##TYPE(#4),##ATOM   IF NOT AN ATOM\n         BZ    ISALIST             THEN IT MUST BE A LIST\n         CLI   ##TYPE(#4),##VECTOR IF IT IS A VECTOR\n         BE    ISAVEC              THEN WE HAVE TO PRINT IT AS A VECTOR\n         CLI   ##TYPE(#4),##FUNARG IF IT IS A FUNARG\n         BE    ISAFUN              THEN WE HAVE TO PRINT IT AS A FUNARG\n         CLI   ##TYPE(#4),##STRUCT IF IT IS A STRUCTURE\n         BE    ISASTR              THEN WE HAVE TO PRINT IT AS A STRUCT\n         TM    ZLCPFLGS,ZLCPSLSH   IF SLASHIFICATION REQUESTED\n         BNO   NOSLASH             THEN...\n         LR    #1,#8                SET #1 TO GET SLASHIFICATION\n         B     AFTSLASH            ELSE...\nNOSLASH  LR    #1,#10               SET #1 NOT TO GET SLASHIFICATION\nAFTSLASH LR    #2,#4               SET ATOM TO BE DUMPED\n         L     #15,ZLCADMP         CALL ZILADMP TO DUMP FORMATTED ATOM\n         #BASR #14,#15             INTO OUTPUT AREA\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF WRITING TO A FILE WITH TABS MODE ON, AND NOT SLASHIFYING,        *\n* SCAN THE DATA FOR TABS AND NEWLINES, AND REFORMAT IF NECESSARY.     *\n* NOTE: CARRIAGE RETURNS (X'0D') AND NEWLINES (X'15') ARE TREATED     *\n*       THE SAME WAY.                                                 *\n*                                                                     *\n* #0 = THE LENGTH OF THE DATA TO BE PRINTED                           *\n* #1 --> THE DATA TO BE PRINTED                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #4,#1               GET ADDRESS OF INPUT STRING\n         LTR   #3,#0               GET ITS LENGTH.  IF NOT POSITIVE,\n         BNP   RETURN              THEN RETURN WITHOUT PRINTING.\n         TM    ZLCPFLGS,ZLCPSLSH   IF SLASHIFYING,\n         BO    PUTASIS             THEN WRITE IT AS IS\n         TM    ZLFFLAG2,ZLFTABS    IF NOT EXPANDING TABS/NEWLINES,\n         BZ    PUTASIS             THEN WRITE IT AS IS\n         LR    #14,#4              GET ADDRESS OF WHERE TO START SCAN\n         LR    #15,#3              GET INITIAL LENGTH FOR SCAN\nTRTLONG  DS    0H\n         CH    #15,=H'256'         IF LENGTH EXCEEDS MAX TRT LENGTH\n         BNH   TRTSHORT            THEN...\n         XR    #1,#1                PRIME TRT REGISTER\n         TRT   0(256,#14),TRTABLE   SCAN FOR TABS OR NEWLINES\n         BNZ   REFORMAT             IF WE FOUND ONE, GO REFORMAT\n         LA    #14,256(,#14)        ELSE BUMP POINTER TO SCAN\n         SH    #15,=H'256'          BUMP DOWN SCAN LENGTH\n         BZ    PUTASIS              IF NO MORE TO SCAN, PRINT ASIS\n         B     TRTLONG              ELSE CONTINUE SCANNING\nTRTSHORT DS    0H                  SCAN 256 CHARACTERS OR LESS\n         BCTR  #15,0               REDUCE SCAN LENGTH FOR EXECUTE\n         EX    #15,TRT1            SCAN FOR TABS OR NEWLINES\n         BZ    PUTASIS             IF NONE FOUND, PRINT IT ASIS. ELSE\nREFORMAT DS    0H                  WE HAVE TO DEAL WITH TABS/NEWLINES\n*                                  #3 = LENGTH OF DATA\n*                                  #4 --> DATA\n*                                  #1 --> FIRST TAB OR NEWLINE CHAR\n         LA    #0,0(#3,#4)         GET POINTER TO END OF DATA\n         ST    #0,INPUTEND         SAVE IT\n         LR    #5,#4               POINT TO INPUT TEXT\n*                                  COMPUTE TAB OFFSET BASED ON CHARPOS\n         L     #0,ZLFCHAR          GET CURRENT CHARACTER POSITION\n         BCTR  #0,0                CONVERT FROM COLUMN TO OFFSET\n         N     #0,=X'00000007'     CONVERT TO MODULO 8\n         ST    #0,TABOFF           STORE AS COMPUTED OFFSET FOR TABBING\n*\n* GET A TAB EXPANSION WORKAREA.  MAX NEEDED = CONTENTS(#3) * 8.\n*\n         LA    #1,16(,#3)          LENGTH OF DATA PLUS FUDGE FACTOR\n         SLA   #1,3                MULTIPLY BY (TABSIZE) 8\n         C     #1,ZLCTWALN         IF EXCEEDS CURRENT WORKAREA LENGTH\n         BNH   LENOK               THEN...\n         LA    #2,7(,#1)            SAVE LENGTH TO BE NEEDED,\n         N     #2,=X'FFFFFFF8'      ROUNDING IT UP TO DOUBLEWORD\n         ICM   #0,15,ZLCTWALN       GET LENGTH OF CURRENT WORKAREA\n         BZ    NOFRETWA             IF ZERO, THERE IS NONE RIGHT NOW\n         L     #1,ZLCTWA            GET ADDRESS OF CURRENT WORKAREA\n         FREEMAIN R,LV=(0),A=(1)    FREE IT\nNOFRETWA DS    0H\n         LR    #0,#2                GET LENGTH FOR GETMAIN\n         #GETMAIN RC,LV=(0),LOC=BELOW GET STORAGE FOR TAB WORKAREA\n         LTR   #15,#15             IF GETMAIN FAILED,\n         BNZ   NOTENUF             THEN ERROR - NOT ENOUGH STORAGE\n         ST    #1,ZLCTWA           SAVE NEW WORKAREA ADDRESS\n         ST    #2,ZLCTWALN         SAVE LENGTH OF NEW WORKAREA\nLENOK    DS    0H                  OK, NOW WE HAVE A WORKAREA\nMORE     DS    0H\n         C     #5,INPUTEND         WHEN REACHED END OF DATA\n         BNL   RETURN              RETURN\n         L     #14,ZLCTWA          GET ADDRESS OF START OF WORKAREA\nSCANLOOP DS    0H\n         L     #1,INPUTEND         PRIME TRT TERMINATOR\n         LR    #15,#1              COMPUTE LENGTH OF DATA TO BE SCANNED\n         SR    #15,#5              IF NO MORE DATA TO SCAN,\n         BNP   FINISHED             THEN PROCESS WHAT WE HAVE\nSCAN256  DS    0H\n         CH    #15,=H'256'         IF LENGTH EXCEEDS MAX TRT LENGTH\n         BNH   STRTSHRT            THEN...\n         XR    #2,#2                CLEAR TRT REGISTER\n         TRT   0(256,#5),TRTABLE    SCAN FOR NEXT TAB OR NEWLINE\n         BNZ   SAFTTRT              IF WE FOUND ONE, GO PROCESS IT\n         MVC   0(256,#14),0(#5)     ELSE MOVE REAL DATA TO WORK AREA\n         LA    #14,256(,#14)        BUMP OUTPUT POINTER BY LENGTH\n         LA    #5,256(,#5)          BUMP INPUT POINTER TO SCAN\n         SH    #15,=H'256'          BUMP DOWN SCAN LENGTH\n         BZ    FINISHED             IF NO MORE TO SCAN, FINISHED\n         B     SCAN256              ELSE CONTINUE SCANNING\nSTRTSHRT DS    0H                  SCAN 256 CHARACTERS OR LESS\n         BCTR  #15,0               ELSE REDUCE FOR EXECUTE\n         XR    #2,#2               CLEAR TRT REGISTER\n         EX    #15,TRT2            SCAN FOR NEXT TAB OR NEWLINE\nSAFTTRT  DS    0H\n*\n* BEFORE PROCESSING FUNNY CHARACTER, MOVE NORMAL DATA TO TAB WORKAREA\n*\n* #1 POINTS TO END-OF-DATA OR FUNNY CHARACTER WHERE WE STOP\n* #5 POINTS TO \"NORMAL\" INPUT DATA TO BE MOVED TO WORKAREA\n* #6 POINTS TO CURRENT LOCATION IN WORKAREA TO MOVE TO\n*\n         LR    #15,#1\n         SR    #15,#5              GET LENGTH OF DATA TO MOVE\n         BNP   NOMOVE              SKIP IF ZERO\n         BCTR  #15,0               REDUCE FOR EXECUTE\n         EX    #15,MVCDATA         MOVE DATA FROM INPUT TO WORKAREA\n         LA    #14,1(#15,#14)      BUMP OUTPUT POINTER BY LENGTH\nNOMOVE   LA    #5,1(,#1)           BUMP INPUT POINTER PAST FUNNY CHAR\n         B     CONTINUE(#2)        NOW BRANCH DEPENDING ON FUNNY CHAR\nCONTINUE B     FINISHED            END OF STRING - FINISH UP\n         B     HT                  FOUND TAB CHARACTER\n         B     NL                  FOUND NEWLINE CHARACTER\n         B     LB                  FOUND LEFT BRACKET\n         B     RB                  FOUND RIGHT BRACKET\n         SPACE 1\nHT       DS    0H                  PROCESS TAB\n         LA    #1,8(,#14)          SET UP ADDRESS TO TAB TO\n         N     #1,=X'FFFFFFF8'     ALIGN TO NEXT HIGHER DOUBLEWORD\n         S     #1,TABOFF           ADJUST FOR CHARACTER POSITION\n         CR    #14,#1              IF THIS IS STILL NOT CORRECT\n         BL    MTABLOOP            THEN\n         LA    #1,8(,#1)            BUMP IT UP 8 MORE BYTES\nMTABLOOP CR    #14,#1              LOOP TO MOVE DATA UNTIL TAB LOCATION\n         BNL   SCANLOOP             IS HIT\n         MVI   0(#14),X'40'        MOVE BLANK TO WORKAREA\n         LA    #14,1(,#14)         BUMP OUTPUT WORKAREA POINTER\n         B     MTABLOOP\n         SPACE 1\nNL       DS    0H                  PROCESS NEWLINE\n         LR    #15,#14             COMPUTE LENGTH OF EXPANDED TEXT\n         L     #14,ZLCTWA          USING ADDRESS OF EXPANDED TEXT\n         SR    #15,#14             (= CURRENT POINTER - START POINTER)\n         BNP   NONLPR              IF NOT POSITIVE, NOTHING TO PRINT\n         C     #15,ZLCTWALN        IF LONGER THAN WORK AREA LENGTH\n         BH    DISASTER            THEN WE REALLY BLEW IT\n         #BAS  #2,PRINTIT          PRINT THIS PART OF THE TEXT\nNONLPR   DS    0H                  THEN FORCE A TERPRI FOR THE NEWLINE\n         L     #15,ZLCTERP         GET ADDRESS OF ZILTERP\n         BALR  #14,#15             CALL ZILTERP TO FORCE PRINT OUTPUT\n         XC    TABOFF,TABOFF       RESET TAB OFFSET TO ZERO\n         B     MORE                CONTINUE PROCESSING\n         SPACE 1\nLB       DS    0H                  PROCESS LEFT SQUARE BRACKET\n         MVC   0(1,#14),ZLCLB      REPLACE WITH COMMON AREA BRACKET\n         LA    #14,1(,#14)         BUMP OUTPUT POINTER\n         B     SCANLOOP            CONTINUE PROCESSING\n         SPACE 1\nRB       DS    0H                  PROCESS RIGHT SQUARE BRACKET\n         MVC   0(1,#14),ZLCRB      REPLACE WITH COMMON AREA BRACKET\n         LA    #14,1(,#14)         BUMP OUTPUT POINTER\n         B     SCANLOOP            CONTINUE PROCESSING\n         SPACE 1\nFINISHED DS    0H\n         LR    #15,#14             COMPUTE LENGTH OF EXPANDED TEXT\n         L     #14,ZLCTWA          USING ADDRESS OF EXPANDED TEXT\n         SR    #15,#14             (= CURRENT POINTER - START POINTER)\n         BNP   MORE                IF NONE LEFT, CONTINUE\n         #BAS  #2,PRINTIT          PRINT WHAT'S LEFT\n         B     MORE                CONTINUE PROCESSING\n         SPACE 1\nNOTENUF  DS    0H                  NO STORAGE FOR WORKAREA\n         #TPUT *,NEMSG,L'NEMSG     TELL THE USER\n         B     PUTASIS             GO TO PRINT WITHOUT REFORMATTING\n         SPACE 1\nDISASTER DS    0H                  WE WENT PAST END OF WORKAREA\n         #TPUT *,DEMSG,L'DEMSG     TELL THE USER\n******** B     PUTASIS             GO TO PRINT WITHOUT REFORMATTING\n         SPACE 1\nPUTASIS  DS    0H                  PRINT WITHOUT REFORMATTING\n         LR    #14,#4              GET ADDRESS OF DATA\n         LR    #15,#3              GET LENGTH OF DATA\n         B     TRYPRINT            GO TO PRINT IT\n         SPACE 1\nTRT1     TRT   0(*-*,#14),TRTABLE  SCAN FOR ANY TABS OR NEWLINES\nTRT2     TRT   0(*-*,#5),TRTABLE   SCAN FOR NEXT TAB OR NEWLINE\nMVCDATA  MVC   0(*-*,#14),0(#5)    MOVE FROM DATA TO WORK AREA\n         EJECT\nISALIST  DS    0H                  THING TO BE PRINTED IS A LIST\n         SPACE\n         LA    #14,=C'('\n         LA    #15,1\n         #BAS  #2,PRINTIT          PRINT A LEFT PARENTHESIS\nPRINTCAR DS    0H\n         ST    #4,4(,#6)           SAVE REGISTER ON STACK\n         L     #4,##CAR(,#4)       GET (CAR LIST)\n         LA    #6,8(,#6)           BUMP STACK POINTER UP\n         #BASR #14,#12             CALL ZILPRIN RECURSIVELY\n         SH    #6,=H'8'            BUMP STACK POINTER DOWN\n         L     #4,4(,#6)           RESTORE OUR REGISTER\n         L     #14,##CDR(,#4)      LOOK AT (CDR LIST)\n         CR    #14,#10             IF CDR IS NIL\n         BE    LISTEND             THEN END OF LIST\n         CR    #14,#13             IF EQUAL TO #13\n         BE    DOTP                OR\n         C     #14,ZLCUNBND        IF EQUAL TO THE UNBOUND OBJECT\n         BE    DOTP                OR\n         C     #14,ZLCRMNIL        IF EQUAL TO RMNIL\n         BE    DOTP                OR\n         TM    ##TYPE(#14),##ATOM  IF THE CDR IS AN ATOM\n         BZ    NOTDOTP             THEN THIS IS A DOTTED PAIR\nDOTP     LA    #14,=C' . '         SO PRINT SPACES AND A PERIOD\n         LA    #15,3\n         #BAS  #2,PRINTIT\n         L     #4,##CDR(,#4)       GET (CDR LIST)\n         LA    #6,4(,#6)           BUMP STACK POINTER UP\n         #BASR #14,#12             CALL ZILPRIN RECURSIVELY\n         SH    #6,=H'4'            BUMP STACK POINTER DOWN\n         B     LISTEND             THEN GO TO PRINT END OF LIST\nNOTDOTP  DS    0H                  LIST NOT A DOTTED PAIR\n         LA    #14,=C' '           PRINT SPACE\n         LA    #15,1\n         #BAS  #2,PRINTIT\n         L     #4,##CDR(,#4)       GET (CDR LIST)\n         B     PRINTCAR            THEN CONTINUE PRINTING LIST\nLISTEND  DS    0H\n         LA    #14,=C')'           PRINT A RIGHT PARENTHESIS\n         LA    #15,1               AND THEN RETURN\n         B     TRYPRINT\n         EJECT\nISASTR   DS    0H                  THING TO BE PRINTED IS A STRUCTURE\n         SPACE\n         LA    #14,=C'#<STRUCT '\n         LA    #15,9\n         #BAS  #2,PRINTIT          PRINT THE BEGINNING OF A STRUCTURE\n         XR    #5,#5               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#4)          GET LENGTH OF STRUCTURE\n         LA    #5,##VECDAT-4(#5,#4) POINT TO LAST STRUCTURE ELEMENT\n         LA    #4,##VECDAT(,#4)    POINT TO FIRST STRUCTURE ELEMENT\nPRINTELS DS    0H\n         STM   #4,#5,4(#6)         SAVE REGISTERS ON STACK\n         L     #4,0(,#4)           GET ELEMENT OF STRUCTURE\n         LA    #6,12(,#6)          BUMP STACK POINTER UP\n         #BASR #14,#12             CALL ZILPRIN RECURSIVELY\n         SH    #6,=H'12'           BUMP STACK POINTER DOWN\n         LM    #4,#5,4(#6)         RESTORE OUR REGISTERS\n         CR    #4,#5               IF THIS IS THE LAST STRUCT ELEMENT\n         BNL   STRUCEND            THEN FINISH PRINTING\n         LA    #14,=C' '           ELSE PRINT SPACE\n         LA    #15,1\n         #BAS  #2,PRINTIT\n         LA    #4,4(,#4)           BUMP TO NEXT STRUCTURE ELEMENT\n         B     PRINTELS            THEN CONTINUE PRINTING STRUCTURE\nSTRUCEND DS    0H\n         LA    #14,=C'>'           PRINT END-OF-STRUCTURE\n         LA    #15,1               AND THEN RETURN\n         B     TRYPRINT\n         EJECT\nISAVEC   DS    0H                  THING TO BE PRINTED IS A VECTOR\n         SPACE\n         LA    #14,=C'#('\n         LA    #15,2\n         #BAS  #2,PRINTIT          PRINT A LEFT VECTOR-PARENTHESIS\n         XR    #5,#5               CLEAR INSERT REGISTER\n         ICM   #5,7,1(#4)          GET LENGTH OF VECTOR TEXT\n         BZ    VECEND              IF NULL VECTOR, SKIP ELEMENT PRINT\n         LA    #5,##VECDAT-4(#5,#4) POINT TO LAST VECTOR ELEMENT\n         LA    #4,##VECDAT(,#4)    POINT TO FIRST VECTOR ELEMENT\nPRINTEL  DS    0H\n         STM   #4,#5,4(#6)         SAVE REGISTERS ON STACK\n         L     #4,0(,#4)           GET ELEMENT OF VECTOR\n         LA    #6,12(,#6)          BUMP STACK POINTER UP\n         #BASR #14,#12             CALL ZILPRIN RECURSIVELY\n         SH    #6,=H'12'           BUMP STACK POINTER DOWN\n         LM    #4,#5,4(#6)         RESTORE OUR REGISTERS\n         CR    #4,#5               IF THIS IS THE LAST VECTOR ELEMENT\n         BNL   VECEND              THEN FINISH PRINTING\n         LA    #14,=C' '           ELSE PRINT SPACE\n         LA    #15,1\n         #BAS  #2,PRINTIT\n         LA    #4,4(,#4)           BUMP TO NEXT VECTOR ELEMENT\n         B     PRINTEL             THEN CONTINUE PRINTING VECTOR\nVECEND   DS    0H\n         LA    #14,=C')'           PRINT A RIGHT PARENTHESIS\n         LA    #15,1               AND THEN RETURN\n         B     TRYPRINT\n         EJECT\nISAFUN   DS    0H                  THING TO BE PRINTED IS A FUNARG\n         LA    #14,=C'#<FUNARG '\n         LA    #15,9\n         #BAS  #2,PRINTIT          PRINT THE BEGINNING OF A FUNARG\n         L     #4,##VECDAT+0(,#4)  GET FUNCTION COMPONENT OF FUNARG\n         LA    #6,4(,#6)           BUMP STACK POINTER UP\n         #BASR #14,#12             CALL ZILPRIN RECURSIVELY\n         SH    #6,=H'4'            BUMP STACK POINTER DOWN\n         LA    #14,=C'>'           PRINT THE ENDING OF IT AND RETURN\n         LA    #15,1\n         B     TRYPRINT\n         EJECT\nISUOA    DS    0H                  THING TO BE PRINTED IS AN\n*                                  UNSUPPLIED OPTIONAL ARGUMENT (#13)\n         LA    #14,$UOA\n         LA    #15,L'$UOA\n         B     TRYPRINT            PRINT UNSUPPLIED OPTIONAL ARGUMENT\n         EJECT\nISUNB    DS    0H                  THING TO BE PRINTED IS THE\n*                                  UNBOUND OBJECT\n         LA    #14,$UNB\n         LA    #15,L'$UNB\n         B     TRYPRINT            PRINT IT\n         EJECT\nISRMN    DS    0H                  THING TO BE PRINTED IS THE\n*                                  \"NOTHING\" READER MACRO OBJECT\n         LA    #14,$RMN\n         LA    #15,L'$RMN\n         B     TRYPRINT            PRINT IT\n         EJECT\nSTKOVFLO DS    0H                  NO ROOM ON STACK TO PRINT THING\n         SPACE 1\n         ST    #14,OF14            SAVE RETURN ADDRESS\n         LA    #14,OFTHING\n         LA    #15,L'OFTHING\n         #BAS  #2,PRINTIT          PRINT WHAT WE GOT\n         L     #14,OF14\n         BR    #14                 RETURN\n         SPACE 1\nOF14     DS    A\nOFTHING  DC    C'...#<PRINT STACK OVERFLOW>...'\n$UOA     DC    C'#<UNSUPPLIED OPTIONAL ARGUMENT>'\n$UNB     DC    C'#<UNBOUND>'\n$RMN     DC    C'#<RMNIL>'\n         EJECT\nTRYPRINT DS    0H\n         #BAS  #2,PRINTIT          PRINT WHAT WE GOT\n         SPACE 1\nRETURN   L     #14,0(,#6)          RELOAD RETURN ADDRESS\n         BR    #14                 RETURN\n         EJECT\nPRINTIT  DS    0H\n*\n* #14 --> DATA TO BE PRINTED\n* #15 = LENGTH OF DATA TO BE PRINTED\n*\n         LTR   #15,#15             IF LENGTH TO BE PRINTED IS ZERO\n         BZR   #2                  THEN PRINT NOTHING\n         SPACE 1\n         ST    #2,SAVERET\n         L     #2,ZLFCHAR          GET CURRENT CHARACTER POSITION\n         BCTR  #2,0                CONVERT FROM COLUMN TO OFFSET\n         LR    #0,#2               SAVE FOR CHARPOS TEST\n         A     #2,ZLFCARD          ADD RECORD AREA LOCATION\n         AR    #2,#15              ADD LENGTH OF DATA\n         C     #2,ZLFEND           IF THIS EXTENDS PAST END OF CARD\n         BNH   OK                   AND\n         TM    ZLFFLAG1,ZLFNEWLN     THERE IS ALREADY DATA ON THE LINE\n         BO    PT                     OR\n         LTR   #0,#0                   CHARACTER POSITION PAST START\n         BNP   OK                       THEN...\nPT       DS    0H\n         SPACE 1\n* IF WE ARE CURRENTLY PRINTING A STACK TRACE, WE PRINT ONLY ONE LINE\n* OF OUTPUT TO PREVENT INFINITE LOOPING.\n         SPACE 1\n         TM    ZLCERFLG,ZLCERTRC   IF STACK TRACING IS ACTIVE\n         BZ    PRTNEWLN            THEN...\n         NI    ZLCPFLGS,255-ZLCPRINT NO MORE ZILPRIN ACTIVE\n         L     #6,ZLCPSADR          SET INITIAL PRINT STACK POINTER\n         L     #14,0(,#6)           RESTORE REGISTER 14\n         L     #5,4(,#6)            RESTORE REGISTER 5\n         L     #12,8(,#6)           RESTORE REGISTER 12\n         BR    #14                  RELOAD REGISTERS AND RETURN\n         SPACE 1\nPRTNEWLN DS    0H\n         STM   #14,#15,P1SAVE       SAVE VOLATILE REGS\n         L     #15,ZLCTERP          GET ADDRESS OF ZILTERP\n         #BASR #14,#15              CALL ZILTERP TO FORCE PRINT OUTPUT\n         LM    #14,#15,P1SAVE       RESTORE VOLATILE REGS\n         SPACE 1\nOK       DS    0H\n         OI    ZLFFLAG1,ZLFNEWLN   SET NEW LINE INDICATION ON\n         L     #3,ZLFCHAR          GET CURRENT CHARACTER POSITION\n         LR    #2,#3               GET CURRENT CHARACTER POSITION\n         BCTR  #2,0                CONVERT FROM COLUMN TO OFFSET\n         A     #2,ZLFCARD          ADD RECORD AREA LOCATION\n         CH    #15,ZLFLRECL        IF LENGTH EXCEEDS PRINT LENGTH\n         BNH   OKLRECL             THEN\n         LH    #1,ZLFLRECL         PRINT FOR THAT LENGTH ONLY\n         BCTR  #1,0                Reduce for continuation character\n         CH    #1,=H'256'          If length exceeds 256\n         BNH   OKNOMVCL            then...\n         STM   #2,#5,MVCLSAVE       Save registers\n******** LR    #2,#2                Destination address = output ptr\n         LR    #3,#1                Length to move\n         LR    #4,#14               Source address = input pointer\n         LR    #5,#3                Length to move\n         MVCL  #2,#4                Move data to output record area\n         LM    #2,#5,MVCLSAVE       Restore registers\n         B     OKAFMVCL            Else...\nOKNOMVCL DS    0H                   Length 256 or less\n         BCTR  #1,0                 REDUCE FOR EXECUTE\n         EX    #1,MVDATA            MOVE DATA TO OUTPUT RECORD AREA\n         LA    #1,1(,#1)            Restore after execute\nOKAFMVCL DS    0H                  Move done\n         SR    #15,#1              SUBTRACT PRINT LENGTH FROM TOTAL\n         AR    #14,#1              BUMP DATA POINTER ACCORDINGLY\n         AR    #2,#1               BUMP DATA POINTER ACCORDINGLY\n         MVI   0(#2),C'\u00a2'          Move in continuation character\n         LA    #1,2(,#1)           Restore to ZLFLRECL+1\n         ST    #1,ZLFCHAR          RESET CHARACTER POINTER\n         B     PRTNEWLN            GO TO TERPRI AND PRINT REST OF IT\nOKLRECL  DS    0H                  ELSE ATOM WILL FIT ON ONE RECORD\n         CH    #15,=H'256'         If length exceeds 256\n         BNH   OKLNMVCL            then...\n         STM   #2,#5,MVCLSAVE       Save registers\n******** LR    #2,#2                Destination address = output ptr\n         LR    #3,#15               Length to move\n         LR    #4,#14               Source address = input pointer\n         LR    #5,#3                Length to move\n         MVCL  #2,#4                Move data to output record area\n         LM    #2,#5,MVCLSAVE       Restore registers\n         B     OKLAMVCL            Else...\nOKLNMVCL DS    0H                   Length 256 or less\n         LR    #1,#15              GET LENGTH\n         BCTR  #1,0                REDUCE FOR EXECUTE\n         EX    #1,MVDATA           MOVE DATA TO OUTPUT RECORD AREA\nOKLAMVCL DS    0H                  Move done\n         AR    #3,#15\n         ST    #3,ZLFCHAR          UPDATE CURRENT CHAR POSITION\n         L     #2,SAVERET\n         BR    #2\nMVDATA   MVC   0(0,#2),0(#14)      MOVE DATA TO OUTPUT\n         SPACE\nP1SAVE   DS    2A                  SAVE AREA\nSAVERET  DS    1A                  SAVE AREA\nMVCLSAVE DS    4A                  Save area\nINPUTEND DS    A                   POINTER TO END OF DATA\nTABOFF   DS    F                   COMPUTED TAB OFFSET\n         SPACE 1\nTRTABLE  DC    256X'00'            TABLE TO SCAN FOR TABS & NEWLINES\n         ORG   TRTABLE+X'05'       HT\n         DC    YL1(4)\n         ORG   TRTABLE+X'0D'       CR\n         DC    YL1(8)\n         ORG   TRTABLE+X'15'       NL\n         DC    YL1(8)\n         ORG   TRTABLE+X'AD'       LEFT SQUARE BRACKET\n         DC    YL1(12)\n         ORG   TRTABLE+X'BD'       RIGHT SQUARE BRACKET\n         DC    YL1(16)\n         ORG   ,\n         SPACE\nNEMSG    DC    C'ZIL2049 NOT ENOUGH MEMORY TO EXPAND TABS OR NEWLINES.'\nDEMSG    DC    C'ZILXXXX ZILPRIN WENT PAST END OF WORKAREA, POSSIBLE LOX\n               SS OF DATA INTEGRITY OR OTHER SEVERE ERROR WILL RESULT.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILRDCH": {"ttr": 15879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x00k\\x00h\\x00j\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 107, "newlines": 104, "modlines": 106, "user": "SEB1525"}, "text": "         TITLE 'ZILRDCH - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILRDCH TAKES THREE (OPTIONAL) ARGUMENTS:                           *\n*                                                                     *\n* (1) INPUT FILE SPECIFICATION                                        *\n* (2) WHETHER (T) OR NOT (NIL) TO INTERN THE RESULTING ATOM.          *\n* (3) WHETHER (T) OR NOT (NIL) TO FOLD THE CHARACTER TO UPPER CASE.   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* In ZIL 1.2 this function was called READCH.  The syntax of READCH   *\n* has been changed to be compatible with Maclisp READCH (PEEKCH was   *\n* changed to ZILPKCH similarly).  Common LISP READ-CHAR and PEEK-CHAR *\n* should be used instead of these functions.  Also TYI and TYIPEEK.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILRDCH  #ZBEG MINARGS=0,MAXARGS=3,NAME='ZILRDCH'\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         #IFIL 1                   ARG 1 = INPUT FILE SPEC\n         SPACE\n         TM    ZLFFLAG1,ZLFEOF     IF END OF FILE ALREADY HIT\n         BO    RDAFTEOF            THEN ERROR - READ AFTER EOF\n         SPACE\n         L     #3,ZLFCHAR          GET CURRENT POSITION\nGOTINPUT DS    0H\n         LTR   #3,#3               CHECK INPUT POINTER\n         BP    INPUTOK             IF POSITIVE, WE HAVE GOOD STUFF\n         BM    RDNL                IF NEGATIVE, RETURN AS A NEWLINE\n******** BZ    RDEOF               IF ZERO, EOF ENCOUNTERED\n         SPACE\nRDEOF    DS    0H                  EOF HIT ON LAST READ\n         OI    ZLFFLAG1,ZLFEOF     INDICATE EOF FOR NEXT CALL\n         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE OFF\n         LR    #15,#10             RETURN NIL\n         B     RETURN\n         SPACE\nRDNL     DS    0H                  NEWLINE HIT ON LAST READ\n*\n* THE FOLLOWING IS TO PREVENT AN EXTRA KEYBOARD UNLOCK WHEN THE\n* INPUT FILE IS A TERMINAL AND END-OF-LINE HAS BEEN ENCOUNTERED.\n* REMEMBER THAT \"READ\" IGNORES END-OF-LINE IT IT IS THE FIRST\n* THING THAT IT SEES - IF THIS WERE NOT THE CASE, READ WOULD\n* HAVE TO BE CHANGED AS WELL.\n*\n         TM    ZLFFLAG1,ZLFNEWLN   IF WE ALREADY RETURNED NEWLINE/NIL,\n         BZ    RDNLNEW1            THEN...\n         NI    ZLFFLAG1,255-ZLFNEWLN SET IT OFF AGAIN\n         #GETC ,                    READ IN THE NEXT CHARACTER\n         B     GOTINPUT             AND TRY TO PROCESS IT\nRDNLNEW1 DS    0H                  ELSE...\n         OI    ZLFFLAG1,ZLFNEWLN   INDICATE NEWLINE\n         LR    #15,#10             RETURN NIL\n         B     RETURN\n         SPACE\nINPUTOK  DS    0H                  REG 3 LOCATES CURRENT CHARACTER\n         SPACE\n         NI    ZLFFLAG1,255-ZLFNEWLN TURN NEWLINE INDICATOR OFF\n         LR    #1,#3               CONVERT RELATIVE COLUMN TO\n         BCTR  #1,0                 ABSOLUTE LOCATION IN LINE\n         A     #1,ZLFCARD            AND PASS IT TO ATOM BUILD RTE\n         C     #10,8(,#11)         IF ARG 3 IS NOT NIL\n         BE    DONTFOLD             OR\n         C     #13,8(,#11)           ARG 3 IS NOT SUPPLIED\n         BE    DONTFOLD               THEN\n         TR    0(1,#1),UPTBL        FOLD CHARACTER TO UPPER CASE.\nDONTFOLD DS    0H\n         ST    #3,ZLFCHAR          SAVE CHARACTER POINTER\n         LA    #0,1                LENGTH OF ATOM TO BE BUILT = 1\n         L     #2,4(,#11)          GET ARG 2 = WHETHER TO INTERN IT\n         LR    #3,#10              SET FORMAT FLAG = NIL\n         L     #15,ZLCABLD         GET ADDRESS OF ZILABLD\n         LA    #4,24(,#11)         SET CURRENT STACK POINTER FOR CONS\n         #BASR #14,#15             CALL ZILABLD TO BUILD THE ATOM\n*                                  MAKING #15 POINT TO NEW ATOM\n         L     #3,ZLFCHAR          RELOAD CHARACTER POINTER\n         #GETC ,                   GET NEXT CHARACTER BEFORE RETURN\n         SPACE\nRETURN   DS    0H\n         ST    #3,ZLFCHAR          RESET CHARACTER POINTER\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\nRDAFTEOF DS    0H                  IF NEGATIVE, EOF WAS ALREADY HIT\n         L     #2,ZLFATOM          Load file atom for error message\n         #ERR  'ZIL2003 ZILRDCH: Read after end of file ',(#2),        X\n               PREFIX=NO\n         SPACE\n         LTORG\n         SPACE\nUPTBL    DC    256YL1(*-UPTBL)     TABLE TO FOLD TO UPPER CASE\n         ORG   UPTBL+X'81'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+X'91'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+X'A2'\n         DC    C'STUVWXYZ'\n         ORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILREM": {"ttr": 15882, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11S\\x00\\xa3\\x00\\xa0\\x00\\xa2\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:53:00", "lines": 163, "newlines": 160, "modlines": 162, "user": "SEB1525"}, "text": "         TITLE 'ZILREM - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                 SIGNED INTEGER REMAINDER                            *\n*                                                                     *\n*  (ZILREM  INTEGER1  INTEGER2)  ==>  RERMAINDER(INTEGER1/INTEGER2)   *\n*                                                                     *\n*  THE SIGN OF THE REMAINDER IS ALWAYS THE SAME AS THE SIGN OF THE    *\n*  FIRST ARGUMENT.  ARGUMENTS OTHER THAN INTEGERS SIGNAL AN ERROR.    *\n*  IF THE SECOND ARGUMENT IS 0 AN ERROR IS SIGNALED.                  *\n*                                                                     *\n*  ===ZILREM NOT YET IMPLEMENTED FOR ALL COMBINATIONS OF BIGNUMS===   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This routine currently calls ZILDIV, ZILMUL and ZILSUB to compute   *\n* bignum-by-bignum remainder.                                         *\n*                                                                     *\n***********************************************************************\nZILREM   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILREM',SUBRS=ZILSUBR\n         #ZPDS 32                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n*---------------------------------------------------------------------*\n*         BOTH ARGUMENTS ARE FIXNUMS - WE WANT SPEED HERE             *\n*---------------------------------------------------------------------*\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#6),##FIXNUM CHECK TYPE OF ARG1\n         BNE   NFX1\n         CLI   ##TYPE(#7),##FIXNUM CHECK TYPE OF ARG2\n         BNE   F1NF2\n         L     #2,##CDR(,#6)       GET FIXED VALUE 1\n         ICM   #1,15,##CDR(#7)     GET FIXED VALUE 2\n         BZ    DIVBY0              IF ZERO, ERROR\n         SRDA  #2,32               SHIFT INTO REGS FOR DIVIDE\n         DR    #2,#1               REMAINDER IN #2, QUOTIENT IN #3\nMKAT     #MKAT FIXED               MAKE A FIXNUM\n*\nRETURN   #ZRET ,                   RESTORE REGISTERS AND RETURN\n*---------------------------------------------------------------------*\n*      ARGUMENT 1 IS NOT A FIXNUM                                     *\n*---------------------------------------------------------------------*\nNFX1     CLI   ##TYPE(#6),##BIGNUM\n         BNE   ERROR1\n         CLI   ##TYPE(#7),##FIXNUM\n         BNE   B1NF2\n         XR    #1,#1               CLEAR FOR LOADING BIGNUM LENGTH\n         LA    #5,4                GENERAL PURPOSE 4\n         ICM   #1,7,1(#6)          GET BIGNUM LENGTH\n         LCR   #5,#5               GENERATE GENERAL PURPOSE -4\n         L     #3,##VECDAT-4(#1,#6) LOAD MS WORD OF DIVIDEND\n         XR    #2,#2               CLEAR UPPER WORD FOR DIVIDE\n         L     #7,##CDR(,#7)       LOAD DIVISOR AND TEST\n         LTR   #7,#7               0?, DON'T CARE ABOUT SIGN OF DIVISOR\n         BZ    DIVBY0              ERROR, CAN'T DIVIDE BY 0\n         DR    #2,#7               FIRST DIVIDE\n         AR    #1,#5               REDUCE INDEX BY ONE WORD\n         AR    #1,#5               REDUCE INDEX BY ANOTHER WORD\n*\nBFLOOP   L     #3,##VECDAT(#1,#6)  LOAD NEXT LOWER BIGNUM WORD\n         SLL   #3,1                SHIFT OUT JUNK BIT, DELETES LSW SIGN\n         SRDL  #2,1                RIGHT JUSTIFY 64-BIT DIVIDEND\n         DR    #2,#7               DIVIDE AGAIN\n         BXH   #1,#5,BFLOOP        ANOTHER WORD?\n*\n         TM    ##VECDAT(#6),X'80'  TEST SIGN OF BIGNUM\n         BNO   MKAT\n         LCR   #2,#2               TAKE NEGATIVE BEFORE STORING\n         #MKAT FIXED               ARG1 WAS NEG, SO RETURN MUST BE NEG\n         B     RETURN\n*---------------------------------------------------------------------*\n*      ARGUMENT 1 IS A FIXNUM, ARGUMENT 2 IS NOT A FIXNUM             *\n*---------------------------------------------------------------------*\nF1NF2    CLI   ##TYPE(#7),##BIGNUM FIX/BIG - PROBABLY JUST RETURN ARG1\n         BNE   ERROR2              ARGUMENT 2 ISN'T A BIGNUM EITHER\n         L     #4,##CDR(,#6)       GET ARG1 FIXNUM\n         LR    #15,#6              GET ARG1 POINTER,#15 IN CASE OF RET\n         LCR   #4,#4               TEST FOR -2147483648 = -2**31\n         BNO   RETURN              NO OVERFLOW, RETURN WITH ARG1\n         CLC   TWO31(12),0(#7)     COMPARE BIGNUM TO 2**31\n         BNE   RETURN              BIG MAGNITUDE ARG2, RETURN WITH ARG1\n         LA    #15,#SFT0           (ZILREM -2147483648 2147483648) = 0\n         B     RETURN              RETURN WITH INLINE 0\n*---------------------------------------------------------------------*\n*      ARGUMENT 1 IS A BIGNUM, ARGUMENT 2 IS NOT A FIXNUM             *\n*---------------------------------------------------------------------*\nB1NF2    CLI   ##TYPE(#7),##BIGNUM\n         BNE   ERROR2              ARG2 IS NOT AN INTEGER\n*---------------------------------------------------------------------*\n*      BOTH ARGUMENTS ARE BIGNUMS                                     *\n*---------------------------------------------------------------------*\n         CLC   1(3,#6),1(#7)       COMPARE LENGTHS IN BIGNUM HEADERS\n         BH    XXXXXX              BIGNUM/BIGNUM DIVIDE NEEDED\n         LR    #15,#6              IN CASE ARG2 MAGNITUDE IS GREATER\n         BL    RETURN              LENGTH OF ARG1 IS SMALLER, RETURN IT\n         XR    #5,#5               CLEAR FOR INSERTION OF 3-BYTE LENGTH\n         ICM   #5,7,1(#6)          GET BIGNUM LENGTHS - BOTH SAME NOW\n         L     #4,##VECDAT-4(#5,#6) LOAD MS WORD OF ARG 1 BIGNUM\n         CL    #4,##VECDAT-4(#5,#7) COMPARE WITH MS WORD OF ARG 2 BIGN\n         BL    RETURN              ARG 1 IS SMALLER, RETURN WITH IT\n******** B     XXXXXX              QUOTIENT WOULD BE 0 OR 1\n**SHOULD SPECIAL CASE ABOVE - DO COMPARE AND: SUBTRACT OR RETURN***\n         SPACE 1\nXXXXXX   DS    0H                  Big/by/big remainder\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Fakeout code for bignum remainder cases that aren't handled here.   *\n*                                                                     *\n* Translation of LISP code (- arg1 (* (/ arg1 arg2) arg2))            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #0,0(,#11)           Get function argument arg1\n         ST    #0,20(,#11)          Store into argument 1\n******** L     #0,0(,#11)           Get function argument arg1\n         ST    #0,24(,#11)          Store into argument 1\n         L     #0,4(,#11)           Get function argument arg2\n         ST    #0,28(,#11)          Store into argument 2\n         L     #15,@ZILDIV          Get address of ZILDIV\n         LA    #1,24(,#11)          Set pointer to arguments in stack.\n         #BASR #14,#15              Call ZILDIV\n         ST    #15,24(,#11)         Store into argument 1\n         L     #0,4(,#11)           Get function argument arg2\n         ST    #0,28(,#11)          Store into argument 2\n         L     #15,@ZILMUL          Get address of ZILMUL\n         LA    #1,24(,#11)          Set pointer to arguments in stack.\n         #BASR #14,#15              Call ZILMUL\n         ST    #15,24(,#11)         Store into argument 2\n         L     #15,@ZILSUB          Get address of ZILSUB\n         LA    #1,20(,#11)          Set pointer to arguments in stack.\n         #BASR #14,#15              Call ZILSUB\n         B     RETURN               Return with value\n         SPACE 1\nZILSUBRS DS    0A                   Subroutine pointers.\n@ZILDIV  DC    V(ZILDIV)            Entry point for ZILDIV\n         DC    CL8'ZILDIV'\n@ZILMUL  DC    V(ZILMUL)            Entry point for ZILMUL\n         DC    CL8'ZILMUL'\n@ZILSUB  DC    V(ZILSUB)            Entry point for ZILSUB\n         DC    CL8'ZILSUB'\nZILSUBRE EQU   *                    End of subroutines.\n         SPACE 1\n*---------------------------------------------------------------------*\n*      INLINE CONSTANTS                                               *\n*---------------------------------------------------------------------*\n         DS    0F                  WORD ALIGN\nTWO31    DC    YL1(##BIGNUM),AL3(8),F'0,1'    2**31 SMALLEST BIGNUM\n*\n*---------------------------------------------------------------------*\n*      MESSAGES                                                       *\n*---------------------------------------------------------------------*\nDIVBY0   #ERR  'Divide by zero attempted taking remainder of ',0(#11)\nERROR1   #ERR  'Argument 1 to remainder not an integer - ',0(#11)\nERROR2   #ERR  'Argument 2 to remainder not an integer - ',4(#11)\n***XXX   #ERR  'Bignum/bignum remainder not implemented by ZILREM for 'X\n               ,0(#11),' and ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILSBND": {"ttr": 16132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11T\\x009\\x006\\x008\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 57, "newlines": 54, "modlines": 56, "user": "SEB1525"}, "text": "         TITLE 'ZILSBND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS FUNCTION IS CALLED BY ALL COMPILED ZIL PROGRAMS WHICH HAVE TO *\n*  PUT THEIR LOCALLY BOUND \"SPECIAL\" VARIABLES ON THE SPECIAL ALIST.  *\n*                                                                     *\n*  This function, along with ZILFBND, replaces the old ZIL 1.2        *\n*  \"ZILVPUT\" function.                                                *\n*                                                                     *\n*  REGISTER 1 IS THE ATOM WHICH IS TO BE BOUND.                       *\n*  REGISTER 2 IS THE VALUE WHICH IS BOUND TO ATOM 1.                  *\n*  REGISTER 1 ON RETURN IS THE CONS CELL WHICH HOLDS THE BINDING.     *\n*                                                                     *\n*  The corresponding LISP definition would look something like this:  *\n*                                                                     *\n* (defun zilsbnd (a b)                                                *\n*  (let ((x (cons a b)))                                              *\n*        (push x (special-alist))                                     *\n*        x))                                                          *\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO STACK SPACE.              *\n* IN ADDITION, IT NEEDS NO BASE REGISTER.                             *\n*                                                                     *\n* NOTE: THE INTERFACE TO THIS ROUTINE IS NONSTANDARD.                 *\n*       COMPILED CODE INVOKES IT AS FOLLOWS:                          *\n*                                                                     *\n*  LA   0,CURRENT STACK LOCATION FOR CONS                             *\n*  L    1,ADDRESS OF FREE VARIABLE SYMBOL                             *\n*  L    2,STACK LOCATION OF VALUE                                     *\n*  L    15,=A(ZILSBND)                                                *\n*  BALR 3,15                                                          *\n*  ST   1,STACK LOCATION OF VALUE                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILSBND  CSECT\n         SPACE 1\n         USING ZLCOMMON,#13\n         SPACE 1\n         L     #15,ZLCCONS         CALL CONS TO CONS ARGS TOGETHER\n         #BASR #14,#15             GIVING A VARIABLE BINDING\n         LR    #1,#15              ARG1=RESULT OF CONS (ALSO RETURNED)\n         L     #15,ZLCCONS         GET ADDRESS OF CONS ROUTINE\n         L     #2,ZLCSALST         ARG2=CURRENT SPECIAL ALIST\n         #BASR #14,#15             CALL CONS TO CONS THEM TOGETHER\n         ST    #15,ZLCSALST        UPDATE ALIST WITH NEW BINDING\n         BR    #3                  RETURN WITH (CAR BINDING) IN REG 1\n         SPACE 1\n         #ZEQU ,\n         SPACE 1\n         #ZCOM ,\n         END\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILSINT": {"ttr": 16134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x02\\x00\\x88\\x01_\\x01\\x00&_\\x17!\\x01\\x04\\x01\\x01\\x01\\x03\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:21:02", "lines": 260, "newlines": 257, "modlines": 259, "user": "SEB1525"}, "text": "         TITLE 'ZILSINT - ZIL 1.3 COMPILED CODE OBJECT INITIALIZATION'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS INVOKED VIA BALR FROM EXTERNAL FUNCTIONS WHICH HAVE  *\n* ATOMS OR LISTS WITHIN THEM, ONE TIME ONLY.  IT RELOCATES ATOMS,     *\n* INTERNS SYMBOLS AND CONVERTS 0 AND 1 POINTERS TO NIL AND T.         *\n*                                                                     *\n* THIS MODULE USES NO STACK SPACE,  SINCE IT'S NOT RECURSIVE.         *\n*                                                                     *\n* ON ENTRY REG 1 POINTS TO THE BEGINNING OF THE AREA CONTAINING THE   *\n* LISTS AND ATOMS TO BE PROCESSED.                                    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: OBVIOUSLY, THIS PROGRAM MUST NOT CONTAIN ANY ATOMS OR LISTS.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILSINT  #ZBEG NAME='ZILSINT'\n         SPACE ,\n         STM   #12,#14,AINTSAVE    SAVE REGISTERS\n         LR    #12,#15             SET UP BASE REGISTER\n         DROP  15\n         USING ZILSINT,#12         ESTABLISH ADDRESSABILITY\n         USING ZLHEADER,#1         ESTABLISH ADDRESSABILITY\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* INITIALIZE THE PARAMETERS USED TO SCAN THE ATOMS TO BE INITIALIZED  *\n*                                                                     *\n* IF THE ATOM POINTERS ARE ZERO, THEN THIS IS A CALL FROM A NON-MAIN  *\n* FUNCTION, SO ONLY POINTER RELOCATION IS TO BE PERFORMED; FURTHER,   *\n* IN THAT CASE THE OFFSETS ARE NEGATIVE SO THEY ARE TO BE SUBTRACTED. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IN CASE THIS ROUTINE WAS INTERRUPTED AND GETS ENTERED AGAIN         *\n* BECAUSE THE CALLER NEVER GOT TO ZAP ITS BRANCH-AROUND, SET THE      *\n* HIGH-ORDER BIT OF ZLHATOMA TO MAKE THIS CODE DO A NO-OP IF IT       *\n* IS EVER CALLED BY THIS MODULE AGAIN.                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         OI    ZLCGCFLG,ZLCGCBLD   TURN ON SPECIAL CONSING FLAG\n         OI    ZLCIFLGS,ZLCISMC    SET NOT INTERRUPTIBLE\n         L     #3,ZLHATOMA         START FROM BEGINNING OF ATOMS\n         OI    ZLHATOMA,X'80'      ZAP IT SO IT'S NEVER GOOD AGAIN\n         L     #5,ZLHLISTE         END WITH END OF LISTS\n         LTR   #3,#3               IF ATOMS POINTER IS ZEROES\n         BZ    MRELOC              THEN DO SUBFUNCTIONAL RELOCATION\n         CLR   #3,#5               COMPARE POINTERS\n         BNL   ENDLISTS            SKIP IF NO LISTS OR ATOMS\n*\n* Start to pass over main-function pointers.  We have to set a\n* pointer to the inline pointers that we have processed so far,\n* so that in case of a GC during our processing (before we have\n* built a vector to reference this stuff) the pointers we have\n* relocated so far will be found by the GC.\n*\n         ST    #3,ZLCSIN1          Set pointer to start of pointers\n         LA    #4,4                SET BXLE REGISTER\n         BCTR  #5,0                ADJUST END PTR FOR BXLE\n         LA    #2,1                MAKE A 1 FOR COMPARES\n         DROP  1\n*\n* IN THE MODULE, ALL REFERENCES TO NIL AND T IN LISTS ARE ASSEMBLED AS\n* FULLWORD VALUES OF 0 AND 1 RESPECTIVELY.\n* THIS CODE CONVERTS THESE TO THE ACTUAL ATOMS NIL AND T.\n* IN ADDITION, ALL POINTERS HEREIN ARE RELATIVE AND MUST BE RELOCATED.\n*\n* FOR EACH POINTER, EITHER CONVERT IT TO NIL/T OR ADD IT TO OBJECT LIST\n* AFTER RELOCATING IT\n*\nLISTLOOP DS    0H                  CONVERT ALL T AND NIL POINTERS\n         SPACE 1\n         L     #7,0(,#3)           PICK UP CONTENTS\n         LTR   #7,#7               IF ZERO\n         BZ    MAKENIL             THEN CHANGE TO NIL\n         CR    #7,#2               ELSE IF ONE\n         BE    MAKET               THEN CHANGE TO T\n         A     #7,AINTSAVE+0       ELSE RELOCATE BY ADDING ENTRY POINT\n         ST    #7,0(,#3)           UPDATE POINTER IN MODULE\n         B     ISITATOM            CONTINUE\nMAKENIL  DS    0H\n         ST    #10,0(,#3)\n         B     NEXTLIST\nMAKET    DS    0H\n         ST    #8,0(,#3)\n         B     NEXTLIST\n         EJECT\nISITATOM DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OBJECT LIST INITIALIZATION                                          *\n*                                                                     *\n* GO THROUGH ALL ATOM POINTERS.                                       *\n* SYMBOLS ARE RELOCATED AND PLACED ON THE OBJECT LIST.                *\n* OTHER KINDS OF ATOMS ARE IGNORED.                                   *\n*                                                                     *\n* #7 POINTS TO THE ATOM IN QUESTION.                                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  LOGIC IS AS FOLLOWS:  SYMBOLS ARE STORED IN COMPILED ZIL CODE IN   *\n*  UNINITIALIZED FORM (SYMBOL TYPE BITS FOLLOWED BY 3 BYTES OF ZEROES *\n*  AND A HASH CODE). WHEN A SYMBOL IS INTERNED (DUE TO ITS NOT BEING  *\n*  FOUND ON THE OBLIST YET), ITS POINTER IS RETURNED BY ZILINTN;      *\n*  IF AN IDENTICAL SYMBOL IS FOUND ON THE OBLIST, THE FORWARDING BIT  *\n*  IN THE SYMBOL AREA IS SET TO 1 AND THE TRUE ADDRESS OF THE SYMBOL  *\n*  (AS FOUND ON THE OBLIST) IS STORED BACK IN THE SYMBOL POINTER.     *\n*  A FORWARDING POINTER IS DEPOSITED IN THE SYMBOL AREA, BUT NOT THE  *\n*  POINTER TO THE ACTUAL SYMBOL (BECAUSE THAT WILL BE INACCESSIBLE    *\n*  AFTER THE GC RELOCATES THE SYMBOL).  THEREFORE, WE STORE THE       *\n*  POINTER TO THE ORIGINAL POINTER, WHICH CAN BE FOUND AS THE         *\n*  FORWARDING POINTER.  THUS, WHEN ZILSINT SCANS ATOM POINTERS AND    *\n*  FINDS A SYMBOL, IT ACTS APPROPRIATELY DEPENDING ON THE CONTENTS    *\n*  OF THE FIRST AND SECOND WORDS.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   ##TYPE(#7),##SYMBOL IF IT'S NOT A SYMBOL\n         BNE   NEXTLIST            THEN DON'T PROCESS IT\n         SPACE 1\n         TM    ##FWBYTE(#7),##FWBIT IF SYMBOL NOT FOUND/FORWARDED YET\n         BZ    OBSEARCH            THEN NEW SYMBOL, GO SEARCH OBLIST\n         L     #7,##FWWD2(,#7)     ELSE GET IT VIA FORWARDING POINTER\n         L     #7,0(,#7)           FOLLOW POINTER TO TRUE POINTER\n         ST    #7,0(,#3)           STORE TRUE SYMBOL POINTER BACK\n         B     NEXTLIST            CONTINUE PROCESSING WITH NEXT ATOM\n         SPACE 1\nOBSEARCH DS    0H                  SEARCH THE OBLIST FOR THIS SYMBOL\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Observe that #7 is greater than zero, being a pointer to a pair of  *\n* words in the load module, and that there may be a preset hash code  *\n* contained therein which ZILINTN might be able to use.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ST    #3,ZLCSIN2          Point to end of pointers so far\n*                                  in case of GC during internment\n         L     #15,ZLCINTN         GET ADDRESS OF ZILINTN\n         LA    #6,8(,#7)           ADDRESS OF PRINT NAME STRING\n         #BASR #14,#15             CALL ZILINTN TO INTERN THE SYMBOL\n         ST    #15,0(,#3)          CHANGE PTR TO POINT TO OBLIST SYMBOL\n         LA    #14,0(,#3)          POINT TO LOCATION OF TRUE POINTER\n         ST    #14,##FWWD2(,#7)    SET FORWARDING POINTER IN OUR SYMBOL\n         OI    ##FWBYTE(#7),##FWBIT SET FORWARDING BIT IN OUR SYMBOL\nNEXTLIST DS    0H\n         BXLE  #3,#4,LISTLOOP      CONTINUE FOR ALL LISTS\n         SPACE 1\nENDLISTS DS    0H\n         SPACE 1\n         XR    #3,#3               Clear temporary pointer pointers\n         ST    #3,ZLCSIN1          that were used in case of GC\n******** ST    #3,ZLCSIN2          (we really don't have to clear #2)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* At this point, add the compiled code header pointer to the ZIL      *\n* \"master vector\" of compiled code headers, used by the GC to collect *\n* all inline compiled code objects.  All the code that allocates and  *\n* maintains this data structure is contained herein.                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LR    #6,#1               Save pointer to module header\n         ICM   #4,15,ZLCICPA       Get address of \"master vector\"\n         BNZ   GOTICPA             If zero, then...\n         LA    #3,2048              load a good initial length\n         LR    #0,#3                use it for getmain\n         #GETMAIN RC,LV=(0),LOC=ANY get storage for it\n         LTR   #15,#15              if getmain failed\n         BNZ   GERROR               then disaster\n         ST    #3,ZLCICPL           store length\n         ST    #1,ZLCICPA           store address\n         LR    #4,#1                load address of \"master vector\"\n         XR    #0,#0                set length used (zero so far)\n         ST    #0,ZLCICPU           store it\nGOTICPA  DS    0H                  Now #4 points to the \"master vector\"\n         L     #5,ZLCICPU          Get length used so far\n         C     #5,ZLCICPL          See if entire length used up\n         BL    ICPOK               If not, we can proceed.  Else...\n         LA    #3,2048(,#5)        Increment length by a good amount\n         LR    #0,#3               Use it for getmain\n         #GETMAIN RC,LV=(0),LOC=ANY Get storage for new space\n         LTR   #15,#15             If getmain failed\n         BNZ   GERROR              then disaster\n         ST    #3,ZLCICPL          Store new length\n         LR    #2,#1               Save address of new space\n         ST    #2,ZLCICPA          Store it\n         LR    #0,#4               Address of old space\n         LR    #1,#5               Used length of old space\n         MVCL  #2,#0               Copy pointers from old space to new\n         LR    #1,#4               Get address of old space\n         LR    #0,#5               Get old length (assume used EQUALS)\n         FREEMAIN RU,LV=(0),A=(1)  Free the old space\n         L     #4,ZLCICPA          Get address of new space\nICPOK    DS    0H                  Now we know there's enough room\n         ST    #6,0(#5,#4)         Store header in next available slot\n         LA    #5,4(,#5)           Increment used length\n         ST    #5,ZLCICPU          Store it\n         SPACE 1\n* Finished.\n         SPACE 1\n         NI    ZLCGCFLG,255-ZLCGCBLD TURN OFF SPECIAL CONSING FLAG\n         NI    ZLCIFLGS,255-ZLCISMC  TURN OFF NON-INTERRUPTIBLE FLAG\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         LM    #12,#14,AINTSAVE    RESTORE REGISTERS\n         BR    #14                 RETURN TO CALLER\n         EJECT\nMRELOC   DS    0H                  RELOCATE SUBFUNCTION LIST POINTERS\n         SPACE 1\n         USING ZLHEADER,#1\n         L     #5,ZLHLISTA         POINT TO START OF POINTERS\n         L     #3,ZLHLISTE         POINT TO END OF POINTERS\n         CR    #5,#3               IF NO LISTS\n         BNL   ENDLISTS            THEN DO NO PROCESSING\n         LA    #2,4                SET UP BXH INCREMENT REGISTER\n         BCTR  #3,0                ADJUST BXH TERMINATION REGISTER\n         L     #6,AINTSAVE+0       GET SAVED #12 = FUNCTION CODE ADDR\n         B     MLOOPF              SKIP FIRST INCREMENT\nMLOOP    BXH   #5,#2,ENDLISTS      EXIT AT END OF LIST OF POINTERS\nMLOOPF   LR    #7,#6               FUNCTION ADDR MINUS OFFSET OF OBJ\n         S     #7,0(,#5)           GIVES ADDRESS OF OBJECT IN MAIN CODE\n         CLI   ##TYPE(#7),##SYMBOL IF THIS IS NOT A SYMBOL\n         BNE   MSTORE              THEN JUST UPDATE POINTER. ELSE...\n         TM    ##FWBYTE(#7),##FWBIT IT MUST POINT TO A FORWARDED SYMBOL\n         BZ    MERROR              ELSE ERROR\n         L     #7,##FWWD2(,#7)     LOAD FORWARDING POINTER FROM SYMBOL\n         L     #7,0(,#7)           FOLLOW POINTER TO TRUE POINTER\nMSTORE   ST    #7,0(,#5)           STORE TRUE POINTER BACK INTO CODE\n         B     MLOOP               CONTINUE FOR ALL POINTERS\n         SPACE 1\nAINTSAVE DS    3A                  SAVE AREA FOR REGISTERS 12-14\n         EJECT\nGERROR   DS    0H\n         #ERR  PREFIX=NO,                                              X\n               'ZIL0071 ZILSINT: Not enough memory for inline compiled X\n               object storage.'\nMERROR   DS    0H\n         WTO   'ZIL0070: INDIRECT SYMBOL POINTER NOT FORWARDED.',      X\n               ROUTCDE=11\n         ABEND 0070,DUMP\n         SPACE\n         LTORG\n         SPACE\n         #ZHDR ,\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSPAD": {"ttr": 16139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x883?\\x00\\x89\\x15o\\x11T\\x00\\xc1\\x00\\xc1\\x00\\xc0\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-11-28T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 193, "newlines": 193, "modlines": 192, "user": "SEB1525"}, "text": "         TITLE 'ZILSPAD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (ZILSPAD string1 length2 padchar3 truncatep4 wherepad5)             *\n*                                                                     *\n*  string1    - a string                                              *\n*  length2    - the length to pad to                                  *\n*  padchar3   - the padding character                                 *\n*  truncatep4 - whether to truncate of string1 longer than length2    *\n*  wherepad5  -  1 = pad on right                                     *\n*               -1 = pad on left                                      *\n*                0 = pad on both sides (center)                       *\n*                                                                     *\n* This function is called by the following user-visible functions:    *\n*                                                                     *\n* (defun string-right-pad                                             *\n*        (string length &optional (padchar \" \") (truncatep nil))      *\n*  (zilspad string length padchar truncatep 1))                       *\n*                                                                     *\n* (defun string-left-pad                                              *\n*        (string length &optional (padchar \" \") (truncatep nil))      *\n*  (zilspad string length padchar truncatep -1))                      *\n*                                                                     *\n* (defun string-center                                                *\n*        (string length &optional (padchar \" \") (truncatep nil))      *\n*  (zilspad string length padchar truncatep 0))                       *\n*                                                                     *\n* Common Lisp:                                                        *\n*                                                                     *\n* (defun make-string (size &key (initial-element \" \"))                *\n*  (zilspad \"\" size initial-element nil 1))                           *\n*                                                                     *\n***********************************************************************\nZILSPAD  #ZBEG MINARGS=5,MAXARGS=5,NAME='ZILSPAD'\n         #ZPDS 5*4+12+0 = 32       DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n*\n* Check arg 1 - must be string (or symbol).\n*\n         LM    #5,#7,0(#11)        Get args 1, 2, and 3\n         CLI   ##TYPE(#5),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#5),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #5,##PNAME(,#5)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H\n         LR    #15,#5              Get into possible return register\n         ST    #5,0(,#11)          Store string back on stack\n*\n* Check arg 2 - must be fixnum.\n*\n         CLI   ##TYPE(#6),##FIXNUM Arg 2 (length) must be a fixnum\n         BNE   ERROR2              else error\n         L     #6,##CDR(,#6)       Get numeric length value\n*\n* Check arg 3 - must be one-character string or character.\n*\n         CLI   ##TYPE(#7),##FIXNUM If arg 3 (padchar) is a fixnum\n         BE    ARG3FIX             then extract character from fixnum\n         CLC   ##TYPE(4,#7),STRLEN1 Else arg 3 must be a string of\n         BNE   ERROR3                length 1, else error\n         MVC   PADCHAR(1),##VECDAT(#7) Extract pad char from string\n         B     ARG3OK\nARG3FIX  DS    0H\n         L     #7,##CDR(,#7)       Get numeric value\n         CL    #7,#SFW255          If not within character range\n         BH    ERROR3              then error\n         STC   #7,PADCHAR          Store pad character\nARG3OK   DS    0H\n         XR    #5,#5\n         ICM   #5,7,1(#15)         Get length of arg 1 string\n*\n* If new-length (arg 2) is equal to old-length (length of arg 1),\n* then just return the original string.\n*                                  #5 = old-length\n*                                  #6 = new-length\n         CR    #5,#6               If lengths are already equal\n         BE    RETURN              then just return the string\n         BL    USENEWLN            If old-length LT new-length, OK\n*\n* If old-length is greater than new-length, then we need to check arg4\n* (the truncatep parameter).\n* If arg4 is NIL, then length of new string is old-length, so we can\n* just return it.  Otherwise length of new string is always arg 2.\n*\n         C     #10,12(,#11)        If arg 4 is NIL (don't truncate)\n         BE    RETURN              then just return the string\nUSENEWLN DS    0H                  else use new-length (already in #6)\n*\n* Check length of string to be created.  If negative, error.\n* If zero, just return the null string.\n*\n         LTR   #6,#6               Check new-length\n         BM    ERROR2              If negative, error\n         BZ    RETNULL             If zero, return null string\n*\n* Allocate space for string, using new-length.\n*\n         LR    #2,#6               Length for ZILVSS = new-length\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,32(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #4,#15              IF STRING BUILD FAILED\n         BZ    ERROR4              THEN ERROR\n*\n* Preset offset to move old data to new string.\n*\n         XR    #3,#3               Set offset of moved data to 0\n*\n* If new-length is less than old-length, then set offset of the\n* string data in the new string to 0 and bypass padding.\n*\n         CR    #5,#6               If old-length exceeds new-length\n         BH    TRUNCATE            then process with truncation\n*\n* Depending on sign of assumed-fixnum arg 5, set offset of\n* string data in the new string as follows:\n*   negative - new-length minus old-length\n*   zero     - (new-length minus old-length) divided by 2\n*   positive - 0\n*\n         L     #2,16(,#11)         Get arg 5 (assume fixnum)\n         L     #2,##CDR(,#2)       Get numeric value\n         LTR   #2,#2               Test sign\n         BP    PADRIGHT            Positive = padding on right\n         BZ    CENTER              Zero = padding on center\n******** BM    PADLEFT             Negative = padding on left\nPADLEFT  DS    0H                  Padding on left, set offset\n         LR    #3,#6               Offset = new-length - old-length\n         SR    #3,#5\n         B     MOVEPAD\nCENTER   DS    0H                  Padding on left, set offset\n         LR    #3,#6               Offset = (new-length - old-length)/2\n         SR    #3,#5\n         SRL   #3,1\n         B     MOVEPAD\nMOVEPAD  DS    0H\n*\n* Pad new string with the pad character up to offset location.\n* Note that this is skipped if the offset is zero (when padding\n* on right or truncating).\n*\n         XR    #0,#0               Source address = 0\n         LA    #14,##VECDAT(,#4)   Destination address = new-string\n         XR    #1,#1               Source length = 0\n         ICM   #1,B'1000',PADCHAR  Fill character = pad character\n         LR    #15,#3              Destination length = offset\n         MVCL  #14,#0              Pad new string with pad character\nPADRIGHT DS    0H                  Padding on right, leave offset 0\nTRUNCATE DS    0H                  Truncating, leave offset 0\nMOVEIT   DS    0H\n*\n* Move string data to new string using above offset.\n*\n         L     #1,0(,#11)          Get pointer to old-string\n         LA    #0,##VECDAT(,#1)    Source address =  old-string text\n         LA    #14,##VECDAT(#3,#4) Dest. address = new-string w/offset\n         LR    #1,#5               Source length = old-length\n         ICM   #1,B'1000',PADCHAR  Fill character = pad character\n         LR    #15,#6              Destination length = new-length\n         MVCL  #14,#0              Move from old-string to new-string\n         LR    #15,#4              Point to new-string\n         B     RETURN              Return new-string\n         SPACE 1\nRETNULL  DS    0H                  Requested length is zero\n         LA    #15,NULLSTR         Return null string\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nNULLSTR  DS    0A                  Align null string to fullword\n         DC    YL1(##STRING),AL3(0),XL4'00'  String \"\"\n         SPACE 1\nSTRLEN1  DC    YL1(##STRING),AL3(1) Header for a string of length 1\nPADCHAR  DS    XL1                 Pad character\n         SPACE 1\nERROR1   #ERR  'Argument 1 to ZILSPAD not a string - ',0(#11)\nERROR2   #ERR  'Argument 2 to ZILSPAD not a non-negative fixnum - ',   X\n               4(#11)\nERROR3   #ERR  'Argument 3 to ZILSPAD not a valid pad character - ',   X\n               8(#11)\nERROR4   #ERR  'ZIL4010 ZILSPAD: Not enough vector/string space to builX\n               d string.',PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/x-lisp", "datatype": "ebcdic", "extension": ".x-lisp"}, "ZILSPKG": {"ttr": 16385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x00\\x89\\x14/\\x01\\x00&_\\x17!\\x00\\x19\\x00\\x16\\x00\\x18\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1989-05-22T00:00:00", "modifydate": "2000-09-21T17:21:17", "lines": 25, "newlines": 22, "modlines": 24, "user": "SEB1525"}, "text": "         TITLE 'ZILSPKG - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILSPKG  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILSPKG'\n         SPACE 1\n         USING ZILSPKG,#15\n         SPACE 1\n         L     #2,0(,#1)\n         CLI   ##TYPE(#2),##SYMBOL\n         BNE   PKERROR\n         L     #15,##PPKG(,#2)\n         BR    #14\n         SPACE 1\nPKERROR  DS    0H\n         LR    #3,#15\n         DROP  #15\n         USING ZILSPKG,#3\n         #ERR  'Argument to ZILSPKG not a symbol - ',(#2)\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILSPRT": {"ttr": 16387, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11T\\x00!\\x00\\x1e\\x00 \\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 33, "newlines": 30, "modlines": 32, "user": "SEB1525"}, "text": "         TITLE 'ZILSPRT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This function takes one required argument:                          *\n* the compiled code SUBR to be made the CURRENT ZIL printer.          *\n* A lexical closure is not acceptable.  To make a lexical closure     *\n* the current printer, use the ZIL \"SETPRT\" function.                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILSPRT  #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILSPRT'\n         #ZPDS 16                  DEFINE STACK SIZE USED\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #3,0(,#11)          Get the argument\n         CLI   ##TYPE(#3),##SUBR   If arg is not a compiled SUBR\n         BNE   ERROR               then error\n         XR    #15,#15             Else clear insert register\n         ICM   #15,7,##CAR+1(#3)   Get address of SUBR code\n         ST    #15,ZLCCPRT         Set current printer address\n         LR    #15,#3              Return the subr\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 2\nERROR    #ERR  'Argument to ZILSPRT not a compiled code SUBR - ',(#3)\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSRD": {"ttr": 16389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x11T\\x00!\\x00\\x1e\\x00 \\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 33, "newlines": 30, "modlines": 32, "user": "SEB1525"}, "text": "         TITLE 'ZILSRD - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This function takes one required argument:                          *\n* the compiled code SUBR to be made the CURRENT ZIL reader.           *\n* A lexical closure is not acceptable.  To make a lexical closure     *\n* the current reader, use the ZIL \"SETREAD\" function.                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILSRD   #ZBEG MINARGS=1,MAXARGS=1,NAME='ZILSRD'\n         #ZPDS 16                  DEFINE STACK SIZE USED\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #3,0(,#11)          Get the argument\n         CLI   ##TYPE(#3),##SUBR   If arg is not a compiled SUBR\n         BNE   ERROR               then error\n         XR    #15,#15             Else clear insert register\n         ICM   #15,7,##CAR+1(#3)   Get address of SUBR code\n         ST    #15,ZLCCRDR         Set current reader address\n         LR    #15,#3              Return the subr\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 2\nERROR    #ERR  'Argument to ZILSRD not a compiled code SUBR - ',(#3)\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILSUB": {"ttr": 16391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11T\\x00\\xbe\\x00\\xbb\\x00\\xbd\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 190, "newlines": 187, "modlines": 189, "user": "SEB1525"}, "text": "         TITLE 'ZILSUB - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILSUB TAKES TWO ARGUMENTS. BOTH MUST BE NUMERIC ATOMS.             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* CONVERSION RULES ARE AS FOLLOWS:                                    *\n*                                                                     *\n* 1. BOTH ARGS FIXED         - PERFORM INTEGER SUBTRACTION.           *\n* 2. BOTH ARGS FLOAT         - PERFORM REAL SUBTRACTION.              *\n* 3. ONE FIXED, ONE FLOAT    - CONVERT THE FIXED ARGUMENT TO          *\n*                              FLOAT AND PERFORM REAL SUBTRACTION.    *\n*                                                                     *\n* 07/18/86 - IF ONE OR BOTH OF THE ARGS IS A BIGNUM, THE SECOND ARG   *\n*            IS NEGATED AND ZILADD IS INVOKED TO DO BIGNUM ADD.       *\n*                                                                     *\n* ANY OTHER TYPES CAUSE AN ERROR.                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note: At present, ZILSUB calls MINUS and ZILADD to do subtraction   *\n*       if one or both of the arguments is a bignum.                  *\n*                                                                     *\n***********************************************************************\n         SPACE\nZILSUB   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILSUB',SUBRS=ZILSUBR\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #6,#7,0(#11)        LOAD ARGUMENTS\n*\n* CHECK TYPE OF ARG 1\n*\n         CLI   ##TYPE(#6),##FIXNUM IF ARG1 IS NOT FIXED\n         BNE   ARG1NFIX            THEN TRY OTHER TYPE\n         CLI   ##TYPE(#7),##FIXNUM IF ARG2 IS NOT FIXED\n         BNE   ARG2NFIX            THEN TRY OTHER TYPE\n*                                  FIXED - FIXED = FIXED\n         L     #2,##CDR(,#6)       GET FIXED VALUE 1\n         S     #2,##CDR(,#7)       SUBTRACT FIXED VALUE 2\n         BO    BIGSTUFF            IF OVERFLOW OCCURRED, DO BIGNUM ADD\n         LA    #0,20(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               MAKE A FIXNUM\n******** B     RETURN              AND RETURN WITH IT\n         SPACE\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nARG2NFIX DS    0H                  ARG 1 IS FIXED, BUT ARG 2 IS NOT\n         CLI   ##TYPE(#7),##BIGNUM\n         BE    BIGSTUFF            FIXED - BIG\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    FIXSFLO             FIXED - SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    FIXDFLO             FIXED - DFLOAT\n         B     ERROR2              FIXED - NONUM = ERROR\nFIXSFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F2,#F0             GET FLOAT VALUE 1\n         B     SUBSFLO1            FIXED - FLOAT = FLOAT\nFIXDFLO  L     #0,##CDR(,#6)       GET FIXED VALUE 1\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F2,#F0             GET FLOAT VALUE 1\n         B     SUBDFLO1            FIXED - FLOAT = FLOAT\n         SPACE\nARG1NFIX DS    0H                  ARG1 is not fixed\n         CLI   ##TYPE(#6),##BIGNUM\n         BE    BIGSTUFF\n         CLI   ##TYPE(#6),##SFLOAT\n         BE    ARG1SFLO\n         CLI   ##TYPE(#6),##DFLOAT\n         BE    ARG1DFLO\n         B     ERROR1\n         SPACE\nARG1SFLO DS    0H                  ARG 1 IS SINGLE FLOAT\n         SPACE\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    SSUBSFLO            SFLOAT - SFLOAT = SFLOAT\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    SSUBDFLO            SFLOAT - DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    SFLOPFIX            SFLOAT - FIXED = SFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BE    BIGSTUFF            SFLOAT - BIG\n         B     ERROR2              FLOAT - NONUM = ERROR\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO SINGLE FLOAT                         *\n*---------------------------------------------------------------------*\nSFLOPFIX LE    #F2,##CDR(,#6)      Get single float value 1\n         L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LRER  #F4,#F0             GET FLOAT VALUE 2\n         B     SUBSFLO2            FLOAT - FIXED = FLOAT\n         SPACE\nARG1DFLO DS    0H                  ARG 1 IS DOUBLE FLOAT\n         SPACE\n         LD    #F2,8(,#6)          GET FLOAT VALUE 1\n*---------------------------------------------------------------------*\n*                      CHECK TYPE OF ARG 2                            *\n*---------------------------------------------------------------------*\n         CLI   ##TYPE(#7),##DFLOAT\n         BE    SUBDFLO1            DFLOAT - DFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##SFLOAT\n         BE    DSUBSFLO            DFLOAT - SFLOAT = DFLOAT\n         CLI   ##TYPE(#7),##FIXNUM\n         BE    DFLOPFIX            DFLOAT - FIXED = DFLOAT\n         CLI   ##TYPE(#7),##BIGNUM\n         BE    BIGSTUFF            DFLOAT - BIG\n         B     ERROR2              DFLOAT - NONUM = ERROR\n         SPACE 1\n*---------------------------------------------------------------------*\n*                      FIXNUM TO DOUBLE FLOAT                         *\n*---------------------------------------------------------------------*\nDFLOPFIX L     #0,##CDR(,#7)       GET FIXED VALUE 2\n         #BAS  #14,FIX2FLO         CONVERT FIXED TO FLOAT\n         LDR   #F4,#F0             GET FLOAT VALUE 2\n         B     SUBDFLO2\n         SPACE\n*---------------------------------------------------------------------*\n*                       SINGLE FLOAT SUBTRACT                         *\n*---------------------------------------------------------------------*\nSSUBSFLO DS    0H\n         LE    #F2,##CDR(,#6)      Get single float value 1\nSUBSFLO1 DS    0H\n         LE    #F4,##CDR(,#7)      Get single float value 2\nSUBSFLO2 DS    0H\n         SER   #F2,#F4             SUBTRACT THEM\n         STE   #F2,ZLCWORK         PUT RESULT IN REG FOR ATOM-MAKING\n         L     #2,ZLCWORK\n         LA    #0,20(,#11)         SET STACK LOCATION FOR CONS\n         #MKAT FLOAT               MAKE A FLONUM\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\n*---------------------------------------------------------------------*\n*                       DOUBLE FLOAT SUBTRACT                         *\n*---------------------------------------------------------------------*\nDSUBSFLO DS    0H\n         SDR   #F4,#F4\n         LE    #F4,##CDR(,#7)      Get double float value 2\n         B     SUBDFLO2\nSSUBDFLO DS    0H\n         SDR   #F2,#F2\n         LE    #F2,##CDR(,#6)      Get double float value 1\nSUBDFLO1 DS    0H\n         LD    #F4,8(,#7)          Get double float value 2\nSUBDFLO2 DS    0H\n         SDR   #F2,#F4             SUBTRACT THEM\n         LDR   #F0,#F2\n         L     #15,ZLCMDF          Get address of ZILMDF\n         #BASR #14,#15             Call ZILMDF to make a double-float\n         B     RETURN              AND RETURN WITH IT\n         SPACE 1\nBIGSTUFF DS    0H                  ONE ARG IS A BIGNUM, OR OVERFLOW\n         SPACE\n         ST    #7,20(,#11)         PASS ARG 2 TO MINUS\n         L     #15,@MINUS          GET ADDRESS OF MINUS\n         LA    #1,20(,#11)         POINT TO ARGS ON STACK\n         #BASR #14,#15             CALL MINUS TO NEGATE ARG 2\n         ST    #15,4(,#11)         STORE RESULT IN ARG 2\n         LR    #1,#11              RELOAD STACK POINTER\n         L     #15,@ZILADD         GET ADDRESS OF ZILADD\n         LM    #11,#12,8(#1)       RELOAD REGS AS IF RETURNING\n         L     #14,16(,#1)         RELOAD REGS AS IF RETURNING\n         BR    #15                 BRANCH TO ZILADD TO DO BIGNUM ADD\n         EJECT\n         COPY  FIX2FLO             FIXED TO FLOAT CONVERSION ROUTINE\n         EJECT\nZILSUBRS DS    0A\n@MINUS   DC    V(MINUS)            ADDRESS OF SUBROUTINE\n         DC    CL8'MINUS'\n@ZILADD  DC    V(ZILADD)           ADDRESS OF SUBROUTINE\n         DC    CL8'ZILADD'\nZILSUBRE EQU   *\n         EJECT\nERROR1   #ERR  'Argument 1 to subtract not a number - ',0(#11)\nERROR2   #ERR  'Argument 2 to subtract not a number - ',4(#11)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILSUBS": {"ttr": 16395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11T\\x00!\\x00\\x18\\x00 \\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 33, "newlines": 24, "modlines": 32, "user": "SEB1525"}, "text": "         TITLE 'ZILSUBS - ZIL 1.3 SUBROUTINE VECTOR MODULE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS LINKEDITED WITH THE SUBROUTINES INDICATED HEREIN BY  *\n* V-CON'S, WHICH ARE THE SUBROUTINES TO BE DYNAMICALLY LOADED BY      *\n* ZILINIT AT INITIALIZATION TIME AND WHOSE ADDRESSES ARE TO BE PLACED *\n* IN THE COMMON AREA.  ROUTINES WHICH REQUIRE THESE SUBROUTINES WILL  *\n* CALL THEM BY RETRIEVING THEIR ADDRESSES OUT OF COMMON RATHER THAN   *\n* HAVING THEM LINKEDITED WITH THE LOAD MODULES.                       *\n* THE REASONS FOR PLACING MODULES IN HERE VARY, BUT THEY INCLUDE      *\n* ESTABLISHING STANDARD (AND POSSIBLY VARYING OVER TIME) INTERFACES   *\n* WHICH DO NOT REQUIRE FULL-FLEDGED MODULES TO BE CODED, OR TO        *\n* PROVIDE EXPEDITED INTERFACES TO COMMONLY INVOKED FUNCTIONS.  THE    *\n* INTERPRETER/EVALUATOR SUPPORT CODE ALSO WILL BENEFIT FROM THESE.    *\n*                                                                     *\n* THIS MODULE IS NOT EXECUTABLE, ALTHOUGH ITS EXTERNAL ROUTINES ARE.  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 06/01/88 - Added ZILVALS.  Reassembly required.  See #ZSUB, #ZCOM.  *\n*                                                                     *\n***********************************************************************\nZILSUBS  CSECT\n         DC    A(ZSASUBS)          ADDRESS OF SUBROUTINE POINTERS\n         #ZSUB ,                   DEFINE EXTERNAL SUBROUTINE VCONS\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILTERM": {"ttr": 16397, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x88\\x01_\\x00\\x89$\\x1f\\x16'\\x014\\x01!\\x014\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-08-29T16:27:00", "lines": 308, "newlines": 289, "modlines": 308, "user": "SEB1525"}, "text": "         TITLE 'ZILTERM - ZIL TERMINATION MODULE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS INVOKED VIA LINK FROM THE MAINLINE MODULE ZILMAIN    *\n* WHENEVER A COMPILED LISP MODULE IS FINISHED.  IT FREES THE STORAGE  *\n* ALLOCATED BY ZILINIT, CLOSES ALL RELEVANT FILES, AND HANDLES ANY    *\n* OTHER CLEANUP FUNCTIONS THAT MAY BE REQUIRED.                       *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         #ZEQU\nZILTERM  CSECT\n         AIF   (NOT &ZILXA).NOMODES\nZILTERM  RMODE 24\nZILTERM  AMODE 31\n.NOMODES ANOP\n         SAVE  (14,12),,ZILTERM_&SYSDATE._&SYSTIME\n         LR    #12,#15             SET UP BASE REGISTER\n         L     #1,8(,#13)          CHAIN TO COMMON AREA\n         ST    #13,4(,#1)\n         LR    #13,#1\n         USING ZILTERM,#12\n         USING ZLCOMMON,#13\n         USING ZLFILBLK,#7\n         SPACE 1\n         OI    ZLCEFLGS,ZLCETERM   INDICATE TERMINATION IN PROGRESS\n*\n* CANCEL ESTAE AND/OR STAX ENVIRONMENTS IF ANY.\n* (CAN'T CANCEL ESTAE FROM THIS RB, SO DON'T EVEN TRY)\n*\n*        TM    ZLCEFLGS,ZLCESTAE\n*        BZ    NOESTAE\n*        ESTAE 0                   CANCEL ABEND HANDLER\n*OESTAE  DS    0H\n         TM    ZLCEFLGS,ZLCESTAX\n         BZ    NOSTAX\n         STAX  ,                   CANCEL ATTENTION HANDLER\nNOSTAX   DS    0H\n*\n* FREE FORTRAN INTERFACE IF ANY.\n*\n         ICM   #1,15,ZLCFTCBA      IF FORTRAN INTERFACE ROUTINE PRESENT\n         BZ    NOFTCB              THEN\n         ICM   #15,15,ZLCFINT\n         BZ    NOFTCB\n         XR    #1,#1                SET FLAG TO CLEAN UP\n         #BASR #14,#15              CALL ZILFINT TO CLEAN UP INTERFACE\nNOFTCB   DS    0H\n*\n* FREE GC WORK AREA IF ANY.\n*\n         ICM   #1,15,ZLCGCBVA\n         BZ    NOFRGCWA\n         L     #0,ZLCGCBVL\n         FREEMAIN RU,LV=(0),A=(1)\nNOFRGCWA DS    0H\n*\n* FREE \"MASTER VECTOR\" OF INLINE COMPILED CODE POINTERS IF ANY\n*\n         ICM   #1,15,ZLCICPA\n         BZ    NOFRICPA\n         L     #0,ZLCICPL\n         FREEMAIN RU,LV=(0),A=(1)\nNOFRICPA DS    0H\n*\n* FREE ZILADMP WORK AREA IF ANY.\n*\n         ICM   #1,15,ZLCDWA\n         BZ    NOFRDWA\n         L     #0,ZLCDWALN\n         FREEMAIN R,LV=(0),A=(1)\nNOFRDWA  DS    0H\n*\n* FREE PRINC/REFORMAT WORK AREA IF ANY.\n*\n         ICM   #1,15,ZLCTWA\n         BZ    NOFRTWA\n         L     #0,ZLCTWALN\n         FREEMAIN R,LV=(0),A=(1)\nNOFRTWA  DS    0H\n*\n* FREE ZIL WORK AREA IF ANY.\n*\n         ICM   #1,15,ZLCWA\n         BZ    NOFRWA\n         L     #0,ZLCWALEN\n         FREEMAIN R,LV=(0),A=(1)\nNOFRWA   DS    0H\n*\n* DELETE READ TABLE(S) IF ANY.\n*\n         ICM   #1,15,ZLCRDTBL\n         BZ    NOFRDTBL\n         LA    #0,256\n         FREEMAIN RU,LV=(0),A=(1)\nNOFRDTBL DS    0H\n*\n* FREE TERMINAL OUTPUT TRANSLATE TABLE IF ANY.\n*\n         ICM   #1,15,ZLCTRMTR\n         BZ    NOFREETT\n         LA    #0,256\n         FREEMAIN RU,LV=(0),A=(1)\nNOFREETT DS    0H\n*\n* CLOSE DRIBBLE FILE IF ALLOCATED.\n*\n         ICM   #4,15,ZLCDRIBL\n         BZ    NODRIB\n         TM    X'30'(#4),X'10'\n         BZ    NODRIB\n         ST    #4,CLOSEL\n         MVI   CLOSEL,X'80'\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,DRIB24           ADDRESS OF THIS CODE\n         LA    #2,DRIB24E          RETURN ADDRESS\n         BSM   #2,#1\nDRIB24   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n         LA    #1,CLOSEL\n         CLOSE MF=(E,(1))\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nDRIB24E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         LR    #1,#4               GET ADDRESS OF THE DRIBBLE DCB\n         LA    #0,96               GET LENGTH OF THE DRIBBLE DCB\n         FREEMAIN R,LV=(0),A=(1)   FREE THE DCB\nNODRIB   DS    0H\n*\n* CLOSE ALL OPEN FILES.\n*\n         L     #5,ZLCSTDIN\n         L     #6,ZLCSTDOU\n*\n* CLOSE ALL OPEN INPUT FILES.\n*\nCLOSEIN  DS    0H\n         LR    #7,#5\nCINLOOP  DS    0H\n         LTR   #7,#7\n         BZ    CLOSEOUT\n         TM    ZLFFLAG1,ZLFTERM\n         BO    NOCLOSEI\n         TM    ZLFFLAG2,ZLFOPEN\n         BZ    NOCLOSEI\n         LA    #1,ZLFDCB\n         TM    X'30'(#1),X'10'\n         BZ    NOCLOSEI\n         ST    #1,CLOSEL\n         MVI   CLOSEL,X'80'\n         AIF   (NOT &ZILXA).SKIP3\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,CLOSI24          ADDRESS OF THIS CODE\n         LA    #2,CLOSI24E         RETURN ADDRESS\n         BSM   #2,#1\nCLOSI24  DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP3   ANOP\n         LA    #1,CLOSEL\n         CLOSE MF=(E,(1))\n*\n* FOR LIBRARY FILE, INSTEAD OF FREEPOOL FREE THE READ BUFFER.\n* THAT IS, WHEN WE HAVE SUPPORT FOR LIBRARY FILES.\n*\n         LA    #1,ZLFDCB\n         FREEPOOL (1)\n         AIF   (NOT &ZILXA).SKIP4\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nCLOSI24E DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP4   ANOP\nNOCLOSEI DS    0H\n         LR    #1,#7\n         L     #7,ZLFCHAIN\n         C     #1,ZLCIFTRM         DON'T FREE IF IT'S THE TERM FILBLK\n         BE    CINLOOP\n         LH    #0,ZLCFBLEN         FREE THE FILE BLOCK\n         FREEMAIN R,LV=(0),A=(1)\n         B     CINLOOP\n*\n* CLOSE ALL OPEN OUTPUT FILES.\n*\nCLOSEOUT DS    0H\n         LR    #7,#6\nCOUTLOOP DS    0H\n         LTR   #7,#7\n         BZ    FINISHED\n         TM    ZLFFLAG1,ZLFTERM\n         BO    NOCLOSEO\n         TM    ZLFFLAG2,ZLFOPEN\n         BZ    NOCLOSEO\n         LA    #1,ZLFDCB\n         TM    X'30'(#1),X'10'\n         BZ    NOCLOSEO\n         ST    #1,CLOSEL\n         MVI   CLOSEL,X'80'\n*\n* IF THERE IS ANY DATA PRINTED TO THE CURRENT LINE THAT HAS NOT BEEN\n* SENT TO THE DATA SET BY TERPRI, WRITE OUT THE LINE NOW.\n* OTHERWISE BUMP BACK THE DCB POINTER, A LA COBOL, SO THAT A LINE\n* OF GARBAGE DOESN'T GET WRITTEN OUT.\n*\n* NOTE: THIS DOESN'T WORK FOR RECFM=V FILES - AT LEAST I HAVEN'T\n* FIGURED OUT HOW TO MAKE IT WORK.  SO WE LET THE LAST RECORD\n* (HOPEFULLY A NULL RECORD) GET WRITTEN OUT IN THAT CASE.\n*\n         TM    ZLFFLAG1,ZLFNEWLN   IF NO UNPROCESSED OUTPUT DATA\n         BO    NOUNPUT              AND\n         TM    ZLFFLAG2,ZLFRECV      THIS IS A RECFM=F FILE\n         BO    AFTUNPUT               THEN\n         L     #1,ZLFDCB+76          TAKE CURRENT RECORD POINTER\n         SH    #1,ZLFDCB+82          SUBTRACT ONE LRECL\n         ST    #1,ZLFDCB+76          RESET CURRENT RECORD POINTER\n         B     AFTUNPUT             ELSE\nNOUNPUT  DS    0H                  THERE IS UNPROCESSED OUTPUT DATA\n         TM    ZLFFLAG2,ZLFRECV    IF THIS IS A RECFM=V FILE\n         BZ    AFTUNPUT            THEN\n         L     #1,ZLFCARD           GET ADDRESS OF START OF RECORD\n         SH    #1,=H'4'             BUMP BACK TO RDW\n         L     #2,ZLFCHAR           GET CURRENT CHARACTER POINTER\n         LA    #2,4-1(,#2)          ADJUST BY 1, ADD 4 TO INCLUDE RDW\n         SLL   #2,16                SHIFT LENGTH INTO LEFT HALF\n         ST    #2,0(,#1)            STORE THE RDW\nAFTUNPUT DS    0H\n         AIF   (NOT &ZILXA).SKIP5\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,CLOSO24          ADDRESS OF THIS CODE\n         LA    #2,CLOSO24E         RETURN ADDRESS\n         BSM   #2,#1\nCLOSO24  DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP5   ANOP\n         LA    #1,CLOSEL\n         CLOSE MF=(E,(1))\n*\n* FOR LIBRARY FILE, INSTEAD OF FREEPOOL FREE THE READ BUFFER.\n* THAT IS, WHEN WE HAVE SUPPORT FOR LIBRARY FILES.\n*\n         LA    #1,ZLFDCB\n         FREEPOOL (1)\n         AIF   (NOT &ZILXA).SKIP6\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nCLOSO24E DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP6   ANOP\nNOCLOSEO DS    0H\n         LR    #1,#7\n         L     #7,ZLFCHAIN\n         C     #1,ZLCOFTRM         DON'T FREE IF IT'S THE TERM FILBLK\n         BE    COUTLOOP\n         LH    #0,ZLCFBLEN\n         FREEMAIN R,LV=(0),A=(1)\n         B     COUTLOOP\nFINISHED DS    0H\n*\n* IF THERE'S \"REAL\" TERMINAL INPUT OR OUTPUT FILE BLOCK(S),\n* THEN FREE THEM NOW.  WE HAVE TO DO IT HERE BECAUSE MAYBE A\n* TERMINAL FILE WAS EXPLICITLY CLOSED, LEAVING THIS STRANDED.\n*\n         ICM   #1,15,ZLCIFTRM\n         BZ    NOFREEIF\n         LH    #0,ZLCFBLEN\n         FREEMAIN R,LV=(0),A=(1)\nNOFREEIF DS    0H\n         ICM   #1,15,ZLCOFTRM\n         BZ    NOFREEOF\n         LH    #0,ZLCFBLEN\n         FREEMAIN R,LV=(0),A=(1)\nNOFREEOF DS    0H\n*\n* DELETE LOADED MODULES.\n*\n         DELETE EP=ZILSUBS         DELETE SUBROUTINE MODULE\n*\n* NOW WE ARE REALLY FINISHED.\n*\n         L     #1,ZLC31ADR         GET ADDRESS OF 31-BIT AREA\n         L     #0,ZLC31SIZ         GET LENGTH OF 31-BIT AREA\n         FREEMAIN RU,LV=(0),A=(1)  FREE IT UP\n         SPACE 1\n         L     #1,ZLC24ADR         FREE ALL REMAINING 24-BIT STORAGE\n         L     #0,ZLC24SIZ\n         L     #13,4(,#13)         RESTORE SAVE AREA\n         FREEMAIN RU,LV=(0),A=(1)\n         SPACE 1\n         LM    #14,#12,12(#13)     RESTORE REGISTERS\n         XR    #15,#15\n         BR    #14                 RETURN TO MAIN LINE CODE\n         SPACE\nCLOSEL   CLOSE (*-*),MF=L\n         SPACE\n         LTORG\n         SPACE\n         #ZCOM ,                   MAP THE COMMON AREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILTERP": {"ttr": 16643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00R\\x00\\x88\\x01_\\x01\\x00&_\\x17!\\x00\\x8e\\x00\\x84\\x00\\x8d\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:21:52", "lines": 142, "newlines": 132, "modlines": 141, "user": "SEB1525"}, "text": "         TITLE 'ZILTERP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE PROCESSES TERPRI REQUESTS, I.E. IT FORCES OUTPUT.       *\n*                                                                     *\n* ON ENTRY:                                                           *\n*                                                                     *\n*  #7 = FILE POINTER                                                  *\n*                                                                     *\n* THIS ROUTINE DESTROYS REGISTERS 14,15,0,1,2,3.                      *\n*                                                                     *\n* REGISTERS 4,5,6,AND 7 (OF COURSE) ARE UNCHANGED                     *\n* (DON'T WORRY,ZILTPUT SAVES ALL THE REGISTERS).                      *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         EJECT\nZILTERP  #ZBEG NAME='ZILTERP'\n         SPACE 1\n         ST    #12,SAVE12          SAVE CALLER'S BASE REGISTER\n         LR    #3,#14              SAVE CALLER'S RETURN REGISTER\n         LR    #12,#15             SET UP OWR BASE REGISTER\n         DROP  #15\n         USING ZILTERP,#12\n         USING ZLFILBLK,#7         ASSUME #7 CONTAINS FILE POINTER\n         SPACE 1\n         TM    ZLFFLAG,ZLFTERM     IF OUTPUT FILE ALLOCATED TO TERMINAL\n         BZ    NOTTERM             THEN\n         L     #1,ZLFCARD           GET ADDRESS OF OUTPUT AREA\n         LH    #2,ZLFLRECL          GET LENGTH OF OUTPUT AREA\n* NOTE - SINCE WE'RE GONNA STICK A NEWLINE ONTO THE END OF THIS LINE,\n*        REG 2 CONTAINS LENGTH MINUS 1 - SUITABLE FOR EXECUTE\n         L     #14,ZLCTRMTR         GET TERMINAL OUTPUT TRANSLATE TABLE\n         EX    #2,TRANS             TRANSLATE THE LINE\n         LA    #14,0(#2,#1)         POINT TO CHARACTER FOLLOWING OUTPUT\n         MVI   0(#14),X'15'         MOVE IN A NEWLINE CHARACTER\n         LR    #15,#14              POINT TO CHAR FOLLOWING LAST CHAR\n         BCTR  #15,0                POINT TO LAST CHARACTER\n         CLI   0(#15),C' '          IF LAST CHARACTER IS NOT A BLANK\n         BNE   BNEND                THEN SKIP TRAILING-BLANK CONVERSION\n         BCTR  #15,0                POINT TO LAST CHARACTER BUT 1\nBNLOOP   DS    0H\n         CR    #15,#1               LOOP BACKWARDS UNTIL START OF LINE\n         BL    BNEND\n         CLI   0(#15),C' '          REPLACE TRAILING BLANKS WITH NULLS\n         BNE   BNEND                SO THAT ONLY ONE TRAILING BLANK IS\n         MVI   1(#15),X'00'           LEFT FOLLOWING LAST NONBLANK\n         BCT   #15,BNLOOP\nBNEND    DS    0H\n         LA    #0,1(,#2)            SET LENGTH INCLUDING NEWLINE\n         #TPUT *,(1),(0),ASIS       DO TPUT\n         B     AFTOUT\n         SPACE 1\nTRANS    TR    0(*-*,#1),0(#14)    TRANSLATE LINE TO DECENT CHARACTERS\n         SPACE 1\nNOTTERM  DS    0H                  ELSE\n         TM    ZLFFLAG2,ZLFRECV    IF THIS IS A RECFM=V FILE,\n         BZ    NOTVB               THEN...\n         L     #1,ZLFCARD           GET ADDRESS OF START OF RECORD\n         SH    #1,=H'4'             BUMP BACK TO RDW\n         L     #2,ZLFCHAR           GET CURRENT CHARACTER POINTER\n         LA    #2,4-1(,#2)          ADJUST BY 1, ADD 4 TO INCLUDE RDW\n         TM    ZLFDCB+36,X'04'      IF RECFM = V.A\n         BZ    NOTTRCVA             THEN...\n         LA    #2,1(,#2)             ADJUST FOR PRINT CONTROL CHAR\n         BCTR  #1,0                  BUMP BACK FOR PRINT CONTROL CHAR\nNOTTRCVA DS    0H\n         SLL   #2,16                SHIFT LENGTH INTO LEFT HALF\n         ST    #2,0(,#1)            STORE THE RDW\nNOTVB    DS    0H\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,CODE24           ADDRESS OF THIS CODE\n         LA    #2,CODE24E          RETURN ADDRESS\n         BSM   #2,#1\nCODE24   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    INDICATE NON-ZIL-CODE RUNNING\n         LA    #1,ZLFDCB           POINT TO DCB\n         PUT   (1)                 DO PUT LOCATE\n         NI    ZLCIFLGS,255-ZLCISYS INDICATE ZIL CODE RUNNING AGAIN\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nCODE24E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\n         LH    #0,ZLFDCB+82        GET DCB LRECL\n         TM    ZLFFLAG2,ZLFRECV    IF THIS IS A RECFM=V FILE\n         BZ    NOTRECFV            THEN...\n         TM    ZLFDCB+36,X'04'      IF RECFM = V.A\n         BZ    NOTRECVA             THEN...\n         MVC   0(5,#1),NULLRDWA      SET THIS RECORD'S RDW\n         LA    #1,5(,#1)             BUMP PAST RDW\n         SH    #0,=H'5'             ADJUST LENGTH OF ACTUAL RECORD TEXT\n         B     NOTRECFA\nNOTRECVA DS    0H                  ELSE RECFM = V(B), NO A\n         MVC   0(4,#1),NULLRDW       SET THIS RECORD'S RDW\n         LA    #1,4(,#1)             BUMP PAST RDW\n         SH    #0,=H'4'             ADJUST LENGTH OF ACTUAL RECORD TEXT\n         B     NOTRECFA\nNOTRECFV DS    0H                  ELSE\n         TM    ZLFDCB+36,X'04'     IF RECFM = F.A\n         BZ    NOTRECFA            THEN...\n         MVI   0(#1),C' '           INITIALIZE PRINT CONTROL CHAR\n         LA    #1,1(,#1)            BUMP POINTER PAST CONTROL CHAR\n         BCTR  #0,0                 SUBTRACT 1 FOR PRINT CONTROL CHAR\nNOTRECFA DS    0H\n         ST    #1,ZLFCARD          STORE CURRENT RECORD ADDRESS\n         STH   #0,ZLFLRECL         STORE RECORD LENGTH\n         ALR   #1,#0               ADDRESS + LENGTH GIVES...\n         ST    #1,ZLFEND           NEW END-OF-RECORD POSITION\nAFTOUT   DS    0H\n         LA    #0,1                SET CHARACTER POSITION\n         ST    #0,ZLFCHAR          TO ONE\n         NI    ZLFFLAG1,255-ZLFNEWLN CLEAR NEW LINE INDICATION\n         LA    #15,X'40'           SOURCE LENGTH = 0\n         SLL   #15,24              FILL = BLANK\n         XR    #14,#14             SOURCE = NULL\n         LH    #1,ZLFLRECL         LENGTH = LENGTH OF OUTPUT AREA\n         L     #0,ZLFCARD          TARGET = OUTPUT AREA\n         MVCL  #0,#14              CLEAR OUTPUT AREA TO BLANKS\n         SPACE 1\n         L     #12,SAVE12          RELOAD CALLER'S BASE REGISTER\n         BR    #3                  RETURN TO CALLER\n         SPACE 1\nSAVE12   DS    A\nNULLRDW  DC    Y(4,0)\nNULLRDWA DC    Y(5,0),C' '\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILTHROW": {"ttr": 16646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x000\\x00\\x88\\x01_\\x01\\x00&_\\x17$\\x01\\xa6\\x01\\x8a\\x01\\xa5\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:24:30", "lines": 422, "newlines": 394, "modlines": 421, "user": "SEB1525"}, "text": "         TITLE 'ZILTHROW - ZIL 1.3 THROW PROCESSOR'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE PROCESSES THE \"THROW\" FUNCTION.                        *\n*                                                                     *\n* IT TAKES TWO ARGUMENTS IN REGISTERS AS FOLLOWS:                     *\n*                                                                     *\n* REGISTER 1 CONTAINS ARGUMENT 1, THE TAG.                            *\n* REGISTER 2 CONTAINS ARGUMENT 2, THE RESULT.                         *\n*                                                                     *\n* THIS ROUTINE SEARCHES THROUGH THE ACTIVE CATCH FRAMES UNTIL IT      *\n* FINDS ONE WHOSE TAG MATCHES ARGUMENT 1.  WHEN IT DOES, IT SCANS     *\n* AGAIN THROUGH THE CHAIN OF CATCH FRAMES LOOKING FOR UNWIND-PROTECT  *\n* FRAMES TO PROCESS; FOR EACH ONE IT FINDS, IT INVOKES THE CLEANUP    *\n* FORMS, TEMPORARILY RESTORING THE ENVIRONMENT TO THE STATE IT WAS IN *\n* AT THE LEXICAL TIME OF THE CLEANUP FORMS.  THIS SCAN TERMINATES     *\n* AT THE CATCH FRAME FOUND ABOVE (TO WHICH WE ARE THROWING), AT WHICH *\n* POINT RETURN TO THAT LEXICAL ENVIRONMENT IS EFFECTED.  IT RESTORES  *\n* THE ENVIRONMENT FROM THE CATCH FRAME, PLACES THE RESULT ARGUMENT IN *\n* REGISTER 15, AND RETURNS TO THE ADDRESS FROM THE CATCH FRAME WHERE  *\n* THE CATCH FUNCTION EXPECTS THE VALUE TO BE RETURNED AND THE CATCH   *\n* FRAME TO BE DEACTIVATED.                                            *\n*                                                                     *\n* IF NO CATCH FRAME IS FOUND, THEN IF THE TAG IS NIL THE PROGRAM IS   *\n* ABNORMALLY TERMINATED, OTHERWISE THE \"ZILERR\" FUNCTION IS INVOKED   *\n* TO DISPLAY AN ERROR MESSAGE AND ISSUE A THROW TO A TAG OF NIL.      *\n*                                                                     *\n* NO STACK SPACE IS REQUIRED, AND REGISTERS NEED NOT BE SAVED.        *\n* REGISTER 15 IS USED AS THE BASE REGISTER AND REGISTER 14 IS         *\n* IRRELEVANT SINCE CONTROL WILL NEVER BE RETURNED NORMALLY.           *\n*                                                                     *\n* THE STRUCTURE OF THE CATCH FRAME IS AS FOLLOWS (NOTE THAT THE       *\n* COMPILER GENERATES THIS STRUCTURE, SO IT MAY NOT BE CHANGED):       *\n*                                                                     *\n* +0  ... ADDRESS OF THE PREVIOUS CATCH FRAME (X'00000000' IF NONE)   *\n* +4  ... SAVED REGISTER 11 (STACK POINTER FROM INVOKER OF CATCH)     *\n* +8  ... SAVED REGISTER 12 (BASE REGISTER FROM INVOKER OF CATCH)     *\n* +12 ... RETURN ADDRESS (TO BRANCH TO END OF CATCH CODE)             *\n* +16 ... SAVED SPECIAL ALIST (VARIABLE BINDING ENVIRONMENT)          *\n* +20 ... SAVED FLUID ALIST (VARIABLE BINDING ENVIRONMENT)            *\n* +24 ... THE CATCH/THROW TAG (X'00000000' FOR UNWIND-PROTECT FRAME)  *\n*                                                                     *\n* ...PLUS THE FOLLOWING, PRESENT ONLY IN UNWIND-PROTECT FRAMES:       *\n*                                                                     *\n* +28 ... ADDRESS OF THE CLEANUP FORMS CODE TO INVOKE                 *\n*         (DURING UNWIND, THIS CONTAINS THE TAG BEING THROWN TO)      *\n* +32 ... THE RETURN VALUE STORED FROM EVALUATING THE PROTECTED FORM  *\n*         (DURING UNWIND, THIS CONTAINS THE RETURN VALUE FROM THROW)  *\n*                                                                     *\n* DURING PROCESSING OF UNWIND-PROTECT CLEANUP FORMS, THE ACTIVE       *\n* CATCH FRAME IS THE ONE ESTABLISHED PREVIOUSLY TO THE UNWIND-PROTECT *\n* FRAME; THE CODE TO DEACTIVATE THE UNWIND-PROTECT FRAME AND TO       *\n* MAKE THE PREVIOUS FRAME THE CURRENT CATCH FRAME IS AT THE BEGINNING *\n* OF THE CLEANUP FORMS CODE GENERATED BY THE COMPILER.                *\n* UPON RETURN FROM THE CLEANUP FORMS, REGISTER 14 POINTS TO THE FRAME *\n* (WHICH HAS NOT BEEN LEXICALLY POPPED FROM THE STACK, DESPITE BEING  *\n* UNHOOKED FROM THE ACTIVE CHAIN).                                    *\n*                                                                     *\n* IF THROWING TO TAG NIL, WHICH MEANS THAT AN ERROR IS                *\n* BEING SIGNALLED, IT DOES A BACK TRACE OF THE STACK IF DEBUG MODE    *\n* IS ACTIVE.                                                          *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         EJECT\nZILTHROW #ZBEG NAME='ZILTHROW'\n         SPACE 1\n*\n* FIRST OF ALL, RESET THE PROGRAM MASK IN CASE SOME FORTRAN ROUTINE\n* SCREWED AROUND WITH IT\n*\n         SPACE 1\n         ICM   #14,8,ZLCPMASK      GET INITIAL PROGRAM MASK\n         SPM   #14                 SET PROGRAM MASK BACK TO NORMAL\n*\n* TURN OFF MISCELLANEOUS ZIL BITS THAT MAY HAVE BEEN LEFT ON SO WE\n* DON'T END UP IN A WEIRD STATE\n*\n         NI    ZLCGCFLG,255-ZLCGCBLD  TURN OFF SPECIAL-GC-CALLER FLAG\n         NI    ZLCPFLGS,255-ZLCPRINT  TURN OFF ZILPRIN-IN-PROCESS FLAG\n         NI    ZLCDFLGS,255-ZLCDCOPY  TURN OFF ZILADMP COPY FLAG\n         NI    ZLCERFLG,255-ZLCERTRC  TURN OFF STACK TRACE FLAG\n         NI    ZLCERFLG,255-ZLCERCFA  TURN OFF CONDITIONAL FILE ACCESS\n         SPACE 1\n         L     #14,ZLCCATCH        GET POINTER TO CURRENT CATCH FRAME\nLOOP     DS    0H\n         LTR   #14,#14             IF NO MORE CATCH FRAMES ARE ACTIVE\n         BZ    NOCATCH             THEN PROCESS THROW ERROR\n         USING CATCH,#14\n         C     #1,CATCHTAG         IF TAG MATCHES\n         BE    GOTCATCH            THEN WE FOUND THE CATCH TO PROCESS\n         L     #14,CATCHLNK        ELSE GET PREVIOUS CATCH FRAME\n         B     LOOP                AND CONTINUE.\n         SPACE 1\nGOTCATCH DS    0H                  WE HAVE THE CATCH FRAME...\n         SPACE 1\n         ST    #12,SAVE12          Save base reg on entry\n         LR    #12,#15             GET A BETTER BASE REGISTER\n         DROP  #15\n         USING ZILTHROW,#12\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* OK, TRY BACK TRACE BEFORE THROWING TO SIGNAL ERROR.                 *\n*                                                                     *\n* Remember that the only registers that can be maintained across      *\n* a call to PRINT/TERPRI are #5.                                      *\n*                                                                     *\n* #4 must point to the object to be printed                           *\n* #7 must point to the file block for standard output                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CR    #1,#10              If throw tag is not NIL\n         BNE   NOTRACE             then skip trace\n         SPACE 1\n         TM    ZLCERFLG,ZLCERDBG   If debug mode is not active\n         BZ    NOTRACE             then skip trace\n         SPACE 1\n         TM    ZLCERFLG,ZLCERTRC   If already doing a back trace\n         BO    NOTRACE             then skip trace\n         SPACE 1\n         OI    ZLCERFLG,ZLCERTRC   Indicate stack tracing active\n         STM   #0,#2,SAVEARGS      Save args to THROW\n         L     #7,ZLCSTDOU         GET STANDARD OUTPUT FILE POINTER\n         USING ZLFILBLK,#7\n         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE\n         LA    #4,TRCMSG1\n         L     #15,ZLCPRIN         Call ZILPRIN to print message\n         #BASR #14,#15\n         L     #15,ZLCTERP         Call ZILTERP to TERPRI\n         #BASR #14,#15\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Try to find the current stack pointer.                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #0,SAVEARGS+0       Get reg 0 at entry to ZILTHROW\n         TM    ZLCGCFLG,ZLCGCBLD   If it was set for CONS/GC\n         BO    REG0OK              then we can assume that it is OK\n         L     #1,SAVE12           Else get base reg of who called us\n         CLC   0(3,#1),=X'47F0F0'  Check for valid ZIL code\n         BNE   GIVEUP              If wrong code, assume default stack\n         XR    #2,#2\n         IC    #2,3(,#1)           Get B2D2 of initial branch instr.\n         AR    #1,#2               Point to next executable instr.\n         CLC   0(2,#1),=X'4100'    Check valid (expected) ZIL code\n         BNE   MAYBLEX             If not what is expected, maybe LEXPR\n         LH    #2,2(,#1)           Get B2D2 of stack size LA instr.\n         SLA   #2,20               Shift out base reg and\n         SRA   #2,20                isolate the maximum stack size\n         AR    #2,#11              Add stack ptr to get max stack addr\n         CR    #0,#11              If reg 0 less than current stack ptr\n         BL    BADREG0             then can't use it\n         CR    #0,#2               If reg 0 greater than max stack ptr\n         BH    BADREG0             then can't use it\n         B     REG0OK              Otherwise use reg 0 as top of stack\nMAYBLEX  DS    0H                  Maybe it's a lexpr...\n         CLC   0(L'LCODE,#1),LCODE See if it's compiled lexpr prologue\n         BNE   GIVEUP              If not, can't verify #0, wrong code\n         LH    #2,L'LCODE(,#1)     Get B2D2 of stack size LA instr.\n         SLA   #2,20               Shift out base reg and\n         SRA   #2,20                isolate the maximum stack size\n         SH    #2,=H'4'            Adjust it\n         AR    #2,#11              Add stack ptr to get max stack addr\n         CR    #0,#11              If reg 0 less than current stack ptr\n         BL    BADREG0             then can't use it\n         CR    #0,#2               If reg 0 greater than max stack ptr\n******** BH    BADREG0             then can't use it\n         BNH   REG0OK              Otherwise use reg 0 as top of stack\nBADREG0  DS    0H\n         LR    #5,#2               Continue, using max stack addr\n         B     STKLOOP\nREG0OK   DS    0H\n         LR    #5,#0               Put into a useable register\n         B     STKLOOP\n         SPACE 1\nLCODE1   DS    0A\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  The code that follows is used to compare with LEXPR header code.   *\n*  See ZCGBEGIN.  If this code is changed in ZCGBEGIN it must also    *\n*  be changed here.                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #2,0(,#1)           Get pointer to LEXPR arg on stack\n         L     #2,##CDR(,#2)       Get fixnum value thereof\n         SLA   #2,2                Multiply it by 4 to get stack length\n         LA    #0,*-*(#2,#1)       Half of the expected LA instruction\n         ORG   *-2                 Throw away the other half\nLCODE    EQU   LCODE1,*-LCODE1     Length of this code\n         SPACE 1\nGIVEUP   DS    0H                  Can't determine stack pointer?\n         SPACE 1\n         LA    #5,4(,#11)          Get last stack pointer\n         SPACE 1\nSTKLOOP  DS    0H                  #5 should be top-of-stack pointer\n         C     #5,ZLCPDADR         Loop until we hit bottom\n         BL    STKEND\n         ICM   #4,15,0(#5)         Get pointer off stack\n         BNP   STKSKIP             If negative, probably ret addr, skip\n         C     #4,ZLCPDADR         If it points into the stack, skip it\n         BL    NOTINSTK\n         CR    #4,#8\n         BL    STKBOUND\nNOTINSTK DS    0H\n         CR    #4,#13              If unsupplied optional argument\n         BE    NOTCODE              or\n         C     #4,ZLCUNBND           the unbound marker\n         BE    NOTCODE                or\n         C     #4,ZLCRMNIL             the RMNIL object\n         BE    NOTCODE                  then it ought to be printed\n         TM    0(#4),X'80'         If this looks like a cons\n         BO    NOTCODE             then it may be suspicious\n         CLC   0(3,#4),=X'47F0F0'  If CAR looks like code\n         BE    CODE                then this must be code\n         AIF   (&ZILXA).XACARCK\n         CLI   0(#4),0             370: If CAR is not a 24-bit pointer\n         BNE   STKSKIP             then skip\n         AGO   .NCARCK\n.XACARCK ANOP\n         C     #10,0(,#4)          XA: If higher than any possible CAR\n         BL    STKSKIP             then skip\n.NCARCK  ANOP\n         CLC   0(4,#4),=F'0'       if CAR looks like zeroes\n         BE    STKSKIP             then skip\n         B     NOTCODE             Else print out as LISP object\nCODE     DS    0H\n         TM    4(#4),X'80'         If invalid module identifier\n         BNO   CODENAME             then...\n         LA    #4,NNCODE            point to unnamed-code-string\n         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE\n         B     STKPRIN              and go print it.\nCODENAME DS    0H                  Else...\n         XR    #15,#15\n         IC    #15,4(,#4)          Get length of module identifier\n         LTR   #15,#15             Reduce by length of date/time info\n         BNP   STKSKIP             If no name, skip\n         CH    #15,=Y(L'FUNTEXT)   If longer than maximum length we use\n         BNH   *+8                 then\n         LA    #15,L'FUNTEXT        use maximum length\n         STCM  #15,7,FUNLEN        Store length into fake string\n         BCTR  #15,0               Reduce for execute\n         EX    #15,MVCNAME         Move function name to our message\n         LA    #4,FUNSTR           Point to our fake string message\n         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE\n         B     STKPRIN\nSTKBOUND DS    0H                  Pointer back into stack found...\n         LA    #4,BOUNDSTR         Point to boundary string\n         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE\n         B     STKPRIN\nNOTCODE  DS    0H\n         OI    ZLCPFLGS,ZLCPSLSH   REQUEST SLASHIFICATION BE DONE\nSTKPRIN  DS    0H\n         L     #15,ZLCPRIN         Call ZILPRIN to print the object\n         #BASR #14,#15\n         L     #15,ZLCTERP         Call ZILTERP to TERPRI\n         #BASR #14,#15\nSTKSKIP  DS    0H\n         SH    #5,=H'4'            Bump down stack\n         B     STKLOOP             Continue\n         SPACE 1\nSTKEND   DS    0H\n         SPACE 1\n         NI    ZLCPFLGS,255-ZLCPSLSH REQUEST NO SLASHIFICATION BE DONE\n         LA    #4,TRCMSG2\n         L     #15,ZLCPRIN         Call ZILPRIN to print message\n         #BASR #14,#15\n         L     #15,ZLCTERP         Call ZILTERP to TERPRI\n         #BASR #14,#15\n         LM    #0,#2,SAVEARGS      Restore args to THROW\n         NI    ZLCERFLG,255-ZLCERTRC No more stack tracing\n         SPACE 1\nNOTRACE  DS    0H                  End tracing\n         SPACE 1\n         LR    #15,#12             BACK TO THE OLD BASE REGISTER\n         DROP  #12\n         USING ZILTHROW,#15\n*\n* NOW THAT WE KNOW WE HAVE A CATCH TO THROW TO, SCAN FOR UNWIND-PROTECT\n* FRAMES TO PROCESS CLEANUP FORMS.\n*\n* TO DO THIS, WE HAVE TO SCAN THE CHAIN OF CATCH FRAMES AGAIN (THE\n* FIRST SCAN WAS JUST TO MAKE SURE WE HAD A VALID TAG).  THIS IS OK\n* BECAUSE GUY STEELE, IN CLTL, SAID WE'D PROBABLY HAVE TO DO THIS IN\n* A VALID IMPLEMENTATION.\n*\n         L     #14,ZLCCATCH        START FROM THE BEGINNING AGAIN\nLOOP2    DS    0H\n         LTR   #14,#14             (THIS CAN'T HAPPEN)\n         BZ    CANTBE\n         ICM   #0,15,CATCHTAG      LOAD THE TAG\n         BZ    DOCLEAN             IF ZEROES, IT'S AN UNWIND-PROTECT\n         CR    #0,#1               IF THIS IS THE MATCHING TAG\n         BE    DOTHROW             THEN REALLY DO THE THROW NOW\n         L     #14,CATCHLNK        ELSE GET PREVIOUS CATCH FRAME\n         B     LOOP2               AND CONTINUE SCAN.\n         SPACE 1\nDOCLEAN  DS    0H                  EXECUTE UNWIND-PROTECT CLEANUP FORMS\n         SPACE 1\n         LA    #0,CLEANRET         SET WHERE TO RETURN AFTER CLEANUP\n         ST    #0,CATCHRET         IN RETURN ADDRESS SLOT OF FRAME\n         L     #0,CATCHSAL         GET SAVED SPECIAL ALIST\n         ST    #0,ZLCSALST         SET CURRENT SPECIAL ALIST THERETO\n         L     #0,CATCHFAL         GET SAVED FLUID ALIST\n         ST    #0,ZLCFALST         SET CURRENT FLUID ALIST THERETO\n         LM    #11,#12,CATCHS11    RESTORE STACK AND BASE REGS #11,#12\n         ST    #15,CATCHS12        SAVE OUR OWN BASE REG IN FRAME\n         DROP  #15                 (THIS INVALIDATES OUR BASE REG)\n         L     #15,CATCHCLN        GET ADDRESS OF CLEANUP FORMS CODE\n         STM   #1,#2,CATCHCLN      SAVE THROW'S ARGS IN FRAME\n         BR    #15                 BRANCH TO CLEANUP FORMS CODE\n         SPACE 1\nCLEANRET DS    0H                  RETURN HERE AFTER CLEANUP FORMS DONE\n*                                  (NOTE: #14 POINTS TO THE UWP FRAME)\n         L     #15,CATCHS12        RESTORE OUR OWN BASE REGISTER\n         USING ZILTHROW,#15        (LETS US HAVE A BASE AGAIN)\n         LM    #1,#2,CATCHCLN      RESTORE THROW'S ARGS\n         L     #14,ZLCCATCH        LOAD WHAT IS NOW CURRENT CATCH FRAME\n         B     LOOP2               CONTINUE SCAN THROUGH FRAMES\n         SPACE 1\nDOTHROW  DS    0H                  NOW ACTUALLY THROW TO THE CATCH\n*\n* TURN OFF REQUEST TO ABEND, BUT LEAVE THE USER CODE SO THAT FUTURE\n* FUNCTIONS MAY BE ABLE TO INTERROGATE IT.\n*\n         NI    ZLCERFLG,255-ZLCERSET  INDICATE NO ABEND TO BE DONE\n*\n* RESTORE THE ALISTS AND REGS 11 AND 12, AND\n* GO TO RETURN ADDRESS WITH RESULT VALUE IN REG 15\n*\n         L     #0,CATCHSAL         GET SAVED SPECIAL ALIST\n         ST    #0,ZLCSALST         RESTORE SPECIAL ALIST\n         L     #0,CATCHFAL         GET SAVED FLUID ALIST\n         ST    #0,ZLCFALST         RESTORE FLUID ALIST\n         LM    #11,#12,CATCHS11    RESTORE STACK AND BASE REGISTERS\n         L     #14,CATCHRET        GET RETURN ADDRESS (END OF CATCH)\n         DROP  #14\n         LR    #15,#2              SET RESULT VALUE\n         BR    #14                 GO TO RETURN POINT\n         SPACE 1\nNOCATCH  DS    0H                  NO CATCH FRAME FOUND...\n         CR    #1,#10              IF THROW TAG IS NIL,\n         BE    DISASTER            THEN THERE'S NO HOPE FOR RECOVERY.\n         LR    #3,#15\n         DROP  #15\n         USING ZILTHROW,#3\n         LR    #2,#1\n         #ERR  'ZIL1011 THROW: No catch active for tag - ',(#2),       X\n               PREFIX=NO\n         DROP  #3\n         SPACE 1\nDISASTER DS    0H                  THROW TO NIL, NO CATCH ACTIVE\n         SPACE 1\n         USING ZILTHROW,#15\n*\n* CANCEL ESTAE AND/OR STAX ENVIRONMENTS IF ANY.\n*\n         TM    ZLCEFLGS,ZLCESTAE   IF AN ESTAE WAS ACTIVE\n         BZ    NOESTAE             THEN\n         ESTAE 0                    CANCEL ABEND HANDLER\nNOESTAE  DS    0H\n         DROP  #15\n         #BASR #15,0\n         USING *,#15\n         TM    ZLCERFLG,ZLCERSET   IF A USER ABEND CODE WAS SET\n         BZ    ABEND000            THEN\n         LH    #1,ZLCABEND          GET USER ABEND CODE SET BY ZILERR\n         LTR   #1,#1                BUT MUST BE BETWEEN 1 AND 4095\n         BNP   ABEND000\n         CH    #1,=H'4095'\n         BNH   ABEND                OTHERWISE\nABEND000 XR    #1,#1                SET USER ABEND CODE = 0\nABEND    DS    0H\n         ABEND (1),DUMP            ABEND WITH RESULT AS USER CODE\n         SPACE 1\nCANTBE   DS    0H\n         EX    0,*                 FORCE 0C3 ABEND IF ERROR SCANNING\n         SPACE 1\n         DROP  #15\n         USING ZILTHROW,#12\nMVCNAME  MVC   FUNTEXT(*-*),5(#4)  Executed: Move function name to msg\n         SPACE 1\nSAVEARGS DS    3A\nSAVE12   DS    A\nFUNSTR   DC    YL1(##STRING)\nFUNLEN   DC    AL3(0)\nFUNTEXT  DS    CL64\nNNCODE   DC    YL1(##STRING)\n         DC    AL3(L'NNTEXT)\nNNTEXT   DC    C'#<NAMELESS ZIL CODE>'\nBOUNDSTR DC    YL1(##STRING)\n         DC    AL3(L'BOUNDTXT)\nBOUNDTXT DC    C';-------<STACK BOUNDARY>-------'\nTRCMSG1  #SATM 'ZIL1600 BACK TRACE OF PUSH DOWN STACK FOLLOWS.'\nTRCMSG2  #SATM 'ZIL1601 END OF STACK TRACE.'\n         SPACE 1\n         LTORG\n         EJECT\nCATCH    DSECT ,                   THIS MAPS THE CATCH FRAME\n         SPACE 1\nCATCHLNK DS    A                   +00 ADDRESS OF PREVIOUS CATCH FRAME\nCATCHS11 DS    A                   +04 ADDRESS OF STACK (SAVED #11)\nCATCHS12 DS    A                   +08 BASE REGISTER (SAVED #12)\nCATCHRET DS    A                   +0C RETURN ADDRESS AFTER FORMS\nCATCHSAL DS    A                   +10 ADDRESS OF SAVED SPECIAL ALIST\nCATCHFAL DS    A                   +14 ADDRESS OF SAVED FLUID ALIST\nCATCHTAG DS    A                   +18 THE CATCH TAG (0 FOR UWP)\nCATCHCLN DS    A                   +1C ADDRESS OF CLEANUP FORMS CODE\nCATCHVAL DS    A                   +20 RETURN VALUE SAVED DURING CLNUP\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILTPUT": {"ttr": 16899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00H\\x00\\x88\\x01_\\x01\\x00&_\\x17$\\x00z\\x00q\\x00y\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:24:48", "lines": 122, "newlines": 113, "modlines": 121, "user": "SEB1525"}, "text": "         TITLE 'ZILTPUT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS FUNCTION IS CALLED BY ZIL ASSEMBLER LANGUAGE PROGRAMS WHICH   *\n*  WISH TO WRITE SOMETHING TO THE TERMINAL.                           *\n*                                                                     *\n*  REGISTER 1 CONTAINS THE ADDRESS OF THE DATA TO BE WRITTEN.         *\n*  REGISTER 0 CONTAINS THE LENGTH OF THE DATA TO BE WRITTEN.          *\n*                                                                     *\n*  IT IS ASSUMED THAT THE LENGTH IS 256 BYTES OR LESS.                *\n*                                                                     *\n*  IF REGISTER 0 IS NEGATIVE, THEN THE DATA IS TO BE SENT VIA         *\n*  TPUT ASIS; OTHERWISE TPUT EDIT IS TO BE USED.                      *\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO STACK SPACE.              *\n*                                                                     *\n***********************************************************************\n         GBLB  &ZILXA\n         #ZSYS\n         SPACE 1\nZILTPUT  #ZBEG NAME='ZILTPUT'\n         SPACE 1\n         STM   #14,#12,TPUTSAVE    SAVE ALL REGISTERS\n         LR    #12,#15             ESTABLISH BASE REGISTER\n         DROP  #15\n         USING ZILTPUT,#12\n         SPACE 1\n         LTR   #0,#0               TEST LENGTH VALUE\n         BZ    RETURN              IF ZERO, DO NOTHING\n         BP    DOTPUT              IF POSITIVE, DO TPUT EDIT\n         LPR   #3,#0               IF NEGATIVE, MAKE IT POSITIVE\n         LR    #4,#1               SAVE ADDRESS\n         TPUT  (#4),(#3),ASIS      DO TPUT ASIS (WITHOUT NEWLINE)\n         B     DRIBBLE             GO TO DO DRIBBLE IF REQUIRED\n         SPACE 1\nDOTPUT   DS    0H\n         LR    #3,#0               SAVE LENGTH\n         LR    #4,#1               SAVE ADDRESS\n         TPUT  (1),(0),R           ISSUE TPUT SVC\n         B     DRIBBLE             GO TO DO DRIBBLE IF REQUIRED\n         EJECT\nDRIBBLE  DS    0H\n         SPACE 1\n         ICM   #2,15,ZLCDRIBL      GET ADDRESS OF DRIBBLE DCB\n         BZ    RETURN              IF NO DRIBBLE DCB IS OPEN, SKIP IT\n         LH    #6,82(,#2)          GET DCB LRECL\n*                                  CHECK FOR NEWLINE AT END OF TEXT\n*                                  AND REMOVE IT IF THERE IS ONE\n         LTR   #3,#3               (SKIP IF LENGTH IS ZERO)\n         BZ    PUTIT\n         LA    #15,0(#4,#3)        POINT TO LAST CHARACTER OF LINE\n         BCTR  #15,0\n         CLI   0(#15),X'15'        IF LAST CHARACTER IS A NEWLINE\n         BNE   PUTIT               THEN\n         BCTR  #3,0                 DROP IT FROM DRIBBLE FILE\nPUTIT    DS    0H\n         AIF   (NOT &ZILXA).SKIP1\n*---------------------------------SWITCH FROM CURRENT AMODE TO AMODE 24\n         LA    #1,CODE24           ADDRESS OF THIS CODE\n         LA    #2,CODE24E          RETURN ADDRESS\n         BSM   #2,#1\nCODE24   DS    0H\n*---------------------------------THE AMODE IS NOW 24\n.SKIP1   ANOP\n         ST    #9,ZLCISV09         SAVE ZIL REGS\n         OI    ZLCIFLGS,ZLCISYS    SET NON-ZIL CODE RUNNING IND ON\n         L     #1,ZLCDRIBL         GET DRIBBLE DCB ADDRESS\n         PUT   (1)                 DO PUT LOCATE\n         NI    ZLCIFLGS,255-ZLCISYS\n         AIF   (NOT &ZILXA).SKIP2\n*---------------------------------SWITCH FROM AMODE 24 TO CURRENT AMODE\n         BSM   0,#2\nCODE24E  DS    0H\n*---------------------------------THE AMODE IS NOW SAME AS ON ENTRY\n.SKIP2   ANOP\n         TM    ZLCIFLGS,ZLCIATTN    IF ATTENTION INTERRUPT OCCURRED\n         BOR   #13                  THEN GO TO HANDLE IT\n         LR    #2,#1               SAVE ADDRESS OF NEXT OUTPUT RECORD\n         LA    #15,X'40'           SOURCE LENGTH = 0\n         SLL   #15,24              FILL = BLANK\n         OR    #15,#3              SOURCE LENGTH = FILL | OUTPUT LEN\n         LR    #14,#4              SOURCE ADDRESS = ERROR MESSAGE\n         LR    #0,#2               TARGET ADDRESS = OUTPUT AREA\n         LR    #1,#6               TARGET LENGTH = DRIBBLE LRECL\n         MVCL  #0,#14              MOVE THE MESSAGE TO DRIBBLE LINE\n         LTR   #1,#3               GET LENGTH OF LINE JUST MOVED\n         BNP   NOTRANS             IF ZERO, SKIP TRANSLATE\n         BCTR  #1,0                ELSE REDUCE FOR EXECUTE\n         EX    #1,TRDRIB           TRANSLATE TO REASONABLE CHARACTERS\nNOTRANS  DS    0H\n         AR    #4,#6               BUMP SOURCE POINTER\n         SR    #3,#6               REDUCE LENGTH\n         BP    PUTIT               CONTINUE WHILE STUFF TO MOVE\nRETURN   DS    0H\n         LM    #14,#12,TPUTSAVE    RELOAD REGISTERS\n         BR    #14                 RETURN\n         SPACE 1\nTRDRIB   TR    0(*-*,#2),TRDRIBTB  TRANSLATE DRIBBLED OUTPUT\n         SPACE 1\nTPUTSAVE DS    9D                  SAVE AREA\n         SPACE 1\nTRDRIBTB DC    256YL1(*-TRDRIBTB)  TRANSLATE TABLE FOR DRIBBLED OUTPUT\n         ORG   TRDRIBTB+X'00'      CHANGE NULLS BACK TO BLANKS\n         DC    X'40'\n         ORG   TRDRIBTB+X'41'      RESTORE LEFT BRACKETS\n         DC    X'AD'\n         ORG   TRDRIBTB+X'42'      RESTORE RIGHT BRACKETS\n         DC    X'BD'\n         ORG   TRDRIBTB+X'BA'      RESTORE LEFT BRACKETS\n         DC    X'AD'\n         ORG   TRDRIBTB+X'BB'      RESTORE RIGHT BRACKETS\n         DC    X'BD'\n         ORG   ,\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILUNBND": {"ttr": 16902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11T\\x00&\\x00#\\x00%\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 38, "newlines": 35, "modlines": 37, "user": "SEB1525"}, "text": "         TITLE 'ZILUNBND - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZILUNBND TAKES NO ARGUMENTS.                                        *\n*                                                                     *\n* THIS FUNCTION RETURNS THE OBJECT \"ZLCUNBND\", A SPECIAL ENTITY THAT  *\n* REPRESENTS AN \"UNBOUND\" VARIABLE VALUE.\n*                                                                     *\n* MAKUNBOUND INSERTS THIS VALUE INTO THE CDR OF A BINDING CELL.       *\n* ZEVSYM CHECKS FOR THIS VALUE AND RETURNS NIL INSTEAD OF A BINDING   *\n* THAT CONTAINS THIS VALUE.                                           *\n* COMPILED CODE HAS BUILT-IN REFERENCES TO THIS OBJECT.               *\n*                                                                     *\n* AN ATTEMPT TO PRINT THIS OBJECT WILL BE DISASTROUS.                 *\n*                                                                     *\n* THIS MODULE USES NO STACK SPACE AND SAVES NO REGISTERS.             *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note:  Presumably this will be obsoleted by shallow binding.        *\n*        A shallow binding implementation will set the value cell of  *\n*        a symbol to a different \"unbound\" marker, which has the      *\n*        high-order bit turned on to facilitate compiled code checks. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILUNBND #ZBEG MINARGS=0,MAXARGS=0,NAME='ZILUNBND'\n         SPACE 1\n         L     #15,ZLCUNBND        GET ADDRESS OF THE \"UNBOUND\" OBJECT\n         BR    #14                 RETURN\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILVALS": {"ttr": 16904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\t\\x00\\x88\\x15?\\x01\\x00&_\\x17%\\x04\\xa8\\x04\\x9e\\x04\\xa7\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1988-06-01T00:00:00", "modifydate": "2000-09-21T17:25:09", "lines": 1192, "newlines": 1182, "modlines": 1191, "user": "SEB1525"}, "text": "         TITLE 'ZILVALS - ZIL 1.3 returner of multiple values'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This routine, linked with ZILSUBS, performs all returning of        *\n* multiple values for ZIL.                                            *\n*                                                                     *\n* The LISP VALUES function will compile into a call to this routine   *\n* with the appropriate settings in the appropriate registers.         *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* On entry to this routine:                                           *\n*                                                                     *\n* =================================================================== *\n*                                                                     *\n* #0 zero:  scan environment to see if multiple values are being      *\n*           requested and return them in the desired format.          *\n*                                                                     *\n* #0 negative: scan environment to see if multiple values are being   *\n*              requested; return the number of values requested in    *\n*              #2 (or -1 if a list of values is requested) and the    *\n*              stack address of the returned values (or list) in #0.  *\n*                                                                     *\n* #0 positive: return the values using the stack address, which is    *\n*              the positive value in #0, and the number of arguments  *\n*              in #2 (-1 if a list of values is requested).           *\n*                                                                     *\n* =================================================================== *\n*                                                                     *\n* #1 - when #0 is zero, points to the stack location where the values *\n*      passed to this routine are stored in successive stack slots.   *\n*                                                                     *\n*      when #0 is negative, irrelevant.                               *\n*                                                                     *\n*      when #0 is positive, the current stack address (for CONSing).  *\n*                                                                     *\n* =================================================================== *\n*                                                                     *\n* #2 - when #0 is zero, contains the number of values stored on the   *\n*      stack passed to this routine.  If -1, the stack slot points    *\n*      to a list of values.                                           *\n*                                                                     *\n*      when #0 is negative, irrelevant.                               *\n*                                                                     *\n*      when #0 is positive, the number of multiple values required    *\n*      (-1 if a list of values must be built).                        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* This routine is invoked from compiled code by:                      *\n* (VALUES ...)    - #0 = zero                                         *\n*                   #1 -> stack location of arguments to VALUES       *\n*                   #2 = number of arguments specified to VALUES      *\n*                                                                     *\n* (VALUES-LIST x) - #0 = zero                                         *\n*                   #1 -> stack location of list argument             *\n*                   #2 = -1                                           *\n*                                                                     *\n* (Note: VALUES-LIST might not be specially handled by the compiler,  *\n*        but might be a function that invokes ZILVALS with the above) *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Multiple values are requested by the following special forms, which *\n* MUST be handled specially by the compiler:                          *\n*                                                                     *\n* (MULTIPLE-VALUE-LIST (form))                                        *\n*                                                                     *\n* (MULTIPLE-VALUE-BIND (arglist) (form) . forms)                      *\n*                                                                     *\n* Note that these are macros in Common LISP.  The only special form   *\n* in Common LISP for requesting multiple values is                    *\n* MULTIPLE-VALUE-CALL, which must be implemented in ZIL as a macro.   *\n*                                                                     *\n* The code sequence for (MULTIPLE-VALUE-LIST (form)) is:              *\n*                                                                     *\n*          ST    #11,xxx(,#11)       Store junk pointer in stack loc. *\n*          ...   ... code to execute (form) ...                       *\n*          ...   ... which returns something in #15 ...               *\n*          ...   ... possible base register loadings here ...         *\n*          C     #11,xxx(,#11)       If multiple values returned,     *\n*          BE    G00001              then...                          *\n*          L     #15,xxx(,#11)        load pointer to list of values  *\n*          B     G00002              else...                          *\n* G00001   DS    0H                  No multiple values returned      *\n*          LR    #1,#15              Return value = arg 1 to CONS     *\n*          L     #15,ZLCCONS         Get address of ZILCONS           *\n*          LR    #2,#10              NIL = arg 2 to CONS              *\n*          BALR  #14,#15             Call ZILCONS for list of 1 value *\n* G00002   DS    0H                  No multiple values returned      *\n*                                                                     *\n* The code sequence for (MULTIPLE-VALUE-BIND (a b c) (form) ...) is:  *\n*                                                                     *\n*          ST    #11,xxx+0(,#11)     Store junk pointer in stack loc. *\n*          ...   ... code to execute (form) ...                       *\n*          ...   ... which returns something in #15 ...               *\n*          BC    0,3(#11,0)          NOP (470B) with # of arguments   *\n*          C     #11,xxx(,#11)       If multiple values returned,     *\n*          BNE   G00001              then do nothing, values set      *\n*          ST    #15,xxx+0(,#11)     else set var A to only value     *\n*          ST    #10,xxx+4(,#11)     set variable B to NIL            *\n*          ST    #10,xxx+8(,#11)     set variable C to NIL            *\n* G00001   DS    0H                                                   *\n*                                                                     *\n* The NOP and the compare to #11 are extremely important, because     *\n* they are signals to ZILVALS that multiple values are being          *\n* requested.  ZILVALS (this routine) determines if multiple values    *\n* are needed by inspecting the instruction flow, starting with the    *\n* return address in #14, to see if:                                   *\n*                                                                     *\n* (1) multiple values are requested by the presence of the special    *\n*     NOP (470B....) or C (59B0....) instruction generated by one     *\n*     of the multiple-value-requesting special forms.                 *\n*                                                                     *\n* (2) a single value is requested (i.e. normal operation) by the      *\n*     presence of instructions that use or reset the contents of #15. *\n*                                                                     *\n* (3) an instruction occurs that signals passing of control to        *\n*     another function (e.g. BALR) or outside of LISP (e.g. SVC).     *\n*                                                                     *\n* Only in case (1) is the processing of multiple values done.         *\n* The instruction flow scanning needs to track the values of the      *\n* ZIL registers #11, #12, and #14 as it goes.  If a call to VALUES,   *\n* for example, is in tail-recursive position, it will be followed     *\n* (not necessarily immediately, since ALIST restores or the like      *\n* may occur) by the code sequence                                     *\n*                                                                     *\n*          LR    1,11                                                 *\n*          LM    11,12,...(1)                                         *\n*          L     14,...(1)                                            *\n*          BR    14                                                   *\n*                                                                     *\n* which is the standard ZIL return sequence from compiled code.       *\n* When this is found, the new values of #11,#12 and #14 must be       *\n* taken from the stack and instruction scanning resumed until one     *\n* of the three cases above is encountered.                            *\n*                                                                     *\n* Branch instructions must be followed as well.  This means that      *\n* base registers must be determined if necessary, as follows:         *\n*                                                                     *\n* #12, the primary base register, must be known at the time.          *\n*                                                                     *\n* #7, if used, is either #12+4095 or #12+4096.  Which it is may       *\n* be determined based on whether the displacement is odd or even.     *\n*                                                                     *\n* #6, if used, is #12+(2*4096).                                       *\n* #5, if used, is #12+(3*4096).                                       *\n* #4, if used, is #12+(4*4096).                                       *\n*                                                                     *\n* Backward branches are NOT followed.                                 *\n*                                                                     *\n* The NOP branch (4700) is a signal used by UNWIND-PROTECT.  When     *\n* this is seen, the NOP branching path is followed, and must take     *\n* you to an instruction that loads a register from the stack.  If     *\n* the register is 15, multiple values are possible (this is one of    *\n* the only cases where a load of 15 does not rule out multiple        *\n* values); if a different register is loaded, the value is not        *\n* being returned and therefore multiple values are irrelevant.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILVALS  CSECT\n         SPACE 1\n         USING ZILVALS,#15\n         #ZUSING ,\n         SPACE 1\n*\n* Dispatch based on the contents of #0.\n* Zero ------- normal call for VALUES:  scan and return values\n* Negative --- scan only, return MV info\n* Positive --- return values only, using info from previous scan call\n*\n         LTR   #0,#0\n         BZ    NORMAL\n         BM    ONLYSCAN\n         BP    ONLYRET\n         EJECT\nNORMAL   DS    0H                  Normal call for VALUES\nONLYSCAN DS    0H                  Scan environment for requestor\n         SPACE 1\n***********************************************************************\n*\n* Register usage:\n*\n* #0 --- entry code (zero, negative or positive)\n* #1 --- volatile (destroyed by TRT)\n* #2 --- volatile (destroyed by TRT)\n* #3 --- VALUES stack pointer    (#1)\n* #4 --- VALUES number of values (#2)\n* #5 --- track stack pointer    (#11)\n* #6 --- track base register    (#12)\n* #7 --- track return address   (#14)\n* #14 -- ZILVALS return address. Be careful!!!\n* #15 -- ZILVALS base register.  Be careful!!!\n*\n***********************************************************************\n         SPACE 1\n*\n* Save the input parameter registers (1,2).\n*\n         LR    #3,#1               Pointer to values on stack\n         LR    #4,#2               Number of values on stack\n*\n* Save the contents of the three important registers (11, 12, 14)\n* at entry to ZILVALS.\n*\n         LR    #5,#11              Caller's stack pointer\n         LR    #6,#12              Caller's code base register\n         LR    #7,#14              Caller's return address\n         SPACE 1\nCONTINUE DS    0H\n         SPACE 1\n         XR    #2,#2               Clear TRT flag register\n         SPACE 1\nOPLOOP   DS    0H\n*\n* Check the opcode pointed to by #7 to see where we're going.\n*\n         TRT   0(1,#7),INSTRTBL    Test the instruction opcode\n         BNZ   GO(#2)              Branch depending on opcode\nGO       B     NO                  #2=0, bad or unusual opcode, no MV's\n         B     MBMV47              #2=4\n         B     MBMV59              #2=8\n         B     MBMV18              #2=12\n         B     MBBALR              #2=16\n         B     MBBCR               #2=20\n         B     MBSVC               #2=24\n         B     MBRR                #2=28\n         B     BUMP2               #2=32\n         B     MBRX                #2=36\n         B     MBSTMLM             #2=40\n         B     MBSI                #2=44\n         B     MBMASK              #2=48\n         B     MBSS                #2=52\n         SPACE 1\nTRTNO    EQU   0\nTRTMV47  EQU   4\nTRTMV59  EQU   8\nTRTMV18  EQU   12\nTRTBALR  EQU   16\nTRTBCR   EQU   20\nTRTSVC   EQU   24\nTRTRR    EQU   28\nTRTBUMP2 EQU   32\nTRTRX    EQU   36\nTRTSTMLM EQU   40\nTRTSI    EQU   44\nTRTMASK  EQU   48\nTRTSS    EQU   52\n         SPACE 1\nINSTRTBL DS    0X                  Table of instruction op codes\n*\n* Most opcodes are undefined or unusual, so they fall into the \"nope,\n* no multiple values being returned from here\" category.  Also, to\n* keep things simple, any instruction that potentially references\n* register 15 implicitly (other than STM and LM) is considered to fall\n* into this category.  In other words, instructions like MVCL, SRDL,\n* M, DR, BXLE are not expected to occur in compiled code, so if they\n* should occur, they will stop the return of multiple values.\n* Instructions that give control temporarily to other code (EX, BAL)\n* for the most part fall into the same category.\n*\n         DC    256YL1(TRTNO)\n         ORG   INSTRTBL+X'05'      BALR\n         DC    1YL1(TRTBALR)\n         ORG   INSTRTBL+X'06'      BCTR\n         DC    1YL1(TRTBALR)\n         ORG   INSTRTBL+X'07'      BCR\n         DC    1YL1(TRTBCR)\n         ORG   INSTRTBL+X'0A'      SVC\n         DC    1YL1(TRTSVC)\n         ORG   INSTRTBL+X'0B'      BSM\n         DC    1YL1(TRTNO)\n         ORG   INSTRTBL+X'0C'      BASSM\n         DC    1YL1(TRTNO)\n         ORG   INSTRTBL+X'0D'      BASR\n         DC    1YL1(TRTBALR)\n         ORG   INSTRTBL+X'10' -17  LPR,LNR,LTR,LCR,NR,CLR,OR,XR\n         DC    8YL1(TRTRR)\n         ORG   INSTRTBL+X'18'      LR\n         DC    1YL1(TRTMV18)\n         ORG   INSTRTBL+X'19' -1B  CR,AR,SR\n         DC    3YL1(TRTRR)\n         ORG   INSTRTBL+X'1E' -1F  ALR,SLR\n         DC    2YL1(TRTRR)\n         ORG   INSTRTBL+X'20' -3F  Floating-point RR instructions\n         DC    32YL1(TRTBUMP2)\n         ORG   INSTRTBL+X'40' -43  STH,LA,STC,IC\n         DC    4YL1(TRTRX)\n         ORG   INSTRTBL+X'46'      BCT\n         DC    1YL1(TRTRX)\n         ORG   INSTRTBL+X'47'      BC\n         DC    1YL1(TRTMV47)\n         ORG   INSTRTBL+X'48' -4C  LH,CH,AH,SH,MH\n         DC    5YL1(TRTRX)\n         ORG   INSTRTBL+X'4E' -50  CVD,CVB,ST\n         DC    3YL1(TRTRX)\n         ORG   INSTRTBL+X'54' -58  N,CL,O,X,L\n         DC    5YL1(TRTRX)\n         ORG   INSTRTBL+X'59'      C\n         DC    1YL1(TRTMV59)\n         ORG   INSTRTBL+X'5A' -5B  A,S\n         DC    2YL1(TRTRX)\n         ORG   INSTRTBL+X'5E' -5F  AL,SL\n         DC    2YL1(TRTRX)\n         ORG   INSTRTBL+X'60'      STD\n         DC    1YL1(TRTRX)\n         ORG   INSTRTBL+X'67' -70  More floating-point\n         DC    10YL1(TRTRX)\n         ORG   INSTRTBL+X'78' -7F  More floating-point\n         DC    8YL1(TRTRX)\n         ORG   INSTRTBL+X'88' -8B  SRL,SLL,SRA,SLA\n         DC    4YL1(TRTRX)\n         ORG   INSTRTBL+X'90'      STM\n         DC    1YL1(TRTSTMLM)\n         ORG   INSTRTBL+X'91' -92  TM,MVI\n         DC    2YL1(TRTSI)\n         ORG   INSTRTBL+X'94' -97  NI,CLI,OI,XI\n         DC    4YL1(TRTSI)\n         ORG   INSTRTBL+X'98'      LM\n         DC    1YL1(TRTSTMLM)\n         ORG   INSTRTBL+X'BD'      CLM,STCM,ICM\n         DC    3YL1(TRTMASK)\n         ORG   INSTRTBL+X'D1' -D7  MVN,MVC,MVZ,NC,CLC,OC,XC\n         DC    7YL1(TRTSS)\n         ORG   INSTRTBL+X'DC' -DF  TR,TRT,ED,EDMK\n         DC    4YL1(TRTSS)\n         ORG   INSTRTBL+X'F0' -F3  SRP,MVO,PACK,UNPK\n         DC    4YL1(TRTSS)\n         ORG   INSTRTBL+X'F8' -FD  ZAP,CP,AP,SP,MP,DP\n         DC    6YL1(TRTSS)\n         ORG\n         EJECT\nMBMV47   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is:                                                          *\n*                                                                     *\n*        X'47' BC                                                     *\n*                                                                     *\n* Format:      opcd c1 i2 b2 d2d2d2                                   *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  This may be one of the multiple value sentinels:                   *\n*                                                                     *\n*     4700x...                                                        *\n*     470B....                                                        *\n*                                                                     *\n*  If it is, go to handle that case specifically.                     *\n*                                                                     *\n*  If it is 47F0...., then we must follow the branch, unless it       *\n*  goes backward, in which case no MV's are returned.                 *\n*                                                                     *\n*  Otherwise, it's a conditional branch, so no MV's are returned.     *\n*                                                                     *\n*  Note that 47Fx where x is nonzero is a computed branch, so we      *\n*  treat that the same wrt no MV's.  We assume that 47Fx0yyy will     *\n*  not occur in compiled code.                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   1(#7),X'F0'         If it's 47F0....\n         BE    MBBRANCH            then go to follow branch\n         CLI   1(#7),X'00'         If it's NOP (4700....)\n         BE    MBBRANCH            then go to handle NOP\n         CLI   1(#7),X'0B'         If it's 470B....\n         BE    MB470B              then go to handle 470B\n         B     NO                  else answer is no\n         SPACE 1\nMB470B   DS    0H                  470B.... - MULTIPLE-VALUE-BIND\n*\n***********************************************************************\n*                                                                     *\n* 470B.... is part of the generated code for MULTIPLE-VALUE-BIND or   *\n* THROW.  If it's 470B,8000, then it's THROW; otherwise M.V.BIND.     *\n*                                                                     *\n* If #0 is negative, return information only.                         *\n* If #0 is zero, store the multiple values here.                      *\n* If #0 is positive - well, that will never get here.                 *\n*                                                                     *\n***********************************************************************\n*\n         LH    #2,2(,#7)           Load number of values from 470Bxxxx\n         LTR   #2,#2               If negative (470B8000),\n         BM    MBTHROW             then go to process THROW\n         LTR   #0,#0               If #0 is negative\n         BM    MVBINFO             then go to return info only\n*\n* The instruction following the 470B.... should be 59B0Bxxx, where\n* Bxxx is the location of the stack slots where the values are to go.\n*\n         LH    #0,6(,#7)           Get Bxxx from 59B0Bxxx instruction\n         N     #0,=X'00000FFF'     Isolate displacement\n         AR    #5,#0               Add displ. to tracked stack address\nMB47VALS DS    0H\n*\n* In the degenerate case of MULTIPLE-VALUE-BIND with a null list of\n* variables to be assigned values, we will return info that zero\n* values are being requested, but will return a single value as if\n* it was a non-multiple-value-returning situation.\n*\n         LTR   #2,#2               If # of requested values is zero\n         BZ    DONOVALS            then return immediate value only\n         LTR   #1,#4               Get number of values being returned\n         BNZ   MVBPUTS             If no values being returned (VALUES)\n         ST    #10,0(,#5)          then store NIL into first value slot\n         LA    #5,4(,#5)            bump to next value slot\n         BCT   #2,MVBNILS           go put NILs in rest of slots if any\n         B     DONOVALS             and then go to return immed. value\nMVBPUTS  DS    0H                  Else one or more values to return\n         LR    #7,#3               Get pointer to values being passed\nMVBPUT   DS    0H                  Loop storing values\n         MVC   0(4,#5),0(#7)       Move value to requesting stack slot\n         BCTR  #2,0                Decrement requested value count\n         LTR   #2,#2               If no more value slots to fill\n         BZ    DONOVALS            then through, go return immed. value\n         LA    #5,4(,#5)           Bump requesting stack slot\n         LA    #7,4(,#7)           Bump passed stack slot\n         BCT   #1,MVBPUT           Decrement passed value count & loop\n******** B     MVBNILS             When all values passed...\nMVBNILS  DS    0H                  Fill unpassed slots with NIL\n         ST    #10,0(,#5)          Store NIL into requesting slot\n         LA    #5,4(,#5)           Bump requesting-slot pointer\n         BCT   #2,MVBNILS          Loop until requestor count exhausted\n         B     DONOVALS            Then go to return immediate value\n         SPACE 1\nMVBINFO  DS    0H                  Return info for MULTIPLE-VALUE-BIND\n         SPACE 1\n*\n* Put stack pointer of values slots in #0, number of values in #2\n*\n* The instruction following the 470B.... should be 59B0Bxxx, where\n* Bxxx is the location of the stack slots where the values are to go.\n*\n         LH    #0,6(,#7)           Get Bxxx from 59B0Bxxx instruction\n         N     #0,=X'00000FFF'     Isolate displacement\n         AR    #0,#5               Add displ. to tracked stack address\n         BR    #14                 Return to caller with info\n         SPACE 1\nMBTHROW  DS    0H                  470B8000 (THROW)\n*\n***********************************************************************\n*                                                                     *\n* When we see that we've hit a THROW, as generated by the compiler    *\n* (this is why THROW has to be a special form), we must find out      *\n* where we're throwing to and keep on tracking.  To do this, we must  *\n* examine the THROW tag and chase the chain of CATCH frames to see    *\n* where we come out.  The tracked stack, base and return registers    *\n* must be \"restored\" in the same way as they would be when the        *\n* THROW is really executed.  To do this, we duplicate the search      *\n* for the THROW tag.  If the tag is not found (which will cause an    *\n* error to be signalled later on), we just come back as if no         *\n* values are being requested.                                         *\n*                                                                     *\n* Is the tag available at run time?  Sure is at this point, because   *\n* the only way we could have gotten this far is in the case of        *\n* (THROW tag (multiple-value-returning-form)), at which point the     *\n* tag has already been evaluated, as you can see.                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* The code sequence for THROW looks something like this:              *\n*                                                                     *\n*   --- evaluate tag and store into xxx(,#11) ---                     *\n*   --- evaluate possible-multiple-value-returning-form ---           *\n*   --- result from above set up to go into #15 ---                   *\n*        BC    0,0(11,8)     470B8000 NOP to signify THROW            *\n*        L     #1,xxx(,#11)  5810Bxxx Load tag into #1                *\n*        LR    #2,#15        182F     Load return value into #2       *\n*        L     #15,ZLCTHROW           Get address of ZILTHROW         *\n*        BR    #15                    Go to ZILTHROW                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* #7 -> 470B8000,5810Bxxx\n*\n         LH    #1,6(,#7)           Get B2D2 of stack location of tag\n         N     #1,=X'00000FFF'     Isolate displacement\n         L     #1,0(#1,#5)         Load tag from stack location\n         L     #2,ZLCCATCH         Get pointer to current catch frame\nTAGLOOP  DS    0H\n         LTR   #2,#2               If no more catch frames are active\n         BZ    NO                  then tag not found, assume no MV's\n         USING CATCH,#2\n         C     #1,CATCHTAG         If tag matches\n         BE    GOTCATCH            then we found the catch to process\n         L     #2,CATCHLNK         Else get previous catch frame\n         B     TAGLOOP             and continue.\nGOTCATCH DS    0H                  We have the catch frame...\n         LM    #5,#6,CATCHS11      \"Restore\" tracked stack and base reg\n         L     #7,CATCHRET         \"Restore\" tracked return address\n         B     CONTINUE            Continue scanning for MV's\n         SPACE 1\nMBBRANCH DS    0H                  4700 or 47F0\n         SPACE 1\n*                                  First determine the base register.\n*                                  Assert #2 = X'000000xx'\n         IC    #2,2(,#7)           Get b2xx into low-order byte\n         SRL   #2,4                Set to base register number\n         LR    #1,#6               Load tracked base register\n         CH    #2,#SFT+8*12+6      If base register = 12\n         BE    BBUPDATE            then OK, use base as is\n         CH    #2,#SFT+8*7+6       If base register = 7\n         BE    BB7                 then set base\n         CH    #2,#SFT+8*6+6       If base register = 6\n         BE    BB6                 then set base\n         CH    #2,#SFT+8*5+6       If base register = 5\n         BE    BB5                 then set base\n         CH    #2,#SFT+8*4+6       If base register = 4\n         BE    BB4                 then set base\n         B     NO                  Else branch to unknown, answer = no\n         SPACE 1\nBB7      DS    0H                  Branch to somewhere off register 7\n         SPACE 1\n         LA    #1,4095(,#1)        Assume using 12-base plus 4095\n         STC   #1,ZLCDBL           Store low-order byte\n         TM    ZLCDBL,X'01'        If resulting address is odd\n         BNO   BBUPDATE            then\n         LA    #1,1(,#1)            it's really 12-base plus 4096\n         B     BBUPDATE            Go extract address\n         SPACE 1\nBB6      DS    0H                  Branch to somewhere off register 6\n         SPACE 1\n         AH    #1,=Y(2*4096)       Assume using 12-base plus 2*4K\n         B     BBUPDATE            Go extract address\n         SPACE 1\nBB5      DS    0H                  Branch to somewhere off register 5\n         SPACE 1\n         AH    #1,=Y(3*4096)       Assume using 12-base plus 3*4K\n         B     BBUPDATE            Go extract address\n         SPACE 1\nBB4      DS    0H                  Branch to somewhere off register 4\n         SPACE 1\n         AH    #1,=Y(4*4096)       Assume using 12-base plus 4*4K\n         B     BBUPDATE            Go extract address\n         SPACE 1\nBBUPDATE DS    0H                  #1 is the base address\n*\n* Update the code register, check it, and follow the code.\n*\n         SPACE 1\n         LH    #2,2(,#7)           Get b2d2 of BC (Cxxx)\n         N     #2,=X'00000FFF'     Isolate displacement\n         AR    #2,#1               Get new code address\n         CR    #2,#7               If address not after tracked address\n         BNH   NO                  then backward branch, answer is no\n*\n* A valid forward branch.  Now we either continue, if it was 47F0,\n* or follow through with UNWIND-PROTECT check, if it was 4700.\n*\n         CLI   1(#7),X'00'         If it was 4700\n         BE    UWPCHECK            then check UWP\n         LR    #7,#2               Else load new code tracking address\n         B     CONTINUE            Continue from new address\n         SPACE 1\nUWPCHECK DS    0H                  #2 -> instruction following cleanup\n*\n* The instruction following the cleanup form is expected to be a load\n* of register 15 from the stack, if multiple values are possible.\n* If it is anything else, values are not being returned from the\n* protected form.  Note that this is an unusual case in that the load\n* of #15 indicates MAYBE rather than NO!\n*\n         CLI   0(#2),X'58'         If not a LOAD of 15,\n         BNE   NO                  then answer is NO\n         TM    1(#2),X'F0'\n         BNO   NO\n         LA    #7,4(,#2)           Else continue with instr. past LOAD\n         B     CONTINUE            Continue from new address\n         SPACE 1\n         EJECT\nMBMV59   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is:                                                          *\n*                                                                     *\n*        X'59' C                                                      *\n*                                                                     *\n* Format:      opcd r1 i2 b2 d2d2d2                                   *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  This may be one of the multiple value sentinels:                   *\n*                                                                     *\n*     59B0....                                                        *\n*                                                                     *\n*  If it is, go to handle that case specifically.                     *\n*                                                                     *\n*  Otherwise, treat like a normal RX instruction.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   1(#7),X'B0'         If it's 59B0....\n******** BE    MB59B0              then go to handle 59B0\n         BNE   MBRX                else handle like normal RX instr\n         SPACE 1\nMB59B0   DS    0H                  59B0.... - MULTIPLE-VALUE-LIST\n*\n***********************************************************************\n*                                                                     *\n* 59B0Bxxx indicates that a list of all the passed values must be     *\n* consed up.                                                          *\n* Bxxx is the location of the stack slot where the list is to go.     *\n*                                                                     *\n***********************************************************************\n*\n         LTR   #0,#0               If #0 is negative\n         BNM   MB59NI              then (return info only)\n         LH    #0,2(,#7)            get Bxxx from 59B0Bxxx instruction\n         N     #0,=X'00000FFF'      isolate displacement\n         L     #2,#SFWM1            set #2 to -1\n         BR    #14                  and return with info\nMB59NI   DS    0H                  Else actually set the values\n         LH    #1,2(,#7)           Get Bxxx from 59B0Bxxx instruction\n         N     #1,=X'00000FFF'     Isolate displacement\n         AR    #5,#1               Add displ. to tracked stack address\nMB59VALS DS    0H\n         LTR   #1,#4               Number of values on stack\n         BNZ   MB59NZ              If zero, then...\n         ST    #10,0(,#5)           store NIL as list of m. values\n         LR    #15,#10              set immed. return value to NIL\n         BR    #14                  and return\nMB59NZ   DS    0H                  Else prepare to cons a list of vals\n         LR    #0,#3               Pointer to values on stack\n         SLA   #1,2                Convert # of values to index\n         AR    #1,#0               Get pointer to top of stack\n         LA    #0,12(,#1)          3 more stack slots for saving\n         #ZPDS (0)                 Check for stack overflow\n         STM   #11,#12,0(#1)       Save the usual registers\n         ST    #14,8(,#1)\n         BALR  #15,0               Set up new local base register\nNEWUSING B     AROUND-*(,#15)      Set up fake header for CONS to see\n         DC    YL1(AROUND-*-1)\n         DC    C'ZILVALS &SYSDATE &SYSTIME '\nAROUND   DS    0H\n         LR    #12,#15             Give us a real base register\n         LR    #11,#1              Save that there stack pointer\n         DROP  #15\n         USING NEWUSING,#12\n         OI    ZLCGCFLG,ZLCGCBLD   Tell CONS that #0 has good value\n         LR    #15,#10             Initialize list to NIL\n         LR    #6,#11\nCONSLOOP DS    0H\n         SH    #6,=H'4'            Point to last value on stack\n         L     #1,0(,#6)           Arg 1 to CONS = value\n         LR    #2,#15              Arg 2 to CONS = list so far\n         L     #15,ZLCCONS         Get address of ZILCONS\n         #BASR #14,#15             Call ZILCONS\n         CR    #6,#3               Loop until we hit bottom\n         BH    CONSLOOP\n         ST    #15,0(,#5)          Store list of values in the place\n         NI    ZLCGCFLG,255-ZLCGCBLD Turn off special consing flag\n         SPACE 1\n         DROP  #12\n         LR    #1,#11              Return sequence...\n         LM    #11,#12,0(#1)       Restore the usual registers\n         L     #14,8(,#1)\n         L     #15,0(,#3)          Load first value from stack\n         BR    #14                 and return with it.\n         SPACE 1\n         USING ZILVALS,#15\n         EJECT\nMBMV18   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is:                                                          *\n*                                                                     *\n*        X'18' LR                                                     *\n*                                                                     *\n* Format:      opcd r1 r2                                             *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  This may be the start of a function return sequence:               *\n*                                                                     *\n*     181B 98BC1... 58E01... 07FE                                     *\n*                                                                     *\n*  or:                                                                *\n*                                                                     *\n*     181B 58E01... 98BC1... 07FE                                     *\n*                                                                     *\n*  If it is one of these, go to handle that case specifically.        *\n*                                                                     *\n*  Otherwise, treat like a normal LR instruction.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   1(#7),X'1B'         If it's \"LR 1,11\"\n         BNE   MBRR                then\n         L     #1,2(,#7)            get next 4 bytes of instructions\n         N     #1,=X'FFFFF000'      mask out variable part\n         C     #1,=X'98BC1000'      If it's \"LM 11,12,xxx(1)\"\n         BE    MB111214             then go process 98BC...., 58E0....\n         C     #1,=X'58E01000'      If it's \"L 14,xxx(1)\"\n         BE    MB141112             then go process 58E0...., 98BC....\n         B     MBRR                 else processs like normal RR instr\nMB111214 DS    0H\n*\n* At this point we could assume the rest is OK.  But to make sure...\n*\n         L     #1,6(,#7)             get next 4 bytes of instructions\n         N     #1,=X'FFFFF000'       mask out variable part\n         C     #1,=X'58E01000'       If it's \"L 14,xxx(1)\"\n         BNE   MBRR                   and\n         CLI   10(#7),X'07'            next instruction is \"BR 14\"\n         BNE   MBRR\n         CLI   11(#7),X'FE'\n         BNE   MBRR                   then\n*\n* We have a function return sequence.  Update the stack pointer,\n* the base register and the return register, and follow the code.\n*\n         LR    #2,#5               Save tracked stack pointer\n         LH    #1,4(,#7)           Get b2d2 of LM (1xxx)\n         N     #1,=X'00000FFF'     Isolate displacement\n         L     #5,0(#1,#2)         Update tracked stack pointer\n*                                  by loading it from stack + displ\n         L     #6,4(#1,#2)         Update tracked base register\n*                                  by loading it from stack + displ + 4\n         LH    #1,8(,#7)           Get b2d2 of \"L 14, xxx(1)\" instr.\n         N     #1,=X'00000FFF'     Isolate displacement\n         L     #7,0(#1,#2)         Update tracked return address\n*                                  by loading it from stack + displ\n         N     #7,=X'7FFFFFFF'     Clear high-order bit of address\n         B     CONTINUE            Continue from new address\n         SPACE 1\nMB141112 DS    0H\n*\n* At this point we could assume the rest is OK.  But to make sure...\n*\n         L     #1,6(,#7)             get next 4 bytes of instructions\n         N     #1,=X'FFFFF000'       mask out variable part\n         C     #1,=X'98BC1000'       If it's \"LM 11,12,xxx(1)\"\n         BNE   MBRR                   and\n         CLI   10(#7),X'07'            next instruction is \"BR 14\"\n         BNE   MBRR\n         CLI   11(#7),X'FE'\n         BNE   MBRR                   then\n*\n* We have a function return sequence.  Update the stack pointer,\n* the base register and the return register, and follow the code.\n*\n         LR    #2,#5               Save tracked stack pointer\n         LH    #1,8(,#7)           Get b2d2 of LM (1xxx)\n         N     #1,=X'00000FFF'     Isolate displacement\n         L     #5,0(#1,#2)         Update tracked stack pointer\n*                                  by loading it from stack + displ\n         L     #6,4(#1,#2)         Update tracked base register\n*                                  by loading it from stack + displ + 4\n         LH    #1,4(,#7)           Get b2d2 of \"L 14, xxx(1)\" instr.\n         N     #1,=X'00000FFF'     Isolate displacement\n         L     #7,0(#1,#2)         Update tracked return address\n*                                  by loading it from stack + displ\n         N     #7,=X'7FFFFFFF'     Clear high-order bit of address\n         B     CONTINUE            Continue from new address\n         EJECT\nMBRR     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'10' LPR                                                    *\n*        X'11' LNR                                                    *\n*        X'12' LTR                                                    *\n*        X'13' LCR                                                    *\n*        X'14' NR                                                     *\n*        X'15' CLR                                                    *\n*        X'16' OR                                                     *\n*        X'17' XR                                                     *\n*        X'18' LR - if not a function return sequence                 *\n*        X'19' CR                                                     *\n*        X'1A' AR                                                     *\n*        X'1B' SR                                                     *\n*        X'1E' ALR                                                    *\n*        X'1F' SLR                                                    *\n*                                                                     *\n* Format:      opcode r1,r2                                           *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If r1 is 15, that's a set or use of #15, so no MV's returned.      *\n*  If r2 is 15, that's a use of #15, so no MV's returned.             *\n*  Otherwise, this affects nothing, so continue.                      *\n*                                                                     *\n* Notes:                                                              *\n*                                                                     *\n*  X'18FF' (\"LR 15,15\") may be used by the compiler when the form     *\n*  (VALUES <form>) is used to force return of exactly one value.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    1(#7),X'F0'         If it's rrFx\n         BO    NO                  then answer is no\n         TM    1(#7),X'0F'         If it's rrxF\n         BO    NO                  then answer is no\n         B     BUMP2               Otherwise continue\n         EJECT\nMBRX     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'40' STH                                                    *\n*        X'41' LA                                                     *\n*        X'42' STC                                                    *\n*        X'43' IC                                                     *\n*        X'46' BCT                                                    *\n*        X'48' LH                                                     *\n*        X'49' CH                                                     *\n*        X'4A' AH                                                     *\n*        X'4B' SH                                                     *\n*        X'4C' MH                                                     *\n*        X'4E' CVD                                                    *\n*        X'4F' CVB                                                    *\n*        X'50' ST                                                     *\n*        X'54' N                                                      *\n*        X'55' CL                                                     *\n*        X'56' O                                                      *\n*        X'57' X                                                      *\n*        X'58' L                                                      *\n*        X'5A' A                                                      *\n*        X'5B' S                                                      *\n*        X'5E' AL                                                     *\n*        X'5F' SL                                                     *\n*        X'88' SRL                                                    *\n*        X'89' SLL                                                    *\n*        X'8A' SRA                                                    *\n*        X'8B' SLA                                                    *\n* The following are floating-point instructions.  Note that the r1    *\n* field can never be X'F', by definition, so that just falls thru.    *\n*        X'60' STD                                                    *\n*        ...through...                                                *\n*        X'7F' SU                                                     *\n*                                                                     *\n* Format:      opcode r1 i2 b2 d2d2d2                                 *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If r1 is 15, that's a set or use of #15, so no MV's returned.      *\n*  If i2 is 15, that's a use of #15, so no MV's returned.             *\n*  If b2 is 15, that's a use of #15, so no MV's returned.             *\n*  Otherwise, this affects nothing, so continue.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    1(#7),X'F0'         If r1 is 15\n         BO    NO                  then answer is no\n         TM    1(#7),X'0F'         If i2 is 15\n         BO    NO                  then answer is no\n         TM    2(#7),X'F0'         If b2 is 15\n         BO    NO                  then answer is no\n         B     BUMP4               Otherwise continue\n         EJECT\nMBSI     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'91' TM                                                     *\n*        X'92' MVI                                                    *\n*        X'94' NI                                                     *\n*        X'95' CLI                                                    *\n*        X'96' OI                                                     *\n*        X'97' XI                                                     *\n*                                                                     *\n* Format:      opcode immed b1 d1d1d1                                 *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If b1 is 15, that's a use of #15, so no MV's returned.             *\n*  Otherwise, this affects nothing, so continue.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    2(#7),X'F0'         If b1 is 15\n         BO    NO                  then answer is no\n         B     BUMP4               Otherwise continue\n         EJECT\nMBMASK   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'BD' CLM                                                    *\n*        X'BE' STCM                                                   *\n*        X'BF' ICM                                                    *\n*                                                                     *\n* Format:      opcode r1 i2 b3 d3d3d3                                 *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If r1 is 15, that's a set or use of #15, so no MV's returned.      *\n*  If b3 is 15, that's a use of #15, so no MV's returned.             *\n*  Otherwise, this affects nothing, so continue.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    1(#7),X'F0'         If r1 is 15\n         BO    NO                  then answer is no\n         TM    2(#7),X'F0'         If b3 is 15\n         BO    NO                  then answer is no\n         B     BUMP4               Otherwise continue\n         EJECT\nMBSS     DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'D1' MVN                                                    *\n*        X'D2' MVC                                                    *\n*        X'D3' MVZ                                                    *\n*        X'D4' NC                                                     *\n*        X'D5' CLC                                                    *\n*        X'D6' OC                                                     *\n*        X'D7' XC                                                     *\n*        X'DC' TR                                                     *\n*        X'DD' TRT                                                    *\n*        X'DE' ED                                                     *\n*        X'DF' EDMK                                                   *\n*        X'F0' SRP                                                    *\n*        X'F1' MVO                                                    *\n*        X'F2' PACK                                                   *\n*        X'F3' UNPK                                                   *\n*        X'F8' ZAP                                                    *\n*        X'F9' CP                                                     *\n*        X'FA' AP                                                     *\n*        X'FB' SP                                                     *\n*        X'FC' MP                                                     *\n*        X'FD' DP                                                     *\n*                                                                     *\n* Format:      opcode ll b1 d1d1d1 b2 d2d2d2                          *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If b1 is 15, that's a use of #15, so no MV's returned.             *\n*  If b2 is 15, that's a use of #15, so no MV's returned.             *\n*  Otherwise, this affects nothing, so continue.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    2(#7),X'F0'         If b1 is 15\n         BO    NO                  then answer is no\n         TM    4(#7),X'F0'         If b2 is 15\n         BO    NO                  then answer is no\n         B     BUMP6               Otherwise continue\n         EJECT\nMBSTMLM  DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'90' STM                                                    *\n*        X'98' LM                                                     *\n*                                                                     *\n* Format:      opcode r1 r2 b2 d2d2d2                                 *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If r1 thru r2 includes register 15, no MV's returned.              *\n*  If i2 is 15, that's a use of #15, so no MV's returned.             *\n*  If b2 is 15, that's a use of #15, so no MV's returned.             *\n*  Otherwise, this affects nothing, so continue.                      *\n*                                                                     *\n* Notes:                                                              *\n*                                                                     *\n*  The LM that occurs as part of a function return sequence is not    *\n*  processed here.  It is handled when the \"LR 1,11\" (181B) is seen.  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    2(#7),X'F0'         If b2 is 15\n         BO    NO                  then answer is no\n         TRT   1(1,#7),STMLMTBL    Else check register combination\n         BZ    NO                  If it includes 15, answer is no\n         B     BUMP4               Otherwise continue\n         SPACE 1\nSTMLMTBL DC    256YL1(0)           Table to check STM/LM reg combos\n         ORG   STMLMTBL+X'00'      00 - 0E are OK\n         DC    15YL1(1)\n         ORG   STMLMTBL+X'11'      11 - 1E are OK\n         DC    14YL1(1)\n         ORG   STMLMTBL+X'22'      22 - 2E are OK\n         DC    13YL1(1)\n         ORG   STMLMTBL+X'33'      33 - 3E are OK\n         DC    12YL1(1)\n         ORG   STMLMTBL+X'44'      44 - 4E are OK\n         DC    11YL1(1)\n         ORG   STMLMTBL+X'55'      55 - 5E are OK\n         DC    10YL1(1)\n         ORG   STMLMTBL+X'66'      66 - 6E are OK\n         DC    9YL1(1)\n         ORG   STMLMTBL+X'77'      77 - 7E are OK\n         DC    8YL1(1)\n         ORG   STMLMTBL+X'88'      88 - 8E are OK\n         DC    7YL1(1)\n         ORG   STMLMTBL+X'99'      99 - 9E are OK\n         DC    6YL1(1)\n         ORG   STMLMTBL+X'AA'      AA - AE are OK\n         DC    5YL1(1)\n         ORG   STMLMTBL+X'BB'      BB - BE are OK\n         DC    4YL1(1)\n         ORG   STMLMTBL+X'CC'      CC - CE are OK\n         DC    3YL1(1)\n         ORG   STMLMTBL+X'DD'      DD - DE are OK\n         DC    2YL1(1)\n         ORG   STMLMTBL+X'EE'      EE is OK\n         DC    1YL1(1)\n         ORG\n         EJECT\nMBBALR   DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'05' BALR                                                   *\n*        X'06' BCTR                                                   *\n*        X'0D' BASR                                                   *\n*                                                                     *\n* Format:      opcode r1,r2                                           *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If r1 is 15, that's a reset of #15, so no MV's returned.           *\n*  If r2 is zero, no branch takes place, so keep going.               *\n*  Otherwise, this is a branchout, so no MV's returned.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    1(#7),X'F0'         If it's 05FX\n         BO    NO                  then answer is no\n         TM    1(#7),X'0F'         If it's 05X0\n         BZ    BUMP2               then continue\n         B     NO                  Otherwise answer is no\n         EJECT\nMBBCR    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'07' BCR                                                    *\n*                                                                     *\n* Format:      opcode c1,r2                                           *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If c1 is 15, that's an unconditional branch, so no MV's returned.  *\n*  (An unconditional BR 14 that is found as part of a function return *\n*   sequence won't be uncovered here, so it needn't be considered.)   *\n*  If c1 is 0, this is a NOPR, so continue.                           *\n*  If r2 is 0, this is a NOPR, so continue.                           *\n*  If r2 is 15, that's a strange use of #15, so no MV's returned.     *\n*  Otherwise, this is a conditional branch to strange location,       *\n*  so continue.                                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         TM    1(#7),X'F0'         If c1 is 15 (07Fx)\n         BO    NO                  then answer is no\n*                                  If c1 is 0  (070x)\n         BZ    BUMP2               then continue\n         TM    1(#7),X'0F'         If r2 is 0  (07x0)\n         BZ    BUMP2               then continue\n*                                  If r2 is 15 (07xF)\n         BO    NO                  then answer is no\n         B     BUMP2               Otherwise continue\n         EJECT\nMBSVC    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* Opcode is one of the following:                                     *\n*                                                                     *\n*        X'0A' SVC                                                    *\n*                                                                     *\n* Format:      opcode i1                                              *\n*                                                                     *\n* Rule:                                                               *\n*                                                                     *\n*  If i1 is 97, this is a TSO TEST breakpoint.  Beware.               *\n*  Otherwise, no multiple values being returned.                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   1(#7),97            If i1 is not 97 (0A61)\n         BNE   NO                  then answer is no\n         LR    #6,#0               Else save system registers\n         LR    #7,#15\n         LA    #1,TESTWARN\n         LA    #0,L'TESTWARN\n         TPUT  (1),(0),R           Warn TSO user\n         LR    #0,#6               Restore system registers\n         LR    #15,#7\n         B     NO                  Assume no MV's\n         SPACE 1\nTESTWARN DC    C'*** ZILVALS encountered TSO TEST breakpoint.  AssumingX\n                that multiple values have NOT been requested. ***'\n         EJECT\nBUMP2    DS    0H                  Keep going after 2-byte opcode\n         LA    #7,2(,#7)           Bump to next sequential instruction\n         B     OPLOOP              Continue\nBUMP4    DS    0H                  Keep going after 4-byte opcode\n         LA    #7,4(,#7)           Bump to next sequential instruction\n         B     OPLOOP              Continue\nBUMP6    DS    0H                  Keep going after 6-byte opcode\n         LA    #7,6(,#7)           Bump to next sequential instruction\n         B     OPLOOP              Continue\n         EJECT\nNO       DS    0H                  Here if no multiple values requested\n         SPACE 1\n         LTR   #0,#0               If requesting info only,\n         BZ    DONOVALS            then...\n         XR    #0,#0                set MV stack pointer to zero\n         LA    #2,1                 set # of values needed to 1\n         BR    #14                  and return with that info\n         SPACE 1\nDONOVALS DS    0H                  Here when must return normal value\n*\n* Since we are supposed to process the multiple values but there are\n* no MV requestors, we simply return the first value in register 15\n* (which we would do whether there were MV's to be processed or not).\n*\n         LTR   #4,#4               If no values to return (\"(VALUES)\")\n         BNZ   RETVAL1             then\n         LR    #15,#10              return NIL as the single value\n         BR    #14\nRETVAL1  DS    0H                  Else...\n         L     #15,0(,#3)          load first value from stack\n         BR    #14                 and return with it.\n         EJECT\nONLYRET  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* Here when #0 is positive, meaning that we already know that         *\n* multiple values must be returned and where and how to return        *\n* them.  #2 is number of slots to put values in (-1 if list needed).  *\n*                                                                     *\n* #3 and #4 better be set up right.                                   *\n*                                                                     *\n***********************************************************************\n*\n         LR    #5,#0               Where to put values\n         LR    #0,#1               Current stack pointer\n         LTR   #2,#2               If #2 is negative\n         BM    MB59VALS            then prepare to return a list\n         B     MB47VALS            else prepare to stick 'em on stack\n         EJECT\n         LTORG\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* This DSECT must match the same one in ZILTHROW.  Exactly!!!         *\n*                                                                     *\n***********************************************************************\n*\nCATCH    DSECT ,                   THIS MAPS THE CATCH FRAME\n         SPACE 1\nCATCHLNK DS    A                   +00 ADDRESS OF PREVIOUS CATCH FRAME\nCATCHS11 DS    A                   +04 ADDRESS OF STACK (SAVED #11)\nCATCHS12 DS    A                   +08 BASE REGISTER (SAVED #12)\nCATCHRET DS    A                   +0C RETURN ADDRESS AFTER FORMS\nCATCHSAL DS    A                   +10 ADDRESS OF SAVED SPECIAL ALIST\nCATCHFAL DS    A                   +14 ADDRESS OF SAVED FLUID ALIST\nCATCHTAG DS    A                   +18 THE CATCH TAG (0 FOR UWP)\nCATCHCLN DS    A                   +1C ADDRESS OF CLEANUP FORMS CODE\nCATCHVAL DS    A                   +20 RETURN VALUE SAVED DURING CLNUP\n         EJECT\n         #ZEQU\n         EJECT\n         #ZCOM\n         EJECT\n         #ZSFT\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILVSET": {"ttr": 17413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11T\\x00,\\x00)\\x00+\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:54:00", "lines": 44, "newlines": 41, "modlines": 43, "user": "SEB1525"}, "text": "         TITLE 'ZILVSET - ZIL 1.3 SPECIAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS MODULE IS INVOKED FROM COMPILED CODE TO IMPLEMENT SET,        *\n*  OR, MORE PRECISELY, ASSIGNMENTS OF SPECIAL VARIABLE VALUES.        *\n*                                                                     *\n*  ON ENTRY, REGISTER 1 POINTS TO THE CURRENT TOP-OF-STACK LOCATION   *\n*            REGISTER 2 POINTS TO THE VARIABLE SYMBOL                 *\n*            REGISTER 3 POINTS TO THE VALUE                           *\n*                                                                     *\n*  LOGIC:                                                             *\n*                                                                     *\n*  THIS ROUTINE INVOKES ZEVSET TO UPDATE A BINDING FOR THE VARIABLE,  *\n*  OR CREATE A GLOBAL ONE IF ONE DOES NOT ALREADY EXIST.              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: THIS MODULE IS OBSOLETE IF SHALLOW BINDING IS IN EFFECT.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILVSET  #ZBEG MINARGS=0,MAXARGS=0,NAME='ZILVSET',SUBRS=ZILSUBR\n         SPACE 1\n         #ZPDS 24\n         #ZSAV ,\n         SPACE 1\n         STM   #2,#3,12(#11)       STORE SYMBOL AND VALUE PTRS ON STACK\n         L     #15,@ZEVSET         GET ADDRESS OF ZEVSET\n         LA    #1,12(,#11)         POINT TO WHERE TO STORE ARGS\n         #BASR #14,#15             CALL ZEVSET TO RETURN A BINDING\n         #ZRET ,                   RETURN WITH NEW BINDING\n         SPACE 2\nZILSUBRS DS    0A\n@ZEVSET  DC    V(ZEVSET)           ADDRESS OF SUBROUTINE\n         DC    CL8'ZEVSET'\nZILSUBRE EQU   *\n         SPACE 2\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZILVSS": {"ttr": 17415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x005\\x00\\x88\\x01_\\x01\\x00&_\\x17%\\x01\\xc9\\x01\\xc6\\x01\\xc8\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:25:35", "lines": 457, "newlines": 454, "modlines": 456, "user": "SEB1525"}, "text": "         TITLE 'ZILVSS - ZIL 1.3 VECTOR/STRING SPACE SERVICES'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE HANDLES REQUESTS FROM ASSEMBLER LANGUAGE PROGRAMS   *\n* FOR VECTOR SPACE OR STRING SPACE.  4 ENTRY CODES ARE DEFINED (THE   *\n* ENTRY CODE IS SET IN REGISTER 1):                                   *\n*                                                                     *\n* REGISTER 1 = 0 ... ALLOCATE AN ENTIRE OBJECT IN V/S SPACE AND       *\n*                    MINIMALLY FORMAT IT.                             *\n* REGISTER 1 = 4 ... BEGIN BUILDING A STRING.                         *\n* REGISTER 1 = 8 ... END A STRING AND MAKE IT A TRUE OBJECT.          *\n* REGISTER 1 = 12 ... ADD DATA TO A STRING BEING BUILT.               *\n* REGISTER 1 = 16 ... CONCATENATE ANOTHER STRING'S DATA TO THIS ONE.  *\n*                                                                     *\n* ENTRY CODES 4, 8 AND 12/16 MUST BE USED IN A LOGICAL SEQUENCE BY    *\n* THE SAME CALLER, AND NO OTHER VECTOR/STRING BUILDING OR CREATION    *\n* MUST BE DONE WHILE THIS IS GOING ON.  FOR EXAMPLE, TO BUILD A       *\n* STRING, A CALLER MAY CALL THIS SUBROUTINE WITH ENTRY CODE 4 TO      *\n* START, THEN DO SEVERAL CALLS WITH ENTRY CODE 12 OR 16 TO ADD DATA   *\n* TO THE STRING, THEN CALL WITH ENTRY CODE 8 TO COMPLETE THE STRING.  *\n* THE STRING IS NOT CONSIDERED TO EXIST UNTIL ENTRY CODE 8 IS CALLED; *\n* IN THAT WAY THE STRING MAY BE \"THROWN AWAY\" AT ANY TIME SIMPLY BY   *\n* FAILING TO CALL ENTRY CODE 8.                                       *\n*                                                                     *\n* NOTE THAT ENTRY CODE 0 MAY BE USED TO CREATE ANY TYPE OF OBJECT     *\n* THAT IS VALID IN VECTOR/STRING SPACE, BUT THE OTHER ENTRY CODES     *\n* ARE FOR STRINGS ONLY.                                               *\n*                                                                     *\n* DETAILS ON WHAT IS EXPECTED ON ENTRY AND WHAT IS RETURNED ARE       *\n* GIVEN IN THE COMMENTS ON EACH INDIVIDUAL ENTRY CODE.  BUT YOU       *\n* SHOULD KNOW THAT REGISTER 0 MUST CONTAIN THE CURRENT STACK          *\n* POINTER FOR ALL ENTRY CODES (POSSIBLY EXCEPT 8) SO THAT THE         *\n* GARBAGE COLLECTOR, IF NECESSARY, CAN BE INVOKED.                    *\n*                                                                     *\n* REGISTERS 14 AND 15 HAVE THEIR STEREOTYPICAL VALUES ON ENTRY.       *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZIL 1.2 - 12/24/85 - A NEW ENTRY CODE (16) ALLOWS THE CONCATENATION *\n* OF STRINGS.  THE DIFFERENCE BETWEEN THIS AND THE ENTRY CODE THAT    *\n* STICKS NEW DATA ON A STRING IS THAT IF ZILVSS HAS TO DO A GC, THE   *\n* STRINGS WILL GET RELOCATED, SO ZILVSS HAS TO KNOW HOW TO FIND THEM. *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILVSS   CSECT\n         SPACE 1\n         USING ZILVSS,#15          NOTE CHEAPO BASE REGISTER!!!\n         USING ZLCOMMON,#13\n         SPACE 1\n         B     VSSGO(#1)           DISPATCH ON ENTRY CODE\nVSSGO    B     VSSALLOC            ENTRY CODE 0 - ALLOCATE SPACE\n         B     VSSSTART            ENTRY CODE 4 - START A STRING\n         B     VSSEND              ENTRY CODE 8 - END A STRING\n         B     VSSMORE             ENTRY CODE 12 - ADD DATA TO STRING\n         B     VSSCONC             ENTRY CODE 16 - CONCATENATE STRING\n         EJECT\nVSSALLOC DS    0H                  ENTRY CODE 0 - ALLOCATE SPACE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ENTRY CODE ALLOCATES SPACE FOR A NEW OBJECT IN VECTOR/STRING   *\n* SPACE AND MINIMALLY FORMATS IT: I.E. SETS THE \"ATOM\" AND \"V/S\"      *\n* BITS IN THE TYPE CODE (IF IT'S A STRING, NO OTHER TYPE BITS NEED    *\n* BE SET) AND STICKS THE LENGTH IN THE APPROPRIATE FIELD.  THE DATA   *\n* IS NOT INITIALIZED IN ANY WAY; IT IS THE CALLER'S RESPONSIBILITY    *\n* TO FILL THIS IN.                                                    *\n*                                                                     *\n* ENTRY: R0 = CURRENT STACK POINTER (IN CASE GC REQUIRED)             *\n*        R1 = 0 (ENTRY CODE)                                          *\n*        R2 = SIZE OF OBJECT TO BE GOTTEN (NOT INCLUDING 4-BYTE HDR)  *\n*                                                                     *\n* EXIT:  R1 -> THE OBJECT CREATED                                     *\n*        R4 -> THE DATA PORTION OF THE OBJECT                         *\n*        R15 SAME AS R1, IN CASE IT'S TO BE RETURNED AS A VALUE       *\n*                                                                     *\n*        IF R4 IS ZERO ON RETURN, THERE WAS NO ROOM AVAILABLE.        *\n*        THE CALLER MUST SIGNAL AN ERROR IN THIS CASE.                *\n*                                                                     *\n* NOTE:  REGISTERS 0 AND 2 ARE CLOBBERED.  DO NOT DEPEND ON THEM!     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #4,ZLCVSADR         GET ADDRESS OF V/S SPACE\n         L     #1,ZLCVSNXT         GET ADDRESS OF AVAILABLE SLOT\n         A     #4,ZLCVSLEN         ADD LENGTH TO POINT TO END OF SPACE\n         SR    #4,#1               GET LENGTH OF SPACE NOW AVAILABLE\n         SH    #4,=H'8'            SUBTRACT HEADER LENGTH FOR COMPARE\n         BNP   VSSAGC              AND 4 EXTRA \"SLUSH FUND\" BYTES\n         CLR   #2,#4               IF SPACE REQUESTED IS LARGER\n         BH    VSSAGC              THEN GO TO GC AND RETRY. ELSE\n*\n* IF #2 IS NEGATIVE, OR IF IT IS 16M OR GREATER, IT WILL ALWAYS TAKE\n* THE ABOVE BRANCH.  THIS TAKES CARE OF INVALID LENGTH REQUESTS.\n* IT ALSO INSURES THAT THE HIGH-ORDER BYTE OF #2 IS X'00'.\n*\n         ST    #2,0(,#1)           STORE LENGTH INTO OBJECT HEADER\n         MVI   0(#1),##ATOM+##VSS  SET BITS: ATOMIC AND IN V/S SPACE\n         LTR   #2,#2               IF REQUESTED LENGTH IS ZERO\n         BNZ   *+8                  THEN\n         LA    #2,1                  INSURE NONZERO LENGTH\n         LA    #2,##VECDAT+3(#1,#2) OBJECT+HEADER+LENGTH -> OBJECT END,\n         N     #2,=X'FFFFFFFC'        ROUNDED UP TO NEXT FULLWORD\n         ST    #2,ZLCVSNXT         UPDATE AVAILABLE-SLOT POINTER\n         LA    #4,##VECDAT(,#1)    SET POINTER TO DATA PORTION\n         LR    #15,#1              SET RETURN VALUE TO POINT TO OBJECT\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nVSSAGC   DS    0H                  HERE IF NO ROOM FOR OBJECT\n         LTR   #2,#2               IF REQUESTED LENGTH WAS NEGATIVE\n         BM    LENERROR            THEN ERROR\n         LA    #1,VSSALLOC         ELSE SET ADDRESS OF RETRY LOCATION\n         B     VSSGC               GO TO DO GARBAGE COLLECTION\n         EJECT\nVSSSTART DS    0H                  ENTRY CODE 4 - START A STRING\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ENTRY CODE STARTS BUILDING A STRING IN THE AVAILABLE SPACE.    *\n* NOTHING IS SPECIFIED EXCEPT THE DESIRE TO BEGIN MAKING A STRING.    *\n*                                                                     *\n* ENTRY: R0 = CURRENT STACK POINTER (IN CASE GC REQUIRED)             *\n*        R1 = 4 (ENTRY CODE)                                          *\n*        R2 = NOT APPLICABLE                                          *\n*                                                                     *\n* EXIT:  R1 -> THE STRING BEING BUILT                                 *\n*        R4 -> THE DATA PORTION OF THE STRING BEING BUILT             *\n*        R5 = ZERO, THE INITIAL LENGTH OF THE STRING                  *\n*                                                                     *\n*        IF R4 IS ZERO ON RETURN, THERE WAS NO ROOM AVAILABLE.        *\n*        THE CALLER MUST SIGNAL AN ERROR IN THIS CASE.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #4,ZLCVSADR         GET ADDRESS OF V/S SPACE\n         L     #1,ZLCVSNXT         GET POINTER TO NEXT AVAILABLE SLOT\n         A     #4,ZLCVSLEN         ADD LENGTH TO POINT TO END OF SPACE\n         SR    #4,#1               GET LENGTH OF SPACE NOW AVAILABLE\n         CH    #4,=H'8'            WE NEED AT LEAST 8 BYTES TO START\n         BL    VSSSGC              IF NOT, GO TO GC AND RETRY. ELSE\n*                                  #1 WILL BE POINTER TO NEW STRING\n         LA    #5,##STRING         SET BITS INDICATING STRING TYPE\n         SLDL  #4,56               SHIFT TO LEFT BYTE OF #4, CLEAR #5\n         STM   #4,#5,0(#1)         INITIALIZE HEADER AND DATA AREA\n         LA    #4,##VECDAT(,#1)    POINT TO DATA AREA OF STRING\n******** XR    #5,#5               #5 (LENGTH) ALREADY ZERO FROM ABOVE\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nVSSSGC   DS    0H                  NO ROOM\n         LA    #1,VSSSTART         SET ADDRESS OF RETRY LOCATION\n         B     VSSGC               GO TO DO GARBAGE COLLECTION\n         EJECT\nVSSEND   DS    0H                  ENTRY CODE 8 - END A STRING\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ENTRY CODE FINISHES BUILDING A STRING STARTED BY THE OTHER     *\n* ENTRY CODES (4 AND 12).  THIS ACTUALLY MAKES THE STRING \"EXIST\"     *\n* BY UPDATING THE AVAILABLE-SLOT POINTER.                             *\n*                                                                     *\n* ENTRY: R0 = NOT APPLICABLE (NO GC REQUIRED FOR THIS)                *\n*        R1 = 8 (ENTRY CODE)                                          *\n*        R2 = NOT APPLICABLE                                          *\n*        R4 -> END OF STRING (POSITION FOLLOWING LAST USED BYTE)      *\n*        R5 = FINAL LENGTH OF STRING                                  *\n*                                                                     *\n* EXIT:  R1 -> THE STRING BEING BUILT                                 *\n*        R15 SAME, IN CASE IT'S TO BE RETURNED AS A VALUE             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #4,#4               IF #4=ZERO (STRING BUILDING FAILED)\n         BZR   #14                 THEN RETURN DOING NOTHING. ELSE\n         L     #1,ZLCVSNXT         GET ADDRESS OF STRING BEING BUILT\n*                                  (WHICH HASN'T BEEN UPDATED TILL NOW)\n         STCM  #5,7,1(#1)          STORE LENGTH OF THE STRING\n         LTR   #5,#5               IF REQUESTED LENGTH IS ZERO\n         BNZ   *+8                  THEN\n         LA    #5,1                  INSURE NONZERO LENGTH\n         LA    #0,4+3(#5,#1)       POINT TO END OF STRING...\n         N     #0,=X'FFFFFFFC'      ROUNDED UP TO NEXT FULLWORD\n         ST    #0,ZLCVSNXT         UPDATE AVAILABLE SLOT POINTER\n*                                  (THIS MAKES THE STRING ALIVE)\n         LR    #15,#1              RETURN STRING ADDRESS IN CASE NEEDED\n         BR    #14                 RETURN TO CALLER\n         EJECT\nVSSMORE  DS    0H                  ENTRY CODE 12 - ADD DATA TO STRING\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ENTRY CODE ADDS DATA TO A STRING CURRENTLY BEING BUILT VIA     *\n* ENTRY CODE 4.                                                       *\n*                                                                     *\n* ENTRY: R0 = CURRENT STACK POINTER (IN CASE GC REQUIRED)             *\n*        R1 = 12 (ENTRY CODE)                                         *\n*        R2 = LENGTH OF DATA TO BE ADDED TO STRING                    *\n*        R4 -> THE CURRENT END OF STRING, WHERE DATA IS TO BE ADDED   *\n*        R5 = THE CURRENT LENGTH OF THE STRING                        *\n*        R6 -> THE DATA TO BE ADDED TO STRING                         *\n*                                                                     *\n* EXIT:                                                               *\n*        R1 -> THE BEGINNING OF THE ENTIRE STRING TEXT                *\n*        R4 -> THE NEW END OF THE STRING, AFTER DATA ADDED            *\n*        R5 = THE NEW LENGTH OF THE STRING, AFTER DATA ADDED          *\n*                                                                     *\n*        IF R4 IS ZERO ON RETURN, THERE WAS NO ROOM AVAILABLE.        *\n*        THE CALLER MUST SIGNAL AN ERROR IN THIS CASE, ALTHOUGH       *\n*        THE ERROR MAY BE DEFERRED.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #4,#4               IF #4=ZERO (STRING BUILDING FAILED)\n         BZR   #14                 THEN RETURN DOING NOTHING. ELSE\n         L     #1,ZLCVSADR         GET ADDRESS OF V/S SPACE\n         A     #1,ZLCVSLEN         ADD LENGTH TO POINT TO END OF SPACE\n         SR    #1,#2               SUBTRACT LENGTH OF STUFF TO ADD\n         CR    #1,#4               IF NEW STUFF WON'T FIT IN SPACE\n         BL    VSSMGC              THEN GO TO GC AND RETRY\n         AR    #5,#2               INCREMENT STRING LENGTH BY NEW AMT\n         C     #5,=X'00FFFFFF'     IF THIS EXCEEDS MAX STRING LENGTH\n         BH    VSSFAIL             THEN SIGNAL ERROR\n         STM   #2,#3,ZLCDBL        TEMPORARILY SAVE REGS\n         LR    #0,#4               GET PTR TO WHERE TO PUT NEW DATA\n         LR    #1,#2               GET LENGTH OF DATA TO ADD\n         LR    #2,#6               GET PTR TO NEW DATA\n         LR    #3,#1               GET LENGTH OF NEW DATA\n         MVCL  #0,#2               MOVE NEW DATA TO STRING AREA\n         LR    #4,#0               POINT TO NEW END-OF-STRING LOC\n         L     #1,ZLCVSNXT         GET ADDRESS OF STRING BEING BUILT\n         LA    #1,##VECDAT(,#1)    POINT TO BEGINNING OF STRING TEXT\n         LM    #2,#3,ZLCDBL        RESTORE REGS\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nVSSMGC   DS    0H                  NO ROOM\n         L     #1,ZLCVSNXT         SAVE ADDRESS OF AVAILABLE SLOT\n         ST    #1,OLDSTR           'CAUSE GC WILL MOVE IT\n********                           RETRY LOCATION FOLLOWS...\n         #BAS  #1,VSSGC            GO TO DO GARBAGE COLLECTION\n*\n* AFTER GC, MOVE STRING FROM OLD V/S SPACE TO NEW V/S SPACE\n*\n         STM   #0,#3,VSSSAVE2      SAVE VOLATILE REGS\n         L     #0,ZLCVSNXT         POINT TO AVAILABLE SLOT IN NEW VSS\n         L     #2,OLDSTR           POINT TO OLD-SPACE STRING DATA\n         LA    #3,4(,#5)           STRING LENGTH + HEADER LENGTH\n         LR    #1,#3               IS LENGTH OF STUFF TO MOVE\n         MVCL  #0,#2               MOVE STRING FROM OLD SPACE TO NEW\n         LR    #4,#0               SET NEW END-OF-STRING POINTER\n         LM    #0,#3,VSSSAVE2      RESTORE REGS\n         B     VSSMORE             NOW RETRY\n         EJECT\nVSSCONC  DS    0H                  ENTRY CODE 16 - CONCATENATE STRING\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ENTRY CODE CONCATENATES THE DATA FROM ANOTHER STRING WITH THE  *\n* STRING CURRENTLY BEING BUILT VIA ENTRY CODE 4.                      *\n*                                                                     *\n* ENTRY: R0 = CURRENT STACK POINTER (IN CASE GC REQUIRED)             *\n*        R1 = 16 (ENTRY CODE)                                         *\n*        R2   NOT USED                                                *\n*        R4 -> THE CURRENT END OF STRING, WHERE DATA IS TO BE ADDED   *\n*        R5 = THE CURRENT LENGTH OF THE STRING                        *\n*        R6 -> THE OTHER STRING WHOSE DATA IS TO BE ADDED TO THIS ONE *\n*                                                                     *\n* EXIT:                                                               *\n*        R1 -> THE BEGINNING OF THE ENTIRE STRING TEXT                *\n*        R4 -> THE NEW END OF THE STRING, AFTER DATA ADDED            *\n*        R5 = THE NEW LENGTH OF THE STRING, AFTER DATA ADDED          *\n*                                                                     *\n*        IF R4 IS ZERO ON RETURN, THERE WAS NO ROOM AVAILABLE.        *\n*        THE CALLER MUST SIGNAL AN ERROR IN THIS CASE, ALTHOUGH       *\n*        THE ERROR MAY BE DEFERRED.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #4,#4               IF #4=ZERO (STRING BUILDING FAILED)\n         BZR   #14                 THEN RETURN DOING NOTHING. ELSE\n         CLI   0(#6),##STRING      IF \"OTHER\" OBJECT IS NOT A STRING\n         BNE   CERROR              THEN ERROR\n         L     #1,ZLCVSADR         GET ADDRESS OF V/S SPACE\n         A     #1,ZLCVSLEN         ADD LENGTH TO POINT TO END OF SPACE\n         XR    #2,#2\n         ICM   #2,7,1(#6)          GET LENGTH OF TEXT OF OTHER STRING\n         SR    #1,#2               SUBTRACT LENGTH OF STUFF TO ADD\n         CR    #1,#4               IF NEW STUFF WON'T FIT IN SPACE\n         BL    VSSCGC              THEN GO TO GC AND RETRY\n         AR    #5,#2               INCREMENT STRING LENGTH BY NEW AMT\n         C     #5,=X'00FFFFFF'     IF THIS EXCEEDS MAX STRING LENGTH\n         BH    VSSFAIL             THEN SIGNAL ERROR\n         STM   #2,#3,ZLCDBL        TEMPORARILY SAVE REGS\n         LR    #0,#4               GET PTR TO WHERE TO PUT NEW DATA\n         LR    #1,#2               GET LENGTH OF DATA TO ADD\n         LA    #2,##VECDAT(,#6)    GET PTR TO NEW DATA\n         LR    #3,#1               GET LENGTH OF NEW DATA\n         MVCL  #0,#2               MOVE NEW DATA TO STRING AREA\n         LR    #4,#0               POINT TO NEW END-OF-STRING LOC\n         L     #1,ZLCVSNXT         GET ADDRESS OF STRING BEING BUILT\n         LA    #1,4(,#1)           POINT TO BEGINNING OF STRING TEXT\n         LM    #2,#3,ZLCDBL        RESTORE REGS\n         BR    #14                 RETURN TO CALLER\n         SPACE 1\nVSSCGC   DS    0H                  NO ROOM\n*\n* WE MUST PUSH THE \"OTHER\" STRING ON THE STACK SO THAT IT CAN BE GC'D\n* AND, IF IT HAS BEEN RELOCATED, WE CAN FIND IT AGAIN.\n*\n         L     #1,ZLCVSNXT         SAVE ADDRESS OF AVAILABLE SLOT\n         ST    #1,OLDSTR           'CAUSE GC WILL MOVE IT\n         LTR   #1,#0               POINT TO CURRENT STACK TOP\n         BZ    VSSFAIL             IF ZEROED BY PREV GC ATTEMPT, FAIL\n         LA    #0,4(,#1)           BUMP STACK POINTER UP BY 4\n         #ZPDS (0)                 CHECK FOR STACK OVERFLOW\n         ST    #6,0(,#1)           PUSH OTHER-STRING PTR FOR GC'ING\n         ST    #1,OLDSTACK         SAVE ITS LOCATION\n********                           RETRY LOCATION FOLLOWS...\n*\n* SINCE WE CHANGED REGISTER 0 TO ACCOMMODATE THE EXTRA STACK LOCATION,\n* BUT REGISTER 12 POINTS TO OUR CALLER'S CODE, THIS WILL THROW THE GC\n* OFF UNLESS WE SET ON THAT SPECIAL BIT.  BUT WE DON'T WANT TO UPSET\n* ANYBODY IN CASE THE BIT IS ALREADY ON, SO...\n*\n         TM    ZLCGCFLG,ZLCGCBLD   IF TRUST-#0 FLAG IS OFF\n         BO    VSSCGC1             THEN...\n         OI    ZLCGCFLG,ZLCGCBLD    TURN IT ON\n         #BAS  #1,VSSGC             GO TO DO GARBAGE COLLECTION\n         NI    ZLCGCFLG,255-ZLCGCBLD TURN IT OFF AGAIN\n         B     VSSCGC2\nVSSCGC1  DS    0H                  ELSE...\n         #BAS  #1,VSSGC            GO TO DO GARBAGE COLLECTION\nVSSCGC2  DS    0H\n*\n* AFTER GC, MOVE STRING FROM OLD V/S SPACE TO NEW V/S SPACE\n*\n         STM   #0,#3,VSSSAVE2      SAVE VOLATILE REGS\n         L     #0,ZLCVSNXT         POINT TO AVAILABLE SLOT IN NEW VSS\n         L     #2,OLDSTR           POINT TO OLD-SPACE STRING DATA\n         LA    #3,4(,#5)           STRING LENGTH + HEADER LENGTH\n         LR    #1,#3               IS LENGTH OF STUFF TO MOVE\n         MVCL  #0,#2               MOVE STRING FROM OLD SPACE TO NEW\n         LR    #4,#0               SET NEW END-OF-STRING POINTER\n         LM    #0,#3,VSSSAVE2      RESTORE REGS\n         L     #6,OLDSTACK         RELOAD ORIGINAL TOP-OF-STACK PTR\n         L     #6,0(,#6)           RELOAD STRING PTR (MAY BE RELCATED)\n         B     VSSCONC             NOW RETRY\n         EJECT\nVSSGC    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS BRANCHED TO WHEN THERE ISN'T ENOUGH ROOM TO         *\n* PERFORM THE REQUESTED OPERATION AND A GARBAGE COLLECTION IS TO      *\n* BE ATTEMPTED SO THAT ENOUGH ROOM WILL BE AVAILABLE.                 *\n*                                                                     *\n* ON ENTRY #1 -> THE PLACE TO BRANCH TO TO RETRY THE OPERATION.       *\n*                                                                     *\n* NOTE THAT WHEN THIS ROUTINE IS FIRST ENTERED, #0 POINTS TO THE      *\n* CURRENT STACK LOCATION (REQUIRED BY GC).  WHEN THIS ROUTINE IS      *\n* EXECUTED ONCE, #0 IS SET TO ZERO SO THAT THE SECOND TIME THRU,      *\n* IT'LL KNOW THAT A GC WAS ATTEMPTED ALREADY AND THERE JUST WON'T     *\n* BE ENOUGH ROOM, SO A FAILURE IS DETECTED.                           *\n*                                                                     *\n* NO ERROR IS SIGNALLED IN THIS ROUTINE.  IT IS THE CALLER'S          *\n* RESPONSIBILITY TO SIGNAL ERRORS WHEN THERE IS NO ROOM TO BUILD      *\n* THE STRING.  IN THIS WAY, FOR EXAMPLE, A ROUTINE CAN CONTINUE TO    *\n* RETRIEVE CHARACTERS TO BUILD A STRING AND NOT CONFUSE AN INPUT      *\n* STREAM UNTIL THE EXPECTED END IS REACHED - THEN SIGNAL THE ERROR.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   #0,#0               IF WE TRIED A GC ALREADY\n         BZ    VSSFAIL             THEN FAILURE - NO ROOM AT ALL\n         #BASR #4,0\n         DROP  #15\n         USING *,4\n         L     #9,ZLCGCEND         FORCE END OF FREE LIST\n         STM   #14,#2,VSSSAVE2     SAVE VOLATILE REGS\n         LR    #1,#10              SET DUMMY ARG 1 FOR CONS = NIL\n         LR    #2,#10              SET DUMMY ARG 2 FOR CONS = NIL\n*                                  #0 ALREADY POINTS TO STACK LOC\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS TO DO GARBAGE COLLECTION\n         LM    #14,#2,VSSSAVE2     RESTORE VOLATILE REGS\n         DROP  #4\n         XR    #0,#0               INDICATE WE TRIED GC ALREADY\n         BR    #1                  GO TO RETRY ROUTINE LOCATION\n         SPACE 1\nVSSFAIL  DS    0H\n         XR    #4,#4               SHOW FAILURE BY CLEARING DATA PTR\n         XR    #15,#15             AND CLEAR RETURN POINTER TOO\n         BR    #14                 RETURN TO CALLER IN FAILURE\n         EJECT\nOLDSTR   DS    A                   PLACEHOLDER FOR STRING SLOT\nOLDSTACK DS    A                   SAVED TOP-OF-STACK ADDRESS\nVSSSAVE2 DS    5A                  SAVE AREA WHILE CALLING GC\n         SPACE 1\nLENERROR DS    0H\n         LR    #3,#15\n         USING ZILVSS,#3\n         XR    #14,#14\n         B     BLOWUP\n         SPACE 1\nCERROR   DS    0H\n         LR    #3,#15\n         USING ZILVSS,#3\n         LA    #14,4\n         B     BLOWUP\n         SPACE 1\nBLOWUP   DS    0H\n         SPACE 1\n*\n* Extract function name for insertion into message\n*\n         SPACE 1\n         XR    #1,#1               Clear insert register\n         STCM  #1,7,FUNLEN         Initialize fake string length to 0\n         IC    #1,4(,#12)          Get length of module identifier\n         SH    #1,=H'16'           Subtract length of date/time info\n         BNP   SKIPNAME            If no name, skip move\n         CH    #1,=Y(L'FUNTEXT)    If longer than our maximum\n         BNH   *+8                 then\n         LA    #1,L'FUNTEXT         use our maximum length\n         STCM  #1,7,FUNLEN         Store length into fake string\n         BCTR  #1,0                Reduce for execute\n         EX    #1,MVCNAME          Move function name to fake string\nSKIPNAME DS    0H\n         SPACE 1\n         B     BOOM(#14)\nBOOM     B     ERROR1\n         B     ERROR2\n         SPACE 1\nERROR1   DS    0H\n         #ERR  PREFIX=NO,'ZIL2050 ',FUNSTR,': Invalid ZILVSS request foX\n               r ',#2,' bytes of vector/string space.'\n         SPACE 1\nERROR2   DS    0H\n         #ERR  PREFIX=NO,'ZIL2051 ',FUNSTR,': Object to be concatenatedX\n                by ZILVSS is not a string.'\n         SPACE 1\nMVCNAME  MVC   FUNTEXT(*-*),5(#12) Executed: Move function name to str\n         SPACE 1\n         DS    0H,XL1              Align fake string to non-halfword\nFUNSTR   DC    YL1(##STRING)\nFUNLEN   DS    AL3\nFUNTEXT  DS    CL64\n         LTORG\n         EJECT\n         #ZEQU\n         EJECT\n         #ZCOM\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILVSYM": {"ttr": 17667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x00J\\x00G\\x00I\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 74, "newlines": 71, "modlines": 73, "user": "SEB1525"}, "text": "         TITLE 'ZILVSYM - ZIL 1.3 SPECIAL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS MODULE IS INVOKED FROM COMPILED CODE TO IMPLEMENT SYMEVAL,    *\n*  OR, MORE PRECISELY, ACCESSES OF SPECIAL VARIABLE VALUES.           *\n*                                                                     *\n*  ON ENTRY, REGISTER 1 POINTS TO THE CURRENT TOP-OF-STACK LOCATION   *\n*            REGISTER 2 POINTS TO THE VARIABLE SYMBOL                 *\n*                                                                     *\n*  LOGIC:                                                             *\n*                                                                     *\n*  THIS ROUTINE INVOKES ZEVSYM TO GET A BINDING FOR THE VARIABLE.     *\n*  IF ZEVSYM RETURNS NIL,  AN \"UNBOUND VARIABLE\" ERROR IS SIGNALLED.  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* NOTE: THIS MODULE IS OBSOLETE IF SHALLOW BINDING IS IN EFFECT.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILVSYM  #ZBEG MINARGS=0,MAXARGS=0,NAME='ZILVSYM',SUBRS=ZILSUBR\n         SPACE 1\n         #ZPDS 20\n         #ZSAV ,\n         SPACE 1\n         ST    #2,12(#11)          STORE SYMBOL ARG ON STACK\n         L     #15,@ZEVSYM         GET ADDRESS OF ZEVSYM\n         LA    #1,12(,#11)         POINT TO WHERE TO STORE ARGS\n         #BASR #14,#15             CALL ZEVSYM TO RETURN A BINDING\n         CR    #15,#10             IF NO BINDING WAS FOUND\n         BE    ERROR               THEN ERROR\n         #ZRET ,                   ELSE RETURN WITH BINDING\nERROR    DS    0H\n*\n* Extract function name for insertion into message\n*\n         SPACE 1\n         L     #2,4(,#11)          THIS IS WHERE #12 WAS SAVED...\n         XR    #1,#1               Clear insert register\n         STCM  #1,7,FUNLEN         Initialize fake string length to 0\n         IC    #1,4(,#2)           Get length of module identifier\n         SH    #1,=H'16'           Subtract length of date/time info\n         BNP   SKIPNAME            If no name, skip move\n         CH    #1,=Y(L'FUNTEXT)    If longer than our maximum\n         BNH   *+8                 then\n         LA    #1,L'FUNTEXT         use our maximum length\n         STCM  #1,7,FUNLEN         Store length into fake string\n         BCTR  #1,0                Reduce for execute\n         EX    #1,MVCNAME          Move function name to fake string\nSKIPNAME DS    0H\n         SPACE 1\n         #ERR  PREFIX=NO,          DISPLAY ERROR MESSAGE               X\n               'ZIL1300 ZILVSYM: Unbound variable ',12(#11),' in compilX\n               ed function ',FUNSTR,'.'\n         SPACE 1\nMVCNAME  MVC   FUNTEXT(*-*),5(#2)  Executed: Move function name to str\n         SPACE 1\n         DS    0H,XL1              Align fake string to non-halfword\nFUNSTR   DC    YL1(##STRING)\nFUNLEN   DS    AL3\nFUNTEXT  DS    CL64\n         SPACE 1\nZILSUBRS DS    0A\n@ZEVSYM  DC    V(ZEVSYM)           ADDRESS OF SUBROUTINE\n         DC    CL8'ZEVSYM'\nZILSUBRE EQU   *\n         SPACE 2\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILVTOS": {"ttr": 17669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x885\\x0f\\x00\\x89\\x15o\\x11U\\x00Z\\x00U\\x00Y\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 90, "newlines": 85, "modlines": 89, "user": "SEB1525"}, "text": "         TITLE 'ZILVTOS - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (ZILVTOS vector1 length2)                                           *\n*                                                                     *\n*  vector1    - a vector of characters                                *\n*  length2    - the number of vector elements to make into a string   *\n*                                                                     *\n* This function is used by the new ZIL reader to build strings.       *\n*                                                                     *\n***********************************************************************\nZILVTOS  #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILVTOS'\n         #ZPDS 2*4+12+0 = 20       DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n*\n* Check arg 1 - must be vector of characters.\n*\n         LM    #6,#7,0(#11)        Get args 1 and 2\n         CLI   ##TYPE(#6),##VECTOR Arg 1 must be a vector\n         BNE   ERROR1              else error\n         XR    #5,#5               Clear insert register\n         ICM   #5,7,1(#6)          Get length of vector arg 1\n         SRA   #5,2                Divide by 4 to get # of elements\n*\n* Check arg 2 - must be fixnum and not greater than length of arg 1.\n*\n         CLI   ##TYPE(#7),##FIXNUM Arg 2 (length) must be a fixnum\n         BNE   ERROR2              else error\n         L     #7,##CDR(,#7)       Get numeric length value\n         LTR   #7,#7               If requested length is 0\n         BZ    RETNULL             then just return null string\n         BM    ERROR2              If requested length negative, error\n         CR    #7,#5               If positive but longer than vector\n         BH    ERROR3              then error\n*\n* Allocate space for a string of the requested length.\n*\n         LR    #2,#7               Length for ZILVSS = arg 2\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF ZILVSS\n         LA    #0,20(,#11)         SET CURRENT STACK POINTER FOR GC\n         #BASR #14,#15             CALL ZILVSS TO CREATE A STRING\n         LTR   #15,#15             IF STRING BUILD FAILED\n         BZ    ERRORGC             THEN ERROR\n*\n* #4 points to the text portion of the string.\n*\n         L     #6,0(,#11)          Reload arg 1 pointer from stack\n         LA    #3,##VECDAT(,#6)    Point to 1st element of vector arg 1\nVLOOP    DS    0H\n         L     #2,0(,#3)           Get element of vector\n         CLI   ##TYPE(#2),##FIXNUM Each element must be a character\n         BNE   ERROR4              (i.e. a fixnum between 0 and 255)\n         L     #0,##CDR(,#2)       Get numeric value\n         CL    #0,#SFW255          If not within character range\n         BH    ERROR4              then error\n         STC   #0,0(,#4)           Store character into string\n         LA    #3,4(,#3)           Bump input pointer\n         LA    #4,1(,#4)           Bump output pointer\n         BCT   #7,VLOOP            Continue (arg 2) times\n         B     RETURN              Return new-string\n         SPACE 1\nRETNULL  DS    0H                  Requested length is zero\n         LA    #15,NULLSTR         Return null string\n******** B     RETURN              Return new-string\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nNULLSTR  DS    0A                  Align null string to fullword\n         DC    YL1(##STRING),AL3(0),XL4'00'  String \"\"\n         SPACE 1\nERROR1   #ERR  'Argument 1 to ZILVTOS not a vector - ',0(#11)\nERROR2   #ERR  'Argument 2 to ZILVTOS not a non-negative fixnum - ',   X\n               4(#11)\nERROR3   #ERR  'Argument 2 to ZILVTOS exceeds length of argument 1 - ',X\n               4(#11)\nERROR4   #ERR  'Non-character element found in ZILVTOS argument 1 - ', X\n               0(#2)\nERRORGC  #ERR  'ZIL4010 ZILVTOS: Not enough vector/string space to builX\n               d string.',PREFIX=NO\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILXCLO": {"ttr": 17672, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x00\\x8c\\x00\\x89\\x00\\x8b\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 140, "newlines": 137, "modlines": 139, "user": "SEB1525"}, "text": "         TITLE 'ZILXCLO - ZIL 1.3 CLOSURE BUILDER FOR FUNCTION ARGS'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS MODULE IS INVOKED FROM COMPILED CODE TO IMPLEMENT THE         *\n*  \"FUNCTION\" SPECIAL FORM - #' - ON UNKNOWN QUANTITIES.              *\n*  THIS IS A NORMAL-LOOKING FUNCTION THAT TAKES 2 ARGUMENTS:          *\n*  (1) THE OBJECT OUT OF WHICH A FUNCTIONAL ARGUMENT IS TO BE BUILT   *\n*  (2) T OR NIL, DEPENDING ON WHETHER A LEXICAL CLOSURE OR JUST A     *\n*  PLAIN OLD DYNAMIC-BINDING \"SUBR\"-TYPE FUNARG IS TO BE BUILT.       *\n*                                                                     *\n*  LOGIC:                                                             *\n*                                                                     *\n*  THIS ROUTINE ATTEMPTS TO RESOLVE THE FIRST ARG AS A COMPILED CODE  *\n*  FUNCTION (A SYMBOL WITH A VALID SUBR PROPERTY).  IF SO, A COMPILED *\n*  LEXICAL CLOSURE IS BUILT, AS INLINE CODE FOR \"FUNCTION\" WOULD      *\n*  DO FOR A KNOWN FUNCTION.  OTHERWISE, AN INTERPRETED LEXICAL        *\n*  CLOSURE OBJECT (FUNARG) IS BUILT, USING MAKE-FUNARG OR SOMETHING   *\n*  EQUIVALENT, AS \"FUNCTION\" DOES UNDER THE INTERPRETER.              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* 10/87 - Since (FUNCTION FOO) and (SUBR FOO) are equivalent in       *\n*         lexically scoped Common Lisp - i.e. there is no lexical     *\n*         environment to capture for a symbol FOO - there is no       *\n*         difference in processing when arg 1 to this subroutine      *\n*         is a symbol, whether arg 2 is T or NIL.  We found that      *\n*         when the SUBR property of the symbol names a lexical        *\n*         closure, the original lexical environment of that           *\n*         closure was being ignored in favor of the (useless)         *\n*         current lexical environment, causing errors when a          *\n*         function was being traced.  Therefore, when arg 1 is        *\n*         a symbol we ignore arg 2, but we check to see if the        *\n*         SUBR property of the symbol names a lexical closure.        *\n*                                                                     *\n* Actually, all we do is to see that the SUBR property is CODEP and,  *\n* if it is, return that value itself.  We don't use new environment.  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* HOPEFULLY SOME DAY SUBRS WILL BE STORED IN THE FUNCTION CELL OF THE *\n* SYMBOL INSTEAD OF (OR IN ADDITION TO) THE PROPERTY LIST.  IF THIS   *\n* IS SO, WE CAN KILL THE CALL TO GET AND THE NECESSITY OF INTERNING   *\n* THE SYMBOL \"SUBR\" IN THIS MODULE.                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILXCLO  #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILXCLO',SUBRS=ZILSUBR,       X\n               PTRS=ZLBPTRS,ATOMS=ZILATOM,LISTS=ZILLIST\n         SPACE 1\n         #ZPDS 2*4+12+12 = 32\n         #ZSAV ,\n         SPACE 1\n*\n* REQUIRED FIRST-TIME-ONLY CODE TO INTERN ATOMS USED BY THIS MODULE.\n*\nZAPGO    NOP   AROUND              EXECUTE ONCE, THEN BRANCH.\n         LA    #1,ZLBPTRS          ADDRESS THE LIST OF POINTERS\n         L     #15,ZLCSINT         GET ADDRESS OF ZILSINT\n         LA    #0,20(,#11)         SET TOP-OF-STACK POINTER\n         #BASR #14,#15             CALL ZILSINT\n         OI    ZAPGO+1,X'F0'       CHANGE NOP TO BRANCH NEXT TIME\nAROUND   DS    0H\n         SPACE 1\n         L     #1,0(,#11)          PICK UP FUNCTIONAL ARG\n         SPACE 1\nCHKTYPE  DS    0H                  SEE WHAT WE GOT\n         SPACE 1\n         CLI   ##TYPE(#1),##SYMBOL\n******** BE    ZSYMBOL             IF SYMBOL, PROCESS SYMBOL\n         BNE   MAKEFUN             ELSE MAKE INTERPRETED CLOSURE\n         SPACE 1\nZSYMBOL  DS    0H                  IF IT IS A SYMBOL...\n         SPACE 1\n*                                  ARG 1 TO GET = OUR ARG 1\n         L     #2,ASUBR            ARG 2 TO GET = 'SUBR\n         LR    #3,#10              ARG 3 TO GET = NIL\n         STM   #1,3,20(#11)        STORE ARGS\n         L     #15,@GET\n         LA    #1,20(,#11)\n         #BASR #14,#15             CALL GET TO (GET SYMBOL 'SUBR)\n         TM    ##TYPE(#15),##CODE  SUBR PROPERTY MUST BE CODEP\n         BO    RETURN              IF SUBR OK, then return it!\n         SPACE 1\nMAKEFUN  DS    0H                  ELSE MUST BE INTERPRETIVE\n         SPACE 1\n         C     #10,4(,#11)         IF ARG 2 TO ZILXCLO = NIL\n         BNE   MAKEFUNT            THEN...\n         L     #15,0(,#11)          JUST RETURN ARG 1 ITSELF\n         B     RETURN              ELSE...\nMAKEFUNT DS    0H                  MAKE AN INTERPRETIVE LEXICAL CLOSURE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* NOTE: THE SECOND ARG TO MAKE-FUNARG IS THE ENVIRONMENT, WHICH WE    *\n* BUILD BY CALLING MKNEWENV (MAKE-NEW-ENVIRONMENT).  WE SPECIFY THE   *\n* CURRENT LEXICAL ALIST FOR THIS.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     #1,ZLCFALST         GET CURRENT LEXICAL ALIST\n         ST    #1,20(,#11)         STORE ARG 1 TO MKNEWENV\n         L     #15,@MKNEWEN        GET ADDRESS OF MKNEWENV\n         LA    #1,20(,#11)         SET POINTER TO ARGS ON STACK\n         #BASR #14,#15             CALL MKNEWENV 2 MAKE NEW ENVIRONMENT\n         ST    #15,24(,#11)        STORE ARG 2 TO MAKE-FUNARG\n         L     #14,0(,#11)         GET ARG 1 TO THIS FUNCTION\n         ST    #14,20(,#11)        STORE ARG 1 TO MAKE-FUNARG\n         L     #15,@MKFUNAR        GET ADDRESS OF MKFUNARG\n         LA    #1,20(,#11)         SET POINTER TO ARGS ON STACK\n         #BASR #14,#15             CALL MAKE-FUNARG TO BUILD A FUNARG\n******** B     RETURN              AND RETURN WITH IT\n         SPACE 1\nRETURN   DS    0H                  RETURN\n         SPACE 1\n         #ZRET ,\n         SPACE 2\nZILSUBRS DS    0A\n@GET     DC    V(GET)              ADDRESS OF SUBROUTINE\n         DC    CL8'GET'\n@MKNEWEN DC    V(MKNEWENV)         ADDRESS OF SUBROUTINE\n         DC    CL8'MKNEWENV'\n@MKFUNAR DC    V(MKFUNARG)         ADDRESS OF SUBROUTINE\n         DC    CL8'MKFUNARG'\nZILSUBRE EQU   *\n         SPACE 2\nZILATOMS DS    0A\nASUBR    DC    A(SUBR-ZILXCLO)     ADDRESS OF ATOM SUBR\nZILATOME EQU   *\nZILLISTS EQU   *\nZILLISTE EQU   *\n         SPACE 2\nSUBR     #AATM 'SUBR'\n         SPACE 2\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILXDEF": {"ttr": 17675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00P\\x00\\x88\\x01_\\x01\\x00&_\\x17%\\x00B\\x00?\\x00A\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:25:50", "lines": 66, "newlines": 63, "modlines": 65, "user": "SEB1525"}, "text": "         TITLE 'ZILXDEF - ZIL 1.3 COMPILED FUNCTION DEFINER'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS MODULE IS INVOKED FROM COMPILED CODE TO IMPLEMENT THE         *\n*  COMPILER-GENERATED FORM FOR \"DEFUN\".                               *\n*                                                                     *\n* ON ENTRY:  REGISTER 0 = CURRENT TOP-OF-STACK POINTER                *\n*            REGISTER 1 --> THE FUNCTION NAME SYMBOL                  *\n*            REGISTER 2 --> THE COMPILED CODE ITSELF                  *\n*                                                                     *\n* ON RETURN: REGISTER 15 IS THE RETURN VALUE FROM ZEVDSUB             *\n*                                                                     *\n*  LOGIC:                                                             *\n*                                                                     *\n*  THIS ROUTINE CALLS ZEVDSUB TO ASSIGN THE COMPILED CODE PROPERTY TO *\n*  THE NAMED FUNCTION.  NOTE THAT DYNAMIC BINDING IS EFFECTED.  NO    *\n*  SUPPORT FOR LEXICAL CLOSURES DEFUNNING IS AVAILABLE HERE.          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILXDEF  #ZBEG NAME='ZILXDEF',SUBRS=ZILSUBR\n         SPACE 1\n         LR    #3,#0               GET CURRENT TOP-OF-STACK POINTER\n         LA    #0,32(,#3)          CHECK ROOM ON STACK\n         #ZPDS (0)\n         STM   #5,#7,0(#3)\n         STM   #11,12,12(#3)\n         ST    #14,20(,#3)\n         LR    #12,#15\n         DROP  #15\n         USING ZILXDEF,#12\n         LR    #11,#3\n         SPACE 1\n         ST    #1,24(,#11)         SAVE SYMBOL ARG\n         LR    #1,#2               GET COMPILED CODE\n         XR    #2,#2               SET ALIST ARG = NIL\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         OI    ZLCGCFLG,ZLCGCBLD   TELL CONS WE'RE IN CHARGE OF #0\n         #BASR #14,#15             CALL CONS TO MAKE A SUBR\n         NI    ZLCGCFLG,255-ZLCGCBLD TURN OFF #0-HANDLING FLAG\n         MVI   ##TYPE(#15),##SUBR  SET TYPE BITS\n         ST    #15,28(,#11)        SET ARG 2 TO ZEVDSUB\n         L     #15,@ZEVDSUB        GET ADDRESS OF ZEVDSUB\n         LA    #1,24(,#11)         POINT TO ARGS ON STACK\n         #BASR #14,#15             CALL ZEVDSUB FOR RUN-TIME DEFUN\n         SPACE 1\n         LR    #3,#11\n         LM    #5,#7,0(#3)\n         LM    #11,12,12(#3)\n         L     #14,20(,#3)\n         BR    #14\n         SPACE 1\n         #ZRET ,\n         SPACE 2\nZILSUBRS DS    0A\n@ZEVDSUB DC    V(ZEVDSUB)          ADDRESS OF SUBROUTINE\n         DC    CL8'ZEVDSUB'\nZILSUBRE EQU   *\n         SPACE 2\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILXFUN": {"ttr": 17677, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x04\\x00\\x88\\x01_\\x01\\x00&_\\x17&\\x01\\x8d\\x01y\\x01\\x8c\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:26:04", "lines": 397, "newlines": 377, "modlines": 396, "user": "SEB1525"}, "text": "         TITLE 'ZILXFUN - ZIL 1.3 FUNCTION EXECUTOR FOR FUNCALL'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS MODULE IS INVOKED FROM COMPILED CODE TO IMPLEMENT FUNCALL.    *\n*  ON ENTRY, REGISTER 1 POINTS TO THE CURRENT PART OF THE STACK,      *\n*  WHICH IS SET UP AS FOLLOWS:                                        *\n*                                                                     *\n*  +0 - LEFT UNUSED SO THIS MODULE CAN SAVE #11 HERE                  *\n*  +4 - LEFT UNUSED SO THIS MODULE CAN SAVE #12 HERE                  *\n*  +8 - LEFT UNUSED SO THIS MODULE CAN SAVE ALIST HERE                *\n*  +C - LEFT UNUSED SO THIS MODULE CAN SAVE #14 HERE                  *\n*  +10 - THE FIRST ARG TO FUNCALL, I.E. THE FUNCTION OBJECT           *\n*  +14 ON - THE OTHER ARGS                                            *\n*                                                                     *\n*  REGISTER 2 CONTAINS THE NUMBER OF ARGS TIMES 4.  NOTE THAT         *\n*  (REG2)+20 = THE SIZE OF THE STACK IN USE AT THE TIME OF ENTRY.     *\n*                                                                     *\n*  LOGIC:                                                             *\n*                                                                     *\n*  THIS ROUTINE ATTEMPTS TO RESOLVE THE FIRST ARG AS A COMPILED CODE  *\n*  FUNCTION (THROUGH BEING A SUBR, A CLOSURE, A SYMBOL WITH A SUBR    *\n*  PROPERTY, OR A FUNARG WHOSE FUNCTION COMPONENT IS ONE OF THE       *\n*  ABOVE).  IF SO, CONTROL IS PASSED DIRECTLY TO THAT CODE, SETTING   *\n*  THE ALIST IF NECESSARY, USING THE ARGS ALREADY ON THE STACK.       *\n*  (IF &OPTIONAL OR &REST ARGS ARE DEFINED, THE ADDITIONAL ARGS       *\n*  NEEDED ARE PLACED ON THE STACK, AFTER MAKING SURE WE HAVE ROOM     *\n*  FOR THEM.)  IF NO SUCH DEFINITION EXISTS, THE ARGS ARE MADE INTO   *\n*  A LIST AND CONTROL IS PASSED TO THE ZILAPPLY FUNCTION.             *\n*                                                                     *\n*  THE RETURN VALUE FROM THIS FUNCTION, OF COURSE, IS THE VALUE       *\n*  OF THE FUNCTION CALL.                                              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* HOPEFULLY SOME DAY SUBRS WILL BE STORED IN THE FUNCTION CELL OF THE *\n* SYMBOL INSTEAD OF (OR IN ADDITION TO) THE PROPERTY LIST.  IF THIS   *\n* IS SO, WE CAN KILL THE CALL TO ZGET AND THE NECESSITY OF INTERNING  *\n* THE SYMBOL \"SUBR\" IN THIS MODULE.                                   *\n*                                                                     *\n***********************************************************************\n*\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 06/14/88 - Support for multiple values.                             *\n*                                                                     *\n***********************************************************************\n*\n         SPACE 1\nZILXFUN  #ZBEG NAME='ZILXFUN',SUBRS=ZILSUBR,                           X\n               PTRS=ZLBPTRS,ATOMS=ZILATOM,LISTS=ZILLIST\n         SPACE 1\n         STM   #11,#14,0(#1)       SAVE REGS ON BOTTOM OF STACK FRAME\n         LR    #12,#15             SET UP CURRENT BASE REGISTER\n         DROP  #15\n         USING ZILXFUN,#12\n         LR    #11,#1              SET UP CURRENT STACK POINTER\n         SPACE 1\n*\n* REQUIRED FIRST-TIME-ONLY CODE TO INTERN ATOMS USED BY THIS MODULE.\n*\nZAPGO    NOP   AROUND              EXECUTE ONCE, THEN BRANCH.\n         ST    #2,SAVE2            SAVE REGISTER 2\n         LA    #1,ZLBPTRS          ADDRESS THE LIST OF POINTERS\n         L     #15,ZLCSINT         GET ADDRESS OF ZILSINT\n         LA    #0,20(#2,#11)       SET POINTER TO TOP OF STACK USED\n         #BASR #14,#15             CALL ZILSINT\n         L     #2,SAVE2            RESTORE REGISTER 2\n         OI    ZAPGO+1,X'F0'       CHANGE NOP TO BRANCH NEXT TIME\nAROUND   DS    0H\n         SPACE 1\n         L     #1,16(,#11)         PICK UP FUNCTIONAL ARG\n         XR    #4,#4               SET ALIST POINTER = ZERO\n         SPACE 1\nCHKTYPE  DS    0H                  SEE WHAT WE GOT\n         SPACE 1\n         CLI   ##TYPE(#1),##SYMBOL\n         BE    ZSYMBOL             IF SYMBOL, PROCESS SYMBOL\n         CLI   ##TYPE(#1),##SUBR\n         BE    ZSUBR               IF SUBR, PROCESS SUBR\n         CLI   ##TYPE(#1),##CLOSUR\n         BE    ZCLOSURE            IF CLOSURE, PROCESS CLOSURE\n         CLI   ##TYPE(#1),##FUNARG\n         BE    ZFUNARG             IF FUNARG, PROCESS FUNARG\n         B     TRYAPPLY            ELSE JUST APPLY IT\n         EJECT\nZSUBR    DS    0H                  IT IS A SUBR\n         XR    #3,#3\n         ICM   #3,7,##CAR+1(#1)    GET POINTER TO COMPILED CODE\n         B     CALLIT\n         EJECT\nZCLOSURE DS    0H                  IT IS A COMPILED CLOSURE\n         XR    #3,#3\n         ICM   #3,7,##CAR+1(#1)    GET POINTER TO COMPILED CODE\n         L     #4,##CDR(,#1)       GET ALIST POINTER\n         B     CALLIT\n         EJECT\nZFUNARG  DS    0H                  IT IS AN INTERPRETED CLOSURE\n         LM    #3,4,##VECDAT(#1)   GET POINTERS TO FUNCTION AND ENV\n         L     #4,##CAR(,#4)       GET ALIST POINTER FROM ENVIRONMENT\n         LR    #1,#3               CHECK THE FUNCTION OBJECT\n         B     CHKTYPE             SEE WHAT WE GOT\n         EJECT\nZSYMBOL  DS    0H                  IT IS A SYMBOL\n         SPACE 1\n         LA    #5,20(#2,#11)       SET POINTER TO TOP OF STACK USED\n*                                  #1 = symbol\n         L     #1,##PLIST(,#1)     Get property list pointer\n         L     #0,ASUBR            #2 = symbol 'SUBR\n         B     ZGETGO              Start looping\nZGETLOOP DS    0H\n         LM    #14,#15,##CAR(#1)   Get CAR+CDR of property (sub)list\n         CR    #0,#14              If (CAR subplist) is \"EQ\" to arg 2\n         BE    ZGETWIN             then win. Else...\n         LTR   #14,#14             If invalid property list (atomic)\n         BM    TRYAPPLY            then no SUBR property\n         L     #1,##CDR(,#15)       get CDR of property (sub)list\nZGETGO   DS    0H\n         CR    #1,#10              Until end of property list (null)\n         BNE   ZGETLOOP             continue processing\n         B     TRYAPPLY            At end, no SUBR property found\nZGETWIN  DS    0H\n         L     #1,##CAR(,#15)      Get CAR of sublist = value of prop.\n         TM    ##TYPE(#1),##CODE   SUBR PROPERTY MUST BE CODEP\n         BNO   TRYAPPLY            ELSE CANNOT BE CALLED, TRY APPLY\n         XR    #4,#4               CLEAR ALIST POINTER\n         B     CHKTYPE             AND SEE WHAT WE GOT\n         EJECT\nCALLIT   DS    0H                  PREPARE TO INVOKE COMPILED CODE\n         SPACE 1\n         OI    ZLCGCFLG,ZLCGCBLD   TELL CONS WE'RE SETTING #0\n         SPACE 1\n*\n* #3 --> THE COMPILED CODE ITSELF\n* #4 --> THE ALIST (ZERO IF NOT A CLOSURE)\n*\n* EXTRACT MINIMUM AND MAXIMUM NUMBER OF ARGS FOR THIS FUNCTION\n*\n         XR    #6,#6               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         LA    #5,20(#2,#11)       SET POINTER TO TOP OF STACK USED\n         IC    #6,4(,#3)           GET LENGTH OF MODULE IDENTIFIER\n         LA    #15,5+3(#6,#3)      POINT PAST MODULE IDENTIFIER\n         N     #15,=X'FFFFFFFC'    ROUNDING UP TO NEXT FULLWORD\n         USING ZINT,#15            ADDRESS THE \"ZINT\" AREA IN MODULE\n         TM    ZINFLAG2,ZINGLEXP   IF THIS IS A COMPILED LEXPR\n         BO    LEXPR               THEN GO TO PROCESS IT AS A LEXPR\n         IC    #6,ZINMINAR         GET MINIMUM NUMBER OF ARGUMENTS\n         IC    #7,ZINMAXAR         GET MAXIMUM NUMBER OF ARGUMENTS\n         CR    #6,#7               IF MINIMUM > MAXIMUM\n         BH    BADFUNC             THEN ERROR - BAD FUNCTION\n         SLA   #6,2                CONVERT MINARGS TO STACK FRAME SIZE\n         CR    #2,#6               IF ARGS PASSED ARE FEWER THAN MIN\n         BL    TOOFEW              THEN ERROR - TOO FEW ARGUMENTS\n         SLA   #7,2                CONVERT MAXARGS TO STACK FRAME SIZE\n         TM    ZINFLAG2,ZINGREST   IF THERE'S A &REST ARG\n         BO    MANYOK               THEN IT'S OK TO HAVE MORE ARGS\n         CR    #2,#7               OTHERWISE IF ARGS PASSED ARE MORE\n         BH    TOOMANY             THEN THAT'S AN ERROR\nMANYOK   DS    0H\n*\n* SET ACTUAL TOP-OF-STACK POINTER BASED ON MAXARGS\n*\n         LA    #6,20(#7,#11)       POINT TO END OF MAX ARGS\n         TM    ZINFLAG2,ZINGREST   IF THERE'S A &REST ARG\n         BZ    MAXNREST            THEN INCLUDE AN EXTRA STACK SLOT\n         LA    #0,4(,#6)            SET TOP-OF-STACK POINTER FOR ARGS\n         B     AFTNREST            ELSE INCLUDE FOR MAXARGS ONLY\nMAXNREST LA    #0,0(,#6)            SET TOP-OF-STACK POINTER FOR ARGS\nAFTNREST DS    0H\n         #ZPDS (0)                 ERROR IF NO ROOM ON STACK\n*\n* IF MAXARGS > MINARGS, FILL IN OPTIONAL ARG SLOTS WITH \"NOT SUPPLIED\"\n*\n* #5  -->  WHERE ADDITIONAL ARGS WOULD HAVE TO BE STACKED\n* #6  -->  WHERE TO STOP STACKING &OPTIONAL ARGS\n*\nOPTLOOP  DS    0H\n         CR    #5,#6\n         BNL   OPTEND\n         ST    #13,0(,#5)          FILL WITH \"UNSUPPLIED\" INDICATOR\n         LA    #5,4(,#5)\n         B     OPTLOOP\nOPTEND   DS    0H\n*\n* IF THERE IS A &REST ARG, CONS UP THE REMAINING ARGS AND DEPOSIT THE\n* POINTER TO THE LIST ON THE STACK.\n*\n* #5  -->  ANY REST ARGS ON THE STACK, PAST END OF OPTIONALS\n* #6  -->  WHERE TO STACK THE &REST ARGLIST\n*\n         TM    ZINFLAGS,ZINGREST\n         BZ    NOREST\n         LA    #0,4(,#5)           SET OUR OWN STACK POINTER FOR CONS\n         #ZPDS (0)                 ERROR IF NO ROOM ON STACK\n         LR    #15,#10             INITIALIZE &REST LIST TO NIL\nRESTLOOP DS    0H\n         ST    #15,0(,#5)          STORE WHAT WE HAVE SO FAR\n         SH    #5,=H'4'            BUMP DOWN ONE STACK SLOT\n         CR    #5,#6\n         BL    RESTEND             UNTIL BOTTOM OF REST ARGS\n         L     #1,0(,#5)           ARG 1 TO CONS = ARG FROM STACK\n         LR    #2,#15              ARG 2 TO CONS = LIST SO FAR\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         #BASR #14,#15             CALL CONS TO BUILD UP &REST LIST\n         B     RESTLOOP            CONTINUE\nRESTEND  DS    0H                  AT THIS POINT 0(#6) IS THE RESTLIST\n         SPACE 1\nNOREST   DS    0H\n         SPACE 1\n         NI    ZLCGCFLG,255-ZLCGCBLD RESET FLAG FOR CONS\n         SPACE 1\n         L     #14,ZLCFALST        GET CURRENT LEXICAL ALIST\n         ST    #14,8(,#11)         SAVE IT ON STACK\n         LTR   #4,#4               IF AN ALIST IS TO BE RESET,\n         BZ    NOALIST             THEN...\n         ST    #4,ZLCFALST          STORE ALIST FOR THIS EXECUTION\nNOALIST  DS    0H\n*                                  #2 IS NOT SET, SORRY\n         LR    #15,#3              LOAD UP SUBROUTINE ENTRY POINT\n         LA    #1,20(,#11)         POINT TO ARGUMENTS ON STACK\n         #BASR #14,#15             CALL THE SUBROUTINE\n         L     #14,8(,#11)         PICK UP SAVED ALIST FROM STACK\n         ST    #14,ZLCFALST        RESTORE SAVED LEXICAL ALIST\n*                                  RETURN VALUE IS IN REGISTER 15\nZRETURN  DS    0H                  RELOAD STACKED REGS AND RETURN\n         SPACE 1\n         LR    #1,#11\n         LM    #11,#12,0(#1)\n         L     #14,12(,#1)\n         BR    #14\n         EJECT\nLEXPR    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF THIS IS A COMPILED LEXPR, THEN WHAT WE DO IS THIS:               *\n*                                                                     *\n*  SHIFT ALL THE ARGS ON THE STACK UP BY 1 STACK SLOT (4 BYTES)       *\n*  AND STICK THE FIXNUM OBJECT REPRESENTING THE NUMBER OF ARGS        *\n*  INTO THE FIRST SLOT, WHICH WILL BE THE ARG TO THE LEXPR.           *\n*  THEN GO TO PASS CONTROL TO IT.                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    #6,20(,#11)         POINT TO FIRST ARG ON STACK\n         LA    #0,4(,#5)           POINT PAST LAST ARG ON STACK PLUS 4\n         #ZPDS (0)                 CHECK IF SPACE AVAILABLE, ERR IF NOT\n         XR    #2,#2               INITIALIZE ARG COUNT TO ZERO\nLARGLOOP DS    0H\n         SH    #5,=H'4'            BUMP DOWN ONE STACK SLOT\n         CR    #5,#6               UNTIL WE HIT BOTTOM\n         BL    ENDLARGS            AT WHICH POINT WE'RE READY TO GO\n         MVC   4(4,#5),0(#5)       BUMP ARG UP ONE STACK SLOT\n         BCT   #2,LARGLOOP         BUMP ARG COUNT, LOOP 4 ARGS ON STACK\nENDLARGS DS    0H                  (NOTE #0 ALREADY POINTS TO T.O.S.)\n         LCR   #2,#2               MAKE ARG COUNT POSITIVE\n         CH    #2,ZLCSFTHI         If within small fixnum range\n         BH    CONSFIX             then\n         LA    #15,#SFT(#2)         point to small fixnum in table\n         ST    #15,0(,#6)           STORE FIXNUM ON STACK AS FIRST ARG\n         B     NOREST               GO TO INVOKE FUNCTION\nCONSFIX  DS    0H                  Else have to cons up a new fixnum\n         #MKAT FIXED               MAKE A FIXNUM FROM ARG COUNT\n         ST    #15,0(,#6)          STORE FIXNUM ON STACK AS FIRST ARG\n         B     NOREST              GO TO INVOKE FUNCTION\n         EJECT\nTRYAPPLY DS    0H\n         SPACE 1\n         OI    ZLCGCFLG,ZLCGCBLD   TELL CONS WE'RE SETTING #0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* INVOKE ZILAPPLY TO EXECUTE FUNCTION INTERPRETIVELY.                 *\n*                                                                     *\n* (ZILAPPLY FUNC ARGS) WHERE FUNC IS AT 20(,#11) AND ARGS IS THE REST *\n* OF THE STACK ARGS LISTIFIED.                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    #5,20(#2,#11)       SET POINTER TO TOP OF STACK USED\n         LA    #6,20(,#11)         POINT TO BOTTOM OF ARGS\n         LA    #0,12(,#5)          RESERVE JUST ENOUGH STACK SIZE\n         #ZPDS (0)                 ERROR IF NO ROOM ON STACK\n         LR    #15,#10             INITIALIZE &REST LIST TO NIL\nARGSLOOP DS    0H\n         ST    #15,0(,#5)          STORE WHAT WE HAVE SO FAR\n         SH    #5,=H'4'            BUMP DOWN ONE STACK SLOT\n         CR    #5,#6\n         BL    ARGSEND             UNTIL BOTTOM OF REST ARGS\n         L     #1,0(,#5)           ARG 1 TO CONS = ARG FROM STACK\n         LR    #2,#15              ARG 2 TO CONS = LIST SO FAR\n         L     #15,ZLCCONS         GET ADDRESS OF CONS\n         #BASR #14,#15             CALL CONS TO BUILD UP &REST LIST\n         B     ARGSLOOP            CONTINUE\nARGSEND  DS    0H                  AT THIS POINT 0(#6) IS APPLY ARG 2\n         SPACE 1\n         NI    ZLCGCFLG,255-ZLCGCBLD RESET FLAG FOR CONS\n         SPACE 1\n         ST    #13,24(,#11)        SET ARG 3 TO ZILAPPLY = (UNSUPPLIED)\n         ST    #13,28(,#11)        SET ARG 4 TO ZILAPPLY = (UNSUPPLIED)\n         L     #15,@ZILAPPL        GET ADDRESS OF ZILAPPLY\n         LA    #1,16(,#11)         POINT TO ARGS ON STACK\n         #BASR #14,#15             CALL ZILAPPLY\n*\n* Note: The branch to ZRETURN that used to be here has been removed\n*       because it was a backward branch, which ZILVALS would interpret\n*       as an indication that multiple values were to be discarded.\n*\n         LR    #1,#11              RELOAD STACKED REGS AND RETURN\n         LM    #11,#12,0(#1)\n         L     #14,12(,#1)\n         BR    #14\n         EJECT\nBADFUNC  DS    0H                  ERROR - BAD FUNCTION\n         LA    #1,BADFSTR\n         LA    #2,BADFNAME\n         B     ERROR\nTOOFEW   DS    0H\n         LA    #1,FEWSTR\n         LA    #2,FEWNAME\n         B     ERROR\nTOOMANY  DS    0H\n         LA    #1,MANYSTR\n         LA    #2,MANYNAME\n******** B     ERROR\n         SPACE 1\nERROR    DS    0H\n         NI    ZLCGCFLG,255-ZLCGCBLD RESET FLAG FOR CONS\n         MVI   0(#2),C' '          CLEAR FUNCTION NAME TO BLANKS\n         MVC   1(NAMELEN-1,#2),0(#2)\n         XR    #15,#15             CLEAR INSERT REGISTER\n         IC    #15,4(,#3)          GET LENGTH OF MODULE IDENTIFIER\n         SH    #15,=H'16'          REDUCE BY LENGTH OF DATE/TIME INFO\n         BNP   NONAME              IF NO NAME, SKIP\n         CH    #15,=Y(NAMELEN)     NOT BLOODY LIKELY, BUT JUST IN CASE\n         BNH   *+8                  LIMIT TO (NAMELEN) CHARACTERS\n         LA    #15,NAMELEN\n         BCTR  #15,0               REDUCE FOR EXECUTE\n         EX    #15,MVCNAME         MOVE FUNCTION NAME TO MESSAGE\n         LA    #2,1(#15,#2)        POINT PAST FUNCTION NAME\nNONAME   DS    0H\n         MVI   0(#2),C'.'          MOVE IN A PERIOD\n         LA    #0,1(,#2)\n         SR    #0,#1               GET LENGTH OF MESSAGE\n         SH    #0,=H'4'            (END - START - PREFIX LENGTH)\n         STCM  #0,7,1(#1)          STORE LENGTH IN FAKE STRING\n         LR    #3,#1\n         #ERR  0(#3),PREFIX=NO     SIGNAL ERROR\n         SPACE 1\nMVCNAME  MVC   0(*-*,#2),5(#3)     EXECUTED: MOVE FUNCTION NAME TO MSG\n         SPACE 1\nSAVE2    DS    A                   REGISTER SAVE\n         SPACE 1\nNAMELEN  EQU   64                  MAX LENGTH OF FUNCTION NAME SHOWN\n         SPACE 2\n         DS    0H,XL1\nFEWSTR   DC    YL1(##STRING),AL3(FEWLEN)\nFEWMSG   DC    C'ZIL1401 Too few arguments passed by FUNCALL to '\nFEWNAME  DS    CL(NAMELEN+1)\nFEWLEN   EQU   *-FEWMSG\n         SPACE 1\n         DS    0H,XL1\nMANYSTR  DC    YL1(##STRING),AL3(MANYLEN)\nMANYMSG  DC    C'ZIL1402 Too many arguments passed by FUNCALL to '\nMANYNAME DS    CL(NAMELEN+1)\nMANYLEN  EQU   *-MANYMSG\n         SPACE 1\n         DS    0H,XL1\nBADFSTR  DC    YL1(##STRING),AL3(BADFLEN)\nBADFMSG  DC    C'ZIL1403 Attempt to FUNCALL invalid ZIL function '\nBADFNAME DS    CL(NAMELEN+1)\nBADFLEN  EQU   *-BADFMSG\n         SPACE 2\nZILSUBRS DS    0A\n@ZILAPPL DC    V(ZILAPPLY)         ADDRESS OF SUBROUTINE\n         DC    CL8'ZILAPPLY'\nZILSUBRE EQU   *\n         SPACE 2\nZILATOMS DS    0A\nASUBR    DC    A(SUBR-ZILXFUN)     ADDRESS OF ATOM SUBR\nZILATOME EQU   *\nZILLISTS EQU   *\nZILLISTE EQU   *\n         SPACE 2\nSUBR     #AATM 'SUBR'\n         SPACE 2\n         LTORG\n         SPACE 2\n         #ZINT ,\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILXLFY": {"ttr": 17926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x17\\x00\\x88\\x01_\\x01\\x00&_\\x17&\\x00n\\x00k\\x00m\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:26:17", "lines": 110, "newlines": 107, "modlines": 109, "user": "SEB1525"}, "text": "         TITLE 'ZILXLFY - ZIL 1.3 LISTIFY PROCESSOR FOR COMPILED CODE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  THIS MODULE IS INVOKED FROM COMPILED CODE TO IMPLEMENT THE         *\n*  \"LISTIFY\" SPECIAL FORM.                                            *\n*                                                                     *\n*  ON ENTRY TO THIS FUNCTION:                                         *\n*                                                                     *\n*  #0 = THE CURRENT TOP-OF-STACK POINTER FOR CONS                     *\n*  #1 = THE ARG TO LISTIFY (MUST BE NIL OR A FIXNUM)                  *\n*                                                                     *\n*  THIS FUNCTION RETURNS A LIST MADE UP OF ARGS FROM THE STACK THAT   *\n*  WERE PASSED TO THE CALLING LEXPR.                                  *\n*                                                                     *\n*  ARG = NIL - CONS UP ALL THE LEXPR ARGS ON THE STACK.               *\n*  ARG > 0   - CONS UP THE FIRST (ARG) ARGS ON THE STACK.             *\n*  ARG < 0   - CONS UP THE LAST (ARG) ARGS ON THE STACK.              *\n*  ARG = 0   - NIL (OF COURSE!).                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILXLFY  #ZBEG NAME='ZILXLFY'\n         SPACE 1\n         ST    #12,SAVE12          SAVE REGISTERS\n         ST    #14,SAVE14\n         LR    #12,#15\n         DROP  #15\n         USING ZILXLFY,#12\n         SPACE 1\n         OI    ZLCGCFLG,ZLCGCBLD   TELL GC OUR #0 IS GOOD\n         SPACE 1\n         LR    #4,#11              GET CURRENT STACK PTR (END OF ARGS)\n         L     #3,0(,#11)          GET POINTER TO BOTTOM OF LEXPR STACK\n         LA    #3,4(,#3)           POINT PAST LEXPR ARG TO STACK ARGS\n         SPACE 1\n         CR    #1,#10              IF ARG TO LISTIFY IS NIL\n         BE    PROCESS             THEN GO CONS UP ALL THE ARGS\n         CLI   ##TYPE(#1),##FIXNUM ELSE ARG MUST BE A FIXNUM\n         BNE   ERROR               IN WHICH CASE\n         L     #1,##CDR(,#1)       GET ITS NUMERIC VALUE\n         SPACE 1\n         LR    #15,#4              GET LENGTH OF STACK AREA WITH ARGS\n         SR    #15,#3\n         SRL   #15,#2              GET THE # OF ARGS PASSED TO LEXPR\n         LTR   #1,#1               CHECK SIGN OF ARG\n         BM    NEG                 IF NEGATIVE, PROCESS NEGATIVE\n         BP    POS                 IF POSITIVE, PROCESS POSITIVE\n         LR    #15,#10             ELSE (LISTIFY 0) ==> NULL LIST\n         B     RETURN              AND RETURN WITH NIL\n         SPACE 1\nPOS      DS    0H                  (LISTIFY N), N > 0\n         SPACE 1\n         CR    #1,#15              IF ARG GREATER THAN TRUE # OF ARGS\n         BNH   *+6                 THEN\n         LR    #1,#15               RESET ARG TO MAX # OF ARGS\n*                                  #3 REMAINS THE SAME.\n         SLL   #1,2                CONVERT TO SIZE OF STACK SLOT\n         LA    #4,0(#1,#3)         SET NEW POINTER TO END OF ARGS\n         B     PROCESS             GO CONS 'EM UP\n         SPACE 1\nNEG      DS    0H                  (LISTIFY N), N < 0\n         SPACE 1\n         LPR   #1,#1               CONVERT TO POSITIVE VALUE\n         CR    #1,#15              IF ARG GREATER THAN TRUE # OF ARGS\n         BNH   *+6                 THEN\n         LR    #1,#15               RESET ARG TO MAX # OF ARGS\n*                                  #4 REMAINS THE SAME.\n         SLL   #1,2                CONVERT TO SIZE OF STACK SLOT\n         LR    #3,#4               SET NEW POINTER TO START OF ARGS\n         SR    #3,#1\n******** B     PROCESS             GO CONS 'EM UP\n         SPACE 1\nPROCESS  DS    0H                  OK, DO IT\n         SPACE 1\n*                                  #3 --> START OF ARGS TO CONS UP\n*                                  #4 --> END OF ARGS TO CONS UP\n         LR    #6,#4               INITIALIZE PTR INTO STACK FOR ARGS\n         LR    #15,#10             INITIALIZE RETURNED LIST TO NIL\nLOOP     DS    0H\n         SH    #6,=H'4'            LOOP DOWN UNTIL NO MORE ARGS\n         CR    #6,#3                AT WHICH POINT\n         BL    RETURN                RETURN WITH WHAT WE'VE GOT\n         L     #1,0(,#6)           ARG 1 TO CONS = ARG FROM STACK\n         LR    #2,#15              ARG 2 TO CONS = LIST SO FAR\n         L     #15,ZLCCONS         GET ADDRESS OF ZILCONS\n         #BASR #14,#15             CALL CONS TO ADD ARG TO LIST\n         B     LOOP                CONTINUE LOOPING\n         SPACE 1\nRETURN   DS    0H                  RETURN VALUE IS IN #15\n         SPACE 1\n         NI    ZLCGCFLG,255-ZLCGCBLD RESTORE GC FLAG\n         SPACE 1\n         L     #14,SAVE14\n         L     #12,SAVE12          RESTORE REGISTERS\n         BR    #14                 RETURN\n         SPACE 1\nERROR    DS    0H                  INVALID ARG\n         LR    #2,#1\n         #ERR  'Argument to LISTIFY not a fixnum or NIL - ',(#2)\n         SPACE 1\nSAVE12   DS    A\nSAVE14   DS    A\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZILXSUB": {"ttr": 17929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x00\\xf5\\x00\\xf2\\x00\\xf4\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 245, "newlines": 242, "modlines": 244, "user": "SEB1525"}, "text": "         TITLE 'ZILXSUB - ZIL 1.3 SUBROUTINE EXECUTOR'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS USED BY EVAL AND APPLY TO EXECUTE SUBRS AND CLOSURES.*\n* PARAMETERS ARE AS FOLLOWS:                                          *\n*                                                                     *\n* PARAMETER 1 IS THE ENTRY POINT OBJECT (GET XXX 'SUBR).              *\n* PARAMETER 2 IS THE LIST OF (EVALUATED) ARGUMENTS.                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZILXSUB  #ZBEG MINARGS=2,MAXARGS=2,NAME='ZILXSUB'\n         SPACE ,\n         #ZPDS 24                  RESERVE INITIAL MINIMAL STACK SPACE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 3\n*\n* PICK UP THE ARGUMENTS\n*\n         LM    #1,#2,0(#11)        PICK UP ARGS\n*                                    #1 = ENTRY POINT TO CALL\n*                                    #2 = ARGUMENT LIST\n*----------------------------------------------------------------------\n*--- SUPPORT FOR (ZILXSUB NIL ...) REMOVED - IT IS NOT NECESSARY. -----\n*----------------------------------------------------------------------\n*------- CR    #1,#10              IF ENTRY = NIL\n*------- BNE   NOTNIL              THEN\n*------- LR    #15,#10              SET RETURN TO NIL\n*------- B     ZRETURN              AND DO NOTHING.\nNOTNIL   DS    0H\n*----------------------------------------------------------------------\n         TM    ##TYPE(#1),##CODE   ARG 1 MUST BE A COMPILED CODE OBJECT\n         BNO   ERR3048             ELSE ERROR\nOK       DS    0H\n*\n* EXTRACT MINIMUM AND MAXIMUM NUMBER OF ARGS FOR THIS FUNCTION\n*\n         XR    #3,#3               CLEAR INSERT REGISTER\n         XR    #6,#6               CLEAR INSERT REGISTER\n         XR    #7,#7               CLEAR INSERT REGISTER\n         ICM   #3,7,##CAR+1(#1)    GET POINTER TO COMPILED CODE\n         IC    #6,4(,#3)           GET LENGTH OF MODULE IDENTIFIER\n         LA    #15,5+3(#6,#3)      POINT PAST MODULE IDENTIFIER\n         N     #15,=X'FFFFFFFC'    ROUNDING UP TO NEXT FULLWORD\n         USING ZINT,#15            ADDRESS THE \"ZINT\" AREA IN MODULE\n         TM    ZINFLAG2,ZINGLEXP   IF THIS IS A COMPILED LEXPR\n         BO    LEXPR               THEN GO TO PROCESS IT AS A LEXPR\n         IC    #6,ZINMINAR         GET MINIMUM NUMBER OF ARGUMENTS\n         IC    #7,ZINMAXAR         GET MAXIMUM NUMBER OF ARGUMENTS\n         CR    #6,#7               IF MINIMUM > MAXIMUM\n         BH    BADFUNC             THEN ERROR - BAD FUNCTION\n         LR    #3,#7               CONVERT TO INDEX INTO STACK\n         TM    ZINFLAG2,ZINGREST   IF A &REST ARG IS EXPECTED,\n         BZ    NOREST              THEN...\n         LA    #3,1(,#3)            ADD ONE MORE FOR IT.\nNOREST   DS    0H                  SET ARG COUNT TO MAXARGS INITIALLY\n         SLA   #3,2                ARGS * 4 = STACK SIZE NEEDED\n         LA    #0,24(#3,#11)       POINT TO NEW STACK LOCATION\n         #ZPDS (0)                 CHECK IF SIZE IS AVAILABLE\n         LA    #5,24(,#11)         POINT TO WHERE TO START STACKING\nSTKLOOP  DS    0H\n         CR    #2,#10              IF AT END OF LIST OF ARGS\n         BE    STKOUT              THEN OUT OF ARGUMENTS\n         LTR   #7,#7               BUT IF MORE ARGS THAN MAX ARGS\n         BZ    EXTRARGS            THEN CHECK FOR A &REST ARG\n         L     #4,##CAR(,#2)       GET ARGUMENT FROM LIST OF ARGS\n         ST    #4,0(,#5)           STORE ONTO STACK\n         LA    #5,4(,#5)           BUMP STACK LOCATION\n         L     #2,##CDR(,#2)       GO TO NEXT ARG IN LIST\n         BCTR  #6,0                DECREMENT MIN ARG COUNT\n         BCTR  #7,0                DECREMENT MAX ARG COUNT\n         B     STKLOOP             AND CONTINUE COUNTING DOWN LIST\nEXTRARGS DS    0H                  MAX ARGS EXCEEDED AND STILL GOT SOME\n         TM    ZINFLAG2,ZINGREST   IF THERE'S A &REST ARG\n         BO    SETREST             THEN SET IT\n         XR    #3,#3               ELSE CLEAR INSERT REGISTER\n         ICM   #3,7,##CAR+1(#1)    ERROR - TOO MANY ARGS\n         LA    #1,MANYSTR\n         LA    #2,MANYNAME\n         LA    #5,MANYMSG\n         XR    #4,#4\n         IC    #4,ZINMAXAR\n         B     ERROR\nSTKOUT   DS    0H                  UNTIL MAX USED UP OR NO MORE ARGS\n         LTR   #6,#6               IF FEWER ARGS THAN MIN ARGS\n         BP    TOOFEW              THEN ERROR\n         LTR   #7,#7               IF DOWN TO MAX\n         BZ    NOARGS              THEN FINISHED SETTING UP ARGS\nSTNILLP  ST    #13,0(,#5)          ELSE STORE (UNSUPPLIED) INTO ARG STK\n         LA    #5,4(,#5)           BUMP STACK LOCATION\n         BCT   #7,STNILLP          CONTINUE UNTIL MAX ARGS USED UP\nNOARGS   DS    0H\n         TM    ZINFLAG2,ZINGREST   IF THERE'S A &REST ARG\n         BZ    NOREST2             THEN SET IT\nSETREST  DS    0H\n         ST    #2,0(,#5)           SET IT TO THE REMAINING ARG LIST\nNOREST2  DS    0H\n         L     #14,ZLCFALST        GET CURRENT FLUID ALIST\n         ST    #14,20(,#11)        SAVE IT ON STACK\n         TM    ##TYPE(#1),##CLOS   IF THIS IS A CLOSURE\n         BZ    NOALIST             THEN\n         ICM   #0,15,##CDR(#1)      GET ALIST POINTER FROM CLOSURE\n         BZ    NOALIST              IF NONE, TREAT LIKE NORMAL SUBR\n         ST    #0,ZLCFALST         STORE FLUID ALIST FOR THIS EXECUTION\nNOALIST  DS    0H\n         DROP  #15\n         XR    #15,#15             CLEAR INSERT REGISTER\n         ICM   #15,7,##CAR+1(#1)   LOAD UP SUBROUTINE ENTRY POINT\n         LA    #1,24(,#11)         POINT TO ARGUMENTS ON STACK\n         #BASR #14,#15             CALL THE SUBROUTINE\n         L     #14,20(,#11)        PICK UP SAVED FLUID ALIST FROM STACK\n         ST    #14,ZLCFALST        RESTORE SAVED FLUID ALIST\n*                                  RETURN VALUE IS IN REGISTER 15\nZRETURN  DS    0H\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 2\nERR3048  DS    0H\n         #ERR  'Argument 1 to ZILXSUB not a compiled code object (SUBR X\n               or closure) - ',0(#11)\n         EJECT\nLEXPR    DS    0H\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* IF THIS IS A COMPILED CODE LEXPR, THIS IS WHAT WE DO:               *\n*                                                                     *\n*  PUT ARGS ON STACK AS FOLLOWS:                                      *\n*                                                                     *\n*    MAKE A FIXNUM OBJECT FROM THE NUMBER OF ARGS PASSED              *\n*    PLACE THE ARGS ON THE STACK FOLLOWING THE FIXNUM OBJECT          *\n*                                                                     *\n*  THE NUMBER OF STACK SLOTS REQUIRED = THE NUMBER OF ARGS + 1.       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LA    #5,28(,#11)         POINT TO WHERE TO START PUTTING ARGS\n         LR    #0,#5               CHECK THAT WE HAVE AT LEAST ENOUGH\n         #ZPDS (0)                 STACK SPACE FOR THE LEXPR FIXNUM ARG\n         XR    #3,#3               INITIALIZE ARG COUNT TO ZERO\nLARGLOOP DS    0H\n         CR    #2,#10              GO THRU LIST OF ARGS UNTIL END\n         BE    ENDLARGS\n         LA    #0,4(,#5)           CHECK THAT WE HAVE AT LEAST ENOUGH\n         #ZPDS (0)                 STACK SPACE FOR ONE MORE ARG\n         LM    #1,#2,##CAR(#2)     GET #1 = ARG OFF THE ARG LIST\n*                                  GET #2 = NEXT ARG IN LIST\n         ST    #1,0(,#5)           STORE IT ON THE STACK\n         LA    #5,4(,#5)           BUMP STACK POINTER\n         BCT   #3,LARGLOOP         DECREMENT ARG COUNT AND CONTINUE\nENDLARGS DS    0H\n         LCR   #2,#3               GET POSITIVE ARG COUNT\n         CH    #2,ZLCSFTHI         If within small fixnum range\n         BNH   SMALLFIX            then go use fixnum from table\n         OI    ZLCGCFLG,ZLCGCBLD   Else TELL GC THAT WE'RE PROVIDING #0\n         #MKAT FIXED               MAKE A FIXNUM OUT OF ARG COUNT\n         NI    ZLCGCFLG,252-ZLCGCBLD  RESTORE GC BIT\n         B     AFTFIX\nSMALLFIX DS    0H                  Small fixnum arg count\n         LA    #15,#SFT(#2)        Get fixnum from small fixnum table\nAFTFIX   DS    0H\n         ST    #15,24(,#11)        STORE IT AS THE ARG TO THE LEXPR\n         LA    #3,1(,#2)           GET ARG COUNT PLUS 1\n         SLA   #3,2                CONVERT TO # OF STACK SLOTS PASSED\n         L     #1,0(,#11)          RELOAD ARG 1 FROM STACK\n         B     NOREST2             GO TO PASS CONTROL TO CODE\n         EJECT\nBADFUNC  DS    0H                  BAD FUNCTION\n*\n* AT SOME TIME IN THE FUTURE THIS MIGHT CONCEIVABLY DENOTE AN FSUBR,\n* MSUBR OR SOME SUCH MONSTROSITY.  HOWEVER, WE ARE CURRENTLY USING IT\n* TO DENOTE A FUNCTION WHICH SHOULD NOT BE BEING CALLED FROM A LISP\n* ENVIRONMENT DIRECTLY, SUCH AS THE ZIL____ SERIES OF INTERNAL ROUTINES\n*\n         XR    #3,#3\n         ICM   #3,7,##CAR+1(#1)    ERROR - BAD FUNCTION\n         LA    #1,BADFSTR\n         LA    #2,BADFNAME\n         XR    #5,#5\n         B     ERROR\nTOOFEW   DS    0H\n         XR    #3,#3\n         ICM   #3,7,##CAR+1(#1)    ERROR - TOO FEW ARGS\n         LA    #1,FEWSTR\n         LA    #2,FEWNAME\n         LA    #5,FEWMSG\n         XR    #4,#4\n         IC    #4,ZINMINAR-ZINT(,#15)\n******** B     ERROR\n         SPACE 1\nERROR    DS    0H\n         MVI   0(#2),C' '          CLEAR FUNCTION NAME TO BLANKS\n         MVC   1(NAMELEN-1,#2),0(#2)\n         XR    #15,#15             CLEAR INSERT REGISTER\n         IC    #15,4(,#3)          GET LENGTH OF MODULE IDENTIFIER\n         SH    #15,=H'16'          REDUCE BY LENGTH OF DATE/TIME INFO\n         BNP   NONAME              IF NO NAME, SKIP\n         CH    #15,=Y(NAMELEN)     NOT BLOODY LIKELY, BUT JUST IN CASE\n         BNH   *+8                  LIMIT TO (NAMELEN) CHARACTERS\n         LA    #15,NAMELEN\n         BCTR  #15,0               REDUCE FOR EXECUTE\n         EX    #15,MVCNAME         MOVE FUNCTION NAME TO MESSAGE\n         LA    #2,1(#15,#2)        POINT PAST FUNCTION NAME\nNONAME   DS    0H\n         MVI   0(#2),C'.'          MOVE IN A PERIOD\n         LA    #0,1(,#2)\n         SR    #0,#1               GET LENGTH OF MESSAGE\n         SH    #0,=H'4'            (END - START - PREFIX LENGTH)\n         STCM  #0,7,1(#1)          STORE LENGTH IN FAKE STRING\n         LR    #2,#1               Get address of fake string\n         LPR   #5,#5               If this is an \"invalid fun\" msg\n         BZ    BADFUNER            then display that message\n         #ERR  0(#5),#4,MSG2,0(#2),PREFIX=NO\n         SPACE 1\nBADFUNER #ERR  BADFSTR,PREFIX=NO\n         SPACE 1\nMVCNAME  MVC   0(*-*,#2),5(#3)     EXECUTED: MOVE FUNCTION NAME TO MSG\n         SPACE 2\nNAMELEN  EQU   64                  MAX LENGTH OF FUNCTION NAME SHOWN\n         SPACE 2\n         DS    0H,XL1\nFEWMSG   #SATM 'ZIL1301 Too few arguments (< '\n         DS    0H,XL1\nMANYMSG  #SATM 'ZIL1302 Too many arguments (> '\n         DS    0H,XL1\nMSG2     #SATM ') to function '\n         DS    0H,XL1\nFEWSTR   DC    YL1(##STRING),AL3(0)\nFEWNAME  DS    CL(NAMELEN+1)\n         DS    0H,XL1\nMANYSTR  DC    YL1(##STRING),AL3(0)\nMANYNAME DS    CL(NAMELEN+1)\n         DS    0H,XL1\nBADFSTR  DC    YL1(##STRING),AL3(0)\nBADFMSG  DC    C'ZIL1303 Attempt to execute invalid ZIL function '\nBADFNAME DS    CL(NAMELEN+1)\n         SPACE 2\n         LTORG\n         SPACE 2\n         #ZINT ,\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZISEXEC": {"ttr": 18177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x88&\\x0f\\x00\\x89\\x15o\\x11U\\x00\\xdb\\x00\\xc2\\x00\\xda\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-09-16T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 219, "newlines": 194, "modlines": 218, "user": "SEB1525"}, "text": "         TITLE 'ZISEXEC - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n* ZISEXEC TAKES AN &REST ARG - LIST OF ATOMS TO BE CONCATENATED INTO  *\n* A SINGLE CHARACTER STRING, WHICH IS THEN INVOKED AS AN ISPF DIALOG  *\n* SERVICE CALL.                                                       *\n*                                                                     *\n* ZISEXEC RETURNS A FIXNUM CONTAINING THE RETURN CODE AS RETURNED BY  *\n* ISPEXEC/ISPLINK.                                                    *\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO EXTRA STACK SPACE.        *\n***********************************************************************\n*                                                                     *\n* ZILADMP IS CALLED TO DUMP EACH ATOM IN THE LIST INTO OUR WORK AREA. *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Change activity:                                                    *\n*                                                                     *\n* 09/16/88 - Automatic uppercasing of command buffer is not done if   *\n*            this is a SELECT service request.                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nZISEXEC  #ZBEG MINARGS=0,MAXARGS=0,RESTARG=T,NAME='ZISEXEC'\n         #ZPDS 16                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         L     #6,0(,#11)          GET &REST ARGUMENT\n         XR    #5,#5               INIT LENGTH REQUIRED SO FAR\nLOOP     DS    0H\n         CR    #6,#10              IF END OF LIST OR NULL LIST\n         BE    NOMORE              THEN END LOOP\n         L     #2,##CAR(,#6)       GET ATOM (ARG 1 TO ZISEXEC)\n         TM    ##TYPE(#2),##ATOM   IF IT'S NOT AN ATOM\n         BZ    BADLIST             THEN ERROR\n         TM    ##TYPE(#2),##VEC    IF IT'S SOME KIND OF VECTOR\n         BO    BADLIST             THEN ERROR\n         L     #15,ZLCADMP         GET ADDRESS OF ZILADMP\n         LR    #1,#10              SET #1 FOR ZILADMP\n         #BASR #14,#15             CALL ZILADMP TO DUMP ATOM\n         LR    #7,#1               SAVE ADDRESS OF DUMPED ATOM\n         LTR   #4,#0               GET LENGTH OF DUMPED ATOM\n         BNP   AFTMOVE             IF ZERO LENGTH, SKIP THIS ONE\n         AR    #0,#5               GET DUMPED-ATOM LENGTH PLUS TOTAL\n         C     #0,ZLCWALEN         IF EXCEEDS CURRENT WORKAREA LENGTH\n         BNH   LENOK               THEN...\n*\n* (1) GETMAIN A NEW WORKAREA WHOSE SIZE IS >= #0.\n* (2) COPY CONTENTS OF OLD WORKAREA TO THE NEW WORKAREA, LENGTH = #5.\n* (3) FREEMAIN THE OLD WORKAREA.\n*\n* #0 = TOTAL LENGTH NEEDED SO FAR, INCLUDING DUMPED-BUT-NOT-ADDED-YET\n* #1 = NOT IN USE\n* #2 = NOT IN USE, WILL CONTAIN NEW WORK AREA LENGTH\n* #3 = NOT IN USE, WILL CONTAIN NEW WORK AREA ADDRESS\n* #4 = LENGTH OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON\n* #5 = TOTAL LENGTH DUMPED SO FAR, NOT INCLUDING THIS STUFF\n* #6 = ADDRESS OF THE SUBLIST CURRENTLY BEING PROCESSED\n* #7 = ADDRESS OF DUMPED ATOM TEXT THAT WE WANT TO ADD ON\n*\n         LR    #2,#0                SAVE LENGTH TO BE NEEDED\n         LA    #2,7(,#2)            GET A LARGER WORK AREA\n         N     #2,=X'FFFFFFF8'      ROUNDED UP TO MULTIPLE OF 8\n         LR    #0,#2                SAVE THE NEW WORK AREA LENGTH\n         #GETMAIN RC,LV=(0),LOC=BELOW GET A NEW WORK AREA\n         LTR   #15,#15              IF GETMAIN FAILED\n         BNZ   ERROR3               THEN ERROR - NOT ENOUGH STORAGE\n         LR    #3,#1                SAVE NEW WORKAREA ADDRESS\n         ICM   #14,15,ZLCWA         #14 = ADDRESS OF OLD AREA\n         BZ    NOFREE               IF NONE, THEN SKIP MOVE & FREE\n         LR    #0,#3                #0 = ADDRESS OF NEW AREA\n         LR    #1,#5                #1 = LENGTH OF DUMPED TEXT\n         LR    #15,#1               #15 = LENGTH OF DUMPED TEXT\n         MVCL  #0,#14               COPY DATA FROM OLD AREA TO NEW AREA\n         L     #1,ZLCWA             GET CURRENT WORK AREA ADDRESS\n         L     #0,ZLCWALEN          GET CURRENT WORK AREA LENGTH\n         FREEMAIN R,LV=(0),A=(1)    FREE THE OLD WORK AREA\nNOFREE   DS    0H\n         ST    #3,ZLCWA             SET NEW ZIL WORKAREA ADDRESS\n         ST    #2,ZLCWALEN          SET NEW ZIL WORKAREA LENGTH\n         SPACE 1\nLENOK    DS    0H                  OTHERWISE - STILL ROOM\n         L     #0,ZLCWA            WORKAREA ADDRESS + WORK AREA LENGTH\n         AR    #0,#5               POINTS TO WHERE TO MOVE DUMPED ATOM\n         LR    #1,#4               SOURCE LENGTH = DUMPED ATOM LENGTH\n         LR    #15,#1              TARGET LENGTH = DUMPED ATOM LENGTH\n         LR    #14,#7              SOURCE ADDRESS = WHERE DUMPED ATOM\n         MVCL  #0,#14              MOVE DUMPED ATOM TO WORK AREA\n         AR    #5,#4               INCREMENT TOTAL LENGTH SO FAR\nAFTMOVE  DS    0H\n         L     #6,##CDR(,#6)       GET REST OF LIST\n         B     LOOP                CONTINUE.\nNOMORE   DS    0H                  LIST HAS BEEN PROCESSED\n         SPACE 1\n*\n* Translate the entire buffer to upper case\n*\n* This is skipped for a SELECT service request, since the SELECT\n* service doesn't require uppercase keywords and often the contents\n* are desired to be lowercase.  Other services fail if lowercase\n* keywords are present.\n*\n* For simplicity, we check only that the first 6 characters of the\n* buffer are \"SELECT\".  Too bad if you have trailing blanks.\n*\n* ZLCWA -> the dialog service string\n* #5 = length thereof\n*\n         CH    #5,=Y(L'$SELECT)    If too short to be SELECT\n         BL    NOTSEL              then it's not a SELECT call. Else\n         L     #1,ZLCWA            Get address of string\n         MVC   SELTEST,0(#1)       Move beginning to testing area\n         TR    SELTEST,UPTBL       Fold to uppercase\n         CLC   SELTEST,$SELECT     If string starts with SELECT\n         BE    DONTFOLD            then skip translation.  Else...\nNOTSEL   DS    0H                  It's not a SELECT service call...\n         L     #1,ZLCWA\n         LR    #2,#5\n         LA    #0,256\nTRLOOP   DS    0H\n         CR    #2,#0\n         BNH   TR1\n         TR    0(256,#1),UPTBL\n         AR    #1,#0\n         SR    #2,#0\n         B     TRLOOP\nTR1      DS    0H\n         BCTR  #2,0\n         EX    #2,EXTR\nDONTFOLD DS    0H                  It's translated if it should've been\n*\n* SET UP PARAMETER LIST FOR ISPEX\n*\n         ST    #5,BUFLEN           STORE PARM LENGTH\n         LA    #1,BUFLEN           GET ADDRESS OF COMMAND WORK AREA\n         ST    #1,PARM1            SET PARAMETER LIST POINTER\n         L     #1,ZLCWA            GET ADDRESS OF COMMAND WORK AREA\n         ST    #1,PARM2            SET PARAMETER LIST POINTER\n         OI    PARM2,X'80'         SET VL BIT\n*\n* Get ISPEX\n*\n         ICM   #15,15,@ISPEX       Get address of ISPEX\n         BNZ   EXOK                If not loaded, then\n         LOAD  EPLOC==CL8'ISPEX',ERRET=NOSPF\n         ST    #0,@ISPEX           Save entry point\n         LR    #15,#0              Get entry point\nEXOK     DS    0H\n*\n* INVOKE THE DIALOG SERVICE VIA ISPEX\n*\n         ST    #9,ZLCISV09         Save #9 in case of interrupt\n         LA    #1,PARMS            POINT TO PARAMETER LIST FOR ISPEX\n         OI    ZLCIFLGS,ZLCISYS    Indicate non-ZIL code running\n         #BASR #14,#15             Call ISPEX\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         NI    ZLCIFLGS,255-ZLCISYS Indicate ZIL code running again\n*\n* CONVERT THE RETURN CODE FROM THE COMMAND INTO A FIXNUM\n*\n         LR    #2,#15              GET RETURN CODE INTO REG FOR FIXNUM\n         LA    #0,16(,#11)         PASS CURRENT STACK LOCATION TO CONS\n         #MKAT FIXED               USING CONTENTS OF #15, MAKE FIXNUM\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nEXTR     TR    0(*-*,#1),UPTBL\n         SPACE 1\n@ISPEX   DC    A(0)                Address of ISPEX (aka ISPEXEC)\n         SPACE 1\nPARMS    DS    0A\nPARM1    DS    A                   BUFFER LENGTH\nPARM2    DS    A                   BUFFER ADDRESS\nBUFLEN   DC    F'0'\n         SPACE 1\n$SELECT  DC    C'SELECT '\nSELTEST  DS    CL(L'$SELECT)\n         SPACE 1\nUPTBL    DC    256YL1(*-UPTBL)\n         ORG   UPTBL+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         SPACE 1\nNOSPF    DS    0H                  HERE IF LINK FAILS\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2121 ISPF dialog services not available, module ISPEX\n               X not found in ZIL library - ',                         X\n               0(#11)              (try to print out list of strings)\n         SPACE 1\nBADLIST  DS    0H\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2122 ZISEXEC: Cannot convert argument to string - ',X\n               (#2),                                                   X\n               X'0D',              carriage return                     X\n               '(it''s a list, vector, funarg, or structure).'\n         SPACE 1\nERROR3   DS    0H                  ERROR - NOT ENOUGH STORAGE\n         XR    #0,#0               CLEAR WORK AREA ADDRESS AND LENGTH\n         ST    #0,ZLCWA\n         ST    #0,ZLCWALEN\n         #ERR  PREFIX=NO,                                              X\n               'ZIL2123 ZISEXEC: Not enough memory to build ISPF dialogX\n                service call string',                                  X\n               0(#11)              (try to print out list of strings)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZISGET": {"ttr": 18181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x00s\\x00p\\x00r\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 115, "newlines": 112, "modlines": 114, "user": "SEB1525"}, "text": "         TITLE 'ZISGET - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (ZISGET 'foo) or (ZISGET \"foo\") returns the value of the ISPF       *\n* dialog variable FOO.  It uses the same variable search as the       *\n* VCOPY service, which it invokes.  The value is returned as a        *\n* LISP string.                                                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nZISGET   #ZBEG MINARGS=1,MAXARGS=1,NAME='ZISGET'\n         #ZPDS 1*4+12+0 = 16       DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         L     #2,0(,#11)          Get arg 1\n         CLI   ##TYPE(#2),##STRING OK if string\n         BE    A1TYPOK\n         CLI   ##TYPE(#2),##SYMBOL If symbol,\n         BNE   ERROR1               then use print name\n         L     #2,##PNAME(,#2)\nA1TYPOK  DS    0H\n         XR    #3,#3\n         ICM   #3,B'0111',1(#2)    Get string length\n         BZ    ERROR1              If null string, invalid variable nm\n         CH    #3,=H'8'            If longer than 8 characters,\n         BH    ERROR1              then invalid variable name\n         MVC   VARNAME,=CL8' '\n         BCTR  #3,0\n         EX    #3,MVCVAR           Move variable name, folding to up.c.\n*\n* Get ISPLINK\n*\n         ICM   #15,15,@ISPLINK     Get address of ISPLINK\n         BNZ   LOADED              If not loaded, then\n         LOAD  EPLOC==CL8'ISPLINK',ERRET=NOSPF\n         ST    #0,@ISPLINK         Save entry point\n         LR    #15,#0              Get entry point\nLOADED   DS    0H\n*\n* INVOKE THE DIALOG SERVICE VIA ISPEX\n*\n         ST    #9,ZLCISV09         Save #9 in case of interrupt\n         LA    #1,PARMS            POINT TO PARAMETER LIST FOR ISPLINK\n         OI    ZLCIFLGS,ZLCISYS    Indicate non-ZIL code running\n         #BASR #14,#15             Call ISPLINK\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         NI    ZLCIFLGS,255-ZLCISYS Indicate ZIL code running again\n*\n* If CONTROL ERRORS RETURN is in effect, and the return code is higher\n* than 8, then we assume variable-not-found condition.\n* We should really handle this better - like set ZERRMSG???\n*\n         CH    #15,=H'20'\n         BE    VERROR\n         LTR   #15,#15\n         BNZ   NOTFOUND\n         SPACE 1\n         L     #5,LENGTHS          Get length of returned value\n         L     #6,VALUES           Get address of returned value\n         LR    #2,#5               Set length of string to create\n         XR    #1,#1               Entry code 0 = allocate new space\n         L     #15,ZLCVSS          Get address of string space service\n         LA    #0,16(,#11)         Set current stack pointer\n         #BASR #14,#15             Call ZILVSS to build string\n         LTR   #4,#4               If ZILVSS failed,\n         BZ    NOROOM              then error\n         LR    #7,#5               Else get length of value\n         MVCL  #4,#6               Move value into string data\n         B     RETURN              Return with string ptr in #15\n         SPACE 1\nNOTFOUND DS    0H                  Variable requested not found\n         SPACE 1\n         LA    #15,NULLSTR         Return a null string\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nMVCVAR   OC    VARNAME(*-*),##VECDAT(#2)\n         SPACE 1\n@ISPLINK DC    A(0)                Address of ISPLINK\n         SPACE 1\nPARMS    DS    0A\nPARM1    DC    A($VCOPY)           Address of 'VCOPY'\nPARM2    DC    A(NAMELIST)         Address of variable name list\nPARM3    DC    A(LENGTHS)          Address of length(s)\nPARM4    DC    A(VALUES)           Address of value(s)\nPARM5    DC    A($LOCATE+X'80000000') Addr of 'LOCATE' parm\n         SPACE 1\n$VCOPY   DC    CL8'VCOPY'          Dialog service name\n$LOCATE  DC    C'LOCATE '          Dialog service parameter\nNAMELIST DC    C'('                Start of name list\nVARNAME  DC    CL8' '              Variable name\n         DC    C')'                End of name list\nLENGTHS  DS    F                   Length of returned value\nVALUES   DS    A                   Address of returned value\n         SPACE 1\nNULLSTR  DC    YL1(##STRING),AL3(0),XL4'00'  String \"\"\n         SPACE 1\nERROR1   #ERR  'Argument to ZISGET not a valid ISPF variable name - ', X\n               0(#11)\nNOSPF    #ERR  'ZISGET failed, ISPF dialog services not available.'\nVERROR   #ERR  'ZISGET failed, ISPF dialog error doing VCOPY.'\nNOROOM   #ERR  'ZISGET failed, not enough vector/string space to returnX\n                variable value.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZISPUT": {"ttr": 18184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x00z\\x00w\\x00y\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 122, "newlines": 119, "modlines": 121, "user": "SEB1525"}, "text": "         TITLE 'ZISPUT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* (ZISPUT 'foo \"bar\") sets the value of the ISPF dialog variable      *\n* FOO to the value BAR.  It uses the VREPLACE service to do this.     *\n* The second argument is returned as the value of the function.       *\n*                                                                     *\n***********************************************************************\n         SPACE\nZISPUT   #ZBEG MINARGS=2,MAXARGS=2,NAME='ZISPUT'\n         #ZPDS 2*4+12+0 = 20       DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE 1\n         LM    #1,#2,0(#11)        Get args 1 and 2\n         CLI   ##TYPE(#1),##STRING Arg 1 must be a string\n         BE    A1TYPOK             or\n         CLI   ##TYPE(#1),##SYMBOL If symbol,\n         BNE   ERROR1               then use print name\n         L     #1,##PNAME(,#1)\nA1TYPOK  DS    0H\n         XR    #4,#4\n         ICM   #4,B'0111',1(#1)    Get string length\n         BZ    ERROR1              If null string, invalid variable nm\n         CH    #4,=H'8'            If longer than 8 characters,\n         BH    ERROR1              then invalid variable name\n         MVC   VARNAME,=CL8' '\n         BCTR  #4,0\n         EX    #4,MVCVAR           Move variable name, folding to up.c.\n*\n* Call ZILADMP to dump out the value.  Note that the value cannot be\n* a list, vector or structure.\n*\n         TM    ##TYPE(#2),##ATOM\n         BZ    BADLIST\n         TM    ##TYPE(#2),##VEC\n         BO    BADLIST\n         L     #15,ZLCADMP         Get address of ZILADMP\n         LR    #1,#10              Set reg 1 for ZILADMP\n         #BASR #14,#15             Call ZILADMP to dump atom\n         LR    #5,#0               Get length of dumped atom\n         LR    #7,#1               Save address of dumped value\n*\n* GETMAIN an area of storage which will belong to ISPF to hold the\n* value of this dialog variable.  Now I know why ISPF keeps getting\n* storage but not freeing it - this is the only way to guarantee that\n* ISPF can hold on to its value.\n*\n         ST    #5,LENGTHS          Store length of dumped atom\n         #GETMAIN RC,LV=(0),LOC=BELOW Get storage for this value\n         LTR   #15,#15\n         BNZ   NOROOM\n         ST    #1,PARM4            Store address of Getmained storage\n         OI    PARM4,X'80'\n         LR    #0,#1               Destination address\n         LR    #1,#5               Destination length\n         LR    #14,#7              Source address\n         LR    #15,#5              Source length\n         MVCL  #0,#14              Move our data to getmained area\n*\n* Get ISPLINK\n*\n         ICM   #15,15,@ISPLINK     Get address of ISPLINK\n         BNZ   LOADED              If not loaded, then\n         LOAD  EPLOC==CL8'ISPLINK',ERRET=NOSPF\n         ST    #0,@ISPLINK         Save entry point\n         LR    #15,#0              Get entry point\nLOADED   DS    0H\n*\n* INVOKE THE DIALOG SERVICE VIA ISPEX\n*\n         ST    #9,ZLCISV09         Save #9 in case of interrupt\n         LA    #1,PARMS            POINT TO PARAMETER LIST FOR ISPLINK\n         OI    ZLCIFLGS,ZLCISYS    Indicate non-ZIL code running\n         #BASR #14,#15             Call ISPLINK\n         TM    ZLCIFLGS,ZLCIATTN   If attention interrupt occurred\n         BOR   #13                 then go to handle it\n         NI    ZLCIFLGS,255-ZLCISYS Indicate ZIL code running again\n*\n* If CONTROL ERRORS RETURN is in effect, and the return code is higher\n* than 8, then we should really handle this better - like set ZERRMSG??\n*\n         LTR   #15,#15\n         BNZ   VERROR\n         SPACE 1\n         L     #15,4(,#11)         Return arg 2 as value\n         SPACE 1\nRETURN   DS    0H\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nMVCVAR   OC    VARNAME(*-*),##VECDAT(#1)\n         SPACE 1\n@ISPLINK DC    A(0)                Address of ISPLINK\n         SPACE 1\nPARMS    DS    0A\nPARM1    DC    A($VREPLAC)         Address of 'VREPLACE'\nPARM2    DC    A(NAMELIST)         Address of variable name list\nPARM3    DC    A(LENGTHS)          Address of length(s)\nPARM4    DS    A                   Address of value(s)\n         SPACE 1\n$VREPLAC DC    CL8'VREPLACE'       Dialog service name\nNAMELIST DC    C'('                Start of name list\nVARNAME  DC    CL8' '              Variable name\n         DC    C')'                End of name list\nLENGTHS  DS    F                   Length of value to set\n         SPACE 1\nERROR1   #ERR  'Arg 1 to ZISPUT not a valid ISPF variable name - ',    X\n               0(#11)\nBADLIST  #ERR  'Arg 2 to ZISPUT is a list, vector or structure, which cX\n               annot be an ISPF dialog variable value - ',4(#11)\nNOSPF    #ERR  'ZISPUT failed, ISPF dialog services not available.'\nVERROR   #ERR  'ZISPUT failed, ISPF dialog error doing VREPLACE.'\nNOROOM   #ERR  'ZISPUT failed, unable to GETMAIN storage to create variX\n               able value for ISPF.'\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZMSALTP": {"ttr": 18187, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x893_\\x00\\x893o\\x12P\\x00\\xb4\\x00\\x82\\x00P\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1989-12-01T00:00:00", "modifydate": "1989-12-02T12:50:00", "lines": 180, "newlines": 130, "modlines": 80, "user": "SEB1525"}, "text": "         TITLE 'ZMSALTP - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZMSALTP takes two args.  Both must be strings or symbols.           *\n*                                                                     *\n* This is \"ALPHALESSP\" for Macsyma or other application that          *\n* requires ASCII collating.                                           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS ROUTINE IS NOT RECURSIVE AND USES NO STACK SPACE.              *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* SUPPORT FOR STRING AND SYMBOL COMPARES.  THE FOLLOWING COMPARISONS  *\n*            ARE LEGAL:                                               *\n*                                                                     *\n*  SYMBOL TO SYMBOL                                                   *\n*  STRING TO STRING                                                   *\n*  SYMBOL TO STRING                                                   *\n*  STRING TO SYMBOL                                                   *\n*                                                                     *\n* ALL MAY BE REMOVED FOR FULL COMMON LISP.                            *\n*                                                                     *\n***********************************************************************\nZMSALTP  #ZBEG MINARGS=2,MAXARGS=2,NAME='ZMSALTP'\n         SPACE\n         LR    #3,#15\n         DROP  #15\n         USING ZMSALTP,#3\n         SPACE\n         LM    #1,#2,0(#1)         LOAD ARGUMENTS\n         LR    #15,#10             PRESET RETURN VALUE TO NIL\n         CR    #1,#2               IF ARGS ARE \"EQ\"\n         BER   #14                 THEN RETURN NIL\n         CLI   ##TYPE(#1),##STRING IF ARGUMENT IS A STRING\n         BE    ARG1OK              THEN OK\n         CLI   ##TYPE(#1),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR1              THEN\n         L     #1,##PNAME(,#1)      TAKE THE PRINT NAME, ELSE ERROR\nARG1OK   DS    0H                  CHECK ARG 2\n         CLI   ##TYPE(#2),##STRING IF ARGUMENT IS A STRING\n         BE    ARG2OK              THEN OK\n         CLI   ##TYPE(#2),##SYMBOL IF ARGUMENT IS A SYMBOL\n         BNE   ERROR2              THEN\n         L     #2,##PNAME(,#2)      TAKE THE PRINT NAME, ELSE ERROR\nARG2OK   DS    0H                  #1 -> string 1, #2 -> string 2\n         SPACE 1\n         XR    #5,#5               Clear insert register\n         XR    #7,#7               Clear insert register\n         ICM   #5,7,1(#1)          Get string length 1\n         BZ    STR1NULL            If zero, string 1 is \"\"\n         ICM   #7,7,1(#2)          Get string length 2\n         BZ    STR2NULL            If zero, string 2 is \"\"\n         LA    #4,##VECDAT(,#1)    Point to text of string arg1\n         LA    #6,##VECDAT(,#2)    Point to text of string arg2\n*\n*                                  #4 = ADDRESS OF ARG 1 DATA\n*                                  #5 = LENGTH OF ARG 1 DATA\n*                                  #6 = ADDRESS OF ARG 2 DATA\n*                                  #7 = LENGTH OF ARG 2 DATA\n*\n         LR    #15,#5              Use length of arg1\n         CR    #5,#7               unless arg1 is longer\n         BNH   *+6                 in which case\n         LR    #15,#7              use shorter length of arg2\n         LA    #0,256              Set up constant 256\n         LA    #2,TRTBLE           Default to EBCDIC translation\n         TM    ZLCLDFLG,ZLCLDASC   but if ASCII mode\n         BNO   TRLOOP              then\n         LA    #2,TRTBLA            set to ASCII translation\nTRLOOP   DS    0H\n         CR    #15,#0              Do while length >= 256\n         BL    SHORTTR\n         MVC   TRWK1(256),0(#4)    Move arg 1 text to work area\n         TR    TRWK1(256),0(#2)    Translate to collating code\n         MVC   TRWK2(256),0(#6)    Move arg 2 text to work area\n         TR    TRWK2(256),0(#2)    Translate to collating code\n         CLC   TRWK1(256),TRWK2    Compare what we have so far\n         BL    LESS                If less, finished, return T\n         BH    GREATER             If greater, finished, return NIL\n*                                  Else compare not finished\n         AR    #4,#0               Bump up pointer to arg 1 text\n         AR    #6,#0               Bump up pointer to arg 2 text\n         SR    #15,#0              Bump down length\n         BNZ   TRLOOP              If some left, continue translating\n         B     EQSOFAR             If none left, args equal, check it\nSHORTTR  DS    0H                  Compare for args shorter than 256\n         BCTR  #15,0               Reduce length for execute\n         EX    #15,MVC1            Move arg 1 text to work area\n         EX    #15,TR1             Translate to collating code\n         EX    #15,MVC2            Move arg 2 text to work area\n         EX    #15,TR2             Translate to collating code\n         EX    #15,CLC             Compare what we have so far\n         BL    LESS                If less, finished, return T\n         BH    GREATER             If greater, finished, return NIL\n******** B     EQSOFAR             Else equal, check what to return\nEQSOFAR  DS    0H                  Arg 1 equal to arg 2\n         CR    #5,#7               Compare arg lengths\n******** BL    LESS                arg 1 shorter than arg 2, thus LT\n******** BE    EQUAL               arg 1 as long as   arg 2, thus EQ\n******** B     GREATER             arg 1 longer than  arg 2, thus GT\n         BNL   NOTLESS             If len1 < len2 then true else false\nTRUE     DS    0H                  (i.e. true)\n         LR    #15,#8              Return T\n         BR    #14\nFALSE    DS    0H                  (i.e. false)\n         LR    #15,#10             Return NIL\n         BR    #14\nSTR1NULL DS    0H                  String 1 is null\n         ICM   #7,7,1(#2)          Get string length 2\n         BZ    EQUAL               If zero, strings are equal\n         B     LESS                Otherwise, arg1 < arg2, return true\n         SPACE 1\nSTR2NULL EQU   FALSE               String 2 is null, but string 1 isn't\n*                                  i.e. arg1 > arg2, return false\n         SPACE 1\nLESS     EQU   TRUE                Arg 1 less than arg 2:     true\nNOTLESS  EQU   FALSE               Arg 1 not less than arg 2: false\nEQUAL    EQU   FALSE               Arg 1 equal to arg 2:      false\nGREATER  EQU   FALSE               Arg 1 greater than arg 2:  false\n         SPACE 1\nMVC1     MVC   TRWK1(*-*),0(#4)    Ex'd: Move arg 1 text to work area\nTR1      TR    TRWK1(*-*),0(#2)    Ex'd: Translate to collating code\nMVC2     MVC   TRWK2(*-*),0(#6)    Ex'd: Move arg 2 text to work area\nTR2      TR    TRWK2(*-*),0(#2)    Ex'd: Translate to collating code\nCLC      CLC   TRWK1(*-*),TRWK2    Ex'd: Compare what we have so far\n         EJECT\nTRWK1    DS    CL256\nTRWK2    DS    CL256\n         SPACE 1\nTRTBLE   DC    256YL1(*-TRTBLE)    ebcdic -> ebcdic translate table\n         SPACE 1\n*                                  ebcdic -> ascii translate table\n*\nTRTBLA   DC    X'000102038209837F' 00-07 NUL SOH STX ETX PF HT LC DEL\n         DC    X'8485860B0C0D0E0F' 08-0F GE RLF SMM VT FF CR SO SI\n         DC    X'1011121387880889' 10-17 DLE DC1 DC2 TM RES NL BS IL\n         DC    X'18198A8B1C1D1E1F' 18-1F CAN EM CC CU1 IFS IGS IRS IUS\n         DC    X'8C8D96978E0A171B' 20-27 DS SOS FS na BYP LF ETB ESC\n         DC    X'98998F9091050607' 28-2F na na SM CU2 na ENQ ACK BEL\n         DC    X'9A9B169C92939404' 30-37 na na SYN na PN RS UC EOT\n         DC    X'9D9E9F951415A01A' 38-3F na na na CU3 DC4 NAK na SUB\n         DC    X'20A1A2A3A4A5A6A7' 40-47 SP na na na na na na na\n         DC    X'A8A9812E3C282B7C' 48-4F na na CENT . < ( + SBAR\n         DC    X'26AAABACADAEAFB0' 50-57 & na na na na na na na\n         DC    X'B1B221242A293B5E' 58-5F na na ! $ * ) ; \u00ac\n         DC    X'2D2FB3B4B5B6B7B8' 60-67 - / na na na na na na\n         DC    X'B9BA802C255F3E3F' 68-6F na na BBAR , % _ > ?\n         DC    X'BBBCBDBEBFC0C1C2' 70-77 na na na na na na na na\n         DC    X'C3603A2340273D22' 78-7F na ` : # @ ' = \"\n         DC    X'C461626364656667' 80-87 na a b c d e f g\n         DC    X'6869C5C6C7C8C9CA' 88-8F h i na na na na na na\n         DC    X'CB6A6B6C6D6E6F70' 90-97 na j k l m n o p\n         DC    X'7172CCCDCECFD0D1' 98-9F q r na na na na na na\n         DC    X'D27E737475767778' A0-A7 na ~ s t u v w x\n         DC    X'797AD3D4D55BD6D7' A8-AF y z na na na LBRACK na na\n         DC    X'D8D9DADBDCDDDEDF' B0-B7 na na na na na na na na\n         DC    X'E0E1E2E3E45DE5E6' B8-BF na na na na na RBRACK na na\n         DC    X'7B41424344454647' C0-C7 { A B C D E F G\n         DC    X'4849E7E8E9EAEBEC' C8-CF H I na na na na na na\n         DC    X'7D4A4B4C4D4E4F50' D0-D7 } J K L M N O P\n         DC    X'5152EDEEEFF0F1F2' D8-DF Q R na na na na na na\n         DC    X'5CF3535455565758' E0-E7 \\ na S T Y V W X\n         DC    X'595AF4F5F6F7F8F9' E8-EF Y Z na na na na na na\n         DC    X'3031323334353637' F0-F7 0 1 2 3 4 5 6 7\n         DC    X'3839FAFBFCFDFEFF' F8-FF 8 9 na na na na na na\n         EJECT\nERROR1   LR    #4,#1\n         #ERR  'Argument 1 to ALPHALESSP not a string - ',(#4)\nERROR2   LR    #4,#2\n         #ERR  'Argument 2 to ALPHALESSP not a string - ',(#4)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZMSASSQ": {"ttr": 18435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x007\\x004\\x006\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 55, "newlines": 52, "modlines": 54, "user": "SEB1525"}, "text": "         TITLE 'ZMSASSQ - BUILT-IN ZIL 1.3 SUBROUTINE FOR MACSYMA'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZMSASSQ: SAME AS ASSQ BUT WORKS ON NUMBERS AS WELL.                 *\n*                                                                     *\n* NEEDED TO RUN MACSYMA, WHICH THINKS (ASSQ 1 '((1 . FOO))) WORKS.    *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZMSASSQ  #ZBEG MINARGS=2,MAXARGS=2,NAME='ZMSASSQ'\n         SPACE 1\n         LR    #3,#15\n         DROP  #15\n         USING ZMSASSQ,#3\n         SPACE 1\n         LM    #5,#6,0(#1)         LOAD THE ARGUMENTS\n         LR    #7,#6\n         CLI   ##TYPE(#5),##FIXNUM IF ARG 1 IS A FIXNUM\n         BE    PFIX                THEN DO FIXNUM SEARCH\n*                                  ELSE DO NORMAL ASSQ SEARCH\n         SPACE 1\nLOOP     DS    0H\n         CR    #7,#10              COMPARE (SUB)ALIST TO NIL\n         LM    #6,#7,##CAR(#7)     #6 = SUBLISTS'S CAR, #7 = ITS CDR\n         BE    FAIL                IF SUBLIST WAS NIL, RETURN NIL\n         C     #5,##CAR(,#6)       IF ARG 1 NOT EQ ITS CAR'S CAR\n         BNE   LOOP                THEN CONTINUE WITH SUBALIST'S CDR\n         LR    #15,#6              ELSE RETURN WITH SUBALIST'S CAR\n         BR    #14\n         SPACE 1\nPFIX     DS    0H                  SEARCH FOR EQL FIXNUM\nFIXNLOOP DS    0H                  SEARCH FOR EQL FIXNUM\n         CR    #7,#10              COMPARE (SUB)ALIST TO NIL\n         LM    #6,#7,##CAR(#7)     #6 = SUBLISTS'S CAR, #7 = ITS CDR\n         BE    FAIL                IF SUBLIST WAS NIL, RETURN NIL\n         ICM   #4,15,##CAR(#6)     GET CAAR OF IT (LEFT ELT OF PAIR)\n         BM    FIXNLOOP            IF IT WASN'T A CONS, NO MATCH\n         CLC   0(8,#5),0(#4)       IF TYPE AND VALUE ARE NOT EQUAL\n         BNE   FIXNLOOP            THEN CONTINUE WITH SUBALIST'S CDR\n         LR    #15,#6              ELSE RETURN WITH SUBALIST'S CAR\n         BR    #14\n         SPACE 1\nFAIL     DS    0H                  NOT FOUND IN ALIST\n         LR    #15,#10             RETURN NIL\n         BR    #14\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSDELQ": {"ttr": 18437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x006\\x00\\x88\\x01_\\x01\\x00&_\\x17&\\x00^\\x00[\\x00]\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:26:36", "lines": 94, "newlines": 91, "modlines": 93, "user": "SEB1525"}, "text": "         TITLE 'ZMSDELQ - BUILT-IN ZIL 1.3 SUBROUTINE FOR MACSYMA'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZMSDELQ: SAME AS DELQ BUT WORKS ON NUMBERS AS WELL.                 *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZMSDELQ  #ZBEG MINARGS=2,MAXARGS=3,NAME='ZMSDELQ'\n         SPACE 1\n         LR    #7,#15              LOCAL BASE REGISTER\n         DROP  #15\n         USING ZMSDELQ,#7\n         SPACE 1\n         LM    #1,#3,0(#1)         LOAD ARGS 1, 2, 3\n         LR    #15,#2              PRESET RETURN VALUE\n         SPACE 1\n         CR    #3,#13              IF ARG 3 NOT SUPPLIED\n         BNE   ARG3SUP             THEN\n         LR    #3,#10               SET ARG 3 = NIL\n         B     ARG3OK               AND GO PROCESS\nARG3SUP  DS    0H                  ELSE\n         SPACE 1\n         CR    #3,#10              IF ARG3 (COUNT) IS NIL\n         BE    ARG3OK              THEN IT'S OK\n         CLI   ##TYPE(#3),##FIXNUM ELSE ARG3 MUST BE A FIXNUM\n         BNE   ARG3ERR             OTHERWISE ERROR\n         ICM   #6,#15,##CDR(#3)    GET FIXNUM VALUE OF ARG3 = COUNT\n         BNPR  #14                 IF NOT POSITIVE, RETURN W/O DELETES\nARG3OK   DS    0H\n         LR    #4,#10              INITIALIZE BASHEE POINTER\n         SPACE 1\n         CLI   ##TYPE(#1),##FIXNUM IF ARG 1 IS A FIXNUM\n         BE    FIXP                THEN GO TO DO FIXNUM DELQ USING EQL\n         SPACE 1\nLOOP     DS    0H                  DO WHILE LIST IS NOT NULL\n         CR    #2,#10              WHEN END OF LIST REACHED\n         BER   #14                 RETURN WITH VALUE IN #15\n         TM    ##TYPE(#2),##ATOM   IF LIST ENDS WITH ATOM\n         BOR   #14                 DO LIKE IT ENDED IN NIL\n         C     #1,##CAR(,#2)       IF ARG1 IS EQ TO CAR OF (SUB)LIST\n         BNE   NOTEQ               THEN...\n         L     #2,##CDR(,#2)        DROP IT FROM (SUB)LIST\n         CR    #4,#10               IF WE HAVE SOMETHING TO BASH\n         BE    NOBASH               THEN\n         ST    #2,##CDR(,#4)         BASH IT (RPLACD TO SPLICE OUT CAR)\n         B     AFTBASH              ELSE\nNOBASH   LR    #15,#2                JUST CHANGE THE RETURN VALUE PTR\nAFTBASH  DS    0H\n         CR    #3,#10               IF THERE IS A COUNT (ARG3 NOT NIL)\n         BE    LOOP                 THEN...\n         BCT   #6,LOOP               DECREMENT, THEN LOOP UNLESS COUNT\n         BR    #14                   REACHED, IN WHICH CASE RETURN\nNOTEQ    DS    0H                  ELSE THIS CAR DOESN'T MATCH\n         LR    #4,#2               SET BASHEE POINTER\n         L     #2,##CDR(,#2)       CDR DOWN (SUB)LIST\n         B     LOOP                CONTINUE LOOPING\n         SPACE 1\nFIXP     DS    0H                  HERE IF ARG 1 IS A FIXNUM\n         SPACE 1\nFIXNLOOP DS    0H\n         CR    #2,#10              WHEN END OF LIST REACHED\n         BER   #14                 RETURN WITH VALUE IN #15\n         TM    ##TYPE(#2),##ATOM   IF LIST ENDS WITH ATOM\n         BOR   #14                 DO LIKE IT ENDED IN NIL\n         L     #5,##CAR(,#2)       LOAD CAR OF (SUB)LIST\n         CLC   0(8,#5),0(#1)       IF ARG1 EQL TO CAR OF (SUB)LIST\n         BNE   FXNOTEQ             THEN...\n         L     #2,##CDR(,#2)        DROP IT FROM (SUB)LIST\n         CR    #4,#10               IF WE HAVE SOMETHING TO BASH\n         BE    FXNOBASH             THEN\n         ST    #2,##CDR(,#4)         BASH IT (RPLACD TO SPLICE OUT CAR)\n         B     FXAFBASH             ELSE\nFXNOBASH LR    #15,#2                JUST CHANGE THE RETURN VALUE PTR\nFXAFBASH DS    0H\n         CR    #3,#10               IF THERE IS A COUNT (ARG3 NOT NIL)\n         BE    FIXNLOOP             THEN...\n         BCT   #6,FIXNLOOP           DECREMENT, THEN LOOP UNLESS COUNT\n         BR    #14                   REACHED, IN WHICH CASE RETURN\nFXNOTEQ  DS    0H                  ELSE THIS CAR DOESN'T MATCH\n         LR    #4,#2               SET BASHEE POINTER\n         L     #2,##CDR(,#2)       CDR DOWN (SUB)LIST\n         B     FIXNLOOP            CONTINUE LOOPING\n         SPACE 1\nARG3ERR  #ERR  'Invalid DELQ count argument - ',(#3)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSDREM": {"ttr": 18440, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x00'\\x00%\\x00&\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 39, "newlines": 37, "modlines": 38, "user": "SEB1525"}, "text": "         TITLE 'ZMSDREM - BUILT-IN ZIL 1.3 SUBROUTINE FOR MACSYMA'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*      ZMSDREM TAKES THREE ARGUMENTS. ALL MUST BE FIXNUMS.            *\n***********************************************************************\nZMSDREM  #ZBEG MINARGS=3,MAXARGS=3,NAME='*DBLREM'\n*\n         #ZPDS 24                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         LM    #3,#5,0(#11)        LOAD ARGUMENTS\n         CLI   ##TYPE(#3),##FIXNUM IS ARG 1 A FIXNUM?\n         BNE   NFX1                IF NOT, ERROR\n         CLI   ##TYPE(#4),##FIXNUM IS ARG 2 A FIXNUM?\n         BNE   NFX2                IF NOT, ERROR\n         CLI   ##TYPE(#5),##FIXNUM IS ARG 3 A FIXNUM?\n         BNE   NFX3                IF NOT, ERROR\n*---------------------------------------------------------------------*\n*            FIXNUM * FIXNUM \\ FIXNUM *DBLREM                         *\n*---------------------------------------------------------------------*\n         L     #3,##CDR(,#3)       GET ARG 1\n         M     #2,##CDR(,#4)       MULTIPLY BY ARG 2\n         D     #2,##CDR(,#5)       DIVIDE BY ARG 3 TO GET REMAINDER\n         #MKAT FIXED               MAKE A FIXNUM\n*\nRETURN   DS    0H                  RETURN WITH NEW ATOM\n         SPACE 1\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE 1\nNFX1     #ERR  'Argument 1 to *DBLREM not a fixnum - ',(#3)\nNFX2     #ERR  'Argument 2 to *DBLREM not a fixnum - ',(#4)\nNFX3     #ERR  'Argument 3 to *DBLREM not a fixnum - ',(#5)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSEQ": {"ttr": 18442, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11U\\x00 \\x00\\x1d\\x00\\x1f\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:55:00", "lines": 32, "newlines": 29, "modlines": 31, "user": "SEB1525"}, "text": "         TITLE 'ZMSEQ - BUILT-IN ZIL 1.3 SUBROUTINE FOR MACSYMA'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* ZMSEQ IS LIKE EQ BUT CONSIDERS EQL FIXNUMS TO BE EQ.                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZMSEQ    #ZBEG MINARGS=2,MAXARGS=2,NAME='ZMSEQ'\n         SPACE 1\n         USING ZMSEQ,#15\n         SPACE 1\n         LM    #2,#3,0(#1)\n         CR    #2,#3\n         BE    TRUE\n         CLI   0(#2),##FIXNUM\n         BNE   FALSE\n         CLC   0(8,#2),0(#3)\n         BNE   FALSE\n******** BE    TRUE\n         DROP  #15\nTRUE     LR    #15,#8\n         BR    #14\nFALSE    LR    #15,#10\n         BR    #14\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSMEMQ": {"ttr": 18444, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00I\\x00\\x88\\x01_\\x01\\x00&_\\x17&\\x009\\x006\\x008\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "2000-09-21T17:26:49", "lines": 57, "newlines": 54, "modlines": 56, "user": "SEB1525"}, "text": "         TITLE 'ZMSMEMQ - BUILT-IN ZIL SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZMSMEMQ: SAME AS MEMQ BUT WORKS ON NUMBERS AS WELL.                 *\n*                                                                     *\n* NEEDED TO RUN MACSYMA, WHICH THINKS THAT FIXNUMS CAN BE EQ.         *\n*                                                                     *\n* THIS ROUTINE IS NONRECURSIVE AND USES NO STACK SPACE.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZMSMEMQ  #ZBEG MINARGS=2,MAXARGS=2,NAME='ZMSMEMQ'\n         SPACE 1\n         LR    #2,#15\n         DROP  #15\n         USING ZMSMEMQ,#2\n         LR    #4,#14              SAVE RETURN ADDRESS\n         LM    #14,#15,0(#1)       LOAD ARGS 1 AND 2\n         CLI   ##TYPE(#14),##FIXNUM IF ARG 1 IS A FIXNUM\n         BE    PFIX                THEN DO FIXNUM SEARCH\n         SPACE 1\nLOOP     DS    0H                  ELSE DO NORMAL (EQ) SEARCH\n         SPACE 1\n         CR    #15,#10             WHEN (SUB)LIST IS NIL\n         BER   #4                  THEN RETURN NIL\n         LM    #5,#6,##CAR(#15)    #14 = CAR OF (SUB)LIST, #15 = CDR\n         LTR   #5,#5               IF (SUB)LIST CELL WAS REALLY ATOMIC\n         BM    BADLIST             THEN BAD LIST, RETURN NIL\n         CR    #14,#5              IF ARG1 IS EQ TO CAR OF (SUB)LIST\n         BER   #4                  THEN RETURN\n         LR    #15,#6              ELSE GET CDR OF (SUB)LIST\n         B     LOOP                AND CONTINUE.\nBADLIST  DS    0H                  (SUB)LIST IS NOT ATOMIC\n         LR    #15,#10             WHAT THE HECK...\n         BR    #4                  JUST RETURN NIL\n         SPACE 1\nPFIX     DS    0H                  SEARCH FOR EQL FIXNUM\n         SPACE 1\nFIXNLOOP DS    0H\n         SPACE 1\n         CR    #15,#10             WHEN (SUB)LIST IS NIL\n         BER   #4                  THEN RETURN NIL\n         LM    #5,#6,##CAR(#15)    #5 = CAR OF (SUB)LIST, #6 = CDR\n         LTR   #5,#5               IF (SUB)LIST CELL WAS REALLY ATOMIC\n         BM    BADLIST             THEN BAD LIST, RETURN NIL\n         CLC   0(8,#14),0(#5)      IF ARGS ARE EQL (BOTH FIXNA)\n         BER   #4                  THEN RETURN\n         LR    #15,#6              ELSE GET CDR OF (SUB)LIST\n         B     FIXNLOOP            AND CONTINUE.\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSREMQ": {"ttr": 18446, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11V\\x00a\\x00^\\x00`\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:56:00", "lines": 97, "newlines": 94, "modlines": 96, "user": "SEB1525"}, "text": "         TITLE 'ZMSREMQ - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZMSREMQ: SAME AS REMQ BUT WORKS ON FIXNUMS AS WELL.  FOR MACSYMA.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZMSREMQ  #ZBEG MINARGS=2,MAXARGS=3,NAME='ZMSREMQ'\n         #ZPDS 3*4+12+4  =     28\n         #ZSAV ARGS=3\n         SPACE 1\n         LM    #5,#7,0(#11)        #5 = ARG1, #6 = ARG2, #7 = ARG3\n         MVI   COMPVAL,X'FF'       Set impossible-to-be-EQL type\n         CLI   ##TYPE(#5),##FIXNUM But if arg1 is a fixnum\n         BNE   ARG1NFIX            then\n         MVC   COMPVAL(8),0(#5)     set compare value to fixnum body\nARG1NFIX DS    0H\n* #5 to be reused.\n* Arg 1 is kept on stack, since CONS might relocate it anyhow.\n         SPACE 1\n         CR    #7,#13              IF ARG 3 NOT SUPPLIED\n         BE    ARG3NULL             then process as if NIL\n         CR    #7,#10              IF ARG3 (COUNT) IS NIL\n         BE    ARG3NULL            THEN IT'S OK\n         CLI   ##TYPE(#7),##FIXNUM ELSE ARG3 MUST BE A FIXNUM\n         BNE   ARG3ERR             OTHERWISE ERROR\n         ICM   #7,#15,##CDR(#7)    GET FIXNUM VALUE OF ARG3 = COUNT\n         BP    ARG3OK              If not positive, then\n         LR    #15,#6               return arg 2\n         B     RETURN\nARG3NULL DS    0H                  Arg 3 is NIL (or unsupplied)\n         XR    #7,#7               SET ARG 3 fixnum value = 0\n*                                  This is NOT the same as specifying\n*                                  0 as arg3.  This value will be able\n*                                  to be decremented without ever going\n*                                  to zero.\nARG3OK   DS    0H                  #7 now contains fixnum value of arg3\n         ST    #10,24(,#11)        Init eventual result to NIL\n         LA    #5,24-##CDR(,#11)   Set pseudolocative for bashing list\n         CR    #6,#10              If arg 2 is NIL\n         BE    RETURNZ             then return NIL.\nLOOP     DS    0H                  Else start looping.\n         ICM   #1,15,##CAR(#6)     Get CAR of sublist\n         BM    RETURNA             If sublist wasn't a CONS, return\n         C     #1,0(,#11)          If arg1 is EQ to CAR of (sub)list\n         BE    EQ                   or\n         CLC   COMPVAL(8),0(#1)    arg1 is EQL to CAR (if fixnum)\n         BNE   NOTEQ                then\nEQ       DS    0H\n         BCT   #7,NEXTCDR           decrement count.\n*                                   If count still nonzero, just\n*                                   continue by skipping this element.\n*                                   If count goes to zero, then...\n         L     #0,##CDR(,#6)         get CDR of remaining (sub)list\n         ST    #0,##CDR(,#5)         bash new list being built\n         B     RETURNZ               return new list\n         SPACE 1\nNOTEQ    DS    0H                  ELSE THIS CAR DOESN'T MATCH\n*                                  Include CAR in new list, already #1\n******** L     #1,##CAR(,#6)       Arg 1 to CONS = CAR of sublist\n         L     #15,ZLCCONS         Get address of ZILCONS\n         LR    #2,#10              Arg 2 to CONS = NIL\n         #BASR #14,#15             Call CONS to get new list element\n*\n* Note: We assume that #5 is not relocated by GC, being a CONS pointer.\n*       We assume that #6 is not relocated by GC, being a CONS pointer.\n*\n         ST    #15,##CDR(,#5)      Bash list being built with new cell\n         LR    #5,#15              Set new bashee pointer\n         SPACE 1\nNEXTCDR  DS    0H\n         L     #6,##CDR(,#6)       Bump down arg2 list.\n         CR    #6,#10              Until arg 2 goes to NIL\n         BNE   LOOP                 continue.\n         SPACE 1\nRETURNZ  DS    0H\n         L     #15,24(,#11)        Load return value\n         SPACE 1\nRETURN   DS    0H                  Return value is in #15\n         #ZRET ,\n         SPACE 1\nRETURNA  DS    0H                  Here only if sublist ends in atom\n*                                  (and no count argument)\n         ST    #6,##CDR(,#5)       Bash list with atomic end of list\n         B     RETURNZ             and return the return value\n         SPACE 1\nCOMPVAL  DS    D                   Area to compare fixnum value\n         SPACE 1\nARG3ERR  #ERR  'Invalid REMQ count argument - ',(#7)\n         SPACE 1\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMSTRUCT": {"ttr": 18449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11V\\x00E\\x00B\\x00D\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:56:00", "lines": 69, "newlines": 66, "modlines": 68, "user": "SEB1525"}, "text": "         TITLE 'ZMSTRUCT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A STRUCTURE OUT OF A LIST.  THE SIZE OF THE   *\n* STRUCT IS THE LENGTH OF THE LIST.                                   *\n*                                                                     *\n* IT TAKES ONE REQUIRED ARGUMENT - THE LIST.                          *\n*                                                                     *\n* NOTE:  THE LIST MUST BE NON-NULL AND ITS CAR MUST BE A SYMBOL.      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZMSTRUCT #ZBEG MINARGS=1,MAXARGS=1,NAME='ZMSTRUCT'\n         SPACE 1\n         #ZPDS 1*4+12+0 = 16\n         #ZSAV ARGS=1\n         SPACE 1\n         L     #1,0(,#11)          LOAD ARG1 = THE LIST\n         TM    ##TYPE(#1),##ATOM   IF LIST IS NIL OR ATOMIC\n         BO    ERROR1              THEN ERROR\n         L     #2,##CAR(,#1)       GET CAR OF LIST\n         CLI   ##TYPE(#2),##SYMBOL IF NOT A SYMBOL\n         BNE   ERROR3              THEN ERROR\n         XR    #7,#7               INITIALIZE LENGTH TO ZERO\nLENLOOP  DS    0H                  LOOP TO DETERMINE LENGTH OF LIST\n         TM    ##TYPE(#1),##ATOM   IF ATOM OR IMPROPER LIST\n         BO    ERROR1              THEN ERROR.  ELSE...\n         LA    #7,1(,#7)           INCREMENT COUNT\n         L     #1,##CDR(,#1)       GET NEXT CDR OF LIST\n         CR    #1,#10              UNTIL END OF LIST\n         BNE   LENLOOP             CONTINUE\nGOTLEN   DS    0H                  #7 = NUMBER OF ELEMENTS IN LIST\n         SLA   #7,2                MULTIPLY BY 4 FOR STRUCT LENGTH\n         LR    #2,#7               SET LENGTH FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF STRING SPACE SERVICE\n         LA    #0,16(,#11)         SET CURRENT STACK LOCATION\n         #BASR #14,#15             CALL ZILVSS TO BUILD THE OBJECT\n         LTR   #4,#4               IF STRUCT BUILD FAILED\n         BZ    ERROR4              THEN ERROR\n         MVI   ##TYPE(#15),##STRUCT SET OBJECT TYPE = STRUCT\n         L     #2,0(,#11)          GET ARG 1 (THE LIST)\n         LA    #6,4                SET INCREMENT REGISTER FOR BXLE\n         BCTR  #7,0                SET TERMINATION REGISTER FOR BXLE\n         XR    #1,#1               SET INDEX REGISTER\nINITLOOP L     #0,##CAR(,#2)       GET EACH ELEMENT OF LIST\n         ST    #0,0(#1,#4)         INITIALIZE EACH ELEMENT IN STRUCT\n         L     #2,##CDR(,#2)       GET NEXT LIST ELEMENT\n         BXLE  #1,#6,INITLOOP\n         SPACE 1\nRETURN   DS    0H                  #15 POINTS TO STRUCT BUILT\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   #ERR  'Argument to ZMSTRUCT not a non-null proper list - ',   X\n               0(#11)\nERROR3   #ERR  'First element of structure to be allocated not a symbolX\n                - ',0(#11)\nERROR4   #ERR  PREFIX=NO,'ZIL4010 ZMSTRUCT: Not enough vector/string spX\n               ace to build structure.'\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZMVECTOR": {"ttr": 18451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11V\\x00<\\x009\\x00;\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:56:00", "lines": 60, "newlines": 57, "modlines": 59, "user": "SEB1525"}, "text": "         TITLE 'ZMVECTOR - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBROUTINE MAKES A VECTOR OUT OF A LIST.  THE SIZE OF THE      *\n* VECTOR IS THE LENGTH OF THE LIST.                                   *\n*                                                                     *\n* IT TAKES ONE REQUIRED ARGUMENT - THE LIST.                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZMVECTOR #ZBEG MINARGS=1,MAXARGS=1,NAME='ZMVECTOR'\n         SPACE 1\n         #ZPDS 1*4+12+0 = 16\n         #ZSAV ,\n         SPACE 1\n         L     #1,0(,#11)          LOAD ARG1 = THE LIST\n         XR    #7,#7               INITIALIZE LENGTH TO ZERO\nLENLOOP  DS    0H                  LOOP TO DETERMINE LENGTH OF LIST\n         CR    #1,#10              WHEN END OF LIST\n         BE    GOTLEN              WE HAVE THE LENGTH\n         TM    ##TYPE(#1),##ATOM   IF ATOM OR IMPROPER LIST\n         BO    ERROR1              THEN ERROR.  ELSE...\n         L     #1,##CDR(,#1)       GET NEXT CDR OF LIST\n         BCT   #7,LENLOOP          DECREMENT COUNT AND CONTINUE\nGOTLEN   DS    0H                  #7 = NUMBER OF ELEMENTS IN LIST\n         LCR   #7,#7               MAKE IT POSITIVE\n         SLA   #7,2                MULTIPLY BY 4 FOR VECTOR LENGTH\n         LR    #2,#7               SET LENGTH FOR ZILVSS\n         XR    #1,#1               ENTRY CODE 0 = ALLOCATE NEW SPACE\n         L     #15,ZLCVSS          GET ADDRESS OF STRING SPACE SERVICE\n         LA    #0,16(,#11)         SET CURRENT STACK LOCATION\n         #BASR #14,#15             CALL ZILVSS TO BUILD THE OBJECT\n         LTR   #4,#4               IF STRING BUILD FAILED\n         BZ    ERROR2              THEN ERROR\n         MVI   ##TYPE(#15),##VECTOR SET OBJECT TYPE = VECTOR\n         L     #2,0(,#11)          GET ARG 1 (THE LIST)\n         LA    #6,4                SET INCREMENT REGISTER FOR BXLE\n         BCTR  #7,0                SET TERMINATION REGISTER FOR BXLE\n         XR    #1,#1               SET INDEX REGISTER\nINITLOOP L     #0,##CAR(,#2)       GET EACH ELEMENT OF LIST\n         ST    #0,0(#1,#4)         INITIALIZE EACH ELEMENT IN VECTOR\n         L     #2,##CDR(,#2)       GET NEXT LIST ELEMENT\n         BXLE  #1,#6,INITLOOP\n         SPACE 1\nRETURN   DS    0H                  #15 POINTS TO VECTOR BUILT\n         SPACE 1\n         #ZRET ,\n         SPACE 1\nERROR1   #ERR  'Argument to ZMVECTOR not a proper list - ',0(#11)\nERROR2   #ERR  PREFIX=NO,'ZIL4010 ZMVECTOR: Not enough vector/string spX\n               ace to build vector.'\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZPUTFPI": {"ttr": 18689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x01_\\x00\\x89\\x15o\\x11V\\x00&\\x00#\\x00%\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-15T00:00:00", "modifydate": "1989-06-05T11:56:00", "lines": 38, "newlines": 35, "modlines": 37, "user": "SEB1525"}, "text": "         TITLE 'ZPUTFPI - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS FUNCTION UPDATES THE CURRENT CHARACTER POSITION OF THE         *\n* SPECIFIED INPUT FILE FROM A FIXNUM ATOM, AND RETURNS THAT VALUE.    *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* ZPUTFPI TAKES TWO ARGUMENTS: ARGUMENT 1 = THE NEW CHARACTER POINTER *\n*                              ARGUMENT 2 = INPUT FILE SPEC (OPT.)    *\n*                                                                     *\n***********************************************************************\n         SPACE\nZPUTFPI  #ZBEG MINARGS=1,MAXARGS=2,NAME='ZPUTFPI'\n         #ZPDS 20                  DEFINE STACK SIZE\n         #ZSAV ,                   SAVE REGISTERS\n         SPACE\n         #IFIL 2                   ARG 2 = INPUT FILE SPEC\n         SPACE\n         L     #15,0(,#11)         GET ARG 1\n         CLI   ##TYPE(#15),##FIXNUM IF NOT A FIXNUM\n         BNE   ERR2113             THEN ERROR\n         L     #14,##CDR(,#15)     GET FIXNUM VALUE\n         ST    #14,ZLFCHAR         SET CURRENT CHARACTER POINTER\n         SPACE\n         #ZRET ,                   RESTORE REGISTERS AND RETURN\n         SPACE\nERR2113  DS    0H\n         #ERR  'Argument 1 to ZPUTFPI not a fixnum - ',0(#11)\n         SPACE\n         LTORG\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZRMINIT": {"ttr": 18691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x882?\\x00\\x89\\x15o\\x11V\\x00S\\x00P\\x00R\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1989-06-05T11:56:00", "lines": 83, "newlines": 80, "modlines": 82, "user": "SEB1525"}, "text": "         TITLE 'ZRMINIT - BUILT-IN ZIL 1.3 SUBROUTINE'\n***********************************************************************\n*                                                                     *\n* ZIL Version 1.3 (c) 1989 The Charles Stark Draper Laboratory Inc.   *\n*                     All rights reserved.                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* THIS SUBR IS CALLED BY READ OR RDRMACRO WHEN THE READTABLE IS NOT   *\n* YET ALLOCATED.  IT ALLOCATES AND INITIALIZES THE READTABLE,         *\n* ESTABLISHING THE DEFAULT SYSTEM READER MACRO DEFINITIONS.           *\n*                                                                     *\n* It also initializes the ZIL work area, used to build atoms.         *\n*                                                                     *\n* Also, this function may be used to reinitialize an                  *\n* existing readtable (e.g. after RMMAC has changed it).               *\n*                                                                     *\n* THIS ROUTINE USES REGISTERS 14 THROUGH 2.                           *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nZRMINIT  #ZBEG MINARGS=0,MAXARGS=0,NAME='ZRMINIT',SUBRS=ZILSUBR\n         SPACE 1\n         DROP  #15\n         SPACE 1\n         LR    #2,#15\n         USING ZRMINIT,#2\n         ICM   #1,15,ZLCRDTBL      IF WE DON'T HAVE A READTABLE YET,\n         BNZ   GOTIT               THEN...\n         LA    #0,256               GET LENGTH OF STORAGE FOR READTABLE\n         GETMAIN R,LV=(0)           GET STORAGE FOR IT\n         ST    #1,ZLCRDTBL          SAVE ITS ADDRESS\nGOTIT    DS    0H                  NOW INITIALIZE THE READTABLE\n         MVC   0(256,#1),READTBL   COPY CONSTANT READ TABLE TO OURS\n         L     #15,@RMQUOTE        GET ADDRESS OF ZRMQUOTE SUBROUTINE\n         STCM  #15,7,QUOTEMAC+1    STORE INTO READER MACRO FORM\n         L     #15,@RMSHARP        GET ADDRESS OF ZRMSHARP SUBROUTINE\n         STCM  #15,7,SHARPMAC+1    STORE INTO READER MACRO FORM\n         L     #15,@RMBQ           GET ADDRESS OF ZRMBQ SUBROUTINE\n         STCM  #15,7,BACKQMAC+1    STORE INTO READER MACRO FORM\n         L     #15,@RMCOMMA        GET ADDRESS OF ZRMCOMMA SUBROUTINE\n         STCM  #15,7,COMMAMAC+1    STORE INTO READER MACRO FORM\n         LA    #15,QUOTEMAC        POINT TO READER MACRO CHAIN\n         ST    #15,ZLCRMCHN        ADD TO (EMPTY) READER MACRO CHAIN\n         OI    C''''(#1),X'80'     IDENTIFY READER MACRO CHARACTER\n         OI    C'#'(#1),X'80'      IDENTIFY READER MACRO CHARACTER\n         OI    C'`'(#1),X'80'      IDENTIFY READER MACRO CHARACTER\n         OI    C','(#1),X'80'      IDENTIFY READER MACRO CHARACTER\n         SPACE 1\n         ICM   #1,15,ZLCWA         GET ADDRESS OF ZIL WORK AREA\n         BNZ   RETURN              IF ALREADY ALLOCATED, RETURN\n         LA    #0,512              ELSE SET UP INITIAL LENGTH\n         ST    #0,ZLCWALEN         SAVE ITS LENGTH\n         #GETMAIN RU,LV=(0),LOC=BELOW GETMAIN THE WORK AREA\n         ST    #1,ZLCWA            SAVE ITS ADDRESS\nRETURN   DS    0H\n         LR    #15,#10             SET RETURN VALUE TO NIL\n         BR    #14                 RETURN\n         SPACE 1\nZILSUBRS DS    0A                  EXTERNAL SUBROUTINES\n@RMQUOTE DC    V(ZRMQUOTE)         ADDRESS OF ' PROCESSOR\n         DC    CL8'ZRMQUOTE'\n@RMSHARP DC    V(ZRMSHARP)         ADDRESS OF # PROCESSOR\n         DC    CL8'ZRMSHARP'\n@RMBQ    DC    V(ZRMBQ)            ADDRESS OF ` PROCESSOR\n         DC    CL8'ZRMBQ'\n@RMCOMMA DC    V(ZRMCOMMA)         ADDRESS OF , PROCESSOR\n         DC    CL8'ZRMCOMMA'\nZILSUBRE DS    0A                  END OF SUBROUTINES\n         SPACE 1\n*\n* THE (STATIC) INITIAL READER-MACRO CHAIN.\n*\nQUOTEMAC DC    C'''',AL3(*-*),A(SHARPMAC)\nSHARPMAC DC    C'#',AL3(*-*),A(BACKQMAC)\nBACKQMAC DC    C'`',AL3(*-*),A(COMMAMAC)\nCOMMAMAC DC    C',',AL3(*-*),A(0)\n         SPACE 1\nREADTBL  #RTBL ,                   DEFINE THE READ TABLE\n         SPACE 1\n         LTORG\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT476/CBT.V500.FILE476.PDS/ASM.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT476/CBT.V500.FILE476.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}