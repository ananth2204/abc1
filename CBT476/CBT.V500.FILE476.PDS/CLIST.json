{"INMR01": {"INMLRECL": 80, "INMFNODE": "CSDLMVS", "INMFUID": "SEB1525", "INMTNODE": "MVS", "INMTUID": "CSDL", "INMFTIME": "20010419151230000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 6233, "INMRECFM": "VB", "INMDIR": 9, "INMDSNAM": "PROGLIB.ZILCBT.CLIST", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"PROGLIB.ZILCBT.CLIST": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6233, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "010109", "DS1SCEXT": "b'\\x80\\x18Y'", "DS1SCALO": "b'P\\x00\\x002'", "DS1LSTAR": "b'\\x00\\x04\\x0e'", "DS1TRBAL": "b'-('"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\xaaM`'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\xaaM`'", "b'X\\xaa^0\\x00\\x00\\x01\\xbd\\x00\\x0c\\x01\\xbe\\x00\\x00\\x00\\x04'", "b'X\\xaa^0\\x00\\x00\\x01\\xe6\\x00\\x08\\x01\\xe6\\x00\\x0e\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$CONFIG": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\t\\x01\\x00$?\\x01\\x01\\x10\\x9f\\x14I\\x01:\\x00\\xfb\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2000-08-30T00:00:00", "modifydate": "2001-04-19T14:49:09", "lines": 314, "newlines": 251, "modlines": 0, "user": "SEB1525"}, "text": "/* REXX.  Fix all members of ZIL distribution for installation. */\n\n/* This exec must be run under ISPF.  If you run it in batch, you must\n   run it under ISPF in batch.  I should add code to run it either way\n*/\n\ntrace off\nsignal on novalue\naddress ispexec\n\nz = 0\n\n/* For all entries other than the \"doitqual\" entry,                 */\n/* change only the \"new\" text values to be changed in this section. */\n/* If something is not to be changed, make the newstring the same   */\n/* as the oldstring.                                                */\n\n/* Base of libraries as extracted from the received XMIT file by    */\n/* CBTxxx.FILExxx.PDS($RECEIVE) job (after editing).                */\n\ndoitqual = \"YOURHLQ?ZIL.\"\n\n/* Base of libraries to be created for production ZIL use.          */\n\nz = z + 1\noldstring.z = \"PROGLIB.ZIL.\"\nnewstring.z = \"SYS8.LISP.\"\n\n/* High level qualifier of other libraries to be used at run time.  */\n\nz = z + 1\noldstring.z = \"PROGLIB\"\nnewstring.z = \"SYS8\"\n\n/* The name of the linkedit-time library containing the             */\n/* Fortran math subroutines (SQRT, DSIN, etc., etc.).  If you do    */\n/* not have these Fortran routines, you will not be able to use     */\n/* the transcendental math functions in Zil.                        */\n\nz = z + 1\noldstring.z = \"SYS1.VSF2FORT\"\nnewstring.z = \"SYS1.FORTLIB\"\n\n/* The name of the assembler on your system.                        */\n\nz = z + 1\noldstring.z = \"SYS1.LINKLIB(IEV90)\"\nnewstring.z = \"SYS1.ASMLIB(ASMBLR)\"\n\n/* The name of the primary assembler macro library.                 */\n\nz = z + 1\noldstring.z = \"SYS1.MACLIB\"\nnewstring.z = \"SYS1.IBM.MACLIB\"\n\n/* The name of the secondary assembler macro library.               */\n\nz = z + 1\noldstring.z = \"SYS1.MODGEN\"\nnewstring.z = \"SYS1.AMODGEN\"\n\n/* JOB card parameter for ZIL compiler JCL.                         */\n\nz = z + 1\noldstring.z = \"REGION=6144K\"\nnewstring.z = \"REGION=6144K\"\n\n/* JOB card parameter for ZIL compiler JCL.                         */\n/* Should match the value of HELDSYSOUTCLASS below.                 */\n\nz = z + 1\noldstring.z = \"MSGCLASS=H\"\nnewstring.z = \"MSGCLASS=H\"\n\n/* Held SYSOUT class for foreground Zil options.                    */\n\nz = z + 1\noldstring.z = \"HELDSYSOUTCLASS = H\"\nnewstring.z = \"HELDSYSOUTCLASS = H\"\n\n/* If the EXECPGM utility (from the CBT tape) is available on       */\n/* your system by default, say Y.  Otherwise say N.                 */\n\nz = z + 1\noldstring.z = \"EXECPGM_IS_AVAILABLE = N\"\nnewstring.z = \"EXECPGM_IS_AVAILABLE = Y\"\n\n/* If you add features here, they must be uppercase versions       */\n/* of the ones you activate in CNTL member $$ZILSET.               */\n/* And don't forget the trailing blank after the last one!!!       */\n\nz = z + 1\noldstring.z = \"CSDL DRAPER \"         /* This one is for FEATURES.  */\nnewstring.z = \"\"                     /* Add local features here.   */\n\n/* End of text section. */\n\nstringcount = z\n\nif doitqual = \"YOURHLQ?ZIL.\" then do\n say \"You must edit this exec before running it.\"\n say \"Please see the instructions in the source code of the exec.\"\n exit\nend\n\ncall doit \"'\"doitqual\"CLIST'\"    , 0 , \"/*\"\ncall doit \"'\"doitqual\"CNTL'\"     , 1 , \"//*\"\ncall doit \"'\"doitqual\"HELP'\"     , 1 , \"\"\ncall doit \"'\"doitqual\"MSG'\"      , 0 , \"\"\ncall doit \"'\"doitqual\"PANEL'\"    , 0 , \"\"\ncall doit \"'\"doitqual\"SKEL'\"     , 1 , \"\"\ncall doit \"'\"doitqual\"TEXT'\"     , 0 , \"\"\n\n/* No need to \"do it\" to the ASM or MACLIB libraries,\n   or LISP, for that matter, since it's all compiled already\n   for your convenience.\n*/\n\nreturn\n\n/* ------------------------------------------------------------------ */\n\ndoit: parse arg pds, numbered, comstr\n\nmembercount = 0\nbadmembers = 0\nmember =\n\ncall listdsi pds\nif result <> 0 then do\n say \"Error, cannot update\" pds\":\"\n say sysmsglvl1\n say sysmsglvl2\n return\nend\n\nrecfm = left(sysrecfm,1)\nlrecl = syslrecl\n\n\"LMINIT DATAID(DATAID) DATASET(\"pds\") ENQ(EXCLU)\"\nif rc <> 0 then do\n call ispf_error\n return\nend\n\n\"LMOPEN DATAID(\"dataid\") OPTION(INPUT)\"\nif rc <> 0 then call ispf_error\nelse do\n say \"---\"\n say \"Processing library:\" pds\n say \"---\"\n do forever\n  \"LMMLIST DATAID(\"dataid\") OPTION(LIST) MEMBER(MEMBER) STATS(NO)\"\n  lmrc = rc\n  if lmrc > 8 then call ispf_error\n  else if lmrc > 0 then leave\n  else if left(member,2) = \"$$\" then iterate\n  else do\n   say \"Processing member\" member\n   dmemid = \"\"\n   \"LMINIT DATAID(DMEMID) DATASET(\"pds\") ENQ(EXCLU)\"\n   if rc > 0 then call ispf_error\n   \"LMOPEN DATAID(\"dmemid\") OPTION(INPUT)\"\n   if rc > 0 then call ispf_error\n   \"LMMFIND DATAID(\"dmemid\") MEMBER(\"member\")\"\n   if rc > 0 then call ispf_error\n   l.  = \"\"\n   l.0 = 0\n   i   = 0\n   do forever\n    line = \"\"\n    len = 0\n    \"LMGET DATAID(\"dmemid\") MODE(INVAR)\"  ,\n    \"DATALOC(LINE) DATALEN(LEN) MAXLEN(80)\"\n    if rc = 8 then leave\n    if rc > 0 then call ispf_error\n    i = i + 1\n    l.i = line\n   end\n   l.0 = i\n   \"LMCLOSE DATAID(\"dmemid\")\"\n   if rc > 0 then call ispf_error\n   changed = 0\n   do i = 1 to l.0\n    l.i = update(l.i,i,comstr)   /* may set \"changed\" flag */\n   end\n   if changed then do\n    \"LMOPEN DATAID(\"dmemid\") OPTION(OUTPUT)\"\n    if rc > 0 then call ispf_error\n    do i = 1 to l.0\n     line = l.i\n     if line = \"\" then line = \" \" /* bleaugh */\n     len = length(line)\n     \"LMPUT DATAID(\"dmemid\") MODE(INVAR)\"  ,\n     \"DATALOC(LINE) DATALEN(\"len\")\"\n     if rc > 0 then call ispf_error\n    end\n    \"LMMREP DATAID(\"dmemid\") MEMBER(\"member\") STATS(NO)\"\n    if rc > 8 then call ispf_error\n    else if rc = 8 then say \"Member\" member \"did not exist. Added.\"\n    else say \"Member\" member \"replaced.\"\n    \"LMCLOSE DATAID(\"dmemid\")\"\n    if rc > 0 then call ispf_error\n   end\n   else do\n    say \"Member\" member \"was not changed.\"\n   end\n  end\n end\nend\n\n\"LMCLOSE DATAID(\"dataid\")\"\nif rc > 0 then call ispf_error\n\nsay \"*** Compressing\" pds \"***\"\n\"LMCOMP DATAID(\"dataid\")\"\nif rc > 0 then call ispf_error\nsay \"Compress complete.\"\n\n\"LMFREE DATAID(\"dataid\")\"\nif rc <> 0 then call ispf_error\n\nreturn\n\n/* ------------------------------------------------------------------ */\n\nispf_error:\n\n zerrlm1 = zerrlm\n \"DISPLAY PANEL(ISPTERM)\"\n\nreturn\n\n/* ------------------------------------------------------------------ */\n\nupdate: parse arg line, eye, commentprefix\n\nline  = strip(line,\"T\")\ncline = line\nnline = line\n\nif commentprefix <> \"\" then do\n if left(cline,length(commentprefix)) = commentprefix then return nline\nend\n\ndo j = 1 to stringcount\n if oldstring.j = newstring.j then iterate j\n if numbered then do\n  linepart = strip(left(cline,72),\"T\")\n  linerest = substr(cline,73,8)\n end\n else do\n  linepart = strip(cline,\"T\")\n  linerest = \"\"\n end\n nl = change(linepart,oldstring.j,newstring.j)\n if numbered then do\n  if length(nl) > 72 then do\n   say\n   say \"*** Error: Line\" eye \"was truncated.  Not changed:\"\n   say\n   say cline\n   say\n   nline = cline\n  end\n  else do\n   nline = left(nl,72) || linerest\n  end\n end\n else do\n  if length(nl) > lrecl then do\n   say\n   say \"*** Error: Line\" eye \"was truncated.  Not changed:\"\n   say\n   say cline\n   say\n   nline = cline\n  end\n  else do\n   nline = nl\n  end\n end\n cline = nline\nend\n\nif nline <> line then do\n say\n say \"Line\" eye \"changed from:\"\n say left(line,79)\n say \"to:\"\n say left(nline,79)\n changed = 1\nend\n\nreturn nline\n\n/* ------------------------------------------------------------------ */\n\nchange: parse arg string,from,to\n\nfl = length(from)\nnewline = \"\"\nix = 1\ndo forever\n ix = pos(from,string)\n if ix = 0 then return newline || string\n part1 = substr(string, 1, ix-1)\n part2 = substr(string, ix+fl)\n newline = newline || part1 || to\n string = part2\nend\n\nreturn newline\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISP": {"ttr": 37, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x01\\x00$\\x1f\\x01\\x00$?\\x10\\x18\\x00x\\x00w\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-08-28T00:00:00", "modifydate": "2000-08-30T10:18:31", "lines": 120, "newlines": 119, "modlines": 0, "user": "SEB1525"}, "text": "/***********************************************************************\n/*                                                                     *\n/* ZIL VERSION 1.3 - invoke the ZIL interpreter, without ISPF          *\n/*                                                                     *\n/***********************************************************************\nPROC 0 +\n       SUBRLIB() INITFILE() NOINITFILE +\n       ACSIZE() CSSIZE() PDSIZE() VSSIZE() +\n       DRIBBLE +\n       LIBRARY() +\n       NEW OLD XTRACE\n\nNGLOBAL RESULT\n\nIF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\nCONTROL NOCAPS\n\nIF &NEW&OLD = NEW THEN SET SYS = N\nELSE IF &NEW&OLD = OLD THEN SET SYS = O\nELSE IF &NEW&OLD =     THEN SET SYS =\nELSE DO\n WRITE Cannot specify both NEW and OLD - specify one or neither.\n EXIT C(12) Q\nEND\n\n/* You may need to do some configuring in this section. */\n\nSET DEFAULTLIBRARY = &STR(PROGLIB.ZIL.&SYS.LOAD)\n\nSET HELDSYSOUTCLASS = H        /* JES held SYSOUT class */\n\n/* If the EXECPGM command from file 183 of the CBT tape is present\n/* on your system, set this variable to Y.  Otherwise set it to N.\n\nSET EXECPGM_IS_AVAILABLE = N\n\n/* End of configuring section. */\n\nIF &SYSTSOE GE 2050 THEN SET TSOLIB_IS_AVAILABLE = Y\nELSE SET TSOLIB_IS_AVAILABLE = N\n\nSET SUBMETHOD =\nIF &NRSTR(&SUBRLIB) NE THEN DO\n IF      &EXECPGM_IS_AVAILABLE = Y THEN SET SUBMETHOD = EXECPGM\n ELSE IF &TSOLIB_IS_AVAILABLE  = Y THEN DO\n  ISPQRY\n  IF &LASTCC = 0 THEN DO\n   WRITE Error: SUBRLIB is not available from within ISPF.\n   WRITE        Please reinvoke this CLIST from TSO READY mode, or\n   WRITE        without the SUBRLIB keyword.\n   EXIT C(16) Q\n  END\n  ELSE DO\n   SET SUBMETHOD = TSOLIB\n  END\n END\n ELSE DO\n  WRITE Error: SUBRLIB is not available.\n  WRITE        Please reinvoke this CLIST without the SUBRLIB keyword.\n  EXIT C(16) Q\n END\nEND\n\nIF &STR(&LIBRARY) = THEN SET LIBRARY = &STR(&DEFAULTLIBRARY)\n\nSET PRESENT_FILES =\nSET MISSING_FILES =\nIF &STR(&INITFILE) = THEN SET NOINITFILE = NOINITFILE\nIF &NOINITFILE = THEN DO\n ALLOC F(ZILIINIT) DA(&INITFILE) SHR REU\n SET PRESENT_FILES = &PRESENT_FILES ZILIINIT\nEND\nELSE DO\n SET MISSING_FILES = &MISSING_FILES ZILIINIT\nEND\nIF &DRIBBLE = DRIBBLE THEN DO\n ALLOC F(ZILDRIBL) SYSOUT(&HELDSYSOUTCLASS) HOLD REU\n SET PRESENT_FILES = &PRESENT_FILES ZILDRIBL\nEND\nELSE DO\n SET MISSING_FILES = &MISSING_FILES ZILDRIBL\nEND\nIF &MISSING_FILES \u00ac= THEN DO\n IF &XTRACE = THEN CONTROL NOMSG\n FREE F(&MISSING_FILES)\n CONTROL MSG\nEND\n\nIF &STR(&ACSIZE) \u00ac= THEN SET ACSIZE = &STR(A=&ACSIZE)\nELSE SET ACSIZE =\nIF &STR(&CSSIZE) \u00ac= THEN SET CSSIZE = &STR(C=&CSSIZE)\nELSE SET CSSIZE =\nIF &STR(&PDSIZE) \u00ac= THEN SET PDSIZE = &STR(P=&PDSIZE)\nELSE SET PDSIZE =\nIF &STR(&VSSIZE) \u00ac= THEN SET VSSIZE = &STR(V=&VSSIZE)\nELSE SET VSSIZE =\n\nSET ZILINPARMS = &NRSTR(\\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&INITFILE)\n\nIF &SUBMETHOD = EXECPGM THEN DO\n ALLOC FI(ZILLIB) DA(&SUBRLIB '&LIBRARY') SHR REU\n EXECPGM ZILIN PARM('&NRSTR(&ZILINPARMS)') TASKLIB(ZILLIB)\n SET CC = &LASTCC\n FREE FI(ZILLIB)\nEND\nELSE IF &SUBMETHOD = TSOLIB THEN DO\n TSOLIB ACT DATASET(&SUBRLIB '&LIBRARY')\n CALL *(ZILIN) '&NRSTR(&ZILINPARMS)'\n SET CC = &LASTCC\n TSOLIB DEACT\nEND\nELSE DO\n CALL '&LIBRARY(ZILIN)' '&NRSTR(&ZILINPARMS)'\n SET CC = &LASTCC\nEND\n\nIF &CC \u00ac= 0 THEN WRITE *** LISP interpreter exited with code &CC ***\nIF &PRESENT_FILES \u00ac= THEN FREE F(&PRESENT_FILES)\n\nEXIT C(&CC)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISPCOMP": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x00$\\x1f\\x01\\x00$\\x1f\\x16\"\\x02\\xa2\\x02\\xa2\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-08-28T00:00:00", "modifydate": "2000-08-28T16:22:35", "lines": 674, "newlines": 674, "modlines": 0, "user": "SEB1525"}, "text": "\n/**********************************************************************/\n/*                                                                    */\n/* LISPCOMP - compile a ZIL (LISP) source file                        */\n/*                                                                    */\n/**********************************************************************/\n\nPROC 1  DSNAME +\n        FUNCTION PROGRAM MODULE +\n        NAME() +\n        LOAD() NOLOAD +\n        ASM() NOASM +\n        PRINT(*) NOPRINT +\n        MACROS() +\n        SUBRLIB() +\n        ACSIZE() +\n        CSSIZE() +\n        PDSIZE() +\n        VSSIZE() +\n        DEBUG NODEBUG +\n        TRANSDEBUG NOTRANSNODEBUG +\n        SYSPARM(XA) +\n        NEW OLD +\n        XTRACE\n\nNGLOBAL RESULT\n\nIF &XTRACE = XTRACE THEN CONTROL LIST SYMLIST CONLIST\nCONTROL NOCAPS\n\n/*  Preliminary syntax checks  */\n\nIF &NOASM = NOASM THEN DO\n SET ASM =\n SET NOLOAD = NOLOAD\nEND\nIF &NOLOAD = NOLOAD THEN SET LOAD =\n\nSET KIND = &FUNCTION &PROGRAM &MODULE\nIF &KIND = THEN DO\n WRITE LISPCOMP: Compile of MODULE assumed.\n SET KIND = MODULE\nEND\nELSE IF &KIND \u00ac= FUNCTION && &KIND \u00ac= PROGRAM && &KIND \u00ac= MODULE THEN DO\n WRITE LISPCOMP: Conflicting operands specified - &KIND\n EXIT C(12) Q\nEND\n\nIF &NEW&OLD = NEW THEN SET SYS = N\nELSE IF &NEW&OLD = OLD THEN SET SYS = O\nELSE IF &NEW&OLD =     THEN SET SYS =\nELSE DO\n WRITE Cannot specify both NEW and OLD - specify one or neither.\n EXIT C(12) Q\nEND\n\n/* You may need to do some configuring in this section. */\n\nSET LIBRARY    = &STR(PROGLIB.ZIL.&SYS.LOAD)\nSET MACLIB     = &STR(PROGLIB.ZIL.&SYS.MACLIB)\nSET ASSEMBLER  = &STR('SYS1.LINKLIB(IEV90)')\nSET SYSMACLIB  = &STR('SYS1.MACLIB')\nSET TEMPPREFIX = &STR(&SYSPREF..ZIL.$ZILTEMP)\n\n/* If the EXECPGM command from file 183 of the CBT tape is present\n/* on your system, set this variable to Y.  Otherwise set it to N.\n\nSET EXECPGM_IS_AVAILABLE = N\n\n/* End of configuring section. */\n\nIF &SYSTSOE GE 2050 THEN SET TSOLIB_IS_AVAILABLE = Y\nELSE SET TSOLIB_IS_AVAILABLE = N\n\nSET SUBMETHOD =\nIF &NRSTR(&SUBRLIB) NE THEN DO\n IF      &EXECPGM_IS_AVAILABLE = Y THEN SET SUBMETHOD = EXECPGM\n ELSE IF &TSOLIB_IS_AVAILABLE  = Y THEN DO\n  ISPQRY\n  IF &LASTCC = 0 THEN DO\n   WRITE Error: SUBRLIB is not available from within ISPF.\n   WRITE        Please reinvoke this CLIST from TSO READY mode, or\n   WRITE        without the SUBRLIB keyword.\n   EXIT C(16) Q\n  END\n  ELSE DO\n   SET SUBMETHOD = TSOLIB\n  END\n END\n ELSE DO\n  WRITE Error: SUBRLIB is not available.\n  WRITE        Please reinvoke this CLIST without the SUBRLIB keyword.\n  EXIT C(16) Q\n END\nEND\n\nIF &STR(&ACSIZE) \u00ac= THEN SET ACSIZE = &STR(A=&ACSIZE)\nELSE SET ACSIZE =\nIF &STR(&CSSIZE) \u00ac= THEN SET CSSIZE = &STR(C=&CSSIZE)\nELSE SET CSSIZE =\nIF &STR(&PDSIZE) \u00ac= THEN SET PDSIZE = &STR(P=&PDSIZE)\nELSE SET PDSIZE =\nIF &STR(&VSSIZE) \u00ac= THEN SET VSSIZE = &STR(V=&VSSIZE)\nELSE SET VSSIZE =\n\nIF &XTRACE = THEN CONTROL NOMSG\nFREE F(SYSIN SYSLIN SYSPRINT SYSLIB SYSUT1 SYSTERM)\nCONTROL MSG\n\nSYSCALL SETDSN &DSNAME TYPE(LISP) ANYORG MEMBER VERIFY LET\nSET MEMCC = &LASTCC\nSET SYSDVAL = &NRSTR(&RESULT)\nIF &MEMCC > 0 THEN EXIT C(&MEMCC) Q\nREADDVAL DSIDENT DSTYPE DSMEM\nIF &STR(&DSMEM) \u00ac= THEN DO\n SET MEMBER = &STR((&DSMEM))\nEND\nELSE SET MEMBER =\nSET ZILCODE = &STR('&DSIDENT..&DSTYPE&MEMBER')\n\nSET INPUTNAME = &STR(&DSMEM)\n\nIF &NOPRINT = NOPRINT THEN DO\n SET PRINT =\nEND\nELSE IF &STR(&PRINT) \u00ac= &STR(*) +\n     && &STR(&PRINT) \u00ac= THEN DO\n SYSCALL SETDSN &PRINT TYPE(ZILLIST) ANYORG NOCHECKMEMBER OPTIONAL LET\n SET MEMCC = &LASTCC\n SET SYSDVAL = &NRSTR(&RESULT)\n READDVAL PRIDENT PRTYPE PRMEM\n IF &STR(&PRMEM) \u00ac= THEN SET MEMBER = &STR((&PRMEM))\n ELSE SET MEMBER =\n SET PRINT = &STR('&PRIDENT..&PRTYPE&MEMBER')\n IF &MEMCC = 8 THEN DO\n  IF &STR(&MEMBER) = THEN SYSCALL MAKEDS &PRINT LISTF120\n  ELSE SYSCALL MAKEPDS &PRINT LISTF120\n END\n ELSE IF &MEMCC > 0 THEN EXIT C(&MEMCC) Q\nEND\nELSE DO\n SET PRINT = &STR(*)\nEND\n\nIF &NOASM = NOASM THEN DO\n SET ASMCODE =\nEND\nELSE IF &STR(&ASM) \u00ac= THEN DO\n SYSCALL SETDSN &ASM TYPE(ASM) ANYORG MEMBER NOCHECKMEMBER OPTIONAL LET\n SET MEMCC = &LASTCC\n SET SYSDVAL = &NRSTR(&RESULT)\n READDVAL ASMIDENT ASMTYPE ASMMEM\n IF &STR(&ASMMEM) \u00ac= THEN SET MEMBER = &STR((&ASMMEM))\n ELSE SET MEMBER =\n SET ASMCODE = &STR('&ASMIDENT..&ASMTYPE&MEMBER')\n IF &MEMCC = 8 THEN DO\n  IF &STR(&MEMBER) = THEN SYSCALL MAKEDS '&ASMIDENT..&ASMTYPE' ASM\n  ELSE SYSCALL MAKEPDS '&ASMIDENT..&ASMTYPE' ASM\n END\n ELSE IF &MEMCC > 4 THEN EXIT C(&MEMCC) Q\nEND\nELSE DO\n SET ASMCODE = &STR('&TEMPPREFIX..ASM')\nEND\n\nSET ASMLIST = &STR('&TEMPPREFIX..ASMLIST')\nSET OBJCODE = &STR('&TEMPPREFIX..OBJ')\n\nIF &NOLOAD = NOLOAD THEN DO\n SET SYSLMOD =\nEND\nELSE DO\n IF &STR(&LOAD) = THEN DO\n  IF &STR(&NAME) \u00ac= THEN SET OUTPUTNAME = &STR(&NAME)\n  ELSE IF &STR(&INPUTNAME) \u00ac= THEN SET OUTPUTNAME = &STR(&INPUTNAME)\n  ELSE SET OUTPUTNAME =\n  SET LDIDENT = &STR(&DSIDENT)\n  SET LDTYPE = LOAD\n END\n ELSE DO\n  SYSCALL SETDSN &LOAD +\n          TYPE(LOAD) PDSORG NOCHECKMEMBER OPTIONAL LET\n  SET MEMCC = &LASTCC\n  SET SYSDVAL = &NRSTR(&RESULT)\n  READDVAL LDIDENT LDTYPE LDMEM\n  IF &MEMCC > 4 THEN EXIT C(&MEMCC) Q\n  IF &STR(&LDMEM) = THEN DO\n   IF &STR(&NAME) \u00ac= THEN SET LDMEM = &STR(&NAME)\n   ELSE IF &STR(&INPUTNAME) \u00ac= THEN SET LDMEM = &STR(&INPUTNAME)\n   /* Otherwise LDMEM and OUTPUTNAME will be blank, which will\n   /* be flagged below as an error.\n  END\n  SET OUTPUTNAME = &STR(&LDMEM)\n END\n IF &STR(&OUTPUTNAME) \u00ac= THEN DO\n  SET MEMBER = &STR((&OUTPUTNAME))\n END\n ELSE SET MEMBER =\n SET SYSLMOD = &STR('&LDIDENT..&LDTYPE&MEMBER')\nEND\n\nIF &STR(&NAME) = THEN DO\n IF &STR(&OUTPUTNAME) \u00ac= THEN SET NAME = &STR(&OUTPUTNAME)\n ELSE +\n  IF &STR(&INPUTNAME) \u00ac= THEN SET NAME = &STR(&INPUTNAME)\n ELSE DO\n  WRITE LISPCOMP: Input is sequential, a NAME is required\n  EXIT C(12) Q\n END\nEND\n\nSET KINDPARM = &SUBSTR(1,&KIND)\nIF &DEBUG = DEBUG THEN SET DEBUGPARM = Y\nELSE SET DEBUGPARM = N\nSET PARM = &STR(&KINDPARM&DEBUGPARM&NAME)\n\nWRITE Compiling &SYSLC(&KIND) &NAME....\nWRITE Source:   &ZILCODE\nIF &STR(&ASM) \u00ac= THEN +\nWRITE Assemble: &ASMCODE\nIF &NOLOAD = THEN +\nWRITE Load:     &SYSLMOD\n\nIF &NOASM = NOASM THEN DO\n ALLOC F(ZILOCODE) DUMMY REU\n ALLOC F(SYSIN)    DUMMY REU\nEND\nELSE DO\n SYSCALL MAKEDS &ASMCODE ASM SIZE(20)\n ALLOC F(ZILOCODE) DA(&ASMCODE) REU\n ALLOC F(SYSIN) DA(&ASMCODE) REU\nEND\nALLOC F(ZILI) DA(*) REU\nIF &NOPRINT = NOPRINT THEN DO\n ALLOC F(ZILO) DUMMY REU\nEND\nELSE DO\n ALLOC F(ZILO) DA(&PRINT) REU\nEND\nIF &STR(&MACROS) \u00ac= THEN +\n ALLOC F(ZILICMAC) SHR REU DA(&MACROS)\nELSE +\n ALLOC F(ZILICMAC) DUMMY REU\nALLOC F(ZILISRC) SHR REU DA(&ZILCODE)\nIF &TRANSDEBUG&NOTRANSDEBUG = TRANSDEBUG THEN DO\n ALLOC F(ZILOCTRN) SP(100 100) T REL REU DEL\n SET CTRN = Y\nEND\nELSE DO\n IF &XTRACE = THEN CONTROL NOMSG\n FREE F(ZILOCTRN)\n CONTROL MSG\n SET CTRN = N\nEND\n\nSET ZILCOPARMS = &NRSTR(\\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&PARM)\n\nIF &SUBMETHOD = EXECPGM THEN DO\n ALLOC FI(ZILLIB) DA(&SUBRLIB '&LIBRARY') SHR REU\n EXECPGM ZILCO PARM('&NRSTR(&ZILCOPARMS)') TASKLIB(ZILLIB)\n SET ZILCOCC = &LASTCC\n FREE FI(ZILLIB)\nEND\nELSE IF &SUBMETHOD = TSOLIB THEN DO\n TSOLIB ACT DATASET(&SUBRLIB '&LIBRARY')\n CALL *(ZILCO) '&NRSTR(&ZILCOPARMS)'\n SET ZILCOCC = &LASTCC\n TSOLIB DEACT\nEND\nELSE DO\n CALL '&LIBRARY(ZILCO)' '&NRSTR(&ZILCOPARMS)'\n SET ZILCOCC = &LASTCC\nEND\n\nIF &ZILCOCC \u00ac= 0 THEN DO\n IF &NOPRINT = NOPRINT THEN DO\n  WRITE LISPCOMP: ZIL compilation failed with error code &ZILCOCC..\n  WRITE           Rerun this CLIST without NOPRINT to determine the error.\n END\n ELSE IF &SUBSTR(1,&PRINT ) = ' THEN DO\n  WRITE LISPCOMP: ZIL compilation failed with error code &ZILCOCC..\n  WRITE           Browse &PRINT to determine the error.\n END\n EXIT C(&ZILCOCC) QUIT\nEND\nFREE F(ZILISRC ZILICMAC ZILI ZILO)\nIF &CTRN = Y THEN DO\n SYSCALL LISTFILE ZILOCTRN\n FREE F(ZILOCTRN)\nEND\n\nIF &NOASM&NOLOAD \u00ac= THEN EXIT\n\nWRITE LISPCOMP: &NAME compiled into &ASMCODE\nIF &SUBSTR(1,&PRINT ) = ' THEN +\nWRITE           Listing in:  &PRINT\n\nIF &SYSDSN(&OBJCODE) \u00ac= OK THEN SYSCALL MAKEDS &OBJCODE OBJ\nIF &SYSDSN(&ASMLIST) \u00ac= OK THEN SYSCALL MAKEDS &ASMLIST ASMLIST\nALLOC F(SYSLIN)     REU DA(&OBJCODE)\nALLOC F(SYSPRINT)   REU DA(&ASMLIST)\nALLOC F(SYSLIB) SHR REU DA(&SYSMACLIB '&MACLIB')\nALLOC F(SYSUT1)     REU T SP(50 50) DEL REL\nALLOC F(SYSTERM)    REU DA(*)\nWRITE Assembly listing output to: &ASMLIST\nWRITE Assembling &NAME into &OBJCODE\n\nCALL &ASSEMBLER +\n     'LIST,TERM,ESD,RLD,NOXREF,OBJECT,NODECK,SYSPARM(&SYSPARM)'\nIF &LASTCC \u00ac= 0 THEN DO\n WRITE LISPCOMP: Assembly failed - check &ASMLIST for errors.\n EXIT C(16) QUIT\nEND\nFREE F(ZILOCODE SYSIN SYSLIN SYSPRINT SYSLIB SYSUT1 SYSTERM)\n\nWRITE Linking &OBJCODE into &SYSLMOD\nIF &SUBRLIB = THEN SET LINKLIB =\nELSE SET LINKLIB = LIB(&SUBRLIB)\nIF &KIND = PROGRAM THEN DO\n LINK &OBJCODE +\n      LOAD(&SYSLMOD) +\n      &LINKLIB +\n      PRINT(*) +\n      LIST LET TERM &MAP &TEST\nEND\nELSE DO\n LINK &OBJCODE +\n      LOAD(&SYSLMOD) +\n      NOPRINT +\n      LIST MAP LET TERM NCAL &MAP &TEST\nEND\nIF &LASTCC > 4 THEN EXIT QUIT\n\nWRITE\nWRITE LISPCOMP: &NAME load module is in &SYSLMOD..\n\nEXIT\n\n/* *** */\n\nSETDSN: +\nPROC 1 DSNAME +\n       TYPE() ANYORG PDSORG SEQORG VERIFY NOVERIFY +\n       MEMBER NOMEMBER LET RECALL NORECALL +\n       OPTIONAL CHECKMEMBER NOCHECKMEMBER\n\nIF &STR(&SYSPREF) = &STR() THEN SET PREFIX =\nELSE SET PREFIX = &STR(&SYSPREF..)\nSET LP = &SUBSTR(1,())\nSET RP = &SUBSTR(2,())\n\nSET RESULT =\nSET ERRORMSG =\nSET ERRORCODE = 0\n\nSELECT &ANYORG&PDSORG&SEQORG\n WHEN (&STR()) SET ORG = ANY\n WHEN (ANYORG) SET ORG = ANY\n WHEN (PDSORG) SET ORG = PDS\n WHEN (SEQORG) SET ORG = SEQ\n OTHERWISE     SET ORG = ANY\nEND\n\nSELECT &ORG\n WHEN (ANY) DO\n  SET MEMBER =\n  IF &MEMBER&NOMEMBER NE MEMBER   THEN SET MEMBER = NOMEMBER\n  IF &VERIFY&NOVERIFY NE NOVERIFY THEN SET VERIFY = VERIFY\n  IF &RECALL&NORECALL NE NORECALL THEN SET RECALL = RECALL\n  IF &CHECKMEMBER&NOCHECKMEMBER NE NOCHECKMEMBER +\n                                  THEN SET CHECKMEMBER = CHECKMEMBER\n END\n WHEN (SEQ) DO\n  SET MEMBER =\n  SET NOMEMBER = NOMEMBER\n  SET CHECKMEMBER =\n  SET NOCHECKMEMBER = NOCHECKMEMBER\n  IF &MEMBER&NOMEMBER NE NOMEMBER THEN SET MEMBER = MEMBER\n  IF &VERIFY&NOVERIFY NE NOVERIFY THEN SET VERIFY = VERIFY\n  IF &RECALL&NORECALL NE NORECALL THEN SET RECALL = RECALL\n  IF &CHECKMEMBER&NOCHECKMEMBER NE NOCHECKMEMBER +\n                                  THEN SET CHECKMEMBER = CHECKMEMBER\n END\n WHEN (PDS) DO\n  IF &MEMBER&NOMEMBER NE NOMEMBER THEN SET MEMBER = MEMBER\n  IF &VERIFY&NOVERIFY NE NOVERIFY THEN SET VERIFY = VERIFY\n  IF &RECALL&NORECALL NE NORECALL THEN SET RECALL = RECALL\n  IF &CHECKMEMBER&NOCHECKMEMBER NE NOCHECKMEMBER +\n                                  THEN SET CHECKMEMBER = CHECKMEMBER\n  IF &NOMEMBER = NOMEMBER THEN NOCHECKMEMBER = NOCHECKMEMBER\n END\nEND\n\nIF &CHECKMEMBER = CHECKMEMBER THEN SET NOVERIFY =\n\nSET L = &LENGTH(&NRSTR(&DSNAME))\n\nIF &SUBSTR(1,&NRSTR(&DSNAME)) = ' THEN DO\n SET QUOTED = Y\n IF &SUBSTR(&L,&NRSTR(&DSNAME)) NE ' THEN DO\n  SET ERRORMSG = &STR(Invalid syntax (mismatched quotes))\n  SET ERRORCODE = 32\n  GOTO BLAZES\n END\n IF &L LT 3 THEN DO\n  SET ERRORMSG = &STR(Invalid syntax (nothing between quotes))\n  SET ERRORCODE = 32\n  GOTO BLAZES\n END\n SET UDSN = &SUBSTR(2:&L-1,&DSNAME)\nEND\nELSE DO\n SET QUOTED = N\n IF &NRSTR(&SYSPREF) = THEN SET UDSN = &NRSTR(&DSNAME)\n ELSE SET UDSN = &NRSTR(&SYSPREF..&DSNAME)\nEND\n\nSET U = &LENGTH(&NRSTR(&UDSN))\n\n/* scan for member name */\n\nSET P = &SYSINDEX(&LP,&NRSTR(&UDSN))\nSET Q = &SYSINDEX(&RP,&NRSTR(&UDSN))\nIF &P > 1 && &Q = &U && &P < &Q-1 THEN DO\n SET DSPART = &SUBSTR(1:&P-1,&NRSTR(&UDSN))\n SET DSMEMB = &SUBSTR(&P+1:&Q-1,&NRSTR(&UDSN))\nEND\nELSE DO\n SET DSPART = &NRSTR(&UDSN)\n SET DSMEMB =\nEND\nSET B = &LENGTH(&NRSTR(&DSPART))\nDO I = &B TO 1 BY -1 WHILE &SUBSTR(&I,&NRSTR(&DSPART)) NE .\nEND\nIF &I = &B THEN DO\n SET ERRORMSG = &STR(Invalid syntax (ends in period))\n SET ERRORCODE = 32\n GOTO BLAZES\nEND\nIF &I = 1 THEN DO\n SET ERRORMSG = &STR(Invalid syntax (start with period))\n SET ERRORCODE = 32\n GOTO BLAZES\nEND\nIF &I = 0 THEN DO\n SET DSBASE = &NRSTR(&DSPART)\n SET DSTYPE =\nEND\nELSE DO\n SET DSBASE = &SUBSTR(1:&I-1,&NRSTR(&DSPART))\n SET DSTYPE = &SUBSTR(&I+1:&B,&NRSTR(&DSPART))\nEND\n\n/* I'm not sure about this.\n\nSET CHANGETYPE = N\n\nIF &LET = LET THEN DO\n IF &QUOTED = N THEN DO\n  IF &NRSTR(&TYPE) NE THEN DO\n   IF &NRSTR(&TYPE) NE &NRSTR(&DSTYPE) THEN DO\n    SET CHANGETYPE = Y\n   END\n  END\n END\nEND\nELSE DO\n IF &QUOTED = Y THEN DO\n  IF &NRSTR(&TYPE) NE THEN DO\n   IF &NRSTR(&TYPE) NE &NRSTR(&DSTYPE) THEN DO\n    SET CHANGETYPE = Y\n   END\n  END\n END\n ELSE DO\n  IF &NRSTR(&TYPE) NE THEN DO\n   IF &NRSTR(&TYPE) NE &NRSTR(&DSTYPE) THEN DO\n    SET CHANGETYPE = Y\n   END\n  END\n END\nEND\n\nIF &CHANGETYPE = Y THEN DO\n SET DSBASE = &NRSTR(&DSPART)\n SET DSTYPE = &NRSTR(&TYPE)\nEND\n\nIF &NRSTR(&DSMEMB) NE THEN SET UDSN = &NRSTR(&DSBASE..&DSTYPE(&DSMEMB))\nELSE                       SET UDSN = &NRSTR(&DSBASE..&DSTYPE)\n\nSET FULLDSN = &NRSTR('&UDSN')\n\nSET RESULT = &NRSTR(&DSBASE &DSTYPE &DSMEMB)\n\nSET STATUS = &SYSDSN(&FULLDSN)\nSELECT &STR(&STATUS)\n WHEN (OK) DO\n END\n WHEN (DATASET NOT FOUND) DO\n  IF &OPTIONAL = OPTIONAL THEN RETURN CODE(8)\n  ELSE DO\n   SET ERRORMSG = &NRSTR(Cannot access data set &FULLDSN: &STATUS)\n   SET ERRORCODE = 8\n   GOTO BLAZES\n  END\n END\n WHEN (MEMBER NOT FOUND) DO\n  IF &NOCHECKMEMBER = NOCHECKMEMBER THEN DO\n  END\n  ELSE DO\n   SET ERRORMSG = &NRSTR(Cannot access data set &FULLDSN: &STATUS)\n   SET ERRORCODE = 8\n   GOTO BLAZES\n  END\n END\n OTHERWISE DO\n  SET ERRORMSG = &NRSTR(Cannot access data set &FULLDSN: &STATUS)\n  SET ERRORCODE = 12\n  GOTO BLAZES\n END\nEND\n\nIF &VERIFY = VERIFY THEN DO\n SET SYSDSORG =\n LISTDSI &FULLDSN &RECALL &NORECALL\n IF &ORG = ANY THEN DO\n  IF &NRSTR(&DSMEMB) NE THEN SET ORG = PDS\n  ELSE SET ORG = SEQ\n END\n IF &ORG = SEQ THEN DO\n  IF &SUBSTR(1:2,&SYSDSORG  ) NE PS THEN DO\n   SET ERRORMSG = &STR(Data set must not be partitioned, but is.)\n   SET ERRORCODE = 12\n   GOTO BLAZES\n  END\n END\n IF &ORG = PDS THEN DO\n  IF &SUBSTR(1:2,&SYSDSORG  ) NE PO THEN DO\n   SET ERRORMSG = &STR(Data set must be partitioned, but is not.)\n   SET ERRORCODE = 12\n   GOTO BLAZES\n  END\n END\nEND\n\nRETURN CODE(0)\n\nBLAZES: +\nWRITE Error processing data set: &UDSN\nIF &NRSTR(&ERRORMSG) = THEN WRITE Unknown error code &ERRORCODE\nELSE WRITE &NRSTR(&ERRORMSG)\n\nRETURN CODE(&ERRORCODE)\n\nEND SETDSN\n\n/* *** */\n\nMAKEDS: PROC 2 DSNAME ATTRLIST SIZE(1)\n\nSYSCALL MAKE &NRSTR(&DSNAME) &NRSTR(&ATTRLIST) SEQ SIZE('&SIZE')\n\nRETURN\n\nEND MAKEDS\n\n/* *** */\n\nMAKEPDS: PROC 2 DSNAME ATTRLIST SIZE(1)\n\nSYSCALL MAKE &NRSTR(&DSNAME) &NRSTR(&ATTRLIST) PDS SIZE('&SIZE')\n\nRETURN\n\nEND MAKEPDS\n\n/* *** */\n\nMAKE: PROC 3 DSNAME ATTRLIST ORG SIZE(1)\n\nSELECT &ATTRLIST\n WHEN (LISTF120) DO\n  SET ARECFM   = F B A\n  SET ALRECL   = 121\n  SET ABLKSIZE = 6171\n END\n WHEN (TEXT) DO\n  SET ARECFM   = V B\n  SET ALRECL   = 255\n  SET ABLKSIZE = 6233\n END\n WHEN (OBJ) DO\n  SET ARECFM   = F B\n  SET ALRECL   = 80\n  SET ABLKSIZE = 2960\n END\n WHEN (ASMLIST) DO\n  SET ARECFM   = F B A\n  SET ALRECL   = 121\n  SET ABLKSIZE = 6171\n END\n OTHERWISE DO\n  SET ARECFM   = F B\n  SET ALRECL   = 80\n  SET ABLKSIZE = 6160\n END\nEND\n\nSET ASPACE1  = 16 * &SIZE\nSET ASPACE2  = 10 * &SIZE\nSET ASPUNITS = BLOCK(&ABLKSIZE)\n\n/* first see if it already exists\n\nSET XMSTAT = &SYSDSN(&NRSTR(&DSNAME))\n\nSELECT &NRSTR(&XMSTAT)\n WHEN (OK) DO\n  RETURN CODE(0)\n END\n WHEN (DATASET NOT FOUND) DO\n  /* go ahead */\n END\n WHEN (MEMBER NOT FOUND) DO\n  RETURN CODE(0)\n END\n OTHERWISE DO\n  WRITE &NRSTR(Error: Cannot use data set &DSNAME: &XMSTAT)\n  RETURN CODE(16)\n END\nEND\n\n\nSET ALLOCPARMS = &NRSTR(+\n      RECFM(&ARECFM) LRECL(&ALRECL) BLKSIZE(&ABLKSIZE) +\n      SPACE(&ASPACE1 &ASPACE2) &ASPUNITS +\n      )\nIF &ORG = PDS THEN DO\n SET ALLOCPARMS = &NRSTR(&ALLOCPARMS) DIR(32)\nEND\n\nALLOC DA(&NRSTR(&DSNAME)) &NRSTR(&ALLOCPARMS)\nIF &LASTCC NE 0 THEN DO\n WRITE Error: Could not allocate new data set &DSNAME..\n RETURN CODE(12)\nEND\n\nRETURN CODE(0)\n\nEND MAKE\n\n/* *** */\n\nLISTFILE: PROC 1 LFDD\n\nCONTROL NOFLUSH\nOPENFILE &LFDD INPUT\nIF &LASTCC NE 0 THEN RETURN\nSET EOF = N\nCONTROL NOFLUSH\nERROR DO\n SET EOF = Y\n RETURN\nEND\nDO WHILE &EOF = N\n GETFILE &LFDD\n SET LFLINE = &&&LFDD\n WRITE &SYSNSUB(2,&LFLINE)\nEND\nCLOSFILE &LFDD\nRETURN\n\nEND LISTFILE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZCHECK": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x00$O\\x01\\x00$O\\t(\\x00\\x92\\x00\\x92\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-08-31T00:00:00", "modifydate": "2000-08-31T09:28:30", "lines": 146, "newlines": 146, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 1 DSNAME SETMSG SMSG() LMSG() NOMEMBER RECALL NORECALL XTRACE\n        /*\n        /* This CLIST is used by ISPF dialog CLISTs to verify the existence\n        /* of a dataset and:\n        /*\n        /*   If SMSG is specified, return short message in a dialog variable.\n        /*   If LMSG is specified, return long message in a dialog variable.\n        /*\n        /*   If SETMSG is specified, set the ISPF message appropriately.\n        /*   Otherwise, display message at user's terminal.\n        /*\n        /* Automatic recall of migrated datasets is optional.\n        /*\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        ERROR DO\n         SET CC = &LASTCC\n         IF &CC = 12 THEN RETURN\n         IF &CC = 20 THEN RETURN\n         ERROR OFF\n         CONTROL MSG\n         IF &CC = 952 THEN -\n          WRITE XZCHECK: Data set '&NRSTR(&DSNAME)' is not available.\n         ELSE IF &CC = 904 | &CC = 900 THEN +\n          WRITE XZCHECK: Invalid syntax in data set name '&NRSTR(&DSNAME)'.\n         ELSE -\n          WRITE XZCHECK: CLIST error &CC occurred processing '&NRSTR(&DSNAME)'.\n         EXIT C(&CC)\n        END\n        IF &SUBSTR(1,&DSNAME) = ' +\n         THEN IF &SUBSTR(&LENGTH(&STR(&DSNAME)),&DSNAME) = ' +\n          THEN SET DSNAME = &SUBSTR(2:&LENGTH(&STR(&DSNAME))-1,&DSNAME)\n         ELSE SET DSNAME = &STR(&DSNAME)\n        ELSE IF &STR(&SYSPREF) NE THEN +\n         SET DSNAME = &STR(&SYSPREF..&DSNAME)\n        SET MIGRATED = N\n        IF &RECALL&NORECALL = RECALL THEN LISTDSI '&DSNAME'\n        ELSE LISTDSI '&DSNAME' NORECALL\n        SET LISTDSICC = &LASTCC\n        IF &LISTDSICC = 16 && &SYSREASON = 0009 THEN DO\n         SET MIGRATED = Y\n        END\n        /**********************************************************************/\n        /*                                                                    */\n        /* If a member name was specified, extract it and isolate dsname.     */\n        /*                                                                    */\n        /**********************************************************************/\n        SET LP = &SUBSTR(1,())\n        SET RP = &SUBSTR(2,())\n        IF &SYSINDEX(&LP,&DSNAME) NE 0 THEN DO\n         SET I = &LENGTH(&STR(&DSNAME))\n         DO WHILE &I > 0\n          IF &SUBSTR(&I,&DSNAME) = &STR(&LP) THEN GOTO FOUNDLP\n          SET I = &I-1\n         END\n         FOUNDLP:+\n         SET PDSN = &SUBSTR(1:&I-1,&DSNAME)\n         SET MEMBER = &SUBSTR(&I+1:&LENGTH(&STR(&DSNAME))-1,&DSNAME)\n        END\n        ELSE DO\n         SET PDSN = &STR(&DSNAME)\n         SET MEMBER =\n        END\n        IF &XTRACE = THEN CONTROL NOMSG\n        IF &MIGRATED = Y THEN DO\n         SET XCC = 40\n         SET SM = &STR(DATASET IS MIGRATED)\n         SET LM = &STR(DATA SET '&DSNAME' IS MIGRATED (UNDER HSM CONTROL).)\n        END\n        ELSE DO\n         SET STATUS = &SYSDSN('&DSNAME')\n         SELECT &SUBSTR(1:8,&STATUS         )\n          WHEN (OK      ) DO\n           SET XCC = 0\n           IF &SYSNEST = NO THEN +\n              WRITE XZCHECK: Data set '&DSNAME' exists and is online.\n          END\n          WHEN (DATASET ) DO\n           SET XCC = 8\n           SET SM = &STR(DATASET NOT CATALOGED)\n           SET LM = &STR(DATA SET '&DSNAME' NOT IN CATALOG.)\n          END\n          WHEN (MEMBER N) DO\n           SET XCC = 4\n           SET SM = &STR(MEMBER NOT FOUND)\n           SET LM = &STR(MEMBER &MEMBER NOT IN DATA SET '&PDSN'.)\n          END\n          WHEN (MEMBER S) DO\n           SET XCC = 12\n           SET SM = &STR(DATASET NOT PARTITIONED)\n           SET LM = &STR(MEMBER &MEMBER SPECIFIED BUT '&PDSN' IS NOT A PDS.)\n          END\n          WHEN (VOLUME N) DO\n           SET XCC = 24\n           SET SM = &STR(VOLUME NOT AVAILABLE)\n           SET LM = &STR(VOLUME NOT ON SYSTEM AND CANNOT BE ACCESSED.)\n          END\n          WHEN (UNAVAILA) DO\n           SET XCC = 28\n           SET SM = &STR(DATASET IN USE)\n           SET LM = &STR(+\n                    '&PDSN' IN USE, CANNOT DETERMINE IF MEMBER &MEMBER EXISTS.)\n          END\n          WHEN (PROTECTE) DO\n           SET XCC = 913\n           SET SM = &STR(ACCESS DENIED)\n           SET LM = &STR(YOU MAY NOT ACCESS THIS PROTECTED DATASET '&PDSN'.)\n          END\n          WHEN (INVALID ) DO\n           SET XCC = 12\n           SET SM = &STR(INVALID DATASET NAME)\n           SET LM = &STR(INVALID SYNTAX IN DATA SET NAME '&DSNAME'.)\n          END\n          OTHERWISE DO\n           SET XCC = 16\n           SET SM = &STR(UNABLE TO ACCESS DATASET)\n           SET LM = &STR(ERROR ACCESSING '&PDSN': &STATUS)\n          END\n         END\n        END\n        CONTROL MSG\n        IF &SMSG \u00ac= THEN DO\n         SET &&SMSG = &NRSTR(&SM)   /* SET REQUESTED VARIABLE TO SHORT MESSAGE\n         ISPEXEC VPUT &SMSG\n        END\n        IF &LMSG \u00ac= THEN DO\n         SET &&LMSG = &NRSTR(&LM)   /* SET REQUESTED VARIABLE TO LONG MESSAGE\n         ISPEXEC VPUT &LMSG\n        END\n        IF &SETMSG = SETMSG THEN DO\n         SET XZCKSM = &STR(&SM)\n         SET XZCKLM = &STR(&LM)\n         ISPEXEC SETMSG MSG(XZCK000)\n        END\n        ELSE DO\n         SET CC = 0\n         CONTROL NOMSG\n         ISPEXEC CONTROL DISPLAY LINE\n         SET ISPCC = &CC\n         CONTROL MSG\n         IF &NRSTR(&LM) NE THEN +\n          WRITE XZCHECK: &NRSTR(&LM)\n         IF &ISPCC = 0 THEN ISPEXEC CONTROL DISPLAY REFRESH\n        END\n        IF &SYSNEST = NO THEN WRITE Exiting with code &XCC.\n        EXIT C(&XCC) Q\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZDRIB": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00@\\x00\\x86\\x02O\\x01\\x00\\x11\\x0f\\x15'\\x00$\\x00$\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "2000-04-19T15:27:40", "lines": 36, "newlines": 36, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 1 DATASETNAME RELEASE NEW OLD MOD NOINFORM XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.2 - SEB1525 - 01/86                                  *\n        /*                                                                    *\n        /* This CLIST allocates a ZIL dribble file.                           *\n        /* The DD name is ZILDRIBL.                                           *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        IF      &NEW&MOD&OLD = NEW THEN SET DISPOSITION = NEW\n        ELSE IF &NEW&MOD&OLD = MOD THEN SET DISPOSITION = MOD\n        ELSE IF &NEW&MOD&OLD = OLD THEN SET DISPOSITION = OLD\n        ELSE DO\n         IF &SYSDSN(&DATASETNAME) = OK THEN SET DISPOSITION = OLD\n         ELSE SET DISPOSITION = NEW\n        END\n        IF &DISPOSITION = NEW | &DISPOSITION = MOD THEN +\n         SET OTHERPARMS = &STR(RECFM(F B) LRECL(80) BL(3120) SP(10 10))\n        ELSE SET OTHERPARMS =\n        ALLOC FI(ZILDRIBL) +\n              DA(&DATASETNAME) +\n              &DISPOSITION +\n              &OTHERPARMS +\n              &RELEASE +\n              REUSE\n        IF &LASTCC = 0 THEN DO\n         IF &NOINFORM = THEN +\n          WRITE XZDRIB: Dribble file allocated to data set &DATASETNAME..\n        END\n        ELSE DO\n         WRITE\n         WRITE XZDRIB Error: Dribble file allocation failed.\n         EXIT C(12) Q\n        END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZIFILE": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00W\\x00\\x86\\x06?\\x01\\x00#\\x1f\\x10S\\x00'\\x00&\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "2000-08-18T10:53:57", "lines": 39, "newlines": 38, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 2 FILENAME DATASETNAME REUSE DISPOSITION(SHR) NOINFORM XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.2 - SEB1525 - 03/86                                  *\n        /*                                                                    *\n        /* This CLIST allocates a ZIL input file.                             *\n        /* The DD name is ZILIxxxx, where xxxx is the file name.              *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        IF &LENGTH(&STR(&FILENAME)) > 4 THEN DO\n         WRITE XZIFILE Error: File name must not exceed 4 characters.\n         EXIT C(12) Q\n        END\n        IF &STR(&FILENAME) = NIL +\n         | &STR(&FILENAME) = T +\n         | &DATATYPE(&STR(&FILENAME)) = NUM THEN DO\n         WRITE XZIFILE Error: \"&FILENAME\" is not a valid file name.\n         EXIT C(12) Q\n        END\n        SET STAT = SYSDSN(&DATASETNAME)\n        IF &STR(&STAT) \u00ac= OK THEN DO\n         WRITE XZIFILE Error: Data set &DATASETNAME is not valid.\n         WRITE XZIFILE Reason: &STAT\n         EXIT C(12) Q\n        END\n        ALLOC FI(ZILI&FILENAME) +\n              DA(&DATASETNAME) +\n              &DISPOSITION +\n              &REUSE\n        IF &LASTCC = 0 THEN DO\n         IF &NOINFORM = THEN +\n          WRITE XZIFILE: Input file &FILENAME allocated to data set &DATASETNAME..\n        END\n        ELSE DO\n         WRITE XZIFILE Error: Input file &FILENAME allocation failed.\n         EXIT C(12) Q\n        END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XZIFREE": {"ttr": 267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00G\\x00\\x86\\x06?\\x01\\x00\\x11\\x0f\\x15'\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "2000-04-19T15:27:47", "lines": 28, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 1 FILENAME XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.2 - SEB1525 - 03/86                                  *\n        /*                                                                    *\n        /* This CLIST frees a ZIL input file.                                 *\n        /* The DD name is ZILIxxxx, where xxxx is the file name.              *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        IF &LENGTH(&STR(&FILENAME)) > 4 THEN DO\n         WRITE XZIFREE Error: File name must not exceed 4 characters.\n         EXIT C(12) Q\n        END\n        IF &STR(&FILENAME) = NIL +\n         | &STR(&FILENAME) = T +\n         | &DATATYPE(&STR(&FILENAME)) = NUM THEN DO\n         WRITE XZIFREE Error: \"&FILENAME\" is not a valid file name.\n         EXIT C(12) Q\n        END\n        FREE FI(ZILI&FILENAME)\n        IF &LASTCC \u00ac= 0 THEN DO\n         WRITE XZIFREE Error: Input file &FILENAME not freed.\n         EXIT C(12) Q\n        END\n        ELSE +\n         WRITE XZIFREE: Input file &FILENAME is now free.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XZIL": {"ttr": 269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x00\\x88\\x05O\\x01\\x00$O\\x086\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-02-23T00:00:00", "modifydate": "2000-08-31T08:36:55", "lines": 19, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* This CLIST enters the ZIL ISPF environment, displaying the ZIL     *\n        /* primary option menu.  If entered from READY mode, this CLIST       *\n        /* will start up a ZIL-dedicated ISPF session.                        *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        IF &SYSISPF = ACTIVE THEN DO\n         ISPEXEC SELECT PANEL(XZIL) NEWAPPL(ISR)\n        END\n        ELSE DO\n         ISPSTART PANEL(XZIL) NEWAPPL(ISR)\n         EXIT\n        END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZIL1": {"ttr": 271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x00\\x88\\x05O\\x01\\x00$?\\x16%\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-02-23T00:00:00", "modifydate": "2000-08-30T16:25:11", "lines": 19, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 1                                                  *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        ISPEXEC CONTROL ERRORS RETURN\n        ISPEXEC BROWSE DATASET('PROGLIB.ZIL.TEXT($NEWS)')\n        IF &LASTCC \u00ac= 0 THEN DO\n         ISPEXEC CONTROL ERRORS CANCEL\n         ISPEXEC DISPLAY PANEL(ZILTERM)\n        END\n        EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZIL2": {"ttr": 273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x88\\x05O\\x01\\x00$O\\t0\\x00/\\x00)\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-02-23T00:00:00", "modifydate": "2000-08-31T09:30:00", "lines": 47, "newlines": 41, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 2                                                  *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        SET CURSOR = XZILMEM\n        LOOP:+\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL2) CURSOR(&CURSOR)\n        IF &LASTCC \u00ac= 0 THEN GOTO EXIT\n        IF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\n        SET DSLEN = &LENGTH(&NRSTR(&XZILSRC))\n        IF &SUBSTR(1,&NRSTR(&XZILSRC))&SUBSTR(&DSLEN,&NRSTR(&XZILSRC)) = '' +\n         THEN SET XZZZSRC = &SUBSTR(2:&DSLEN-1,&NRSTR(&XZILSRC))\n        ELSE SET XZZZSRC = &NRSTR(&SYSPREF..&XZILSRC)\n        LISTDSI '&XZZZSRC' NORECALL\n        IF &SYSREASON = 9 /* migrated */ THEN DO\n         SET MIGDSN = &STR('&XZZZSRC')\n         ISPEXEC DISPLAY PANEL(XZCKMIG)\n         IF &LASTCC \u00ac= 0 THEN GOTO LOOP\n        END\n        IF &STR(&XZILMEM) = THEN SET EDITDS = '&XZZZSRC'\n        ELSE SET EDITDS = '&XZZZSRC(&XZILMEM)'\n        ISPEXEC CONTROL ERRORS RETURN\n        ISPEXEC EDIT DATASET(&EDITDS)\n        SELECT &LASTCC\n         WHEN (0)  DO\n                    ISPEXEC SETMSG MSG(XZIL016)\n                   END\n         WHEN (4)  DO\n                   END\n         OTHERWISE DO\n                    ISPEXEC SETMSG MSG(&ZERRMSG)\n                   END\n        END\n        SET CURSOR = XZILMEM\n        ISPEXEC CONTROL ERRORS CANCEL\n        GOTO LOOP\n        EXIT:+\n        EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZIL3": {"ttr": 275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00(\\x00\\x88\\x05O\\x01\\x00$O\\tD\\x00{\\x00p\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1988-02-23T00:00:00", "modifydate": "2000-08-31T09:44:28", "lines": 123, "newlines": 112, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 3                                                  *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        CONTROL NOFLUSH NOCAPS\n        /* Configuration section. */\n        SET HELDSYSOUTCLASS = H\n        SET EXECPGM_IS_AVAILABLE = N\n        /* End configuration section. */\n        SET CURSOR = XZILINIT\n        LOOP:+\n        ISPEXEC CONTROL ERRORS CANCEL\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL3) CURSOR(&CURSOR)\n        IF &LASTCC \u00ac= 0 THEN GOTO EXIT\n        IF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\n        IF &SUBSTR(1,&ZCMD ) = E THEN DO\n         SET EDITDS = &SYSNSUB(2,&&&XZILCUR)\n         IF &STR(&EDITDS) = THEN DO\n          ISPEXEC SETMSG MSG(XZIL013)\n          SET CURSOR = &XZILCUR\n          GOTO LOOP\n         END\n         ISPEXEC CONTROL ERRORS RETURN\n         ISPEXEC EDIT DATASET(&EDITDS)\n         SELECT &LASTCC\n          WHEN (0)  DO\n                     ISPEXEC SETMSG MSG(XZIL016)\n                    END\n          WHEN (4)  DO\n                    END\n          OTHERWISE DO\n                     ISPEXEC SETMSG MSG(&ZERRMSG)\n                     SET CURSOR = &XZILCUR\n                     GOTO LOOP\n                    END\n         END\n         SET CURSOR = &XZILCUR\n         SET ZCMD =\n         GOTO LOOP\n        END\n\n        IF &STR(&XZILSUB1 &XZILSUB2 &XZILSUB3 &XZILSUB4) NE THEN DO\n         IF &EXECPGM_IS_AVAILABLE = N THEN DO\n          ISPEXEC SETMSG MSG(XZIL020)\n          SET CURSOR = XZILSUB1\n          GOTO LOOP\n         END\n         SET SUBMETHOD = EXECPGM\n        END\n        ELSE SET SUBMETHOD =\n\n        IF &STR(&XZILACSZ) \u00ac= THEN SET ACSIZE = &STR(A=&XZILACSZ)\n        ELSE SET ACSIZE =\n        IF &STR(&XZILCSSZ) \u00ac= THEN SET CSSIZE = &STR(C=&XZILCSSZ)\n        ELSE SET CSSIZE =\n        IF &STR(&XZILPDSZ) \u00ac= THEN SET PDSIZE = &STR(P=&XZILPDSZ)\n        ELSE SET PDSIZE =\n        IF &STR(&XZILVSSZ) \u00ac= THEN SET VSSIZE = &STR(V=&XZILVSSZ)\n        ELSE SET VSSIZE =\n\n        IF &NRSTR(&XZILINIT) \u00ac= THEN DO\n         ALLOC F(ZILIINIT) SHR REU DA(&XZILINIT)\n         IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        END\n        ELSE DO\n         IF &XTRACE = THEN CONTROL NOMSG\n         FREE F(ZILIINIT)\n         CONTROL MSG\n        END\n        IF &NRSTR(&XZILSODS) \u00ac= THEN DO\n         ALLOC F(ZILDRIBL) MOD REU DA(&XZILSODS) T SP(50 50)\n         IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n         SET DRIBBLE = Y\n        END\n        ELSE IF &XZILSOSC \u00ac= THEN DO\n         IF &XZILSOSC = &HELDSYSOUTCLASS THEN SET HOLD = HOLD\n         ELSE SET HOLD =\n         ALLOC F(ZILDRIBL) SYSOUT(&XZILSOSC) &HOLD REU\n         IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n         SET DRIBBLE = Y\n        END\n        ELSE DO\n         IF &XTRACE = THEN CONTROL NOMSG\n         FREE F(ZILDRIBL)\n         CONTROL MSG\n         SET DRIBBLE = N\n        END\n        ALLOC F(ZILI) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        ALLOC F(ZILO) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        ISPEXEC CONTROL DISPLAY LINE START(1)\n        SET LIBRARY = PROGLIB.ZIL.&XZILSYS.LOAD\n        SET ZILINPARMS = &NRSTR(\\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&XZILINIT)\n        IF &SUBMETHOD = EXECPGM THEN DO\n         ALLOC FI(ZILLIB) SHR REU +\n               DA(&XZILSUB1 &XZILSUB2 &XZILSUB3 &XZILSUB4 '&LIBRARY')\n         EXECPGM ZILIN PARM('&NRSTR(&ZILINPARMS)') TASKLIB(ZILLIB)\n         SET XZILCC = &LASTCC\n         FREE FI(ZILLIB)\n        END\n        ELSE DO\n         CALL '&LIBRARY(ZILIN)' '&NRSTR(&ZILINPARMS)'\n         SET XZILCC = &LASTCC\n        END\n        ISPEXEC SETMSG MSG(XZIL004)\n        IF &NRSTR(&XZILINIT) \u00ac= THEN FREE F(ZILIINIT)\n        IF &DRIBBLE = Y THEN FREE F(ZILDRIBL)\n        GOTO LOOP\n        ERROR:+\n        ISPEXEC SETMSG MSG(XZIL005)\n        GOTO LOOP\n        EXIT:+\n        EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZIL4": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x008\\x00\\x88\\x14\\x7f\\x01\\x00$O\\x16\\x06\\x01\\xeb\\x01\\xbb\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1988-05-26T00:00:00", "modifydate": "2000-08-31T16:06:38", "lines": 491, "newlines": 443, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 4                                                  *\n        /*                                                                    *\n        /**********************************************************************\n\n        NGLOBAL DEBUG LIBRARIES LIBRARY LISPMACS MACLIB TEMPPFX\n        NGLOBAL ACSIZE CSSIZE PDSIZE VSSIZE TRACE SYSPARM\n        NGLOBAL EXECPGM_IS_AVAILABLE SYSMACLIB ASSEMBLER ASMTHRESHOLD\n\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        SET TRACE = &XTRACE\n        CONTROL NOFLUSH NOCAPS\n        /* Configuration section. */\n        SET EXECPGM_IS_AVAILABLE = N\n        SET SYSMACLIB = &STR('SYS1.MACLIB')\n        SET ASSEMBLER = &STR('SYS1.LINKLIB(IEV90)')\n        SET SYSPARM   = XA\n        SET ASMTHRESHOLD = 0 /* 4 if you still get USING warnings */\n        /* End configuration section. */\n        SET CURSOR = XZILMEM\n        ISPEXEC VGET (ZTEMPF ZSCREEN) /* ZTEMPF = some_prefix.SPFTEMPn.CNTL\n        /* This code for PIE/TSO Sessions installations. */\n        SET SESSNO = &SUBSTR(&LENGTH(&STR(&ZTEMPF)),&ZTEMPF)\n        IF &SESSNO \u00ac= L THEN +\n         SET TEMPPFX = &STR(&SYSUID..SPFPIE&SESSNO..SPFTEMP&ZSCREEN)\n        ELSE +\n         SET TEMPPFX = &SUBSTR(1:&LENGTH(&STR(&ZTEMPF))-5,&ZTEMPF)\n        /* End code for PIE/TSO Sessions installations. */\n        LOOP:+\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL4) CURSOR(&CURSOR)\n        IF &LASTCC \u00ac= 0 THEN EXIT\n        IF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\n        SET XZZZSRC = &STR(&XZILSRC)\n        SET XZZZLNK = &STR(&XZILLNK)\n        SYSCALL QUALIFY XZZZSRC\n        SYSCALL QUALIFY XZZZLNK\n        IF &XZILSEL = E THEN DO\n         SYSCALL EDIT ZILMEM('&XZILMEM') ZILSRC('&XZZZSRC')\n         GOTO LOOP\n        END\n        SET LIBRARY = PROGLIB.ZIL.&XZILSYS.LOAD\n        SET MACLIB  = PROGLIB.ZIL.&XZILSYS.MACLIB\n        IF &STR(&XZILACSZ) \u00ac= THEN SET ACSIZE = &STR(A=&XZILACSZ)\n        ELSE SET ACSIZE =\n        IF &STR(&XZILCSSZ) \u00ac= THEN SET CSSIZE = &STR(C=&XZILCSSZ)\n        ELSE SET CSSIZE =\n        IF &STR(&XZILPDSZ) \u00ac= THEN SET PDSIZE = &STR(P=&XZILPDSZ)\n        ELSE SET PDSIZE =\n        IF &STR(&XZILVSSZ) \u00ac= THEN SET VSSIZE = &STR(V=&XZILVSSZ)\n        ELSE SET VSSIZE =\n\n        SET DEBUG = &XZILDBG\n\n        SET LISPMACS = &STR(&XZILMAC1 &XZILMAC2 &XZILMAC3 &XZILMAC4)\n\n        SET LIBRARIES = &XZILSUB1 &XZILSUB2 &XZILSUB3 &XZILSUB4\n\n        IF &STR(&LIBRARIES) NE THEN DO\n         IF &EXECPGM_IS_AVAILABLE = N THEN DO\n          ISPEXEC SETMSG MSG(XZIL020)\n          SET CURSOR = XZILSUB1\n          GOTO LOOP\n         END\n         SET SUBMETHOD = EXECPGM\n        END\n        ELSE SET SUBMETHOD =\n\n        IF &TRACE = THEN CONTROL NOMSG\n        FREE F(SYSIN SYSLIN SYSPRINT SYSLIB SYSUT1 SYSTERM)\n        CONTROL MSG\n\n        IF &STR(&XZILSEL) \u00ac= THEN DO\n\n         SYSCALL COMPILE ZILSEL ('&XZILSEL') +\n                         ZILMEM ('&XZILMEM') +\n                         ZILNAME('&XZILNAM') +\n                         ZILSRC ('&XZZZSRC') +\n                         ZILLINK('&XZZZLNK') +\n                         ZILTRN ('&XZILTRN') +\n                         ZILBZL ('&XZILBZL') +\n                         ZILBAL ('&XZILBAL') +\n                         ZILBLL ('&XZILBLL')\n\n          /*  500: cursor --> XZILMEM\n          /* 1000: cursor --> XZILMEM\n          /* 2000: cursor --> XZILMEM\n          /* 3000: cursor --> XZILMEM\n          /* 4000: cursor --> XZILMAC1\n\n         SELECT &LASTCC\n          WHEN (0)\n          WHEN (4)    SET CURSOR = XZILMEM\n          WHEN (4000) SET CURSOR = XZILMAC1\n          WHEN (1)    SET CURSOR = XZILLNK\n          OTHERWISE   SET CURSOR = XZILSRC\n         END\n\n        END\n\n        ELSE DO\n\n        /* process member list */\n\n         ISPEXEC CONTROL ERRORS RETURN\n\n         ISPEXEC LMINIT DATAID(DATAID) DATASET('&XZZZSRC')\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMOPEN DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n\n         SET MLCURSOR = ZCMD\n         SET MLTOP    = &STR(&XZILMEM)\n\n         MLOOP:+\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(DISPLAY) MEMBER(&XZILMEM) +\n                         COMMANDS(ANY) +\n                         CURSOR(&MLCURSOR) +\n                         TOP(&MLTOP) +\n                         PANEL(XZIL4M)\n         SELECT &LASTCC\n          WHEN (0)\n          WHEN (4) GOTO NO_MEMBERS\n          WHEN (8) GOTO MFINISH\n          OTHERWISE GOTO ERROR\n         END\n\n        /**********************************************************************/\n        /*                                                                    */\n        /* Selection variables returned:                                      */\n        /*                                                                    */\n        /* ZLMEMBER - name of selected member                                 */\n        /* ZCMD     - primary command                                         */\n        /* ZLLCMD   - line command used to select the member                  */\n        /* ZLUDATA  - user data area on member list                           */\n        /*                                                                    */\n        /**********************************************************************/\n\n         SET PROCESSED_OK = N\n\n         SET SYSDVAL = &NRSTR(&ZCMD)\n         READDVAL ZCMDVERB ZCMDOPERAND\n         SELECT (&NRSTR(&ZCMDVERB))\n          WHEN ()\n          WHEN (E | EDIT) DO\n           IF &SYSINDEX(*,&ZCMDOPERAND) \u00ac= 0 THEN DO\n            ISPEXEC SETMSG MSG(ISRM053) /* \"*\" not valid */\n            GOTO MLOOP\n           END\n           SYSCALL EDIT ZILMEM('&NRSTR(&ZCMDOPERAND)') ZILSRC('&XZZZSRC')\n           SET CC = &LASTCC\n           IF &CC > 8 THEN SET MLCURSOR = ZCMD\n           ELSE DO\n            SET ZCMD =\n            SET MLTOP = &NRSTR(&ZCMDOPERAND)\n            IF &CC = 0 THEN DO\n             ISPEXEC LMMDISP DATAID(&DATAID) OPTION(ADD) +\n                             MEMBER(&NRSTR(&ZCMDOPERAND)) +\n                             ZLUDATA (*ADDED)\n             IF &LASTCC > 8 THEN GOTO ERROR\n             /* if lastcc = 8 then member already exists, not added */\n            END\n           END\n           GOTO MLOOP\n          END\n          OTHERWISE DO\n           ISPEXEC SETMSG MSG(ISPZ001)\n           GOTO MLOOP\n          END\n         END\n\n         SET MLTOP = &STR(&ZLMEMBER)\n\n         PROCESS_A_MEMBER:+\n         SET PROCESSED_OK = N\n\n         SYSCALL BACKSCAN ZLUDATA\n         SYSCALL BACKSCAN ZLMEMBER\n\n         IF &SUBSTR(1,&ZLUDATA ) = &STR(*) THEN SET NEWNAME =\n         ELSE SET NEWNAME = &STR(&ZLUDATA)\n\n         SELECT &ZLLCMD\n          WHEN (F|P|M) DO\n                    SYSCALL COMPILE ZILSEL ('&ZLLCMD'  ) +\n                                    ZILMEM ('&ZLMEMBER') +\n                                    ZILNAME('&NEWNAME' ) +\n                                    ZILSRC ('&XZZZSRC' ) +\n                                    ZILLINK('&XZZZLNK' ) +\n                                    ZILTRN ('&XZILTRN' ) +\n                                    ZILBZL ('&XZILBZL' ) +\n                                    ZILBAL ('&XZILBAL' ) +\n                                    ZILBLL ('&XZILBLL' )\n                    SELECT &LASTCC\n                     WHEN (0)    DO\n                                  SET ZLUDATA = &STR(*COMLNKD)\n                                  SET PROCESSED_OK = Y\n                                 END\n                     WHEN ( 500)  SET ZLUDATA = &STR(*COMFAIL)\n                     WHEN (1000)  SET ZLUDATA = &STR(*ASMFAIL)\n                     WHEN (2000)  SET ZLUDATA = &STR(*LNKFAIL)\n                     OTHERWISE    SET ZLUDATA = &STR(*ALCFAIL)\n                    END\n                    SET ZLLCMD =\n                   END\n          WHEN (E) DO\n                    SYSCALL EDIT ZILMEM('&ZLMEMBER') ZILSRC('&XZZZSRC')\n                    IF &LASTCC = 0 THEN +\n                     SET ZLUDATA = &STR(*SAVED)\n                    ELSE +\n                     SET ZLUDATA =\n                    SET ZLLCMD =\n                    SET PROCESSED_OK = Y\n                   END\n          OTHERWISE DO\n                     ISPEXEC SETMSG MSG(XZIL019) /* invalid selection code\n                     SET MLTOP = &STR(&ZLMEMBER)\n                    END\n         END\n\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(PUT) +\n                         MEMBER(&ZLMEMBER) ZLLCMD(&ZLLCMD) ZLUDATA(&ZLUDATA)\n         IF &LASTCC > 8 THEN GOTO ERROR\n\n         IF &PROCESSED_OK = Y THEN DO\n          ISPEXEC LMMDISP DATAID(&DATAID) OPTION(GET)\n          SET CC =  &LASTCC\n          IF &CC > 8 THEN GOTO ERROR\n          IF &CC = 0 THEN GOTO PROCESS_A_MEMBER\n          SET MLCURSOR = ZCMD\n         END\n         ELSE DO\n          SET MLCURSOR = ZLLCMD\n         END\n\n         GOTO MLOOP\n\n         NO_MEMBERS: ISPEXEC SETMSG MSG(XZIL018)\n         SET CURSOR = XZILMEM\n         GOTO LOOP\n\n         MFINISH:+\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(FREE)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMCLOSE DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMFREE DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n\n        END\n\n        GOTO LOOP\n\n        ERROR:ISPEXEC CONTROL ERRORS CANCEL\n        ISPEXEC DISPLAY PANEL(ZILTERM)\n        GOTO LOOP\n\n        COMPILE: PROC 0 ZILSEL()  ZILMEM()  ZILNAME() +\n                        ZILSRC()  ZILLINK()  +\n                        ZILTRN()  ZILBZL()  ZILBAL()  ZILBLL()\n\n        SET COMPILED = 0\n        SET ASSEMBLED = 0\n        SET LINKEDITED = 0\n        SET COMPILER_ERROR = 0\n        SET ASSEMBLY_ERROR = 0\n        SET LINKEDIT_ERROR = 0\n        SET ISAPROG = &ZILSEL\n        IF &ISAPROG = P THEN DO\n         SET ALONE =\n         SET NCAL =\n        END\n        ELSE DO\n         SET ALONE = ALONE\n         SET NCAL = NCAL\n        END\n        IF &STR(&ZILNAME) \u00ac= THEN SET THENAME = &STR(&ZILNAME)\n        ELSE SET THENAME = &STR(&ZILMEM)\n        SET PARM = &STR(&ISAPROG&DEBUG&THENAME)\n        %XZCHECK '&ZILSRC(&ZILMEM)' SETMSG\n        SET CHKCC = &LASTCC\n        IF &CHKCC \u00ac= 0 THEN DO\n         RETURN CODE(&CHKCC)\n        END\n        %XZCHECK '&ZILLINK(&THENAME)' SETMSG\n        SELECT &LASTCC\n         WHEN (0) DO\n                  END\n         WHEN (4) DO\n                   ISPEXEC SETMSG MSG(XZIL014)  /* the only way to \"SETNOMSG\"\n                  END\n         OTHERWISE DO\n          RETURN CODE(1)\n         END\n        END\n        ISPEXEC CONTROL DISPLAY LINE START(1)\n        SET ASMCODE = &STR('&TEMPPFX..ASM')\n        SET OBJCODE = &STR('&TEMPPFX..OBJ')\n        SET ZILLIST = &STR('&TEMPPFX..ZILLIST')\n        SET ASMLIST = &STR('&TEMPPFX..ASMLIST')\n        SET LNKLIST = &STR('&TEMPPFX..LNKLIST')\n        SET TRNLIST = &STR('&TEMPPFX..TRNLIST')\n        WRITE ZIL LISP source code input to compiler in: '&ZILSRC(&ZILMEM)'\n        WRITE Generated ZIL LISP compilation listing to: &ZILLIST\n        WRITE Generated assembler source code output to: &ASMCODE\n        IF &ZILTRN = Y THEN DO\n        WRITE Compilation internal transform listing to: &TRNLIST\n        END\n        IF &SYSDSN(&ASMCODE) \u00ac= OK THEN %XZMAKE DS &ASMCODE ASM SIZE(5)\n        ALLOC F(ZILOCODE) DA(&ASMCODE) REU\n        ALLOC F(SYSIN) DA(&ASMCODE) REU\n        IF &SYSDSN(&ZILLIST) \u00ac= OK THEN %XZMAKE DS &ZILLIST LISTF120\n        ALLOC F(ZILO) DA(&ZILLIST) REU\n        IF &ZILTRN = Y THEN DO\n         IF &SYSDSN(&TRNLIST) \u00ac= OK THEN %XZMAKE DS &TRNLIST LISTF120\n         ALLOC F(ZILOCTRN) DA(&TRNLIST) REU\n        END\n        ELSE DO\n         IF &TRACE = THEN CONTROL NOMSG\n         FREE F(ZILOCTRN)\n         CONTROL MSG\n        END\n        ALLOC F(ZILISRC) SHR REU DA('&ZILSRC(&ZILMEM)')\n        IF &LASTCC \u00ac= 0 THEN DO\n         ISPEXEC SETMSG MSG(XZIL005)  /* Allocation error */\n         RETURN CODE(3000)\n        END\n        IF &STR(&LISPMACS) = THEN DO\n         ALLOC F(ZILICMAC) DUMMY REU\n        END\n        ELSE DO\n         ALLOC F(ZILICMAC) SHR REU DA(&LISPMACS)\n         IF &LASTCC \u00ac= 0 THEN DO\n          ISPEXEC SETMSG MSG(XZIL005)  /* Allocation error */\n          RETURN CODE(4000)\n         END\n        END\n        ALLOC F(ZILI) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN DO\n         ISPEXEC SETMSG MSG(XZIL005)  /* Allocation error */\n         RETURN CODE(3000)\n        END\n        WRITE ZIL LISP compilation in progress for &THENAME\n        SET ZILCOPARMS = &NRSTR(\\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&PARM)\n        IF &SUBMETHOD = EXECPGM THEN DO\n         ALLOC FI(ZILLIB) SHR REU +\n               DA(&LIBRARIES '&LIBRARY')\n         EXECPGM ZILCO PARM('&NRSTR(&ZILCOPARMS)') TASKLIB(ZILLIB)\n         SET XZILCC = &LASTCC\n         FREE FI(ZILLIB)\n        END\n        ELSE DO\n         CALL '&LIBRARY(ZILCO)' '&NRSTR(&ZILCOPARMS)'\n         SET XZILCC = &LASTCC\n        END\n        SET COMPILED = 1\n        FREE F(ZILISRC ZILICMAC ZILI ZILO)\n        IF &ZILTRN = Y THEN FREE F(ZILOCTRN)\n        IF &XZILCC \u00ac= 0 THEN DO\n         SET COMPILER_ERROR = 1\n         ISPEXEC SETMSG MSG(XZIL008)  /* Compilation failed */\n         GOTO BROLIST\n        END\n        ELSE WRITE &THENAME compiled into &ASMCODE\n        IF &ZILBAL = Y THEN DO\n         IF &SYSDSN(&ASMLIST) \u00ac= OK THEN %XZMAKE DS &ASMLIST ASMLIST SIZE(10)\n        END\n        IF &SYSDSN(&OBJCODE) \u00ac= OK THEN %XZMAKE DS &OBJCODE OBJ\n        ALLOC F(SYSLIN)     REU DA(&OBJCODE)              DSORG(PS)\n        IF &ZILBAL = Y THEN DO\n         ALLOC F(SYSPRINT)  REU DA(&ASMLIST)              DSORG(PS)\n        END\n        ELSE DO\n         ALLOC F(SYSPRINT)  REU DUMMY                     DSORG(PS)\n        END\n        ALLOC F(SYSLIB) SHR REU DA(&SYSMACLIB '&MACLIB') DSORG(PO)\n        ALLOC F(SYSUT1)     REU T SP(50 50) DEL REL\n        ALLOC F(SYSTERM)    REU DA(*)\n        WRITE Assembly object output to: &OBJCODE\n        IF &ZILBAL = Y THEN DO\n         WRITE Assembly print output to: &ASMLIST\n        END\n        WRITE Assembly in progress for &THENAME\n        CALL &ASSEMBLER +\n         'LIST,TERM,ESD,NORLD,NOXREF,OBJECT,NODECK,SYSPARM(&SYSPARM)'\n        SET XZILCC = &LASTCC\n        FREE F(ZILOCODE SYSIN SYSLIN SYSPRINT SYSLIB SYSUT1 SYSTERM)\n        SET ASSEMBLED = 1\n        IF &XZILCC > &ASMTHRESHOLD THEN DO\n         SET COMPILER_ERROR = 1\n         SET ASSEMBLY_ERROR = 1\n         ISPEXEC SETMSG MSG(XZIL009)  /* Assembly failed */\n         GOTO BROLIST\n        END\n        CONTROL MSG\n        IF &ZILBLL = Y THEN DO\n         IF &SYSDSN(&LNKLIST) \u00ac= OK THEN %XZMAKE DS &LNKLIST LINKLIST\n         WRITE Linkage editor print output to: &LNKLIST\n         SET LINKPRINT = &STR(PRINT(&LNKLIST))\n        END\n        ELSE DO\n         SET LINKPRINT = NOPRINT\n        END\n        WRITE Linkedit in progress for &THENAME\n        LINK &OBJCODE +\n           LOAD('&ZILLINK(&THENAME)') +\n            LIB('&ZILLINK' &LIBRARIES '&LIBRARY') +\n             &LINKPRINT +\n              LIST MAP LET TERM &NCAL\n        SET XZILCC = &LASTCC\n        SET LINKEDITED = 1\n        IF &XZILCC > 4 THEN DO\n         WRITE Possible linkedit error, RC=&XZILCC\n         SET COMPILER_ERROR = 1\n         SET ASSEMBLY_ERROR = 1\n         SET LINKEDIT_ERROR = 1\n        END\n        IF &XZILCC < 12 THEN +\n         WRITE Load module is in: '&ZILLINK(&THENAME)'.\n        BROLIST:+\n        ISPEXEC CONTROL ERRORS RETURN\n        IF &ZILTRN = Y THEN DO\n         ISPEXEC BROWSE DATASET(&TRNLIST)\n         IF &LASTCC > 12 THEN ISPEXEC DISPLAY PANEL(ZILTERM)\n        END\n        IF &ZILBZL = Y | &COMPILER_ERROR = 1 THEN DO\n         ISPEXEC BROWSE DATASET(&ZILLIST)\n         IF &LASTCC > 12 THEN ISPEXEC DISPLAY PANEL(ZILTERM)\n        END\n        IF &ASSEMBLED = 1 THEN DO\n         IF &ZILBAL = Y /* | &ASSEMBLY_ERROR = 1 */ THEN DO\n          ISPEXEC BROWSE DATASET(&ASMLIST)\n          IF &LASTCC > 12 THEN ISPEXEC DISPLAY PANEL(ZILTERM)\n         END\n        END\n        IF &LINKEDITED = 1 THEN DO\n         IF &ZILBLL = Y /* | &LINKEDIT_ERROR = 1 */ THEN DO\n          ISPEXEC BROWSE DATASET(&LNKLIST)\n          IF &LASTCC > 12 THEN ISPEXEC DISPLAY PANEL(ZILTERM)\n         END\n        END\n        ISPEXEC CONTROL ERRORS CANCEL\n        IF      &COMPILER_ERROR = 1 THEN RETURN CODE( 500)\n        ELSE IF &ASSEMBLY_ERROR = 1 THEN RETURN CODE(1000)\n        ELSE IF &LINKEDIT_ERROR = 1 THEN RETURN CODE(2000)\n        ELSE RETURN CODE(0)\n        END /* COMPILE */\n\n        EDIT: PROC 0 ZILMEM() ZILSRC()\n         ISPEXEC CONTROL ERRORS RETURN\n         ISPEXEC EDIT DATASET('&ZILSRC(&ZILMEM)')\n         SET CC = &LASTCC\n         SELECT &CC\n          WHEN (0) SYSCALL SETMSG_XZIL015 &ZILSRC &ZILMEM\n          WHEN (4)  /* nothing */\n          OTHERWISE ISPEXEC SETMSG MSG(&ZERRMSG)\n         END\n         ISPEXEC CONTROL ERRORS CANCEL\n         RETURN CODE(&CC)\n        END /* EDIT */\n\n        QUALIFY: PROC 1 VAR\n        SYSREF VAR\n        SET L = &LENGTH(&STR(&VAR))\n        IF &SUBSTR(1,&VAR ) = ' THEN +\n         SET VAR = &SUBSTR(2:&L-1,&VAR)\n        ELSE +\n         SET VAR = &STR(&SYSPREF..&VAR)\n        END /* QUALIFY\n\n        BACKSCAN: PROC 1 WORD\n         SYSREF WORD\n         SET I = &SYSINDEX( ,&NRSTR(&WORD))\n         IF &I = 1 THEN SET WORD =\n         ELSE IF &I \u00ac= 0 THEN SET WORD = &SUBSTR(1:&I-1,&NRSTR(&WORD))\n        END /* BACKSCAN\n\n        /* Subprocedure to isolate the XZILMEM variable. */\n\n        SETMSG_XZIL015:PROC 2 XZZZSRC XZILMEM\n        ISPEXEC SETMSG MSG(XZIL015)\n        RETURN\n        END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XZIL5": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00#\\x00\\x88\\x17?\\x01\\x00$?\\x16%\\x01\\x19\\x01\\x11\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-06-21T00:00:00", "modifydate": "2000-08-30T16:25:23", "lines": 281, "newlines": 273, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 5                                                  *\n        /*                                                                    *\n        /* 06/05/86 - SEB1525 - Support for compiling modules and EDIT.       *\n        /* 06/21/88 - SEB1525 - Member list processing added.                 *\n        /*                                                                    *\n        /**********************************************************************\n\n        NGLOBAL FTOPEN ZPARM\n        NGLOBAL ACSIZE CSSIZE PDSIZE VSSIZE TRACE\n        NGLOBAL XZILDBG XZILCTRN XZILSYS\n        NGLOBAL XZILMAC1 XZILMAC2 XZILMAC3 XZILMAC4\n        NGLOBAL XZILSUB1 XZILSUB2 XZILSUB3 XZILSUB4\n\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n\n        SET TRACE = &XTRACE\n        CONTROL NOFLUSH NOCAPS\n        ISPEXEC VGET (+\n                      XZILDBG XZILCTRN XZILSYS +\n                      XZILMAC1 XZILMAC2 XZILMAC3 XZILMAC4 +\n                      XZILSUB1 XZILSUB2 XZILSUB3 XZILSUB4 +\n                     ) PROFILE\n        LOOP:+\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL5)\n        IF &LASTCC \u00ac= 0 THEN EXIT\n        SET XZZZSRC = &STR(&XZILSRC)\n        SET XZZZLNK = &STR(&XZILLNK)\n        SYSCALL QUALIFY XZZZSRC\n        SYSCALL QUALIFY XZZZLNK\n        IF &XZILSEL = E THEN DO\n         SYSCALL EDIT ZILMEM('&XZILMEM') ZILSRC('&XZZZSRC')\n         GOTO LOOP\n        END\n        IF &STR(&XZILACSZ) \u00ac= THEN SET ACSIZE = &STR(A=&XZILACSZ)\n        ELSE SET ACSIZE =\n        IF &STR(&XZILCSSZ) \u00ac= THEN SET CSSIZE = &STR(C=&XZILCSSZ)\n        ELSE SET CSSIZE =\n        IF &STR(&XZILPDSZ) \u00ac= THEN SET PDSIZE = &STR(P=&XZILPDSZ)\n        ELSE SET PDSIZE =\n        IF &STR(&XZILVSSZ) \u00ac= THEN SET VSSIZE = &STR(V=&XZILVSSZ)\n        ELSE SET VSSIZE =\n        SET ZPARM = &STR(&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE)\n        SET FTOPEN = N\n\n        IF &STR(&XZILSEL) \u00ac= THEN DO\n\n         SYSCALL COMPILE ZILSEL ('&XZILSEL') +\n                         ZILMEM ('&XZILMEM') +\n                         ZILNAME('&XZILNAM') +\n                         ZILSRC ('&XZZZSRC') +\n                         ZILLINK('&XZZZLNK')\n\n        END\n\n        ELSE DO\n\n        /* process member list */\n\n         ISPEXEC CONTROL ERRORS RETURN\n\n         ISPEXEC LMINIT DATAID(DATAID) DATASET('&XZZZSRC')\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMOPEN DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n\n         SET MLCURSOR = ZCMD\n         SET MLTOP    = &STR(&XZILMEM)\n\n         MLOOP:+\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(DISPLAY) MEMBER(&XZILMEM) +\n                         COMMANDS(ANY) +\n                         CURSOR(&MLCURSOR) +\n                         TOP(&MLTOP) +\n                         PANEL(XZIL5M)\n         SELECT &LASTCC\n          WHEN (0)\n          WHEN (4) GOTO NO_MEMBERS\n          WHEN (8) GOTO MFINISH\n          OTHERWISE GOTO ERROR\n         END\n\n        /**********************************************************************/\n        /*                                                                    */\n        /* Selection variables returned:                                      */\n        /*                                                                    */\n        /* ZLMEMBER - name of selected member                                 */\n        /* ZCMD     - primary command                                         */\n        /* ZLLCMD   - line command used to select the member                  */\n        /* ZLUDATA  - user data area on member list                           */\n        /*                                                                    */\n        /**********************************************************************/\n\n         SET PROCESSED_OK = N\n\n         SET SYSDVAL = &NRSTR(&ZCMD)\n         READDVAL ZCMDVERB ZCMDOPERAND\n         SELECT (&NRSTR(&ZCMDVERB))\n          WHEN ()\n          WHEN (E | EDIT) DO\n           IF &SYSINDEX(*,&ZCMDOPERAND) \u00ac= 0 THEN DO\n            ISPEXEC SETMSG MSG(ISRM053) /* \"*\" not valid */\n            GOTO MLOOP\n           END\n           SYSCALL EDIT ZILMEM('&NRSTR(&ZCMDOPERAND)') ZILSRC('&XZZZSRC')\n           SET CC = &LASTCC\n           IF &CC > 8 THEN SET MLCURSOR = ZCMD\n           ELSE DO\n            SET ZCMD =\n            SET MLTOP = &NRSTR(&ZCMDOPERAND)\n            IF &CC = 0 THEN DO\n             ISPEXEC LMMDISP DATAID(&DATAID) OPTION(ADD) +\n                             MEMBER(&NRSTR(&ZCMDOPERAND)) +\n                             ZLUDATA (*ADDED)\n             IF &LASTCC > 8 THEN GOTO ERROR\n             /* if lastcc = 8 then member already exists, not added */\n            END\n           END\n           GOTO MLOOP\n          END\n          OTHERWISE DO\n           ISPEXEC SETMSG MSG(ISPZ001)\n           GOTO MLOOP\n          END\n         END\n\n         SET MLTOP = &STR(&ZLMEMBER)\n\n         PROCESS_A_MEMBER:+\n         SET PROCESSED_OK = N\n\n         SYSCALL BACKSCAN ZLUDATA\n         SYSCALL BACKSCAN ZLMEMBER\n\n         IF &SUBSTR(1,&ZLUDATA ) = &STR(*) THEN SET NEWNAME =\n         ELSE SET NEWNAME = &STR(&ZLUDATA)\n\n         SELECT &ZLLCMD\n          WHEN (F|P|M) DO\n                    SYSCALL COMPILE ZILSEL ('&ZLLCMD'  ) +\n                                    ZILMEM ('&ZLMEMBER') +\n                                    ZILNAME('&NEWNAME' ) +\n                                    ZILSRC ('&XZZZSRC' ) +\n                                    ZILLINK('&XZZZLNK' )\n                    SELECT &LASTCC\n                     WHEN (0)    DO\n                                  SET ZLUDATA = &STR(*SEL'D)\n                                  SET PROCESSED_OK = Y\n                                 END\n                     OTHERWISE    SET ZLUDATA = &STR(*ALCFAIL)\n                    END\n                    SET ZLLCMD =\n                   END\n          WHEN (E) DO\n                    SYSCALL EDIT ZILMEM('&ZLMEMBER') ZILSRC('&XZZZSRC')\n                    IF &LASTCC = 0 THEN +\n                     SET ZLUDATA = &STR(*SAVED)\n                    ELSE +\n                     SET ZLUDATA =\n                    SET ZLLCMD =\n                    SET PROCESSED_OK = Y\n                   END\n          OTHERWISE DO\n                     ISPEXEC SETMSG MSG(XZIL019) /* invalid selection code\n                     SET MLTOP = &STR(&ZLMEMBER)\n                    END\n         END\n\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(PUT) +\n                         MEMBER(&ZLMEMBER) ZLLCMD(&ZLLCMD) ZLUDATA(&ZLUDATA)\n         IF &LASTCC > 8 THEN GOTO ERROR\n\n         IF &PROCESSED_OK = Y THEN DO\n          ISPEXEC LMMDISP DATAID(&DATAID) OPTION(GET)\n          SET CC =  &LASTCC\n          IF &CC > 8 THEN GOTO ERROR\n          IF &CC = 0 THEN GOTO PROCESS_A_MEMBER\n          SET MLCURSOR = ZCMD\n         END\n         ELSE DO\n          SET MLCURSOR = ZLLCMD\n         END\n\n         GOTO MLOOP\n\n         NO_MEMBERS: ISPEXEC SETMSG MSG(XZIL018)\n         SET CURSOR = XZILMEM\n         GOTO LOOP\n\n         MFINISH:+\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(FREE)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMCLOSE DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMFREE DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n\n        END\n\n        IF &FTOPEN = Y THEN DO\n         ISPEXEC VGET ZTEMPF\n         ISPEXEC FTCLOSE\n         ISPEXEC CONTROL ERRORS RETURN\n         ISPEXEC EDIT DATASET('&ZTEMPF')\n         IF &LASTCC > 4 THEN ISPEXEC DISPLAY PANEL(ZILTERM)\n         ISPEXEC CONTROL ERRORS CANCEL\n        END\n        GOTO LOOP\n\n        COMPILE: PROC 0 ZILSEL()  ZILMEM()  ZILNAME() +\n                        ZILSRC()  ZILLINK()\n\n        IF &STR(&ZILNAME) \u00ac= THEN SET THENAME = &STR(&ZILNAME)\n        ELSE SET THENAME = &STR(&ZILMEM)\n        SET XZILPRG = &ZILSEL\n        IF &ZILSEL = P THEN DO\n         SET XZILNCA =\n        END\n        ELSE DO\n         SET XZILNCA = NCAL\n        END\n        IF &STR(&XZILSUB1&XZILSUB2&XZILSUB3&XZILSUB4) \u00ac= THEN DO\n         SET XZILCST = Y\n        END\n        ELSE DO\n         SET XZILCST = N\n        END\n        IF &FTOPEN = N THEN DO\n         SET FTOPEN = Y\n         ISPEXEC FTOPEN TEMP\n         ISPEXEC FTINCL XZIL5J\n        END\n\n        ISPEXEC FTINCL XZIL5\n\n        RETURN\n        END /* COMPILE */\n\n\n        EDIT: PROC 0 ZILMEM() ZILSRC()\n         ISPEXEC CONTROL ERRORS RETURN\n         ISPEXEC EDIT DATASET('&ZILSRC(&ZILMEM)')\n         SET CC = &LASTCC\n         SELECT &CC\n          WHEN (0) SYSCALL SETMSG_XZIL015 &ZILSRC &ZILMEM\n          WHEN (4)  /* nothing */\n          OTHERWISE ISPEXEC SETMSG MSG(&ZERRMSG)\n         END\n         ISPEXEC CONTROL ERRORS CANCEL\n         RETURN CODE(&CC)\n        END /* EDIT */\n\n\n        QUALIFY: PROC 1 VAR\n        SYSREF VAR\n        SET L = &LENGTH(&STR(&VAR))\n        IF &SUBSTR(1,&VAR ) = ' THEN +\n         SET VAR = &SUBSTR(2:&L-1,&VAR)\n        ELSE +\n         SET VAR = &STR(&SYSPREF..&VAR)\n        END /* QUALIFY\n\n        BACKSCAN: PROC 1 WORD\n         SYSREF WORD\n         SET I = &SYSINDEX( ,&NRSTR(&WORD))\n         IF &I = 1 THEN SET WORD =\n         ELSE IF &I \u00ac= 0 THEN SET WORD = &SUBSTR(1:&I-1,&NRSTR(&WORD))\n        END /* BACKSCAN\n\n        /* Subprocedure to isolate the XZILMEM variable. */\n\n        SETMSG_XZIL015:PROC 2 XZZZSRC XZILMEM\n        ISPEXEC SETMSG MSG(XZIL015)\n        RETURN\n        END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XZIL6": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00X\\x00\\x88\\x05O\\x01\\x00$O\\t0\\x00>\\x00>\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-02-23T00:00:00", "modifydate": "2000-08-31T09:30:58", "lines": 62, "newlines": 62, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 6                                                  *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        CONTROL NOFLUSH NOCAPS\n        SET CURSOR = XZILMEM\n        LOOP:+\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL6) CURSOR(&CURSOR)\n        IF &LASTCC \u00ac= 0 THEN GOTO EXIT\n        IF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\n        IF &STR(&XZILACSZ) \u00ac= THEN SET ACSIZE = &STR(A=&XZILACSZ)\n        ELSE SET ACSIZE =\n        IF &STR(&XZILCSSZ) \u00ac= THEN SET CSSIZE = &STR(C=&XZILCSSZ)\n        ELSE SET CSSIZE =\n        IF &STR(&XZILPDSZ) \u00ac= THEN SET PDSIZE = &STR(P=&XZILPDSZ)\n        ELSE SET PDSIZE =\n        IF &STR(&XZILVSSZ) \u00ac= THEN SET VSSIZE = &STR(V=&XZILVSSZ)\n        ELSE SET VSSIZE =\n        SET SYSDVAL = &STR(&XZILLNK)\n        READDVAL XZZZLNK\n        %XZCHECK '&XZZZLNK(&XZILMEM)' SETMSG\n        SET CHKCC = &LASTCC\n        IF &CHKCC \u00ac= 0 THEN DO\n         IF &CHKCC = 4 THEN SET CURSOR = XZILMEM\n         ELSE SET CURSOR = XZILLNK\n         GOTO LOOP\n        END\n        IF &XZILPRM = THEN SET PARM =\n        ELSE IF &SUBSTR(1,&XZILPRM) = ' THEN +\n         SET PARM = &SUBSTR(2:&LENGTH(&NRSTR(&XZILPRM))-1,&NRSTR(&XZILPRM))\n        ELSE SET PARM = &NRSTR(&XZILPRM)\n        SET PARM = &NRSTR(\\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&PARM)\n        IF &LENGTH(&NRSTR(&PARM)) > 100 THEN DO\n         ISPEXEC SETMSG MSG(XZIL010)\n         SET CURSOR = XZILPRM\n         GOTO LOOP\n        END\n        ISPEXEC CONTROL DISPLAY LINE\n        ALLOC F(ZILI) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        ALLOC F(ZILO) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        SET LIBRARY = 'PROGLIB.ZIL.&XZILSYS.LOAD'\n        XINV &XZILMEM '&NRSTR(&PARM)' NOFILE +\n             LIB('&XZZZLNK' &LIBRARY)\n        SET XZILCC = &LASTCC\n        ISPEXEC SETMSG MSG(XZIL011)\n        GOTO LOOP\n        ERROR:+\n        ISPEXEC SETMSG MSG(XZIL005)\n        GOTO LOOP\n        EXIT:+\n        EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZIL7": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x04\\x00\\x88\\x05O\\x01\\x00$O\\t1\\x00o\\x00j\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1988-02-23T00:00:00", "modifydate": "2000-08-31T09:31:04", "lines": 111, "newlines": 106, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 7                                                  *\n        /*                                                                    *\n        /* 06/05/86 - SEB1525 - Support for compiling modules and EDIT.       *\n        /*                                                                    *\n        /* 04/14/88 - SEB1525 - Support for additional compiler libraries.    *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        CONTROL NOFLUSH NOCAPS\n        SET CURSOR = XZILMEM\n        LOOP:+\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL7) CURSOR(&CURSOR)\n        IF &LASTCC \u00ac= 0 THEN GOTO EXIT\n        IF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\n        SET SYSDVAL = &STR(&XZILSRC)\n        READDVAL XZZZSRC\n        IF &XZILSEL = E THEN DO\n         IF &STR(&XZILSRC) = THEN DO\n          SET CURSOR = XZILSRC\n          ISPEXEC SETMSG MSG(XZIL013)\n          GOTO LOOP\n         END\n         ISPEXEC CONTROL ERRORS RETURN\n         ISPEXEC EDIT DATASET('&XZZZSRC(&XZILMEM)')\n         SELECT &LASTCC\n          WHEN (0)  ISPEXEC SETMSG MSG(XZIL015)\n          WHEN (4)  /* nothing */\n          OTHERWISE ISPEXEC SETMSG MSG(&ZERRMSG)\n         END\n         ISPEXEC CONTROL ERRORS CANCEL\n         GOTO LOOP\n        END\n        SET LIBRARY = 'PROGLIB.ZIL.&XZILSYS.LOAD'\n        IF &STR(&XZILACSZ) \u00ac= THEN SET ACSIZE = &STR(A=&XZILACSZ)\n        ELSE SET ACSIZE =\n        IF &STR(&XZILCSSZ) \u00ac= THEN SET CSSIZE = &STR(C=&XZILCSSZ)\n        ELSE SET CSSIZE =\n        IF &STR(&XZILPDSZ) \u00ac= THEN SET PDSIZE = &STR(P=&XZILPDSZ)\n        ELSE SET PDSIZE =\n        IF &STR(&XZILVSSZ) \u00ac= THEN SET VSSIZE = &STR(V=&XZILVSSZ)\n        ELSE SET VSSIZE =\n        SET ISAPROG = &XZILSEL\n        IF &STR(&XZILNAM) \u00ac= THEN SET THENAME = &STR(&XZILNAM)\n        ELSE SET THENAME = &STR(&XZILMEM)\n        SET PARM = &STR(&ISAPROG&XZILDBG&THENAME)\n        IF &STR(&XZILMAC1&XZILMAC2&XZILMAC3&XZILMAC4) = THEN DO\n         ALLOC F(ZILICMAC) DUMMY REU\n        END\n        ELSE DO\n         ALLOC F(ZILICMAC) SHR REU DA(&XZILMAC1 &XZILMAC2 &XZILMAC3 &XZILMAC4)\n         IF &LASTCC \u00ac= 0 THEN DO\n          SET CURSOR = XZILMAC1\n          GOTO ERROR\n         END\n        END\n        ALLOC F(ZILOCTRN) DA(*) REU\n        ALLOC F(ZILI) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        ALLOC F(ZILO) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        ALLOC F(ZILOCODE) DA(*) REU\n        IF &LASTCC \u00ac= 0 THEN GOTO ERROR\n        IF &STR(&XZILALL) = THEN DO\n         ALLOC F(ZILISRC) DA(*) REU\n         IF &LASTCC \u00ac= 0 THEN DO\n          SET CURSOR = XZILSRC\n          GOTO ERROR\n         END\n        END\n        ELSE DO\n         %XZCHECK '&XZZZSRC(&XZILMEM)' SETMSG\n         SET CHKCC = &LASTCC\n         IF &CHKCC \u00ac= 0 THEN DO\n          IF &CHKCC = 4 THEN SET CURSOR = XZILMEM\n          ELSE SET CURSOR = XZILSRC\n          GOTO LOOP\n         END\n         IF &XTRACE = THEN CONTROL NOMSG\n         ALLOC F(ZILISRC) SHR REU DA('&XZZZSRC(&XZILMEM)')\n         IF &LASTCC \u00ac= 0 THEN DO\n          CONTROL MSG\n          SET CURSOR = XZILMAC1\n          GOTO ERROR\n         END\n         CONTROL MSG\n        END\n        /* Make XCMD handle attentions\n        IF &STR(&XZILSUB1.&XZILSUB2.&XZILSUB3.&XZILSUB4.&XZILRUN) = THEN +\n         SET LIBRARY = &STR(&LIBRARY &LIBRARY)\n        ISPEXEC CONTROL DISPLAY LINE\n        XCMD \"ZILCO \\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&PARM\" +\n             NOFILE +\n             LIB(&XZILSUB1 &XZILSUB2 &XZILSUB3 &XZILSUB4 &XZILRUN &LIBRARY)\n        SET XZILCC = &LASTCC\n        FREE F(ZILISRC ZILICMAC ZILI ZILO ZILOCODE ZILOCTRN)\n        ISPEXEC SETMSG MSG(XZIL011)\n        GOTO LOOP\n        ERROR:+\n        ISPEXEC SETMSG MSG(XZIL005)\n        GOTO LOOP\n        EXIT:+\n        EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XZIL8": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x00\\x88\\x05O\\x01\\x00$O\\t1\\x00V\\x00V\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-02-23T00:00:00", "modifydate": "2000-08-31T09:31:12", "lines": 86, "newlines": 86, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 8                                                  *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        CONTROL NOFLUSH NOCAPS\n        SET CURSOR = XZIL8FN\n        LOOP:+\n        CONTROL NOPROMPT\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL8) CURSOR(&CURSOR)\n        IF &LASTCC \u00ac= 0 THEN GOTO EXIT\n        IF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\n        SET SYSDVAL = &STR(&XZIL8FL)\n        READDVAL XZZZ8FL\n        %XZCHECK '&XZZZ8FL(&XZIL8FN)' SETMSG\n        SET CC = &LASTCC\n        IF &CC \u00ac= 0 THEN DO\n         IF &CC = 4 THEN SET CURSOR = XZIL8FN\n         ELSE SET CURSOR = XZIL8FL\n         GOTO LOOP\n        END\n        SET SYSDVAL = &STR(&XZIL8PL)\n        READDVAL XZZZ8PL\n        %XZCHECK '&XZZZ8PL(&XZIL8PN)' SETMSG\n        SET CC = &LASTCC\n        IF &CC \u00ac= 0 THEN DO\n         IF &CC = 4 THEN SET CURSOR = XZIL8PN\n         ELSE SET CURSOR = XZIL8PL\n         GOTO LOOP\n        END\n        ALLOC F(ZFUNLIB) SHR REU DA('&XZZZ8FL')\n        IF &LASTCC \u00ac= 0 THEN DO\n         SET CURSOR = XZIL8FL\n         GOTO LOOP\n        END\n        ALLOC F(SYSLMOD) SHR REU DA('&XZZZ8PL')\n        IF &LASTCC \u00ac= 0 THEN DO\n         SET CURSOR = XZIL8FL\n         GOTO LOOP\n        END\n        ISPEXEC CONTROL DISPLAY LINE START(1)\n        CONTROL PROMPT\n        IF &STR(&XZIL8PN) = ZILSUBS THEN DO\n         LINK * +\n              LOAD('&XZZZ8PL') +\n              PRINT(*) +\n              LIST MAP LET TEST\n         DATA PROMPT\n         ORDER &XZIL8PN,&XZIL8FN\n         INCLUDE ZFUNLIB(&XZIL8FN)\n         INCLUDE SYSLMOD(&XZIL8PN)\n         NAME &XZIL8PN(R)\n        &STR()\n         ENDDATA\n        END\n        ELSE DO\n         LINK * +\n              LOAD('&XZZZ8PL') +\n              PRINT(*) +\n              LIST LET /* MAP */\n         DATA PROMPT\n         ORDER ZILMAIN,&XZIL8PN,&XZIL8FN\n         INCLUDE ZFUNLIB(&XZIL8FN)\n         INCLUDE SYSLMOD(&XZIL8PN)\n         ENTRY ZILMAIN\n         NAME &XZIL8PN(R)\n        &STR()\n         ENDDATA\n        END\n        SET XZILCC = &LASTCC\n        IF &XZILCC > 0 THEN WRITE Possible linkedit error, RC=&XZILCC\n        WRITE Load module &XZIL8PN replaced in '&XZZZ8PL'.\n        GOTO LOOP\n        ERROR:+\n        ISPEXEC SETMSG MSG(XZIL005)\n        GOTO LOOP\n        EXIT:+\n        EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZIL9": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x000\\x00\\x88\\x14O\\x01\\x00$O\\t5\\x01\\xae\\x010\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1988-05-23T00:00:00", "modifydate": "2000-08-31T09:35:30", "lines": 430, "newlines": 304, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.3 - SEB1525 - 02/88                                  *\n        /*                                                                    *\n        /* ISPF ZIL option 9 - assemble ZIL assembler language function       *\n        /*                                                                    *\n        /* Change activity:                                                   *\n        /*                                                                    *\n        /* 05/25/88 - Member list processing added.                           *\n        /* 05/31/88 - \"B\" selection code added to member list processing.     *\n        /* 12/16/88 - Blank now means member list, not assemble.              *\n        /* 04/25/90 - Use 'SYS1.MODGEN' instead of 'DST1.AMODGEN'             *\n        /*                                                                    *\n        /**********************************************************************\n\n        NGLOBAL MACLIB TEMPPFX TEST XREF\n\n        IF &XTRACE = XTRACE THEN DO\n         CONTROL CONLIST SYMLIST LIST\n         ISPEXEC CONTROL DISPLAY LINE\n        END\n        CONTROL NOFLUSH NOCAPS\n        SET CURSOR = XZASMEM\n        ISPEXEC VGET (ZTEMPF ZSCREEN) /* ZTEMPF = some_prefix.SPFTEMPn.CNTL\n        SET SESSNO = &SUBSTR(&LENGTH(&STR(&ZTEMPF)),&ZTEMPF)\n        IF &SESSNO \u00ac= L THEN +\n         SET TEMPPFX = &STR(&SYSUID..SPFPIE&SESSNO..SPFTEMP&ZSCREEN)\n        ELSE +\n         SET TEMPPFX = &SUBSTR(1:&LENGTH(&STR(&ZTEMPF))-5,&ZTEMPF)\n        LOOP:+\n        ISPEXEC CONTROL DISPLAY REFRESH\n        ISPEXEC DISPLAY PANEL(XZIL9) CURSOR(&CURSOR)\n        IF &LASTCC \u00ac= 0 THEN EXIT\n        IF &XTRACE = XTRACE THEN ISPEXEC CONTROL DISPLAY LINE\n        SET XZZZSRC = &STR(&XZASSRC)\n        SET XZZZLNK = &STR(&XZASLNK)\n        SYSCALL QUALIFY XZZZSRC\n        SYSCALL QUALIFY XZZZLNK\n        IF &XZASSEL = E THEN DO\n         SYSCALL EDIT ASSMEM('&XZASMEM') ASSSRC('&XZZZSRC')\n         GOTO LOOP\n        END\n\n        SELECT &XZASTST\n         WHEN (Y)   SET TEST = TEST\n         OTHERWISE  SET TEST = NOTEST\n        END\n        SELECT &XZASXRF\n         WHEN (F)   SET XREF = XREF(FULL)\n         WHEN (S)   SET XREF = XREF(SHORT)\n         OTHERWISE  SET XREF = NOXREF\n        END\n\n        SET MACLIB =  'PROGLIB.ZIL.&XZILSYS.MACLIB'\n\n        /**********************************************************************/\n        /*                                                                    */\n        /* If the selection is blank                                          */\n        /* or the member name is blank or a pattern, generate a member list.  */\n        /*                                                                    */\n        /**********************************************************************/\n\n        /* (&STR(&XZASMEM) \u00ac= &STR() && &SYSINDEX(*,&XZASMEM) = 0) THEN DO\n\n        IF &XZASSEL = A THEN DO\n\n         SYSCALL ASSEMBLE ASSMEM ('&XZASMEM') +\n                          ASSNAME('&XZASNAM') +\n                          ASSSRC ('&XZZZSRC') +\n                          ASSLINK('&XZZZLNK') +\n                          ASSBAL ('&XZASBAL') +\n                          ASSBLL ('&XZASBLL') +\n                          ASSMAL ('&XZASMAL') +\n                          ASSPARM('&XZASPRM')\n         SELECT (&LASTCC)\n          WHEN (0)\n          WHEN (4)  DO\n                     SET CURSOR = XZASMEM\n                    END\n          WHEN (1)  DO\n                     SET CURSOR = XZASLNK\n                    END\n          OTHERWISE DO\n                     SET CURSOR = XZASSRC\n                   END\n         END\n\n        END\n\n        ELSE DO\n\n        /* process member list */\n\n         ISPEXEC CONTROL ERRORS RETURN\n\n         ISPEXEC LMINIT DATAID(DATAID) DATASET('&XZZZSRC')\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMOPEN DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n\n         SET MLCURSOR = ZCMD\n         SET MLTOP    = &STR(&XZASMEM)\n\n         MLOOP:+\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(DISPLAY) MEMBER(&XZASMEM) +\n                         COMMANDS(ANY) +\n                         CURSOR(&MLCURSOR) +\n                         TOP(&MLTOP) +\n                         PANEL(XZIL9M)\n         SELECT &LASTCC\n          WHEN (0)\n          WHEN (4) GOTO NO_MEMBERS\n          WHEN (8) GOTO MFINISH\n          OTHERWISE GOTO ERROR\n         END\n\n        /**********************************************************************/\n        /*                                                                    */\n        /* Selection variables returned:                                      */\n        /*                                                                    */\n        /* ZLMEMBER - name of selected member                                 */\n        /* ZCMD     - primary command                                         */\n        /* ZLLCMD   - line command used to select the member                  */\n        /* ZLUDATA  - user data area on member list                           */\n        /*                                                                    */\n        /**********************************************************************/\n\n         SET PROCESSED_OK = N\n\n         SET SYSDVAL = &NRSTR(&ZCMD)\n         READDVAL ZCMDVERB ZCMDOPERAND\n         SELECT (&NRSTR(&ZCMDVERB))\n          WHEN ()\n          WHEN (E | EDIT) DO\n           IF &SYSINDEX(*,&ZCMDOPERAND) \u00ac= 0 THEN DO\n            ISPEXEC SETMSG MSG(ISRM053) /* \"*\" not valid */\n            GOTO MLOOP\n           END\n           SYSCALL EDIT ASSMEM('&NRSTR(&ZCMDOPERAND)') ASSSRC('&XZZZSRC')\n           SET CC = &LASTCC\n           IF &CC > 8 THEN SET MLCURSOR = ZCMD\n           ELSE DO\n            SET ZCMD =\n            SET MLTOP = &NRSTR(&ZCMDOPERAND)\n            IF &CC = 0 THEN DO\n             ISPEXEC LMMDISP DATAID(&DATAID) OPTION(ADD) +\n                             MEMBER(&NRSTR(&ZCMDOPERAND)) +\n                             ZLUDATA (*ADDED)\n             IF &LASTCC > 8 THEN GOTO ERROR\n             /* if lastcc = 8 then member already exists, not added */\n            END\n           END\n           GOTO MLOOP\n          END\n          OTHERWISE DO\n           ISPEXEC SETMSG MSG(ISPZ001)\n           GOTO MLOOP\n          END\n         END\n\n         SET MLTOP = &STR(&ZLMEMBER)\n\n         PROCESS_A_MEMBER:+\n         SET PROCESSED_OK = N\n\n         SYSCALL BACKSCAN ZLUDATA\n         SYSCALL BACKSCAN ZLMEMBER\n\n         IF &SUBSTR(1,&ZLUDATA ) = &STR(*) THEN SET NEWNAME =\n         ELSE SET NEWNAME = &STR(&ZLUDATA)\n\n         SELECT &ZLLCMD\n          WHEN (A) DO\n                    SYSCALL ASSEMBLE ASSMEM ('&ZLMEMBER') +\n                                     ASSNAME('&NEWNAME' ) +\n                                     ASSSRC ('&XZZZSRC' ) +\n                                     ASSLINK('&XZZZLNK' ) +\n                                     ASSBAL ('&XZASBAL' ) +\n                                     ASSBLL ('&XZASBLL' ) +\n                                     ASSMAL ('&XZASMAL' ) +\n                                     ASSPARM('&XZASPRM' )\n                    SELECT &LASTCC\n                     WHEN (0)    DO\n                                  SET ZLUDATA = &STR(*ASMLNKD)\n                                  SET PROCESSED_OK = Y\n                                 END\n                     WHEN (1000)  SET ZLUDATA = &STR(*ASMFAIL)\n                     WHEN (2000)  SET ZLUDATA = &STR(*LNKFAIL)\n                     OTHERWISE    SET ZLUDATA = &STR(*ALCFAIL)\n                    END\n                    SET ZLLCMD =\n                   END\n          WHEN (E) DO\n                    SYSCALL EDIT ASSMEM('&ZLMEMBER') ASSSRC('&XZZZSRC')\n                    IF &LASTCC = 0 THEN +\n                     SET ZLUDATA = &STR(*SAVED)\n                    ELSE +\n                     SET ZLUDATA =\n                    SET ZLLCMD =\n                    SET PROCESSED_OK = Y\n                   END\n          WHEN (B) DO\n                    SYSCALL BROWSE   ASSMEM ('&ZLMEMBER') +\n                                     ASSNAME('&NEWNAME' ) +\n                                     ASSMAL ('&XZASMAL' )\n                    IF &LASTCC = 0 THEN DO\n                     SET PROCESSED_OK = Y\n                     SET ZLUDATA =\n                     SET ZLLCMD =\n                    END\n                   END\n          OTHERWISE DO\n                     ISPEXEC SETMSG MSG(XZIL017) /* invalid selection code\n                     SET MLTOP = &STR(&ZLMEMBER)\n                    END\n         END\n\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(PUT) +\n                         MEMBER(&ZLMEMBER) ZLLCMD(&ZLLCMD) ZLUDATA(&ZLUDATA)\n         IF &LASTCC > 8 THEN GOTO ERROR\n\n         IF &PROCESSED_OK = Y THEN DO\n          ISPEXEC LMMDISP DATAID(&DATAID) OPTION(GET)\n          SET CC =  &LASTCC\n          IF &CC > 8 THEN GOTO ERROR\n          IF &CC = 0 THEN GOTO PROCESS_A_MEMBER\n          SET MLCURSOR = ZCMD\n         END\n         ELSE DO\n          SET MLCURSOR = ZLLCMD\n         END\n\n         GOTO MLOOP\n\n         NO_MEMBERS: ISPEXEC SETMSG MSG(XZIL018)\n         SET CURSOR = XZASMEM\n         GOTO LOOP\n\n         MFINISH:+\n         ISPEXEC LMMDISP DATAID(&DATAID) OPTION(FREE)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMCLOSE DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n         ISPEXEC LMFREE DATAID(&DATAID)\n         IF &LASTCC >= 8 THEN GOTO ERROR\n        END\n\n        GOTO LOOP\n\n        ERROR:ISPEXEC CONTROL ERRORS CANCEL\n        ISPEXEC DISPLAY PANEL(ZILTERM)\n        GOTO LOOP\n\n        ASSEMBLE: PROC 0 ASSMEM() ASSNAME() ASSSRC() ASSLINK() +\n                         ASSBAL() ASSBLL()  ASSMAL() ASSPARM()\n\n        SET ASSEMBLED = 0\n        SET LINKEDITED = 0\n        SET ASSEMBLY_ERROR = 0\n        SET LINKEDIT_ERROR = 0\n        IF &STR(&ASSNAME) \u00ac= THEN SET THENAME = &STR(&ASSNAME)\n        ELSE SET THENAME = &STR(&ASSMEM)\n        %XZCHECK '&ASSSRC(&ASSMEM)' SETMSG\n        SET CHKCC = &LASTCC\n        IF &CHKCC \u00ac= 0 THEN DO\n         RETURN CODE(&CHKCC)\n        END\n        %XZCHECK '&ASSLINK(&THENAME)' SETMSG\n        SELECT &LASTCC\n         WHEN (0) DO\n                  END\n         WHEN (4) DO\n                   ISPEXEC SETMSG MSG(XZIL014)  /* the only way to \"SETNOMSG\"\n                  END\n         OTHERWISE DO\n          RETURN CODE(1)\n         END\n        END\n        ISPEXEC CONTROL DISPLAY LINE START(1)\n        SET ASMCODE = &STR('&ASSSRC(&ASSMEM)')\n        SET OBJCODE = &STR('&TEMPPFX..OBJ')\n        SET LNKLIST = &STR('&TEMPPFX..LNKLIST')\n        IF &ASSMAL = Y THEN +\n         SET ASMLIST = &STR('&SYSPREF..&THENAME..ASMLIST')\n        ELSE +\n         SET ASMLIST = &STR('&TEMPPFX..ASMLIST')\n        IF &ASSBAL = Y THEN DO\n         IF &SYSDSN(&ASMLIST) \u00ac= OK THEN %XZMAKE DS &ASMLIST ASMLIST\n        END\n        IF &SYSDSN(&OBJCODE) \u00ac= OK THEN %XZMAKE DS &OBJCODE OBJ\n        ALLOC F(IEVIN)  SHR REU DA(&ASMCODE)\n        ALLOC F(IEVLIN)     REU DA(&OBJCODE)              DSORG(PS)\n        IF &ASSBAL = Y THEN DO\n         ALLOC F(IEVPRINT)  REU DA(&ASMLIST)              DSORG(PS)\n        END\n        ELSE DO\n         ALLOC F(IEVPRINT)  REU DUMMY\n        END\n        ALLOC F(IEVLIB) SHR REU DA('SYS1.MACLIB' 'SYS1.MODGEN' &MACLIB)\n        ALLOC F(IEVUT1)     REU T SP(50 50) DEL REL\n        ALLOC F(IEVTERM)    REU DA(*)\n        WRITE Assembly object output to: &OBJCODE\n        IF &ASSBAL = Y THEN DO\n         WRITE Assembly print output to: &ASMLIST\n        END\n        WRITE Assembly in progress for &THENAME\n        XINV IEV90 'LIST,TERM,ESD,NORLD,OBJECT,NODECK,NORENT,&XREF,&TEST,+\n                    SYSPARM(&NRSTR(&ASSPARM))' +\n             NOFILE +\n             SYSIN(IEVIN) SYSLIN(IEVLIN) SYSPRINT(IEVPRINT) SYSLIB(IEVLIB) +\n             SYSTERM(IEVTERM) SYSUT1(IEVUT1)\n        SET XZILCC = &LASTCC\n        FREE F(IEVIN IEVLIN IEVPRINT IEVLIB IEVUT1 IEVTERM)\n        SET ASSEMBLED = 1\n        IF &XZILCC > 0 THEN DO\n         SET ASSEMBLY_ERROR = 1\n         ISPEXEC SETMSG MSG(XZIL009)\n         GOTO BROLIST\n        END\n        SELECT &STR(&THENAME)\n         WHEN (ZIFINIT) DO\n          SET NCAL =\n          SET LINKLIB = LIB('SYS1.VSF2FORT')\n         END\n         WHEN (ZILSUBS) DO\n          SET NCAL =\n          SET LINKLIB = LIB('&ASSLINK')\n         END\n         OTHERWISE DO\n          SET NCAL = NCAL\n          SET LINKLIB =\n         END\n        END\n        IF &ASSBLL = Y THEN DO\n         IF &SYSDSN(&LNKLIST) \u00ac= OK THEN %XZMAKE DS &LNKLIST LINKLIST\n         WRITE Linkage editor print output to: &LNKLIST\n         SET LINKPRINT = &STR(PRINT(&LNKLIST))\n        END\n        ELSE DO\n         SET LINKPRINT = NOPRINT\n        END\n        WRITE Linkedit in progress for &THENAME\n        LINK &OBJCODE +\n           LOAD('&ASSLINK(&THENAME)') +\n           &LINKPRINT +\n           &LINKLIB +\n           LIST MAP LET TERM &NCAL &TEST\n        SET XZILCC = &LASTCC\n        SET LINKEDITED = 1\n        IF &XZILCC > 4 THEN DO\n         WRITE Possible linkedit error, RC=&XZILCC\n         SET ASSEMBLY_ERROR = 1\n         SET LINKEDIT_ERROR = 1\n         ISPEXEC SETMSG MSG(XZIL000)\n        END\n        IF &XZILCC < 12 THEN +\n         WRITE Load module is in: '&ASSLINK(&THENAME)'.\n        BROLIST:+\n        ISPEXEC CONTROL ERRORS RETURN\n        IF &ASSEMBLED = 1 THEN DO\n         IF &ASSBAL = Y /* | &ASSEMBLY_ERROR = 1 */ THEN DO\n          ISPEXEC BROWSE DATASET(&ASMLIST)\n          IF &LASTCC > 8 THEN ISPEXEC DISPLAY PANEL(ZILTERM)\n         END\n        END\n        IF &LINKEDITED = 1 THEN DO\n         IF &ASSBLL = Y /* | &LINKEDIT_ERROR = 1 */ THEN DO\n          ISPEXEC BROWSE DATASET(&LNKLIST)\n          IF &LASTCC > 8 THEN ISPEXEC DISPLAY PANEL(ZILTERM)\n         END\n        END\n        ISPEXEC CONTROL ERRORS CANCEL\n        IF      &ASSEMBLY_ERROR = 1 THEN RETURN CODE(1000)\n        ELSE IF &LINKEDIT_ERROR = 1 THEN RETURN CODE(2000)\n        ELSE RETURN CODE(0)\n        END /* ASSEMBLE */\n\n        EDIT: PROC 0 ASSMEM() ASSSRC()\n         ISPEXEC CONTROL ERRORS RETURN\n         ISPEXEC EDIT DATASET('&ASSSRC(&ASSMEM)')\n         SET CC = &LASTCC\n         SELECT &CC\n          WHEN (0) SYSCALL SETMSG_XZIL015 &ASSSRC &ASSMEM\n          WHEN (4)  /* nothing */\n          OTHERWISE ISPEXEC SETMSG MSG(&ZERRMSG)\n         END\n         ISPEXEC CONTROL ERRORS CANCEL\n         RETURN CODE(&CC)\n        END /* EDIT */\n\n        BROWSE: PROC 0 ASSMEM() ASSNAME() ASSMAL()\n         IF &STR(&ASSNAME) \u00ac= THEN SET THENAME = &STR(&ASSNAME)\n         ELSE SET THENAME = &STR(&ASSMEM)\n         IF &ASSMAL = Y THEN +\n          SET ASMLIST = &STR('&SYSPREF..&THENAME..ASMLIST')\n         ELSE +\n          SET ASMLIST = &STR('&TEMPPFX..ASMLIST')\n         ISPEXEC CONTROL ERRORS RETURN\n         ISPEXEC BROWSE DATASET(&ASMLIST)\n         SET CC = &LASTCC\n         IF &CC > 8 THEN ISPEXEC SETMSG MSG(&ZERRMSG)\n         ELSE ISPEXEC SETMSG MSG(XZIL014)  /* the only way to \"SETNOMSG\"\n         ISPEXEC CONTROL ERRORS CANCEL\n         RETURN CODE(&CC)\n        END /* BROWSE */\n\n        QUALIFY: PROC 1 VAR\n         SYSREF VAR\n         SET L = &LENGTH(&STR(&VAR))\n         IF &SUBSTR(1,&VAR ) = ' THEN +\n          SET VAR = &SUBSTR(2:&L-1,&VAR)\n         ELSE +\n          SET VAR = &STR(&SYSPREF..&VAR)\n        END /* QUALIFY\n\n        BACKSCAN: PROC 1 WORD\n         SYSREF WORD\n         SET I = &SYSINDEX( ,&NRSTR(&WORD))\n         IF &I = 1 THEN SET WORD =\n         ELSE IF &I \u00ac= 0 THEN SET WORD = &SUBSTR(1:&I-1,&NRSTR(&WORD))\n        END /* BACKSCAN\n\n        /* Subprocedure to isolate the XZILMEM variable. */\n\n        SETMSG_XZIL015:PROC 2 XZZZSRC XZILMEM\n        ISPEXEC SETMSG MSG(XZIL015)\n        RETURN\n        END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XZMAKE": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x00$O\\x01\\x00$O\\t7\\x00K\\x00F\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-08-31T00:00:00", "modifydate": "2000-08-31T09:37:17", "lines": 75, "newlines": 70, "modlines": 0, "user": "SEB1525"}, "text": "PROC 3 WHAT DSNAME ATTRLIST SIZE(1)\n\nSELECT &ATTRLIST\n WHEN (LISTF120) DO\n  SET ARECFM   = F B A\n  SET ALRECL   = 121\n  SET ABLKSIZE = 6171\n END\n WHEN (TEXT) DO\n  SET ARECFM   = V B\n  SET ALRECL   = 255\n  SET ABLKSIZE = 6233\n END\n WHEN (OBJ) DO\n  SET ARECFM   = F B\n  SET ALRECL   = 80\n  SET ABLKSIZE = 2960\n END\n WHEN (ASMLIST) DO\n  SET ARECFM   = F B A\n  SET ALRECL   = 121\n  SET ABLKSIZE = 6171\n END\n WHEN (LINKLIST) DO\n  SET ARECFM   = F B A\n  SET ALRECL   = 121\n  SET ABLKSIZE = 4235\n END\n OTHERWISE DO\n  SET ARECFM   = F B\n  SET ALRECL   = 80\n  SET ABLKSIZE = 6160\n END\nEND\n\nSET ASPACE1  = 16 * &SIZE\nSET ASPACE2  = 10 * &SIZE\nSET ASPUNITS = BLOCK(&ABLKSIZE)\n\n/* first see if it already exists\n\nSET XMSTAT = &SYSDSN(&NRSTR(&DSNAME))\n\nSELECT &NRSTR(&XMSTAT)\n WHEN (OK) DO\n  EXIT CODE(0)\n END\n WHEN (DATASET NOT FOUND) DO\n  /* go ahead */\n END\n WHEN (MEMBER NOT FOUND) DO\n  EXIT CODE(0)\n END\n OTHERWISE DO\n  WRITE &NRSTR(Error: Cannot use data set &DSNAME: &XMSTAT)\n  EXIT CODE(16)\n END\nEND\n\nSET ALLOCPARMS = &NRSTR(+\n      RECFM(&ARECFM) LRECL(&ALRECL) BLKSIZE(&ABLKSIZE) +\n      SPACE(&ASPACE1 &ASPACE2) &ASPUNITS +\n      )\nIF &WHAT = PDS THEN DO\n SET ALLOCPARMS = &NRSTR(&ALLOCPARMS) DIR(32)\nEND\n\nALLOC DA(&NRSTR(&DSNAME)) &NRSTR(&ALLOCPARMS)\nIF &LASTCC NE 0 THEN DO\n WRITE Error: Could not allocate new data set &DSNAME..\n EXIT CODE(12)\nEND\n\nEXIT CODE(0)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZNODRIB": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x00\\x86\\x02O\\x01\\x00\\x11\\x0f\\x15(\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-01-24T00:00:00", "modifydate": "2000-04-19T15:28:31", "lines": 19, "newlines": 19, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.2 - SEB1525 - 01/86                                  *\n        /*                                                                    *\n        /* This CLIST frees a ZIL dribble file.                               *\n        /* The DD name is ZILDRIBL.                                           *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        FREE FI(ZILDRIBL)\n        IF &LASTCC \u00ac= 0 THEN DO\n         WRITE\n         WRITE XZNODRIB Error: Dribble file not freed.\n         EXIT C(12) Q\n        END\n        ELSE +\n         WRITE XZNODRIB: Dribble file is now free.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XZOFILE": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00A\\x00\\x86\\x06?\\x01\\x00#\\x1f\\x10V\\x00.\\x00/\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "2000-08-18T10:56:41", "lines": 46, "newlines": 47, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 2 FILENAME DATASETNAME REUSE RELEASE NEW OLD MOD NOINFORM XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.2 - SEB1525 - 03/86                                  *\n        /*                                                                    *\n        /* This CLIST allocates a ZIL output file.                            *\n        /* The DD name is ZILOxxxx, where xxxx is the file name.              *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        IF &LENGTH(&STR(&FILENAME)) > 4 THEN DO\n         WRITE XZOFILE Error: File name must not exceed 4 characters.\n         EXIT C(12) Q\n        END\n        IF &STR(&FILENAME) = NIL +\n         | &STR(&FILENAME) = T +\n         | &DATATYPE(&STR(&FILENAME)) = NUM THEN DO\n         WRITE XZOFILE Error: \"&FILENAME\" is not a valid file name.\n         EXIT C(12) Q\n        END\n        IF      &NEW&MOD&OLD = NEW THEN SET DISPOSITION = NEW\n        ELSE IF &NEW&MOD&OLD = MOD THEN SET DISPOSITION = MOD\n        ELSE IF &NEW&MOD&OLD = OLD THEN SET DISPOSITION = OLD\n        ELSE DO\n         SET STAT = SYSDSN(&DATASETNAME)\n         IF &STR(&STAT) = DATASET NOT FOUND THEN SET DISPOSITION = NEW\n         ELSE SET DISPOSITION = OLD\n        END\n        IF &DISPOSITION = NEW | &DISPOSITION = MOD THEN +\n         SET OTHERPARMS = &STR(RECFM(F B) LRECL(80) BL(800) SP(10 10))\n        ELSE SET OTHERPARMS =\n        ALLOC FI(ZILO&FILENAME) +\n              DA(&DATASETNAME) +\n              &DISPOSITION +\n              &OTHERPARMS +\n              &RELEASE +\n              &REUSE\n        IF &LASTCC = 0 THEN DO\n         IF &NOINFORM = THEN +\n          WRITE XZOFILE: Output file &FILENAME allocated to data set &DATASETNAME..\n        END\n        ELSE DO\n         WRITE XZOFILE Error: Output file &FILENAME allocation failed.\n         EXIT C(12) Q\n        END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XZOFREE": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x00\\x86\\x06?\\x01\\x00\\x11\\x0f\\x15(\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-03-04T00:00:00", "modifydate": "2000-04-19T15:28:40", "lines": 28, "newlines": 28, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 1 FILENAME XTRACE\n        /**********************************************************************\n        /*                                                                    *\n        /* ZIL VERSION 1.2 - SEB1525 - 03/86                                  *\n        /*                                                                    *\n        /* This CLIST frees a ZIL output file.                                *\n        /* The DD name is ZILOxxxx, where xxxx is the file name.              *\n        /*                                                                    *\n        /**********************************************************************\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        CONTROL NOFLUSH NOCAPS\n        IF &LENGTH(&STR(&FILENAME)) > 4 THEN DO\n         WRITE XZOFREE Error: File name must not exceed 4 characters.\n         EXIT C(12) Q\n        END\n        IF &STR(&FILENAME) = NIL +\n         | &STR(&FILENAME) = T +\n         | &DATATYPE(&STR(&FILENAME)) = NUM THEN DO\n         WRITE XZOFREE Error: \"&FILENAME\" is not a valid file name.\n         EXIT C(12) Q\n        END\n        FREE FI(ZILO&FILENAME)\n        IF &LASTCC \u00ac= 0 THEN DO\n         WRITE XZOFREE Error: Output file &FILENAME not freed.\n         EXIT C(12) Q\n        END\n        ELSE +\n         WRITE XZOFREE: Output file &FILENAME is now free.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Z370COMP": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\x00\\x11\\x0f\\x01\\x00$?\\x10\\x05\\x00\\xdd\\x01*\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-04-19T00:00:00", "modifydate": "2000-08-30T10:05:09", "lines": 221, "newlines": 298, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 1  DSNAME +\n                FUNCTION PROGRAM MODULE +\n                NAME() +\n                LOAD() NOLOAD +\n                ASM() NOASM +\n                PRINT(*) NOPRINT +\n                MACROS() +\n                ACSIZE() +\n                CSSIZE() +\n                PDSIZE() +\n                VSSIZE() +\n                DEBUG NODEBUG +\n                TRANSDEBUG NOTRANSNODEBUG +\n                SYSPARM (XA) +\n                LIBRARY (PROGLIB.ZIL.LOAD) +\n                MACLIB  (PROGLIB.ZIL.MACLIB) +\n                XTRACE\n        /*\n        /**********************************************************************\n        /*                                                                    *\n        /*  ZIL version 1.3 - (c) 1988 Charles Stark Draper Laboratory Inc.   *\n        /*                                                                    *\n        /**********************************************************************\n        /*\n        IF &XTRACE \u00ac= THEN CONTROL LIST SYMLIST CONLIST\n        /*\n        IF &NOASM = NOASM THEN DO\n         SET ASM =\n         SET NOLOAD = NOLOAD\n        END\n        IF &NOLOAD = NOLOAD THEN SET LOAD =\n        ELSE IF &STR(&LOAD) = THEN DO\n         WRITE ZILCOMP: LOAD(LIBRARY(MEMBER)) MUST BE SPECIFIED.\n         EXIT C(16) Q\n        END\n        /*\n        SET KIND = &FUNCTION &PROGRAM &MODULE\n        IF &KIND = THEN DO\n         WRITE ZILCOMP: COMPILE OF MODULE ASSUMED.\n         SET KIND = MODULE\n        END\n        ELSE IF &KIND \u00ac= FUNCTION && &KIND \u00ac= PROGRAM && &KIND \u00ac= MODULE THEN DO\n         WRITE ZILCOMP: CONFLICTING OPERANDS SPECIFIED - &KIND\n         EXIT C(12) Q\n        END\n        /*\n        DO WHILE &STR(&NAME) =\n         WRITENR ENTER THE NAME OF THE &KIND TO BE COMPILED:\n         READ NAME\n        END\n        /*\n        IF &STR(&ACSIZE) \u00ac= THEN SET ACSIZE = &STR(A=&ACSIZE)\n        ELSE SET ACSIZE =\n        IF &STR(&CSSIZE) \u00ac= THEN SET CSSIZE = &STR(C=&CSSIZE)\n        ELSE SET CSSIZE =\n        IF &STR(&PDSIZE) \u00ac= THEN SET PDSIZE = &STR(P=&PDSIZE)\n        ELSE SET PDSIZE =\n        IF &STR(&VSSIZE) \u00ac= THEN SET VSSIZE = &STR(V=&VSSIZE)\n        ELSE SET VSSIZE =\n        /*\n        IF &XTRACE = THEN CONTROL NOMSG\n        FREE FI(ZILI ZILO ZILISRC ZILOCODE ZILICMAC ZILICTRN)\n        FREE ATTR(@PRINT @ASM @LOAD @OBJ @ASMLIST)\n        CONTROL MSG\n        /*\n        IF &STR(&ASM) = THEN SET ASM = &STR('&SYSPREF..$ZILTEMP.ASM')\n        SET ASMLIST = &STR('&SYSPREF..$ZILTEMP.ASMLIST')\n        SET OBJCODE = &STR('&SYSPREF..$ZILTEMP.OBJ')\n        /*\n        ALLOC FI(ZILISRC) DA(&DSNAME) SHR\n        /*\n        IF &NOPRINT = NOPRINT THEN DO\n         ALLOC FI(ZILO) DUMMY\n        END\n        ELSE IF &STR(&PRINT) \u00ac= &STR(*) +\n             && &STR(&PRINT) \u00ac= THEN DO\n         CONTROL NOFLUSH\n         IF &XTRACE = THEN CONTROL NOMSG\n         ALLOC FI(ZILO) DA(&PRINT)\n         IF &LASTCC \u00ac= 0 THEN DO\n          CONTROL FLUSH MSG\n          ATTR @PRINT RECFM(F B A) LRECL(151) BLKSIZE(6191)\n          ALLOC FI(ZILO) DA(&PRINT) T SP(10 10) REL USING(@PRINT)\n         END\n         CONTROL FLUSH MSG\n        END\n        ELSE DO\n         ALLOC FI(ZILO) DA(*)\n        END\n        /*\n        IF &NOASM = NOASM THEN DO\n         ALLOC FI(ZILOCODE) DUMMY\n        END\n        ELSE DO\n         CONTROL NOFLUSH\n         IF &XTRACE = THEN CONTROL NOMSG\n         ALLOC FI(ZILOCODE) DA(&ASM)\n         IF &LASTCC \u00ac= 0 THEN DO\n          CONTROL FLUSH MSG\n          ATTR @ASM RECFM(F B) LRECL(80) BLKSIZE(6160)\n          ALLOC FI(ZILOCODE) DA(&ASM) T SP(10 10) REL USING(@ASM)\n          FREE ATTR(@ASM)\n         END\n         CONTROL FLUSH MSG\n        END\n        /*\n        SET KINDPARM = &SUBSTR(1,&KIND)\n        IF &DEBUG = DEBUG THEN SET DEBUGPARM = Y\n        ELSE SET DEBUGPARM = N\n        SET PARM = &STR(&KINDPARM&DEBUGPARM&NAME)\n        /*\n        ALLOC F(ZILI) DA(*) REU\n        /*\n        IF &STR(&MACROS) \u00ac= THEN +\n         ALLOC F(ZILICMAC) DA(&MACROS) SHR\n        ELSE +\n         ALLOC F(ZILICMAC) DUMMY\n        /*\n        IF &TRANSDEBUG&NOTRANSDEBUG = TRANSDEBUG THEN DO\n         ALLOC F(ZILOCTRN) SP(100 100) T REL DEL\n         SET CTRN = Y\n        END\n        ELSE DO\n         SET CTRN = N\n        END\n        /*\n        CALL '&LIBRARY(ZILCO)' '\\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&PARM'\n        SET ZILCOCC = &LASTCC\n        IF &ZILCOCC \u00ac= 0 THEN DO\n         IF &NOPRINT = NOPRINT THEN DO\n          WRITE ZILCOMP: ZIL COMPILATION FAILED WITH ERROR CODE &ZILCOCC..\n          WRITE          RERUN THIS CLIST WITHOUT NOPRINT TO DETERMINE THE ERROR.\n         END\n         ELSE IF &SUBSTR(1,&PRINT ) = ' THEN DO\n          WRITE ZILCOMP: ZIL COMPILATION FAILED WITH ERROR CODE &ZILCOCC..\n          WRITE          BROWSE &PRINT TO DETERMINE THE ERROR.\n         END\n         EXIT C(&ZILCOCC) QUIT\n        END\n        FREE F(ZILOCODE ZILISRC ZILICMAC ZILI ZILO)\n        IF &CTRN = Y THEN DO\n         OPENFILE ZILOCTRN\n         ERROR GOTO TRNEND\n         TRNLOOP:+\n         GETFILE ZILOCTRN\n         WRITE &ZILOCTRN\n         GOTO TRNLOOP\n         TRNEND:ERROR OFF\n         CLOSFILE ZILOCTRN\n         FREE F(ZILOCTRN)\n        END\n        /*\n        IF &NOASM&NOLOAD \u00ac= THEN EXIT\n        /*\n        WRITE ZILCOMP: &NAME COMPILED INTO &ASM\n        IF &SUBSTR(1,&PRINT ) = ' THEN +\n        WRITE         LISTING IN:  &PRINT\n        /*\n        CONTROL NOFLUSH\n        IF &XTRACE = THEN CONTROL NOMSG\n        FREE F(SYSIN SYSPUNCH SYSPRINT SYSLIB SYSUT1 SYSUT2 SYSUT3 SYSTERM)\n        ALLOC FI(SYSPUNCH) DA(&OBJCODE)\n        IF &LASTCC \u00ac= 0 THEN DO\n         CONTROL FLUSH MSG\n         ATTR @OBJ RECFM(F B) LRECL(80) BLKSIZE(3200)\n         ALLOC FI(SYSPUNCH) DA(&OBJCODE) T SP(10 10) REL USING(@OBJ)\n        END\n        /*\n        CONTROL NOFLUSH\n        IF &XTRACE = THEN CONTROL NOMSG\n        ALLOC FI(SYSPRINT) DA(&ASMLIST)\n        IF &LASTCC \u00ac= 0 THEN DO\n         CONTROL FLUSH MSG\n         ATTR @ASMLIST RECFM(F B A) LRECL(121) BLKSIZE(6171)\n         ALLOC FI(SYSPRINT) DA(&ASMLIST) T SP(10 10) REL USING(@ASMLIST)\n        END\n        CONTROL FLUSH MSG\n        ALLOC F(SYSIN) DA(&ASM) SHR\n        ALLOC F(SYSLIB) DA('SYS1.MACLIB' '&MACLIB') SHR\n        ALLOC F(SYSUT1) T SP(50 50) DEL REL\n        ALLOC F(SYSUT2) T SP(50 50) DEL REL\n        ALLOC F(SYSUT3) T SP(50 50) DEL REL\n        ALLOC F(SYSTERM) DA(*)\n        /*\n        WRITE ASSEMBLY LISTING OUTPUT TO: &ASMLIST\n        WRITE ASSEMBLING &NAME INTO &OBJCODE\n        CALL 'SYS1.LINKLIB(IFOX00)' +\n             'LIST,TERM,ESD,RLD,NOXREF,DECK,NOOBJECT,SYSPARM(&SYSPARM)'\n        IF &LASTCC \u00ac= 0 THEN DO\n         WRITE ZILCOMP: ASSEMBLY FAILED - CHECK &ASMLIST FOR ERRORS.\n         EXIT C(16) QUIT\n        END\n        FREE F(SYSIN SYSPUNCH SYSPRINT SYSLIB SYSUT1 SYSUT2 SYSUT3 SYSTERM)\n        /*\n        IF &NOLOAD = NOLOAD THEN EXIT\n        /*\n        WRITE LINKING &OBJCODE INTO &LOAD\n        IF &STR(&SUBRLIB) = THEN SET LINKLIB =\n        ELSE SET LINKLIB = LIB(&SUBRLIB)\n        IF &KIND = PROGRAM THEN DO\n         LINK &OBJCODE +\n              LOAD(&LOAD) +\n              &LINKLIB +\n              PRINT(*) +\n              LIST LET TERM &MAP &TEST\n         SET LINKCC = &LASTCC\n        END\n        ELSE DO\n         LINK &OBJCODE +\n              LOAD(&LOAD) +\n              PRINT(*) +\n              LIST LET TERM NCAL &MAP &TEST\n         SET LINKCC = &LASTCC\n        END\n        IF &XTRACE = THEN CONTROL NOMSG\n        FREE FI(ZILI ZILO ZILISRC ZILOCODE ZILICMAC ZILICTRN)\n        FREE ATTR(@PRINT @ASM @LOAD @OBJ @ASMLIST)\n        CONTROL MSG\n        IF &LINKCC > 4 THEN EXIT QUIT\n        WRITE ZILCOMP: &NAME LOAD MODULE IS IN &LOAD..\n        EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Z370LISP": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00F\\x01\\x00\\x11\\x0f\\x01\\x00$?\\x10A\\x00<\\x00?\\x00\\x00\\xe2\\xc5\\xc2\\xf1\\xf5\\xf2\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2000-04-19T00:00:00", "modifydate": "2000-08-30T10:41:46", "lines": 60, "newlines": 63, "modlines": 0, "user": "SEB1525"}, "text": "        PROC 0 +\n             INITFILE() NOINITFILE +\n             ACSIZE() CSSIZE() PDSIZE() VSSIZE() +\n             DRIBBLE HOLDCLASS() +\n             LIBRARY(PROGLIB.ZIL.LOAD) +\n             XTRACE\n        /*\n        /**********************************************************************\n        /*                                                                    *\n        /*  ZIL version 1.3 - (c) 1989 Charles Stark Draper Laboratory Inc.   *\n        /*                                                                    *\n        /**********************************************************************\n        /*\n        IF &XTRACE = XTRACE THEN CONTROL CONLIST SYMLIST LIST\n        /*\n        SET HELDSYSOUTCLASS = H\n        IF &STR(&HOLDCLASS) = THEN SET HOLDCLASS = &STR(&HELDSYSOUTCLASS)\n        SET PRESENT_FILES =\n        SET MISSING_FILES =\n        IF &STR(&INITFILE) = THEN SET NOINITFILE = NOINITFILE\n        IF &NOINITFILE = THEN DO\n         IF &XTRACE = THEN CONTROL NOMSG\n         FREE FI(ZILIINIT)\n         CONTROL MSG\n         ALLOC FI(ZILIINIT) DA(&INITFILE) SHR\n         SET PRESENT_FILES = &PRESENT_FILES ZILIINIT\n        END\n        ELSE DO\n         SET MISSING_FILES = &MISSING_FILES ZILIINIT\n        END\n        IF &DRIBBLE = DRIBBLE THEN DO\n         IF &XTRACE = THEN CONTROL NOMSG\n         FREE FI(ZILDRIBL)\n         CONTROL MSG\n         ALLOC FI(ZILDRIBL) SYSOUT(&HOLDCLASS) HOLD\n         SET PRESENT_FILES = &PRESENT_FILES ZILDRIBL\n        END\n        ELSE DO\n         SET MISSING_FILES = &MISSING_FILES ZILDRIBL\n        END\n        IF &MISSING_FILES \u00ac= THEN DO\n         IF &XTRACE = THEN CONTROL NOMSG\n         FREE FI(&MISSING_FILES)\n         CONTROL MSG\n        END\n        /*\n        IF &STR(&ACSIZE) \u00ac= THEN SET ACSIZE = &STR(A=&ACSIZE)\n        ELSE SET ACSIZE =\n        IF &STR(&CSSIZE) \u00ac= THEN SET CSSIZE = &STR(C=&CSSIZE)\n        ELSE SET CSSIZE =\n        IF &STR(&PDSIZE) \u00ac= THEN SET PDSIZE = &STR(P=&PDSIZE)\n        ELSE SET PDSIZE =\n        IF &STR(&VSSIZE) \u00ac= THEN SET VSSIZE = &STR(V=&VSSIZE)\n        ELSE SET VSSIZE =\n        /*\n        CALL '&LIBRARY(ZILIN)' '\\&ACSIZE,&CSSIZE,&PDSIZE,&VSSIZE\\&INITFILE'\n        SET CC = &LASTCC\n        IF &CC \u00ac= 0 THEN WRITE *** LISP INTERPRETER EXITED WITH CODE &CC ***\n        IF &PRESENT_FILES \u00ac= THEN FREE FI(&PRESENT_FILES)\n        EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT476/CBT.V500.FILE476.PDS/CLIST.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT476/CBT.V500.FILE476.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}