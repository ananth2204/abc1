{"INMR01": {"INMLRECL": 80, "INMFNODE": "TEST", "INMFUID": "RYS", "INMTNODE": "N1", "INMTUID": "RYS", "INMFTIME": "20021222172811000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 27998, "INMRECFM": "VB", "INMDIR": 6, "INMDSNAM": "RYSJSYT.ZLIB.C", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"RYSJSYT.ZLIB.C": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27998, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "020356", "DS1SCEXT": "b'\\x80m^'", "DS1SCALO": "b'P\\x00\\x00\\x04'", "DS1LSTAR": "b'\\x00\\x05\\x04'", "DS1TRBAL": "b'\\xa6\\x04'"}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0b\\x90\\x00\\x04\\x8b]P'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0b\\x90\\x00\\x04\\x8b]P'", "b'X\\xfcD\\xa0\\x00\\x00\\x01J\\x00\\x05\\x01J\\x00\\x0b\\x00\\x07'", "b'X\\xfcD\\xa0\\x00\\x00\\x01U\\x00\\n\\x01U\\x00\\x0b\\x00\\x02'", "b'X\\xfcD\\xa0\\x00\\x00\\x01U\\x00\\x0c\\x01U\\x00\\r\\x00\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"ADLER32": {"ttr": 8, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* adler32.c -- compute the Adler-32 checksum of a data stream\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zlib.h\"\n\n#define BASE 65521L /* largest prime smaller than 65536 */\n#define NMAX 5552\n/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2\u00ac32-1 */\n\n#define DO1(buf,i)  {s1 += buf\u00ddi\u00a8; s2 += s1;}\n#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);\n#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);\n#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n#define DO16(buf)   DO8(buf,0); DO8(buf,8);\n\n/* ========================================================================= */\nuLong ZEXPORT adler32(adler, buf, len)\n    uLong adler;\n    const Bytef *buf;\n    uInt len;\n{\n    unsigned long s1 = adler & 0xffff;\n    unsigned long s2 = (adler >> 16) & 0xffff;\n    int k;\n\n    if (buf == Z_NULL) return 1L;\n\n    while (len > 0) {\n        k = len < NMAX ? len : NMAX;\n        len -= k;\n        while (k >= 16) {\n            DO16(buf);\n\t    buf += 16;\n            k -= 16;\n        }\n        if (k != 0) do {\n            s1 += *buf++;\n\t    s2 += s1;\n        } while (--k);\n        s1 %= BASE;\n        s2 %= BASE;\n    }\n    return (s2 << 16) | s1;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 10, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* compress.c -- compress a memory buffer\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zlib.h\"\n\n/* ===========================================================================\n     Compresses the source buffer into the destination buffer. The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer. Upon entry, destLen is the total size of the\n   destination buffer, which must be at least 0.1% larger than sourceLen plus\n   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\nint ZEXPORT compress2 (dest, destLen, source, sourceLen, level)\n    Bytef *dest;\n    uLongf *destLen;\n    const Bytef *source;\n    uLong sourceLen;\n    int level;\n{\n    z_stream stream;\n    int err;\n\n    stream.next_in = (Bytef*)source;\n    stream.avail_in = (uInt)sourceLen;\n#ifdef MAXSEG_64K\n    /* Check for source > 64K on 16-bit machine: */\n    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;\n#endif\n    stream.next_out = dest;\n    stream.avail_out = (uInt)*destLen;\n    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;\n\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n    stream.opaque = (voidpf)0;\n\n    err = deflateInit(&stream, level);\n    if (err != Z_OK) return err;\n\n    err = deflate(&stream, Z_FINISH);\n    if (err != Z_STREAM_END) {\n        deflateEnd(&stream);\n        return err == Z_OK ? Z_BUF_ERROR : err;\n    }\n    *destLen = stream.total_out;\n\n    err = deflateEnd(&stream);\n    return err;\n}\n\n/* ===========================================================================\n */\nint ZEXPORT compress (dest, destLen, source, sourceLen)\n    Bytef *dest;\n    uLongf *destLen;\n    const Bytef *source;\n    uLong sourceLen;\n{\n    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRC32": {"ttr": 12, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* crc32.c -- compute the CRC-32 of a data stream\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zlib.h\"\n\n#define local static\n\n#ifdef DYNAMIC_CRC_TABLE\n\nlocal int crc_table_empty = 1;\nlocal uLongf crc_table\u00dd256\u00a8;\nlocal void make_crc_table OF((void));\n\n/*\n  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:\n  x\u00ac32+x\u00ac26+x\u00ac23+x\u00ac22+x\u00ac16+x\u00ac12+x\u00ac11+x\u00ac10+x\u00ac8+x\u00ac7+x\u00ac5+x\u00ac4+x\u00ac2+x+1.\n\n  Polynomials over GF(2) are represented in binary, one bit per coefficient,\n  with the lowest powers in the most significant bit.  Then adding polynomials\n  is just exclusive-or, and multiplying a polynomial by x is a right shift by\n  one.  If we call the above polynomial p, and represent a byte as the\n  polynomial q, also with the lowest power in the most significant bit (so the\n  byte 0xb1 is the polynomial x\u00ac7+x\u00ac3+x+1), then the CRC is (q*x\u00ac32) mod p,\n  where a mod b means the remainder after dividing a by b.\n\n  This calculation is done using the shift-register method of multiplying and\n  taking the remainder.  The register is initialized to zero, and for each\n  incoming bit, x\u00ac32 is added mod p to the register if the bit is a one (where\n  x\u00ac32 mod p is p+x\u00ac32 = x\u00ac26+...+1), and the register is multiplied mod p by\n  x (which is shifting right by one and adding x\u00ac32 mod p if the bit shifted\n  out is a one).  We start with the highest power (least significant bit) of\n  q and repeat for all eight bits of q.\n\n  The table is simply the CRC of all possible eight bit values.  This is all\n  the information needed to generate CRC's on data a byte at a time for all\n  combinations of CRC register values and incoming bytes.\n*/\nlocal void make_crc_table()\n{\n  uLong c;\n  int n, k;\n  uLong poly;            /* polynomial exclusive-or pattern */\n  /* terms of polynomial defining this crc (except x\u00ac32): */\n  static const Byte p\u00dd\u00a8 = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n  /* make exclusive-or pattern from polynomial (0xedb88320L) */\n  poly = 0L;\n  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)\n    poly |= 1L << (31 - p\u00ddn\u00a8);\n\n  for (n = 0; n < 256; n++)\n  {\n    c = (uLong)n;\n    for (k = 0; k < 8; k++)\n      c = c & 1 ? poly \u00ac (c >> 1) : c >> 1;\n    crc_table\u00ddn\u00a8 = c;\n  }\n  crc_table_empty = 0;\n}\n#else\n/* ========================================================================\n * Table of CRC-32's of all single-byte values (made by make_crc_table)\n */\nlocal const uLongf crc_table\u00dd256\u00a8 = {\n  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,\n  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,\n  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,\n  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,\n  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,\n  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,\n  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,\n  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,\n  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,\n  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,\n  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,\n  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,\n  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,\n  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,\n  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,\n  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,\n  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,\n  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,\n  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,\n  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,\n  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,\n  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,\n  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,\n  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,\n  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,\n  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,\n  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,\n  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,\n  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,\n  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,\n  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,\n  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,\n  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,\n  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,\n  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,\n  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,\n  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,\n  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,\n  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,\n  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,\n  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,\n  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,\n  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,\n  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,\n  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,\n  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,\n  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,\n  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,\n  0x2d02ef8dL\n};\n#endif\n\n/* =========================================================================\n * This function can be used by asm versions of crc32()\n */\nconst uLongf * ZEXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n  if (crc_table_empty) make_crc_table();\n#endif\n  return (const uLongf *)crc_table;\n}\n\n/* ========================================================================= */\n#define DO1(buf) crc = crc_table\u00dd((int)crc \u00ac (*buf++)) & 0xff\u00a8 \u00ac (crc >> 8);\n#define DO2(buf)  DO1(buf); DO1(buf);\n#define DO4(buf)  DO2(buf); DO2(buf);\n#define DO8(buf)  DO4(buf); DO4(buf);\n\n/* ========================================================================= */\nuLong ZEXPORT crc32(crc, buf, len)\n    uLong crc;\n    const Bytef *buf;\n    uInt len;\n{\n    if (buf == Z_NULL) return 0L;\n#ifdef DYNAMIC_CRC_TABLE\n    if (crc_table_empty)\n      make_crc_table();\n#endif\n    crc = crc \u00ac 0xffffffffL;\n    while (len >= 8)\n    {\n      DO8(buf);\n      len -= 8;\n    }\n    if (len) do {\n      DO1(buf);\n    } while (--len);\n    return crc \u00ac 0xffffffffL;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFLATE": {"ttr": 14, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* deflate.c -- compress data using the deflation algorithm\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process depends on being able to identify portions\n *      of the input text which are identical to earlier input (within a\n *      sliding window trailing behind the input currently being processed).\n *\n *      The most straightforward technique turns out to be the fastest for\n *      most input files: try all possible matches and select the longest.\n *      The key feature of this algorithm is that insertions into the string\n *      dictionary are very simple and thus fast, and deletions are avoided\n *      completely. Insertions are performed at each input character, whereas\n *      string matches are performed only when the previous match ends. So it\n *      is preferable to spend more time in matches to allow very fast string\n *      insertions and avoid deletions. The matching algorithm for small\n *      strings is inspired from that of Rabin & Karp. A brute force approach\n *      is used to find longer strings when a small match has been found.\n *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze\n *      (by Leonid Broukhis).\n *         A previous version of this file used a more sophisticated algorithm\n *      (by Fiala and Greene) which is guaranteed to run in linear amortized\n *      time, but has a larger average cost, uses more memory and is patented.\n *      However the F&G algorithm may be faster for some highly redundant\n *      files if the parameter max_chain_length (described below) is too large.\n *\n *  ACKNOWLEDGEMENTS\n *\n *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and\n *      I found it in 'freeze' written by Leonid Broukhis.\n *      Thanks to many people for bug reports and testing.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n *      Available in ftp://ds.internic.net/rfc/rfc1951.txt\n *\n *      A description of the Rabin and Karp algorithm is given in the book\n *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n *\n *      Fiala,E.R., and Greene,D.H.\n *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595\n *\n */\n\n/* @(#) $Id$ */\n\n#include \"deflate.h\"\n\nconst char deflate_copyright\u00dd\u00a8 =\n   \" deflate 1.1.4 Copyright 1995-2002 Jean-loup Gailly \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\n\n/* ===========================================================================\n *  Function prototypes.\n */\ntypedef enum {\n    need_more,      /* block not completed, need more input or more output */\n    block_done,     /* block flush performed */\n    finish_started, /* finish started, need only more output at next deflate */\n    finish_done     /* finish done, accept no more input or output */\n} block_state;\n\ntypedef block_state (*compress_func) OF((deflate_state *s, int flush));\n/* Compression function. Returns the block state after the call. */\n\nlocal void fill_window    OF((deflate_state *s));\nlocal block_state deflate_stored OF((deflate_state *s, int flush));\nlocal block_state deflate_fast   OF((deflate_state *s, int flush));\nlocal block_state deflate_slow   OF((deflate_state *s, int flush));\nlocal void lm_init        OF((deflate_state *s));\nlocal void putShortMSB    OF((deflate_state *s, uInt b));\nlocal void flush_pending  OF((z_streamp strm));\nlocal int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));\n#ifdef ASMV\n      void match_init OF((void)); /* asm code initialization */\n      uInt longest_match  OF((deflate_state *s, IPos cur_match));\n#else\nlocal uInt longest_match  OF((deflate_state *s, IPos cur_match));\n#endif\n\n#ifdef DEBUG\nlocal  void check_match OF((deflate_state *s, IPos start, IPos match,\n                            int length));\n#endif\n\n/* ===========================================================================\n * Local data\n */\n\n#define NIL 0\n/* Tail of hash chains */\n\n#ifndef TOO_FAR\n#  define TOO_FAR 4096\n#endif\n/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */\n\n#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n/* Minimum amount of lookahead, except at the end of the input file.\n * See deflate.c for comments about the MIN_MATCH+1.\n */\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\ntypedef struct config_s {\n   ush good_length; /* reduce lazy search above this match length */\n   ush max_lazy;    /* do not perform lazy search above this match length */\n   ush nice_length; /* quit search above this match length */\n   ush max_chain;\n   compress_func func;\n} config;\n\nlocal const config configuration_table\u00dd10\u00a8 = {\n/*      good lazy nice chain */\n/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */\n/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */\n/* 2 */ {4,    5, 16,    8, deflate_fast},\n/* 3 */ {4,    6, 32,   32, deflate_fast},\n\n/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */\n/* 5 */ {8,   16, 32,   32, deflate_slow},\n/* 6 */ {8,   16, 128, 128, deflate_slow},\n/* 7 */ {8,   32, 128, 256, deflate_slow},\n/* 8 */ {32, 128, 258, 1024, deflate_slow},\n/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */\n\n/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n * meaning.\n */\n\n#define EQUAL 0\n/* result of memcmp for equal strings */\n\nstruct static_tree_desc_s {int dummy;}; /* for buggy compilers */\n\n/* ===========================================================================\n * Update a hash value with the given input byte\n * IN  assertion: all calls to to UPDATE_HASH are made with consecutive\n *    input characters, so that a running hash key can be computed from the\n *    previous key instead of complete recalculation each time.\n */\n#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) \u00ac (c)) & s->hash_mask)\n\n\n/* ===========================================================================\n * Insert string str in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * If this file is compiled with -DFASTEST, the compression level is forced\n * to 1, and no hash chains are maintained.\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n *    input characters and the first MIN_MATCH bytes of str are valid\n *    (except for the last MIN_MATCH-1 bytes of the input file).\n */\n#ifdef FASTEST\n#define INSERT_STRING(s, str, match_head) \\\n   (UPDATE_HASH(s, s->ins_h, s->window\u00dd(str) + (MIN_MATCH-1)\u00a8), \\\n    match_head = s->head\u00dds->ins_h\u00a8, \\\n    s->head\u00dds->ins_h\u00a8 = (Pos)(str))\n#else\n#define INSERT_STRING(s, str, match_head) \\\n   (UPDATE_HASH(s, s->ins_h, s->window\u00dd(str) + (MIN_MATCH-1)\u00a8), \\\n    s->prev\u00dd(str) & s->w_mask\u00a8 = match_head = s->head\u00dds->ins_h\u00a8, \\\n    s->head\u00dds->ins_h\u00a8 = (Pos)(str))\n#endif\n\n/* ===========================================================================\n * Initialize the hash table (avoiding 64K overflow for 16 bit systems).\n * prev\u00dd\u00a8 will be initialized on the fly.\n */\n#define CLEAR_HASH(s) \\\n    s->head\u00dds->hash_size-1\u00a8 = NIL; \\\n    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));\n\n/* ========================================================================= */\nint ZEXPORT deflateInit_(strm, level, version, stream_size)\n    z_streamp strm;\n    int level;\n    const char *version;\n    int stream_size;\n{\n    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,\n\t\t\t Z_DEFAULT_STRATEGY, version, stream_size);\n    /* To do: ignore strm->next_in if we use it as window */\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n\t\t  version, stream_size)\n    z_streamp strm;\n    int  level;\n    int  method;\n    int  windowBits;\n    int  memLevel;\n    int  strategy;\n    const char *version;\n    int stream_size;\n{\n    deflate_state *s;\n    int noheader = 0;\n    static const char* my_version = ZLIB_VERSION;\n\n    ushf *overlay;\n    /* We overlay pending_buf and d_buf+l_buf. This works since the average\n     * output size for (length,distance) codes is <= 24 bits.\n     */\n\n    if (version == Z_NULL || version\u00dd0\u00a8 != my_version\u00dd0\u00a8 ||\n        stream_size != sizeof(z_stream)) {\n\treturn Z_VERSION_ERROR;\n    }\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n\n    strm->msg = Z_NULL;\n    if (strm->zalloc == Z_NULL) {\n\tstrm->zalloc = zcalloc;\n\tstrm->opaque = (voidpf)0;\n    }\n    if (strm->zfree == Z_NULL) strm->zfree = zcfree;\n\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#ifdef FASTEST\n    level = 1;\n#endif\n\n    if (windowBits < 0) { /* undocumented feature: suppress zlib header */\n        noheader = 1;\n        windowBits = -windowBits;\n    }\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n        windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||\n\tstrategy < 0 || strategy > Z_HUFFMAN_ONLY) {\n        return Z_STREAM_ERROR;\n    }\n    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));\n    if (s == Z_NULL) return Z_MEM_ERROR;\n    strm->state = (struct internal_state FAR *)s;\n    s->strm = strm;\n\n    s->noheader = noheader;\n    s->w_bits = windowBits;\n    s->w_size = 1 << s->w_bits;\n    s->w_mask = s->w_size - 1;\n\n    s->hash_bits = memLevel + 7;\n    s->hash_size = 1 << s->hash_bits;\n    s->hash_mask = s->hash_size - 1;\n    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);\n\n    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));\n    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));\n    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));\n\n    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    s->pending_buf = (uchf *) overlay;\n    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\n\n    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||\n        s->pending_buf == Z_NULL) {\n        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);\n        deflateEnd (strm);\n        return Z_MEM_ERROR;\n    }\n    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n    s->level = level;\n    s->strategy = strategy;\n    s->method = (Byte)method;\n\n    return deflateReset(strm);\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n    z_streamp strm;\n    const Bytef *dictionary;\n    uInt  dictLength;\n{\n    deflate_state *s;\n    uInt length = dictLength;\n    uInt n;\n    IPos hash_head = 0;\n\n    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||\n        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;\n\n    s = strm->state;\n    strm->adler = adler32(strm->adler, dictionary, dictLength);\n\n    if (length < MIN_MATCH) return Z_OK;\n    if (length > MAX_DIST(s)) {\n\tlength = MAX_DIST(s);\n#ifndef USE_DICT_HEAD\n\tdictionary += dictLength - length; /* use the tail of the dictionary */\n#endif\n    }\n    zmemcpy(s->window, dictionary, length);\n    s->strstart = length;\n    s->block_start = (long)length;\n\n    /* Insert all strings in the hash table (except for the last two bytes).\n     * s->lookahead stays null, so s->ins_h will be recomputed at the next\n     * call of fill_window.\n     */\n    s->ins_h = s->window\u00dd0\u00a8;\n    UPDATE_HASH(s, s->ins_h, s->window\u00dd1\u00a8);\n    for (n = 0; n <= length - MIN_MATCH; n++) {\n\tINSERT_STRING(s, n, hash_head);\n    }\n    if (hash_head) hash_head = 0;  /* to make compiler happy */\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateReset (strm)\n    z_streamp strm;\n{\n    deflate_state *s;\n\n    if (strm == Z_NULL || strm->state == Z_NULL ||\n        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;\n\n    strm->total_in = strm->total_out = 0;\n    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */\n    strm->data_type = Z_UNKNOWN;\n\n    s = (deflate_state *)strm->state;\n    s->pending = 0;\n    s->pending_out = s->pending_buf;\n\n    if (s->noheader < 0) {\n        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */\n    }\n    s->status = s->noheader ? BUSY_STATE : INIT_STATE;\n    strm->adler = 1;\n    s->last_flush = Z_NO_FLUSH;\n\n    _tr_init(s);\n    lm_init(s);\n\n    return Z_OK;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateParams(strm, level, strategy)\n    z_streamp strm;\n    int level;\n    int strategy;\n{\n    deflate_state *s;\n    compress_func func;\n    int err = Z_OK;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    s = strm->state;\n\n    if (level == Z_DEFAULT_COMPRESSION) {\n\tlevel = 6;\n    }\n    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {\n\treturn Z_STREAM_ERROR;\n    }\n    func = configuration_table\u00dds->level\u00a8.func;\n\n    if (func != configuration_table\u00ddlevel\u00a8.func && strm->total_in != 0) {\n\t/* Flush the last buffer: */\n\terr = deflate(strm, Z_PARTIAL_FLUSH);\n    }\n    if (s->level != level) {\n\ts->level = level;\n\ts->max_lazy_match   = configuration_table\u00ddlevel\u00a8.max_lazy;\n\ts->good_match       = configuration_table\u00ddlevel\u00a8.good_length;\n\ts->nice_match       = configuration_table\u00ddlevel\u00a8.nice_length;\n\ts->max_chain_length = configuration_table\u00ddlevel\u00a8.max_chain;\n    }\n    s->strategy = strategy;\n    return err;\n}\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nlocal void putShortMSB (s, b)\n    deflate_state *s;\n    uInt b;\n{\n    put_byte(s, (Byte)(b >> 8));\n    put_byte(s, (Byte)(b & 0xff));\n}\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->next_out buffer and copying into it.\n * (See also read_buf()).\n */\nlocal void flush_pending(strm)\n    z_streamp strm;\n{\n    unsigned len = strm->state->pending;\n\n    if (len > strm->avail_out) len = strm->avail_out;\n    if (len == 0) return;\n\n    zmemcpy(strm->next_out, strm->state->pending_out, len);\n    strm->next_out  += len;\n    strm->state->pending_out  += len;\n    strm->total_out += len;\n    strm->avail_out  -= len;\n    strm->state->pending -= len;\n    if (strm->state->pending == 0) {\n        strm->state->pending_out = strm->state->pending_buf;\n    }\n}\n\n/* ========================================================================= */\nint ZEXPORT deflate (strm, flush)\n    z_streamp strm;\n    int flush;\n{\n    int old_flush; /* value of flush param for previous deflate call */\n    deflate_state *s;\n\n    if (strm == Z_NULL || strm->state == Z_NULL ||\n\tflush > Z_FINISH || flush < 0) {\n        return Z_STREAM_ERROR;\n    }\n    s = strm->state;\n\n    if (strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0) ||\n\t(s->status == FINISH_STATE && flush != Z_FINISH)) {\n        ERR_RETURN(strm, Z_STREAM_ERROR);\n    }\n    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);\n\n    s->strm = strm; /* just in case */\n    old_flush = s->last_flush;\n    s->last_flush = flush;\n\n    /* Write the zlib header */\n    if (s->status == INIT_STATE) {\n\n        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n        uInt level_flags = (s->level-1) >> 1;\n\n        if (level_flags > 3) level_flags = 3;\n        header |= (level_flags << 6);\n\tif (s->strstart != 0) header |= PRESET_DICT;\n        header += 31 - (header % 31);\n\n        s->status = BUSY_STATE;\n        putShortMSB(s, header);\n\n\t/* Save the adler32 of the preset dictionary: */\n\tif (s->strstart != 0) {\n\t    putShortMSB(s, (uInt)(strm->adler >> 16));\n\t    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n\t}\n\tstrm->adler = 1L;\n    }\n\n    /* Flush as much pending output as possible */\n    if (s->pending != 0) {\n        flush_pending(strm);\n        if (strm->avail_out == 0) {\n\t    /* Since avail_out is 0, deflate will be called again with\n\t     * more output space, but possibly with both pending and\n\t     * avail_in equal to zero. There won't be anything to do,\n\t     * but this is not an error situation so make sure we\n\t     * return OK instead of BUF_ERROR at next call of deflate:\n             */\n\t    s->last_flush = -1;\n\t    return Z_OK;\n\t}\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUFF_ERROR.\n     */\n    } else if (strm->avail_in == 0 && flush <= old_flush &&\n\t       flush != Z_FINISH) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* User must not provide more input after the first FINISH: */\n    if (s->status == FINISH_STATE && strm->avail_in != 0) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm->avail_in != 0 || s->lookahead != 0 ||\n        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\n        block_state bstate;\n\n\tbstate = (*(configuration_table\u00dds->level\u00a8.func))(s, flush);\n\n        if (bstate == finish_started || bstate == finish_done) {\n            s->status = FINISH_STATE;\n        }\n        if (bstate == need_more || bstate == finish_started) {\n\t    if (strm->avail_out == 0) {\n\t        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n\t    }\n\t    return Z_OK;\n\t    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n\t     * of deflate should use the same flush parameter to make sure\n\t     * that the flush is complete. So we don't have to output an\n\t     * empty block here, this will be done at next call. This also\n\t     * ensures that for a very small output buffer, we emit at most\n\t     * one empty block.\n\t     */\n\t}\n        if (bstate == block_done) {\n            if (flush == Z_PARTIAL_FLUSH) {\n                _tr_align(s);\n            } else { /* FULL_FLUSH or SYNC_FLUSH */\n                _tr_stored_block(s, (char*)0, 0L, 0);\n                /* For a full flush, this empty block will be recognized\n                 * as a special marker by inflate_sync().\n                 */\n                if (flush == Z_FULL_FLUSH) {\n                    CLEAR_HASH(s);             /* forget history */\n                }\n            }\n            flush_pending(strm);\n\t    if (strm->avail_out == 0) {\n\t      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n\t      return Z_OK;\n\t    }\n        }\n    }\n    Assert(strm->avail_out > 0, \"bug2\");\n\n    if (flush != Z_FINISH) return Z_OK;\n    if (s->noheader) return Z_STREAM_END;\n\n    /* Write the zlib trailer (adler32) */\n    putShortMSB(s, (uInt)(strm->adler >> 16));\n    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    s->noheader = -1; /* write the trailer only once! */\n    return s->pending != 0 ? Z_OK : Z_STREAM_END;\n}\n\n/* ========================================================================= */\nint ZEXPORT deflateEnd (strm)\n    z_streamp strm;\n{\n    int status;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n\n    status = strm->state->status;\n    if (status != INIT_STATE && status != BUSY_STATE &&\n\tstatus != FINISH_STATE) {\n      return Z_STREAM_ERROR;\n    }\n\n    /* Deallocate in reverse order of allocations: */\n    TRY_FREE(strm, strm->state->pending_buf);\n    TRY_FREE(strm, strm->state->head);\n    TRY_FREE(strm, strm->state->prev);\n    TRY_FREE(strm, strm->state->window);\n\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n\n    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n}\n\n/* =========================================================================\n * Copy the source state to the destination state.\n * To simplify the source, this is not supported for 16-bit MSDOS (which\n * doesn't have enough memory anyway to duplicate compression states).\n */\nint ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n\n\n    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source->state;\n\n    *dest = *source;\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    *ds = *ss;\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    /* following zmemcpy do not work for 16-bit MSDOS */\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif\n}\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->next_in buffer and copying from it.\n * (See also flush_pending()).\n */\nlocal int read_buf(strm, buf, size)\n    z_streamp strm;\n    Bytef *buf;\n    unsigned size;\n{\n    unsigned len = strm->avail_in;\n\n    if (len > size) len = size;\n    if (len == 0) return 0;\n\n    strm->avail_in  -= len;\n\n    if (!strm->state->noheader) {\n        strm->adler = adler32(strm->adler, strm->next_in, len);\n    }\n    zmemcpy(buf, strm->next_in, len);\n    strm->next_in  += len;\n    strm->total_in += len;\n\n    return (int)len;\n}\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nlocal void lm_init (s)\n    deflate_state *s;\n{\n    s->window_size = (ulg)2L*s->w_size;\n\n    CLEAR_HASH(s);\n\n    /* Set the default configuration parameters:\n     */\n    s->max_lazy_match   = configuration_table\u00dds->level\u00a8.max_lazy;\n    s->good_match       = configuration_table\u00dds->level\u00a8.good_length;\n    s->nice_match       = configuration_table\u00dds->level\u00a8.nice_length;\n    s->max_chain_length = configuration_table\u00dds->level\u00a8.max_chain;\n\n    s->strstart = 0;\n    s->block_start = 0L;\n    s->lookahead = 0;\n    s->match_length = s->prev_length = MIN_MATCH-1;\n    s->match_available = 0;\n    s->ins_h = 0;\n#ifdef ASMV\n    match_init(); /* initialize the asm code */\n#endif\n}\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\n#ifndef ASMV\n/* For 80x86 and 680x0, an optimized version will be provided in match.asm or\n * match.S. The code will be functionally equivalent.\n */\n#ifndef FASTEST\nlocal uInt longest_match(s, cur_match)\n    deflate_state *s;\n    IPos cur_match;                             /* current match */\n{\n    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                       /* matched string */\n    register int len;                           /* length of current match */\n    int best_len = s->prev_length;              /* best match length so far */\n    int nice_match = s->nice_match;             /* stop if match long enough */\n    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n        s->strstart - (IPos)MAX_DIST(s) : NIL;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n    Posf *prev = s->prev;\n    uInt wmask = s->w_mask;\n\n#ifdef UNALIGNED_OK\n    /* Compare two bytes at a time. Note: this is not always beneficial.\n     * Try with and without -DUNALIGNED_OK to check.\n     */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n    register ush scan_start = *(ushf*)scan;\n    register ush scan_end   = *(ushf*)(scan+best_len-1);\n#else\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n    register Byte scan_end1  = scan\u00ddbest_len-1\u00a8;\n    register Byte scan_end   = scan\u00ddbest_len\u00a8;\n#endif\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    /* Do not waste too much time if we already have a good match: */\n    if (s->prev_length >= s->good_match) {\n        chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     */\n    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n\n    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    do {\n        Assert(cur_match < s->strstart, \"no future\");\n        match = s->window + cur_match;\n\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2:\n         */\n#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n        /* This code assumes sizeof(unsigned short) == 2. Do not use\n         * UNALIGNED_OK if your compiler uses a different size.\n         */\n        if (*(ushf*)(match+best_len-1) != scan_end ||\n            *(ushf*)match != scan_start) continue;\n\n        /* It is not necessary to compare scan\u00dd2\u00a8 and match\u00dd2\u00a8 since they are\n         * always equal when the other bytes match, given that the hash keys\n         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n         * lookahead only every 4th comparison; the 128th check will be made\n         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n         * necessary to put more guard bytes at the end of the window, or\n         * to check more often for insufficient lookahead.\n         */\n        Assert(scan\u00dd2\u00a8 == match\u00dd2\u00a8, \"scan\u00dd2\u00a8?\");\n        scan++, match++;\n        do {\n        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n                 scan < strend);\n        /* The funny \"do {}\" generates better code on most compilers */\n\n        /* Here, scan <= window+strstart+257 */\n        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        if (*scan == *match) scan++;\n\n        len = (MAX_MATCH - 1) - (int)(strend-scan);\n        scan = strend - (MAX_MATCH-1);\n\n#else /* UNALIGNED_OK */\n\n        if (match\u00ddbest_len\u00a8   != scan_end  ||\n            match\u00ddbest_len-1\u00a8 != scan_end1 ||\n            *match            != *scan     ||\n            *++match          != scan\u00dd1\u00a8)      continue;\n\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan\u00dd2\u00a8 and match\u00dd2\u00a8 since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n        scan += 2, match++;\n        Assert(*scan == *match, \"match\u00dd2\u00a8?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n        do {\n        } while (*++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 scan < strend);\n\n        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n        len = MAX_MATCH - (int)(strend - scan);\n        scan = strend - MAX_MATCH;\n\n#endif /* UNALIGNED_OK */\n\n        if (len > best_len) {\n            s->match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) break;\n#ifdef UNALIGNED_OK\n            scan_end = *(ushf*)(scan+best_len-1);\n#else\n            scan_end1  = scan\u00ddbest_len-1\u00a8;\n            scan_end   = scan\u00ddbest_len\u00a8;\n#endif\n        }\n    } while ((cur_match = prev\u00ddcur_match & wmask\u00a8) > limit\n             && --chain_length != 0);\n\n    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n    return s->lookahead;\n}\n\n#else /* FASTEST */\n/* ---------------------------------------------------------------------------\n * Optimized version for level == 1 only\n */\nlocal uInt longest_match(s, cur_match)\n    deflate_state *s;\n    IPos cur_match;                             /* current match */\n{\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                       /* matched string */\n    register int len;                           /* length of current match */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    Assert(cur_match < s->strstart, \"no future\");\n\n    match = s->window + cur_match;\n\n    /* Return failure if the match length is less than 2:\n     */\n    if (match\u00dd0\u00a8 != scan\u00dd0\u00a8 || match\u00dd1\u00a8 != scan\u00dd1\u00a8) return MIN_MATCH-1;\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan\u00dd2\u00a8 and match\u00dd2\u00a8 since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2, match += 2;\n    Assert(*scan == *match, \"match\u00dd2\u00a8?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n    } while (*++scan == *++match && *++scan == *++match &&\n\t     *++scan == *++match && *++scan == *++match &&\n\t     *++scan == *++match && *++scan == *++match &&\n\t     *++scan == *++match && *++scan == *++match &&\n\t     scan < strend);\n\n    Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (int)(strend - scan);\n\n    if (len < MIN_MATCH) return MIN_MATCH - 1;\n\n    s->match_start = cur_match;\n    return len <= s->lookahead ? len : s->lookahead;\n}\n#endif /* FASTEST */\n#endif /* ASMV */\n\n#ifdef DEBUG\n/* ===========================================================================\n * Check that the match at match_start is indeed a match.\n */\nlocal void check_match(s, start, match, length)\n    deflate_state *s;\n    IPos start, match;\n    int length;\n{\n    /* check that the match is indeed a match */\n    if (zmemcmp(s->window + match,\n                s->window + start, length) != EQUAL) {\n        fprintf(stderr, \" start %u, match %u, length %d\\n\",\n\t\tstart, match, length);\n        do {\n\t    fprintf(stderr, \"%c%c\", s->window\u00ddmatch++\u00a8, s->window\u00ddstart++\u00a8);\n\t} while (--length != 0);\n        z_error(\"invalid match\");\n    }\n    if (z_verbose > 1) {\n        fprintf(stderr,\"\\\\\u00dd%d,%d\u00a8\", start-match, length);\n        do { putc(s->window\u00ddstart++\u00a8, stderr); } while (--length != 0);\n    }\n}\n#else\n#  define check_match(s, start, match, length)\n#endif\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nlocal void fill_window(s)\n    deflate_state *s;\n{\n    register unsigned n, m;\n    register Posf *p;\n    unsigned more;    /* Amount of free space at the end of the window. */\n    uInt wsize = s->w_size;\n\n    do {\n        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n\n        /* Deal with !@#$% 64K limit: */\n        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n            more = wsize;\n\n        } else if (more == (unsigned)(-1)) {\n            /* Very unlikely, but possible on 16 bit machine if strstart == 0\n             * and lookahead == 1 (input done one byte at time)\n             */\n            more--;\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        } else if (s->strstart >= wsize+MAX_DIST(s)) {\n\n            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);\n            s->match_start -= wsize;\n            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */\n            s->block_start -= (long) wsize;\n\n            /* Slide the hash table (could be avoided with 32 bit values\n               at the expense of memory usage). We slide even when level == 0\n               to keep the hash table consistent if we switch back to level > 0\n               later. (Using level 0 permanently is not an optimal usage of\n               zlib, so we don't care about this pathological case.)\n             */\n\t    n = s->hash_size;\n\t    p = &s->head\u00ddn\u00a8;\n\t    do {\n\t\tm = *--p;\n\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n\t    } while (--n);\n\n\t    n = wsize;\n#ifndef FASTEST\n\t    p = &s->prev\u00ddn\u00a8;\n\t    do {\n\t\tm = *--p;\n\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n\t\t/* If n is not on any hash chain, prev\u00ddn\u00a8 is garbage but\n\t\t * its value will never be used.\n\t\t */\n\t    } while (--n);\n#endif\n            more += wsize;\n        }\n        if (s->strm->avail_in == 0) return;\n\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        Assert(more >= 2, \"more < 2\");\n\n        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n        s->lookahead += n;\n\n        /* Initialize the hash value now that we have some input: */\n        if (s->lookahead >= MIN_MATCH) {\n            s->ins_h = s->window\u00dds->strstart\u00a8;\n            UPDATE_HASH(s, s->ins_h, s->window\u00dds->strstart+1\u00a8);\n#if MIN_MATCH != 3\n            Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n}\n\n/* ===========================================================================\n * Flush the current block, with given end-of-file flag.\n * IN assertion: strstart is set to the end of the current match.\n */\n#define FLUSH_BLOCK_ONLY(s, eof) { \\\n   _tr_flush_block(s, (s->block_start >= 0L ? \\\n                   (charf *)&s->window\u00dd(unsigned)s->block_start\u00a8 : \\\n                   (charf *)Z_NULL), \\\n\t\t(ulg)((long)s->strstart - s->block_start), \\\n\t\t(eof)); \\\n   s->block_start = s->strstart; \\\n   flush_pending(s->strm); \\\n   Tracev((stderr,\"\u00ddFLUSH\u00a8\")); \\\n}\n\n/* Same but force premature exit if necessary. */\n#define FLUSH_BLOCK(s, eof) { \\\n   FLUSH_BLOCK_ONLY(s, eof); \\\n   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \\\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nlocal block_state deflate_stored(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n     * to pending_buf_size, and each stored block has a 5 byte header:\n     */\n    ulg max_block_size = 0xffff;\n    ulg max_start;\n\n    if (max_block_size > s->pending_buf_size - 5) {\n        max_block_size = s->pending_buf_size - 5;\n    }\n\n    /* Copy as much as possible from input to output: */\n    for (;;) {\n        /* Fill the window as much as possible: */\n        if (s->lookahead <= 1) {\n\n            Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n\t\t   s->block_start >= (long)s->w_size, \"slide too late\");\n\n            fill_window(s);\n            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;\n\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\tAssert(s->block_start >= 0L, \"block gone\");\n\n\ts->strstart += s->lookahead;\n\ts->lookahead = 0;\n\n\t/* Emit a stored block if pending_buf will be full: */\n \tmax_start = s->block_start + max_block_size;\n        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {\n\t    /* strstart == 0 is possible when wraparound on 16-bit machine */\n\t    s->lookahead = (uInt)(s->strstart - max_start);\n\t    s->strstart = (uInt)max_start;\n            FLUSH_BLOCK(s, 0);\n\t}\n\t/* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {\n            FLUSH_BLOCK(s, 0);\n\t}\n    }\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nlocal block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head = NIL; /* head of the hash chain */\n    int bflush;           /* set if current block must be flushed */\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t        return need_more;\n\t    }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window\u00ddstrstart .. strstart+2\u00a8 in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            if (s->strategy != Z_HUFFMAN_ONLY) {\n                s->match_length = longest_match (s, hash_head);\n            }\n            /* longest_match() sets match_start */\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n\n            s->lookahead -= s->match_length;\n\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; /* string at strstart already in hash table */\n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     * always MIN_MATCH bytes ahead.\n                     */\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n\t    {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window\u00dds->strstart\u00a8;\n                UPDATE_HASH(s, s->ins_h, s->window\u00dds->strstart+1\u00a8);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n                 * matter since it will be recomputed at next deflate call.\n                 */\n            }\n        } else {\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\", s->window\u00dds->strstart\u00a8));\n            _tr_tally_lit (s, s->window\u00dds->strstart\u00a8, bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nlocal block_state deflate_slow(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head = NIL;    /* head of hash chain */\n    int bflush;              /* set if current block must be flushed */\n\n    /* Process the input block. */\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t        return need_more;\n\t    }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window\u00ddstrstart .. strstart+2\u00a8 in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        s->prev_length = s->match_length, s->prev_match = s->match_start;\n        s->match_length = MIN_MATCH-1;\n\n        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&\n            s->strstart - hash_head <= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            if (s->strategy != Z_HUFFMAN_ONLY) {\n                s->match_length = longest_match (s, hash_head);\n            }\n            /* longest_match() sets match_start */\n\n            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||\n                 (s->match_length == MIN_MATCH &&\n                  s->strstart - s->match_start > TOO_FAR))) {\n\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                s->match_length = MIN_MATCH-1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {\n            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n\n            check_match(s, s->strstart-1, s->prev_match, s->prev_length);\n\n            _tr_tally_dist(s, s->strstart -1 - s->prev_match,\n\t\t\t   s->prev_length - MIN_MATCH, bflush);\n\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             */\n            s->lookahead -= s->prev_length-1;\n            s->prev_length -= 2;\n            do {\n                if (++s->strstart <= max_insert) {\n                    INSERT_STRING(s, s->strstart, hash_head);\n                }\n            } while (--s->prev_length != 0);\n            s->match_available = 0;\n            s->match_length = MIN_MATCH-1;\n            s->strstart++;\n\n            if (bflush) FLUSH_BLOCK(s, 0);\n\n        } else if (s->match_available) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            Tracevv((stderr,\"%c\", s->window\u00dds->strstart-1\u00a8));\n\t    _tr_tally_lit(s, s->window\u00dds->strstart-1\u00a8, bflush);\n\t    if (bflush) {\n                FLUSH_BLOCK_ONLY(s, 0);\n            }\n            s->strstart++;\n            s->lookahead--;\n            if (s->strm->avail_out == 0) return need_more;\n        } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            s->match_available = 1;\n            s->strstart++;\n            s->lookahead--;\n        }\n    }\n    Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s->match_available) {\n        Tracevv((stderr,\"%c\", s->window\u00dds->strstart-1\u00a8));\n        _tr_tally_lit(s, s->window\u00dds->strstart-1\u00a8, bflush);\n        s->match_available = 0;\n    }\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXAMPLE": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* example.c -- usage example of the zlib compression library\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include <stdio.h>\n#include \"zlib.h\"\n\n#ifdef STDC\n#  include <string.h>\n#  include <stdlib.h>\n#else\n   extern void exit  OF((int));\n#endif\n\n#if defined(VMS) || defined(RISCOS)\n#  define TESTFILE \"foo-gz\"\n#else\n#  define TESTFILE \"foo.gz\"\n#endif\n\n#define CHECK_ERR(err, msg) { \\\n    if (err != Z_OK) { \\\n        fprintf(stderr, \"%s error: %d\\n\", msg, err); \\\n        exit(1); \\\n    } \\\n}\n\nconst char hello\u00dd\u00a8 = \"hello, hello!\";\n/* \"hello world\" would be more standard, but the repeated \"hello\"\n * stresses the compression code better, sorry...\n */\n\nconst char dictionary\u00dd\u00a8 = \"hello\";\nuLong dictId; /* Adler32 value of the dictionary */\n\nvoid test_compress      OF((Byte *compr, uLong comprLen,\n\t\t            Byte *uncompr, uLong uncomprLen));\nvoid test_gzio          OF((const char *out, const char *in,\n\t\t            Byte *uncompr, int uncomprLen));\nvoid test_deflate       OF((Byte *compr, uLong comprLen));\nvoid test_inflate       OF((Byte *compr, uLong comprLen,\n\t\t            Byte *uncompr, uLong uncomprLen));\nvoid test_large_deflate OF((Byte *compr, uLong comprLen,\n\t\t            Byte *uncompr, uLong uncomprLen));\nvoid test_large_inflate OF((Byte *compr, uLong comprLen,\n\t\t            Byte *uncompr, uLong uncomprLen));\nvoid test_flush         OF((Byte *compr, uLong *comprLen));\nvoid test_sync          OF((Byte *compr, uLong comprLen,\n\t\t            Byte *uncompr, uLong uncomprLen));\nvoid test_dict_deflate  OF((Byte *compr, uLong comprLen));\nvoid test_dict_inflate  OF((Byte *compr, uLong comprLen,\n\t\t            Byte *uncompr, uLong uncomprLen));\nint  main               OF((int argc, char *argv\u00dd\u00a8));\n\n/* ===========================================================================\n * Test compress() and uncompress()\n */\nvoid test_compress(compr, comprLen, uncompr, uncomprLen)\n    Byte *compr, *uncompr;\n    uLong comprLen, uncomprLen;\n{\n    int err;\n    uLong len = strlen(hello)+1;\n\n    err = compress(compr, &comprLen, (const Bytef*)hello, len);\n    CHECK_ERR(err, \"compress\");\n\n    strcpy((char*)uncompr, \"garbage\");\n\n    err = uncompress(uncompr, &uncomprLen, compr, comprLen);\n    CHECK_ERR(err, \"uncompress\");\n\n    if (strcmp((char*)uncompr, hello)) {\n        fprintf(stderr, \"bad uncompress\\n\");\n\texit(1);\n    } else {\n        printf(\"uncompress(): %s\\n\", (char *)uncompr);\n    }\n}\n\n/* ===========================================================================\n * Test read/write of .gz files\n */\nvoid test_gzio(out, in, uncompr, uncomprLen)\n    const char *out; /* compressed output file */\n    const char *in;  /* compressed input file */\n    Byte *uncompr;\n    int  uncomprLen;\n{\n    int err;\n    int len = strlen(hello)+1;\n    gzFile file;\n    z_off_t pos;\n\n    file = gzopen(out, \"wb\");\n    if (file == NULL) {\n        fprintf(stderr, \"gzopen error\\n\");\n        exit(1);\n    }\n    gzputc(file, 'h');\n    if (gzputs(file, \"ello\") != 4) {\n        fprintf(stderr, \"gzputs err: %s\\n\", gzerror(file, &err));\n\texit(1);\n    }\n    if (gzprintf(file, \", %s!\", \"hello\") != 8) {\n        fprintf(stderr, \"gzprintf err: %s\\n\", gzerror(file, &err));\n\texit(1);\n    }\n    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */\n    gzclose(file);\n\n    file = gzopen(in, \"rb\");\n    if (file == NULL) {\n        fprintf(stderr, \"gzopen error\\n\");\n    }\n    strcpy((char*)uncompr, \"garbage\");\n\n    uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);\n    if (uncomprLen != len) {\n        fprintf(stderr, \"gzread err: %s\\n\", gzerror(file, &err));\n\texit(1);\n    }\n    if (strcmp((char*)uncompr, hello)) {\n        fprintf(stderr, \"bad gzread: %s\\n\", (char*)uncompr);\n\texit(1);\n    } else {\n        printf(\"gzread(): %s\\n\", (char *)uncompr);\n    }\n\n    pos = gzseek(file, -8L, SEEK_CUR);\n    if (pos != 6 || gztell(file) != pos) {\n\tfprintf(stderr, \"gzseek error, pos=%ld, gztell=%ld\\n\",\n\t\t(long)pos, (long)gztell(file));\n\texit(1);\n    }\n\n    if (gzgetc(file) != ' ') {\n\tfprintf(stderr, \"gzgetc error\\n\");\n\texit(1);\n    }\n\n    gzgets(file, (char*)uncompr, uncomprLen);\n    uncomprLen = strlen((char*)uncompr);\n    if (uncomprLen != 6) { /* \"hello!\" */\n        fprintf(stderr, \"gzgets err after gzseek: %s\\n\", gzerror(file, &err));\n\texit(1);\n    }\n    if (strcmp((char*)uncompr, hello+7)) {\n        fprintf(stderr, \"bad gzgets after gzseek\\n\");\n\texit(1);\n    } else {\n        printf(\"gzgets() after gzseek: %s\\n\", (char *)uncompr);\n    }\n\n    gzclose(file);\n}\n\n/* ===========================================================================\n * Test deflate() with small buffers\n */\nvoid test_deflate(compr, comprLen)\n    Byte *compr;\n    uLong comprLen;\n{\n    z_stream c_stream; /* compression stream */\n    int err;\n    int len = strlen(hello)+1;\n\n    c_stream.zalloc = (alloc_func)0;\n    c_stream.zfree = (free_func)0;\n    c_stream.opaque = (voidpf)0;\n\n    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_in  = (Bytef*)hello;\n    c_stream.next_out = compr;\n\n    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {\n        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */\n        err = deflate(&c_stream, Z_NO_FLUSH);\n        CHECK_ERR(err, \"deflate\");\n    }\n    /* Finish the stream, still forcing small buffers: */\n    for (;;) {\n        c_stream.avail_out = 1;\n        err = deflate(&c_stream, Z_FINISH);\n        if (err == Z_STREAM_END) break;\n        CHECK_ERR(err, \"deflate\");\n    }\n\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}\n\n/* ===========================================================================\n * Test inflate() with small buffers\n */\nvoid test_inflate(compr, comprLen, uncompr, uncomprLen)\n    Byte *compr, *uncompr;\n    uLong comprLen, uncomprLen;\n{\n    int err;\n    z_stream d_stream; /* decompression stream */\n\n    strcpy((char*)uncompr, \"garbage\");\n\n    d_stream.zalloc = (alloc_func)0;\n    d_stream.zfree = (free_func)0;\n    d_stream.opaque = (voidpf)0;\n\n    d_stream.next_in  = compr;\n    d_stream.avail_in = 0;\n    d_stream.next_out = uncompr;\n\n    err = inflateInit(&d_stream);\n    CHECK_ERR(err, \"inflateInit\");\n\n    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {\n        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */\n        err = inflate(&d_stream, Z_NO_FLUSH);\n        if (err == Z_STREAM_END) break;\n        CHECK_ERR(err, \"inflate\");\n    }\n\n    err = inflateEnd(&d_stream);\n    CHECK_ERR(err, \"inflateEnd\");\n\n    if (strcmp((char*)uncompr, hello)) {\n        fprintf(stderr, \"bad inflate\\n\");\n\texit(1);\n    } else {\n        printf(\"inflate(): %s\\n\", (char *)uncompr);\n    }\n}\n\n/* ===========================================================================\n * Test deflate() with large buffers and dynamic change of compression level\n */\nvoid test_large_deflate(compr, comprLen, uncompr, uncomprLen)\n    Byte *compr, *uncompr;\n    uLong comprLen, uncomprLen;\n{\n    z_stream c_stream; /* compression stream */\n    int err;\n\n    c_stream.zalloc = (alloc_func)0;\n    c_stream.zfree = (free_func)0;\n    c_stream.opaque = (voidpf)0;\n\n    err = deflateInit(&c_stream, Z_BEST_SPEED);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_out = compr;\n    c_stream.avail_out = (uInt)comprLen;\n\n    /* At this point, uncompr is still mostly zeroes, so it should compress\n     * very well:\n     */\n    c_stream.next_in = uncompr;\n    c_stream.avail_in = (uInt)uncomprLen;\n    err = deflate(&c_stream, Z_NO_FLUSH);\n    CHECK_ERR(err, \"deflate\");\n    if (c_stream.avail_in != 0) {\n        fprintf(stderr, \"deflate not greedy\\n\");\n\texit(1);\n    }\n\n    /* Feed in already compressed data and switch to no compression: */\n    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);\n    c_stream.next_in = compr;\n    c_stream.avail_in = (uInt)comprLen/2;\n    err = deflate(&c_stream, Z_NO_FLUSH);\n    CHECK_ERR(err, \"deflate\");\n\n    /* Switch back to compressing mode: */\n    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);\n    c_stream.next_in = uncompr;\n    c_stream.avail_in = (uInt)uncomprLen;\n    err = deflate(&c_stream, Z_NO_FLUSH);\n    CHECK_ERR(err, \"deflate\");\n\n    err = deflate(&c_stream, Z_FINISH);\n    if (err != Z_STREAM_END) {\n        fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n\texit(1);\n    }\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}\n\n/* ===========================================================================\n * Test inflate() with large buffers\n */\nvoid test_large_inflate(compr, comprLen, uncompr, uncomprLen)\n    Byte *compr, *uncompr;\n    uLong comprLen, uncomprLen;\n{\n    int err;\n    z_stream d_stream; /* decompression stream */\n\n    strcpy((char*)uncompr, \"garbage\");\n\n    d_stream.zalloc = (alloc_func)0;\n    d_stream.zfree = (free_func)0;\n    d_stream.opaque = (voidpf)0;\n\n    d_stream.next_in  = compr;\n    d_stream.avail_in = (uInt)comprLen;\n\n    err = inflateInit(&d_stream);\n    CHECK_ERR(err, \"inflateInit\");\n\n    for (;;) {\n        d_stream.next_out = uncompr;            /* discard the output */\n\td_stream.avail_out = (uInt)uncomprLen;\n        err = inflate(&d_stream, Z_NO_FLUSH);\n        if (err == Z_STREAM_END) break;\n        CHECK_ERR(err, \"large inflate\");\n    }\n\n    err = inflateEnd(&d_stream);\n    CHECK_ERR(err, \"inflateEnd\");\n\n    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {\n        fprintf(stderr, \"bad large inflate: %ld\\n\", d_stream.total_out);\n\texit(1);\n    } else {\n        printf(\"large_inflate(): OK\\n\");\n    }\n}\n\n/* ===========================================================================\n * Test deflate() with full flush\n */\nvoid test_flush(compr, comprLen)\n    Byte *compr;\n    uLong *comprLen;\n{\n    z_stream c_stream; /* compression stream */\n    int err;\n    int len = strlen(hello)+1;\n\n    c_stream.zalloc = (alloc_func)0;\n    c_stream.zfree = (free_func)0;\n    c_stream.opaque = (voidpf)0;\n\n    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_in  = (Bytef*)hello;\n    c_stream.next_out = compr;\n    c_stream.avail_in = 3;\n    c_stream.avail_out = (uInt)*comprLen;\n    err = deflate(&c_stream, Z_FULL_FLUSH);\n    CHECK_ERR(err, \"deflate\");\n\n    compr\u00dd3\u00a8++; /* force an error in first compressed block */\n    c_stream.avail_in = len - 3;\n\n    err = deflate(&c_stream, Z_FINISH);\n    if (err != Z_STREAM_END) {\n        CHECK_ERR(err, \"deflate\");\n    }\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n\n    *comprLen = c_stream.total_out;\n}\n\n/* ===========================================================================\n * Test inflateSync()\n */\nvoid test_sync(compr, comprLen, uncompr, uncomprLen)\n    Byte *compr, *uncompr;\n    uLong comprLen, uncomprLen;\n{\n    int err;\n    z_stream d_stream; /* decompression stream */\n\n    strcpy((char*)uncompr, \"garbage\");\n\n    d_stream.zalloc = (alloc_func)0;\n    d_stream.zfree = (free_func)0;\n    d_stream.opaque = (voidpf)0;\n\n    d_stream.next_in  = compr;\n    d_stream.avail_in = 2; /* just read the zlib header */\n\n    err = inflateInit(&d_stream);\n    CHECK_ERR(err, \"inflateInit\");\n\n    d_stream.next_out = uncompr;\n    d_stream.avail_out = (uInt)uncomprLen;\n\n    inflate(&d_stream, Z_NO_FLUSH);\n    CHECK_ERR(err, \"inflate\");\n\n    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */\n    err = inflateSync(&d_stream);           /* but skip the damaged part */\n    CHECK_ERR(err, \"inflateSync\");\n\n    err = inflate(&d_stream, Z_FINISH);\n    if (err != Z_DATA_ERROR) {\n        fprintf(stderr, \"inflate should report DATA_ERROR\\n\");\n        /* Because of incorrect adler32 */\n\texit(1);\n    }\n    err = inflateEnd(&d_stream);\n    CHECK_ERR(err, \"inflateEnd\");\n\n    printf(\"after inflateSync(): hel%s\\n\", (char *)uncompr);\n}\n\n/* ===========================================================================\n * Test deflate() with preset dictionary\n */\nvoid test_dict_deflate(compr, comprLen)\n    Byte *compr;\n    uLong comprLen;\n{\n    z_stream c_stream; /* compression stream */\n    int err;\n\n    c_stream.zalloc = (alloc_func)0;\n    c_stream.zfree = (free_func)0;\n    c_stream.opaque = (voidpf)0;\n\n    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    err = deflateSetDictionary(&c_stream,\n\t\t\t       (const Bytef*)dictionary, sizeof(dictionary));\n    CHECK_ERR(err, \"deflateSetDictionary\");\n\n    dictId = c_stream.adler;\n    c_stream.next_out = compr;\n    c_stream.avail_out = (uInt)comprLen;\n\n    c_stream.next_in = (Bytef*)hello;\n    c_stream.avail_in = (uInt)strlen(hello)+1;\n\n    err = deflate(&c_stream, Z_FINISH);\n    if (err != Z_STREAM_END) {\n        fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n\texit(1);\n    }\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}\n\n/* ===========================================================================\n * Test inflate() with a preset dictionary\n */\nvoid test_dict_inflate(compr, comprLen, uncompr, uncomprLen)\n    Byte *compr, *uncompr;\n    uLong comprLen, uncomprLen;\n{\n    int err;\n    z_stream d_stream; /* decompression stream */\n\n    strcpy((char*)uncompr, \"garbage\");\n\n    d_stream.zalloc = (alloc_func)0;\n    d_stream.zfree = (free_func)0;\n    d_stream.opaque = (voidpf)0;\n\n    d_stream.next_in  = compr;\n    d_stream.avail_in = (uInt)comprLen;\n\n    err = inflateInit(&d_stream);\n    CHECK_ERR(err, \"inflateInit\");\n\n    d_stream.next_out = uncompr;\n    d_stream.avail_out = (uInt)uncomprLen;\n\n    for (;;) {\n        err = inflate(&d_stream, Z_NO_FLUSH);\n        if (err == Z_STREAM_END) break;\n\tif (err == Z_NEED_DICT) {\n\t    if (d_stream.adler != dictId) {\n\t\tfprintf(stderr, \"unexpected dictionary\");\n\t\texit(1);\n\t    }\n\t    err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,\n\t\t\t\t       sizeof(dictionary));\n\t}\n        CHECK_ERR(err, \"inflate with dict\");\n    }\n\n    err = inflateEnd(&d_stream);\n    CHECK_ERR(err, \"inflateEnd\");\n\n    if (strcmp((char*)uncompr, hello)) {\n        fprintf(stderr, \"bad inflate with dict\\n\");\n\texit(1);\n    } else {\n        printf(\"inflate with dictionary: %s\\n\", (char *)uncompr);\n    }\n}\n\n/* ===========================================================================\n * Usage:  example \u00ddoutput.gz  \u00ddinput.gz\u00a8\u00a8\n */\n\nint main(argc, argv)\n    int argc;\n    char *argv\u00dd\u00a8;\n{\n    Byte *compr, *uncompr;\n    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */\n    uLong uncomprLen = comprLen;\n    static const char* myVersion = ZLIB_VERSION;\n\n    if (zlibVersion()\u00dd0\u00a8 != myVersion\u00dd0\u00a8) {\n        fprintf(stderr, \"incompatible zlib version\\n\");\n        exit(1);\n\n    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {\n        fprintf(stderr, \"warning: different zlib version\\n\");\n    }\n\n    compr    = (Byte*)calloc((uInt)comprLen, 1);\n    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);\n    /* compr and uncompr are cleared to avoid reading uninitialized\n     * data and to ensure that uncompr compresses well.\n     */\n    if (compr == Z_NULL || uncompr == Z_NULL) {\n        printf(\"out of memory\\n\");\n\texit(1);\n    }\n    test_compress(compr, comprLen, uncompr, uncomprLen);\n\n    test_gzio((argc > 1 ? argv\u00dd1\u00a8 : TESTFILE),\n              (argc > 2 ? argv\u00dd2\u00a8 : TESTFILE),\n\t      uncompr, (int)uncomprLen);\n\n    test_deflate(compr, comprLen);\n    test_inflate(compr, comprLen, uncompr, uncomprLen);\n\n    test_large_deflate(compr, comprLen, uncompr, uncomprLen);\n    test_large_inflate(compr, comprLen, uncompr, uncomprLen);\n\n    test_flush(compr, &comprLen);\n    test_sync(compr, comprLen, uncompr, uncomprLen);\n    comprLen = uncomprLen;\n\n    test_dict_deflate(compr, comprLen);\n    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);\n\n    exit(0);\n    return 0; /* to avoid warning */\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GZIO": {"ttr": 513, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* gzio.c -- IO on .gz files\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n *\n * Compile this file with -DNO_DEFLATE to avoid the compression code.\n */\n\n/* @(#) $Id$ */\n\n#include <stdio.h>\n\n#include \"zutil.h\"\n\nstruct internal_state {int dummy;}; /* for buggy compilers */\n\n#ifndef Z_BUFSIZE\n#  ifdef MAXSEG_64K\n#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */\n#  else\n#    define Z_BUFSIZE 16384\n#  endif\n#endif\n#ifndef Z_PRINTF_BUFSIZE\n#  define Z_PRINTF_BUFSIZE 4096\n#endif\n\n#define ALLOC(size) malloc(size)\n#define TRYFREE(p) {if (p) free(p);}\n\nstatic int gz_magic\u00dd2\u00a8 = {0x1f, 0x8b}; /* gzip magic header */\n\n/* gzip flag byte */\n#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */\n#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */\n#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */\n#define ORIG_NAME    0x08 /* bit 3 set: original file name present */\n#define COMMENT      0x10 /* bit 4 set: file comment present */\n#define RESERVED     0xE0 /* bits 5..7: reserved */\n\ntypedef struct gz_stream {\n    z_stream stream;\n    int      z_err;   /* error code for last stream operation */\n    int      z_eof;   /* set if end of input file */\n    FILE     *file;   /* .gz file */\n    Byte     *inbuf;  /* input buffer */\n    Byte     *outbuf; /* output buffer */\n    uLong    crc;     /* crc32 of uncompressed data */\n    char     *msg;    /* error message */\n    char     *path;   /* path name for debugging only */\n    int      transparent; /* 1 if input file is not a .gz file */\n    char     mode;    /* 'w' or 'r' */\n    long     startpos; /* start of compressed data in file (header skipped) */\n} gz_stream;\n\n\nlocal gzFile gz_open      OF((const char *path, const char *mode, int  fd));\nlocal int do_flush        OF((gzFile file, int flush));\nlocal int    get_byte     OF((gz_stream *s));\nlocal void   check_header OF((gz_stream *s));\nlocal int    destroy      OF((gz_stream *s));\nlocal void   putLong      OF((FILE *file, uLong x));\nlocal uLong  getLong      OF((gz_stream *s));\n\n/* ===========================================================================\n     Opens a gzip (.gz) file for reading or writing. The mode parameter\n   is as in fopen (\"rb\" or \"wb\"). The file is given either by file descriptor\n   or path name (if fd == -1).\n     gz_open return NULL if the file could not be opened or if there was\n   insufficient memory to allocate the (de)compression state; errno\n   can be checked to distinguish the two cases (if errno is zero, the\n   zlib error is Z_MEM_ERROR).\n*/\nlocal gzFile gz_open (path, mode, fd)\n    const char *path;\n    const char *mode;\n    int  fd;\n{\n    int err;\n    int level = Z_DEFAULT_COMPRESSION; /* compression level */\n    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */\n    char *p = (char*)mode;\n    gz_stream *s;\n    char fmode\u00dd80\u00a8; /* copy of mode, without the compression level */\n    char *m = fmode;\n\n    if (!path || !mode) return Z_NULL;\n\n    s = (gz_stream *)ALLOC(sizeof(gz_stream));\n    if (!s) return Z_NULL;\n\n    s->stream.zalloc = (alloc_func)0;\n    s->stream.zfree = (free_func)0;\n    s->stream.opaque = (voidpf)0;\n    s->stream.next_in = s->inbuf = Z_NULL;\n    s->stream.next_out = s->outbuf = Z_NULL;\n    s->stream.avail_in = s->stream.avail_out = 0;\n    s->file = NULL;\n    s->z_err = Z_OK;\n    s->z_eof = 0;\n    s->crc = crc32(0L, Z_NULL, 0);\n    s->msg = NULL;\n    s->transparent = 0;\n\n    s->path = (char*)ALLOC(strlen(path)+1);\n    if (s->path == NULL) {\n        return destroy(s), (gzFile)Z_NULL;\n    }\n    strcpy(s->path, path); /* do this early for debugging */\n\n    s->mode = '\\0';\n    do {\n        if (*p == 'r') s->mode = 'r';\n        if (*p == 'w' || *p == 'a') s->mode = 'w';\n        if (*p >= '0' && *p <= '9') {\n\t    level = *p - '0';\n\t} else if (*p == 'f') {\n\t  strategy = Z_FILTERED;\n\t} else if (*p == 'h') {\n\t  strategy = Z_HUFFMAN_ONLY;\n\t} else {\n\t    *m++ = *p; /* copy the mode */\n\t}\n    } while (*p++ && m != fmode + sizeof(fmode));\n    if (s->mode == '\\0') return destroy(s), (gzFile)Z_NULL;\n\n    if (s->mode == 'w') {\n#ifdef NO_DEFLATE\n        err = Z_STREAM_ERROR;\n#else\n        err = deflateInit2(&(s->stream), level,\n                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);\n        /* windowBits is passed < 0 to suppress zlib header */\n\n        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n#endif\n        if (err != Z_OK || s->outbuf == Z_NULL) {\n            return destroy(s), (gzFile)Z_NULL;\n        }\n    } else {\n        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);\n\n        err = inflateInit2(&(s->stream), -MAX_WBITS);\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are\n         * present after the compressed stream.\n         */\n        if (err != Z_OK || s->inbuf == Z_NULL) {\n            return destroy(s), (gzFile)Z_NULL;\n        }\n    }\n    s->stream.avail_out = Z_BUFSIZE;\n\n    errno = 0;\n    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);\n\n    if (s->file == NULL) {\n        return destroy(s), (gzFile)Z_NULL;\n    }\n    if (s->mode == 'w') {\n        /* Write a very simple .gz header:\n         */\n        fprintf(s->file, \"%c%c%c%c%c%c%c%c%c%c\", gz_magic\u00dd0\u00a8, gz_magic\u00dd1\u00a8,\n             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);\n\ts->startpos = 10L;\n\t/* We use 10L instead of ftell(s->file) to because ftell causes an\n         * fflush on some systems. This version of the library doesn't use\n         * startpos anyway in write mode, so this initialization is not\n         * necessary.\n         */\n    } else {\n\tcheck_header(s); /* skip the .gz header */\n\ts->startpos = (ftell(s->file) - s->stream.avail_in);\n    }\n\n    return (gzFile)s;\n}\n\n/* ===========================================================================\n     Opens a gzip (.gz) file for reading or writing.\n*/\ngzFile ZEXPORT gzopen (path, mode)\n    const char *path;\n    const char *mode;\n{\n    return gz_open (path, mode, -1);\n}\n\n/* ===========================================================================\n     Associate a gzFile with the file descriptor fd. fd is not dup'ed here\n   to mimic the behavio(u)r of fdopen.\n*/\ngzFile ZEXPORT gzdopen (fd, mode)\n    int fd;\n    const char *mode;\n{\n    char name\u00dd20\u00a8;\n\n    if (fd < 0) return (gzFile)Z_NULL;\n    sprintf(name, \"<fd:%d>\", fd); /* for debugging */\n\n    return gz_open (name, mode, fd);\n}\n\n/* ===========================================================================\n * Update the compression level and strategy\n */\nint ZEXPORT gzsetparams (file, level, strategy)\n    gzFile file;\n    int level;\n    int strategy;\n{\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;\n\n    /* Make room to allow flushing */\n    if (s->stream.avail_out == 0) {\n\n\ts->stream.next_out = s->outbuf;\n\tif (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {\n\t    s->z_err = Z_ERRNO;\n\t}\n\ts->stream.avail_out = Z_BUFSIZE;\n    }\n\n    return deflateParams (&(s->stream), level, strategy);\n}\n\n/* ===========================================================================\n     Read a byte from a gz_stream; update next_in and avail_in. Return EOF\n   for end of file.\n   IN assertion: the stream s has been sucessfully opened for reading.\n*/\nlocal int get_byte(s)\n    gz_stream *s;\n{\n    if (s->z_eof) return EOF;\n    if (s->stream.avail_in == 0) {\n\terrno = 0;\n\ts->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n\tif (s->stream.avail_in == 0) {\n\t    s->z_eof = 1;\n\t    if (ferror(s->file)) s->z_err = Z_ERRNO;\n\t    return EOF;\n\t}\n\ts->stream.next_in = s->inbuf;\n    }\n    s->stream.avail_in--;\n    return *(s->stream.next_in)++;\n}\n\n/* ===========================================================================\n      Check the gzip header of a gz_stream opened for reading. Set the stream\n    mode to transparent if the gzip magic header is not present; set s->err\n    to Z_DATA_ERROR if the magic header is present but the rest of the header\n    is incorrect.\n    IN assertion: the stream s has already been created sucessfully;\n       s->stream.avail_in is zero for the first time, but may be non-zero\n       for concatenated .gz files.\n*/\nlocal void check_header(s)\n    gz_stream *s;\n{\n    int method; /* method byte */\n    int flags;  /* flags byte */\n    uInt len;\n    int c;\n\n    /* Check the gzip magic header */\n    for (len = 0; len < 2; len++) {\n\tc = get_byte(s);\n\tif (c != gz_magic\u00ddlen\u00a8) {\n\t    if (len != 0) s->stream.avail_in++, s->stream.next_in--;\n\t    if (c != EOF) {\n\t\ts->stream.avail_in++, s->stream.next_in--;\n\t\ts->transparent = 1;\n\t    }\n\t    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;\n\t    return;\n\t}\n    }\n    method = get_byte(s);\n    flags = get_byte(s);\n    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {\n\ts->z_err = Z_DATA_ERROR;\n\treturn;\n    }\n\n    /* Discard time, xflags and OS code: */\n    for (len = 0; len < 6; len++) (void)get_byte(s);\n\n    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */\n\tlen  =  (uInt)get_byte(s);\n\tlen += ((uInt)get_byte(s))<<8;\n\t/* len is garbage if EOF but the loop below will quit anyway */\n\twhile (len-- != 0 && get_byte(s) != EOF) ;\n    }\n    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */\n\twhile ((c = get_byte(s)) != 0 && c != EOF) ;\n    }\n    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */\n\twhile ((c = get_byte(s)) != 0 && c != EOF) ;\n    }\n    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */\n\tfor (len = 0; len < 2; len++) (void)get_byte(s);\n    }\n    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;\n}\n\n /* ===========================================================================\n * Cleanup then free the given gz_stream. Return a zlib error code.\n   Try freeing in the reverse order of allocations.\n */\nlocal int destroy (s)\n    gz_stream *s;\n{\n    int err = Z_OK;\n\n    if (!s) return Z_STREAM_ERROR;\n\n    TRYFREE(s->msg);\n\n    if (s->stream.state != NULL) {\n\tif (s->mode == 'w') {\n#ifdef NO_DEFLATE\n\t    err = Z_STREAM_ERROR;\n#else\n\t    err = deflateEnd(&(s->stream));\n#endif\n\t} else if (s->mode == 'r') {\n\t    err = inflateEnd(&(s->stream));\n\t}\n    }\n    if (s->file != NULL && fclose(s->file)) {\n#ifdef ESPIPE\n\tif (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */\n#endif\n\t    err = Z_ERRNO;\n    }\n    if (s->z_err < 0) err = s->z_err;\n\n    TRYFREE(s->inbuf);\n    TRYFREE(s->outbuf);\n    TRYFREE(s->path);\n    TRYFREE(s);\n    return err;\n}\n\n/* ===========================================================================\n     Reads the given number of uncompressed bytes from the compressed file.\n   gzread returns the number of bytes actually read (0 for end of file).\n*/\nint ZEXPORT gzread (file, buf, len)\n    gzFile file;\n    voidp buf;\n    unsigned len;\n{\n    gz_stream *s = (gz_stream*)file;\n    Bytef *start = (Bytef*)buf; /* starting point for crc computation */\n    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */\n\n    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;\n\n    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;\n    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */\n\n    next_out = (Byte*)buf;\n    s->stream.next_out = (Bytef*)buf;\n    s->stream.avail_out = len;\n\n    while (s->stream.avail_out != 0) {\n\n\tif (s->transparent) {\n\t    /* Copy first the lookahead bytes: */\n\t    uInt n = s->stream.avail_in;\n\t    if (n > s->stream.avail_out) n = s->stream.avail_out;\n\t    if (n > 0) {\n\t\tzmemcpy(s->stream.next_out, s->stream.next_in, n);\n\t\tnext_out += n;\n\t\ts->stream.next_out = next_out;\n\t\ts->stream.next_in   += n;\n\t\ts->stream.avail_out -= n;\n\t\ts->stream.avail_in  -= n;\n\t    }\n\t    if (s->stream.avail_out > 0) {\n\t\ts->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,\n\t\t\t\t\t     s->file);\n\t    }\n\t    len -= s->stream.avail_out;\n\t    s->stream.total_in  += (uLong)len;\n\t    s->stream.total_out += (uLong)len;\n            if (len == 0) s->z_eof = 1;\n\t    return (int)len;\n\t}\n        if (s->stream.avail_in == 0 && !s->z_eof) {\n\n            errno = 0;\n            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n            if (s->stream.avail_in == 0) {\n                s->z_eof = 1;\n\t\tif (ferror(s->file)) {\n\t\t    s->z_err = Z_ERRNO;\n\t\t    break;\n\t\t}\n            }\n            s->stream.next_in = s->inbuf;\n        }\n        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);\n\n\tif (s->z_err == Z_STREAM_END) {\n\t    /* Check CRC and original size */\n\t    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n\t    start = s->stream.next_out;\n\n\t    if (getLong(s) != s->crc) {\n\t\ts->z_err = Z_DATA_ERROR;\n\t    } else {\n\t        (void)getLong(s);\n                /* The uncompressed length returned by above getlong() may\n                 * be different from s->stream.total_out) in case of\n\t\t * concatenated .gz files. Check for such files:\n\t\t */\n\t\tcheck_header(s);\n\t\tif (s->z_err == Z_OK) {\n\t\t    uLong total_in = s->stream.total_in;\n\t\t    uLong total_out = s->stream.total_out;\n\n\t\t    inflateReset(&(s->stream));\n\t\t    s->stream.total_in = total_in;\n\t\t    s->stream.total_out = total_out;\n\t\t    s->crc = crc32(0L, Z_NULL, 0);\n\t\t}\n\t    }\n\t}\n\tif (s->z_err != Z_OK || s->z_eof) break;\n    }\n    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n\n    return (int)(len - s->stream.avail_out);\n}\n\n\n/* ===========================================================================\n      Reads one byte from the compressed file. gzgetc returns this byte\n   or -1 in case of end of file or error.\n*/\nint ZEXPORT gzgetc(file)\n    gzFile file;\n{\n    unsigned char c;\n\n    return gzread(file, &c, 1) == 1 ? c : -1;\n}\n\n\n/* ===========================================================================\n      Reads bytes from the compressed file until len-1 characters are\n   read, or a newline character is read and transferred to buf, or an\n   end-of-file condition is encountered.  The string is then terminated\n   with a null character.\n      gzgets returns buf, or Z_NULL in case of error.\n\n      The current implementation is not optimized at all.\n*/\nchar * ZEXPORT gzgets(file, buf, len)\n    gzFile file;\n    char *buf;\n    int len;\n{\n    char *b = buf;\n    if (buf == Z_NULL || len <= 0) return Z_NULL;\n\n    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\\n') ;\n    *buf = '\\0';\n    return b == buf && len > 0 ? Z_NULL : b;\n}\n\n\n#ifndef NO_DEFLATE\n/* ===========================================================================\n     Writes the given number of uncompressed bytes into the compressed file.\n   gzwrite returns the number of bytes actually written (0 in case of error).\n*/\nint ZEXPORT gzwrite (file, buf, len)\n    gzFile file;\n    const voidp buf;\n    unsigned len;\n{\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;\n\n    s->stream.next_in = (Bytef*)buf;\n    s->stream.avail_in = len;\n\n    while (s->stream.avail_in != 0) {\n\n        if (s->stream.avail_out == 0) {\n\n            s->stream.next_out = s->outbuf;\n            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {\n                s->z_err = Z_ERRNO;\n                break;\n            }\n            s->stream.avail_out = Z_BUFSIZE;\n        }\n        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);\n        if (s->z_err != Z_OK) break;\n    }\n    s->crc = crc32(s->crc, (const Bytef *)buf, len);\n\n    return (int)(len - s->stream.avail_in);\n}\n\n/* ===========================================================================\n     Converts, formats, and writes the args to the compressed file under\n   control of the format string, as in fprintf. gzprintf returns the number of\n   uncompressed bytes actually written (0 in case of error).\n*/\n#ifdef STDC\n#include <stdarg.h>\n\nint ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n{\n    char buf\u00ddZ_PRINTF_BUFSIZE\u00a8;\n    va_list va;\n    int len;\n\n    va_start(va, format);\n#ifdef HAS_vsnprintf\n    (void)vsnprintf(buf, sizeof(buf), format, va);\n#else\n    (void)vsprintf(buf, format, va);\n#endif\n    va_end(va);\n    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */\n    if (len <= 0) return 0;\n\n    return gzwrite(file, buf, (unsigned)len);\n}\n#else /* not ANSI C */\n\nint ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n\t               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)\n    gzFile file;\n    const char *format;\n    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n\ta11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n{\n    char buf\u00ddZ_PRINTF_BUFSIZE\u00a8;\n    int len;\n\n#ifdef HAS_snprintf\n    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,\n\t     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#else\n    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,\n\t    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#endif\n    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */\n    if (len <= 0) return 0;\n\n    return gzwrite(file, buf, len);\n}\n#endif\n\n/* ===========================================================================\n      Writes c, converted to an unsigned char, into the compressed file.\n   gzputc returns the value that was written, or -1 in case of error.\n*/\nint ZEXPORT gzputc(file, c)\n    gzFile file;\n    int c;\n{\n    unsigned char cc = (unsigned char) c; /* required for big endian systems */\n\n    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;\n}\n\n\n/* ===========================================================================\n      Writes the given null-terminated string to the compressed file, excluding\n   the terminating null character.\n      gzputs returns the number of characters written, or -1 in case of error.\n*/\nint ZEXPORT gzputs(file, s)\n    gzFile file;\n    const char *s;\n{\n    return gzwrite(file, (char*)s, (unsigned)strlen(s));\n}\n\n\n/* ===========================================================================\n     Flushes all pending output into the compressed file. The parameter\n   flush is as in the deflate() function.\n*/\nlocal int do_flush (file, flush)\n    gzFile file;\n    int flush;\n{\n    uInt len;\n    int done = 0;\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;\n\n    s->stream.avail_in = 0; /* should be zero already anyway */\n\n    for (;;) {\n        len = Z_BUFSIZE - s->stream.avail_out;\n\n        if (len != 0) {\n            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {\n                s->z_err = Z_ERRNO;\n                return Z_ERRNO;\n            }\n            s->stream.next_out = s->outbuf;\n            s->stream.avail_out = Z_BUFSIZE;\n        }\n        if (done) break;\n        s->z_err = deflate(&(s->stream), flush);\n\n\t/* Ignore the second of two consecutive flushes: */\n\tif (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;\n\n        /* deflate has finished flushing only when it hasn't used up\n         * all the available space in the output buffer:\n         */\n        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);\n\n        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;\n    }\n    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n}\n\nint ZEXPORT gzflush (file, flush)\n     gzFile file;\n     int flush;\n{\n    gz_stream *s = (gz_stream*)file;\n    int err = do_flush (file, flush);\n\n    if (err) return err;\n    fflush(s->file);\n    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n}\n#endif /* NO_DEFLATE */\n\n/* ===========================================================================\n      Sets the starting position for the next gzread or gzwrite on the given\n   compressed file. The offset represents a number of bytes in the\n      gzseek returns the resulting offset location as measured in bytes from\n   the beginning of the uncompressed stream, or -1 in case of error.\n      SEEK_END is not implemented, returns error.\n      In this version of the library, gzseek can be extremely slow.\n*/\nz_off_t ZEXPORT gzseek (file, offset, whence)\n    gzFile file;\n    z_off_t offset;\n    int whence;\n{\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL || whence == SEEK_END ||\n\ts->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {\n\treturn -1L;\n    }\n\n    if (s->mode == 'w') {\n#ifdef NO_DEFLATE\n\treturn -1L;\n#else\n\tif (whence == SEEK_SET) {\n\t    offset -= s->stream.total_in;\n\t}\n\tif (offset < 0) return -1L;\n\n\t/* At this point, offset is the number of zero bytes to write. */\n\tif (s->inbuf == Z_NULL) {\n\t    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */\n\t    zmemzero(s->inbuf, Z_BUFSIZE);\n\t}\n\twhile (offset > 0)  {\n\t    uInt size = Z_BUFSIZE;\n\t    if (offset < Z_BUFSIZE) size = (uInt)offset;\n\n\t    size = gzwrite(file, s->inbuf, size);\n\t    if (size == 0) return -1L;\n\n\t    offset -= size;\n\t}\n\treturn (z_off_t)s->stream.total_in;\n#endif\n    }\n    /* Rest of function is for reading only */\n\n    /* compute absolute position */\n    if (whence == SEEK_CUR) {\n\toffset += s->stream.total_out;\n    }\n    if (offset < 0) return -1L;\n\n    if (s->transparent) {\n\t/* map to fseek */\n\ts->stream.avail_in = 0;\n\ts->stream.next_in = s->inbuf;\n        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;\n\n\ts->stream.total_in = s->stream.total_out = (uLong)offset;\n\treturn offset;\n    }\n\n    /* For a negative seek, rewind and use positive seek */\n    if ((uLong)offset >= s->stream.total_out) {\n\toffset -= s->stream.total_out;\n    } else if (gzrewind(file) < 0) {\n\treturn -1L;\n    }\n    /* offset is now the number of bytes to skip. */\n\n    if (offset != 0 && s->outbuf == Z_NULL) {\n\ts->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n    }\n    while (offset > 0)  {\n\tint size = Z_BUFSIZE;\n\tif (offset < Z_BUFSIZE) size = (int)offset;\n\n\tsize = gzread(file, s->outbuf, (uInt)size);\n\tif (size <= 0) return -1L;\n\toffset -= size;\n    }\n    return (z_off_t)s->stream.total_out;\n}\n\n/* ===========================================================================\n     Rewinds input file.\n*/\nint ZEXPORT gzrewind (file)\n    gzFile file;\n{\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL || s->mode != 'r') return -1;\n\n    s->z_err = Z_OK;\n    s->z_eof = 0;\n    s->stream.avail_in = 0;\n    s->stream.next_in = s->inbuf;\n    s->crc = crc32(0L, Z_NULL, 0);\n\n    if (s->startpos == 0) { /* not a compressed file */\n\trewind(s->file);\n\treturn 0;\n    }\n\n    (void) inflateReset(&s->stream);\n    return fseek(s->file, s->startpos, SEEK_SET);\n}\n\n/* ===========================================================================\n     Returns the starting position for the next gzread or gzwrite on the\n   given compressed file. This position represents a number of bytes in the\n   uncompressed data stream.\n*/\nz_off_t ZEXPORT gztell (file)\n    gzFile file;\n{\n    return gzseek(file, 0L, SEEK_CUR);\n}\n\n/* ===========================================================================\n     Returns 1 when EOF has previously been detected reading the given\n   input stream, otherwise zero.\n*/\nint ZEXPORT gzeof (file)\n    gzFile file;\n{\n    gz_stream *s = (gz_stream*)file;\n\n    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;\n}\n\n/* ===========================================================================\n   Outputs a long in LSB order to the given file\n*/\nlocal void putLong (file, x)\n    FILE *file;\n    uLong x;\n{\n    int n;\n    for (n = 0; n < 4; n++) {\n        fputc((int)(x & 0xff), file);\n        x >>= 8;\n    }\n}\n\n/* ===========================================================================\n   Reads a long in LSB order from the given gz_stream. Sets z_err in case\n   of error.\n*/\nlocal uLong getLong (s)\n    gz_stream *s;\n{\n    uLong x = (uLong)get_byte(s);\n    int c;\n\n    x += ((uLong)get_byte(s))<<8;\n    x += ((uLong)get_byte(s))<<16;\n    c = get_byte(s);\n    if (c == EOF) s->z_err = Z_DATA_ERROR;\n    x += ((uLong)c)<<24;\n    return x;\n}\n\n/* ===========================================================================\n     Flushes all pending output if necessary, closes the compressed file\n   and deallocates all the (de)compression state.\n*/\nint ZEXPORT gzclose (file)\n    gzFile file;\n{\n    int err;\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL) return Z_STREAM_ERROR;\n\n    if (s->mode == 'w') {\n#ifdef NO_DEFLATE\n\treturn Z_STREAM_ERROR;\n#else\n        err = do_flush (file, Z_FINISH);\n        if (err != Z_OK) return destroy((gz_stream*)file);\n\n        putLong (s->file, s->crc);\n        putLong (s->file, s->stream.total_in);\n#endif\n    }\n    return destroy((gz_stream*)file);\n}\n\n/* ===========================================================================\n     Returns the error message for the last error which occured on the\n   given compressed file. errnum is set to zlib error number. If an\n   error occured in the file system and not in the compression library,\n   errnum is set to Z_ERRNO and the application may consult errno\n   to get the exact error code.\n*/\nconst char*  ZEXPORT gzerror (file, errnum)\n    gzFile file;\n    int *errnum;\n{\n    char *m;\n    gz_stream *s = (gz_stream*)file;\n\n    if (s == NULL) {\n        *errnum = Z_STREAM_ERROR;\n        return (const char*)ERR_MSG(Z_STREAM_ERROR);\n    }\n    *errnum = s->z_err;\n    if (*errnum == Z_OK) return (const char*)\"\";\n\n    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);\n\n    if (m == NULL || *m == '\\0') m = (char*)ERR_MSG(s->z_err);\n\n    TRYFREE(s->msg);\n    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);\n    strcpy(s->msg, s->path);\n    strcat(s->msg, \": \");\n    strcat(s->msg, m);\n    return (const char*)s->msg;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFBLOCK": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* infblock.c -- interpret and process block types to last block\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"infblock.h\"\n#include \"inftrees.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n\nstruct inflate_codes_state {int dummy;}; /* for buggy compilers */\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n/* Table for deflate from PKZIP's appnote.txt. */\nlocal const uInt border\u00dd\u00a8 = { /* Order of the bit length code lengths */\n        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n/*\n   Notes beyond the 1.93a appnote.txt:\n\n   1. Distance pointers never point before the beginning of the output\n      stream.\n   2. Distance pointers can point back across blocks, up to 32k away.\n   3. There is an implied maximum of 7 bits for the bit length table and\n      15 bits for the actual data.\n   4. If only one code exists, then it is encoded using one bit.  (Zero\n      would be more efficient, but perhaps a little confusing.)  If two\n      codes exist, they are coded using one bit each (0 and 1).\n   5. There is no way of sending zero distance codes--a dummy must be\n      sent if there are none.  (History: a pre 2.0 version of PKZIP would\n      store blocks with no distance codes, but this was discovered to be\n      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow\n      zero distance codes, which is sent as one code of zero bits in\n      length.\n   6. There are up to 286 literal/length codes.  Code 256 represents the\n      end-of-block.  Note however that the static length tree defines\n      288 codes just to fill out the Huffman codes.  Codes 286 and 287\n      cannot be used though, since there is no length base or extra bits\n      defined for them.  Similarily, there are up to 30 distance codes.\n      However, static trees define 32 codes (all 5 bits) to fill out the\n      Huffman codes, but the last two had better not show up in the data.\n   7. Unzip can check dynamic Huffman blocks for complete code sets.\n      The exception is that a single code would not be complete (see #4).\n   8. The five bits following the block type is really the number of\n      literal codes sent minus 257.\n   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits\n      (1+6+6).  Therefore, to output three times the length, you output\n      three codes (1+1+1), whereas to output four times the same length,\n      you only need two codes (1+3).  Hmm.\n  10. In the tree reconstruction algorithm, Code = Code + Increment\n      only if BitLength(i) is not zero.  (Pretty obvious.)\n  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)\n  12. Note: length code 284 can represent 227-258, but length code 285\n      really is 258.  The last length deserves its own, short code\n      since it gets used a lot in very redundant files.  The length\n      258 is special since 258 - 3 (the min match length) is 255.\n  13. The literal/length and distance code bit lengths are read as a\n      single stream of lengths.  It is possible (and advantageous) for\n      a repeat code (16, 17, or 18) to go across the boundary between\n      the two sets of lengths.\n */\n\n\nvoid inflate_blocks_reset(s, z, c)\ninflate_blocks_statef *s;\nz_streamp z;\nuLongf *c;\n{\n  if (c != Z_NULL)\n    *c = s->check;\n  if (s->mode == BTREE || s->mode == DTREE)\n    ZFREE(z, s->sub.trees.blens);\n  if (s->mode == CODES)\n    inflate_codes_free(s->sub.decode.codes, z);\n  s->mode = TYPE;\n  s->bitk = 0;\n  s->bitb = 0;\n  s->read = s->write = s->window;\n  if (s->checkfn != Z_NULL)\n    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);\n  Tracev((stderr, \"inflate:   blocks reset\\n\"));\n}\n\n\ninflate_blocks_statef *inflate_blocks_new(z, c, w)\nz_streamp z;\ncheck_func c;\nuInt w;\n{\n  inflate_blocks_statef *s;\n\n  if ((s = (inflate_blocks_statef *)ZALLOC\n       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)\n    return s;\n  if ((s->hufts =\n       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)\n  {\n    ZFREE(z, s);\n    return Z_NULL;\n  }\n  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)\n  {\n    ZFREE(z, s->hufts);\n    ZFREE(z, s);\n    return Z_NULL;\n  }\n  s->end = s->window + w;\n  s->checkfn = c;\n  s->mode = TYPE;\n  Tracev((stderr, \"inflate:   blocks allocated\\n\"));\n  inflate_blocks_reset(s, z, Z_NULL);\n  return s;\n}\n\n\nint inflate_blocks(s, z, r)\ninflate_blocks_statef *s;\nz_streamp z;\nint r;\n{\n  uInt t;               /* temporary storage */\n  uLong b;              /* bit buffer */\n  uInt k;               /* bits in bit buffer */\n  Bytef *p;             /* input data pointer */\n  uInt n;               /* bytes available there */\n  Bytef *q;             /* output window write pointer */\n  uInt m;               /* bytes to end of window or read pointer */\n\n  /* copy input/output information to locals (UPDATE macro restores) */\n  LOAD\n\n  /* process input based on current state */\n  while (1) switch (s->mode)\n  {\n    case TYPE:\n      NEEDBITS(3)\n      t = (uInt)b & 7;\n      s->last = t & 1;\n      switch (t >> 1)\n      {\n        case 0:                         /* stored */\n          Tracev((stderr, \"inflate:     stored block%s\\n\",\n                 s->last ? \" (last)\" : \"\"));\n          DUMPBITS(3)\n          t = k & 7;                    /* go to byte boundary */\n          DUMPBITS(t)\n          s->mode = LENS;               /* get length of stored block */\n          break;\n        case 1:                         /* fixed */\n          Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                 s->last ? \" (last)\" : \"\"));\n          {\n            uInt bl, bd;\n            inflate_huft *tl, *td;\n\n            inflate_trees_fixed(&bl, &bd, &tl, &td, z);\n            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);\n            if (s->sub.decode.codes == Z_NULL)\n            {\n              r = Z_MEM_ERROR;\n              LEAVE\n            }\n          }\n          DUMPBITS(3)\n          s->mode = CODES;\n          break;\n        case 2:                         /* dynamic */\n          Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                 s->last ? \" (last)\" : \"\"));\n          DUMPBITS(3)\n          s->mode = TABLE;\n          break;\n        case 3:                         /* illegal */\n          DUMPBITS(3)\n          s->mode = BAD;\n          z->msg = (char*)\"invalid block type\";\n          r = Z_DATA_ERROR;\n          LEAVE\n      }\n      break;\n    case LENS:\n      NEEDBITS(32)\n      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))\n      {\n        s->mode = BAD;\n        z->msg = (char*)\"invalid stored block lengths\";\n        r = Z_DATA_ERROR;\n        LEAVE\n      }\n      s->sub.left = (uInt)b & 0xffff;\n      b = k = 0;                      /* dump bits */\n      Tracev((stderr, \"inflate:       stored length %u\\n\", s->sub.left));\n      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);\n      break;\n    case STORED:\n      if (n == 0)\n        LEAVE\n      NEEDOUT\n      t = s->sub.left;\n      if (t > n) t = n;\n      if (t > m) t = m;\n      zmemcpy(q, p, t);\n      p += t;  n -= t;\n      q += t;  m -= t;\n      if ((s->sub.left -= t) != 0)\n        break;\n      Tracev((stderr, \"inflate:       stored end, %lu total out\\n\",\n              z->total_out + (q >= s->read ? q - s->read :\n              (s->end - s->read) + (q - s->window))));\n      s->mode = s->last ? DRY : TYPE;\n      break;\n    case TABLE:\n      NEEDBITS(14)\n      s->sub.trees.table = t = (uInt)b & 0x3fff;\n#ifndef PKZIP_BUG_WORKAROUND\n      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n      {\n        s->mode = BAD;\n        z->msg = (char*)\"too many length or distance symbols\";\n        r = Z_DATA_ERROR;\n        LEAVE\n      }\n#endif\n      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)\n      {\n        r = Z_MEM_ERROR;\n        LEAVE\n      }\n      DUMPBITS(14)\n      s->sub.trees.index = 0;\n      Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n      s->mode = BTREE;\n    case BTREE:\n      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))\n      {\n        NEEDBITS(3)\n        s->sub.trees.blens\u00ddborder\u00dds->sub.trees.index++\u00a8\u00a8 = (uInt)b & 7;\n        DUMPBITS(3)\n      }\n      while (s->sub.trees.index < 19)\n        s->sub.trees.blens\u00ddborder\u00dds->sub.trees.index++\u00a8\u00a8 = 0;\n      s->sub.trees.bb = 7;\n      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,\n                             &s->sub.trees.tb, s->hufts, z);\n      if (t != Z_OK)\n      {\n        r = t;\n        if (r == Z_DATA_ERROR)\n        {\n          ZFREE(z, s->sub.trees.blens);\n          s->mode = BAD;\n        }\n        LEAVE\n      }\n      s->sub.trees.index = 0;\n      Tracev((stderr, \"inflate:       bits tree ok\\n\"));\n      s->mode = DTREE;\n    case DTREE:\n      while (t = s->sub.trees.table,\n             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))\n      {\n        inflate_huft *h;\n        uInt i, j, c;\n\n        t = s->sub.trees.bb;\n        NEEDBITS(t)\n        h = s->sub.trees.tb + ((uInt)b & inflate_mask\u00ddt\u00a8);\n        t = h->bits;\n        c = h->base;\n        if (c < 16)\n        {\n          DUMPBITS(t)\n          s->sub.trees.blens\u00dds->sub.trees.index++\u00a8 = c;\n        }\n        else /* c == 16..18 */\n        {\n          i = c == 18 ? 7 : c - 14;\n          j = c == 18 ? 11 : 3;\n          NEEDBITS(t + i)\n          DUMPBITS(t)\n          j += (uInt)b & inflate_mask\u00ddi\u00a8;\n          DUMPBITS(i)\n          i = s->sub.trees.index;\n          t = s->sub.trees.table;\n          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n              (c == 16 && i < 1))\n          {\n            ZFREE(z, s->sub.trees.blens);\n            s->mode = BAD;\n            z->msg = (char*)\"invalid bit length repeat\";\n            r = Z_DATA_ERROR;\n            LEAVE\n          }\n          c = c == 16 ? s->sub.trees.blens\u00ddi - 1\u00a8 : 0;\n          do {\n            s->sub.trees.blens\u00ddi++\u00a8 = c;\n          } while (--j);\n          s->sub.trees.index = i;\n        }\n      }\n      s->sub.trees.tb = Z_NULL;\n      {\n        uInt bl, bd;\n        inflate_huft *tl, *td;\n        inflate_codes_statef *c;\n\n        bl = 9;         /* must be <= 9 for lookahead assumptions */\n        bd = 6;         /* must be <= 9 for lookahead assumptions */\n        t = s->sub.trees.table;\n        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),\n                                  s->sub.trees.blens, &bl, &bd, &tl, &td,\n                                  s->hufts, z);\n        if (t != Z_OK)\n        {\n          if (t == (uInt)Z_DATA_ERROR)\n          {\n            ZFREE(z, s->sub.trees.blens);\n            s->mode = BAD;\n          }\n          r = t;\n          LEAVE\n        }\n        Tracev((stderr, \"inflate:       trees ok\\n\"));\n        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)\n        {\n          r = Z_MEM_ERROR;\n          LEAVE\n        }\n        s->sub.decode.codes = c;\n      }\n      ZFREE(z, s->sub.trees.blens);\n      s->mode = CODES;\n    case CODES:\n      UPDATE\n      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)\n        return inflate_flush(s, z, r);\n      r = Z_OK;\n      inflate_codes_free(s->sub.decode.codes, z);\n      LOAD\n      Tracev((stderr, \"inflate:       codes end, %lu total out\\n\",\n              z->total_out + (q >= s->read ? q - s->read :\n              (s->end - s->read) + (q - s->window))));\n      if (!s->last)\n      {\n        s->mode = TYPE;\n        break;\n      }\n      s->mode = DRY;\n    case DRY:\n      FLUSH\n      if (s->read != s->write)\n        LEAVE\n      s->mode = DONE;\n    case DONE:\n      r = Z_STREAM_END;\n      LEAVE\n    case BAD:\n      r = Z_DATA_ERROR;\n      LEAVE\n    default:\n      r = Z_STREAM_ERROR;\n      LEAVE\n  }\n}\n\n\nint inflate_blocks_free(s, z)\ninflate_blocks_statef *s;\nz_streamp z;\n{\n  inflate_blocks_reset(s, z, Z_NULL);\n  ZFREE(z, s->window);\n  ZFREE(z, s->hufts);\n  ZFREE(z, s);\n  Tracev((stderr, \"inflate:   blocks freed\\n\"));\n  return Z_OK;\n}\n\n\nvoid inflate_set_dictionary(s, d, n)\ninflate_blocks_statef *s;\nconst Bytef *d;\nuInt  n;\n{\n  zmemcpy(s->window, d, n);\n  s->read = s->write = s->window + n;\n}\n\n\n/* Returns true if inflate is currently at the end of a block generated\n * by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n * IN assertion: s != Z_NULL\n */\nint inflate_blocks_sync_point(s)\ninflate_blocks_statef *s;\n{\n  return s->mode == LENS;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFCODES": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* infcodes.c -- process literals and length/distance pairs\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"infblock.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n#include \"inffast.h\"\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\ntypedef enum {        /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n      START,    /* x: set up for LEN */\n      LEN,      /* i: get length/literal/eob next */\n      LENEXT,   /* i: getting length extra (have base) */\n      DIST,     /* i: get distance next */\n      DISTEXT,  /* i: getting distance extra */\n      COPY,     /* o: copying bytes in window, waiting for space */\n      LIT,      /* o: got literal, waiting for output space */\n      WASH,     /* o: got eob, possibly still output waiting */\n      END,      /* x: got eob and all data flushed */\n      BADCODE}  /* x: got error */\ninflate_codes_mode;\n\n/* inflate codes private state */\nstruct inflate_codes_state {\n\n  /* mode */\n  inflate_codes_mode mode;      /* current inflate_codes mode */\n\n  /* mode dependent information */\n  uInt len;\n  union {\n    struct {\n      inflate_huft *tree;       /* pointer into tree */\n      uInt need;                /* bits needed */\n    } code;             /* if LEN or DIST, where in tree */\n    uInt lit;           /* if LIT, literal */\n    struct {\n      uInt get;                 /* bits to get for extra */\n      uInt dist;                /* distance back to copy from */\n    } copy;             /* if EXT or COPY, where and how much */\n  } sub;                /* submode */\n\n  /* mode independent information */\n  Byte lbits;           /* ltree bits decoded per branch */\n  Byte dbits;           /* dtree bits decoder per branch */\n  inflate_huft *ltree;          /* literal/length/eob tree */\n  inflate_huft *dtree;          /* distance tree */\n\n};\n\n\ninflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)\nuInt bl, bd;\ninflate_huft *tl;\ninflate_huft *td; /* need separate declaration for Borland C++ */\nz_streamp z;\n{\n  inflate_codes_statef *c;\n\n  if ((c = (inflate_codes_statef *)\n       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)\n  {\n    c->mode = START;\n    c->lbits = (Byte)bl;\n    c->dbits = (Byte)bd;\n    c->ltree = tl;\n    c->dtree = td;\n    Tracev((stderr, \"inflate:       codes new\\n\"));\n  }\n  return c;\n}\n\n\nint inflate_codes(s, z, r)\ninflate_blocks_statef *s;\nz_streamp z;\nint r;\n{\n  uInt j;               /* temporary storage */\n  inflate_huft *t;      /* temporary pointer */\n  uInt e;               /* extra bits or operation */\n  uLong b;              /* bit buffer */\n  uInt k;               /* bits in bit buffer */\n  Bytef *p;             /* input data pointer */\n  uInt n;               /* bytes available there */\n  Bytef *q;             /* output window write pointer */\n  uInt m;               /* bytes to end of window or read pointer */\n  Bytef *f;             /* pointer to copy strings from */\n  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */\n\n  /* copy input/output information to locals (UPDATE macro restores) */\n  LOAD\n\n  /* process input and output based on current state */\n  while (1) switch (c->mode)\n  {             /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n    case START:         /* x: set up for LEN */\n#ifndef SLOW\n      if (m >= 258 && n >= 10)\n      {\n        UPDATE\n        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);\n        LOAD\n        if (r != Z_OK)\n        {\n          c->mode = r == Z_STREAM_END ? WASH : BADCODE;\n          break;\n        }\n      }\n#endif /* !SLOW */\n      c->sub.code.need = c->lbits;\n      c->sub.code.tree = c->ltree;\n      c->mode = LEN;\n    case LEN:           /* i: get length/literal/eob next */\n      j = c->sub.code.need;\n      NEEDBITS(j)\n      t = c->sub.code.tree + ((uInt)b & inflate_mask\u00ddj\u00a8);\n      DUMPBITS(t->bits)\n      e = (uInt)(t->exop);\n      if (e == 0)               /* literal */\n      {\n        c->sub.lit = t->base;\n        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                 \"inflate:         literal '%c'\\n\" :\n                 \"inflate:         literal 0x%02x\\n\", t->base));\n        c->mode = LIT;\n        break;\n      }\n      if (e & 16)               /* length */\n      {\n        c->sub.copy.get = e & 15;\n        c->len = t->base;\n        c->mode = LENEXT;\n        break;\n      }\n      if ((e & 64) == 0)        /* next table */\n      {\n        c->sub.code.need = e;\n        c->sub.code.tree = t + t->base;\n        break;\n      }\n      if (e & 32)               /* end of block */\n      {\n        Tracevv((stderr, \"inflate:         end of block\\n\"));\n        c->mode = WASH;\n        break;\n      }\n      c->mode = BADCODE;        /* invalid code */\n      z->msg = (char*)\"invalid literal/length code\";\n      r = Z_DATA_ERROR;\n      LEAVE\n    case LENEXT:        /* i: getting length extra (have base) */\n      j = c->sub.copy.get;\n      NEEDBITS(j)\n      c->len += (uInt)b & inflate_mask\u00ddj\u00a8;\n      DUMPBITS(j)\n      c->sub.code.need = c->dbits;\n      c->sub.code.tree = c->dtree;\n      Tracevv((stderr, \"inflate:         length %u\\n\", c->len));\n      c->mode = DIST;\n    case DIST:          /* i: get distance next */\n      j = c->sub.code.need;\n      NEEDBITS(j)\n      t = c->sub.code.tree + ((uInt)b & inflate_mask\u00ddj\u00a8);\n      DUMPBITS(t->bits)\n      e = (uInt)(t->exop);\n      if (e & 16)               /* distance */\n      {\n        c->sub.copy.get = e & 15;\n        c->sub.copy.dist = t->base;\n        c->mode = DISTEXT;\n        break;\n      }\n      if ((e & 64) == 0)        /* next table */\n      {\n        c->sub.code.need = e;\n        c->sub.code.tree = t + t->base;\n        break;\n      }\n      c->mode = BADCODE;        /* invalid code */\n      z->msg = (char*)\"invalid distance code\";\n      r = Z_DATA_ERROR;\n      LEAVE\n    case DISTEXT:       /* i: getting distance extra */\n      j = c->sub.copy.get;\n      NEEDBITS(j)\n      c->sub.copy.dist += (uInt)b & inflate_mask\u00ddj\u00a8;\n      DUMPBITS(j)\n      Tracevv((stderr, \"inflate:         distance %u\\n\", c->sub.copy.dist));\n      c->mode = COPY;\n    case COPY:          /* o: copying bytes in window, waiting for space */\n      f = q - c->sub.copy.dist;\n      while (f < s->window)             /* modulo window size-\"while\" instead */\n        f += s->end - s->window;        /* of \"if\" handles invalid distances */\n      while (c->len)\n      {\n        NEEDOUT\n        OUTBYTE(*f++)\n        if (f == s->end)\n          f = s->window;\n        c->len--;\n      }\n      c->mode = START;\n      break;\n    case LIT:           /* o: got literal, waiting for output space */\n      NEEDOUT\n      OUTBYTE(c->sub.lit)\n      c->mode = START;\n      break;\n    case WASH:          /* o: got eob, possibly more output */\n      if (k > 7)        /* return unused byte, if any */\n      {\n        Assert(k < 16, \"inflate_codes grabbed too many bytes\")\n        k -= 8;\n        n++;\n        p--;            /* can always return one */\n      }\n      FLUSH\n      if (s->read != s->write)\n        LEAVE\n      c->mode = END;\n    case END:\n      r = Z_STREAM_END;\n      LEAVE\n    case BADCODE:       /* x: got error */\n      r = Z_DATA_ERROR;\n      LEAVE\n    default:\n      r = Z_STREAM_ERROR;\n      LEAVE\n  }\n#ifdef NEED_DUMMY_RETURN\n  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n#endif\n}\n\n\nvoid inflate_codes_free(c, z)\ninflate_codes_statef *c;\nz_streamp z;\n{\n  ZFREE(z, c);\n  Tracev((stderr, \"inflate:       codes free\\n\"));\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFFAST": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inffast.c -- process literals and length/distance pairs fast\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n#include \"infblock.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n#include \"inffast.h\"\n\nstruct inflate_codes_state {int dummy;}; /* for buggy compilers */\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n/* macros for bit input with no checking and for returning unused bytes */\n#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}\n#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}\n\n/* Called with number of bytes left to write in window at least 258\n   (the maximum string length) and number of input bytes available\n   at least ten.  The ten bytes are six bytes for the longest length/\n   distance pair plus four bytes for overloading the bit buffer. */\n\nint inflate_fast(bl, bd, tl, td, s, z)\nuInt bl, bd;\ninflate_huft *tl;\ninflate_huft *td; /* need separate declaration for Borland C++ */\ninflate_blocks_statef *s;\nz_streamp z;\n{\n  inflate_huft *t;      /* temporary pointer */\n  uInt e;               /* extra bits or operation */\n  uLong b;              /* bit buffer */\n  uInt k;               /* bits in bit buffer */\n  Bytef *p;             /* input data pointer */\n  uInt n;               /* bytes available there */\n  Bytef *q;             /* output window write pointer */\n  uInt m;               /* bytes to end of window or read pointer */\n  uInt ml;              /* mask for literal/length tree */\n  uInt md;              /* mask for distance tree */\n  uInt c;               /* bytes to copy */\n  uInt d;               /* distance back to copy from */\n  Bytef *r;             /* copy source pointer */\n\n  /* load input, output, bit values */\n  LOAD\n\n  /* initialize masks */\n  ml = inflate_mask\u00ddbl\u00a8;\n  md = inflate_mask\u00ddbd\u00a8;\n\n  /* do until not enough input or output space for fast loop */\n  do {                          /* assume called with m >= 258 && n >= 10 */\n    /* get literal/length code */\n    GRABBITS(20)                /* max bits for literal/length code */\n    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)\n    {\n      DUMPBITS(t->bits)\n      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                \"inflate:         * literal '%c'\\n\" :\n                \"inflate:         * literal 0x%02x\\n\", t->base));\n      *q++ = (Byte)t->base;\n      m--;\n      continue;\n    }\n    do {\n      DUMPBITS(t->bits)\n      if (e & 16)\n      {\n        /* get extra bits for length */\n        e &= 15;\n        c = t->base + ((uInt)b & inflate_mask\u00dde\u00a8);\n        DUMPBITS(e)\n        Tracevv((stderr, \"inflate:         * length %u\\n\", c));\n\n        /* decode distance base of block to copy */\n        GRABBITS(15);           /* max bits for distance code */\n        e = (t = td + ((uInt)b & md))->exop;\n        do {\n          DUMPBITS(t->bits)\n          if (e & 16)\n          {\n            /* get extra bits to add to distance base */\n            e &= 15;\n            GRABBITS(e)         /* get extra bits (up to 13) */\n            d = t->base + ((uInt)b & inflate_mask\u00dde\u00a8);\n            DUMPBITS(e)\n            Tracevv((stderr, \"inflate:         * distance %u\\n\", d));\n\n            /* do the copy */\n            m -= c;\n            r = q - d;\n            if (r < s->window)                  /* wrap if needed */\n            {\n              do {\n                r += s->end - s->window;        /* force pointer in window */\n              } while (r < s->window);          /* covers invalid distances */\n              e = s->end - r;\n              if (c > e)\n              {\n                c -= e;                         /* wrapped copy */\n                do {\n                    *q++ = *r++;\n                } while (--e);\n                r = s->window;\n                do {\n                    *q++ = *r++;\n                } while (--c);\n              }\n              else                              /* normal copy */\n              {\n                *q++ = *r++;  c--;\n                *q++ = *r++;  c--;\n                do {\n                    *q++ = *r++;\n                } while (--c);\n              }\n            }\n            else                                /* normal copy */\n            {\n              *q++ = *r++;  c--;\n              *q++ = *r++;  c--;\n              do {\n                *q++ = *r++;\n              } while (--c);\n            }\n            break;\n          }\n          else if ((e & 64) == 0)\n          {\n            t += t->base;\n            e = (t += ((uInt)b & inflate_mask\u00dde\u00a8))->exop;\n          }\n          else\n          {\n            z->msg = (char*)\"invalid distance code\";\n            UNGRAB\n            UPDATE\n            return Z_DATA_ERROR;\n          }\n        } while (1);\n        break;\n      }\n      if ((e & 64) == 0)\n      {\n        t += t->base;\n        if ((e = (t += ((uInt)b & inflate_mask\u00dde\u00a8))->exop) == 0)\n        {\n          DUMPBITS(t->bits)\n          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n                    \"inflate:         * literal '%c'\\n\" :\n                    \"inflate:         * literal 0x%02x\\n\", t->base));\n          *q++ = (Byte)t->base;\n          m--;\n          break;\n        }\n      }\n      else if (e & 32)\n      {\n        Tracevv((stderr, \"inflate:         * end of block\\n\"));\n        UNGRAB\n        UPDATE\n        return Z_STREAM_END;\n      }\n      else\n      {\n        z->msg = (char*)\"invalid literal/length code\";\n        UNGRAB\n        UPDATE\n        return Z_DATA_ERROR;\n      }\n    } while (1);\n  } while (m >= 258 && n >= 10);\n\n  /* not enough input or output--restore pointers and return */\n  UNGRAB\n  UPDATE\n  return Z_OK;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFLATE": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inflate.c -- zlib interface to inflate modules\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"infblock.h\"\n\nstruct inflate_blocks_state {int dummy;}; /* for buggy compilers */\n\ntypedef enum {\n      METHOD,   /* waiting for method byte */\n      FLAG,     /* waiting for flag byte */\n      DICT4,    /* four dictionary check bytes to go */\n      DICT3,    /* three dictionary check bytes to go */\n      DICT2,    /* two dictionary check bytes to go */\n      DICT1,    /* one dictionary check byte to go */\n      DICT0,    /* waiting for inflateSetDictionary */\n      BLOCKS,   /* decompressing blocks */\n      CHECK4,   /* four check bytes to go */\n      CHECK3,   /* three check bytes to go */\n      CHECK2,   /* two check bytes to go */\n      CHECK1,   /* one check byte to go */\n      DONE,     /* finished check, done */\n      BAD}      /* got an error--stay here */\ninflate_mode;\n\n/* inflate private state */\nstruct internal_state {\n\n  /* mode */\n  inflate_mode  mode;   /* current inflate mode */\n\n  /* mode dependent information */\n  union {\n    uInt method;        /* if FLAGS, method byte */\n    struct {\n      uLong was;                /* computed check value */\n      uLong need;               /* stream check value */\n    } check;            /* if CHECK, check values to compare */\n    uInt marker;        /* if BAD, inflateSync's marker bytes count */\n  } sub;        /* submode */\n\n  /* mode independent information */\n  int  nowrap;          /* flag for no wrapper */\n  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */\n  inflate_blocks_statef\n    *blocks;            /* current inflate_blocks state */\n\n};\n\n\nint ZEXPORT inflateReset(z)\nz_streamp z;\n{\n  if (z == Z_NULL || z->state == Z_NULL)\n    return Z_STREAM_ERROR;\n  z->total_in = z->total_out = 0;\n  z->msg = Z_NULL;\n  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;\n  inflate_blocks_reset(z->state->blocks, z, Z_NULL);\n  Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\n\nint ZEXPORT inflateEnd(z)\nz_streamp z;\n{\n  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)\n    return Z_STREAM_ERROR;\n  if (z->state->blocks != Z_NULL)\n    inflate_blocks_free(z->state->blocks, z);\n  ZFREE(z, z->state);\n  z->state = Z_NULL;\n  Tracev((stderr, \"inflate: end\\n\"));\n  return Z_OK;\n}\n\n\nint ZEXPORT inflateInit2_(z, w, version, stream_size)\nz_streamp z;\nint w;\nconst char *version;\nint stream_size;\n{\n  if (version == Z_NULL || version\u00dd0\u00a8 != ZLIB_VERSION\u00dd0\u00a8 ||\n      stream_size != sizeof(z_stream))\n      return Z_VERSION_ERROR;\n\n  /* initialize state */\n  if (z == Z_NULL)\n    return Z_STREAM_ERROR;\n  z->msg = Z_NULL;\n  if (z->zalloc == Z_NULL)\n  {\n    z->zalloc = zcalloc;\n    z->opaque = (voidpf)0;\n  }\n  if (z->zfree == Z_NULL) z->zfree = zcfree;\n  if ((z->state = (struct internal_state FAR *)\n       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)\n    return Z_MEM_ERROR;\n  z->state->blocks = Z_NULL;\n\n  /* handle undocumented nowrap option (no zlib header or check) */\n  z->state->nowrap = 0;\n  if (w < 0)\n  {\n    w = - w;\n    z->state->nowrap = 1;\n  }\n\n  /* set window size */\n  if (w < 8 || w > 15)\n  {\n    inflateEnd(z);\n    return Z_STREAM_ERROR;\n  }\n  z->state->wbits = (uInt)w;\n\n  /* create inflate_blocks state */\n  if ((z->state->blocks =\n      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))\n      == Z_NULL)\n  {\n    inflateEnd(z);\n    return Z_MEM_ERROR;\n  }\n  Tracev((stderr, \"inflate: allocated\\n\"));\n\n  /* reset state */\n  inflateReset(z);\n  return Z_OK;\n}\n\n\nint ZEXPORT inflateInit_(z, version, stream_size)\nz_streamp z;\nconst char *version;\nint stream_size;\n{\n  return inflateInit2_(z, DEF_WBITS, version, stream_size);\n}\n\n\n#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}\n#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)\n\nint ZEXPORT inflate(z, f)\nz_streamp z;\nint f;\n{\n  int r;\n  uInt b;\n\n  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)\n    return Z_STREAM_ERROR;\n  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n  r = Z_BUF_ERROR;\n  while (1) switch (z->state->mode)\n  {\n    case METHOD:\n      NEEDBYTE\n      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)\n      {\n        z->state->mode = BAD;\n        z->msg = (char*)\"unknown compression method\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      }\n      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)\n      {\n        z->state->mode = BAD;\n        z->msg = (char*)\"invalid window size\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      }\n      z->state->mode = FLAG;\n    case FLAG:\n      NEEDBYTE\n      b = NEXTBYTE;\n      if (((z->state->sub.method << 8) + b) % 31)\n      {\n        z->state->mode = BAD;\n        z->msg = (char*)\"incorrect header check\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      }\n      Tracev((stderr, \"inflate: zlib header ok\\n\"));\n      if (!(b & PRESET_DICT))\n      {\n        z->state->mode = BLOCKS;\n        break;\n      }\n      z->state->mode = DICT4;\n    case DICT4:\n      NEEDBYTE\n      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n      z->state->mode = DICT3;\n    case DICT3:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n      z->state->mode = DICT2;\n    case DICT2:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n      z->state->mode = DICT1;\n    case DICT1:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE;\n      z->adler = z->state->sub.check.need;\n      z->state->mode = DICT0;\n      return Z_NEED_DICT;\n    case DICT0:\n      z->state->mode = BAD;\n      z->msg = (char*)\"need dictionary\";\n      z->state->sub.marker = 0;       /* can try inflateSync */\n      return Z_STREAM_ERROR;\n    case BLOCKS:\n      r = inflate_blocks(z->state->blocks, z, r);\n      if (r == Z_DATA_ERROR)\n      {\n        z->state->mode = BAD;\n        z->state->sub.marker = 0;       /* can try inflateSync */\n        break;\n      }\n      if (r == Z_OK)\n        r = f;\n      if (r != Z_STREAM_END)\n        return r;\n      r = f;\n      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);\n      if (z->state->nowrap)\n      {\n        z->state->mode = DONE;\n        break;\n      }\n      z->state->mode = CHECK4;\n    case CHECK4:\n      NEEDBYTE\n      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n      z->state->mode = CHECK3;\n    case CHECK3:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n      z->state->mode = CHECK2;\n    case CHECK2:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n      z->state->mode = CHECK1;\n    case CHECK1:\n      NEEDBYTE\n      z->state->sub.check.need += (uLong)NEXTBYTE;\n\n      if (z->state->sub.check.was != z->state->sub.check.need)\n      {\n        z->state->mode = BAD;\n        z->msg = (char*)\"incorrect data check\";\n        z->state->sub.marker = 5;       /* can't try inflateSync */\n        break;\n      }\n      Tracev((stderr, \"inflate: zlib check ok\\n\"));\n      z->state->mode = DONE;\n    case DONE:\n      return Z_STREAM_END;\n    case BAD:\n      return Z_DATA_ERROR;\n    default:\n      return Z_STREAM_ERROR;\n  }\n#ifdef NEED_DUMMY_RETURN\n  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n#endif\n}\n\n\nint ZEXPORT inflateSetDictionary(z, dictionary, dictLength)\nz_streamp z;\nconst Bytef *dictionary;\nuInt  dictLength;\n{\n  uInt length = dictLength;\n\n  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)\n    return Z_STREAM_ERROR;\n\n  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;\n  z->adler = 1L;\n\n  if (length >= ((uInt)1<<z->state->wbits))\n  {\n    length = (1<<z->state->wbits)-1;\n    dictionary += dictLength - length;\n  }\n  inflate_set_dictionary(z->state->blocks, dictionary, length);\n  z->state->mode = BLOCKS;\n  return Z_OK;\n}\n\n\nint ZEXPORT inflateSync(z)\nz_streamp z;\n{\n  uInt n;       /* number of bytes to look at */\n  Bytef *p;     /* pointer to bytes */\n  uInt m;       /* number of marker bytes found in a row */\n  uLong r, w;   /* temporaries to save total_in and total_out */\n\n  /* set up */\n  if (z == Z_NULL || z->state == Z_NULL)\n    return Z_STREAM_ERROR;\n  if (z->state->mode != BAD)\n  {\n    z->state->mode = BAD;\n    z->state->sub.marker = 0;\n  }\n  if ((n = z->avail_in) == 0)\n    return Z_BUF_ERROR;\n  p = z->next_in;\n  m = z->state->sub.marker;\n\n  /* search */\n  while (n && m < 4)\n  {\n    static const Byte mark\u00dd4\u00a8 = {0, 0, 0xff, 0xff};\n    if (*p == mark\u00ddm\u00a8)\n      m++;\n    else if (*p)\n      m = 0;\n    else\n      m = 4 - m;\n    p++, n--;\n  }\n\n  /* restore */\n  z->total_in += p - z->next_in;\n  z->next_in = p;\n  z->avail_in = n;\n  z->state->sub.marker = m;\n\n  /* return no joy or set up to restart on a new block */\n  if (m != 4)\n    return Z_DATA_ERROR;\n  r = z->total_in;  w = z->total_out;\n  inflateReset(z);\n  z->total_in = r;  z->total_out = w;\n  z->state->mode = BLOCKS;\n  return Z_OK;\n}\n\n\n/* Returns true if inflate is currently at the end of a block generated\n * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n * but removes the length bytes of the resulting empty stored block. When\n * decompressing, PPP checks that at the end of input packet, inflate is\n * waiting for these length bytes.\n */\nint ZEXPORT inflateSyncPoint(z)\nz_streamp z;\n{\n  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)\n    return Z_STREAM_ERROR;\n  return inflate_blocks_sync_point(z->state->blocks);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFTREES": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inftrees.c -- generate Huffman trees for efficient decoding\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"inftrees.h\"\n\n#if !defined(BUILDFIXED) && !defined(STDC)\n#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */\n#endif\n\nconst char inflate_copyright\u00dd\u00a8 =\n   \" inflate 1.1.4 Copyright 1995-2002 Mark Adler \";\n/*\n  If you use the zlib library in a product, an acknowledgment is welcome\n  in the documentation of your product. If for some reason you cannot\n  include such an acknowledgment, I would appreciate that you keep this\n  copyright string in the executable of your product.\n */\nstruct internal_state  {int dummy;}; /* for buggy compilers */\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n\nlocal int huft_build OF((\n    uIntf *,            /* code lengths in bits */\n    uInt,               /* number of codes */\n    uInt,               /* number of \"simple\" codes */\n    const uIntf *,      /* list of base values for non-simple codes */\n    const uIntf *,      /* list of extra bits for non-simple codes */\n    inflate_huft * FAR*,/* result: starting table */\n    uIntf *,            /* maximum lookup bits (returns actual) */\n    inflate_huft *,     /* space for trees */\n    uInt *,             /* hufts used in space */\n    uIntf * ));         /* space for values */\n\n/* Tables for deflate from PKZIP's appnote.txt. */\nlocal const uInt cplens\u00dd31\u00a8 = { /* Copy lengths for literal codes 257..285 */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n        /* see note #13 above about 258 */\nlocal const uInt cplext\u00dd31\u00a8 = { /* Extra bits for literal codes 257..285 */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */\nlocal const uInt cpdist\u00dd30\u00a8 = { /* Copy offsets for distance codes 0..29 */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\nlocal const uInt cpdext\u00dd30\u00a8 = { /* Extra bits for distance codes */\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n/*\n   Huffman code decoding is performed using a multi-level table lookup.\n   The fastest way to decode is to simply build a lookup table whose\n   size is determined by the longest code.  However, the time it takes\n   to build this table can also be a factor if the data being decoded\n   is not very long.  The most common codes are necessarily the\n   shortest codes, so those codes dominate the decoding time, and hence\n   the speed.  The idea is you can have a shorter table that decodes the\n   shorter, more probable codes, and then point to subsidiary tables for\n   the longer codes.  The time it costs to decode the longer codes is\n   then traded against the time it takes to make longer tables.\n\n   This results of this trade are in the variables lbits and dbits\n   below.  lbits is the number of bits the first level table for literal/\n   length codes can decode in one step, and dbits is the same thing for\n   the distance codes.  Subsequent tables are also less than or equal to\n   those sizes.  These values may be adjusted either when all of the\n   codes are shorter than that, in which case the longest code length in\n   bits is used, or when the shortest code is *longer* than the requested\n   table size, in which case the length of the shortest code in bits is\n   used.\n\n   There are two different values for the two tables, since they code a\n   different number of possibilities each.  The literal/length table\n   codes 286 possible values, or in a flat code, a little over eight\n   bits.  The distance table codes 30 possible values, or a little less\n   than five bits, flat.  The optimum values for speed end up being\n   about one bit more than those, so lbits is 8+1 and dbits is 5+1.\n   The optimum values may differ though from machine to machine, and\n   possibly even between compilers.  Your mileage may vary.\n */\n\n\n/* If BMAX needs to be larger than 16, then h and x\u00dd\u00a8 should be uLong. */\n#define BMAX 15         /* maximum bit length of any code */\n\nlocal int huft_build(b, n, s, d, e, t, m, hp, hn, v)\nuIntf *b;               /* code lengths in bits (all assumed <= BMAX) */\nuInt n;                 /* number of codes (assumed <= 288) */\nuInt s;                 /* number of simple-valued codes (0..s-1) */\nconst uIntf *d;         /* list of base values for non-simple codes */\nconst uIntf *e;         /* list of extra bits for non-simple codes */\ninflate_huft * FAR *t;  /* result: starting table */\nuIntf *m;               /* maximum lookup bits, returns actual */\ninflate_huft *hp;       /* space for trees */\nuInt *hn;               /* hufts used in space */\nuIntf *v;               /* working area: values in order of bit length */\n/* Given a list of code lengths and a maximum table size, make a set of\n   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n   if the given code set is incomplete (the tables are still built in this\n   case), or Z_DATA_ERROR if the input is invalid. */\n{\n\n  uInt a;                       /* counter for codes of length k */\n  uInt c\u00ddBMAX+1\u00a8;               /* bit length count table */\n  uInt f;                       /* i repeats in table every f entries */\n  int g;                        /* maximum code length */\n  int h;                        /* table level */\n  register uInt i;              /* counter, current code */\n  register uInt j;              /* counter */\n  register int k;               /* number of bits in current code */\n  int l;                        /* bits per table (returned in m) */\n  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */\n  register uIntf *p;            /* pointer into c\u00dd\u00a8, b\u00dd\u00a8, or v\u00dd\u00a8 */\n  inflate_huft *q;              /* points to current table */\n  struct inflate_huft_s r;      /* table entry for structure assignment */\n  inflate_huft *u\u00ddBMAX\u00a8;        /* table stack */\n  register int w;               /* bits before this table == (l * h) */\n  uInt x\u00ddBMAX+1\u00a8;               /* bit offsets, then code stack */\n  uIntf *xp;                    /* pointer into x */\n  int y;                        /* number of dummy codes added */\n  uInt z;                       /* number of entries in current table */\n\n\n  /* Generate counts for each bit length */\n  p = c;\n#define C0 *p++ = 0;\n#define C2 C0 C0 C0 C0\n#define C4 C2 C2 C2 C2\n  C4                            /* clear c\u00dd\u00a8--assume BMAX+1 is 16 */\n  p = b;  i = n;\n  do {\n    c\u00dd*p++\u00a8++;                  /* assume all entries <= BMAX */\n  } while (--i);\n  if (c\u00dd0\u00a8 == n)                /* null input--all zero length codes */\n  {\n    *t = (inflate_huft *)Z_NULL;\n    *m = 0;\n    return Z_OK;\n  }\n\n\n  /* Find minimum and maximum length, bound *m by those */\n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c\u00ddj\u00a8)\n      break;\n  k = j;                        /* minimum code length */\n  if ((uInt)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c\u00ddi\u00a8)\n      break;\n  g = i;                        /* maximum code length */\n  if ((uInt)l > i)\n    l = i;\n  *m = l;\n\n\n  /* Adjust last length count to fill out codes, if needed */\n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c\u00ddj\u00a8) < 0)\n      return Z_DATA_ERROR;\n  if ((y -= c\u00ddi\u00a8) < 0)\n    return Z_DATA_ERROR;\n  c\u00ddi\u00a8 += y;\n\n\n  /* Generate starting offsets into the value table for each length */\n  x\u00dd1\u00a8 = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                 /* note that i == g from above */\n    *xp++ = (j += *p++);\n  }\n\n\n  /* Make a table of values in order of bit lengths */\n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v\u00ddx\u00ddj\u00a8++\u00a8 = i;\n  } while (++i < n);\n  n = x\u00ddg\u00a8;                     /* set n to length of v */\n\n\n  /* Generate the Huffman codes and for each, make the table entries */\n  x\u00dd0\u00a8 = i = 0;                 /* first Huffman code is zero */\n  p = v;                        /* grab values in bit order */\n  h = -1;                       /* no tables yet--level -1 */\n  w = -l;                       /* bits decoded == (l * h) */\n  u\u00dd0\u00a8 = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */\n  q = (inflate_huft *)Z_NULL;   /* ditto */\n  z = 0;                        /* ditto */\n\n  /* go through the bit lengths (k already is bits in shortest code) */\n  for (; k <= g; k++)\n  {\n    a = c\u00ddk\u00a8;\n    while (a--)\n    {\n      /* here i is the Huffman code of length k bits for value *p */\n      /* make tables up to required level */\n      while (k > w + l)\n      {\n        h++;\n        w += l;                 /* previous table always l bits */\n\n        /* compute minimum size table less than or equal to l bits */\n        z = g - w;\n        z = z > (uInt)l ? l : z;        /* table size upper limit */\n        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n        {                       /* too few codes for k-w bit table */\n          f -= a + 1;           /* deduct codes from patterns left */\n          xp = c + k;\n          if (j < z)\n            while (++j < z)     /* try smaller tables up to z bits */\n            {\n              if ((f <<= 1) <= *++xp)\n                break;          /* enough codes to use up j bits */\n              f -= *xp;         /* else deduct codes from patterns */\n            }\n        }\n        z = 1 << j;             /* table entries for j-bit table */\n\n        /* allocate new table */\n        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */\n          return Z_DATA_ERROR;  /* overflow of MANY */\n        u\u00ddh\u00a8 = q = hp + *hn;\n        *hn += z;\n\n        /* connect to last table, if there is one */\n        if (h)\n        {\n          x\u00ddh\u00a8 = i;             /* save pattern for backing up */\n          r.bits = (Byte)l;     /* bits to dump before this table */\n          r.exop = (Byte)j;     /* bits in this table */\n          j = i >> (w - l);\n          r.base = (uInt)(q - u\u00ddh-1\u00a8 - j);   /* offset to this table */\n          u\u00ddh-1\u00a8\u00ddj\u00a8 = r;        /* connect to last table */\n        }\n        else\n          *t = q;               /* first table is returned result */\n      }\n\n      /* set up table entry in r */\n      r.bits = (Byte)(k - w);\n      if (p >= v + n)\n        r.exop = 128 + 64;      /* out of values--invalid code */\n      else if (*p < s)\n      {\n        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */\n        r.base = *p++;          /* simple code is just the value */\n      }\n      else\n      {\n        r.exop = (Byte)(e\u00dd*p - s\u00a8 + 16 + 64);/* non-simple--look up in lists */\n        r.base = d\u00dd*p++ - s\u00a8;\n      }\n\n      /* fill code-like entries with r */\n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q\u00ddj\u00a8 = r;\n\n      /* backwards increment the k-bit code i */\n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i \u00ac= j;\n      i \u00ac= j;\n\n      /* backup over finished tables */\n      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */\n      while ((i & mask) != x\u00ddh\u00a8)\n      {\n        h--;                    /* don't need to update q */\n        w -= l;\n        mask = (1 << w) - 1;\n      }\n    }\n  }\n\n\n  /* Return Z_BUF_ERROR if we were given an incomplete table */\n  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n}\n\n\nint inflate_trees_bits(c, bb, tb, hp, z)\nuIntf *c;               /* 19 code lengths */\nuIntf *bb;              /* bits tree desired/actual depth */\ninflate_huft * FAR *tb; /* bits tree result */\ninflate_huft *hp;       /* space for trees */\nz_streamp z;            /* for messages */\n{\n  int r;\n  uInt hn = 0;          /* hufts used in space */\n  uIntf *v;             /* work area for huft_build */\n\n  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)\n    return Z_MEM_ERROR;\n  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,\n                 tb, bb, hp, &hn, v);\n  if (r == Z_DATA_ERROR)\n    z->msg = (char*)\"oversubscribed dynamic bit lengths tree\";\n  else if (r == Z_BUF_ERROR || *bb == 0)\n  {\n    z->msg = (char*)\"incomplete dynamic bit lengths tree\";\n    r = Z_DATA_ERROR;\n  }\n  ZFREE(z, v);\n  return r;\n}\n\n\nint inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)\nuInt nl;                /* number of literal/length codes */\nuInt nd;                /* number of distance codes */\nuIntf *c;               /* that many (total) code lengths */\nuIntf *bl;              /* literal desired/actual bit depth */\nuIntf *bd;              /* distance desired/actual bit depth */\ninflate_huft * FAR *tl; /* literal/length tree result */\ninflate_huft * FAR *td; /* distance tree result */\ninflate_huft *hp;       /* space for trees */\nz_streamp z;            /* for messages */\n{\n  int r;\n  uInt hn = 0;          /* hufts used in space */\n  uIntf *v;             /* work area for huft_build */\n\n  /* allocate work area */\n  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n    return Z_MEM_ERROR;\n\n  /* build literal/length tree */\n  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);\n  if (r != Z_OK || *bl == 0)\n  {\n    if (r == Z_DATA_ERROR)\n      z->msg = (char*)\"oversubscribed literal/length tree\";\n    else if (r != Z_MEM_ERROR)\n    {\n      z->msg = (char*)\"incomplete literal/length tree\";\n      r = Z_DATA_ERROR;\n    }\n    ZFREE(z, v);\n    return r;\n  }\n\n  /* build distance tree */\n  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);\n  if (r != Z_OK || (*bd == 0 && nl > 257))\n  {\n    if (r == Z_DATA_ERROR)\n      z->msg = (char*)\"oversubscribed distance tree\";\n    else if (r == Z_BUF_ERROR) {\n#ifdef PKZIP_BUG_WORKAROUND\n      r = Z_OK;\n    }\n#else\n      z->msg = (char*)\"incomplete distance tree\";\n      r = Z_DATA_ERROR;\n    }\n    else if (r != Z_MEM_ERROR)\n    {\n      z->msg = (char*)\"empty distance tree with lengths\";\n      r = Z_DATA_ERROR;\n    }\n    ZFREE(z, v);\n    return r;\n#endif\n  }\n\n  /* done */\n  ZFREE(z, v);\n  return Z_OK;\n}\n\n\n/* build fixed tables only once--keep them here */\n#ifdef BUILDFIXED\nlocal int fixed_built = 0;\n#define FIXEDH 544      /* number of hufts used by fixed tables */\nlocal inflate_huft fixed_mem\u00ddFIXEDH\u00a8;\nlocal uInt fixed_bl;\nlocal uInt fixed_bd;\nlocal inflate_huft *fixed_tl;\nlocal inflate_huft *fixed_td;\n#else\n#include \"inffixed.h\"\n#endif\n\n\nint inflate_trees_fixed(bl, bd, tl, td, z)\nuIntf *bl;               /* literal desired/actual bit depth */\nuIntf *bd;               /* distance desired/actual bit depth */\ninflate_huft * FAR *tl;  /* literal/length tree result */\ninflate_huft * FAR *td;  /* distance tree result */\nz_streamp z;             /* for memory allocation */\n{\n#ifdef BUILDFIXED\n  /* build fixed tables if not already */\n  if (!fixed_built)\n  {\n    int k;              /* temporary variable */\n    uInt f = 0;         /* number of hufts used in fixed_mem */\n    uIntf *c;           /* length list for huft_build */\n    uIntf *v;           /* work area for huft_build */\n\n    /* allocate memory */\n    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n      return Z_MEM_ERROR;\n    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n    {\n      ZFREE(z, c);\n      return Z_MEM_ERROR;\n    }\n\n    /* literal table */\n    for (k = 0; k < 144; k++)\n      c\u00ddk\u00a8 = 8;\n    for (; k < 256; k++)\n      c\u00ddk\u00a8 = 9;\n    for (; k < 280; k++)\n      c\u00ddk\u00a8 = 7;\n    for (; k < 288; k++)\n      c\u00ddk\u00a8 = 8;\n    fixed_bl = 9;\n    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,\n               fixed_mem, &f, v);\n\n    /* distance table */\n    for (k = 0; k < 30; k++)\n      c\u00ddk\u00a8 = 5;\n    fixed_bd = 5;\n    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,\n               fixed_mem, &f, v);\n\n    /* done */\n    ZFREE(z, v);\n    ZFREE(z, c);\n    fixed_built = 1;\n  }\n#endif\n  *bl = fixed_bl;\n  *bd = fixed_bd;\n  *tl = fixed_tl;\n  *td = fixed_td;\n  return Z_OK;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INFUTIL": {"ttr": 775, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* inflate_util.c -- data and routines common to blocks and codes\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n#include \"zutil.h\"\n#include \"infblock.h\"\n#include \"inftrees.h\"\n#include \"infcodes.h\"\n#include \"infutil.h\"\n\nstruct inflate_codes_state {int dummy;}; /* for buggy compilers */\n\n/* And'ing with mask\u00ddn\u00a8 masks the lower n bits */\nuInt inflate_mask\u00dd17\u00a8 = {\n    0x0000,\n    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n};\n\n\n/* copy as much as possible from the sliding window to the output area */\nint inflate_flush(s, z, r)\ninflate_blocks_statef *s;\nz_streamp z;\nint r;\n{\n  uInt n;\n  Bytef *p;\n  Bytef *q;\n\n  /* local copies of source and destination pointers */\n  p = z->next_out;\n  q = s->read;\n\n  /* compute number of bytes to copy as far as end of window */\n  n = (uInt)((q <= s->write ? s->write : s->end) - q);\n  if (n > z->avail_out) n = z->avail_out;\n  if (n && r == Z_BUF_ERROR) r = Z_OK;\n\n  /* update counters */\n  z->avail_out -= n;\n  z->total_out += n;\n\n  /* update check information */\n  if (s->checkfn != Z_NULL)\n    z->adler = s->check = (*s->checkfn)(s->check, q, n);\n\n  /* copy as far as end of window */\n  zmemcpy(p, q, n);\n  p += n;\n  q += n;\n\n  /* see if more to copy at beginning of window */\n  if (q == s->end)\n  {\n    /* wrap pointers */\n    q = s->window;\n    if (s->write == s->end)\n      s->write = s->window;\n\n    /* compute bytes to copy */\n    n = (uInt)(s->write - q);\n    if (n > z->avail_out) n = z->avail_out;\n    if (n && r == Z_BUF_ERROR) r = Z_OK;\n\n    /* update counters */\n    z->avail_out -= n;\n    z->total_out += n;\n\n    /* update check information */\n    if (s->checkfn != Z_NULL)\n      z->adler = s->check = (*s->checkfn)(s->check, q, n);\n\n    /* copy */\n    zmemcpy(p, q, n);\n    p += n;\n    q += n;\n  }\n\n  /* update pointers */\n  z->next_out = p;\n  s->read = q;\n\n  /* done */\n  return r;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKETREE": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* maketree.c -- make inffixed.h table for decoding fixed codes\n * Copyright (C) 1995-2002 Mark Adler\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* WARNING: this file should *not* be used by applications. It is\n   part of the implementation of the compression library and is\n   subject to change. Applications should only use zlib.h.\n */\n\n/* This program is included in the distribution for completeness.\n   You do not need to compile or run this program since inffixed.h\n   is already included in the distribution.  To use this program\n   you need to compile zlib with BUILDFIXED defined and then compile\n   and link this program with the zlib library.  Then the output of\n   this program can be piped to inffixed.h. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"zutil.h\"\n#include \"inftrees.h\"\n\n/* simplify the use of the inflate_huft type with some defines */\n#define exop word.what.Exop\n#define bits word.what.Bits\n\n/* generate initialization table for an inflate_huft structure array */\nvoid maketree(uInt b, inflate_huft *t)\n{\n  int i, e;\n\n  i = 0;\n  while (1)\n  {\n    e = t\u00ddi\u00a8.exop;\n    if (e && (e & (16+64)) == 0)        /* table pointer */\n    {\n      fprintf(stderr, \"maketree: cannot initialize sub-tables!\\n\");\n      exit(1);\n    }\n    if (i % 4 == 0)\n      printf(\"\\n   \");\n    printf(\" {{{%u,%u}},%u}\", t\u00ddi\u00a8.exop, t\u00ddi\u00a8.bits, t\u00ddi\u00a8.base);\n    if (++i == (1<<b))\n      break;\n    putchar(',');\n  }\n  puts(\"\");\n}\n\n/* create the fixed tables in C initialization syntax */\nvoid main(void)\n{\n  int r;\n  uInt bl, bd;\n  inflate_huft *tl, *td;\n  z_stream z;\n\n  z.zalloc = zcalloc;\n  z.opaque = (voidpf)0;\n  z.zfree = zcfree;\n  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);\n  if (r)\n  {\n    fprintf(stderr, \"inflate_trees_fixed error %d\\n\", r);\n    return;\n  }\n  puts(\"/* inffixed.h -- table for decoding fixed codes\");\n  puts(\" * Generated automatically by the maketree.c program\");\n  puts(\" */\");\n  puts(\"\");\n  puts(\"/* WARNING: this file should *not* be used by applications. It is\");\n  puts(\"   part of the implementation of the compression library and is\");\n  puts(\"   subject to change. Applications should only use zlib.h.\");\n  puts(\" */\");\n  puts(\"\");\n  printf(\"local uInt fixed_bl = %d;\\n\", bl);\n  printf(\"local uInt fixed_bd = %d;\\n\", bd);\n  printf(\"local inflate_huft fixed_tl\u00dd\u00a8 = {\");\n  maketree(bl, tl);\n  puts(\"  };\");\n  printf(\"local inflate_huft fixed_td\u00dd\u00a8 = {\");\n  maketree(bd, td);\n  puts(\"  };\");\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MINIGZIP": {"ttr": 779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* minigzip.c -- simulate gzip using the zlib compression library\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n * minigzip is a minimal implementation of the gzip utility. This is\n * only an example of using zlib and isn't meant to replace the\n * full-featured gzip. No attempt is made to deal with file systems\n * limiting names to 14 or 8+3 characters, etc... Error checking is\n * very limited. So use minigzip only for testing; use gzip for the\n * real thing. On MSDOS, use only on file names without extension\n * or in pipe mode.\n */\n\n/* @(#) $Id$ */\n\n#include <stdio.h>\n#include \"zlib.h\"\n\n#ifdef STDC\n#  include <string.h>\n#  include <stdlib.h>\n#else\n   extern void exit  OF((int));\n#endif\n\n#ifdef USE_MMAP\n#  include <sys/types.h>\n#  include <sys/mman.h>\n#  include <sys/stat.h>\n#endif\n\n#if defined(MSDOS) || defined(OS2) || defined(WIN32)\n#  include <fcntl.h>\n#  include <io.h>\n#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)\n#else\n#  define SET_BINARY_MODE(file)\n#endif\n\n#ifdef VMS\n#  define unlink delete\n#  define GZ_SUFFIX \"-gz\"\n#endif\n#ifdef RISCOS\n#  define unlink remove\n#  define GZ_SUFFIX \"-gz\"\n#  define fileno(file) file->__file\n#endif\n#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n#  include <unix.h> /* for fileno */\n#endif\n\n#ifndef WIN32 /* unlink already in stdio.h for WIN32 */\n  extern int unlink OF((const char *));\n#endif\n\n#ifndef GZ_SUFFIX\n#  define GZ_SUFFIX \".gz\"\n#endif\n#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)\n\n#define BUFLEN      16384\n#define MAX_NAME_LEN 1024\n\n#ifdef MAXSEG_64K\n#  define local static\n   /* Needed for systems with limitation on stack size. */\n#else\n#  define local\n#endif\n\nchar *prog;\n\nvoid error            OF((const char *msg));\nvoid gz_compress      OF((FILE   *in, gzFile out));\n#ifdef USE_MMAP\nint  gz_compress_mmap OF((FILE   *in, gzFile out));\n#endif\nvoid gz_uncompress    OF((gzFile in, FILE   *out));\nvoid file_compress    OF((char  *file, char *mode));\nvoid file_uncompress  OF((char  *file));\nint  main             OF((int argc, char *argv\u00dd\u00a8));\n\n/* ===========================================================================\n * Display error message and exit\n */\nvoid error(msg)\n    const char *msg;\n{\n    fprintf(stderr, \"%s: %s\\n\", prog, msg);\n    exit(1);\n}\n\n/* ===========================================================================\n * Compress input to output then close both files.\n */\n\nvoid gz_compress(in, out)\n    FILE   *in;\n    gzFile out;\n{\n    local char buf\u00ddBUFLEN\u00a8;\n    int len;\n    int err;\n\n#ifdef USE_MMAP\n    /* Try first compressing with mmap. If mmap fails (minigzip used in a\n     * pipe), use the normal fread loop.\n     */\n    if (gz_compress_mmap(in, out) == Z_OK) return;\n#endif\n    for (;;) {\n        len = fread(buf, 1, sizeof(buf), in);\n        if (ferror(in)) {\n            perror(\"fread\");\n            exit(1);\n        }\n        if (len == 0) break;\n\n        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));\n    }\n    fclose(in);\n    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n}\n\n#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */\n\n/* Try compressing the input file at once using mmap. Return Z_OK if\n * if success, Z_ERRNO otherwise.\n */\nint gz_compress_mmap(in, out)\n    FILE   *in;\n    gzFile out;\n{\n    int len;\n    int err;\n    int ifd = fileno(in);\n    caddr_t buf;    /* mmap'ed buffer for the entire input file */\n    off_t buf_len;  /* length of the input file */\n    struct stat sb;\n\n    /* Determine the size of the file, needed for mmap: */\n    if (fstat(ifd, &sb) < 0) return Z_ERRNO;\n    buf_len = sb.st_size;\n    if (buf_len <= 0) return Z_ERRNO;\n\n    /* Now do the actual mmap: */\n    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);\n    if (buf == (caddr_t)(-1)) return Z_ERRNO;\n\n    /* Compress the whole file at once: */\n    len = gzwrite(out, (char *)buf, (unsigned)buf_len);\n\n    if (len != (int)buf_len) error(gzerror(out, &err));\n\n    munmap(buf, buf_len);\n    fclose(in);\n    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n    return Z_OK;\n}\n#endif /* USE_MMAP */\n\n/* ===========================================================================\n * Uncompress input to output then close both files.\n */\nvoid gz_uncompress(in, out)\n    gzFile in;\n    FILE   *out;\n{\n    local char buf\u00ddBUFLEN\u00a8;\n    int len;\n    int err;\n\n    for (;;) {\n        len = gzread(in, buf, sizeof(buf));\n        if (len < 0) error (gzerror(in, &err));\n        if (len == 0) break;\n\n        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {\n\t    error(\"failed fwrite\");\n\t}\n    }\n    if (fclose(out)) error(\"failed fclose\");\n\n    if (gzclose(in) != Z_OK) error(\"failed gzclose\");\n}\n\n\n/* ===========================================================================\n * Compress the given file: create a corresponding .gz file and remove the\n * original.\n */\nvoid file_compress(file, mode)\n    char  *file;\n    char  *mode;\n{\n    local char outfile\u00ddMAX_NAME_LEN\u00a8;\n    FILE  *in;\n    gzFile out;\n\n    strcpy(outfile, file);\n    strcat(outfile, GZ_SUFFIX);\n\n    in = fopen(file, \"rb\");\n    if (in == NULL) {\n        perror(file);\n        exit(1);\n    }\n    out = gzopen(outfile, mode);\n    if (out == NULL) {\n        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, outfile);\n        exit(1);\n    }\n    gz_compress(in, out);\n\n    unlink(file);\n}\n\n\n/* ===========================================================================\n * Uncompress the given file and remove the original.\n */\nvoid file_uncompress(file)\n    char  *file;\n{\n    local char buf\u00ddMAX_NAME_LEN\u00a8;\n    char *infile, *outfile;\n    FILE  *out;\n    gzFile in;\n    int len = strlen(file);\n\n    strcpy(buf, file);\n\n    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {\n        infile = file;\n        outfile = buf;\n        outfile\u00ddlen-3\u00a8 = '\\0';\n    } else {\n        outfile = file;\n        infile = buf;\n        strcat(infile, GZ_SUFFIX);\n    }\n    in = gzopen(infile, \"rb\");\n    if (in == NULL) {\n        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, infile);\n        exit(1);\n    }\n    out = fopen(outfile, \"wb\");\n    if (out == NULL) {\n        perror(file);\n        exit(1);\n    }\n\n    gz_uncompress(in, out);\n\n    unlink(infile);\n}\n\n\n/* ===========================================================================\n * Usage:  minigzip \u00dd-d\u00a8 \u00dd-f\u00a8 \u00dd-h\u00a8 \u00dd-1 to -9\u00a8 \u00ddfiles...\u00a8\n *   -d : decompress\n *   -f : compress with Z_FILTERED\n *   -h : compress with Z_HUFFMAN_ONLY\n *   -1 to -9 : compression level\n */\n\nint main(argc, argv)\n    int argc;\n    char *argv\u00dd\u00a8;\n{\n    int uncompr = 0;\n    gzFile file;\n    char outmode\u00dd20\u00a8;\n\n    strcpy(outmode, \"wb6 \");\n\n    prog = argv\u00dd0\u00a8;\n    argc--, argv++;\n\n    while (argc > 0) {\n      if (strcmp(*argv, \"-d\") == 0)\n\tuncompr = 1;\n      else if (strcmp(*argv, \"-f\") == 0)\n\toutmode\u00dd3\u00a8 = 'f';\n      else if (strcmp(*argv, \"-h\") == 0)\n\toutmode\u00dd3\u00a8 = 'h';\n      else if ((*argv)\u00dd0\u00a8 == '-' && (*argv)\u00dd1\u00a8 >= '1' && (*argv)\u00dd1\u00a8 <= '9' &&\n\t       (*argv)\u00dd2\u00a8 == 0)\n\toutmode\u00dd2\u00a8 = (*argv)\u00dd1\u00a8;\n      else\n\tbreak;\n      argc--, argv++;\n    }\n    if (argc == 0) {\n        SET_BINARY_MODE(stdin);\n        SET_BINARY_MODE(stdout);\n        if (uncompr) {\n            file = gzdopen(fileno(stdin), \"rb\");\n            if (file == NULL) error(\"can't gzdopen stdin\");\n            gz_uncompress(file, stdout);\n        } else {\n            file = gzdopen(fileno(stdout), outmode);\n            if (file == NULL) error(\"can't gzdopen stdout\");\n            gz_compress(stdin, file);\n        }\n    } else {\n        do {\n            if (uncompr) {\n                file_uncompress(*argv);\n            } else {\n                file_compress(*argv, outmode);\n            }\n        } while (argv++, --argc);\n    }\n    exit(0);\n    return 0; /* to avoid warning */\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "README": {"ttr": 1283, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "zlib 1.1.4 is a general purpose data compression library.  All the code\nis thread safe.  The data format used by the zlib library\nis described by RFCs (Request for Comments) 1950 to 1952 in the files\nhttp://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate\nformat) and rfc1952.txt (gzip format). These documents are also available in\nother formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html\n\nAll functions of the compression library are documented in the file zlib.h\n(volunteer to write man pages welcome, contact jloup@gzip.org). A usage\nexample of the library is given in the file example.c which also tests that\nthe library is working correctly. Another example is given in the file\nminigzip.c. The compression library itself is composed of all source files\nexcept example.c and minigzip.c.\n\nTo compile all files and run the test program, follow the instructions\ngiven at the top of Makefile. In short \"make test; make install\"\nshould work for most machines. For Unix: \"./configure; make test; make install\"\nFor MSDOS, use one of the special makefiles such as Makefile.msc.\nFor VMS, use Make_vms.com or descrip.mms.\n\nQuestions about zlib should be sent to <zlib@gzip.org>, or to\nGilles Vollant <info@winimage.com> for the Windows DLL version.\nThe zlib home page is http://www.zlib.org or http://www.gzip.org/zlib/\nBefore reporting a problem, please check this site to verify that\nyou have the latest version of zlib; otherwise get the latest version and\ncheck whether the problem still exists or not.\n\nPLEASE read the zlib FAQ http://www.gzip.org/zlib/zlib_faq.html\nbefore asking for help.\n\nMark Nelson <markn@ieee.org> wrote an article about zlib for the Jan. 1997\nissue of  Dr. Dobb's Journal; a copy of the article is available in\nhttp://dogma.net/markn/articles/zlibtool/zlibtool.htm\n\nThe changes made in version 1.1.4 are documented in the file ChangeLog.\nThe only changes made since 1.1.3 are bug corrections:\n\n- ZFREE was repeated on same allocation on some error conditions.\n  This creates a security problem described in\n  http://www.zlib.org/advisory-2002-03-11.txt\n- Returned incorrect error (Z_MEM_ERROR) on some invalid data\n- Avoid accesses before window for invalid distances with inflate window\n  less than 32K.\n- force windowBits > 8 to avoid a bug in the encoder for a window size\n  of 256 bytes. (A complete fix will be available in 1.1.5).\n\nThe beta version 1.1.5beta includes many more changes. A new official\nversion 1.1.5 will be released as soon as extensive testing has been\ncompleted on it.\n\n\nUnsupported third party contributions are provided in directory \"contrib\".\n\nA Java implementation of zlib is available in the Java Development Kit\nhttp://www.javasoft.com/products/JDK/1.1/docs/api/Package-java.util.zip.html\nSee the zlib home page http://www.zlib.org for details.\n\nA Perl interface to zlib written by Paul Marquess <pmarquess@bfsec.bt.co.uk>\nis in the CPAN (Comprehensive Perl Archive Network) sites\nhttp://www.cpan.org/modules/by-module/Compress/\n\nA Python interface to zlib written by A.M. Kuchling <amk@magnet.com>\nis available in Python 1.5 and later versions, see\nhttp://www.python.org/doc/lib/module-zlib.html\n\nA zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com>\nis availlable at http://www.westend.com/~kupries/doc/trf/man/man.html\n\nAn experimental package to read and write files in .zip format,\nwritten on top of zlib by Gilles Vollant <info@winimage.com>, is\navailable at http://www.winimage.com/zLibDll/unzip.html\nand also in the contrib/minizip directory of zlib.\n\n\nNotes for some targets:\n\n- To build a Windows DLL version, include in a DLL project zlib.def, zlib.rc\n  and all .c files except example.c and minigzip.c; compile with -DZLIB_DLL\n  The zlib DLL support was initially done by Alessandro Iacopetti and is\n  now maintained by Gilles Vollant <info@winimage.com>. Check the zlib DLL\n  home page at http://www.winimage.com/zLibDll\n\n  From Visual Basic, you can call the DLL functions which do not take\n  a structure as argument: compress, uncompress and all gz* functions.\n  See contrib/visual-basic.txt for more information, or get\n  http://www.tcfb.com/dowseware/cmp-z-it.zip\n\n- For 64-bit Irix, deflate.c must be compiled without any optimization.\n  With -O, one libpng test fails. The test works in 32 bit mode (with\n  the -n32 compiler flag). The compiler bug has been reported to SGI.\n\n- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1\n  it works when compiled with cc.\n\n- on Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1\n  is necessary to get gzprintf working correctly. This is done by configure.\n\n- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works\n  with other compilers. Use \"make test\" to check your compiler.\n\n- gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.\n\n- For Turbo C the small model is supported only with reduced performance to\n  avoid any far allocation; it was tested with -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3\n\n- For PalmOs, see http://www.cs.uit.no/~perm/PASTA/pilot/software.html\n  Per Harald Myrvang <perm@stud.cs.uit.no>\n\n\nAcknowledgments:\n\n  The deflate format used by zlib was defined by Phil Katz. The deflate\n  and zlib specifications were written by L. Peter Deutsch. Thanks to all the\n  people who reported problems and suggested various improvements in zlib;\n  they are too numerous to cite here.\n\nCopyright notice:\n\n (C) 1995-2002 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\nIf you use the zlib library in a product, we would appreciate *not*\nreceiving lengthy legal documents to sign. The sources are provided\nfor free but without warranty of any kind.  The library has been\nentirely written by Jean-loup Gailly and Mark Adler; it does not\ninclude third-party code.\n\nIf you redistribute modified sources, we would appreciate that you include\nin the file ChangeLog history information documenting your changes.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TREES": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* trees.c -- output deflated data using Huffman coding\n * Copyright (C) 1995-2002 Jean-loup Gailly\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/*\n *  ALGORITHM\n *\n *      The \"deflation\" process uses several Huffman trees. The more\n *      common source values are represented by shorter bit sequences.\n *\n *      Each code tree is stored in a compressed form which is itself\n * a Huffman encoding of the lengths of all the code strings (in\n * ascending order by source values).  The actual code strings are\n * reconstructed from the lengths in the inflate process, as described\n * in the deflate specification.\n *\n *  REFERENCES\n *\n *      Deutsch, L.P.,\"'Deflate' Compressed Data Format Specification\".\n *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc\n *\n *      Storer, James A.\n *          Data Compression:  Methods and Theory, pp. 49-50.\n *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.\n *\n *      Sedgewick, R.\n *          Algorithms, p290.\n *          Addison-Wesley, 1983. ISBN 0-201-06672-6.\n */\n\n/* @(#) $Id$ */\n\n/* #define GEN_TREES_H */\n\n#include \"deflate.h\"\n\n#ifdef DEBUG\n#  include <ctype.h>\n#endif\n\n/* ===========================================================================\n * Constants\n */\n\n#define MAX_BL_BITS 7\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\n#define END_BLOCK 256\n/* end of block literal code */\n\n#define REP_3_6      16\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n#define REPZ_3_10    17\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n#define REPZ_11_138  18\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nlocal const int extra_lbits\u00ddLENGTH_CODES\u00a8 /* extra bits for each length code */\n   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};\n\nlocal const int extra_dbits\u00ddD_CODES\u00a8 /* extra bits for each distance code */\n   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nlocal const int extra_blbits\u00ddBL_CODES\u00a8/* extra bits for each bit length code */\n   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};\n\nlocal const uch bl_order\u00ddBL_CODES\u00a8\n   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n#define Buf_size (8 * 2*sizeof(char))\n/* Number of bits used within bi_buf. (bi_buf might be implemented on\n * more than 16 bits on some systems.)\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n#define DIST_CODE_LEN  512 /* see definition of array dist_code below */\n\n#if defined(GEN_TREES_H) || !defined(STDC)\n/* non ANSI compilers may not accept trees.h */\n\nlocal ct_data static_ltree\u00ddL_CODES+2\u00a8;\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nlocal ct_data static_dtree\u00ddD_CODES\u00a8;\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nuch _dist_code\u00ddDIST_CODE_LEN\u00a8;\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nuch _length_code\u00ddMAX_MATCH-MIN_MATCH+1\u00a8;\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nlocal int base_length\u00ddLENGTH_CODES\u00a8;\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nlocal int base_dist\u00ddD_CODES\u00a8;\n/* First normalized distance for each code (0 = distance of 1) */\n\n#else\n#  include \"trees.h\"\n#endif /* GEN_TREES_H */\n\nstruct static_tree_desc_s {\n    const ct_data *static_tree;  /* static tree or NULL */\n    const intf *extra_bits;      /* extra bits for each code or NULL */\n    int     extra_base;          /* base index for extra_bits */\n    int     elems;               /* max number of elements in the tree */\n    int     max_length;          /* max bit length for the codes */\n};\n\nlocal static_tree_desc  static_l_desc =\n{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};\n\nlocal static_tree_desc  static_d_desc =\n{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};\n\nlocal static_tree_desc  static_bl_desc =\n{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};\n\n/* ===========================================================================\n * Local (static) routines in this file.\n */\n\nlocal void tr_static_init OF((void));\nlocal void init_block     OF((deflate_state *s));\nlocal void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));\nlocal void gen_bitlen     OF((deflate_state *s, tree_desc *desc));\nlocal void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));\nlocal void build_tree     OF((deflate_state *s, tree_desc *desc));\nlocal void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));\nlocal void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));\nlocal int  build_bl_tree  OF((deflate_state *s));\nlocal void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,\n                              int blcodes));\nlocal void compress_block OF((deflate_state *s, ct_data *ltree,\n                              ct_data *dtree));\nlocal void set_data_type  OF((deflate_state *s));\nlocal unsigned bi_reverse OF((unsigned value, int length));\nlocal void bi_windup      OF((deflate_state *s));\nlocal void bi_flush       OF((deflate_state *s));\nlocal void copy_block     OF((deflate_state *s, charf *buf, unsigned len,\n                              int header));\n\n#ifdef GEN_TREES_H\nlocal void gen_trees_header OF((void));\n#endif\n\n#ifndef DEBUG\n#  define send_code(s, c, tree) send_bits(s, tree\u00ddc\u00a8.Code, tree\u00ddc\u00a8.Len)\n   /* Send a code of the given tree. c and tree must not have side effects */\n\n#else /* DEBUG */\n#  define send_code(s, c, tree) \\\n     { if (z_verbose>2) fprintf(stderr,\"\\ncd %3d \",(c)); \\\n       send_bits(s, tree\u00ddc\u00a8.Code, tree\u00ddc\u00a8.Len); }\n#endif\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\n#define put_short(s, w) { \\\n    put_byte(s, (uch)((w) & 0xff)); \\\n    put_byte(s, (uch)((ush)(w) >> 8)); \\\n}\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\n#ifdef DEBUG\nlocal void send_bits      OF((deflate_state *s, int value, int length));\n\nlocal void send_bits(s, value, length)\n    deflate_state *s;\n    int value;  /* value to send */\n    int length; /* number of bits */\n{\n    Tracevv((stderr,\" l %2d v %4x \", length, value));\n    Assert(length > 0 && length <= 15, \"invalid length\");\n    s->bits_sent += (ulg)length;\n\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n     * unused bits in value.\n     */\n    if (s->bi_valid > (int)Buf_size - length) {\n        s->bi_buf |= (value << s->bi_valid);\n        put_short(s, s->bi_buf);\n        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);\n        s->bi_valid += length - Buf_size;\n    } else {\n        s->bi_buf |= value << s->bi_valid;\n        s->bi_valid += length;\n    }\n}\n#else /* !DEBUG */\n\n#define send_bits(s, value, length) \\\n{ int len = length;\\\n  if (s->bi_valid > (int)Buf_size - len) {\\\n    int val = value;\\\n    s->bi_buf |= (val << s->bi_valid);\\\n    put_short(s, s->bi_buf);\\\n    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\\\n    s->bi_valid += len - Buf_size;\\\n  } else {\\\n    s->bi_buf |= (value) << s->bi_valid;\\\n    s->bi_valid += len;\\\n  }\\\n}\n#endif /* DEBUG */\n\n\n#define MAX(a,b) (a >= b ? a : b)\n/* the arguments must not have side effects */\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nlocal void tr_static_init()\n{\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count\u00ddMAX_BITS+1\u00a8;\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length\u00ddcode\u00a8 = length;\n        for (n = 0; n < (1<<extra_lbits\u00ddcode\u00a8); n++) {\n            _length_code\u00ddlength++\u00a8 = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code\u00dd255\u00a8 to use the best encoding:\n     */\n    _length_code\u00ddlength-1\u00a8 = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist\u00ddcode\u00a8 = dist;\n        for (n = 0; n < (1<<extra_dbits\u00ddcode\u00a8); n++) {\n            _dist_code\u00dddist++\u00a8 = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist\u00ddcode\u00a8 = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits\u00ddcode\u00a8-7)); n++) {\n            _dist_code\u00dd256 + dist++\u00a8 = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count\u00ddbits\u00a8 = 0;\n    n = 0;\n    while (n <= 143) static_ltree\u00ddn++\u00a8.Len = 8, bl_count\u00dd8\u00a8++;\n    while (n <= 255) static_ltree\u00ddn++\u00a8.Len = 9, bl_count\u00dd9\u00a8++;\n    while (n <= 279) static_ltree\u00ddn++\u00a8.Len = 7, bl_count\u00dd7\u00a8++;\n    while (n <= 287) static_ltree\u00ddn++\u00a8.Len = 8, bl_count\u00dd8\u00a8++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree\u00ddn\u00a8.Len = 5;\n        static_dtree\u00ddn\u00a8.Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}\n\n/* ===========================================================================\n * Genererate the file trees.h describing the static trees.\n */\n#ifdef GEN_TREES_H\n#  ifndef DEBUG\n#    include <stdio.h>\n#  endif\n\n#  define SEPARATOR(i, last, width) \\\n      ((i) == (last)? \"\\n};\\n\\n\" :    \\\n       ((i) % (width) == (width)-1 ? \",\\n\" : \", \"))\n\nvoid gen_trees_header()\n{\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header != NULL, \"Can't open trees.h\");\n    fprintf(header,\n\t    \"/* header created automatically with -DGEN_TREES_H */\\n\\n\");\n\n    fprintf(header, \"local const ct_data static_ltree\u00ddL_CODES+2\u00a8 = {\\n\");\n    for (i = 0; i < L_CODES+2; i++) {\n\tfprintf(header, \"{{%3u},{%3u}}%s\", static_ltree\u00ddi\u00a8.Code,\n\t\tstatic_ltree\u00ddi\u00a8.Len, SEPARATOR(i, L_CODES+1, 5));\n    }\n\n    fprintf(header, \"local const ct_data static_dtree\u00ddD_CODES\u00a8 = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n\tfprintf(header, \"{{%2u},{%2u}}%s\", static_dtree\u00ddi\u00a8.Code,\n\t\tstatic_dtree\u00ddi\u00a8.Len, SEPARATOR(i, D_CODES-1, 5));\n    }\n\n    fprintf(header, \"const uch _dist_code\u00ddDIST_CODE_LEN\u00a8 = {\\n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) {\n\tfprintf(header, \"%2u%s\", _dist_code\u00ddi\u00a8,\n\t\tSEPARATOR(i, DIST_CODE_LEN-1, 20));\n    }\n\n    fprintf(header, \"const uch _length_code\u00ddMAX_MATCH-MIN_MATCH+1\u00a8= {\\n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {\n\tfprintf(header, \"%2u%s\", _length_code\u00ddi\u00a8,\n\t\tSEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    }\n\n    fprintf(header, \"local const int base_length\u00ddLENGTH_CODES\u00a8 = {\\n\");\n    for (i = 0; i < LENGTH_CODES; i++) {\n\tfprintf(header, \"%1u%s\", base_length\u00ddi\u00a8,\n\t\tSEPARATOR(i, LENGTH_CODES-1, 20));\n    }\n\n    fprintf(header, \"local const int base_dist\u00ddD_CODES\u00a8 = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n\tfprintf(header, \"%5u%s\", base_dist\u00ddi\u00a8,\n\t\tSEPARATOR(i, D_CODES-1, 10));\n    }\n\n    fclose(header);\n}\n#endif /* GEN_TREES_H */\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nvoid _tr_init(s)\n    deflate_state *s;\n{\n    tr_static_init();\n\n    s->l_desc.dyn_tree = s->dyn_ltree;\n    s->l_desc.stat_desc = &static_l_desc;\n\n    s->d_desc.dyn_tree = s->dyn_dtree;\n    s->d_desc.stat_desc = &static_d_desc;\n\n    s->bl_desc.dyn_tree = s->bl_tree;\n    s->bl_desc.stat_desc = &static_bl_desc;\n\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n    s->last_eob_len = 8; /* enough lookahead for inflate */\n#ifdef DEBUG\n    s->compressed_len = 0L;\n    s->bits_sent = 0L;\n#endif\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n}\n\n/* ===========================================================================\n * Initialize a new block.\n */\nlocal void init_block(s)\n    deflate_state *s;\n{\n    int n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree\u00ddn\u00a8.Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree\u00ddn\u00a8.Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree\u00ddn\u00a8.Freq = 0;\n\n    s->dyn_ltree\u00ddEND_BLOCK\u00a8.Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}\n\n#define SMALLEST 1\n/* Index within the heap array of least frequent node in the Huffman tree */\n\n\n/* ===========================================================================\n * Remove the smallest element from the heap and recreate the heap with\n * one less element. Updates heap and heap_len.\n */\n#define pqremove(s, tree, top) \\\n{\\\n    top = s->heap\u00ddSMALLEST\u00a8; \\\n    s->heap\u00ddSMALLEST\u00a8 = s->heap\u00dds->heap_len--\u00a8; \\\n    pqdownheap(s, tree, SMALLEST); \\\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\n#define smaller(tree, n, m, depth) \\\n   (tree\u00ddn\u00a8.Freq < tree\u00ddm\u00a8.Freq || \\\n   (tree\u00ddn\u00a8.Freq == tree\u00ddm\u00a8.Freq && depth\u00ddn\u00a8 <= depth\u00ddm\u00a8))\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nlocal void pqdownheap(s, tree, k)\n    deflate_state *s;\n    ct_data *tree;  /* the tree to restore */\n    int k;               /* node to move down */\n{\n    int v = s->heap\u00ddk\u00a8;\n    int j = k << 1;  /* left son of k */\n    while (j <= s->heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s->heap_len &&\n            smaller(tree, s->heap\u00ddj+1\u00a8, s->heap\u00ddj\u00a8, s->depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s->heap\u00ddj\u00a8, s->depth)) break;\n\n        /* Exchange v with the smallest son */\n        s->heap\u00ddk\u00a8 = s->heap\u00ddj\u00a8;  k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n    }\n    s->heap\u00ddk\u00a8 = v;\n}\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap\u00ddheap_max\u00a8 and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nlocal void gen_bitlen(s, desc)\n    deflate_state *s;\n    tree_desc *desc;    /* the tree descriptor */\n{\n    ct_data *tree        = desc->dyn_tree;\n    int max_code         = desc->max_code;\n    const ct_data *stree = desc->stat_desc->static_tree;\n    const intf *extra    = desc->stat_desc->extra_bits;\n    int base             = desc->stat_desc->extra_base;\n    int max_length       = desc->stat_desc->max_length;\n    int h;              /* heap index */\n    int n, m;           /* iterate over the tree elements */\n    int bits;           /* bit length */\n    int xbits;          /* extra bits */\n    ush f;              /* frequency */\n    int overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count\u00ddbits\u00a8 = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree\u00dds->heap\u00dds->heap_max\u00a8\u00a8.Len = 0; /* root of the heap */\n\n    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {\n        n = s->heap\u00ddh\u00a8;\n        bits = tree\u00ddtree\u00ddn\u00a8.Dad\u00a8.Len + 1;\n        if (bits > max_length) bits = max_length, overflow++;\n        tree\u00ddn\u00a8.Len = (ush)bits;\n        /* We overwrite tree\u00ddn\u00a8.Dad which is no longer needed */\n\n        if (n > max_code) continue; /* not a leaf node */\n\n        s->bl_count\u00ddbits\u00a8++;\n        xbits = 0;\n        if (n >= base) xbits = extra\u00ddn-base\u00a8;\n        f = tree\u00ddn\u00a8.Freq;\n        s->opt_len += (ulg)f * (bits + xbits);\n        if (stree) s->static_len += (ulg)f * (stree\u00ddn\u00a8.Len + xbits);\n    }\n    if (overflow == 0) return;\n\n    Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n        bits = max_length-1;\n        while (s->bl_count\u00ddbits\u00a8 == 0) bits--;\n        s->bl_count\u00ddbits\u00a8--;      /* move one leaf down the tree */\n        s->bl_count\u00ddbits+1\u00a8 += 2; /* move one overflow item as its brother */\n        s->bl_count\u00ddmax_length\u00a8--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count\u00ddmax_length\u00a8\n         */\n        overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits != 0; bits--) {\n        n = s->bl_count\u00ddbits\u00a8;\n        while (n != 0) {\n            m = s->heap\u00dd--h\u00a8;\n            if (m > max_code) continue;\n            if (tree\u00ddm\u00a8.Len != (unsigned) bits) {\n                Trace((stderr,\"code %d bits %d->%d\\n\", m, tree\u00ddm\u00a8.Len, bits));\n                s->opt_len += ((long)bits - (long)tree\u00ddm\u00a8.Len)\n                              *(long)tree\u00ddm\u00a8.Freq;\n                tree\u00ddm\u00a8.Len = (ush)bits;\n            }\n            n--;\n        }\n    }\n}\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nlocal void gen_codes (tree, max_code, bl_count)\n    ct_data *tree;             /* the tree to decorate */\n    int max_code;              /* largest code with non zero frequency */\n    ushf *bl_count;            /* number of codes at each bit length */\n{\n    ush next_code\u00ddMAX_BITS+1\u00a8; /* next code value for each bit length */\n    ush code = 0;              /* running code value */\n    int bits;                  /* bit index */\n    int n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code\u00ddbits\u00a8 = code = (code + bl_count\u00ddbits-1\u00a8) << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    Assert (code + bl_count\u00ddMAX_BITS\u00a8-1 == (1<<MAX_BITS)-1,\n            \"inconsistent bit counts\");\n    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n        int len = tree\u00ddn\u00a8.Len;\n        if (len == 0) continue;\n        /* Now reverse the bits */\n        tree\u00ddn\u00a8.Code = bi_reverse(next_code\u00ddlen\u00a8++, len);\n\n        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n             n, (isgraph(n) ? n : ' '), len, tree\u00ddn\u00a8.Code, next_code\u00ddlen\u00a8-1));\n    }\n}\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nlocal void build_tree(s, desc)\n    deflate_state *s;\n    tree_desc *desc; /* the tree descriptor */\n{\n    ct_data *tree         = desc->dyn_tree;\n    const ct_data *stree  = desc->stat_desc->static_tree;\n    int elems             = desc->stat_desc->elems;\n    int n, m;          /* iterate over heap elements */\n    int max_code = -1; /* largest code with non zero frequency */\n    int node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap\u00ddSMALLEST\u00a8. The sons of heap\u00ddn\u00a8 are heap\u00dd2*n\u00a8 and heap\u00dd2*n+1\u00a8.\n     * heap\u00dd0\u00a8 is not used.\n     */\n    s->heap_len = 0, s->heap_max = HEAP_SIZE;\n\n    for (n = 0; n < elems; n++) {\n        if (tree\u00ddn\u00a8.Freq != 0) {\n            s->heap\u00dd++(s->heap_len)\u00a8 = max_code = n;\n            s->depth\u00ddn\u00a8 = 0;\n        } else {\n            tree\u00ddn\u00a8.Len = 0;\n        }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s->heap_len < 2) {\n        node = s->heap\u00dd++(s->heap_len)\u00a8 = (max_code < 2 ? ++max_code : 0);\n        tree\u00ddnode\u00a8.Freq = 1;\n        s->depth\u00ddnode\u00a8 = 0;\n        s->opt_len--; if (stree) s->static_len -= stree\u00ddnode\u00a8.Len;\n        /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc->max_code = max_code;\n\n    /* The elements heap\u00ddheap_len/2+1 .. heap_len\u00a8 are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n        pqremove(s, tree, n);  /* n = node of least frequency */\n        m = s->heap\u00ddSMALLEST\u00a8; /* m = node of next least frequency */\n\n        s->heap\u00dd--(s->heap_max)\u00a8 = n; /* keep the nodes sorted by frequency */\n        s->heap\u00dd--(s->heap_max)\u00a8 = m;\n\n        /* Create a new node father of n and m */\n        tree\u00ddnode\u00a8.Freq = tree\u00ddn\u00a8.Freq + tree\u00ddm\u00a8.Freq;\n        s->depth\u00ddnode\u00a8 = (uch) (MAX(s->depth\u00ddn\u00a8, s->depth\u00ddm\u00a8) + 1);\n        tree\u00ddn\u00a8.Dad = tree\u00ddm\u00a8.Dad = (ush)node;\n#ifdef DUMP_BL_TREE\n        if (tree == s->bl_tree) {\n            fprintf(stderr,\"\\nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree\u00ddnode\u00a8.Freq, n, tree\u00ddn\u00a8.Freq, m, tree\u00ddm\u00a8.Freq);\n        }\n#endif\n        /* and insert the new node in the heap */\n        s->heap\u00ddSMALLEST\u00a8 = node++;\n        pqdownheap(s, tree, SMALLEST);\n\n    } while (s->heap_len >= 2);\n\n    s->heap\u00dd--(s->heap_max)\u00a8 = s->heap\u00ddSMALLEST\u00a8;\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, (tree_desc *)desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes ((ct_data *)tree, max_code, s->bl_count);\n}\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nlocal void scan_tree (s, tree, max_code)\n    deflate_state *s;\n    ct_data *tree;   /* the tree to be scanned */\n    int max_code;    /* and its largest code of non zero frequency */\n{\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree\u00dd0\u00a8.Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    if (nextlen == 0) max_count = 138, min_count = 3;\n    tree\u00ddmax_code+1\u00a8.Len = (ush)0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree\u00ddn+1\u00a8.Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s->bl_tree\u00ddcurlen\u00a8.Freq += count;\n        } else if (curlen != 0) {\n            if (curlen != prevlen) s->bl_tree\u00ddcurlen\u00a8.Freq++;\n            s->bl_tree\u00ddREP_3_6\u00a8.Freq++;\n        } else if (count <= 10) {\n            s->bl_tree\u00ddREPZ_3_10\u00a8.Freq++;\n        } else {\n            s->bl_tree\u00ddREPZ_11_138\u00a8.Freq++;\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nlocal void send_tree (s, tree, max_code)\n    deflate_state *s;\n    ct_data *tree; /* the tree to be scanned */\n    int max_code;       /* and its largest code of non zero frequency */\n{\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree\u00dd0\u00a8.Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    /* tree\u00ddmax_code+1\u00a8.Len = -1; */  /* guard already set */\n    if (nextlen == 0) max_count = 138, min_count = 3;\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree\u00ddn+1\u00a8.Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);\n\n        } else if (curlen != 0) {\n            if (curlen != prevlen) {\n                send_code(s, curlen, s->bl_tree); count--;\n            }\n            Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);\n\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);\n\n        } else {\n            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nlocal int build_bl_tree(s)\n    deflate_state *s;\n{\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);\n    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, (tree_desc *)(&(s->bl_desc)));\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n        if (s->bl_tree\u00ddbl_order\u00ddmax_blindex\u00a8\u00a8.Len != 0) break;\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s->opt_len += 3*(max_blindex+1) + 5+5+4;\n    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n            s->opt_len, s->static_len));\n\n    return max_blindex;\n}\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nlocal void send_all_trees(s, lcodes, dcodes, blcodes)\n    deflate_state *s;\n    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n    int rank;                    /* index in bl_order */\n\n    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n            \"too many codes\");\n    Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes-1,   5);\n    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n        Tracev((stderr, \"\\nbl code %2d \", bl_order\u00ddrank\u00a8));\n        send_bits(s, s->bl_tree\u00ddbl_order\u00ddrank\u00a8\u00a8.Len, 3);\n    }\n    Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */\n    Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */\n    Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n/* ===========================================================================\n * Send a stored block\n */\nvoid _tr_stored_block(s, buf, stored_len, eof)\n    deflate_state *s;\n    charf *buf;       /* input block */\n    ulg stored_len;   /* length of input block */\n    int eof;          /* true if this is the last block for a file */\n{\n    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */\n#ifdef DEBUG\n    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;\n    s->compressed_len += (stored_len + 4) << 3;\n#endif\n    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */\n}\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n * The current inflate code requires 9 bits of lookahead. If the\n * last two codes for the previous block (real code plus EOB) were coded\n * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode\n * the last real code. In this case we send two empty static blocks instead\n * of one. (There are no problems if the previous block is stored or fixed.)\n * To simplify the code, we assume the worst case of last real code encoded\n * on one bit only.\n */\nvoid _tr_align(s)\n    deflate_state *s;\n{\n    send_bits(s, STATIC_TREES<<1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n#ifdef DEBUG\n    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */\n#endif\n    bi_flush(s);\n    /* Of the 10 bits for the empty block, we have already sent\n     * (10 - bi_valid) bits. The lookahead for the last real code (before\n     * the EOB of the previous block) was thus at least one plus the length\n     * of the EOB plus what we have just sent of the empty static block.\n     */\n    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {\n        send_bits(s, STATIC_TREES<<1, 3);\n        send_code(s, END_BLOCK, static_ltree);\n#ifdef DEBUG\n        s->compressed_len += 10L;\n#endif\n        bi_flush(s);\n    }\n    s->last_eob_len = 7;\n}\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nvoid _tr_flush_block(s, buf, stored_len, eof)\n    deflate_state *s;\n    charf *buf;       /* input block, or NULL if too old */\n    ulg stored_len;   /* length of input block */\n    int eof;          /* true if this is the last block for a file */\n{\n    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */\n    int max_blindex = 0;  /* index of last bit length code of non zero freq */\n\n    /* Build the Huffman trees unless a stored block is forced */\n    if (s->level > 0) {\n\n\t /* Check if the file is ascii or binary */\n\tif (s->data_type == Z_UNKNOWN) set_data_type(s);\n\n\t/* Construct the literal and distance trees */\n\tbuild_tree(s, (tree_desc *)(&(s->l_desc)));\n\tTracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n\t\ts->static_len));\n\n\tbuild_tree(s, (tree_desc *)(&(s->d_desc)));\n\tTracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n\t\ts->static_len));\n\t/* At this point, opt_len and static_len are the total bit lengths of\n\t * the compressed block data, excluding the tree representations.\n\t */\n\n\t/* Build the bit length tree for the above two trees, and get the index\n\t * in bl_order of the last bit length code to send.\n\t */\n\tmax_blindex = build_bl_tree(s);\n\n\t/* Determine the best encoding. Compute first the block length in bytes*/\n\topt_lenb = (s->opt_len+3+7)>>3;\n\tstatic_lenb = (s->static_len+3+7)>>3;\n\n\tTracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n\t\topt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n\t\ts->last_lit));\n\n\tif (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n\n    } else {\n        Assert(buf != (char*)0, \"lost buf\");\n\topt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n    }\n\n#ifdef FORCE_STORED\n    if (buf != (char*)0) { /* force stored block */\n#else\n    if (stored_len+4 <= opt_lenb && buf != (char*)0) {\n                       /* 4: two words for the lengths */\n#endif\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, eof);\n\n#ifdef FORCE_STATIC\n    } else if (static_lenb >= 0) { /* force static trees */\n#else\n    } else if (static_lenb == opt_lenb) {\n#endif\n        send_bits(s, (STATIC_TREES<<1)+eof, 3);\n        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);\n#ifdef DEBUG\n        s->compressed_len += 3 + s->static_len;\n#endif\n    } else {\n        send_bits(s, (DYN_TREES<<1)+eof, 3);\n        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,\n                       max_blindex+1);\n        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);\n#ifdef DEBUG\n        s->compressed_len += 3 + s->opt_len;\n#endif\n    }\n    Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2\u00ac32, for files larger than 512 MB\n     * and uLong implemented on 32 bits.\n     */\n    init_block(s);\n\n    if (eof) {\n        bi_windup(s);\n#ifdef DEBUG\n        s->compressed_len += 7;  /* align on byte boundary */\n#endif\n    }\n    Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n           s->compressed_len-7*eof));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nint _tr_tally (s, dist, lc)\n    deflate_state *s;\n    unsigned dist;  /* distance of matched string */\n    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n    s->d_buf\u00dds->last_lit\u00a8 = (ush)dist;\n    s->l_buf\u00dds->last_lit++\u00a8 = (uch)lc;\n    if (dist == 0) {\n        /* lc is the unmatched char */\n        s->dyn_ltree\u00ddlc\u00a8.Freq++;\n    } else {\n        s->matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;             /* dist = match distance - 1 */\n        Assert((ush)dist < (ush)MAX_DIST(s) &&\n               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n               (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s->dyn_ltree\u00dd_length_code\u00ddlc\u00a8+LITERALS+1\u00a8.Freq++;\n        s->dyn_dtree\u00ddd_code(dist)\u00a8.Freq++;\n    }\n\n#ifdef TRUNCATE_BLOCK\n    /* Try to guess if it is profitable to stop the current block here */\n    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {\n        /* Compute an upper bound for the compressed length */\n        ulg out_length = (ulg)s->last_lit*8L;\n        ulg in_length = (ulg)((long)s->strstart - s->block_start);\n        int dcode;\n        for (dcode = 0; dcode < D_CODES; dcode++) {\n            out_length += (ulg)s->dyn_dtree\u00dddcode\u00a8.Freq *\n                (5L+extra_dbits\u00dddcode\u00a8);\n        }\n        out_length >>= 3;\n        Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n               s->last_lit, in_length, out_length,\n               100L - out_length*100L/in_length));\n        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;\n    }\n#endif\n    return (s->last_lit == s->lit_bufsize-1);\n    /* We avoid equality with lit_bufsize because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n}\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nlocal void compress_block(s, ltree, dtree)\n    deflate_state *s;\n    ct_data *ltree; /* literal tree */\n    ct_data *dtree; /* distance tree */\n{\n    unsigned dist;      /* distance of matched string */\n    int lc;             /* match length or unmatched char (if dist == 0) */\n    unsigned lx = 0;    /* running index in l_buf */\n    unsigned code;      /* the code to send */\n    int extra;          /* number of extra bits to send */\n\n    if (s->last_lit != 0) do {\n        dist = s->d_buf\u00ddlx\u00a8;\n        lc = s->l_buf\u00ddlx++\u00a8;\n        if (dist == 0) {\n            send_code(s, lc, ltree); /* send a literal byte */\n            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code\u00ddlc\u00a8;\n            send_code(s, code+LITERALS+1, ltree); /* send the length code */\n            extra = extra_lbits\u00ddcode\u00a8;\n            if (extra != 0) {\n                lc -= base_length\u00ddcode\u00a8;\n                send_bits(s, lc, extra);       /* send the extra length bits */\n            }\n            dist--; /* dist is now the match distance - 1 */\n            code = d_code(dist);\n            Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);       /* send the distance code */\n            extra = extra_dbits\u00ddcode\u00a8;\n            if (extra != 0) {\n                dist -= base_dist\u00ddcode\u00a8;\n                send_bits(s, dist, extra);   /* send the extra distance bits */\n            }\n        } /* literal or match pair ? */\n\n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n        Assert(s->pending < s->lit_bufsize + 2*lx, \"pendingBuf overflow\");\n\n    } while (lx < s->last_lit);\n\n    send_code(s, END_BLOCK, ltree);\n    s->last_eob_len = ltree\u00ddEND_BLOCK\u00a8.Len;\n}\n\n/* ===========================================================================\n * Set the data type to ASCII or BINARY, using a crude approximation:\n * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.\n * IN assertion: the fields freq of dyn_ltree are set and the total of all\n * frequencies does not exceed 64K (to fit in an int on 16 bit machines).\n */\nlocal void set_data_type(s)\n    deflate_state *s;\n{\n    int n = 0;\n    unsigned ascii_freq = 0;\n    unsigned bin_freq = 0;\n    while (n < 7)        bin_freq += s->dyn_ltree\u00ddn++\u00a8.Freq;\n    while (n < 128)    ascii_freq += s->dyn_ltree\u00ddn++\u00a8.Freq;\n    while (n < LITERALS) bin_freq += s->dyn_ltree\u00ddn++\u00a8.Freq;\n    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);\n}\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nlocal unsigned bi_reverse(code, len)\n    unsigned code; /* the value to invert */\n    int len;       /* its bit length */\n{\n    register unsigned res = 0;\n    do {\n        res |= code & 1;\n        code >>= 1, res <<= 1;\n    } while (--len > 0);\n    return res >> 1;\n}\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nlocal void bi_flush(s)\n    deflate_state *s;\n{\n    if (s->bi_valid == 16) {\n        put_short(s, s->bi_buf);\n        s->bi_buf = 0;\n        s->bi_valid = 0;\n    } else if (s->bi_valid >= 8) {\n        put_byte(s, (Byte)s->bi_buf);\n        s->bi_buf >>= 8;\n        s->bi_valid -= 8;\n    }\n}\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nlocal void bi_windup(s)\n    deflate_state *s;\n{\n    if (s->bi_valid > 8) {\n        put_short(s, s->bi_buf);\n    } else if (s->bi_valid > 0) {\n        put_byte(s, (Byte)s->bi_buf);\n    }\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n#ifdef DEBUG\n    s->bits_sent = (s->bits_sent+7) & ~7;\n#endif\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nlocal void copy_block(s, buf, len, header)\n    deflate_state *s;\n    charf    *buf;    /* the input data */\n    unsigned len;     /* its length */\n    int      header;  /* true if block header must be written */\n{\n    bi_windup(s);        /* align on byte boundary */\n    s->last_eob_len = 8; /* enough lookahead for inflate */\n\n    if (header) {\n        put_short(s, (ush)len);\n        put_short(s, (ush)~len);\n#ifdef DEBUG\n        s->bits_sent += 2*16;\n#endif\n    }\n#ifdef DEBUG\n    s->bits_sent += (ulg)len<<3;\n#endif\n    while (len--) {\n        put_byte(s, *buf++);\n    }\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNCOMPR": {"ttr": 1028, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* uncompr.c -- decompress a memory buffer\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zlib.h\"\n\n/* ===========================================================================\n     Decompresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer. Upon entry, destLen is the total\n   size of the destination buffer, which must be large enough to hold the\n   entire uncompressed data. (The size of the uncompressed data must have\n   been saved previously by the compressor and transmitted to the decompressor\n   by some mechanism outside the scope of this compression library.)\n   Upon exit, destLen is the actual size of the compressed buffer.\n     This function can be used to decompress a whole file at once if the\n   input file is mmap'ed.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer, or Z_DATA_ERROR if the input data was corrupted.\n*/\nint ZEXPORT uncompress (dest, destLen, source, sourceLen)\n    Bytef *dest;\n    uLongf *destLen;\n    const Bytef *source;\n    uLong sourceLen;\n{\n    z_stream stream;\n    int err;\n\n    stream.next_in = (Bytef*)source;\n    stream.avail_in = (uInt)sourceLen;\n    /* Check for source > 64K on 16-bit machine: */\n    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;\n\n    stream.next_out = dest;\n    stream.avail_out = (uInt)*destLen;\n    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;\n\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n\n    err = inflateInit(&stream);\n    if (err != Z_OK) return err;\n\n    err = inflate(&stream, Z_FINISH);\n    if (err != Z_STREAM_END) {\n        inflateEnd(&stream);\n        return err == Z_OK ? Z_BUF_ERROR : err;\n    }\n    *destLen = stream.total_out;\n\n    err = inflateEnd(&stream);\n    return err;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZUTIL": {"ttr": 1281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* zutil.c -- target dependent utility functions for the compression library\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h\n */\n\n/* @(#) $Id$ */\n\n#include \"zutil.h\"\n\nstruct internal_state      {int dummy;}; /* for buggy compilers */\n\n#ifndef STDC\nextern void exit OF((int));\n#endif\n\nconst char *z_errmsg\u00dd10\u00a8 = {\n\"need dictionary\",     /* Z_NEED_DICT       2  */\n\"stream end\",          /* Z_STREAM_END      1  */\n\"\",                    /* Z_OK              0  */\n\"file error\",          /* Z_ERRNO         (-1) */\n\"stream error\",        /* Z_STREAM_ERROR  (-2) */\n\"data error\",          /* Z_DATA_ERROR    (-3) */\n\"insufficient memory\", /* Z_MEM_ERROR     (-4) */\n\"buffer error\",        /* Z_BUF_ERROR     (-5) */\n\"incompatible version\",/* Z_VERSION_ERROR (-6) */\n\"\"};\n\n\nconst char * ZEXPORT zlibVersion()\n{\n    return ZLIB_VERSION;\n}\n\n#ifdef DEBUG\n\n#  ifndef verbose\n#    define verbose 0\n#  endif\nint z_verbose = verbose;\n\nvoid z_error (m)\n    char *m;\n{\n    fprintf(stderr, \"%s\\n\", m);\n    exit(1);\n}\n#endif\n\n/* exported to allow conversion of error code to string for compress() and\n * uncompress()\n */\nconst char * ZEXPORT zError(err)\n    int err;\n{\n    return ERR_MSG(err);\n}\n\n\n#ifndef HAVE_MEMCPY\n\nvoid zmemcpy(dest, source, len)\n    Bytef* dest;\n    const Bytef* source;\n    uInt  len;\n{\n    if (len == 0) return;\n    do {\n        *dest++ = *source++; /* ??? to be unrolled */\n    } while (--len != 0);\n}\n\nint zmemcmp(s1, s2, len)\n    const Bytef* s1;\n    const Bytef* s2;\n    uInt  len;\n{\n    uInt j;\n\n    for (j = 0; j < len; j++) {\n        if (s1\u00ddj\u00a8 != s2\u00ddj\u00a8) return 2*(s1\u00ddj\u00a8 > s2\u00ddj\u00a8)-1;\n    }\n    return 0;\n}\n\nvoid zmemzero(dest, len)\n    Bytef* dest;\n    uInt  len;\n{\n    if (len == 0) return;\n    do {\n        *dest++ = 0;  /* ??? to be unrolled */\n    } while (--len != 0);\n}\n#endif\n\n#ifdef __TURBOC__\n#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)\n/* Small and medium model in Turbo C are for now limited to near allocation\n * with reduced MAX_WBITS and MAX_MEM_LEVEL\n */\n#  define MY_ZCALLOC\n\n/* Turbo C malloc() does not allow dynamic allocation of 64K bytes\n * and farmalloc(64K) returns a pointer with an offset of 8, so we\n * must fix the pointer. Warning: the pointer must be put back to its\n * original form in order to free it, use zcfree().\n */\n\n#define MAX_PTR 10\n/* 10*64K = 640K */\n\nlocal int next_ptr = 0;\n\ntypedef struct ptr_table_s {\n    voidpf org_ptr;\n    voidpf new_ptr;\n} ptr_table;\n\nlocal ptr_table table\u00ddMAX_PTR\u00a8;\n/* This table is used to remember the original form of pointers\n * to large buffers (64K). Such pointers are normalized with a zero offset.\n * Since MSDOS is not a preemptive multitasking OS, this table is not\n * protected from concurrent access. This hack doesn't work anyway on\n * a protected system like OS/2. Use Microsoft C instead.\n */\n\nvoidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table\u00ddnext_ptr\u00a8.org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table\u00ddnext_ptr++\u00a8.new_ptr = buf;\n    return buf;\n}\n\nvoid  zcfree (voidpf opaque, voidpf ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table\u00ddn\u00a8.new_ptr) continue;\n\n        farfree(table\u00ddn\u00a8.org_ptr);\n        while (++n < next_ptr) {\n            table\u00ddn-1\u00a8 = table\u00ddn\u00a8;\n        }\n        next_ptr--;\n        return;\n    }\n    ptr = opaque; /* just to make some compilers happy */\n    Assert(0, \"zcfree: ptr not found\");\n}\n#endif\n#endif /* __TURBOC__ */\n\n\n#if defined(M_I86) && !defined(__32BIT__)\n/* Microsoft C in 16-bit mode */\n\n#  define MY_ZCALLOC\n\n#if (!defined(_MSC_VER) || (_MSC_VER <= 600))\n#  define _halloc  halloc\n#  define _hfree   hfree\n#endif\n\nvoidpf zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n}\n\nvoid  zcfree (voidpf opaque, voidpf ptr)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    _hfree(ptr);\n}\n\n#endif /* MSC */\n\n\n#ifndef MY_ZCALLOC /* Any system without a special alloc function */\n\n#ifndef STDC\nextern voidp  calloc OF((uInt items, uInt size));\nextern void   free   OF((voidpf ptr));\n#endif\n\nvoidpf zcalloc (opaque, items, size)\n    voidpf opaque;\n    unsigned items;\n    unsigned size;\n{\n    if (opaque) items += size - size; /* make compiler happy */\n    return (voidpf)calloc(items, size);\n}\n\nvoid  zcfree (opaque, ptr)\n    voidpf opaque;\n    voidpf ptr;\n{\n    free(ptr);\n    if (opaque) return; /* make compiler happy */\n}\n\n#endif /* MY_ZCALLOC */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT541/CBT.V500.FILE541.PDS/X$ZC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT541/CBT.V500.FILE541.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}