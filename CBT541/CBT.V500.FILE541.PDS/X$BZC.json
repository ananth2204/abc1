{"INMR01": {"INMLRECL": 80, "INMFNODE": "TEST", "INMFUID": "RYS", "INMTNODE": "N1", "INMTUID": "RYS", "INMFTIME": "20021222173039000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 3200, "INMRECFM": "VB", "INMDIR": 6, "INMDSNAM": "RYSJSYT.BZLIB.C", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"RYSJSYT.BZLIB.C": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 3200, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "020356", "DS1SCEXT": "b'\\x80\\x0c\\x80'", "DS1SCALO": "b'P\\x00\\x00\\x18'", "DS1LSTAR": "b'\\x00\\x03\\x0e'", "DS1TRBAL": "b'U\\x88'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0b\\x90\\x00\\x04\\x8b]`'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0b\\x90\\x00\\x04\\x8b]`'", "b'X\\xfcD\\xa0\\x00\\x00\\x00\\xd9\\x00\\x05\\x00\\xd9\\x00\\x0b\\x00\\x07'", "b'X\\xfcD\\xa0\\x00\\x00\\x01J\\x00\\x0c\\x01J\\x00\\r\\x00\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"BLKSRT": {"ttr": 8, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*-------------------------------------------------------------*/\n/*--- Block sorting machinery                               ---*/\n/*---                                           blocksort.c ---*/\n/*-------------------------------------------------------------*/\n\n/*--\n  This file is a part of bzip2 and/or libbzip2, a program and\n  library for lossless, block-sorting data compression.\n\n  Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n\n  2. The origin of this software must not be misrepresented; you must\n     not claim that you wrote the original software.  If you use this\n     software in a product, an acknowledgment in the product\n     documentation would be appreciated but is not required.\n\n  3. Altered source versions must be plainly marked as such, and must\n     not be misrepresented as being the original software.\n\n  4. The name of the author may not be used to endorse or promote\n     products derived from this software without specific prior written\n     permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  Julian Seward, Cambridge, UK.\n  jseward@acm.org\n  bzip2/libbzip2 version 1.0 of 21 March 2000\n\n  This program is based on (at least) the work of:\n     Mike Burrows\n     David Wheeler\n     Peter Fenwick\n     Alistair Moffat\n     Radford Neal\n     Ian H. Witten\n     Robert Sedgewick\n     Jon L. Bentley\n\n  For more information on these sources, see the manual.\n\n  To get some idea how the block sorting algorithms in this file\n  work, read my paper\n     On the Performance of BWT Sorting Algorithms\n  in Proceedings of the IEEE Data Compression Conference 2000,\n  Snowbird, Utah, USA, 27-30 March 2000.  The main sort in this\n  file implements the algorithm called  cache  in the paper.\n--*/\n\n\n#include \"bzlibprv.h\"\n\n/*---------------------------------------------*/\n/*--- Fallback O(N log(N)\u00ac2) sorting        ---*/\n/*--- algorithm, for repetitive blocks      ---*/\n/*---------------------------------------------*/\n\n/*---------------------------------------------*/\nstatic\n__inline__\nvoid fallbackSimpleSort ( UInt32* fmap,\n                          UInt32* eclass,\n                          Int32   lo,\n                          Int32   hi )\n{\n   Int32 i, j, tmp;\n   UInt32 ec_tmp;\n\n   if (lo == hi) return;\n\n   if (hi - lo > 3) {\n      for ( i = hi-4; i >= lo; i-- ) {\n         tmp = fmap\u00ddi\u00a8;\n         ec_tmp = eclass\u00ddtmp\u00a8;\n         for ( j = i+4; j <= hi && ec_tmp > eclass\u00ddfmap\u00ddj\u00a8\u00a8; j += 4 )\n            fmap\u00ddj-4\u00a8 = fmap\u00ddj\u00a8;\n         fmap\u00ddj-4\u00a8 = tmp;\n      }\n   }\n\n   for ( i = hi-1; i >= lo; i-- ) {\n      tmp = fmap\u00ddi\u00a8;\n      ec_tmp = eclass\u00ddtmp\u00a8;\n      for ( j = i+1; j <= hi && ec_tmp > eclass\u00ddfmap\u00ddj\u00a8\u00a8; j++ )\n         fmap\u00ddj-1\u00a8 = fmap\u00ddj\u00a8;\n      fmap\u00ddj-1\u00a8 = tmp;\n   }\n}\n\n\n/*---------------------------------------------*/\n#define fswap(zz1, zz2) \\\n   { Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }\n\n#define fvswap(zzp1, zzp2, zzn)       \\\n{                                     \\\n   Int32 yyp1 = (zzp1);               \\\n   Int32 yyp2 = (zzp2);               \\\n   Int32 yyn  = (zzn);                \\\n   while (yyn > 0) {                  \\\n      fswap(fmap\u00ddyyp1\u00a8, fmap\u00ddyyp2\u00a8);  \\\n      yyp1++; yyp2++; yyn--;          \\\n   }                                  \\\n}\n\n\n#define fmin(a,b) ((a) < (b)) ? (a) : (b)\n\n#define fpush(lz,hz) { stackLo\u00ddsp\u00a8 = lz; \\\n                       stackHi\u00ddsp\u00a8 = hz; \\\n                       sp++; }\n\n#define fpop(lz,hz) { sp--;              \\\n                      lz = stackLo\u00ddsp\u00a8;  \\\n                      hz = stackHi\u00ddsp\u00a8; }\n\n#define FALLBACK_QSORT_SMALL_THRESH 10\n#define FALLBACK_QSORT_STACK_SIZE   100\n\n\nstatic\nvoid fallbackQSort3 ( UInt32* fmap,\n                      UInt32* eclass,\n                      Int32   loSt,\n                      Int32   hiSt )\n{\n   Int32 unLo, unHi, ltLo, gtHi, n, m;\n   Int32 sp, lo, hi;\n   UInt32 med, r, r3;\n   Int32 stackLo\u00ddFALLBACK_QSORT_STACK_SIZE\u00a8;\n   Int32 stackHi\u00ddFALLBACK_QSORT_STACK_SIZE\u00a8;\n\n   r = 0;\n\n   sp = 0;\n   fpush ( loSt, hiSt );\n\n   while (sp > 0) {\n\n      AssertH ( sp < FALLBACK_QSORT_STACK_SIZE, 1004 );\n\n      fpop ( lo, hi );\n      if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\n         fallbackSimpleSort ( fmap, eclass, lo, hi );\n         continue;\n      }\n\n      /* Random partitioning.  Median of 3 sometimes fails to\n         avoid bad cases.  Median of 9 seems to help but\n         looks rather expensive.  This too seems to work but\n         is cheaper.  Guidance for the magic constants\n         7621 and 32768 is taken from Sedgewick's algorithms\n         book, chapter 35.\n      */\n      r = ((r * 7621) + 1) % 32768;\n      r3 = r % 3;\n      if (r3 == 0) med = eclass\u00ddfmap\u00ddlo\u00a8\u00a8; else\n      if (r3 == 1) med = eclass\u00ddfmap\u00dd(lo+hi)>>1\u00a8\u00a8; else\n                   med = eclass\u00ddfmap\u00ddhi\u00a8\u00a8;\n\n      unLo = ltLo = lo;\n      unHi = gtHi = hi;\n\n      while (1) {\n         while (1) {\n            if (unLo > unHi) break;\n            n = (Int32)eclass\u00ddfmap\u00ddunLo\u00a8\u00a8 - (Int32)med;\n            if (n == 0) {\n               fswap(fmap\u00ddunLo\u00a8, fmap\u00ddltLo\u00a8);\n               ltLo++; unLo++;\n               continue;\n            };\n            if (n > 0) break;\n            unLo++;\n         }\n         while (1) {\n            if (unLo > unHi) break;\n            n = (Int32)eclass\u00ddfmap\u00ddunHi\u00a8\u00a8 - (Int32)med;\n            if (n == 0) {\n               fswap(fmap\u00ddunHi\u00a8, fmap\u00ddgtHi\u00a8);\n               gtHi--; unHi--;\n               continue;\n            };\n            if (n < 0) break;\n            unHi--;\n         }\n         if (unLo > unHi) break;\n         fswap(fmap\u00ddunLo\u00a8, fmap\u00ddunHi\u00a8); unLo++; unHi--;\n      }\n\n      AssertD ( unHi == unLo-1, \"fallbackQSort3(2)\" );\n\n      if (gtHi < ltLo) continue;\n\n      n = fmin(ltLo-lo, unLo-ltLo); fvswap(lo, unLo-n, n);\n      m = fmin(hi-gtHi, gtHi-unHi); fvswap(unLo, hi-m+1, m);\n\n      n = lo + unLo - ltLo - 1;\n      m = hi - (gtHi - unHi) + 1;\n\n      if (n - lo > hi - m) {\n         fpush ( lo, n );\n         fpush ( m, hi );\n      } else {\n         fpush ( m, hi );\n         fpush ( lo, n );\n      }\n   }\n}\n\n#undef fmin\n#undef fpush\n#undef fpop\n#undef fswap\n#undef fvswap\n#undef FALLBACK_QSORT_SMALL_THRESH\n#undef FALLBACK_QSORT_STACK_SIZE\n\n\n/*---------------------------------------------*/\n/* Pre:\n      nblock > 0\n      eclass exists for \u00dd0 .. nblock-1\u00a8\n      ((UChar*)eclass) \u00dd0 .. nblock-1\u00a8 holds block\n      ptr exists for \u00dd0 .. nblock-1\u00a8\n\n   Post:\n      ((UChar*)eclass) \u00dd0 .. nblock-1\u00a8 holds block\n      All other areas of eclass destroyed\n      fmap \u00dd0 .. nblock-1\u00a8 holds sorted order\n      bhtab \u00dd 0 .. 2+(nblock/32) \u00a8 destroyed\n*/\n\n#define       SET_BH(zz)  bhtab\u00dd(zz) >> 5\u00a8 |= (1 << ((zz) & 31))\n#define     CLEAR_BH(zz)  bhtab\u00dd(zz) >> 5\u00a8 &= ~(1 << ((zz) & 31))\n#define     ISSET_BH(zz)  (bhtab\u00dd(zz) >> 5\u00a8 & (1 << ((zz) & 31)))\n#define      WORD_BH(zz)  bhtab\u00dd(zz) >> 5\u00a8\n#define UNALIGNED_BH(zz)  ((zz) & 0x01f)\n\nstatic\nvoid fallbackSort ( UInt32* fmap,\n                    UInt32* eclass,\n                    UInt32* bhtab,\n                    Int32   nblock,\n                    Int32   verb )\n{\n   Int32 ftab\u00dd257\u00a8;\n   Int32 ftabCopy\u00dd256\u00a8;\n   Int32 H, i, j, k, l, r, cc, cc1;\n   Int32 nNotDone;\n   Int32 nBhtab;\n   UChar* eclass8 = (UChar*)eclass;\n\n   /*--\n      Initial 1-char radix sort to generate\n      initial fmap and initial BH bits.\n   --*/\n   if (verb >= 4)\n      VPrintf0 ( \"        bucket sorting ...\\n\" );\n   for (i = 0; i < 257;    i++) ftab\u00ddi\u00a8 = 0;\n   for (i = 0; i < nblock; i++) ftab\u00ddeclass8\u00ddi\u00a8\u00a8++;\n   for (i = 0; i < 256;    i++) ftabCopy\u00ddi\u00a8 = ftab\u00ddi\u00a8;\n   for (i = 1; i < 257;    i++) ftab\u00ddi\u00a8 += ftab\u00ddi-1\u00a8;\n\n   for (i = 0; i < nblock; i++) {\n      j = eclass8\u00ddi\u00a8;\n      k = ftab\u00ddj\u00a8 - 1;\n      ftab\u00ddj\u00a8 = k;\n      fmap\u00ddk\u00a8 = i;\n   }\n\n   nBhtab = 2 + (nblock / 32);\n   for (i = 0; i < nBhtab; i++) bhtab\u00ddi\u00a8 = 0;\n   for (i = 0; i < 256; i++) SET_BH(ftab\u00ddi\u00a8);\n\n   /*--\n      Inductively refine the buckets.  Kind-of an\n      \"exponential radix sort\" (!), inspired by the\n      Manber-Myers suffix array construction algorithm.\n   --*/\n\n   /*-- set sentinel bits for block-end detection --*/\n   for (i = 0; i < 32; i++) {\n      SET_BH(nblock + 2*i);\n      CLEAR_BH(nblock + 2*i + 1);\n   }\n\n   /*-- the log(N) loop --*/\n   H = 1;\n   while (1) {\n\n      if (verb >= 4)\n         VPrintf1 ( \"        depth %6d has \", H );\n\n      j = 0;\n      for (i = 0; i < nblock; i++) {\n         if (ISSET_BH(i)) j = i;\n         k = fmap\u00ddi\u00a8 - H; if (k < 0) k += nblock;\n         eclass\u00ddk\u00a8 = j;\n      }\n\n      nNotDone = 0;\n      r = -1;\n      while (1) {\n\n\t /*-- find the next non-singleton bucket --*/\n         k = r + 1;\n         while (ISSET_BH(k) && UNALIGNED_BH(k)) k++;\n         if (ISSET_BH(k)) {\n            while (WORD_BH(k) == 0xffffffff) k += 32;\n            while (ISSET_BH(k)) k++;\n         }\n         l = k - 1;\n         if (l >= nblock) break;\n         while (!ISSET_BH(k) && UNALIGNED_BH(k)) k++;\n         if (!ISSET_BH(k)) {\n            while (WORD_BH(k) == 0x00000000) k += 32;\n            while (!ISSET_BH(k)) k++;\n         }\n         r = k - 1;\n         if (r >= nblock) break;\n\n         /*-- now \u00ddl, r\u00a8 bracket current bucket --*/\n         if (r > l) {\n            nNotDone += (r - l + 1);\n            fallbackQSort3 ( fmap, eclass, l, r );\n\n            /*-- scan bucket and generate header bits-- */\n            cc = -1;\n            for (i = l; i <= r; i++) {\n               cc1 = eclass\u00ddfmap\u00ddi\u00a8\u00a8;\n               if (cc != cc1) { SET_BH(i); cc = cc1; };\n            }\n         }\n      }\n\n      if (verb >= 4)\n         VPrintf1 ( \"%6d unresolved strings\\n\", nNotDone );\n\n      H *= 2;\n      if (H > nblock || nNotDone == 0) break;\n   }\n\n   /*--\n      Reconstruct the original block in\n      eclass8 \u00dd0 .. nblock-1\u00a8, since the\n      previous phase destroyed it.\n   --*/\n   if (verb >= 4)\n      VPrintf0 ( \"        reconstructing block ...\\n\" );\n   j = 0;\n   for (i = 0; i < nblock; i++) {\n      while (ftabCopy\u00ddj\u00a8 == 0) j++;\n      ftabCopy\u00ddj\u00a8--;\n      eclass8\u00ddfmap\u00ddi\u00a8\u00a8 = (UChar)j;\n   }\n   AssertH ( j < 256, 1005 );\n}\n\n#undef       SET_BH\n#undef     CLEAR_BH\n#undef     ISSET_BH\n#undef      WORD_BH\n#undef UNALIGNED_BH\n\n\n/*---------------------------------------------*/\n/*--- The main, O(N\u00ac2 log(N)) sorting       ---*/\n/*--- algorithm.  Faster for \"normal\"       ---*/\n/*--- non-repetitive blocks.                ---*/\n/*---------------------------------------------*/\n\n/*---------------------------------------------*/\nstatic\n__inline__\nBool mainGtU ( UInt32  i1,\n               UInt32  i2,\n               UChar*  block,\n               UInt16* quadrant,\n               UInt32  nblock,\n               Int32*  budget )\n{\n   Int32  k;\n   UChar  c1, c2;\n   UInt16 s1, s2;\n\n   AssertD ( i1 != i2, \"mainGtU\" );\n   /* 1 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 2 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 3 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 4 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 5 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 6 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 7 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 8 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 9 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 10 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 11 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n   /* 12 */\n   c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n   if (c1 != c2) return (c1 > c2);\n   i1++; i2++;\n\n   k = nblock + 8;\n\n   do {\n      /* 1 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 2 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 3 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 4 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 5 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 6 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 7 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n      /* 8 */\n      c1 = block\u00ddi1\u00a8; c2 = block\u00ddi2\u00a8;\n      if (c1 != c2) return (c1 > c2);\n      s1 = quadrant\u00ddi1\u00a8; s2 = quadrant\u00ddi2\u00a8;\n      if (s1 != s2) return (s1 > s2);\n      i1++; i2++;\n\n      if (i1 >= nblock) i1 -= nblock;\n      if (i2 >= nblock) i2 -= nblock;\n\n      k -= 8;\n      (*budget)--;\n   }\n      while (k >= 0);\n\n   return False;\n}\n\n\n/*---------------------------------------------*/\n/*--\n   Knuth's increments seem to work better\n   than Incerpi-Sedgewick here.  Possibly\n   because the number of elems to sort is\n   usually small, typically <= 20.\n--*/\nstatic\nInt32 incs\u00dd14\u00a8 = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n                   9841, 29524, 88573, 265720,\n                   797161, 2391484 };\n\nstatic\nvoid mainSimpleSort ( UInt32* ptr,\n                      UChar*  block,\n                      UInt16* quadrant,\n                      Int32   nblock,\n                      Int32   lo,\n                      Int32   hi,\n                      Int32   d,\n                      Int32*  budget )\n{\n   Int32 i, j, h, bigN, hp;\n   UInt32 v;\n\n   bigN = hi - lo + 1;\n   if (bigN < 2) return;\n\n   hp = 0;\n   while (incs\u00ddhp\u00a8 < bigN) hp++;\n   hp--;\n\n   for (; hp >= 0; hp--) {\n      h = incs\u00ddhp\u00a8;\n\n      i = lo + h;\n      while (True) {\n\n         /*-- copy 1 --*/\n         if (i > hi) break;\n         v = ptr\u00ddi\u00a8;\n         j = i;\n         while ( mainGtU (\n                    ptr\u00ddj-h\u00a8+d, v+d, block, quadrant, nblock, budget\n                 ) ) {\n            ptr\u00ddj\u00a8 = ptr\u00ddj-h\u00a8;\n            j = j - h;\n            if (j <= (lo + h - 1)) break;\n         }\n         ptr\u00ddj\u00a8 = v;\n         i++;\n\n         /*-- copy 2 --*/\n         if (i > hi) break;\n         v = ptr\u00ddi\u00a8;\n         j = i;\n         while ( mainGtU (\n                    ptr\u00ddj-h\u00a8+d, v+d, block, quadrant, nblock, budget\n                 ) ) {\n            ptr\u00ddj\u00a8 = ptr\u00ddj-h\u00a8;\n            j = j - h;\n            if (j <= (lo + h - 1)) break;\n         }\n         ptr\u00ddj\u00a8 = v;\n         i++;\n\n         /*-- copy 3 --*/\n         if (i > hi) break;\n         v = ptr\u00ddi\u00a8;\n         j = i;\n         while ( mainGtU (\n                    ptr\u00ddj-h\u00a8+d, v+d, block, quadrant, nblock, budget\n                 ) ) {\n            ptr\u00ddj\u00a8 = ptr\u00ddj-h\u00a8;\n            j = j - h;\n            if (j <= (lo + h - 1)) break;\n         }\n         ptr\u00ddj\u00a8 = v;\n         i++;\n\n         if (*budget < 0) return;\n      }\n   }\n}\n\n\n/*---------------------------------------------*/\n/*--\n   The following is an implementation of\n   an elegant 3-way quicksort for strings,\n   described in a paper \"Fast Algorithms for\n   Sorting and Searching Strings\", by Robert\n   Sedgewick and Jon L. Bentley.\n--*/\n\n#define mswap(zz1, zz2) \\\n   { Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }\n\n#define mvswap(zzp1, zzp2, zzn)       \\\n{                                     \\\n   Int32 yyp1 = (zzp1);               \\\n   Int32 yyp2 = (zzp2);               \\\n   Int32 yyn  = (zzn);                \\\n   while (yyn > 0) {                  \\\n      mswap(ptr\u00ddyyp1\u00a8, ptr\u00ddyyp2\u00a8);    \\\n      yyp1++; yyp2++; yyn--;          \\\n   }                                  \\\n}\n\nstatic\n__inline__\nUChar mmed3 ( UChar a, UChar b, UChar c )\n{\n   UChar t;\n   if (a > b) { t = a; a = b; b = t; };\n   if (b > c) {\n      b = c;\n      if (a > b) b = a;\n   }\n   return b;\n}\n\n#define mmin(a,b) ((a) < (b)) ? (a) : (b)\n\n#define mpush(lz,hz,dz) { stackLo\u00ddsp\u00a8 = lz; \\\n                          stackHi\u00ddsp\u00a8 = hz; \\\n                          stackD \u00ddsp\u00a8 = dz; \\\n                          sp++; }\n\n#define mpop(lz,hz,dz) { sp--;             \\\n                         lz = stackLo\u00ddsp\u00a8; \\\n                         hz = stackHi\u00ddsp\u00a8; \\\n                         dz = stackD \u00ddsp\u00a8; }\n\n\n#define mnextsize(az) (nextHi\u00ddaz\u00a8-nextLo\u00ddaz\u00a8)\n\n#define mnextswap(az,bz)                                        \\\n   { Int32 tz;                                                  \\\n     tz = nextLo\u00ddaz\u00a8; nextLo\u00ddaz\u00a8 = nextLo\u00ddbz\u00a8; nextLo\u00ddbz\u00a8 = tz; \\\n     tz = nextHi\u00ddaz\u00a8; nextHi\u00ddaz\u00a8 = nextHi\u00ddbz\u00a8; nextHi\u00ddbz\u00a8 = tz; \\\n     tz = nextD \u00ddaz\u00a8; nextD \u00ddaz\u00a8 = nextD \u00ddbz\u00a8; nextD \u00ddbz\u00a8 = tz; }\n\n\n#define MAIN_QSORT_SMALL_THRESH 20\n#define MAIN_QSORT_DEPTH_THRESH (BZ_N_RADIX + BZ_N_QSORT)\n#define MAIN_QSORT_STACK_SIZE 100\n\nstatic\nvoid mainQSort3 ( UInt32* ptr,\n                  UChar*  block,\n                  UInt16* quadrant,\n                  Int32   nblock,\n                  Int32   loSt,\n                  Int32   hiSt,\n                  Int32   dSt,\n                  Int32*  budget )\n{\n   Int32 unLo, unHi, ltLo, gtHi, n, m, med;\n   Int32 sp, lo, hi, d;\n\n   Int32 stackLo\u00ddMAIN_QSORT_STACK_SIZE\u00a8;\n   Int32 stackHi\u00ddMAIN_QSORT_STACK_SIZE\u00a8;\n   Int32 stackD \u00ddMAIN_QSORT_STACK_SIZE\u00a8;\n\n   Int32 nextLo\u00dd3\u00a8;\n   Int32 nextHi\u00dd3\u00a8;\n   Int32 nextD \u00dd3\u00a8;\n\n   sp = 0;\n   mpush ( loSt, hiSt, dSt );\n\n   while (sp > 0) {\n\n      AssertH ( sp < MAIN_QSORT_STACK_SIZE, 1001 );\n\n      mpop ( lo, hi, d );\n      if (hi - lo < MAIN_QSORT_SMALL_THRESH ||\n          d > MAIN_QSORT_DEPTH_THRESH) {\n         mainSimpleSort ( ptr, block, quadrant, nblock, lo, hi, d, budget );\n         if (*budget < 0) return;\n         continue;\n      }\n\n      med = (Int32)\n            mmed3 ( block\u00ddptr\u00dd lo         \u00a8+d\u00a8,\n                    block\u00ddptr\u00dd hi         \u00a8+d\u00a8,\n                    block\u00ddptr\u00dd (lo+hi)>>1 \u00a8+d\u00a8 );\n\n      unLo = ltLo = lo;\n      unHi = gtHi = hi;\n\n      while (True) {\n         while (True) {\n            if (unLo > unHi) break;\n            n = ((Int32)block\u00ddptr\u00ddunLo\u00a8+d\u00a8) - med;\n            if (n == 0) {\n               mswap(ptr\u00ddunLo\u00a8, ptr\u00ddltLo\u00a8);\n               ltLo++; unLo++; continue;\n            };\n            if (n >  0) break;\n            unLo++;\n         }\n         while (True) {\n            if (unLo > unHi) break;\n            n = ((Int32)block\u00ddptr\u00ddunHi\u00a8+d\u00a8) - med;\n            if (n == 0) {\n               mswap(ptr\u00ddunHi\u00a8, ptr\u00ddgtHi\u00a8);\n               gtHi--; unHi--; continue;\n            };\n            if (n <  0) break;\n            unHi--;\n         }\n         if (unLo > unHi) break;\n         mswap(ptr\u00ddunLo\u00a8, ptr\u00ddunHi\u00a8); unLo++; unHi--;\n      }\n\n      AssertD ( unHi == unLo-1, \"mainQSort3(2)\" );\n\n      if (gtHi < ltLo) {\n         mpush(lo, hi, d+1 );\n         continue;\n      }\n\n      n = mmin(ltLo-lo, unLo-ltLo); mvswap(lo, unLo-n, n);\n      m = mmin(hi-gtHi, gtHi-unHi); mvswap(unLo, hi-m+1, m);\n\n      n = lo + unLo - ltLo - 1;\n      m = hi - (gtHi - unHi) + 1;\n\n      nextLo\u00dd0\u00a8 = lo;  nextHi\u00dd0\u00a8 = n;   nextD\u00dd0\u00a8 = d;\n      nextLo\u00dd1\u00a8 = m;   nextHi\u00dd1\u00a8 = hi;  nextD\u00dd1\u00a8 = d;\n      nextLo\u00dd2\u00a8 = n+1; nextHi\u00dd2\u00a8 = m-1; nextD\u00dd2\u00a8 = d+1;\n\n      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);\n      if (mnextsize(1) < mnextsize(2)) mnextswap(1,2);\n      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);\n\n      AssertD (mnextsize(0) >= mnextsize(1), \"mainQSort3(8)\" );\n      AssertD (mnextsize(1) >= mnextsize(2), \"mainQSort3(9)\" );\n\n      mpush (nextLo\u00dd0\u00a8, nextHi\u00dd0\u00a8, nextD\u00dd0\u00a8);\n      mpush (nextLo\u00dd1\u00a8, nextHi\u00dd1\u00a8, nextD\u00dd1\u00a8);\n      mpush (nextLo\u00dd2\u00a8, nextHi\u00dd2\u00a8, nextD\u00dd2\u00a8);\n   }\n}\n\n#undef mswap\n#undef mvswap\n#undef mpush\n#undef mpop\n#undef mmin\n#undef mnextsize\n#undef mnextswap\n#undef MAIN_QSORT_SMALL_THRESH\n#undef MAIN_QSORT_DEPTH_THRESH\n#undef MAIN_QSORT_STACK_SIZE\n\n\n/*---------------------------------------------*/\n/* Pre:\n      nblock > N_OVERSHOOT\n      block32 exists for \u00dd0 .. nblock-1 +N_OVERSHOOT\u00a8\n      ((UChar*)block32) \u00dd0 .. nblock-1\u00a8 holds block\n      ptr exists for \u00dd0 .. nblock-1\u00a8\n\n   Post:\n      ((UChar*)block32) \u00dd0 .. nblock-1\u00a8 holds block\n      All other areas of block32 destroyed\n      ftab \u00dd0 .. 65536 \u00a8 destroyed\n      ptr \u00dd0 .. nblock-1\u00a8 holds sorted order\n      if (*budget < 0), sorting was abandoned\n*/\n\n#define BIGFREQ(b) (ftab\u00dd((b)+1) << 8\u00a8 - ftab\u00dd(b) << 8\u00a8)\n#define SETMASK (1 << 21)\n#define CLEARMASK (~(SETMASK))\n\nstatic\nvoid mainSort ( UInt32* ptr,\n                UChar*  block,\n                UInt16* quadrant,\n                UInt32* ftab,\n                Int32   nblock,\n                Int32   verb,\n                Int32*  budget )\n{\n   Int32  i, j, k, ss, sb;\n   Int32  runningOrder\u00dd256\u00a8;\n   Bool   bigDone\u00dd256\u00a8;\n   Int32  copyStart\u00dd256\u00a8;\n   Int32  copyEnd  \u00dd256\u00a8;\n   UChar  c1;\n   Int32  numQSorted;\n   UInt16 s;\n   if (verb >= 4) VPrintf0 ( \"        main sort initialise ...\\n\" );\n\n   /*-- set up the 2-byte frequency table --*/\n   for (i = 65536; i >= 0; i--) ftab\u00ddi\u00a8 = 0;\n\n   j = block\u00dd0\u00a8 << 8;\n   i = nblock-1;\n   for (; i >= 3; i -= 4) {\n      quadrant\u00ddi\u00a8 = 0;\n      j = (j >> 8) | ( ((UInt16)block\u00ddi\u00a8) << 8);\n      ftab\u00ddj\u00a8++;\n      quadrant\u00ddi-1\u00a8 = 0;\n      j = (j >> 8) | ( ((UInt16)block\u00ddi-1\u00a8) << 8);\n      ftab\u00ddj\u00a8++;\n      quadrant\u00ddi-2\u00a8 = 0;\n      j = (j >> 8) | ( ((UInt16)block\u00ddi-2\u00a8) << 8);\n      ftab\u00ddj\u00a8++;\n      quadrant\u00ddi-3\u00a8 = 0;\n      j = (j >> 8) | ( ((UInt16)block\u00ddi-3\u00a8) << 8);\n      ftab\u00ddj\u00a8++;\n   }\n   for (; i >= 0; i--) {\n      quadrant\u00ddi\u00a8 = 0;\n      j = (j >> 8) | ( ((UInt16)block\u00ddi\u00a8) << 8);\n      ftab\u00ddj\u00a8++;\n   }\n\n   /*-- (emphasises close relationship of block & quadrant) --*/\n   for (i = 0; i < BZ_N_OVERSHOOT; i++) {\n      block   \u00ddnblock+i\u00a8 = block\u00ddi\u00a8;\n      quadrant\u00ddnblock+i\u00a8 = 0;\n   }\n\n   if (verb >= 4) VPrintf0 ( \"        bucket sorting ...\\n\" );\n\n   /*-- Complete the initial radix sort --*/\n   for (i = 1; i <= 65536; i++) ftab\u00ddi\u00a8 += ftab\u00ddi-1\u00a8;\n\n   s = block\u00dd0\u00a8 << 8;\n   i = nblock-1;\n   for (; i >= 3; i -= 4) {\n      s = (s >> 8) | (block\u00ddi\u00a8 << 8);\n      j = ftab\u00dds\u00a8 -1;\n      ftab\u00dds\u00a8 = j;\n      ptr\u00ddj\u00a8 = i;\n      s = (s >> 8) | (block\u00ddi-1\u00a8 << 8);\n      j = ftab\u00dds\u00a8 -1;\n      ftab\u00dds\u00a8 = j;\n      ptr\u00ddj\u00a8 = i-1;\n      s = (s >> 8) | (block\u00ddi-2\u00a8 << 8);\n      j = ftab\u00dds\u00a8 -1;\n      ftab\u00dds\u00a8 = j;\n      ptr\u00ddj\u00a8 = i-2;\n      s = (s >> 8) | (block\u00ddi-3\u00a8 << 8);\n      j = ftab\u00dds\u00a8 -1;\n      ftab\u00dds\u00a8 = j;\n      ptr\u00ddj\u00a8 = i-3;\n   }\n   for (; i >= 0; i--) {\n      s = (s >> 8) | (block\u00ddi\u00a8 << 8);\n      j = ftab\u00dds\u00a8 -1;\n      ftab\u00dds\u00a8 = j;\n      ptr\u00ddj\u00a8 = i;\n   }\n\n   /*--\n      Now ftab contains the first loc of every small bucket.\n      Calculate the running order, from smallest to largest\n      big bucket.\n   --*/\n   for (i = 0; i <= 255; i++) {\n      bigDone     \u00ddi\u00a8 = False;\n      runningOrder\u00ddi\u00a8 = i;\n   }\n\n   {\n      Int32 vv;\n      Int32 h = 1;\n      do h = 3 * h + 1; while (h <= 256);\n      do {\n         h = h / 3;\n         for (i = h; i <= 255; i++) {\n            vv = runningOrder\u00ddi\u00a8;\n            j = i;\n            while ( BIGFREQ(runningOrder\u00ddj-h\u00a8) > BIGFREQ(vv) ) {\n               runningOrder\u00ddj\u00a8 = runningOrder\u00ddj-h\u00a8;\n               j = j - h;\n               if (j <= (h - 1)) goto zero;\n            }\n            zero:\n            runningOrder\u00ddj\u00a8 = vv;\n         }\n      } while (h != 1);\n   }\n\n   /*--\n      The main sorting loop.\n   --*/\n\n   numQSorted = 0;\n\n   for (i = 0; i <= 255; i++) {\n\n      /*--\n         Process big buckets, starting with the least full.\n         Basically this is a 3-step process in which we call\n         mainQSort3 to sort the small buckets \u00ddss, j\u00a8, but\n         also make a big effort to avoid the calls if we can.\n      --*/\n      ss = runningOrder\u00ddi\u00a8;\n\n      /*--\n         Step 1:\n         Complete the big bucket \u00ddss\u00a8 by quicksorting\n         any unsorted small buckets \u00ddss, j\u00a8, for j != ss.\n         Hopefully previous pointer-scanning phases have already\n         completed many of the small buckets \u00ddss, j\u00a8, so\n         we don't have to sort them at all.\n      --*/\n      for (j = 0; j <= 255; j++) {\n         if (j != ss) {\n            sb = (ss << 8) + j;\n            if ( ! (ftab\u00ddsb\u00a8 & SETMASK) ) {\n               Int32 lo = ftab\u00ddsb\u00a8   & CLEARMASK;\n               Int32 hi = (ftab\u00ddsb+1\u00a8 & CLEARMASK) - 1;\n               if (hi > lo) {\n                  if (verb >= 4)\n                     VPrintf4 ( \"        qsort \u00dd0x%x, 0x%x\u00a8   \"\n                                \"done %d   this %d\\n\",\n                                ss, j, numQSorted, hi - lo + 1 );\n                  mainQSort3 (\n                     ptr, block, quadrant, nblock,\n                     lo, hi, BZ_N_RADIX, budget\n                  );\n                  numQSorted += (hi - lo + 1);\n                  if (*budget < 0) return;\n               }\n            }\n            ftab\u00ddsb\u00a8 |= SETMASK;\n         }\n      }\n\n      AssertH ( !bigDone\u00ddss\u00a8, 1006 );\n\n      /*--\n         Step 2:\n         Now scan this big bucket \u00ddss\u00a8 so as to synthesise the\n         sorted order for small buckets \u00ddt, ss\u00a8 for all t,\n         including, magically, the bucket \u00ddss,ss\u00a8 too.\n         This will avoid doing Real Work in subsequent Step 1's.\n      --*/\n      {\n         for (j = 0; j <= 255; j++) {\n            copyStart\u00ddj\u00a8 =  ftab\u00dd(j << 8) + ss\u00a8     & CLEARMASK;\n            copyEnd  \u00ddj\u00a8 = (ftab\u00dd(j << 8) + ss + 1\u00a8 & CLEARMASK) - 1;\n         }\n         for (j = ftab\u00ddss << 8\u00a8 & CLEARMASK; j < copyStart\u00ddss\u00a8; j++) {\n            k = ptr\u00ddj\u00a8-1; if (k < 0) k += nblock;\n            c1 = block\u00ddk\u00a8;\n            if (!bigDone\u00ddc1\u00a8)\n               ptr\u00dd copyStart\u00ddc1\u00a8++ \u00a8 = k;\n         }\n         for (j = (ftab\u00dd(ss+1) << 8\u00a8 & CLEARMASK) - 1; j > copyEnd\u00ddss\u00a8; j--) {\n            k = ptr\u00ddj\u00a8-1; if (k < 0) k += nblock;\n            c1 = block\u00ddk\u00a8;\n            if (!bigDone\u00ddc1\u00a8)\n               ptr\u00dd copyEnd\u00ddc1\u00a8-- \u00a8 = k;\n         }\n      }\n\n      AssertH ( copyStart\u00ddss\u00a8-1 == copyEnd\u00ddss\u00a8, 1007 );\n\n      for (j = 0; j <= 255; j++) ftab\u00dd(j << 8) + ss\u00a8 |= SETMASK;\n\n      /*--\n         Step 3:\n         The \u00ddss\u00a8 big bucket is now done.  Record this fact,\n         and update the quadrant descriptors.  Remember to\n         update quadrants in the overshoot area too, if\n         necessary.  The \"if (i < 255)\" test merely skips\n         this updating for the last bucket processed, since\n         updating for the last bucket is pointless.\n\n         The quadrant array provides a way to incrementally\n         cache sort orderings, as they appear, so as to\n         make subsequent comparisons in fullGtU() complete\n         faster.  For repetitive blocks this makes a big\n         difference (but not big enough to be able to avoid\n         the fallback sorting mechanism, exponential radix sort).\n\n         The precise meaning is: at all times:\n\n            for 0 <= i < nblock and 0 <= j <= nblock\n\n            if block\u00ddi\u00a8 != block\u00ddj\u00a8,\n\n               then the relative values of quadrant\u00ddi\u00a8 and\n                    quadrant\u00ddj\u00a8 are meaningless.\n\n               else {\n                  if quadrant\u00ddi\u00a8 < quadrant\u00ddj\u00a8\n                     then the string starting at i lexicographically\n                     precedes the string starting at j\n\n                  else if quadrant\u00ddi\u00a8 > quadrant\u00ddj\u00a8\n                     then the string starting at j lexicographically\n                     precedes the string starting at i\n\n                  else\n                     the relative ordering of the strings starting\n                     at i and j has not yet been determined.\n               }\n      --*/\n      bigDone\u00ddss\u00a8 = True;\n\n      if (i < 255) {\n         Int32 bbStart  = ftab\u00ddss << 8\u00a8 & CLEARMASK;\n         Int32 bbSize   = (ftab\u00dd(ss+1) << 8\u00a8 & CLEARMASK) - bbStart;\n         Int32 shifts   = 0;\n\n         while ((bbSize >> shifts) > 65534) shifts++;\n\n         for (j = bbSize-1; j >= 0; j--) {\n            Int32 a2update     = ptr\u00ddbbStart + j\u00a8;\n            UInt16 qVal        = (UInt16)(j >> shifts);\n            quadrant\u00dda2update\u00a8 = qVal;\n            if (a2update < BZ_N_OVERSHOOT)\n               quadrant\u00dda2update + nblock\u00a8 = qVal;\n         }\n         AssertH ( ((bbSize-1) >> shifts) <= 65535, 1002 );\n      }\n\n   }\n\n   if (verb >= 4)\n      VPrintf3 ( \"        %d pointers, %d sorted, %d scanned\\n\",\n                 nblock, numQSorted, nblock - numQSorted );\n}\n\n#undef BIGFREQ\n#undef SETMASK\n#undef CLEARMASK\n\n\n/*---------------------------------------------*/\n/* Pre:\n      nblock > 0\n      arr2 exists for \u00dd0 .. nblock-1 +N_OVERSHOOT\u00a8\n      ((UChar*)arr2)  \u00dd0 .. nblock-1\u00a8 holds block\n      arr1 exists for \u00dd0 .. nblock-1\u00a8\n\n   Post:\n      ((UChar*)arr2) \u00dd0 .. nblock-1\u00a8 holds block\n      All other areas of block destroyed\n      ftab \u00dd 0 .. 65536 \u00a8 destroyed\n      arr1 \u00dd0 .. nblock-1\u00a8 holds sorted order\n*/\nvoid BZ2_blockSort ( EState* s )\n{\n   UInt32* ptr    = s->ptr;\n   UChar*  block  = s->block;\n   UInt32* ftab   = s->ftab;\n   Int32   nblock = s->nblock;\n   Int32   verb   = s->verbosity;\n   Int32   wfact  = s->workFactor;\n   UInt16* quadrant;\n   Int32   budget;\n   Int32   budgetInit;\n   Int32   i;\n\n   if (nblock < 10000) {\n      fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );\n   } else {\n      /* Calculate the location for quadrant, remembering to get\n         the alignment right.  Assumes that &(block\u00dd0\u00a8) is at least\n         2-byte aligned -- this should be ok since block is really\n         the first section of arr2.\n      */\n      i = nblock+BZ_N_OVERSHOOT;\n      if (i & 1) i++;\n      quadrant = (UInt16*)(&(block\u00ddi\u00a8));\n\n      /* (wfact-1) / 3 puts the default-factor-30\n         transition point at very roughly the same place as\n         with v0.1 and v0.9.0.\n         Not that it particularly matters any more, since the\n         resulting compressed stream is now the same regardless\n         of whether or not we use the main sort or fallback sort.\n      */\n      if (wfact < 1  ) wfact = 1;\n      if (wfact > 100) wfact = 100;\n      budgetInit = nblock * ((wfact-1) / 3);\n      budget = budgetInit;\n\n      mainSort ( ptr, block, quadrant, ftab, nblock, verb, &budget );\n      if (verb >= 3)\n         VPrintf3 ( \"      %d work, %d block, ratio %5.2f\\n\",\n                    budgetInit - budget,\n                    nblock,\n                    (float)(budgetInit - budget) /\n                    (float)(nblock==0 ? 1 : nblock) );\n      if (budget < 0) {\n         if (verb >= 2)\n            VPrintf0 ( \"    too repetitive; using fallback\"\n                       \" sorting algorithm\\n\" );\n         fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );\n      }\n   }\n\n   s->origPtr = -1;\n   for (i = 0; i < s->nblock; i++)\n      if (ptr\u00ddi\u00a8 == 0)\n         { s->origPtr = i; break; };\n\n   AssertH( s->origPtr != -1, 1003 );\n}\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                       blocksort.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BZLIB": {"ttr": 21, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*-------------------------------------------------------------*/\n/*--- Library top-level functions.                          ---*/\n/*---                                               bzlib.c ---*/\n/*-------------------------------------------------------------*/\n\n/*--\n  This file is a part of bzip2 and/or libbzip2, a program and\n  library for lossless, block-sorting data compression.\n\n  Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n\n  2. The origin of this software must not be misrepresented; you must\n     not claim that you wrote the original software.  If you use this\n     software in a product, an acknowledgment in the product\n     documentation would be appreciated but is not required.\n\n  3. Altered source versions must be plainly marked as such, and must\n     not be misrepresented as being the original software.\n\n  4. The name of the author may not be used to endorse or promote\n     products derived from this software without specific prior written\n     permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  Julian Seward, Cambridge, UK.\n  jseward@acm.org\n  bzip2/libbzip2 version 1.0 of 21 March 2000\n\n  This program is based on (at least) the work of:\n     Mike Burrows\n     David Wheeler\n     Peter Fenwick\n     Alistair Moffat\n     Radford Neal\n     Ian H. Witten\n     Robert Sedgewick\n     Jon L. Bentley\n\n  For more information on these sources, see the manual.\n--*/\n\n/*--\n   CHANGES\n   ~~~~~~~\n   0.9.0 -- original version.\n\n   0.9.0a/b -- no changes in this file.\n\n   0.9.0c\n      * made zero-length BZ_FLUSH work correctly in bzCompress().\n      * fixed bzWrite/bzRead to ignore zero-length requests.\n      * fixed bzread to correctly handle read requests after EOF.\n      * wrong parameter order in call to bzDecompressInit in\n        bzBuffToBuffDecompress.  Fixed.\n--*/\n\n#include \"bzlibprv.h\"\n\n\n/*---------------------------------------------------*/\n/*--- Compression stuff                           ---*/\n/*---------------------------------------------------*/\n\n\n/*---------------------------------------------------*/\n#ifndef BZ_NO_STDIO\nvoid BZ2_bz__AssertH__fail ( int errcode )\n{\n   fprintf(stderr,\n      \"\\n\\nbzip2/libbzip2: internal error number %d.\\n\"\n      \"This is a bug in bzip2/libbzip2, %s.\\n\"\n      \"Please report it to me at: jseward@acm.org.  If this happened\\n\"\n      \"when you were using some program which uses libbzip2 as a\\n\"\n      \"component, you should also report this bug to the author(s)\\n\"\n      \"of that program.  Please make an effort to report this bug;\\n\"\n      \"timely and accurate bug reports eventually lead to higher\\n\"\n      \"quality software.  Thanks.  Julian Seward, 21 March 2000.\\n\\n\",\n      errcode,\n      BZ2_bzlibVersion()\n   );\n   exit(3);\n}\n#endif\n\n\n/*---------------------------------------------------*/\nstatic\nint bz_config_ok ( void )\n{\n   if (sizeof(int)   != 4) return 0;\n   if (sizeof(short) != 2) return 0;\n   if (sizeof(char)  != 1) return 0;\n   return 1;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid* default_bzalloc ( void* opaque, Int32 items, Int32 size )\n{\n   void* v = malloc ( items * size );\n   return v;\n}\n\nstatic\nvoid default_bzfree ( void* opaque, void* addr )\n{\n   if (addr != NULL) free ( addr );\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid prepare_new_block ( EState* s )\n{\n   Int32 i;\n   s->nblock = 0;\n   s->numZ = 0;\n   s->state_out_pos = 0;\n   BZ_INITIALISE_CRC ( s->blockCRC );\n   for (i = 0; i < 256; i++) s->inUse\u00ddi\u00a8 = False;\n   s->blockNo++;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid init_RL ( EState* s )\n{\n   s->state_in_ch  = 256;\n   s->state_in_len = 0;\n}\n\n\nstatic\nBool isempty_RL ( EState* s )\n{\n   if (s->state_in_ch < 256 && s->state_in_len > 0)\n      return False; else\n      return True;\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzCompressInit)\n                    ( bz_stream* strm,\n                     int        blockSize100k,\n                     int        verbosity,\n                     int        workFactor )\n{\n   Int32   n;\n   EState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL ||\n       blockSize100k < 1 || blockSize100k > 9 ||\n       workFactor < 0 || workFactor > 250)\n     return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(EState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm = strm;\n\n   s->arr1 = NULL;\n   s->arr2 = NULL;\n   s->ftab = NULL;\n\n   n       = 100000 * blockSize100k;\n   s->arr1 = BZALLOC( n                  * sizeof(UInt32) );\n   s->arr2 = BZALLOC( (n+BZ_N_OVERSHOOT) * sizeof(UInt32) );\n   s->ftab = BZALLOC( 65537              * sizeof(UInt32) );\n\n   if (s->arr1 == NULL || s->arr2 == NULL || s->ftab == NULL) {\n      if (s->arr1 != NULL) BZFREE(s->arr1);\n      if (s->arr2 != NULL) BZFREE(s->arr2);\n      if (s->ftab != NULL) BZFREE(s->ftab);\n      if (s       != NULL) BZFREE(s);\n      return BZ_MEM_ERROR;\n   }\n\n   s->blockNo           = 0;\n   s->state             = BZ_S_INPUT;\n   s->mode              = BZ_M_RUNNING;\n   s->combinedCRC       = 0;\n   s->blockSize100k     = blockSize100k;\n   s->nblockMAX         = 100000 * blockSize100k - 19;\n   s->verbosity         = verbosity;\n   s->workFactor        = workFactor;\n\n   s->block             = (UChar*)s->arr2;\n   s->mtfv              = (UInt16*)s->arr1;\n   s->zbits             = NULL;\n   s->ptr               = (UInt32*)s->arr1;\n\n   strm->state          = s;\n   strm->total_in_lo32  = 0;\n   strm->total_in_hi32  = 0;\n   strm->total_out_lo32 = 0;\n   strm->total_out_hi32 = 0;\n   init_RL ( s );\n   prepare_new_block ( s );\n   return BZ_OK;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid add_pair_to_block ( EState* s )\n{\n   Int32 i;\n   UChar ch = (UChar)(s->state_in_ch);\n   for (i = 0; i < s->state_in_len; i++) {\n      BZ_UPDATE_CRC( s->blockCRC, ch );\n   }\n   s->inUse\u00dds->state_in_ch\u00a8 = True;\n   switch (s->state_in_len) {\n      case 1:\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         break;\n      case 2:\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         break;\n      case 3:\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         break;\n      default:\n         s->inUse\u00dds->state_in_len-4\u00a8 = True;\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         s->block\u00dds->nblock\u00a8 = (UChar)ch; s->nblock++;\n         s->block\u00dds->nblock\u00a8 = ((UChar)(s->state_in_len-4));\n         s->nblock++;\n         break;\n   }\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid flush_RL ( EState* s )\n{\n   if (s->state_in_ch < 256) add_pair_to_block ( s );\n   init_RL ( s );\n}\n\n\n/*---------------------------------------------------*/\n#define ADD_CHAR_TO_BLOCK(zs,zchh0)               \\\n{                                                 \\\n   UInt32 zchh = (UInt32)(zchh0);                 \\\n   /*-- fast track the common case --*/           \\\n   if (zchh != zs->state_in_ch &&                 \\\n       zs->state_in_len == 1) {                   \\\n      UChar ch = (UChar)(zs->state_in_ch);        \\\n      BZ_UPDATE_CRC( zs->blockCRC, ch );          \\\n      zs->inUse\u00ddzs->state_in_ch\u00a8 = True;          \\\n      zs->block\u00ddzs->nblock\u00a8 = (UChar)ch;          \\\n      zs->nblock++;                               \\\n      zs->state_in_ch = zchh;                     \\\n   }                                              \\\n   else                                           \\\n   /*-- general, uncommon cases --*/              \\\n   if (zchh != zs->state_in_ch ||                 \\\n      zs->state_in_len == 255) {                  \\\n      if (zs->state_in_ch < 256)                  \\\n         add_pair_to_block ( zs );                \\\n      zs->state_in_ch = zchh;                     \\\n      zs->state_in_len = 1;                       \\\n   } else {                                       \\\n      zs->state_in_len++;                         \\\n   }                                              \\\n}\n\n\n/*---------------------------------------------------*/\nstatic\nBool copy_input_until_stop ( EState* s )\n{\n   Bool progress_in = False;\n\n   if (s->mode == BZ_M_RUNNING) {\n\n      /*-- fast track the common case --*/\n      while (True) {\n         /*-- block full? --*/\n         if (s->nblock >= s->nblockMAX) break;\n         /*-- no input? --*/\n         if (s->strm->avail_in == 0) break;\n         progress_in = True;\n         ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );\n         s->strm->next_in++;\n         s->strm->avail_in--;\n         s->strm->total_in_lo32++;\n         if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;\n      }\n\n   } else {\n\n      /*-- general, uncommon case --*/\n      while (True) {\n         /*-- block full? --*/\n         if (s->nblock >= s->nblockMAX) break;\n         /*-- no input? --*/\n         if (s->strm->avail_in == 0) break;\n         /*-- flush/finish end? --*/\n         if (s->avail_in_expect == 0) break;\n         progress_in = True;\n         ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) );\n         s->strm->next_in++;\n         s->strm->avail_in--;\n         s->strm->total_in_lo32++;\n         if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;\n         s->avail_in_expect--;\n      }\n   }\n   return progress_in;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nBool copy_output_until_stop ( EState* s )\n{\n   Bool progress_out = False;\n\n   while (True) {\n\n      /*-- no output space? --*/\n      if (s->strm->avail_out == 0) break;\n\n      /*-- block done? --*/\n      if (s->state_out_pos >= s->numZ) break;\n\n      progress_out = True;\n      *(s->strm->next_out) = s->zbits\u00dds->state_out_pos\u00a8;\n      s->state_out_pos++;\n      s->strm->avail_out--;\n      s->strm->next_out++;\n      s->strm->total_out_lo32++;\n      if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n   }\n\n   return progress_out;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nBool handle_compress ( bz_stream* strm )\n{\n   Bool progress_in  = False;\n   Bool progress_out = False;\n   EState* s = strm->state;\n\n   while (True) {\n\n      if (s->state == BZ_S_OUTPUT) {\n         progress_out |= copy_output_until_stop ( s );\n         if (s->state_out_pos < s->numZ) break;\n         if (s->mode == BZ_M_FINISHING &&\n             s->avail_in_expect == 0 &&\n             isempty_RL(s)) break;\n         prepare_new_block ( s );\n         s->state = BZ_S_INPUT;\n         if (s->mode == BZ_M_FLUSHING &&\n             s->avail_in_expect == 0 &&\n             isempty_RL(s)) break;\n      }\n\n      if (s->state == BZ_S_INPUT) {\n         progress_in |= copy_input_until_stop ( s );\n         if (s->mode != BZ_M_RUNNING && s->avail_in_expect == 0) {\n            flush_RL ( s );\n            BZ2_compressBlock ( s, (Bool)(s->mode == BZ_M_FINISHING) );\n            s->state = BZ_S_OUTPUT;\n         }\n         else\n         if (s->nblock >= s->nblockMAX) {\n            BZ2_compressBlock ( s, False );\n            s->state = BZ_S_OUTPUT;\n         }\n         else\n         if (s->strm->avail_in == 0) {\n            break;\n         }\n      }\n\n   }\n\n   return progress_in || progress_out;\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )\n{\n   Bool progress;\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   preswitch:\n   switch (s->mode) {\n\n      case BZ_M_IDLE:\n         return BZ_SEQUENCE_ERROR;\n\n      case BZ_M_RUNNING:\n         if (action == BZ_RUN) {\n            progress = handle_compress ( strm );\n            return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;\n         }\n         else\n\t if (action == BZ_FLUSH) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FLUSHING;\n            goto preswitch;\n         }\n         else\n         if (action == BZ_FINISH) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = BZ_M_FINISHING;\n            goto preswitch;\n         }\n         else\n            return BZ_PARAM_ERROR;\n\n      case BZ_M_FLUSHING:\n         if (action != BZ_FLUSH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect != s->strm->avail_in)\n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n             s->state_out_pos < s->numZ) return BZ_FLUSH_OK;\n         s->mode = BZ_M_RUNNING;\n         return BZ_RUN_OK;\n\n      case BZ_M_FINISHING:\n         if (action != BZ_FINISH) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect != s->strm->avail_in)\n            return BZ_SEQUENCE_ERROR;\n         progress = handle_compress ( strm );\n         if (!progress) return BZ_SEQUENCE_ERROR;\n         if (s->avail_in_expect > 0 || !isempty_RL(s) ||\n             s->state_out_pos < s->numZ) return BZ_FINISH_OK;\n         s->mode = BZ_M_IDLE;\n         return BZ_STREAM_END;\n   }\n   return BZ_OK; /*--not reached--*/\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )\n{\n   EState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   if (s->arr1 != NULL) BZFREE(s->arr1);\n   if (s->arr2 != NULL) BZFREE(s->arr2);\n   if (s->ftab != NULL) BZFREE(s->ftab);\n   BZFREE(strm->state);\n\n   strm->state = NULL;\n\n   return BZ_OK;\n}\n\n\n/*---------------------------------------------------*/\n/*--- Decompression stuff                         ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzDecompressInit)\n                     ( bz_stream* strm,\n                       int        verbosity,\n                       int        small )\n{\n   DState* s;\n\n   if (!bz_config_ok()) return BZ_CONFIG_ERROR;\n\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   if (small != 0 && small != 1) return BZ_PARAM_ERROR;\n   if (verbosity < 0 || verbosity > 4) return BZ_PARAM_ERROR;\n\n   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;\n   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;\n\n   s = BZALLOC( sizeof(DState) );\n   if (s == NULL) return BZ_MEM_ERROR;\n   s->strm                  = strm;\n   strm->state              = s;\n   s->state                 = BZ_X_MAGIC_1;\n   s->bsLive                = 0;\n   s->bsBuff                = 0;\n   s->calculatedCombinedCRC = 0;\n   strm->total_in_lo32      = 0;\n   strm->total_in_hi32      = 0;\n   strm->total_out_lo32     = 0;\n   strm->total_out_hi32     = 0;\n   s->smallDecompress       = (Bool)small;\n   s->ll4                   = NULL;\n   s->ll16                  = NULL;\n   s->tt                    = NULL;\n   s->currBlockNo           = 0;\n   s->verbosity             = verbosity;\n\n   return BZ_OK;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid unRLE_obuf_to_output_FAST ( DState* s )\n{\n   UChar k1;\n\n   if (s->blockRandomised) {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n\n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return;\n\n\n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         s->state_out_len = 2;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         s->state_out_len = 3;\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_FAST(s->k0); BZ_RAND_UPD_MASK;\n         s->k0 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n      }\n\n   } else {\n\n      /* restore */\n      UInt32        c_calculatedBlockCRC = s->calculatedBlockCRC;\n      UChar         c_state_out_ch       = s->state_out_ch;\n      Int32         c_state_out_len      = s->state_out_len;\n      Int32         c_nblock_used        = s->nblock_used;\n      Int32         c_k0                 = s->k0;\n      UInt32*       c_tt                 = s->tt;\n      UInt32        c_tPos               = s->tPos;\n      char*         cs_next_out          = s->strm->next_out;\n      unsigned int  cs_avail_out         = s->strm->avail_out;\n      /* end restore */\n\n      UInt32       avail_out_INIT = cs_avail_out;\n      Int32        s_save_nblockPP = s->save_nblock+1;\n      unsigned int total_out_lo32_old;\n\n      while (True) {\n\n         /* try to finish existing run */\n         if (c_state_out_len > 0) {\n            while (True) {\n               if (cs_avail_out == 0) goto return_notr;\n               if (c_state_out_len == 1) break;\n               *( (UChar*)(cs_next_out) ) = c_state_out_ch;\n               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );\n               c_state_out_len--;\n               cs_next_out++;\n               cs_avail_out--;\n            }\n            s_state_out_len_eq_one:\n            {\n               if (cs_avail_out == 0) {\n                  c_state_out_len = 1; goto return_notr;\n               };\n               *( (UChar*)(cs_next_out) ) = c_state_out_ch;\n               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );\n               cs_next_out++;\n               cs_avail_out--;\n            }\n         }\n         /* can a new run be started? */\n         if (c_nblock_used == s_save_nblockPP) {\n            c_state_out_len = 0; goto return_notr;\n         };\n         c_state_out_ch = c_k0;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (k1 != c_k0) {\n            c_k0 = k1; goto s_state_out_len_eq_one;\n         };\n         if (c_nblock_used == s_save_nblockPP)\n            goto s_state_out_len_eq_one;\n\n         c_state_out_len = 2;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (c_nblock_used == s_save_nblockPP) continue;\n         if (k1 != c_k0) { c_k0 = k1; continue; };\n\n         c_state_out_len = 3;\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         if (c_nblock_used == s_save_nblockPP) continue;\n         if (k1 != c_k0) { c_k0 = k1; continue; };\n\n         BZ_GET_FAST_C(k1); c_nblock_used++;\n         c_state_out_len = ((Int32)k1) + 4;\n         BZ_GET_FAST_C(c_k0); c_nblock_used++;\n      }\n\n      return_notr:\n      total_out_lo32_old = s->strm->total_out_lo32;\n      s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);\n      if (s->strm->total_out_lo32 < total_out_lo32_old)\n         s->strm->total_out_hi32++;\n\n      /* save */\n      s->calculatedBlockCRC = c_calculatedBlockCRC;\n      s->state_out_ch       = c_state_out_ch;\n      s->state_out_len      = c_state_out_len;\n      s->nblock_used        = c_nblock_used;\n      s->k0                 = c_k0;\n      s->tt                 = c_tt;\n      s->tPos               = c_tPos;\n      s->strm->next_out     = cs_next_out;\n      s->strm->avail_out    = cs_avail_out;\n      /* end save */\n   }\n}\n\n\n\n/*---------------------------------------------------*/\n__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )\n{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) >> 1;\n      if (indx >= cftab\u00ddmid\u00a8) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid unRLE_obuf_to_output_SMALL ( DState* s )\n{\n   UChar k1;\n\n   if (s->blockRandomised) {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n\n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return;\n\n\n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK;\n         k1 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); BZ_RAND_UPD_MASK;\n         s->k0 \u00ac= BZ_RAND_MASK; s->nblock_used++;\n      }\n\n   } else {\n\n      while (True) {\n         /* try to finish existing run */\n         while (True) {\n            if (s->strm->avail_out == 0) return;\n            if (s->state_out_len == 0) break;\n            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;\n            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );\n            s->state_out_len--;\n            s->strm->next_out++;\n            s->strm->avail_out--;\n            s->strm->total_out_lo32++;\n            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;\n         }\n\n         /* can a new run be started? */\n         if (s->nblock_used == s->save_nblock+1) return;\n\n         s->state_out_len = 1;\n         s->state_out_ch = s->k0;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         s->state_out_len = 2;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         s->state_out_len = 3;\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         if (s->nblock_used == s->save_nblock+1) continue;\n         if (k1 != s->k0) { s->k0 = k1; continue; };\n\n         BZ_GET_SMALL(k1); s->nblock_used++;\n         s->state_out_len = ((Int32)k1) + 4;\n         BZ_GET_SMALL(s->k0); s->nblock_used++;\n      }\n\n   }\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzDecompress) ( bz_stream *strm )\n{\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   while (True) {\n      if (s->state == BZ_X_IDLE) return BZ_SEQUENCE_ERROR;\n      if (s->state == BZ_X_OUTPUT) {\n         if (s->smallDecompress)\n            unRLE_obuf_to_output_SMALL ( s ); else\n            unRLE_obuf_to_output_FAST  ( s );\n         if (s->nblock_used == s->save_nblock+1 && s->state_out_len == 0) {\n            BZ_FINALISE_CRC ( s->calculatedBlockCRC );\n            if (s->verbosity >= 3)\n               VPrintf2 ( \" {0x%x, 0x%x}\", s->storedBlockCRC,\n                          s->calculatedBlockCRC );\n            if (s->verbosity >= 2) VPrintf0 ( \"\u00a8\" );\n            if (s->calculatedBlockCRC != s->storedBlockCRC)\n               return BZ_DATA_ERROR;\n            s->calculatedCombinedCRC\n               = (s->calculatedCombinedCRC << 1) |\n                    (s->calculatedCombinedCRC >> 31);\n            s->calculatedCombinedCRC \u00ac= s->calculatedBlockCRC;\n            s->state = BZ_X_BLKHDR_1;\n         } else {\n            return BZ_OK;\n         }\n      }\n      if (s->state >= BZ_X_MAGIC_1) {\n         Int32 r = BZ2_decompress ( s );\n         if (r == BZ_STREAM_END) {\n            if (s->verbosity >= 3)\n               VPrintf2 ( \"\\n    combined CRCs: stored = 0x%x, computed = 0x%x\",\n                          s->storedCombinedCRC, s->calculatedCombinedCRC );\n            if (s->calculatedCombinedCRC != s->storedCombinedCRC)\n               return BZ_DATA_ERROR;\n            return r;\n         }\n         if (s->state != BZ_X_OUTPUT) return r;\n      }\n   }\n\n   AssertH ( 0, 6001 );\n\n   return 0;  /*NOTREACHED*/\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzDecompressEnd)  ( bz_stream *strm )\n{\n   DState* s;\n   if (strm == NULL) return BZ_PARAM_ERROR;\n   s = strm->state;\n   if (s == NULL) return BZ_PARAM_ERROR;\n   if (s->strm != strm) return BZ_PARAM_ERROR;\n\n   if (s->tt   != NULL) BZFREE(s->tt);\n   if (s->ll16 != NULL) BZFREE(s->ll16);\n   if (s->ll4  != NULL) BZFREE(s->ll4);\n\n   BZFREE(strm->state);\n   strm->state = NULL;\n\n   return BZ_OK;\n}\n\n\n#ifndef BZ_NO_STDIO\n/*---------------------------------------------------*/\n/*--- File I/O stuff                              ---*/\n/*---------------------------------------------------*/\n\n#define BZ_SETERR(eee)                    \\\n{                                         \\\n   if (bzerror != NULL) *bzerror = eee;   \\\n   if (bzf != NULL) bzf->lastErr = eee;   \\\n}\n\ntypedef\n   struct {\n      FILE*     handle;\n      Char      buf\u00ddBZ_MAX_UNUSED\u00a8;\n      Int32     bufN;\n      Bool      writing;\n      bz_stream strm;\n      Int32     lastErr;\n      Bool      initialisedOk;\n   }\n   bzFile;\n\n\n/*---------------------------------------------*/\nstatic Bool myfeof ( FILE* f )\n{\n   Int32 c = fgetc ( f );\n   if (c == EOF) return True;\n   ungetc ( c, f );\n   return False;\n}\n\n\n/*---------------------------------------------------*/\nBZFILE* BZ_API(BZ2_bzWriteOpen)\n                    ( int*  bzerror,\n                      FILE* f,\n                      int   blockSize100k,\n                      int   verbosity,\n                      int   workFactor )\n{\n   Int32   ret;\n   bzFile* bzf = NULL;\n\n   BZ_SETERR(BZ_OK);\n\n   if (f == NULL ||\n       (blockSize100k < 1 || blockSize100k > 9) ||\n       (workFactor < 0 || workFactor > 250) ||\n       (verbosity < 0 || verbosity > 4))\n      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };\n\n   if (ferror(f))\n      { BZ_SETERR(BZ_IO_ERROR); return NULL; };\n\n   bzf = malloc ( sizeof(bzFile) );\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };\n\n   BZ_SETERR(BZ_OK);\n   bzf->initialisedOk = False;\n   bzf->bufN          = 0;\n   bzf->handle        = f;\n   bzf->writing       = True;\n   bzf->strm.bzalloc  = NULL;\n   bzf->strm.bzfree   = NULL;\n   bzf->strm.opaque   = NULL;\n\n   if (workFactor == 0) workFactor = 30;\n   ret = BZ2_bzCompressInit ( &(bzf->strm), blockSize100k,\n                              verbosity, workFactor );\n   if (ret != BZ_OK)\n      { BZ_SETERR(ret); free(bzf); return NULL; };\n\n   bzf->strm.avail_in = 0;\n   bzf->initialisedOk = True;\n   return bzf;\n}\n\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzWrite)\n             ( int*    bzerror,\n               BZFILE* b,\n               void*   buf,\n               int     len )\n{\n   Int32 n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL || buf == NULL || len < 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n   if (!(bzf->writing))\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (ferror(bzf->handle))\n      { BZ_SETERR(BZ_IO_ERROR); return; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return; };\n\n   bzf->strm.avail_in = len;\n   bzf->strm.next_in  = buf;\n\n   while (True) {\n      bzf->strm.avail_out = BZ_MAX_UNUSED;\n      bzf->strm.next_out = bzf->buf;\n      ret = BZ2_bzCompress ( &(bzf->strm), BZ_RUN );\n      if (ret != BZ_RUN_OK)\n         { BZ_SETERR(ret); return; };\n\n      if (bzf->strm.avail_out < BZ_MAX_UNUSED) {\n         n = BZ_MAX_UNUSED - bzf->strm.avail_out;\n         n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar),\n                       n, bzf->handle );\n         if (n != n2 || ferror(bzf->handle))\n            { BZ_SETERR(BZ_IO_ERROR); return; };\n      }\n\n      if (bzf->strm.avail_in == 0)\n         { BZ_SETERR(BZ_OK); return; };\n   }\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzWriteClose)\n                  ( int*          bzerror,\n                    BZFILE*       b,\n                    int           abandon,\n                    unsigned int* nbytes_in,\n                    unsigned int* nbytes_out )\n{\n   BZ2_bzWriteClose64 ( bzerror, b, abandon,\n                        nbytes_in, NULL, nbytes_out, NULL );\n}\n\n\nvoid BZ_API(BZ2_bzWriteClose64)\n                  ( int*          bzerror,\n                    BZFILE*       b,\n                    int           abandon,\n                    unsigned int* nbytes_in_lo32,\n                    unsigned int* nbytes_in_hi32,\n                    unsigned int* nbytes_out_lo32,\n                    unsigned int* nbytes_out_hi32 )\n{\n   Int32   n, n2, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n   if (!(bzf->writing))\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (ferror(bzf->handle))\n      { BZ_SETERR(BZ_IO_ERROR); return; };\n\n   if (nbytes_in_lo32 != NULL) *nbytes_in_lo32 = 0;\n   if (nbytes_in_hi32 != NULL) *nbytes_in_hi32 = 0;\n   if (nbytes_out_lo32 != NULL) *nbytes_out_lo32 = 0;\n   if (nbytes_out_hi32 != NULL) *nbytes_out_hi32 = 0;\n\n   if ((!abandon) && bzf->lastErr == BZ_OK) {\n      while (True) {\n         bzf->strm.avail_out = BZ_MAX_UNUSED;\n         bzf->strm.next_out = bzf->buf;\n         ret = BZ2_bzCompress ( &(bzf->strm), BZ_FINISH );\n         if (ret != BZ_FINISH_OK && ret != BZ_STREAM_END)\n            { BZ_SETERR(ret); return; };\n\n         if (bzf->strm.avail_out < BZ_MAX_UNUSED) {\n            n = BZ_MAX_UNUSED - bzf->strm.avail_out;\n            n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar),\n                          n, bzf->handle );\n            if (n != n2 || ferror(bzf->handle))\n               { BZ_SETERR(BZ_IO_ERROR); return; };\n         }\n\n         if (ret == BZ_STREAM_END) break;\n      }\n   }\n\n   if ( !abandon && !ferror ( bzf->handle ) ) {\n      fflush ( bzf->handle );\n      if (ferror(bzf->handle))\n         { BZ_SETERR(BZ_IO_ERROR); return; };\n   }\n\n   if (nbytes_in_lo32 != NULL)\n      *nbytes_in_lo32 = bzf->strm.total_in_lo32;\n   if (nbytes_in_hi32 != NULL)\n      *nbytes_in_hi32 = bzf->strm.total_in_hi32;\n   if (nbytes_out_lo32 != NULL)\n      *nbytes_out_lo32 = bzf->strm.total_out_lo32;\n   if (nbytes_out_hi32 != NULL)\n      *nbytes_out_hi32 = bzf->strm.total_out_hi32;\n\n   BZ_SETERR(BZ_OK);\n   BZ2_bzCompressEnd ( &(bzf->strm) );\n   free ( bzf );\n}\n\n\n/*---------------------------------------------------*/\nBZFILE* BZ_API(BZ2_bzReadOpen)\n                   ( int*  bzerror,\n                     FILE* f,\n                     int   verbosity,\n                     int   small,\n                     void* unused,\n                     int   nUnused )\n{\n   bzFile* bzf = NULL;\n   int     ret;\n\n   BZ_SETERR(BZ_OK);\n\n   if (f == NULL ||\n       (small != 0 && small != 1) ||\n       (verbosity < 0 || verbosity > 4) ||\n       (unused == NULL && nUnused != 0) ||\n       (unused != NULL && (nUnused < 0 || nUnused > BZ_MAX_UNUSED)))\n      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };\n\n   if (ferror(f))\n      { BZ_SETERR(BZ_IO_ERROR); return NULL; };\n\n   bzf = malloc ( sizeof(bzFile) );\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };\n\n   BZ_SETERR(BZ_OK);\n\n   bzf->initialisedOk = False;\n   bzf->handle        = f;\n   bzf->bufN          = 0;\n   bzf->writing       = False;\n   bzf->strm.bzalloc  = NULL;\n   bzf->strm.bzfree   = NULL;\n   bzf->strm.opaque   = NULL;\n\n   while (nUnused > 0) {\n      bzf->buf\u00ddbzf->bufN\u00a8 = *((UChar*)(unused)); bzf->bufN++;\n      unused = ((void*)( 1 + ((UChar*)(unused))  ));\n      nUnused--;\n   }\n\n   ret = BZ2_bzDecompressInit ( &(bzf->strm), verbosity, small );\n   if (ret != BZ_OK)\n      { BZ_SETERR(ret); free(bzf); return NULL; };\n\n   bzf->strm.avail_in = bzf->bufN;\n   bzf->strm.next_in  = bzf->buf;\n\n   bzf->initialisedOk = True;\n   return bzf;\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )\n{\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_OK); return; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n\n   if (bzf->initialisedOk)\n      (void)BZ2_bzDecompressEnd ( &(bzf->strm) );\n   free ( bzf );\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzRead)\n           ( int*    bzerror,\n             BZFILE* b,\n             void*   buf,\n             int     len )\n{\n   Int32   n, ret;\n   bzFile* bzf = (bzFile*)b;\n\n   BZ_SETERR(BZ_OK);\n\n   if (bzf == NULL || buf == NULL || len < 0)\n      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };\n\n   if (bzf->writing)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };\n\n   if (len == 0)\n      { BZ_SETERR(BZ_OK); return 0; };\n\n   bzf->strm.avail_out = len;\n   bzf->strm.next_out = buf;\n\n   while (True) {\n\n      if (ferror(bzf->handle))\n         { BZ_SETERR(BZ_IO_ERROR); return 0; };\n\n      if (bzf->strm.avail_in == 0 && !myfeof(bzf->handle)) {\n         n = fread ( bzf->buf, sizeof(UChar),\n                     BZ_MAX_UNUSED, bzf->handle );\n         if (ferror(bzf->handle))\n            { BZ_SETERR(BZ_IO_ERROR); return 0; };\n         bzf->bufN = n;\n         bzf->strm.avail_in = bzf->bufN;\n         bzf->strm.next_in = bzf->buf;\n      }\n\n      ret = BZ2_bzDecompress ( &(bzf->strm) );\n\n      if (ret != BZ_OK && ret != BZ_STREAM_END)\n         { BZ_SETERR(ret); return 0; };\n\n      if (ret == BZ_OK && myfeof(bzf->handle) &&\n          bzf->strm.avail_in == 0 && bzf->strm.avail_out > 0)\n         { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };\n\n      if (ret == BZ_STREAM_END)\n         { BZ_SETERR(BZ_STREAM_END);\n           return len - bzf->strm.avail_out; };\n      if (bzf->strm.avail_out == 0)\n         { BZ_SETERR(BZ_OK); return len; };\n\n   }\n\n   return 0; /*not reached*/\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzReadGetUnused)\n                     ( int*    bzerror,\n                       BZFILE* b,\n                       void**  unused,\n                       int*    nUnused )\n{\n   bzFile* bzf = (bzFile*)b;\n   if (bzf == NULL)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n   if (bzf->lastErr != BZ_STREAM_END)\n      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };\n   if (unused == NULL || nUnused == NULL)\n      { BZ_SETERR(BZ_PARAM_ERROR); return; };\n\n   BZ_SETERR(BZ_OK);\n   *nUnused = bzf->strm.avail_in;\n   *unused = bzf->strm.next_in;\n}\n#endif\n\n\n/*---------------------------------------------------*/\n/*--- Misc convenience stuff                      ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzBuffToBuffCompress)\n                         ( char*         dest,\n                           unsigned int* destLen,\n                           char*         source,\n                           unsigned int  sourceLen,\n                           int           blockSize100k,\n                           int           verbosity,\n                           int           workFactor )\n{\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL || destLen == NULL ||\n       source == NULL ||\n       blockSize100k < 1 || blockSize100k > 9 ||\n       verbosity < 0 || verbosity > 4 ||\n       workFactor < 0 || workFactor > 250)\n      return BZ_PARAM_ERROR;\n\n   if (workFactor == 0) workFactor = 30;\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzCompressInit ( &strm, blockSize100k,\n                              verbosity, workFactor );\n   if (ret != BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzCompress ( &strm, BZ_FINISH );\n   if (ret == BZ_FINISH_OK) goto output_overflow;\n   if (ret != BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;\n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OK;\n\n   output_overflow:\n   BZ2_bzCompressEnd ( &strm );\n   return BZ_OUTBUFF_FULL;\n\n   errhandler:\n   BZ2_bzCompressEnd ( &strm );\n   return ret;\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzBuffToBuffDecompress)\n                           ( char*         dest,\n                             unsigned int* destLen,\n                             char*         source,\n                             unsigned int  sourceLen,\n                             int           small,\n                             int           verbosity )\n{\n   bz_stream strm;\n   int ret;\n\n   if (dest == NULL || destLen == NULL ||\n       source == NULL ||\n       (small != 0 && small != 1) ||\n       verbosity < 0 || verbosity > 4)\n          return BZ_PARAM_ERROR;\n\n   strm.bzalloc = NULL;\n   strm.bzfree = NULL;\n   strm.opaque = NULL;\n   ret = BZ2_bzDecompressInit ( &strm, verbosity, small );\n   if (ret != BZ_OK) return ret;\n\n   strm.next_in = source;\n   strm.next_out = dest;\n   strm.avail_in = sourceLen;\n   strm.avail_out = *destLen;\n\n   ret = BZ2_bzDecompress ( &strm );\n   if (ret == BZ_OK) goto output_overflow_or_eof;\n   if (ret != BZ_STREAM_END) goto errhandler;\n\n   /* normal termination */\n   *destLen -= strm.avail_out;\n   BZ2_bzDecompressEnd ( &strm );\n   return BZ_OK;\n\n   output_overflow_or_eof:\n   if (strm.avail_out > 0) {\n      BZ2_bzDecompressEnd ( &strm );\n      return BZ_UNEXPECTED_EOF;\n   } else {\n      BZ2_bzDecompressEnd ( &strm );\n      return BZ_OUTBUFF_FULL;\n   };\n\n   errhandler:\n   BZ2_bzDecompressEnd ( &strm );\n   return ret;\n}\n\n\n/*---------------------------------------------------*/\n/*--\n   Code contributed by Yoshioka Tsuneo\n   (QWF00133@niftyserve.or.jp/tsuneo-y@is.aist-nara.ac.jp),\n   to support better zlib compatibility.\n   This code is not _officially_ part of libbzip2 (yet);\n   I haven't tested it, documented it, or considered the\n   threading-safeness of it.\n   If this code breaks, please contact both Yoshioka and me.\n--*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\n/*--\n   return version like \"0.9.0c\".\n--*/\nconst char * BZ_API(BZ2_bzlibVersion)(void)\n{\n   return BZ_VERSION;\n}\n\n\n#ifndef BZ_NO_STDIO\n/*---------------------------------------------------*/\n\n#if defined(_WIN32) || defined(OS2) || defined(MSDOS)\n#   include <fcntl.h>\n#   include <io.h>\n#   define SET_BINARY_MODE(file) setmode(fileno(file),O_BINARY)\n#else\n#   define SET_BINARY_MODE(file)\n#endif\nstatic\nBZFILE * bzopen_or_bzdopen\n               ( const char *path,   /* no use when bzdopen */\n                 int fd,             /* no use when bzdopen */\n                 const char *mode,\n                 int open_mode)      /* bzopen: 0, bzdopen:1 */\n{\n   int    bzerr;\n   char   unused\u00ddBZ_MAX_UNUSED\u00a8;\n   int    blockSize100k = 9;\n   int    writing       = 0;\n   char   mode2\u00dd10\u00a8     = \"\";\n   FILE   *fp           = NULL;\n   BZFILE *bzfp         = NULL;\n   int    verbosity     = 0;\n   int    workFactor    = 30;\n   int    smallMode     = 0;\n   int    nUnused       = 0;\n\n   if (mode == NULL) return NULL;\n   while (*mode) {\n      switch (*mode) {\n      case 'r':\n         writing = 0; break;\n      case 'w':\n         writing = 1; break;\n      case 's':\n         smallMode = 1; break;\n      default:\n         if (isdigit((int)(*mode))) {\n            blockSize100k = *mode-'0';\n         }\n      }\n      mode++;\n   }\n   strcat(mode2, writing ? \"w\" : \"r\" );\n   strcat(mode2,\"b\");   /* binary mode */\n\n   if (open_mode==0) {\n      if (path==NULL || strcmp(path,\"\")==0) {\n        fp = (writing ? stdout : stdin);\n        SET_BINARY_MODE(fp);\n      } else {\n        fp = fopen(path,mode2);\n      }\n   } else {\n#ifdef BZ_STRICT_ANSI\n      fp = NULL;\n#else\n      fp = fdopen(fd,mode2);\n#endif\n   }\n   if (fp == NULL) return NULL;\n\n   if (writing) {\n      /* Guard against total chaos and anarchy -- JRS */\n      if (blockSize100k < 1) blockSize100k = 1;\n      if (blockSize100k > 9) blockSize100k = 9;\n      bzfp = BZ2_bzWriteOpen(&bzerr,fp,blockSize100k,\n                             verbosity,workFactor);\n   } else {\n      bzfp = BZ2_bzReadOpen(&bzerr,fp,verbosity,smallMode,\n                            unused,nUnused);\n   }\n   if (bzfp == NULL) {\n      if (fp != stdin && fp != stdout) fclose(fp);\n      return NULL;\n   }\n   return bzfp;\n}\n\n\n/*---------------------------------------------------*/\n/*--\n   open file for read or write.\n      ex) bzopen(\"file\",\"w9\")\n      case path=\"\" or NULL => use stdin or stdout.\n--*/\nBZFILE * BZ_API(BZ2_bzopen)\n               ( const char *path,\n                 const char *mode )\n{\n   return bzopen_or_bzdopen(path,-1,mode,/*bzopen*/0);\n}\n\n\n/*---------------------------------------------------*/\nBZFILE * BZ_API(BZ2_bzdopen)\n               ( int fd,\n                 const char *mode )\n{\n   return bzopen_or_bzdopen(NULL,fd,mode,/*bzdopen*/1);\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzread) (BZFILE* b, void* buf, int len )\n{\n   int bzerr, nread;\n   if (((bzFile*)b)->lastErr == BZ_STREAM_END) return 0;\n   nread = BZ2_bzRead(&bzerr,b,buf,len);\n   if (bzerr == BZ_OK || bzerr == BZ_STREAM_END) {\n      return nread;\n   } else {\n      return -1;\n   }\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzwrite) (BZFILE* b, void* buf, int len )\n{\n   int bzerr;\n\n   BZ2_bzWrite(&bzerr,b,buf,len);\n   if(bzerr == BZ_OK){\n      return len;\n   }else{\n      return -1;\n   }\n}\n\n\n/*---------------------------------------------------*/\nint BZ_API(BZ2_bzflush) (BZFILE *b)\n{\n   /* do nothing now... */\n   return 0;\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ_API(BZ2_bzclose) (BZFILE* b)\n{\n   int bzerr;\n   FILE *fp = ((bzFile *)b)->handle;\n\n   if (b==NULL) {return;}\n   if(((bzFile*)b)->writing){\n      BZ2_bzWriteClose(&bzerr,b,0,NULL,NULL);\n      if(bzerr != BZ_OK){\n         BZ2_bzWriteClose(NULL,b,1,NULL,NULL);\n      }\n   }else{\n      BZ2_bzReadClose(&bzerr,b);\n   }\n   if(fp!=stdin && fp!=stdout){\n      fclose(fp);\n   }\n}\n\n\n/*---------------------------------------------------*/\n/*--\n   return last error code\n--*/\nstatic char *bzerrorstrings\u00dd\u00a8 = {\n       \"OK\"\n      ,\"SEQUENCE_ERROR\"\n      ,\"PARAM_ERROR\"\n      ,\"MEM_ERROR\"\n      ,\"DATA_ERROR\"\n      ,\"DATA_ERROR_MAGIC\"\n      ,\"IO_ERROR\"\n      ,\"UNEXPECTED_EOF\"\n      ,\"OUTBUFF_FULL\"\n      ,\"CONFIG_ERROR\"\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n      ,\"???\"   /* for future */\n};\n\n\nconst char * BZ_API(BZ2_bzerror) (BZFILE *b, int *errnum)\n{\n   int err = ((bzFile *)b)->lastErr;\n\n   if(err>0) err = 0;\n   *errnum = err;\n   return bzerrorstrings\u00dderr*-1\u00a8;\n}\n#endif\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                           bzlib.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 514, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*-------------------------------------------------------------*/\n/*--- Compression machinery (not incl block sorting)        ---*/\n/*---                                            compress.c ---*/\n/*-------------------------------------------------------------*/\n\n/*--\n  This file is a part of bzip2 and/or libbzip2, a program and\n  library for lossless, block-sorting data compression.\n\n  Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n\n  2. The origin of this software must not be misrepresented; you must\n     not claim that you wrote the original software.  If you use this\n     software in a product, an acknowledgment in the product\n     documentation would be appreciated but is not required.\n\n  3. Altered source versions must be plainly marked as such, and must\n     not be misrepresented as being the original software.\n\n  4. The name of the author may not be used to endorse or promote\n     products derived from this software without specific prior written\n     permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  Julian Seward, Cambridge, UK.\n  jseward@acm.org\n  bzip2/libbzip2 version 1.0 of 21 March 2000\n\n  This program is based on (at least) the work of:\n     Mike Burrows\n     David Wheeler\n     Peter Fenwick\n     Alistair Moffat\n     Radford Neal\n     Ian H. Witten\n     Robert Sedgewick\n     Jon L. Bentley\n\n  For more information on these sources, see the manual.\n--*/\n\n/*--\n   CHANGES\n   ~~~~~~~\n   0.9.0 -- original version.\n\n   0.9.0a/b -- no changes in this file.\n\n   0.9.0c\n      * changed setting of nGroups in sendMTFValues() so as to\n        do a bit better on small files\n--*/\n\n#include \"bzlibprv.h\"\n\n\n/*---------------------------------------------------*/\n/*--- Bit stream I/O                              ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nvoid BZ2_bsInitWrite ( EState* s )\n{\n   s->bsLive = 0;\n   s->bsBuff = 0;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid bsFinishWrite ( EState* s )\n{\n   while (s->bsLive > 0) {\n      s->zbits\u00dds->numZ\u00a8 = (UChar)(s->bsBuff >> 24);\n      s->numZ++;\n      s->bsBuff <<= 8;\n      s->bsLive -= 8;\n   }\n}\n\n\n/*---------------------------------------------------*/\n#define bsNEEDW(nz)                           \\\n{                                             \\\n   while (s->bsLive >= 8) {                   \\\n      s->zbits\u00dds->numZ\u00a8                       \\\n         = (UChar)(s->bsBuff >> 24);          \\\n      s->numZ++;                              \\\n      s->bsBuff <<= 8;                        \\\n      s->bsLive -= 8;                         \\\n   }                                          \\\n}\n\n\n/*---------------------------------------------------*/\nstatic\n__inline__\nvoid bsW ( EState* s, Int32 n, UInt32 v )\n{\n   bsNEEDW ( n );\n   s->bsBuff |= (v << (32 - s->bsLive - n));\n   s->bsLive += n;\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid bsPutUInt32 ( EState* s, UInt32 u )\n{\n   bsW ( s, 8, (u >> 24) & 0xffL );\n   bsW ( s, 8, (u >> 16) & 0xffL );\n   bsW ( s, 8, (u >>  8) & 0xffL );\n   bsW ( s, 8,  u        & 0xffL );\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid bsPutUChar ( EState* s, UChar c )\n{\n   bsW( s, 8, (UInt32)c );\n}\n\n\n/*---------------------------------------------------*/\n/*--- The back end proper                         ---*/\n/*---------------------------------------------------*/\n\n/*---------------------------------------------------*/\nstatic\nvoid makeMaps_e ( EState* s )\n{\n   Int32 i;\n   s->nInUse = 0;\n   for (i = 0; i < 256; i++)\n      if (s->inUse\u00ddi\u00a8) {\n         s->unseqToSeq\u00ddi\u00a8 = s->nInUse;\n         s->nInUse++;\n      }\n}\n\n\n/*---------------------------------------------------*/\nstatic\nvoid generateMTFValues ( EState* s )\n{\n   UChar   yy\u00dd256\u00a8;\n   Int32   i, j;\n   Int32   zPend;\n   Int32   wr;\n   Int32   EOB;\n\n   /*\n      After sorting (eg, here),\n         s->arr1 \u00dd 0 .. s->nblock-1 \u00a8 holds sorted order,\n         and\n         ((UChar*)s->arr2) \u00dd 0 .. s->nblock-1 \u00a8\n         holds the original block data.\n\n      The first thing to do is generate the MTF values,\n      and put them in\n         ((UInt16*)s->arr1) \u00dd 0 .. s->nblock-1 \u00a8.\n      Because there are strictly fewer or equal MTF values\n      than block values, ptr values in this area are overwritten\n      with MTF values only when they are no longer needed.\n\n      The final compressed bitstream is generated into the\n      area starting at\n         (UChar*) (&((UChar*)s->arr2)\u00dds->nblock\u00a8)\n\n      These storage aliases are set up in bzCompressInit(),\n      except for the last one, which is arranged in\n      compressBlock().\n   */\n   UInt32* ptr   = s->ptr;\n   UChar* block  = s->block;\n   UInt16* mtfv  = s->mtfv;\n\n   makeMaps_e ( s );\n   EOB = s->nInUse+1;\n\n   for (i = 0; i <= EOB; i++) s->mtfFreq\u00ddi\u00a8 = 0;\n\n   wr = 0;\n   zPend = 0;\n   for (i = 0; i < s->nInUse; i++) yy\u00ddi\u00a8 = (UChar) i;\n\n   for (i = 0; i < s->nblock; i++) {\n      UChar ll_i;\n      AssertD ( wr <= i, \"generateMTFValues(1)\" );\n      j = ptr\u00ddi\u00a8-1; if (j < 0) j += s->nblock;\n      ll_i = s->unseqToSeq\u00ddblock\u00ddj\u00a8\u00a8;\n      AssertD ( ll_i < s->nInUse, \"generateMTFValues(2a)\" );\n\n      if (yy\u00dd0\u00a8 == ll_i) {\n         zPend++;\n      } else {\n\n         if (zPend > 0) {\n            zPend--;\n            while (True) {\n               if (zPend & 1) {\n                  mtfv\u00ddwr\u00a8 = BZ_RUNB; wr++;\n                  s->mtfFreq\u00ddBZ_RUNB\u00a8++;\n               } else {\n                  mtfv\u00ddwr\u00a8 = BZ_RUNA; wr++;\n                  s->mtfFreq\u00ddBZ_RUNA\u00a8++;\n               }\n               if (zPend < 2) break;\n               zPend = (zPend - 2) / 2;\n            };\n            zPend = 0;\n         }\n         {\n            register UChar  rtmp;\n            register UChar* ryy_j;\n            register UChar  rll_i;\n            rtmp  = yy\u00dd1\u00a8;\n            yy\u00dd1\u00a8 = yy\u00dd0\u00a8;\n            ryy_j = &(yy\u00dd1\u00a8);\n            rll_i = ll_i;\n            while ( rll_i != rtmp ) {\n               register UChar rtmp2;\n               ryy_j++;\n               rtmp2  = rtmp;\n               rtmp   = *ryy_j;\n               *ryy_j = rtmp2;\n            };\n            yy\u00dd0\u00a8 = rtmp;\n            j = ryy_j - &(yy\u00dd0\u00a8);\n            mtfv\u00ddwr\u00a8 = j+1; wr++; s->mtfFreq\u00ddj+1\u00a8++;\n         }\n\n      }\n   }\n\n   if (zPend > 0) {\n      zPend--;\n      while (True) {\n         if (zPend & 1) {\n            mtfv\u00ddwr\u00a8 = BZ_RUNB; wr++;\n            s->mtfFreq\u00ddBZ_RUNB\u00a8++;\n         } else {\n            mtfv\u00ddwr\u00a8 = BZ_RUNA; wr++;\n            s->mtfFreq\u00ddBZ_RUNA\u00a8++;\n         }\n         if (zPend < 2) break;\n         zPend = (zPend - 2) / 2;\n      };\n      zPend = 0;\n   }\n\n   mtfv\u00ddwr\u00a8 = EOB; wr++; s->mtfFreq\u00ddEOB\u00a8++;\n\n   s->nMTF = wr;\n}\n\n\n/*---------------------------------------------------*/\n#define BZ_LESSER_ICOST  0\n#define BZ_GREATER_ICOST 15\n\nstatic\nvoid sendMTFValues ( EState* s )\n{\n   Int32 v, t, i, j, gs, ge, totc, bt, bc, iter;\n   Int32 nSelectors, alphaSize, minLen, maxLen, selCtr;\n   Int32 nGroups, nBytes;\n\n   /*--\n   UChar  len \u00ddBZ_N_GROUPS\u00a8\u00ddBZ_MAX_ALPHA_SIZE\u00a8;\n   is a global since the decoder also needs it.\n\n   Int32  code\u00ddBZ_N_GROUPS\u00a8\u00ddBZ_MAX_ALPHA_SIZE\u00a8;\n   Int32  rfreq\u00ddBZ_N_GROUPS\u00a8\u00ddBZ_MAX_ALPHA_SIZE\u00a8;\n   are also globals only used in this proc.\n   Made global to keep stack frame size small.\n   --*/\n\n\n   UInt16 cost\u00ddBZ_N_GROUPS\u00a8;\n   Int32  fave\u00ddBZ_N_GROUPS\u00a8;\n\n   UInt16* mtfv = s->mtfv;\n\n   if (s->verbosity >= 3)\n      VPrintf3( \"      %d in block, %d after MTF & 1-2 coding, \"\n                \"%d+2 syms in use\\n\",\n                s->nblock, s->nMTF, s->nInUse );\n\n   alphaSize = s->nInUse+2;\n   for (t = 0; t < BZ_N_GROUPS; t++)\n      for (v = 0; v < alphaSize; v++)\n         s->len\u00ddt\u00a8\u00ddv\u00a8 = BZ_GREATER_ICOST;\n\n   /*--- Decide how many coding tables to use ---*/\n   AssertH ( s->nMTF > 0, 3001 );\n   if (s->nMTF < 200)  nGroups = 2; else\n   if (s->nMTF < 600)  nGroups = 3; else\n   if (s->nMTF < 1200) nGroups = 4; else\n   if (s->nMTF < 2400) nGroups = 5; else\n                       nGroups = 6;\n\n   /*--- Generate an initial set of coding tables ---*/\n   {\n      Int32 nPart, remF, tFreq, aFreq;\n\n      nPart = nGroups;\n      remF  = s->nMTF;\n      gs = 0;\n      while (nPart > 0) {\n         tFreq = remF / nPart;\n         ge = gs-1;\n         aFreq = 0;\n         while (aFreq < tFreq && ge < alphaSize-1) {\n            ge++;\n            aFreq += s->mtfFreq\u00ddge\u00a8;\n         }\n\n         if (ge > gs\n             && nPart != nGroups && nPart != 1\n             && ((nGroups-nPart) % 2 == 1)) {\n            aFreq -= s->mtfFreq\u00ddge\u00a8;\n            ge--;\n         }\n\n         if (s->verbosity >= 3)\n            VPrintf5( \"      initial group %d, \u00dd%d .. %d\u00a8, \"\n                      \"has %d syms (%4.1f%%)\\n\",\n                      nPart, gs, ge, aFreq,\n                      (100.0 * (float)aFreq) / (float)(s->nMTF) );\n\n         for (v = 0; v < alphaSize; v++)\n            if (v >= gs && v <= ge)\n               s->len\u00ddnPart-1\u00a8\u00ddv\u00a8 = BZ_LESSER_ICOST; else\n               s->len\u00ddnPart-1\u00a8\u00ddv\u00a8 = BZ_GREATER_ICOST;\n\n         nPart--;\n         gs = ge+1;\n         remF -= aFreq;\n      }\n   }\n\n   /*---\n      Iterate up to BZ_N_ITERS times to improve the tables.\n   ---*/\n   for (iter = 0; iter < BZ_N_ITERS; iter++) {\n\n      for (t = 0; t < nGroups; t++) fave\u00ddt\u00a8 = 0;\n\n      for (t = 0; t < nGroups; t++)\n         for (v = 0; v < alphaSize; v++)\n            s->rfreq\u00ddt\u00a8\u00ddv\u00a8 = 0;\n\n      /*---\n        Set up an auxiliary length table which is used to fast-track\n\tthe common case (nGroups == 6).\n      ---*/\n      if (nGroups == 6) {\n         for (v = 0; v < alphaSize; v++) {\n            s->len_pack\u00ddv\u00a8\u00dd0\u00a8 = (s->len\u00dd1\u00a8\u00ddv\u00a8 << 16) | s->len\u00dd0\u00a8\u00ddv\u00a8;\n            s->len_pack\u00ddv\u00a8\u00dd1\u00a8 = (s->len\u00dd3\u00a8\u00ddv\u00a8 << 16) | s->len\u00dd2\u00a8\u00ddv\u00a8;\n            s->len_pack\u00ddv\u00a8\u00dd2\u00a8 = (s->len\u00dd5\u00a8\u00ddv\u00a8 << 16) | s->len\u00dd4\u00a8\u00ddv\u00a8;\n\t }\n      }\n\n      nSelectors = 0;\n      totc = 0;\n      gs = 0;\n      while (True) {\n\n         /*--- Set group start & end marks. --*/\n         if (gs >= s->nMTF) break;\n         ge = gs + BZ_G_SIZE - 1;\n         if (ge >= s->nMTF) ge = s->nMTF-1;\n\n         /*--\n            Calculate the cost of this group as coded\n            by each of the coding tables.\n         --*/\n         for (t = 0; t < nGroups; t++) cost\u00ddt\u00a8 = 0;\n\n         if (nGroups == 6 && 50 == ge-gs+1) {\n            /*--- fast track the common case ---*/\n            register UInt32 cost01, cost23, cost45;\n            register UInt16 icv;\n            cost01 = cost23 = cost45 = 0;\n\n#           define BZ_ITER(nn)                \\\n               icv = mtfv\u00ddgs+(nn)\u00a8;           \\\n               cost01 += s->len_pack\u00ddicv\u00a8\u00dd0\u00a8; \\\n               cost23 += s->len_pack\u00ddicv\u00a8\u00dd1\u00a8; \\\n               cost45 += s->len_pack\u00ddicv\u00a8\u00dd2\u00a8; \\\n\n            BZ_ITER(0);  BZ_ITER(1);  BZ_ITER(2);  BZ_ITER(3);  BZ_ITER(4);\n            BZ_ITER(5);  BZ_ITER(6);  BZ_ITER(7);  BZ_ITER(8);  BZ_ITER(9);\n            BZ_ITER(10); BZ_ITER(11); BZ_ITER(12); BZ_ITER(13); BZ_ITER(14);\n            BZ_ITER(15); BZ_ITER(16); BZ_ITER(17); BZ_ITER(18); BZ_ITER(19);\n            BZ_ITER(20); BZ_ITER(21); BZ_ITER(22); BZ_ITER(23); BZ_ITER(24);\n            BZ_ITER(25); BZ_ITER(26); BZ_ITER(27); BZ_ITER(28); BZ_ITER(29);\n            BZ_ITER(30); BZ_ITER(31); BZ_ITER(32); BZ_ITER(33); BZ_ITER(34);\n            BZ_ITER(35); BZ_ITER(36); BZ_ITER(37); BZ_ITER(38); BZ_ITER(39);\n            BZ_ITER(40); BZ_ITER(41); BZ_ITER(42); BZ_ITER(43); BZ_ITER(44);\n            BZ_ITER(45); BZ_ITER(46); BZ_ITER(47); BZ_ITER(48); BZ_ITER(49);\n\n#           undef BZ_ITER\n\n            cost\u00dd0\u00a8 = cost01 & 0xffff; cost\u00dd1\u00a8 = cost01 >> 16;\n            cost\u00dd2\u00a8 = cost23 & 0xffff; cost\u00dd3\u00a8 = cost23 >> 16;\n            cost\u00dd4\u00a8 = cost45 & 0xffff; cost\u00dd5\u00a8 = cost45 >> 16;\n\n         } else {\n\t    /*--- slow version which correctly handles all situations ---*/\n            for (i = gs; i <= ge; i++) {\n               UInt16 icv = mtfv\u00ddi\u00a8;\n               for (t = 0; t < nGroups; t++) cost\u00ddt\u00a8 += s->len\u00ddt\u00a8\u00ddicv\u00a8;\n            }\n         }\n\n         /*--\n            Find the coding table which is best for this group,\n            and record its identity in the selector table.\n         --*/\n         bc = 999999999; bt = -1;\n         for (t = 0; t < nGroups; t++)\n            if (cost\u00ddt\u00a8 < bc) { bc = cost\u00ddt\u00a8; bt = t; };\n         totc += bc;\n         fave\u00ddbt\u00a8++;\n         s->selector\u00ddnSelectors\u00a8 = bt;\n         nSelectors++;\n\n         /*--\n            Increment the symbol frequencies for the selected table.\n          --*/\n         if (nGroups == 6 && 50 == ge-gs+1) {\n            /*--- fast track the common case ---*/\n\n#           define BZ_ITUR(nn) s->rfreq\u00ddbt\u00a8\u00dd mtfv\u00ddgs+(nn)\u00a8 \u00a8++\n\n            BZ_ITUR(0);  BZ_ITUR(1);  BZ_ITUR(2);  BZ_ITUR(3);  BZ_ITUR(4);\n            BZ_ITUR(5);  BZ_ITUR(6);  BZ_ITUR(7);  BZ_ITUR(8);  BZ_ITUR(9);\n            BZ_ITUR(10); BZ_ITUR(11); BZ_ITUR(12); BZ_ITUR(13); BZ_ITUR(14);\n            BZ_ITUR(15); BZ_ITUR(16); BZ_ITUR(17); BZ_ITUR(18); BZ_ITUR(19);\n            BZ_ITUR(20); BZ_ITUR(21); BZ_ITUR(22); BZ_ITUR(23); BZ_ITUR(24);\n            BZ_ITUR(25); BZ_ITUR(26); BZ_ITUR(27); BZ_ITUR(28); BZ_ITUR(29);\n            BZ_ITUR(30); BZ_ITUR(31); BZ_ITUR(32); BZ_ITUR(33); BZ_ITUR(34);\n            BZ_ITUR(35); BZ_ITUR(36); BZ_ITUR(37); BZ_ITUR(38); BZ_ITUR(39);\n            BZ_ITUR(40); BZ_ITUR(41); BZ_ITUR(42); BZ_ITUR(43); BZ_ITUR(44);\n            BZ_ITUR(45); BZ_ITUR(46); BZ_ITUR(47); BZ_ITUR(48); BZ_ITUR(49);\n\n#           undef BZ_ITUR\n\n         } else {\n\t    /*--- slow version which correctly handles all situations ---*/\n            for (i = gs; i <= ge; i++)\n               s->rfreq\u00ddbt\u00a8\u00dd mtfv\u00ddi\u00a8 \u00a8++;\n         }\n\n         gs = ge+1;\n      }\n      if (s->verbosity >= 3) {\n         VPrintf2 ( \"      pass %d: size is %d, grp uses are \",\n                   iter+1, totc/8 );\n         for (t = 0; t < nGroups; t++)\n            VPrintf1 ( \"%d \", fave\u00ddt\u00a8 );\n         VPrintf0 ( \"\\n\" );\n      }\n\n      /*--\n        Recompute the tables based on the accumulated frequencies.\n      --*/\n      for (t = 0; t < nGroups; t++)\n         BZ2_hbMakeCodeLengths ( &(s->len\u00ddt\u00a8\u00dd0\u00a8), &(s->rfreq\u00ddt\u00a8\u00dd0\u00a8),\n                                 alphaSize, 20 );\n   }\n\n\n   AssertH( nGroups < 8, 3002 );\n   AssertH( nSelectors < 32768 &&\n            nSelectors <= (2 + (900000 / BZ_G_SIZE)),\n            3003 );\n\n\n   /*--- Compute MTF values for the selectors. ---*/\n   {\n      UChar pos\u00ddBZ_N_GROUPS\u00a8, ll_i, tmp2, tmp;\n      for (i = 0; i < nGroups; i++) pos\u00ddi\u00a8 = i;\n      for (i = 0; i < nSelectors; i++) {\n         ll_i = s->selector\u00ddi\u00a8;\n         j = 0;\n         tmp = pos\u00ddj\u00a8;\n         while ( ll_i != tmp ) {\n            j++;\n            tmp2 = tmp;\n            tmp = pos\u00ddj\u00a8;\n            pos\u00ddj\u00a8 = tmp2;\n         };\n         pos\u00dd0\u00a8 = tmp;\n         s->selectorMtf\u00ddi\u00a8 = j;\n      }\n   };\n\n   /*--- Assign actual codes for the tables. --*/\n   for (t = 0; t < nGroups; t++) {\n      minLen = 32;\n      maxLen = 0;\n      for (i = 0; i < alphaSize; i++) {\n         if (s->len\u00ddt\u00a8\u00ddi\u00a8 > maxLen) maxLen = s->len\u00ddt\u00a8\u00ddi\u00a8;\n         if (s->len\u00ddt\u00a8\u00ddi\u00a8 < minLen) minLen = s->len\u00ddt\u00a8\u00ddi\u00a8;\n      }\n      AssertH ( !(maxLen > 20), 3004 );\n      AssertH ( !(minLen < 1),  3005 );\n      BZ2_hbAssignCodes ( &(s->code\u00ddt\u00a8\u00dd0\u00a8), &(s->len\u00ddt\u00a8\u00dd0\u00a8),\n                          minLen, maxLen, alphaSize );\n   }\n\n   /*--- Transmit the mapping table. ---*/\n   {\n      Bool inUse16\u00dd16\u00a8;\n      for (i = 0; i < 16; i++) {\n          inUse16\u00ddi\u00a8 = False;\n          for (j = 0; j < 16; j++)\n             if (s->inUse\u00ddi * 16 + j\u00a8) inUse16\u00ddi\u00a8 = True;\n      }\n\n      nBytes = s->numZ;\n      for (i = 0; i < 16; i++)\n         if (inUse16\u00ddi\u00a8) bsW(s,1,1); else bsW(s,1,0);\n\n      for (i = 0; i < 16; i++)\n         if (inUse16\u00ddi\u00a8)\n            for (j = 0; j < 16; j++) {\n               if (s->inUse\u00ddi * 16 + j\u00a8) bsW(s,1,1); else bsW(s,1,0);\n            }\n\n      if (s->verbosity >= 3)\n         VPrintf1( \"      bytes: mapping %d, \", s->numZ-nBytes );\n   }\n\n   /*--- Now the selectors. ---*/\n   nBytes = s->numZ;\n   bsW ( s, 3, nGroups );\n   bsW ( s, 15, nSelectors );\n   for (i = 0; i < nSelectors; i++) {\n      for (j = 0; j < s->selectorMtf\u00ddi\u00a8; j++) bsW(s,1,1);\n      bsW(s,1,0);\n   }\n   if (s->verbosity >= 3)\n      VPrintf1( \"selectors %d, \", s->numZ-nBytes );\n\n   /*--- Now the coding tables. ---*/\n   nBytes = s->numZ;\n\n   for (t = 0; t < nGroups; t++) {\n      Int32 curr = s->len\u00ddt\u00a8\u00dd0\u00a8;\n      bsW ( s, 5, curr );\n      for (i = 0; i < alphaSize; i++) {\n         while (curr < s->len\u00ddt\u00a8\u00ddi\u00a8) { bsW(s,2,2); curr++; /* 10 */ };\n         while (curr > s->len\u00ddt\u00a8\u00ddi\u00a8) { bsW(s,2,3); curr--; /* 11 */ };\n         bsW ( s, 1, 0 );\n      }\n   }\n\n   if (s->verbosity >= 3)\n      VPrintf1 ( \"code lengths %d, \", s->numZ-nBytes );\n\n   /*--- And finally, the block data proper ---*/\n   nBytes = s->numZ;\n   selCtr = 0;\n   gs = 0;\n   while (True) {\n      if (gs >= s->nMTF) break;\n      ge = gs + BZ_G_SIZE - 1;\n      if (ge >= s->nMTF) ge = s->nMTF-1;\n      AssertH ( s->selector\u00ddselCtr\u00a8 < nGroups, 3006 );\n\n      if (nGroups == 6 && 50 == ge-gs+1) {\n            /*--- fast track the common case ---*/\n            UInt16 mtfv_i;\n            UChar* s_len_sel_selCtr\n               = &(s->len\u00dds->selector\u00ddselCtr\u00a8\u00a8\u00dd0\u00a8);\n            Int32* s_code_sel_selCtr\n               = &(s->code\u00dds->selector\u00ddselCtr\u00a8\u00a8\u00dd0\u00a8);\n\n#           define BZ_ITAH(nn)                      \\\n               mtfv_i = mtfv\u00ddgs+(nn)\u00a8;              \\\n               bsW ( s,                             \\\n                     s_len_sel_selCtr\u00ddmtfv_i\u00a8,      \\\n                     s_code_sel_selCtr\u00ddmtfv_i\u00a8 )\n\n            BZ_ITAH(0);  BZ_ITAH(1);  BZ_ITAH(2);  BZ_ITAH(3);  BZ_ITAH(4);\n            BZ_ITAH(5);  BZ_ITAH(6);  BZ_ITAH(7);  BZ_ITAH(8);  BZ_ITAH(9);\n            BZ_ITAH(10); BZ_ITAH(11); BZ_ITAH(12); BZ_ITAH(13); BZ_ITAH(14);\n            BZ_ITAH(15); BZ_ITAH(16); BZ_ITAH(17); BZ_ITAH(18); BZ_ITAH(19);\n            BZ_ITAH(20); BZ_ITAH(21); BZ_ITAH(22); BZ_ITAH(23); BZ_ITAH(24);\n            BZ_ITAH(25); BZ_ITAH(26); BZ_ITAH(27); BZ_ITAH(28); BZ_ITAH(29);\n            BZ_ITAH(30); BZ_ITAH(31); BZ_ITAH(32); BZ_ITAH(33); BZ_ITAH(34);\n            BZ_ITAH(35); BZ_ITAH(36); BZ_ITAH(37); BZ_ITAH(38); BZ_ITAH(39);\n            BZ_ITAH(40); BZ_ITAH(41); BZ_ITAH(42); BZ_ITAH(43); BZ_ITAH(44);\n            BZ_ITAH(45); BZ_ITAH(46); BZ_ITAH(47); BZ_ITAH(48); BZ_ITAH(49);\n\n#           undef BZ_ITAH\n\n      } else {\n\t /*--- slow version which correctly handles all situations ---*/\n         for (i = gs; i <= ge; i++) {\n            bsW ( s,\n                  s->len  \u00dds->selector\u00ddselCtr\u00a8\u00a8 \u00ddmtfv\u00ddi\u00a8\u00a8,\n                  s->code \u00dds->selector\u00ddselCtr\u00a8\u00a8 \u00ddmtfv\u00ddi\u00a8\u00a8 );\n         }\n      }\n\n\n      gs = ge+1;\n      selCtr++;\n   }\n   AssertH( selCtr == nSelectors, 3007 );\n\n   if (s->verbosity >= 3)\n      VPrintf1( \"codes %d\\n\", s->numZ-nBytes );\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ2_compressBlock ( EState* s, Bool is_last_block )\n{\n   if (s->nblock > 0) {\n\n      BZ_FINALISE_CRC ( s->blockCRC );\n      s->combinedCRC = (s->combinedCRC << 1) | (s->combinedCRC >> 31);\n      s->combinedCRC \u00ac= s->blockCRC;\n      if (s->blockNo > 1) s->numZ = 0;\n\n      if (s->verbosity >= 2)\n         VPrintf4( \"    block %d: crc = 0x%8x, \"\n                   \"combined CRC = 0x%8x, size = %d\\n\",\n                   s->blockNo, s->blockCRC, s->combinedCRC, s->nblock );\n\n      BZ2_blockSort ( s );\n   }\n\n   s->zbits = (UChar*) (&((UChar*)s->arr2)\u00dds->nblock\u00a8);\n\n   /*-- If this is the first block, create the stream header. --*/\n   if (s->blockNo == 1) {\n      BZ2_bsInitWrite ( s );\n      bsPutUChar ( s, BZ_HDR_B );\n      bsPutUChar ( s, BZ_HDR_Z );\n      bsPutUChar ( s, BZ_HDR_h );\n      bsPutUChar ( s, (UChar)( BZ_HDR_0 + s->blockSize100k ) );\n   }\n\n   if (s->nblock > 0) {\n\n      bsPutUChar ( s, 0x31 ); bsPutUChar ( s, 0x41 );\n      bsPutUChar ( s, 0x59 ); bsPutUChar ( s, 0x26 );\n      bsPutUChar ( s, 0x53 ); bsPutUChar ( s, 0x59 );\n\n      /*-- Now the block's CRC, so it is in a known place. --*/\n      bsPutUInt32 ( s, s->blockCRC );\n\n      /*--\n         Now a single bit indicating (non-)randomisation.\n         As of version 0.9.5, we use a better sorting algorithm\n         which makes randomisation unnecessary.  So always set\n         the randomised bit to 'no'.  Of course, the decoder\n         still needs to be able to handle randomised blocks\n         so as to maintain backwards compatibility with\n         older versions of bzip2.\n      --*/\n      bsW(s,1,0);\n\n      bsW ( s, 24, s->origPtr );\n      generateMTFValues ( s );\n      sendMTFValues ( s );\n   }\n\n\n   /*-- If this is the last block, add the stream trailer. --*/\n   if (is_last_block) {\n\n      bsPutUChar ( s, 0x17 ); bsPutUChar ( s, 0x72 );\n      bsPutUChar ( s, 0x45 ); bsPutUChar ( s, 0x38 );\n      bsPutUChar ( s, 0x50 ); bsPutUChar ( s, 0x90 );\n      bsPutUInt32 ( s, s->combinedCRC );\n      if (s->verbosity >= 2)\n         VPrintf1( \"    final combined CRC = 0x%x\\n   \", s->combinedCRC );\n      bsFinishWrite ( s );\n   }\n}\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                        compress.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRCTABLE": {"ttr": 523, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*-------------------------------------------------------------*/\n/*--- Table for doing CRCs                                  ---*/\n/*---                                            crctable.c ---*/\n/*-------------------------------------------------------------*/\n\n/*--\n  This file is a part of bzip2 and/or libbzip2, a program and\n  library for lossless, block-sorting data compression.\n\n  Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n\n  2. The origin of this software must not be misrepresented; you must\n     not claim that you wrote the original software.  If you use this\n     software in a product, an acknowledgment in the product\n     documentation would be appreciated but is not required.\n\n  3. Altered source versions must be plainly marked as such, and must\n     not be misrepresented as being the original software.\n\n  4. The name of the author may not be used to endorse or promote\n     products derived from this software without specific prior written\n     permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  Julian Seward, Cambridge, UK.\n  jseward@acm.org\n  bzip2/libbzip2 version 1.0 of 21 March 2000\n\n  This program is based on (at least) the work of:\n     Mike Burrows\n     David Wheeler\n     Peter Fenwick\n     Alistair Moffat\n     Radford Neal\n     Ian H. Witten\n     Robert Sedgewick\n     Jon L. Bentley\n\n  For more information on these sources, see the manual.\n--*/\n\n\n#include \"bzlibprv.h\"\n\n/*--\n  I think this is an implementation of the AUTODIN-II,\n  Ethernet & FDDI 32-bit CRC standard.  Vaguely derived\n  from code by Rob Warnock, in Section 51 of the\n  comp.compression FAQ.\n--*/\n\nUInt32 BZ2_crc32Table\u00dd256\u00a8 = {\n\n   /*-- Ugly, innit? --*/\n\n   0x00000000L, 0x04c11db7L, 0x09823b6eL, 0x0d4326d9L,\n   0x130476dcL, 0x17c56b6bL, 0x1a864db2L, 0x1e475005L,\n   0x2608edb8L, 0x22c9f00fL, 0x2f8ad6d6L, 0x2b4bcb61L,\n   0x350c9b64L, 0x31cd86d3L, 0x3c8ea00aL, 0x384fbdbdL,\n   0x4c11db70L, 0x48d0c6c7L, 0x4593e01eL, 0x4152fda9L,\n   0x5f15adacL, 0x5bd4b01bL, 0x569796c2L, 0x52568b75L,\n   0x6a1936c8L, 0x6ed82b7fL, 0x639b0da6L, 0x675a1011L,\n   0x791d4014L, 0x7ddc5da3L, 0x709f7b7aL, 0x745e66cdL,\n   0x9823b6e0L, 0x9ce2ab57L, 0x91a18d8eL, 0x95609039L,\n   0x8b27c03cL, 0x8fe6dd8bL, 0x82a5fb52L, 0x8664e6e5L,\n   0xbe2b5b58L, 0xbaea46efL, 0xb7a96036L, 0xb3687d81L,\n   0xad2f2d84L, 0xa9ee3033L, 0xa4ad16eaL, 0xa06c0b5dL,\n   0xd4326d90L, 0xd0f37027L, 0xddb056feL, 0xd9714b49L,\n   0xc7361b4cL, 0xc3f706fbL, 0xceb42022L, 0xca753d95L,\n   0xf23a8028L, 0xf6fb9d9fL, 0xfbb8bb46L, 0xff79a6f1L,\n   0xe13ef6f4L, 0xe5ffeb43L, 0xe8bccd9aL, 0xec7dd02dL,\n   0x34867077L, 0x30476dc0L, 0x3d044b19L, 0x39c556aeL,\n   0x278206abL, 0x23431b1cL, 0x2e003dc5L, 0x2ac12072L,\n   0x128e9dcfL, 0x164f8078L, 0x1b0ca6a1L, 0x1fcdbb16L,\n   0x018aeb13L, 0x054bf6a4L, 0x0808d07dL, 0x0cc9cdcaL,\n   0x7897ab07L, 0x7c56b6b0L, 0x71159069L, 0x75d48ddeL,\n   0x6b93dddbL, 0x6f52c06cL, 0x6211e6b5L, 0x66d0fb02L,\n   0x5e9f46bfL, 0x5a5e5b08L, 0x571d7dd1L, 0x53dc6066L,\n   0x4d9b3063L, 0x495a2dd4L, 0x44190b0dL, 0x40d816baL,\n   0xaca5c697L, 0xa864db20L, 0xa527fdf9L, 0xa1e6e04eL,\n   0xbfa1b04bL, 0xbb60adfcL, 0xb6238b25L, 0xb2e29692L,\n   0x8aad2b2fL, 0x8e6c3698L, 0x832f1041L, 0x87ee0df6L,\n   0x99a95df3L, 0x9d684044L, 0x902b669dL, 0x94ea7b2aL,\n   0xe0b41de7L, 0xe4750050L, 0xe9362689L, 0xedf73b3eL,\n   0xf3b06b3bL, 0xf771768cL, 0xfa325055L, 0xfef34de2L,\n   0xc6bcf05fL, 0xc27dede8L, 0xcf3ecb31L, 0xcbffd686L,\n   0xd5b88683L, 0xd1799b34L, 0xdc3abdedL, 0xd8fba05aL,\n   0x690ce0eeL, 0x6dcdfd59L, 0x608edb80L, 0x644fc637L,\n   0x7a089632L, 0x7ec98b85L, 0x738aad5cL, 0x774bb0ebL,\n   0x4f040d56L, 0x4bc510e1L, 0x46863638L, 0x42472b8fL,\n   0x5c007b8aL, 0x58c1663dL, 0x558240e4L, 0x51435d53L,\n   0x251d3b9eL, 0x21dc2629L, 0x2c9f00f0L, 0x285e1d47L,\n   0x36194d42L, 0x32d850f5L, 0x3f9b762cL, 0x3b5a6b9bL,\n   0x0315d626L, 0x07d4cb91L, 0x0a97ed48L, 0x0e56f0ffL,\n   0x1011a0faL, 0x14d0bd4dL, 0x19939b94L, 0x1d528623L,\n   0xf12f560eL, 0xf5ee4bb9L, 0xf8ad6d60L, 0xfc6c70d7L,\n   0xe22b20d2L, 0xe6ea3d65L, 0xeba91bbcL, 0xef68060bL,\n   0xd727bbb6L, 0xd3e6a601L, 0xdea580d8L, 0xda649d6fL,\n   0xc423cd6aL, 0xc0e2d0ddL, 0xcda1f604L, 0xc960ebb3L,\n   0xbd3e8d7eL, 0xb9ff90c9L, 0xb4bcb610L, 0xb07daba7L,\n   0xae3afba2L, 0xaafbe615L, 0xa7b8c0ccL, 0xa379dd7bL,\n   0x9b3660c6L, 0x9ff77d71L, 0x92b45ba8L, 0x9675461fL,\n   0x8832161aL, 0x8cf30badL, 0x81b02d74L, 0x857130c3L,\n   0x5d8a9099L, 0x594b8d2eL, 0x5408abf7L, 0x50c9b640L,\n   0x4e8ee645L, 0x4a4ffbf2L, 0x470cdd2bL, 0x43cdc09cL,\n   0x7b827d21L, 0x7f436096L, 0x7200464fL, 0x76c15bf8L,\n   0x68860bfdL, 0x6c47164aL, 0x61043093L, 0x65c52d24L,\n   0x119b4be9L, 0x155a565eL, 0x18197087L, 0x1cd86d30L,\n   0x029f3d35L, 0x065e2082L, 0x0b1d065bL, 0x0fdc1becL,\n   0x3793a651L, 0x3352bbe6L, 0x3e119d3fL, 0x3ad08088L,\n   0x2497d08dL, 0x2056cd3aL, 0x2d15ebe3L, 0x29d4f654L,\n   0xc5a92679L, 0xc1683bceL, 0xcc2b1d17L, 0xc8ea00a0L,\n   0xd6ad50a5L, 0xd26c4d12L, 0xdf2f6bcbL, 0xdbee767cL,\n   0xe3a1cbc1L, 0xe760d676L, 0xea23f0afL, 0xeee2ed18L,\n   0xf0a5bd1dL, 0xf464a0aaL, 0xf9278673L, 0xfde69bc4L,\n   0x89b8fd09L, 0x8d79e0beL, 0x803ac667L, 0x84fbdbd0L,\n   0x9abc8bd5L, 0x9e7d9662L, 0x933eb0bbL, 0x97ffad0cL,\n   0xafb010b1L, 0xab710d06L, 0xa6322bdfL, 0xa2f33668L,\n   0xbcb4666dL, 0xb8757bdaL, 0xb5365d03L, 0xb1f740b4L\n};\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                        crctable.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DECOMPR": {"ttr": 527, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*-------------------------------------------------------------*/\n/*--- Decompression machinery                               ---*/\n/*---                                          decompress.c ---*/\n/*-------------------------------------------------------------*/\n\n/*--\n  This file is a part of bzip2 and/or libbzip2, a program and\n  library for lossless, block-sorting data compression.\n\n  Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n\n  2. The origin of this software must not be misrepresented; you must\n     not claim that you wrote the original software.  If you use this\n     software in a product, an acknowledgment in the product\n     documentation would be appreciated but is not required.\n\n  3. Altered source versions must be plainly marked as such, and must\n     not be misrepresented as being the original software.\n\n  4. The name of the author may not be used to endorse or promote\n     products derived from this software without specific prior written\n     permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  Julian Seward, Cambridge, UK.\n  jseward@acm.org\n  bzip2/libbzip2 version 1.0 of 21 March 2000\n\n  This program is based on (at least) the work of:\n     Mike Burrows\n     David Wheeler\n     Peter Fenwick\n     Alistair Moffat\n     Radford Neal\n     Ian H. Witten\n     Robert Sedgewick\n     Jon L. Bentley\n\n  For more information on these sources, see the manual.\n--*/\n\n\n#include \"bzlibprv.h\"\n\n\n/*---------------------------------------------------*/\nstatic\nvoid makeMaps_d ( DState* s )\n{\n   Int32 i;\n   s->nInUse = 0;\n   for (i = 0; i < 256; i++)\n      if (s->inUse\u00ddi\u00a8) {\n         s->seqToUnseq\u00dds->nInUse\u00a8 = i;\n         s->nInUse++;\n      }\n}\n\n\n/*---------------------------------------------------*/\n#define RETURN(rrr)                               \\\n   { retVal = rrr; goto save_state_and_return; };\n\n#define GET_BITS(lll,vvv,nnn)                     \\\n   case lll: s->state = lll;                      \\\n   while (True) {                                 \\\n      if (s->bsLive >= nnn) {                     \\\n         UInt32 v;                                \\\n         v = (s->bsBuff >>                        \\\n             (s->bsLive-nnn)) & ((1 << nnn)-1);   \\\n         s->bsLive -= nnn;                        \\\n         vvv = v;                                 \\\n         break;                                   \\\n      }                                           \\\n      if (s->strm->avail_in == 0) RETURN(BZ_OK);  \\\n      s->bsBuff                                   \\\n         = (s->bsBuff << 8) |                     \\\n           ((UInt32)                              \\\n              (*((UChar*)(s->strm->next_in))));   \\\n      s->bsLive += 8;                             \\\n      s->strm->next_in++;                         \\\n      s->strm->avail_in--;                        \\\n      s->strm->total_in_lo32++;                   \\\n      if (s->strm->total_in_lo32 == 0)            \\\n         s->strm->total_in_hi32++;                \\\n   }\n\n#define GET_UCHAR(lll,uuu)                        \\\n   GET_BITS(lll,uuu,8)\n\n#define GET_BIT(lll,uuu)                          \\\n   GET_BITS(lll,uuu,1)\n\n/*---------------------------------------------------*/\n#define GET_MTF_VAL(label1,label2,lval)           \\\n{                                                 \\\n   if (groupPos == 0) {                           \\\n      groupNo++;                                  \\\n      if (groupNo >= nSelectors)                  \\\n         RETURN(BZ_DATA_ERROR);                   \\\n      groupPos = BZ_G_SIZE;                       \\\n      gSel = s->selector\u00ddgroupNo\u00a8;                \\\n      gMinlen = s->minLens\u00ddgSel\u00a8;                 \\\n      gLimit = &(s->limit\u00ddgSel\u00a8\u00dd0\u00a8);              \\\n      gPerm = &(s->perm\u00ddgSel\u00a8\u00dd0\u00a8);                \\\n      gBase = &(s->base\u00ddgSel\u00a8\u00dd0\u00a8);                \\\n   }                                              \\\n   groupPos--;                                    \\\n   zn = gMinlen;                                  \\\n   GET_BITS(label1, zvec, zn);                    \\\n   while (1) {                                    \\\n      if (zn > 20 /* the longest code */)         \\\n         RETURN(BZ_DATA_ERROR);                   \\\n      if (zvec <= gLimit\u00ddzn\u00a8) break;              \\\n      zn++;                                       \\\n      GET_BIT(label2, zj);                        \\\n      zvec = (zvec << 1) | zj;                    \\\n   };                                             \\\n   if (zvec - gBase\u00ddzn\u00a8 < 0                       \\\n       || zvec - gBase\u00ddzn\u00a8 >= BZ_MAX_ALPHA_SIZE)  \\\n      RETURN(BZ_DATA_ERROR);                      \\\n   lval = gPerm\u00ddzvec - gBase\u00ddzn\u00a8\u00a8;                \\\n}\n\n\n/*---------------------------------------------------*/\nInt32 BZ2_decompress ( DState* s )\n{\n   UChar      uc;\n   Int32      retVal;\n   Int32      minLen, maxLen;\n   bz_stream* strm = s->strm;\n\n   /* stuff that needs to be saved/restored */\n   Int32  i;\n   Int32  j;\n   Int32  t;\n   Int32  alphaSize;\n   Int32  nGroups;\n   Int32  nSelectors;\n   Int32  EOB;\n   Int32  groupNo;\n   Int32  groupPos;\n   Int32  nextSym;\n   Int32  nblockMAX;\n   Int32  nblock;\n   Int32  es;\n   Int32  N;\n   Int32  curr;\n   Int32  zt;\n   Int32  zn;\n   Int32  zvec;\n   Int32  zj;\n   Int32  gSel;\n   Int32  gMinlen;\n   Int32* gLimit;\n   Int32* gBase;\n   Int32* gPerm;\n\n   if (s->state == BZ_X_MAGIC_1) {\n      /*initialise the save area*/\n      s->save_i           = 0;\n      s->save_j           = 0;\n      s->save_t           = 0;\n      s->save_alphaSize   = 0;\n      s->save_nGroups     = 0;\n      s->save_nSelectors  = 0;\n      s->save_EOB         = 0;\n      s->save_groupNo     = 0;\n      s->save_groupPos    = 0;\n      s->save_nextSym     = 0;\n      s->save_nblockMAX   = 0;\n      s->save_nblock      = 0;\n      s->save_es          = 0;\n      s->save_N           = 0;\n      s->save_curr        = 0;\n      s->save_zt          = 0;\n      s->save_zn          = 0;\n      s->save_zvec        = 0;\n      s->save_zj          = 0;\n      s->save_gSel        = 0;\n      s->save_gMinlen     = 0;\n      s->save_gLimit      = NULL;\n      s->save_gBase       = NULL;\n      s->save_gPerm       = NULL;\n   }\n\n   /*restore from the save area*/\n   i           = s->save_i;\n   j           = s->save_j;\n   t           = s->save_t;\n   alphaSize   = s->save_alphaSize;\n   nGroups     = s->save_nGroups;\n   nSelectors  = s->save_nSelectors;\n   EOB         = s->save_EOB;\n   groupNo     = s->save_groupNo;\n   groupPos    = s->save_groupPos;\n   nextSym     = s->save_nextSym;\n   nblockMAX   = s->save_nblockMAX;\n   nblock      = s->save_nblock;\n   es          = s->save_es;\n   N           = s->save_N;\n   curr        = s->save_curr;\n   zt          = s->save_zt;\n   zn          = s->save_zn;\n   zvec        = s->save_zvec;\n   zj          = s->save_zj;\n   gSel        = s->save_gSel;\n   gMinlen     = s->save_gMinlen;\n   gLimit      = s->save_gLimit;\n   gBase       = s->save_gBase;\n   gPerm       = s->save_gPerm;\n\n   retVal = BZ_OK;\n\n   switch (s->state) {\n\n      GET_UCHAR(BZ_X_MAGIC_1, uc);\n      if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_2, uc);\n      if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_3, uc)\n      if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)\n      if (s->blockSize100k < BZ_HDR_0 + 1 ||\n          s->blockSize100k > BZ_HDR_0 + 9) RETURN(BZ_DATA_ERROR_MAGIC);\n      s->blockSize100k -= BZ_HDR_0;\n\n      if (s->smallDecompress) {\n         s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );\n         s->ll4  = BZALLOC(\n                      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar)\n                   );\n         if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);\n      } else {\n         s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );\n         if (s->tt == NULL) RETURN(BZ_MEM_ERROR);\n      }\n\n      GET_UCHAR(BZ_X_BLKHDR_1, uc);\n\n      if (uc == 0x17) goto endhdr_2;\n      if (uc != 0x31) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_2, uc);\n      if (uc != 0x41) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_3, uc);\n      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_4, uc);\n      if (uc != 0x26) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_5, uc);\n      if (uc != 0x53) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_6, uc);\n      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n\n      s->currBlockNo++;\n      if (s->verbosity >= 2)\n         VPrintf1 ( \"\\n    \u00dd%d: huff+mtf \", s->currBlockNo );\n\n      s->storedBlockCRC = 0;\n      GET_UCHAR(BZ_X_BCRC_1, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_2, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_3, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_4, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n\n      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);\n\n      s->origPtr = 0;\n      GET_UCHAR(BZ_X_ORIGPTR_1, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_2, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_3, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n\n      if (s->origPtr < 0)\n         RETURN(BZ_DATA_ERROR);\n      if (s->origPtr > 10 + 100000*s->blockSize100k)\n         RETURN(BZ_DATA_ERROR);\n\n      /*--- Receive the mapping table ---*/\n      for (i = 0; i < 16; i++) {\n         GET_BIT(BZ_X_MAPPING_1, uc);\n         if (uc == 1)\n            s->inUse16\u00ddi\u00a8 = True; else\n            s->inUse16\u00ddi\u00a8 = False;\n      }\n\n      for (i = 0; i < 256; i++) s->inUse\u00ddi\u00a8 = False;\n\n      for (i = 0; i < 16; i++)\n         if (s->inUse16\u00ddi\u00a8)\n            for (j = 0; j < 16; j++) {\n               GET_BIT(BZ_X_MAPPING_2, uc);\n               if (uc == 1) s->inUse\u00ddi * 16 + j\u00a8 = True;\n            }\n      makeMaps_d ( s );\n      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);\n      alphaSize = s->nInUse+2;\n\n      /*--- Now the selectors ---*/\n      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);\n      if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR);\n      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);\n      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);\n      for (i = 0; i < nSelectors; i++) {\n         j = 0;\n         while (True) {\n            GET_BIT(BZ_X_SELECTOR_3, uc);\n            if (uc == 0) break;\n            j++;\n            if (j >= nGroups) RETURN(BZ_DATA_ERROR);\n         }\n         s->selectorMtf\u00ddi\u00a8 = j;\n      }\n\n      /*--- Undo the MTF values for the selectors. ---*/\n      {\n         UChar pos\u00ddBZ_N_GROUPS\u00a8, tmp, v;\n         for (v = 0; v < nGroups; v++) pos\u00ddv\u00a8 = v;\n\n         for (i = 0; i < nSelectors; i++) {\n            v = s->selectorMtf\u00ddi\u00a8;\n            tmp = pos\u00ddv\u00a8;\n            while (v > 0) { pos\u00ddv\u00a8 = pos\u00ddv-1\u00a8; v--; }\n            pos\u00dd0\u00a8 = tmp;\n            s->selector\u00ddi\u00a8 = tmp;\n         }\n      }\n\n      /*--- Now the coding tables ---*/\n      for (t = 0; t < nGroups; t++) {\n         GET_BITS(BZ_X_CODING_1, curr, 5);\n         for (i = 0; i < alphaSize; i++) {\n            while (True) {\n               if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);\n               GET_BIT(BZ_X_CODING_2, uc);\n               if (uc == 0) break;\n               GET_BIT(BZ_X_CODING_3, uc);\n               if (uc == 0) curr++; else curr--;\n            }\n            s->len\u00ddt\u00a8\u00ddi\u00a8 = curr;\n         }\n      }\n\n      /*--- Create the Huffman decoding tables ---*/\n      for (t = 0; t < nGroups; t++) {\n         minLen = 32;\n         maxLen = 0;\n         for (i = 0; i < alphaSize; i++) {\n            if (s->len\u00ddt\u00a8\u00ddi\u00a8 > maxLen) maxLen = s->len\u00ddt\u00a8\u00ddi\u00a8;\n            if (s->len\u00ddt\u00a8\u00ddi\u00a8 < minLen) minLen = s->len\u00ddt\u00a8\u00ddi\u00a8;\n         }\n         BZ2_hbCreateDecodeTables (\n            &(s->limit\u00ddt\u00a8\u00dd0\u00a8),\n            &(s->base\u00ddt\u00a8\u00dd0\u00a8),\n            &(s->perm\u00ddt\u00a8\u00dd0\u00a8),\n            &(s->len\u00ddt\u00a8\u00dd0\u00a8),\n            minLen, maxLen, alphaSize\n         );\n         s->minLens\u00ddt\u00a8 = minLen;\n      }\n\n      /*--- Now the MTF values ---*/\n\n      EOB      = s->nInUse+1;\n      nblockMAX = 100000 * s->blockSize100k;\n      groupNo  = -1;\n      groupPos = 0;\n\n      for (i = 0; i <= 255; i++) s->unzftab\u00ddi\u00a8 = 0;\n\n      /*-- MTF init --*/\n      {\n         Int32 ii, jj, kk;\n         kk = MTFA_SIZE-1;\n         for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {\n            for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n               s->mtfa\u00ddkk\u00a8 = (UChar)(ii * MTFL_SIZE + jj);\n               kk--;\n            }\n            s->mtfbase\u00ddii\u00a8 = kk + 1;\n         }\n      }\n      /*-- end MTF init --*/\n\n      nblock = 0;\n      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);\n\n      while (True) {\n\n         if (nextSym == EOB) break;\n\n         if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {\n\n            es = -1;\n            N = 1;\n            do {\n               if (nextSym == BZ_RUNA) es = es + (0+1) * N; else\n               if (nextSym == BZ_RUNB) es = es + (1+1) * N;\n               N = N * 2;\n               GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);\n            }\n               while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);\n\n            es++;\n            uc = s->seqToUnseq\u00dd s->mtfa\u00dds->mtfbase\u00dd0\u00a8\u00a8 \u00a8;\n            s->unzftab\u00dduc\u00a8 += es;\n\n            if (s->smallDecompress)\n               while (es > 0) {\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->ll16\u00ddnblock\u00a8 = (UInt16)uc;\n                  nblock++;\n                  es--;\n               }\n            else\n               while (es > 0) {\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->tt\u00ddnblock\u00a8 = (UInt32)uc;\n                  nblock++;\n                  es--;\n               };\n\n            continue;\n\n         } else {\n\n            if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n\n            /*-- uc = MTF ( nextSym-1 ) --*/\n            {\n               Int32 ii, jj, kk, pp, lno, off;\n               UInt32 nn;\n               nn = (UInt32)(nextSym - 1);\n\n               if (nn < MTFL_SIZE) {\n                  /* avoid general-case expense */\n                  pp = s->mtfbase\u00dd0\u00a8;\n                  uc = s->mtfa\u00ddpp+nn\u00a8;\n                  while (nn > 3) {\n                     Int32 z = pp+nn;\n                     s->mtfa\u00dd(z)  \u00a8 = s->mtfa\u00dd(z)-1\u00a8;\n                     s->mtfa\u00dd(z)-1\u00a8 = s->mtfa\u00dd(z)-2\u00a8;\n                     s->mtfa\u00dd(z)-2\u00a8 = s->mtfa\u00dd(z)-3\u00a8;\n                     s->mtfa\u00dd(z)-3\u00a8 = s->mtfa\u00dd(z)-4\u00a8;\n                     nn -= 4;\n                  }\n                  while (nn > 0) {\n                     s->mtfa\u00dd(pp+nn)\u00a8 = s->mtfa\u00dd(pp+nn)-1\u00a8; nn--;\n                  };\n                  s->mtfa\u00ddpp\u00a8 = uc;\n               } else {\n                  /* general case */\n                  lno = nn / MTFL_SIZE;\n                  off = nn % MTFL_SIZE;\n                  pp = s->mtfbase\u00ddlno\u00a8 + off;\n                  uc = s->mtfa\u00ddpp\u00a8;\n                  while (pp > s->mtfbase\u00ddlno\u00a8) {\n                     s->mtfa\u00ddpp\u00a8 = s->mtfa\u00ddpp-1\u00a8; pp--;\n                  };\n                  s->mtfbase\u00ddlno\u00a8++;\n                  while (lno > 0) {\n                     s->mtfbase\u00ddlno\u00a8--;\n                     s->mtfa\u00dds->mtfbase\u00ddlno\u00a8\u00a8\n                        = s->mtfa\u00dds->mtfbase\u00ddlno-1\u00a8 + MTFL_SIZE - 1\u00a8;\n                     lno--;\n                  }\n                  s->mtfbase\u00dd0\u00a8--;\n                  s->mtfa\u00dds->mtfbase\u00dd0\u00a8\u00a8 = uc;\n                  if (s->mtfbase\u00dd0\u00a8 == 0) {\n                     kk = MTFA_SIZE-1;\n                     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {\n                        for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n                           s->mtfa\u00ddkk\u00a8 = s->mtfa\u00dds->mtfbase\u00ddii\u00a8 + jj\u00a8;\n                           kk--;\n                        }\n                        s->mtfbase\u00ddii\u00a8 = kk + 1;\n                     }\n                  }\n               }\n            }\n            /*-- end uc = MTF ( nextSym-1 ) --*/\n\n            s->unzftab\u00dds->seqToUnseq\u00dduc\u00a8\u00a8++;\n            if (s->smallDecompress)\n               s->ll16\u00ddnblock\u00a8 = (UInt16)(s->seqToUnseq\u00dduc\u00a8); else\n               s->tt\u00ddnblock\u00a8   = (UInt32)(s->seqToUnseq\u00dduc\u00a8);\n            nblock++;\n\n            GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);\n            continue;\n         }\n      }\n\n      /* Now we know what nblock is, we can do a better sanity\n         check on s->origPtr.\n      */\n      if (s->origPtr < 0 || s->origPtr >= nblock)\n         RETURN(BZ_DATA_ERROR);\n\n      s->state_out_len = 0;\n      s->state_out_ch  = 0;\n      BZ_INITIALISE_CRC ( s->calculatedBlockCRC );\n      s->state = BZ_X_OUTPUT;\n      if (s->verbosity >= 2) VPrintf0 ( \"rt+rld\" );\n\n      /*-- Set up cftab to facilitate generation of T\u00ac(-1) --*/\n      s->cftab\u00dd0\u00a8 = 0;\n      for (i = 1; i <= 256; i++) s->cftab\u00ddi\u00a8 = s->unzftab\u00ddi-1\u00a8;\n      for (i = 1; i <= 256; i++) s->cftab\u00ddi\u00a8 += s->cftab\u00ddi-1\u00a8;\n\n      if (s->smallDecompress) {\n\n         /*-- Make a copy of cftab, used in generation of T --*/\n         for (i = 0; i <= 256; i++) s->cftabCopy\u00ddi\u00a8 = s->cftab\u00ddi\u00a8;\n\n         /*-- compute the T vector --*/\n         for (i = 0; i < nblock; i++) {\n            uc = (UChar)(s->ll16\u00ddi\u00a8);\n            SET_LL(i, s->cftabCopy\u00dduc\u00a8);\n            s->cftabCopy\u00dduc\u00a8++;\n         }\n\n         /*-- Compute T\u00ac(-1) by pointer reversal on T --*/\n         i = s->origPtr;\n         j = GET_LL(i);\n         do {\n            Int32 tmp = GET_LL(j);\n            SET_LL(j, i);\n            i = j;\n            j = tmp;\n         }\n            while (i != s->origPtr);\n\n         s->tPos = s->origPtr;\n         s->nblock_used = 0;\n         if (s->blockRandomised) {\n            BZ_RAND_INIT_MASK;\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 \u00ac= BZ_RAND_MASK;\n         } else {\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n         }\n\n      } else {\n\n         /*-- compute the T\u00ac(-1) vector --*/\n         for (i = 0; i < nblock; i++) {\n            uc = (UChar)(s->tt\u00ddi\u00a8 & 0xff);\n            s->tt\u00dds->cftab\u00dduc\u00a8\u00a8 |= (i << 8);\n            s->cftab\u00dduc\u00a8++;\n         }\n\n         s->tPos = s->tt\u00dds->origPtr\u00a8 >> 8;\n         s->nblock_used = 0;\n         if (s->blockRandomised) {\n            BZ_RAND_INIT_MASK;\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 \u00ac= BZ_RAND_MASK;\n         } else {\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n         }\n\n      }\n\n      RETURN(BZ_OK);\n\n\n\n    endhdr_2:\n\n      GET_UCHAR(BZ_X_ENDHDR_2, uc);\n      if (uc != 0x72) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_3, uc);\n      if (uc != 0x45) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_4, uc);\n      if (uc != 0x38) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_5, uc);\n      if (uc != 0x50) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_6, uc);\n      if (uc != 0x90) RETURN(BZ_DATA_ERROR);\n\n      s->storedCombinedCRC = 0;\n      GET_UCHAR(BZ_X_CCRC_1, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_2, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_3, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_4, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n\n      s->state = BZ_X_IDLE;\n      RETURN(BZ_STREAM_END);\n\n      default: AssertH ( False, 4001 );\n   }\n\n   AssertH ( False, 4002 );\n\n   save_state_and_return:\n\n   s->save_i           = i;\n   s->save_j           = j;\n   s->save_t           = t;\n   s->save_alphaSize   = alphaSize;\n   s->save_nGroups     = nGroups;\n   s->save_nSelectors  = nSelectors;\n   s->save_EOB         = EOB;\n   s->save_groupNo     = groupNo;\n   s->save_groupPos    = groupPos;\n   s->save_nextSym     = nextSym;\n   s->save_nblockMAX   = nblockMAX;\n   s->save_nblock      = nblock;\n   s->save_es          = es;\n   s->save_N           = N;\n   s->save_curr        = curr;\n   s->save_zt          = zt;\n   s->save_zn          = zn;\n   s->save_zvec        = zvec;\n   s->save_zj          = zj;\n   s->save_gSel        = gSel;\n   s->save_gMinlen     = gMinlen;\n   s->save_gLimit      = gLimit;\n   s->save_gBase       = gBase;\n   s->save_gPerm       = gPerm;\n\n   return retVal;\n}\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                      decompress.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HUFFMAN": {"ttr": 774, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*-------------------------------------------------------------*/\n/*--- Huffman coding low-level stuff                        ---*/\n/*---                                             huffman.c ---*/\n/*-------------------------------------------------------------*/\n\n/*--\n  This file is a part of bzip2 and/or libbzip2, a program and\n  library for lossless, block-sorting data compression.\n\n  Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n\n  2. The origin of this software must not be misrepresented; you must\n     not claim that you wrote the original software.  If you use this\n     software in a product, an acknowledgment in the product\n     documentation would be appreciated but is not required.\n\n  3. Altered source versions must be plainly marked as such, and must\n     not be misrepresented as being the original software.\n\n  4. The name of the author may not be used to endorse or promote\n     products derived from this software without specific prior written\n     permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  Julian Seward, Cambridge, UK.\n  jseward@acm.org\n  bzip2/libbzip2 version 1.0 of 21 March 2000\n\n  This program is based on (at least) the work of:\n     Mike Burrows\n     David Wheeler\n     Peter Fenwick\n     Alistair Moffat\n     Radford Neal\n     Ian H. Witten\n     Robert Sedgewick\n     Jon L. Bentley\n\n  For more information on these sources, see the manual.\n--*/\n\n\n#include \"bzlibprv.h\"\n\n/*---------------------------------------------------*/\n#define WEIGHTOF(zz0)  ((zz0) & 0xffffff00)\n#define DEPTHOF(zz1)   ((zz1) & 0x000000ff)\n#define MYMAX(zz2,zz3) ((zz2) > (zz3) ? (zz2) : (zz3))\n\n#define ADDWEIGHTS(zw1,zw2)                           \\\n   (WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \\\n   (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))\n\n#define UPHEAP(z)                                     \\\n{                                                     \\\n   Int32 zz, tmp;                                     \\\n   zz = z; tmp = heap\u00ddzz\u00a8;                            \\\n   while (weight\u00ddtmp\u00a8 < weight\u00ddheap\u00ddzz >> 1\u00a8\u00a8) {      \\\n      heap\u00ddzz\u00a8 = heap\u00ddzz >> 1\u00a8;                       \\\n      zz >>= 1;                                       \\\n   }                                                  \\\n   heap\u00ddzz\u00a8 = tmp;                                    \\\n}\n\n#define DOWNHEAP(z)                                   \\\n{                                                     \\\n   Int32 zz, yy, tmp;                                 \\\n   zz = z; tmp = heap\u00ddzz\u00a8;                            \\\n   while (True) {                                     \\\n      yy = zz << 1;                                   \\\n      if (yy > nHeap) break;                          \\\n      if (yy < nHeap &&                               \\\n          weight\u00ddheap\u00ddyy+1\u00a8\u00a8 < weight\u00ddheap\u00ddyy\u00a8\u00a8)      \\\n         yy++;                                        \\\n      if (weight\u00ddtmp\u00a8 < weight\u00ddheap\u00ddyy\u00a8\u00a8) break;      \\\n      heap\u00ddzz\u00a8 = heap\u00ddyy\u00a8;                            \\\n      zz = yy;                                        \\\n   }                                                  \\\n   heap\u00ddzz\u00a8 = tmp;                                    \\\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ2_hbMakeCodeLengths ( UChar *len,\n                             Int32 *freq,\n                             Int32 alphaSize,\n                             Int32 maxLen )\n{\n   /*--\n      Nodes and heap entries run from 1.  Entry 0\n      for both the heap and nodes is a sentinel.\n   --*/\n   Int32 nNodes, nHeap, n1, n2, i, j, k;\n   Bool  tooLong;\n\n   Int32 heap   \u00dd BZ_MAX_ALPHA_SIZE + 2 \u00a8;\n   Int32 weight \u00dd BZ_MAX_ALPHA_SIZE * 2 \u00a8;\n   Int32 parent \u00dd BZ_MAX_ALPHA_SIZE * 2 \u00a8;\n\n   for (i = 0; i < alphaSize; i++)\n      weight\u00ddi+1\u00a8 = (freq\u00ddi\u00a8 == 0 ? 1 : freq\u00ddi\u00a8) << 8;\n\n   while (True) {\n\n      nNodes = alphaSize;\n      nHeap = 0;\n\n      heap\u00dd0\u00a8 = 0;\n      weight\u00dd0\u00a8 = 0;\n      parent\u00dd0\u00a8 = -2;\n\n      for (i = 1; i <= alphaSize; i++) {\n         parent\u00ddi\u00a8 = -1;\n         nHeap++;\n         heap\u00ddnHeap\u00a8 = i;\n         UPHEAP(nHeap);\n      }\n\n      AssertH( nHeap < (BZ_MAX_ALPHA_SIZE+2), 2001 );\n\n      while (nHeap > 1) {\n         n1 = heap\u00dd1\u00a8; heap\u00dd1\u00a8 = heap\u00ddnHeap\u00a8; nHeap--; DOWNHEAP(1);\n         n2 = heap\u00dd1\u00a8; heap\u00dd1\u00a8 = heap\u00ddnHeap\u00a8; nHeap--; DOWNHEAP(1);\n         nNodes++;\n         parent\u00ddn1\u00a8 = parent\u00ddn2\u00a8 = nNodes;\n         weight\u00ddnNodes\u00a8 = ADDWEIGHTS(weight\u00ddn1\u00a8, weight\u00ddn2\u00a8);\n         parent\u00ddnNodes\u00a8 = -1;\n         nHeap++;\n         heap\u00ddnHeap\u00a8 = nNodes;\n         UPHEAP(nHeap);\n      }\n\n      AssertH( nNodes < (BZ_MAX_ALPHA_SIZE * 2), 2002 );\n\n      tooLong = False;\n      for (i = 1; i <= alphaSize; i++) {\n         j = 0;\n         k = i;\n         while (parent\u00ddk\u00a8 >= 0) { k = parent\u00ddk\u00a8; j++; }\n         len\u00ddi-1\u00a8 = j;\n         if (j > maxLen) tooLong = True;\n      }\n\n      if (! tooLong) break;\n\n      for (i = 1; i < alphaSize; i++) {\n         j = weight\u00ddi\u00a8 >> 8;\n         j = 1 + (j / 2);\n         weight\u00ddi\u00a8 = j << 8;\n      }\n   }\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ2_hbAssignCodes ( Int32 *code,\n                         UChar *length,\n                         Int32 minLen,\n                         Int32 maxLen,\n                         Int32 alphaSize )\n{\n   Int32 n, vec, i;\n\n   vec = 0;\n   for (n = minLen; n <= maxLen; n++) {\n      for (i = 0; i < alphaSize; i++)\n         if (length\u00ddi\u00a8 == n) { code\u00ddi\u00a8 = vec; vec++; };\n      vec <<= 1;\n   }\n}\n\n\n/*---------------------------------------------------*/\nvoid BZ2_hbCreateDecodeTables ( Int32 *limit,\n                                Int32 *base,\n                                Int32 *perm,\n                                UChar *length,\n                                Int32 minLen,\n                                Int32 maxLen,\n                                Int32 alphaSize )\n{\n   Int32 pp, i, j, vec;\n\n   pp = 0;\n   for (i = minLen; i <= maxLen; i++)\n      for (j = 0; j < alphaSize; j++)\n         if (length\u00ddj\u00a8 == i) { perm\u00ddpp\u00a8 = j; pp++; };\n\n   for (i = 0; i < BZ_MAX_CODE_LEN; i++) base\u00ddi\u00a8 = 0;\n   for (i = 0; i < alphaSize; i++) base\u00ddlength\u00ddi\u00a8+1\u00a8++;\n\n   for (i = 1; i < BZ_MAX_CODE_LEN; i++) base\u00ddi\u00a8 += base\u00ddi-1\u00a8;\n\n   for (i = 0; i < BZ_MAX_CODE_LEN; i++) limit\u00ddi\u00a8 = 0;\n   vec = 0;\n\n   for (i = minLen; i <= maxLen; i++) {\n      vec += (base\u00ddi+1\u00a8 - base\u00ddi\u00a8);\n      limit\u00ddi\u00a8 = vec-1;\n      vec <<= 1;\n   }\n   for (i = minLen + 1; i <= maxLen; i++)\n      base\u00ddi\u00a8 = ((limit\u00ddi-1\u00a8 + 1) << 1) - base\u00ddi\u00a8;\n}\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                         huffman.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LICENSE": {"ttr": 778, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\nThis program, \"bzip2\" and associated library \"libbzip2\", are\ncopyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. The origin of this software must not be misrepresented; you must\n   not claim that you wrote the original software.  If you use this\n   software in a product, an acknowledgment in the product\n   documentation would be appreciated but is not required.\n\n3. Altered source versions must be plainly marked as such, and must\n   not be misrepresented as being the original software.\n\n4. The name of the author may not be used to endorse or promote\n   products derived from this software without specific prior written\n   permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\nGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nJulian Seward, Cambridge, UK.\njseward@acm.org\nbzip2/libbzip2 version 1.0 of 21 March 2000\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RANDTAB": {"ttr": 780, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/*-------------------------------------------------------------*/\n/*--- Table for randomising repetitive blocks               ---*/\n/*---                                           randtable.c ---*/\n/*-------------------------------------------------------------*/\n\n/*--\n  This file is a part of bzip2 and/or libbzip2, a program and\n  library for lossless, block-sorting data compression.\n\n  Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n\n  2. The origin of this software must not be misrepresented; you must\n     not claim that you wrote the original software.  If you use this\n     software in a product, an acknowledgment in the product\n     documentation would be appreciated but is not required.\n\n  3. Altered source versions must be plainly marked as such, and must\n     not be misrepresented as being the original software.\n\n  4. The name of the author may not be used to endorse or promote\n     products derived from this software without specific prior written\n     permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  Julian Seward, Cambridge, UK.\n  jseward@acm.org\n  bzip2/libbzip2 version 1.0 of 21 March 2000\n\n  This program is based on (at least) the work of:\n     Mike Burrows\n     David Wheeler\n     Peter Fenwick\n     Alistair Moffat\n     Radford Neal\n     Ian H. Witten\n     Robert Sedgewick\n     Jon L. Bentley\n\n  For more information on these sources, see the manual.\n--*/\n\n\n#include \"bzlibprv.h\"\n\n\n/*---------------------------------------------*/\nInt32 BZ2_rNums\u00dd512\u00a8 = {\n   619, 720, 127, 481, 931, 816, 813, 233, 566, 247,\n   985, 724, 205, 454, 863, 491, 741, 242, 949, 214,\n   733, 859, 335, 708, 621, 574, 73, 654, 730, 472,\n   419, 436, 278, 496, 867, 210, 399, 680, 480, 51,\n   878, 465, 811, 169, 869, 675, 611, 697, 867, 561,\n   862, 687, 507, 283, 482, 129, 807, 591, 733, 623,\n   150, 238, 59, 379, 684, 877, 625, 169, 643, 105,\n   170, 607, 520, 932, 727, 476, 693, 425, 174, 647,\n   73, 122, 335, 530, 442, 853, 695, 249, 445, 515,\n   909, 545, 703, 919, 874, 474, 882, 500, 594, 612,\n   641, 801, 220, 162, 819, 984, 589, 513, 495, 799,\n   161, 604, 958, 533, 221, 400, 386, 867, 600, 782,\n   382, 596, 414, 171, 516, 375, 682, 485, 911, 276,\n   98, 553, 163, 354, 666, 933, 424, 341, 533, 870,\n   227, 730, 475, 186, 263, 647, 537, 686, 600, 224,\n   469, 68, 770, 919, 190, 373, 294, 822, 808, 206,\n   184, 943, 795, 384, 383, 461, 404, 758, 839, 887,\n   715, 67, 618, 276, 204, 918, 873, 777, 604, 560,\n   951, 160, 578, 722, 79, 804, 96, 409, 713, 940,\n   652, 934, 970, 447, 318, 353, 859, 672, 112, 785,\n   645, 863, 803, 350, 139, 93, 354, 99, 820, 908,\n   609, 772, 154, 274, 580, 184, 79, 626, 630, 742,\n   653, 282, 762, 623, 680, 81, 927, 626, 789, 125,\n   411, 521, 938, 300, 821, 78, 343, 175, 128, 250,\n   170, 774, 972, 275, 999, 639, 495, 78, 352, 126,\n   857, 956, 358, 619, 580, 124, 737, 594, 701, 612,\n   669, 112, 134, 694, 363, 992, 809, 743, 168, 974,\n   944, 375, 748, 52, 600, 747, 642, 182, 862, 81,\n   344, 805, 988, 739, 511, 655, 814, 334, 249, 515,\n   897, 955, 664, 981, 649, 113, 974, 459, 893, 228,\n   433, 837, 553, 268, 926, 240, 102, 654, 459, 51,\n   686, 754, 806, 760, 493, 403, 415, 394, 687, 700,\n   946, 670, 656, 610, 738, 392, 760, 799, 887, 653,\n   978, 321, 576, 617, 626, 502, 894, 679, 243, 440,\n   680, 879, 194, 572, 640, 724, 926, 56, 204, 700,\n   707, 151, 457, 449, 797, 195, 791, 558, 945, 679,\n   297, 59, 87, 824, 713, 663, 412, 693, 342, 606,\n   134, 108, 571, 364, 631, 212, 174, 643, 304, 329,\n   343, 97, 430, 751, 497, 314, 983, 374, 822, 928,\n   140, 206, 73, 263, 980, 736, 876, 478, 430, 305,\n   170, 514, 364, 692, 829, 82, 855, 953, 676, 246,\n   369, 970, 294, 750, 807, 827, 150, 790, 288, 923,\n   804, 378, 215, 828, 592, 281, 565, 555, 710, 82,\n   896, 831, 547, 261, 524, 462, 293, 465, 502, 56,\n   661, 821, 976, 991, 658, 869, 905, 758, 745, 193,\n   768, 550, 608, 933, 378, 286, 215, 979, 792, 961,\n   61, 688, 793, 644, 986, 403, 106, 366, 905, 644,\n   372, 567, 466, 434, 645, 210, 389, 550, 919, 135,\n   780, 773, 635, 389, 707, 100, 626, 958, 165, 504,\n   920, 176, 193, 713, 857, 265, 203, 50, 668, 108,\n   645, 990, 626, 197, 510, 357, 358, 850, 858, 364,\n   936, 638\n};\n\n\n/*-------------------------------------------------------------*/\n/*--- end                                       randtable.c ---*/\n/*-------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT541/CBT.V500.FILE541.PDS/X$BZC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT541/CBT.V500.FILE541.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}