{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20140327200102000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 3120, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "IBMUSER.CCKD.ASM", "INMMEMBR": "IBMUSER.CCKD.ASM", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"IBMUSER.CCKD.ASM": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 3120, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "140086", "DS1SCEXT": "b'\\x80\\x0c0'", "DS1SCALO": "b'P\\x00\\x000'", "DS1LSTAR": "b'\\x008\\x05'", "DS1TRBAL": "b'\\xcc\\x88'"}, "COPYR2": {"deb": "b'\\x0c\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8fU\\xa0\\x00\\x04\\x98\\xcbX'", "extents": ["b'\\x0c\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8fU\\xa0\\x00\\x04\\x98\\xcbX'", "b'X\\xf5\\x1d(\\x00\\x00\\x01,\\x00\\x0e\\x01-\\x00\\x0b\\x00\\r'", "b'X\\xf5\\x1d(\\x00\\x00\\x01d\\x00\\t\\x01d\\x00\\x0c\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x01d\\x00\\r\\x01e\\x00\\x01\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x01e\\x00\\x02\\x01e\\x00\\x05\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x01e\\x00\\x06\\x01e\\x00\\t\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x01e\\x00\\n\\x01e\\x00\\r\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x01\\xac\\x00\\x00\\x01\\xac\\x00\\x03\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x01\\xad\\x00\\x04\\x01\\xad\\x00\\x07\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x01\\xad\\x00\\x08\\x01\\xad\\x00\\x0b\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x02\\x01\\x00\\x0b\\x02\\x01\\x00\\x0e\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x03\\x89\\x00\\x08\\x03\\x89\\x00\\x0b\\x00\\x04'", "b'X\\xf5\\x1d(\\x00\\x00\\x03\\x89\\x00\\x0c\\x03\\x8a\\x00\\x00\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"CCKDDUMP": {"ttr": 12299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00 \\x01\\x14\\x08o\\x01\\x14\\x08o\\x15H\\x08\\xef\\x08\\xef\\x00\\x00\\xc3\\xe5\\xc1\\xd9\\xd3\\xc5\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2014-03-27T00:00:00", "modifydate": "2014-03-27T15:48:20", "lines": 2287, "newlines": 2287, "modlines": 0, "user": "CVARLET"}, "text": "*/* ----------------------------------------------------------------\n* *      build a dasd file from sysut1 to sysut2\n* * ---------------------------------------------------------------- */\nversion  EQU   0\nrelease  EQU   1\nmod      EQU   15                                               CZV70\n\n*/* ----------------------------------------------------------------\n* *      macros\n* * ---------------------------------------------------------------- */\n\n         MACRO\n&L       STLE &R,&A                      store little-endian\n&L       STC  &R,&A\n         STCM &R,2,1+&A\n         STCM &R,4,2+&A\n         STCM &R,8,3+&A\n         MEND\n\n         MACRO\n&L       STHLE &R,&A                     store halfword little-endian\n&L       STC  &R,&A\n         STCM &R,2,1+&A\n         MEND\n\n         MACRO\n&L       LLE  &R,&A                      load little-endian\n&L       IC   &R,&A\n         ICM  &R,2,1+&A\n         ICM  &R,4,2+&A\n         ICM  &R,8,3+&A\n         MEND\n\n         MACRO\n&L       LHLE &R,&A                      load halfword little-endian\n&L       SLR  &R,&R\n         IC   &R,&A\n         ICM  &R,2,1+&A\n         MEND\n\n         MACRO\n&L      #MSG   &LVL,&MSG,&TYPE=CALL\n         LCLA  &A,&N,&O\n         LCLC  &C\n         GBLA  &MSG_IX\n         GBLC  &MSGS(256)\n         AIF   ('&TYPE' EQ 'CALL').CALL,                               x\n               ('&TYPE' EQ 'GEN').GEN\n         MNOTE 8,'Invalid type specified'\n         MEXIT\n.*\n.CALL    ANOP\n&C       SETC  '&LVL'\n         AIF   ('&LVL' NE '').LVLOK\n&C       SETC  '1'\n.LVLOK   ANOP\n&L       CLI   msglvl,&C\n         BH    #MG&SYSNDX.X\n&MSG_IX  SETA  &MSG_IX+1\n&MSGS(&MSG_IX) SETC '&MSG'\n         L     re,=A(#MSG&MSG_IX)\n         LA    rf,L'#MSG&MSG_IX\n&A       SETA  1\n&O       SETA  0\n&N       SETA  N'&SYSLIST-2\n         AGO   .PL0\n.PLLOOP  ANOP\n         LA    re,&SYSLIST(&A+2)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX14\n         LA    rf,&SYSLIST(&A+2)\n&A       SETA  &A+1\n.PL0     AIF   (&A GT &N).PLX15\n         LA    r0,&SYSLIST(&A+2)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX0\n         LA    r1,&SYSLIST(&A+2)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX1\n         STM   re,r1,msgl+&O\n&O       SETA  &O+16\n         AGO   .PLLOOP\n.PLX14   ST    re,msgl+&O\n         AGO   .CALL2\n.PLX15   STM   re,rf,msgl+&O\n         AGO   .CALL2\n.PLX0    STM   re,r0,msgl+&O\n         AGO   .CALL2\n.PLX1    STM   re,r1,msgl+&O\n.CALL2   LA    r1,msgl\n         L     rf,=a(msg_rtn)\n         BALR  re,rf\n#MG&SYSNDX.X   DS 0H\n         MEXIT\n.*\n.GEN     ANOP\n         AIF   ('&L' EQ '').GENNOL\n&L       DS    0H\n.GENNOL  ANOP\n&A       SETA  1\n.GENLOOP AIF   (&A GT &MSG_IX).MEND\n#MSG&A   DC    C&MSGS(&A)\n&A       SETA  &A+1\n         AGO   .GENLOOP\n.MEND    MEND\n*/* ----------------------------------------------------------------\n* *\n* * ---------------------------------------------------------------- */\nmain     CSECT ,\nmain     RMODE ANY\nmain     AMODE 31\n         SAVE  (14,12),,'cckddump main() &SYSDATE &SYSTIME '\npgmid    EQU   main+5\n         LR    rc,rf\n         USING main,rc\n         LA    rb,4095(,rc)\n         USING main+4095,rb\n         LR    r2,r1\n*/* ----------------------------------------------------------------\n* *      get/clear workareas\n* * ---------------------------------------------------------------- */\n         STORAGE OBTAIN,LENGTH=vdw_len,BNDRY=PAGE\n         ST    r1,8(,rd)\n         ST    rd,4(,r1)\n         LR    rd,r1\n         USING vdw,rd\n         MVC   id,=C'vdw '\n         LA    r0,vdw+8\n         L     r1,=A(vdw_len-8)\n         SLR   rf,rf\n         MVCL  r0,re\n         ST    rd,vdw_31\n         STORAGE OBTAIN,LENGTH=vdw24_len,LOC=BELOW,BNDRY=PAGE\n         ST    r1,vdw_24\n         LR    ra,r1\n         USING vdw24,ra\n         MVC   id24,=C'vdw24'\n         LA    r0,vdw24+4\n         L     r1,=A(vdw24_len-4)\n         SLR   rf,rf\n         MVCL  r0,re\n\n*/* ----------------------------------------------------------------\n* *      try to open print file\n* * ---------------------------------------------------------------- */\n\n         MVC   prdcb,model_prdcb\n         MVC   prdcbe,model_prdcbe\npr       USING IHADCB,prdcb\n         LA    r1,prdcbe\n         ST    r1,pr.DCBDCBE\n         MVC   devtl,model_devtl\n         DEVTYPE pr.DCBDDNAM,(devta,L'devta),MF=(E,devtl)\n         LTR   rf,rf\n         BNZ   noprint\n         MVC   openl,model_openl\n         OPEN  (pr.IHADCB,OUTPUT),MODE=31,MF=(E,openl)\n        #MSG   1,'%s %d.%d.%d starting',                               x\n               pgmid,=A(version),=A(release),=A(mod)\n        #MSG   0,'main workarea is at address 0x%x, 24-bit workarea is x\n               at address 0x%x',vdw_31,vdw_24\nnoprint  DS    0H\n\n*/* ----------------------------------------------------------------\n* *      get parameters\n* * ---------------------------------------------------------------- */\n\n         LR    r1,r2\n         BAS   r9,getopts\n\n*/* ----------------------------------------------------------------\n* *      get device information for sysut1 [the volume to be dumped]\n* * ---------------------------------------------------------------- */\n\n         MVC   devtl,model_devtl\n         DEVTYPE =CL8'SYSUT1',(devta,L'devta),                         x\n               INFOLIST=devt_infol_2,MF=(E,devtl)\n         LTR   rf,rf\n         BNZ   ut1_devt_err\n         TM    devta+2,UCB3DACC          check for dasd device\n         BNO   ut1_not_dasd\n         TM    dev_flags,X'80'           check for eckd\n         BNO   ut1_not_eckd\n         L     r3,cyls\n         M     r2,trks_per_cyl           total number of trks\n         ST    r3,trks\n\n*/* ----------------------------------------------------------------\n* *      get device information for sysut2 [the file to be dumped]\n* * ---------------------------------------------------------------- */\n\n         MVC   devtl,model_devtl\n         DEVTYPE =CL8'SYSUT2',(dw,L'devta),                            x\n               INFOLIST=devt_infol_2,MF=(E,devtl)\n         LTR   rf,rf\n         BNZ   out_devt_err\n         TM    dw+2,UCB3DACC             check for dasd device\n         BNO   out_not_dasd\n\n*/* ----------------------------------------------------------------\n* *      part 1  -- determine which tracks to dump\n* *\n* *      From the vtoc, determine which tracks are to be dumped.\n* *      A vector [trk_vec] is built for each track on the volume.\n* *      If an entry is zero, then the track will not be dumped;\n* *      otherwise, the entry points to an entry in the dataset\n* *      table [dsn_area] which will contain statistics about each\n* *      dataset on the volume.  The first 3 entries in the dataset\n* *      table are special, representing free space [**free**],\n* *      track 0 [**track 0] and the vtoc [**vtoc**], respectively.\n* *\n* * ---------------------------------------------------------------- */\n\n*/* ----------------------------------------------------------------\n* *      open sysut1 vtoc\n* * ---------------------------------------------------------------- */\n\nvt       USING IHADCB,vtdcb\n         MVC   vtdcb,model_vtdcb\n         LA    r1,exlst\n         STCM  r1,7,vt.DCBEXLSA\n         LA    r1,jfcb\n         ST    r1,exlst\n         MVI   exlst,X'87'\n         MVC   openl24,model_openl24\n         RDJFCB (vt.IHADCB,INPUT),MF=(E,openl24)\n         LTR   rf,rf\n         BNZ   ut1_rdjfcb_err\nj        USING INFMJFCB,jfcb\n         MVI   j.JFCBDSNM,4              vtoc name is all x'04's\n         MVC   j.JFCBDSNM+1(L'JFCBDSNM-1),j.JFCBDSNM\n         MVC   volser,j.JFCBVOLS\n         DROP  j\n         OPEN  vt.IHADCB,TYPE=J,MF=(E,openl24)\n         TM    vt.DCBOFLGS,DCBOFOPN\n         BNO   ut1_vtoc_open_err\n         L     r2,vt.DCBDEBAD            load deb address for cvaf\n         N     r2,=A(X'00FFFFFF')\n        #MSG   1,'%s:6 vtoc opened',volser\n        #MSG   0,'%s:6 has %d cyls, %d trks/cyl and %d total trks',    x\n               volser,cyls,trks_per_cyl,trks\n\n*/* ----------------------------------------------------------------\n* *      read the format 4 dscb\n* * ---------------------------------------------------------------- */\n\nh        USING BFLHDR,bflh\n         OI    h.BFLHFL,BFLHDSCB\n         MVI   h.BFLHNOE,1\ne        USING BFLE,bflent\n         LA    r1,dscb4\n         ST    r1,e.BFLEBUF\n         OI    e.BFLEFL,BFLECHR\n         MVI   e.BFLELTH,L'dscb4\n         MVC   cvpl_area,model_cvpl\n         CVAFSEQ ACCESS=GTEQ,BUFLIST=h.BFLHDR,DEB=(r2),                x\n               BRANCH=(YES,PGM),MF=(E,cvpl_area)\n         LTR   rf,rf\n         BNZ   ut1_dscb4_err\n         DROP  h,e\nf4       USING IECSDSL4-44,dscb4\n         CLI   f4.DS4IDFMT,C'4'\n         BNE   ut1_dscb4_err\n\n*/* ----------------------------------------------------------------\n* *      calculate size of the vtoc and get an area for all dscbs\n* * ---------------------------------------------------------------- */\n\n         SLR   r4,r4\n         IC    r4,f4.DS4DEVDT\n         ST    r4,dscbs_per_trk\n         LA    r1,f4.DS4VTOCE\n         BAL   re,cnv_xtnt               r0 - starting track,          x\n                                         r1 - number of tracks\n         ST    r1,vtoc_trks\n         MR    r0,r4\n         ST    r1,total_dscbs            number of dscbs\n         MH    r1,=Y(DS1END-IECSDSL1)\n         ST    r1,vtoc_size              size of vtoc\n         STORAGE OBTAIN,LENGTH=(r1),BNDRY=PAGE   area for the vtoc\n         ST    r1,vtoc_area\n        #MSG   0,'%s:6 vtoc has %d total dscbs',                       x\n               volser,total_dscbs\n        #MSG   0,'storage obtained for vtoc area, addr 0x%x size %d',  x\n               vtoc_area,vtoc_size\n\n*/* ----------------------------------------------------------------\n* *      read the entire vtoc a track at a time\n* * ---------------------------------------------------------------- */\n\n        #MSG   0,'reading %s:6 vtoc',volser\n         L     r3,vtoc_area\n         L     r4,vtoc_trks\n         LA    r5,=XL5'0'\n         BAL   re,cvaf_bld\n         MVC   cvpl_area,model_cvpl      read the first track\n         CVAFSEQ ACCESS=GTEQ,BUFLIST=bflh,DEB=(r2),                    x\n               BRANCH=(YES,PGM),MF=(E,cvpl_area)\n         LTR   rf,rf\n         BNZ   ut1_cvaf_err\n         B     vtocnext\nvtocloop BAL   re,cvaf_bld               read another track\n         CVAFSEQ ACCESS=GT,BUFLIST=bflh,DEB=(r2),                      x\n               BRANCH=(YES,PGM),MF=(E,cvpl_area)\n         LTR   rf,rf\n         BNZ   ut1_cvaf_err\nvtocnext BCT   r4,vtocloop\n         CLOSE vtdcb,MF=(E,openl24)\n        #MSG   0,'%s:6 vtoc closed',volser\n         B     process_vtoc\n\n*/* ----------------------------------------------------------------\n* *      subroutine to build the cvaf control blocks\n* *\n* *      r3 - pointer to buffer for dscb (updated)\n* *      r5 - cchhr of 1st dscb - points to last bflearg on exit\n* * ---------------------------------------------------------------- */\n\ncvaf_bld XC    bflh,bflh\n         USING IECSDSL1,r3\nh        USING BFLHDR,bflh\n         OI    h.BFLHFL,BFLHDSCB\n         L     r0,dscbs_per_trk\n         STC   r0,h.BFLHNOE\n         LA    rf,bflent\n         USING BFLE,rf\ncvaf_bld_loop  DS 0H\n         XC    BFLE(BFLELN),BFLE\n         OI    BFLEFL,BFLECHR\n         MVI   BFLELTH,DS1END-IECSDSF1\n         MVC   BFLEARG,0(r5)             arg only used for 1st entry\n         ST    r3,BFLEBUF\n         LA    r3,DS1END\n         LA    r5,BFLEARG                r5 will point to last bflearg\n         LA    rf,BFLE+BFLELN              on exit\n         BCT   r0,cvaf_bld_loop\n         BR    re\n         DROP  r3,h,rf\n\n*/* ----------------------------------------------------------------\n* *      count nbr datasets and get a dataset area\n* * ---------------------------------------------------------------- */\n\nprocess_vtoc   DS 0H\n         L     r0,total_dscbs\n         L     r1,vtoc_area\n         USING IECSDSL1,r1\n         SLR   r3,3                      init nbr datasets\n         SLR   rf,rf\ncnt_dsn  CLI   DS1FMTID,C'1'\n         BNE   cnt_dsn_next\n         LA    r3,1(,r3)\n         LR    rf,r1                     remember last fmt1 dscb addr\ncnt_dsn_next   DS 0H\n         LA    r1,DS1END\n         BCT   r0,cnt_dsn\n         DROP  r1\n         ST    r3,dsn_nbr\n         ST    rf,last_f1_dscb\n        #MSG   1,'%d datasets are on %s:6',dsn_nbr,volser\n         LA    r3,3(,r3)                 for free, track 0 and vtoc\n         ST    r3,dsn_nbr\n         M     r2,=A(dsn_area_len)\n         ST    r3,dsn_area_size\n         STORAGE OBTAIN,LENGTH=(R3),BNDRY=PAGE\n         ST    r1,dsn_area_addr\n         LR    r2,r1\n         SLR   rf,rf\n         MVCL  r2,re\n         USING dsn_area,r1\n         MVC   dsn_name,=CL44'*** free ***'\n         LA    r1,dsn_area_len(,r1)\n         MVC   dsn_name,=CL44'*** track 0 ***'\n         MVC   dsn_extents,=A(1)\n         MVC   dsn_trks,=A(1)\n         MVC   dsn_trks_dump,=A(1)\n         DROP  r1\n        #MSG   0,'storage obtained for dsn area, addr 0x%x size %d',   x\n               dsn_area_addr,dsn_area_size\n\n*/* ----------------------------------------------------------------\n* *      get track vector\n* *\n* *      each word corresponds to a track;  if the word is non-zero\n* *      then it points to a dsn_area entry and the track will\n* *      be dumped.\n* * ---------------------------------------------------------------- */\n\n         L     r3,trks\n         SLL   r3,2\n         ST    r3,trk_vec_size\n         STORAGE OBTAIN,LENGTH=(r3),BNDRY=PAGE\n         ST    r1,trk_vec\n         LR    r2,r1\n         SLR   rf,rf\n         MVCL  r2,re\n         TM    opts,ALLTRKS              dumping all tracks ?\n         BNO   init_trk_vec1              no, continue\n         L     r3,trks\ninit_trk_vec   DS 0H\n         MVC   0(4,r1),dsn_area_addr     set entry to '*** none ***'\n         LA    r1,4(,r1)\n         BCT   r3,init_trk_vec\ninit_trk_vec1  DS 0H\n         L     r1,trk_vec\n         L     r2,dsn_area_addr\n         LA    r2,dsn_area_len(,r2)      track 0 dsn_area [2nd entry]\n         ST    r2,0(,r1)                 set track 0 to dump\n        #MSG   0,'storage obtained for trk vector, addr 0x%x size %d', x\n               trk_vec,trk_vec_size\n\n*/* ----------------------------------------------------------------\n* *      figure out which tracks to dump\n* * ---------------------------------------------------------------- */\n\n         L     r9,vtoc_area\n         L     r4,dsn_area_addr\n         LA    r4,dsn_area_len*2(,r4)    point to 3rd entry [vtoc]\n         USING dsn_area,r4\n\nfmt4     MVC   dsn_name,=CL44'*** vtoc ***'   first dscb is format 4\n         MVC   dsn_extents,=A(1)\n         USING IECSDSL4-44,r9\n         LA    r1,DS4VTOCE\n         BAL   re,cnv_xtnt               get vtoc start trk, size\n         ST    r1,dsn_trks\n         ST    r1,dsn_trks_dump\n         LA    r1,DS4VTOCE\n         LA    r2,1\n         SLR   r3,r3\n         BCTR  r3,0\n         BAL   re,upd_trk_vec\n         LA    r4,dsn_area_len(,r4)\n         DROP  r9\n\n         USING IECSDSL1,r9\nvtoc_loop LA   r9,DS1END\n         CL    r9,last_f1_dscb\n         BH    vtoc_exit\n         CLI   DS1FMTID,C'1'\n         BNE   vtoc_loop\n\nfmt1     MVC   dsn_name,DS1DSNAM         format 1 dscb processing\n         SLR   r2,r2\n         IC    r2,DS1NOEPV\n         ST    r2,dsn_extents\n         LTR   r2,r2\n         BZ    f1_part2\n\n*/*      count number of tracks allocated for the dataset            */\n\n         LA    r6,DS1EXT1\n         LA    r7,3                     format 1 has 3 extents\nf1_xt    LR    r1,r6\n         BAL   re,cnv_xtnt\n         A     r1,dsn_trks\n         ST    r1,dsn_trks\n         SH    r2,=Y(1)\n         BNP   f1_part2\n         LA    r6,10(,r6)\n         BCT   r7,f1_xt\n\nfmt3     LA    r1,DS1PTRDS\n         BAL   re,cnv_ptr\n         LR    r8,r1\n         USING IECSDSL3,r8\n\n         LA    r6,DS3EXTNT              fmt 3 starts off with 4 extents\n         LA    r7,4\nf3_xt1   LR    r1,r6\n         BAL   re,cnv_xtnt\n         A     r1,dsn_trks\n         ST    r1,dsn_trks\n         SH    r2,=Y(1)\n         BNP   f1_part2\n         LA    r6,10(,r6)\n         BCT   r7,f3_xt1\n\n         LA    r6,DS3ADEXT\n         LA    r7,9                      and has 9 additional extents\nf3_xt2   LR    r1,r6\n         BAL   re,cnv_xtnt\n         A     r1,dsn_trks\n         ST    r1,dsn_trks\n         SH    r2,=Y(1)\n         BNP   f1_part2\n         LA    r6,10(,r6)\n         BCT   r7,f3_xt2\n         LA    r1,DS3PTRDS\n         B     fmt3\n         DROP  r8\n\nf1_part2 DS    0H\n\n*/*      check if dataset included or excluded                       */\n\n         L     r1,dsn_incl_list\n         LTR   r1,r1\n         BZ    f1_in_ok\n         LA    r0,DS1DSNAM\n         BAL   re,chk_dsn_list\n         LTR   rf,rf\n         BZ    f1_in_ok\n         OI    dsn_flag,dsn_not_incl\nf1_in_ok L     r1,dsn_excl_list\n         LTR   r1,r1\n         BZ    f1_ex_ok\n         LA    r0,DS1DSNAM\n         BAL   re,chk_dsn_list\n         LTR   rf,rf\n         BNZ   f1_ex_ok\n         OI    dsn_flag,dsn_excl\n        #MSG   1,'%s:44 Excluded',DS1DSNAM  Msg for DS exclude  SOMITCW\nf1_ex_ok TM    dsn_flag,dsn_not_incl+dsn_excl\n         BNZ   f1_exit\n\n*/*      check if we'll use ds1lstar                                 */\n\n         SLR   r3,r3                     presume we won't use ds1lstar\n         BCTR  r3,0\n         TM    opts,ALLDATA+ALLTRKS\n         BNZ   f1_no_lstar\n         TM    DS1SMSFG,DS1PDSE+DS1STRP+DS1PDSEX+DS1DSAE\n         BNZ   f1_no_lstar\n         CLC   DS1DSORG,=AL1(DS1DSGPS,0)\n         BE    f1_lstar_ok\n         CLC   DS1DSORG,=AL1(DS1DSGPO,0)\n         BNE   f1_no_lstar\nf1_lstar_ok    DS 0H\n         SLR   r3,r3\n         ICM   r3,3,DS1LSTAR\n         LA    r3,1(,r3)                 number tracks in use\nf1_no_lstar    DS 0H\n\n*/*      scan the extents                                            */\n\n         LA    r0,3\n         LA    r1,DS1EXT1\n         L     r2,dsn_extents\nf1_xt_2  BAL   re,upd_trk_vec\n         LTR   rf,rf\n         BNZ   f1_exit\n         BCT   r0,f1_xt_2\n         LA    r1,DS1PTRDS\nfmt3_2   BAL   re,cnv_ptr\n         LR    r8,r1\n         USING IECSDSL3,r8\n         LA    r1,DS3EXTNT\n         LA    r0,4\nf3_xt1_2 BAL   re,upd_trk_vec\n         LTR   rf,rf\n         BNZ   f1_exit\n         BCT   r0,f3_xt1_2\n         LA    r1,DS3ADEXT\n         LA    r0,9\nf3_xt2_2 BAL   re,upd_trk_vec\n         LTR   rf,rf\n         BNZ   f1_exit\n         BCT   r0,f3_xt2_2\n         LA    r1,DS3PTRDS\n         B     fmt3_2\n         DROP  r8\nf1_exit  LA    r4,dsn_area_len(,r4)\n         B     vtoc_loop\nvtoc_exit DS   0H\n         DROP  r9,r4\n\n         L     r1,vtoc_area\n         L     r0,vtoc_size\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n        #MSG   0,'storage released for vtoc area, addr 0x%x size %d',  x\n               vtoc_area,vtoc_size\n         XC    vtoc_area,vtoc_area\n         XC    last_f1_dscb,last_f1_dscb\n         XC    vtoc_size,vtoc_size\n\n*  The dsn_excl_list memory is being freed here.                SOMITCW\n         L    r1,dsn_excl_list  Load addr. of first list entry  SOMITCW\nin_free  DS   0H                                                SOMITCW\n         LTR  r1,r1         See if a list entry to free         SOMITCW\n         BZ   in_freed      All dsn_excl_list freed, go exit    SOMITCW\n         L    r2,0(,r1)     Save the next address to free       SOMITCW\n         FREEMAIN RU,LV=49,A=(1)  Free the list entry           SOMITCW\n         LR   r1,r2         Set the next address to free        SOMITCW\n         B    in_free       Go to free the next list entry      SOMITCW\nin_freed DS   0H                                                SOMITCW\n         XC   dsn_excl_list(4),dsn_excl_list  Clear the anchor  SOMITCW\n\n\n*/* ----------------------------------------------------------------\n* *      count number of tracks we're going to dump\n* * ---------------------------------------------------------------- */\n\n         SLR   r2,r2\n         L     r1,trk_vec\n         L     r0,trks\n         SLR   rf,rf\ncnt_dump CL    rf,0(,r1)\n         BE    *+8\n         LA    r2,1(,r2)\n         LA    r1,4(,r1)\n         BCT   r0,cnt_dump\n         ST    r2,trks_dump\n        #MSG   0,'%d tracks out of %d will be dumped',                 x\n               trks_dump,trks\n\n*/* ----------------------------------------------------------------\n* *      part 2 -- do the actual work\n*/* ----------------------------------------------------------------\n\n*/* ----------------------------------------------------------------\n* *      open sysut1 in excp mode\n* * ---------------------------------------------------------------- */\n\nex       USING IHADCB,exdcb\n         MVC   exdcb,model_exdcb\n         LA    r1,exlst\n         STCM  r1,7,ex.DCBEXLSA\n         LA    r1,jfcb\n         ST    r1,exlst\n         MVI   exlst,X'87'\n         MVC   openl24,model_openl24\n         RDJFCB (ex.IHADCB,INPUT),MF=(E,openl24)\n         LTR   rf,rf\n         BNZ   ut1_rdjfcb_err\nj        USING INFMJFCB,jfcb\n         MVI   j.JFCBDSNM,4              vtoc name is all x'04's\n         MVC   j.JFCBDSNM+1(L'JFCBDSNM-1),j.JFCBDSNM\n         DROP  j\n         OPEN  ex.IHADCB,TYPE=J,MF=(E,openl24)\n         TM    ex.DCBOFLGS,DCBOFOPN\n         BNO   ut1_excp_open_err\n\n*/* ----------------------------------------------------------------\n* *      update the deb so we can read the entire volume\n* *      [this requires key 0 - hence supervisor state]\n* * ---------------------------------------------------------------- */\n\n         L     r2,ex.DCBDEBAD            load deb address\n         N     r2,=A(X'00FFFFFF')\n         USING DEBBASIC,r2\n         LA    r3,DEBBASND\n         USING DEBDASD,r3\n         MODESET MODE=SUP\n         IPK   0(r2)\n         SPKA  0\n         SLR   r1,r1\n         STH   r1,DEBSTRCC\n         STH   r1,DEBSTRHH\n         L     r1,cyls\n         BCTR  r1,0\n         STCM  r1,3,DEBENDCC\n         L     r1,trks_per_cyl\n         BCTR  r1,0\n         STCM  r1,3,DEBENDHH\n         L     r1,trks\n         C     r1,=A(65535)\n         BNH   *+8\n         L     r1,=A(65535)\n         STCM  r1,3,DEBNMTRK\n         SPKA  0(r2)\n         MODESET MODE=PROB\n         DROP  r2,r3\n\n*/* ----------------------------------------------------------------\n* *      build the sysut1 iob\n* * ---------------------------------------------------------------- */\n\ni1       USING IOBSTDRD,excp_iob\n         OI    i1.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,excp_ecb\n         ST    r1,i1.IOBECBPT\n         LA    r1,excp_ccws\n         ST    r1,i1.IOBSTART\n         LA    r1,exdcb\n         ST    r1,i1.IOBDCBPT\n\n*/* ----------------------------------------------------------------\n* *      get area for read track (rt)\n* * ---------------------------------------------------------------- */\n\n         MVC   trkcalcl,model_trkcalcl\n         TRKCALC FUNCTN=TRKBAL,TYPE=devta+3,R=1,K=0,DD=65535,          x\n               MAXSIZE=YES,REGSAVE=YES,MF=(E,trkcalcl)\n         LR    r3,r0                     copy max r1 data size\n         A     r3,=A(ha_len+count_len+8+count_len+8)                   x\n                                         add ha size, r0 size,         x\n                                         r1 count and end-track marker\n         LA    r3,511(,r3)               round_up 512\n         SRL   r3,9\n         SLL   r3,9\n         ST    r3,trk_size\n         M     r2,trks_per_cyl\n         STORAGE OBTAIN,LENGTH=(r3),LOC=BELOW,BNDRY=PAGE\n         ST    r1,excp_io_area\n         ST    r3,excp_io_size\n        #MSG   0,'storage obtained for %s i/o area, addr 0x%x size %d',x\n               volser,excp_io_area,excp_io_size\n\n*/* ----------------------------------------------------------------\n* *      get area for compression\n* * ---------------------------------------------------------------- */\n\n         TM    opts,COMPRESSION\n         BNO   no_compress_1\n         L     r2,trk_size\n         A     r2,=A(4096)\n         SRL   r2,12\n         SLL   r2,12\n         STORAGE OBTAIN,LENGTH=(r2),BNDRY=PAGE\n         STM   r1,r2,compr_area\n        #MSG   0,'storage obtained for compression, addr 0x%x size %d',x\n               compr_area,compr_size\n         LA    r2,handle\n         LA    r3,=A(32*1024)\n         LA    r4,=A(1)\n         STM   r2,r4,dw\n         OI    dw+8,X'80'\n         LA    r1,dw\n         L     rf,=V(EDCXHOTL)           create persistent c environ\n         BALR  re,rf\n        #MSG   0,'persistent c environment created, handle=0x%x',      x\n               handle\nno_compress_1  DS 0H\n\n*/* ----------------------------------------------------------------\n* *      open sysut2 (output file)\n* * ---------------------------------------------------------------- */\n\no        USING IHADCB,outdcb\n         MVC   outdcb,model_outdcb\n         MVC   outdcbe,model_outdcbe                            CZV70\n         LA    r1,outdcbe                                       CZV70\n         ST    r1,o.DCBDCBE                                     CZV70\n\n         OPEN  (o.IHADCB,OUTPUT),MF=(E,openl24)\n         TM    o.DCBOFLGS,DCBOFOPN\n         BNO   out_open_err\n        #MSG   1,'file SYSUT2 opened for output'\n\n*/* ----------------------------------------------------------------\n* *      get sysut2 i/o areas\n* * ---------------------------------------------------------------- */\n\n         STORAGE OBTAIN,LENGTH=16384,BNDRY=PAGE\n         ST    r1,out_buf                first output buffer\n         MVC   out_bufsz,=A(16384)\n\n*        build the headers\n         LR    r3,r1\n         USING VDHDR,r3\n         ST    r3,vdhdr_addr\n         LR    r0,r3\n         L     r1,=A(16384)\n         SLR   rf,rf\n         MVCL  r0,re\n         USING CKDDASD_DEVHDR,VDH_devhdr\n*        MVC   CKD_devid,=cl8'CKD_C370'                 Deleted SOMITCW\n*        TR    CKD_devid,e2aTab                         Deleted SOMITCW\n         MVC   CKD_devid,=XL8'434B445F43333730'                 SOMITCW\n         L     rf,trks_per_cyl\n         STLE  rf,CKD_heads\n         L     rf,trk_size\n         STLE  rf,CKD_trksize\n         MVI   CKD_devtype,x'90'\n         CLI   devta+3,x'0f'\n         BE    *+8\n         MVI   CKD_devtype,x'80'\n         USING CCKDDASD_DEVHDR,VDH_devhdr2\n         MVC   CCKD_vrm,=AL1(version,release,mod)\n         TM    opts,DONTCOMPRESS\n         BO    *+8\n         MVI   CCKD_options,1\n         L     rf,cyls\n         STLE  rf,CCKD_cyls\n\n*        calculate number lvl 1 entries\n         L     rf,trks\n         LR    r2,rf\n         SRL   r2,8                      number of trks / 256\n         N     rf,=A(X'000000ff')          evenly divisible ?\n         BZ    *+8\n         LA    r2,1(,r2)                     no, increment number\n         STLE  r2,CCKD_numl1tab\n         LA    r1,256\n         STLE  r1,CCKD_numl2tab\n\n         L     r1,cckd_compr\n         STC   r1,CCKD_compress\n         L     r1,cckd_compr_level\n         STHLE r1,CCKD_compress_parm\n         LR    r1,r2                     calclate first pos\n         SLL   r1,2                       (at end ov lvl 1 tab)\n         AL    r1,=A(VDH_l1tab-VDHDR)\n         ST    r1,out_pos\n         ST    r1,bytes_ovh\n         DROP  r3\n\n*        get area for rewrites\n         LA    r2,2(r2,r2)               2 entries for ea lvl 2 tab\n         MH    r2,=Y(rw_len)              plus the 1st buf + a spare\n         STORAGE OBTAIN,LENGTH=(r2),BNDRY=PAGE\n         STM   r1,r2,rw_area\n         LR    r0,r1                     clear the rewrite area\n         LR    r1,r2\n         SLR   rf,rf\n         MVCL  r0,re\n         L     r2,rw_area                set first rewrite entry\n         USING rw_ent,r2\n         MVC   rw_buf,out_buf\n         ST    r2,last_rw\n         LA    r2,rw_next\n         ST    r2,next_rw\n         DROP  r2\n\n*/* ----------------------------------------------------------------\n* *      read tracks\n* * ---------------------------------------------------------------- */\n\n          SLR  r2,r2                     init relative track\n          L    r3,trk_vec\nread_loop CL   r2,trks\n          BNL  read_exit\n          LR   rf,r2                     get dsn area addr for trk\n          SLL  rf,2\n          L    r4,0(rf,r3)\n          LTR  r4,r4\n          BZ   read_next\n          SLR  r6,r6\n          LR   r7,r2\n          D    r6,trks_per_cyl           get cc [r7] and hh [r6]\n          XC   i1.IOBSEEK,i1.IOBSEEK\n          STCM r7,3,i1.IOBCC\n          STCM r6,3,i1.IOBHH\n\n*         build locate record ccw\n          XC   excp_ccws,excp_ccws\n          LA   r5,excp_ccws\n          USING ccw0,r5\n          MVI  CCW0CMD,lr\n          LA   r1,lr_parms\n          STCM r1,7,CCW0ADDR\n          OI   CCW0FLAG,CCW0CC\n          LA   r1,L'lr_parms\n          STCM r1,3,CCW0CNT\n          LA   r5,CCW0END\n\n*         build read track ccws, try to read to end-of-cylinder\n          L    r0,trk_size\n          L    r1,excp_io_area\n          USING ha,r1\nread_rt   MVI  ha_bin,0                  build a ha\n          STCM r7,3,ha_cc\n          STCM r6,3,ha_hh\n          LA   rf,ha_end\n          DROP r1\n          MVI  CCW0CMD,rt\n          STCM rf,7,CCW0ADDR\n          OI   CCW0FLAG,CCW0SLI+CCW0CC\n          STCM r0,3,CCW0CNT\n          AR   r1,r0                     next i/o area addr\n          LA   r6,1(,r6)                 increment hh\n          C    r6,trks_per_cyl\n          BNL  read_rt_x                 exit if next cylinder\n          LA   r2,1(,r2)                 increment track nbr\n          LR   rf,r2\n          SLL  rf,2\n          L    r4,0(rf,r3)\n          LTR  r4,r4\n          BZ   read_rt_x                 exit if trk_vec entry is 0\n          LA   r5,CCW0END                 else point to next ccw\n          B    read_rt                     and loop back\nread_rt_x NI   CCW0FLAG,255-CCW0CC       unchain last ccw\n          DROP r5\n          SLR  rf,rf\n          ICM  rf,3,i1.IOBHH\n          SR   r6,rf                     number of read rt ccws\n\n*         build locate record parameters\n          XC   lr_parms,lr_parms\n          LA   r5,lr_parms\n          USING lr_parm_area,r5\n          MVI  lr_op,lr_orient_home+lr_read_tracks\n          STC  r6,lr_count\n          MVC  lr_seek_addr,i1.IOBCC\n          MVC  lr_search_arg,i1.IOBCC\n          DROP r5\n\n*         issue excp\n          XC   excp_ecb,excp_ecb\n          EXCP i1.IOBSTDRD\n          WAIT 1,ECB=excp_ecb\n          CLI  excp_ecb,X'7f'\n          BNE  ut1_io_err\n\n*          process each track image\n           L    r1,excp_io_area\nread_proc  LA   r7,ha_len(,r1)          find end of the track\n           USING count,r7\nread_proc1 CLC  =X'ffffffffffffffff',count\n           BE   read_proc2\n           SLR  rf,rf\n           IC   rf,count_key\n           SLR  r0,r0\n           ICM  r0,3,count_data\n           AR   rf,r0\n           LA   r7,count_end(rf)\n           B    read_proc1\n           DROP r7\nread_proc2 LA   r0,8(,r7)               get length of track image\n           SR   r0,r1\n           ST   r1,trk_addr\n           ST   r0,trk_sz\n           ST   r1,ctrk_addr\n           CH   r0,=Y(37)                track just an eof ?\n           BNE  *+6\n           SLR  r0,r0                     yes, use 0 length\n           ST   r0,ctrk_sz\n\n*         compress the track [but not the ha]\n*         void *__xhotu(void *handle, void *function, ...);\n*         int compress(uchar *dest,   ulong *destLen,\n*                      const uchar *source, ulong sourceLen);\n          TM   opts,COMPRESSION\n          BNO  no_compress2\n          LA   re,handle                 set parms for edcxhotu\n          LA   rf,=V(COMPRES2)\n          STM  re,rf,zlib_pl\n          LM   re,rf,compr_area          dest area, length\n          MVC  0(ha_len,re),0(r1)        copy the ha\n          MVI  0(re),1                   flag indicating compressed trk\n          LA   re,ha_len(,re)            point past the ha\n          SH   rf,=Y(ha_len)             adjust dest length\n          ST   rf,compr_used             set dest length\n          LA   rf,compr_used             addr dest length\n          STM  re,rf,zlib_pl+8           set dest addr, addr len\n          SH   r0,=Y(ha_len)             adjust source len\n          BNP  no_compress2               don't compress if null track\n          ST   r0,zlib_pl+20             set source length\n          LA   r1,ha_len(,r1)            adjust source addr\n          ST   r1,zlib_pl+16             set source addr\n          L    re,compr_level            get compression level\n          ST   re,zlib_pl+24             set compression level\n          LA   r1,zlib_pl                parameter list addr\n          L    rf,=V(EDCXHOTU)           call zlib compress function\n          BALR re,rf\n          LTR  rf,rf                     test return code\n          BNZ  no_compress2\n          L    r1,compr_used             get compressed length\n          LA   r1,ha_len(,r1)            add size of ha\n          C    r1,trk_sz                 check lengths\n          BNL  no_compress2              use uncompressed img\n          MVC  ctrk_addr,compr_area\n          ST   r1,ctrk_sz\nno_compress2   DS 0H\n\n*         update byte counts\n          LM   r0,r1,bytes_read          total bytes read\n          AL   r1,trk_sz\n          BC   12,*+8\n          AL   r0,=A(1)\n          STM  r0,r1,bytes_read\n          LM   r0,r1,bytes_written       total bytes written\n          AL   r1,ctrk_sz\n          BC   12,*+8\n          AL   r0,=A(1)\n          STM  r0,r1,bytes_written\n\n          L    r1,ctrk_addr              calculate dsn entry address\n          USING ha_bin,r1\n          SLR  re,re\n          SLR  rf,rf\n          ICM  rf,3,ha_cc\n          M    re,trks_per_cyl\n          SLR  re,re\n          ICM  re,3,ha_hh\n          ALR  rf,re\n          SLL  rf,2\n          L    r4,0(rf,r3)\n          DROP r1\n          USING dsn_area,r4\n\n          LM   r0,r1,dsn_bytes_read      dataset bytes read\n          AL   r1,trk_sz\n          BC   12,*+8\n          AL   r0,=A(1)\n          STM  r0,r1,dsn_bytes_read\n          LM   r0,r1,dsn_bytes_written   dataset bytes written\n          AL   r1,ctrk_sz\n          BC   12,*+8\n          AL   r0,=A(1)\n          STM  r0,r1,dsn_bytes_written\n\n          DROP r4\n\n*         call write track routine\n          LA   r1,ctrk_addr              point to addr, len\n          BAL  re,write_track            call write_track()\n\n          L    r1,trk_addr\n          A    r1,trk_size\n          BCT  r6,read_proc              loop back if more tracks\n\n*         next track\nread_next LA   r2,1(,r2)\n          B    read_loop\n\n*/* ----------------------------------------------------------------\n* *       finished reading  --  cleanup\n* * ---------------------------------------------------------------- */\n\nread_exit SLR  r1,r1                     nullify parm pointer\n          BAL  re,write_track            call write_track() to finish\n          CLOSE exdcb,MF=(E,openl24)\n         #MSG  1,'file SYSUT1 closed'\n          CLC  =A(0),handle\n          BE   no_c_env\n          LA   r1,handle                 terminate the c environment\n          ST   r1,dw\n          OI   dw,X'80'\n          LA   r1,dw\n          L    rf,=V(EDCXHOTT)\n          BALR re,rf\nno_c_env  LM   r1,r2,excp_io_area\n          STORAGE RELEASE,ADDR=(1),LENGTH=(r2)\n          LM   r1,r2,compr_area\n          LTR  r1,r1\n          BZ   read_term\n          STORAGE RELEASE,ADDR=(1),LENGTH=(r2)\nread_term DS   0H\n\n********* DC   H'0'\n\n*/* ----------------------------------------------------------------\n* *       print statistics\n* * ---------------------------------------------------------------- */\n\n          L    rf,=A(do_stats)       statistics routine addr\n          BALR re,rf                 print the statistics\n\n*/* ----------------------------------------------------------------\n* *       close the print file\n* * ---------------------------------------------------------------- */\n\n          TM   pr.DCBOFLGS,DCBOFOPN  did the print file open\n          BNO  noprint2                nope\n          CLOSE pr.IHADCB,MODE=31,MF=(E,openl)\nnoprint2  DS   0H\n\n*/* ----------------------------------------------------------------\n* *       free the workareas and return\n* * ---------------------------------------------------------------- */\n\n          L    r1,vdw_24\n          L    r0,=A(vdw24_len)\n          STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n          LR   r1,rd\n          L    rd,4(,rd)\n          L    r0,=A(vdw_len)\n          STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n          RETURN (14,12),RC=0\n\n*/* ----------------------------------------------------------------\n* *      write_track()  --  output subroutine\n* * ---------------------------------------------------------------- */\n\nwrite_track    DS 0H\n          STM  re,r8,wt_save\n          LTR  r8,r1                 0 means finish up\n          BZ   wt_finish\n          LM   re,rf,0(r8)           load addr, length\n          LTR  rf,rf                 do nothing for null tracks\n          BZ   wt_return\n          USING ha,re\n          SLR  r1,r1                 calculate track number from ha\n          ICM  r1,3,ha_cc\n          M    r0,trks_per_cyl\n          SLR  r2,r2\n          ICM  r2,3,ha_hh\n          AR   r2,r1\n          DROP re\n\n*         get pos of level 2 table\n\n          L    r3,vdhdr_addr\n          USING VDHDR,r3\n          LR   r4,r2\n          SRL  r4,8                  lvl 1 tab index\n          SLL  r4,2                  lvl 1 tab entry len is 4\n          LA   r4,VDH_l1tab(r4)      addr lvl 2 tab pos in lvl 1 tab\n          DROP r3\n          LLE  r3,0(r4)              lvl 2 tab pos\n          LTR  r3,r3                 does lvl 2 tab exist\n          BNZ  wt_l2t_ok               yes, continue\n\n*         level 2 table doesn't exist yet; build one\n\n          L    r0,bytes_ovh          update\n          AL   r0,=A(256*L'L2TAB_entry) overhead\n          ST   r0,bytes_ovh               total\n*         get pos range of the new level 2 table\n          L    r3,out_pos            load current pos\n          STLE r3,0(r4)              update lvl 1 pos\n          LR   r4,r3                 calculate next pos\n          AL   r4,=A(256*L'L2TAB_entry)\n          ST   r4,out_pos            set next available pos\n*         set  buffer for rewrite [if it already isn't]\n          L    r5,last_rw            see if buf set for rewrite\n          USING rw_ent,r5\n          CLC  rw_pos,out_buf_pos\n          BE   wt_l2t_1                yes, continue\n          LA   r5,rw_next                try next entry\n          CLC  rw_pos,out_buf_pos\n          BE   wt_l2t_1                    yes, continue\n          L    r5,next_rw            no, set this buf for rewrite\n          MVC  rw_pos,out_buf_pos\n          MVC  rw_buf,out_buf\n          LA   r0,rw_next\n          ST   r0,next_rw            set next available rewrite entry\nwt_l2t_1  ST   r5,last_rw            update last rewrite entry addr\n*         if the table fills this buffer then write it out\n          LR   r0,r4                 copy next pos\n          N    r0,=A(x'ffffc000')    convert to buf pos\n          CL   r0,out_buf_pos        need to write this buf ?\n          BE   wt_l2t_ok               no, continue\n          L    r6,out_buf            write the current buf\n          WRITE outdecb,SF,outdcb,(r6),MF=E\n          CHECK outdecb\n          NOTE  outdcb               note its file position\n          ST   r1,rw_ttr\n          STORAGE OBTAIN,LENGTH=16384,BNDRY=PAGE\n          L    r0,out_bufsz\n          AL   r0,=A(16384)\n          ST   r0,out_bufsz\n          LR   r6,r1\n          ST   r6,out_buf            new output buf\n          LR   r0,r6                 clear the buf\n          L    r1,=A(16384)\n          SLR  rf,rf\n          MVCL r0,re\n          L    r1,out_buf_pos        load previous buf pos\n          AL   r1,=A(16384)          set new buf pos\n          ST   r1,out_buf_pos        set new buf pos\n*         if the table spans into the new buf then set it for rewrite\n          CLR  r4,r1                 new pos same as new buf pos ?\n          BE   wt_l2t_ok               yes, table didn't span\n          L    r5,next_rw            get a new rewrite entry\n          ST   r1,rw_pos             set buf pos\n          ST   r6,rw_buf             set buf addr\n          LA   r5,rw_next\n          ST   r5,next_rw            set next available rewrite entry\n          DROP r5\nwt_l2t_ok DS   0H                    r3 has lvl 2 tab pos\n\n*         build the lvl 2 entry in a work area\n*         (this is necessary because the entry might span buffers)\nw         USING L2TAB,dw\n          XC   w.L2TAB_entry,w.L2TAB_entry\n          L    r1,out_pos            get next available pos\n          STLE r1,w.L2TAB_pos         set pos for trk image\n          L    r1,4(,r8)             get length of trk image\n          STHLE r1,w.L2TAB_size       set size of the area\n          STHLE r1,w.L2TAB_len         set length of the trk image\n          DROP w\n\n*         get address of the lvl 2 entry\n          SLL  r2,24                 shift out all but low 8 bits\n          SRL  r2,21                 shift back but multiplied by 8\n          AR   r2,r3                 have pos for lvl 2 tab entry\n          LR   rf,r2\n          N    rf,=A(x'ffffc000')    pos of buf for this entry\n          L    r4,last_rw            find the rewrite entry\n          USING rw_ent,r4\n          CL   rf,rw_pos\n          BE   wt_l2t_2                found the entry\n          LA   r4,rw_next            else try the next entry\n          CL   rf,rw_pos\n          BNE  wt_logic_err            not good\nwt_l2t_2  L    rf,rw_buf             load buf addr for this entry\n          N    r2,=A(x'00003fff')    get buf offset from pos\n          AR   r2,rf                 now have addr of lvl 2 entry\n\n*         copy the work entry to the actual entry\n          USING L2TAB,r2\n          A    rf,=A(16384)          calculate length\n          SR   rf,r2                 left in this buf\n          CH   rf,=Y(8)              check length to copy\n          BNH  *+8\n          LA   rf,8\n          BCTR rf,0                  decrement for EX\n          EX   rf,wt_l2t_mvc         copy the entry\n          LA   re,6                  calculate length-1\n          SR   re,rf                  to copy\n          BM   wt_l2t_x              exit if finished\n          LA   rf,dw+1(rf)           source address\n          LA   r4,rw_next            to next rewrite entry\n          L    r2,rw_buf             target addr (start of next buf)\n          EX   re,wt_l2t_mvc2        copy the rest\n          B    wt_l2t_x\nwt_l2t_mvc  MVC L2TAB_entry(0),dw\nwt_l2t_mvc2 MVC L2TAB_entry(0),0(rf)\n          DROP r4,r2\nwt_l2t_x  DS   0H                    lvl 2 tab entry built\n\n*         copy the track image\n          LM   r4,r5,0(r8)           source addr, length\nwt_data   LTR  r5,r5                 anything left to copy ?\n          BZ   wt_return              no, return\n          L    r2,out_pos            get current pos\n          N    r2,=A(x'00003fff')     convert to buf offset\n          L    r3,out_buf            get current buf addr\n          ALR  r2,r3                 now have target addr\n          AL   r3,=A(16384)          calculate target length\n          SLR  r3,r2\n          CLR  r3,r5                 check lengths\n          BNH  *+6                    and set target length\n          LR   r3,r5                   to the shortest\n          LR   r1,r3                 save target length\n          MVCL r2,r4                 copy\n          L    r2,out_pos            get old pos\n          ALR  r2,r1                 new pos\n          ST   r2,out_pos            set new pos\n          L    r3,out_buf_pos        load current buf pos\n          N    r2,=A(x'ffffc000')    new buf pos\n          CLR  r2,r3                 is current buf full ?\n          BE   wt_data                no [but r5 should be 0]\n          ST   r2,out_buf_pos        set new buf pos\n          L    r6,out_buf            write the buffer\n          WRITE outdecb,SF,outdcb,(r6),MF=E\n          CHECK outdecb\n          LR   r1,r6                 copy old buf addr\n          L    r6,last_rw            check for old buf rewrite\n          USING rw_ent,r6\n          CL   r3,rw_pos\n          BE   wt_data_1               yes ... get new buf\n          LA   r6,rw_next\n          CL   r3,rw_pos\n          BNE  wt_data_2                no ... use old buf\nwt_data_1 NOTE outdcb                note disk addr for old buf\n          ST   r1,rw_ttr\n          DROP r6\n          STORAGE OBTAIN,LENGTH=16384,BNDRY=PAGE\n          L    r0,out_bufsz\n          AL   r0,=A(16384)\n          ST   r0,out_bufsz\n          ST   r1,out_buf            new buf\nwt_data_2 LR   r0,r1                 clear the buf\n          L    r1,=A(16384)\n          SLR  rf,rf\n          MVCL r0,re\n          B    wt_data\n\nwt_return LM   re,r8,wt_save         return\n          BR   re\n\n*/* ----------------------------------------------------------------\n* *      write_track() finish\n* *      - set free space and write last buffer(s)\n* *      - close & reopen in updat mode\n* *      - rewrite buffers in the rewrite queue\n* *      - close & return\n* * ---------------------------------------------------------------- */\n\nwt_finish DS  0H\n\n*         unused space at the end is free space\n          L    r2,out_pos            get next available pos\n          N    r2,=A(x'00003fff')    convert to buf offset\n          BZ   wt_fsp_ok             if zero then no free space\n          L    r3,=A(16384)          calculate length of free space\n          SLR  r3,r2                   on current block\n          LR   r4,r3                 copy\n          CH   r4,=Y(8)              minimum free space is 8 bytes\n          BNL  *+8                     otherwise we need\n          AL   r4,=A(16384)              another block\n          ST   r4,bytes_free         remember free space\n          XC   dw,dw                 build the free entry in a work\n          STLE r4,dw+4                area since we may span buffers\n          AL   r2,out_buf            get addr of free space\n          CH   r3,=Y(8)              check length left\n          BNH  *+8                    jumps if not too long\n          LA   r3,8                    else reset\n          BCTR r3,0                  decrement for ex\n          EX   r3,wt_fsp_mvc         copy the free space entry\n          LA   r4,dw+1(r3)           resume copy from here\n          LA   r5,6                  calculate length-1 left to copy\n          SR   r5,r3                  negative if all copied\n\n*         write the last buffer(s)\nwt_fsp_wr L    r6,out_buf            write the buffer\n          WRITE outdecb,SF,outdcb,(r6),MF=E\n          CHECK outdecb\n          LR   r1,r6                 copy old buf addr\n          L    r3,out_buf_pos        get buffer pos\n          L    r6,last_rw            check for old buf rewrite\n          USING rw_ent,r6\n          CL   r3,rw_pos\n          BE   wt_fsp_1                yes ... get new buf\n          LA   r6,rw_next\n          CL   r3,rw_pos\n          BNE  wt_fsp_2                 no ... use old buf\nwt_fsp_1  NOTE outdcb                note disk addr for old buf\n          ST   r1,rw_ttr\n          DROP r6\n          STORAGE OBTAIN,LENGTH=16384,BNDRY=PAGE\n          L    r0,out_bufsz\n          AL   r0,=A(16384)\n          ST   r0,out_bufsz\n          ST   r1,out_buf            new buf\nwt_fsp_2  AL   r3,=A(16384)          new buf pos\n          ST   r3,out_buf_pos        set new pos\n          LR   r0,r1                 clear the buf\n          L    r1,=A(16384)\n          SLR  rf,rf\n          MVCL r0,re\n          LTR  r5,r5                 more to copy ?\n          BM   wt_fsp_ok              no, continue\n          L    r2,out_buf            get target addr\n          EX   r5,wt_fsp_mvc2        copy the rest of the entry\n          SLR  r5,r5                 make r5 negative\n          BCTR r5,0                   to terminate the loop\n          B    wt_fsp_wr             go write\nwt_fsp_mvc  MVC 0(0,r2),dw\nwt_fsp_mvc2 MVC 0(0,r2),0(r4)\nwt_fsp_ok DS   0H                    last block has been written\n\n*         update the header\n          L    r2,vdhdr_addr\n          USING VDHDR,r2\n          USING CCKDDASD_DEVHDR,VDH_devhdr2\n          L    re,out_buf_pos\n          STLE re,CCKD_size           set file size\n          L    rf,out_pos\n          STLE rf,CCKD_used           set bytes used\n          L    r0,bytes_free\n          STLE r0,CCKD_free_total     set total free space\n          STLE r0,CCKD_free_largest   set largest free space\n          LTR  r0,r0                  any free space ?\n          BZ   wt_hd2_ok               no, continue\n          STLE rf,CCKD_free           set offset to free entry\n          LA   r1,1\n          STLE r1,CCKD_free_number    set number free entries\n          DROP r2\nwt_hd2_ok DS   0H\n\n*         close the file and open in update mode\n          CLOSE outdcb,MF=(E,openl24)\n         #MSG  1,'file SYSUT2 closed for output'\no         USING IHADCB,outdcb\n          OPEN (o.IHADCB,UPDAT),MF=(E,openl24)\n          TM   o.DCBOFLGS,DCBOFOPN\n          BNO  out_open_err\n         #MSG  1,'file SYSUT2 opened for update'\n\n*         update the noted buffers\n          L    r2,rw_area\n          USING rw_ent,r2\n          L    r3,out_buf             buffer for read/write\nwt_update C    r2,next_rw             at end of entries ?\n          BNL  wt_upd_ok                yes, exit\n          POINT outdcb,rw_ttr         position the file\n          READ outdecb,SF,outdcb,(r3),MF=E\n          CHECK outdecb\n          LR   r0,r3                  copy the rewrite buf\n          L    r1,=A(16384)\n          L    re,rw_buf\n          LR   rf,r1\n          MVCL r0,re\n          WRITE outdecb,SF,outdcb,(r3),MF=E\n          CHECK outdecb\n          L    r1,rw_buf              free the buf\n          STORAGE RELEASE,ADDR=(1),LENGTH=16384\n          LA   r2,rw_next             point to the next entry\n          B    wt_update              loop back\nwt_upd_ok CLOSE outdcb,MF=(E,openl24)\n          STORAGE RELEASE,ADDR=(r3),LENGTH=16384\n          LM   r1,r2,rw_area          free stuff\n          STORAGE RELEASE,ADDR=(1),LENGTH=(r2)\n         #MSG  1,'file SYSUT2 closed for update'\n          B    wt_return\n\n*/* ------------------------------------------------------      SOMITCW\n* *      subroutine to check if dsn is in the include or        SOMITCW\n* *      exclude list.                                          SOMITCW\n* *      r0 points to the dsname from the vtoc on entry         SOMITCW\n* *      rf points to the dsname from the vtoc for compare      SOMITCW\n* *      r1 points to the first list entry                      SOMITCW\n* *          A(next-entry-address)                              SOMITCW\n* *          XL1'EX-CLC-compare-length'                         SOMITCW\n* *          CL44'dsn-or-dsn-prefix'                            SOMITCW\n* *      r2 is the length for the EX of the CLC instruction     SOMITCW\n* *      rf will have 0 if dsname found, otherwise 4            SOMITCW\n* * ---------------------------------------------------- */     SOMITCW\n*                                                               SOMITCW\nchk_dsn_list   DS 0H                                            SOMITCW\n         LR    rf,r0        Copy DS1-DSNAME for addressing      SOMITCW\ncdl_loop DS    0H                                               SOMITCW\n         IC    r2,4(,r1)    Load length for EX of CLC           SOMITCW\n         EX    r2,cdl_CLC   See if the data set name found      SOMITCW\n         BE    cdl_ret0     Data set in list, go return         SOMITCW\n         ICM   r1,B'1111',0(r1)  Link to the next entry         SOMITCW\n         BZ    cdl_ret4     End of list, return dsn not found   SOMITCW\n         B     cdl_loop     Go back to try next list entry      SOMITCW\ncdl_ret4 LA    rf,4         Indicate that dsname not found      SOMITCW\n         BR    re           Return to caller                    SOMITCW\ncdl_ret0 SLR   rf,rf        Indicate that dsname was found      SOMITCW\ncdl_ret  BR    re           Return to caller                    SOMITCW\ncdl_CLC  CLC   0(0,rf),5(r1)  See if the dsn is in list         SOMITCW\n\n*/* ----------------------------------------------------------------\n* *      subroutine to convert a 10 byte vtoc extent descriptor [r1]\n* *      to starting track [r0] and number tracks [r1]\n* * ---------------------------------------------------------------- */\n\ncnv_xtnt STM   r2,r5,cnv_xtnt_save\n         SLR   r3,r3                     calculate ending extent\n         ICM   r3,3,6(r1)\n         M     r2,trks_per_cyl\n         AH    r3,8(,r1)\n         SLR   r5,r5                     calculate beginning extent\n         ICM   r5,3,2(r1)\n         M     r4,trks_per_cyl\n         AH    r5,4(,r1)\n         LR    r0,r5\n         SR    r3,r5\n         LA    r1,1(,r3)\n         LM    r2,r5,cnv_xtnt_save\n         BR    re\n\n*/* ----------------------------------------------------------------\n* *      subroutine to convert a 5 byte vtoc pointer [r1]\n* *      to an address in the vtoc area [r1]\n* * ---------------------------------------------------------------- */\n\ncnv_ptr  STM   r2,r5,cnv_ptr_save\nf4       USING IECSDSL4-44,dscb4\n         SLR   r3,r3                     calculate vtoc starting trk\n         ICM   r3,3,f4.DS4VTOCE+2\n         M     r2,trks_per_cyl\n         SLR   r2,r2\n         ICM   r2,3,f4.DS4VTOCE+4\n         AR    r3,r2\n         SLR   r5,r5                     calculate dscb trk\n         ICM   r5,3,0(r1)\n         M     r4,trks_per_cyl\n         AH    r5,2(,r1)\n         SR    r5,r3                     have relative trk\n         M     r4,dscbs_per_trk\n         SLR   r3,r3\n         IC    r3,4(,r1)\n         AR    r5,r3                     now have relative dscb\n         BCTR  r5,0\n         M     r4,=A(DS1END-IECSDSF1)\n         L     r6,vtoc_area\n         LA    r1,0(r5,r6)\n         LM    r2,r6,cnv_ptr_save\n         BR    re\n         DROP  f4\n\n*/* ----------------------------------------------------------------\n* *      subroutine to populate the track vector table\n* *\n* *      r1 - pointer to extent descriptor (incremented)\n* *      r2 - nbr extents left (decremented)\n* *      r3 - -1 or last relative track (decremented)\n* *      r4 - dsn entry address\n* *\n* * ---------------------------------------------------------------- */\n\nupd_trk_vec SAVE (14,12)\n         USING dsn_area,r4\n         LA    rf,4\n         LTR   r2,r2                     exit if no extents left\n         BNP   utvret\n         BCTR  r2,0\n         LTR   r3,r3                     exit if lstar is zero\n         BZ    utvret\n         LA    r5,10(,r1)\n         BAL   re,cnv_xtnt\n         LR    r6,r0\n         SLL   r6,2\n         AL    r6,trk_vec\n         L     r7,dsn_trks_dump\nutvloop  ST    r4,0(,r6)\n         LA    r7,1(,r7)\n         LTR   r3,r3\n         BM    utvnext\n         SH    r3,=Y(1)\n         BNP   utvexit\nutvnext  LA    r6,4(,r6)\n         BCT   r1,utvloop\n         SLR   rf,rf\nutvexit  ST    r7,dsn_trks_dump\n         LR    r1,r5\nutvret   STM   r1,r3,24(rd)\n         RETURN (14,12),RC=(15)\n         DROP  r4\n\n*/* ----------------------------------------------------------------\n* *      retrieve options\n* * ---------------------------------------------------------------- */\n\ngetopts  DS    0H\n         MVI   opts,COMPRESSION\n         MVC   compr_level,=A(CCKD_DEFAULT_COMPRESSION)    For this JOB\n         MVC   cckd_compr_level,=A(Z_DEFAULT_COMPRESSION)  In CCKD disk\n         MVC   cckd_compr,=A(CCKD_COMPRESS_ZLIB)\n\n*/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   SOMITCW\n* *      See if a SYSIN file                                    SOMITCW\n* * - - - - - - - - - - - - - - - - - - - - - - - - - - - - */  SOMITCW\n*                                                               SOMITCW\n*  Locate Task I/O Table                                        SOMITCW\n         MVC   extract,model_extract  Move MF=L EXTRACT MACRO   SOMITCW\n         EXTRACT tiot_addr,'S',FIELDS=TIOT,MF=(E,EXTRACT)       SOMITCW\n         L     rf,tiot_addr                                     SOMITCW\n         LA    r1,24        Bump past JOB, STEP, PROCSTEP names SOMITCW\nin_tiot  DS    0H                                               SOMITCW\n         AR    rf,r1        Bump to next TIOT entry             SOMITCW\n         ICM   r1,b'0001',0(rf) Load length of TIOT entry       SOMITCW\n         BZR   r9           No SYSIN, take all defaults         SOMITCW\n*        CLC   in.DCBDDNAM,4(rf)   See if the SYSIN entry       SOMITCW\n    CLC model_indcb+DCBDDNAM-IHADCB(8),4(rf) See if SYSIN entry SOMITCW\n         BNE   in_tiot      Not SYSIN, go check next TIOT entry SOMITCW\n*                                                               SOMITCW\n*/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - -   SOMITCW\n* *      try to open SYSIN file                                 SOMITCW\n* * - - - - - - - - - - - - - - - - - - - - - - - - - - - - */  SOMITCW\n*                                                               SOMITCW\n         MVC   indcb,model_indcb                                SOMITCW\n         MVC   indcbe,model_indcbe                              SOMITCW\nin       USING IHADCB,indcb                                     SOMITCW\n         LA    r1,indcbe                                        SOMITCW\n         ST    r1,in.DCBDCBE                                    SOMITCW\n* SYSIN exists, OPEN it                                         SOMITCW\n* * A list entry will be built for each exclude record          SOMITCW\n* * Format of each list entry will be:                          SOMITCW\n* *    A(next-entry-address)                                    SOMITCW\n* *    XL1'EX-CLC-compare-length'                               SOMITCW\n* *    CL44'dsn-or-dsn-prefix'                                  SOMITCW\n* * r2 will contain the address of the previous list entry,     SOMITCW\n* *    to link the new list entry to the previous.              SOMITCW\n         MVC   openl,model_openl   Insure unused bits are zero  SOMITCW\n         OPEN  (in.IHADCB,INPUT),MODE=31,MF=(E,openl)           SOMITCW\n         TM    in.DCBOFLGS,DCBOFOPN  See if SYSIN OPENed        SOMITCW\n         BZ    X'081B'(rb)  Abend S0C6 if OPEN failed           SOMITCW\n         LA    R2,dsn_excl_list  Load address of list anchor    SOMITCW\nin_get   DS    0h                                               SOMITCW\n         GET   in.IHADCB    Read a record                       SOMITCW\n         MVC   in_rec,0(r1) Store record for display            SOMITCW\n        #MSG   1,'SYSIN Read: %s:71',in_rec  Display the record SOMITCW\n         CLI   in_rec,C'*'  See if a comment                    SOMITCW\n         BE    in_get       Is comment, don't process           SOMITCW\n         CLC   =Cl8'EXCLUDE ',in_rec  See if an exclude         SOMITCW\n         BNE   ut1_bad_sysin  Not an exclude, go abend          SOMITCW\n         GETMAIN RU,LV=49   Get memory for a list entry         SOMITCW\n         XC    0(4,r1),0(r1)  Clear link addr.in GETMAINed area SOMITCW\n         ST    r1,0(,r2)    Link to the old list entry          SOMITCW\n         LR    rf,r1        Load the new list entry address     SOMITCW\n         CLI   in_rec+8,X'40' See if a data set name            SOMITCW\n         BE    ut1_bad_sysin  No data set name, go abend        SOMITCW\n         MVC   5(44,rf),in_rec+8  Save entire possible dsname   SOMITCW\n         TRT   in_rec+8(44),in_trt_table find space or asterisk SOMITCW\n         BZ    in_full44    Full data set name, go store        SOMITCW\n         LA    r2,in_rec+8  Load address of start of dsname     SOMITCW\n         CLI   0(r1),X'40'  See if a space found                SOMITCW\n         BE    in_dsn_found Dsn found, go add to list           SOMITCW\nin_prefix_found DS 0H                                           SOMITCW\n         BCTR  r1,0         Drop the asterisk byte for prefix   SOMITCW\nin_dsn_found DS 0H                                              SOMITCW\n*already LA    r2,in_rec+8  Load address of start of dsname     SOMITCW\n         SR    r1,r2        Find the length of the dsname       SOMITCW\n         STC   r1,4(,rf)    Store the length for compare        SOMITCW\nin_next  DS    0H                                               SOMITCW\n         LR    r2,rf        Restore list entry address          SOMITCW\n         B     in_get       Go get the next record              SOMITCW\nin_full44 DS 0H                                                 SOMITCW\n         MVI   4(rf),x'43'  Store EX length of data set name    SOMITCW\n         B     in_next      Go get next SYSIN record            SOMITCW\nin_exit  DS    0H                                               SOMITCW\n         CLOSE in.IHADCB,MODE=31,MF=(E,openl)                   SOMITCW\n         BR    r9           SYSIN processed, return to caller   SOMITCW\n*        BR    re                                       Deleted SOMITCW\n\n*/* ----------------------------------------------------------------\n* *      fatal errors\n* * ---------------------------------------------------------------- */\n\nut1_bad_sysin  DS 0H                                            SOMITCW\n         LR    r2,r1        Save bad sysin record               SOMITCW\n  #MSG   3,'Bad record on SYSIN, must start with \"EXCLUDE dsn\"' SOMITCW\n         B     abend                                            SOMITCW\n\nut1_devt_err   DS 0H\n         STM   rf,r0,retcode\n        #MSG   3,'DEVTYPE failed for SYSUT1; RC=%x reason %x',         x\n               retcode,rsncode\n         B     abend\n\nout_devt_err   DS 0H\n         STM   rf,r0,retcode\n        #MSG   3,'DEVTYPE failed for SYSUT2; RC=%x reason %x',         x\n               retcode,rsncode\n         B     abend\n\nut1_not_dasd   DS 0H\n        #MSG   3,'SYSUT1 is not a disk device'\n         B     abend\n\nout_not_dasd   DS 0H\n        #MSG   3,'SYSUT2 is not a disk device'\n         B     abend\n\nut1_not_eckd   DS 0H\n        #MSG   3,'SYSUT1 is not an eckd disk device'\n         B     abend\n\nut1_rdjfcb_err DS 0H\n         ST    rf,retcode\n        #MSG   3,'RDJFCB failed for SYSUT1; RC=%x',retcode\n         B     abend\n\nut1_vtoc_open_err DS 0H\n        #MSG   3,'OPEN failed for SYSUT1 vtoc on %s',volser\n         B     abend\n\nout_open_err   DS 0H\n        #MSG   3,'OPEN failed for SYSUT2'\n         B     abend\n\nut1_dscb4_err     DS 0H\n         ST    rf,retcode\nc        USING CVPL,cvpl_area\n        #MSG   3,'Error processing format 4 dscb on %s; RC=%x CVSTAT=%dx\n               :1',volser,retcode,c.CVSTAT\n         B     abend\n         DROP  c\n\nut1_cvaf_err      ABEND 6\n         ST    rf,retcode\nc        USING CVPL,cvpl_area\n        #MSG   3,'CVAF error reading %s vtoc; RC=%x CVSTAT=%d:1',      x\n               volser,retcode,c.CVSTAT\n         B     abend\n         DROP  c\n\nut1_excp_open_err DS 0H\n        #MSG   3,'EXCP OPEN failed for SYSUT1 on %s',volser\n         B     abend\n\nut1_io_err        DS 0H\n        #MSG   3,'EXCP I/O error for SYSUT1 on %s',volser\n         B     abend\n\nwt_logic_err      DS 0H\n        #MSG   3,'logic error writing track',volser\n         B     abend\n\nabend    ABEND 99,DUMP\n\n*/* ----------------------------------------------------------------\n* *      literals and constants\n* * ---------------------------------------------------------------- */\n\n                 LTORG ,\n                 WXTRN EDCXHOTL,EDCXHOTU,EDCXHOTT,COMPRESS\n                 PRINT   GEN             Was NOGEN              SOMITCW\nmodel_extract    EXTRACT *-*,'S',FIELDS=TIOT,MF=L               SOMITCW\nmodel_extract_l  EQU  *-model_extract                           SOMITCW\nmodel_indcb      DCB  DDNAME=SYSIN,DSORG=PS,MACRF=GL,DCBE=0     SOMITCW\nmodel_indcb_l    EQU  *-model_indcb                             SOMITCW\nmodel_indcbe     DCBE RMODE31=BUFF,EODAD=in_exit                SOMITCW\nmodel_indcbe_l   EQU  *-model_indcbe                            SOMITCW\nmodel_prdcb      DCB  DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,DCBE=0\nmodel_prdcb_l    EQU  *-model_prdcb\nmodel_prdcbe     DCBE RMODE31=BUFF\nmodel_prdcbe_l   EQU  *-model_prdcbe\nmodel_vtdcb      DCB  DDNAME=SYSUT1,DSORG=PS,MACRF=R\nmodel_vtdcb_l    EQU  *-model_vtdcb\nmodel_exdcb      DCB  DDNAME=SYSUT1,DSORG=DA,MACRF=E\nmodel_exdcb_l    EQU  *-model_exdcb\nmodel_outdcb     DCB  DDNAME=SYSUT2,DSORG=PS,MACRF=(RP,WP),            x\n               RECFM=F,BLKSIZE=16384,LRECL=16384,DCBE=0         CZV70\nmodel_outdcb_l   EQU  *-model_outdcb\nmodel_outdcbe    DCBE BLOCKTOKENSIZE=LARGE                      CZV70\nmodel_outdcbe_l  EQU  *-model_outdcbe                           CZV70\nmodel_openl      OPEN (0),MODE=31,MF=L\nmodel_openl_l    EQU  *-model_openl\nmodel_openl24    OPEN (0),MODE=31,MF=L\nmodel_openl24_l  EQU  *-model_openl24\nmodel_devtl      DEVTYPE ,,INFOLIST=devt_infol_1,MF=L\nmodel_devtl_l    EQU  *-model_devtl\ndevt_infol_1     DEVTYPE INFO=DEVTYPE\ndevt_infol_2     DEVTYPE INFO=(DEVTYPE,DASD)\nmodel_cvpl       CVAFSEQ MF=L\nmodel_cvpl_l     EQU  *-model_cvpl\nmodel_trkcalcl   TRKCALC MF=L\nmodel_trkcalcl_l EQU  *-model_trkcalcl\n* e2aTAB   DS    0D                                     Deleted SOMITCW\n*      0 1 2 3  4 5 6 7  8 9 a b  c d e f               Deleted SOMITCW\n* DC X'00010203 1A091A7F 1A1A1A0B 0C0D0E0F' 0           Deleted SOMITCW\n* DC X'10111213 1A0A081A 18191A1A 1C1D1E1F' 1           Deleted SOMITCW\n* DC X'1A1A1C1A 1A0A171B 1A1A1A1A 1A050607' 2           Deleted SOMITCW\n* DC X'1A1A161A 1A1E1A04 1A1A1A1A 14151A1A' 3           Deleted SOMITCW\n* DC X'20A6E180 EB909FE2 AB8B9B2E 3C282B7C' 4           Deleted SOMITCW\n* DC X'26A9AA9C DBA599E3 A89E2124 2A293B5E' 5           Deleted SOMITCW\n* DC X'2D2FDFDC 9ADDDE98 9DACBA2C 255F3E3F' 6           Deleted SOMITCW\n* DC X'D78894B0 B1B2FCD6 FB603A23 40273D22' 7           Deleted SOMITCW\n* DC X'F8616263 64656667 686996A4 F3AFAEC5' 8           Deleted SOMITCW\n* DC X'8C6A6B6C 6D6E6F70 71729787 CE93F1FE' 9           Deleted SOMITCW\n* DC X'C87E7374 75767778 797AEFC0 DA5BF2F9' a           Deleted SOMITCW\n* DC X'B5B6FDB7 B8B9E6BB BCBD8DD9 BF5DD8C4' b           Deleted SOMITCW\n* DC X'7B414243 44454647 4849CBCA BEE8ECED' c           Deleted SOMITCW\n* DC X'7D4A4B4C 4D4E4F50 5152A1AD F5F4A38F' d           Deleted SOMITCW\n* DC X'5CE75354 55565758 595AA085 8EE9E4D1' e           Deleted SOMITCW\n* DC X'30313233 34353637 3839B3F7 F0FAA7FF' f           Deleted SOMITCW\n\nin_trt_table DC 256Xl1'0'   Table to find end of dsname         SOMITCW\n         ORG   in_trt_table+X'40'  Back up the location counter SOMITCW\n         DC    XL1'40'      Overlay the space position          SOMITCW\n         ORG   ,            Set the location counter to normal  SOMITCW\n         ORG   in_trt_table+X'5C'  Back up the location counter SOMITCW\n         DC    XL1'5C'      Overlay the asterisk position       SOMITCW\n         ORG   ,            Set the location counter to normal  SOMITCW\n                 PRINT GEN\n         DROP ,\n\n*/* ----------------------------------------------------------------\n* *      subroutine to issue messages\n* * ---------------------------------------------------------------- */\n\n          USING msg_rtn,rc\n          USING vdw,rd\n          USING vdw24,ra\nmsg_rtn   STM  re,rc,mr_save\n          LR   rc,rf\n          LA   r8,prdcb\n          USING IHADCB,r8\n          TM   DCBOFLGS,DCBOFOPN\n          BNO  mr_ret               return if no message file\n          LM   r4,r5,0(r1)          pattern addr, length\n          BCTR r5,0\n          LA   r3,8(,r1)            first parameter\n          LA   r6,msg\n          MVI  msg,C' '             init msg to blanks\n          MVC  msg+1(L'msg-1),msg\n\nmr_loop   LTR  r5,r5\n          BM   mr_exit\n          LA   r1,1(r4,r5)\n          SLR  r2,r2\n          EX   r5,mr_trt1\n          SR   r1,r4                length scanned\n          BNP  mr_skip1\n          LR   rf,r1\n          BCTR rf,0\n          EX   rf,mr_mvc1           copy literal text\n          AR   r6,r1\nmr_skip1  AR   r4,r1\n          SR   r5,r1\n          BM   mr_exit\n          BP   mr_skip2\n\n          MVC  0(1,r6),0(r4)        string ends in special char\n          LA   r6,1(,r6)\n          B    mr_exit\n\nmr_skip2  B    *(r2)                br on special char type\n          B    mr_pct               '%'\n          B    mr_bs                '\\'\n\nmr_pct    CLI  1(r4),C's'\n          BE   mr_pct_s\n          CLI  1(r4),C'x'\n          BE   mr_pct_x\n          CLI  1(r4),C'd'\n          BE   mr_pct_d\n          MVC  0(1,r6),0(r4)        tread '%' as any other char\n          LA   r6,1(,r6)\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_loop\nmr_pct_s  L    r7,0(,r3)            load string ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%s'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  mr_pct_s3\n          LR   r2,r7                source len = 0, find end of string\nmr_pct_s1 CLI  0(r2),C' '\n          BNH  mr_pct_s2\n          LA   r2,1(,r2)\n          B    mr_pct_s1\nmr_pct_s2 SR   r2,r7\n          BNP  mr_loop\nmr_pct_s3 LR   rf,r2                copy source string to the msg\n          BCTR rf,0\n          EX   rf,mr_mvc2\n          LTR  r1,r1\n          BNZ  mr_pct_s5\n          AR   r6,r2                truncate trailing spaces if\nmr_pct_s4 BCTR r6,0                  target len is 0\n          CLI  0(r6),C' '\n          BNH  mr_pct_s4\n          LA   r6,1(,r6)\n          B    mr_loop\nmr_pct_s5 CR   r1,r2\n          BH   mr_pct_s6\n          AR   r6,r1                truncate the string\n          B    mr_loop\nmr_pct_s6 AR   r6,r2                pad string with trailing blanks\n          SR   r1,r2\nmr_pct_s7 MVI  0(r6),C' '\n          LA   r6,1(,r6)\n          BCT  r1,mr_pct_s7\n          B    mr_loop\n\nmr_pct_x  L    r7,0(,r3)            load hex ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%x'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          EX   r2,mr_pct_x_unpk\n          TR   dw,mr_hextab\n          LTR  r1,r1\n          BNZ  mr_pct_x1\n          LA   r1,8                 determine default target len\n          CLC  =C'00',dw\n          BNE  mr_pct_x1\n          LA   r1,6\n          CLC  =C'0000',dw\n          BNE  mr_pct_x1\n          LA   r1,4\n          CLC  =C'000000',dw\n          BNE  mr_pct_x1\n          LA   r1,2\nmr_pct_x1 LA   r7,dw+8              copy the hex string to the msg\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_pct_d  L    r7,0(,r3)            load decimal ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%d'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          LA   rf,4\n          SR   rf,r2\n          LA   re,15\n          SRL  re,0(rf)\n          EX   re,mr_pct_d_icm\n          CVD  rf,dw\n          MVC  dw2(16),=X'40202020202020202020202020202120'\n          ED   dw2(16),dw\n          LTR  r1,r1\n          BNZ  mr_pct_d2\n          LA   rf,dw2+16            default length -\nmr_pct_d1 BCTR rf,0                  truncate leading spaces\n          CLI  0(rf),C' '\n          BH   mr_pct_d1\n          LA   r1,dw2+15\n          SR   r1,rf\nmr_pct_d2 LA   r7,dw2+16\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_bs     MVC  0(1,r6),1(r4)        copy char following '\\'\n          LA   r6,1(,r6)\n          LA   r4,2(,r4)\n          SH   r5,=Y(2)\n          B    mr_loop\n\nmr_exit   LA   r1,msg\n          SR   r6,r1                calculate msg length\n          BNP  mr_ret\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   *+8\n          LA   r6,1(,r6)            increment for carriage control\n\n          TM   DCBRECFM,DCBRECU\n          BO   mr_u\n          TM   DCBRECFM,DCBRECF\n          BO   mr_f\n          TM   DCBRECFM,DCBRECV\n          BO   mr_v\n\nmr_u      CH   r6,DCBBLKSI\n          BNH  *+8\n          LH   r6,DCBBLKSI\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_u1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_u1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_u1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_f      CH   r6,DCBLRECL\n          BNH  *+8\n          LH   r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_f1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_f1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_f1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_v      LA   r6,4(,r6)\n          LH   r1,DCBBLKSI\n          SH   r1,=Y(4)\n          CR   r6,r1\n          BNH  *+6\n          LR   r6,r1\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          STH  r6,0(,r1)\n          XC   2(2,r1),2(r1)\n          LA   r1,4(,r1)\n          SH   r6,=Y(4)\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_v1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_v1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_v1     BCTR r6,0\n          EX   r6,mr_mvc3\n\nmr_ret    LM   re,rc,mr_save\n          BR   re\n          DROP r8\n\n*/* ----------------------------------------------------------------\n* *       message subroutine to get operand lengths\n* * ---------------------------------------------------------------- */\n\nmr_op     SLR  r1,r1\n          SLR  r2,r2\nmr_op1    LTR  r5,r5                first number is target length\n          BMR  re\n          CLI  0(r4),C'0'\n          BL   mr_op2\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r1,=Y(10)\n          AR   r1,rf\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_op1\nmr_op2    CLI  0(r4),C':'          second number follows a ':'\n          BNER re\nmr_op3    LA   r4,1(,r4)           second number is source length\n          SH   r5,=Y(1)\n          BMR  re\n          CLI  0(r4),C'0'\n          BLR  re\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r2,=Y(10)\n          AR   r2,rf\n          B    mr_op3\n\n*/* ---------------------------------------------------------------- */\n\nmr_mvc1   MVC  0(0,r6),0(r4)\nmr_trt1   TRT  0(0,r4),mr_tab1\nmr_mvc2   MVC  0(0,r6),0(r7)\nmr_mvc3   MVC  0(0,r1),msg\nmr_pct_x_unpk  UNPK dw(9),0(0,r7)\nmr_pct_d_icm   ICM rf,0,0(r7)\nmr_tab1   DC   XL256'0'\n          ORG  mr_tab1+C'%'\n          DC   AL1(4)\n          ORG  mr_tab1+C'\\'\n          DC   AL1(8)\n          ORG  mr_tab1+256\nmr_hextab EQU  *-240\n          DC   C'0123456789abcdef'\ndo_stats  BR   14\n          LTORG ,\n\n*/* ----------------------------------------------------------------\n* *      messages\n* * ---------------------------------------------------------------- */\n\n         #MSG  TYPE=GEN\n\n*/* ----------------------------------------------------------------\n* *      dynamic storage\n* * ---------------------------------------------------------------- */\n\nvdw            DSECT\nid                DS  0CL4'vdw'\nsave              DS  18F\ncnv_xtnt_save     DS  8F                 savearea for cnv_xtnt\ncnv_ptr_save      DS  8F                 savearea for cnv_ptr\nwt_save           DS  12F                savearea for write_track\nmr_save           DS  16F                savearea for msg_rtn\nvdw_31            DS  A                  addr this area\nvdw_24            DS  A                  addr 24 bit area\nopts              DS  X\nALLTRKS           EQU X'80'              dump all tracks\nALLDATA           EQU X'40'              dump all data in datasets\nCOMPRESSION       EQU X'20'              compress dumped data\nDONTCOMPRESS      EQU X'10'              explicitly don't compress\nmsglvl            DS  X\nvolser            DS  CL6\nretcode           DS  F\nrsncode           DS  F\ndw                DS  D\ndw2               DS  D\ndw3               DS  D\ndw4               DS  D\ntrks              DS  F                  total number tracks\ntrks_dump         DS  F                  total number tracks to dump\ntrk_size          DS  F                  max track size\ntrk_vec           DS  A                  vector of trks to dump\ntrk_vec_size      DS  F\ndscbs_per_trk     DS  F                  number dscbs per track\nvtoc_trks         DS  F                  number tracks in vtoc\ntotal_dscbs       DS  F                  number dscbs in vtoc\nvtoc_area         DS  A                  addr of area to hold all dscbs\nvtoc_size         DS  F                  size of area to hold all dscbs\nlast_f1_dscb      DS  A                  addr last format 1 dscb\ndsn_nbr           DS  F                  nbr datasets on volume\ntiot_addr      DS  A        Address of the Task I/O Table       SOMITCW\nin_rec         DS  CL80     Input record for display            SOMITCW\ndsn_area_addr     DS  A\ndsn_area_size     DS  A\ndsn_incl_list     DS  A\ndsn_excl_list     DS  A\nexcp_io_area      DS  A\nexcp_io_size      DS  F\ncompr_area        DS  A\ncompr_size        DS  F\ncompr_used        DS  F\ncompr_level       DS  F\ncckd_compr        DS  F\ncckd_compr_level  DS  F\nZ_NO_COMPRESSION      EQU  0\nZ_BEST_SPEED          EQU  1\nZ_BEST_COMPRESSION    EQU  9\nZ_DEFAULT_COMPRESSION EQU -1\nCCKD_DEFAULT_COMPRESSION EQU  3\nout_buf           DS  A                  current output buf addr\nout_buf_pos       DS  F                  pos for current buf\nout_bufsz         DS  F                  total buf size used for output\nvdhdr_addr        DS  A                  buf addr containing VDHDR\nout_pos           DS  F                  current available pos\nrw_area           DS  A                  rewrite area addr\nrw_size           DS  F                  size of rewrite area\nlast_rw           DS  A                  addr last used entries\nnext_rw           DS  A                  next available entry\ntrk_addr          DS  A\ntrk_sz            DS  F\nctrk_addr         DS  A\nctrk_sz           DS  F\nbytes_read        DS  2F\nbytes_written     DS  2F\nbytes_ovh         DS  F\nbytes_free        DS  F\nhandle            DS  F\nmsgl              DS  16F\nextract           DS  XL(model_extract_l)                       SOMITCW\nindcbe            DS  XL(model_indcbe_l)                        SOMITCW\nprdcbe            DS  XL(model_prdcbe_l)\noutdcbe           DS  XL(model_outdcbe_l)                       CZV70\nopenl             DS  XL(model_openl_l)\ndevtl             DS  XL(model_devtl_l)\ndevta             DS  XL(32)\ncyls              EQU devta+4,4\ntrks_per_cyl      EQU devta+8,4\ndev_flags         EQU devta+12,2\ntrkcalcl          DS  XL(model_trkcalcl_l)\nzlib_pl           DS  8F\ndscb4             DS  XL(DS1END-IECSDSF1)\nmsg               DS  CL256\ncvpl_area         DS  XL(model_cvpl_l)\nbflh              DS  XL(BFLHLN)\nbflent            DS  256XL(BFLELN)\nbfle_arg          DS  XL(L'BFLEARG)\nvdw_len           EQU *-vdw\n\nvdw24          DSECT  ,\nid24              DS  CL4'vdw24'\nopenl24           DS  XL(model_openl24_l)\nexlst             DS  F\nindcb          DS  XL(model_indcb_l)                            SOMITCW\nprdcb             DS  XL(model_prdcb_l)\nvtdcb             DS  XL(model_vtdcb_l)\nexdcb             DS  XL(model_exdcb_l)\n                READ  outdecb,SF,MF=L\noutdcb            DS  XL(model_outdcb_l)\njfcb              DS  XL(JFCBLGTH)\nexcp_ecb          DS  F\n                  DS  0D\nlr_parms          DS  XL16\nexcp_iob          DS  XL40\nexcp_ccws         DS  XL256\nvdw24_len         EQU *-vdw24\n\ndsn_area       DSECT\ndsn_name          DS  CL44\ndsn_flag          DS  F\ndsn_not_incl      EQU X'80'\ndsn_excl          EQU X'40'\ndsn_extents       DS  F\ndsn_trks          DS  F\ndsn_trks_dump     DS  F\ndsn_bytes_read    DS  2F\ndsn_bytes_written DS  2F\ndsn_next          DS  0F\ndsn_area_len      EQU *-dsn_area\n\nlr_parm_area   DSECT  ,                  locate record parameter area\nlr_op             DS  X                  operation byte\nlr_orient_count   EQU B'00000000'\nlr_orient_home    EQU B'01000000'\nlr_orient_data    EQU B'10000000'\nlr_orient_index   EQU B'11000000'\nlr_orient         EQU X'00'\nlr_write_data     EQU X'01'\nlr_format_write   EQU X'03'\nlr_read_data      EQU X'06'\nlr_write_track    EQU X'0b'\nlr_read_tracks    EQU X'0c'\nlr_read           EQU X'16'\nlr_aux            DS  X                  auxiliary byte\nlr_use_tlf        EQU B'10000000'\nlr_read_count_ccw EQU B'00000001'\n                  DS  X\nlr_count          DS  X                  count parameter\nlr_seek_addr      DS  0XL4               seek addr\nlr_seek_addr_cc   DS  XL2\nlr_seek_addr_hh   DS  XL2\nlr_search_arg     DS  0XL5               search arg\nlr_search_arg_cc  DS  XL2\nlr_search_arg_hh  DS  XL2\nlr_search_arg_r   DS  X\nlr_sector         DS  X\nlr_tlf            DS  XL2                transfer length factor\nlr_parms_l        EQU *-lr_parm_area\n\ncount          DSECT  ,                  count area descriptor\ncount_cchhr       DS  0XL5               record address\ncount_cchh        DS  0XL4               record address\ncount_cc          DS  XL2\ncount_hh          DS  XL2\ncount_r           DS  X\ncount_key         DS  X                  key length\ncount_data        DS  XL2                data length\ncount_end         DS  0X\ncount_len         EQU *-count\n\nha             DSECT  ,                  home area descriptor\nha_bin            DS  X\nha_cc             DS  XL2\nha_hh             DS  XL2\nha_end            DS  0X\nha_len            EQU *-ha\n\nrw_ent         DSECT  ,                  rewrite entry\nrw_pos            DS  F\nrw_buf            DS  A\nrw_ttr            DS  F\nrw_next           DS  0F\nrw_len            EQU *-rw_ent\n\nL2TAB          DSECT  ,                  level 2 lookup table entry\nL2TAB_entry       DS  0XL8\nL2TAB_pos         DS  XL4                   pos of track image\nL2TAB_len         DS  XL2                   length of track in area\nL2TAB_size        DS  XL2                   size of track area\nL2TAB_next        DS  0X\n\nVDHDR          DSECT  ,                  virt disk file header\nVDH_devhdr        DS  XL512\nVDH_devhdr2       DS  XL512\nVDH_l1tab         DS  0X\n\nCKDDASD_DEVHDR DSECT  ,                  device header\nCKD_devid         DS  XL8\nCKD_heads         DS  F\nCKD_trksize       DS  F\nCKD_devtype       DS  X\nCKD_fileseq       DS  X\nCKD_highcyl       DS  H\nCKD_resv          DS  XL(512-(*-CKDDASD_DEVHDR))\nCKD_len           EQU *-CKDDASD_DEVHDR\n\nCCKDDASD_DEVHDR   DSECT ,                compressed device header\nCCKD_vrm            DS  XL3\nCCKD_options        DS  X\nCCKD_NOFUDGE        EQU 1\nCCKD_BIGENDIAN      EQU 2\nCCKD_OPENED         EQU 128\nCCKD_numl1tab       DS  F\nCCKD_numl2tab       DS  F\nCCKD_size           DS  F\nCCKD_used           DS  F\nCCKD_free           DS  F\nCCKD_free_total     DS  F\nCCKD_free_largest   DS  F\nCCKD_free_number    DS  F\nCCKD_free_imbed     DS  F\nCCKD_cyls           DS  F\n                    DS  X\nCCKD_compress       DS  X\nCCKD_COMPRESS_NONE  EQU 0\nCCKD_COMPRESS_ZLIB  EQU 1\nCCKD_compress_parm  DS  H\nCCKD_gcol           DS  5XL16\nCCKD_resv           DS  XL(512-(*-CCKDDASD_DEVHDR))\nCCKD_len            EQU *-CCKDDASD_DEVHDR\n\n*/* ----------------------------------------------------------------\n* *      dsects\n* * ---------------------------------------------------------------- */\n\n PRINT   GEN           Was NOGEN                                SOMITCW\n DCBD DSORG=PS\n IEFUCBOB ,\n IEFJFCBN ,\n ICVAFBFL ,\n ICVAFPL  ,\n IECSDSL1 (1,3,4)\n IEZDEB   ,\n IEZIOB   ,\n IOSDCCW  ,\n\n*/* ----------------------------------------------------------------\n* *      equates\n* * ---------------------------------------------------------------- */\n\nlr equ  x'47'   locate record\nrt equ  x'de'   read track\n\nr0 equ  0\nr1 equ  1\nr2 equ  2\nr3 equ  3\nr4 equ  4\nr5 equ  5\nr6 equ  6\nr7 equ  7\nr8 equ  8\nr9 equ  9\nra equ 10\nrb equ 11\nrc equ 12\nrd equ 13\nre equ 14\nrf equ 15\n\n         END ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCKDLOAD": {"ttr": 13322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x000\\x01\\x14\\x08o\\x01\\x14\\x08o\\x15H\\x08\\x11\\x08\\x11\\x00\\x00\\xc3\\xe5\\xc1\\xd9\\xd3\\xc5\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2014-03-27T00:00:00", "modifydate": "2014-03-27T15:48:30", "lines": 2065, "newlines": 2065, "modlines": 0, "user": "CVARLET"}, "text": "*/* -------------------------------------------------------------------\n*   Restore a cckd file to a real dasd unit.\n*   The dasd unit must be offline.\n*\n*   Invocation:\n*      //step   EXEC PGM=CCKDLOAD,PARM=unit\n*      //STEPLIB  DD DISP=SHR,DSN=apf.authorized.loadlib\n*      //SYSPRINT DD SYSOUT=*\n*      //SYSUT1   DD DISP=SHR,DSN=cckd.file\n*\n* ------------------------------------------------------------------ */\n\n*/* -------------------------------------------------------------------\n*   local macros\n* ------------------------------------------------------------------ */\n         MACRO\n&L      #LLE  &R,&A                      load little-endian\n&L       IC   &R,&A\n         ICM  &R,2,1+&A\n         ICM  &R,4,2+&A\n         ICM  &R,8,3+&A\n         MEND\n\n         MACRO\n&L      #LHLE &R,&A                      load halfword little-endian\n&L       SLR  &R,&R\n         IC   &R,&A\n         ICM  &R,2,1+&A\n         MEND\n\n         MACRO\n&L      #LC   &R,&A                      load conditional\n&L       TM   cdevhdr_options,CCKD_BIGENDIAN\n         BO   #LC&SYSNDX.A\n        #LLE  &R,&A\n         B    #LC&SYSNDX.B\n#LC&SYSNDX.A  L  &R,&A\n#LC&SYSNDX.B  DS 0H\n         MEND\n\n         MACRO\n&L      #LHC  &R,&A                      load halfword conditional\n&L       TM   cdevhdr_options,CCKD_BIGENDIAN\n         BO   #LHC&SYSNDX.A\n        #LHLE &R,&A\n         B    #LHC&SYSNDX.B\n#LHC&SYSNDX.A SLR &R,&R\n              ICM &R,3,&A\n#LHC&SYSNDX.B DS  0H\n         MEND\n\n         MACRO\n&L      #READ &OFFSET=,&LENGTH=,&ADDR=   read a cckd block\n&L       LA   r1,pl\n.*\n         AIF  ('&OFFSET'(1,1) EQ '(').r1\n         LA   re,&OFFSET\n         AGO  .x1\n.r1      LR   re,&OFFSET(1)\n.x1      ANOP\n.*\n         AIF  ('&LENGTH'(1,1) EQ '(').r2\n         LA   rf,&LENGTH\n         AGO  .x2\n.r2      LR   rf,&LENGTH(1)\n.x2      ANOP\n.*\n         AIF  ('&ADDR'(1,1) EQ '(').r3\n         LA   r0,&ADDR\n         AGO  .x3\n.r3      LR   r0,&ADDR(1)\n.x3      ANOP\n.*\n         STM  re,r0,0(r1)\n         L    rf,=A(readr)\n         BALR re,rf\n         MEND\n\n         MACRO\n&L      #WRITE &ADDR=                    write a ckd track image\n.*\n         AIF  ('&ADDR'(1,1) EQ '(').r1\n&L       LA   r1,&ADDR\n         AGO  .x1\n.r1      ANOP\n&L       LR   r1,&ADDR(1)\n.x1      ANOP\n         L    rf,=A(writer)\n         BALR re,rf\n         MEND\n\n         MACRO\n&L      #MSG   &MSG,&TYPE=CALL           messages\n         LCLA  &A,&N,&O\n         LCLC  &C\n         GBLA  &MSG_IX\n         GBLC  &MSGS(256)\n         AIF   ('&TYPE' EQ 'CALL').CALL,                               x\n               ('&TYPE' EQ 'GEN').GEN\n         MNOTE 8,'Invalid type specified'\n         MEXIT\n.*\n.CALL    ANOP\n&MSG_IX  SETA  &MSG_IX+1\n&MSGS(&MSG_IX) SETC '&MSG'\n&L       L     re,=A(#MSG&MSG_IX)\n         LA    rf,L'#MSG&MSG_IX\n&A       SETA  2\n&O       SETA  0\n&N       SETA  N'&SYSLIST\n         AGO   .PL0\n.PLLOOP  ANOP\n         LA    re,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX14\n         LA    rf,&SYSLIST(&A)\n&A       SETA  &A+1\n.PL0     ANOP\n         AIF   (&A GT &N).PLX15\n         LA    r0,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX0\n         LA    r1,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX1\n         STM   re,r1,pl+&O\n&O       SETA  &O+16\n         AGO   .PLLOOP\n.PLX14   ST    re,pl+&O\n         AGO   .CALL2\n.PLX15   STM   re,rf,pl+&O\n         AGO   .CALL2\n.PLX0    STM   re,r0,pl+&O\n         AGO   .CALL2\n.PLX1    STM   re,r1,pl+&O\n.CALL2   LA    r1,pl\n         L     rf,=a(msgr)\n         BALR  re,rf\n         MEXIT\n.*\n.GEN     ANOP\n         AIF   ('&L' EQ '').GENNOL\n&L       DS    0H\n.GENNOL  ANOP\n&A       SETA  1\n.GENLOOP AIF   (&A GT &MSG_IX).MEND\n#MSG&A   DC    C&MSGS(&A)\n&A       SETA  &A+1\n         AGO   .GENLOOP\n.MEND    MEND\n\n*/* -------------------------------------------------------------------\n*   mainline routine\n* ------------------------------------------------------------------ */\nmain     CSECT ,\nmain     AMODE 31\nmain     RMODE ANY\n         B     init-*(,rf)\n         DC    AL1(init-*)\npgmid    DC    CL8'cckdload'\nvrm      DC    X'000102'          version 0 release 1 modlvl 2  CZV70\n         DC    C' &SYSDATE &SYSTIME '\ninit     SAVE  (14,12)\n         LR    rc,rf              set base reg\n         USING main,rc\n         LA    ra,4095(,rc)       set 2nd base reg\n         USING main+4095,ra\n         LR    r2,r1              copy parm reg\n\n*/* -------------------------------------------------------------------\n*   obtain and initialize workareas\n* ------------------------------------------------------------------ */\n         STORAGE OBTAIN,LENGTH=workl,BNDRY=PAGE get work area\n         ST    r1,8(,rd)          chain save areas\n         ST    rd,4(,r1)\n         LR    rd,r1              set area base\n         USING work,rd\n         MVC   workid,pgmid       set area identifier\n         LA    r0,work+8          clear the area\n         L     r1,=a(workl-8)\n         SLR   rf,rf\n         MVCL  r0,re\n         STORAGE OBTAIN,LENGTH=work24l,LOC=BELOW,BNDRY=PAGE 24 bit area\n         LR    rb,r1              set 24-bit area base\n         USING work24,rb\n         MVC   work24id,pgmid     set 24-bit area identifier\n         LA    r0,work24+4        clear the 24-bit area\n         L     r1,=a(work24l-4)\n         SLR   rf,rf\n         MVCL  r0,re\n\n*/* -------------------------------------------------------------------\n*   process PARM= : <unit-address>\n* ------------------------------------------------------------------ */\n         N     r2,=A(X'7fffffff') test parameter reg\n         BZ    Enoparm             invalid parameter list\n         L     r3,0(,r2)          point to parameters\n         N     r3,=A(X'7fffffff')  test parameter reg\n         BZ    Enoparm              invalid parameter list\n         LH    r4,0(,r3)          get length of parameters\n         LTR   r4,r4               test length\n         BNP   Enoparm              invalid parameter list\n         BCTR  r4,0               decrement for EX\n         LA    r3,2(,r3)          point past length\n         SLR   r2,r2              clear TRT register\n\n*/*      1st and only parm is unit address in hex                    */\n         XC    dw,dw              clear double-word work area\n         CH    r4,=Y(4)           check 2nd parm length\n         BNL   Ebadparm           error if too long\n         EX    r4,parmmvc         copy 2nd parameter\n*/*      MVC   dw(0),0(r3)        *** executed ***                   */\n         TR    dw,upcase          convert to uppercase\n         EX    r4,parmhexc        test if all hex digits\n*/*      TRT   drwdw(0),hexchars  *** executed ***                   */\n         BNZ   Ebadparm            error if not\n         EX    r4,parmhex         convert to hex digits\n*/*      TR    dw(0),hextab       *** executed ***                   */\n         LA    r5,1(,r4)\n         EX    r5,parmpack        get hex value\n*/*      PACK  dw2,dw(0)          *** executed ***                   */\n         SLR   r5,r5              clear unit address\n         ICM   r5,3,dw2+5         load hex value\n         STH   r5,unit            save unit address\n\n*/* -------------------------------------------------------------------\n*   print initialization message\n* ------------------------------------------------------------------ */\n         TIME  DEC\n         STM   r0,r1,ctime        get time and date of load\n         LA    r1,ctime\n         LA    r0,dtime\n         BAL   re,datetime\n        #MSG   '%s:8 %d:1.%d:1.%d:1 load starting at %s:20',           X\n               pgmid,vrm,vrm+1,vrm+2,dtime\n\n*/* -------------------------------------------------------------------\n*   open the cckd file\n* ------------------------------------------------------------------ */\n         MVC   sysut1,m_sysut1                   copy the model dcb\n         MVC   sysut1e,m_sysut1e                 copy the model dcbe\nut1      USING IHADCB,sysut1\n         LA    r1,sysut1e                        set dcbe address\n         ST    r1,ut1.DCBDCBE                     in the dcb\n         DEVTYPE ut1.DCBDDNAM,devta              get device info\n         LTR   rf,rf                             test return code\n         BNZ   Edevterr                           error if non-zero\n         TM    devta+2,UCB3DACC                  check for dasd device\n         BNO   Enotdasd1                          error if not on dasd\n         MVC   openl,m_openl                     copy model open list\n         OPEN  (sysut1,INPUT),MODE=31,MF=(E,openl) open the cckd file\n         TM    ut1.DCBOFLGS,DCBOFOPN             did cckd file open ?\n         BNO   Eopenerr                           no, open error\n         CLC   ut1.DCBBLKSI,=Y(16384)       check block size    CZV70\n         BNE   Ebadblksz                    error if not 16384  CZV70\n         MVC   pl(l_tcpl),m_tcpl                 copy model parm list\n         TRKCALC FUNCTN=TRKCAP,TYPE=devta+3,RKDD==x'01004000',  CZV70  x\n               REGSAVE=YES,MF=(E,pl)             calculate blks/trk\n         LTR   rf,rf                             test return code\n         BNZ   Etrkcalc                           error if non-zero\n         ST    r0,bpt                            save blks/trk\n\n*/* -------------------------------------------------------------------\n*   read the CKDDASD_DEVHDR\n* ------------------------------------------------------------------ */\n        #READ  OFFSET=0,LENGTH=CKDDASD_DEVHDR_SIZE,ADDR=devhdr\n         USING CKDDASD_DEVHDR,devhdr\n         TR    devhdr_devid,A2E\n         CLC   devhdr_devid,=C'CKD_C370'         check devid\n         BNE   Edevid\n        #LLE   r1,devhdr_heads                   get number of heads\n         ST    r1,heads\n        #LLE   r1,devhdr_trksize                 get trk size\n         ST    r1,trklen\n         IC    r1,devhdr_devtype                 get device type\n         STC   r1,devtype+1\n         STC   r1,devtype\n         TR    devtype(1),devtype_table          get 1st byte\n         CLI   devtype,0                         known type ?\n         BE    Ebaddevt                           no, error\n\n*/* -------------------------------------------------------------------\n*   read the CCKDDASD_DEVHDR\n* ------------------------------------------------------------------ */\n        #READ  OFFSET=CKDDASD_DEVHDR_SIZE,LENGTH=CCKDDASD_DEVHDR_SIZE, x\n               ADDR=cdevhdr\n         USING CCKDDASD_DEVHDR,cdevhdr\n         TM    cdevhdr_options,CCKD_OPENED       was file closed ?\n         BNO   openok                             yes, continue\n        #MSG   'Warning... cckd file was not closed'\n         MVC   result,=A(4)\nopenok   DS    0H\n        #LC    r1,cdevhdr_cyls                   number of cylinders\n         ST    r1,cyls\n        #LC    r2,cdevhdr_numl1tab               l1 table entries\n         ST    r2,numl1tab\n\n*/* -------------------------------------------------------------------\n*   read the CCKD_L1TAB\n* ------------------------------------------------------------------ */\n         SLL   r2,2                              size of l1tab\n         STORAGE OBTAIN,LENGTH=(r2)              get l1tab storage\n         LR    r3,r1\n         ST    r3,l1tab\n        #READ  OFFSET=CCKD_L1TAB_POS,LENGTH=(r2),ADDR=(r3)\n\n*/* -------------------------------------------------------------------\n*   find the last used track and cylinder\n* ------------------------------------------------------------------ */\n         ALR   r2,r3                             end of l1tab\nlastl1   SH    r2,=Y(CCKD_L1ENT_SIZE)            backup an entry\n         CLR   r2,r3                             before the beginning ?\n         BL    Eempty                             yes, empty file\n        #LC    r4,0(r2)                          get l2tab offset\n         LTR   r4,r4                             empty ?\n         BZ    lastl1                             yes, keep looking\n        #READ  OFFSET=(r4),LENGTH=CCKD_L2TAB_SIZE,ADDR=l2tab\n         LA    r4,l2tab                          beginning of l2tab\n         LA    r5,CCKD_L2TAB_SIZE(,r4)           end of l2tab\nlastl2   SH    r5,=Y(CCKD_L2ENT_SIZE)            backup an entry\n         CLR   r5,r4                             before the beginning ?\n         BL    lastl1                             yes, keep looking\n         USING CCKD_L2ENT,r5\n        #LC    r0,l2ent_pos                      load trk offset\n         LTR   r0,r0                             empty ?\n         BZ    lastl2                             yes, keep looking\n         SR    r2,r3                             each 4-byte l1tab\n         SRL   r2,2                               entry represents\n         SLL   r2,8                                256 tracks\n         SR    r5,r4                             each 8-byte l2tab\n         SRL   r5,3                               entry is a track\n         AR    r5,r2                             have last used trk\n         ST    r5,lasttrk\n         SLR   r4,r4\n         D     r4,heads                          have last used cyl\n         ST    r5,lastcyl\n         DROP  r5\n\n        #MSG   'cckd file is a %x4:2 cyls %d heads %d trklen %d; cyl %dx\n                is the last used cylinder',                            x\n               devtype,cyls,heads,trklen,lastcyl\n\n*/* -------------------------------------------------------------------\n*   `fake-open' the offline device\n* ------------------------------------------------------------------ */\n\n*/* -------------------------------------------------------------------\n*   look for the ucb for the unit & make sure it's an offline dasd\n* ------------------------------------------------------------------ */\n         MVC   pl(l_ulpl),m_ulpl                 copy parm list\n         MODESET MODE=SUP\n         UCBLOOK DEVN=unit,UCBPTR=ucbaddr,PIN,PTOKEN=ptoken,           x\n               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,pl),                x\n               TEXT==C'cckddump offline dasd lookup'\n         STM   rf,r0,retcd                       save ret/rsn codes\n         MODESET MODE=PROB\n         LM    rf,r0,retcd\n         LTR   rf,rf                             check return code\n         BNZ   Ebaducbl                           ucblook error\n         OI    flags,ucbpin\n         L     r2,ucbaddr\n         USING UCBOB,r2\n         CLI   UCBTBYT3,UCB3DACC                 check for dasd ucb\n         BNE   Ebaducbt                           not a dasd unit\n         TM    UCBSTAT,UCBONLI                   is device online ?\n         BO    Ebaducbs                           unit is not offline\n\n*/* -------------------------------------------------------------------\n*   if we got a 31-bit address then we need to `capture' a 24-bit addr\n* ------------------------------------------------------------------ */\n         MVC   cucbaddr,ucbaddr                  copy ucb addr\n         TM    ucbaddr,X'ff'                     31 bit address ?\n         BZ    cucbok                             no, continue\n         MVC   pl(l_cupl),m_cupl                 copy parm list\n         MODESET MODE=SUP\n         IOSCAPU CAPTUCB,UCBPTR=ucbaddr,CAPTPTR=cucbaddr,              x\n               MF=(E,pl)                         capture 24 bit addr\n         STM   rf,r0,retcd                       save ret/rsn codes\n         MODESET MODE=PROB\n         LM    rf,r0,retcd\n         LTR   rf,rf                             check return code\n         BNZ   Ebaducbc                           ioscapu error\n         OI    flags,captucb\ncucbok   DS    0H\n\n*/* -------------------------------------------------------------------\n*   build a dcb for the offline dasd\n* ------------------------------------------------------------------ */\n         MVC   unitdcb,m_unitdcb                 copy model dcb\nudcb     USING IHADCB,unitdcb\n         MVC   udcb.DCBMACRF,udcb.DCBMACR        copy macr\n\n*/* -------------------------------------------------------------------\n*   build a deb for the offline dasd\n* ------------------------------------------------------------------ */\n         MODESET MODE=SUP,KEY=ZERO\n         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW\n         ST    r1,debaddr                        save deb address\n         XC    0(DEBLENGTH,r1),0(r1)             clear the deb\n         LR    r3,r1                             app vector table\n         USING DEBAVT,r3\n         LA    r4,DEBBASND-DEBAVT(,r3)           debdasd section\n         USING DEBDASD,r4\n         LA    r5,DEBDASDE-DEBDASD(,r4)          deb ext section\n         USING DEBXTN,r5\n         L     r6,CVTPTR                         get cvt address\n         USING CVT,r6\n         L     rf,CVTXAPG                        ios app vector table\n         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf)     copy vector table\n         ST    r5,DEBXTNP                        set ext address\n         USING PSA,r0\n         L     r7,PSATOLD                        get tcb address\n         USING TCB,r7\n         ST    r7,DEBTCBAD                       set tcb address\n         OI    DEBFLGS1,DEBXTNIN                 indicate ext exists\n         LA    r0,unitdcb                        get dcb address\n         ST    r0,DEBDCBAD                       set dcb address\n         MVI   DEBDEBID,15                       set deb identifier\n         OC    DEBPROTG,TCBPKF                   set protection key\n         ST    r3,DEBAPPAD                       set app table address\n         MVC   DEBUCBA,cucbaddr+1                set ucb address\n         MVC   DEBXLNGH,=Y(DEBXLEN)              set ext length\n         LA    r1,DEBBASIC                       get basic address\n         STCM  r1,7,udcb.DCBDEBA                 set deb addr in dcb\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         MVC   DEBDEBB,TCBDEB+1                  set addr next deb\n         LA    r1,DEBBASIC                       get basic addr\n         ST    r1,TCBDEB                         chain deb to the tcb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n\n*/* -------------------------------------------------------------------\n*   add the deb to the deb list\n* ------------------------------------------------------------------ */\n         DEBCHK unitdcb,TYPE=ADD,AM=EXCP\n         STM   rf,r0,retcd\n         MODESET MODE=PROB,KEY=NZERO\n         LM    rf,r0,retcd\n         LTR   rf,rf                             test return code\n         BNZ   Ebaddeba                           debchk add failed\n         OI    flags,debadded\n\n*/* -------------------------------------------------------------------\n*   build the dasd extent\n* ------------------------------------------------------------------ */\n         MODESET MODE=SUP,KEY=ZERO\n         MVC   DEBUCBAD,cucbaddr                 set 24-bit ucb addr\n         MVI   DEBDVMOD,0                        set device modifier\n         MVC   DEBENDCC,=X'7fff'                 set end cylinder\n         MVC   DEBENDHH,=X'00ff'                 set end head\n         MVC   DEBNMTRK,=X'7fff'                 set nbr trks in extent\n         MODESET MODE=PROB,KEY=NZERO\n\n         DROP  r0,r2,r3,r4,r6,r7\n\n*/* -------------------------------------------------------------------\n*   build a couple of iobs\n* ------------------------------------------------------------------ */\ni1       USING IOBSTDRD,iob1\n         OI    i1.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,ecb1\n         ST    r1,i1.IOBECBPT\n         LA    r1,ccws\n         ST    r1,i1.IOBSTART\n         LA    r1,unitdcb\n         ST    r1,i1.IOBDCBPT\ni2       USING IOBSTDRD,iob2\n         OI    i2.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,ecb2\n         ST    r1,i2.IOBECBPT\n         LA    r1,ccws\n         LA    r1,ccwl(,r1)\n         ST    r1,i2.IOBSTART\n         LA    r1,unitdcb\n         ST    r1,i2.IOBDCBPT\n\n*/* -------------------------------------------------------------------\n*   turn off the `not ready' bit\n* ------------------------------------------------------------------ */\n         L     r2,ucbaddr                        load ucb addr\n         USING UCBOB,r2\n         TM    UCBFLA,UCBNRY                     `not ready' bit on ?\n         BNO   nryok                              no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         NI    UCBFLA,255-UCBNRY                 turn off `not ready'\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\n         OI    flags,notready\nnryok    DS    0H\n\n*/* -------------------------------------------------------------------\n*   sense the offline device\n* ------------------------------------------------------------------ */\n         LA    r2,ccws\n         USING CCW0,r2\n\n         MODESET MODE=SUP,KEY=ZERO\n         OI    DEBXFLG2,DEBCHCMP+DEBBYP\n         MODESET MODE=PROB,KEY=NZERO\n\n*/* seek                                                            */\n         XC    CCW0(8),CCW0\n         MVI   CCW0CMD,SK\n         LA    r1,zeros\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         MVC   CCW0CNT,=Y(6)\n         EXCP  iob1\n         WAIT  1,ECB=ecb1\n         CLI   ecb1,ECBNORM\n         BNE   Esnserr\n\n*/* Sense ID                                                        */\n         XC    ecb1,ecb1\n         XC    CCW0(8),CCW0\n         MVI   CCW0CMD,SNSID\n         LA    r1,snsidarea\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         MVC   CCW0CNT,=Y(L'snsidarea)\n         EXCP  iob1\n         WAIT  1,ECB=ecb1\n         CLI   ecb1,ECBNORM\n         BNE   Esnserr\n\n*/* Sense                                                           */\n         XC    ecb1,ecb1\n         XC    CCW0(8),CCW0\n         MVI   CCW0CMD,SNS\n         LA    r1,snsarea\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         MVC   CCW0CNT,=Y(L'snsarea)\n         EXCP  iob1\n         WAIT  1,ECB=ecb1\n         CLI   ecb1,ECBNORM\n         BNE   Esnserr\n\n*/* Read Device Characteristics                                     */\n         XC    ecb1,ecb1\n         XC    CCW0(8),CCW0\n         MVI   CCW0CMD,RDC\n         LA    r1,rdcarea\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,0\n         MVC   CCW0CNT,=Y(L'rdcarea)\n         EXCP  iob1\n         WAIT  1,ECB=ecb1\n         CLI   ecb1,ECBNORM\n         BNE   Esnserr\n\n*/* Sense Subsystem Status\n         XC    ecb1,ecb1\n         XC    CCW0(8),CCW0\n         MVI   CCW0CMD,SNSS\n         LA    r1,snssarea\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         MVC   CCW0CNT,=Y(L'snssarea)\n         EXCP  iob1\n         WAIT  1,ECB=ecb1\n         CLI   ecb1,ECBNORM\n         BNE   Esnserr\n\n         MODESET MODE=SUP,KEY=ZERO\n         NI    DEBXFLG2,255-DEBBYP\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2,r5\n\n*/* -------------------------------------------------------------------\n*   perform some sanity checks\n* ------------------------------------------------------------------ */\n         USING RDCinfo,rdcarea\n         MVC   pl(l_tcpl),m_tcpl                 copy model parm list\n         L     r2,cucbaddr\n         TRKCALC FUNCTN=TRKBAL,UCB=(r2),RKDD==A(x'0100ffff'),          x\n               MAXSIZE=YES,REGSAVE=YES,MF=(E,pl)\n         CH    rf,=Y(8)\n         BNE   Ebadcap                           unexpected return code\n         LR    r1,r0                             round up 512\n         LA    r1,511(,r1)\n         N     r1,=A(x'fffffe00')\n         ST    r1,utrklen\n        #MSG   'unit %x4:2 is a %x4:2 cyls %d:2 heads %d:2 trklen %d', x\n               unit,RDCdevt,RDCprime,RDCheads,utrklen\n         CLC   RDCdevt,devtype\n         BNE   Emisdevt\n         CLC   RDCheads,heads+2\n         BNE   Emisheads\n         CLC   trklen,utrklen\n         BNE   Emislen\n         CLC   RDCprime,lastcyl+2\n         BH    cylok\n        #MSG   'Warning... cckd file uses more cylinders than availablex\n                on %x4:2; extras will be omitted',unit\n         MVC   result,=A(4)\ncylok    DS    0H\n*/* Dump tracks thru last used cylinder, or thru last cylinder on    */\n*/* on the output device, whichever is lower                         */\n         L     r3,lastcyl\n         LA    r3,1(,r3)\n         M     r2,heads\n         ST    r3,tracks\n         SLR   r3,r3\n         ICM   r3,3,RDCprime\n         M     r2,heads\n         C     r3,tracks\n         BH    *+8\n         ST    r3,tracks                         tracks to write\n        #MSG   '%d tracks will be written',tracks\n         L     r3,tracks                         tracks to write\n         D     r2,=A(10)\n         LA    r3,99(,r3)\n         SLR   r2,r2\n         D     r2,=A(100)\n         LTR   r3,r3\n         BNZ   *+8\n         LA    r3,1                              10% of tracks to be\n         MH    r3,=Y(100)                         written rounded up\n         ST    r3,trk10pct                         to next 100\n         SLR   r2,r2                                for status msg\n         L     r3,tracks\n         D     r2,heads\n         ST    r3,cyls\n\n*/* -------------------------------------------------------------------\n*   get area for the buffers\n* ------------------------------------------------------------------ */\n         L     r2,trklen\n         SLL   r2,2                              space for 4 buffers\n         STORAGE OBTAIN,LENGTH=(r2)\n         ST    r1,buf1\n         AL    r1,trklen\n         ST    r1,buf2\n         AL    r1,trklen\n         ST    r1,buf3\n         AL    r1,trklen\n         ST    r1,buf4\n\n*/* -------------------------------------------------------------------\n*   create a persistent c environment\n* ------------------------------------------------------------------ */\n         LA    r2,handle\n         LA    r3,=A(32*1024)\n         LA    r4,=A(1)\n         STM   r2,r4,pl\n         OI    pl+8,X'80'\n         LA    r1,pl\n         L     rf,=V(EDCXHOTL)           create persistent c environ\n         BALR  re,rf\n******* #MSG   'persistent c environment created, handle=0x%x',handle\n\n*/* -------------------------------------------------------------------\n*   setup the output channel programs\n* ------------------------------------------------------------------ */\n         LA    r2,ccws            point to 1st ccws\n         USING CCW0,r2\n         LA    r3,lrparm1         point to 1st LR parameters\n         USING LRparm,r3\n         LA    r4,idaw1           point to 1st idaw list\n         LA    rf,2               build 2 sets of ccws\nbldcp    XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,DX         set define extent command\n         LA    r1,dxarea          address of dx area\n         STCM  r1,7,CCW0ADDR      set address\n         MVI   CCW0FLAG,CCW0CC    command chaining\n         MVC   CCW0CNT,=Y(L'dxarea) set length\n         LA    r2,CCW0END         to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,TIC        set transfer-in-control command\n         LA    r1,CCW0END         address of next ccw\n         STCM  r1,7,CCW0ADDR      set next ccw address\n         LA    r2,CCW0END         to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,LR         set locate record command\n         STCM  r3,7,CCW0ADDR      set address in locate record ccw\n         OI    CCW0FLAG,CCW0CC    command chaining\n         MVC   CCW0CNT,=Y(LRparml) set length\n         MVI   LRop,LRocount+LRfwrite set operation byte\n         LA    r0,255             build 255 write ccws\nbldcp2   LA    r2,CCW0END         point to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,WCKD       set read track command\n         STCM  r4,7,CCW0ADDR      set address for idaw\n         LA    r4,4(,r4)          point to next idaw\n         BCT   r0,bldcp2          loop back\n         LA    r2,ccws            point to 2nd\n         LA    r2,ccwl(,r2)        channel program\n         LA    r3,lrparm2         point to 2nd LR parameters\n         LA    r4,idaw2           point to 2nd idaw list\n         BCT   rf,bldcp           build 2nd channel program\n         DROP  r2,r3\n\n*/* -------------------------------------------------------------------\n*   setup the output define extent area\n* ------------------------------------------------------------------ */\n         MVI   dxarea,X'c0'       permit all write operations\n         MVI   dxarea+1,X'c0'     eckd\n         L     r1,cyls            low extent is cyl 0 head 0\n         BCTR  r1,0 set high extent\n         stcm  r1,3,dxarea+12\n         ICM   r1,3,RDCheads\n         BCTR  r1,0\n         STCM  r1,3,dxarea+14\n\n*/* -------------------------------------------------------------------\n*   Read/write each track image\n* ------------------------------------------------------------------ */\n         SLR   r2,r2              init buffer switch\n         SLR   r3,r3              init l1tab index\n         MVC   trkstat,trk10pct init status\n\nrwloop   DS    0H\n\n*/* Read the next l2tab                                              */\n         LR    r4,r3\n         SLL   r4,2\n         AL    r4,l1tab\n        #LC    r5,0(r4)\n         LTR   r4,r5\n         BZ    l2null\n        #READ  OFFSET=(r4),LENGTH=CCKD_L2TAB_SIZE,ADDR=l2tab\n         B     l2ok\nl2null   LA    r0,l2tab\n         LA    r1,CCKD_L2TAB_SIZE\n         SLR   rf,rf\n         MVCL  re,r0\nl2ok     DS    0H\n\n*/* Loop for each entry in the l2tab, exit if all tracks processed   */\n         SLR   r4,r4\nrwloop2  LR    rf,r3\n         SLL   rf,8\n         AR    rf,r4\n         CL    rf,tracks\n         BNL   rwexit\n         ST    rf,track\n\n*/* Get offset/length of the track image from the l2tab entry        */\n         LR    r5,r4\n         SLL   r5,3\n         LA    r5,l2tab(r5)\n         USING CCKD_L2ENT,r5\n        #LC    r6,l2ent_pos\n        #LHC   r7,l2ent_len\n         DROP  r5\n\n         L     r5,bufs(r2)\n\n*/* Read the track image unless its a null track                     */\n         LTR   r6,r6\n         BZ    trknull\n        #READ  OFFSET=(r6),LENGTH=(r7),ADDR=(r5)\n         B     trkok\ntrknull  XC    0(CCKD_NULLTRK_SIZE,r5),0(r5)\n*/* Build a null trk: 0cchh cchh0008 00000000 cchh1000 ffffffff      */\n         SLR   re,re\n         L     rf,track\n         D     re,heads\n         STCM  rf,3,1(r5)\n         STCM  re,3,3(r5)\n         MVC   5(4,r5),1(r5)\n         MVI   8(r5),8\n         MVC   21(4,r5),1(r5)\n         MVI   25(r5),1\n         MVC   29(8,r5),eightFF\ntrkok    DS    0H\n\n         CLI   0(r5),CCKD_COMPRESS_MAX\n         BNH   compok\n        #MSG   'Trk %d unknown compression: %d:1',track,0(r5)\n         MVC   result,=A(8)\n         B     trknull\ncompok   DS    0H\n\n*/* Uncompress the track image                                       */\n         SLR   rf,rf\n         IC    rf,0(,r5)\n         SLL   rf,2\n         B     *+4(rf)\n         B     compnone              0 - not compressed\n         B     compzlib              1 - zlib compression\n         B     compbz2               2 - bz2 compression\n\n*/* Not compressed                                                   */\ncompnone LR    r6,r5\n         B     compdone\n\n*/* zlib compression                                                 */\ncompzlib LR    r6,r5\n         AL    r6,trklen\n         MVC   0(CKDDASD_TRKHDR_SIZE,r6),0(r5)\n         LA    re,handle\n         LA    rf,=V(UNCOMPRE)\n         LA    r0,CKDDASD_TRKHDR_SIZE(,r6)\n         L     r1,trklen\n         SH    r1,=Y(CKDDASD_TRKHDR_SIZE)\n         ST    r1,complen\n         LA    r1,complen\n         STM   re,r1,pl\n         LA    re,CKDDASD_TRKHDR_SIZE(,r5)\n         LR    rf,r7\n         SH    rf,=Y(CKDDASD_TRKHDR_SIZE)\n         STM   re,rf,pl+16\n         LA    r1,pl\n         L     rf,=V(EDCXHOTU)\n         BALR  re,rf\n         LTR   rf,rf\n         BZ    compdone\n         ST    rf,retcd\n        #MSG   'trk %d zlib uncompress error: %d',track,retcd\n         MVC   result,=A(8)\n         B     trknull\n\n*/* bzip2 compression                                                */\ncompbz2  LR    r6,r5\n         AL    r6,trklen\n         MVC   0(CKDDASD_TRKHDR_SIZE,r6),0(r5)\n         LA    re,handle\n         LA    rf,=V(bzbuffd)\n         LA    r0,CKDDASD_TRKHDR_SIZE(,r6)\n         L     r1,trklen\n         SH    r1,=Y(CKDDASD_TRKHDR_SIZE)\n         ST    r1,complen\n         LA    r1,complen\n         STM   re,r1,pl\n         LA    re,CKDDASD_TRKHDR_SIZE(,r5)\n         LR    rf,r7\n         SH    rf,=Y(CKDDASD_TRKHDR_SIZE)\n         SLR   r0,r0\n         SLR   r1,r1\n         STM   re,r1,pl+16\n         LA    r1,pl\n         L     rf,=V(EDCXHOTU)\n         BALR  re,rf\n         LTR   rf,rf\n         BZ    compdone\n         ST    rf,retcd\n        #MSG   'trk %d bzip2 decompress error: %d',track,retcd\n         MVC   result,=A(8)\n         B     trknull\n\ncompdone DS    0H\n\n*/* Schedule the track image to be written                           */\n        #WRITE ADDR=(r6)\n\n*/* Write status message if it's time                                */\n         CLC   track,trkstat\n         BL    rwnext2\n        #MSG   '%d tracks written',track\n         L     r1,trkstat\n         AL    r1,trk10pct\n         ST    r1,trkstat\n\nrwnext2  X     r2,=A(8)                       flip/flop buffers\n         LA    r4,1(,r4)\n         CH    r4,=Y(256)\n         BL    rwloop2\n\nrwnext   LA    r3,1(,r3)\n         B     rwloop\nrwexit   DS    0H\n\n         TIME  DEC\n         STM   r0,r1,ctime\n         LA    r1,ctime\n         LA    r0,dtime\n         BAL   re,datetime\n        #MSG   '%d tracks written at %s:20, max code: %d',             x\n               tracks,dtime,result\n\n*/* -------------------------------------------------------------------\n*   cleanup and terminate\n* ------------------------------------------------------------------ */\n\nterminate DS   0H\n\n*/* Make sure all write i/o has completed                            */\n        #WRITE ADDR=0\n\n*/* Terminate the persistant c environment                           */\n         CLC   =A(0),handle\n         BE    term1\n         LA    r1,handle\n         ST    r1,pl\n         OI    pl,X'80'\n         LA    r1,pl\n         L     rf,=V(EDCXHOTT)\n         BALR  re,rf\nterm1    DS    0H\n\n*/* Close the cckd file                                              */\n         TM    ut1.DCBOFLGS,DCBOFOPN\n         BNO   term2\n         MVC   openl,m_openl\n         CLOSE (sysut1),MODE=31,MF=(E,openl)\nterm2    DS    0H\n\n*/* Free the i/o areas                                               */\n         L     r1,buf1\n         LTR   r1,r1\n         BZ    term3\n         L     r2,trklen\n         SLL   r2,2\n         STORAGE RELEASE,ADDR=(1),LENGTH=(r2)\nterm3    DS    0H\n\n*/* Free the l1tab                                                   */\n         L     r1,l1tab\n         LTR   r1,r1\n         BZ    term4\n         L     r2,numl1tab\n         SLL   r2,2\n         STORAGE RELEASE,ADDR=(1),LENGTH=(r2)\nterm4    DS    0H\n\n*/* Call debchk to delete the deb                                    */\n         TM    flags,debadded\n         BNO   term5\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK unitdcb,TYPE=DELETE,AM=EXCP delete the deb\n         MODESET MODE=PROB,KEY=NZERO\nterm5    DS    0H\n\n         L     r2,debaddr\n         LTR   r2,r2\n         BZ    term6\n\n*/* Remove the deb from the deb chain                                */\n         USING DEBAVT,r2\n         LA    r3,DEBBASIC\n         DROP  r2\n         L     r4,PSATOLD-PSA\n         USING TCB,r4\n         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)\n         USING DEBBASIC,r4\n         MODESET MODE=SUP,KEY=ZERO\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         SPKA  X'80'\ntermdeb  LR    r4,r5\n         SLR   r5,r5\n         ICM   r5,7,DEBDEBB\n         BZ    termdebx\n         CLR   r3,r5\n         BNE   termdeb\n         SPKA  0\n         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5)\n         DROP  r4\ntermdebx SPKA  0\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n\n*/* Free deb storage                                                */\n         MODESET MODE=SUP,KEY=ZERO\n         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230\n         MODESET MODE=PROB,KEY=NZERO\nterm6    DS    0H\n\n*/* Turn the ucb `not ready' bit back on if we turned it off         */\n         TM    flags,notready\n         BNO   term7\n         L     r2,ucbaddr\n         USING UCBOB,r2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    UCBFLA,UCBNRY\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\nterm7    DS    0H\n\n*/* Uncapture the ucb                                                */\n         TM    flags,captucb\n         BNO   term8\n         MVC   pl(l_cupl),m_cupl\n         MODESET MODE=SUP\n         IOSCAPU UCAPTUCB,CAPTPTR=cucbaddr,MF=(E,pl)\n         MODESET MODE=PROB\nterm8    DS    0H\n\n*/* Unpin the ucb                                                    */\n         TM    flags,ucbpin\n         BNO   term9\n         MVC   pl(l_uupl),m_uupl\n         MODESET MODE=SUP\n         UCBPIN UNPIN,PTOKEN=ptoken,MF=(E,pl)\n         MODESET MODE=PROB\nterm9    DS    0H\n\n*/* Close the sysprint file                                          */\npdcb     USING IHADCB,prtdcb\n         TM    pdcb.DCBOFLGS,DCBOFOPN\n         BNO   term10\n         MVC   openl,m_openl\n         CLOSE (prtdcb),MODE=31,MF=(E,openl)\nterm10   DS    0H\n\n*/* Free the work areas                                              */\n         STORAGE RELEASE,ADDR=(rb),LENGTH=work24l\n         LR    r1,rd\n         L     r2,result\n         L     rd,4(,rd)\n         STORAGE RELEASE,ADDR=(1),LENGTH=workl\n\n*/* Return                                                           */\n         LR    rf,r2\n         RETURN (14,12),RC=(15)\n\n*/* -------------------------------------------------------------------\n*   format date & time\n* ------------------------------------------------------------------ */\ndatetime STM   re,r2,12(rd)       save some regs\n         LR    r2,r0              copy output area address\n         MVI   0(r2),C' '         blank the output area\n         MVC   1(19,r2),0(r2)\n         MVC   11(9,r2),=X'4021207a20207a2020' edit pattern for time\n         ED    11(9,r2),0(r1)     edited time\n         XC    dw,dw              clear double word work area\n         SLR   rf,rf\n         ICM   rf,3,4(r1)         decimal year\n         SLL   rf,4               shift over a nibble\n         ST    rf,dw+4            store in the double word\n         OI    dw+7,X'0f'         set bottom nibble\n         AP    dw,=P'1900'        calculate the year\n         OI    dw+7,X'0f'         fix bottom nibble for unpk\n         UNPK  7(4,r2),dw         set the year\n         CVB   rf,dw              get binary year\n         N     rf,=A(3)           test for leap year\n         BZ    *+8                 jumps if leap year\n         LA    rf,2                 else set non-leapyr offset\n         ZAP   dw,6(2,r1)         get julian day in double word\n         CVB   r0,dw              get julian day binary\n         LA    re,dtjtab          point to julian table\ndtfind   CH    r0,8(rf,re)        found table entry ?\n         BNH   dtfound             yes, exit loop\n         LA    re,8(,re)          point to next entry\n         B     dtfind              and loop back\ndtfound  MVC   3(3,r2),4(re)      set month from the table\n         SH    r0,0(rf,re)        calculate day of month\n         CVD   r0,dw              get day of month packed\n         L     r0,dw+4            load packed day\n         SLL   r0,20              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,0(,r2)          set 1st digit of the month\n         OI    0(r2),C'0'         convert to ebcdic character\n         L     r0,dw+4            load packed day\n         SLL   r0,24              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,1(,r2)          set 2nd digit of the month\n         OI    1(r2),C'0'         convert to ebcdic character\n         LM    re,r2,12(rd)       restore regs\n         BR    re                  and thankfully return\ndtjtab   DC    Y(0,0),C'Jan '     Julian date table\n         DC    Y(31,31),C'Feb '\n         DC    Y(60,59),C'Mar '\n         DC    Y(91,90),C'Apr '\n         DC    Y(121,120),C'May '\n         DC    Y(152,151),C'Jun '\n         DC    Y(182,181),C'Jul '\n         DC    Y(213,212),C'Aug '\n         DC    Y(244,243),C'Sep '\n         DC    Y(274,273),C'Oct '\n         DC    Y(305,304),C'Nov '\n         DC    Y(335,334),C'Dec '\n         DC    Y(999,999),C'??? '\n\n*/* -------------------------------------------------------------------\n*   error routines\n* ------------------------------------------------------------------ */\nEnoparm #MSG   '** Unit address not specified'\n         B     Eexit\nEbadparm MVC   dw,=CL8' '\n         CH    r4,=Y(8)\n         BNH   *+8\n         LA    r4,8\n         SH    r4,=Y(1)\n         BM    *+4+4+6\n         EX    r4,*+4\n         MVC   dw(0),0(r3)\n        #MSG   '** Invalid unit address: %s:8',dw\n         B     Eexit\nEdevid  #MSG   '** SYSUT1 is not a cckd file; devid validation failed'\n         B     Eexit\nEsynad1 #MSG   '** SYSUT1 fatal error, Synad EP loaded'    CZV70\n         B     Eexit                                       CZV70\nEdevterr STM   rf,r0,retcd\n         CLC   retcd(8),=A(4,4)     missing ddname ?\n         BE    Enoddn                yes, noddn error\n        #MSG   '** SYSUT1 DEVTYPE error: rc=%d, reason=%d',            X\n               retcd,rsncd\n         B     Eexit\nEnoddn  #MSG   '** SYSUT1 ddname not found'\n         B     Eexit\nEnotdasd1 #MSG '** SYSUT1 not a dasd file'\n         B     Eexit\nEopenerr #MSG  '** SYSUT1 did not open'\n         B     Eexit\nEbadblksz #MSG '** SYSUT1 blksz is not 16384'              CZV70\n         B     Eexit\nEtrkcalc ST    rf,retcd\n        #MSG   '** TRKCAP failed for SYSUT1: rc=%d',retcd\n         B     Eexit\nEbaddevt #MSG  '** cckd dasd devtype not supported: 0x%x2:1',devtype+1\n         B     Eexit\nEempty   #MSG  '** cckd file contains all null tracks'\n         B     Eexit\nEpoint   ST    rf,retcd\n        #MSG   '** SYSUT1 point error: rc=%d ttr=%x6:3',retcd,ttr\n         B     Eexit\nEbaducbl CH    RF,=Y(4)\n         BE    Enoucb\n        #MSG   '** UCBLOOK error for unit %x4:2: rc 0x%x rsn 0x%x',    X\n               unit,retcd,rsncd\n         B     Eexit\nEnoucb  #MSG   '** UCB not found for unit %x4:2',unit\n         B     Eexit\nEbaducbt L     r2,ucbaddr\n         USING UCBOB,r2\n        #MSG   '** UCB for unit %x4:2 is not dasd, type is %x:1',      X\n               unit,UCBTBYT3\n         B     Eexit\n         DROP  r2\nEbaducbs #MSG  '** Device %x4:2 is not offline',unit\n         B     Eexit\nEbaducbc #MSG  '** IOSCAPU CAPTUCB failed for %x4:2; rc=0x%x rsn=0x%x',X\n               unit,retcd,rsncd\n         B     Eexit\nEbaddeba #MSG  '** DEBCHK ADD for %x4:2 failed; rc=0x%x',              X\n               unit,retcd\n         B     Eexit\nEsnserr #MSG   '** Sense failed for %x4:2: command %x2:1, CC 0x%x2:1, SX\n               tat 0x%x4:2',unit,ccws,ecb1,i1.IOBSTBYT\n         B     Eexit\nEbadcap  ST    rf,retcd\n        #MSG   '** TRKBAL for %x4:2 unexpected return code; rc=0x%x',  X\n               unit,retcd\n         B     Eexit\nEmisdevt #MSG  '** devtype mismatch %x4:2=%x4:2, cckd=%x4:2',          X\n               unit,RDCdevt,devtype\n         B     Eexit\nEmisheads #MSG '** number heads mismatch %x4:2=%d:2, cckd=%d',         X\n               unit,RDCheads,heads\n         B     Eexit\nEmislen #MSG   '** trklen mismatch %x4:2=%d, cckd=%d',                 X\n               unit,utrklen,trklen\n         B     Eexit\nEioerr   SLR   r2,r2\n         ICM   r2,7,waitecb+1\n         LA    r0,ecb1\n         LA    r3,iob1\n         CLR   r0,r2\n         BE    *+8\n         LA    r3,iob2\n         USING ECB,r2\n         USING IOBSTDRD,r3\n        #MSG   '** I/O error %x4:2 CCHH %x8: CC %x2:1, Stat %x4:2',    X\n               unit,prevcchh,ECBCC,IOBSTBYT\n         DROP  r2,r3\n         B     Eexit\n\nEexit    MVC   result,=A(12)\n         B     terminate\n\n*/* -------------------------------------------------------------------\n*   literals and constants\n* ------------------------------------------------------------------ */\n          LTORG ,\nparmmvc   MVC   dw(0),0(r3)        *** executed ***\nparmhexc  TRT   dw(0),hexchars     *** executed ***\nparmhex   TR    dw(0),hextab       *** executed ***\nparmpack  PACK  dw2,dw(0)          *** executed ***\nm_unitdcb DCB   DDNAME=0,DSORG=PS,MACRF=E\nl_unitdcb EQU   *-m_unitdcb\nm_sysut1  DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=RP,DCBE=m_sysut1e,RECFM=F\nl_sysut1  EQU   *-m_sysut1\nm_sysut1e DCBE  RMODE31=BUFF,SYNAD=Esynad1,BLOCKTOKENSIZE=LARGE CZV70\nl_sysut1e EQU   *-m_sysut1e\nm_prtdcb  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,DCBE=m_prtdcbe\nl_prtdcb  EQU   *-m_prtdcb\nm_prtdcbe DCBE  RMODE31=BUFF\nl_prtdcbe EQU   *-m_prtdcbe\nm_openl   OPEN  (0),MODE=31,MF=L\nl_openl   EQU   *-m_openl\n          UCBLOOK MF=(L,m_ulpl)\nl_ulpl    EQU   *-m_ulpl\n          UCBPIN MF=(L,m_uupl)\nl_uupl    EQU   *-m_uupl\n          IOSCAPU MF=(L,m_cupl)\nl_cupl    EQU   *-m_cupl\nm_tcpl    TRKCALC MF=L\nl_tcpl    EQU   *-m_tcpl\neightFF   DC    X'ffffffffffffffff'\ndevtype_table   DC 256X'00'\n          ORG   devtype_table+x'80'\n          DC    X'33'\n          ORG   devtype_table+x'90'\n          DC    X'33'\n          ORG   devtype_table+x'45'\n          DC    X'93'\n          ORG   devtype_table+256\nhextab    DC    256X'00'\n          ORG   hextab+C'0'\n          DC    AL1(0,1,2,3,4,5,6,7,8,9)\n          ORG   hextab+C'a'\n          DC    AL1(10,11,12,13,14,15)\n          ORG   hextab+C'A'\n          DC    AL1(10,11,12,13,14,15)\n          ORG   hextab+256\nhexchars  DC    256x'ff'\n          ORG   hexchars+C'a'\n          DC    6x'0'\n          ORG   hexchars+C'A'\n          DC    6x'0'\n          ORG   hexchars+C'0'\n          DC    10x'0'\n          ORG   hexchars+256\nupcase    DC    C' ',255AL1(*-upcase)\n          ORG   upcase+c'a'\n          DC    C'ABCDEFGHI'\n          ORG   upcase+c'j'\n          DC    C'JKLMNOPQR'\n          ORG   upcase+c's'\n          DC    C'STUVWXYZ'\n          ORG   upcase+256\nA2E       DS    0D\n*      0 1 2 3 4 5 6 7 8 9 a b c d e f\n DC X'00010203372D2E2F1605250B0C0D0E0F' 0\n DC X'101112133C3D322618193F27221D351F' 1\n DC X'405A7F7B5B6C507D4D5D5C4E6B604B61' 2\n DC X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F' 3\n DC X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6' 4\n DC X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D' 5\n DC X'79818283848586878889919293949596' 6\n DC X'979899A2A3A4A5A6A7A8A9C04FD0A107' 7\n DC X'00010203372D2E2F1605250B0C0D0E0F' 8\n DC X'101112133C3D322618193F27221D351F' 9\n DC X'405A7F7B5B6C507D4D5D5C4E6B604B61' a\n DC X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F' b\n DC X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6' c\n DC X'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D' d\n DC X'79818283848586878889919293949596' e\n DC X'979899A2A3A4A5A6A7A8A9C04FD0A107' f\nhex2char  EQU   *-240\n          DC    C'0123456789ABCDEF'\n          DROP  ,\nmainend   DS    0D\n\n*/* -------------------------------------------------------------------\n*   Subroutine to read the cckd file\n* ------------------------------------------------------------------ */\n          USING readr,r9\n          USING work,rd\n          USING work24,rb\n          USING main,rc\n          USING (main+4095,mainend),ra\nreadr     STM  r0,rf,save1\n          LR   r9,rf\n\n          LM   r2,r4,0(r1)          load offset, length, address\n\n*/* Read the first block into the tempbuf                            */\n          LR   r7,r2                copy the offset\n          SRL  r7,14                get the block number   CZV70\n          LTR  r2,r2                test offset\n          BZ   r_getblk1            always read 1st block for offset 0\n          CL   r7,lastblk           already have the 1st block ?\n          BE   r_gotblk1             yes, continue\n          ST   r7,lastblk           remember this block\n          SLR  r6,r6\n          D    r6,bpt               calculate ttr\n          STCM r7,7,ttr                                    CZV70\n          LA   r6,1(,r6)\n          STC  r6,ttr+3                                    CZV70\n          POINT sysut1,ttr          position to the block\n          LTR  rf,rf\n          BNZ  Epoint\nr_getblk1 READ ut1decb,SF,sysut1,tempbuf,'S',MF=E\n          CHECK ut1decb             read the block\nr_gotblk1 DS   0H\n\n*/* Copy data from the first block to the caller's buffer            */\n          LR   r5,r2                calculate data offset\n          N    r5,=A(X'00003fff')    in the first block    CZV70\n          LH   r6,=Y(16384)         calculate data length  CZV70\n          SR   r6,r5                 in the first block\n          AR   r2,r6                new offset\n          LR   re,r4                target address\n          LR   rf,r6                data length in the first block\n          CR   rf,r3                if requested length is less\n          BL   *+6                   then use that instead\n          LR   rf,r3\n          LA   r0,tempbuf(r5)       source address\n          LR   r1,rf                length to copy\n          AR   r4,rf                adjust target address\n          SR   r3,rf                adjust target length\n          MVCL re,r0                copy data from the 1st block\n\n*/* Read the intermediate blocks directly into the caller's buffer   */\nr_getint  LTR  r3,r3                test length left to read\n          BZ   r_return             return if everything read\n          CH   r3,=Y(16384)   able to read a full block ?  CZV70\n          BL   r_getlast             no, special processing for last\n          READ ut1decb,SF,sysut1,(r4),'S',MF=E\n          CHECK ut1decb             read an intermediate block\n          AH   r2,=Y(16384)         adjust the offset      CZV70\n          SH   r3,=Y(16384)         adjust the length left CZV70\n          AH   r4,=Y(16384)         adjust buffer position CZV70\n          B    r_getint             read some more\n\n*/* Read the last block into the tempbuf                             */\nr_getlast SRL  r2,14       change offset to block number   CZV70\n          ST   r2,lastblk            and save it\n          READ ut1decb,SF,sysut1,tempbuf,'S',MF=E\n          CHECK ut1decb\n          LR   re,r4                target address\n          LR   rf,r3                target length\n          LA   r0,tempbuf           source address\n          LR   r1,rf                source length\n          MVCL re,r0                copy data from the last block\n\nr_return  LM   r0,rf,save1\n          BR   re\n\n          LTORG ,\n          DROP ,\n\n*/* -------------------------------------------------------------------\n*   Subroutine to write track images to the offline dasd unit\n* ------------------------------------------------------------------ */\n          USING writer,r9\n          USING work,rd\n          USING work24,rb\n          USING main,rc\n          USING (main+4095,mainend),ra\nwriter    STM  r0,rf,save1\n          LR   r9,rf\n\n*/* If buffer address is zero then we simply wait on the last I/O    */\n          LTR  r1,r1\n          BZ   w_finish\n\n*/* Get the IOB we will use                                          */\n          L    r2,iobswtch          0 = iob1, 1 = iob2\n          LA   r3,iob1              presume iob1\n          LTR  r2,r2\n          BZ   *+8\n          LA   r3,iob2              use iob2 if switch is non-zero\n          USING IOBSTDRD,r3\n          X    r2,=A(1)             flip/flop the switch\n          ST   r2,iobswtch\n\n*/* Complete the channel program                                     */\n          MVC  prevcchh,curcchh     copy last cchh scheculed\n          MVC  curcchh,1(r1)        current cchh (from HA)\n          MVC  IOBCC(4),curcchh     set extent in the iob\n          SLR  r2,r2\n          ICM  r2,7,IOBECBPB\n          USING ECB,r2\n          XC   ECB,ECB              clear the ecb\n\n*/* If record 1 is end-of-track then make it eof then eot            */\n          CLC  eightFF,5+8+8(r1)    check for end-of-track\n          BNE  w_wnoteot             continue if not\n          MVC  5+8+8(8,r1),5(r1)      else copy r0 t0 r1\n          MVI  5+8+8+4(r1),1           and set r to 1\n          MVI  5+8+8+7(r1),0            and data len to 0\n          MVC  5+8+8+8(8,r1),eightFF     now set the eot\nw_wnoteot DS   0h\n\n          LA   r1,5+8+8(,r1)        point to record 1\n          SLR  rf,rf                clear record count\n          SLR  r4,r4\n          ICM  r4,7,IOBSTRTB        address of the channel program\n          USING CCW0,r4\n          LA   r4,CCW0END           point past dx ccw\n          LA   r4,CCW0END           point past tic ccw\n          SLR  r5,r5\n          ICM  r5,7,CCW0ADDR        locate record parm addr\n          USING LRparm,r5\n          MVC  LRseek,IOBCC\n          MVC  LRsearch,IOBCC\nw_wckd    LA   r4,CCW0END           point to next ccw\n          LA   rf,1(,rf)            increment record count\n          SLR  r6,r6\n          ICM  r6,7,CCW0ADDR        load IDAW address\n          ST   r1,0(,r6)            set record addr in the IDAW\n          SLR  r0,r0\n          IC   r0,5(,r1)            key length\n          SLR  re,re\n          ICM  re,3,6(r1)           data length\n          AR   re,r0\n          LA   re,8(,re)            cound-key-data-length\n          STCM re,3,CCW0CNT\n          OI   CCW0FLAG,CCW0CC+CCW0IDA set chain & idaw bits\n          AR   r1,re                point to the next record\n          CLC  eightFF,0(r1)        at end of the track ?\n          BNE  w_wckd                no, keep building\n          NI   CCW0FLAG,255-CCW0CC  turn off chain bit for last ccw\n          STC  rf,LRcount           set count of WCKD ccws\n\n*/* Schedule this channel program and wait for the previous one      */\n          LR   rf,r2                copy ecb address\n          L    r2,waitecb           load ecb address to wait on\n          ST   rf,waitecb           set new ecb address to wait on\n          EXCP IOBSTDRD             schedule the i/o\n          LTR  r2,r2                any ecb to wait on ?\n          BZ   w_return              no, just return\n          WAIT 1,ECB=ECB            wait for previous i/o\n          CLI  ECBCC,ECBNORM        successful completion ?\n          BNE  Eioerr                no, i/o error\n          B    w_return\n\n*/* Wait for the last i/o to finish                                  */\nw_finish  L    r2,waitecb           ecb for last i/o\n          LTR  r2,r2                 is it set ?\n          BZ   w_return               no, just return\n          XC   waitecb,waitecb\n          WAIT 1,ECB=ECB            wait for the last i/o\n          CLI  ECBCC,ECBNORM         normal completion ?\n          BNE  Eioerr                 no, i/o error\n\nw_return  LM   r0,rf,save1\n          BR   re\n\n          LTORG ,\n          DROP ,\n\n*/* -------------------------------------------------------------------\n*   Subroutine to issue messages\n* ------------------------------------------------------------------ */\n          USING msgr,r9\n          USING work,rd\n          USING work24,rb\n          USING main,rc\n          USING (main+4095,mainend),ra\nmsgr      STM  r0,rf,save2\n          LR   r9,rf\nprt       USING IHADCB,prtdcb\n          TM   prt.DCBOFLGS,DCBOFOPN\n          BO   mr_opened            continue if message file is opened\n\n          LR   r2,r1                save reg 1\n          TM   flags,noprint        test if no print file\n          BO   mr_ret                return if not\n          MVC  prtdcb,m_prtdcb      copy the model print dcb\n          MVC  prtdcbe,m_prtdcbe    copy model print dcbe\n          LA   r1,prtdcbe           set dcbe address\n          ST   r1,prt.DCBDCBE        in the dcb\n          OI   flags,noprint        presume no print\n          DEVTYPE prt.DCBDDNAM,dw   issue devtype for the ddname\n          LTR  rf,rf                test devtype return code\n          BNZ  mr_ret                return if some error\n          L    r1,=A(mr_oxit)       get address of the open exit\n          LA   rf,mr_oxitl          get open exit length\n          BCTR rf,0                 decrement\n          EX   rf,*+4               copy the open exit\n          MVC  openxit(0),0(r1)     *** executed ***\n          LA   r1,openxit           get open exit addr\n          ST   r1,exlst             set in exit list\n          MVI  exlst,x'85'          set exit type\n          LA   r1,exlst             point to exit list\n          STCM r1,7,prt.DCBEXLSA    set exlst addr in the dcb\n          MVC  openl,m_openl        copy model open list\n          OPEN (prtdcb,OUTPUT),MODE=31,MF=(E,openl)\n          TM   prt.DCBOFLGS,DCBOFOPN did the file open ?\n          BNO  mr_ret                 no, return\n          NI   flags,255-noprint       else turn off `noprt' bit\n          LR   r1,r2                restore reg 1\n\nmr_opened LM   r4,r5,0(r1)          pattern addr, length\n\n          BCTR r5,0\n          LA   r3,8(,r1)            first parameter\n          LA   r6,msg\n          MVI  msg,C' '             init msg to blanks\n          MVC  msg+1(L'msg-1),msg\n\nmr_loop   LTR  r5,r5\n          BM   mr_exit\n          LA   r1,1(r4,r5)\n          SLR  r2,r2\n          EX   r5,mr_trt1\n          SR   r1,r4                length scanned\n          BNP  mr_skip1\n          LR   rf,r1\n          BCTR rf,0\n          EX   rf,mr_mvc1           copy literal text\n          AR   r6,r1\nmr_skip1  AR   r4,r1\n          SR   r5,r1\n          BM   mr_exit\n          BP   mr_skip2\n\n          MVC  0(1,r6),0(r4)        string ends in special char\n          LA   r6,1(,r6)\n          B    mr_exit\n\nmr_skip2  B    *(r2)                br on special char type\n          B    mr_pct               '%'\n          B    mr_bs                '\\'\n\nmr_pct    CLI  1(r4),C's'\n          BE   mr_pct_s\n          CLI  1(r4),C'x'\n          BE   mr_pct_x\n          CLI  1(r4),C'd'\n          BE   mr_pct_d\n          MVC  0(1,r6),0(r4)        treat '%' as any other char\n          LA   r6,1(,r6)\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_loop\nmr_pct_s  L    r7,0(,r3)            load string ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%s'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  mr_pct_s3\n          LR   r2,r7                source len = 0, find end of string\nmr_pct_s1 CLI  0(r2),C' '\n          BNH  mr_pct_s2\n          LA   r2,1(,r2)\n          B    mr_pct_s1\nmr_pct_s2 SR   r2,r7\n          BNP  mr_loop\nmr_pct_s3 LR   rf,r2                copy source string to the msg\n          BCTR rf,0\n          EX   rf,mr_mvc2\n          LTR  r1,r1\n          BNZ  mr_pct_s5\n          AR   r6,r2                truncate trailing spaces if\nmr_pct_s4 BCTR r6,0                  target len is 0\n          CLI  0(r6),C' '\n          BNH  mr_pct_s4\n          LA   r6,1(,r6)\n          B    mr_loop\nmr_pct_s5 CR   r1,r2\n          BH   mr_pct_s6\n          AR   r6,r1                truncate the string\n          B    mr_loop\nmr_pct_s6 AR   r6,r2                pad string with trailing blanks\n          SR   r1,r2\nmr_pct_s7 MVI  0(r6),C' '\n          LA   r6,1(,r6)\n          BCT  r1,mr_pct_s7\n          B    mr_loop\n\nmr_pct_x  L    r7,0(,r3)            load hex ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%x'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          EX   r2,mr_pct_x_unpk\n          TR   dw,mr_hextab\n          LTR  r1,r1\n          BNZ  mr_pct_x1\n          LA   r1,8                 determine default target len\n          CLC  =C'00',dw\n          BNE  mr_pct_x1\n          LA   r1,6\n          CLC  =C'0000',dw\n          BNE  mr_pct_x1\n          LA   r1,4\n          CLC  =C'000000',dw\n          BNE  mr_pct_x1\n          LA   r1,2\nmr_pct_x1 LA   r7,dw+8              copy the hex string to the msg\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_pct_d  L    r7,0(,r3)            load decimal ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%d'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          LA   rf,4\n          SR   rf,r2\n          LA   re,15\n          SRL  re,0(rf)\n          EX   re,mr_pct_d_icm\n          CVD  rf,dw\n          MVC  dw2(16),=X'40202020202020202020202020202120'\n          ED   dw2(16),dw\n          LTR  r1,r1\n          BNZ  mr_pct_d2\n          LA   rf,dw2+16            default length -\nmr_pct_d1 BCTR rf,0                  truncate leading spaces\n          CLI  0(rf),C' '\n          BH   mr_pct_d1\n          LA   r1,dw2+15\n          SR   r1,rf\nmr_pct_d2 LA   r7,dw2+16\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_bs     MVC  0(1,r6),1(r4)        copy char following '\\'\n          LA   r6,1(,r6)\n          LA   r4,2(,r4)\n          SH   r5,=Y(2)\n          B    mr_loop\n\nmr_exit   LA   r1,msg\n          SR   r6,r1                calculate msg length\n          BNP  mr_ret\n          TM   prt.DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   *+8\n          LA   r6,1(,r6)            increment for carriage control\n\n          TM   prt.DCBRECFM,DCBRECU\n          BO   mr_u\n          TM   prt.DCBRECFM,DCBRECF\n          BO   mr_f\n          TM   prt.DCBRECFM,DCBRECV\n          BO   mr_v\n\nmr_u      CH   r6,prt.DCBBLKSI\n          BNH  *+8\n          LH   r6,prt.DCBBLKSI\n          STH  r6,prt.DCBLRECL\n          PUT  prtdcb\n          TM   prt.DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_u1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   prt.DCBRECFM,DCBRECCA\n          BO   mr_u1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_u1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_f      CH   r6,prt.DCBLRECL\n          BNH  *+8\n          LH   r6,prt.DCBLRECL\n          PUT  prtdcb\n          TM   prt.DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_f1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   prt.DCBRECFM,DCBRECCA\n          BO   mr_f1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_f1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_v      LA   r6,4(,r6)\n          LH   r1,prt.DCBBLKSI\n          SH   r1,=Y(4)\n          CR   r6,r1\n          BNH  *+6\n          LR   r6,r1\n          STH  r6,prt.DCBLRECL\n          PUT  prtdcb\n          STH  r6,0(,r1)\n          XC   2(2,r1),2(r1)\n          LA   r1,4(,r1)\n          SH   r6,=Y(4)\n          TM   prt.DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_v1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   prt.DCBRECFM,DCBRECCA\n          BO   mr_v1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_v1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_ret    LM   r0,rf,save2\n          BR   re\n\n*/* -------------------------------------------------------------------\n* message subroutine to get operand lengths\n* ------------------------------------------------------------------ */\n\nmr_op     SLR  r1,r1\n          SLR  r2,r2\nmr_op1    LTR  r5,r5                first number is target length\n          BMR  re\n          CLI  0(r4),C'0'\n          BL   mr_op2\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r1,=Y(10)\n          AR   r1,rf\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_op1\nmr_op2    CLI  0(r4),C':'          second number follows a ':'\n          BNER re\nmr_op3    LA   r4,1(,r4)           second number is source length\n          SH   r5,=Y(1)\n          BMR  re\n          CLI  0(r4),C'0'\n          BLR  re\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r2,=Y(10)\n          AR   r2,rf\n          B    mr_op3\n\n*/* ---------------------------------------------------------------- */\n\nmr_mvc1   MVC  0(0,r6),0(r4)\nmr_trt1   TRT  0(0,r4),mr_tab1\nmr_mvc2   MVC  0(0,r6),0(r7)\nmr_mvc3   MVC  0(0,r1),msg\nmr_pct_x_unpk  UNPK dw(9),0(0,r7)\nmr_pct_d_icm   ICM rf,0,0(r7)\nmr_tab1   DC   XL256'0'\n          ORG  mr_tab1+C'%'\n          DC   AL1(4)\n          ORG  mr_tab1+C'\\'\n          DC   AL1(8)\n          ORG  mr_tab1+256\nmr_hextab EQU  *-240\n          DC   C'0123456789abcdef'\n          LTORG ,\n         #MSG  TYPE=GEN           messages\n          DROP ,\n\n*/* -------------------------------------------------------------------\n*   message open exit - relocated to 24 bit storage\n* ------------------------------------------------------------------ */\n\n         USING mr_oxit,rf\n         USING IHADCB,R1\nmr_oxit  CLI   DCBRECFM,0          any record format ?\n         BNE   *+8                  jumps if yes\n         MVI   DCBRECFM,DCBRECV+DCBRECBR else set to `vb'\n\n         SLR   r0,r0               get a zero\n         CH    r0,DCBLRECL         any lrecl\n         BNE   *+10                 jumps if yes\n         MVC   DCBLRECL,=Y(125)      copy default lrecl\n\n         CH    r0,DCBBLKSI         any blksize\n         BNE   *+10                 jumps if yes\n         MVC   DCBBLKSI,=Y(16384)    copy default blksize  CZV70\n\n         TM    DCBRECFM,DCBRECU    test record type\n         BO    mr_oxitu             undefined\n         TM    DCBRECFM,DCBRECV    test record type\n         BO    mr_oxitv             variable\n         TM    DCBRECFM,DCBRECF    test record type\n         BO    mr_oxitf             fixed\n         B     mr_oxit0            unknown, return\n\nmr_oxitu MVC   DCBLRECL,DCBBLKSI   undefined, set lrecl from blksize\n         B     mr_oxit0            return\n\nmr_oxitv LH    r3,DCBBLKSI         variable, load blksize\n         LA    r0,4                calculate maximum\n         SR    r3,r0                lrecl\n         CH    r3,DCBLRECL         check against lrecl\n         BNL   mr_oxit0             return if not too high\n         STH   r3,DCBLRECL           else reset to max\n         B     mr_oxit0            return\n\nmr_oxitf LH    r3,DCBBLKSI         fixed, load blksize\n         SLR   r2,r2               clear for divide\n         LH    r0,DCBLRECL         load lrecl\n         DR    r2,r0               divide lrecl into blksize\n         LTR   r2,r2               test if any remainder\n         BZ    mr_oxit0            return if not\n         MH    r3,DCBLRECL         calculate new blksize\n         STH   r3,DCBBLKSI         set new blksize\n\nmr_oxit0 BR    re\n         LTORG ,\nmr_oxitl EQU   *-mr_oxit\n         DROP  ,\n\n*/* -------------------------------------------------------------------\n*   workareas\n* ------------------------------------------------------------------ */\nwork     DSECT ,\nworkid   DS    0CL4                     identifier\nsave     DS    18F                      standard save area\nsave1    DS    16F                      save area for read/write\nsave2    DS    16F                      save area for subroutines\nresult   DS    F                        result (return) value\nflags    DS    X                        flag bits\nucbpin   EQU   X'80'                    offline dasd ucb pinned\ncaptucb  EQU   X'40'                    offline dasd ucb captured\ndebadded EQU   X'20'                    offline dasd ucb deb added\nnotready EQU   X'10'                    offline ucb `not ready' bit\nnoprint  EQU   X'01'                    print ddname not present\nunit     DS    H                        offline unit address\nbpt      DS    F                        cckd file blocks per track\nheads    DS    F                        cckd heads per cylinder\ntrklen   DS    F                        cckd track length\nutrklen  DS    F                        unit track length\ncomplen  DS    F                        compression length\ndevtype  DS    H                        cckd device type\nnuml1tab DS    F                        number l1tab entries\nlasttrk  DS    F                        last track\nlastcyl  DS    F                        last cylinder\ncyls     DS    F                        cylinders to write\ntracks   DS    F                        tracks to write\ntrack    DS    F                        tracks being written\ntrk10pct DS    F                        tracks per status message\ntrkstat  DS    F                        write status msg at this trk\nhandle   DS    F                        persistent c handle\nprevcchh DS    F                        previous cchh written\ncurcchh  DS    F                        current cchh being written\nwaitecb  DS    A                        address of ecb to wait on\niobswtch DS    F                        iob flip/flop indicator\nretcd    DS    F                        return code\nrsncd    DS    F                        reason code\nucbaddr  DS    A                        ucb address\ncucbaddr DS    A                        captured ucb address\ndebaddr  DS    A                        deb address\nbufs     DS    0A                       i/o area address\nbuf1     DS    A\nbuf2     DS    A\nbuf3     DS    A\nbuf4     DS    A\nptoken   DS    D                        ucb pin token\ndevta    DS    D                        devtype area\nctime    DS    D                        current date/time\ndtime    DS    CL20                     date/time display area\nlastblk  DS    F               last cckd 16384 block read  CZV70\nttr      DS    F                        ttr for cckd block\ndw       DS    D                        double word work areas\ndw2      DS    D\ndw3      DS    D\ndw4      DS    D\nsysut1e  DS    XL(l_sysut1e)            cckd file dcbe\nprtdcbe  DS    XL(l_prtdcbe)            print dcbe\npl       DS    32F                      general parameter list\nopenl    DS    XL(l_openl)              open parameter list\ndevhdr   DS    0XL(CKDDASD_DEVHDR_SIZE) device header\ncdevhdr  DS    XL(CCKDDASD_DEVHDR_SIZE) compressed device header\nl1tab    DS    A                        l1tab address\nl2tab    DS    XL(CCKD_L2TAB_SIZE)      l2tab\nmsg      DS    CL256                    message\ntempbuf  DS    XL16384          temp buffer for cckd read  CZV70\nworkl    EQU   *-work\n\nwork24    DSECT ,                  24-bit work area\nwork24id  DS    CL4                identifier\nzeros     DS    XL16               24-bit zeroes\nunitdcb   DS    XL(l_unitdcb)      offline dasd dcb\nsysut1    DS    XL(l_sysut1)       sysut1 dcb\n          READ  ut1decb,SF,MF=L    sysut1 decb\nprtdcb    DS    XL(l_prtdcb)       sysprint dcb\nexlst     DS    F                  dcb exit list\nsnsidarea DS    XL20               device snsid info\nsnsarea   DS    XL32               device sense\nrdcarea   DS    XL64               device characteristics\nsnssarea  DS    XL40               device snss info\necb1      DS    F                  output ecb 1\necb2      DS    F                  output ecb 2\niob1      DS    XL40               output iob 1\niob2      DS    XL40               output iob 2\nlrparm1   DS    XL16               locate record parameter area 1\nlrparm2   DS    XL16               locate record parameter area 2\ndxarea    DS    XL16               define extent area\nopenxit   DS    XL256              relocated message open exit\nidaw1     DS    255A               idaws 1\nidaw2     DS    255A               idaws 2\nccws      DS    258D               channel program 1\nccwl      EQU   *-ccws             channel program length\nccw2      DS    258D               channel program 2\nwork24l   EQU   *-work24\n\nRDCinfo  DSECT ,                  read device characteristics info\nRDCsdt   DS    XL2                storage director type\nRDCsdmi  DS    X                  storage director model information\nRDCdevt  DS    XL2                device type\nRDCdevm  DS    X                  device model\nRDCdasdf DS    XL4                device & storage director facilities\nRDCclass DS    X                  device class code\nRDCtype  DS    X                  device type code\nRDCprime DS    XL2                number of primary cylinders\nRDCheads DS    XL2                tracks per cylinde\nRDCsctrs DS    X                  number of sectors\nRDCtrkln DS    XL3                total track length (usable)\nRDChar0  DS    XL2                length of ha and r0\nRDCtccf  DS    X                  track capacity calculation formula\nRDCfctrs DS    XL5                track capacity calculation factors\nRDCacyl  DS    XL2                address of first alternate cylinder\nRDCacyln DS    XL2                number of alternate tracks\nRDCdcyl  DS    XL2                address of first diagnostic cylinder\nRDCdcyln DS    XL2                number of diagnostic tracks\nRDCscyl  DS    XL2                address of first device support cyl\nRDCscyln DS    XL2                number of device support tracks\nRDCmdrid DS    X                  mdr record id\nRDCobrid DS    X                  obr record id\nRDCsdtc  DS    X                  storage director type code\nRDCrtspl DS    X                  read trackset parameter length\nRDCmaxr0 DS    XL2                maximum record zero data length\n         DS    X                  (reserved)\nRDCtss   DS    X                  track set size\nRDCatccf DS    X                  additional track capacity calc. factr\nRDCrps   DS    XL2                rps sector calculation factors\n         DS    XL3                (reserved)\nRDCgdff  DS    X                  generic device/cu functions/features\n         DS    X                  (reserved -- zeroes)\nRDCrduc  DS    X                  real control unit code\nRDCrdc   DS    X                  real device code\n         DS    XL6                (reserved)\nRDCinfol EQU   *-RDCinfo\n\nLRparm   DSECT ,                  locate record paramete\nLRop     DS    X                  operation byte\nLRocount EQU   B'00000000'        orient count\nLRohome  EQU   B'01000000'        orient home\nLRodata  EQU   B'10000000'        orient data\nLRoindex EQU   B'11000000'        orient index\nLRorient EQU   X'00'              orient\nLRwrite  EQU   X'01'              write data\nLRfwrite EQU   X'03'              format write\nLRread   EQU   X'06'              read data\nLRwt     EQU   X'0b'              write track\nLRrt     EQU   X'0c'              read tracks\nLRrd     EQU   X'16'              read\nLRaux    DS    X                  auxiliary byte\nLRusetlf EQU   B'10000000'        transfer length factor specified\nLRrcccw  EQU   B'00000001'        a read count ccw is suffixed\n         DS    X\nLRcount  DS    X                  count parameter\nLRseek   DS    0XL4               seek addr\nLRseekcc DS    XL2\nLRseekhh DS    XL2\nLRsearch DS    0XL5               search arg\nLRsrchcc DS    XL2\nLRsrchhh DS    XL2\nLRsrchr  DS    X\nLRsector DS    X\nLRtlf    DS    XL2                transfer length factor\nLRparml  EQU   *-LRparm\n\nCKDDASD_DEVHDR   DSECT ,\ndevhdr_devid     DS    CL8\ndevhdr_heads     DS    F\ndevhdr_trksize   DS    F\ndevhdr_devtype   DS    X\ndevhdr_fileseq   DS    X\ndevhdr_highcyl   DS    H\n                 DS    XL492\nCKDDASD_DEVHDR_SIZE    EQU *-CKDDASD_DEVHDR\n\nCKDDASD_TRKHDR   DSECT ,\ntrkhdr_bin       DS    X\ntrkhdr_cyl       DS    XL2\ntrkhdr_head      DS    XL2\nCKDDASD_TRKHDR_SIZE    EQU *-CKDDASD_TRKHDR\n\nCCKDDASD_DEVHDR  DSECT   ,\ncdevhdr_vrm      DS      XL3\ncdevhdr_options  DS      X\ncdevhdr_numl1tab DS      F\ncdevhdr_numl2tab DS      F\ncdevhdr_size     DS      F\ncdevhdr_used     DS      F\ncdevhdr_free     DS      F\ncdevhdr_free_total    DS F\ncdevhdr_free_largest  DS F\ncdevhdr_free_number   DS F\ncdevhdr_free_imbed    DS F\ncdevhdr_cyls     DS      F\n                 DS      X\ncdevhdr_compress DS      X\ncdevhdr_compress_parm DS H\n                 DS      XL464\nCCKDDASD_DEVHDR_SIZE EQU *-CCKDDASD_DEVHDR\n\nCCKD_VERSION     EQU   0\nCCKD_RELEASE     EQU   2\nCCKD_MODLVL      EQU   1\n\nCCKD_NOFUDGE     EQU   1\nCCKD_BIGENDIAN   EQU   2\nCCKD_OPENED      EQU   128\n\nCCKD_COMPRESS_NONE  EQU 0\nCCKD_COMPRESS_ZLIB  EQU 1\nCCKD_COMPRESS_BZIP2 EQU 2\nCCKD_COMPRESS_MAX   EQU CCKD_COMPRESS_BZIP2\n\nCCKD_L1TAB_POS      EQU CKDDASD_DEVHDR_SIZE+CCKDDASD_DEVHDR_SIZE\nCCKD_L1ENT_SIZE     EQU 4\nCCKD_NULLTRK_SIZE   EQU 37\n\nCCKD_L2ENT       DSECT   ,\nl2ent_pos        DS      F\nl2ent_len        DS      H\nl2ent_size       DS      H\nCCKD_L2ENT_SIZE  EQU     *-CCKD_L2ENT\nCCKD_L2TAB_SIZE  EQU     256*CCKD_L2ENT_SIZE\n\n*/* -------------------------------------------------------------------\n*   dsects\n* ------------------------------------------------------------------ */\n         PRINT NOGEN\n         DCBD  DSORG=PS\n         IHADCBE ,\nUCBDSECT DSECT ,\n         IEFUCBOB ,\n         IEZDEB ,\nDEBLENGTH EQU  (DEBBASND-DEBAVT)+(DEBDASDE-DEBDASD)+DEBXLEN\n         IEZIOB ,\n         IHAECB ,\n         IOSDCCW ,\n         CVT   DSECT=YES\n         IHAPSA ,\n         IKJTCB ,\nSTAR     TRKCALC MF=D\n\n*/* -------------------------------------------------------------------\n*   equates\n* ------------------------------------------------------------------ */\nSK    EQU X'07'\nSNSID EQU X'e4'\nSNS   EQU X'04'\nRDC   EQU X'64'\nSNSS  EQU X'54'\nRT    EQU X'de'\nDX    EQU X'63'\nLR    EQU X'47'\nWR0   EQU X'15'\nWCKD  EQU X'1d'\nTIC   EQU X'08'\n\nr0 EQU 0\nr1 EQU 1\nr2 EQU 2\nr3 EQU 3\nr4 EQU 4\nr5 EQU 5\nr6 EQU 6\nr7 EQU 7\nr8 EQU 8\nr9 EQU 9\nra EQU 10\nrb EQU 11\nrc EQU 12\nrd EQU 13\nre EQU 14\nrf EQU 15\n\n         END ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT541/CBT.V500.FILE541.PDS/X$CCKDA.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT541/CBT.V500.FILE541.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}