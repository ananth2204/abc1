{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012350000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2762942, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE565.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2762942, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2762942, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE565.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00+\\x03'", "DS1TRBAL": "b'\\xc6\\x06'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x042\\x00\\x03\\x045\\x00\\x01\\x00,'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x16\\x1f\\x01\\x02\\x16\\x1f\\t(\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-10T00:00:00", "modifydate": "2002-06-10T09:28:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 448    FILE:  565\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT448.FILE565\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    8000    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 25,754 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/10/02    09:28:40    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x02\\x14O\\x01\\x02\\x14O\\t#\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-24T00:00:00", "modifydate": "2002-05-24T09:23:31", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: Documentation of File 565\nDate: Fri, 24 May 2002 08:28:11 -0400\nFrom: \"Thornton, Dick\" <rthornton@trigon.com>\nTo: xgob1 <sbgolob@attglobal.net>, xgob2 <sbgolob@aol.com>\n\nHi Sam,\n\nHere's the last installment on documentation for my files unless\nI happen across something else by accident in the next 38 days or\nso.  It is an XMIT of a PDS that contains:\n\n    CCLASS ---> should be $$README in the CCLASS library within\n             FILE 565\n    CLASS  ---> should be $$README in the CLASS library within\n             FILE 565\n    DUMPCLAS ----> should be the $$README in the DUMPCLAS library\n             within FILE 565\n    FILE565 ----> should be the $$README in FILE 565 itself. It\n             is actually the sum of the above three.\n    TEXTBOOK ---> should be TEXTBOOK in the DUMPCLAS library\n             within FILE 565. It is an XMIT of a\n             DSORG=PS,RECFM=FBA,LRECL=133 dataset containing the\n             class textbook.\n\nThanks again for your good work,\nDick\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x02\\x14O\\x01\\x02\\x14O\\x07T\\x00\\x9a\\x00\\x9a\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-24T00:00:00", "modifydate": "2002-05-24T07:54:17", "lines": 154, "newlines": 154, "modlines": 0, "user": "BC0THOR"}, "text": "************************************************************************\n* File 565 is a set of three libraries containing classes on the c     *\n* programming language, COBOL, and Abend-Aid dump reading. The classes *\n* are not intended for self study, although it may be possible for a   *\n* person to learn from the materials without an instructor. The classes*\n* are intended for use by the presenter of the class, who would review *\n* and modify the materials for his environment and needs.              *\n*                                                                      *\n* All members in each of the three libraries are described below.      *\n************************************************************************\n************************************************************************\n* CCLASS: the C Language class library. This class is intended for use *\n*         with a C Language compiler/editor/development environment on *\n*         a PC, and specifically uses the Borland Turbo-C product,     *\n*         which was inexpensive, powerful, and easy to use when the    *\n*         course was developed.                                        *\n************************************************************************\nBINSRCH   Sample C subroutine for searching a sequential file binarily.\nCIRCLE    Sample C main program to compute diameter, area given radius.\nCONGRATS  Text for a congratulations letter to students on completion.\nCONTENTS  Text for the table of contents for the course.\nCRITIQUE  Text for a course critique to be filled out by students.\nDUMPHEX   Sample C main program to print a file in hex and character.\nGENLDAT2  Sample C subroutine to perform date reformatting.\nHANDBOOK  Text of the primary handout for the students for the course.\nHELLO2    Sample C main program: the traditional \"Hello World!\" program.\nKEYVALU   Sample C program to display the hex value for a keypress.\nLOADSTRG  Sample C main program to read/display strings.\nMENU10    Sample C main program to display a menu and obtain a request.\nSKELETON  Sample C program that can be used to develop a new program.\nSTRUCT9   Sample C code to demonstrate use os structures and unions.\nSYLLABUS  Text for a course syllabus.\nTEMPCONV  Sample C main program to convert temperatures F to/from C.\nVER2EDIT  Text describing Turbo-C Version 2 Editor commands.\nVER2LSN1  Text for first lesson using Turbo-C version 2 on the PC.\nVER3EDIT  Text describing Turbo-C++ Version 3 Editor commands.\nVER3LSN1  Text for the first lesson using Turbo-C version 3 on the PC.\n\n************************************************************************\n* CLASS: the COBOL Language class library. This is an incomplete course*\n*        that may be of use to someone wishing to develop an elementary*\n*        class in COBOL. I had a request to develop the class from a   *\n*        non-programmer who had to deal with COBOL programmers, and    *\n*        hoped to be able to communicate better with them after the    *\n*        class. I presented an initial class in commonly used computer *\n*        and programming terminology, however work schedules interfered*\n*        and the students were never able to wangle time to take the   *\n*        follow-on, so I never finished the course.                    *\n************************************************************************\n$$README  Text: this file\nCALC100C  Sample tax calculation program in COBOL.\nCALC100X  Execution JCL for the CALC100C program.\nCHAR100C  Sample COBOL program to get number from user, display edited.\nCHAR200C  Sample COBOL program gets name from user, displays converted.\nCHAR300C  Sample COBOL program gets ZIP-code, displays with hyphen.\nCOBLKEDJ  JCL to compile and linkedit a COBOL program.\nDATE100C  Sample COBOL program to calculate elapsed days between dates.\nDATE200C  Sample COBOL program to display age, given birth date.\nDELDEFNJ  JCL using IDCAMS to delete, define a VSAM dataset.\nIND1000C  Sample COBOL program showing VSAM READs and WRITEs.\nIND2000C  Sample COBOL program shows Add/Change/Delete for a VSAM file.\nIND4000C  Sample COBOL program reads, displays record from VSAM file.\nJOBCARDJ  JCL job card sample.\nLISTMODC  Sample COBOL program reads source program, prints statistics.\nPAYMNTC   Sample COBOL program creates, maintains VSAM payroll file.\nPAYRECF   Sample COBOL COPY book describing a record.\nREL4000C  Sample COBOL program processes a relative record VSAM file.\nRPT1000C  Sample COBOL report program.\nRPT2000C  Sample COBOL report program.\nRPT3000C  Sample COBOL report program.\nRPT5000C  Sample COBOL report program.\nSEQ1000C  Sample COBOL program using sequential and VSAM datasets.\nSEQ2000C  Sample COBOL program using sequential and VSAM datasets.\nSKELETNC  Sample COBOL program that can be used to develop new programs.\nSRT1000C  Sample COBOL program showing code for an internal sort.\n************************************************************************\n* DUMPREAD: A class in reading Abend-Aid dumps for COBOL programers.   *\n*           It is fairly non-technical, and takes two days to present  *\n*           as given here. The materials I hand out are a textbook, a  *\n*           set of program compile and linkedit listings, and 10-12    *\n*           dumps. The $instruc member describes how to prepare the    *\n*           handout materials.                                         *\n*          .The first day, I teach from the textbook using a blackboard*\n*           and at the end of the day I go through the first dump to   *\n*           model the process of locating the abending instruction, and*\n*           then locating and evaluating every data field in the       *\n*           failing instruction.                                       *\n*          .The second day I have each student (or a pair of students  *\n*           if there are more than 10) go through a dump. They first   *\n*           locate the failing instruction, then find each data field  *\n*           referenced in the instruction, and evaluate the data found.*\n*          .The dumps are primarily S0C7, and all use the same main    *\n*           COBOL program. Each dump abends on a different instruction,*\n*           however, and most of the failing instructions contain an   *\n*           indexed data field and a subscripted data field, giving 4  *\n*           fields to be found and evaluated for validity. Data types  *\n*           vary among data fields to give practice in validating data.*\n*           I have each student locate all four data elements, even if *\n*           it is obvious that the first or second caused the failure. *\n************************************************************************\n$INSTRUC  Text file describing how to create the handout materials.\nABNDCOB   COBOL main program in which most of the abends occur.\nCOBABEND  A COBOL subroutine called by the main program.\nCOPYDUMP  A COBOL program that is run when creating the handout stuff.\nCOPYNUM   A COBOL program that is run when creating the handout stuff.\nCRSDESC   Text file that describes the course objectives.\nCVTDATE   An assembler language subroutine called by COBABEND.\nJOB001    JCL to create the handout materials: Job #1\nJOB002A   JCL to create dump 10: Job #2\nJOB002B   JCL to create dump 11: Job #3\nJOB0021   JCL to create dump 1: Job #4\nJOB0022   JCL to create dump 2: Job #5\nJOB0023   JCL to create dump 3: Job #6\nJOB0024   JCL to create dump 4: Job #7\nJOB0025   JCL to create dump 5: Job #8\nJOB0026   JCL to create dump 6: Job #9\nJOB0027   JCL to create dump 7: Job #10\nJOB0028   JCL to create dump 8: Job #11\nJOB0029   JCL to create dump 9: Job #12\n. A manual process is required between 0029 and JOB003. See $INSTRUC.\nJOB003    JCL to create the handouts: Job #13\nJOB004    JCL to create the handouts: Job #14\nPROCNUM   A COBOL subroutine called by the ABDUMP program.\nSYSADD    An assembler subroutine called by the ABDUMP program.\nSYSAD2    An assembler subroutine called by the ABDUMP program.\nSYSDATE   A COBOL subroutine called by the ABDUMP program.\nTABLE     A table of data used by JOB002A-JOB0029 in creating dumps.\nTABLE0A   A table of data used by JOB002A\nTABLE0B   A table of data used by JOB002B\nTABLE01   A table of data used by JOB0021\nTABLE02   A table of data used by JOB0022\nTABLE03   A table of data used by JOB0023\nTABLE04   A table of data used by JOB0024\nTABLE05   A table of data used by JOB0025\nTABLE06   A table of data used by JOB0026\nTABLE07   A table of data used by JOB0027\nTABLE08   A table of data used by JOB0028\nTABLE09   A table of data used by JOB0029\nTABLE1    ? No longer used\nTABLE2    ? No longer used\nTABLE3    ? No longer used\nTABLE4    ? No longer used\nTEXTBOOK  The textbook for the course in XMIT unload format.\nTRANFILA  A transaction file used by JOB002A\nTRANFILB  A transaction file used by JOB002B\nTRANFIL1  A transaction file used by JOB0021\nTRANFIL2  A transaction file used by JOB0022\nTRANFIL3  A transaction file used by JOB0023\nTRANFIL4  A transaction file used by JOB0024\nTRANFIL5  A transaction file used by JOB0025\nTRANFIL6  A transaction file used by JOB0026\nTRANFIL7  A transaction file used by JOB0027\nTRANFIL8  A transaction file used by JOB0028\nTRANFIL9  A transaction file used by JOB0029\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x06\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f W\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T20:57:06", "lines": 31, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*   CREATE MESSAGES AND PANELS DATASETS FOR USE WITH THESE EXECS\n//*\n//*\n//LOA1 EXEC PGM=PDSLOAD            /* FROM FILE 093 - LOAD ON FILE 035\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT444.FILE565(CCLASS)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FILE565.CCLASS,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//   SPACE=(TRK,(45,15,44),RLSE),UNIT=SYSALLDA,VOL=SER=DATA04\n//*\n//LOA2 EXEC PGM=PDSLOAD            /* FROM FILE 093 - LOAD ON FILE 035\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT444.FILE565(COBCLASS)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FILE565.COBCLASS,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//   SPACE=(TRK,(45,30,44),RLSE),UNIT=SYSALLDA,VOL=SER=DATA04\n//*\n//LOA3 EXEC PGM=PDSLOAD            /* FROM FILE 093 - LOAD ON FILE 035\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT444.FILE565(DUMPREAD)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FILE565.DUMPREAD,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//   SPACE=(TRK,(45,30,44),RLSE),UNIT=SYSALLDA,VOL=SER=DATA04\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE565": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00@\\x01\\x01\\x02_\\x01\\x02\\x10O\\x08\\x12\\x00!\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-04-14T08:12:40", "lines": 33, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 565 is from Dick Thornton, who is the author of the       *   FILE 565\n//*           DISASSEMBLER program on File 217, and his new         *   FILE 565\n//*           DISASSEMBLER program on File 234.  This is his        *   FILE 565\n//*           collection of classes he has either given, or was     *   FILE 565\n//*           planning to give.                                     *   FILE 565\n//*                                                                 *   FILE 565\n//*           There are 3 members in this file, which are           *   FILE 565\n//*           IEBUPDTE-unloaded pds'es, and if you use the          *   FILE 565\n//*           PDSLOAD command instead of IEBUPDTE, you will         *   FILE 565\n//*           also get ISPF statistics in each pds.  See member     *   FILE 565\n//*           $PDSLOAD for a job to produce the 3 pds'es.           *   FILE 565\n//*                                                                 *   FILE 565\n//*           You will have to re-sort the members of these         *   FILE 565\n//*           pds'es for yourself, because the members get          *   FILE 565\n//*           listed in EBCDIC collating sequence, of course,       *   FILE 565\n//*           and they may not have been presented to the           *   FILE 565\n//*           students in this order.  Please examine the doc       *   FILE 565\n//*           which accompanies each course, carefully.             *   FILE 565\n//*                                                                 *   FILE 565\n//*           The members are:                                      *   FILE 565\n//*                                                                 *   FILE 565\n//*           CCLASS   - This is a 5-week class in C Language       *   FILE 565\n//*                      which Dick has given.                      *   FILE 565\n//*                                                                 *   FILE 565\n//*           COBCLASS - This is a COBOL class.                     *   FILE 565\n//*                                                                 *   FILE 565\n//*           DUMPREAD - This is Dick's dump reading class.         *   FILE 565\n//*                                                                 *   FILE 565\n//*           emails:  (check to see which are relevant):           *   FILE 565\n//*               dickthor@hotmail.com                              *   FILE 565\n//*               cthornton@swva.net                                *   FILE 565\n//*               rthornton@trigon.com                              *   FILE 565\n//*                                                                 *   FILE 565\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CCLASS": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x14O\\x01\\x02\\x14O\\tP \\xb1 \\xb1\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-24T00:00:00", "modifydate": "2002-05-24T09:50:00", "lines": 8369, "newlines": 8369, "modlines": 0, "user": "BC0THOR"}, "text": "./ ADD NAME=$$README 0100-02143-02143-1556-00028-00028-00000-BC0THOR\n************************************************************************\n* CCLASS: the C Language class library. This class is intended for use *\n*         with a C Language compiler/editor/development environment on *\n*         a PC, and specifically uses the Borland Turbo-C product,     *\n*         which was inexpensive, powerful, and easy to use when the    *\n*         course was developed.                                        *\n************************************************************************\n$$readme  This file.\nBINSRCH   Sample C subroutine for searching a sequential file binarily.\nCIRCLE    Sample C main program to compute diameter, area given radius.\nCONGRATS  Text for a congratulations letter to students on completion.\nCONTENTS  Text for the table of contents for the course.\nCRITIQUE  Text for a course critique to be filled out by students.\nDUMPHEX   Sample C main program to print a file in hex and character.\nGENLDAT2  Sample C subroutine to perform date reformatting.\nHANDBOOK  Text of the primary handout for the students for the course.\nHELLO2    Sample C main program: the traditional \"Hello World!\" program.\nKEYVALU   Sample C program to display the hex value for a keypress.\nLOADSTRG  Sample C main program to read/display strings.\nMENU10    Sample C main program to display a menu and obtain a request.\nSKELETON  Sample C program that can be used to develop a new program.\nSTRUCT9   Sample C code to demonstrate use os structures and unions.\nSYLLABUS  Text for a course syllabus.\nTEMPCONV  Sample C main program to convert temperatures F to/from C.\nVER2EDIT  Text describing Turbo-C Version 2 Editor commands.\nVER2LSN1  Text for first lesson using Turbo-C version 2 on the PC.\nVER3EDIT  Text describing Turbo-C++ Version 3 Editor commands.\nVER3LSN1  Text for the first lesson using Turbo-C version 3 on the PC.\n./ ADD NAME=BINSRCH  0100-02144-02144-0950-00076-00076-00000-BC0THOR\n/****************************************************************/\n/*          binsrch.c, a binary search function                 */\n/* caller supplies:                                             */\n/*    (1) a pointer to the FILE to be searched (must be OPEN).  */\n/*    (2) a pointer to the key argument used for the search.    */\n/*    (3) length of each record in the file (int).              */\n/*    (4) length of the key in the records (int).               */\n/*    (5) relative position of the key in the record (int, 0+). */\n/*    (6) a pointer to the callers record return area.          */\n/* function returns:                                            */\n/*    (1) an int whose value is -1 if the record is found or    */\n/*        0 of it is not found.                                 */\n/*    (2) the record found, if the search was successful.       */\n/*                                                              */\n/* Author R Thornton, October, 1993                             */\n/****************************************************************/\n#include <stdio.h>\n\nint binsrch(FILE *rf,\n\t\t\tchar *arg_key,\n\t\t\tint recdleng,\n\t\t\tint keyleng,\n\t\t\tint keyloc,\n\t\t\tchar *record)\n{\n\n  long int file_size;             /* file length in bytes */\n  long int max_slots;             /* number records in file */\n  long int curr_slot  = 0;        /* current record slot number */\n  long int curr_offset = 0;       /* current offset increment */\n  long int file_offset;           /* computed file offset */\n  int      compare = 0;           /* current compare indicator */\n  int      result = 0;            /* result indicator */\n\n  result = 0;                     /* set up for not found */\n  if(fseek(rf,0,SEEK_END) != 0)   /* set file pointer to end of file */\n\treturn(result);               /* terminate if error */\n  if((file_size = ftell(rf)) == -1L) /* get file size in bytes */\n\treturn(result);               /* terminate if error */\n  max_slots = file_size / recdleng;  /* compute number records in file */\n  curr_slot = 0;                 /* set initial slot number */\n  curr_offset = max_slots - 1;   /* set initial offset increment */\n  compare = -1;                  /* set compare for low */\n  while(curr_offset != 1) {\n\tcurr_offset ++;              /* add 1 to insure rounding high */\n\tcurr_offset /= 2;            /* offset / 2 (rounded high */\n\tif(compare < 0) {            /* if last key read was low */\n\t  curr_slot += curr_offset;     /* add offset increment */\n\t  if(curr_slot >= max_slots) {  /* if result past end of file */\n\t\tcompare = 1;                   /* set compare to high */\n\t\tcontinue;                      /* and continue to while */\n\t  }\n\t  else ;\n\t}\n\telse {                       /* if last key read was high */\n\t  curr_slot -= curr_offset;     /* subtract offset increment */\n\t  if(curr_slot < 0) {           /* if result prior to 1st slot */\n\t\tcompare = -1;                  /* set compare to low */\n\t\tcontinue;                      /* and continue to while */\n\t  }\n\t  else ;\n\t}\n\tfile_offset = curr_slot * recdleng;   /* compute file offset */\n\tif((fseek(rf,file_offset,0)) != 0)    /* position in file */\n\t  break;                              /* terminate if error */\n\tfread(record,recdleng,1,rf);          /* read the record */\n\tif((compare=memcmp(record+keyloc,arg_key,keyleng)) == 0) { /* found? */\n\t  result = -1;\n\t  break;                                          /* yes, quit */\n\t}\n  }\n  return(result);\n}\n\n\n\n./ ADD NAME=CIRCLE   0100-02144-02144-0950-00083-00083-00000-BC0THOR\n          /******************************************************************/\n          /*                         circle.c                               */\n          /* circle.c: displays area, circumference, and volume of a sphere */\n          /* when given the radius.                                         */\n          /******************************************************************/\n\n          #include <stdio.h>               /* include standard I/O header   */\n          #include <math.h>                /* include math header for float */\n\n          #define PI 3.14159               /* define PI = 3.14159           */\n\n          float area, circumference, volume; /* define global float vrbls   */\n\n          /******************************************************************/\n          /* function prototypes                                            */\n          /******************************************************************/\n          float calculate_area(double radius);\n          float calculate_circumference(double diameter);\n          float calculate_volume(double radius);\n\n          /******************************************************************/\n          /* main function: initial entry point to the program. The radius  */\n          /* of the circle of interest is expected to be typed on the       */\n          /* command line following the program name.                       */\n          /******************************************************************/\n\n          main(int argc, char *argv[]) {   /* function header for main      */\n\n            double radius;                 /* define radius                 */\n\n            if(argc != 2) {                /* got two command line strings? */\n              printf(\"Usage is: circle radius\\n\"); /* no, explain how to use*/\n              exit(1);                     /* and terminate                 */\n            }\n            radius = atof(argv[1]);        /* convert 2nd string to double  */\n\n            area = calculate_area(radius); /* compute circle area           */\n            circumference = calculate_circumference(2 * radius); /* circumf.*/\n            volume = calculate_volume(radius); /* and volume                */\n\n            printf(\"The radius given is %f\\n\",radius); /* display radius    */\n            printf(\"Area is %f\\n\",area);               /* area,             */\n            printf(\"Circumference is %f\\n\",circumference); /* circumference,*/\n            printf(\"Volume is %f\\n\",volume);           /* and volume        */\n          }                                /* end of main function          */\n\n          /******************************************************************/\n          /* calculate_area computes the area of a circle, given the radius */\n          /* and returns it to the caller as a float.                       */\n          /******************************************************************/\n          float calculate_area(double rad) { /* calculate_area function head*/\n\n            float answer;                  /* define answer field           */\n\n            answer = PI * rad * rad;       /* compute area of circle        */\n\n            return(answer);                /* return area of circle         */\n          }                                /* end calculate_area function   */\n\n          /******************************************************************/\n          /* calculate_circumference computes the circumference of a circle,*/\n          /* given the diameter.                                            */\n          /******************************************************************/\n\n          float calculate_circumference(double diameter) { /* function hdr  */\n\n            return(PI * diameter);         /* compute, return circumference */\n          }                                /* end of calcualte_circumference*/\n\n          /******************************************************************/\n          /* calculate_volume computes the volume of a sphere, given its    */\n          /* radius.                                                        */\n          /******************************************************************/\n\n          float calculate_volume(double r) { /* calculate_volume header     */\n\n            float rcubed, vol;             /* define rcubed, vol            */\n\n            rcubed = r * r * r;            /* compute rcubed                */\n            vol = (4 * rcubed) / 3;        /* compute volume of sphere      */\n            return(vol);                   /* return computed volume        */\n          }                                /* end of calcualte_volume func  */\n\n./ ADD NAME=CONGRATS 0100-02144-02144-0950-00060-00060-00000-BC0THOR\n                                   August 22nd, 1994\n\n         Congratulations on completing the class in Elementary C Programming.\n         This represents a significant amount of effort and time, and can be\n         valuable to you if you follow up with practice in writing programs in\n         C. Without practice, you will quickly forget the language and how to\n         use the Integrated Development Environment to build and test\n         programs.\n\n         A working knowledge of the C language will help you in many ways, as\n         it is the underlying code in many Client-Server applications. The\n         UNIX operating system is itself written in C, and the command line\n         language, as well as Shell Script programming is heavily C oriented.\n         Blue Cross already has application systems in place in the telephone\n         Voice Response system and in a number of areas in HCS. In a vendor\n         supplied OCR Scanner system Richard Womble deals with the vendor has\n         agreed to supply C source code we can maintain, saving $6,000 per\n         year in maintenance fees. There are also a number of IBM RS6000\n         systems either installed or planned for Blue Cross. These systems are\n         supplied with an operating system called AIX, which is the IBM\n         version of UNIX. Lin Merritt is currently writing C programs to\n         extract performance data which will be fed into his capacity planning\n         processes. Other opportunities will be available for those who\n         maintain their skills in C programming, I am sure.\n\n         While higher level languages such as Power Builder will likely be\n         preferred for new applications at Blue Cross, an understanding of C\n         can help you understand the concepts and syntax used by other Client-\n         Server components.\n\n         Please try to write several small programs soon to help solidify your\n         knowledge. In the appendices to your class handouts you will find\n         information on cursor positioning for the IBM PC, information on\n         processing special keys (such as function keys) when reading from the\n         keyboard on an IBM PC, and three programs written in C that offer\n         examples of C programming. One program is the binary search routine\n         now being used with the VRU system. The second program is a file dump\n         that produces output in hex and character format. The third program\n         is a skeleton you can use in building your own programs. It contains\n         input, output, and print files and some common supporting functions.\n         You might consider enhancing these programs as an exercise. A sub-\n         program (function) called GENLDAT2 is available for anyone who may be\n         interested. This is functionally similar to the mainframe subroutine\n         of the same name. Also, a library of small C source programs is\n         available. If you'd like a copy, send me a blank 3.5\" disk at mail\n         drop 02A.\n\n         When you find the time, I would appreciate the course critique\n         returned to me at mail drop 02A.\n\n         Thanks very much,\n\n\n\n\n\n\n\n         Dick Thornton\n         Instructor\n./ ADD NAME=CONTENTS 0100-02144-02144-0950-00114-00114-00000-BC0THOR\n         ******************************************************************\n         *                    Elementary C Programming                    *\n         ******************************************************************\n                                  TABLE OF CONTENTS\n\n         Lesson 1  - Installation, Customizing, and Checkout: ......... 1\n                     Installing the compiler and integrated\n                     development environment, customizing the\n                     compiler and IDE, running under OS/2, create,\n                     compile, and execute a short program.\n\n         Lesson 2  - Basic Structure of C Programs: Syntax,   ......... 3\n                     comments, program organization, functions,\n                     the main() function, function Prototypes,\n                     preprocessor directives, escape sequences.\n\n         Lesson 3  - Variables, Operators, and printf: Lifetime ....... 7\n                     and visibility, definition syntax, types of\n                     variables, naming variables, initializing\n                     variables, arithmetic operators, increment\n                     and decrement operators, printf() syntax and\n                     use.\n\n         Lesson 4  - Include, Define, and Functions: Syntax, .......... 12\n                     parameters, prototype, returning values,\n                     passing data (by reference, by value),\n                     external variables.\n\n         Lesson 5  - Arrays, Strings, and Constants: Defining and ..... 18\n                     initializing arrays, strings, and constants.\n\n         Lesson 6  - Relational and Logical Operators and ............. 21\n                     Decisions: Relational operators, logical\n                     operators, if statements, and logical\n                     expressions.\n\n         Lesson 7  - Loops and Keyboard Input Functions For loops, .... 25\n                     while loops, do while loops, break and\n                     continue statements, getc, getch, getche and\n                     gets functions.\n\n         Lesson 8  - Pointers: Referring to elements of arrays, ....... 32\n                     sending to functions, pointers to pointers.\n\n         Lesson 9  - Structures and Unions and the sizeof keyword: .... 37\n                     Structures, unions, unions of structures,\n                     structures including unions, use of sizeof.\n\n         Lesson 10 - Switch statements and the conditional operator. .. 42\n\n         Lesson 11 - Advanced Variables: Pointer notation for ......... 45\n                     structures, enumerated data type, typedef,\n                     type conversion and casting.\n\n\n                                         i\n\n         ******************************************************************\n         *                    Elementary C Programming                    *\n         ******************************************************************\n                                  TABLE OF CONTENTS\n\n         Lesson 12 - Files and I/O Part 1: Types of disk I/O, ......... 50\n                     standard (stream) I/O, binary mode and text\n                     mode.\n\n         Lesson 13 - Files and I/O Part 2: Record I/O, random ......... 55\n                     access, using handles.\n\n         Lesson 14 - Miscellaneous topics: The goto statement, ........ 60\n                     labels, models, separate compilation,\n                     projects, bitwise operators, operator\n                     precedence,\n\n         APPNDX A  - Turbo C Editor Navigation and Hot Key Guide ...... 65\n\n         APPNDX B  - Data Definitions - COBOL vs C .................... 66\n\n         APPNDX C  - Cross-Reference to Turbo C Library Functions ..... 69\n\n         APPNDX D  - Key Codes for the IBM PC ......................... 80\n\n         APPNDX E  - ANSI.SYS Screen/Cursor Control ................... 83\n\n         APPNDX F  - ANSI.SYS and Attribute Control ................... 84\n\n         APPNDX G  - Keywords and Operators in C ...................... 85\n\n         hello2.c  - Version of \"Hello, World!\" program ............... 87\n\n         circle.c  - Circle/sphere calculations program ............... 89\n\n         tempconv.c- Temperature conversion program ................... 91\n\n         loadstrg.c- Program to store strings in memory ............... 93\n\n         struct9.c - Structure usage program .......................... 94\n\n         menu10.c  - Menu program ..................................... 96\n\n         dumphex.c - File dump program ................................ 99\n\n         skeleton.c- Skeleton program for development ................. 103\n\n         binsrch.c - Binary search of a file function ................. 111\n\n         genldat2.c- Generalized date function ........................ 113\n\n         keyvalu.c - Program to display key values .................... 124\n\n\n\n                                         ii\n\n./ ADD NAME=CRITIQUE 0100-02144-02144-0950-00253-00253-00000-BC0THOR\n                                    Course Critique\n\n         Course Name: Elementary C Programming\n\n         Instructor:  Dick Thornton\n\n         Dates: July 18th, 1994 through August 19th, 1994\n\n         Please help me make this a better class by taking a few minutes to\n         provide thoughtful answers to the following questions. If you wish,\n         feel free to make any comments concerning the class that you feel\n         would improve it.\n\n         I. Course schedule. What schedule would best fit your personal work\n            habits?\n            (1) As it was presented (9:00-11:30 Monday, Wednesday, and Friday\n                for 5 weeks.\n            (2) 8:30 - 12:00 two days per week for 5 weeks.\n            (3) 8:30 - 4:30 one day per week for 5 weeks.\n            (4) 8:30 - 4:30 five consecutive days.\n            (5) 8:30 - 4:30 two days per week for 2.5 weeks.\n            (6) Other (specify):\n\n         II. Do you feel the 5-week class duration was:\n            (1) Too long. Should have been:\n            (2) Too short. Should have been:\n            (3) About the right duration.\n\n         III. Regarding the length of each session:\n            (1) Sessions too long. Should have been:\n            (2) Sessions were too short. Should have been:\n            (3) Sessions were about the right length.\n\n          IV. Number of breaks per session:\n            (1) There were too many breaks. Should have been about:\n            (2) There were too few breaks. Should have been about:\n            (3) Two breaks per session was about right\n\n           V. Length of breaks:\n            (1) Too long, should be more like:\n            (2) Too short. Should be about:\n            (3) 10 minute breaks were about right.\n\n          VI. How well do you understand the following C topics?\n              Use the scale like this:\n\n                 0. What??? Did we go over something like that?\n                 1. I remember seeing it, but probably couldn't understand it\n                    in someone else's program, and certainly couldn't use it.\n                 2. Somewhat comfortable with it. Could understand it if found\n                    in someone else's program, but would not want to try to\n                    code my own.\n                 3. I understand it well, would have no trouble understanding\n                    it in someone else's program. I could code it with help\n                    from a book or the IDE's help functions.\n                 4. I understand it very well if seen in another program and\n                    feel I could probably code it reasonably well in most\n                    cases without help.\n                 5. No problem!\n\n               (   ) Use of the Turbo C IDE editor\n               (   ) Use of the HELP and Language Help features of the IDE\n               (   ) Use of the Turbo C IDE in compiling programs\n               (   ) Use of the Turbo C IDE in running programs\n               (   ) Use of the Turbo C IDE in testing programs\n               (   ) Basic C language syntax: forming names, ending\n                     statements, writing simple C instructions.\n               (   ) Organization of C programs: where to put variable\n                     definitions, procedure statements, functions, requirement\n                     for the main function, etc.\n               (   ) Function prototypes: what they are, how to write them.\n               (   ) Turbo C library functions: how to find which to use, how\n                     to use them using course materials and the IDE.\n               (   ) #include statements: what they do, how to code them, how\n                     to find the required header for a library function.\n               (   ) #define statements: what they do, how to code them\n               (   ) Escape sequences: what they are and how to code them in\n                     printf for newline, carriage-return, etc.\n               (   ) Simple variables: how to define variables of the built-in\n                     types, such as char, int, long, float, double.\n               (   ) Simple variables: how to provide initial values when\n                     defining them.\n               (   ) Arithmetic operators (+, -, *, /, %) what they mean and\n                     how to use them in simple expressions.\n               (   ) Using the assignment operator (=) to move data into a\n                     variable.\n               (   ) Increment and decrement operators (++ and --): what they\n                     mean and how to use them as either prefix or postfix.\n               (   ) The printf function: how to use it to display text and\n                     formatted variables.\n               (   ) Function calls: how to code them.\n               (   ) Functions: how to code your own.\n               (   ) Values returned by library functions: using the IDE to\n                     find what is returned.\n               (   ) Returning a value from your own function: how to write\n                     the code to return the value.\n               (   ) How to code a function call to obtain the value returned\n                     by the function.\n               (   ) Passing addresses to a function so that it can modify\n                     data in the calling function: coding the function itself\n                     and the call to it.\n               (   ) Defining global variables: where and how.\n                 0. What???\n                 1. Very weak understanding, no way I could code it.\n                 2. Some understanding, but couldn't code my own.\n                 3. Understand fairly well, could code with help.\n                 4. Understand very well, probably code it without help.\n                 5. No problem!\n\n               (   ) References to global variables in a separately\n                     compiled program. (Not the program in which they are\n                     defined.)\n               (   ) Defining an array of simple data types, such as int,\n                     float, etc.\n               (   ) Specifying initial values for an array of simple\n                     variables.\n               (   ) Defining and giving an initial value for a string.\n               (   ) Using the standard library functions for string\n                     manipulation.\n               (   ) Simple conditional (if) statements using ordinary\n                     relational operators (==, <, <=, >, >=, !=).\n               (   ) Using boolean if statements such as: if(switch) ...\n               (   ) Understanding the negation operator and how it affects\n                     boolean expressions such as: if(!switch) ...\n               (   ) Compound relational conditions using the && and ||\n                     operators.\n               (   ) Using an if statement that performs more than one\n                     instruction.\n               (   ) Using an else statement.\n               (   ) Using nested if - else constructs.\n               (   ) Using a for loop statement: coding the parameters and\n                     body of the loop.\n               (   ) Using a while loop statement: coding the parameters and\n                     body of the loop.\n               (   ) Using a do ... while statement: coding the parameters and\n                     body of the loop.\n               (   ) Using a never-ending while statement.\n               (   ) Breaking out of a loop using the break instruction.\n               (   ) Terminating processing in a given iteration of a\n                     loop and returning to the top to begin the next iteration\n                     using the continue keyword.\n               (   ) Reading characters from the keyboard using the getch and\n                     getche library functions.\n               (   ) Reading strings from the keyboard using the gets\n                     library function.\n               (   ) Defining pointers.\n               (   ) Using a pointer to access an array.\n               (   ) Using an array name as a pointer.\n               (   ) Defining a structure: what a structure is, syntax for\n                     declaring and defining one.\n               (   ) Using the dot operator to refer to fields within a\n                     structure or union.\n               (   ) Declaring a structure and later using the declaration to\n                     define one.\n               (   ) Specifying initial values for the fields in a structure\n                     when it is defined.\n               (   ) Defining an array of structures.\n               (   ) Using brackets and the dot operator to refer to a field\n                     within an element of an array of structures.\n               (   ) Specifying initial values for the fields in the members\n                     of an array of structures.\n                 0. What???\n                 1. Very weak understanding, no way I could code it.\n                 2. Some understanding, but couldn't code my own.\n                 3. Understand fairly well, could code with help.\n                 4. Understand very well, probably code it without help.\n                 5. No problem!\n\n               (   ) Declaring a union: what a union is, syntax for declaring\n                     and defining one.\n               (   ) Declaring a structure containing another structure.\n               (   ) Declaring a union containing several structures.\n               (   ) Using the sizeof keyword to get the size of a structure\n                     of union.\n               (   ) Using a switch statement: specifying the switch variable\n                     and the body of the switch.\n               (   ) Specifying cases within the body of the switch statement.\n               (   ) Understanding how cases work in a switch statement.\n               (   ) Using the default keyword in a switch statement.\n               (   ) Using the break statement is a switch statement.\n               (   ) Using the conditional operator (max = (i<j) ? i : j;)\n               (   ) Using pointer notation for structures.\n               (   ) Using the enumerated data type for condition name\n                     processing: syntax for definition.\n               (   ) Specifying enum condition names in if statements.\n               (   ) Specifying a value for an enum data item using condition\n                     names.\n               (   ) Using the typedef statement to create a new data type.\n               (   ) Using a data type created by a typedef when defining a\n                     data field of the new type.\n               (   ) Understanding how C converts between different data types\n                     included in an expression.\n               (   ) Using type casting (coercion) to force C to convert a\n                     variable to another form before use.\n               (   ) Understand the difference between binary mode and test\n                     mode in file processing.\n               (   ) Understand the difference between standard (stream) I/O\n                     and system level I/O.\n               (   ) Use the FILE type to create a pointer for use by stream\n                     I/O functions.\n               (   ) Using the fopen library function to open stream files.\n               (   ) Using the getc library function to read a stream file in\n                     character-by-character input mode.\n               (   ) Using the fread library function to read stream files in\n                     record mode input.\n               (   ) Using the putc library function to write stream files\n                     character-by-character.\n               (   ) Using the fprintf function for formatted output to a\n                     stream file.\n               (   ) Using the fwrite library function to write records to\n                     stream files.\n               (   ) Using fclose to close stream files.\n               (   ) Using the return value from getc and fread to detect end\n                     of file.\n               (   ) Using the perror library function to print an error\n                     message when an I/O error occurs.\n               (   ) Using the ferror library function to determine when an\n                     error has occurred during file I/O.\n               (   ) Using the exit keyword to terminate a program.\n                 0. What???\n                 1. Very weak understanding, no way I could code it.\n                 2. Some understanding, but couldn't code my own.\n                 3. Understand fairly well, could code with help.\n                 4. Understand very well, probably code it without help.\n                 5. No problem!\n\n               (   ) Using the fseek library function to position to a\n                     specific location within a file for random I/O.\n               (   ) Defining the handle for use by system level I/O.\n               (   ) Understanding you cannot mix library functions between\n                     stream I/O and system level I/O.\n               (   ) Knowing how to tell that a given library function is for\n                     use with stream I/O or system level I/O.\n               (   ) Using library functions open, read, write, and close in\n                     system level I/O for files.\n               (   ) Using the goto statement and defining labels for its use.\n               (   ) Understanding Turbo C models for use with PC's.\n               (   ) Understanding how to separately compile sub-programs.\n               (   ) Understanding how to use the project function in the IDE\n                     to link several separately compiled programs to build an\n                     executable module.\n               (   ) Using bitwise operators (&, |, ^, <<, >>, ~).\n               (   ) Understanding operator precedence and associativity and\n                     how it affects expression interpretation in C.\n\n\n         VII. Would you like to see a follow-on class given in C++ which would\n              Object-Orientation concepts such as objects, inheritance,\n              polymorphism and overloading?\n\n\n        VIII. Please feel free to add any other comments or suggestions you\n              feel might make this a better class. Thank you.\n./ ADD NAME=DUMPHEX  0100-02144-02144-0950-00179-00179-00000-BC0THOR\n        /******************************************************************/\n        /*                         dumphex.c                              */\n        /* dumphex.c displays and optionally prints the content of a file */\n        /* in hex and character, 16-bytes per line. user specifies the    */\n        /* name of the file to dump on the command line.                  */\n        /******************************************************************/\n\n        #include <stdio.h>               /* include standard I/O header   */\n        #include <stdlib.h>              /* include standard lib header   */\n\n        /******************************************************************/\n        /* main function: on entry the number of command line arguments   */\n        /* is available in argc, while argv is an array of strings, which */\n        /* contains the command line arguemnts. The first command line    */\n        /* string ([0]) is always the program name.                       */\n        /******************************************************************/\n\n        void main(int argc, char *argv[]) {\n\n        /******************************************************************/\n        /*               define global work fields                        */\n        /******************************************************************/\n        char prntlin[68];                     /* print line */\n        unsigned char ch;                     /* character work field */\n        unsigned char prtsw='\\0';             /* print switch */\n        unsigned int j,l,row=0;               /* work fields */\n        int i,k;                              /* work fields */\n        unsigned long bytno=0,tot=0;          /* work fields */\n\n        /******************************************************************/\n        /*               function prototypes                              */\n        /******************************************************************/\n        void atox(unsigned char, char[], char[]);  /* function prototype */\n\n        /******************************************************************/\n        /*               FILE pointer definitions                         */\n        /******************************************************************/\n        FILE *infil,*outfil;                  /* FILE pointers */\n\n        /******************************************************************/\n        /*        end of data definitions, begin processing               */\n        /******************************************************************/\n\n        prntlin[0]='\\n';                      /* put newline in print line */\n        prntlin[67]='\\0';                     /* insure valid string */\n\n        /*******************************************************************/\n        /* If command line has two strings (1=\"dumphex\", 2=filename), open */\n        /* the input file, otherwise display the proper syntax to use and  */\n        /* terminate the program.                                          */\n        /*******************************************************************/\n\n        if(argc!=2) {\n            printf(\"\\nSYNTAX: dumphex [d:][\\path\\]filename[.ext]\");\n            exit(1);\n        }\n        if((infil=fopen(argv[1],\"rb\"))==NULL) {\n            printf(\"\\nCan't open the input file, %s\",argv[1]);\n            exit(1);\n        }\n\n        /*******************************************************************/\n        /* Ask user if the file dump is to be printed or only displayed on */\n        /* the screen. If print is requested, set the print switch and open*/\n        /* the print file and print a header line.                         */\n        /*******************************************************************/\n\n        printf(\"\\nDo you want to print the file (y/n): \");\n        while((prtsw!='y')&&(prtsw!='n'))\n            prtsw=getche();\n        if(prtsw=='n')\n            prtsw='\\0';\n        if(prtsw)\n            if((outfil=fopen(\"prn\",\"w\"))==NULL) {\n                printf(\"\\nCan't open the printer file.\");\n                exit(0);\n            }\n            else {\n                fputs(\"\\n     ***** Hex/Character Dump of: \",outfil);\n                fputs(argv[1],outfil);\n                fputs(\" *****\\n\",outfil);\n            }\n        /*******************************************************************/\n        /* Build a line of print containing the offset from the beginning  */\n        /* of the file, 8 groups of 2 hex bytes each, and the printable    */\n        /* ASCII characters for them.                                      */\n        /*******************************************************************/\n        do {\n            for(i=1;i<67;i++)        /* pre-clear the print */\n            prntlin[i]=' ';              /* line to blanks */\n            /***************************************************************/\n            /* Calculate and print the file offset in hex at left of line. */\n            /***************************************************************/\n            ch=bytno/65536;\n            atox(ch,&prntlin[1],&prntlin[2]);\n            ch=(bytno%65536)/256;\n            atox(ch,&prntlin[3],&prntlin[4]);\n            ch=bytno%256;\n            atox(ch,&prntlin[5],&prntlin[6]);\n            bytno+=16;\n            /***************************************************************/\n            /* Read characters from the file and copy them into the        */\n            /* printable character portion of the print line (positions    */\n            /* 52-67).                                                     */\n            /***************************************************************/\n            i=51;\n            while((i<67)&&(k=getc(infil))!=EOF) {\n                prntlin[i++]=k;\n                tot+=1;\n            }\n            /***************************************************************/\n            /* Convert the characters in print line positions 52-67 to hex */\n            /* (2 hex digits per character) and use the hex digits to make */\n            /* eight groups of 2-bytes (4 print positions). Single spaces  */\n            /* are placed between each group of 2 bytes with a double space*/\n            /* in the center.                                              */\n            /***************************************************************/\n            for(j=51,l=9;j<i;j++) {\n                atox(prntlin[j],&prntlin[l],&prntlin[l+1]);\n                l+=2;\n                if(l==13||l==18||l==23||l==34||l==39||l==44)\n                    l+=1;\n                if(l==28)\n                    l+=2;\n            }\n            /***************************************************************/\n            /* Scan the character area of the print line (positions 52-67) */\n            /* and replace non-printable characters with periods.          */\n            /***************************************************************/\n            for(j=51;j<i;j++)\n                if((prntlin[j]<' ')||(prntlin[j]>'z'))\n                    prntlin[j]='.';\n            /***************************************************************/\n            /* Display the line on the screen. If the print switch is on,  */\n            /* print it, too. Check to see if we are at the bottom of the  */\n            /* screen. If so, ask the user whether to continue or to quit. */\n            /***************************************************************/\n            printf(\"%s\",prntlin);\n            if(prtsw)\n                fputs(prntlin,outfil);\n            row += 1;                       /* increment row counter */\n            if(row >= 22) {                 /* if end of screen: */\n                row = 0;                        /* reset row counter */\n                printf(\"\\nEnter Q to quit or press ENTER to continue: \");\n                ch = getchar();                 /* get response */\n                if((ch == 'q') || (ch == 'Q'))\n                    exit(1);                /* quit if Q entered */\n            }\n        }\n        while(k!=EOF);                      /* end of d... while */\n\n        /*******************************************************************/\n        /* End of file to be dumped. Print totals, close files, and        */\n        /* terminate normally.                                             */\n        /*******************************************************************/\n\n        printf(\"\\n\\nTotal bytes in file = %d.\\n\",tot);\n        if(prtsw) {\n            fputs(\"\\n\\nTotal bytes in file = \",outfil);\n            itoa(tot,prntlin,10);\n            fputs(prntlin,outfil);\n            fputs(\"\\n\\n\\n\",outfil);\n            fclose(outfil);\n        }\n        fclose(infil);\n        }\n\n        /******************************************************************/\n        /* function to convert a character to two printable hex digits    */\n        /******************************************************************/\n\n        void atox(unsigned char ch,  char *hi, char *lo) {\n\n            char hextbl[]=\"0123456789ABCDEF\";\n\n            *hi=hextbl[ch/16];      /* convert high-order hex digit */\n            *lo=hextbl[ch%16];      /* convert low-order hex digit */\n        }\n\n./ ADD NAME=GENLDAT2 0100-02144-02144-0950-00524-00524-00000-BC0THOR\n          /*****************************************************************/\n          /*                         genldat2.c                            */\n          /* This function provides the caller with a table of information */\n          /* concerning a specified date. The caller places a date in one  */\n          /* of the Julian or Gregorian fields of the DATEGENL structure   */\n          /* and an indicator of the type date sent in the datyp field, and*/\n          /* invokes genldat2(), which fills in all the remaining fields in*/\n          /* the DATEGENL structure. A pointer to DATEGENL is passed to    */\n          /* this function by the caller.                                  */\n          /*****************************************************************/\n\n          #include <string.h>\n\n          struct DATEGENL {\n            enum {\n              julian_yyyyddd_sent = 'j',\n              gregorian_mmddyyyy_sent = 'g',\n              gregorian_yyyymmdd_sent = 'y'\n            } datyp;                          /* date supplied type        */\n            enum {\n              successful_conversion = ' ',\n              error_in_data_supplied = 'e',\n            } daterr;                         /* result indicator          */\n            enum {\n              Monday = '1',\n              Tuesday = '2',\n              Wednesday = '3',\n              Thursday = '4',\n              Friday = '5',\n              Saturday = '6',\n              Sunday = '7'\n            } daywk;                          /* day of week indicator     */\n            enum {\n              not_a_holiday = ' ',\n              New_Years_Day = '1',\n              Christmas_Eve = '2',\n              Good_Friday = '3',\n              Memorial_Day = '4',\n              Independence_Day = '5',\n              Labor_Day = '6',\n              Thanksgiving_Day = '7',\n              Friday_After_Thanksgiving = '8',\n              Christmas_Day = '9',\n            } holiday;                        /* holiday indicator         */\n            enum {\n              not_leap_year = '0',\n              leap_year = '1',\n            } yeartyp;                        /* year type                 */\n            char juldate[8];                     /* julian date yyyyddd    */\n            char gregmdy[9];                     /* gregorian date mmddyyyy*/\n            char gregymd[9];                     /* gregorian date yyyymmdd*/\n            char litdate[19];                    /* literal date, eg:      */\n                                                    /* May 9, 2002         */\n            char julslash[9];                    /* julian date yy/ddd     */\n            char grgslash[11];                   /* gregorian:  mm/dd/yyyy */\n            char daylit[10];                     /* literal day of week eg:*/\n                                                    /* Sunday              */\n            char monthlit[10];                   /* literal month, eg: July*/\n          };\n\n          /*****************************************************************/\n          /* yeardata contains data about this year: day of week for       */\n          /* January 1st, leap year indicator, and holiday dates. Format:  */\n          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */\n          /*   byte2: leap year indicator: 1 = leap year else 0            */\n          /*   remainder: holiday fields of 5 bytes each. Format of each:  */\n          /*          byte1: holiday type indicator (same as p->holiday)   */\n          /*          bytes 2-5: MMDD date of the holiday                  */\n          /* tblukup() locates data for this year and initializes this area*/\n          /*****************************************************************/\n          struct year_entry2 {\n            char jan1_day;\n            char leap_year_ind;\n            struct {\n              char holiday_type;\n              char holiday_mmdd[5];\n            } holiday_table[9];\n          } yeardata;\n\n          /*****************************************************************/\n          /* function prototypes                                           */\n          /*****************************************************************/\n          void genldat2(struct DATEGENL *p);\n          void julian_sent(struct DATEGENL *p);\n          void gregorian_sent(struct DATEGENL *p);\n          void datcomn(struct DATEGENL *p);\n          void tblukup(struct DATEGENL *p);\n\n\n          void genldat2(struct DATEGENL *p) {\n\n            p->daterr = ' ';                       /* clear error indicator*/\n            p->holiday = ' ';                       /* clear holiday indic */\n            if(p->datyp == julian_yyyyddd_sent) {   /* julian date sent    */\n              julian_sent(p);\n              return;\n            }\n            else\n              if((p->datyp == gregorian_mmddyyyy_sent) || /* gregorian sent*/\n                  (p->datyp == gregorian_yyyymmdd_sent)) {\n                gregorian_sent(p);\n                return;\n              }\n              else {                        /* invalid date type specified */\n                p->daterr = 'e';\n                return;\n              }\n          }                                       /* end function genldat2 */\n\n          /*****************************************************************/\n          /* The gregcvrt[] table is used in converting between julian and */\n          /* gregorian dates. It contains the day numbers corresponding to */\n          /* the first day of each month. The gregcv1 table contains leap  */\n          /* year values, while the gregcv0 table contains normal year     */\n          /* values. the appropriate values are moved to gregcvrt[] by the */\n          /* tblukup() function.                                           */\n          /*****************************************************************/\n          int gregcvrt[13];\n\n          static int gregcv0[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243,\n                                    273, 304, 334, 999};\n\n          static int gregcv1[13] = {0, 31, 60, 91, 121, 152, 182, 213, 244,\n                                    274, 305, 335, 999};\n\n          /*****************************************************************/\n          /* julian_sent(): main function to handle julian date sent       */\n          /*****************************************************************/\n          void julian_sent(struct DATEGENL *p) {\n            int i, julday;\n\n            /* ----- julian date must be 7 bytes long ---------------------*/\n            if(strlen(p->juldate) != 7) {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- century must be 19 or 20 -----------------------------*/\n            if(((p->juldate[0] == '1') && (p->juldate[1] == '9')) ||\n                ((p->juldate[0] == '2') && (p->juldate[1] == '0')))\n               ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* --- julian date must consist entirely of decimal digits --- */\n            for(i=2; i<7; i++)\n              if((p->juldate[i] < '0') || (p->juldate[i] > '9')) {\n                p->daterr = 'e';\n                return;\n            }\n\n            /* ----- move julian year to gregorian year fields ----------- */\n            for(i = 0; i < 4; i++) {\n              p->gregmdy[i+4] = p->juldate[i];  /* year to greg mdy        */\n              p->gregymd[i] = p->juldate[i];    /* year to greg ymd        */\n            }\n\n            /* ----- go get year table data ------------------------------ */\n            tblukup(p);\n\n            /* ----- julian day must be 1 - 366 -------------------------- */\n            julday = atoi(&p->juldate[4]);      /*get julian day to integer*/\n            if((julday > 0 ) && (julday < 366))\n              ;\n            else\n              if((julday == 366) && (p->yeartyp == leap_year))\n                ;\n              else {\n                p->daterr = 'e';\n                return;\n              }\n\n            /* ----- build gregorian mmdd fields ------------------------- */\n            i = 0;\n            while(gregcvrt[i] < julday)       /* look up  for month and day*/\n            i++;\n            julday -= gregcvrt[i - 1];     /* deduct days to start of month*/\n            p->gregymd[4] = (i / 10) | '0';        /* build gregorian month*/\n            p->gregymd[5] = (i % 10) | '0';\n            p->gregymd[6] = (julday / 10) | '0';  /* build greg day of mnth*/\n            p->gregymd[7] = (julday % 10) | '0';\n            memcpy(&p->gregmdy[0], &p->gregymd[4], 4);    /*copy month, day*/\n            datcomn(p);                           /* finish processing date*/\n            return;\n          }                                    /* end function julian_sent */\n\n          /*****************************************************************/\n          /* The grgvldy[] table contains the number of days in each month.*/\n          /* It is used in validating the gregorian date.                  */\n          /*****************************************************************/\n          static int grgvldy[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31,\n                                    30, 31};\n\n          /*****************************************************************/\n          /* gregorian_sent(): main function to handle gregorian date sent.*/\n          /*****************************************************************/\n          void gregorian_sent(struct DATEGENL *p) {\n\n            int i, day, mth;\n\n            /* ----- make both gregorian dates the same date ------------- */\n            if(p->datyp == gregorian_mmddyyyy_sent) {\n              memcpy(&p->gregymd[0], &p->gregmdy[4], 4); /* copy year      */\n              memcpy(&p->gregymd[4], &p->gregmdy[0], 4); /* copy mmdd      */\n              p->gregymd[8] = '\\0';\n            }\n            else {\n              memcpy(&p->gregmdy[0], &p->gregymd[4], 4); /* copy mmdd      */\n              memcpy(&p->gregmdy[4], &p->gregymd[0], 4); /* copy year      */\n              p->gregmdy[8] = '\\0';\n            }\n\n            /* ----- gregorian date must be 8 bytes long ----------------- */\n            if((strlen(p->gregmdy) == 8) && (strlen(p->gregymd) == 8))\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- century must be 19 or 20 ---------------------------- */\n            if(((p->gregmdy[4] == '1') && (p->gregmdy[5] == '9')) ||\n                  ((p->gregmdy[4] == '2') && (p->gregmdy[5] == '0')))\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- all 8 bytes must be decimal digits ------------------ */\n            for(i=0; i<8; i++)\n              if((p->gregmdy[i] < '0') || (p->gregmdy[i] > '9')) {\n                p->daterr = 'e';\n                return;\n              }\n\n            /* ----- day must be > 0 ------------------------------------- */\n            day = ((p->gregmdy[2] - '0') * 10) + (p->gregmdy[3] - '0');\n            if(day)\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- month must be 01 to 12 ------------------------------ */\n            mth = ((p->gregmdy[0] - '0') * 10) + (p->gregmdy[1] - '0');\n            if((mth) && (mth < 13))\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- perform year table lookup function ------------------ */\n            tblukup(p);\n\n            /* ----- check for valid day within the month ---------------- */\n            i = grgvldy[mth - 1];\n            if(day > i)\n            if(p->yeartyp == leap_year)\n              if(day == 29)\n                ;\n              else {\n                p->daterr = 'e';\n                return;\n              }\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- build julian date from gregorian -------------------- */\n            memcpy(&p->juldate[0], & p->gregymd[0], 4);\n            i = (gregcvrt[mth - 1]) + day;\n            p->juldate[4] = ((i / 100) + '0');\n            i %= 100;\n            p->juldate[5] = ((i / 10) + '0');\n            i %= 10;\n            p->juldate[6] = i + '0';\n            p->juldate[7] = '\\0';\n\n            /* ----- go finish date processing --------------------------- */\n            datcomn(p);\n            return;\n          }                                 /* end function gregorian_sent */\n\n          /*****************************************************************/\n          /* The julmo[] table contains the literal month names.           */\n          /*****************************************************************/\n          static char julmo[12][10] = {{\"January\"},{\"February\"},{\"March\"},\n                                       {\"April\"},{\"May\"},{\"June\"},{\"July\"},\n                                       {\"August\"},{\"September\"},{\"October\"},\n                                       {\"November\"},{\"December\"}};\n\n          /*****************************************************************/\n          /* The dwktbl[] table contains the literal day of week names.    */\n          /*****************************************************************/\n          static char dwktbl[7][10] = {{\"Monday\"},{\"Tuesday\"},{\"Wednesday\"},\n                                       {\"Thursday\"},{\"Friday\"},{\"Saturday\"},\n                                       {\"Sunday\"}};\n\n          /*****************************************************************/\n          /* datcomn(): common date processing.                            */\n          /*****************************************************************/\n          void datcomn(struct DATEGENL *p) {\n\n            int i, j;\n\n            /* ----- build the julslash date field ----------------------- */\n            memmove(&p->julslash[0], &p->juldate[0], 4);\n            p->julslash[4] = '/';\n            strcpy(&p->julslash[5], &p->juldate[4]);\n\n            /* ----- build the grgslash date field ----------------------- */\n            memmove(&p->grgslash[0], &p->gregmdy[0], 2);\n            p->grgslash[2] = '/';\n            memmove(&p->grgslash[3], &p->gregmdy[2], 2);\n            p->grgslash[5] = '/';\n            strcpy(&p->grgslash[6], &p->gregmdy[4]);\n\n            /* determine whether this date is a holiday and set indicator  */\n            for(i = 0; i < 9; i++)\n              if(!strcmp(yeardata.holiday_table[i].holiday_mmdd,&p->gregymd[4]))\n{\n                p->holiday = yeardata.holiday_table[i].holiday_type;\n                break;\n              }\n\n            /* ----- build the litdate field ----------------------------- */\n            i = ((atoi(&p->juldate[4])) + (yeardata.jan1_day - '0')) % 7;\n            if(i == 0) i = 7;\n            p->daywk = i | '0';                 /* move day of week number */\n            strcpy(p->daylit, dwktbl[i-1]);    /* move day of week literal */\n            i = (((p->gregmdy[0]) - '0') * 10) + ((p->gregmdy[1]) - '0');\n            strcpy(p->monthlit, julmo[i - 1]);          /* move month name */\n            strcpy(p->litdate, p->monthlit);                 /* month name */\n            i = 2;\n            while(p->litdate[++i]);\n            p->litdate[i++] = ' ';\n            if(p->gregmdy[2] != '0')\n              p->litdate[i++] = p->gregmdy[2];\n            p->litdate[i++] = p->gregmdy[3];                        /* day */\n            p->litdate[i++] = ',';                                /* comma */\n            p->litdate[i++] = ' ';                                /* blank */\n            memcpy(&p->litdate[i], p->gregymd, 4);                 /* year */\n            p->litdate[i + 4] = '\\0';\n          }                                        /* end function datcomn */\n\n          /*****************************************************************/\n          /* yeartbl1 contains subscript values (0-13) to yeartbl2. When   */\n          /* the next is 6 or 13, January 1st next year falls on Saturday, */\n          /* and will be observed on December 31st of this year (the       */\n          /* preceding Friday).                                            */\n          /*****************************************************************/\n          static int yeartbl1[201] = {\n                              1,2,3,4,12,0,1,2,10,5,          /* 1900-1909 */\n                              6,0,8,3,4,5,13,1,2,3,           /* 1910-1919 */\n                              11,6,0,1,9,4,5,6,7,2,           /* 1920-1929 */\n                              3,4,12,0,1,2,10,5,6,0,          /* 1930-1939 */\n                              8,3,4,5,13,1,2,3,11,6,          /* 1940-1949 */\n                              0,1,9,4,5,6,7,2,3,4,            /* 1950-1959 */\n                              12,0,1,2,10,5,6,0,8,3,          /* 1960-1969 */\n                              4,5,13,1,2,3,11,6,0,1,          /* 1970-1979 */\n                              9,4,5,6,7,2,3,4,12,0,           /* 1980-1989 */\n                              1,2,10,5,6,0,8,3,4,5,           /* 1990-1999 */\n                              13,0,1,2,10,5,6,0,8,3,          /* 2000-2009 */\n                              4,5,13,1,2,3,11,6,0,1,          /* 2010-2019 */\n                              9,4,5,6,7,2,3,4,12,0,           /* 2020-2029 */\n                              1,2,10,5,6,0,8,3,4,5,           /* 2030-2039 */\n                              13,1,2,3,11,6,0,1,9,4,          /* 2040-2049 */\n                              5,6,7,2,3,4,12,0,1,2,           /* 2050-2059 */\n                              10,5,6,0,8,3,4,5,13,1,          /* 2060-2069 */\n                              2,3,11,6,0,1,9,4,5,6,           /* 2070-2079 */\n                              7,2,3,4,12,0,1,2,10,5,          /* 2080-2089 */\n                              6,0,8,3,4,5,6,0,1,2,            /* 2090-2099 */\n                              3 };                                 /* 2100 */\n\n          /*****************************************************************/\n          /* yeartbl2 contains data about the year: day of week for January*/\n          /* 1st, leap year indicator, and holiday dates. Format is:       */\n          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */\n          /*   byte2: leap year indicator: 1 = leap year else 0            */\n          /*   bytes 3-42: holiday fields of 5 bytes each. Format of each: */\n          /*          byte1: holiday type indicator (same as p->holiday)   */\n          /*          bytes 2-5: MMDD date of the holiday                  */\n          /* entry 7 type is pre-set for Good Friday, and entry 8 is       */\n          /* pre-set for a possible New Year's Day observed when Jan1 of   */\n          /* next year is Saturday                                         */\n          /*****************************************************************/\n          static struct year_entry2 yeartbl2[14]={\n            {'6','0',{{'1',\"0102\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n                      {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'0','0',{{'1',\"0101\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n                      {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'1','0',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n                      {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'2','0',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n                      {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'3','0',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n                      {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'4','0',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n                      {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'5','0',{{' ',\"0000\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n                      {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'6','1',{{'1',\"0102\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n                      {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'0','1',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n                      {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'1','1',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n                      {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'2','1',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n                      {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'3','1',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n                      {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'4','1',{{'1',\"0101\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n                      {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'5','1',{{'1',\"0000\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n                      {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}}\n          };\n\n          /*****************************************************************/\n          /* The goodfri[] table contains the dates of Good Friday for each*/\n          /* year from 1900 to 2099. An index to the table can be computed */\n          /* as: year - 1900.                                              */\n          /*****************************************************************/\n          static struct {\n            char good_friday_mmdd[5];     /* month-day date of Good Friday */\n          } goodfri[200] = {\n               {\"0413\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0401\"},  /* 1900-1904 */\n               {\"0421\"},{\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},  /* 1905-1909 */\n               {\"0325\"},{\"0414\"},{\"0405\"},{\"0321\"},{\"0410\"},  /* 1910-1914 */\n               {\"0402\"},{\"0421\"},{\"0406\"},{\"0329\"},{\"0418\"},  /* 1915-1919 */\n               {\"0402\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0418\"},  /* 1920-1924 */\n               {\"0410\"},{\"0402\"},{\"0415\"},{\"0406\"},{\"0329\"},  /* 1925-1929 */\n               {\"0418\"},{\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},  /* 1930-1934 */\n               {\"0419\"},{\"0410\"},{\"0326\"},{\"0415\"},{\"0407\"},  /* 1935-1939 */\n               {\"0322\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0407\"},  /* 1940-1944 */\n               {\"0330\"},{\"0419\"},{\"0404\"},{\"0326\"},{\"0415\"},  /* 1945-1949 */\n               {\"0407\"},{\"0323\"},{\"0411\"},{\"0403\"},{\"0416\"},  /* 1950-1954 */\n               {\"0408\"},{\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},  /* 1955-1959 */\n               {\"0415\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0327\"},  /* 1960-1964 */\n               {\"0416\"},{\"0408\"},{\"0324\"},{\"0412\"},{\"0404\"},  /* 1965-1969 */\n               {\"0327\"},{\"0409\"},{\"0331\"},{\"0420\"},{\"0412\"},  /* 1970-1974 */\n               {\"0328\"},{\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},  /* 1975-1979 */\n               {\"0404\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0420\"},  /* 1980-1984 */\n               {\"0405\"},{\"0328\"},{\"0417\"},{\"0401\"},{\"0324\"},  /* 1985-1989 */\n               {\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},{\"0401\"},  /* 1990-1994 */\n               {\"0414\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0402\"},  /* 1995-1999 */\n               {\"0421\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},  /* 2000-2004 */\n               {\"0325\"},{\"0414\"},{\"0406\"},{\"0321\"},{\"0410\"},  /* 2005-2009 */\n               {\"0402\"},{\"0422\"},{\"0406\"},{\"0329\"},{\"0418\"},  /* 2010-2014 */\n               {\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0419\"},  /* 2015-2019 */\n               {\"0410\"},{\"0402\"},{\"0415\"},{\"0407\"},{\"0329\"},  /* 2020-2024 */\n               {\"0418\"},{\"0403\"},{\"0326\"},{\"0414\"},{\"0330\"},  /* 2025-2029 */\n               {\"0419\"},{\"0411\"},{\"0326\"},{\"0415\"},{\"0407\"},  /* 2030-2034 */\n               {\"0323\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0408\"},  /* 2035-2039 */\n               {\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},{\"0415\"},  /* 2040-2044 */\n               {\"0407\"},{\"0323\"},{\"0412\"},{\"0403\"},{\"0416\"},  /* 2045-2049 */\n               {\"0408\"},{\"0331\"},{\"0419\"},{\"0404\"},{\"0327\"},  /* 2050-2054 */\n               {\"0416\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0328\"},  /* 2055-2059 */\n               {\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},{\"0404\"},  /* 2060-2064 */\n               {\"0327\"},{\"0409\"},{\"0401\"},{\"0420\"},{\"0412\"},  /* 2065-2069 */\n               {\"0328\"},{\"0417\"},{\"0408\"},{\"0324\"},{\"0413\"},  /* 2070-2074 */\n               {\"0405\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0421\"},  /* 2075-2079 */\n               {\"0405\"},{\"0328\"},{\"0417\"},{\"0402\"},{\"0324\"},  /* 2080-2084 */\n               {\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},{\"0401\"},  /* 2085-2089 */\n               {\"0414\"},{\"0406\"},{\"0328\"},{\"0410\"},{\"0402\"},  /* 2090-2094 */\n               {\"0422\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0410\"}   /* 2095-2099 */\n            };\n\n          /*****************************************************************/\n          /* tblukup(): performs year table lookups using the gregmdy year.*/\n          /* The data entry found is moved to the yeardata area.           */\n          /*****************************************************************/\n          void tblukup(struct DATEGENL *p) {\n            int i, j, *q;\n            char char_year[5];\n\n            /* ----- compute the year table index = year - 1900 ---------- */\n            memcpy(char_year, p->gregymd, 4);\n            char_year[4] = '\\0';\n            i = atoi(char_year);                    /* convert year to int */\n            i -= 1900;                      /* deduct 1900 for index value */\n            j = yeartbl1[i];             /* get index to second year table */\n\n            /* - move entry for the specified year to the yeardata field - */\n            yeardata = yeartbl2[j];              /* copy data for the year */\n\n            /* - move the Good Friday date to the yeardata holiday table - */\n            strcpy(yeardata.holiday_table[7].holiday_mmdd,\n                                               goodfri[i].good_friday_mmdd);\n\n            /* if next year begins on Saturday, make December 31 a holiday */\n            if((yeartbl1[i+1] == 6) || (yeartbl1[i+1] == 13)) {\n              yeardata.holiday_table[8].holiday_type = '1';} /* 12/31 NewYr*/\n\n            /* ----- set year type in dategenl structure ----------------- */\n            p->yeartyp = yeardata.leap_year_ind; /* year type to dategenl  */\n\n            /* ----- set correct values in the gregcvrt() table ---------- */\n            q = gregcv0;\n            if(p->yeartyp == leap_year)\n            q = gregcv1;\n            for(i = 0; i < 13; i++)\n              gregcvrt[i] = *q++;\n            }                                      /* end function tblukup */\n\n./ ADD NAME=HANDBOOK 0100-02144-02144-0950-05773-05773-00000-BC0THOR\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON01*\n          *----------------------------------------------------------------*\n                       Installation, Customizing, and Checkout\n\n         I. Install Turbo C++ Version 1.3 Second Edition (DOS)\n\n            A. Basic installation on hard drive (must have 6MB free)\n               1. Put Disk 1 in the A drive\n               2. Type A:INSTALL and press ENTER\n               3. Press ENTER to continue with installation\n               4. Press ENTER for Source Drive is A\n               5. Arrow down to Start Installation, press ENTER\n               6. Remove/Insert disks as requested until all 5 are done\n               7. At end press ENTER until the C:> DOS prompt appears\n\n            B. Make source and output directories\n               1. Type following lines (ENTER after each):\n                         CD C:\\TC\n                         MD CSOURCE\n                         MD OUTPUT\n\n            C. Set up DOS System files using a file editor. Be sure to use\n               a simple ASCII editor such as EDLIN or DOS's EDIT, not one\n               like WordPerfect which adds control information to the file.\n               1.Put FILES=20 (or more) in CONFIG.SYS\n               2.Add ;C:\\TC\\BIN;C:\\TC\\OUTPUT to path in AUTOEXEC.BAT\n               3.Create C:\\TC.BAT containing the following lines:\n                         CD C:\\TC\\CSOURCE\n                         C:\\TC\\BIN\\TC\n\n            D. Customize the Turbo C++ environment\n               1. At the C:\\> prompt, type TC. This should start Turbo C++\n                  which will display a window with information about Turbo C++\n                  and with OK at the bottom. Press ENTER to continue.\n               2. Activate the Options pull-down menu by typing Alt-O or\n                  F10/O.\n               3. Type D to activate the Directories window.\n               4. Tab to the Output Directories window and type C:\\TC\\OUTPUT\n                  then press ENTER.\n               5. Activate the Options pull-down menu again using Alt-O or\n                  F10/O then type S for the save window, then press ENTER to\n                  save the updated options.\n\n        II. Test the Turbo C++ Version 1.3 Second Edition Installation\n\n            A. Re-Boot the system to bring in the updated system files.\n\n            B. At the C:\\> prompt, type TC. This should start Turbo C++\n               which will display a window with information about Turbo C++\n               and with OK at the bottom. Press ENTER to continue.\n\n            C. Create, compile, and execute a short program.\n               1. Start a Turbo C++ session by typing TC and pressing ENTER.\n               2. Open a file by typing Alt-F/O or just F3\n               3. The name window will contain *.C initially. Ignore this\n                  and type HELLO.C which will replace the *.C, then press\n                  ENTER.\n               4. An EDIT window will open with a double line around it,\n                  showing it is the \"active\" window. HELLO.C will appear\n                  centered at the top.\n               5. Type the following lines (ENTER after each line):\n                        /* hello.c --- Hello, World! */\n                        #include <stdio.h>\n                        main() {\n                          printf(\"Hello, World!\\n\");\n                        }\n               6. Save this source program by pressing F2.\n               7. Compile and link (Make) the program by pressing F9.\n               8. A window should appear saying \"Success Press Any Key\".\n               9. Press any key.\n              10. The edit screen reappears with a MESSAGE screen at the\n                  bottom. The double line is on the MESSAGE screen, which is\n                  now the \"active\" screen. The messages include a warning\n                  concerning function returning a value. Note that the arrow\n                  keys move you around in the MESSAGE window, NOT the edit\n                  window. This message is only a warning and the program will\n                  run o.k. as-is, however we will fix the warning later.\n              11. Switch to the EDIT window by pressing F6\n              12. To run the program, press Alt-R/R or Ctrl-F9. The program\n                  will execute. Since it writes to the screen, your screen\n                  will blink momentarily.\n              13. To view the output of the program press Alt-F5. You should\n                  see Hello, World! as the last line displayed. To return to\n                  Turbo C++, press any key.\n\n            D. Exercise some other IDE functions\n               1. Insert the word void before the main function header:\n                        void main() {\n               2. Compile and link (Make) the program by pressing F9.\n               3. A window should appear saying \"Success Press Any Key\".\n               4. Press any key.\n               5. The edit screen should reappear as the active window with\n                  a double line around it.\n               6. Move the cursor to one of the letters in the word printf\n                  and press Ctrl-F1 for HELP concerning this function.\n               7. Scroll down the HELP window using the arrow keys and/or\n                  the PgUp and PgDn keys. Note the amount of information\n                  given for the printf function.\n               8. Press Alt-X to exit from Turbo C++.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON02*\n          *----------------------------------------------------------------*\n                            Basic Structure of C Programs\n\n         I. Basic Organization of C programs (refer to hello2.c listing)\n\n            A. Explanatory comments (optional, but traditional).\n\n            B. Preprocessor commands as needed (#include, #define, etc).\n\n            C. Function Prototypes as needed.\n\n            D. Global variables and constants.\n\n            E. Processing functions.\n               1. Function header.\n               2. Any or all the statements listed in A-D above.\n               3. C language processing instructions.\n               4. One and only one function must be named main.\n\n        II. Syntax.\n\n            A. General.\n               1. Extra white space is ignored by the compiler.\n               2. At least one blank is often needed around a word to make\n                  it identifiable to the compiler.\n               3. The C language is case sensitive. The words TXT, Txt,\n                  TxT, txT, and txt are all different.\n\n            B. Comments.\n               1. Comments begin with /* and continue to the next */.\n               2. Missing or misspelled */ can cause ugly problems.\n               3. Ctrl-Q [ is handy to locate the ending */.\n\n            C. Preprocessor commands.\n               1. All begin with # followed by the command name.\n               2. Command names are always in lower case.\n               3. Have no ending semicolon.\n               4. #include is similar to COBOL COPY.\n               5. #define causes the first operand to be replaced by the\n                  second operand before compilation begins.\n\n            D. Function Prototypes.\n               1. Pre-define user functions to insure proper use.\n               2. Specify the data returned, if any.\n               3. Specify the type, number, and order of parameters passed\n                  when the function is invoked.\n\n            E. Global variables and constants.\n               1. Begin with a type or type modifier such as int, char,\n                  unsigned, long, float, const, etc.\n               2. Contain the name of the variable or constant.\n               3. Use square brackets to identify arrays and give array\n                  dimensions.\n               4. Always end with a semicolon.\n\n            F. Processing functions.\n               1. Have function headers very similar to their prototypes.\n               2. Parameters are contained within parentheses following the\n                  function name.\n               2. Do not end with a semicolon.\n               3. Processing instructions are enclosed within curly braces.\n               4. Missing or extra curly braces cause compile errors.\n               5. Ctrl-Q [ is handy to locate the ending curly brace.\n\n            G. Processing statements.\n               1. Most processing statements end with a semicolon.\n               2. May be grouped as a block within Curly Braces.\n               3. Semicolons are not usually used following the ending\n                  brace of a block of instructions.\n               4. Square brackets enclose subscripts\n               5. Double quotes enclose string constants\n               6. Single quotes enclose character constants\n               7. Escape sequences are used to specify special characters.\n                  They begin with a backslash followed by a letter or\n                  sometimes digits. Examples are:\n                        \\n   = newline (hex 0A)\n                        \\t   = tab (hex 09)\n                        \\b   = backspace (hex 08)\n                        \\r   = carriage return (hex 0D)\n                        \\f   = form feed (hex 0C)\n                        \\'   = single quote (apostrophe)\n                        \\\"   = double quote\n                        \\\\   = back-slash\n                        \\xdd = a hexadecimal value where each d is 0-F\n\n\n       III. See APPNDXB for a comparison of COBOL and C data definitions.\n\n        IV. Hands-On Session (refer to APPNDXA for Editor keys):\n            A. Get into Turbo C's IDE:\n                    cd c:\\tc\\csource\n                    tc\n\n            B. Load hello2.c into the IDE Edit window:\n                    F3\n                    c:\\tc\\csource\\hello2.c\n\n            C. Insert some source code errors:\n               1. Change #define to #degine on line 4\n               2. Change main() to maiin() on line 10\n               3. Delete the ending \" on line 19.\n               4. Delete the ending right parenthesis on line 22\n\n            D. Attempt to run the program: Ctrl-F9\n\n            E. An error message appears: press any key to remove it.\n\n            F. Screen now has Edit window above, but Message window below and\n               it is the active window. Press the arrow keys and see how the\n               display is affected. Note that the Edit window cursor moves to\n               the line containing the error.\n\n            G. Correct the \"Unknown preprocessor directive ...\" error:\n                     Press F6 until the Message Window is active\n                     Use the up and down arrow keys to highlight the\n                     \"Unknown Preprocessor ...\" message.\n                     Press F6 to activate the Edit Window.\n                     Change the word \"degine\" to \"define\"\n\n            H. Correct the \"Undefined symbol White ...\" error:\n                     Press F6 to activate the Message Window.\n                     Press the down arrow key to highlight the next error.\n                     Note that this error was caused by the misspelled\n                     preprocessor directive above.\n\n            I. Correct the \"Unterminated string ...\" error:\n                     Press the down arrow key to highlight the next error.\n                     Press F6 to activate the Edit Window.\n                     Insert the ending \" just after the \\n at the end of the\n                     line. Note that the End key is handy to jump to the end\n                     of the line.\n\n            J. Correct the \"Function call missing ) ...\" error:\n                     Press F6 to activate the Message Window.\n                     Press the down arrow key to highlight the next error.\n                     Press F6 to activate the Edit Window.\n                     Missing (unbalanced) parentheses, braces, brackets,\n                     quotes, apostrophes, comment delimiters and so forth\n                     can be difficult to find. To exercise use of the editor\n                     here:\n                        Place the cursor on the ending \")\" on line 22.\n                        Press Ctrl-Q [ to find the matching \"(\".\n                        Now press Ctrl-Q } to get back to the original \")\".\n                     Add a new \")\" just before the ending \";\" om line 22.\n                     Put the cursor on the new \")\" just added and again\n                     enter Ctrl-Q [ to locate the matching \"(\". This should\n                     now land on the \"(\" after printf.\n\n            K. Attempt to run the program again: Ctrl-F9\n            L. An error message appears: press any key to remove it.\n\n            M. Correct the \"Undefined label _main ...\"\n                     First, note that this is a Linker error, not a compiler\n                     error.\n                     You should also be aware that most function names are\n                     prefixed by an underscore by the compiler, so the\n                     missing label is really \"main\".\n                     Finally, the C language requires one and only one\n                     function named \"main\" to exist in an executable module,\n                     as this is the initial entry point where execution\n                     begins.\n                     Since the IDE has no way to tell where the \"main\"\n                     function may be, it does not identify a source line to\n                     be changed.\n                     Press F6 to activate the Edit Window.\n                     Use the PgUp, PgDn, and arrow keys to locate line 10.\n                     change maiin to main\n\n            N. Before executing the program see if you can guess what the\n               output will be:\n               1. How many lines of output will there be?\n               2. What will the output say?\n\n            O. Attempt to run the program: Ctrl-F9\n\n            P. Run is successful, use Alt-F5 to check output.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON03*\n          *----------------------------------------------------------------*\n                           Variables, Operators, and printf\n\n\n         I. Fundamental C data definitions.\n\n            A. Characteristics of variables and constants.\n               1. Lifetime of a variable is the length of time it exists.\n               2. Visibility, also called scope, refers to the parts of a\n                  program in which a variable can be recognized.\n               3. Automatic variables are also called local variables or\n                  dynamic local variables. Automatic variables are defined\n                  within the body of a function. They are created when the\n                  function is entered for execution and destroyed when\n                  execution returns to the caller of the function. Because of\n                  this, they cannot retain values across calls to the\n                  function. Automatic variables are visible only within the\n                  function in which they are defined, so the names of\n                  automatic variables can be reused in many functions in a\n                  program with each function using its own version.\n               4. External variables are also referred to as global variables.\n                  They can be referenced by name in any function within a\n                  program. They are created when the executable program is\n                  created and last for the duration of the program's execution\n                  so that their content is retained across any function call.\n                  The contents of a global variable may be set or changed by\n                  any function. External variables must be defined outside any\n                  function. An external variable is automatically visible to\n                  all functions which follow its definition in the same source\n                  program file. Functions which precede the definition in the\n                  same source program file, and functions which are separately\n                  compiled must declare the external variable with an extern\n                  statement before it can be used. For example, suppose the\n                  variable abc is defined in source program abcmain.c outside\n                  any function (normally before any function definition), and\n                  it is to be used in another source program called abcsubr.c:\n                  a. In abcmain.c, before any function is defined we might see\n                              int abc;       /* global variable abc */\n                  b. Then in order to use this variable in the separate source\n                     program abcsubr.c, the variable abc would be declared:\n                              extern int abc;  /* declare the global abc */\n               5. Static variables are defined within a function using the\n                  static qualifier:\n                              static int holdits_value;\n                  Like automatic variables, a static variable can be seen only\n                  within the function in which it is defined. The static\n                  variable is created when the function is initially entered\n                  for execution and remains in existence for the duration of\n                  execution of the program. If the defining function returns\n                  and is later called again, the static variable will contain\n                  the last value placed in it.\n\n            B. Types of variables\n               1. char is a single byte which can hold one character in the\n                  local character set of the machine being used.\n               2. int represents an integer of the natural size of integers on\n                  the machine being used.\n               3. float is a single-precision floating point number.\n               4. double is a double-precision floating point number.\n               5. The physical memory size required for a given type of\n                  variable is not specified by the C language, but rather by\n                  machine being used. The range of values for a numeric item\n                  depends on its size. Here are some common machines and the\n                  variable sizes used:\n\n                          DEC       Honeywell   IBM 370     IBM\n                          PDP-11    6000        MAINFRAME   PC\n\n                          ASCII     ASCII       EBCDIC      ASCII\n                  char     8 bits    9 bits      8 bits      8 bits\n                  int     16        36          32          16\n                  short   16        36          16          16\n                  long    32        36          32          32\n                  float   32        36          32          32\n                  double  64        72          64          64\n\n               6. For the IBM PC, the basic data types can hold the following\n                  numeric values:\n                  char (1 byte) signed range is -128 to +127\n                                unsigned range is 0 to 255\n                  int  (2 bytes) signed range is -32,768 to +32,767\n                                 unsigned range is 0 to 65,535\n                  short is same as int on the PC\n                  long (4 bytes) signed range is -2,147,483,648 to\n                                                 +2,147,483,647\n                  float (4 bytes) exponent has a range of 10**-38 to 10**+38\n                                  mantissa has up to 6 digits of precision\n                  double (8 bytes) exponent has a range of 10**-308 to\n                                   10**+308 while the mantissa has up to 15\n                                   digits of precision\n            C. Syntax for defining basic variables.\n               1. Storage class specifier. Optional, but when specified may be\n                  auto, static, extern, register, or typedef.\n               2. Type modifier is also optional. It may be short, long, or\n                  unsigned.\n               3. Type specifier is required and may be char, short, int,\n                  long, unsigned, float, double, struct specifier, union\n                  specifier, or typedef name. Note that short, long, and\n                  unsigned may optionally be followed by int so that these\n                  modifiers can act alone as specifiers.\n               4. Name is the identifier used to refer to the variable in\n                  procedure statements. Names may contain a-z (both upper and\n                  lower case), digits 0-9 and the underscore. The first\n                  character must be a letter or underscore. Names may contain\n                  any number of characters, but only the first 31 will be used\n                  by the compiler.\n               5. When an array is defined, a pair of square brackets follows\n                  the name. The number of occurrences may be contained within\n                  the brackets.\n               6. An initial value may be supplied for the variable. If so, is\n                  is specified following an = sign following the preceding\n                  definition.\n               7. The variable definition is terminated with a semicolon.\n\n            D. Initializing variables\n               1. If an initial value is given, it is preceded by an = sign.\n               2. Single characters (including escape sequences) are\n                  surrounded in single quotes (apostrophes). Examples:\n                        char ltr = 'a';\n                        char carriage_return_character '\\r';\n                        char hex_byte = '\\x9D';\n               3. Integer values may have an optional sign followed by decimal\n                  digits to make a value between -32768 and 32767. Unsigned\n                  integers can be from 0 to 65535. Examples:\n                       int countr;\n                       int negval = -6339;\n                       int posval = 32767;\n                       unsigned int maxval = 65535;\n               4. Long values may have an optional sign followed by decimal\n                  digits to form a value in the range -2147483648 to\n                  2147483647. An unsigned long can be from 0 to 4294967295.\n                  Examples:\n                       long bignum;\n                       unsigned long = 4123456789;\n                       long negnbr = -60;\n               5. Float values contain decimal points and can contain an\n                  optional sign followed by a value in decimal notation or in\n                  exponential notation. Float values have up to 6 digits of\n                  precision and an exponent range from -38 to +38. Examples:\n                       float fltnum;\n                       float smlnbr = 99.99;    -or-   float smlnbr = 9999E-2;\n                       float lrgnbr = 320000.0; -or-   float lrgnbr = 3.2E5;\n               6. Double values are identical to float except in range. The\n                  double has up to 15 digits of precision and an exponent\n                  range of -308 to +308.\n\n        II. Arithmetic and assignment operators used in C\n\n            A. Arithmetic Operators:\n               1. Addition: +\n               2. Subtraction: -\n               3. Multiplication: *\n               4. Division: /\n               5. Remainder: %\n               6. Unary - permitted, but not unary +\n\n            B. Increment and decrement operators\n               1. Increment: ++\n               2. Decrement: --\n               3. Prefix means apply before using the variable\n               4. Postfix means to use the variable in the expression as-is,\n                  then apply the increment or decrement.\n\n            C. Assignment Operators\n               1. Set variable to the value of an expression: =\n               2. Add a value to present content of a variable: +=\n               3. Subtract a value from present content of a variable: -=\n               4. Multiply present content of a variable: *=\n               5. Divide into present content of a variable: /=\n\n       III. The printf function\n\n            A. The printf() function is used to display information on the\n               screen. The output data may contain constant text interspersed\n               with formatted data from variables.\n\n            B. The parameter data passed to printf is somewhat confusing, as\n               it is in two parts. The first portion contains a character\n               string enclosed in double quotation marks. This first portion\n               provides all the constant text and identifies where to place\n               and how to format any data from variables. The second portion\n               of the parameter data contains the variables which are to be\n               used in the first portion. For example:\n                    printf(\"Variable abc\\'s data here: %d\",abc);\n               Note the first portion is a character string enclosed within\n               quotes. The second portion names the variable to be mapped into\n               the first portion. In the first portion, the position for a\n               variable is identified by a % followed by the formatting rules.\n               In this case, the %d indicates a decimal number is to be\n               included from the variable given in the second part. A comma\n               separates the two parts following the quote ending the first\n               part. In this case, the variable to be used is called abc.\n\n            C. Some format specifiers used with printf\n               1. %d specifies signed decimal from an int\n               2. %ld specifies signed decimal from a long\n               3. %X specifies upper-case hexadecimal from an int\n               4. %u specifies unsigned decimal from an int\n               5. %c specifies a single character from a char\n               6. %s specifies characters from a null-terminated string\n               7. %f specifies decimal from a float\n               8. %e specifies decimal from a double\n               9. %p specifies a pointer value\n\n            D. Width modifiers immediately follow the % if used.\n               1. Flags or modifiers\n                  a. - prints left justified in the field\n                  b. + prints a number with a sign always\n                  c. 0 causes leading zero fill\n               2. Minimum field width. If output size is less than this it\n                  will be right justified with leading blanks unless a flag is\n                  used to change this default.\n               3. A period may be given followed by the number of decimal\n                  places to be displayed.\n\n        IV. Hands-On Session: (see APPNDXA for editor keys):\n\n            A. Invoke Turbo C++.\n               1. At the DOS prompt type:\n                        tc\n               2. Type Alt-F3 to clear the current edit window.\n               3. Press F3 to get the Load a File Window.\n               4. Type:\n                        d:\\tc\\csource\\circle.c\n\n            B. Find all global and automatic variables.\n\n            C. Find any arithmetic operators. What are they?\n\n            D. What types of variables are used in the program?\n\n            E. How is a floating point variable specified in printf?\n\n            F. Use the pair matching function of the editor to locate the\n               ending brace for the main function.\n\n            G. Use the language help function of the editor to learn more\n               about the atof function. What does it return? Is it portable?\n\n            H. Run the program and check the output screen? Why did you get\n               that output? Use the Run menu pull-down to enter a radius value\n               as an argument, then re-run. Is the output correct now?\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON04*\n          *----------------------------------------------------------------*\n                            Include, Define, and Functions\n\n         I.  General.\n\n             A. Program organization.\n                1. Comments optionally precede code to describe the\n                   program.\n                2. Preprocessor statements.\n                   a. #include.\n                      1. Identify header files to be included in the\n                         program.\n                      2. Header files never print with the #include'ing\n                         program, but may be viewed via the editor if\n                         desired.\n                      3. Statements in #include'd headers acts exactly as\n                         though it were coded there by the programmer.\n                      4. When the header file is a standard library header\n                         supplied with the compiler it will be found in the\n                         standard include file. In this case, the name is\n                         included in angle brackets:\n                                  #include <stdio.h>\n                      5. When a user-written header file is to be included,\n                         it is included within double quotation marks. If\n                         it will be found in the current source program\n                         directory, only the file name is needed, otherwise\n                         a full path is required:\n                                  #include \"d:\\tc\\myheaders\\vruhead.h\"\n                   b. #define statements.\n                      1. Can be used to provide a replacement of one word\n                         by another. This is useful in areas which may\n                         change to permit a single point of change to\n                         simplify maintenance. For example, a table may\n                         increase in size over time. To minimize\n                         maintenance problems caused by cahnges, you might\n                         code:\n                                  #define NUM_STATES 48\n                         This would cause the preprocessor to scan for all\n                         occurrences of the string NUM_STATES and replace\n                         each with 48. This would be done prior to\n                         compilation. For example, the following code would\n                         be affected:\n                                  int state_population[NUM_STATES];\n\n                                  for(i=0;i<NUM_STATES;i++)\n                      2. It is traditional, but not required, to use all\n                         upper-case names for #define'd names.\n                      3. If a name is given with no value, it is considered\n                         to be \"defined\" for use by the #ifdef and #ifndef\n                         directives. The #ifdef statement is true if the\n                         following name is defined. The #ifndef statement is\n                         true if the following name is not defined.\n                         Consider a small header file called myhdr.h which\n                         defines some global variables:\n\n                                 /* define global variables */\n                                 #ifdef MAIN\n                                   int i;         /* index 1 */\n                                   int j;         /* index 2 */\n                                   float total;   /* sales total */\n                                 #endif MAIN\n\n                                 #ifndef MAIN\n                                   extern int i;         /* index 1 */\n                                   extern int j;         /* index 2 */\n                                   extern float total;   /* sales total */\n                                 #endif MAIN\n                         In the main source program we would #define MAIN\n                         so that the globals will be defined:\n                                /* main program */\n                                #define MAIN\n                                #include \"myhdr.h\"\n                                void main() {\n                                .\n                                .\n                                .\n                         And in a separate source module we want externs,\n                         so MAIN is not #define'd:\n                                /* called functions module */\n                                #include \"myhdr.h\"\n                                int subfun1(int req, char typ, float fig) {\n                                .\n                                .\n                                .\n                3. Function prototypes can be anywhere outside any function\n                   and prior to the first call to the function.\n\n                4. Global data can be defined anywhere outside any function\n                   and prior to the first reference to it. If a global\n                   variable is not defined in the same source module and\n                   before the first reference to it, the field must be\n                   declared with an extern to prevent the compiler from\n                   flagging the reference as an undefined variable.\n\n                5. Every executable program must have function named main.\n                   1. This is always the entry point to an executable\n                      program.\n                   2. The only valid parameters on the main function are the\n                      command line parameters. In modern C these are\n                      usually coded as:\n                                 void main(int argv, char *argv[])\n                   3. In the original C, the parameters for a function had\n                      to be defined following the header, so this is the\n                      way they appeared:\n                                 main(argc, argv)\n                                 int argc;    /* number strings */\n                                 char *argv[]; /* array of strings */\n                   4. Traditionally, argc and argv are the names given to\n                      the command line parameters received by the main\n                      function, however they may be called any desired\n                      name.\n                   5. The argc parameter is an int that contains the number\n                      of strings entered on the command line when the\n                      program was invoked. The argv aprameter is an array\n                      of strings containing everything entered on the\n                      command line. For example, assume a program was\n                      invoked by entering the following command:\n                                 prvmaint old_provider new_provider prv_rpt\n                      In this case, since four strings were entered, argc\n                      would contain a 4 and argv would contain an array of\n                      pointers to the four strings \"prvmaint\",\n                      \"old_provider\", New_provider\" and \"prv_rpt\".\n\n             B. Function organization.\n                1. Comments are optionally provided to explain the purpose\n                   of the function.\n                2. A function header identifies the function to the\n                   compiler and gives information about what kind of data\n                   (if any) will be returned by the function, and about the\n                   parameters received on entry.\n                3. Argument definitions are enclosed in parentheses. They\n                   show the order and names of the parameters, and may also\n                   contain the full definitions for parameters in modern\n                   compilers. In older compilers, the parameter fields must\n                   be separately defined following the function header and\n                   before the opening brace for the body.\n                4. Preprocessor statements such as #include and #define may\n                   be used if needed.\n                5. Body of function.\n                   a. Is enclosed within braces.\n                   b. Data definitions precede processing instructions.\n                   c. Processing instructions follow data definitions.\n                   d. A closing brace ends the body. No final semicolon is\n                      used.\n\n        II.  Syntax.\n\n             A. Prototype.\n                1. Return value.\n                   a. Only a single value is possible.\n                   b. Can be a basic C type (int, char, float, long, double).\n                   c. Void can be used if no value is returned.\n                   d. Can be a user defined struct or union (not in\n                      original C).\n                   e. Arrays cannot be returned.\n                   f. Pointers\n                2. Parameter field.\n                   a. Enclosed in parentheses.\n                   b. Specifies order of parameters.\n                   c. Specifies types of parameters.\n                   d. Optionally names parameters\n                3. Termination is a semicolon.\n\n             B. Header.\n                1. Return value same as in prototype.\n                2. Parameter field\n                   a. May be same as in prototype.\n                   b. If parameter arguments are not defined within the\n                      parameter field parentheses, they must be defined\n                      prior to the opening brace for the body of the\n                      function.\n                3. Function body.\n                   a. Enclosed in braces following the header and any\n                      input parameter definitions.\n                   b. Contains the data and instructions which comprise the\n                      function.\n                   c. Data definitions must precede the first executable\n                      instruction in any block of instructions bounded by\n                      braces.\n                4. Termination is the ending brace for the body. There is\n                   no ending semicolon.\n\n             C. Reference (calling the function)\n                1. Return value\n                   a. Void is never specified on a call.\n                   b. The value returned by a function can be ignored by\n                      merely not referring to it in the call.\n                   c. When a returned value is to be used, a variable must\n                      be coded followed by the call to the function. When\n                      the function returns, the value is copied into the\n                      variable specified. For example, given a function\n                      whose prototype is:\n                                             int sum(int, int);\n                      To get the value returned into a variable called\n                      total, you would code:\n                                             total = sum(cost1, cost2);\n                2. Parameter field.\n                   a. Parameter field is enclosed within parentheses.\n                   b. Names the data fields to be passed to the function.\n                   c. Data fields must be passed in the same order they are\n                      specified on the prototype and header statements.\n                   d. Data fields passed must have the types specified on\n                      the prototype statement.\n                3. Termination is a semicolon after the parameter field.\n\n       III.  Passing data to and from functions.\n\n             A. Passing by value.\n                1. Except for arrays, a copy is made of a data item passed\n                   to a called function.\n                2. The called function cannot change the original data\n                   field in the calling function for non-arrays unless a\n                   pointer is passed to it.\n\n             B. Passing by reference.\n                1. This is the method used by COBOL. A pointer is passed\n                   which contains the address of the original data field(s)\n                   in the calling program.\n                2. Any changes made by the called program affect the\n                   original data field in the calling program.\n                3. This method of reference is always used by c for arrays\n                   and can always be done, if desired, by passing a pointer\n                   rather than a data name.\n\n             C. Returning values.\n                1. This is of limited value, as only one value can be\n                   returned.\n                2. As noted above, input parameter fields can be changed by\n                   a called function when the parameter is an array, or\n                   when a pointer is passed.\n                3. A global variable can be modified by the called function\n                   which can be used by the caller on return. When global\n                   variables are to be changed they are not specified in\n                   the called function's parameter list (or a copy would be\n                   passed).\n                4. The return statement is used to return a value to the\n                   function's caller. Syntax for the return statement looks\n                   like a function call, as the return value or an\n                   expression containing it are in parentheses following\n                   the return keyword:\n                                return(volume);\n\n             D. Terminating functions and programs.\n                1. The return keyword can be used to immediately terminate\n                   a function and return to the caller with a value.\n                2. The exit keyword can be used to terminate a program and\n                   pass a value which can be tested by the batch file (PC)\n                   or shell program (UNIX and AIX) which invoked the\n                   program. This is analogous to the return code used by\n                   mainframe JCL. The exit statement is coded like a\n                   function call with a parenthesized value following the\n                   exit keyword. For example, to terminate a program and\n                   return a value of 3:\n                                         exit(3);\n                3. A function automatically returns to its caller if\n                   control passes to the ending brace for the body of the\n                   function. If the function is main, this will also result\n                   in program termination.\n\n             E. External variables.\n                1. External variables (global variables) are those defined\n                   outside any function. They are often defined prior to\n                   the first function is a source module, but may occur\n                   between functions or after the last function in the\n                   source module.\n                2. Global variables can be used by any function in the same\n                   source module that follows the definition.\n                3. While global variables are accessible by any function in\n                   an executable program, they can be referenced directly\n                   only by those functions defined in the same source\n                   module following the definition. In separate source\n                   modules or functions preceding the definition of the\n                   global variable, an extern statement must be used to\n                   declare use of the variable.\n\n\n\n        IV.  For a listing of the library functions provided by Turbo C,\n             see APPNDXC.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON05*\n          *----------------------------------------------------------------*\n                            Arrays, Strings, and Constants\n\n         I. Arrays.\n\n            A. Arrays are defined by enclosing the number of occurrences\n               within square brackets following the name.\n\n            B. When initial values are supplied, the square brackets may be\n               empty, and the compiler will use the number of values supplied\n               as the number of occurrences. If a number of occurrences is\n               given in the square brackets this is used in creating the\n               array. Examples:\n\n                 int year_counts[12];   /* an array of 12 int counters */\n                 float week_vals[] = {0.0, 12.3, 2.9, 41.6, 17.1};\n                 char text_line[5] = {'t', 'e', 'x', 't', '\\0'};\n                 long multi_lvl[3][4] = {{5, 1, 99, 67},\n                                         {33, 2195, 703, 1},\n                                         {23945, 0, 0, 193}};\n\n            C. Array elements are referenced in the same manner they are\n               defined: by use of square brackets. When referring to an array\n               element, however, the brackets must contain the number of\n               the element. Unlike COBOL, C begins with 0 so that the first\n               element of the array year_counts would specified as:\n                            year_counts[0]\n\n            D. Since the bracketed subscript value begins with 0, the last\n               element in an array is one less than the number of occurrences.\n               For example, the last element of the array text_line would be\n               coded:\n                             text_line[7]\n\n            E. The array name when used without a bracketed subscript is\n               valid, and is treated by C as a pointer to the first element of\n               the array. Use of pointers is covered later.\n\n        II. Strings.\n\n            A. Strings are not a real data type in C, but are handled as arrays\n               of characters. Even so, strings can be defined by enclosing the\n               string characters between double quotation marks. For example,\n               the array above called text_line could have been defined as\n               follows:\n                           char text_line = \"text\";\n\n            B. Strings in C are null-terminated. That is,each string ends with\n               a null character ('\\0') which occupies a byte. Whenever a\n               string is specified within double quotation marks, the C\n               compiler will append a null to the string so that it will\n               occupy one byte more than the number of characters between\n               quotes. This must be accounted for or overlays will occur.\n               Examples:\n\n                  char strg[12];       /* 11-char and 1 null string */\n                  char fild_str[] = \"abc\";  /* 3 char and 1 null string */\n                  char strg_aray[4][9] = {\"Dick\",\n                                          \"Jane\",\n                                          \"Harry\",\n                                          \"James\"};\n\n       III. Constants\n\n            A. Constants can be specified within a statement as self-defining\n               values in the same way they are given as initial values: a\n               single character will appear between apostrophes, an integer as\n               a string of decimal digits, a float including a decimal point,\n               and a string between double quotes. Some examples are:\n                       a_vrbl = 'w';\n                       carr_rtrn = '\\r';\n                       record_counter += 1;\n                       cost_factor = 23.97378;\n\n\n            B. The const keyword can be used with one of the standard data\n               types to create an unchangeable constant. Constants are often\n               given names in capital letters. Examples:\n                       const char NEW_LINE = '\\n';\n                       const float PI = 3.14159;\n                       const int CON5 = 5;\n        IV. Hands-on\n\n            A. Start an IDE session in Turbo C++ using program circle.c:\n               1. Type TC on the command line at the DOS prompt and press the\n                  ENTER key.\n               2. When the IDE window appears, type Alt-F3 to close the\n                  program window unless it contains circle.c.\n               3. On the Load A File screen type d:\\tc\\csource\\circle.c and\n                  press ENTER. This should bring the circle.c program into the\n                  edit window.\n\n            B. Trace a few lines of the program:\n               1. Press F7 (trace). You should see the program compile, then\n                  the edit screen will scroll to the line containing the\n                  header for the main function, which will be highlighted.\n               2. Press F7 again. The if( ... statement is highlighted.\n               3. Press F7 again. The printf( ... statement is highlighted.\n               4. F7 again causes the screen to flash and the exit statement\n                  is highlighted.\n               5. F7 again terminates the test.\n               6. Now press Alt-F5 to view the screen and you should see a\n                  message showing \"Usage is circle radius.\"\n               7. Press any key to return to the IDE.\n\n            C. Set the command line argument for the circle program and\n               execute it.\n               1. Press Alt-r to activate the Run window, then A for the\n                  Program Arguments window. Type a radius value of 12.5 into\n                  the window and press ENTER.\n               2. Now press Ctrl-F9 to execute the program. You should see the\n                  screen flash as the output is written.\n               3. Press Alt-F5 to view the screen. There should be four lines\n                  showing the radius given, the area of the circle, the\n                  circumference of the circle, and the volume of a sphere with\n                  that radius.\n\n            D. Exercise the breakpoint and evaluate features of the debugger:\n               1. Scroll to line 21 beginning \"area = ...\" and place the\n                  cursor on any letter in the word radius, then press Ctrl-F7.\n                  This should bring up a Watch window showing radius. Press\n                  ENTER to accept this watch. Now the active window is a watch\n                  window showing radius is an undefined symbol. That's o.k.,\n                  as it will be valid when filled later.\n               2. Press F6 which activates the Message window. Press Alt-F3 to\n                  delete it. Press F6 until the edit window is active. With\n                  the cursor still on line 21 press Ctrl-F8 to set a\n                  breakpoint. The line should be highlighted now.\n               3. Press Ctrl-F9 to execute to the breakpoint. Turbo C will\n                  then execute  up to line 21, and stop. Now press F6 until\n                  the watch window appears at the bottom. You should see that\n                  radius is now valid and contains 12.5.\n               4. Press F8, which will execute the area = statement and\n                  advance to the circumference = statement.\n               5. Move the cursor up to the word area on line 21 and press\n                  Ctrl-F4. This will bring up an Evaluate and Modify window\n                  that has the word area in the expression field. Press ENTER\n                  to see the value contained in the area field. The result\n                  field will now show 490.8734. Press the tab key twice to\n                  activate the New Value window, then type 123.456 and press\n                  ENTER, then ESC to get back to the edit window.\n               6. Execute the program again using Ctrl-F9. It will complete\n                  and terminate, as there are no more breakpoints. Press Alt-\n                  F5 to see the screen and you can see the area is now\n                  123.456001, reflecting the change you made to the area\n                  field before it was displayed.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON06*\n          *----------------------------------------------------------------*\n                    Relational and Logical Operators and Decisions\n\n         I. Relational Operators <, >, <=, >=, ==, !=\n\n            A. These operators are used with comparisons in expressions.\n               The <, >, <=, and >= operators are used in the normal sense\n               of less than, greater than, less than or equal to, and\n               greater than or equal to, respectively.\n\n            B. Note particularly the == operator. This is used to mean \"is\n               equal to\". The = operator is the assignment of values\n               operator, and does not mean the same thing at all. For\n               example:\n\n                       a = b     <- This means move b to a\n                       a == b    <- This means compare a to b and set the\n                                    result to true (1) if they are equal or\n                                    false (0) if they are not equal.\n\n            C. The \"not equal to\" operator is != in C.\n\n        II. Logical Operators &&, ||, !\n\n            A. The AND (&&) operator is used between two condition\n               expressions to show that the net result will be true only if\n               the first condition AND the second condition are true. If\n               either condition expression is false, the entire condition\n               is false. For example, the condition:\n                          ((a > 0) && (a < 10))\n               will be true if a is a number between 1 and 9. If a is 0 or\n               negative, the first condition expression is false, and if a\n               is 10 or more the second expression is false.\n\n            B. The OR (||) operator is used between two condition\n               expressions to show that the net result will be true if\n               either the first condition OR the second condition is true.\n               If either condition expression is true, the entire condition\n               is true. The overall condition is false only of both\n               expressions are false. For example, the condition:\n                          ((a > 0) || (b < 10))\n               will be true if a is a number greater than 0 OR if b is a\n               number less than 10.\n\n            C. The ! (negation) operator is a unary operator used to\n               reverse the value of an expression. That is, if the\n               following expression is true, ! makes it false and vice-\n               versa.\n\n       III. Decision statements\n            A: The if statement:\n               1. The if is followed by a parenthesized conditional\n                  expression. The expression is evaluated and, if true, the\n                  following action is taken. For example, to move the value\n                  of the variable base_cost to the variable amount when the\n                  variable quantity_sold is greater than zero:\n                      if(quantity_sold > 0)\n                        amount = base_cost;\n\n               2. The conditional expression used may be quite complex with\n                  multiple parenthesized conditions interconnected with\n                  AND's and OR's. For example:\n                      if((((amount > 0) && (cost < 20.00)) ||\n                          (quantity < 200)) && (state == 43))\n                             total = quantity * amount;\n               3. Boolean expressions are common in C. These use a single\n                  variable as a conditional expression, which can appear\n                  strange at first. When a boolean condition is specified,\n                  the content of the variable is tested for 0. If it is\n                  zero, the condition is false, otherwise it is true.\n                  Notice that only zero is false, all other values positive\n                  and negative are considered true. The following statement\n                  will be true if the variable quantity is not zero:\n                           if(quantity)\n                              amount = quantity * price;\n\n               4. Another area that commonly causes problems occurs when\n                  the = (assignment of values) operator is used instead of\n                  the == (is equal to) operator. This may result in an\n                  instruction that compiles without error, but produces\n                  incorrect results and can be difficult to debug.Consider\n                  the following instruction:\n                      if(a = b)  c++;\n                  As written, the compiler views this as an assignment of\n                  values (move b into a) followed by a boolean test of the\n                  resulting content of a. The content of variable a is\n                  tested for a value of zero: if it is zero the if\n                  statement is \"false\" and no action will be taken. If a is\n                  non-zero it is \"true\", and the variable c will be\n                  incremented. The correct way to code this would be:\n                      if(a == b) c++;\n                  so that c is incremented only if a is equal to b.\n\n               5. If more than one statement must be executed when an if is\n                  true, the several instructions must be grouped by use of\n                  braces following the conditional expression. There is no\n                  semicolon following the ending brace. An example is:\n                      if(a == b) {\n                          amount = 6;\n                          quantity = amount + 3;\n                          i++;\n                          strcat(descript,\"Made in USA\");\n                      }\n\n               6. An else may be used immediately following the\n                  statement (or block) for the true action. As with the if,\n                  else can have only a single statement unless a block of\n                  instructions is enclosed in braces. For example:\n                      if(i > 16)\n                        tbl_ent[i] = 0;\n                      else {\n                        i++;\n                        tbl_ent[j] = 16;\n                      }\n\n               7. When if - else instructions are nested, it may be\n                  difficult to identify which if a given else belongs to.\n                  Indentation helps a lot, but can also be misleading if\n                  not done properly. The rule is that an else belongs to\n                  the nearest previous if that does not have an else. For\n                  example:\n                     if(a = b)\n                       if(i = 0)\n                         if(k = 0)\n                           if(x = 9) {\n                              amount++;\n                              cost = cost_tbl[5];\n                           }\n                         else\n                           x++;\n                  Notice that the programmer evidently expects the else to\n                  match with the if(k = 0) due to its indentation. However,\n                  the nearest previous if without an else is the if(x = 9),\n                  and the else will be executed with that if, not the\n                  earlier one.\n\n        IV. Hands-On.\n            A. Start a Turbo C session and begin a new program called\n               tempconv.c.\n            B. Enter an introductory comment.\n            C. Include the stdio.h header.\n            D. Define the name MAX_ENTRIES to be 3.\n            E. Define a global floating point variable called fahrenheit.\n            F. Define an array of floating point variables called celcius\n               that contains MAX_ENTRIES. Initialize the entries to -12.5,\n               32.0, and 212.0.\n            G. Define a global integer named i.\n            H. Make a prototype for a function called compute_fahrenheit\n               which returns nothing and accepts no parameters on entry.\n            J. In the main function, set i to 0. If the celcius value\n               referenced by i is positive, call the compute-fahrenheit\n               function, then print a message showing the i'th entry of the\n               celcius table as the celcius temperature, and the variable\n               named fahrenheit as the fahrenheit equivalent.\n            K. Repeat step J. with i = 1.\n            L. Repeat step J. with i = 2.\n            M. Enter an introductory comment for the compute_fahrenheit\n               function.\n            N. Type the function header for the compute_fahrenheit\n               function.\n            P. Compute fahrenheit = 9/5 * celcius + 32 for the particular\n               value of celcius designated by the index, i.\n            Q. Compile and execute your program.\n            R. Verify correct output by viewing the DOS screen.\n            S. For additional practice, write another program that converts\n               fahrenheit to celcius. Make the variables automatic rather\n               than global. Pass the fahrenheit temperature to the compute\n               function and have it return the celcius value as a float.\n               For negative temperatures, print a message stating the\n               negative temperature is being rejected.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON07*\n          *----------------------------------------------------------------*\n                          Loops and Keyboard Input Functions\n\n         I. The for loop:\n\n            A. The for loop is probably used more than any other loop\n               instruction in C programs. It provides for initialization of\n               the loop control variable, loop termination control, and\n               updating the loop control variable. The for loop is most\n               suitable for use when a fixed number of loops is desired and\n               the number is known in advance.\n               When\n               the loop can terminate at any time dependent on outside\n               conditions, the while loop is preferred.\n\n            B. Syntax for the for loop is:\n                    for(expr1; expr2; expr3) body;\n\n            C. The three expressions given parenthetically are separated by\n               semicolons. All the expressions are optional, but the\n               semicolons are not. This is the minimum code valid for a for\n               loop:\n                         for(;;);\n\n            D. expr1 is an expression executed ONCE just before the loop\n               processing begins. It is usually an assignment statement\n               used to initialize the loop control variable prior to\n               entering the loop. Suppose an integer named i is to be used\n               as the loop control variable and that it is to begin with\n               the value zero:\n                         for(i=0; i<50; i++)\n                           c = getche();\n\n               If no loop variable initialization is needed, expr1 can be\n               omitted, but not its ending semicolon:\n                        for(;i<50;i++)\n                           c++;\n               It is possible to include several initialization\n               instructions in expr1. When this is done, the individual\n               statements are separated by commas and they will be executed\n               left-to-right. If we want to initialize i to 0 and j to 5 we\n               could code:\n                         for(i=0, j=5; i<50; i++)\n                           week_ctr[i]++;\n\n            E. expr2 is an expression evaluated BEFORE EACH PASS through\n               the body of the for loop. When expr2 evaluates false the\n               loop terminates and execution continues with the statement\n               following the for loop. When the expression evaluates as\n               true, the body of the loop is executed. If the expression is\n               false to begin with, the statement body will not execute at\n               all. When the loop control variable is used also as an index\n               against a table, it must begin at zero in order to see the\n               first entry. The final value will be one less than the\n               number of array elements. For example, to search a table of\n               39 struct elements we might code:\n                         for(i=0; i<39; i++)\n                            if(strcmp(paytbl[i].lastname, \"jones\")) {\n                               paytbl[i].total++;\n                               break;\n                            }\n\n               When expr2 is omitted, the for loop is considered never\n               ending and must be terminated by other means, such as break,\n               continue, return, exit, etc. A never ending for loop might\n               be coded:\n                         for(i=0;;i++)\n                           if((strlen(record)) == 0)\n                             break;\n\n            F. expr3 is an expression that is executed AFTER EACH PASS\n               through the instruction body. It is ordinarily used to\n               increment the loop variable. It is also possible to process\n               an array in reverse by decrementing the loop variable:\n                         for(i=38; i>=0; i--)\n                           aray[i] = '\\0';\n\n               If the loop control variable is maintained by code in the\n               body, the third expression can be omitted:\n                         for(;i<50;)\n                           c++;\n\n            G. The body is a single instruction or a block of instructions\n               enclosed in braces. The ending brace is not followed by a\n               semicolon. Be sure you do not place a semicolon after the\n               closing parenthesis of the for loop expressions, as this\n               terminates the for immediately, and the body will be\n               executed once after the for loop completes (if it ever\n               does):\n                         for(i=0; i<39; i++);\n                           counter_array[i] = 0;\n               The above would result in looping 39 times with no action\n               taken. Subsequently, i would be 39 and the 40th element of\n               counter_array would be incremented.\n\n            H. A for loop is often used for processing serially against an\n               array. For example, to zero out all 50 elements of an array\n               if int's called state_pop:\n                            for(i=0;i<50;i++)\n                              state_pop[i] = 0;\n               In this for loop, the loop variable, i, is initially set to\n               zero. Next, i is compared to 50. If i is less than 50 the\n               first (i=0) element is set to zero. After the body statement\n               is executed, the third expression is executed, which adds 1\n               to i. Now the new value of i is compared to 50 and so on\n               until i becomes 50. When i becomes 50 the for loop\n               terminates and execution proceeds with the instruction\n               following the for loop.\n\n\n        II. The while loop.\n\n            A. The while loop contains a loop termination control\n               expression only. Initialization and control of any variables\n               must be done by the programmer. While loops are second in\n               popularity only to the for loop. While loops are preferred\n               when the loop can terminate at any time dependent on outside\n               conditions, such as I/O.\n\n            B. Syntax for the for while loop is:\n                       while(control_expression) body;\n\n            C. The control_expression is evaluated before each execution if\n               the body of the loop. If the expression evaluates false\n               (zero) control passes to the statement following the while\n               loop. If it is true (non-zero) the body of the while is\n               executed. Any initialization must be done prior to the while\n               statement, and any loop control processing must be done\n               within the body of the loop. The while loop is like a for\n               loop using only the middle expression.\n\n            D. As with the for loop, a single instruction or a group of\n               instructions enclosed in braces constitutes the body of the\n               loop. A while loop with a body composed of two instructions\n               might be:\n                        while(i > 0) {\n                           a = b;\n                           c++;\n                        }\n\n            E. If a semicolon is coded following closing parenthesis of the\n               while expression, there is no body, and the loop may be\n               infinite if the body process is required to develop the\n               ending condition. For example:\n                          i=90;\n                          while(i);\n                             ctr[i--] = 0;\n               would result in a never ending loop, since i cannot be set\n               to zero to make the loop expression false.\n\n            F. A common form of the while is used when the ending condition\n               cannot easily be specified. In this case, a never ending\n               while is deliberately specified with the termination\n               testing done in the body of the  loop. For example:\n                   while(1) {\n                     if(end_of_input) break;\n                     i++;\n                     printf(\"Loop continues\");\n                   }\n               In this case, the loop termination control expression is\n               (1). When evaluated, this will never be false (zero), so the\n               loop is never ending. In this case the break instruction is\n               often used to exit from the loop. In addition, the return\n               and exit instructions could be used. The never ending while\n               loop may have any non-zero constant value. Another common\n               value is:\n                     while(-1) ...\n\n       III. The do ... while loop.\n\n            A. The do ... while loop begins with an instruction or block of\n               instructions that is always done at least once with the\n               controlling while instruction following this. The do ...\n               while loop is less popular than for and while, but is often\n               used when the instructions must be executed at least once.\n\n            B. Syntax for the for do ... while loop is:\n                       do {\n                           instructions ...\n                       }\n                       while(control_expression);\n\n            C. This construct begins with the reserved word do followed by\n               one instruction or a block of instructions enclosed in\n               braces. Following the instruction is a while statement that\n               is exactly like the normal while except that it has no\n               following body of instructions. Instead, control passes back\n               to the do if the while expression is true. When the while\n               expression is false control falls through to the next in-\n               line instruction. The do ... while construct is useful when\n               the loop body must always be executed at least once.\n               Example:\n                       do\n                         a+=5;\n                         claim_total = 0;\n                         strcpy(social_security,\"000-00-0000\");\n                       while(a <= 95);\n\n        IV. The break instruction.\n\n            A. The break instruction is used to break out of the smallest\n               enclosing while, do, for, or switch statement. Control\n               passes to the statement following the terminated statement.\n\n            B. Syntax of the break statement is:\n                     break;\n\n            C. At times it may be necessary to break out of a loop prior to\n               the normal termination. Example:\n                     while(more_records) {\n                        for(i=0;i<99;i++) {\n                          if(inventory[i].item_number > search_item)\n                            break;\n                          if(inventory[i].item_number == search_item) {\n                            inventory[i].quantity--;\n                            break;\n                          }\n                        fread(input_file,inventory_record);\n                     }\n               In this example, the inventory table is searched for an\n               item. Since the table is in item number order, it is\n               unnecessary to continue the search when the table item is\n               greater than the search item number, so a break is issued.\n               Also, when the matching item is found, quantity is\n               decremented, and the for loop is terminated with a break\n               rather than continuing the search. After the for loop is\n               terminated, control passes to the fread and processing\n               continues within the while loop, which is not affected by\n               the break in this instance.\n\n         V. The continue instruction.\n\n            A. The continue instruction is used to cause control to pass to\n               the end of the smallest enclosing while, do, or for\n               statement so that the next iteration will be initiated. In\n               this case, the loop is not terminated.\n\n            B. It is often efficient to continue execution for a given\n               table element  when it can be seen that it is not of\n               interest to the process. While nested if logic can usually\n               handle these situations, it may be clearer to merely\n               continue with the next table element. Example:\n                      for(i=0<i<95;i++) {\n                        if(tbl_el[i].type != '6') continue;\n                        i++;\n                        tbl_el[i].qty++;\n                      }\n               Here, only table entries having type = '6' are desired. If\n               entry type is not 6, control passes to the end of the loop\n               and the third expression of the for loop (i++) is executed,\n               then the second expression is tested for the next iteration.\n\n        VI. The getch() and getche() functions (see APPNDXD for codes).\n\n            A. These functions are used to read data typed in at the\n               keyboard and return the next key typed with no buffering.\n               Special keys, such as function keys, are returned as a two-\n               character sequence: the first character of the pair is zero\n               and the second is the scan code for the key pressed. The\n               getch and getche functions are identical except that getche\n               echoes the key pressed to the screen while getch does not.\n\n            B. Syntax is:\n                     unsigned char c;\n                     c = getch();\n                        -or-\n                     c = getche();\n\n            C. The character field returned is usually defined as an\n               unsigned char to permit use of all possible key values. An\n               example of processing key entry until the character 'q' is\n               pressed is:\n                           unsigned char c = 0;\n\n                           where((c=getche()) != 'q') {\n                             amount = 0;\n                             qty += 5;\n                           }\n\n       VII. The gets() function.\n\n            A. The gets function reads a string from the keyboard and\n               places the characters typed in a string variable in memory\n               until a newline character is typed. The newline character is\n               not included in the string, but the string is terminated\n               with a null (\\0). Control returns to the caller after the\n               newline is pressed.\n\n            B. Syntax for the gets function:\n                            char string[80];\n\n                            gets(string);\n\n            C. Since the gets function handles backspace, delete, and other\n               editing, it can greatly simplify processing as compared to\n               using getch or getche to read the string one byte at a time.\n               An example of use is:\n                            char name[20];\n\n                            printf(\"Enter your name: \");\n                            gets(name);\n                            printf(\"Your name is %s\\n\",name);\n\n      VIII. Hands-On.\n            A. Start a Turbo-C IDE session and begin a program named\n               lesson7.c.\n            B. Enter an identifying comment, include the stdio.h header,\n               and begin the main function.\n            C. Build an array of strings and initialize it to contain the\n               following names: Amy, Beverly, Carl, David, Elizabeth,\n               Frank, Georgie, Harold, Imelda, John, Karla, Leonard, and\n               Queen. Make each entry 12 bytes long. Partial example:\n                    char names[26][12] = {{\"Amy\"},{\"Beverly\"},\n                                          {\"Carl\"},{\"David\"},\n                                           ...\n                                          {\"Leonard\"},{\"Queen\"}};\n            D. Define an integer to be used as an index for the table\n               search.\n            E. Define a 20-byte string for the user's name.\n            F. Ask the user for their name using the printf function.\n            G. Read the user's name into your name field using the gets\n               function.\n            H. Use a for loop to search the table of names:\n               1. If the name is found, use a printf to type a message such\n                  \"Congratulations, you are among the chosen few\", then\n                  terminate the for loop using a break statement.\n               2. If the name is not found in the table, use printf to type\n                  a message such as \"Sorry, you are not allowed\".\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON08*\n          *----------------------------------------------------------------*\n                                       Pointers\n\n         I. Defining pointers.\n            A. Pointers are usually defined by use of the * operator. While\n               * is also used as an arithmetic operator, the C compiler\n               identifies the meaning from context. In a data definition\n               statement, a * preceding the variable's name means the\n               variable is a pointer. To define a pointer to integers, you\n               might see:\n                            int *intptr;\n               Likewise, to create a pointer to floats, characters, or\n               doubles:\n                            float *fltp;\n                            char *p;\n                            double *dp;\n               Note that the pointer itself is an int. The compiler wants\n               to know the data type pointed to for pointer arithmetic.\n\n            B. Array and string names are pointers. As mentioned\n               previously, the name of a string when used without brackets\n               is an address constant which points to the first entry of\n               the array. Because of this, you get a free pointer to an\n               array whenever an array is defined.\n\n            C. Pointer constants are usually not defined by the programmer,\n               but are inherent attributes of data fields. That is, any\n               data field has an address and that address cannot be\n               changed: it is a constant value.\n\n        II. Initializing pointer variables.\n\n            A. Like most other data fields, a pointer field will contain\n               zero at creation time if it is defined globally, or as a\n               static local variable. When defined as a local (automatic)\n               variable, its initial value is undefined.\n\n            B. The & operator can be used to obtain the address of a data\n               item. This is the method usually used to provide an initial\n               value for a pointer variable. For example, at definition\n               time we could create a pointer variable called pv that\n               contained the address of an integer field named abc:\n                         int *pv = &abc;\n               Likewise, to assign the address of a float field named fdt\n               to a pointer named fp we could code:\n                          fp = &fdt;\n               Notice that we do not use the * operator when referring to\n               the pointer variable as a data field. Also, it is not\n               required that an address be assigned to a variable defined\n               as a pointer. That is, if px and py are are defined as\n               pointers to integers, and abc is an int, it would be\n               syntactically correct to specify:\n                          px = 43;\n                          px = abc;\n                          px = py;\n\n            C. The address 0 (zero) is considered invalid, so that a\n               pointer containing zero does not contain a valid address.\n               This fact is used by many functions that return pointers. If\n               the function fails, it will often return zero, which is not\n               a valid pointer.\n\n       III. Using pointers to address data fields.\n\n            A. Pointer arithmetic works a little differently than int or\n               float arithmetic. Since pointers are defined as pointers to\n               a particular data type (int, char, etc), their values change\n               at the same rate as the size of the data type they point to.\n               For example, an int on the PC is 2 bytes long. If pn is\n               defined as a pointer to int and the following is coded:\n                           pn = 32;\n                           pn++;\n               the final value of pn will be 37. When you increment a\n               pointer, you add the length of of the data types it points\n               to. Likewise if you decrement the pointer, its value will be\n               reduced by the length of the data type it points to. The\n               same logic applies when using addition and subtraction. As\n               example, if pf is a pointer to float and the following is\n               coded:\n                            pf = 12;\n                            pf += 7;\n               the final value of pf will be 40. This is because a float is\n               4 bytes long, so the length of 7 floats is 28 bytes.\n               12 + 28 = 40.\n\n            B. Using the * operator with a pointer to address data is\n               called indirection. Ordinarily, when a data field named x is\n               referenced, the meaning is \"data contained in the variable\n               x\". However, when x is defined as a pointer and *x is used\n               in a data reference, the meaning becomes \"data pointed\n               to by x\". For example, to add one to an int called ctr using\n               a pointer called p we could code:\n                             p = &ctr;    /* p now points to ctr */\n                             *p++;        /* add 1 to ctr */\n\n            C. Pointers can be used to address array elements instead of\n               using brackets with subscripts. For example, if you want to\n               increment the third element of an array of ints called ctr\n               using the bracket method, you might code:\n                             ctr[2]++;\n               A pointer to int called pc which had been initialized to\n               contain the address of the first element of ctr could be\n               used instead:\n                             *(pc+2)++;\n\n\n        IV. Sending pointers to functions.\n\n            A. Normally, C passes by value. That is, when a variable is\n               passed to a function, a copy is made of the data, and the\n               copy is used by the called function. This protects data from\n               casual modification by other functions. If a pointer is\n               passed to a function, however, the function can use the\n               pointer to modify the original data in the calling program's\n               area. To pass a pointer, you can define a pointer, assign\n               the desired address to it and put it in the called function\n               parameter list. Alternatively, you can simply use the &\n               operator with the data name in the function parameter list.\n               For example to pass the address of (a pointer to) a data\n               field called colr_cnt to a function called set_video:\n                               set_video(&colr_cnt);\n\n            B. Another means of passing pointers to called functions occurs\n               when an array is passed. By C definition, the name of an\n               array is the address of its first element. When an array\n               name is coded in a function parameter list, a pointer\n               variable is created for use by the called function and it is\n               initialized with the address of the array.\n\n            C. Displaying the content of a pointer is simple using printf.\n               Since a pointer is an int, it can be printed using the %d\n               specifier for a decimal value. If the pointer value is\n               desired in hexadecimal, use the %p specifier.\n\n         V. Using pointers to pointers (double indirection).\n\n            A. An array of strings of varying length can be very\n               inefficient in memory, especially when most of the strings\n               are short, but a few are very long. For example, consider a\n               table containing the names Ann, Ted, Jim, Sylvester, Abe,\n               Bill, Sid, Tom, and Ben. In order to make an array of these\n               names, each entry must be long enough to hold the longest\n               entry, in this case 10 bytes while most of the names would\n               require only 4 bytes. The normal definition would be like:\n                         char name_tbl[9][10] = {{\"Ann\"},{Ted\"},\n                                                 {\"Sylvester\"},{\"Abe\"},\n                                                 {\"Bill\"},{\"Sid\"},{\"Tom\"},\n                                                 {\"Ben\"}};\n               If we create a table of pointers to strings instead, we can\n               save a lot of memory. This is because a pointer requires\n               only two bytes of memory, and the strings can then be placed\n               into areas of the right size for each. To define an array of\n               pointers to strings we can code:\n                         char *name_ptr[] = {{\"Ann\"},{Ted\"},\n                                             {\"Sylvester\"},{\"Abe\"},\n                                             {\"Bill\"},{\"Sid\"},{\"Tom\"},\n                                             {\"Ben\"}};\n               In this definition, name_ptr is an array ([]) of pointers\n               (*) to characters (char).\n\n            B. Double indirection.\n               1. In double indirection, we refer to a pointer to a\n                  pointer, which is defined above. We can choose to use\n                  array notation to refer to the strings, or a combination\n                  of pointer and array notation, or pure pointer notation.\n               2. Using pure array notation to point to the first character\n                  of each string, where i is an int value between 0 and 7\n                  we could process the first byte of one of the strings by:\n                          name_ptr[i][0] = 'A';\n                  To refer to the string itself, only the first set of\n                  brackets would be needed:\n                          printf(\"The name is %s.\\n\",name_ptr[i]);\n               3. Using pure mixed notation to point to the first character\n                  of each string, where i is an int value between 0 and 7\n                  we could process the first byte of one of the strings by:\n                          *(name_ptr+i)[0] = 'A';\n                  To refer to the string itself, only the first part is\n                  needed:\n                          printf(\"The name is %s.\\n\",*(name_ptr+i));\n               4. Using pure pointer notation to point to the first character\n                  of each string, where i is an int value between 0 and 7\n                  we could process the first byte of one of the strings by:\n                          *(*(name_ptr)) = 'A';\n                  And to refer to the string itself:\n                          printf(\"The name is %s.\\n\",*(name_ptr+i));\n\n        VI. Hands-On session: write a program to read up to 100 strings\n            from the keyboard and then display them on the screen.\n            A. Use the gets function to read the strings.\n            B. Do not display any string until all been read.\n            C. Define one single area where strings will be read. When\n               a string of zero length, or 100 strings have been entered,\n               display them in the same order they were entered.\n            D. To determine the length of the string read, use the strlen\n               function. To learn how to use this function and which header\n               file it needs, use ctrl-F1.\n            E. If the string length is > 0, dynamically obtain some memory\n               to hold the string and save a pointer to this in an array of\n               pointers.\n            F. Define an array of 101 pointers to characters to hold the\n               addresses of the strings.\n            G. The malloc function can be used to obtain an area of memory.\n               The memory size should be one more than the size returned by\n               strlen, to account for the ending null. To use learn about\n               malloc and its header, use ctrl-F1.\n            H. Save the memory pointer returned by malloc in the next\n               element of the pointer table.\n            I. Move the string read to the memory obtained by malloc using\n               the strcpy function (use ctrl-F1 to learn about it).\n            J. When a string of zero length is read, or when 100 strings\n               have been read, stop reading and begin displaying the\n               strings.\n            K. To display the strings, get the pointers from the pointer\n               table and use the printf function to display them.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON09*\n          *----------------------------------------------------------------*\n                           Structures and Unions and Sizeof\n\n         I. Structures.\n\n            A. In C terms, a structure is a new data type defined by the\n               programmer. It may contain any combination of any of the\n               data types known to C at that time: int, char, float, other\n               structures, unions, etc.\n\n            B. Structures are declared/defined by use of the struct\n               keyword. Following the struct keyword is an optional name\n               that can be used to identify this structure type, then a\n               pair of braces enclosing the data definitions comprising the\n               structure. Following the closing brace is an optional name\n               that is used to define and reserve storage for the\n               structure. A semicolon follows the declaration. Example:\n                        struct personnel_record {\n                          int   id_nbr;\n                          char  last_name[20];\n                          char  first_name[12];\n                          char  middle_initial;\n                          char  sex;\n                          char  birth_date[7];\n                          int   nbr_dependents;\n                          float salary;\n                        } employee, *p;\n               The above structure declares a structure of type\n               personnel_record. This new data type contains the fields\n               id_nbr, last_name, first_name, middle_initial, sex,\n               birth_date, nbr_dependents, and salary. The data name\n               employee is defined, reserving an area for one of these\n               personnel_record structures. In addition, the data name p is\n               defined as a pointer to type personnel_record and storage is\n               reserved for this pointer.\n\n            C. Once the structure is declared, it can be used in later\n               definitions and within other declarations. For example, to\n               define another personnel_record structure called\n               hold_employee:\n                          struct personnel_record hold_employee;\n               And to create an array of 25 of these structures:\n                          struct personnel_record emp_tbl[25];\n\n            D. The dot operator is used to refer to data fields within a\n               structure. The structure name (not the structure type) is\n               used, followed by a dot, then the field. For using the\n               definitions above, we might move the salary from the\n               employee structure to the hold_employee structure by:\n                          hold_employee.salary = employee.salary;\n\n            E. Structures can be initialized at the time of definition, if\n               desired. To do so, the definition is followed by an = sign\n               and a set of braces enclosing the values for the individual\n               fields which are separated by commas. A semicolon terminates\n               the value group. for example, using the structure declared\n               in B. above:\n                 struct personnel_record employee = {1259,\"Thornton\",\"Dick\",\n                                                     'N','M',\"351027\",3,\n                                                     35000.00};\n\n\n        II. Unions.\n\n            A. The union is used to redefine an area. Many data types may\n               be identified within a union, only one of which may occupy\n               it at any given time. The size of the union in bytes is\n               equal to the size of the largest of the included fields.\n\n            B. A union is defined in much the same way as a structure. The\n               word union is optionally followed by a union type name by\n               which other occurrences of this union type can be defined.\n               Next is the content of the union enclosed within braces.\n               Following the content is a field name is this declaration is\n               also to define one of these unions, and a semicolon ends the\n               definition. For example, to define a union which might\n               contain an int named count or a struct of type\n               personnel_record named emp:\n                    union myunion {\n                        int count;\n                        char full_name[35];\n                        float amount;\n                    } redf;\n               At any given time, this union could contain the int count or\n               the string named full_name or the float named amount. Other\n               fields could have been included, as well.\n\n            C. Fields within the union are accessed via the dot operator,\n               just as with the structure. To set the count field to 0 in\n               the union above:\n                     redf.count = 0;\n\n            D. As with structures, if a union type name is supplied, it can\n               be used in later definitions. Using the declaration in B.,\n               we can create another occurrence of the same union called\n               secundo:\n                     union myunion secundo;\n\n       III. Complex structures and unions.\n\n            A. Unions may also contain structures within them. For example:\n                     union red2 {\n                       float quantity;\n                       struct personnel_record emp;\n                     };\n               The dot operator must be applied twice to refer to fields\n               within the emp structure in the red2 union. To set salary to\n               36000.00, for example:\n                     redf.emp.salary = 36000.00;\n\n            B. Structures may include unions, too. For example:\n                      struct {\n                         int item_nbr;\n                         char description[23];\n                         char item_type;\n                         union {\n                           int legs;\n                           float weight;\n                           float girth;\n                           long surface_area;\n                         } size;\n                         int minimum_order_quantity;\n                         float cost;\n                       } inv;\n               Notice that no structure type name is given, nor is a union\n               type name given. This is acceptable, as the structure and\n               union are unique within the program, and will not be\n               referenced by type anywhere else. Both the structure and the\n               included union have field names, however, as it would be\n               impossible to refer to thier fields without names.\n\n               The dot operator must be applied twice to get at fields\n               within the union named size. For example to set surface area\n               to 5090617:\n                           inv.size.surface_area = 5090617;\n\n            C. Arrays of structures are quite common, and are defined as\n               you would expect, using the structure type name, structure\n               name, and brackets enclosing the number of occurrences.\n               Using the personnel_record structure type, an array of 18 of\n               these structures could be created by:\n                   struct personnel_record emp[18];\n               To refer to a particular entry in the array, use brackets\n               following the structure name, then a dot and the field name.\n               To set id_nbr to 8734 in the third entry of the array:\n                   emp[2].id_nbr = 8734;\n\n        IV. The sizeof keyword.\n            A. Syntax for the sizeof keyword is like that for a function\n               call: the object name is in parentheses following the sizeof\n               keyword:\n                           sizeof(object)\n\n            B. The sizeof keyword returns the size of the object as an int\n               value. This is often used in declarations, I/O reads and\n               writes, memory moves, dynamic storage allocations, and so\n               forth. By using sizeof, you do not have to manually compute\n               the size of arrays and unions. In addition, using sizeof\n               rather than hard-coded sizes saves effort when maintenance\n               changes affect the size of structures or unions. Examples of\n               sizeof use:\n                          printf(\"the size of an int is %d\\n\",sizeof(int));\n                          p = (struct abc)malloc(sizeof(struct abc));\n                          memcpy(area1,area2,sizeof(area1));\n\n            C. The object supplied to sizeof can be a type name (int,\n               float, struct abc, union xyz, etc), or a variable name. The\n               length returned will be the defined length of the variable.\n               If the variable is a structure, the length of the structure\n               is returned. If the variable is an array (or string), the\n               length of the array as defined is given. Examples of use\n               with a structure:\n                                 struct abc {\n                                   int iii;\n                                   float fff;\n                                   char sss[15];\n                                 } def;\n\n                                 struct abc ghi[10];\n\n                                 sizeof(def)        /* returns 21 */\n                                 sizeof(abc)        /* error: abc is\n                                                       undefined  */\n                                 sizeof(struct abc) /* returns 21 */\n                                 sizeof(ghi)        /* returns 210 */\n\n            D. When sizeof is given the name of an array or string, it\n               returns the defined length of the array or string, not the\n               length of the string that currently occupies the array. To\n               find the length of the occupying string, use the strlen\n               function, not the sizeof keyword. For example:\n\n                                 char stg[33] = \"Dick\";\n\n                                 sizeof(stg)       /* returns 33 */\n                                 strlen(stg)       /* returns 4 */\n\n        IV. Hands on session.\n\n            A. Start a Turbo-C edit session with struct9.c. This program\n               declares an array of 12 structures which contain employee\n               data. The elements are initialized to zeros, then data is\n               obtained from the keyboard to fill the structures until all\n               12 are filled or the user enters an employee number of zero.\n\n            B. Make the following additions to the program (before the\n               final brace which ends the main function):\n               1. Display a heading line:\n                  EMP#   NAME          RATE    HOURS     PAY\n               2. Print one line for each table entry where pay_grade is an\n                  'h'.\n               3. Each line should contain the employee number, name,\n                  hourly rate, hours worked, and pay amount which is hours\n                  worked times rate. Line up the fields under their heading\n                  columns. Each decimal field should print with 2 decimals.\n               4. Display 3 blank lines to separate the reports.\n               5. Display a heading line:\n                  EMP#   NAME          SALARY     PAY\n               6. Print one line for each table entry where pay_grade is\n                  not 'h'.\n               7. Each line should contain the employee number, name,\n                  annual salary, and pay amount which is annual salary\n                  divided by 52. Line up the fields under their heading\n                  columns. Each decimal field should print with 2 decimals.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON10*\n          *----------------------------------------------------------------*\n                               More Control Statements\n\n         I. The switch statement.\n\n            A. The switch statement is roughly equivalent to a GO TO\n               DEPENDING ON statement in COBOL. Switch has, as a parameter,\n               a variable which is used to select the various \"cases\". The\n               body of the switch statement contains the cases, which\n               relate values of the switch variable to actions. Switch\n               statements are quite common in C programs, and are used\n               wherever a single data field may contain several different\n               values which drive processing.\n\n               1. Syntax: the keyword switch is followed by a variable name\n                  in parentheses. The body of the switch statement comes\n                  next, and is surrounded in braces. There is no semicolon\n                  at the end of the switch body. Within the body of the\n                  switch are case statements and optionally a default\n                  statement with their associated processing statements.\n                  Each case statement gives a single value for the switch\n                  variable followed by a colon and the processing\n                  statements to be executed when the switch variable has\n                  that value. An optional default statement can be included\n                  to handle the \"none of the above\" situation. Example:\n\n                      switch(record_type) {\n                        case '1':\n                        case '5':\n                           n = strlen(company_name);\n                           pop_ctr[n]++;\n                           break;\n                        case '2':\n                           i++;\n                        case '3':\n                           amount = qty * price;\n                           break;\n                        case '7':\n                           break;\n                        default:\n                           printf(\"%c is invalid for record type\",\n                                  record_type);\n                      }\n\n               2. In the switch above, record_type is defined as a single\n                  character field, so the case values are given as\n                  characters: single characters enclosed in single quotes.\n                  If the switch variable is an int, the case values would\n                  have been decimal numbers.\n\n               3. The processing statements following the default statement\n                  are executed if processing reaches that statement.\n\n               4. Once a case statement is matched, all following\n                  processing statements are executed until a break\n                  statement is encountered or the ending brace of the\n                  switch body is reached. In the example above, if case\n                  '2': is matched, the instructions following case '2' and\n                  case '3' are all executed, since no break occurs until\n                  the end of the case '3' statements.\n\n            B. The conditional operator is an unusual construct that allows\n               you to specify a condition and set a variable to one value\n               if the condition is true, or to a second value if it is\n               false. The conditional operator is used a moderate amount so\n               you need to be able to recognize it.\n\n               1. Syntax: the variable to be changed is specified, followed\n                  by the = sign. A parenthesized condition follows the =\n                  sign. After the condition is a ?, then the value to be\n                  placed in the variable if the condition tests true. After\n                  this there is a : followed by the value to be set in the\n                  variable if the condition tests false. The entire\n                  statement ends with a semicolon. Example:\n\n                           max = (i > j) ? i : j;\n\n                  This statement tests the condition (i > j). If it is\n                  true, max is set to the value in i, otherwise it is set\n                  to the value in j.\n\n        II. Hands-on session.\n\n            A. Write a program in C which will send the following menu to\n               the screen and accept a one-character response from the\n               keyboard:\n                             A = add two numbers\n\n                             S = subtract two numbers\n\n                             M = multiply two numbers\n\n                             D = divide one number into another\n\n                             Q = quit\n\n            B. To erase the screen you can printf(\"\\x1B[2J\"); or better\n               yet, #define CLEAR \"\\x1B[2J\" and then printf(CLEAR); Before\n               this will work, you will have to include DEVICE=ANSI.SYS in\n               your config.sys file for DOS.\n\n            C. Use a switch statement to execute one of four functions\n               which you will write to perform the indicated operation.\n\n            D. Write four functions, one for each arithmetic operation.\n               Each function should ask for the two numbers, perform the\n               indicated operation, display the result, and wait for the\n               user to press a key before returning to the main function.\n\n            E. The main function should continue to display the menu and\n               process the response until the letter q is entered. A while\n               loop would be useful here.\n\n            F. You should provide for entry of either uppercase or\n               lowercase letters at the menu.\n\n            G. Since the functions contain a lot of common code, you may\n               want to cut and paste. To do this, put the cursor on the\n               first byte to be copied. Hold the shift key down and use the\n               arrow keys to highlight the entire area to be copied. Now\n               press and hold the shift key, then the Del key. This will\n               cut the marked area out of the program. Do not move the\n               cursor, but again press and hold shift, then press the Ins\n               key once. This should bring back the marked block. Move the\n               cursor to the location where you want a copy, then press and\n               hold shift, then press Ins once. You should now have the\n               marked block showing. To unmark the block press and hold the\n               Ctrl key, then the k key followed by the h key.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON11*\n          *----------------------------------------------------------------*\n                                  Advanced Variables\n\n         I. Pointer notation for structures.\n\n            A. While the dot operator and array notation can be used to\n               refer to elements of structures, a special pointer notation\n               is also available that can often simplify references when\n               using a pointer. To use this notation, an arrow is used\n               between the pointer and structure element. The arrow is\n               composed of the dash followed by the greater-than sign. For\n               example, if p is a pointer to a structure that contains a\n               field named cash, it can be referenced as:\n                               p->cash\n\n            B. Only one structure pointer reference seems possible in a\n               single data field reference. For example, given the\n               following definitions:\n\n                   struct cov {\n                     char type;\n                     int  days;\n                     float ded;\n                   } *pc\n\n                   struct sub {\n                     char id[10].\n                     char name[33];\n                     struct cov covrg[3];\n                     float ytd_claims;\n                   } *ps, subr[90];\n\n               A structure of type cov is declared and a pointer called pc\n               is defined for it. Another structure of type sub is declared\n               which contains an array of three elements of struct cov as\n               well as other fields. A pointer called ps and a 90-element\n               array of struct sub are defined. A reference to the\n               ytd field could be made as either of the following:\n\n                 ps = subr;                    i = 0;\n                 ps->ytd = 1250.75     -OR-    sub[i].ytd = 1250.75;\n\n               Notice that ps must be initialized to point to one of the\n               elements in the subr array before it can be used\n               meaningfully. Below are two ways in which the field named\n               type in the covrg array within struct sub can be referenced:\n\n                  pc = covrg                  j = 0;\n                  pc->type = 'c';    -OR-     sub[i].covrg[j].type = 'c';\n\n               The structure pointer notation here is much more compact\n               than the method using the dot operator, however it is more\n               difficult to understand what the pc-> means than it is to\n               interpret the sub[i].covrg[j].\n\n        II. The enumerated data type is similar to the 88 level condition\n            name of COBOL in that it allows reference to the content of a\n            field using a meaningful name, rather than the actual value.\n            The enumerated data type is always an int, however it may be\n            treated as a single character.\n\n            A. Syntax of the enumerated data type begins with the enum\n               keyword. An optional name follows the enum keyword which\n               names the enum data type if it is referenced in a later\n               declaration or definition. The names to be used for various\n               values follow enclosed within braces. Following the closing\n               brace is an optional name to be used in reference to the\n               item if it is being defined. A semicolon terminates the\n               enum. The names given in the braces may be assigned specific\n               values using an = sign. If no value is given for name, it is\n               assigned a numerical value 1 greater than the preceding\n               name. The first name is assigned the value zero if no value\n               is provided. Names are separated by commas within the\n               braces. Example:\n                               enum jobs {\n                                  janitor,\n                                  junior_programmer = 10,\n                                  programmer,\n                                  programmer_analyst,\n                                  senior_programmer,\n                                  supervisor = 50,\n                                  manager,\n                                  director\n                               } job;\n               The name janitor will be associated with the value zero for\n               the field named job. Junior_programmer will be associated\n               with 10, programmer with 11, programmer_analyst with 12,\n               senior_programmer with 13, supervisor with 50, manager with\n               51, and director with 52. If no values had been assigned,\n               janitor would have been zero, junior_programmer one,\n               programmer two, etc. All the names could have been assigned\n               values, if desired.\n\n            B. In COBOL, a condition name is used directly, as in:\n\n                   IF JANITOR PERFORM HOURLY-PAY-ROUTINE.\n\n               This construction is not allowed in C. Rather, the field\n               name is used with a relational operator and the value name.\n               The equivalent C statement might be:\n\n                   if(job = janitor) hourly_pay_routine();\n\n            C. An advantage of the C enum over COBOL's 88 levels is that\n               the names may be used in statements other than comparisons.\n               For example,\n\n                   IF JOB < MANAGER\n                      MOVE PROGRAMMER-ANALYST TO JOB.\n\n               would be illegal in COBOL, but not in C. The statement:\n\n                   if(job < manager)\n                     job = programmer_analyst;\n\n               is perfectly acceptable in C.\n\n            D. Certain restrictions may apply to use of the enum data type\n               and associated names. One book says that decimal values\n               cannot be directly assigned to enum variables. In other\n               words, stating:\n\n                              job = manager;\n\n               should be legal, while\n\n                              job = 50;\n\n               should produce a compiler error. I found that Turbo C does\n               not consider this an error. The same book noted that the\n               only valid relational comparison operators for use with enum\n               types are == and !=. In fact, Turbo C will honor < and\n               probably all others.\n\n       III. The typedef keyword is used to provide another name for an\n            existing data type a data type. This can sometimes improve\n            program readability, but should be used with caution, as the\n            maintenance programmer may be confused when a strange name is\n            used where a data type name is expected.\n\n            A. Syntax for the typedef begins with the reserved word typedef\n               followed by the existing data type, then the new data type\n               name to be used. The statement ends with a semicolon. Two\n               examples follow. The first provides a new type name for\n               unsigned char and the second for struct payrec:\n\n                    typedef unsigned char BYTE;\n\n                    typedef struct payrec payrecd;\n\n            B. With these new names, definition for data items can be\n               written differently. The following shows the original\n               definition followed by a definition using the new name. Both\n               are valid, and both result in identical data definitions:\n\n                    unsigned char c;        /* original (still valid */\n                    BYTE c;                 /* using new type name */\n\n                    struct payrec payroll_record;   /* original way */\n                    payrecd payroll_record;   /* using new type name */\n\n        IV. Type conversion and casting.\n\n            A. While C ordinarily handles mixed data types in an expression\n               properly, there are pitfalls, and it is a good idea to\n               maintain a single data type throughout an expression, if\n               possible: that is, use only int or only long or only float\n               or only double. When mixed types are used, the compiler\n               converts the variables to compatible types before doing the\n               indicated operations. When mixed variable types are used,\n               the compiler converts from a lower type to a higher type\n               before the operation where the ranking from lowest to\n               highest is:\n\n                            (lowest) char\n                                     int\n                                     long\n                                     float\n                           (highest) double\n\n            B. When an expression containing mixed variable types is\n               calcualted, the eventual answer will be of the type of the\n               highest data type used anywhere in the expression. If the\n               result field is of lower data type, the answer must be\n               scaled back to this lower type and can result in loss of\n               precision or a completely incorrect result.\n\n            C. Typecasting is a method of forcing the compiler to convert a\n               variable to another data type. This is often done when a\n               variable to be passed to a function is not of the type\n               required by the function. In order to cast a variable as\n               another type, enter the desired data type in parentheses\n               before the data name being used. For example, assume you\n               want to find the square root of an int field called bignum,\n               but the sqroot() function being used expects its input\n               parameter to be a long:\n\n                    root2 = sqroot( (long)bignum);\n\n               In the statement above, the compiler will convert the int\n               named bignum to a long before passing it to the sqroot\n               function.\n\n         V. Hands-on session.\n\n            A. Call up the program menu10.c in the Turbo C IDE.\n\n            B. In the global area, declare an enum called req that defines\n               ADD as 'a', SUBTRACT as 's', MULTIPLY as 'm', and DIVIDE as\n               'd'.\n\n            C. Define a new data type called REQUEST for the enum above.\n\n            D. Define an array of 12 structures named memo. Each structure\n               element should contain one item of the new data type\n               REQUEST called request, a float called number1, a float\n               called number2, and a float called answer.\n\n            E. Define a pointer to the array above. Call the pointer pm.\n               You can do this as part of the array definition or as a\n               separate statement.\n\n            F. In the main() function, begin with an instruction to put the\n               address of the first element of memo into the pointer called\n               pm.\n\n            G. In each of the processing routines, add_numbers();\n               subtract_numbers(), multiply_numbers(), and\n               divide_numbers(), add the following code:\n\n               1. Put the appropriate value for ADD, SUBTRACT, MULTIPLY, or\n                  DIVIDE into the request item within the element of the\n                  memo array pointed to by pointer pm. Use structure\n                  pointer notation (->).\n\n               2. After the first number is obtained, put its value into\n                  the number1 field pointed to by pm.\n\n               3. After the second number is obtained, put its value into\n                  the number2 field pointed to by pm.\n\n               4. After the answer is calculated, put its value into the\n                  answer field pointed to by pm.\n\n               5. Update the pm pointer to point to the next element in the\n                  memo array.\n\n               6. Back in the main() function, after a Q is entered and the\n                  while loop is terminated, add a loop to run through the\n                  memo array and display each element that contains data.\n                  Display the word corresponding to the value in the\n                  request field and display all the number fields with 2\n                  decimals and identifiers.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON12*\n          *----------------------------------------------------------------*\n                                 Files and I/O Part 1\n\n         I. Types of disk I/O:\n\n            A. Standard (stream) I/O: most commonly used, wider range of\n               commands, easier to use, automatic buffering.\n               1. Character I/O: fopen, getc, putc, fclose\n               2. String I/O: gets, puts\n               3. Formatted I/O: fprintf, fscanf\n               4. Record I/O: fread, fwrite\n\n            B. System I/O: fewer ways to handle data, more primitive\n               system, more work required of programmer, no buffering,\n               often more efficient in memory usage, faster I/O.\n               1. Buffer I/O: read, write\n\n        II. Modes of file I/O\n\n            A. Binary mode\n               1. Add \"b\" after type letter in fopen or default\n               2. Data written and read without change.\n               3. Signals EOF when all file bytes read.\n\n            B. Text mode\n               1. Add \"t\" after type letter in fopen\n               2. A newline character (hex 0A, decimal 10) is changed to\n                  CR/LF before writing record.\n               3. Changes a CR/LF into a newline when reading.\n               4. Signals EOF when all file bytes have been read OR a Ctrl-\n                   Z character is read (hex 1A, 26 decimal).\n\n       III. Using the stream I/O functions\n\n            A. Preparing for standard (stream) I/O\n               1. #include <stdio.h>\n               2. Defining the pointer to the file:\n                  FILE *fptr;\n\n            B. Opening the file:\n               1. Gives system the name of the file, how we plan to process\n                  it. System builds FILE structure, buffer. FILE structure\n                  contains file info such as current size, buffer\n                  locations, current location in file (file pointer).\n               2. fptr = fopen(\"filename\",\"r\");\n                   \"r\" = read, must exist\n                   \"w\" = write over or create\n                   \"a\" = append to or create\n                   \"r+\" = read/write, must exist\n                   \"w+\" = read/write over or create\n                   \"a+\" = read/append or create\n                   \"rb\", \"wb\", \"ab\", \"rb+\", \"wb+\", \"ab+\" for binary mode\n                   \"rt\", \"wt\", \"at\", \"rt+\", \"wt+\", \"at+\" for text mode\n               4. Standard coding for file open combines the open with a\n                  test to see if it was successful, and error handling if\n                  it was unsuccessful, for example:\n\n                        if((fptr = fopen(argv[1],\"r\")) == NULL) {\n                          perror(\"Open failed for input file\");\n                          exit(1);\n                        }\n\n               5. The following strings are predefined filenames (reserved\n                  names) which can be used for the standard devices on an\n                  IBM PC or clone:\n                   \"in\" = standard input device (keyboard)\n                   \"out\" = standard output device (display)\n                   \"err\" = standard error device (display\n                   \"aux\" = standard auxiliary device (serial port)\n                   \"prn\" = standard printing device (parallel printer)\n\n            C. Reading from a stream file (after it has been opened):\n               1. For reading one-character-at-a-time from a stream:\n                           ch=getc(fptr);\n                  a. At end of file, ch == EOF, and EOF is -1, therefore ch\n                     must be defined as an int:\n                           int ch;\n                  b. Read statements are often contained within a while\n                     loop that controls overall execution of the program:\n\n                          while((ch=getc(fptr)) != EOF) {\n                            program\n                              execution\n                                statements\n                          }\n\n               2. For reading a string from a stream file the fgets\n                  function is used. This function reads a string of\n                  characters from the (open) file and copies them into a\n                  storage area provided by the programmer. Reading\n                  continues until a newline (\\n) is read or a designated\n                  maximum number of bytes (-1) have been read. The newline\n                  character (if found) is placed in the storage area. A\n                  null is added following the last character read to form a\n                  true string. If successful, fgets returns a pointer to\n                  the string read, otherwise a NULL is returned. When a\n                  NULL is returned, an error may have occurred, or end-of-\n                  file. The feof function can test for end-of-file, while\n                  ferror can test for errors. For example, when reading a\n                  file of 79-byte (maximum) strings, you might code:\n                       while((fgets(string_area,80,fptr) != NULL) {\n                          record\n                            processing\n                              statements\n                       }\n                       if(ferror(fptr) != 0) {\n                         perror(\"Error occurred reading file\");\n                         fclose(fptr);\n                         exit(1);\n                       }\n                       else {\n                         fclose(fptr);\n                         exit(0);\n                      }\n               3. Formatted input can be handled by use of the fscanf\n                  function. This can be used in reverse of the way printf\n                  writes formatted output. The scanf functions are tricky\n                  to use, offer little help to the programmer or user, and\n                  cause your system to lock up if coded improperly. Other\n                  functions can probably be used to greater advantage in\n                  any given situation. The following instruction would read\n                  three data fields from an open file pointer fptr. The\n                  first field will be considered a string, and will be\n                  placed in the field defined as name. The second field\n                  will be considered a decimal number and will be placed in\n                  the field called code. The third field will be considered\n                  a floating point number and will be converted and placed\n                  in the height field. Note that field ADDRESSES must be\n                  specified, not field names. If you forget this, you will\n                  probably have to reboot your machine to get out of a\n                  lockup after you run the program.\n\n                        fscanf(fptr,\"%s %d %f\",name,&code,&height);\n\n               4. Reading \"records\" from stream files is very much like\n                  reading fixed-length records in a mainframe COBOL\n                  program. You provide an area to contain the record(s)\n                  read, the length of the record, the number of records to\n                  be read and the pointer to the (open) file. The fread\n                  function returns an int containing the number of records\n                  read. For example, to read a single (1) record into the\n                  structure named record from the file pointed to by fptr,\n                  you could code:\n\n                    while(fread(&record, sizeof(record), 1, fptr) == 1) {\n                      record\n                        processing\n                          statements\n                    }\n                   if(ferror(fptr) {\n                     perror(\"Error reading input file\");\n                     fclose(fptr;\n                     exit(1);\n                   }\n\n            D. Writing data into a standard (stream) file:\n               1. Writing characters one-by-one:\n\n                    putc(ch,fptr);\n\n               2. Writing strings to an (open) stream file uses the fputs\n                  function. The programmer must provide a field containing\n                  a normal null-terminated string to be written to the\n                  file. The terminating null is not written to the file. If\n                  a newline or any other data is to be written, the\n                  programmer must provide it in the string area, as nothing\n                  will be added by fputs . For example, to write a string\n                  contained in a field called string_area to an open stream\n                  pointed to by fptr:\n\n                            fputs(string_area,fptr);\n\n               3. Formatted output is written using the fprintf function.\n                  This function is almost identical to the printf function\n                  that should be familiar by now. The only difference is\n                  that fprintf requires the name of the file to be written\n                  to. As with printf, you will have to include your own\n                  newline character, if desired. For example, If the (open)\n                  stream file pointed to by fptr is to be used, you might\n                  code:\n\n                  fprintf(fptr,\"%s %d %f\\n\",name,code,height);\n\n               4. Record I/O to an open stream file uses the fwrite\n                  function. This is very much like the fread function and\n                  requires the address of the area containing the record to\n                  be written (oftem a structure), the length of the record,\n                  the number of consecutive records to be written (usually\n                  1), and the pointer to the open stream file. An example,\n                  writing a single (1) structure called record to a stream\n                  file pointed to by fptr is:\n\n                         fwrite(&record, sizeof(record), 1, fptr);\n\n            E. Closing a stream file:\n               1. Characters left in buffers, but not yet physically\n                  written are sent to the file, then communications areas\n                  used for the file are freed (FILE structure, buffer).\n               2. The function fclose is used to close a stream file. All\n                  that is needed is the pointer to the open stream file:\n\n                        fclose(fptr);\n\n        IV. Hands-on session.\n\n            A. Bring struct9.c into the Turbo C IDE.\n\n            B. Define a pointer to a stream file called fptr.\n\n            C. Use the fopen function to open the file for binary mode\n               where you will write the file. Choose an open option that\n               will write over the file if it exists, or create it if it\n               does not exist.\n\n            D. After each emp structure is built, write it to your file\n               using the fwrite function.\n\n            E. When all  emp structures have been written and there is no\n               more input to be processed, use fclose to close the stream\n               file, then fopen to read it back in binary mode.\n\n            F. Read each structure in the file using the fread function and\n               display the data for each using the printf function.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            lesson13*\n          *----------------------------------------------------------------*\n                                 Files and I/O Part 2\n\n         I. Random Access\n\n            A. File pointer: A pointer to a byte within a file. Normally\n               set to beginning of file when the file is opened file is\n               opened except for append it is set to end of file. The file\n               pointer is maintained within the FILE structure and is\n               updated when the file is read or written.\n\n            B. The fseek function can be used to update the file pointer\n               directly. See binsrch.c in this handout.\n\n               1. Like many other C functions, fseek is often written with\n                  an if statement to handle errors. An int is returned with\n                  zero if the pointer is moved successfully, or non-zero if\n                  it failed. Parameters required by fseek are the pointer\n                  to the open FILE structure, the new pointer offset and a\n                  \"whence\" integer which shows where the offset is measured\n                  from. Example:\n\n                       if(fseek(fptr, offset, 0) != 0) {\n                         perror(\"Unable to set file pointer\");\n                         exit(1);\n                       }\n\n               2. The offset field must be a long. If a constant is\n                  specified, add the letter l behind the number: 346l, for\n                  example.\n\n               3. The third parameter is the \"whence\" field. It is an\n                  integer containing a 0, 1, or 2 showing how to apply the\n                  offset:\n                   0 = from beginning of file\n                   1 = from current position of file pointer\n                   2 = from end of file\n\n               4. The names SEEK_SET, SEEK_CUR, and SEEK_END can be used\n                  rather than the digits 0, 1, and 2 if desired.\n\n               5. Once the file pointer is set using fseek, the next read\n                  or write function begins at that point in the file.\n\n            C. The ftell function can be used to find where the pointer is\n               located within the file at the time the ftell is executed.\n               This can be used to note where a record will be written.\n               1. The only parameter needed by ftell is a pointer to the\n                  open FILE structure. The ftell function returns a long\n                  containing the current offset of the pointer from the\n                  beginning of the file. If fp is defined as a pointer to\n                  FILE, offset is defined as a long integer, and the\n                  associated file has been opened, you could get the byte\n                  location of the next byte to be processed in the file\n                  with:\n\n                                      offset ftell(fp);\n\n        II. System level I/O.\n\n            A. System level I/O is an older, more primitive form of I/O\n               that requires more work on the part of the programmer, but\n               can sometimes provide faster file access with reduced memory\n               usage. Only one type of data transfer is available, called\n               buffered I/O, which is very similar to the record I/O method\n               used in stream I/O. Be careful not to mix stream I/O and\n               system level I/O functions for a file in the same program,\n               as they are not compatible.\n\n            B. Setting up for system level I/O:\n\n               1. First, include the header files containing the function\n                  prototypes and definitions needed:\n\n                       #include <io.h>         /* function prototypes */\n                       #include <fcntl.h>      /* O_FLAGS defines     */\n                       #include <sys\\stat.h>   /* S_FLAGS defines     */\n\n               2. Define an integer for the file handle. Unlike stream I/O\n                  which uses a pointer to FILE, system I/O uses a simple\n                  int which contains a file number assigned by the\n                  operating system. For example, if you want to refer to\n                  the file as infile:\n\n                       int infile;             /* define the handle */\n\n               3. Since some of the system I/O functions return the number\n                  of bytes processed, you will need an integer field to\n                  contain this returned value:\n\n                       int bytes;              /* nbr bytes read/written */\n\n               4. With system level I/O, the programmer must set up a\n                  buffer. Traditionally, the buffer used is a multiple of\n                  the physical sector size used on the disk. In PC's this\n                  is 512 bytes, so a multiple of 512 bytes is most\n                  efficient. For a single buffer, you might code:\n\n                       char buff[512];        /* data buffer */\n\n            C. Opening the file for system level I/O is similar to stream\n               file open processing. For system I/O, the function used is\n               open, and the data returned is a handle (file number).\n               1. Syntax for the open function is much like that for stream\n                  I/O. The value returned is an int called a handle that is\n                  merely a file number used by the operating system to\n                  identify the file. If the open fails, a -1 is returned.\n                  The first parameter passed is a character string\n                  containing the file name. The second parameter is the\n                  mode, which is specified using \"O_FLAGS\". The third\n                  parameter is required if a file is to be created. It is\n                  called the file permissions, and is set up by use of\n                  \"S_FLAGS\". The O_FLAGS and S_FLAGS are combined by use of\n                  the bitwise OR operator, rather than by commas. For\n                  example, to open a file named \"claim_err\" for output,\n                  creating the file if it does not exist, and writing in\n                  binary mode with permission given to read and write the\n                  file:\n\n                  if((infile = open(\"claim_err\",O_CREAT | O_WRONLY |\n                                    O_BINARY, S_IREAD | S_IWRITE)) < 0) {\n                    perror(\"Unable to open claim_err File: \");\n                    exit(1);\n                  }\n\n               2. The following O_FLAGS are defined in fcntl.h:\n                    O_RDONLY   Open for reading only\n                    O_WRONLY   Open for writing only\n                    O_RDWR     Open for reading and writing\n                    O_APPEND   Open for appending. File pointer will be set\n                               to end of file before each write.\n                    O_CREAT    Has no effect if the file already exists. If\n                               it does not exist, the file is created with\n                               the file access permissions given by the\n                               S_FLAGS.\n                    O_EXCL     Used with O_CREAT to return an error if the\n                               file already exists.\n                    O_TRUNC    If the file exists, its length is truncated\n                               to zero.\n                    O_BINARY   Open file in binary mode.\n                    O_TEXT     Open file in text mode.\n\n               3. The following S_FLAGS are defined in sys\\stat.h:\n                    S_IWRITE   Permission to write\n                    S_IREAD    Permission to read\n\n               4. Some file handles are pre-defined by the operating\n                  system, and do not have to be opened. These are:\n\n                    0 = stdin (keyboard)\n                    1 = stdout (display)\n                    2 = stderr (display)\n                    3 = stdaux (serial port)\n                    4 = stdprn (printer)\n               5. In order to specify the file mode for pre-defined files,\n               you can use the setmode function with either O_BINARY or\n               O_TEXT. For example to set stdprn to binary mode:\n\n                    setmode(4,O_BINARY);\n\n\n            C. Reading a file using system level I/O uses the read\n               function. This function returns an int containing the number\n               of bytes read if it was successful, zero if end of file was\n               encountered, or -1 if an error occurred. The parameters\n               passed include the file handle, a pointer to the buffer, and\n               an unsigned int value containing the number of bytes to\n               read. Reading begins at the location of the file pointer.\n               Using the examples given above so far, to read infile:\n\n                    while((bytes = read(infile, buff, 512)) > 0) {\n                       statements\n                         to process\n                           data in file\n                    }\n                    if(bytes < 0) {\n                      perror(\"Error reading infile\");\n                      exit(1);\n                    }\n\n            D. Writing a file using system level I/O uses the write\n               function. This function returns an int containing the number\n               of bytes written if it was successful, or -1 if an error\n               occurred. The parameters passed include the file handle, a\n               pointer to the buffer, and an unsigned int value containing\n               the number of bytes to be written. Writing begins at the\n               location of the file pointer. Using the examples given above\n               so far, to write to a file whose handle is outhndl:\n\n                   if((write(outhndl,buff,512)) < 0) {\n                     perror(\"Error writing to outhndl\");\n                     exit(1);\n                   }\n\n\n            E. Writing a file using system level I/O uses the close\n               function. The only parameter required is the file handle.\n               For example, to close the file above:\n\n                   close(outhndl);\n\n       III. Hands-on session.\n\n            A. Begin a new program in the TurboC IDE (Alt-F, N).\n\n            B. Use stream I/O for this program.\n\n            C. Define a structure which will contain an enum for\n               day_of_week such that Sunday is 0, Monday is 1, ... Saturday\n               is 6. The second field in the structure should be a floating\n               point variable called temperature. Call the defined\n               structure temprec.\n\n            D. Set up and open a binary output file which will contain\n               records of type struct temprec.\n\n            E. Write procedure statements to get day_of_week and\n               temperature pairs from the keyboard and put the data into\n               the temprec structure. Quit when an invalid value is entered\n               for day_of_week.\n\n            F. Write each temprec structure to disk.\n\n            G. After completion (invalid day_of_week entered), close the\n               file for output and reopen it for input.\n\n            H. Ask the user for a number indicating the day_of_week to be\n               processed. Accept only 0-6 and keep asking until a valid\n               entry is given.\n\n            I. Using the day_of_week entered, read the file and accumulate\n               the total number of records for the specified day and a\n               total of the temperatures for that day.\n\n            J. At end of file, compute th average temperature for that day\n               and display a message like:\n\n               There were xxx yyyyyyyy days. Average temperature was zzz.zz\n\n               Where xxx is the total number of the specified days,\n               yyyyyyyy is the spelled-out equivalent of the day requested\n               (for example, if 1 was entered, the message should say\n               Monday), and zzz.zz is the average temperature with 2\n               decimal places.\n\n          *----------------------------------------------------------------*\n          *                    Elementary C Programming            LESSON14*\n          *----------------------------------------------------------------*\n                                 Miscellaneous Topics\n\n         I. The goto statement and labels\n\n            A. A label provides a name for a location in a program which is\n               to be the destination for a goto statement. A label follows\n               the rules for names in C programs, and is followed by a\n               colon. The label may be on a line by itself, or other code\n               may follow it on the same line if desired. To create a label\n               called Error_End, code:\n\n                           Error_end:\n\n            B. The goto statement is followed by the name of a label in the\n               program. The label may be defined before or after the goto,\n               but both must exist within the same function. The following\n               would be correct if Error_end and Executive_routine were\n               both defined as labels within the same function:\n\n                          if(error)\n                            goto Error_end;\n                          else\n                            goto Executive_routine;\n\n            C. The goto statement is seldom seen in C programs and its use\n               is discouraged owing to its potential for creating\n               unmanageable \"spaghetti\" code.\n\n        II. Memory Models.\n\n            A. Turbo C has a number of memory models for the PC due to its\n               segmented memory. It is best to choose the smallest model\n               possible, as the size of pointers and code necessary to\n               support them increase with the larger models. Memory model\n               specification is set by use of the Options pull-down (Alt-\n               O), then the Compiler choice followed by the code generation\n               selection. To set the model, enter Alt-x, where x is the\n               first letter of the model desired. Press enter to set this\n               model (it will be saved across sessions).\n\n            B. The models available, in ascending size order, are:\n               Tiny:  Limits total memory for the entire program to 64K.\n               Small: Limits total memory for data to 64K and total memory\n                      for code to 64K for a maximum program size of 128K.\n                      A good choice for small programs.\n               Compact: Limit memory used for code to 64K but allow as much\n                      memory as needed for data storage. Probably best for\n                      a program with a lot of data storage requirements.\n               Medium: Limit memory used for data to 64K but allow as much\n                      as needed for code.\n               Large: Allow as much memory as needed for both code and\n                      data.\n               Huge: Reserved for use by programs which have a single data\n                      item (usually an array) that itself exceeds 64K.\n\n       III. Separate Compilation (Projects)\n\n            A. When programs are written into separate source programs and\n               are separately compiled, they must all be pulled together\n               into a single module for execution. There are several\n               requirements for this to work properly:\n\n               1. Subroutines, or sub-functions are those called by other\n                  functions. They cannot be called main(), as there can be\n                  only one function called main() in an executable module.\n                  For this reason, you cannot link a subroutine, as the\n                  linker builds executable modules. It expects to find one-\n                  and-only-one main() function. The subroutine has no main\n                  function, so a linker error is produced. The solution is\n                  to only compile the sub-programs. This creates an object\n                  module which can later be linked with other separately\n                  compiled object modules to create an executable program.\n                  Object modules have names ending with .obj and will be\n                  found in your output directory after any compile.\n\n               2. An executable module must have one-and-only-one main()\n                  function. This is because execution begins at the main()\n                  function in every executable C program.\n\n               3. User-written header files may also be needed by some or\n                  all of the programs.\n\n               4. Global variables can be defined in only one of the\n                  compiled modules. In other modules which are separately\n                  compiled, the global variables must be declared as\n                  extern.\n\n            B. The make utility is a program supplied by most C compiler\n               vendors that permits specification of all the source\n               modules, header files, and object modules that will be used\n               to create an executable program. In addition to merely\n               putting the pieces together, make will test them to see if\n               they are current or require re-compiling or re-linking. This\n               saves you the trouble of remembering what has been changed.\n               The TurboC IDE has a make facility built into it called the\n               project manager. It is simple to use, and is described in\n               your User's Guide.\n\n        IV. Bitwise Operators &, |, ^, ~, >>, <<\n\n            A. Bitwise operators specify operations that actually change\n               the content of a variable.\n\n            B. The AND operator (&) is binary, causing the right hand\n               operand to be AND'ed against the left operand, setting the\n               result in the left operand. The AND operates at the bit\n               level, comparing the operands left-to-right one bit at a\n               time. When the corresponding bits in both operands are on,\n               the bit remains on in the left operand, otherwise it is\n               turned off (set to zero). The AND can be used to turn off\n               selected bits in a field. For example, if the variable h\n               originally contained 0x47, it will contain 0x43 after:\n                         h & 0xFD\n\n            C. The OR operator (|) is binary, causing the right hand\n               operand to be OR'ed against the left operand, setting the\n               result in the left operand. The OR operates at the bit\n               level, comparing the operands left-to-right one bit at a\n               time. When the corresponding bits in both operands are off,\n               the bit remains off in the left operand, otherwise it is\n               turned on (set to one). The OR can be used to turn\n               individual bits on in a field. For example, if variable p\n               originally contained 0x13, it will contain 0x93 after:\n                         p | 0x80;\n\n            D. The EXCLUSIVE OR operator (^) is binary, causing the right\n               hand operand to be EXCLUSIVE OR'ed against the left operand,\n               setting the result in the left operand. The EXCLUSIVE OR\n               operates at the bit level, comparing the operands left-to-\n               right one bit at a time. When the corresponding bits in both\n               operands are opposite, the bit is turned on (set to one) in\n               the left operand. When the corresponding bits in both\n               operands are the same, the bit is turned off (set to zero).\n               For example, if variable s originally contains 0x16 it will\n               contain 0x8A after:\n                         s ^ 0x9C;\n\n            E. The bitwise COMPLEMENT operator (~) is unary. It scans the\n               following field bit-by-bit, changing zeroes to ones and ones\n               to zeros. Two consecutive COMPLEMENT operations to the same\n               field returns the original value. For example, if the\n               variable q originally contained 0xCC, it will contain 0x33\n               after:\n                         ~q;\n            F. The bitwise shift operators are unary, and shift the\n               following field right (>>) or left (<<) the number of bits\n               specified following the shift operator. The bit shifted out\n               is lost, and a zero is inserted in the opposite end of the\n               field (except for negative signed fields shifted right). For\n               example, if the variable f contained 0x05 originally, it\n               will contain 0x14 after:\n                          f << 2;\n               Also, if variable u is an unsigned char field which\n               contained 0x05 initially, it will contain 0x01 after:\n                          u >> 2;\n\n            G. For signed fields, the high-order bit is considered to be\n               the sign, and is zero for positive values or one for\n               negative values. When a right shift is done on a signed\n               field (including char's) and the field contains a negative\n               value, the bit shifted out is lost, however, a one bit is\n               shifted in from the left.\n\n         V. Operator precedence and associativity.\n\n            A. When an expression contains several operators, some rule\n               must be provided to account for the order in which they are\n               to be processed. Those processed first or earlier are said\n               to be of higher precedence than those of later or last use.\n               In addition, some operators are associated with what follows\n               to their right, while others are associated with that which\n               preceded them on the left. This is called associativity. The\n               chart below lists all the C operators from highest\n               precedence (top of list) to lowest precedence (bottom of\n               list). Where more than one operator is on a line the\n               operators have equal precedence and are evaluated in the\n               order found.\n\n                OPERATORS                     ASSOCIATIVITY\n                () [] -> .                    Left-to-Right\n                ! ~ ++ -- - (type) * & sizeof Right-to-Left\n                * / %                         Left-to-Right\n                + -                           Left-to-Right\n                << >>                         Left-to-Right\n                < <= > >=                     Left-to-Right\n                == !=                         Left-to-Right\n                &                             Left-to-Right\n                ^                             Left-to-Right\n                |                             Left-to-Right\n                &&                            Left-to-Right\n                ||                            Left-to-Right\n                ?:                            Right-to-Left\n                = += -= etc.                  Right-to-Left\n                ,                             Left-to-Right\n            B. Precedence has a dramatic effect on the result of boolean\n               and arithmetic expression evaluation, as well as the\n               interpretation of declarations. It is best to use\n               parentheses to force grouping of portions of an expression,\n               even when you are sure of the order. This makes the process\n               clearer to maintenance programmers and is less likely to\n               create problems if the statement requires later\n               modification.\n\n               1. Consider the statement\n                      i = a + b * c;\n                  Since * is of higher priority than either = or + it is\n                  evaluated first, and the product of b and c is calculated\n                  and held. Next, as + is of higher precedence than =, it\n                  is evaluated now so that a is added to the previously\n                  computed product of b and c. This result is held.\n                  Finally, the = operator is processed so that the value of\n                  i is set to the held result. The effect is as though we\n                  had written:\n\n                      i = a + (b * c);\n\n               2. Notice that [] is of higher precedence than * so that the\n                  following declarations have different meanings:\n                      int *pa[];\n                      int(*pa)[];\n\n                  In the first, we read \"pa is an array of pointers to\n                  integers\".\n\n                  In the second, *pa is in parentheses, so that must be\n                  evaluated first and we read \"pa is a pointer\" followed by\n                  \"to an array\" and finally \"of integers\".\n\n          ******************************************************************\n          *       Turbo C Editor Navigation and Hot Key Guide    APPENDIX A*\n          ******************************************************************\n\n         EDIT CURSOR MOVEMENTS             EDIT MISCELLANEOUS\n         Beginning of Line  = Home         Delete a Line      = Ctrl-Y\n         End of Line        = End          Delete to EOL      = Ctrl-Q Y\n         Top of Window      = Ctrl-Home\n         Bottom of Window   = Ctrl-End     EDIT BLOCK OPERATIONS\n         Top of File        = Ctrl-PgUp    Mark a Block       = Shift-arrow\n         Bottom of File     = Ctrl-PgDn    Copy a Cut Block   = Shift-Ins\n         Set Bookmark n     = Ctrl-K n     Delete Marked Block= Ctrl-Del\n         Go To Bookmark n   = Ctrl-Q n     Cut Marked Block   = Shift-Del-Ins\n         Pair Match Forward = Ctrl-Q ]     Paste Marked Block = Shift-Ins\n         Pair Match Back    = Ctrl-Q [     Hide/Display Block = Ctrl-K H\n         Search             = Ctrl-Q F     Print Marked Block = Ctrl-K P\n         Repeat Last Search = Ctrl-L       Read Block On Disk = Ctrl-K R\n         Search and Replace = Ctrl-Q A     Write Block to Disk= Ctrl-K W\n         Go to Next Window  = F6\n                                           DEBUGGING\n         GENERAL                           Trace Execution Into = F7\n         Help                 = F1         Trace Execution Over = F8\n         Language Help        = Ctrl-F1    Execute to Cursor    = F2\n         Exit Turbo C         = Alt-X      Toggle Breakpoint    = Ctrl-F8\n         Return to Prior Menu = Esc        Add Watch            = Ctrl-F7\n         Save Current File    = F2         Evaluate             = Ctrl-F4\n         Activate Menu Bar    = F10        View Program Output  = Alt-F5\n         Open a File to Edit  = F3\n         Zoom Active Window   = F5         Reference: Turbo C User's Guide\n         Compile and Make     = F9                    Chapter 9\n\n          ******************************************************************\n          *               Elementary C Programming                  APPNDXB*\n          ******************************************************************\n                       Data Definitions -  COBOL vs C:\n\n         05 FLD1   PIC X.                   The C definition for a single\n         char fld1;                         character first gives the data\n                                            type which is the lower-case\n                                            word char followed by the\n                                            field name, which may be any\n                                            mix of upper and lower case.\n                                            The statement is terminated by\n                                            a semicolon.\n\n         05 FLD2   PIC X VALUE 'A'.         The value for a single character\n         char fld2 = 'A'.                   is coded in the same way as it\n                                            is in COBOL: enclosed in single\n                                            quotes. When a value is coded\n                                            it is preceded by an = rather\n                                            than the word VALUE, as in\n                                            COBOL.\n\n\n         05 FLD3   PIC X(5).                The C language does not have a\n         char fld3[5].                      data type for character strings.\n                            Instead, a character\n                                            string is treated as a\n                                            character array. The square\n                                            brackets contain the number of\n                                            characters in the array.\n\n         05 FLD4   PIC X(6) VALUE 'CONTENT'.  While C does not recognize a\n         char fld4[7] = \"CONTENT\";          character string as a data type,\n                               it does provide a way to\n                                            encode a character string by\n                                            enclosing the string within\n                                            double quotation marks. In C, a\n                                            true string is null-terminated.\n                                            That is, a binary zero is added\n                                            at the end to identify the end\n                                            of the string. For this reason,\n                                            the C string definition\n                                            requires one character more\n                                            than the number of characters\n                                            in the string itself.\n\n         05 FLD5   PIC S9(4).               A signed integer (whole number\n         int fld5;                          without decimals) is defined\n                                            in C using the int data type.\n                                            The int can hold a value\n                                            between -32,768 and +32,767.\n                                            The value is kept in binary.\n\n         05 FLD6   PIC 9(4).                An unsigned integer field must\n         unsigned int fld6;                 have the word unsigned as a\n                                            qualifier. An unsigned int can\n                                            contain a value from 0 to\n                                            65535.\n         05 FLD7   PIC S9(4) value -60.     This example shows how to give\n         int fld7 = -60.                    an initial value for an int. A\n                                            negative value is shown. The +\n                                            is NOT used when specifying a\n                                            positive value, however.\n\n         05 FLD8   PIC 9(10).               For unsigned integer values\n         unsigned long fld8;                over 65,535 or for signed\n                                            integer values outside the\n                                            range 32,768 to +32,767 the\n                                            long int must be used. When\n                                            long is specified the int is\n                                            implied and can be omitted.\n                                            An unsigned long can contain\n                                            values from 0 to 4,294,967,295.\n\n         05 FLD9   PIC S9(8) value +19372.  Values are given for long\n         long fld9 = 19372;                 fields in the same way as for\n                                            int fields: a decimal value\n                                            following an = sign. The signed\n                                            long can hold values from -\n                                            2,147,483,648 to\n                                            +2,147,483,647.\n\n         05 FLD10  PIC S9(5)V99 VALUE +96.73. When a number requires\n         float fld10 = 96.73;               decimals, the float and double\n                                            data types are used in C. The\n                                            float type is a single\n                                            precision floating point field\n                                            that can contain positive and\n                                            negative values from 10**-38 to\n                                            10**+38.\n\n         05 FLD11  PIC 9(18)V9(5).          For very large numbers, the\n         double fld11;                      double type is used. It is a\n                                            floating point field that can\n                                            contain positive and negative\n                                            numbers with decimal points in\n                                            the range 10**-308 to 10**+308.\n\n\n         05 FLD12  PIC X OCCURS 10 TIMES.   In C, an array is defined by\n         char fld12[10];                    placing the number of\n                                            occurrences in square brackets\n                                            following the field name. C\n                                            supports multi-level arrays\n                                            which are specified by\n                                            consecutive bracketed\n                                            occurrence values, for example,\n                                            int aray3[5][12][73];\n\n         05 FLD13  PIC S9(5) OCCURS 50 TIMES. An array of long integers is\n         long fld13[50];                    specified in the same manner.\n\n         05 FLD14A PIC X(8).                Data redefinition in C is done\n         05 FLD14B PIC 9(8) REDEFINES FLD14A.  using the union. A union\n                                            definition may contain any\n         union un_dcl_nam {                 number of data fields, but only\n           char fld14a[8];                  one will be present at any\n           long fld14b;                     given time. The size allocated\n         } un_def_nam;                      to the union is that of the\n                                            largest field contained within\n                                            it. Note that curly braces\n                                            surround the included fields.\n                                            The name following the word\n                                            union is the generic name\n                                            applied to the union and is\n                                            optional, though outside\n                                            references cannot be made to it\n                                            unless the generic name is\n                                            supplied. The name following\n                                            the ending curly brace is also\n                                            optional, but must be used if\n                                            storage is to be set aside for\n                                            the union, as this is the name\n                                            used to refer to the union.\n\n         01 REC1.                           In C, records are called\n            05 FLDR1  PIC X.                structures. Unions and\n            05 FLDR2  PIC S9(3).            structures allow the programmer\n            05 FLDR3  PIC X(8).             define new data types. Unlike\n            05 FLDR4  PIC 9(7)V999.         unions, structures contain all\n                                            the fields defined within them.\n         struct rec1 {                      A structure may contain other\n           char fldr1;                      structures and unions within it\n           int fldr2;                       and a union may contain other\n           char fldr3[8];                   unions and structures within\n           unsigned float fldr4;            This is because C recognizes\n         };                                 unions and structures as new\n                                            data types. As with the union,\n                                            a name following the struct\n                                            keyword is optional and can be\n                                            used to define the structure at\n                                            other points. A name following\n                                            the ending curly brace is also\n                                            optional, but required for\n                                            definitions where storage is\n                                            set aside, and this name is\n                                            used in references to the\n                                            structure.\n\n          ******************************************************************\n          *                    Elementary C Programming             APPNDXC*\n          ******************************************************************\n                     Cross-Reference to Turbo C Library Functions\n\n                             *** LIBRARY CATEGORIES ***\n\n                       MEMORY MANIPULATION <mem.h> <string.h>\n\n                       CHARACTER CLASSIFICATION <ctype.h>\n\n                       CHARACTER CONVERSION <ctype.h>\n\n                       DATA CONVERSION <stdlib.h>\n\n                       DIRECTORY MANIPULATION <dir.h>\n\n                       FILE MANIPULATION <io.h> <stdio.h>\n\n                       GRAPHICS <graphics.h>\n\n                       DRAWING AND ANIMATION <graphics.h>\n\n                       COMBINING GRAPHICS AND TEXT <graphics.h>\n\n                       TEXT MODE ROUTINES <conio.h>\n\n                       STREAM ORIENTED FILE I/O <stdio.h>\n\n                       LOW-LEVEL FILE I/O <io.h>\n\n                       CONSOLE AND PORT I/O <conio.h>\n\n                       MATH <math.h>\n\n                       Memory Allocation <alloc.h>\n\n                       String Manipulation <string.h>\n\n                       Searching and Sorting <stdlib.h>\n\n                       Process Control <process.h>\n\n                       System Calls <dos.h>\n\n                       Time <time.h> <dos.h>\n\n         Notes: (1) The normal header file is shown in angle brackets <>\n                (2) D indicates functions available for DOS/PC\n                (3) U indicates functions available on UNIX\n                (4) A indicates ANSI compatible functions\n                           *** MEMORY MANIPULATION <mem.h> <string.h> ***\n\n     DU. memccpy           Copy one memory area to another\n     DUA memchr            Search for a character in a memory area\n     DUA memcmp            Compare two areas of memory\n     DUA memcpy            Copy one memory area to another\n     DU. memicmp           Compare two areas of memory ignoring case\n     DUA memmove           Move one memory area to another\n     DUA memset            Set all bytes of a buffer to a given character\n     D?? movedata          Move memory area to another segment\n     D?? setmem            Set all bytes of a buffer to a given character\n     DU. swab              Swap adjacent bytes in a memory area\n\n                           *** CHARACTER CLASSIFICATION <ctype.h> ***\n\n     DUA isalnum           True if character is alphanumeric\n     DUA isalpha           True if character is alphabetic\n     DU. isascii           True if character is ASCII\n     DUA iscntrl           True if character is a control character\n     DUA isdigit           True if character is a decimal digit\n     DUA isgraph           True if character is a graphical character\n     DUA islower           True if character is a lowercase letter\n     DUA isprint           True if character is printable\n     DUA ispunct           True if character is punctuation\n     DUA isspace           True if character is a blank\n     DUA isupper           True if character is an uppercase letter\n     DUA isxdigit          True if character is a hexadecimal digit\n\n                           *** CHARACTER CONVERSION <ctype.h> ***\n\n     DU. toascii           Convert character to ASCII\n     DU. _tolower          Convert character to lowercase\n     DUA tolower           Convert character to lowercase (checks upper)\n     DU. _toupper          Convert character to uppercase\n     DUA toupper           Converts character to uppercase\n\n                           *** DIRECTORY MANIPULATION <dir.h> ***\n\n     DU. chdir             Change current directory to a given path\n     D.. getcwd            Returns name of current working directory\n     D?? mkdir             Create a directory using given path name\n     D?? rmdir             Delete a specified directory\n     D.. searchpath        Locate named file in current path directories\n\n                           *** DATA CONVERSION <stdlib.h> ***\n\n     DUA atof              Convert string to floating point value\n     DUA atoi              Convert string to integer\n     DUA atol              Convert string to long integer\n     DU. ecvt              Convert double to a string\n     DU. fcvt              Convert double to string rounded\n     DU. gcvt              Convert double to a string\n     D?? itoa              Convert integer to a string\n     D?? ltoa              Convert long integer to string by radix\n     DUA strtod            Convert string to a float\n     DUA strtol            Convert string to a long integer\n     D.A strtoul           Convert string to unsigned long\n     D?? ultoa             Convert unsigned long to a string\n\n                           *** MEMORY ALLOCATION <alloc.h> ***\n\n     DU. brk               Set a new break value\n     DUA calloc            Allocate an array and init all elements to 0\n     D.. coreleft          Return amount of available memory\n     D.. farcalloc         Alloc an array of elements in the far heap\n     D.. farcore           Get amount of available memory\n     D.. farfree           Free a block of memory alloc from far heap\n     D.. farmalloc         Allocate a block of memory from far heap\n     D.. farrealloc        Reallocate a block of memory\n     DUA free              Free a block of memory\n     DUA malloc            Allocate a block of memory\n     DUA realloc           Reallocate (adjust size) of a block of memory\n     DU. sbrk              Allocate memory by adjusting the break value\n\n                           *** FILE MANIPULATION <io.h> <stdio.h> ***\n\n     DU. access            Check permission settings for specified file\n     DU. chmod             Change permission settings for specified file\n     D.. chsize            Change size of a file\n     D?? filelength        Get size of specified file in bytes\n     D.. fnmerge           Construct DOS path name\n     D.. fnsplit           Split DOS pathname into sub-strings\n     D?? fstat             Get file status information\n     D?? isatty            Check if a handle denotes a file or a device\n     D.. lock              Lock parts of a file open for sharing\n     DU. mktemp            Generate a unique temporary file name\n     DUA remove            Delete a named file\n     D.A rename            Rename a file\n     DU. setmode           Set file translation mode for an open file\n     D?? stat              Get file status information for a file\n     D?? umask             Set file permission mask\n     DU. unlink            Delete a file\n     D.. unlock            Unlock previously locked parts of a file\n\n                           *** GRAPHICS <graphics.h>***\n\n     D.. closegraph        Close Turbo C graphics package\n     D.. detectgraph       Detect graphics hardware\n     D.. getarccoords      Get coordinates of endpoints of an arc\n     D?? getaspectratio    Get the aspect ratio of the screen\n     D.. getbkcolor        Get the background color number\n     D.. getcolor          Get the current drawing color\n     D?? pallettetype      Get default pallette of current graphics driver\n     D.. getdrivername     Get name of current graphics driver\n     D.. getfillpattern    Get current fill pattern\n     D.. getfillsettings   Get current fill style and fill color\n     D.. getgraphmode      Get the current graphics mode number\n     D.. getlinesettings   Get the current line style and thickness\n     D.. getmaxcolor       Get the maximum color number for current mode\n     D.. getmaxmode        Get maximum mode number for current driver\n     D.. getmaxx           Get the maximum x coordinate\n     D.. getmaxy           Get the maximum y coordinate\n     D.. getmodename       Get descriptive name of current mode\n     D.. getmoderange      Get the low and high mode numbers\n     D.. getpallette       Get the current pallette setting\n     D.. getpallettesize   Get the number of colors in current pallette\n     D.. getviewsettings   Get the current viewport settings\n     D.. getx              Get x coordinate current position\n     D.. gety              Get y coordinate current position\n     D.. graphdefaults     Reset graphics package to default settings\n     D.. grapherrormsg     Get the error message for the given error code\n     D.. _graphfreemem     User-defined memory deallocation routine\n     D.. _graphgetmem      User-defined memory allocation routine\n     D.. graphresult       Get result code of the graphics operation\n     D.. initgraph         Initialize the Turbo C graphics package\n     D.. installuserdriver Install a new BGI driver in the graphics system\n     D.. registerbgidriver Register a preloaded graphics driver\n     D.. restorecrtmode    Go from a graphics mode to a text mode\n     D.. setactivepage     Set the active page\n     D.. setallpallette    Redefine entire pallettein EGA/VGA\n     D.. setaspectratio    Set the aspect ratio\n     D.. setbkcolor        Set a new background color\n     D.. setcolor          Set a new drawing color\n     D.. setfillpattern    Select a new fill pattern and color\n     D.. setfillstyle      Choose a predefined fill style and color\n     D.. setgraphbufsize   Set buffer size or internal buffer\n     D.. setgraphmode      Select a graphics mode\n     D.. setlinestyle      Select a line style and thickness\n     D.. setpallette       Redefine a single color in the pallette\n     D.. setrgbpallette    Define a color in the IBM 8514 adapter\n     D.. setviewport       Define a viewport\n     D.. setvisualpage     Select the graphics page to be displayed\n     D.. setwritemode      Set the writing mode for line drawings\n\n                           *** DRAWING AND ANIMATION <graphics.h> ***\n\n     D.. arc               Draw a circular arc of specified extent\n     D.. bar               Draw a filled rectangular bar\n     D.. bar3d             Draw a filled 3-d rectangular bar\n     D.. circle            Draw a circle given center and radius\n     D.. cleardevice       Clear the screen\n     D.. clearviewport     Clear the current viewport\n     D.. drawpoly          Draw a number of line segments\n     D.. ellipse           Draw an ellipse\n     D.. fillellipse       Draw a filled ellipse\n     D.. fillpoly          Draw a filled polygon\n     D.. floodfill         Fill an enclosed area\n     D.. getimage          Save rectangular screen image in a buffer\n     D.. getpixel          Get the pixel value at a screen coordinate\n     D.. imagesize         Compute bytes needed to save an image\n     D.. line              Draw a line between two points\n     D.. linerel           Draw a line to a point at a specified offset\n     D.. lineto            Draw a line to another point\n     D.. moverel           Move to a point at a specified offset\n     D.. moveto            Move to a new point\n     D.. pieslice          Draw a filled pie slice\n     D.. putimage          Restore saved image from buffer\n     D.. putpixel          Set a pixel to a specified color\n     D.. rectangle         Draw a rectangle\n     D.. sector            Draw a filled elliptical sector\n\n                  *** COMBINING GRAPHICS AND TEXT <graphics.h> ***\n\n     D.. gettextsettings   Get current settings for graphics text\n     D.. installuserfont   Install a new stroke font in the graphics system\n     D.. outtext           Draw a string using current font\n     D.. outtextxy         Draw a text string at a given point\n     D.. settextjustify    Select text justification\n     D.. settextstyle      Select font and character size\n     D.. setusercharsize   Set the scaling factor for characters\n     D.. textheight        Get the height of a text string in pixels\n     D.. textwidth         Get the width of a string in pixels\n     D.. registerbgifont   Register a preloaded font\n     D.. registerfarbgifont Register a preloaded font (far data)\n\n                           *** TEXT MODE ROUTINES <conio.h> ***\n\n     D.. clreol            Erase to the end of the line\n     D.. clrscr            Erase the screen in text mode\n     D.. delline           Delete the line on which the cursor rests\n     D.. gettext           Save a portion of text screen in a buffer\n     D.. gettextinfo       Get text mode settings\n     D.. gotoxy            Move cursor to a specific location\n     D.. highvideo         Turn on high intensity bit\n     D.. insline           Insert a line\n     D.. lowvideo          Turn off high intensity bit\n     D.. movetext          Copy one on-screen rectangle to another\n     D.. normvideo         Set the text attribute to its normal setting\n     D.. puttext           Restore saved text to the screen\n     D.. textattr          Set text attribute\n     D.. textbackground    Select background attribute\n     D.. textcolor         Select foreground text attribute\n     D.. textmode          Set a new text mode\n     D.. wherex            Get x-coordinate of cursor\n     D.. wherey            Get y-coordinate of cursor\n     D.. window            Define a text window\n\n                           *** STREAM ORIENTED FILE I/O <stdio.h> ***\n\n     DUA clearerr          Clear error indicator of stream file\n     DUA fclose            Close a stream file\n     DU. fcloseall         Close all open stream files\n     DU. fdopen            Open a file for stream I/O using its handle\n     DUA feof              Check if end of file occurred on a stream\n     DUA ferror            Check for stream file I/O errors\n     DUA fflush            Write out (flush) buffer to stream file\n     DUA fgetc             Get a character from a stream file\n     DU. fgetchar          Read a character from stdin\n     D.A fgetpos           Get the current position in a stream file\n     DUA fgets             Read a string from a stream file\n     DU. fileno            Get the handle of a stream file\n     DU. flushall          Flush all buffers for all open stream files\n     DUA fopen             Open a stream file for buffered I/O\n     DUA fprintf           Write formatted output to a stream file\n     DUA fputc             Write a character to a stream file\n     DU. fputchar          Write a character to stdout\n     DUA fputs             Write a string to a stream file\n     DUA fread             Read stream file data into a buffer\n     DUA freopen           Reassign a stream file pointer to another file\n     DUA fscanf            Read input from a stream file\n     DUA fseek             Set current position in a stream file\n     D.A fsetpos           Set current position in a stream file\n     DUA ftell             Get current location in a stream file\n     DU. fwrite            Write data to a stream file\n     DUA getc              Read a character from a stream file\n     DUA getchar           Read a character from stdin\n     DUA gets              Read a line from stdin\n     DU. getw              Read a binary integer from a stream file\n     DUA printf            Write data to stdout\n     DUA putc              Write a character to a stream file\n     DUA putchar           Write a character to stdout\n     DUA puts              Write a string to stdout\n     DU. putw              Write a binary integer to a stream file\n     DUA rewind            Rewind a file\n     DUA scanf             Read formatted input from stdin\n     DUA setbuf            Set up a new buffer for the stream file\n     DUA setvbuf           Set up new buffer and buffer level for stream\n     DUA sprintf           Write formatted output to a string\n     DUA sscanf            Read formatted input from a string\n     DUA tmpfile           Open a temporary file\n     DUA tmpnam            Get temporary file name\n     DUA ungetc            Push back character into stream file's buffer\n     DUA vprintf           Write formatted output to a stream file\n     DU. vfscanf           Read formatted input from a stream file\n     DUA vprintf           Write formatted output to stdout\n     DUA vscanf            Read formatted input from stdin\n     DU. vsprintf          Write formatted output to a string\n     D.. vsscanf           Read formatted input from a string\n\n                           *** LOW-LEVEL FILE I/O <io.h> ***\n\n     DU. close             Close a file opened for low-level I/O\n     DU. creat             Create a new file with specified permissions\n     D.. creatnew          Create a new file if none exists\n     D.. creattemp         Create a temporary file\n     DU. dup               Create a second handle for a low-level file\n     DU. dup2              Reassign a handle to an open low-level file\n     D?? eof               Check for end of file on a low-level file\n     DU. lseek             Go to a specified position in a low-level file\n     DU. open              Open a file for low-level I/O\n     DU. read              Read data from a file opened for low-level I/O\n     DU. sopen             Open a file for shared access'\n     DU. tell              Get current position in a low-level file\n     DU. write             Write data to a file opened for low-level I/O\n\n                           *** CONSOLE AND PORT I/O <conio.h> ***\n\n     D.. cgets             Read a string from the console\n     D.. cprintf           Write formatted output to console\n     D.. cputs             Write a string to the console\n     DU. cscanf            Read formatted input from the console\n     D.. getch             Read a character from the keyboard without echo\n     D.. getche            Read a character from the keyboard with echo\n     DU. getpass           Prompt for a password and read it without echo\n     D.. inport            Read two bytes from specified I/O port address\n     D.. inportb           Read a byte from specified I/o port address\n     D?? kbhit             Determine if any key has been pressed\n     D.. outport           Write two bytes to specified I/O port address\n     D.. outportb          Write a byte to specified I/O port address\n     D.. putch             Write a character to the screen\n     DU. ungetch           Push back last character into keyboard buffer\n\n                           *** MATH <math.h> ***\n\n     DUA abs               Get absolute value of an integer\n     DUA acos              Compute arc cosine\n     DUA asin              Compute arc sine\n     DUA atan              Compute arc tangent\n     DUA atan2             Compute arc tangent of a fraction\n     DU. cabs              Compute magnitude of a complex number\n     DUA ceil              Get the smallest integral value exceeding\n     D.. _clear87          Clear the floating point status word\n     D.. _control87        Set a new floating point control word\n     DUA cos               Compute arc cosine of angle in radians\n     DUA cosh              Compute hyperbolic cosine\n     D.A div               Divide one integer by another\n     DUA exp               Compute exponential\n     DUA fabs              Compute absolute value\n     DUA floor             Get largest integral value less than\n     D.A fmod              Divide giving integral quotient and remainder\n     D.. _fpreset          Reset floating point package\n     DUA frexp             Break float into mantissa and exponent\n     DU. hypot             Compute hypotenuse of a right triangle\n     DUA labs              Find absolute value of a long\n     DUA ldexp             Builds a double from mantissa and exponent\n     D.A ldiv              Divide one long by another\n     DUA log               Compute log of a double\n     DUA log10             Compute log to the base 10 of a double\n     D?? _lrotl            Rotate a long left a specified nbr of bytes\n     D?? _lrotr            Rotate a long right a specified nbr of bytes\n     D.. matherr           handle math errors (you can write your own)\n     D?? _matherr          handle math errors\n     D?? max               Macro to get a maximum of two arguments\n     D?? min               Macro to get a minimum of two arguments\n     D?? modf              Breaks double to fractional and integer parts\n     DUA pow               Compute a number raised to a power\n     DU. pow10             Compute 10 raised to a specified power\n     DUA rand              Get a random integer 0 to 32,767,236\n     D?? random            Get random number between 0 and specified max\n     D?? randomize         Set a seed for the random number generator\n     D?? _rotl             Rotate an integer left a specified nbr bytes\n     D?? _rotr             Rotate an integer right a specified nbr bytes\n     DUA sin               Compute sine of an angle in radians\n     DUA sinh              Compute hyperbolic sine of a double\n     DUA sqrt              Compute square root of a double\n     DUA srand             Set new seed for random nbr generator\n     D.. _status87         Get the floating point status word\n     DUA tan               Compute tangent of an angle in radians\n     DUA tanh              Compute hyperbolic tangent of a double\n\n                           *** STRING MANIPULATION <string.h> ***\n\n     DU. stpcpy            Copy one string to another\n     DUA strcat            Concatenate one string to another\n     DUA strchr            Search a string for a specified character\n     DUA strcmp            Compare two strings\n     D?? strcmpi           Compare two strings ignoring case\n     DUA strcpy            Copy one string to another\n     DUA strcspn           Find 1st occur of a char one strg to another\n     DU. strdup            Create duplicate copy of a string\n     D?? strerror          Get error message for given error number\n     D.A _strerror         Get error message for last error\n     D?? stricmp           Compare two strings ignoring case\n     DUA strlen            Get length of a string\n     D?? strlwr            Convert string to lowercase\n     DUA strncat           Append chars from one string to another\n     DUA strncmp           Compare 1st n chars of two strings\n     D?? strncmpi          Compare 1st n chars of 2 strgs ignoring case\n     DUA strncpy           Copy 1st n chars of one string to another\n     D?? strnicmp          Compare 1st n chars of 2 strings ignoring case\n     D?? strnset           Set 1st n chars of a string to given character\n     DUA strpbrk           Locate 1st occur of any char one strg to other\n     DUA strrchr           Find last occur of given char in a string\n     D?? strrev            Reverse order of characters in a string\n     D?? strset            Set all characters in a string to given char\n     DUA strspn            Locate 1st char in one string not in other\n\n                           *** PROCESS CONTROL <process.h> ***\n\n     DUA strstr            Find 1st occur of one string in another\n     DUA strtok            Get tokens from a string\n     D?? strupr            Convert string to uppercase\n     DUA abort             Abort a process\n     DUA assert            Abort a process if expression is false\n     D.A atexit            Set up functions to call when process ends\n     D.. exec              Launch a child process (pass command line)\n     D.. execle            Launch a child (pass cmd line & environment)\n     D.. execlp            Launch a child (use PATH, pass cmd line)\n     D.. execlpe           Launch a child (use PATH, pass cmd line, env)\n     D.. execv             Launch a child (pass argument vector)\n     D.. execve            Launch a child (pass arg vector & environment)\n     D.. execvp            Launch child (use PATH, pass arg vector)\n     D.. execvpe           Launch child (use PATH, pass arg vect, env)\n     DU. exit              Terminate process after flushing all buffers\n     DUA _exit             Terminate process without flushing buffers\n     DUA getenv            Get definition of environment variable\n     DUA longjmp           Return by restoring a saved stack environment\n     DUA perror            Print error message for last system error\n     DU. putenv            Insert new definition into environment table\n     DUA raise             Generate a C signal (exception)\n     DUA setjmp            Save the stack environment for use by longjmp\n     D.A signal            Establish a signal handler\n     D?? spawn             Spawn child process (pass cmd line)\n     D?? spawnle           Spawn child (pass cmd line & environment)\n     D?? spawnlp           Spawn child (use PATH, pass cmd line)\n     D?? spawnlpe          Spawn child (use PATH, pass cmd line, env)\n     D?? spawnv            Spawn child (pass arg vector)\n     D?? spawnve           Spawn child (pass arg vector & env)\n     D?? spawnvp           Spawn child (use PATH, pass arg vector)\n     D?? spawnvpe          Spawn child (use PATH, pass arg vector & env)\n     DUA system            Execute an MS-DOS command\n                           *** SEARCHING AND SORTING <stdlib.h> ***\n\n     DUA bsearch           Perform binary search\n     D?? lfind             Search linearly for given keyword\n     DU. lsearch           Search linearly for a given keyword\n     DUA qsort             Use quicksort algorithm to sort an array\n\n\n                           *** SYSTEM CALLS <dos.h> ***\n\n     D.. absread           Read from logical disk sectors using int 25h\n     D.. abswrite          Write to logical disk sectors using int 26h\n     D.. allocmem          Get memory from DOS (function 48h)\n     D.. bdos              Call DOS functions using only DX and AL\n     D.. bdosptr           Call DOS functions needing pointer DS:DX\n     D.. bioscom           Access BIOS RS232C services int 14h)\n     D.. biosdisk          Access the BIOS disk services (int 13h)\n     D.. biosequip         Get equipment flag (int 11h)\n     D.. bioskey           Access BIOS keyboard services (int 16h)\n     D.. biosmemory        Get memory size in KB (int 12h)\n     D.. biosprint         Access BIOS printer services (int 17h)\n     D.. biostime          Get time of day clock (int 1Ah)\n     D.. _chmod            Change attributes of a file\n     D.. _close            Close file (DOS function 3Eh)\n     D.. _creat            Create a file - erases existing (DOS 3Ch)\n     D.. country           Get/set country dependent date/time formats\n     D.. ctrlbrk           Install a control-break handler\n     D.. delay             Wait a specified nbr milliseconds\n     D.. disable           Turn off interrupts (with CLI)\n     D.. dosexterr         Get extended error info (function 59h)\n     D.. dostounix         Convert date and time from DOS to UNIX format\n     D.. __emit__          Embed 8086 opcodes and operands in code\n     D.. enable            Enable interrupts (using STI)\n     D.. findfirst         Find 1st occur of a file (DOS 4Eh)\n     D.. findnext          Find next occurrence of file (func 4Fh)\n     D.. FP_OFF            Macro to get offset of a far pointer\n     D.. FP_SEG            Macro to get segment address of far pointer\n     D.. freemem           Free memory to DOS (function 49h)\n     D.. geninterrupt      Generate specified software interrupt\n     D.. getcbrk           Use DOS function 33h to get ctrl-brk check flag\n     D.. getcurdir         Get the current directory for specified drive\n     D.. getdate           Get date (function 2Ah)\n     D.. getdfree          Get size of free and used space on disk\n     D.. getdisk           Get current drive number (function 19h)\n     D.. getdta            Get the address of the disk transfer area\n     D.. getfat            Get file allocation table (FAT) info\n     D.. getfatd           Get FAT information for default drive\n     D.. getftime          Get modification time of file (func 57h)\n     D.. getpsp            Get segment address of Program Segment Prefix\n     D.. getswitchar       Use DOS function 37h to get current switch char\n     D.. gettime           Get time (DOS function 2Ch)\n     D.. getverify         Get current setting of VERIFY flag\n     D.. interrupt         Get address of handler for int nbr (func 35h)\n     D.. harderr           Set up a handler for critical errors\n     D.. hardresume        Return to DOS from critical error handler\n     D.. hardretn          Return to appl from critical error handler\n     D.. ioctl             Use DOS function 44h for IOCTL of device drivers\n     D.. int86             Generate 80x86 software interrupts\n     D.. int86x            Generate 80x86 software interrupts\n     D.. intdos            Generate int 21h to access DOS functions\n     D.. intdosx           Generate int 21h to access DOS functions\n     D.. intr              Generate any 80x86 software interrupt\n     D.. keep              Terminate and stay resident (DOS func 31h)\n     D.. MK_FP             Make a far pointer out of segment and offset\n     D.. nosound           Turn off the PC's speaker\n     D.. _open             Open a file (DOS function 3Dh)\n     D.. parsfnm           Parse a file name using FCB (DOS func 29h)\n     D.. peek              Get word at specified segment and offset address\n     D.. peekb             Get byte at specified segment and offset address\n     D.. poke              Copy value into word at specified address\n     D.. pokeb             Copy value into byte at specified address\n     D.. _read             Read binary data from file (func 3Fh)\n     D.. randbrd           Read records from file using FCB (DOS func 27h)\n     D.. randwr            Write records to file using FCB (DOS func 28h)\n     D.. segread           Read the segment registers\n     D.. setblock          Alter size of allocated memory (func 4Ah)\n     D.. setcbrk           Set the ctrll-brk check flg (DOS func 33h)\n     D.. setdate           Set the date (function 2Bh)\n     D.. setdisk           Set the current drive (function 0Eh)\n     D.. setdta            Set up a Disk Transfer Area for FCB file I/O\n     D.. setftime          Set the file modification time (func 57h)\n     D.. setswitchar       Use DOS function 37h to set new switch char\n     D.. settime           Set the system time (function 2Dh)\n     D.. setvect           Set up new handler for given int nbr (func 25h)\n     D.. setverify         Set the VERIFY flag\n     DU. sleep             Wait a specified number of seconds\n     D.. sound             Turn on the PC's speaker at given frequency\n     D.. unixtodos         Convert time from UNIX to DOS format\n     D.. _write            Write binary data to file (Function 40h)\n\n                           *** TIME <time.h> <dos.h>***\n\n     DUA asctime           Convert time from struct tm to string\n     D.A clock             Get elapsed processor time in clock ticks\n     DUA ctime             Convert binary time to string\n     DUA difftime          Compute difference between two times in seconds\n     DU. ftime             Get current time in a timeb struct\n     DUA gmtime            Get Greenwich Mean Time in a tm struct\n     DUA localtime         Get the local time in a tm struct\n     DU. stime             Get the system time and date\n     DUA time              Get current times as seconds since 1/1/1970\n     DU. tzset             Set global variables from env vrbl TZ\n\n          *********************************************************************\n          *                   Elementary C Programming                 APPNDXD*\n          *********************************************************************\n                              Key Codes for the IBM PC\n\n         When reading from the keyboard, normal printable ASCII characters are\n         returned as would be expected in a single character variable. When a\n         special key is pressed, however, it is returned as a 2-character\n         sequence. The first character returned is a null (\\0). This is a sign\n         that a non-ASCII key was pressed, and its scan code will be presented\n         by the next read to the keyboard. The scan code relates to the\n         physical position of the key on the keyboard. Here is a list of the\n         key codes for the IBM PC. All key code values are given in decimal.\n         When the code is a scan code for an extended key code it is shown in\n         angle brackets. See keyvalu.c for a program to obtain key values.\n\n         KEY          ALONE   WITH CTRL   WITH ALT WITH SHIFT  SHIFTED\n\n         j             106          10       <36>         74      J\n         k             107          11       <37>         75      K\n         l             108          12       <38>         76      L\n         ;(semicolon)   59           .       <39>         58      :\n         '(apostrophe)  39           .       <40>         34      \"\n         Enter          13          10       <28>         13\n         z             122          26       <44>         90      Z\n         x             120          24       <45>         88      X\n         c              99           3       <46>         67      C\n         v             118          22       <47>         86      V\n         b              98           2       <48>         66      B\n         n             110          14       <49>         78      N\n         m             109          13       <50>         77      M\n         , (comma)      44           .       <51>         60      <\n         . (period)     46           .       <52>         62      >\n         /              47           .       <53>         63      ?\n         Space          32          32         .          32\n         Up Arrow      <72>       <141>     <152>          .\n         Left Arrow    <75>       <115>     <155>          .\n         Down Arrow    <80>       <145>     <160>          .\n         Right Arrow   <77>       <116>     <157>          .\n         - (dash)       45          31      <130>         95      underscore\n         =              61           .      <131>         43      +\n         Backspace       8         127       <14>          8\n         Ins           <82>       <146>     <162>        <82>\n         Home          <71>       <119>      OS/2        <71>\n         PgUp          <73>       <132>     <153>        <73>\n         Tab             9        <148>      OS/2        <15>\n         q             113          17      <16>          81      Q\n         w             119          23      <17>          87      W\n         e             101           5      <18>          69      E\n         r             114          18      <19>          82      R\n         t             116          20      <20>          84      T\n         KEY          ALONE   WITH CTRL   WITH ALT WITH SHIFT  SHIFTED\n\n         y             121          25      <21>          89      Y\n         u             117          21      <22>          85      U\n         i             105           9      <23>          73      I\n         o             111          15      <24>          79      O\n         p             112          16      <25>          80      P\n         [ (L. Bracket) 91          27      <26>         123      { (L. Brace)\n         ] (R. Bracket) 93          29      <27>         125      } (R. Brace)\n         \\              92          28      <43>         124      | (Logic OR)\n         Del           <83>       <147>    <163>         <83>\n         End           <79>       <117>    <159>         <79>\n         PgDn          <81>       <118>    <161>         <81>\n         a              97           1      <30>          65      A\n         s             115          19      <31>          83      S\n         d             100           4      <32>          68      D\n         f             102           6      <33>          70      F\n         g             103           7      <34>          71      G\n         h             104           8      <35>          72      H\n         Esc            27         OS/2     OS/2         OS/2\n         F1            <59>        <94>    <104>         <84>\n         F2            <60>        <95>    <105>         <85>\n         F3            <61>        <96>    <106>         <86>\n         F4            <62>        <97>    <107>         <87>\n         F5            <63>        <98>    <108>         <88>\n         F6            <64>        <99>    <109>         <89>\n         F7            <65>       <100>    <110>         <90>\n         F8            <66>       <101>    <111>         <91>\n         F9            <67>       <102>    <112>         <92>\n         F10           <68>       <103>    <113>         <93>\n         F11          <133>       <137>    <139>        <135>\n         F12          <134>       <138>    <140>        <136>\n         PrtScn          .           .         .           .\n         Scroll Lock     .           .         .           .\n         Pause           .           .         .           .\n                        96           .       <41>        126      ~ (Tilde)\n         1              49           .      <120>         33      !\n         2              50          <3>     <121>         64      @\n         3              51           .      <122>         35      #\n         4              52           .      <123>         36      $\n         5              53           .      <124>         37      %\n         6              54           .      <125>         94      ^ (carat)\n         7              55           .      <126>         38      &\n         8              56           .      <127>         42      *\n         9              57           .      <128>         40      (\n         0              48           .      <129>         41      )\n         KEY          ALONE   WITH CTRL   WITH ALT WITH SHIFT  SHIFTED\n\n                        (Keypad - NumLock OFF)\n         /              47        <149>     <164>         47\n         *              42        <150>      <55>         42\n         -              45        <142>      <74>         45\n         7             <71>       <119>        7           .      Home\n         8             <72>       <141>        8           .      Up Arrow\n         9             <73>       <132>        9           .      PgUp\n         4             <75>       <115>        4           .      Left Arrow\n         5             <76>       <143>        5          53\n         6             <77>       <116>        6           .      Right Arrow\n         1             <79>       <117>        1           .      End\n         2             <80>       <145>        2           .      Down Arrow\n         3             <81>       <118>        3           .      PgDn\n         0             <82>          .         .           .      Ins\n         Del           <83>          .         .           .      . (period)\n         +              43        <144>      <78>         43\n         Enter          13          10      <166>         13\n\n                        (Keypad - NumLock ON)\n         /              47        <149>     <164>         47\n         *              42        <150>      <55>         42\n         -              45        <142>      <74>         45\n         7              55        <119>        7           .      Home\n         8              56        <141>        8           .      Up Arrow\n         9              57        <132>        9           .      PgUp\n         4              52        <115>        4           .      Left Arrow\n         5              53        <143>        5          76\n         6              54        <116>        6           .      Right Arrow\n         1              49        <117>        1           .      End\n         2              50        <145>        2           .      Down Arrow\n         3              51        <118>        3           .      PgDn\n         0              48           .         .           .      Ins\n         Del            46           .         .           .      . (period)\n         +              43        <144>      <78>         43\n         Enter          13          10      <166>         13\n\n          *********************************************************************\n          *                   Elementary C Programming                 APPNDXE*\n          *********************************************************************\n                           ANSI.SYS Screen/Cursor Control\n\n         ANSI.SYS is an optional device driver supplied with DOS that permits\n         use of \"escape sequences\" to control cursor positioning and screen\n         control. To install it, edit the CONFIG.SYS file and add the line:\n                     DEVICE=ANSI.SYS\n         then re-boot the computer. After installation, ANSI.SYS checks all\n         characters sent to the screen for special \"escape sequences\"\n         beginning with the Esc key value of hex 1B (\\x1B) followed by a left\n         bracket. The characters following the ESC and left bracket define the\n         operation to be performed. Because they are cryptic and easily mis-\n         keyed, they are often set up using #define statements so that more\n         readable names may be used in printf statements. Here are some of the\n         more common ones:\n\n         #define CLEAR \"\\x1B[2J\"\n         #define ERASE_EOL \"\\x1B[K\"\n         #define CURSOR_UP \"\\x1B[A\"\n         #define CURSOR_DOWN \"\\x1B[B\"\n         #define CURSOR_RIGHT \"\\x1B[C\"\n         #define CURSOR_LEFT \"\\x1B[D\"\n         #define POSITION_CURSOR \"\\x1B[%d;%df\"\n         #define SAVE_CURSOR_POSITION \"\\x1B[s\"\n         #define RESTORE_CURSOR \"\\x1B[u\"\n         #define CURSOR_UP_NROWS \"\\x1B[%dA\"\n         #define CURSOR_DOWN_NROWS \"\\x1B[%dB\"\n         #define CURSOR_RIGHT_NCOLS \"\\x1B[%dC\"\n         #define CURSOR_LEFT_NCOLS \"\\x1B[%dD\"\n\n\n         To use these definitions, just place them in the parameter for a\n         printf. Notice that the surrounding quotes are included in the\n         definition. Here are some examples:\n\n         printf(CLEAR);           /* clear screen, home cursor */\n         printf(ERASE_EOL);       /* erase from cursor to end of line */\n         printf(CURSOR_UP);       /* move cursor up one line */\n         printf(CURSOR_DOWN);     /* move cursor down one line */\n         printf(CURSOR_RIGHT);    /* move cursor right one column */\n         printf(CURSOR_LEFT);     /* move cursor left one column */\n         printf(POSITION_CURSOR,row,col);  /* move cursor to the row number */\n                                  /* contained in the int variable row and  */\n                                  /* the column number contained in the int */\n                                  /* variable col.                          */\n         printf(CURSOR_UP_NROWS,i); /* Move cursor up i rows */\n         printf(CURSOR_DOWN_NROWS,7); /* Move cursor down 7 rows */\n         printf(CURSOR_RIGHT_NCOLS,j); /* move cursor right j columns */\n         printf(CURSOR_LEFT_NCOLS,3); /* move cursor left 3 columns */\n\n          *********************************************************************\n          *                   Elementary C Programming                 APPNDXF*\n          *********************************************************************\n                           ANSI.SYS and Attribute Control\n\n         ANSI.SYS also contains escape sequences to permit setting screen\n         character attributes. Every character in display memory is stored as\n         a pair of bytes, one containing the character value itself, and the\n         other its attributes. Here is how to define the escape sequence for\n         setting attribute characters and the attributes themselves:\n\n         #define NORMAL    \"\\x1B[0dm\"\n         #define BOLD      \"\\x1B[1dm\"\n         #define UNDERLINE \"\\x1B[4dm\"\n         #define BLINK     \"\\x1B[5dm\"\n         #define REVERSE   \"\\x1B[7dm\"\n         #define INVISIBLE \"\\x1B[8dm\"\n\n         Once a particular attribute has been turned on, all characters\n         printed from that point on will have the specified attribute until\n         the NORMAL attribute is written to reset it. Because of this,\n         attributes can be combined by consecutively issuing them.\n\n         To use the definitions above, include them as strings in a printf\n         statement, using %s at the point where they are to become effective.\n         For example:\n\n              printf(\"Normal %s Blink %s back to normal\",BLINK,NORMAL);\n\n         will create a display line with the word Blink blinking. Since the\n         NORMAL attribute is issued after the word Blink, the remaining\n         characters will be in normal mode. To display the word WIERD as a\n         reversed video blinking field, code:\n\n              printf(\"%s %s WIERD\",BLINK,REVERSE);\n\n         Since the NORMAL attribute was not issued following this display, the\n         reversed-video-blinking will continue to be applied to all characters\n         displayed until NORMAL is re-established.\n\n          *********************************************************************\n          *                   Elementary C Programming                 APPNDXG*\n          *********************************************************************\n                             Keywords and Operators in C\n\n                              Reserved Keywords\n         int             integer data type\n         char            character data type\n         float           single precision floating point data type\n         double          double precision floating point data type\n         struct          structure data type\n         union           union data type\n         long            long integer data type\n         short           short integer data type\n         unsigned        unsigned data type modifier\n         auto            automatic data type modifier\n         extern          external data type modifier\n         register        register data type\n         typedef         creates a new data type\n         static          static data type modifier\n         goto            goto a label\n         return          return from a function\n         sizeof          returns length of an object\n         break           breaks out of a loop\n         continue        jumps back to beginning of loop\n         if              conditional statement\n         else            conditional statement\n         for             loop statement\n         do              loop statemdnt\n         while           loop statement\n         switch          process control statement\n         case            identifies a switch statement case\n         default         default processing for a switch\n         entry           Reserved, not currently used\n                      Operators in C (in precedence order)\n\n         ()  []  .  ->                groups, membership\n\n         -  ~  !  *  &                unary\n\n         ++  --  sizeof  casts        unary\n\n         *  /  %                      multiplicative\n\n         +  -                         additive\n\n         <<  >>                       shift\n\n         <  >  <=  >=                 relational\n\n         ==  !=                       equality\n\n         &                            bitwise AND\n\n         ^                            bitwise exclusive OR\n\n         |                            bitwise inclusive OR\n\n         &&                           logical AND\n\n         ||                           logical OR\n\n         ?:                           conditional\n\n         =  *=  /=  %=  +=  -=        assignment\n\n         <<=  >>=  &=  ^=  |=         assignment\n\n         ,                            series\n\n          *********************************************************************\n          *                   Elementary C Programming                hello2.c*\n          *********************************************************************\n\n          /***************************************************************/\n          /*                   hello2.c                                  */\n          /* hello2.c is version2 of the Hello, World! program           */\n          /***************************************************************/\n\n          #include <stdio.h>;              /* include standard I/O header*/\n\n          #define White 623                /* White is 623               */\n\n          int print_count(int count);      /* print_count prototype      */\n\n          char hello[] = \"hello, zorld!\\n\"; /* string with initial value */\n\n          /***************************************************************/\n          /* main function: initial program entry point                  */\n          /***************************************************************/\n\n          void main() {                    /* function header for main   */\n\n            int count = White;             /* define count = 623         */\n            char picx = 'W';               /* define picx = 'W'          */\n\n            hello[7] = picx;               /* move picx to string[7]     */\n            printf(\"%s\",hello);            /* display modified string    */\n            printf                         /* printf                     */\n                  (                           /* with                    */\n                   \"White space is ignored\\n\"    /* many                 */\n                                              )     /* imbedded          */\n                                                ;      /* spaces         */\n\n         /****************************************************************/\n         /* The printf below displays the number returned by the         */\n         /* print_count function. Notice that no variable is used on the */\n         /* right side of the parameter, but only a call to print_count. */\n         /* this is because a function call IS what it returns.          */\n         /****************************************************************/\n\n            printf(\"The print_count() function returned %d\\n\",\n                    print_count(count));   /* print print_count's return */\n         }                                 /* end of main function       */\n\n         /****************************************************************/\n         /* print_count: display value of the count field and return an  */\n         /* integer value to the caller.                                 */\n         /****************************************************************/\n\n         int print_count(int white) {   /* print_count's function header */\n\n           int ret_valu;                   /* define ret_valu            */\n\n           /**************************************************************/\n           /* The printf below displays the integer value received as a  */\n           /* parameter on entry. Note that it is passed by the caller as*/\n           /* a field called count, but is called white on entry to the  */\n           /* print_count function. Also note that the #define for White */\n           /* does not affect this, as it begins with a lower case w.    */\n           /**************************************************************/\n           printf(\"The value of the count field is: %d\\n\",white);\n\n           ret_valu = white % 600;         /* ret_valu is remainder value*/\n           return(ret_valu);               /* return ret_valu to caller  */\n        }                                  /* end of print_count function*/\n\n          *********************************************************************\n          *                   Elementary C Programming                circle.c*\n          *********************************************************************\n\n          /******************************************************************/\n          /*                         circle.c                               */\n          /* circle.c: displays area, circumference, and volume of a sphere */\n          /* when given the radius.                                         */\n          /******************************************************************/\n\n          #include <stdio.h>               /* include standard I/O header   */\n          #include <math.h>                /* include math header for float */\n\n          #define PI 3.14159               /* define PI = 3.14159           */\n\n          float area, circumference, volume; /* define global float vrbls   */\n\n          /******************************************************************/\n          /* function prototypes                                            */\n          /******************************************************************/\n          float calculate_area(double radius);\n          float calculate_circumference(double diameter);\n          float calculate_volume(double radius);\n\n          /******************************************************************/\n          /* main function: initial entry point to the program. The radius  */\n          /* of the circle of interest is expected to be typed on the       */\n          /* command line following the program name.                       */\n          /******************************************************************/\n\n          main(int argc, char *argv[]) {   /* function header for main      */\n\n            double radius;                 /* define radius                 */\n\n            if(argc != 2) {                /* got two command line strings? */\n              printf(\"Usage is: circle radius\\n\"); /* no, explain how to use*/\n              exit(1);                     /* and terminate                 */\n            }\n            radius = atof(argv[1]);        /* convert 2nd string to double  */\n\n            area = calculate_area(radius); /* compute circle area           */\n            circumference = calculate_circumference(2 * radius); /* circumf.*/\n            volume = calculate_volume(radius); /* and volume                */\n\n            printf(\"The radius given is %f\\n\",radius); /* display radius    */\n            printf(\"Area is %f\\n\",area);               /* area,             */\n            printf(\"Circumference is %f\\n\",circumference); /* circumference,*/\n            printf(\"Volume is %f\\n\",volume);           /* and volume        */\n          }                                /* end of main function          */\n\n          /******************************************************************/\n          /* calculate_area computes the area of a circle, given the radius */\n          /* and returns it to the caller as a float.                       */\n          /******************************************************************/\n          float calculate_area(double rad) { /* calculate_area function head*/\n\n            float answer;                  /* define answer field           */\n\n            answer = PI * rad * rad;       /* compute area of circle        */\n\n            return(answer);                /* return area of circle         */\n          }                                /* end calculate_area function   */\n\n          /******************************************************************/\n          /* calculate_circumference computes the circumference of a circle,*/\n          /* given the diameter.                                            */\n          /******************************************************************/\n\n          float calculate_circumference(double diameter) { /* function hdr  */\n\n            return(PI * diameter);         /* compute, return circumference */\n          }                                /* end of calcualte_circumference*/\n\n          /******************************************************************/\n          /* calculate_volume computes the volume of a sphere, given its    */\n          /* radius.                                                        */\n          /******************************************************************/\n\n          float calculate_volume(double r) { /* calculate_volume header     */\n\n            float rcubed, vol;             /* define rcubed, vol            */\n\n            rcubed = r * r * r;            /* compute rcubed                */\n            vol = (4 * rcubed) / 3;        /* compute volume of sphere      */\n            return(vol);                   /* return computed volume        */\n          }                                /* end of calcualte_volume func  */\n\n          *********************************************************************\n          *                   Elementary C Programming              tempconv.c*\n          *********************************************************************\n\n         /***************************************************************/\n         /*                         tempconv.c                          */\n         /* tempconv.c converts a celcius temperature to the equivalent */\n         /* fahrenheit temperature and displays both temperatures. The  */\n         /* celcius temperatures are contained in a table within the    */\n         /* program, and only positive temperatures produce a display.  */\n         /***************************************************************/\n\n         #include <stdio.h>              /* include standard I/O header */\n\n         #define MAX_ENTRIES 3           /* define MAX_ENTRIES = 3      */\n\n         float fahrenheit;               /* define fahrenheit           */\n         float celcius[MAX_ENTRIES] = {-12.5, 32.0, 212.0}; /* celcius  */\n         int i;                          /* define i                    */\n\n         void compute_fahrenheit(void);  /* compute_fahrenheit prototype*/\n\n\n         /***************************************************************/\n         /* main function: initial entry point for program              */\n         /***************************************************************/\n\n         void main() {\n\n           i = 0;                        /* set i to zero               */\n           if(celcius[i] > 0.0) {        /* positive celcius value?     */\n             compute_fahrenheit();          /* yes, go convert          */\n             printf(\"%f celcius = %f fahrenheit\\n\",celcius[i],fahrenheit);\n           }\n\n           i = 1;                        /* set i to one                */\n           if(celcius[i] > 0.0) {        /* positive celcius value?     */\n             compute_fahrenheit();          /* yes, go convert          */\n             printf(\"%f celcius = %f fahrenheit\\n\",celcius[i],fahrenheit);\n           }\n\n           i = 2;                        /* set i to two                */\n           if(celcius[i] > 0.0) {        /* positive celcius value?     */\n             compute_fahrenheit();          /* yes, go convert          */\n             printf(\"%f celcius = %f fahrenheit\\n\",celcius[i],fahrenheit);\n           }\n\n         }                               /* end of main function        */\n\n         /***************************************************************/\n         /* compute_fahrenheit: compute the fahrenheit equivalent to a  */\n         /* celcius temperature.                                        */\n         /***************************************************************/\n\n         void compute_fahrenheit(void) {  /* compute_fahrenheit header  */\n           /*************************************************************/\n           /* The calculation below computes the fahrenheit equivalent  */\n           /* of a celcius temperature as:                              */\n           /*    fahrenheit = (9/5 * celcius) + 32                      */\n           /*************************************************************/\n           fahrenheit = ((((celcius[i]) * 9) / 5) + 32);\n         }                               /* end of compute_fahrenheit   */\n\n          *********************************************************************\n          *                   Elementary C Programming              loadstrg.c*\n          *********************************************************************\n\n          /******************************************************************/\n          /*                        loadstrg.c                              */\n          /* loadstrg.c reads up to 100 character strings from the keyboard */\n          /* into memory, then displays them after the last one is entered. */\n          /******************************************************************/\n\n          #include <stdio.h>                 /* include standard I/O header */\n          #include <stdlib.h>                /* include standard lib header */\n          #include <string.h>                /* include string header       */\n\n          /******************************************************************/\n          /* main function: initial entry point to the program. reads the   */\n          /* strings into storage areas obtained individually for each one. */\n          /* After the last string (user presses enter with no data), all   */\n          /* the stored strings are displayed.                              */\n          /******************************************************************/\n\n          main() {                           /* function header for main    */\n\n            char *p[101];                    /* p is array of ptrs to chars */\n            int i,l;                         /* define work subscripts      */\n            char string[80];                 /* define work string          */\n\n            for(i=0;i<100;i++) {             /* loop for up to 100 strings  */\n              gets(string);                    /* read string into work area*/\n              if(!(l = strlen(string))) break; /* if null string, break loop*/\n              *(p+i) = (char *)malloc(l+1);    /* else get storage to hold  */\n              strcpy(*(p+i),string);           /* and copy string to storage*/\n            }\n\n            *(p+i) = 0;                      /* 0 = end of array pointers   */\n\n            for(i=0;i<100;i++) {             /* loop to display strings     */\n              if(!p[i]) break;                  /* if end of table, break   */\n              printf(\"%s\\n\",*(p+i));            /* else display the string  */\n            }\n          }                                  /* end of main function        */\n\n          *********************************************************************\n          *                   Elementary C Programming               struct9.c*\n          *********************************************************************\n\n          /******************************************************************/\n          /*                       struct9.c                                */\n          /* struct9.c is an exercise in the use of structures and          */\n          /* unions.                                                        */\n          /******************************************************************/\n\n          #include <stdio.h>         /* include standard I/O header         */\n          #include <stdlib.h>        /* include standard library header     */\n          #include <string.h>        /* include string header               */\n\n          /******************************************************************/\n          /* main function: initial entry point to the program.             */\n          /******************************************************************/\n\n          void main() {              /* function header for main            */\n\n            struct {                 /* define a structure                  */\n              int emp_nbr;\n              char last_name[12];\n              char pay_grade;\n              union {                   /* which contains a union           */\n                struct {                   /* which includes a structure,   */\n                  float hours_worked;\n                  float hourly_rate;\n                } hourly;\n                float annual_salary;       /* and a float                   */\n              } pay_data;                  /* union name is pay_data        */\n            } emp[12];               /* structure array name is emp         */\n\n            int i,a;                 /* define work integers                */\n            char string[80];         /* define work string                  */\n\n            for(i=0;i<12;i++) {      /* loop to clear out all emp elements  */\n              emp[i].emp_nbr = 0;\n              emp[i].last_name[0] = '\\0';\n              emp[i].pay_grade = 'h';\n              emp[i].pay_data.hourly.hours_worked = 0.0;\n              emp[i].pay_data.hourly.hourly_rate = 0.0;\n            }\n\n            for(i=0;i<12;i++) {      /* loop to build emp elements          */\n              printf(\"\\nEnter emp_nbr for #%d: \",i+1); /* ask for emp_nbr   */\n              gets(string);                            /* read it to string */\n              emp[i].emp_nbr = atoi(string);           /* and convert to int*/\n              if(!(emp[i].emp_nbr)) break;  /* if emp_nbr is zero, break out*/\n              printf(\"\\nEnter last name: \");   /* ask for last name         */\n              gets(string);                    /* read last name into string*/\n              string[11] = '\\0';               /* truncate to 11 byte name  */\n              strcpy(emp[i].last_name,string); /* copy last name to element */\n              printf(\"\\nEnter pay grade, h if hourly, s if salaried: \");\n              emp[i].pay_grade = getche();    /* read pay grade into element*/\n              /**************************************************************/\n              /* if pay_grade is for hourly, ask for, read in, convert, and */\n              /* put into the element the hourly rate and hours worked.     */\n              /**************************************************************/\n              if(emp[i].pay_grade == 'h') {\n                printf(\"\\nEnter hourly rate, dollars and cents: \");\n                gets(string);\n                emp[i].pay_data.hourly.hourly_rate = atof(string);\n                printf(\"\\nEnter hours worked with 2 decimal places: \");\n                gets(string);\n                emp[i].pay_data.hourly.hours_worked = atof(string);\n              }\n              /**************************************************************/\n              /* if pay_grade is not for hourly, assumption is that it is   */\n              /* for salaried. Ask for, read in, convert, and move annual   */\n              /* salary to the array element.                               */\n              /**************************************************************/\n              else {\n                printf(\"\\nEnter annual salary, dollars and cents: \");\n                gets(string);\n                emp[i].pay_data.annual_salary = atof(string);\n              }\n            }\n          }                                   /* end of main function       */\n\n          *********************************************************************\n          *                   Elementary C Programming                menu10.c*\n          *********************************************************************\n\n\n          /******************************************************************/\n          /*                         menu10.c                               */\n          /* menu10.c displays a menu asking the user for an a, s, m, or d  */\n          /* as a request to add, subtract, multiply, or divide two numbers.*/\n          /* Four functions handle each type of request, each asking for the*/\n          /* numbers, reading the numbers from the keyboard, performing the */\n          /* keyboard, performing the arithmetic, and displaying results.   */\n          /******************************************************************/\n\n                               /**********************/\n          /********************* header file includes ***********************/\n                               /**********************/\n          #include <stdio.h>\n          #include <math.h>\n\n                               /**********************/\n          /*********************       defines        ***********************/\n                               /**********************/\n          #define CLEAR \"\\x1B[2J\"\n\n                               /**********************/\n          /*********************  global data fields  ***********************/\n                               /**********************/\n          float num1,num2;\n          float sum,difference,product,quotient,remainder;\n          char string[80];\n          unsigned char c;\n\n                               /**********************/\n          /********************* function prototypes  ***********************/\n                               /**********************/\n          void add_numbers(void);\n          void subtract_numbers(void);\n          void multiply_numbers(void);\n          void divide_numbers(void);\n\n                                /*********************/\n          /*********************     main function    ***********************/\n          /*** display menu, read request and call appropriate function *****/\n             /**********************************************************/\n          void main() {\n            c = ' ';\n            while((c != 'q') & (c != 'Q')) {                /* display menu */\n\n              printf(CLEAR);\n              printf(\"\\n\\n\\n\\n        A = add numbers\");\n              printf(\"\\n\\n        S = subtract numbers\");\n              printf(\"\\n\\n        M = multiply numbers\");\n              printf(\"\\n\\n        D = divide numbers\");\n              printf(\"\\n\\n        Q = quit\");\n              printf(\"\\n\\n            \");\n\n              switch(c=getch()) {                           /* read request */\n                case 'q':\n                case 'Q':\n                  break;\n                case 'a':\n                case 'A':\n                  add_numbers();\n                  break;\n                case 's':\n                case 'S':\n                  subtract_numbers();\n                  break;\n                case 'm':\n                case 'M':\n                  multiply_numbers();\n                  break;\n                case 'd':\n                case 'D':\n                  divide_numbers();\n                  break;\n              }\n            }\n          }\n\n                                /**********************/\n          /*********************  add_numbers function **********************/\n          /************* add two numbers and display the sum ****************/\n                       /*************************************/\n          void add_numbers() {\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            sum = num1 + num2;\n            printf(\"\\n\\n\\n        %f + %f = %f\",num1,num2,sum);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n                            /****************************/\n          /******************  subtract_numbers function ********************/\n          /******** subtract two numbers and display the difference *********/\n                  /*************************************************/\n          /* subtract two numbers and display the difference */\n          void subtract_numbers(void) {\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            difference = num1 - num2;\n            printf(\"\\n\\n\\n        %f - %f = %f\",num1,num2,difference);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n                             /***************************/\n          /******************* multiply_numbers function ********************/\n          /******** multiply two numbers and display the product ************/\n                  /**********************************************/\n          /* multiply two numbers and display the product */\n          void multiply_numbers(void) {\n\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            product = num1 * num2;\n            printf(\"\\n\\n\\n        %f * %f = %f\",num1,num2,product);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n                                /**********************/\n          /********************  divide_numbers function ********************/\n          /********* divide two numbers and display the quotient ************/\n                   /*********************************************/\n          /* divide two numbers and display the quotient and remainder */\n          void divide_numbers(void) {\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            quotient = num1 / num2;\n            printf(\"\\n\\n\\n        %f / %f = %f\",num1,num2,quotient);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n          *********************************************************************\n          *                   Elementary C Programming               dumphex.c*\n          *********************************************************************\n\n        /******************************************************************/\n        /*                         dumphex.c                              */\n        /* dumphex.c displays and optionally prints the content of a file */\n        /* in hex and character, 16-bytes per line. user specifies the    */\n        /* name of the file to dump on the command line.                  */\n        /******************************************************************/\n\n        #include <stdio.h>               /* include standard I/O header   */\n        #include <stdlib.h>              /* include standard lib header   */\n\n        /******************************************************************/\n        /* main function: on entry the number of command line arguments   */\n        /* is available in argc, while argv is an array of strings, which */\n        /* contains the command line arguemnts. The first command line    */\n        /* string ([0]) is always the program name.                       */\n        /******************************************************************/\n\n        void main(int argc, char *argv[]) {\n\n        /******************************************************************/\n        /*               define global work fields                        */\n        /******************************************************************/\n        char prntlin[68];                     /* print line */\n        unsigned char ch;                     /* character work field */\n        unsigned char prtsw='\\0';             /* print switch */\n        unsigned int j,l,row=0;               /* work fields */\n        int i,k;                              /* work fields */\n        unsigned long bytno=0,tot=0;          /* work fields */\n\n        /******************************************************************/\n        /*               function prototypes                              */\n        /******************************************************************/\n        void atox(unsigned char, char[], char[]);  /* function prototype */\n\n        /******************************************************************/\n        /*               FILE pointer definitions                         */\n        /******************************************************************/\n        FILE *infil,*outfil;                  /* FILE pointers */\n\n        /******************************************************************/\n        /*        end of data definitions, begin processing               */\n        /******************************************************************/\n\n        prntlin[0]='\\n';                      /* put newline in print line */\n        prntlin[67]='\\0';                     /* insure valid string */\n\n        /*******************************************************************/\n        /* If command line has two strings (1=\"dumphex\", 2=filename), open */\n        /* the input file, otherwise display the proper syntax to use and  */\n        /* terminate the program.                                          */\n        /*******************************************************************/\n\n        if(argc!=2) {\n            printf(\"\\nSYNTAX: dumphex [d:][\\path\\]filename[.ext]\");\n            exit(1);\n        }\n        if((infil=fopen(argv[1],\"rb\"))==NULL) {\n            printf(\"\\nCan't open the input file, %s\",argv[1]);\n            exit(1);\n        }\n\n        /*******************************************************************/\n        /* Ask user if the file dump is to be printed or only displayed on */\n        /* the screen. If print is requested, set the print switch and open*/\n        /* the print file and print a header line.                         */\n        /*******************************************************************/\n\n        printf(\"\\nDo you want to print the file (y/n): \");\n        while((prtsw!='y')&&(prtsw!='n'))\n            prtsw=getche();\n        if(prtsw=='n')\n            prtsw='\\0';\n        if(prtsw)\n            if((outfil=fopen(\"prn\",\"w\"))==NULL) {\n                printf(\"\\nCan't open the printer file.\");\n                exit(0);\n            }\n            else {\n                fputs(\"\\n     ***** Hex/Character Dump of: \",outfil);\n                fputs(argv[1],outfil);\n                fputs(\" *****\\n\",outfil);\n            }\n        /*******************************************************************/\n        /* Build a line of print containing the offset from the beginning  */\n        /* of the file, 8 groups of 2 hex bytes each, and the printable    */\n        /* ASCII characters for them.                                      */\n        /*******************************************************************/\n        do {\n            for(i=1;i<67;i++)        /* pre-clear the print */\n            prntlin[i]=' ';              /* line to blanks */\n            /***************************************************************/\n            /* Calculate and print the file offset in hex at left of line. */\n            /***************************************************************/\n            ch=bytno/65536;\n            atox(ch,&prntlin[1],&prntlin[2]);\n            ch=(bytno%65536)/256;\n            atox(ch,&prntlin[3],&prntlin[4]);\n            ch=bytno%256;\n            atox(ch,&prntlin[5],&prntlin[6]);\n            bytno+=16;\n            /***************************************************************/\n            /* Read characters from the file and copy them into the        */\n            /* printable character portion of the print line (positions    */\n            /* 52-67).                                                     */\n            /***************************************************************/\n            i=51;\n            while((i<67)&&(k=getc(infil))!=EOF) {\n                prntlin[i++]=k;\n                tot+=1;\n            }\n            /***************************************************************/\n            /* Convert the characters in print line positions 52-67 to hex */\n            /* (2 hex digits per character) and use the hex digits to make */\n            /* eight groups of 2-bytes (4 print positions). Single spaces  */\n            /* are placed between each group of 2 bytes with a double space*/\n            /* in the center.                                              */\n            /***************************************************************/\n            for(j=51,l=9;j<i;j++) {\n                atox(prntlin[j],&prntlin[l],&prntlin[l+1]);\n                l+=2;\n                if(l==13||l==18||l==23||l==34||l==39||l==44)\n                    l+=1;\n                if(l==28)\n                    l+=2;\n            }\n            /***************************************************************/\n            /* Scan the character area of the print line (positions 52-67) */\n            /* and replace non-printable characters with periods.          */\n            /***************************************************************/\n            for(j=51;j<i;j++)\n                if((prntlin[j]<' ')||(prntlin[j]>'z'))\n                    prntlin[j]='.';\n            /***************************************************************/\n            /* Display the line on the screen. If the print switch is on,  */\n            /* print it, too. Check to see if we are at the bottom of the  */\n            /* screen. If so, ask the user whether to continue or to quit. */\n            /***************************************************************/\n            printf(\"%s\",prntlin);\n            if(prtsw)\n                fputs(prntlin,outfil);\n            row += 1;                       /* increment row counter */\n            if(row >= 22) {                 /* if end of screen: */\n                row = 0;                        /* reset row counter */\n                printf(\"\\nEnter Q to quit or press ENTER to continue: \");\n                ch = getchar();                 /* get response */\n                if((ch == 'q') || (ch == 'Q'))\n                    exit(1);                /* quit if Q entered */\n            }\n        }\n        while(k!=EOF);                      /* end of d... while */\n\n        /*******************************************************************/\n        /* End of file to be dumped. Print totals, close files, and        */\n        /* terminate normally.                                             */\n        /*******************************************************************/\n\n        printf(\"\\n\\nTotal bytes in file = %d.\\n\",tot);\n        if(prtsw) {\n            fputs(\"\\n\\nTotal bytes in file = \",outfil);\n            itoa(tot,prntlin,10);\n            fputs(prntlin,outfil);\n            fputs(\"\\n\\n\\n\",outfil);\n            fclose(outfil);\n        }\n        fclose(infil);\n        }\n\n        /******************************************************************/\n        /* function to convert a character to two printable hex digits    */\n        /******************************************************************/\n\n        void atox(unsigned char ch,  char *hi, char *lo) {\n\n            char hextbl[]=\"0123456789ABCDEF\";\n            *hi=hextbl[ch/16];      /* convert high-order hex digit */\n            *lo=hextbl[ch%16];      /* convert low-order hex digit */\n        }\n\n          *********************************************************************\n          *                   Elementary C Programming              skeleton.c*\n          *********************************************************************\n\n         /*******************************************************************/\n         /*                     skeleton.c                                  */\n         /*                                                                 */\n         /* generic c program that includes an input file, output file,     */\n         /* print file, and common processing functions:                    */\n         /*  main       = executive routine: overall program control        */\n         /*  mainline   = mainline processing control                       */\n         /*  initialize = open files, set up headers and call headings      */\n         /*  readrec    = read input file records and count them            */\n         /*  writerec   = write output file records and count them          */\n         /*  printline  = print detail, clear print line, call headings     */\n         /*  headings   = print heading lines for new page                  */\n         /*  edit       = edit numbers with commas, decimal points, etc     */\n         /*  terminate  = close files, print totals, stop execution         */\n         /*                                                                 */\n         /*                                                                 */\n         /* Author R Thornton September 1993                                */\n         /*******************************************************************/\n\n         #include <stdio.h>\n         #include <stdlib.h>\n         #include <time.h>\n\n         void initialize(int argc, char *argv[]);  /* initialization func   */\n         void mainline(void);                  /* mainline function         */\n         void terminate(void);                 /* termination function      */\n         void readrec(void);                   /* read next input file rec  */\n         void writerec(void);                  /* write record to out file  */\n         void printline(void);                 /* print a line to rept file */\n         int edit(char output[], char pattern[], char number[]); /* edit fnc*/\n         void headings(void);                  /* print report heading      */\n\n         FILE *infile, *outfile, *prtfile;     /* file handle pointers      */\n\n         char innam[81];                       /* input file name           */\n         char outnam[81];                      /* output file name          */\n         char prtnam[81] = \"prn\";              /* print file name           */\n\n         char prtline[135];                    /* print line buffer         */\n         char inrecord[256];                   /* input file record area    */\n         char outrecord[256];                  /* output file record area   */\n\n         char *h1ptr;                          /* heading line 1 pointer    */\n         struct {                              /* first heading line        */\n           char hdr_skip;                        /* form feed               */\n           char hdr_date[10];                    /* report date             */\n           char ctr1[45];                        /* centering blanks        */\n           char title_line[21];                  /* centered report title   */\n           char ctr2[45];                        /* centering blanks        */\n           char page_lit[5];                     /* page literal            */\n           char page_nbr[6];                     /* page number             */\n           char newline;                         /* newline character       */\n           char null_byte;                       /* terminating null        */\n         } header1;\n\n         int i;                                /* general purpose int       */\n         char number[32];                      /* ascii numbers for edit()  */\n         int morerecs = -1;                    /* input end-of-file switch  */\n         long incount = 0;                     /* input record counter      */\n         long outcount = 0;                    /* output record counter     */\n         int linecnt = 0;                      /* print line counter        */\n         int pagecnt = 0;                      /* print page counter        */\n         struct tm *t;                         /* pointer to time structure */\n         time_t seconds;                       /* current timer value       */\n\n         /*******************************************************************/\n         /* executive routine: overall program control                      */\n         /*******************************************************************/\n         void main(int argc, char *argv[]) {\n            initialize(argc, argv);            /* open files                */\n            while(morerecs)                    /* perform mainline until    */\n               mainline();                     /* no more records           */\n            terminate();                       /* close files               */\n            exit(0);                           /* quit                      */\n         }\n         /*******************************************************************/\n         /* mainline function: process input file until no more records.    */\n         /*******************************************************************/\n         void mainline(void) {\n            strcpy(prtline,inrecord);          /* move input record to print*/\n            printline();                       /* and print it              */\n            strcpy(outrecord,inrecord);       /* move input record to output*/\n            writerec();                        /* write an output record    */\n            readrec();                         /* read next input record    */\n         }\n         /*******************************************************************/\n         /* initialization: open files, read first input record.            */\n         /*******************************************************************/\n         void initialize(int argc, char *argv[]) {\n           if(argc == 3) {                     /* if two filenames given:   */\n             strcpy(&innam,argv[1]);             /* 1st is input filename   */\n             strcpy(&outnam,argv[2]);            /* 2nd is output filename  */\n           }\n           else\n             if(argc == 4) {                   /* if three filenames given: */\n               strcpy(&innam,argv[1]);           /* 1st is input filename   */\n               strcpy(&outnam,argv[2]);          /* 2nd is output filename  */\n               strcpy(&prtnam,argv[3]);          /* 3rd is print file name  */\n             }\n             else {                            /* if neither 2 nor 3 given: */\n               printf(\"\\nEnter input file spec: \"); /* ask for input filenam*/\n               gets(innam);                         /* and read it in       */\n               printf(\"\\nEnter output file spec: \"); /* ask for output filen*/\n               gets(outnam);                        /* and read it in       */\n               printf(\"\\nEnter output file spec (or prn): \"); /* ask for prt*/\n               gets(prtnam);                        /* and read it in       */\n             }\n           if((infile=fopen(innam,\"rb\")) == NULL) { /* open input           */\n             printf(\"Can't open file %s.\",innam);   /* open failed message  */\n             exit(1);                               /* terminate            */\n           }\n           if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output        */\n             printf(\"Can't open file %s.\",outnam);\n             exit(1);\n           }\n           if((prtfile=fopen(prtnam,\"w\"))==NULL) { /* open print file       */\n             printf(\"\\nCan't open the printer file.\"); /* open failed msg   */\n             exit(1);                                  /* terminate         */\n           }\n           h1ptr = (char *)&header1;               /* point to header1 line */\n           for(i=0;i<133;i++)                      /* clear header line     */\n             h1ptr[i] = ' ';                         /* to all spaces       */\n           header1.hdr_skip = '\\f';              /* form feed to header line*/\n           memcpy(header1.title_line,\"SKELETON REPORT TITLE\",21); /* copy hd*/\n           timezone = 5 * 60 * 60;               /* set local time for e.s.t*/\n           daylight = -1;                        /* indicate daylit sav time*/\n           time(&seconds);                       /* time in secs            */\n           t = localtime(&seconds);              /* local time to tm struct */\n           sprintf(header1.hdr_date,\"%2d\\/%2d\\/%2d\",\n                                       t->tm_mon,t->tm_mday,t->tm_year);\n           header1.hdr_date[8] = ' ';            /* clear terminating null  */\n           memcpy(header1.page_lit,\"PAGE \",5);   /* PAGE literal to header  */\n           prtline[133] = '\\0';                 /* terminal null to prt line*/\n           headings();                           /* write first heading     */\n           readrec();                        /* read first input file record*/\n         }\n         /*******************************************************************/\n         /* read next input file record. at end of file, set morerecs switch*/\n         /*******************************************************************/\n         void readrec() {\n           if(fgets(inrecord,255,infile) == NULL) /* read input until eof   */\n             morerecs = 0;                      /* set switch at end of file*/\n           if(morerecs)                           /* if not at end of file  */\n           incount++;                               /* add 1 to records read*/\n         }\n         /*******************************************************************/\n         /* write a record to the output file                               */\n         /*******************************************************************/\n         void writerec() {\n           fputs(outrecord,outfile);             /* write output record     */\n           outcount++;                           /* add 1 to records written*/\n         }\n         /*******************************************************************/\n         /* write a line to the printer                                     */\n         /*******************************************************************/\n         void printline() {\n           prtline[133] = '\\n';            /* terminal newline to print line*/\n           prtline[134] = '\\0';            /* terminal null to print line   */\n           fputs(prtline,prtfile);         /* write print line              */\n           linecnt++;                      /* add 1 to line counter         */\n           if(linecnt > 56)                /* if end of page                */\n             headings();                     /* write heading lines         */\n           else                            /* otherwise                     */\n             for(i=0;i<133;i++)              /* clear print line            */\n               prtline[i] = ' ';               /* to all spaces             */\n         }\n         /*******************************************************************/\n         /* write a report heading                                          */\n         /*******************************************************************/\n         void headings() {\n           linecnt = 0;                      /* clear line counter          */\n           pagecnt++;                        /* add 1 to page counter       */\n           sprintf(number,\"%d\",pagecnt);     /* convert to printable nbr    */\n           edit(header1.page_nbr,\"zz,zz9\",number); /* page nbr to hdr line  */\n           header1.newline = '\\n';           /* terminal newline to hdr     */\n           header1.null_byte = '\\0';         /* terminal null to header     */\n           fputs((char *)&header1,prtfile);  /* write header line           */\n           for(i=0;i<133;i++)                /* clear print line            */\n             prtline[i] = ' ';                 /* to all spaces             */\n           prtline[133] = '\\n';              /* ending newline to print line*/\n           prtline[134] = '\\0';              /* terminal null to print line */\n           fputs(prtline,prtfile);           /* blank line after heading    */\n         }\n\n         /*******************************************************************/\n         /* The edit function provides numeric report editing, including    */\n         /* leading zero suppression, check protection, floating $, leading */\n         /* or trailing minus sign, insertion of commas, decimal points and */\n         /* other non-numeric fields. The first parameter is the address of */\n         /* the edited output, whose size will be the same as the pattern.  */\n         /* The second parameter is the editing pattern which must be a true*/\n         /* null-terminated string containing the edit pattern. The third   */\n         /* is the number to be edited, a null-terminated string containing */\n         /* only digits 0-9 except the first position, which is a -, if the */\n         /* number is negative. The pattern may be up to 64 characters, and */\n         /* the number to be edited may contain up to 32 characters. The    */\n         /* number may not contain more significant digits than there are   */\n         /* digit select characters in the pattern. If there are more digits*/\n         /* selected by the pattern than there are in the number, leading   */\n         /* zeros will be assumed. In the pattern, the first character may  */\n         /* be:      $ (floating dollar sign)                               */\n         /*          * (check protection)                                   */\n         /*          - (floating minus sign)                                */\n         /* The body of the edit pattern will be composed of digit select   */\n         /* characters (z and 9) and other characters, handled as follows:  */\n         /*          z (zero suppression output is a blank in this position */\n         /*             until significance is set by receipt of a significan*/\n         /*             digit or a 9 in the pattern. After significance is  */\n         /*             set, output is a digit from the number.)            */\n         /*          9 (output is a digit from the number and significance  */\n         /*             is set, even if the digit is a leading zero.)       */\n         /*        other characters in the pattern will be output as-is afte*/\n         /*             significance is set, but will be output as blanks   */\n         /*             before significance is set.                         */\n         /* Characters in the pattern following the last digit select will  */\n         /* be output as-is if the number is negative, otherwise output will*/\n         /* be blanks for these pattern positions.                          */\n         /*                                                                 */\n         /* When * check protection is selected, output will be *, rather   */\n         /* than blanks as mentioned above.                                 */\n         /*                                                                 */\n         /* An integer is returned to indicate success or errors:           */\n         /*                 0 = successful edit                             */\n         /*                 1 = pattern too long (over 64 characters)       */\n         /*                 2 = too many digits selected (over 32)          */\n         /*                 3 = no output digits selected in pattern        */\n         /*                 4 = number contains non-numeric data            */\n         /*                 5 = number has more digits than the pattern     */\n         /*                                                                 */\n         /* Examples:                            nbr=             outf=     */\n         /*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00 */\n         /*                                      123                   1.23 */\n         /*                                      562983            5,629.83 */\n         /*                                      -4675                46.75-*/\n         /*    err=edit(outf,\"$,$$$.$$\",nbr);    0                          */\n         /*                                      123                  $1.23 */\n         /*                                      562983           $5,629.83 */\n         /*                                      -4675               $46.75 */\n         /*    err=edit(outf,\"***.**\",nbr);      0                          */\n         /*                                      123                 **1.23 */\n         /*                                      562983   err = 5           */\n         /*                                      -4675               *46.75 */\n         /*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00 */\n         /*                                      123                   1.23 */\n         /*                                      562983            5,629.83 */\n         /*                                      -46.75              -46.75 */\n         /*                                                                 */\n         /* Author R Thornton April 1989                                    */\n         /*******************************************************************/\n         /**/\n         int edit(char output[], char pattern[], char number[]) {\n           char float_val = ' ';\n           char fill_val = ' ';\n           char sign_val = ' ';\n           int signif = 0;\n           int psize = 0;\n           int pdig = 0;\n           int plast = 0;\n           int ndig = 0;\n           char nbr[33];\n           char ch= ' ';\n           int po=0;\n           int n=0;\n\n         /*******************************************************************/\n         /* examine pattern: set up float and fill, count size and digits   */\n         /*******************************************************************/\n           if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n             float_val = ch;\n           if(ch == '*')\n             fill_val = '*';\n           while((ch=pattern[po]) != '\\0') {\n            if((ch == 'z') || (ch == '9')) {\n               pdig++;\n               plast = po;\n             }\n             psize++;\n             po++;\n           }\n           if(psize > 63)\n             return(1);\n           if(pdig > 32)\n             return(2);\n           if(!pdig)\n             return(3);\n\n         /*******************************************************************/\n         /* examine number: set up sign, count digits, check numeric.       */\n         /* set error if more digits than pattern, move right justified     */\n         /*******************************************************************/\n           if(number[0] == '-') {\n             sign_val = '-';\n             n = 1;\n           }\n           while((ch=number[n]) != '\\0') {\n             if((ch < '0') || (ch > '9'))\n               return(4);\n             ndig++;\n             n++;\n           }\n           if(ndig > pdig)\n             return(5);\n           for(po=0;po<(pdig-ndig);po++)\n             nbr[po] = '0';\n           if(sign_val == ' ')\n             n = 0;\n           else\n             n=1;\n           for(;po<pdig;po++,n++)\n             nbr[po] = number[n];\n\n         /********************************************************************/\n         /* scan across the pattern, setting the corresponding output        */\n         /* byte from pattern, fill, or amt depending on the pattern         */\n         /* character and state of significance.                             */\n         /********************************************************************/\n           if(float_val != ' ') {\n             output[0] = ' ';\n             po = 1;\n           }\n           else\n             po = 0;\n           n = 0;\n           while((po <= plast)) {\n             ch = pattern[po];\n             if(ch == 'z') {\n               if(signif) {\n                 output[po] = nbr[n];\n                 n++;\n               }\n               else {\n                 if(nbr[n] == '0') {\n                   output[po] = fill_val;\n                   n++;\n                 }\n                 else {\n                   output[po] = nbr[n];\n                   signif = -1;\n                   n++;\n                   if(float_val == ' ')\n                     ;\n                   else\n                     if((float_val == '$') || (sign_val == '-'))\n                       output[po-1] = float_val;\n                 }\n               }\n             }\n             else if(ch == '9') {\n               output[po] = nbr[n];\n               if(!signif) {\n                 signif = -1;\n                 if(float_val == ' ')\n                   ;\n                 else\n                   if((float_val == '$') || (sign_val == '-'))\n                     output[po-1] = float_val;\n               }\n               n++;\n             }\n             else {\n               if(signif)\n                 output[po] = pattern[po];\n               else\n                 output[po] = fill_val;\n             }\n             po++;\n           }\n           while((ch=pattern[po]) != '\\0') {\n             if(sign_val == ' ')\n               output[po++] = fill_val;\n             else\n               output[po++] = pattern[po];\n           }\n           return(0);\n         }\n\n         /*******************************************************************/\n         /* termination: close files                                        */\n         /*******************************************************************/\n         void terminate() {\n           sprintf(number,\"%ld\",incount);    /* convert input count to ascii*/\n           edit(prtline, \"zz,zzz,zz9\", number); /* edit number to prtline   */\n           strcpy(prtline+10,\" input records read\"); /* message to prt      */\n           printline();                      /* print count                 */\n           sprintf(number,\"%ld\",outcount);   /* convert input count to ascii*/\n           edit(prtline, \"zz,zzz,zz9\", number); /* edit number to prtline   */\n           strcpy(prtline+10,\" output records written\"); /* message to prt  */\n           printline();                      /* print count                 */\n           fclose(infile);                   /* close input file            */\n           fclose(outfile);                  /* close output file           */\n           fclose(prtfile);                  /* close print file            */\n         }\n\n          *********************************************************************\n          *                   Elementary C Programming               binsrch.c*\n          *********************************************************************\n\n          /****************************************************************/\n          /*          binsrch.c: a binary file search function            */\n          /* caller supplies:                                             */\n          /*    (1) a pointer to the FILE to be searched (must be OPEN).  */\n          /*    (2) a pointer to the key argument used for the search.    */\n          /*    (3) length of each record in the file (int).              */\n          /*    (4) length of the key in the records (int).               */\n          /*    (5) relative position of the key in the record (int, 0+). */\n          /*    (6) a pointer to the callers record return area.          */\n          /* function returns:                                            */\n          /*    (1) an int whose value is -1 if the record is found or    */\n          /*        0 of it is not found.                                 */\n          /*    (2) the record found, if the search was successful.       */\n          /*                                                              */\n          /* Author R Thornton, October, 1993                             */\n          /****************************************************************/\n          #include <stdio.h>\n\n          int binsrch( FILE *rf, char *arg_key, int recdleng, int keyleng,\n                       int keyloc, char *record ) {\n\n            long int file_size;             /* file length in bytes */\n            long int max_slots;             /* number records in file */\n            long int curr_slot  = 0;        /* current record slot number */\n            long int curr_offset = 0;       /* current offset increment */\n            long int file_offset;           /* computed file offset */\n            int      compare = 0;           /* current compare indicator */\n            int      result = 0;            /* result indicator */\n\n            result = 0;                     /* set up for not found */\n            if(fseek(rf,0,SEEK_END) != 0)   /* set file pointer to end of file *\n/\n              return(result);               /* terminate if error */\n            if((file_size = ftell(rf)) == -1L) /* get file size in bytes */\n              return(result);               /* terminate if error */\n            max_slots = file_size / recdleng;  /* compute number records in file\n */\n            curr_slot = 0;                 /* set initial slot number */\n            curr_offset = max_slots - 1;   /* set initial offset increment */\n            compare = -1;                  /* set compare for low */\n            while(curr_offset != 1) {\n              curr_offset ++;              /* add 1 to insure rounding high */\n              curr_offset /= 2;            /* offset / 2 (rounded high */\n              if(compare < 0) {            /* if last key read was low */\n                curr_slot += curr_offset;     /* add offset increment */\n                if(curr_slot >= max_slots) {  /* if result past end of file */\n                  compare = 1;                   /* set compare to high */\n                  continue;                      /* and continue to while */\n                }\n                else ;\n              }\n              else {                       /* if last key read was high */\n                curr_slot -= curr_offset;     /* subtract offset increment */\n                if(curr_slot < 0) {           /* if result prior to 1st slot */\n                  compare = -1;                  /* set compare to low */\n                  continue;                      /* and continue to while */\n                }\n                else ;\n              }\n              file_offset = curr_slot * recdleng;   /* compute file offset */\n              if((fseek(rf,file_offset,0)) != 0)    /* position in file */\n                break;                              /* terminate if error */\n              fread(record,recdleng,1,rf);          /* read the record */\n              if((compare=memcmp(record+keyloc,arg_key,keyleng)) == 0) { /* foun\nd? */\n                result = -1;\n                break;                                          /* yes, quit */\n              }\n            }\n            return(result);\n          }\n\n          *********************************************************************\n          *                   Elementary C Programming              genldat2.c*\n          *********************************************************************\n\n          /*****************************************************************/\n          /*                         genldat2.c                            */\n          /* This function provides the caller with a table of information */\n          /* concerning a specified date. The caller places a date in one  */\n          /* of the Julian or Gregorian fields of the DATEGENL structure   */\n          /* and an indicator of the type date sent in the datyp field, and*/\n          /* invokes genldat2(), which fills in all the remaining fields in*/\n          /* the DATEGENL structure. A pointer to DATEGENL is passed to    */\n          /* this function by the caller.                                  */\n          /*****************************************************************/\n\n          #include <string.h>\n\n          struct DATEGENL {\n            enum {\n              julian_yyyyddd_sent = 'j',\n              gregorian_mmddyyyy_sent = 'g',\n              gregorian_yyyymmdd_sent = 'y'\n            } datyp;                          /* date supplied type        */\n            enum {\n              successful_conversion = ' ',\n              error_in_data_supplied = 'e',\n            } daterr;                         /* result indicator          */\n            enum {\n              Monday = '1',\n              Tuesday = '2',\n              Wednesday = '3',\n              Thursday = '4',\n              Friday = '5',\n              Saturday = '6',\n              Sunday = '7'\n            } daywk;                          /* day of week indicator     */\n            enum {\n              not_a_holiday = ' ',\n              New_Years_Day = '1',\n              Christmas_Eve = '2',\n              Good_Friday = '3',\n              Memorial_Day = '4',\n              Independence_Day = '5',\n              Labor_Day = '6',\n              Thanksgiving_Day = '7',\n              Friday_After_Thanksgiving = '8',\n              Christmas_Day = '9',\n            } holiday;                        /* holiday indicator         */\n            enum {\n              not_leap_year = '0',\n              leap_year = '1',\n            } yeartyp;                        /* year type                 */\n            char juldate[8];                     /* julian date yyyyddd    */\n            char gregmdy[9];                     /* gregorian date mmddyyyy*/\n            char gregymd[9];                     /* gregorian date yyyymmdd*/\n            char litdate[19];                    /* literal date, eg:      */\n                                                    /* May 9, 2002         */\n            char julslash[9];                    /* julian date yy/ddd     */\n            char grgslash[11];                   /* gregorian:  mm/dd/yyyy */\n            char daylit[10];                     /* literal day of week eg:*/\n                                                    /* Sunday              */\n            char monthlit[10];                   /* literal month, eg: July*/\n          };\n\n          /*****************************************************************/\n          /* yeardata contains data about this year: day of week for       */\n          /* January 1st, leap year indicator, and holiday dates. Format:  */\n          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */\n          /*   byte2: leap year indicator: 1 = leap year else 0            */\n          /*   remainder: holiday fields of 5 bytes each. Format of each:  */\n          /*          byte1: holiday type indicator (same as p->holiday)   */\n          /*          bytes 2-5: MMDD date of the holiday                  */\n          /* tblukup() locates data for this year and initializes this area*/\n          /*****************************************************************/\n          struct year_entry2 {\n            char jan1_day;\n            char leap_year_ind;\n            struct {\n              char holiday_type;\n              char holiday_mmdd[5];\n            } holiday_table[9];\n          } yeardata;\n\n          /*****************************************************************/\n          /* function prototypes                                           */\n          /*****************************************************************/\n          void genldat2(struct DATEGENL *p);\n          void julian_sent(struct DATEGENL *p);\n          void gregorian_sent(struct DATEGENL *p);\n          void datcomn(struct DATEGENL *p);\n          void tblukup(struct DATEGENL *p);\n\n\n          void genldat2(struct DATEGENL *p) {\n\n            p->daterr = ' ';                       /* clear error indicator*/\n            p->holiday = ' ';                       /* clear holiday indic */\n            if(p->datyp == julian_yyyyddd_sent) {   /* julian date sent    */\n              julian_sent(p);\n              return;\n            }\n            else\n              if((p->datyp == gregorian_mmddyyyy_sent) || /* gregorian sent*/\n                  (p->datyp == gregorian_yyyymmdd_sent)) {\n                gregorian_sent(p);\n                return;\n              }\n              else {                        /* invalid date type specified */\n                p->daterr = 'e';\n                return;\n              }\n          }                                       /* end function genldat2 */\n\n          /*****************************************************************/\n          /* The gregcvrt[] table is used in converting between julian and */\n          /* gregorian dates. It contains the day numbers corresponding to */\n          /* the first day of each month. The gregcv1 table contains leap  */\n          /* year values, while the gregcv0 table contains normal year     */\n          /* values. the appropriate values are moved to gregcvrt[] by the */\n          /* tblukup() function.                                           */\n          /*****************************************************************/\n          int gregcvrt[13];\n\n          static int gregcv0[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243,\n                                    273, 304, 334, 999};\n\n          static int gregcv1[13] = {0, 31, 60, 91, 121, 152, 182, 213, 244,\n                                    274, 305, 335, 999};\n\n          /*****************************************************************/\n          /* julian_sent(): main function to handle julian date sent       */\n          /*****************************************************************/\n          void julian_sent(struct DATEGENL *p) {\n            int i, julday;\n\n            /* ----- julian date must be 7 bytes long ---------------------*/\n            if(strlen(p->juldate) != 7) {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- century must be 19 or 20 -----------------------------*/\n            if(((p->juldate[0] == '1') && (p->juldate[1] == '9')) ||\n                ((p->juldate[0] == '2') && (p->juldate[1] == '0')))\n               ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* --- julian date must consist entirely of decimal digits --- */\n            for(i=2; i<7; i++)\n              if((p->juldate[i] < '0') || (p->juldate[i] > '9')) {\n                p->daterr = 'e';\n                return;\n            }\n\n            /* ----- move julian year to gregorian year fields ----------- */\n            for(i = 0; i < 4; i++) {\n              p->gregmdy[i+4] = p->juldate[i];  /* year to greg mdy        */\n              p->gregymd[i] = p->juldate[i];    /* year to greg ymd        */\n            }\n\n            /* ----- go get year table data ------------------------------ */\n            tblukup(p);\n\n            /* ----- julian day must be 1 - 366 -------------------------- */\n            julday = atoi(&p->juldate[4]);      /*get julian day to integer*/\n            if((julday > 0 ) && (julday < 366))\n              ;\n            else\n              if((julday == 366) && (p->yeartyp == leap_year))\n                ;\n              else {\n                p->daterr = 'e';\n                return;\n              }\n\n            /* ----- build gregorian mmdd fields ------------------------- */\n            i = 0;\n            while(gregcvrt[i] < julday)       /* look up  for month and day*/\n            i++;\n            julday -= gregcvrt[i - 1];     /* deduct days to start of month*/\n            p->gregymd[4] = (i / 10) | '0';        /* build gregorian month*/\n            p->gregymd[5] = (i % 10) | '0';\n            p->gregymd[6] = (julday / 10) | '0';  /* build greg day of mnth*/\n            p->gregymd[7] = (julday % 10) | '0';\n            memcpy(&p->gregmdy[0], &p->gregymd[4], 4);    /*copy month, day*/\n            datcomn(p);                           /* finish processing date*/\n            return;\n          }                                    /* end function julian_sent */\n\n          /*****************************************************************/\n          /* The grgvldy[] table contains the number of days in each month.*/\n          /* It is used in validating the gregorian date.                  */\n          /*****************************************************************/\n          static int grgvldy[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31,\n                                    30, 31};\n\n          /*****************************************************************/\n          /* gregorian_sent(): main function to handle gregorian date sent.*/\n          /*****************************************************************/\n          void gregorian_sent(struct DATEGENL *p) {\n\n            int i, day, mth;\n\n            /* ----- make both gregorian dates the same date ------------- */\n            if(p->datyp == gregorian_mmddyyyy_sent) {\n              memcpy(&p->gregymd[0], &p->gregmdy[4], 4); /* copy year      */\n              memcpy(&p->gregymd[4], &p->gregmdy[0], 4); /* copy mmdd      */\n              p->gregymd[8] = '\\0';\n            }\n            else {\n              memcpy(&p->gregmdy[0], &p->gregymd[4], 4); /* copy mmdd      */\n              memcpy(&p->gregmdy[4], &p->gregymd[0], 4); /* copy year      */\n              p->gregmdy[8] = '\\0';\n            }\n\n            /* ----- gregorian date must be 8 bytes long ----------------- */\n            if((strlen(p->gregmdy) == 8) && (strlen(p->gregymd) == 8))\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- century must be 19 or 20 ---------------------------- */\n            if(((p->gregmdy[4] == '1') && (p->gregmdy[5] == '9')) ||\n                  ((p->gregmdy[4] == '2') && (p->gregmdy[5] == '0')))\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- all 8 bytes must be decimal digits ------------------ */\n            for(i=0; i<8; i++)\n              if((p->gregmdy[i] < '0') || (p->gregmdy[i] > '9')) {\n                p->daterr = 'e';\n                return;\n              }\n\n            /* ----- day must be > 0 ------------------------------------- */\n            day = ((p->gregmdy[2] - '0') * 10) + (p->gregmdy[3] - '0');\n            if(day)\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- month must be 01 to 12 ------------------------------ */\n            mth = ((p->gregmdy[0] - '0') * 10) + (p->gregmdy[1] - '0');\n            if((mth) && (mth < 13))\n              ;\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- perform year table lookup function ------------------ */\n            tblukup(p);\n\n            /* ----- check for valid day within the month ---------------- */\n            i = grgvldy[mth - 1];\n            if(day > i)\n            if(p->yeartyp == leap_year)\n              if(day == 29)\n                ;\n              else {\n                p->daterr = 'e';\n                return;\n              }\n            else {\n              p->daterr = 'e';\n              return;\n            }\n\n            /* ----- build julian date from gregorian -------------------- */\n            memcpy(&p->juldate[0], & p->gregymd[0], 4);\n            i = (gregcvrt[mth - 1]) + day;\n            p->juldate[4] = ((i / 100) + '0');\n            i %= 100;\n            p->juldate[5] = ((i / 10) + '0');\n            i %= 10;\n            p->juldate[6] = i + '0';\n            p->juldate[7] = '\\0';\n\n            /* ----- go finish date processing --------------------------- */\n            datcomn(p);\n            return;\n          }                                 /* end function gregorian_sent */\n\n          /*****************************************************************/\n          /* The julmo[] table contains the literal month names.           */\n          /*****************************************************************/\n          static char julmo[12][10] = {{\"January\"},{\"February\"},{\"March\"},\n                                       {\"April\"},{\"May\"},{\"June\"},{\"July\"},\n                                       {\"August\"},{\"September\"},{\"October\"},\n                                       {\"November\"},{\"December\"}};\n\n          /*****************************************************************/\n          /* The dwktbl[] table contains the literal day of week names.    */\n          /*****************************************************************/\n          static char dwktbl[7][10] = {{\"Monday\"},{\"Tuesday\"},{\"Wednesday\"},\n                                       {\"Thursday\"},{\"Friday\"},{\"Saturday\"},\n                                       {\"Sunday\"}};\n\n          /*****************************************************************/\n          /* datcomn(): common date processing.                            */\n          /*****************************************************************/\n          void datcomn(struct DATEGENL *p) {\n\n            int i, j;\n\n            /* ----- build the julslash date field ----------------------- */\n            memmove(&p->julslash[0], &p->juldate[0], 4);\n            p->julslash[4] = '/';\n            strcpy(&p->julslash[5], &p->juldate[4]);\n\n            /* ----- build the grgslash date field ----------------------- */\n            memmove(&p->grgslash[0], &p->gregmdy[0], 2);\n            p->grgslash[2] = '/';\n            memmove(&p->grgslash[3], &p->gregmdy[2], 2);\n            p->grgslash[5] = '/';\n            strcpy(&p->grgslash[6], &p->gregmdy[4]);\n\n            /* determine whether this date is a holiday and set indicator  */\n            for(i = 0; i < 9; i++)\n              if(!strcmp(yeardata.holiday_table[i].holiday_mmdd,&p->gregymd[4]))\n{\n                p->holiday = yeardata.holiday_table[i].holiday_type;\n                break;\n              }\n\n            /* ----- build the litdate field ----------------------------- */\n            i = ((atoi(&p->juldate[4])) + (yeardata.jan1_day - '0')) % 7;\n            if(i == 0) i = 7;\n            p->daywk = i | '0';                 /* move day of week number */\n            strcpy(p->daylit, dwktbl[i-1]);    /* move day of week literal */\n            i = (((p->gregmdy[0]) - '0') * 10) + ((p->gregmdy[1]) - '0');\n            strcpy(p->monthlit, julmo[i - 1]);          /* move month name */\n            strcpy(p->litdate, p->monthlit);                 /* month name */\n            i = 2;\n            while(p->litdate[++i]);\n            p->litdate[i++] = ' ';\n            if(p->gregmdy[2] != '0')\n              p->litdate[i++] = p->gregmdy[2];\n            p->litdate[i++] = p->gregmdy[3];                        /* day */\n            p->litdate[i++] = ',';                                /* comma */\n            p->litdate[i++] = ' ';                                /* blank */\n            memcpy(&p->litdate[i], p->gregymd, 4);                 /* year */\n            p->litdate[i + 4] = '\\0';\n          }                                        /* end function datcomn */\n\n          /*****************************************************************/\n          /* yeartbl1 contains subscript values (0-13) to yeartbl2. When   */\n          /* the next is 6 or 13, January 1st next year falls on Saturday, */\n          /* and will be observed on December 31st of this year (the       */\n          /* preceding Friday).                                            */\n          /*****************************************************************/\n          static int yeartbl1[201] = {\n                              1,2,3,4,12,0,1,2,10,5,          /* 1900-1909 */\n                              6,0,8,3,4,5,13,1,2,3,           /* 1910-1919 */\n                              11,6,0,1,9,4,5,6,7,2,           /* 1920-1929 */\n                              3,4,12,0,1,2,10,5,6,0,          /* 1930-1939 */\n                              8,3,4,5,13,1,2,3,11,6,          /* 1940-1949 */\n                              0,1,9,4,5,6,7,2,3,4,            /* 1950-1959 */\n                              12,0,1,2,10,5,6,0,8,3,          /* 1960-1969 */\n                              4,5,13,1,2,3,11,6,0,1,          /* 1970-1979 */\n                              9,4,5,6,7,2,3,4,12,0,           /* 1980-1989 */\n                              1,2,10,5,6,0,8,3,4,5,           /* 1990-1999 */\n                              13,0,1,2,10,5,6,0,8,3,          /* 2000-2009 */\n                              4,5,13,1,2,3,11,6,0,1,          /* 2010-2019 */\n                              9,4,5,6,7,2,3,4,12,0,           /* 2020-2029 */\n                              1,2,10,5,6,0,8,3,4,5,           /* 2030-2039 */\n                              13,1,2,3,11,6,0,1,9,4,          /* 2040-2049 */\n                              5,6,7,2,3,4,12,0,1,2,           /* 2050-2059 */\n                              10,5,6,0,8,3,4,5,13,1,          /* 2060-2069 */\n                              2,3,11,6,0,1,9,4,5,6,           /* 2070-2079 */\n                              7,2,3,4,12,0,1,2,10,5,          /* 2080-2089 */\n                              6,0,8,3,4,5,6,0,1,2,            /* 2090-2099 */\n                              3 };                                 /* 2100 */\n\n          /*****************************************************************/\n          /* yeartbl2 contains data about the year: day of week for January*/\n          /* 1st, leap year indicator, and holiday dates. Format is:       */\n          /*   byte1: day of week for Jan 1: 0=Monday - 6=Sunday           */\n          /*   byte2: leap year indicator: 1 = leap year else 0            */\n          /*   bytes 3-42: holiday fields of 5 bytes each. Format of each: */\n          /*          byte1: holiday type indicator (same as p->holiday)   */\n          /*          bytes 2-5: MMDD date of the holiday                  */\n          /* entry 7 type is pre-set for Good Friday, and entry 8 is       */\n          /* pre-set for a possible New Year's Day observed when Jan1 of   */\n          /* next year is Saturday                                         */\n          /*****************************************************************/\n          static struct year_entry2 yeartbl2[14]={\n            {'6','0',{{'1',\"0102\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n                      {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'0','0',{{'1',\"0101\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n                      {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'1','0',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n                      {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'2','0',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n                      {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'3','0',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n                      {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'4','0',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n                      {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'5','0',{{' ',\"0000\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n                      {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'6','1',{{'1',\"0102\"},{'4',\"0528\"},{'5',\"0704\"},{'6',\"0903\"},\n                      {'7',\"1122\"},{'8',\"1123\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'0','1',{{'1',\"0101\"},{'4',\"0527\"},{'5',\"0704\"},{'6',\"0902\"},\n                      {'7',\"1128\"},{'8',\"1129\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'1','1',{{'1',\"0101\"},{'4',\"0526\"},{'5',\"0704\"},{'6',\"0901\"},\n                      {'7',\"1127\"},{'8',\"1128\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'2','1',{{'1',\"0101\"},{'4',\"0525\"},{'5',\"0703\"},{'6',\"0907\"},\n                      {'7',\"1126\"},{'8',\"1127\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'3','1',{{'1',\"0101\"},{'4',\"0531\"},{'5',\"0705\"},{'6',\"0906\"},\n                      {'7',\"1125\"},{'8',\"1126\"},{'9',\"1224\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'4','1',{{'1',\"0101\"},{'4',\"0530\"},{'5',\"0704\"},{'6',\"0905\"},\n                      {'7',\"1124\"},{'8',\"1125\"},{'9',\"1226\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}},\n            {'5','1',{{'1',\"0000\"},{'4',\"0529\"},{'5',\"0704\"},{'6',\"0904\"},\n                      {'7',\"1123\"},{'8',\"1124\"},{'9',\"1225\"},{'3',\"0000\"},\n                      {' ',\"1231\"}}}\n          };\n\n          /*****************************************************************/\n          /* The goodfri[] table contains the dates of Good Friday for each*/\n          /* year from 1900 to 2099. An index to the table can be computed */\n          /* as: year - 1900.                                              */\n          /*****************************************************************/\n          static struct {\n            char good_friday_mmdd[5];     /* month-day date of Good Friday */\n          } goodfri[200] = {\n               {\"0413\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0401\"},  /* 1900-1904 */\n               {\"0421\"},{\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},  /* 1905-1909 */\n               {\"0325\"},{\"0414\"},{\"0405\"},{\"0321\"},{\"0410\"},  /* 1910-1914 */\n               {\"0402\"},{\"0421\"},{\"0406\"},{\"0329\"},{\"0418\"},  /* 1915-1919 */\n               {\"0402\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0418\"},  /* 1920-1924 */\n               {\"0410\"},{\"0402\"},{\"0415\"},{\"0406\"},{\"0329\"},  /* 1925-1929 */\n               {\"0418\"},{\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},  /* 1930-1934 */\n               {\"0419\"},{\"0410\"},{\"0326\"},{\"0415\"},{\"0407\"},  /* 1935-1939 */\n               {\"0322\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0407\"},  /* 1940-1944 */\n               {\"0330\"},{\"0419\"},{\"0404\"},{\"0326\"},{\"0415\"},  /* 1945-1949 */\n               {\"0407\"},{\"0323\"},{\"0411\"},{\"0403\"},{\"0416\"},  /* 1950-1954 */\n               {\"0408\"},{\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},  /* 1955-1959 */\n               {\"0415\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0327\"},  /* 1960-1964 */\n               {\"0416\"},{\"0408\"},{\"0324\"},{\"0412\"},{\"0404\"},  /* 1965-1969 */\n               {\"0327\"},{\"0409\"},{\"0331\"},{\"0420\"},{\"0412\"},  /* 1970-1974 */\n               {\"0328\"},{\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},  /* 1975-1979 */\n               {\"0404\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0420\"},  /* 1980-1984 */\n               {\"0405\"},{\"0328\"},{\"0417\"},{\"0401\"},{\"0324\"},  /* 1985-1989 */\n               {\"0413\"},{\"0329\"},{\"0417\"},{\"0409\"},{\"0401\"},  /* 1990-1994 */\n               {\"0414\"},{\"0405\"},{\"0328\"},{\"0410\"},{\"0402\"},  /* 1995-1999 */\n               {\"0421\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},  /* 2000-2004 */\n               {\"0325\"},{\"0414\"},{\"0406\"},{\"0321\"},{\"0410\"},  /* 2005-2009 */\n               {\"0402\"},{\"0422\"},{\"0406\"},{\"0329\"},{\"0418\"},  /* 2010-2014 */\n               {\"0403\"},{\"0325\"},{\"0414\"},{\"0330\"},{\"0419\"},  /* 2015-2019 */\n               {\"0410\"},{\"0402\"},{\"0415\"},{\"0407\"},{\"0329\"},  /* 2020-2024 */\n               {\"0418\"},{\"0403\"},{\"0326\"},{\"0414\"},{\"0330\"},  /* 2025-2029 */\n               {\"0419\"},{\"0411\"},{\"0326\"},{\"0415\"},{\"0407\"},  /* 2030-2034 */\n               {\"0323\"},{\"0411\"},{\"0403\"},{\"0423\"},{\"0408\"},  /* 2035-2039 */\n               {\"0330\"},{\"0419\"},{\"0404\"},{\"0327\"},{\"0415\"},  /* 2040-2044 */\n               {\"0407\"},{\"0323\"},{\"0412\"},{\"0403\"},{\"0416\"},  /* 2045-2049 */\n               {\"0408\"},{\"0331\"},{\"0419\"},{\"0404\"},{\"0327\"},  /* 2050-2054 */\n               {\"0416\"},{\"0331\"},{\"0420\"},{\"0412\"},{\"0328\"},  /* 2055-2059 */\n               {\"0416\"},{\"0408\"},{\"0324\"},{\"0413\"},{\"0404\"},  /* 2060-2064 */\n               {\"0327\"},{\"0409\"},{\"0401\"},{\"0420\"},{\"0412\"},  /* 2065-2069 */\n               {\"0328\"},{\"0417\"},{\"0408\"},{\"0324\"},{\"0413\"},  /* 2070-2074 */\n               {\"0405\"},{\"0417\"},{\"0409\"},{\"0401\"},{\"0421\"},  /* 2075-2079 */\n               {\"0405\"},{\"0328\"},{\"0417\"},{\"0402\"},{\"0324\"},  /* 2080-2084 */\n               {\"0413\"},{\"0329\"},{\"0418\"},{\"0409\"},{\"0401\"},  /* 2085-2089 */\n               {\"0414\"},{\"0406\"},{\"0328\"},{\"0410\"},{\"0402\"},  /* 2090-2094 */\n               {\"0422\"},{\"0413\"},{\"0329\"},{\"0418\"},{\"0410\"}   /* 2095-2099 */\n            };\n\n          /*****************************************************************/\n          /* tblukup(): performs year table lookups using the gregmdy year.*/\n          /* The data entry found is moved to the yeardata area.           */\n          /*****************************************************************/\n          void tblukup(struct DATEGENL *p) {\n            int i, j, *q;\n            char char_year[5];\n\n            /* ----- compute the year table index = year - 1900 ---------- */\n            memcpy(char_year, p->gregymd, 4);\n            char_year[4] = '\\0';\n            i = atoi(char_year);                    /* convert year to int */\n            i -= 1900;                      /* deduct 1900 for index value */\n            j = yeartbl1[i];             /* get index to second year table */\n\n            /* - move entry for the specified year to the yeardata field - */\n            yeardata = yeartbl2[j];              /* copy data for the year */\n\n            /* - move the Good Friday date to the yeardata holiday table - */\n            strcpy(yeardata.holiday_table[7].holiday_mmdd,\n                                               goodfri[i].good_friday_mmdd);\n\n            /* if next year begins on Saturday, make December 31 a holiday */\n            if((yeartbl1[i+1] == 6) || (yeartbl1[i+1] == 13)) {\n              yeardata.holiday_table[8].holiday_type = '1';} /* 12/31 NewYr*/\n\n            /* ----- set year type in dategenl structure ----------------- */\n            p->yeartyp = yeardata.leap_year_ind; /* year type to dategenl  */\n\n            /* ----- set correct values in the gregcvrt() table ---------- */\n            q = gregcv0;\n            if(p->yeartyp == leap_year)\n            q = gregcv1;\n            for(i = 0; i < 13; i++)\n              gregcvrt[i] = *q++;\n            }                                      /* end function tblukup */\n\n          *********************************************************************\n          *                   Elementary C Programming               keyvalu.c*\n          *********************************************************************\n\n            /*****************************************************************/\n            /*                           keyvalu.c                           */\n            /* keyvalu.c shows the decimal, hex, and character values for any*/\n            /* key pressed alone or in combination with Ctrl, Alt, or Shift. */\n            /*****************************************************************/\n\n            #include <stdio.h>            /* include header for standard I/O */\n\n            unsigned char c;              /* define c                        */\n            int qcnt;                     /* define qcnt                     */\n\n            /*****************************************************************/\n            /* main function: this is the initial entry point to the program */\n            /*****************************************************************/\n\n            void main() {                 /* function header for main        */\n\n              /***************************************************************/\n              /* display instructions for the user                           */\n              /***************************************************************/\n              printf(\"\\nPress any single key alone or in combination with \");\n              printf(\"\\nCtrl, Alt, or Shift to see the decimal, hex, and \");\n              printf(\"\\nprintable values for the key.\");\n              printf(\"\\nTo terminate press q four times in succession.\\n\\n\");\n\n              /***************************************************************/\n              /* This never ending while loop runs until the user types the  */\n              /* letter q four times in succession. This is the main process */\n              /* loop that gets the key(s) pressed and produces a display    */\n              /* giving the key values in decimal, hex, and character forms. */\n              /***************************************************************/\n              while(1) {                      /* loop forever                */\n                c = getch();                  /* read a key into c           */\n                if(c == 0) {                  /* if c is zero, it is extended*/\n                  c = getch();                   /* code, so read scan code  */\n                                                 /* and display extended code*/\n                  printf(\"Extended key scan code: %d (%02X) %s\\n\",c,c,\"N/A\");\n                }\n                else                          /* if key read is not zero     */\n                                              /* display normal key values   */\n                printf(\"Normal: %d (%02X) %c\\n\",c,c,c);\n                if(c == 'q') {                /* if key pressed is a q       */\n                  if(qcnt == 3)                  /* and this is the 3rd q    */\n                    break;                          /* break out of the while*/\n                  else                        /* otherwise, if not the 3rd   */\n                    qcnt++;                      /* increment q counter      */\n                }\n                else                          /* otherwise, if not a q       */\n                  qcnt = 0;                      /* clear the q counter      */\n              }\n            }                                 /* end of main function        */\n\n./ ADD NAME=HELLO2   0100-02144-02144-0950-00063-00063-00000-BC0THOR\n          /***************************************************************/\n          /*                   hello2.c                                  */\n          /* hello2.c is version2 of the Hello, World! program           */\n          /***************************************************************/\n\n          #include <stdio.h>;              /* include standard I/O header*/\n\n          #define White 623                /* White is 623               */\n\n          int print_count(int count);      /* print_count prototype      */\n\n          char hello[] = \"hello, zorld!\\n\"; /* string with initial value */\n\n          /***************************************************************/\n          /* main function: initial program entry point                  */\n          /***************************************************************/\n\n          void main() {                    /* function header for main   */\n\n            int count = White;             /* define count = 623         */\n            char picx = 'W';               /* define picx = 'W'          */\n\n            hello[7] = picx;               /* move picx to string[7]     */\n            printf(\"%s\",hello);            /* display modified string    */\n            printf                         /* printf                     */\n                  (                           /* with                    */\n                   \"White space is ignored\\n\"    /* many                 */\n                                              )     /* imbedded          */\n                                                ;      /* spaces         */\n\n         /****************************************************************/\n         /* The printf below displays the number returned by the         */\n         /* print_count function. Notice that no variable is used on the */\n         /* right side of the parameter, but only a call to print_count. */\n         /* this is because a function call IS what it returns.          */\n         /****************************************************************/\n\n            printf(\"The print_count() function returned %d\\n\",\n                    print_count(count));   /* print print_count's return */\n         }                                 /* end of main function       */\n\n         /****************************************************************/\n         /* print_count: display value of the count field and return an  */\n         /* integer value to the caller.                                 */\n         /****************************************************************/\n\n         int print_count(int white) {   /* print_count's function header */\n\n           int ret_valu;                   /* define ret_valu            */\n\n           /**************************************************************/\n           /* The printf below displays the integer value received as a  */\n           /* parameter on entry. Note that it is passed by the caller as*/\n           /* a field called count, but is called white on entry to the  */\n           /* print_count function. Also note that the #define for White */\n           /* does not affect this, as it begins with a lower case w.    */\n           /**************************************************************/\n           printf(\"The value of the count field is: %d\\n\",white);\n\n           ret_valu = white % 600;         /* ret_valu is remainder value*/\n           return(ret_valu);               /* return ret_valu to caller  */\n        }                                  /* end of print_count function*/\n\n./ ADD NAME=KEYVALU  0100-02144-02144-0950-00052-00052-00000-BC0THOR\n            /*****************************************************************/\n            /*                           keyvalu.c                           */\n            /* keyvalu.c shows the decimal, hex, and character values for any*/\n            /* key pressed alone or in combination with Ctrl, Alt, or Shift. */\n            /*****************************************************************/\n\n            #include <stdio.h>            /* include header for standard I/O */\n\n            unsigned char c;              /* define c                        */\n            int qcnt;                     /* define qcnt                     */\n\n            /*****************************************************************/\n            /* main function: this is the initial entry point to the program */\n            /*****************************************************************/\n\n            void main() {                 /* function header for main        */\n\n              /***************************************************************/\n              /* display instructions for the user                           */\n              /***************************************************************/\n              printf(\"\\nPress any single key alone or in combination with \");\n              printf(\"\\nCtrl, Alt, or Shift to see the decimal, hex, and \");\n              printf(\"\\nprintable values for the key.\");\n              printf(\"\\nTo terminate press q four times in succession.\\n\\n\");\n\n              /***************************************************************/\n              /* This never ending while loop runs until the user types the  */\n              /* letter q four times in succession. This is the main process */\n              /* loop that gets the key(s) pressed and produces a display    */\n              /* giving the key values in decimal, hex, and character forms. */\n              /***************************************************************/\n              while(1) {                      /* loop forever                */\n                c = getch();                  /* read a key into c           */\n                if(c == 0) {                  /* if c is zero, it is extended*/\n                  c = getch();                   /* code, so read scan code  */\n                                                 /* and display extended code*/\n                  printf(\"Extended key scan code: %d (%02X) %s\\n\",c,c,\"N/A\");\n                }\n                else                          /* if key read is not zero     */\n                                              /* display normal key values   */\n                printf(\"Normal: %d (%02X) %c\\n\",c,c,c);\n                if(c == 'q') {                /* if key pressed is a q       */\n                  if(qcnt == 3)                  /* and this is the 3rd q    */\n                    break;                          /* break out of the while*/\n                  else                        /* otherwise, if not the 3rd   */\n                    qcnt++;                      /* increment q counter      */\n                }\n                else                          /* otherwise, if not a q       */\n                  qcnt = 0;                      /* clear the q counter      */\n              }\n            }                                 /* end of main function        */\n\n./ ADD NAME=LOADSTRG 0100-02144-02144-0950-00038-00038-00000-BC0THOR\n          /******************************************************************/\n          /*                        loadstrg.c                              */\n          /* loadstrg.c reads up to 100 character strings from the keyboard */\n          /* into memory, then displays them after the last one is entered. */\n          /******************************************************************/\n\n          #include <stdio.h>                 /* include standard I/O header */\n          #include <stdlib.h>                /* include standard lib header */\n          #include <string.h>                /* include string header       */\n\n          /******************************************************************/\n          /* main function: initial entry point to the program. reads the   */\n          /* strings into storage areas obtained individually for each one. */\n          /* After the last string (user presses enter with no data), all   */\n          /* the stored strings are displayed.                              */\n          /******************************************************************/\n\n          main() {                           /* function header for main    */\n\n            char *p[101];                    /* p is array of ptrs to chars */\n            int i,l;                         /* define work subscripts      */\n            char string[80];                 /* define work string          */\n\n            for(i=0;i<100;i++) {             /* loop for up to 100 strings  */\n              gets(string);                    /* read string into work area*/\n              if(!(l = strlen(string))) break; /* if null string, break loop*/\n              *(p+i) = (char *)malloc(l+1);    /* else get storage to hold  */\n              strcpy(*(p+i),string);           /* and copy string to storage*/\n            }\n\n            *(p+i) = 0;                      /* 0 = end of array pointers   */\n\n            for(i=0;i<100;i++) {             /* loop to display strings     */\n              if(!p[i]) break;                  /* if end of table, break   */\n              printf(\"%s\\n\",*(p+i));            /* else display the string  */\n            }\n          }                                  /* end of main function        */\n\n./ ADD NAME=MENU10   0100-02144-02144-0950-00152-00152-00000-BC0THOR\n          /******************************************************************/\n          /*                         menu10.c                               */\n          /* menu10.c displays a menu asking the user for an a, s, m, or d  */\n          /* as a request to add, subtract, multiply, or divide two numbers.*/\n          /* Four functions handle each type of request, each asking for the*/\n          /* numbers, reading the numbers from the keyboard, performing the */\n          /* keyboard, performing the arithmetic, and displaying results.   */\n          /******************************************************************/\n\n                               /**********************/\n          /********************* header file includes ***********************/\n                               /**********************/\n          #include <stdio.h>\n          #include <math.h>\n\n                               /**********************/\n          /*********************       defines        ***********************/\n                               /**********************/\n          #define CLEAR \"\\x1B[2J\"\n\n                               /**********************/\n          /*********************  global data fields  ***********************/\n                               /**********************/\n          float num1,num2;\n          float sum,difference,product,quotient,remainder;\n          char string[80];\n          unsigned char c;\n\n                               /**********************/\n          /********************* function prototypes  ***********************/\n                               /**********************/\n          void add_numbers(void);\n          void subtract_numbers(void);\n          void multiply_numbers(void);\n          void divide_numbers(void);\n\n                                /*********************/\n          /*********************     main function    ***********************/\n          /*** display menu, read request and call appropriate function *****/\n             /**********************************************************/\n          void main() {\n            c = ' ';\n            while((c != 'q') & (c != 'Q')) {                /* display menu */\n\n              printf(CLEAR);\n              printf(\"\\n\\n\\n\\n        A = add numbers\");\n              printf(\"\\n\\n        S = subtract numbers\");\n              printf(\"\\n\\n        M = multiply numbers\");\n              printf(\"\\n\\n        D = divide numbers\");\n              printf(\"\\n\\n        Q = quit\");\n              printf(\"\\n\\n            \");\n\n              switch(c=getch()) {                           /* read request */\n                case 'q':\n                case 'Q':\n                  break;\n                case 'a':\n                case 'A':\n                  add_numbers();\n                  break;\n                case 's':\n                case 'S':\n                  subtract_numbers();\n                  break;\n                case 'm':\n                case 'M':\n                  multiply_numbers();\n                  break;\n                case 'd':\n                case 'D':\n                  divide_numbers();\n                  break;\n              }\n            }\n          }\n\n                                /**********************/\n          /*********************  add_numbers function **********************/\n          /************* add two numbers and display the sum ****************/\n                       /*************************************/\n          void add_numbers() {\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            sum = num1 + num2;\n            printf(\"\\n\\n\\n        %f + %f = %f\",num1,num2,sum);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n                            /****************************/\n          /******************  subtract_numbers function ********************/\n          /******** subtract two numbers and display the difference *********/\n                  /*************************************************/\n          /* subtract two numbers and display the difference */\n          void subtract_numbers(void) {\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            difference = num1 - num2;\n            printf(\"\\n\\n\\n        %f - %f = %f\",num1,num2,difference);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n                             /***************************/\n          /******************* multiply_numbers function ********************/\n          /******** multiply two numbers and display the product ************/\n                  /**********************************************/\n          /* multiply two numbers and display the product */\n          void multiply_numbers(void) {\n\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            product = num1 * num2;\n            printf(\"\\n\\n\\n        %f * %f = %f\",num1,num2,product);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n                                /**********************/\n          /********************  divide_numbers function ********************/\n          /********* divide two numbers and display the quotient ************/\n                   /*********************************************/\n          /* divide two numbers and display the quotient and remainder */\n          void divide_numbers(void) {\n            printf(CLEAR);\n            printf(\"\\n\\n\\n\\n        Enter First number: \");\n            gets( string);\n            num1 = atof(string);\n            printf(\"\\n\\n\\n\\n        Enter Second number: \");\n            gets( string);\n            num2 = atof(string);\n            quotient = num1 / num2;\n            printf(\"\\n\\n\\n        %f / %f = %f\",num1,num2,quotient);\n            printf(\"\\n\\n        Press any key to continue\");\n            getch();\n          }\n\n./ ADD NAME=SKELETON 0100-02144-02144-0950-00393-00393-00000-BC0THOR\n         /*******************************************************************/\n         /*                     skeleton.c                                  */\n         /*                                                                 */\n         /* generic c program that includes an input file, output file,     */\n         /* print file, and common processing functions:                    */\n         /*  main       = executive routine: overall program control        */\n         /*  mainline   = mainline processing control                       */\n         /*  initialize = open files, set up headers and call headings      */\n         /*  readrec    = read input file records and count them            */\n         /*  writerec   = write output file records and count them          */\n         /*  printline  = print detail, clear print line, call headings     */\n         /*  headings   = print heading lines for new page                  */\n         /*  edit       = edit numbers with commas, decimal points, etc     */\n         /*  terminate  = close files, print totals, stop execution         */\n         /*                                                                 */\n         /*                                                                 */\n         /* Author R Thornton September 1993                                */\n         /*******************************************************************/\n\n         #include <stdio.h>\n         #include <stdlib.h>\n         #include <time.h>\n\n         void initialize(int argc, char *argv[]);  /* initialization func   */\n         void mainline(void);                  /* mainline function         */\n         void terminate(void);                 /* termination function      */\n         void readrec(void);                   /* read next input file rec  */\n         void writerec(void);                  /* write record to out file  */\n         void printline(void);                 /* print a line to rept file */\n         int edit(char output[], char pattern[], char number[]); /* edit fnc*/\n         void headings(void);                  /* print report heading      */\n\n         FILE *infile, *outfile, *prtfile;     /* file handle pointers      */\n\n         char innam[81];                       /* input file name           */\n         char outnam[81];                      /* output file name          */\n         char prtnam[81] = \"prn\";              /* print file name           */\n\n         char prtline[135];                    /* print line buffer         */\n         char inrecord[256];                   /* input file record area    */\n         char outrecord[256];                  /* output file record area   */\n\n         char *h1ptr;                          /* heading line 1 pointer    */\n         struct {                              /* first heading line        */\n           char hdr_skip;                        /* form feed               */\n           char hdr_date[10];                    /* report date             */\n           char ctr1[45];                        /* centering blanks        */\n           char title_line[21];                  /* centered report title   */\n           char ctr2[45];                        /* centering blanks        */\n           char page_lit[5];                     /* page literal            */\n           char page_nbr[6];                     /* page number             */\n           char newline;                         /* newline character       */\n           char null_byte;                       /* terminating null        */\n         } header1;\n\n         int i;                                /* general purpose int       */\n         char number[32];                      /* ascii numbers for edit()  */\n         int morerecs = -1;                    /* input end-of-file switch  */\n         long incount = 0;                     /* input record counter      */\n         long outcount = 0;                    /* output record counter     */\n         int linecnt = 0;                      /* print line counter        */\n         int pagecnt = 0;                      /* print page counter        */\n         struct tm *t;                         /* pointer to time structure */\n         time_t seconds;                       /* current timer value       */\n\n         /*******************************************************************/\n         /* executive routine: overall program control                      */\n         /*******************************************************************/\n         void main(int argc, char *argv[]) {\n            initialize(argc, argv);            /* open files                */\n            while(morerecs)                    /* perform mainline until    */\n               mainline();                     /* no more records           */\n            terminate();                       /* close files               */\n            exit(0);                           /* quit                      */\n         }\n         /*******************************************************************/\n         /* mainline function: process input file until no more records.    */\n         /*******************************************************************/\n         void mainline(void) {\n            strcpy(prtline,inrecord);          /* move input record to print*/\n            printline();                       /* and print it              */\n            strcpy(outrecord,inrecord);       /* move input record to output*/\n            writerec();                        /* write an output record    */\n            readrec();                         /* read next input record    */\n         }\n         /*******************************************************************/\n         /* initialization: open files, read first input record.            */\n         /*******************************************************************/\n         void initialize(int argc, char *argv[]) {\n           if(argc == 3) {                     /* if two filenames given:   */\n             strcpy(&innam,argv[1]);             /* 1st is input filename   */\n             strcpy(&outnam,argv[2]);            /* 2nd is output filename  */\n           }\n           else\n             if(argc == 4) {                   /* if three filenames given: */\n               strcpy(&innam,argv[1]);           /* 1st is input filename   */\n               strcpy(&outnam,argv[2]);          /* 2nd is output filename  */\n               strcpy(&prtnam,argv[3]);          /* 3rd is print file name  */\n             }\n             else {                            /* if neither 2 nor 3 given: */\n               printf(\"\\nEnter input file spec: \"); /* ask for input filenam*/\n               gets(innam);                         /* and read it in       */\n               printf(\"\\nEnter output file spec: \"); /* ask for output filen*/\n               gets(outnam);                        /* and read it in       */\n               printf(\"\\nEnter output file spec (or prn): \"); /* ask for prt*/\n               gets(prtnam);                        /* and read it in       */\n             }\n           if((infile=fopen(innam,\"rb\")) == NULL) { /* open input           */\n             printf(\"Can't open file %s.\",innam);   /* open failed message  */\n             exit(1);                               /* terminate            */\n           }\n           if((outfile=fopen(outnam,\"wb\")) == NULL) { /* open output        */\n             printf(\"Can't open file %s.\",outnam);\n             exit(1);\n           }\n           if((prtfile=fopen(prtnam,\"w\"))==NULL) { /* open print file       */\n             printf(\"\\nCan't open the printer file.\"); /* open failed msg   */\n             exit(1);                                  /* terminate         */\n           }\n           h1ptr = (char *)&header1;               /* point to header1 line */\n           for(i=0;i<133;i++)                      /* clear header line     */\n             h1ptr[i] = ' ';                         /* to all spaces       */\n           header1.hdr_skip = '\\f';              /* form feed to header line*/\n           memcpy(header1.title_line,\"SKELETON REPORT TITLE\",21); /* copy hd*/\n           timezone = 5 * 60 * 60;               /* set local time for e.s.t*/\n           daylight = -1;                        /* indicate daylit sav time*/\n           time(&seconds);                       /* time in secs            */\n           t = localtime(&seconds);              /* local time to tm struct */\n           sprintf(header1.hdr_date,\"%2d\\/%2d\\/%2d\",\n                                       t->tm_mon,t->tm_mday,t->tm_year);\n           header1.hdr_date[8] = ' ';            /* clear terminating null  */\n           memcpy(header1.page_lit,\"PAGE \",5);   /* PAGE literal to header  */\n           prtline[133] = '\\0';                 /* terminal null to prt line*/\n           headings();                           /* write first heading     */\n           readrec();                        /* read first input file record*/\n         }\n         /*******************************************************************/\n         /* read next input file record. at end of file, set morerecs switch*/\n         /*******************************************************************/\n         void readrec() {\n           if(fgets(inrecord,255,infile) == NULL) /* read input until eof   */\n             morerecs = 0;                      /* set switch at end of file*/\n           if(morerecs)                           /* if not at end of file  */\n           incount++;                               /* add 1 to records read*/\n         }\n         /*******************************************************************/\n         /* write a record to the output file                               */\n         /*******************************************************************/\n         void writerec() {\n           fputs(outrecord,outfile);             /* write output record     */\n           outcount++;                           /* add 1 to records written*/\n         }\n         /*******************************************************************/\n         /* write a line to the printer                                     */\n         /*******************************************************************/\n         void printline() {\n           prtline[133] = '\\n';            /* terminal newline to print line*/\n           prtline[134] = '\\0';            /* terminal null to print line   */\n           fputs(prtline,prtfile);         /* write print line              */\n           linecnt++;                      /* add 1 to line counter         */\n           if(linecnt > 56)                /* if end of page                */\n             headings();                     /* write heading lines         */\n           else                            /* otherwise                     */\n             for(i=0;i<133;i++)              /* clear print line            */\n               prtline[i] = ' ';               /* to all spaces             */\n         }\n         /*******************************************************************/\n         /* write a report heading                                          */\n         /*******************************************************************/\n         void headings() {\n           linecnt = 0;                      /* clear line counter          */\n           pagecnt++;                        /* add 1 to page counter       */\n           sprintf(number,\"%d\",pagecnt);     /* convert to printable nbr    */\n           edit(header1.page_nbr,\"zz,zz9\",number); /* page nbr to hdr line  */\n           header1.newline = '\\n';           /* terminal newline to hdr     */\n           header1.null_byte = '\\0';         /* terminal null to header     */\n           fputs((char *)&header1,prtfile);  /* write header line           */\n           for(i=0;i<133;i++)                /* clear print line            */\n             prtline[i] = ' ';                 /* to all spaces             */\n           prtline[133] = '\\n';              /* ending newline to print line*/\n           prtline[134] = '\\0';              /* terminal null to print line */\n           fputs(prtline,prtfile);           /* blank line after heading    */\n         }\n\n         /*******************************************************************/\n         /* The edit function provides numeric report editing, including    */\n         /* leading zero suppression, check protection, floating $, leading */\n         /* or trailing minus sign, insertion of commas, decimal points and */\n         /* other non-numeric fields. The first parameter is the address of */\n         /* the edited output, whose size will be the same as the pattern.  */\n         /* The second parameter is the editing pattern which must be a true*/\n         /* null-terminated string containing the edit pattern. The third   */\n         /* is the number to be edited, a null-terminated string containing */\n         /* only digits 0-9 except the first position, which is a -, if the */\n         /* number is negative. The pattern may be up to 64 characters, and */\n         /* the number to be edited may contain up to 32 characters. The    */\n         /* number may not contain more significant digits than there are   */\n         /* digit select characters in the pattern. If there are more digits*/\n         /* selected by the pattern than there are in the number, leading   */\n         /* zeros will be assumed. In the pattern, the first character may  */\n         /* be:      $ (floating dollar sign)                               */\n         /*          * (check protection)                                   */\n         /*          - (floating minus sign)                                */\n         /* The body of the edit pattern will be composed of digit select   */\n         /* characters (z and 9) and other characters, handled as follows:  */\n         /*          z (zero suppression output is a blank in this position */\n         /*             until significance is set by receipt of a significan*/\n         /*             digit or a 9 in the pattern. After significance is  */\n         /*             set, output is a digit from the number.)            */\n         /*          9 (output is a digit from the number and significance  */\n         /*             is set, even if the digit is a leading zero.)       */\n         /*        other characters in the pattern will be output as-is afte*/\n         /*             significance is set, but will be output as blanks   */\n         /*             before significance is set.                         */\n         /* Characters in the pattern following the last digit select will  */\n         /* be output as-is if the number is negative, otherwise output will*/\n         /* be blanks for these pattern positions.                          */\n         /*                                                                 */\n         /* When * check protection is selected, output will be *, rather   */\n         /* than blanks as mentioned above.                                 */\n         /*                                                                 */\n         /* An integer is returned to indicate success or errors:           */\n         /*                 0 = successful edit                             */\n         /*                 1 = pattern too long (over 64 characters)       */\n         /*                 2 = too many digits selected (over 32)          */\n         /*                 3 = no output digits selected in pattern        */\n         /*                 4 = number contains non-numeric data            */\n         /*                 5 = number has more digits than the pattern     */\n         /*                                                                 */\n         /* Examples:                            nbr=             outf=     */\n         /*    err=edit(outf,\"zz,zz9.99-\",nbr);  0                     0.00 */\n         /*                                      123                   1.23 */\n         /*                                      562983            5,629.83 */\n         /*                                      -4675                46.75-*/\n         /*    err=edit(outf,\"$,$$$.$$\",nbr);    0                          */\n         /*                                      123                  $1.23 */\n         /*                                      562983           $5,629.83 */\n         /*                                      -4675               $46.75 */\n         /*    err=edit(outf,\"***.**\",nbr);      0                          */\n         /*                                      123                 **1.23 */\n         /*                                      562983   err = 5           */\n         /*                                      -4675               *46.75 */\n         /*    err=edit(outf,\"--,--9.99\",nbr);   0                     0.00 */\n         /*                                      123                   1.23 */\n         /*                                      562983            5,629.83 */\n         /*                                      -46.75              -46.75 */\n         /*                                                                 */\n         /* Author R Thornton April 1989                                    */\n         /*******************************************************************/\n         /**/\n         int edit(char output[], char pattern[], char number[]) {\n           char float_val = ' ';\n           char fill_val = ' ';\n           char sign_val = ' ';\n           int signif = 0;\n           int psize = 0;\n           int pdig = 0;\n           int plast = 0;\n           int ndig = 0;\n           char nbr[33];\n           char ch= ' ';\n           int po=0;\n           int n=0;\n\n         /*******************************************************************/\n         /* examine pattern: set up float and fill, count size and digits   */\n         /*******************************************************************/\n           if(((ch=pattern[0]) == '$') || (ch == '*') || (ch == '-'))\n             float_val = ch;\n           if(ch == '*')\n             fill_val = '*';\n           while((ch=pattern[po]) != '\\0') {\n            if((ch == 'z') || (ch == '9')) {\n               pdig++;\n               plast = po;\n             }\n             psize++;\n             po++;\n           }\n           if(psize > 63)\n             return(1);\n           if(pdig > 32)\n             return(2);\n           if(!pdig)\n             return(3);\n\n         /*******************************************************************/\n         /* examine number: set up sign, count digits, check numeric.       */\n         /* set error if more digits than pattern, move right justified     */\n         /*******************************************************************/\n           if(number[0] == '-') {\n             sign_val = '-';\n             n = 1;\n           }\n           while((ch=number[n]) != '\\0') {\n             if((ch < '0') || (ch > '9'))\n               return(4);\n             ndig++;\n             n++;\n           }\n           if(ndig > pdig)\n             return(5);\n           for(po=0;po<(pdig-ndig);po++)\n             nbr[po] = '0';\n           if(sign_val == ' ')\n             n = 0;\n           else\n             n=1;\n           for(;po<pdig;po++,n++)\n             nbr[po] = number[n];\n\n         /********************************************************************/\n         /* scan across the pattern, setting the corresponding output        */\n         /* byte from pattern, fill, or amt depending on the pattern         */\n         /* character and state of significance.                             */\n         /********************************************************************/\n           if(float_val != ' ') {\n             output[0] = ' ';\n             po = 1;\n           }\n           else\n             po = 0;\n           n = 0;\n           while((po <= plast)) {\n             ch = pattern[po];\n             if(ch == 'z') {\n               if(signif) {\n                 output[po] = nbr[n];\n                 n++;\n               }\n               else {\n                 if(nbr[n] == '0') {\n                   output[po] = fill_val;\n                   n++;\n                 }\n                 else {\n                   output[po] = nbr[n];\n                   signif = -1;\n                   n++;\n                   if(float_val == ' ')\n                     ;\n                   else\n                     if((float_val == '$') || (sign_val == '-'))\n                       output[po-1] = float_val;\n                 }\n               }\n             }\n             else if(ch == '9') {\n               output[po] = nbr[n];\n               if(!signif) {\n                 signif = -1;\n                 if(float_val == ' ')\n                   ;\n                 else\n                   if((float_val == '$') || (sign_val == '-'))\n                     output[po-1] = float_val;\n               }\n               n++;\n             }\n             else {\n               if(signif)\n                 output[po] = pattern[po];\n               else\n                 output[po] = fill_val;\n             }\n             po++;\n           }\n           while((ch=pattern[po]) != '\\0') {\n             if(sign_val == ' ')\n               output[po++] = fill_val;\n             else\n               output[po++] = pattern[po];\n           }\n           return(0);\n         }\n\n         /*******************************************************************/\n         /* termination: close files                                        */\n         /*******************************************************************/\n         void terminate() {\n           sprintf(number,\"%ld\",incount);    /* convert input count to ascii*/\n           edit(prtline, \"zz,zzz,zz9\", number); /* edit number to prtline   */\n           strcpy(prtline+10,\" input records read\"); /* message to prt      */\n           printline();                      /* print count                 */\n           sprintf(number,\"%ld\",outcount);   /* convert input count to ascii*/\n           edit(prtline, \"zz,zzz,zz9\", number); /* edit number to prtline   */\n           strcpy(prtline+10,\" output records written\"); /* message to prt  */\n           printline();                      /* print count                 */\n           fclose(infile);                   /* close input file            */\n           fclose(outfile);                  /* close output file           */\n           fclose(prtfile);                  /* close print file            */\n         }\n\n./ ADD NAME=STRUCT9  0100-02144-02144-0950-00076-00076-00000-BC0THOR\n          /******************************************************************/\n          /*                       struct9.c                                */\n          /* struct9.c is an exercise in the use of structures and          */\n          /* unions.                                                        */\n          /******************************************************************/\n\n          #include <stdio.h>         /* include standard I/O header         */\n          #include <stdlib.h>        /* include standard library header     */\n          #include <string.h>        /* include string header               */\n\n          /******************************************************************/\n          /* main function: initial entry point to the program.             */\n          /******************************************************************/\n\n          void main() {              /* function header for main            */\n\n            struct {                 /* define a structure                  */\n              int emp_nbr;\n              char last_name[12];\n              char pay_grade;\n              union {                   /* which contains a union           */\n                struct {                   /* which includes a structure,   */\n                  float hours_worked;\n                  float hourly_rate;\n                } hourly;\n                float annual_salary;       /* and a float                   */\n              } pay_data;                  /* union name is pay_data        */\n            } emp[12];               /* structure array name is emp         */\n\n            int i,a;                 /* define work integers                */\n            char string[80];         /* define work string                  */\n\n            for(i=0;i<12;i++) {      /* loop to clear out all emp elements  */\n              emp[i].emp_nbr = 0;\n              emp[i].last_name[0] = '\\0';\n              emp[i].pay_grade = 'h';\n              emp[i].pay_data.hourly.hours_worked = 0.0;\n              emp[i].pay_data.hourly.hourly_rate = 0.0;\n            }\n\n            for(i=0;i<12;i++) {      /* loop to build emp elements          */\n              printf(\"\\nEnter emp_nbr for #%d: \",i+1); /* ask for emp_nbr   */\n              gets(string);                            /* read it to string */\n              emp[i].emp_nbr = atoi(string);           /* and convert to int*/\n              if(!(emp[i].emp_nbr)) break;  /* if emp_nbr is zero, break out*/\n              printf(\"\\nEnter last name: \");   /* ask for last name         */\n              gets(string);                    /* read last name into string*/\n              string[11] = '\\0';               /* truncate to 11 byte name  */\n              strcpy(emp[i].last_name,string); /* copy last name to element */\n              printf(\"\\nEnter pay grade, h if hourly, s if salaried: \");\n              emp[i].pay_grade = getche();    /* read pay grade into element*/\n              /**************************************************************/\n              /* if pay_grade is for hourly, ask for, read in, convert, and */\n              /* put into the element the hourly rate and hours worked.     */\n              /**************************************************************/\n              if(emp[i].pay_grade == 'h') {\n                printf(\"\\nEnter hourly rate, dollars and cents: \");\n                gets(string);\n                emp[i].pay_data.hourly.hourly_rate = atof(string);\n                printf(\"\\nEnter hours worked with 2 decimal places: \");\n                gets(string);\n                emp[i].pay_data.hourly.hours_worked = atof(string);\n              }\n              /**************************************************************/\n              /* if pay_grade is not for hourly, assumption is that it is   */\n              /* for salaried. Ask for, read in, convert, and move annual   */\n              /* salary to the array element.                               */\n              /**************************************************************/\n              else {\n                printf(\"\\nEnter annual salary, dollars and cents: \");\n                gets(string);\n                emp[i].pay_data.annual_salary = atof(string);\n              }\n            }\n          }                                   /* end of main function       */\n\n./ ADD NAME=SYLLABUS 0100-02144-02144-0950-00090-00090-00000-BC0THOR\n         ******************************************************************\n         *            Elementary C Programming                    SYLLABUS*\n         ******************************************************************\n                      Course Syllabus                                Page 1\n\n         Objectives:  On completion, the student should be able to\n                      understand, write, compile, test, and execute simple\n                      programs using the C language.\n\n         Audience:    Persons who plan to code in the C language,\n                      analyze programs written in C, design systems that\n                      might include C programs, or who wish to expand their\n                      general data processing skills to prepare for Client\n                      Server environments.\n\n         Prereq's:    Students should have recent applications coding\n                      experience in some second or third generation\n                      compiled computer language such as Basic, COBOL,\n                      Pascal, C, Fortran, PL/I, etc.\n\n\n\n                                          Course Content\n\n         Session 1  - Installation, Customizing, and Checkout:\n                      Installing the compiler and integrated development\n                      environment, customizing the compiler and IDE, running\n                      under OS/2, create, compile, and execute a short program.\n\n         Session 2  - Basic Structure of C Programs:\n                      Syntax, comments, program organization, functions, the\n                      main() function, function Prototypes, preprocessor\n                      directives, escape sequences.\n\n         Session 3  - Variables, Operators, and printf:\n                      Lifetime and visibility, definition syntax, types of\n                      variables, naming variables, initializing variables,\n                      arithmetic operators, increment and decrement\n                      operators, printf() syntax and use.\n\n         Session 4  - Include, Define, and Functions:\n                      Syntax, parameters, prototype, returning values,\n                      passing data (by reference, by value), external\n                      variables.\n\n         Session 5  - Arrays, Strings, and Constants:\n                      Defining and initializing arrays, strings, and\n                      constants.\n\n         Session 6.   Relational and Logical Operators and Decisions:\n                      Relational operators, logical operators, if\n                      statements, and logical expressions.\n\n         Session 7  - Loops and Keyboard Input Functions\n                      For loops, while loops, do while loops, break and\n                      continue statements, getc, getch, getche and\n                      gets functions.\n\n         ******************************************************************\n         *            Elementary C Programming                    SYLLABUS*\n         ******************************************************************\n                      Course Syllabus                                Page 2\n\n         Session 8  - Pointers:\n                      Referring to elements of arrays, sending to functions,\n                      pointers to pointers.\n\n         Session 9  - Structures and Unions:\n                      Structures, unions, unions of structures, structures\n                      including unions.\n\n         Session 10 - Switch statements and the conditional operator.\n\n         Session 11 - Advanced Variables:\n                      Pointer notation for structures, enumerated data type,\n                      typedef, type conversion and casting.\n\n         Session 12 - Files and I/O Part 1:\n                      Types of disk I/O, standard (stream) I/O, binary mode\n                      and text mode.\n\n         Session 13 - Files and I/O Part 2:\n                      Record I/O, random access, using handles.\n\n         Session 14 - Miscellaneous topics:\n                      The goto statement, labels, models, separate\n                      compilation, projects, bitwise operators, operator\n                      precedence,\n\n\n./ ADD NAME=TEMPCONV 0100-02144-02144-0950-00059-00059-00000-BC0THOR\n         /***************************************************************/\n         /*                         tempconv.c                          */\n         /* tempconv.c converts a celcius temperature to the equivalent */\n         /* fahrenheit temperature and displays both temperatures. The  */\n         /* celcius temperatures are contained in a table within the    */\n         /* program, and only positive temperatures produce a display.  */\n         /***************************************************************/\n\n         #include <stdio.h>              /* include standard I/O header */\n\n         #define MAX_ENTRIES 3           /* define MAX_ENTRIES = 3      */\n\n         float fahrenheit;               /* define fahrenheit           */\n         float celcius[MAX_ENTRIES] = {-12.5, 32.0, 212.0}; /* celcius  */\n         int i;                          /* define i                    */\n\n         void compute_fahrenheit(void);  /* compute_fahrenheit prototype*/\n\n\n         /***************************************************************/\n         /* main function: initial entry point for program              */\n         /***************************************************************/\n\n         void main() {\n\n           i = 0;                        /* set i to zero               */\n           if(celcius[i] > 0.0) {        /* positive celcius value?     */\n             compute_fahrenheit();          /* yes, go convert          */\n             printf(\"%f celcius = %f fahrenheit\\n\",celcius[i],fahrenheit);\n           }\n\n           i = 1;                        /* set i to one                */\n           if(celcius[i] > 0.0) {        /* positive celcius value?     */\n             compute_fahrenheit();          /* yes, go convert          */\n             printf(\"%f celcius = %f fahrenheit\\n\",celcius[i],fahrenheit);\n           }\n\n           i = 2;                        /* set i to two                */\n           if(celcius[i] > 0.0) {        /* positive celcius value?     */\n             compute_fahrenheit();          /* yes, go convert          */\n             printf(\"%f celcius = %f fahrenheit\\n\",celcius[i],fahrenheit);\n           }\n\n         }                               /* end of main function        */\n\n         /***************************************************************/\n         /* compute_fahrenheit: compute the fahrenheit equivalent to a  */\n         /* celcius temperature.                                        */\n         /***************************************************************/\n\n         void compute_fahrenheit(void) {  /* compute_fahrenheit header  */\n           /*************************************************************/\n           /* The calculation below computes the fahrenheit equivalent  */\n           /* of a celcius temperature as:                              */\n           /*    fahrenheit = (9/5 * celcius) + 32                      */\n           /*************************************************************/\n           fahrenheit = ((((celcius[i]) * 9) / 5) + 32);\n         }                               /* end of compute_fahrenheit   */\n\n./ ADD NAME=VER2EDIT 0100-02144-02144-0950-00060-00060-00000-BC0THOR\n  *****************************************************************************\n  *                           TURBO-C EDITOR COMMANDS              EDITOR2.002*\n\n  *****************************************************************************\n\n  Cursor Left                Left Arrow       Insert Mode toggle         Ins\n\n  Cursor Right               Right Arrow      Bookmark, Set 0-3          cL0-3\n\n  Cursor Up                  Up Arrow         Bookmark, Move to 0-3      cK0-3\n\n  Cursor Down                Down Arrow       Move to Previous Pos       cKP\n\n  Cursor to Left of Line     Home             Line, Insert               cJ\n\n  Cursor to Right of Line    End              Line, Delete               cD\n\n  Cursor to Top of Screen    cHome            Line, Erase to End         cE\n\n  Cursor to Bottom of Screen cEnd             Line, Restore              cKR\n\n  Cursor to Top of File      cT               Find Matching }, ], )      c]\n\n  Cursor to Bottom of File   cB               Find Match Prev {, [, (    c[\n\n  Screen Scroll Up           cW               Find String                cF\n\n  Screen Scroll Down         cZ               Find & Replace             cR\n\n  Screen Page Up             PgUp             Find, Repeat               cU\n\n  Screen Page Down           PgDn               B=Backward, W=Whole Words,\n\n  Block, Mark Begin          cS                 G=Global, L=Local in Block\n\n  Block, Mark End            cV                 N=Auto Replace, U=Ignore Case\n\n  Block, Move to Begin       cQ               Character, Delete          Del\n\n  Block, Move to End         cA               Character, Delete Left     Backspa\nce\n  Block, Hide/Show toggle    cH               Tab                        Tab\n\n  Block, Copy Above Cursor   cC               Tab, toggle                cKT\n\n  Block, Move Above Cursor   cG               Autoindent toggle          sTab\n\n  Block, Delete              cY               Unindent toggle            cKX\n\n  Block, Read From Disk      cN               Insert Control Char        cKC\n\n  Block, Write to Disk       cO               Optimal Fill toggle        cKB\n\n  Block, Indent              cKI              Abort Operation            Esc\n\n  Block, Unindent            cKU              Exit Editor                cX\n\n  Block, Print               cP               Language Help              cF1\n\n\n./ ADD NAME=VER2LSN1 0100-02144-02144-0950-00139-00139-00000-BC0THOR\n         *----------------------------------------------------------------*\n         *                    Elementary C Programming         LESSON2.001*\n         *----------------------------------------------------------------*\n                          Session 1 - Getting Started                Page 1\n\n         I.  Install Turbo C Version 2.0 (DOS).\n             A. Put the INSTALL disk in the A drive.\n             B. Enter a:install\n                1. At first window press ENTER to continue\n                2. At second window press ENTER to use drive A for input\n                3. At third window press the down-arrow about 7 times until\n                   the START INSTALLATION selection is highlighted, then\n                   press ENTER.\n                4. Follow directions until installation is complete.\n             D. Check to see that CONFIG.SYS contains FILES=20 or more. If\n                not, add it using an ASCII editor (NOT WP).\n             E. Edit AUTOEXEC.BAT and add to the PATH list:\n                        ;C:\\TC;C:\\TC\\OUTPUT\n             F. Create subdirectories CSOURCE and OUTPUT under the TC\n                directory:\n                1. Enter cd c:\\tc\n                2. Enter md c:\\csource\n                3. Enter md c:\\output\n             G. Re-boot the machine to make the updated CONFIG.SYS and\n                AUTOEXEC.BAT active.\n             H. Configure Turbo C for your environment.\n                1. Enter cd c:\\tc\\csource\n                2. Enter tc\n                3. When the TURBO C window appears enter Alt-O\n                4. When the Options pull-down appears, enter D\n                5. When the directories window appears, enter O\n                6. In the Output Directory window, enter C:\\TC\\OUTPUT\n                7. Enter T\n                8. In the Turbo C Directory window, enter C:\\TC\\CSOURCE\n                9. Press Esc to get back to the Options window, then press\n                   S to save.\n                10. Enter C:\\TC\\CSOURCE\n                11. Press Esc to return to the EDIT window.\n             I. References\n                1. Turbo C User's Guide pages 10-12.\n\n         II. Test the Turbo C installation.\n             A. Enter Alt-F to get the File pull-down.\n             B. Enter N for a new source file\n             C. Enter the following program (observe case):\n                 /* hello.c -- Hello, World! */\n                 #include <stdio.h>\n                 main() {\n                   printf(\"\\nHello, World!\");\n                 }\n             D. To save the program enter Alt-F to get the File pull-down,\n                then W to get the New Name window and enter hello.c as the\n                name of the program.\n             E. Press Ctrl-F9 to compile and run the program. If all goes\n                well you will see a compile window, then a linker window,\n                then a flicker as the program executes, then the EDIT screen.\n                If you're having a bad day, you may get an error. Fix the code\n                and try again.\n         *----------------------------------------------------------------*\n         *                    Elementary C Programming         LESSON2.001*\n         *----------------------------------------------------------------*\n                          Session 1 - Getting Started                Page 2\n\n             F. To check the program output enter Alt-F5. This should show you\n                the DOS command screen with the display showing:\n                      Hello, World!\n             G. Press any key to return to the Integrated Development\n                Environment (IDE).\n             H. References: Turbo C User's Guide page 10.\n\n         III. Using the Integrated Development Environment.\n             A. To activate the menu bar, press F10 then use the left and\n                right arrow keys to select the desired pull-down. You can also\n                enter Alt- followed by the first letter of the desired pull-\n                down (A, E, R, C, P, O, D, or B) to go directly.\n             B. Along the bottom of the IDE screen you can see some of the F-\n                key values. If you press and hold the Alt key a few seconds\n                the values change to the Alt-f-key values.\n             C. F1 is the HELP key and gives information on use of the editor.\n                To exit HELP, press Esc.\n             D. Move the cursor to any letter within the word printf on the\n                edit screen, then press Ctrl-F1. This gives language help for\n                the item under the cursor. If the item selected has no help, a\n                general screen is presented with two selectable items:\n                keywords and header files. When in the language help area you\n                can use the arrow keys to select other related topics. Press\n                enter at any of these to display the related topic. To exit\n                language help, press Esc.\n             E. You may notice your IDE screen has two windows showing, a\n                large one at the top with the name Edit and a smaller one near\n                the bottom with the name Watch. The Edit window has a double\n                line across the top, showing it is the \"active\" window. If you\n                press F6, the Watch window will become the \"active\" window.\n                You can use the F6 key to switch between any windows on the\n                screen. To make the \"active\" window occupy the full screen,\n                press F5, the \"zoom\" key. To restore it to the smaller size,\n                press F5 again.\n             F. Another useful key is F9, which does a Make on your program.\n                This is equivalent to a compile and link - very handy.\n             G. Alt-F5 is used to switch displays to the DOS screen so you can\n                see the output of programs run while in the IDE. Pressing any\n                key returns you to the IDE.\n             H. The C language uses a lot of symbol pairs, such as (), {}, [],\n                \"\", and /* */. It is often important to be able to identify\n                the matching symbol within a pair. To do this, put the cursor\n                on one of the symbols, then press Ctrl-Q-[. The display will\n                scroll if necessary and the cursor will be on the opposite\n                symbol of the pair.\n             I. References: Turbo C User's Guide chapters 3 and 7.\n         *----------------------------------------------------------------*\n         *                    Elementary C Programming         LESSON2.001*\n         *----------------------------------------------------------------*\n                          Session 1 - Getting Started                Page 3\n         IV. Turbo C Utilities\n             A. Utility programs are executed outside the IDE at the normal\n                DOS prompt.\n             B. The TOUCH utility is used to force the compiler to recompile a\n                program. This is sometimes necessary, as the compiler compares\n                the file dates to decide if a compile is necessary, and if it\n                decides the current program is current it will not recompile.\n             C. GREP is a general purpose file searching program.\n             D. TCINST can be used to change many installation options, but it\n                is of most use in changing the Editor key uses. When you enter\n                tcinst, an installation menu appears. Choose the Editor\n                Commands selection. A scrollable window of Editor command keys\n                appears which shows primary commands on the left and secondary\n                on the right. Use arrow keys to select the command to change,\n                then press enter and type in the change, then press enter to\n                make it active or Esc to ignore the changes. Typing R will\n                restore all commands to their default values. Pressing F4\n                rotates between wordstar-like, ignore case, and verbatim. When\n                changes are complete, enter Esc, then Q to quit and save, then\n                Y to save or N to exit without saving. Making changes can\n                provide much improved operation, however the manual and help\n                screens will no longer be correct for the changed keys.\n             E. References: Turbo C Reference Guide pages 22, 509, 565-569,\n                481.\n\n\n./ ADD NAME=VER3EDIT 0100-02144-02144-0950-00037-00037-00000-BC0THOR\n\n                      ***** TURBO-C++ EDITOR COMMANDS *****\n\n*************************************************************************\n* Cursor to Left of Line     Home  \u00b3 \u00b3 Bookmark, Set 0-3          cL0-3 *\n* Cursor to Right of Line    End   \u00b3 \u00b3 Bookmark, Move to 0-3      cK0-3 *\n* Cursor to Top of Screen    cHome \u00b3 \u00b3 Move to Previous Pos       cS    *\n* Cursor to Bottom of Screen cEnd  \u00b3 \u00b3 Line, Insert               cJ    *\n* Cursor to Top of File      cT    \u00b3 \u00b3 Line, Delete               cD    *\n* Cursor to Bottom of File   cB    \u00b3 \u00b3 Line, Erase to End         cE    *\n* Screen Scroll Up           cW    \u00b3 \u00b3 Find Matching }, ], )      c]    *\n* Screen Scroll Down         cZ    \u00b3 \u00b3 Find String                cF    *\n* Block, Mark Begin          cLfAr \u00b3 \u00b3 Find & Replace             cR    *\n* Block, Mark End            cRgAr \u00b3 \u00b3 Find Next Occurrence       cU    *\n* Block, Hide/Show toggle    cPgDn \u00b3 \u00b3 Language Help              cF1   *\n* Block, Copy                cC    \u00b3 \u00b3                                  *\n* Block, Move                cG    \u00b3 \u00b3                                  *\n* Block, Delete              cY    \u00b3 \u00b3                                  *\n* Block, Read From Disk      cN    \u00b3 \u00b3                                  *\n* Block, Write to Disk       cO    \u00b3 \u00b3 C:\\TC3\\DOC\\DICK.TEM              *\n*************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n./ ADD NAME=VER3LSN1 0100-02144-02144-0950-00099-00099-00000-BC0THOR\n         *----------------------------------------------------------------*\n         *                    Elementary C Programming         LESSON3.001*\n         *----------------------------------------------------------------*\n                             Session 1 - Getting Started            Page 1\n\n         I. Session 1\n            A. Install Turbo C++ Version 3.0 (DOS)\n               .Must have 10,000,000 bytes free on hard drive\n               .Put Disk 1 in the A drive\n               .Type A:INSTALL and press ENTER\n               .Press ENTER for Source Drive is A\n               .Arrow down to Start Installation, press ENTER\n               .Remove/Insert disks as requested until all 5 are done\n               .At end press ENTER, then ESC to get out of README\n            B. Make source and output directories\n               .Type following lines (ENTER after each):\n                CD C:\\TC\n                MD CSOURCE\n                MD OUTPUT\n            C. If running a DOS window under OS2:\n               .Right click on ICON for the DOS window to be used.\n               .Left click on Open\n               .Left click on Settings\n               .Left click on Session\n               .Left click on DOS Settings\n               .Left click on DOS_AUTOEXEC\n               .Note name in the Value: window at right. This is the name\n                of the AUTOEXEC.BAT file for this session.\n               .Scroll window until DPMI_DOS_API appears.\n               .Left click on DPMI_DOS_API\n               .Left click on right end of the Value: window.\n               .Left click on ENABLED\n               .Left click on Save (bottom left)\n               .Double-click on upper left of Generic - Settings window\n            D. Set up DOS System files using a file editor. Be sure to use\n               a simple ASCII editor such as EDLIN or DOS's EDIT, not one\n               like WordPerfect which adds control information to the file.\n               .Put FILES=20 (or more) in CONFIG.SYS\n               .Add ;C:\\TC\\BIN;C:\\TC\\OUTPUT to path in AUTOEXEC.BAT\n               .Create C:\\TC.BAT containing the following lines:\n                CD C:\\TC\\CSOURCE\n                C:\\TC\\BIN\\TC\n                CD C:\\\n            E. Re-Boot the system to bring in the updated system files. If\n               you are running DOS under OS2, just close the session and\n               reopen it.\n            F. At the C:\\> prompt, type TC. This should start Turbo C++\n               which will display a window with information about Turbo C++\n               and with OK at the bottom. Press ENTER to continue.\n            G. Activate the Options pull-down menu by typing Alt-O or\n               F10/O.\n            H. Type D to activate the Directories window.\n            I. Tab to the Output Directories window and type C:\\TC\\OUTPUT\n               (do not press ENTER).\n            J. Tab to the Source Directories window and type C:\\TC\\CSOURCE\n               then press ENTER.\n            K. The pull-downs will disappear, leaving the Options menu\n               selection highlighted. Press ENTER for the pull-down, then\n               type S for the save window, then press ENTER to save.\n         *----------------------------------------------------------------*\n         *                    Elementary C Programming         LESSON3.001*\n         *----------------------------------------------------------------*\n                             Session 1 - Getting Started            Page 2\n\n            L. Create, compile, and execute a short program.\n               .Start a Turbo C++ session by typing TC and pressing ENTER.\n               .Open a file by typing Alf-F/O or just F3\n               .The name window will contain *.CPP initially. Ignore this\n                and type HELLO.C which will replace the *.CPP, then press\n                ENTER.\n               .An EDIT window will open with a double line around it,\n                showing it is the \"active\" window. HELLO.C will appear\n                centered at the top.\n               .Type the following lines (ENTER after each line):\n                main() {\n                  printf(\"Hello, World!\");\n                }\n               .Save this source program by pressing F2.\n               .Compile and link (Make) the program by pressing F9.\n               .A window should appear saying \"Success Press Any Key\".\n                Press any key.\n               .The edit screen reappears with a MESSAGE screen at the\n                bottom. The double line is on the MESSAGE screen, which is\n                the \"active\" screen. The messages include a warning\n                concerning function returning a value. Note that the arrow\n                keys move you around in the MESSAGE window.\n               .Switch to the EDIT window by pressing F6\n               .Move the cursor to one of the letters in the word printf\n                and press Ctrl-F1 for HELP concerning this function.\n               .Scroll down the HELP window until you see the Return Value\n                header. This explains the value returned by printf.\n               .Since we only got a warning, the program should execute. To\n                run the program, press Alt-R/R or Ctrl-F9. The program will\n                execute. Since it writes to the screen, your screen will\n                blink momentarily.\n               .To view the output of the program press Alt-F5. You should\n                see Hello, World! as the last line displayed. To return to\n                Turbo C++, press any key.\n               .Press Alt-X to exit from Turbo C++.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCLASS": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x14O\\x01\\x02\\x14O\\tP\\x1dn\\x1dn\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-24T00:00:00", "modifydate": "2002-05-24T09:50:00", "lines": 7534, "newlines": 7534, "modlines": 0, "user": "BC0THOR"}, "text": "./ ADD NAME=$$README 0100-02143-02143-1556-00037-00037-00000-BC0THOR\n************************************************************************\n* CLASS: the COBOL Language class library. This is an incomplete course*\n*        that may be of use to someone wishing to develop an elementary*\n*        class in COBOL. I had a request to develop the class from a   *\n*        non-programmer who had to deal with COBOL programmers, and    *\n*        hoped to be able to communicate better with them after the    *\n*        class. I presented an initial class in commonly used computer *\n*        and programming terminology, however work schedules interfered*\n*        and the students were never able to wangle time to take the   *\n*        follow-on, so I never finished the course.                    *\n************************************************************************\n$$README  Text: this file\nCALC100C  Sample tax calculation program in COBOL.\nCALC100X  Execution JCL for the CALC100C program.\nCHAR100C  Sample COBOL program to get number from user, display edited.\nCHAR200C  Sample COBOL program gets name from user, displays converted.\nCHAR300C  Sample COBOL program gets ZIP-code, displays with hyphen.\nCOBLKEDJ  JCL to compile and linkedit a COBOL program.\nDATE100C  Sample COBOL program to calculate elapsed days between dates.\nDATE200C  Sample COBOL program to display age, given birth date.\nDELDEFNJ  JCL using IDCAMS to delete, define a VSAM dataset.\nIND1000C  Sample COBOL program showing VSAM READs and WRITEs.\nIND2000C  Sample COBOL program shows Add/Change/Delete for a VSAM file.\nIND4000C  Sample COBOL program reads, displays record from VSAM file.\nJOBCARDJ  JCL job card sample.\nLISTMODC  Sample COBOL program reads source program, prints statistics.\nPAYMNTC   Sample COBOL program creates, maintains VSAM payroll file.\nPAYRECF   Sample COBOL COPY book describing a record.\nREL4000C  Sample COBOL program processes a relative record VSAM file.\nRPT1000C  Sample COBOL report program.\nRPT2000C  Sample COBOL report program.\nRPT3000C  Sample COBOL report program.\nRPT5000C  Sample COBOL report program.\nSEQ1000C  Sample COBOL program using sequential and VSAM datasets.\nSEQ2000C  Sample COBOL program using sequential and VSAM datasets.\nSKELETNC  Sample COBOL program that can be used to develop new programs.\nSRT1000C  Sample COBOL program showing code for an internal sort.\n./ ADD NAME=$$READM1 0100-01302-01302-1202-00009-00009-00000-BC0THOR\n000100This PDS contains members to be used in an elementary COBOL programming\n      class. In most cases, the first 7 characters identify a program, and\n      the last character is the type, where:\n        C = COBOL source program.\n        F = FILEDESC (copy book).\n        X = Execution JCL for a class program.\n        J = Execution JCL for a utility program.\n        D = Data file for a class program.\n        e = Second data file for a class program.\n./ ADD NAME=CALC100C 0101-01299-01302-1119-00039-00039-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. CALC100C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 DATA DIVISION.\n001000*\n001100 FILE SECTION.\n001200*\n001300 WORKING-STORAGE SECTION.\n001400*\n001500 77  END-OF-SESSION-SWITCH       PIC X       VALUE \"N\".\n001600 77  SALES-AMOUNT                PIC 9(5)V99.\n001700 77  SALES-TAX                   PIC Z,ZZZ.99.\n001800*\n001900 PROCEDURE DIVISION.\n002000*\n002100 000-CALCULATE-SALES-TAX.\n002200*\n002300     PERFORM 100-CALCULATE-ONE-SALES-TAX\n002400         UNTIL END-OF-SESSION-SWITCH = \"Y\".\n002500     DISPLAY \"END OF SESSION.\".\n002600     STOP RUN.\n002700*\n002800 100-CALCULATE-ONE-SALES-TAX.\n002900*\n003000     DISPLAY \"-----------------------------------------------\".\n003100     DISPLAY \"TO END PROGRAM, ENTER 0.\".\n003200     DISPLAY \"TO CALCULATE SALES TAX, ENTER THE SALES AMOUNT.\".\n003300     ACCEPT SALES-AMOUNT.\n003400     IF SALES-AMOUNT = ZERO\n003500         MOVE \"Y\" TO END-OF-SESSION-SWITCH\n003600     ELSE\n003700         COMPUTE SALES-TAX ROUNDED =\n003800             SALES-AMOUNT * .0785\n003900         DISPLAY \"SALES TAX = \" SALES-TAX.\n./ ADD NAME=CALC100X 0102-01302-01306-1536-00011-00015-00000-BC0THOR\n//*******************************************************************\n//*          ???????.PDS.CLASS(CALC100X)                            *\n//*******************************************************************\n//CALC100C EXEC PGM=CALC100C\n//STEPLIB  DD   DSN=???????.LOAD.LOAD,DISP=SHR\n//SYSUDUMP DD   SYSOUT=*\n//SYSOUT   DD   SYSOUT=*\n//SYSIN    DD   *\n0012037\n5127493\n0000000\n./ ADD NAME=CHAR100C 0101-01302-01302-1120-00072-00072-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200\n000300 PROGRAM-ID. CHAR100C.\n000400\n000500 ENVIRONMENT DIVISION.\n000600\n000700 INPUT-OUTPUT SECTION.\n000800\n000900 DATA DIVISION.\n001000\n001100 FILE SECTION.\n001200\n001300 WORKING-STORAGE SECTION.\n001400\n001500 01  SWITCHES.\n001600     05  END-OF-SESSION-SWITCH   PIC X       VALUE \"N\".\n001700         88  END-OF-SESSION                  VALUE \"Y\" \"Y\".\n001800     05  VALID-ENTRY-SWITCH      PIC X.\n001900         88  VALID-ENTRY                     VALUE \"Y\".\n002000\n002100 01  WORK-FIELDS.\n002200     05  USER-ENTRY              PIC X(5).\n002300     05  WORK-FIELD              PIC X(6).\n002400     05  EDITED-RESULT           PIC S9(5).\n002500     05  COUNT-1                 PIC S9(3).\n002600     05  COUNT-2                 PIC S9(3).\n002700\n002800 PROCEDURE DIVISION.\n002900\n003000 000-EDIT-NUMERIC-ENTRIES.\n003100\n003200     PERFORM 100-EDIT-NUMERIC-ENTRY\n003300         UNTIL END-OF-SESSION.\n003400     DISPLAY \"END OF SESSION.\".\n003500     STOP RUN.\n003600\n003700 100-EDIT-NUMERIC-ENTRY.\n003800\n003900     DISPLAY \"-----------------------------------------------\".\n004000     DISPLAY \"TO END PROGRAM, ENTER Y (OR Y).\".\n004100     ACCEPT END-OF-SESSION-SWITCH.\n004200     DISPLAY \"-----------------------------------------------\".\n004300     IF NOT END-OF-SESSION\n004400         PERFORM 110-GET-INPUT-FIELDS\n004500         PERFORM 120-EDIT-NUMERIC-ENTRY\n004600         IF VALID-ENTRY\n004700             DISPLAY \"EDITED RESULT = \" EDITED-RESULT\n004800         ELSE\n004900             DISPLAY \"INVALID ENTRY.\".\n005000\n005100 110-GET-INPUT-FIELDS.\n005200\n005300     DISPLAY \"ENTER NUMERIC FIELD (99999).\".\n005400     ACCEPT USER-ENTRY.\n005500\n005600 120-EDIT-NUMERIC-ENTRY.\n005700\n005800     MOVE ZERO TO COUNT-1 COUNT-2.\n005900     MOVE USER-ENTRY TO WORK-FIELD.\n006000\n006100     INSPECT WORK-FIELD\n006200         TALLYING COUNT-1 FOR ALL \"$\" ALL \",\" ALL \".\"\n006300         REPLACING LEADING \" \" BY \"0\".\n006400\n006500     IF COUNT-1 = 0\n006600         INSPECT WORK-FIELD\n006700             TALLYING COUNT-2 FOR CHARACTERS BEFORE \" \"\n006800         MOVE WORK-FIELD (1:COUNT-2) TO EDITED-RESULT\n006900         MOVE \"Y\" TO VALID-ENTRY-SWITCH\n007000     ELSE\n007100         MOVE \"N\" TO VALID-ENTRY-SWITCH.\n007200\n./ ADD NAME=CHAR200C 0101-01302-01302-1120-00065-00065-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200\n000300 PROGRAM-ID. CHAR200C.\n000400\n000500 ENVIRONMENT DIVISION.\n000600\n000700 INPUT-OUTPUT SECTION.\n000800\n000900 DATA DIVISION.\n001000\n001100 FILE SECTION.\n001200\n001300 WORKING-STORAGE SECTION.\n001400\n001500 01  SWITCHES.\n001600     05  END-OF-SESSION-SWITCH   PIC X       VALUE \"N\".\n001700         88  END-OF-SESSION                  VALUE \"Y\" \"Y\".\n001800\n001900 01  WORK-FIELDS.\n002000     05  FULL-NAME               PIC X(20).\n002100     05  NAME-1                  PIC X(10).\n002200     05  POINTER-FIELD           PIC S9(3).\n002300\n002400 PROCEDURE DIVISION.\n002500\n002600 000-CONVERT-NAME-FIELDS.\n002700\n002800     PERFORM 100-CONVERT-NAME-FIELD\n002900         UNTIL END-OF-SESSION.\n003000     DISPLAY \"END OF SESSION.\".\n003100     STOP RUN.\n003200\n003300 100-CONVERT-NAME-FIELD.\n003400\n003500     DISPLAY \"-----------------------------------------------\".\n003600     DISPLAY \"TO END PROGRAM, ENTER Y (OR Y).\".\n003700     ACCEPT END-OF-SESSION-SWITCH.\n003800     DISPLAY \"-----------------------------------------------\".\n003900     IF NOT END-OF-SESSION\n004000         PERFORM 110-GET-INPUT-FIELDS\n004100         PERFORM 120-CONVERT-NAME\n004200         DISPLAY \"RESULT: \" FULL-NAME.\n004300\n004400 110-GET-INPUT-FIELDS.\n004500\n004600     DISPLAY \"ENTER FULL NAME IN ALL CAPS (20).\".\n004700     ACCEPT FULL-NAME.\n004800\n004900 120-CONVERT-NAME.\n005000\n005100     MOVE FUNCTION LOWER-CASE (FULL-NAME) TO FULL-NAME.\n005200     MOVE FUNCTION UPPER-CASE (FULL-NAME (1:1))\n005300         TO FULL-NAME (1:1).\n005400     MOVE 1 TO POINTER-FIELD.\n005500     UNSTRING FULL-NAME DELIMITED BY ALL \" \"\n005600         INTO NAME-1\n005700         WITH POINTER POINTER-FIELD.\n005800     MOVE FUNCTION UPPER-CASE (FULL-NAME (POINTER-FIELD:1))\n005900         TO FULL-NAME (POINTER-FIELD:1).\n006000     UNSTRING FULL-NAME DELIMITED BY ALL \" \"\n006100         INTO NAME-1\n006200         WITH POINTER POINTER-FIELD.\n006300     IF POINTER-FIELD <= 20\n006400        MOVE FUNCTION UPPER-CASE (FULL-NAME (POINTER-FIELD:1))\n006500             TO FULL-NAME (POINTER-FIELD:1).\n./ ADD NAME=CHAR300C 0101-01302-01302-1123-00079-00079-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200\n000300 PROGRAM-ID. CHAR300C.\n000400\n000500 ENVIRONMENT DIVISION.\n000600\n000700 INPUT-OUTPUT SECTION.\n000800\n000900 DATA DIVISION.\n001000\n001100 FILE SECTION.\n001200\n001300 WORKING-STORAGE SECTION.\n001400\n001500 01  SWITCHES.\n001600     05  END-OF-SESSION-SWITCH   PIC X       VALUE \"N\".\n001700         88  END-OF-SESSION                  VALUE \"Y\" \"Y\".\n001800     05  VALID-ENTRY-SWITCH      PIC X.\n001900         88  VALID-ENTRY                     VALUE \"Y\".\n002000\n002100 01  WORK-FIELDS.\n002200     05  ZIP-CODE                PIC X(10).\n002300     05  EDITED-ZIP-CODE         PIC X(9).\n002400     05  COUNT-1                 PIC S9(3).\n002500     05  COUNT-2                 PIC S9(3).\n002600     05  COUNT-3                 PIC S9(3).\n002700\n002800 PROCEDURE DIVISION.\n002900\n003000 000-EDIT-ZIP-CODES.\n003100\n003200     PERFORM 100-EDIT-ZIP-CODE\n003300         UNTIL END-OF-SESSION.\n003400     DISPLAY \"END OF SESSION.\".\n003500     STOP RUN.\n003600\n003700 100-EDIT-ZIP-CODE.\n003800\n003900     DISPLAY \"-----------------------------------------------\".\n004000     DISPLAY \"TO END PROGRAM, ENTER Y (OR Y).\".\n004100     ACCEPT END-OF-SESSION-SWITCH.\n004200     DISPLAY \"-----------------------------------------------\".\n004300     IF NOT END-OF-SESSION\n004400         PERFORM 110-GET-INPUT-FIELDS\n004500         PERFORM 120-EDIT-ZIP-CODE-ENTRY\n004600         IF VALID-ENTRY\n004700             DISPLAY \"EDITED ZIP CODE = \" EDITED-ZIP-CODE\n004800         ELSE\n004900             DISPLAY \"INVALID ENTRY.\".\n005000\n005100 110-GET-INPUT-FIELDS.\n005200\n005300     DISPLAY \"ENTER ZIP CODE WITH OR WITHOUT A HYPHEN (-).\".\n005400     ACCEPT ZIP-CODE.\n005500\n005600 120-EDIT-ZIP-CODE-ENTRY.\n005700\n005800     MOVE ZERO TO COUNT-1 COUNT-2 COUNT-3.\n005900\n006000     INSPECT ZIP-CODE TALLYING\n006100         COUNT-1 FOR ALL \"-\"\n006200         COUNT-2 FOR CHARACTERS BEFORE \"-\".\n006300     INSPECT ZIP-CODE\n006400         TALLYING COUNT-3 FOR CHARACTERS BEFORE \" \".\n006500\n006600     IF COUNT-1 = 0 AND (COUNT-3 = 5 OR COUNT-3 = 9)\n006700         MOVE ZIP-CODE TO EDITED-ZIP-CODE\n006800         MOVE \"Y\" TO VALID-ENTRY-SWITCH\n006900     ELSE\n007000         IF COUNT-1 = 1 AND COUNT-2 = 5\n007100             MOVE ZIP-CODE (1:5) TO EDITED-ZIP-CODE\n007200             MOVE \"Y\" TO VALID-ENTRY-SWITCH\n007300             IF COUNT-3 = 10\n007400                 MOVE ZIP-CODE (7:4)  TO EDITED-ZIP-CODE (6:)\n007500             END-IF\n007600         ELSE\n007700             MOVE \"N\" TO VALID-ENTRY-SWITCH\n007800         END-IF\n007900     END-IF.\n./ ADD NAME=COBLKEDJ 0108-01288-01303-1535-00047-00051-00000-BC0THOR\n//*******************************************************************\n//*                 ???????.PDS.CLASS(COBLKEDJ)                     *\n//* COMPILE/LINK ???????.PDS.COBOL(########) TO ???????.LOAD.LOAD   *\n//*******************************************************************\n//*------------------------------------------------------------------\n//* COMPILE STEP    (COB390)\n//*------------------------------------------------------------------\n//COMPILE  EXEC PGM=CWPCMAIN\n//STEPLIB  DD   DSN=IGY.V2R1M0.SIGYCOMP,DISP=SHR\n//SYSTERM  DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//CWPERRM  DD   SYSOUT=*\n//SYSPUNCH DD   DUMMY\n//SYSUT1   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n//SYSUT2   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n//SYSUT3   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n//SYSUT4   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n//SYSUT5   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n//SYSUT6   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n//SYSUT7   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n//SYSLIN   DD   DSN=&&SYSLIN,DISP=(NEW,PASS),\n//         UNIT=DISK,SPACE=(CYL,(1,1)),\n//         LRECL=80,RECFM=FB,BLKSIZE=4000\n//SYSLIB   DD   DSN=???????.PDS.CLASS,DISP=SHR\n//         DD   DSN=EMVSP.OUTPUT.FILEDESC,DISP=SHR\n//SYSIN    DD   DSN=???????.PDS.CLASS(########),DISP=SHR\n//XOPTIONS DD   DSN=SPP.XPEDTSO.V6R6M0.XOPTIONS,DISP=SHR\n//CWPDDIO  DD   DSN=???????.TST.XPEDITER.DDIO,DISP=SHR\n//CWPPRMO  DD  *\nCOBOL(OUTPUT(PRINT,DDIO))\nPROCESSOR(OUTPUT(NOPRINT,NODDIO),TEXT(NONE))\nLANGUAGE(COBOL/390)\nDDIO(OUTPUT(NOLIST,NOXREF,FIND,NODMAP,NOOFFSET,COMPRESS))\n//*------------------------------------------------------------------\n//* LINKEDIT STEP\n//*------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,COND=(8,LE),\n//         PARM=('LIST,LET,MAP,XREF,CALL')\n//SYSPRINT DD   SYSOUT=*\n//SYSLIN   DD   DSN=&&SYSLIN,DISP=(SHR,PASS)\n//SYSLIB   DD   DSN=CEE.SCEELKED,DISP=SHR\n//         DD   DSN=???????.LOAD.LOAD,DISP=SHR\n//         DD   DSN=EMVSP.OUTPUT.LOADLIB,DISP=SHR\n//         DD   DSN=SYS1.LINKLIB,DISP=SHR\n//         DD   DSN=SYS1.IMSVS.RESLIB,DISP=SHR\n//SYSLMOD  DD   DSN=???????.LOAD.LOAD(########),DISP=SHR\n//SYSUT1   DD   SPACE=(CYL,(2,2)),UNIT=DISK\n./ ADD NAME=DATE100C 0101-01302-01302-1125-00086-00086-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200\n000300 PROGRAM-ID. DATE100C.\n000400\n000500 ENVIRONMENT DIVISION.\n000600\n000700 INPUT-OUTPUT SECTION.\n000800\n000900 DATA DIVISION.\n001000\n001100 FILE SECTION.\n001200\n001300 WORKING-STORAGE SECTION.\n001400\n001500 01  SWITCHES.\n001600     05  END-OF-SESSION-SWITCH   PIC X       VALUE \"N\".\n001700         88  END-OF-SESSION                  VALUE \"Y\" \"Y\".\n001800\n001900 01  USER-ENTRIES.\n002000\n002100     05  DATE-1                  PIC 9(5).\n002200     05  DATE-1-R REDEFINES DATE-1.\n002300         10  D1-YEAR             PIC 9(2).\n002400         10  D1-DAYS             PIC 9(3).\n002500     05  DATE-2                  PIC 9(5).\n002600     05  DATE-2-R REDEFINES DATE-2.\n002700         10  D2-YEAR             PIC 9(2).\n002800         10  D2-DAYS             PIC 9(3).\n002900\n003000 01  WORK-FIELDS.\n003100\n003200     05  WORK-DATE.\n003300         10  WORK-YEAR           PIC 9(2).\n003400         10  WORK-DAYS           PIC 9(3).\n003500     05  TOTAL-DAYS              PIC S9(5).\n003600     05  TOTAL-DAYS-1            PIC S9(5).\n003700     05  TOTAL-DAYS-2            PIC S9(5).\n003800     05  ELAPSED-DAYS            PIC Z(5).\n003900     05  YEAR-REMAINDER          PIC S9.\n004000     05  LEAP-YEARS              PIC S9(3).\n004100\n004200 PROCEDURE DIVISION.\n004300\n004400 000-CALCULATE-ELAPSED-DAYS.\n004500\n004600     PERFORM 100-CALCULATE-ELAPSED-DAYS\n004700         UNTIL END-OF-SESSION.\n004800     DISPLAY \"END OF SESSION.\".\n004900     STOP RUN.\n005000\n005100 100-CALCULATE-ELAPSED-DAYS.\n005200\n005300     DISPLAY \"-----------------------------------------------\".\n005400     DISPLAY \"TO END PROGRAM, ENTER Y (OR Y).\".\n005500     ACCEPT END-OF-SESSION-SWITCH.\n005600     DISPLAY \"-----------------------------------------------\".\n005700     IF NOT END-OF-SESSION\n005800         PERFORM 110-GET-USER-ENTRIES\n005900         PERFORM 120-CALCULATE-ELAPSED-DAYS\n006000         DISPLAY \"ELAPSED DAYS = \" ELAPSED-DAYS.\n006100\n006200 110-GET-USER-ENTRIES.\n006300\n006400     DISPLAY \"ENTER FIRST DATE (YYDDD).\".\n006500     ACCEPT DATE-1.\n006600     DISPLAY \"ENTER SECOND DATE (YYDDD).\".\n006700     ACCEPT DATE-2.\n006800\n006900 120-CALCULATE-ELAPSED-DAYS.\n007000\n007100     MOVE DATE-1 TO WORK-DATE.\n007200     PERFORM 130-COMPUTE-TOTAL-DAYS.\n007300     MOVE TOTAL-DAYS TO TOTAL-DAYS-1.\n007400     MOVE DATE-2 TO WORK-DATE.\n007500     PERFORM 130-COMPUTE-TOTAL-DAYS.\n007600     MOVE TOTAL-DAYS TO TOTAL-DAYS-2.\n007700     COMPUTE ELAPSED-DAYS = TOTAL-DAYS-1 - TOTAL-DAYS-2.\n007800\n007900 130-COMPUTE-TOTAL-DAYS.\n008000\n008100     DIVIDE WORK-YEAR BY 4 GIVING LEAP-YEARS\n008200         REMAINDER YEAR-REMAINDER.\n008300     COMPUTE TOTAL-DAYS = (WORK-YEAR * 365)\n008400                        + WORK-DAYS + LEAP-YEARS.\n008500     IF YEAR-REMAINDER = 0\n008600         COMPUTE TOTAL-DAYS = TOTAL-DAYS - 1.\n./ ADD NAME=DATE200C 0101-01302-01302-1125-00063-00063-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200\n000300 PROGRAM-ID. DATE200C.\n000400\n000500 ENVIRONMENT DIVISION.\n000600\n000700 INPUT-OUTPUT SECTION.\n000800\n000900 DATA DIVISION.\n001000\n001100 FILE SECTION.\n001200\n001300 WORKING-STORAGE SECTION.\n001400\n001500 01  SWITCHES.\n001600     05  END-OF-SESSION-SWITCH        PIC X       VALUE \"N\".\n001700         88  END-OF-SESSION                       VALUE \"Y\" \"Y\".\n001800\n001900 01  CURRENT-DATE-AND-TIME.\n002000\n002100     05  CD-DATE.\n002200         10  CD-YEAR                  PIC 9(4).\n002300         10  CD-MONTH                 PIC 9(2).\n002400         10  CD-DAY                   PIC 9(2).\n002500\n002600 01  USER-ENTRIES.\n002700\n002800     05  BIRTH-MONTH                  PIC 9(2).\n002900     05  BIRTH-DAY                    PIC 9(2).\n003000     05  BIRTH-YEAR                   PIC 9(2).\n003100\n003200 01  WORK-FIELDS.\n003300\n003400     05  USER-AGE                     PIC Z(3).\n003500\n003600 PROCEDURE DIVISION.\n003700\n003800 000-CALCULATE-USER-AGES.\n003900\n004000     ACCEPT CD-DATE FROM DATE YYYYMMDD.\n004100     PERFORM 100-CALCULATE-USER-AGE\n004200         UNTIL END-OF-SESSION.\n004300     DISPLAY \"END OF SESSION.\".\n004400     STOP RUN.\n004500\n004600 100-CALCULATE-USER-AGE.\n004700\n004800     DISPLAY \"-----------------------------------------------\".\n004900     DISPLAY \"TO END PROGRAM, ENTER Y (OR Y).\".\n005000     ACCEPT END-OF-SESSION-SWITCH.\n005100     DISPLAY \"-----------------------------------------------\".\n005200     IF NOT END-OF-SESSION\n005300         PERFORM 110-GET-USER-ENTRIES\n005400         DISPLAY \"AGE = \" USER-AGE.\n005500\n005600 110-GET-USER-ENTRIES.\n005700\n005800     DISPLAY \"ENTER MONTH OF BIRTH.\".\n005900     ACCEPT BIRTH-MONTH.\n006000     DISPLAY \"ENTER DAY OF BIRTH.\".\n006100     ACCEPT BIRTH-DAY.\n006200     DISPLAY \"ENTER YEAR OF BIRTH (99).\".\n006300     ACCEPT BIRTH-YEAR.\n./ ADD NAME=DELDEFNJ 0105-01289-01302-1126-00036-00021-00000-BC0THOR\n//BC0THORJ JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,\n//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=4M\n//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n//*******************************************************************\n//*                 BC0THOR.PDS.CLASS(DELDEFNJ)                     *\n//*                DELETE, THEN DEFINE A VSAM DATA SET              *\n//*******************************************************************\n//SCRATCH  EXEC PGM=IDCAMS\n//SYSPRINT DD   SYSOUT=*\n//SYSIN    DD   *\n  DELETE BC0THOR.TSTCLASS.PAYFILE -\n        PURGE -\n        NOERASE -\n        CLUSTER\n  DEFINE CLUSTER -\n         (NAME(BC0THOR.TSTCLASS.PAYFILE) -\n         SHAREOPTIONS(3 3) -\n         UNIQUE) -\n       INDEX -\n         (NAME(BC0THOR.TSTCLASS.PAYFILE.INDEX) -\n         TRACKS(1 1) -\n         CONTROLINTERVALSIZE(512) -\n         VOLUMES(*) -\n         IMBED -\n         REPLICATE) -\n       DATA -\n         (NAME(BC0THOR.TSTCLASS.PAYFILE.DATA) -\n         VOLUMES(*) -\n         SPEED -\n         KEYS(9 1) -\n         RECORDSIZE(564 564) -\n         FREESPACE(25 25) -\n         CYLINDERS(5 1) -\n         CONTROLINTERVALSIZE(4096))\n  LISTCAT ENTRIES('BC0THOR.TSTCLASS.PAYFILE') ALL\n./ ADD NAME=IND1000C 0101-01302-01302-1128-00077-00077-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. IND100C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000     SELECT INVMASTS ASSIGN TO INVMASTS.\n001100     SELECT INVMASTI ASSIGN TO INVMASTI\n001200                     ORGANIZATION IS INDEXED\n001300                     ACCESS IS SEQUENTIAL\n001400                     RECORD KEY IS IR-ITEM-NO.\n001500*\n001600 DATA DIVISION.\n001700*\n001800 FILE SECTION.\n001900*\n002000 FD  INVMASTS.\n002100*\n002200 01  SEQUENTIAL-RECORD-AREA  PIC X(70).\n002300*\n002400 FD  INVMASTI.\n002500*\n002600 01  INDEXED-RECORD-AREA.\n002700     05  IR-ITEM-NO              PIC X(5).\n002800     05  FILLER                  PIC X(65).\n002900*\n003000 WORKING-STORAGE SECTION.\n003100*\n003200 01  SWITCHES.\n003300     05  INVMAST-EOF-SWITCH      PIC X    VALUE \"N\".\n003400         88  INVMAST-EOF                  VALUE \"Y\".\n003500*\n003600 01  INVENTORY-MASTER-RECORD.\n003700     05  IM-ITEM-NO              PIC X(5).\n003800     05  IM-DESCRIPTIVE-DATA.\n003900         10  IM-ITEM-DESC        PIC X(40).\n004000         10  IM-UNIT-COST        PIC S9(3)V99.\n004100         10  IM-UNIT-PRICE       PIC S9(3)V99.\n004200     05  IM-INVENTORY-DATA.\n004300         10  IM-REORDER-POINT    PIC S9(5).\n004400         10  IM-ON-HAND          PIC S9(5).\n004500         10  IM-ON-ORDER         PIC S9(5).\n004600*\n004700 PROCEDURE DIVISION.\n004800*\n004900 000-CREATE-INVENTORY-FILE.\n005000*\n005100     OPEN INPUT  INVMASTS\n005200          OUTPUT INVMASTI.\n005300     PERFORM 100-CREATE-INVENTORY-RECORD\n005400         UNTIL INVMAST-EOF.\n005500     CLOSE INVMASTS\n005600           INVMASTI.\n005700     STOP RUN.\n005800*\n005900 100-CREATE-INVENTORY-RECORD.\n006000*\n006100     PERFORM 110-READ-SEQUENTIAL-RECORD.\n006200     IF NOT INVMAST-EOF\n006300         PERFORM 120-WRITE-INDEXED-RECORD.\n006400*\n006500 110-READ-SEQUENTIAL-RECORD.\n006600*\n006700     READ INVMASTS INTO INVENTORY-MASTER-RECORD\n006800         AT END\n006900             MOVE \"Y\" TO INVMAST-EOF-SWITCH.\n007000*\n007100 120-WRITE-INDEXED-RECORD.\n007200*\n007300     WRITE INDEXED-RECORD-AREA FROM INVENTORY-MASTER-RECORD\n007400         INVALID KEY\n007500             DISPLAY \"WRITE ERROR ON INVMAST FOR ITEM NUMBER \"\n007600                 IR-ITEM-NO\n007700             MOVE \"Y\" TO INVMAST-EOF-SWITCH.\n./ ADD NAME=IND2000C 0101-01302-01302-1135-00168-00168-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID.  IND2000C\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000*\n001100     SELECT MNTTRAN  ASSIGN TO MNTTRAN.\n001200     SELECT INVMAST  ASSIGN TO INVMAST\n001300                     ORGANIZATION IS INDEXED\n001400                     ACCESS IS RANDOM\n001500                     RECORD KEY IS IR-ITEM-NO.\n001600     SELECT ERRTRAN  ASSIGN TO ERRTRAN\n001700                     FILE STATUS IS ERRTRAN-FILE-STATUS.\n001800*\n001900 DATA DIVISION.\n002000*\n002100 FILE SECTION.\n002200*\n002300 FD  MNTTRAN.\n002400*\n002500 01  TRANSACTION-RECORD      PIC X(61).\n002600*\n002700 FD  INVMAST.\n002800*\n002900 01  INVENTORY-RECORD-AREA.\n003000     05  IR-ITEM-NO          PIC X(5).\n003100     05  FILLER              PIC X(65).\n003200*\n003300 FD  ERRTRAN.\n003400*\n003500 01  ERROR-TRANSACTION       PIC X(61).\n003600*\n003700 WORKING-STORAGE SECTION.\n003800*\n003900 01  SWITCHES.\n004000     05  TRANSACTION-EOF-SWITCH  PIC X   VALUE \"N\".\n004100         88  TRANSACTION-EOF             VALUE \"Y\".\n004200     05  MASTER-FOUND-SWITCH     PIC X   VALUE \"Y\".\n004300         88  MASTER-FOUND                VALUE \"Y\".\n004400*\n004500 01  FILE-STATUS-FIELDS.\n004600     05  ERRTRAN-FILE-STATUS     PIC XX.\n004700         88  ERRTRAN-SUCCESSFUL          VALUE \"00\".\n004800*\n004900 01  MAINTENANCE-TRANSACTION.\n005000     05  MT-TRANSACTION-CODE     PIC X.\n005100         88  DELETE-RECORD               VALUE \"1\".\n005200         88  ADD-RECORD                  VALUE \"2\".\n005300         88  CHANGE-RECORD               VALUE \"3\".\n005400     05  MT-MASTER-DATA.\n005500         10  MT-ITEM-NO          PIC X(5).\n005600         10  MT-ITEM-DESC        PIC X(40).\n005700         10  MT-UNIT-COST        PIC S9(3)V99.\n005800         10  MT-UNIT-PRICE       PIC S9(3)V99.\n005900         10  MT-REORDER-POINT    PIC S9(5).\n006000*\n006100 01  INVENTORY-MASTER-RECORD.\n006200     05  IM-ITEM-NO              PIC X(5).\n006300     05  IM-DESCRIPTIVE-DATA.\n006400         10  IM-ITEM-DESC        PIC X(40).\n006500         10  IM-UNIT-COST        PIC S9(3)V99.\n006600         10  IM-UNIT-PRICE       PIC S9(3)V99.\n006700     05  IM-INVENTORY-DATA.\n006800         10  IM-REORDER-POINT    PIC S9(5).\n006900         10  IM-ON-HAND          PIC S9(5).\n007000         10  IM-ON-ORDER         PIC S9(5).\n007100*\n007200 PROCEDURE DIVISION.\n007300*\n007400 000-MAINTAIN-INVENTORY-FILE.\n007500*\n007600     OPEN INPUT  MNTTRAN\n007700          I-O    INVMAST\n007800          OUTPUT ERRTRAN.\n007900     PERFORM 300-MAINTAIN-INVENTORY-RECORD\n008000         UNTIL TRANSACTION-EOF.\n008100     CLOSE MNTTRAN\n008200           INVMAST\n008300           ERRTRAN.\n008400     STOP RUN.\n008500*\n008600 300-MAINTAIN-INVENTORY-RECORD.\n008700*\n008800     PERFORM 310-READ-INVENTORY-TRANSACTION.\n008900     IF NOT TRANSACTION-EOF\n009000         PERFORM 320-READ-INVENTORY-MASTER\n009100         IF DELETE-RECORD\n009200             IF MASTER-FOUND\n009300                 PERFORM 330-DELETE-INVENTORY-RECORD\n009400             ELSE\n009500                 PERFORM 380-WRITE-ERROR-TRANSACTION\n009600         ELSE IF ADD-RECORD\n009700             IF MASTER-FOUND\n009800                 PERFORM 380-WRITE-ERROR-TRANSACTION\n009900             ELSE\n010000                 PERFORM 340-ADD-INVENTORY-RECORD\n010100         ELSE IF CHANGE-RECORD\n010200             IF MASTER-FOUND\n010300                 PERFORM 360-CHANGE-INVENTORY-RECORD\n010400             ELSE\n010500                 PERFORM 380-WRITE-ERROR-TRANSACTION.\n010600*\n010700 310-READ-INVENTORY-TRANSACTION.\n010800*\n010900     READ MNTTRAN INTO MAINTENANCE-TRANSACTION\n011000         AT END\n011100             MOVE \"Y\" TO TRANSACTION-EOF-SWITCH.\n011200*\n011300 320-READ-INVENTORY-MASTER.\n011400*\n011500     MOVE MT-ITEM-NO TO IR-ITEM-NO.\n011600     READ INVMAST INTO INVENTORY-MASTER-RECORD\n011700         INVALID KEY\n011800             MOVE \"N\" TO MASTER-FOUND-SWITCH\n011900         NOT INVALID KEY\n012000             MOVE \"Y\" TO MASTER-FOUND-SWITCH.\n012100*\n012200 330-DELETE-INVENTORY-RECORD.\n012300*\n012400     DELETE INVMAST.\n012500*\n012600 340-ADD-INVENTORY-RECORD.\n012700*\n012800     MOVE MT-ITEM-NO       TO IM-ITEM-NO.\n012900     MOVE MT-ITEM-DESC     TO IM-ITEM-DESC.\n013000     MOVE MT-UNIT-COST     TO IM-UNIT-COST.\n013100     MOVE MT-UNIT-PRICE    TO IM-UNIT-PRICE.\n013200     MOVE MT-REORDER-POINT TO IM-REORDER-POINT.\n013300     MOVE ZERO             TO IM-ON-HAND.\n013400     MOVE ZERO             TO IM-ON-ORDER.\n013500     PERFORM 350-WRITE-INVENTORY-RECORD.\n013600*\n013700 350-WRITE-INVENTORY-RECORD.\n013800*\n013900     WRITE INVENTORY-RECORD-AREA FROM INVENTORY-MASTER-RECORD\n014000         INVALID KEY\n014100             DISPLAY \"WRITE ERROR ON INVMAST FOR ITEM NUMBER \"\n014200                 IR-ITEM-NO\n014300             MOVE \"Y\" TO TRANSACTION-EOF-SWITCH.\n014400*\n014500 360-CHANGE-INVENTORY-RECORD.\n014600*\n014700     IF MT-ITEM-DESC NOT = SPACE\n014800         MOVE MT-ITEM-DESC TO IM-ITEM-DESC.\n014900     IF MT-UNIT-COST NOT = ZERO\n015000         MOVE MT-UNIT-COST TO IM-UNIT-COST.\n015100     IF MT-UNIT-PRICE NOT = ZERO\n015200         MOVE MT-UNIT-PRICE TO IM-UNIT-PRICE.\n015300     IF MT-REORDER-POINT NOT = ZERO\n015400         MOVE MT-REORDER-POINT TO IM-REORDER-POINT.\n015500     PERFORM 370-REWRITE-INVENTORY-RECORD.\n015600*\n015700 370-REWRITE-INVENTORY-RECORD.\n015800*\n015900     REWRITE INVENTORY-RECORD-AREA FROM INVENTORY-MASTER-RECORD.\n016000*\n016100 380-WRITE-ERROR-TRANSACTION.\n016200*\n016300     WRITE ERROR-TRANSACTION FROM MAINTENANCE-TRANSACTION.\n016400     IF NOT ERRTRAN-SUCCESSFUL\n016500         DISPLAY \"WRITE ERROR ON ERRTRAN FOR ITEM NUMBER \"\n016600             MT-ITEM-NO\n016700         DISPLAY \"FILE STATUS CODE IS \" ERRTRAN-FILE-STATUS\n016800         MOVE \"Y\" TO TRANSACTION-EOF-SWITCH.\n./ ADD NAME=IND4000C 0102-01302-01302-1422-00076-00076-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. IND4000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000*\n001100     SELECT CUSTMAST ASSIGN TO CUSTMAST\n001200                     ORGANIZATION IS INDEXED\n001300                     ACCESS IS RANDOM\n001400                     RECORD KEY IS CM-CUSTOMER-NUMBER\n001500                     ALTERNATE RECORD KEY IS CM-BRANCH-NUMBER\n001600                         WITH DUPLICATES.\n001700*\n001800 DATA DIVISION.\n001900*\n002000 FILE SECTION.\n002100*\n002200 FD  CUSTMAST.\n002300*\n002400 01  CUSTOMER-MASTER-RECORD.\n002500     05  CM-BRANCH-NUMBER        PIC 9(2).\n002600     05  CM-SALESREP-NUMBER      PIC 9(2).\n002700     05  CM-CUSTOMER-NUMBER      PIC X(5).\n002800     05  CM-CUSTOMER-NAME        PIC X(20).\n002900     05  CM-SALES-THIS-YTD       PIC S9(5)V9(2).\n003000     05  CM-SALES-LAST-YTD       PIC S9(5)V9(2).\n003100*\n003200 WORKING-STORAGE SECTION.\n003300*\n003400 01  SWITCHES.\n003500     05  END-OF-SESSION-SWITCH   PIC X   VALUE \"N\".\n003600         88  END-OF-SESSION              VALUE \"Y\".\n003700*\n003800 01  USER-ENTRIES.\n003900     05  CUSTOMER-NUMBER         PIC 9(5).\n004000*\n004100 01  WORK-FIELDS.\n004200     05  EDITED-YTD-SALES        PIC ZZ,ZZZ.99-.\n004300*\n004400 PROCEDURE DIVISION.\n004500*\n004600 000-DISPLAY-CUSTOMER-RECORDS.\n004700*\n004800     OPEN INPUT CUSTMAST.\n004900     PERFORM 100-DISPLAY-CUSTOMER-RECORD\n005000         UNTIL END-OF-SESSION.\n005100     CLOSE CUSTMAST.\n005200     STOP RUN.\n005300*\n005400 100-DISPLAY-CUSTOMER-RECORD.\n005500*\n005600     PERFORM 110-GET-USER-ENTRY.\n005700*\n005800 110-GET-USER-ENTRY.\n005900*\n006000     DISPLAY \"ENTER A CUSTOMER NUMBER.\".\n006100     DISPLAY \"OR, ENTER 99999 TO END THE PROGRAM.\".\n006200     DISPLAY \"-----------------------------------------\".\n006300     ACCEPT CUSTOMER-NUMBER.\n006400     IF CUSTOMER-NUMBER = 99999\n006500         MOVE \"Y\" TO END-OF-SESSION-SWITCH.\n006600*\n006700 120-READ-CUSTOMER-RECORD.\n006800*\n006900*\n007000 130-DISPLAY-CUSTOMER-DATA.\n007100*\n007200     MOVE CM-SALES-THIS-YTD TO EDITED-YTD-SALES.\n007300     DISPLAY \"NUMBER  NAME                    YTD SALES\".\n007400     DISPLAY CM-CUSTOMER-NUMBER \"   \" CM-CUSTOMER-NAME\n007500             \"    \" EDITED-YTD-SALES.\n007600     DISPLAY \"-----------------------------------------\".\n./ ADD NAME=JOBCARDJ 0101-01303-01303-1533-00004-00008-00000-BC0THOR\n//???????X JOB (0000000-0000000,,TMVS01-UR-XXXX),'YOURNAME',CLASS=A,\n//   MSGCLASS=Y,NOTIFY=???????,REGION=104M\n//JESOUT OUTPUT GROUPID=???,DEFAULT=YES,JESDS=ALL, <==??? IS MAIL DROP\n//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG\n./ ADD NAME=LISTMODC 0102-01302-01311-1307-02037-02036-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID.    LISTMODC.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 CONFIGURATION SECTION.\n000800*\n000900 INPUT-OUTPUT SECTION.\n001000*\n001100 FILE-CONTROL.\n001200*\n001300     SELECT SRCEFILE   ASSIGN TO SRCEFILE.\n001500     SELECT MODLIST    ASSIGN TO MODLIST.\n001600*\n001700 DATA DIVISION.\n001800*\n001900 FILE SECTION.\n002000*\n002100 FD  SRCEFILE\n002110     RECORDING MODE IS F\n002200     LABEL RECORDS ARE STANDARD.\n002300*\n002400 01  SOURCE-RECORD.\n002500*\n002600     05  FILLER                    PIC X(6).\n002700     05  CODING-AREA               PIC X(66).\n002800         88  BLANK-LINE            VALUE SPACE.\n002900     05  CODING-AREA-X             REDEFINES CODING-AREA.\n003000         10  AST-AREA              PIC X.\n003100             88  COMMENT           VALUE \"*\".\n003200         10  DATA-AREA.\n003300             15  A-AREA            PIC X(4).\n003400             15  B-AREA            PIC X(61).\n003500     05  FILLER                    PIC X(8).\n003600*\n003700 FD  MODLIST\n003710     RECORDING MODE IS F\n003800     LABEL RECORDS ARE STANDARD.\n003900*\n004000 01  PRINT-AREA.\n004100*\n004200     05  PRINT-LINE        PIC X(132).\n004300     05  PRINT-LINE-1      REDEFINES PRINT-LINE.\n004400         10  PL1-ASTERISK  PIC X.\n004500         10  PL1-NAME      PIC X(32).\n004600         10  FILLER        PIC X(99).\n004700     05  PRINT-LINE-2      REDEFINES PRINT-LINE.\n004800         10  FILLER        PIC X(4).\n004900         10  PL2-ASTERISK  PIC X.\n005000         10  PL2-NAME      PIC X(32).\n005100         10  FILLER        PIC X(95).\n005200     05  PRINT-LINE-3      REDEFINES PRINT-LINE.\n005300         10  FILLER        PIC X(8).\n005400         10  PL3-ASTERISK  PIC X.\n005500         10  PL3-NAME      PIC X(32).\n005600         10  FILLER        PIC X(91).\n005700     05  PRINT-LINE-4      REDEFINES PRINT-LINE.\n005800         10  FILLER        PIC X(12).\n005900         10  PL4-ASTERISK  PIC X.\n006000         10  PL4-NAME      PIC X(32).\n006100         10  FILLER        PIC X(87).\n006200     05  PRINT-LINE-5      REDEFINES PRINT-LINE.\n006300         10  FILLER        PIC X(16).\n006400         10  PL5-ASTERISK  PIC X.\n006500         10  PL5-NAME      PIC X(32).\n006600         10  FILLER        PIC X(83).\n006700     05  PRINT-LINE-6      REDEFINES PRINT-LINE.\n006800         10  FILLER        PIC X(20).\n006900         10  PL6-ASTERISK  PIC X.\n007000         10  PL6-NAME      PIC X(32).\n007100         10  FILLER        PIC X(79).\n007200     05  PRINT-LINE-7      REDEFINES PRINT-LINE.\n007300         10  FILLER        PIC X(24).\n007400         10  PL7-ASTERISK  PIC X.\n007500         10  PL7-NAME      PIC X(32).\n007600         10  FILLER        PIC X(75).\n007700     05  PRINT-LINE-8      REDEFINES PRINT-LINE.\n007800         10  FILLER        PIC X(28).\n007900         10  PL8-ASTERISK  PIC X.\n008000         10  PL8-NAME      PIC X(32).\n008100         10  FILLER        PIC X(71).\n008200     05  PRINT-LINE-9      REDEFINES PRINT-LINE.\n008300         10  FILLER        PIC X(32).\n008400         10  PL9-ASTERISK  PIC X.\n008500         10  PL9-NAME      PIC X(32).\n008600         10  FILLER        PIC X(67).\n008700     05  PRINT-LINE-10     REDEFINES PRINT-LINE.\n008800         10  FILLER        PIC X(36).\n008900         10  PL10-ASTERISK PIC X.\n009000         10  PL10-NAME     PIC X(32).\n009100         10  FILLER        PIC X(63).\n009200     05  PRINT-LINE-11     REDEFINES PRINT-LINE.\n009300         10  FILLER        PIC X(40).\n009400         10  PL11-ASTERISK PIC X.\n009500         10  PL11-NAME     PIC X(32).\n009600         10  FILLER        PIC X(59).\n009700     05  PRINT-LINE-12     REDEFINES PRINT-LINE.\n009800         10  FILLER        PIC X(44).\n009900         10  PL12-ASTERISK PIC X.\n010000         10  PL12-NAME     PIC X(32).\n010100         10  FILLER        PIC X(55).\n010200     05  PRINT-LINE-13     REDEFINES PRINT-LINE.\n010300         10  FILLER        PIC X(48).\n010400         10  PL13-ASTERISK PIC X.\n010500         10  PL13-NAME     PIC X(32).\n010600         10  FILLER        PIC X(51).\n010700     05  PRINT-LINE-14     REDEFINES PRINT-LINE.\n010800         10  FILLER        PIC X(52).\n010900         10  PL14-ASTERISK PIC X.\n011000         10  PL14-NAME     PIC X(32).\n011100         10  FILLER        PIC X(47).\n011200     05  PRINT-LINE-15     REDEFINES PRINT-LINE.\n011300         10  FILLER        PIC X(56).\n011400         10  PL15-ASTERISK PIC X.\n011500         10  PL15-NAME     PIC X(32).\n011600         10  FILLER        PIC X(43).\n011700     05  PRINT-LINE-16     REDEFINES PRINT-LINE.\n011800         10  FILLER        PIC X(60).\n011900         10  PL16-ASTERISK PIC X.\n012000         10  PL16-NAME     PIC X(32).\n012100         10  FILLER        PIC X(39).\n012200     05  PRINT-LINE-17     REDEFINES PRINT-LINE.\n012300         10  FILLER        PIC X(64).\n012400         10  PL17-ASTERISK PIC X.\n012500         10  PL17-NAME     PIC X(32).\n012600         10  FILLER        PIC X(35).\n012700     05  PRINT-LINE-18     REDEFINES PRINT-LINE.\n012800         10  FILLER        PIC X(68).\n012900         10  PL18-ASTERISK PIC X.\n013000         10  PL18-NAME     PIC X(32).\n013100         10  FILLER        PIC X(31).\n013200     05  PRINT-LINE-19     REDEFINES PRINT-LINE.\n013300         10  FILLER        PIC X(72).\n013400         10  PL19-ASTERISK PIC X.\n013500         10  PL19-NAME     PIC X(32).\n013600         10  FILLER        PIC X(27).\n013700     05  PRINT-LINE-20     REDEFINES PRINT-LINE.\n013800         10  FILLER        PIC X(76).\n013900         10  PL20-ASTERISK PIC X.\n014000         10  PL20-NAME     PIC X(32).\n014100         10  FILLER        PIC X(23).\n014200     05  PRINT-LINE-21     REDEFINES PRINT-LINE.\n014300         10  FILLER        PIC X(80).\n014400         10  PL21-ASTERISK PIC X.\n014500         10  PL21-NAME     PIC X(32).\n014600         10  FILLER        PIC X(19).\n014700     05  PRINT-LINE-22     REDEFINES PRINT-LINE.\n014800         10  FILLER        PIC X(84).\n014900         10  PL22-ASTERISK PIC X.\n015000         10  PL22-NAME     PIC X(32).\n015100         10  FILLER        PIC X(15).\n015200     05  PRINT-LINE-23     REDEFINES PRINT-LINE.\n015300         10  FILLER        PIC X(88).\n015400         10  PL23-ASTERISK PIC X.\n015500         10  PL23-NAME     PIC X(32).\n015600         10  FILLER        PIC X(11).\n015700     05  PRINT-LINE-24     REDEFINES PRINT-LINE.\n015800         10  FILLER        PIC X(92).\n015900         10  PL24-ASTERISK PIC X.\n016000         10  PL24-NAME     PIC X(32).\n016100         10  FILLER        PIC X(7).\n016200     05  PRINT-LINE-25     REDEFINES PRINT-LINE.\n016300         10  FILLER        PIC X(96).\n016400         10  PL25-ASTERISK PIC X.\n016500         10  PL25-NAME     PIC X(32).\n016600         10  FILLER        PIC X(3).\n016700     05  DECLARATIVE-LINE      REDEFINES PRINT-LINE.\n016800         10  FILLER            PIC X.\n016900         10  DL-CODE           PIC X(65).\n017000         10  FILLER            PIC X(66).\n017100     05  MODULE-LINE           REDEFINES PRINT-LINE.\n017200         10  ML-MODULE-NAME    PIC X(30).\n017300         10  FILLER            PIC X(102).\n017400     05  STATISTICS-LINE       REDEFINES PRINT-LINE.\n017500         10  SL-DESCRIPTION    PIC X(30).\n017600         10  SL-COUNT          PIC ZZ,ZZ9.\n017700         10  FILLER            PIC X(96).\n017800*\n017900 WORKING-STORAGE SECTION.\n018000*\n018100 01  MODULE-TABLE.\n018200*\n018300     05  MODULE-ENTRY                  OCCURS 250 TIMES\n018400                                       INDEXED BY MODULE-INDEX.\n018500         10  MODULE-NUMBER             PIC S9(3)    COMP.\n018600         10  FULL-MODULE-NAME.\n018700             15  MODULE-NAME           PIC X(30).\n018800             15  FILLER                PIC X.\n018900             15  COMMON-MODULE-FLAG    PIC X.\n019000                 88  COMMON-MODULE     VALUE \"C\".\n019100         10  MODULE-TYPE-FLAG          PIC X.\n019200             88  PROGRAM-PARAGRAPH     VALUE \"P\".\n019300             88  PROGRAM-SECTION       VALUE \"X\".\n019400             88  SUBPROGRAM            VALUE \"S\".\n019500         10  MODULE-PRINTED-SW         PIC X.\n019600             88  MODULE-PRINTED        VALUE \"Y\".\n019700         10  TIMES-CALLED              PIC S9(3)    COMP.\n019800         10  MODULE-CALL-COUNT         PIC S9(3)    COMP.\n019900         10  MODULE-CALL-DATA          OCCURS 25 TIMES\n020000                                       INDEXED BY CALL-INDEX.\n020100             15  CALLED-MODULE         PIC S9(3)    COMP.\n020200         10  CALL-OVERFLOW-SW          PIC X.\n020300*\n020400 01  MODULE-TABLE-LIMITS               COMP.\n020500*\n020600     05  MODULE-LIMIT                  PIC S999     VALUE +250.\n020700     05  CALL-LIMIT                    PIC S999     VALUE +25.\n020800*\n020900 01  UNSTRING-WORK-FIELDS.\n021000*\n021100     05  SOURCE-LINE.\n021200         10  SOURCE-LINE-POSITION      PIC X\n021300             OCCURS 66 TIMES\n021400             INDEXED BY SOURCE-LINE-POSITION-INDEX.\n021500     05  NEXT-SOURCE-WORD.\n021600         10  SOURCE-WORD-POSITION      PIC X\n021700             OCCURS 30 TIMES\n021800             INDEXED BY SOURCE-WORD-POSITION-INDEX.\n021900     05  SOURCE-WORDS.\n022000         10  SOURCE-WORD               PIC X(30)\n022100             OCCURS 8 TIMES\n022200             INDEXED BY SOURCE-WORD-INDEX.\n022300     05  SOURCE-WORD-COUNT             PIC S9      COMP.\n022400*\n022500 01  PROGRAM-CONTROL-SWITCHES.\n022600*\n022700     05  PARAGRAPH-MODULES-SW          PIC X       VALUE \"Y\".\n022800         88  PARAGRAPH-MODULES                     VALUE \"Y\".\n022900         88  SECTION-MODULES                       VALUE \"N\".\n023000     05  SRCEFILE-EOF-SW               PIC X       VALUE \"N\".\n023100         88  SRCEFILE-EOF                          VALUE \"Y\".\n023200     05  ACTIVE-RECORD-SW              PIC X.\n023300         88  ACTIVE-RECORD                         VALUE \"Y\".\n023400     05  CANCEL-PROGRAM-SW             PIC X       VALUE \"N\".\n023500         88  CANCEL-PROGRAM                        VALUE \"Y\".\n023600     05  COUNT-LINES-SW                PIC X       VALUE \"Y\".\n023700         88  COUNT-LINES                           VALUE \"Y\".\n023800     05  PROCEDURE-DIVISION-SW         PIC X       VALUE \"N\".\n023900         88  PROCEDURE-DIVISION                    VALUE \"Y\".\n024000     05  DECLARATIVES-SECTION-SW       PIC X.\n024100         88  DECLARATIVES-SECTION                  VALUE \"Y\".\n024200     05  END-DECLARATIVES-SW           PIC X       VALUE \"N\".\n024300         88  END-DECLARATIVES                      VALUE \"Y\".\n024400     05  FIRST-MODULE-NAME-SW          PIC X       VALUE \"Y\".\n024500         88  FIRST-MODULE-NAME                     VALUE \"Y\".\n024600     05  NEXT-PROCEDURE-NAME-SW        PIC X.\n024700         88  NEXT-PROCEDURE-NAME                   VALUE \"Y\".\n024800     05  DUPLICATE-CALL-SW             PIC X       VALUE \"N\".\n024900         88  DUPLICATE-CALL                        VALUE \"Y\".\n025000*\n025100 01  SEARCH-SWITCHES.\n025200*\n025300     05  FOUND-SW                      PIC X.\n025400         88  FOUND                                 VALUE \"Y\".\n025500     05  PERFORM-FOUND-SW              PIC X       VALUE \"N\".\n025600         88  PERFORM-FOUND                         VALUE \"Y\".\n025700     05  CALL-FOUND-SW                 PIC X       VALUE \"N\".\n025800         88  CALL-FOUND                            VALUE \"Y\".\n025900     05  SORT-FOUND-SW                 PIC X       VALUE \"N\".\n026000         88  SORT-FOUND                            VALUE \"Y\".\n026100     05  MERGE-FOUND-SW                PIC X       VALUE \"N\".\n026200         88  MERGE-FOUND                           VALUE \"Y\".\n026300     05  INPUT-PROCEDURE-FOUND-SW      PIC X       VALUE \"N\".\n026400         88  INPUT-PROCEDURE-FOUND                 VALUE \"Y\".\n026500     05  OUTPUT-PROCEDURE-FOUND-SW     PIC X       VALUE \"N\".\n026600         88  OUTPUT-PROCEDURE-FOUND                VALUE \"Y\".\n026700     05  GOTO-FOUND-SW                 PIC X       VALUE \"N\".\n026800         88  GOTO-FOUND                            VALUE \"Y\".\n026900     05  USE-STATEMENT-SW              PIC X       VALUE \"N\".\n027000         88  USE-STATEMENT                         VALUE \"Y\".\n027100*\n027200 01  SUMMARY-SWITCHES.\n027300*\n027400     05  TABLE-OVERFLOW-SW             PIC X       VALUE \"N\".\n027500         88  TABLE-OVERFLOW                        VALUE \"Y\".\n027600     05  MODULE-CALL-OVERFLOW-SW       PIC X       VALUE \"N\".\n027700         88  CALL-OVERFLOW                         VALUE \"Y\".\n027800     05  LEVEL-OVERFLOW-SW             PIC X       VALUE \"N\".\n027900         88  LEVEL-OVERFLOW                        VALUE \"Y\".\n028000     05  PRINT-UNCALLED-MODULES-SW     PIC X       VALUE \"N\".\n028100         88  PRINT-UNCALLED-MODULES                VALUE \"Y\".\n028200     05  PRINT-CALLED-SUBPROGRAMS-SW   PIC X       VALUE \"N\".\n028300         88  PRINT-CALLED-SUBPROGRAMS              VALUE \"Y\".\n028400*\n028500 01  DATE-FIELDS.\n028600*\n028700     05  SYSTEM-DATE         PIC 9(6).\n028800     05  SYSTEM-DATE-R       REDEFINES SYSTEM-DATE.\n028900         10  SYSTEM-YEAR     PIC 99.\n029000         10  SYSTEM-MONTH    PIC 99.\n029100         10  SYSTEM-DAY      PIC 99.\n029200     05  TODAYS-DATE         PIC 9(6).\n029300     05  TODAYS-DATE-R       REDEFINES TODAYS-DATE.\n029400         10  TODAYS-MONTH    PIC 99.\n029500         10  TODAYS-DAY      PIC 99.\n029600         10  TODAYS-YEAR     PIC 99.\n029700*\n029800 01  TIME-FIELDS.\n029900*\n030000     05  SYSTEM-TIME             PIC 9(8).\n030100     05  SYSTEM-TIME-R           REDEFINES SYSTEM-TIME.\n030200         10  SYSTEM-HOUR         PIC 99.\n030300         10  SYSTEM-MINUTE       PIC 99.\n030400         10  SYSTEM-SECOND       PIC 99.\n030500         10  SYSTEM-HUNDREDTH    PIC 99.\n030600*\n030700 01  COUNT-FIELDS                   COMP.\n030800*\n030900     05  TOTAL-LINE-COUNT           PIC S9(5)    VALUE ZERO.\n031000     05  SOURCE-LINE-COUNT          PIC S9(5)    VALUE ZERO.\n031100     05  PD-LINE-COUNT              PIC S9(5)    VALUE ZERO.\n031200     05  MODULE-COUNT               PIC S9(3)    VALUE ZERO.\n031300     05  COBOL-MODULE-COUNT         PIC S9(3)    VALUE ZERO.\n031400     05  COBOL-PARAGRAPH-COUNT      PIC S9(3)    VALUE ZERO.\n031500     05  COBOL-SECTION-COUNT        PIC S9(3)    VALUE ZERO.\n031600     05  SUBPROGRAM-COUNT           PIC S9(3)    VALUE ZERO.\n031700     05  RESTART-COUNT              PIC S9(5)    VALUE ZERO.\n031800     05  PERFORM-COUNT              PIC S9(3)    VALUE ZERO.\n031900     05  INLINE-PERFORM-COUNT       PIC S9(3)    VALUE ZERO.\n032000     05  CALL-COUNT                 PIC S9(3)    VALUE ZERO.\n032100     05  SORT-COUNT                 PIC S9(3)    VALUE ZERO.\n032200     05  MERGE-COUNT                PIC S9(3)    VALUE ZERO.\n032300     05  SORT-MERGE-PROCEDURE-COUNT PIC S9(3)    VALUE ZERO.\n032400     05  GOTO-COUNT                 PIC S9(3)    VALUE ZERO.\n032500     05  NUMBER-OF-CALLS            PIC S9(3)    VALUE ZERO.\n032600     05  PERIOD-COUNT               PIC S9       VALUE ZERO.\n032700*\n032800 01  RECORD-LOCATOR-NUMBERS          COMP.\n032900*\n033000     05  FIRST-PD-RECORD-NO          PIC S9(5)   VALUE ZERO.\n033100     05  FIRST-DECLARATIVE-RECORD-NO PIC S9(5)   VALUE ZERO.\n033200     05  LAST-DECLARATIVE-RECORD-NO  PIC S9(5)   VALUE ZERO.\n033300     05  FIRST-PROC-NAME-RECORD-NO   PIC S9(5)   VALUE ZERO.\n033400*\n033500 01  SAVE-AREAS.\n033600*\n033700     05  PRINT-SAVE-AREA             PIC X(132).\n033800     05  INDEX-SAVE-AREA             INDEX.\n033900     05  CALLED-MODULE-SAVE-AREA     PIC S9(3)   COMP.\n034000*\n034100 01  SEARCH-FIELDS.\n034200*\n034300     05  CALLED-PROC-NAME            PIC X(30).\n034400     05  CALLED-PROC-NUMBER          PIC S9(3)   COMP.\n034500*\n034600 01  INDEX-DATA-FIELDS   INDEX.\n034700*\n034800     05  MODULE-INDEX-SAVE-AREA-1.\n034900     05  MODULE-INDEX-SAVE-AREA-2.\n035000     05  MODULE-INDEX-SAVE-AREA-3.\n035100     05  MODULE-INDEX-SAVE-AREA-4.\n035200     05  MODULE-INDEX-SAVE-AREA-5.\n035300     05  MODULE-INDEX-SAVE-AREA-6.\n035400     05  MODULE-INDEX-SAVE-AREA-7.\n035500     05  MODULE-INDEX-SAVE-AREA-8.\n035600     05  MODULE-INDEX-SAVE-AREA-9.\n035700     05  MODULE-INDEX-SAVE-AREA-10.\n035800     05  MODULE-INDEX-SAVE-AREA-11.\n035900     05  MODULE-INDEX-SAVE-AREA-12.\n036000     05  MODULE-INDEX-SAVE-AREA-13.\n036100     05  MODULE-INDEX-SAVE-AREA-14.\n036200     05  MODULE-INDEX-SAVE-AREA-15.\n036300     05  MODULE-INDEX-SAVE-AREA-16.\n036400     05  MODULE-INDEX-SAVE-AREA-17.\n036500     05  MODULE-INDEX-SAVE-AREA-18.\n036600     05  MODULE-INDEX-SAVE-AREA-19.\n036700     05  MODULE-INDEX-SAVE-AREA-20.\n036800     05  MODULE-INDEX-SAVE-AREA-21.\n036900     05  MODULE-INDEX-SAVE-AREA-22.\n037000     05  MODULE-INDEX-SAVE-AREA-23.\n037100     05  MODULE-INDEX-SAVE-AREA-24.\n037200*\n037300     05  CALL-INDEX-SAVE-AREA-1.\n037400     05  CALL-INDEX-SAVE-AREA-2.\n037500     05  CALL-INDEX-SAVE-AREA-3.\n037600     05  CALL-INDEX-SAVE-AREA-4.\n037700     05  CALL-INDEX-SAVE-AREA-5.\n037800     05  CALL-INDEX-SAVE-AREA-6.\n037900     05  CALL-INDEX-SAVE-AREA-7.\n038000     05  CALL-INDEX-SAVE-AREA-8.\n038100     05  CALL-INDEX-SAVE-AREA-9.\n038200     05  CALL-INDEX-SAVE-AREA-10.\n038300     05  CALL-INDEX-SAVE-AREA-11.\n038400     05  CALL-INDEX-SAVE-AREA-12.\n038500     05  CALL-INDEX-SAVE-AREA-13.\n038600     05  CALL-INDEX-SAVE-AREA-14.\n038700     05  CALL-INDEX-SAVE-AREA-15.\n038800     05  CALL-INDEX-SAVE-AREA-16.\n038900     05  CALL-INDEX-SAVE-AREA-17.\n039000     05  CALL-INDEX-SAVE-AREA-18.\n039100     05  CALL-INDEX-SAVE-AREA-19.\n039200     05  CALL-INDEX-SAVE-AREA-20.\n039300     05  CALL-INDEX-SAVE-AREA-21.\n039400     05  CALL-INDEX-SAVE-AREA-22.\n039500     05  CALL-INDEX-SAVE-AREA-23.\n039600*\n039700 01  PRINT-FIELDS                COMP.\n039800*\n039900     05  LINE-COUNT              PIC S9(3)  VALUE +99.\n040000     05  LINES-ON-PAGE           PIC S9(3)  VALUE +55.\n040100     05  PAGE-COUNT              PIC S9(3)  VALUE ZERO.\n040200     05  SPACE-CONTROL           PIC S9.\n040300*\n040400 01  ERROR-MESSAGES.\n040500*\n040600     05  NO-PROGRAM-ID-MESSAGE.\n040700*\n040800         10  FILLER    PIC X(20)   VALUE \"PROGRAM-ID NOT FOUND\".\n040900         10  FILLER    PIC X(20)   VALUE \" -- PROGRAM TERMINAT\".\n041000         10  FILLER    PIC X(20)   VALUE \"ED.                 \".\n041100*\n041200     05  NO-PROCEDURE-DIVISION-MESSAGE.\n041300*\n041400         10  FILLER    PIC X(20)   VALUE \"PROCEDURE DIVISION N\".\n041500         10  FILLER    PIC X(20)   VALUE \"OT FOUND -- PROGRAM \".\n041600         10  FILLER    PIC X(20)   VALUE \"TERMINATED.         \".\n041700*\n041800     05  NO-END-DECLARATIVES-MESSAGE.\n041900*\n042000         10  FILLER    PIC X(20)   VALUE \"END DECLARATIVES NOT\".\n042100         10  FILLER    PIC X(20)   VALUE \" FOUND -- PROGRAM TE\".\n042200         10  FILLER    PIC X(20)   VALUE \"RMINATED.           \".\n042300*\n042400     05  TABLE-OVERFLOW-MESSAGE-1.\n042500*\n042600         10  FILLER    PIC X(20)   VALUE \"PROGRAM EXCEEDS MODU\".\n042700         10  FILLER    PIC X(20)   VALUE \"LE LIMIT -- LISTMODS\".\n042800         10  FILLER    PIC X(20)   VALUE \" CANNOT EXECUTE.    \".\n042900*\n043000     05  TABLE-OVERFLOW-MESSAGE-2.\n043100*\n043200         10  FILLER    PIC X(20)   VALUE \"PROGRAM EXCEEDS MODU\".\n043300         10  FILLER    PIC X(20)   VALUE \"LE LIMIT SO ALL SUBP\".\n043400         10  FILLER    PIC X(20)   VALUE \"ROGRAMS OR SORT/MERG\".\n043500         10  FILLER    PIC X(20)   VALUE \"E MODULES AREN\"\"T LIS\".\n043600         10  FILLER    PIC X(20)   VALUE \"TED.                \".\n043700*\n043800     05  CALL-OVERFLOW-MESSAGE.\n043900*\n044000         10  FILLER    PIC X(20)   VALUE \"** CALL OVERFLOW:  O\".\n044100         10  FILLER    PIC X(20)   VALUE \"NE OR MORE MODULES E\".\n044200         10  FILLER    PIC X(20)   VALUE \"XCEED THE CALL LIMIT\".\n044300         10  FILLER    PIC X(20)   VALUE \".                   \".\n044400*\n044500     05  LEVEL-OVERFLOW-MESSAGE.\n044600*\n044700         10  FILLER    PIC X(20)   VALUE \"** LEVEL OVERFLOW:  \".\n044800         10  FILLER    PIC X(20)   VALUE \"PROGRAM CONTAINS OVE\".\n044900         10  FILLER    PIC X(20)   VALUE \"R 25 LEVELS OF CALLS\".\n045000         10  FILLER    PIC X(20)   VALUE \", BUT ONLY 25 CAN BE\".\n045100         10  FILLER    PIC X(20)   VALUE \" PRINTED.           \".\n045200*\n045300 01  SUMMARY-HEADINGS.\n045400*\n045500     05  DECLARATIVES-HEADING       PIC X(30)\n045600         VALUE \"DECLARATIVES SUMMARY ---------\".\n045700     05  ERROR-MESSAGES-HEADING     PIC X(30)\n045800         VALUE \"ERROR MESSAGES ---------------\".\n045900     05  UNCALLED-MODULES-HEADING   PIC X(30)\n046000         VALUE \"UNCALLED MODULES -------------\".\n046100     05  CALLED-SUBPROGRAMS-HEADING PIC X(30)\n046200         VALUE \"CALLED SUBPROGRAMS -----------\".\n046300     05  PROGRAM-STATISTICS-HEADING PIC X(30)\n046400         VALUE \"PROGRAM STATISTICS -----------\".\n046500*\n046600 01  HEADING-LINE-1.\n046700*\n046800     05  FILLER               PIC X(15)   VALUE \"DATE AND TIME:\".\n046900     05  HDG1-DATE            PIC 99/99/99.\n047000     05  FILLER               PIC XX      VALUE SPACE.\n047100     05  HDG2-TIME-DATA.\n047200         10  HDG2-HOURS       PIC XX.\n047300         10  FILLER           PIC X       VALUE \":\".\n047400         10  HDG2-MINUTES     PIC XX.\n047500         10  FILLER           PIC X       VALUE SPACE.\n047600         10  HDG2-TIME-SUFFIX PIC X(8).\n047700     05  FILLER               PIC X(84)   VALUE SPACE.\n047800     05  FILLER               PIC X(6)    VALUE \"PAGE:\".\n047900     05  HDG1-PAGE-NUMBER     PIC ZZ9.\n048000*\n048100 01  HEADING-LINE-2.\n048200*\n048300     05  FILLER               PIC X(15)   VALUE \"PROGRAM-ID:\".\n048400     05  HDG2-PROGRAM-NAME    PIC X(30).\n048500     05  FILLER               PIC X(87)   VALUE SPACE.\n048600*\n048700 01  SUMMARY-HEADING-LINE.\n048800*\n048900     05  SHL-HEADING     PIC X(30).\n049000     05  FILLER          PIC X(20)   VALUE \"--------------------\".\n049100     05  FILLER          PIC X(20)   VALUE \"--------------------\".\n049200     05  FILLER          PIC X(20)   VALUE \"--------------------\".\n049300     05  FILLER          PIC X(20)   VALUE \"--------------------\".\n049400     05  FILLER          PIC X(20)   VALUE \"--------------------\".\n049500     05  FILLER          PIC X(2)    VALUE \"--\".\n049600*\n049700 PROCEDURE DIVISION.\n049800*\n049900 0000-PRINT-STRUCTURE-LISTING.\n050000*\n050100     OPEN INPUT  SRCEFILE\n050200          OUTPUT MODLIST.\n050300     PERFORM 1000-GET-HEADING-DATA.\n050400     IF NOT CANCEL-PROGRAM\n050500         PERFORM 2000-LOCATE-FIRST-PROCEDURE\n050600         IF NOT CANCEL-PROGRAM\n050700             PERFORM 3000-LOAD-MODULE-NAMES\n050800             IF NOT CANCEL-PROGRAM\n050900                 PERFORM 4000-LOAD-MODULE-CALLS\n051000                 PERFORM 5000-PRINT-STRUCTURE-LISTING\n051100                 IF DECLARATIVES-SECTION                          DEC\n051200                     PERFORM 6000-PRINT-DECLARATIVES              DEC\n051300                     PERFORM 7000-PRINT-PROGRAM-SUMMARY           DEC\n051400                 ELSE                                             DEC\n051500                     PERFORM 7000-PRINT-PROGRAM-SUMMARY.\n051600     CLOSE SRCEFILE\n051700           MODLIST.\n051800     STOP RUN.\n051900*\n052000 1000-GET-HEADING-DATA.\n052100*\n052200     ACCEPT SYSTEM-DATE FROM DATE.\n052300     MOVE SYSTEM-YEAR   TO TODAYS-YEAR.\n052400     MOVE SYSTEM-MONTH  TO TODAYS-MONTH.\n052500     MOVE SYSTEM-DAY    TO TODAYS-DAY.\n052600     MOVE TODAYS-DATE   TO HDG1-DATE.\n052700*\n052800     ACCEPT SYSTEM-TIME FROM TIME.\n052900     IF SYSTEM-HOUR LESS 12\n053000         MOVE \"AM\" TO HDG2-TIME-SUFFIX\n053100     ELSE\n053200         MOVE \"PM\" TO HDG2-TIME-SUFFIX\n053300         IF SYSTEM-HOUR GREATER 12\n053400             SUBTRACT 12 FROM SYSTEM-HOUR.\n053500     MOVE SYSTEM-HOUR   TO HDG2-HOURS.\n053600     MOVE SYSTEM-MINUTE TO HDG2-MINUTES.\n053700*\n053800     PERFORM 1100-GET-PROGRAM-NAME\n053900         UNTIL FOUND\n054000            OR CANCEL-PROGRAM.\n054100*\n054200 1100-GET-PROGRAM-NAME.\n054300*\n054400     MOVE \"N\" TO ACTIVE-RECORD-SW.\n054500     PERFORM 1110-READ-SOURCE-FILE\n054600         UNTIL SRCEFILE-EOF\n054700            OR (ACTIVE-RECORD AND A-AREA NOT = SPACE).\n054800     IF NOT SRCEFILE-EOF\n054900         PERFORM 1130-UNSTRING-SOURCE-LINE\n055000         IF SOURCE-WORD (1) = \"PROGRAM-ID\"\n055100             MOVE SOURCE-WORD (2) TO HDG2-PROGRAM-NAME\n055200             MOVE \"Y\" TO FOUND-SW\n055300         ELSE\n055400             MOVE \"N\" TO FOUND-SW\n055500     ELSE\n055600         MOVE \"Y\" TO CANCEL-PROGRAM-SW\n055700         MOVE SPACE TO HDG2-PROGRAM-NAME\n055800         MOVE NO-PROGRAM-ID-MESSAGE TO PRINT-LINE\n055900         PERFORM 1180-PRINT-REPORT-LINE.\n056000*\n056100 1110-READ-SOURCE-FILE.\n056200*\n056300     READ SRCEFILE\n056400         AT END\n056500             MOVE \"Y\" TO SRCEFILE-EOF-SW.\n056600     IF    COMMENT\n056700        OR BLANK-LINE\n056800         MOVE \"N\" TO ACTIVE-RECORD-SW\n056900     ELSE\n057000         MOVE \"Y\" TO ACTIVE-RECORD-SW.\n057100     IF NOT SRCEFILE-EOF\n057200         IF COUNT-LINES\n057300             PERFORM 1120-ACCUMULATE-RECORD-COUNTS.\n057400*\n057500 1120-ACCUMULATE-RECORD-COUNTS.\n057600*\n057700     ADD 1 TO TOTAL-LINE-COUNT.\n057800     IF ACTIVE-RECORD\n057900         ADD 1 TO SOURCE-LINE-COUNT\n058000         IF PROCEDURE-DIVISION\n058100             ADD 1 TO PD-LINE-COUNT.\n058200*\n058300 1130-UNSTRING-SOURCE-LINE.\n058400*\n058500     MOVE DATA-AREA TO SOURCE-LINE.\n058600     INSPECT SOURCE-LINE REPLACING ALL \",\" BY \" \".\n058700     INSPECT SOURCE-LINE REPLACING ALL \".\" BY \" \".\n058800     MOVE SPACE TO SOURCE-WORDS.\n058900     SET SOURCE-LINE-POSITION-INDEX TO 1.\n059000     SET SOURCE-WORD-INDEX TO 1.\n059100     PERFORM 1140-UNSTRING-NEXT-WORD\n059200         UNTIL SOURCE-WORD-INDEX > 8\n059300            OR SOURCE-LINE-POSITION-INDEX > 65.\n059400*\n059500 1140-UNSTRING-NEXT-WORD.\n059600*\n059700     MOVE SPACE TO NEXT-SOURCE-WORD.\n059800*\n059900     PERFORM 1150-FIND-NEXT-SOURCE-WORD\n060000         UNTIL SOURCE-LINE-POSITION (SOURCE-LINE-POSITION-INDEX)\n060100               NOT = SPACE\n060200            OR SOURCE-LINE-POSITION-INDEX > 65.\n060300*\n060400     IF SOURCE-LINE-POSITION (SOURCE-LINE-POSITION-INDEX) = QUOTE\n060500         IF SOURCE-WORD-INDEX NOT = 1\n060600             SET SOURCE-WORD-INDEX DOWN BY 1\n060700             IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"CALL\"\n060800                 SET SOURCE-WORD-INDEX UP BY 1\n060900             ELSE\n061000                 SET SOURCE-WORD-INDEX UP BY 1\n061100                 SET SOURCE-LINE-POSITION-INDEX UP BY 1\n061200                 PERFORM 1160-FIND-LITERAL-ENDING\n061300                     UNTIL SOURCE-LINE-POSITION\n061400                           (SOURCE-LINE-POSITION-INDEX) = QUOTE\n061500                        OR SOURCE-LINE-POSITION-INDEX > 65\n061600                 IF SOURCE-LINE-POSITION-INDEX < 66\n061700                     SET SOURCE-LINE-POSITION-INDEX UP BY 1.\n061800*\n061900     PERFORM 1170-BUILD-NEXT-SOURCE-WORD\n062000         VARYING SOURCE-WORD-POSITION-INDEX FROM 1 BY 1\n062100           UNTIL SOURCE-LINE-POSITION (SOURCE-LINE-POSITION-INDEX)\n062200                = SPACE\n062300              OR SOURCE-LINE-POSITION-INDEX > 65.\n062400*\n062500     IF NEXT-SOURCE-WORD NOT = SPACE\n062600         MOVE NEXT-SOURCE-WORD TO SOURCE-WORD (SOURCE-WORD-INDEX)\n062700         SET SOURCE-WORD-COUNT TO SOURCE-WORD-INDEX\n062800         SET SOURCE-WORD-INDEX UP BY 1.\n062900*\n063000 1150-FIND-NEXT-SOURCE-WORD.\n063100*\n063200     SET SOURCE-LINE-POSITION-INDEX UP BY 1.\n063300*\n063400 1160-FIND-LITERAL-ENDING.\n063500*\n063600     SET SOURCE-LINE-POSITION-INDEX UP BY 1.\n063700*\n063800 1170-BUILD-NEXT-SOURCE-WORD.\n063900*\n064000     MOVE SOURCE-LINE-POSITION (SOURCE-LINE-POSITION-INDEX)\n064100         TO SOURCE-WORD-POSITION (SOURCE-WORD-POSITION-INDEX).\n064200     SET SOURCE-LINE-POSITION-INDEX UP BY 1.\n064300*\n064400 1180-PRINT-REPORT-LINE.\n064500*\n064600     IF LINE-COUNT > LINES-ON-PAGE\n064700         PERFORM 1190-PRINT-HEADING-LINES\n064800         PERFORM 1210-WRITE-REPORT-LINE\n064900     ELSE\n065000         PERFORM 1210-WRITE-REPORT-LINE.\n065100     MOVE SPACE TO PRINT-AREA.\n065200*\n065300 1190-PRINT-HEADING-LINES.\n065400*\n065500     MOVE PRINT-LINE      TO PRINT-SAVE-AREA.\n065600     ADD 1                TO PAGE-COUNT.\n065700     MOVE PAGE-COUNT      TO HDG1-PAGE-NUMBER.\n065800     MOVE HEADING-LINE-1  TO PRINT-LINE.\n065900     PERFORM 1200-WRITE-PAGE-TOP-LINE.\n066000     MOVE 1               TO SPACE-CONTROL.\n066100     MOVE HEADING-LINE-2  TO PRINT-LINE.\n066200     PERFORM 1210-WRITE-REPORT-LINE.\n066300     MOVE 2               TO SPACE-CONTROL.\n066400     MOVE ZERO            TO LINE-COUNT.\n066500     MOVE PRINT-SAVE-AREA TO PRINT-LINE.\n066600*\n066700 1200-WRITE-PAGE-TOP-LINE.\n066800*\n066900     WRITE PRINT-AREA\n067000         AFTER ADVANCING PAGE.\n067100*\n067200 1210-WRITE-REPORT-LINE.\n067300*\n067400     WRITE PRINT-AREA\n067500         AFTER ADVANCING SPACE-CONTROL LINES.\n067600     ADD SPACE-CONTROL TO LINE-COUNT.\n067700     MOVE 1            TO SPACE-CONTROL.\n067800*\n067900 2000-LOCATE-FIRST-PROCEDURE.\n068000*\n068100     PERFORM 2100-LOCATE-PD-HEADER\n068200         UNTIL PROCEDURE-DIVISION\n068300            OR CANCEL-PROGRAM.\n068400     IF NOT CANCEL-PROGRAM\n068500         PERFORM 2200-LOCATE-DECLARATIVES\n068600         IF NOT CANCEL-PROGRAM\n068700             PERFORM 2300-LOCATE-FIRST-PROC-NAME.\n068800*\n068900 2100-LOCATE-PD-HEADER.\n069000*\n069100     MOVE \"N\" TO ACTIVE-RECORD-SW.\n069200     PERFORM 1110-READ-SOURCE-FILE\n069300         UNTIL SRCEFILE-EOF\n069400            OR (ACTIVE-RECORD AND A-AREA NOT = SPACE).\n069500     IF NOT SRCEFILE-EOF\n069600         PERFORM 1130-UNSTRING-SOURCE-LINE\n069700         IF SOURCE-WORD (1) = \"PROCEDURE\"\n069800             MOVE TOTAL-LINE-COUNT TO FIRST-PD-RECORD-NO\n069900             MOVE \"Y\" TO PROCEDURE-DIVISION-SW\n070000             ADD 1 TO PD-LINE-COUNT\n070100         ELSE\n070200             MOVE \"N\" TO PROCEDURE-DIVISION-SW\n070300     ELSE\n070400         MOVE \"Y\" TO CANCEL-PROGRAM-SW\n070500         MOVE NO-PROCEDURE-DIVISION-MESSAGE TO PRINT-LINE\n070600         PERFORM 1180-PRINT-REPORT-LINE.\n070700*\n070800 2200-LOCATE-DECLARATIVES.\n070900*\n071000     MOVE \"N\" TO ACTIVE-RECORD-SW.\n071100     PERFORM 1110-READ-SOURCE-FILE\n071200         UNTIL SRCEFILE-EOF\n071300            OR (ACTIVE-RECORD AND A-AREA NOT = SPACE).\n071400     PERFORM 1130-UNSTRING-SOURCE-LINE.\n071500     IF SOURCE-WORD (1) = \"DECLARATIVES\"\n071600         MOVE TOTAL-LINE-COUNT TO FIRST-DECLARATIVE-RECORD-NO\n071700         MOVE \"Y\" TO DECLARATIVES-SECTION-SW\n071800     ELSE\n071900         MOVE \"N\" TO DECLARATIVES-SECTION-SW.\n072000     IF DECLARATIVES-SECTION\n072100         PERFORM 2210-LOCATE-END-DECLARATIVES\n072200             UNTIL END-DECLARATIVES\n072300                OR CANCEL-PROGRAM.\n072400*\n072500 2210-LOCATE-END-DECLARATIVES.\n072600*\n072700     MOVE \"N\" TO ACTIVE-RECORD-SW.\n072800     PERFORM 1110-READ-SOURCE-FILE\n072900         UNTIL SRCEFILE-EOF\n073000            OR (ACTIVE-RECORD AND A-AREA NOT = SPACE).\n073100     PERFORM 1130-UNSTRING-SOURCE-LINE.\n073200     IF SRCEFILE-EOF\n073300         MOVE \"Y\" TO CANCEL-PROGRAM-SW\n073400         MOVE NO-END-DECLARATIVES-MESSAGE TO PRINT-LINE\n073500         PERFORM 1180-PRINT-REPORT-LINE\n073600     ELSE\n073700         IF SOURCE-WORD (1) = \"END\"\n073800              MOVE TOTAL-LINE-COUNT TO LAST-DECLARATIVE-RECORD-NO\n073900              MOVE \"Y\" TO END-DECLARATIVES-SW.\n074000*\n074100 2300-LOCATE-FIRST-PROC-NAME.\n074200*\n074300     IF DECLARATIVES-SECTION\n074400         MOVE \"N\" TO ACTIVE-RECORD-SW\n074500         PERFORM 1110-READ-SOURCE-FILE\n074600             UNTIL SRCEFILE-EOF\n074700                OR (ACTIVE-RECORD AND A-AREA NOT = SPACE).\n074800     IF NOT SRCEFILE-EOF\n074900         MOVE TOTAL-LINE-COUNT TO FIRST-PROC-NAME-RECORD-NO.\n075000*\n075100 3000-LOAD-MODULE-NAMES.\n075200*\n075300     PERFORM 3100-CLEAR-MODULE-TABLE\n075400         VARYING MODULE-INDEX FROM 1 BY 1\n075500         UNTIL MODULE-INDEX > MODULE-LIMIT.\n075600     SET MODULE-INDEX TO 1.\n075700     PERFORM 3200-LOAD-MODULE-NAME\n075800         UNTIL SRCEFILE-EOF\n075900            OR TABLE-OVERFLOW.\n076000     IF TABLE-OVERFLOW\n076100         MOVE \"Y\" TO CANCEL-PROGRAM-SW\n076200         MOVE TABLE-OVERFLOW-MESSAGE-1 TO PRINT-LINE\n076300         PERFORM 1180-PRINT-REPORT-LINE\n076400     ELSE\n076500         SET MODULE-INDEX DOWN BY 1\n076600         SET MODULE-COUNT TO MODULE-INDEX.\n076700*\n076800 3100-CLEAR-MODULE-TABLE.\n076900*\n077000     MOVE ZERO  TO MODULE-NUMBER (MODULE-INDEX).\n077100     MOVE SPACE TO FULL-MODULE-NAME (MODULE-INDEX)\n077200                   MODULE-TYPE-FLAG (MODULE-INDEX).\n077300     MOVE \"N\"   TO CALL-OVERFLOW-SW (MODULE-INDEX)\n077400                   MODULE-PRINTED-SW (MODULE-INDEX).\n077500     MOVE ZERO  TO TIMES-CALLED (MODULE-INDEX).\n077600     MOVE ZERO  TO MODULE-CALL-COUNT (MODULE-INDEX).\n077700     PERFORM 3110-CLEAR-MODULE-CALLS\n077800         VARYING CALL-INDEX FROM 1 BY 1\n077900         UNTIL CALL-INDEX > CALL-LIMIT.\n078000*\n078100 3110-CLEAR-MODULE-CALLS.\n078200*\n078300     MOVE ZERO\n078400         TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n078500*\n078600 3200-LOAD-MODULE-NAME.\n078700*\n078800     MOVE \"N\" TO ACTIVE-RECORD-SW.\n078900     IF FIRST-MODULE-NAME\n079000         MOVE \"N\" TO FIRST-MODULE-NAME-SW\n079100     ELSE\n079200         PERFORM 1110-READ-SOURCE-FILE\n079300             UNTIL SRCEFILE-EOF\n079400                OR (ACTIVE-RECORD AND A-AREA NOT = SPACE).\n079500     IF NOT SRCEFILE-EOF\n079600         IF PARAGRAPH-MODULES\n079700             IF MODULE-INDEX NOT > MODULE-LIMIT\n079800                PERFORM 1130-UNSTRING-SOURCE-LINE\n079900                SET MODULE-NUMBER (MODULE-INDEX) TO MODULE-INDEX\n080000                MOVE SOURCE-WORD (1) TO MODULE-NAME (MODULE-INDEX)\n080100                ADD 1 TO COBOL-MODULE-COUNT\n080200                IF SOURCE-WORD (2) = \"SECTION\"\n080300                    MOVE \"X\" TO MODULE-TYPE-FLAG (MODULE-INDEX)\n080400                    ADD 1 TO COBOL-SECTION-COUNT\n080500                    SET MODULE-INDEX UP BY 1\n080600                ELSE\n080700                    MOVE \"P\" TO MODULE-TYPE-FLAG (MODULE-INDEX)\n080800                    ADD 1 TO COBOL-PARAGRAPH-COUNT\n080900                    SET MODULE-INDEX UP BY 1\n081000             ELSE\n081100                 MOVE \"Y\" TO TABLE-OVERFLOW-SW.\n081200     IF NOT SRCEFILE-EOF\n081300         IF SECTION-MODULES\n081400             PERFORM 1130-UNSTRING-SOURCE-LINE\n081500             IF SOURCE-WORD (2) = \"SECTION\"\n081600                 IF MODULE-INDEX NOT > MODULE-LIMIT\n081700                     MOVE \"X\" TO MODULE-TYPE-FLAG (MODULE-INDEX)\n081800                     SET MODULE-NUMBER (MODULE-INDEX)\n081900                         TO MODULE-INDEX\n082000                     MOVE SOURCE-WORD (1)\n082100                         TO MODULE-NAME (MODULE-INDEX)\n082200                     ADD 1 TO COBOL-SECTION-COUNT\n082300                     ADD 1 TO COBOL-MODULE-COUNT\n082400                     SET MODULE-INDEX UP BY 1\n082500                 ELSE\n082600                     MOVE \"Y\" TO TABLE-OVERFLOW-SW\n082700             ELSE\n082800                 ADD 1 TO COBOL-PARAGRAPH-COUNT.\n082900*\n083000 4000-LOAD-MODULE-CALLS.\n083100*\n083200     MOVE \"N\" TO COUNT-LINES-SW.\n083300     MOVE \"N\" TO SRCEFILE-EOF-SW.\n083400     PERFORM 4100-RESTART-PROC-DIVISION.\n083500     PERFORM 4200-LOAD-CALLS-FOR-ONE-MODULE\n083600         VARYING MODULE-INDEX FROM 1 BY 1\n083700         UNTIL MODULE-INDEX > MODULE-COUNT.\n083800     PERFORM 4800-COUNT-MODULE-CALLS.\n083900*\n084000 4100-RESTART-PROC-DIVISION.\n084100*\n084200     CLOSE SRCEFILE.\n084300     OPEN INPUT SRCEFILE.\n084400     PERFORM 1110-READ-SOURCE-FILE\n084500         VARYING RESTART-COUNT FROM 1 BY 1\n084600         UNTIL RESTART-COUNT > FIRST-PROC-NAME-RECORD-NO.\n084700*\n084800 4200-LOAD-CALLS-FOR-ONE-MODULE.\n084900*\n085000     MOVE \"N\" TO NEXT-PROCEDURE-NAME-SW.\n085100     SET CALL-INDEX TO 1.\n085200     PERFORM 4210-LOAD-ONE-MODULE-CALL\n085300         UNTIL SRCEFILE-EOF\n085400            OR NEXT-PROCEDURE-NAME.\n085500*\n085600 4210-LOAD-ONE-MODULE-CALL.\n085700*\n085800     MOVE \"N\" TO ACTIVE-RECORD-SW.\n085900     PERFORM 1110-READ-SOURCE-FILE\n086000         UNTIL SRCEFILE-EOF\n086100            OR ACTIVE-RECORD.\n086200     IF NOT SRCEFILE-EOF\n086300         PERFORM 1130-UNSTRING-SOURCE-LINE\n086400         IF A-AREA = SPACE\n086500             MOVE \"N\" TO PERFORM-FOUND-SW\n086600             MOVE \"N\" TO CALL-FOUND-SW\n086700             MOVE \"N\" TO SORT-FOUND-SW\n086800             MOVE \"N\" TO MERGE-FOUND-SW\n086900             MOVE \"N\" TO INPUT-PROCEDURE-FOUND-SW\n087000             MOVE \"N\" TO OUTPUT-PROCEDURE-FOUND-SW\n087100             MOVE \"N\" TO GOTO-FOUND-SW\n087200             PERFORM 4220-SEARCH-FOR-CALLING-VERB\n087300                 VARYING SOURCE-WORD-INDEX FROM 1 BY 1\n087400                 UNTIL SOURCE-WORD-INDEX > SOURCE-WORD-COUNT\n087500                    OR PERFORM-FOUND\n087600                    OR CALL-FOUND\n087700                    OR SORT-FOUND\n087800                    OR MERGE-FOUND\n087900                    OR INPUT-PROCEDURE-FOUND\n088000                    OR OUTPUT-PROCEDURE-FOUND\n088100                    OR GOTO-FOUND\n088200         ELSE\n088300             IF PARAGRAPH-MODULES\n088400                 MOVE \"Y\" TO NEXT-PROCEDURE-NAME-SW\n088500             ELSE\n088600                 IF SOURCE-WORD (2) = \"SECTION\"\n088700                     MOVE \"Y\" TO NEXT-PROCEDURE-NAME-SW.\n088800     IF NOT SRCEFILE-EOF\n088900         IF A-AREA = SPACE\n089000             IF PERFORM-FOUND\n089100                 PERFORM 4300-LOAD-PERFORMED-PROCEDURE\n089200             ELSE IF CALL-FOUND\n089300                 PERFORM 4400-LOAD-CALLED-PROCEDURE\n089400             ELSE IF SORT-FOUND\n089500                 PERFORM 4500-LOAD-SORT-MERGE-PROCEDURE\n089600             ELSE IF MERGE-FOUND\n089700                 PERFORM 4500-LOAD-SORT-MERGE-PROCEDURE\n089800             ELSE IF INPUT-PROCEDURE-FOUND\n089900                 PERFORM 4600-LOAD-INPUT-PROCEDURE\n090000             ELSE IF OUTPUT-PROCEDURE-FOUND\n090100                 PERFORM 4700-LOAD-OUTPUT-PROCEDURE.\n090200*\n090300 4220-SEARCH-FOR-CALLING-VERB.\n090400*\n090500     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"PERFORM\"\n090600         ADD 1 TO PERFORM-COUNT\n090700         MOVE \"Y\" TO PERFORM-FOUND-SW.\n090800     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"CALL\"\n090900         ADD 1 TO CALL-COUNT\n091000         MOVE \"Y\" TO CALL-FOUND-SW.\n091100     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"SORT\"\n091200         ADD 1 TO SORT-COUNT\n091300         MOVE \"Y\" TO SORT-FOUND-SW.\n091400     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"MERGE\"\n091500         ADD 1 TO MERGE-COUNT\n091600         MOVE \"Y\" TO MERGE-FOUND-SW.\n091700     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"GO\"\n091800         ADD 1 TO GOTO-COUNT\n091900         MOVE \"Y\" TO GOTO-FOUND-SW.\n092000     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"INPUT\"\n092100         SET SOURCE-WORD-INDEX UP BY 1\n092200         IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"PROCEDURE\"\n092300             MOVE \"Y\" TO INPUT-PROCEDURE-FOUND-SW\n092400             ADD 1 TO SORT-MERGE-PROCEDURE-COUNT\n092500         ELSE\n092600             SET SOURCE-WORD-INDEX DOWN BY 1.\n092700     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"OUTPUT\"\n092800         SET SOURCE-WORD-INDEX UP BY 1\n092900             IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"PROCEDURE\"\n093000                 MOVE \"Y\" TO OUTPUT-PROCEDURE-FOUND-SW\n093100                 ADD 1 TO SORT-MERGE-PROCEDURE-COUNT\n093200             ELSE\n093300                 SET SOURCE-WORD-INDEX DOWN BY 1.\n093400*\n093500 4300-LOAD-PERFORMED-PROCEDURE.\n093600*\n093700     IF SOURCE-WORD (SOURCE-WORD-INDEX) NOT = SPACE\n093800         MOVE SOURCE-WORD (SOURCE-WORD-INDEX) TO CALLED-PROC-NAME\n093900         PERFORM 4310-SEARCH-FOR-CALLED-MODULE\n094000         IF FOUND\n094100             PERFORM 4320-SEARCH-FOR-DUPLICATE-CALL\n094200             IF NOT DUPLICATE-CALL\n094300                 IF CALL-INDEX NOT > CALL-LIMIT\n094400                     MOVE CALLED-PROC-NUMBER\n094500                     TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n094600                     ADD 1 TO MODULE-CALL-COUNT (MODULE-INDEX)\n094700                     SET CALL-INDEX UP BY 1\n094800                 ELSE\n094900                     MOVE \"Y\" TO MODULE-CALL-OVERFLOW-SW\n095000                     MOVE \"Y\" TO CALL-OVERFLOW-SW (MODULE-INDEX)\n095100                 END-IF\n095200             END-IF\n095300         ELSE\n095400             ADD 1 TO INLINE-PERFORM-COUNT\n095500         END-IF\n095600     ELSE\n095700*    IF SOURCE-WORD (SOURCE-WORD-INDEX) = SPACE\n095800         ADD 1 TO INLINE-PERFORM-COUNT.\n095900*\n096000 4310-SEARCH-FOR-CALLED-MODULE.\n096100*\n096200     SET INDEX-SAVE-AREA TO MODULE-INDEX.\n096300     SET MODULE-INDEX TO 1.\n096400     SEARCH MODULE-ENTRY\n096500         WHEN MODULE-NAME (MODULE-INDEX) = CALLED-PROC-NAME\n096600             SET CALLED-PROC-NUMBER TO MODULE-INDEX\n096700             MOVE \"Y\" TO FOUND-SW\n096800         WHEN MODULE-INDEX = MODULE-COUNT\n096900             MOVE \"N\" TO FOUND-SW.\n097000     SET MODULE-INDEX TO INDEX-SAVE-AREA.\n097100*\n097200 4320-SEARCH-FOR-DUPLICATE-CALL.\n097300*\n097400     SET INDEX-SAVE-AREA TO CALL-INDEX.\n097500     MOVE \"N\" TO DUPLICATE-CALL-SW.\n097600     PERFORM 4330-SEARCH-CALL-AREA\n097700         VARYING CALL-INDEX FROM 1 BY 1\n097800         UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n097900            OR DUPLICATE-CALL.\n098000     SET CALL-INDEX TO INDEX-SAVE-AREA.\n098100*\n098200 4330-SEARCH-CALL-AREA.\n098300*\n098400     IF CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n098500             = CALLED-PROC-NUMBER\n098600         MOVE \"Y\" TO DUPLICATE-CALL-SW.\n098700*\n098800 4400-LOAD-CALLED-PROCEDURE.\n098900*\n099000     MOVE SOURCE-WORD (SOURCE-WORD-INDEX) TO CALLED-PROC-NAME.\n099100     PERFORM 4310-SEARCH-FOR-CALLED-MODULE.\n099200     IF FOUND\n099300         PERFORM 4320-SEARCH-FOR-DUPLICATE-CALL\n099400         IF NOT DUPLICATE-CALL\n099500             IF CALL-INDEX NOT > CALL-LIMIT\n099600                 MOVE CALLED-PROC-NUMBER\n099700                     TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n099800                 ADD 1 TO MODULE-CALL-COUNT (MODULE-INDEX)\n099900                 SET CALL-INDEX UP BY 1\n100000             ELSE\n100100                 MOVE \"Y\" TO MODULE-CALL-OVERFLOW-SW\n100200                 MOVE \"Y\" TO CALL-OVERFLOW-SW (MODULE-INDEX).\n100300     IF NOT FOUND\n100400         PERFORM 4410-LOAD-SUBPROGRAM-MODULE\n100500         IF NOT TABLE-OVERFLOW\n100600             IF CALL-INDEX NOT > CALL-LIMIT\n100700                 MOVE CALLED-PROC-NUMBER\n100800                     TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n100900                 ADD 1 TO MODULE-CALL-COUNT (MODULE-INDEX)\n101000                 SET CALL-INDEX UP BY 1\n101100             ELSE\n101200                 MOVE \"Y\" TO MODULE-CALL-OVERFLOW-SW\n101300                 MOVE \"Y\" TO CALL-OVERFLOW-SW (MODULE-INDEX).\n101400*\n101500 4410-LOAD-SUBPROGRAM-MODULE.\n101600*\n101700     SET INDEX-SAVE-AREA TO MODULE-INDEX.\n101800     SET MODULE-INDEX TO MODULE-COUNT.\n101900     SET MODULE-INDEX UP BY 1.\n102000     IF MODULE-INDEX NOT > MODULE-LIMIT\n102100         SET MODULE-NUMBER (MODULE-INDEX) TO MODULE-INDEX\n102200         MOVE CALLED-PROC-NAME TO MODULE-NAME (MODULE-INDEX)\n102300         MOVE \"S\" TO MODULE-TYPE-FLAG (MODULE-INDEX)\n102400         SET CALLED-PROC-NUMBER TO MODULE-INDEX\n102500         SET MODULE-COUNT TO MODULE-INDEX\n102600         MOVE \"Y\" TO PRINT-CALLED-SUBPROGRAMS-SW\n102700         ADD 1 TO SUBPROGRAM-COUNT\n102800     ELSE\n102900         MOVE \"Y\" TO TABLE-OVERFLOW-SW.\n103000     SET MODULE-INDEX TO INDEX-SAVE-AREA.\n103100*\n103200 4500-LOAD-SORT-MERGE-PROCEDURE.\n103300*\n103400     IF SORT-FOUND\n103500         MOVE \"(SORT)\" TO CALLED-PROC-NAME\n103600     ELSE\n103700         MOVE \"(MERGE)\" TO CALLED-PROC-NAME.\n103800     PERFORM 4310-SEARCH-FOR-CALLED-MODULE.\n103900     IF FOUND\n104000         PERFORM 4320-SEARCH-FOR-DUPLICATE-CALL\n104100         IF NOT DUPLICATE-CALL\n104200             IF CALL-INDEX NOT > CALL-LIMIT\n104300                 MOVE CALLED-PROC-NUMBER\n104400                     TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n104500                 ADD 1 TO MODULE-CALL-COUNT (MODULE-INDEX)\n104600                 SET CALL-INDEX UP BY 1\n104700             ELSE\n104800                 MOVE \"Y\" TO MODULE-CALL-OVERFLOW-SW\n104900                 MOVE \"Y\" TO CALL-OVERFLOW-SW (MODULE-INDEX).\n105000     IF NOT FOUND\n105100         PERFORM 4510-LOAD-SORT-MERGE-MODULE\n105200         IF NOT TABLE-OVERFLOW\n105300             IF CALL-INDEX NOT > CALL-LIMIT\n105400                 MOVE CALLED-PROC-NUMBER\n105500                     TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n105600                 ADD 1 TO MODULE-CALL-COUNT (MODULE-INDEX)\n105700                 SET CALL-INDEX UP BY 1\n105800             ELSE\n105900                 MOVE \"Y\" TO MODULE-CALL-OVERFLOW-SW\n106000                 MOVE \"Y\" TO CALL-OVERFLOW-SW (MODULE-INDEX).\n106100*\n106200 4510-LOAD-SORT-MERGE-MODULE.\n106300*\n106400     SET INDEX-SAVE-AREA TO MODULE-INDEX.\n106500     SET MODULE-INDEX TO MODULE-COUNT.\n106600     SET MODULE-INDEX UP BY 1.\n106700     IF MODULE-INDEX NOT > MODULE-LIMIT\n106800         SET MODULE-NUMBER (MODULE-INDEX) TO MODULE-INDEX\n106900         MOVE CALLED-PROC-NAME TO MODULE-NAME (MODULE-INDEX)\n107000         MOVE \"T\" TO MODULE-TYPE-FLAG (MODULE-INDEX)\n107100         SET CALLED-PROC-NUMBER TO MODULE-INDEX\n107200         SET MODULE-COUNT TO MODULE-INDEX\n107300     ELSE\n107400         MOVE \"Y\" TO TABLE-OVERFLOW-SW.\n107500     SET MODULE-INDEX TO INDEX-SAVE-AREA.\n107600*\n107700 4600-LOAD-INPUT-PROCEDURE.\n107800*\n107900     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"IS\"\n108000         SET SOURCE-WORD-INDEX UP BY 1.\n108100     MOVE SOURCE-WORD (SOURCE-WORD-INDEX) TO CALLED-PROC-NAME.\n108200     PERFORM 4310-SEARCH-FOR-CALLED-MODULE.\n108300     IF FOUND\n108400         PERFORM 4320-SEARCH-FOR-DUPLICATE-CALL\n108500         IF NOT DUPLICATE-CALL\n108600             IF CALL-INDEX > CALL-LIMIT\n108700                 MOVE \"Y\" TO MODULE-CALL-OVERFLOW-SW\n108800                 MOVE \"Y\" TO CALL-OVERFLOW-SW (MODULE-INDEX)\n108900             ELSE\n109000                 MOVE CALLED-PROC-NUMBER\n109100                     TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n109200                 ADD 1 TO MODULE-CALL-COUNT (MODULE-INDEX)\n109300                 IF CALL-INDEX > 1\n109400                     PERFORM 4610-SWITCH-LAST-TWO-CALLS\n109500                     SET CALL-INDEX UP BY 1\n109600                 ELSE\n109700                     SET CALL-INDEX UP BY 1.\n109800*\n109900 4610-SWITCH-LAST-TWO-CALLS.\n110000*\n110100     MOVE CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n110200         TO CALLED-MODULE-SAVE-AREA.\n110300     MOVE CALLED-MODULE (MODULE-INDEX, CALL-INDEX - 1)\n110400         TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n110500     MOVE CALLED-MODULE-SAVE-AREA\n110600         TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX - 1).\n110700*\n110800 4700-LOAD-OUTPUT-PROCEDURE.\n110900*\n111000     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"IS\"\n111100         SET SOURCE-WORD-INDEX UP BY 1.\n111200     MOVE SOURCE-WORD (SOURCE-WORD-INDEX) TO CALLED-PROC-NAME.\n111300     PERFORM 4310-SEARCH-FOR-CALLED-MODULE.\n111400     IF FOUND\n111500         PERFORM 4320-SEARCH-FOR-DUPLICATE-CALL\n111600         IF NOT DUPLICATE-CALL\n111700             IF CALL-INDEX NOT > CALL-LIMIT\n111800                 MOVE CALLED-PROC-NUMBER\n111900                     TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX)\n112000                 ADD 1 TO MODULE-CALL-COUNT (MODULE-INDEX)\n112100                 SET CALL-INDEX UP BY 1\n112200             ELSE\n112300                 MOVE \"Y\" TO MODULE-CALL-OVERFLOW-SW\n112400                 MOVE \"Y\" TO CALL-OVERFLOW-SW (MODULE-INDEX).\n112500*\n112600 4800-COUNT-MODULE-CALLS.\n112700*\n112800     PERFORM 4810-COUNT-CALLS-FROM-1-MODULE\n112900         VARYING MODULE-INDEX FROM 1 BY 1\n113000         UNTIL MODULE-INDEX > MODULE-COUNT.\n113100     IF MODULE-CALL-COUNT (1) > ZERO\n113200         MOVE 1 TO TIMES-CALLED (1)\n113300     ELSE\n113400         MOVE 1 TO TIMES-CALLED (2).\n113500     PERFORM 4830-SET-CALLING-FLAGS\n113600         VARYING MODULE-INDEX FROM 1 BY 1\n113700         UNTIL MODULE-INDEX > MODULE-COUNT.\n113800*\n113900 4810-COUNT-CALLS-FROM-1-MODULE.\n114000*\n114100     PERFORM 4820-SEARCH-MODULE-ENTRIES\n114200         VARYING CALL-INDEX FROM 1 BY 1\n114300         UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX).\n114400*\n114500 4820-SEARCH-MODULE-ENTRIES.\n114600*\n114700     SET INDEX-SAVE-AREA TO MODULE-INDEX.\n114800     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n114900     ADD 1 TO TIMES-CALLED (MODULE-INDEX).\n115000     SET MODULE-INDEX TO INDEX-SAVE-AREA.\n115100*\n115200 4830-SET-CALLING-FLAGS.\n115300*\n115400     IF TIMES-CALLED (MODULE-INDEX) > 1\n115500         MOVE \"C\" TO COMMON-MODULE-FLAG (MODULE-INDEX).\n115600     IF TIMES-CALLED (MODULE-INDEX) = ZERO\n115700         MOVE \"Y\" TO PRINT-UNCALLED-MODULES-SW.\n115800*\n115900 5000-PRINT-STRUCTURE-LISTING.\n116000*\n116100     SET MODULE-INDEX TO 1.\n116200     MOVE SPACE TO PRINT-LINE.\n116300     PERFORM 5001-PRINT-LEVEL-1.\n116400     PERFORM 5002-PRINT-LEVEL-2\n116500         VARYING CALL-INDEX FROM 1 BY 1\n116600         UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX).\n116700     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n116800         MOVE CALL-OVERFLOW-MESSAGE TO PL2-NAME\n116900         PERFORM 1180-PRINT-REPORT-LINE.\n117000     MOVE \"*\" TO PL1-ASTERISK.                                    AST\n117100     PERFORM 1180-PRINT-REPORT-LINE.                              AST\n117200*\n117300 5001-PRINT-LEVEL-1.\n117400*\n117500     MOVE \"*\" TO  PL1-ASTERISK.                                   AST\n117600     PERFORM 1180-PRINT-REPORT-LINE.                              AST\n117700     IF     MODULE-CALL-COUNT (MODULE-INDEX) = ZERO\n117800        AND PROGRAM-SECTION (MODULE-INDEX)\n117900         SET MODULE-INDEX UP BY 1.\n118000     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL1-NAME.\n118100     PERFORM 1180-PRINT-REPORT-LINE.\n118200*\n118300 5002-PRINT-LEVEL-2.\n118400*\n118500     IF CALL-INDEX = 1                                            AST\n118600         MOVE \"*\" TO PL1-ASTERISK                                 AST\n118700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n118800     MOVE ZERO TO NUMBER-OF-CALLS.\n118900     SET MODULE-INDEX-SAVE-AREA-1 TO MODULE-INDEX.\n119000     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n119100     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL2-NAME.\n119200     PERFORM 1180-PRINT-REPORT-LINE.\n119300     IF NOT COMMON-MODULE (MODULE-INDEX)\n119400         OR (COMMON-MODULE (MODULE-INDEX)\n119500             AND NOT MODULE-PRINTED (MODULE-INDEX))\n119600         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n119700         SET CALL-INDEX-SAVE-AREA-1 TO CALL-INDEX\n119800         PERFORM 5003-PRINT-LEVEL-3\n119900             VARYING CALL-INDEX FROM 1 BY 1\n120000             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n120100         SET NUMBER-OF-CALLS TO CALL-INDEX\n120200         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-1.\n120300     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n120400         MOVE \"** CALL OVERFLOW **\" TO PL3-NAME\n120500         PERFORM 1180-PRINT-REPORT-LINE.\n120600     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-1.\n120700     IF NUMBER-OF-CALLS > 1                                       AST\n120800         MOVE \"*\" TO PL2-ASTERISK                                 AST\n120900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n121000*\n121100 5003-PRINT-LEVEL-3.\n121200*\n121300     IF CALL-INDEX = 1                                            AST\n121400         MOVE \"*\" TO PL2-ASTERISK                                 AST\n121500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n121600     MOVE ZERO TO NUMBER-OF-CALLS.\n121700     SET MODULE-INDEX-SAVE-AREA-2 TO MODULE-INDEX.\n121800     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n121900     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL3-NAME.\n122000     PERFORM 1180-PRINT-REPORT-LINE.\n122100     IF NOT COMMON-MODULE (MODULE-INDEX)\n122200         OR (COMMON-MODULE (MODULE-INDEX)\n122300             AND NOT MODULE-PRINTED (MODULE-INDEX))\n122400         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n122500         SET CALL-INDEX-SAVE-AREA-2 TO CALL-INDEX\n122600         PERFORM 5004-PRINT-LEVEL-4\n122700             VARYING CALL-INDEX FROM 1 BY 1\n122800             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n122900         SET NUMBER-OF-CALLS TO CALL-INDEX\n123000         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-2.\n123100     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n123200         MOVE \"** CALL OVERFLOW **\" TO PL4-NAME\n123300         PERFORM 1180-PRINT-REPORT-LINE.\n123400     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-2.\n123500     IF NUMBER-OF-CALLS > 1                                       AST\n123600         MOVE \"*\" TO PL3-ASTERISK                                 AST\n123700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n123800*\n123900 5004-PRINT-LEVEL-4.\n124000*\n124100     IF CALL-INDEX = 1                                            AST\n124200         MOVE \"*\" TO PL3-ASTERISK                                 AST\n124300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n124400     MOVE ZERO TO NUMBER-OF-CALLS.\n124500     SET MODULE-INDEX-SAVE-AREA-3 TO MODULE-INDEX.\n124600     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n124700     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL4-NAME.\n124800     PERFORM 1180-PRINT-REPORT-LINE.\n124900     IF NOT COMMON-MODULE (MODULE-INDEX)\n125000         OR (COMMON-MODULE (MODULE-INDEX)\n125100             AND NOT MODULE-PRINTED (MODULE-INDEX))\n125200         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n125300         SET CALL-INDEX-SAVE-AREA-3 TO CALL-INDEX\n125400         PERFORM 5005-PRINT-LEVEL-5\n125500             VARYING CALL-INDEX FROM 1 BY 1\n125600             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n125700         SET NUMBER-OF-CALLS TO CALL-INDEX\n125800         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-3.\n125900     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n126000         MOVE \"** CALL OVERFLOW **\" TO PL5-NAME\n126100         PERFORM 1180-PRINT-REPORT-LINE.\n126200     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-3.\n126300     IF NUMBER-OF-CALLS > 1                                       AST\n126400         MOVE \"*\" TO PL4-ASTERISK                                 AST\n126500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n126600*\n126700 5005-PRINT-LEVEL-5.\n126800*\n126900     IF CALL-INDEX = 1                                            AST\n127000         MOVE \"*\" TO PL4-ASTERISK                                 AST\n127100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n127200     MOVE ZERO TO NUMBER-OF-CALLS.\n127300     SET MODULE-INDEX-SAVE-AREA-4 TO MODULE-INDEX.\n127400     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n127500     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL5-NAME.\n127600     PERFORM 1180-PRINT-REPORT-LINE.\n127700     IF NOT COMMON-MODULE (MODULE-INDEX)\n127800         OR (COMMON-MODULE (MODULE-INDEX)\n127900             AND NOT MODULE-PRINTED (MODULE-INDEX))\n128000         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n128100         SET CALL-INDEX-SAVE-AREA-4 TO CALL-INDEX\n128200         PERFORM 5006-PRINT-LEVEL-6\n128300             VARYING CALL-INDEX FROM 1 BY 1\n128400             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n128500         SET NUMBER-OF-CALLS TO CALL-INDEX\n128600         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-4.\n128700     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n128800         MOVE \"** CALL OVERFLOW **\" TO PL6-NAME\n128900         PERFORM 1180-PRINT-REPORT-LINE.\n129000     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-4.\n129100     IF NUMBER-OF-CALLS > 1                                       AST\n129200         MOVE \"*\" TO PL5-ASTERISK                                 AST\n129300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n129400*\n129500 5006-PRINT-LEVEL-6.\n129600*\n129700     IF CALL-INDEX = 1                                            AST\n129800         MOVE \"*\" TO PL5-ASTERISK                                 AST\n129900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n130000     MOVE ZERO TO NUMBER-OF-CALLS.\n130100     SET MODULE-INDEX-SAVE-AREA-5 TO MODULE-INDEX.\n130200     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n130300     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL6-NAME.\n130400     PERFORM 1180-PRINT-REPORT-LINE.\n130500     IF NOT COMMON-MODULE (MODULE-INDEX)\n130600         OR (COMMON-MODULE (MODULE-INDEX)\n130700             AND NOT MODULE-PRINTED (MODULE-INDEX))\n130800         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n130900         SET CALL-INDEX-SAVE-AREA-5 TO CALL-INDEX\n131000         PERFORM 5007-PRINT-LEVEL-7\n131100             VARYING CALL-INDEX FROM 1 BY 1\n131200             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n131300         SET NUMBER-OF-CALLS TO CALL-INDEX\n131400         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-5.\n131500     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n131600         MOVE \"** CALL OVERFLOW **\" TO PL7-NAME\n131700         PERFORM 1180-PRINT-REPORT-LINE.\n131800     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-5.\n131900     IF NUMBER-OF-CALLS > 1                                       AST\n132000         MOVE \"*\" TO PL6-ASTERISK                                 AST\n132100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n132200*\n132300 5007-PRINT-LEVEL-7.\n132400*\n132500     IF CALL-INDEX = 1                                            AST\n132600         MOVE \"*\" TO PL6-ASTERISK                                 AST\n132700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n132800     MOVE ZERO TO NUMBER-OF-CALLS.\n132900     SET MODULE-INDEX-SAVE-AREA-6 TO MODULE-INDEX.\n133000     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n133100     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL7-NAME.\n133200     PERFORM 1180-PRINT-REPORT-LINE.\n133300     IF NOT COMMON-MODULE (MODULE-INDEX)\n133400         OR (COMMON-MODULE (MODULE-INDEX)\n133500             AND NOT MODULE-PRINTED (MODULE-INDEX))\n133600         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n133700         SET CALL-INDEX-SAVE-AREA-6 TO CALL-INDEX\n133800         PERFORM 5008-PRINT-LEVEL-8\n133900             VARYING CALL-INDEX FROM 1 BY 1\n134000             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n134100         SET NUMBER-OF-CALLS TO CALL-INDEX\n134200         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-6.\n134300     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n134400         MOVE \"** CALL OVERFLOW **\" TO PL8-NAME\n134500         PERFORM 1180-PRINT-REPORT-LINE.\n134600     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-6.\n134700     IF NUMBER-OF-CALLS > 1                                       AST\n134800         MOVE \"*\" TO PL7-ASTERISK                                 AST\n134900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n135000*\n135100 5008-PRINT-LEVEL-8.\n135200*\n135300     IF CALL-INDEX = 1                                            AST\n135400         MOVE \"*\" TO PL7-ASTERISK                                 AST\n135500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n135600     MOVE ZERO TO NUMBER-OF-CALLS.\n135700     SET MODULE-INDEX-SAVE-AREA-7 TO MODULE-INDEX.\n135800     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n135900     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL8-NAME.\n136000     PERFORM 1180-PRINT-REPORT-LINE.\n136100     IF NOT COMMON-MODULE (MODULE-INDEX)\n136200         OR (COMMON-MODULE (MODULE-INDEX)\n136300             AND NOT MODULE-PRINTED (MODULE-INDEX))\n136400         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n136500         SET CALL-INDEX-SAVE-AREA-7 TO CALL-INDEX\n136600         PERFORM 5009-PRINT-LEVEL-9\n136700             VARYING CALL-INDEX FROM 1 BY 1\n136800             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n136900         SET NUMBER-OF-CALLS TO CALL-INDEX\n137000         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-7.\n137100     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n137200         MOVE \"** CALL OVERFLOW **\" TO PL9-NAME\n137300         PERFORM 1180-PRINT-REPORT-LINE.\n137400     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-7.\n137500     IF NUMBER-OF-CALLS > 1                                       AST\n137600         MOVE \"*\" TO PL8-ASTERISK                                 AST\n137700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n137800*\n137900 5009-PRINT-LEVEL-9.\n138000*\n138100     IF CALL-INDEX = 1                                            AST\n138200         MOVE \"*\" TO PL8-ASTERISK                                 AST\n138300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n138400     MOVE ZERO TO NUMBER-OF-CALLS.\n138500     SET MODULE-INDEX-SAVE-AREA-8 TO MODULE-INDEX.\n138600     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n138700     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL9-NAME.\n138800     PERFORM 1180-PRINT-REPORT-LINE.\n138900     IF NOT COMMON-MODULE (MODULE-INDEX)\n139000         OR (COMMON-MODULE (MODULE-INDEX)\n139100             AND NOT MODULE-PRINTED (MODULE-INDEX))\n139200         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n139300         SET CALL-INDEX-SAVE-AREA-8 TO CALL-INDEX\n139400         PERFORM 5010-PRINT-LEVEL-10\n139500             VARYING CALL-INDEX FROM 1 BY 1\n139600             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n139700         SET NUMBER-OF-CALLS TO CALL-INDEX\n139800         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-8.\n139900     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n140000         MOVE \"** CALL OVERFLOW **\" TO PL10-NAME\n140100         PERFORM 1180-PRINT-REPORT-LINE.\n140200     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-8.\n140300     IF NUMBER-OF-CALLS > 1                                       AST\n140400         MOVE \"*\" TO PL9-ASTERISK                                 AST\n140500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n140600*\n140700 5010-PRINT-LEVEL-10.\n140800*\n140900     IF CALL-INDEX = 1                                            AST\n141000         MOVE \"*\" TO PL9-ASTERISK                                 AST\n141100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n141200     MOVE ZERO TO NUMBER-OF-CALLS.\n141300     SET MODULE-INDEX-SAVE-AREA-9 TO MODULE-INDEX.\n141400     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n141500     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL10-NAME.\n141600     PERFORM 1180-PRINT-REPORT-LINE.\n141700     IF NOT COMMON-MODULE (MODULE-INDEX)\n141800         OR (COMMON-MODULE (MODULE-INDEX)\n141900             AND NOT MODULE-PRINTED (MODULE-INDEX))\n142000         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n142100         SET CALL-INDEX-SAVE-AREA-9 TO CALL-INDEX\n142200         PERFORM 5011-PRINT-LEVEL-11\n142300             VARYING CALL-INDEX FROM 1 BY 1\n142400             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n142500         SET NUMBER-OF-CALLS TO CALL-INDEX\n142600         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-9.\n142700     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n142800         MOVE \"** CALL OVERFLOW **\" TO PL11-NAME\n142900         PERFORM 1180-PRINT-REPORT-LINE.\n143000     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-9.\n143100     IF NUMBER-OF-CALLS > 1                                       AST\n143200         MOVE \"*\" TO PL10-ASTERISK                                AST\n143300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n143400*\n143500 5011-PRINT-LEVEL-11.\n143600*\n143700     IF CALL-INDEX = 1                                            AST\n143800         MOVE \"*\" TO PL10-ASTERISK                                AST\n143900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n144000     MOVE ZERO TO NUMBER-OF-CALLS.\n144100     SET MODULE-INDEX-SAVE-AREA-10 TO MODULE-INDEX.\n144200     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n144300     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL11-NAME.\n144400     PERFORM 1180-PRINT-REPORT-LINE.\n144500     IF NOT COMMON-MODULE (MODULE-INDEX)\n144600         OR (COMMON-MODULE (MODULE-INDEX)\n144700             AND NOT MODULE-PRINTED (MODULE-INDEX))\n144800         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n144900         SET CALL-INDEX-SAVE-AREA-10 TO CALL-INDEX\n145000         PERFORM 5012-PRINT-LEVEL-12\n145100             VARYING CALL-INDEX FROM 1 BY 1\n145200             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n145300         SET NUMBER-OF-CALLS TO CALL-INDEX\n145400         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-10.\n145500     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n145600         MOVE \"** CALL OVERFLOW **\" TO PL12-NAME\n145700         PERFORM 1180-PRINT-REPORT-LINE.\n145800     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-10.\n145900     IF NUMBER-OF-CALLS > 1                                       AST\n146000         MOVE \"*\" TO PL11-ASTERISK                                AST\n146100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n146200*\n146300 5012-PRINT-LEVEL-12.\n146400*\n146500     IF CALL-INDEX = 1                                            AST\n146600         MOVE \"*\" TO PL11-ASTERISK                                AST\n146700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n146800     MOVE ZERO TO NUMBER-OF-CALLS.\n146900     SET MODULE-INDEX-SAVE-AREA-11 TO MODULE-INDEX.\n147000     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n147100     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL12-NAME.\n147200     PERFORM 1180-PRINT-REPORT-LINE.\n147300     IF NOT COMMON-MODULE (MODULE-INDEX)\n147400         OR (COMMON-MODULE (MODULE-INDEX)\n147500             AND NOT MODULE-PRINTED (MODULE-INDEX))\n147600         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n147700         SET CALL-INDEX-SAVE-AREA-11 TO CALL-INDEX\n147800         PERFORM 5013-PRINT-LEVEL-13\n147900             VARYING CALL-INDEX FROM 1 BY 1\n148000             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n148100         SET NUMBER-OF-CALLS TO CALL-INDEX\n148200         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-11.\n148300     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n148400         MOVE \"** CALL OVERFLOW **\" TO PL13-NAME\n148500         PERFORM 1180-PRINT-REPORT-LINE.\n148600     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-11.\n148700     IF NUMBER-OF-CALLS > 1                                       AST\n148800         MOVE \"*\" TO PL12-ASTERISK                                AST\n148900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n149000*\n149100 5013-PRINT-LEVEL-13.\n149200*\n149300     IF CALL-INDEX = 1                                            AST\n149400         MOVE \"*\" TO PL12-ASTERISK                                AST\n149500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n149600     MOVE ZERO TO NUMBER-OF-CALLS.\n149700     SET MODULE-INDEX-SAVE-AREA-12 TO MODULE-INDEX.\n149800     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n149900     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL13-NAME.\n150000     PERFORM 1180-PRINT-REPORT-LINE.\n150100     IF NOT COMMON-MODULE (MODULE-INDEX)\n150200         OR (COMMON-MODULE (MODULE-INDEX)\n150300             AND NOT MODULE-PRINTED (MODULE-INDEX))\n150400         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n150500         SET CALL-INDEX-SAVE-AREA-12 TO CALL-INDEX\n150600         PERFORM 5014-PRINT-LEVEL-14\n150700             VARYING CALL-INDEX FROM 1 BY 1\n150800             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n150900         SET NUMBER-OF-CALLS TO CALL-INDEX\n151000         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-12.\n151100     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n151200         MOVE \"** CALL OVERFLOW **\" TO PL14-NAME\n151300         PERFORM 1180-PRINT-REPORT-LINE.\n151400     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-12.\n151500     IF NUMBER-OF-CALLS > 1                                       AST\n151600         MOVE \"*\" TO PL13-ASTERISK                                AST\n151700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n151800*\n151900 5014-PRINT-LEVEL-14.\n152000*\n152100     IF CALL-INDEX = 1                                            AST\n152200         MOVE \"*\" TO PL13-ASTERISK                                AST\n152300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n152400     MOVE ZERO TO NUMBER-OF-CALLS.\n152500     SET MODULE-INDEX-SAVE-AREA-13 TO MODULE-INDEX.\n152600     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n152700     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL14-NAME.\n152800     PERFORM 1180-PRINT-REPORT-LINE.\n152900     IF NOT COMMON-MODULE (MODULE-INDEX)\n153000         OR (COMMON-MODULE (MODULE-INDEX)\n153100             AND NOT MODULE-PRINTED (MODULE-INDEX))\n153200         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n153300         SET CALL-INDEX-SAVE-AREA-13 TO CALL-INDEX\n153400         PERFORM 5015-PRINT-LEVEL-15\n153500             VARYING CALL-INDEX FROM 1 BY 1\n153600             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n153700         SET NUMBER-OF-CALLS TO CALL-INDEX\n153800         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-13.\n153900     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n154000         MOVE \"** CALL OVERFLOW **\" TO PL15-NAME\n154100         PERFORM 1180-PRINT-REPORT-LINE.\n154200     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-13.\n154300     IF NUMBER-OF-CALLS > 1                                       AST\n154400         MOVE \"*\" TO PL14-ASTERISK                                AST\n154500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n154600*\n154700 5015-PRINT-LEVEL-15.\n154800*\n154900     IF CALL-INDEX = 1                                            AST\n155000         MOVE \"*\" TO PL14-ASTERISK                                AST\n155100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n155200     MOVE ZERO TO NUMBER-OF-CALLS.\n155300     SET MODULE-INDEX-SAVE-AREA-14 TO MODULE-INDEX.\n155400     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n155500     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL15-NAME.\n155600     PERFORM 1180-PRINT-REPORT-LINE.\n155700     IF NOT COMMON-MODULE (MODULE-INDEX)\n155800         OR (COMMON-MODULE (MODULE-INDEX)\n155900             AND NOT MODULE-PRINTED (MODULE-INDEX))\n156000         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n156100         SET CALL-INDEX-SAVE-AREA-14 TO CALL-INDEX\n156200         PERFORM 5016-PRINT-LEVEL-16\n156300             VARYING CALL-INDEX FROM 1 BY 1\n156400             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n156500         SET NUMBER-OF-CALLS TO CALL-INDEX\n156600         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-14.\n156700     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n156800         MOVE \"** CALL OVERFLOW **\" TO PL16-NAME\n156900         PERFORM 1180-PRINT-REPORT-LINE.\n157000     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-14.\n157100     IF NUMBER-OF-CALLS > 1                                       AST\n157200         MOVE \"*\" TO PL15-ASTERISK                                AST\n157300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n157400*\n157500 5016-PRINT-LEVEL-16.\n157600*\n157700     IF CALL-INDEX = 1                                            AST\n157800         MOVE \"*\" TO PL15-ASTERISK                                AST\n157900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n158000     MOVE ZERO TO NUMBER-OF-CALLS.\n158100     SET MODULE-INDEX-SAVE-AREA-15 TO MODULE-INDEX.\n158200     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n158300     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL16-NAME.\n158400     PERFORM 1180-PRINT-REPORT-LINE.\n158500     IF NOT COMMON-MODULE (MODULE-INDEX)\n158600         OR (COMMON-MODULE (MODULE-INDEX)\n158700             AND NOT MODULE-PRINTED (MODULE-INDEX))\n158800         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n158900         SET CALL-INDEX-SAVE-AREA-15 TO CALL-INDEX\n159000         PERFORM 5017-PRINT-LEVEL-17\n159100             VARYING CALL-INDEX FROM 1 BY 1\n159200             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n159300         SET NUMBER-OF-CALLS TO CALL-INDEX\n159400         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-15.\n159500     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n159600         MOVE \"** CALL OVERFLOW **\" TO PL17-NAME\n159700         PERFORM 1180-PRINT-REPORT-LINE.\n159800     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-15.\n159900     IF NUMBER-OF-CALLS > 1                                       AST\n160000         MOVE \"*\" TO PL16-ASTERISK                                AST\n160100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n160200*\n160300 5017-PRINT-LEVEL-17.\n160400*\n160500     IF CALL-INDEX = 1                                            AST\n160600         MOVE \"*\" TO PL16-ASTERISK                                AST\n160700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n160800     MOVE ZERO TO NUMBER-OF-CALLS.\n160900     SET MODULE-INDEX-SAVE-AREA-16 TO MODULE-INDEX.\n161000     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n161100     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL17-NAME.\n161200     PERFORM 1180-PRINT-REPORT-LINE.\n161300     IF NOT COMMON-MODULE (MODULE-INDEX)\n161400         OR (COMMON-MODULE (MODULE-INDEX)\n161500             AND NOT MODULE-PRINTED (MODULE-INDEX))\n161600         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n161700         SET CALL-INDEX-SAVE-AREA-16 TO CALL-INDEX\n161800         PERFORM 5018-PRINT-LEVEL-18\n161900             VARYING CALL-INDEX FROM 1 BY 1\n162000             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n162100         SET NUMBER-OF-CALLS TO CALL-INDEX\n162200         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-16.\n162300     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n162400         MOVE \"** CALL OVERFLOW **\" TO PL18-NAME\n162500         PERFORM 1180-PRINT-REPORT-LINE.\n162600     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-16.\n162700     IF NUMBER-OF-CALLS > 1                                       AST\n162800         MOVE \"*\" TO PL17-ASTERISK                                AST\n162900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n163000*\n163100 5018-PRINT-LEVEL-18.\n163200*\n163300     IF CALL-INDEX = 1                                            AST\n163400         MOVE \"*\" TO PL17-ASTERISK                                AST\n163500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n163600     MOVE ZERO TO NUMBER-OF-CALLS.\n163700     SET MODULE-INDEX-SAVE-AREA-17 TO MODULE-INDEX.\n163800     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n163900     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL18-NAME.\n164000     PERFORM 1180-PRINT-REPORT-LINE.\n164100     IF NOT COMMON-MODULE (MODULE-INDEX)\n164200         OR (COMMON-MODULE (MODULE-INDEX)\n164300             AND NOT MODULE-PRINTED (MODULE-INDEX))\n164400         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n164500         SET CALL-INDEX-SAVE-AREA-17 TO CALL-INDEX\n164600         PERFORM 5019-PRINT-LEVEL-19\n164700             VARYING CALL-INDEX FROM 1 BY 1\n164800             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n164900         SET NUMBER-OF-CALLS TO CALL-INDEX\n165000         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-17.\n165100     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n165200         MOVE \"** CALL OVERFLOW **\" TO PL19-NAME\n165300         PERFORM 1180-PRINT-REPORT-LINE.\n165400     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-17.\n165500     IF NUMBER-OF-CALLS > 1                                       AST\n165600         MOVE \"*\" TO PL18-ASTERISK                                AST\n165700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n165800*\n165900 5019-PRINT-LEVEL-19.\n166000*\n166100     IF CALL-INDEX = 1                                            AST\n166200         MOVE \"*\" TO PL18-ASTERISK                                AST\n166300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n166400     MOVE ZERO TO NUMBER-OF-CALLS.\n166500     SET MODULE-INDEX-SAVE-AREA-18 TO MODULE-INDEX.\n166600     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n166700     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL19-NAME.\n166800     PERFORM 1180-PRINT-REPORT-LINE.\n166900     IF NOT COMMON-MODULE (MODULE-INDEX)\n167000         OR (COMMON-MODULE (MODULE-INDEX)\n167100             AND NOT MODULE-PRINTED (MODULE-INDEX))\n167200         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n167300         SET CALL-INDEX-SAVE-AREA-18 TO CALL-INDEX\n167400         PERFORM 5020-PRINT-LEVEL-20\n167500             VARYING CALL-INDEX FROM 1 BY 1\n167600             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n167700         SET NUMBER-OF-CALLS TO CALL-INDEX\n167800         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-18.\n167900     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n168000         MOVE \"** CALL OVERFLOW **\" TO PL20-NAME\n168100         PERFORM 1180-PRINT-REPORT-LINE.\n168200     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-18.\n168300     IF NUMBER-OF-CALLS > 1                                       AST\n168400         MOVE \"*\" TO PL19-ASTERISK                                AST\n168500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n168600*\n168700 5020-PRINT-LEVEL-20.\n168800*\n168900     IF CALL-INDEX = 1                                            AST\n169000         MOVE \"*\" TO PL19-ASTERISK                                AST\n169100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n169200     MOVE ZERO TO NUMBER-OF-CALLS.\n169300     SET MODULE-INDEX-SAVE-AREA-19 TO MODULE-INDEX.\n169400     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n169500     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL20-NAME.\n169600     PERFORM 1180-PRINT-REPORT-LINE.\n169700     IF NOT COMMON-MODULE (MODULE-INDEX)\n169800         OR (COMMON-MODULE (MODULE-INDEX)\n169900             AND NOT MODULE-PRINTED (MODULE-INDEX))\n170000         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n170100         SET CALL-INDEX-SAVE-AREA-19 TO CALL-INDEX\n170200         PERFORM 5021-PRINT-LEVEL-21\n170300             VARYING CALL-INDEX FROM 1 BY 1\n170400             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n170500         SET NUMBER-OF-CALLS TO CALL-INDEX\n170600         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-19.\n170700     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n170800         MOVE \"** CALL OVERFLOW **\" TO PL21-NAME\n170900         PERFORM 1180-PRINT-REPORT-LINE.\n171000     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-19.\n171100     IF NUMBER-OF-CALLS > 1                                       AST\n171200         MOVE \"*\" TO PL20-ASTERISK                                AST\n171300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n171400*\n171500 5021-PRINT-LEVEL-21.\n171600*\n171700     IF CALL-INDEX = 1                                            AST\n171800         MOVE \"*\" TO PL20-ASTERISK                                AST\n171900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n172000     MOVE ZERO TO NUMBER-OF-CALLS.\n172100     SET MODULE-INDEX-SAVE-AREA-20 TO MODULE-INDEX.\n172200     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n172300     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL21-NAME.\n172400     PERFORM 1180-PRINT-REPORT-LINE.\n172500     IF NOT COMMON-MODULE (MODULE-INDEX)\n172600         OR (COMMON-MODULE (MODULE-INDEX)\n172700             AND NOT MODULE-PRINTED (MODULE-INDEX))\n172800         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n172900         SET CALL-INDEX-SAVE-AREA-20 TO CALL-INDEX\n173000         PERFORM 5022-PRINT-LEVEL-22\n173100             VARYING CALL-INDEX FROM 1 BY 1\n173200             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n173300         SET NUMBER-OF-CALLS TO CALL-INDEX\n173400         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-20.\n173500     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n173600         MOVE \"** CALL OVERFLOW **\" TO PL22-NAME\n173700         PERFORM 1180-PRINT-REPORT-LINE.\n173800     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-20.\n173900     IF NUMBER-OF-CALLS > 1                                       AST\n174000         MOVE \"*\" TO PL21-ASTERISK                                AST\n174100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n174200*\n174300 5022-PRINT-LEVEL-22.\n174400*\n174500     IF CALL-INDEX = 1                                            AST\n174600         MOVE \"*\" TO PL21-ASTERISK                                AST\n174700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n174800     MOVE ZERO TO NUMBER-OF-CALLS.\n174900     SET MODULE-INDEX-SAVE-AREA-21 TO MODULE-INDEX.\n175000     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n175100     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL22-NAME.\n175200     PERFORM 1180-PRINT-REPORT-LINE.\n175300     IF NOT COMMON-MODULE (MODULE-INDEX)\n175400         OR (COMMON-MODULE (MODULE-INDEX)\n175500             AND NOT MODULE-PRINTED (MODULE-INDEX))\n175600         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n175700         SET CALL-INDEX-SAVE-AREA-21 TO CALL-INDEX\n175800         PERFORM 5023-PRINT-LEVEL-23\n175900             VARYING CALL-INDEX FROM 1 BY 1\n176000             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n176100         SET NUMBER-OF-CALLS TO CALL-INDEX\n176200         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-21.\n176300     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n176400         MOVE \"** CALL OVERFLOW **\" TO PL23-NAME\n176500         PERFORM 1180-PRINT-REPORT-LINE.\n176600     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-21.\n176700     IF NUMBER-OF-CALLS > 1                                       AST\n176800         MOVE \"*\" TO PL22-ASTERISK                                AST\n176900         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n177000*\n177100 5023-PRINT-LEVEL-23.\n177200*\n177300     IF CALL-INDEX = 1                                            AST\n177400         MOVE \"*\" TO PL22-ASTERISK                                AST\n177500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n177600     MOVE ZERO TO NUMBER-OF-CALLS.\n177700     SET MODULE-INDEX-SAVE-AREA-22 TO MODULE-INDEX.\n177800     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n177900     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL23-NAME.\n178000     PERFORM 1180-PRINT-REPORT-LINE.\n178100     IF NOT COMMON-MODULE (MODULE-INDEX)\n178200         OR (COMMON-MODULE (MODULE-INDEX)\n178300             AND NOT MODULE-PRINTED (MODULE-INDEX))\n178400         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n178500         SET CALL-INDEX-SAVE-AREA-22 TO CALL-INDEX\n178600         PERFORM 5024-PRINT-LEVEL-24\n178700             VARYING CALL-INDEX FROM 1 BY 1\n178800             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n178900         SET NUMBER-OF-CALLS TO CALL-INDEX\n179000         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-22.\n179100     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n179200         MOVE \"** CALL OVERFLOW **\" TO PL24-NAME\n179300         PERFORM 1180-PRINT-REPORT-LINE.\n179400     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-22.\n179500     IF NUMBER-OF-CALLS > 1                                       AST\n179600         MOVE \"*\" TO PL23-ASTERISK                                AST\n179700         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n179800*\n179900 5024-PRINT-LEVEL-24.\n180000*\n180100     IF CALL-INDEX = 1                                            AST\n180200         MOVE \"*\" TO PL23-ASTERISK                                AST\n180300         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n180400     MOVE ZERO TO NUMBER-OF-CALLS.\n180500     SET MODULE-INDEX-SAVE-AREA-23 TO MODULE-INDEX.\n180600     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n180700     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL24-NAME.\n180800     PERFORM 1180-PRINT-REPORT-LINE.\n180900     IF NOT COMMON-MODULE (MODULE-INDEX)\n181000         OR (COMMON-MODULE (MODULE-INDEX)\n181100             AND NOT MODULE-PRINTED (MODULE-INDEX))\n181200         MOVE \"Y\" TO MODULE-PRINTED-SW (MODULE-INDEX)\n181300         SET CALL-INDEX-SAVE-AREA-23 TO CALL-INDEX\n181400         PERFORM 5025-PRINT-LEVEL-25\n181500             VARYING CALL-INDEX FROM 1 BY 1\n181600             UNTIL CALL-INDEX > MODULE-CALL-COUNT (MODULE-INDEX)\n181700         SET NUMBER-OF-CALLS TO CALL-INDEX\n181800         SET CALL-INDEX TO CALL-INDEX-SAVE-AREA-23.\n181900     IF CALL-OVERFLOW-SW (MODULE-INDEX) = \"Y\"\n182000         MOVE \"** CALL OVERFLOW **\" TO PL5-NAME\n182100         PERFORM 1180-PRINT-REPORT-LINE.\n182200     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-23.\n182300     IF NUMBER-OF-CALLS > 1                                       AST\n182400         MOVE \"*\" TO PL24-ASTERISK                                AST\n182500         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n182600*\n182700 5025-PRINT-LEVEL-25.\n182800*\n182900     IF CALL-INDEX = 1                                            AST\n183000         MOVE \"*\" TO PL24-ASTERISK                                AST\n183100         PERFORM 1180-PRINT-REPORT-LINE.                          AST\n183200     SET MODULE-INDEX-SAVE-AREA-24 TO MODULE-INDEX.\n183300     SET MODULE-INDEX TO CALLED-MODULE (MODULE-INDEX, CALL-INDEX).\n183400     MOVE FULL-MODULE-NAME (MODULE-INDEX) TO PL25-NAME.\n183500     PERFORM 1180-PRINT-REPORT-LINE.\n183600     IF     (MODULE-CALL-COUNT (MODULE-INDEX) NOT = ZERO)\n183700        AND (NOT MODULE-PRINTED (MODULE-INDEX))\n183800         MOVE \"** LEVEL OVERFLOW **\" TO PL25-NAME\n183900         PERFORM 1180-PRINT-REPORT-LINE\n184000         MOVE \"Y\" TO LEVEL-OVERFLOW-SW.\n184100     SET MODULE-INDEX TO MODULE-INDEX-SAVE-AREA-24.\n184200*\n184300 6000-PRINT-DECLARATIVES.                                         DEC\n184400*                                                                 DEC\n184500     MOVE 99 TO LINE-COUNT.                                       DEC\n184600     MOVE \"N\" TO SRCEFILE-EOF-SW.                                 DEC\n184700     PERFORM 6100-RESTART-DECLARATIVES.                           DEC\n184800     MOVE DECLARATIVES-HEADING TO SHL-HEADING.                    DEC\n184900     MOVE SUMMARY-HEADING-LINE TO PRINT-LINE.                     DEC\n185000     MOVE 2 TO SPACE-CONTROL.                                     DEC\n185100     PERFORM 1180-PRINT-REPORT-LINE.                              DEC\n185200     MOVE 2 TO SPACE-CONTROL.                                     DEC\n185300     PERFORM 6200-PRINT-DECLARATIVE-LINE                          DEC\n185400         VARYING RESTART-COUNT                                    DEC\n185500             FROM FIRST-DECLARATIVE-RECORD-NO BY 1                DEC\n185600         UNTIL RESTART-COUNT > LAST-DECLARATIVE-RECORD-NO.        DEC\n185700*                                                                 DEC\n185800 6100-RESTART-DECLARATIVES.                                       DEC\n185900*                                                                 DEC\n186000     CLOSE SRCEFILE.                                              DEC\n186100     OPEN INPUT SRCEFILE.                                         DEC\n186200     PERFORM 1110-READ-SOURCE-FILE                                DEC\n186300         VARYING RESTART-COUNT FROM 1 BY 1                        DEC\n186400         UNTIL RESTART-COUNT > FIRST-DECLARATIVE-RECORD-NO.       DEC\n186500*                                                                 DEC\n186600 6200-PRINT-DECLARATIVE-LINE.                                     DEC\n186700*                                                                 DEC\n186800     PERFORM 1110-READ-SOURCE-FILE.                               DEC\n186900*                                                                 DEC\n187000     IF ACTIVE-RECORD                                             DEC\n187100         IF A-AREA NOT = SPACE                                    DEC\n187200             PERFORM 1130-UNSTRING-SOURCE-LINE                    DEC\n187300             IF SOURCE-WORD (2) = \"SECTION\"                       DEC\n187400                 MOVE \"*\" TO PL1-ASTERISK                         DEC\n187500                 PERFORM 1180-PRINT-REPORT-LINE                   DEC\n187600                 MOVE DATA-AREA TO DL-CODE                        DEC\n187700                 PERFORM 1180-PRINT-REPORT-LINE                   DEC\n187800                 MOVE \"*\" TO PL1-ASTERISK                         DEC\n187900                 PERFORM 1180-PRINT-REPORT-LINE.                  DEC\n188000*                                                                 DEC\n188100     IF ACTIVE-RECORD                                             DEC\n188200         IF A-AREA = SPACE                                        DEC\n188300             IF NOT USE-STATEMENT                                 DEC\n188400                 PERFORM 1130-UNSTRING-SOURCE-LINE                DEC\n188500                 PERFORM 6210-SEARCH-FOR-USE-VERB                 DEC\n188600                     VARYING SOURCE-WORD-INDEX FROM 1 BY 1        DEC\n188700                     UNTIL SOURCE-WORD-INDEX > SOURCE-WORD-COUNT  DEC\n188800                        OR USE-STATEMENT                          DEC\n188900                     IF USE-STATEMENT                             DEC\n189000                         MOVE DATA-AREA TO DL-CODE                DEC\n189100                         PERFORM 1180-PRINT-REPORT-LINE           DEC\n189200                         MOVE ZERO TO PERIOD-COUNT                DEC\n189300                         INSPECT DATA-AREA TALLYING PERIOD-COUNT  DEC\n189400                             FOR ALL \".\"                          DEC\n189500                         IF PERIOD-COUNT > ZERO                   DEC\n189600                             MOVE \"N\" TO USE-STATEMENT-SW         DEC\n189700                         ELSE                                     DEC\n189800                             NEXT SENTENCE                        DEC\n189900                     ELSE                                         DEC\n190000                         NEXT SENTENCE                            DEC\n190100                 ELSE                                             DEC\n190200                     MOVE DATA-AREA TO DECLARATIVE-LINE           DEC\n190300                     PERFORM 1180-PRINT-REPORT-LINE               DEC\n190400                     MOVE ZERO TO PERIOD-COUNT                    DEC\n190500                     INSPECT DATA-AREA TALLYING PERIOD-COUNT      DEC\n190600                         FOR ALL \".\"                              DEC\n190700                     IF PERIOD-COUNT > ZERO                       DEC\n190800                         MOVE \"N\" TO USE-STATEMENT-SW.            DEC\n190900*                                                                 DEC\n191000 6210-SEARCH-FOR-USE-VERB.                                        DEC\n191100*                                                                 DEC\n191200     IF SOURCE-WORD (SOURCE-WORD-INDEX) = \"USE\"                   DEC\n191300         MOVE \"Y\" TO USE-STATEMENT-SW.                            DEC\n191400*                                                                 DEC\n191500 7000-PRINT-PROGRAM-SUMMARY.\n191600*\n191700     MOVE 99 TO LINE-COUNT.\n191800     IF    TABLE-OVERFLOW\n191900        OR CALL-OVERFLOW\n192000        OR LEVEL-OVERFLOW\n192100         PERFORM 7100-PRINT-ERROR-MESSAGES.\n192200     IF PRINT-UNCALLED-MODULES\n192300         PERFORM 7200-PRINT-UNCALLED-MODULES.\n192400     IF PRINT-CALLED-SUBPROGRAMS\n192500         PERFORM 7300-PRINT-CALLED-SUBPROGRAMS.\n192600     PERFORM 7400-PRINT-PROGRAM-STATISTICS.\n192700*\n192800 7100-PRINT-ERROR-MESSAGES.\n192900*\n193000     MOVE ERROR-MESSAGES-HEADING TO SHL-HEADING.\n193100     MOVE SUMMARY-HEADING-LINE TO PRINT-LINE.\n193200     MOVE 2 TO SPACE-CONTROL.\n193300     PERFORM 1180-PRINT-REPORT-LINE.\n193400     MOVE 2 TO SPACE-CONTROL.\n193500     IF TABLE-OVERFLOW\n193600         MOVE TABLE-OVERFLOW-MESSAGE-2 TO PRINT-LINE\n193700         PERFORM 1180-PRINT-REPORT-LINE.\n193800     IF CALL-OVERFLOW\n193900         MOVE CALL-OVERFLOW-MESSAGE TO PRINT-LINE\n194000         PERFORM 1180-PRINT-REPORT-LINE.\n194100     IF LEVEL-OVERFLOW\n194200         MOVE LEVEL-OVERFLOW-MESSAGE TO PRINT-LINE\n194300         PERFORM 1180-PRINT-REPORT-LINE.\n194400*\n194500 7200-PRINT-UNCALLED-MODULES.\n194600*\n194700     MOVE UNCALLED-MODULES-HEADING TO SHL-HEADING.\n194800     MOVE SUMMARY-HEADING-LINE TO PRINT-LINE.\n194900     MOVE 2 TO SPACE-CONTROL.\n195000     PERFORM 1180-PRINT-REPORT-LINE.\n195100     MOVE 2 TO SPACE-CONTROL.\n195200     PERFORM 7210-PRINT-UNCALLED-MODULE\n195300         VARYING MODULE-INDEX FROM 1 BY 1\n195400         UNTIL MODULE-INDEX > MODULE-COUNT.\n195500*\n195600 7210-PRINT-UNCALLED-MODULE.\n195700*\n195800     IF TIMES-CALLED (MODULE-INDEX) = ZERO\n195900         MOVE MODULE-NAME (MODULE-INDEX) TO ML-MODULE-NAME\n196000         PERFORM 1180-PRINT-REPORT-LINE.\n196100*\n196200 7300-PRINT-CALLED-SUBPROGRAMS.\n196300*\n196400     MOVE CALLED-SUBPROGRAMS-HEADING TO SHL-HEADING.\n196500     MOVE SUMMARY-HEADING-LINE TO PRINT-LINE.\n196600     MOVE 2 TO SPACE-CONTROL.\n196700     PERFORM 1180-PRINT-REPORT-LINE.\n196800     MOVE 2 TO SPACE-CONTROL.\n196900     PERFORM 7310-PRINT-CALLED-SUBPROGRAM\n197000         VARYING MODULE-INDEX FROM 1 BY 1\n197100         UNTIL MODULE-INDEX > MODULE-COUNT.\n197200*\n197300 7310-PRINT-CALLED-SUBPROGRAM.\n197400*\n197500     IF SUBPROGRAM (MODULE-INDEX)\n197600         MOVE MODULE-NAME (MODULE-INDEX) TO ML-MODULE-NAME\n197700         PERFORM 1180-PRINT-REPORT-LINE.\n197800*\n197900 7400-PRINT-PROGRAM-STATISTICS.\n198000*\n198100     MOVE PROGRAM-STATISTICS-HEADING TO SHL-HEADING.\n198200     MOVE SUMMARY-HEADING-LINE              TO PRINT-LINE.\n198300     MOVE 2                                 TO SPACE-CONTROL.\n198400     PERFORM 1180-PRINT-REPORT-LINE.\n198500     MOVE \"TOTAL LINES IN PROGRAM:\"         TO SL-DESCRIPTION.\n198600     MOVE TOTAL-LINE-COUNT                  TO SL-COUNT.\n198700     MOVE 2                                 TO SPACE-CONTROL.\n198800     PERFORM 1180-PRINT-REPORT-LINE.\n198900     MOVE \"TOTAL LINES MINUS COMMENTS:\"     TO SL-DESCRIPTION.\n199000     MOVE SOURCE-LINE-COUNT                 TO SL-COUNT.\n199100     MOVE 1                                 TO SPACE-CONTROL.\n199200     PERFORM 1180-PRINT-REPORT-LINE.\n199300     MOVE \"PD LINES MINUS COMMENTS:\"        TO SL-DESCRIPTION.\n199400     MOVE PD-LINE-COUNT                     TO SL-COUNT.\n199500     PERFORM 1180-PRINT-REPORT-LINE.\n199600*\n199700     MOVE \"NUMBER OF COBOL SECTIONS:\"       TO SL-DESCRIPTION.\n199800     MOVE COBOL-SECTION-COUNT               TO SL-COUNT.\n199900     MOVE 2                                 TO SPACE-CONTROL.\n200000     PERFORM 1180-PRINT-REPORT-LINE.\n200100     MOVE \"NUMBER OF COBOL PARAGRAPHS:\"     TO SL-DESCRIPTION.\n200200     MOVE COBOL-PARAGRAPH-COUNT             TO SL-COUNT.\n200300     PERFORM 1180-PRINT-REPORT-LINE.\n200400     MOVE \"NUMBER OF SUBPROGRAMS USED:\"     TO SL-DESCRIPTION.\n200500     MOVE SUBPROGRAM-COUNT                  TO SL-COUNT.\n200600     PERFORM 1180-PRINT-REPORT-LINE.\n200700     MOVE \"AVG. LINES PER COBOL MODULE:\"    TO SL-DESCRIPTION.\n200800     IF COBOL-MODULE-COUNT NOT = ZERO\n200900         DIVIDE PD-LINE-COUNT BY COBOL-MODULE-COUNT\n201000             GIVING SL-COUNT ROUNDED\n201100     ELSE\n201200         MOVE PD-LINE-COUNT                 TO SL-COUNT.\n201300     PERFORM 1180-PRINT-REPORT-LINE.\n201400*\n201500     MOVE \"NUMBER OF PERFORM STATEMENTS:\"   TO SL-DESCRIPTION.\n201600     MOVE PERFORM-COUNT                     TO SL-COUNT.\n201700     MOVE 2                                 TO SPACE-CONTROL.\n201800     PERFORM 1180-PRINT-REPORT-LINE.\n201900     MOVE \"NUMBER OF INLINE PERFORMS:\"      TO SL-DESCRIPTION.\n202000     MOVE INLINE-PERFORM-COUNT              TO SL-COUNT.\n202100     PERFORM 1180-PRINT-REPORT-LINE.\n202200     MOVE \"NUMBER OF CALL STATEMENTS:\"      TO SL-DESCRIPTION.\n202300     MOVE CALL-COUNT                        TO SL-COUNT.\n202400     PERFORM 1180-PRINT-REPORT-LINE.\n202500     MOVE \"NUMBER OF SORT STATEMENTS:\"      TO SL-DESCRIPTION.\n202600     MOVE SORT-COUNT                        TO SL-COUNT.\n202700     PERFORM 1180-PRINT-REPORT-LINE.\n202800     MOVE \"NUMBER OF MERGE STATEMENTS:\"     TO SL-DESCRIPTION.\n202900     MOVE MERGE-COUNT                       TO SL-COUNT.\n203000     PERFORM 1180-PRINT-REPORT-LINE.\n203100     MOVE \"NO. OF SORT/MERGE PROCEDURES:\"   TO SL-DESCRIPTION.\n203200     MOVE SORT-MERGE-PROCEDURE-COUNT        TO SL-COUNT.\n203300     PERFORM 1180-PRINT-REPORT-LINE.\n203400     MOVE \"NUMBER OF GO TO STATEMENTS:\"     TO SL-DESCRIPTION.\n203500     MOVE GOTO-COUNT                        TO SL-COUNT.\n203600     PERFORM 1180-PRINT-REPORT-LINE.\n./ ADD NAME=PAYMNTC  0120-01289-01302-1139-02601-00092-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.                                         @\n000200 PROGRAM-ID.    PAYMNTC.                                          @\n000300 AUTHOR. DICK THORNTON.                                           @\n000400***************************************************************** @\n000500*REMARKS. PAYMAINT CREATES AND MAINTAINS THE VSAM PAYROLL MASTER* @\n000600*         FILE USING TRANSACTION RECORDS.                       * @\n000700*      THE INCOMING PAYROLL FILE TRANSACTION FILE IS APPLIED TO * @\n000800*      THE CURRENT VSAM PAYROLL MASTER FILE. WHEN ALL           * @\n000900*      TRANSACTIONS HAVE BEEN PROCESSED, JOB TOTALS ARE PRINTED.* @\n001000*      FOR EACH TRANSACTION RECORD READ, THE FOLLOWING          * @\n001100*      PROCESSING IS DONE:                                      * @\n001200*        1. IDENTIFY THE TRANSACTION TYPE AS ADD, CHANGE, OR    * @\n001300*           DELETE.                                             * @\n001400*        2. EDIT AND VALIDATE ALL FIELDS FOR CORRECT DATA TYPE  * @\n001500*           AND CONTENT.                                        * @\n001600*        3. VERIFY THAT UPDATES AND DELETES REFER TO EXISTING   * @\n001700*           MASTER FILE RECORDS, AND THAT ADDED RECORDS DO NOT  * @\n001800*           PRESENTLY EXIST.                                    * @\n001900*        4. PRINT AN ERROR REPORT SHOWING ALL ERRORS FOUND.     * @\n002000*        5. FOR DELETES, WHERE THE CURRENT MASTER FILE RECORD   * @\n002100*           IS MARKED \"ACTIVE\", SET THE RECORD STATUS BYTE TO   * @\n002200*           'D' AND REWRITE THE RECORD. WHEN THE CURRENT MASTER * @\n002300*           FILE RECORD IS MARKED DELETED, ISSUE A DELETE FOR   * @\n002400*           THE RECORD. PRINT RESULTS OF THE DELETION TO THE    * @\n002500*           TRANSACTION REPORT.                                 * @\n002600*        6. FOR UPDATES, REPLACE THE DATA IN THE CORRESPONDING  * @\n002700*           FIELDS OF THE MASTER FILE RECORD AND REWRITE THE    * @\n002800*           RECORD. BLANK FIELDS IN TRANSACTION RECORDS ARE     * @\n002900*           IGNORED.SHOW THE CONTENT OF CHANGED FIELDS ON THE   * @\n003000*           TRANSACTION REPORT, GIVING BOTH BEFORE AND AFTER    * @\n003100*           FIELD VALUES. WHEN A NON-NUMERIC FIELD IN A TRANS-  * @\n003200*           ACTION RECORD CONTAINS ALL '#', THE CURRENT VALUE   * @\n003300*           THE PAYROLL MASTER FILE RECORD WILL BE ERASED TO    * @\n003400*           BLANKS. THIS DOES NOT APPLY TO LAST NAME, FIRST NAME* @\n003500*           ADDRESS LINE 1, CITY, STATE, ZIP-5, EMPLOYEE TYPE,  * @\n003600*           JOB TITLE, DEPARTMENT, LOCATION, AND COST CENTER.   * @\n003700*        7. SOCIAL SECURITY NUMBER CANNOT BE CHANGED. TO DO THIS* @\n003800*           REQUIRES THE CURRENT RECORD BE DELETED, AND A NEW   * @\n003900*           RECORD ADDED WITH THE CORRECT SOCIAL SECURITY NUMBER* @\n004000*        8. FOR ADDS, BUILD A NEW MASTER FILE RECORD AND WRITE  * @\n004100*           IT TO THE VSAM MASTER FILE. PRINT THE NEW RECORD    * @\n004200*           DATA ON THE TRANSACTION REPORT. NOTE THAT ADD       * @\n004300*           TRANSACTIONS REQUIRE 5 TRANSACTION RECORDS, WHICH   * @\n004400*           MUST BE IN ORDER IN THE TRANSACTION FILE: A1, A2,   * @\n004500*           A3, A4, A5. IF ANY OF THE ADD TRANSACTION RECORDS   * @\n004600*           ARE MISSING OR OUT OF ORDER THE NEW RECORD WILL NOT * @\n004700*           BE WRITTEN TO THE MASTER FILE.                      * @\n004800*        8. TO PROVIDE FOR A VERIFICATION RUN IN WHICH NO UPDATE* @\n004900*           IS MADE TO THE MASTER FILE, A PARM FIELD IS REQUIRED* @\n005000*           ON THE JCL EXEC STATEMENT. WHEN PARM=VERIFY, ALL    * @\n005100*           FUNCTIONS ARE PERFORMED EXCEPT ACTUAL CHANGES TO THE* @\n005200*           PAYROLL MASTER FILE. WHEN PARM=UPDATE, ALL FUNCTIONS* @\n005300*           INCLUDING MASTER FILE CHANGES ARE DONE.             * @\n005400*           NOTE: DURING A PARM=VERIFY RUN, CHANGES CANNOT BE   * @\n005500*           SPECIFIED FOR A NEW MASTER FILE RECORD ADDED IN THIS* @\n005600*           RUN, SINCE THE RECORD WILL NOT EXIST.               * @\n005700***************************************************************** @\n005800 ENVIRONMENT DIVISION.                                            @\n005900 CONFIGURATION SECTION.                                           @\n006000 SPECIAL-NAMES.                                                   @\n006100     C01 IS TOP-OF-PAGE                                           @\n006200     CLASS ADDRESS-CHARACTERS IS 'A' THRU 'I', 'J' THRU 'R',      @\n006300                          'S' THRU 'Z', ' ', '-', '/', '.',       @\n006400                          '#', '%', '&', ':', '''', ','           @\n006500     CLASS NAME-CHARACTERS IS 'A' THRU 'I', 'J' THRU 'R',         @\n006600                          'S' THRU 'Z', ' ', '-'                  @\n006700     CLASS ALPHANUMERIC-DATA IS 'A' THRU 'I', 'J' THRU 'R',       @\n006800                          'S' THRU 'Z', ' ', '-', '0' THRU '9'.   @\n006900 INPUT-OUTPUT SECTION.                                            @\n007000 FILE-CONTROL.                                                    @\n007100     SELECT TRANSACTION-FILE ASSIGN TO TRANFILE.                  @\n007200     SELECT ERROR-REPORT ASSIGN TO ERRORS.                        @\n007300     SELECT TRANSACTION-REPORT ASSIGN TO TRANSRPT.                @\n007400     SELECT PAYROLL-MASTER-FILE ASSIGN TO PAYMASTR                @\n007500            ORGANIZATION IS INDEXED                               @\n007600            ACCESS IS DYNAMIC                                     @\n007700            RECORD KEY IS PR-SOCIAL-SECURITY-NBR                  @\n007800            STATUS IS WS-VSAM-FILE-STATUS.                        @\n007900 DATA DIVISION.                                                   @\n008000 FILE SECTION.                                                    @\n008100 FD  PAYROLL-MASTER-FILE                                          @\n008200     RECORD CONTAINS 564 CHARACTERS.                              @\n008300     COPY PAYRECRF.                                               @\n008400                                                                  @\n008500 FD  TRANSACTION-FILE                                             @\n008600     BLOCK CONTAINS 0 RECORDS                                     @\n008700     RECORD CONTAINS 80 CHARACTERS                                @\n008800     RECORDING MODE IS F                                          @\n008900     LABEL RECORDS ARE STANDARD.                                  @\n009000 01  TRANSACTION-RECORD.                                          @     10\n009100     05  TR-TYPE                    PIC X.                        @     20\n009200         88  TR-ADD                   VALUE 'A'.                  @     30\n009300         88  TR-CHANGE                VALUE 'C'.                  @     40\n009400         88  TR-DELETE                VALUE 'D'.                  @     40\n009500     05  TR-ADD-SEQ-NBR             PIC X.                        @\n009600     05  TR-SOCIAL-SECURITY-NBR     PIC X(9).                     @\n009700     05  FILLER                     PIC X(61).                    @\n009800     05  TR-SEQUENCE-NUMBER         PIC X(8).                     @\n009900 01  TRANSACTION-DELETE-RECORD.                                   @\n010000     05  TR-DEL-TYPE                PIC X.                        @\n010100         88  TR-DEL-DELETE            VALUE 'D'.                  @     30\n010200     05  FILLER                     PIC X.                        @\n010300     05  TR-DEL-SOCIAL-SECURITY-NBR PIC X(9).                     @\n010400     05  FILLER                     PIC X(69).                    @\n010500 01  TRANSACTION-ADD-CHANGE1.                                     @\n010600     05  TR-AC1-TYPE                PIC XX.                       @     20\n010700         88  TR-ADD1                  VALUE 'A1'.                 @     30\n010800         88  TR-CHANGE1               VALUE 'C1'.                 @     30\n010900     05  TR-AC1-SOCIAL-SECURITY-NBR PIC X(9).                     @\n011000     05  TR-AC1-LAST-NAME           PIC X(12).                    @\n011100     05  TR-AC1-FIRST-NAME          PIC X(12).                    @\n011200     05  TR-AC1-INITIAL             PIC X.                        @\n011300     05  TR-AC1-NAME-SUFFIX         PIC XXX.                      @\n011400     05  TR-AC1-ADDRESS-LINE-1      PIC X(25).                    @\n011500     05  FILLER                     PIC X(16).                    @\n011600 01  TRANSACTION-ADD-CHANGE2.                                     @\n011700     05  TR-AC2-TYPE                PIC XX.                       @     20\n011800         88  TR-ADD2                  VALUE 'A2'.                 @     30\n011900         88  TR-CHANGE2               VALUE 'C2'.                 @     30\n012000     05  TR-AC2-SOCIAL-SECURITY-NBR PIC X(9).                     @\n012100     05  TR-AC2-ADDRESS-LINE2       PIC X(25).                    @\n012200     05  TR-AC2-CITY                PIC X(24).                    @\n012300     05  TR-AC2-STATE               PIC X(2).                     @\n012400     05  TR-AC2-ZIP-5               PIC X(5).                     @\n012500     05  TR-AC2-ZIP-LAST-4          PIC X(4).                     @\n012600     05  FILLER                     PIC X(9).                     @\n012700 01  TRANSACTION-ADD-CHANGE3.                                     @\n012800     05  TR-AC3-TYPE                PIC XX.                       @     20\n012900         88  TR-ADD3                  VALUE 'A3'.                 @     30\n013000         88  TR-CHANGE3               VALUE 'C3'.                 @     30\n013100     05  TR-AC3-SOCIAL-SECURITY-NBR PIC X(9).                     @\n013200     05  TR-AC3-EMPLOYEE-TYPE       PIC X.                        @\n013300     05  TR-AC3-JOB-TITLE           PIC X(35).                    @\n013400     05  TR-AC3-DEPARTMENT          PIC X(20).                    @\n013500     05  TR-AC3-COST-CENTER         PIC XX.                       @\n013600     05  FILLER                     PIC X(11).                    @\n013700 01  TRANSACTION-ADD-CHANGE4.                                     @\n013800     05  TR-AC4-TYPE                PIC XX.                       @     20\n013900         88  TR-ADD4                  VALUE 'A4'.                 @     30\n014000         88  TR-CHANGE4               VALUE 'C4'.                 @     30\n014100     05  TR-AC4-SOCIAL-SECURITY-NBR PIC X(9).                     @\n014200     05  TR-AC4-LOCATION            PIC X(20).                    @\n014300     05  TR-AC4-SEMI-MTHLY-SALARY-9 PIC S9(7)V99.                 @\n014400     05  TR-AC4-SEMI-MTHLY-SALARY-X REDEFINES                     @\n014500         TR-AC4-SEMI-MTHLY-SALARY-9 PIC X(9).                     @\n014600     05  FILLER REDEFINES TR-AC4-SEMI-MTHLY-SALARY-X.             @\n014700         10  TR-AC4-BLANKS          PIC X(4).                     @\n014800         10  TR-AC4-HOURLY-RATE-9   PIC S9(3)V99.                 @\n014900         10  TR-AC4-HOURLY-RATE-X   REDEFINES                     @\n015000             TR-AC4-HOURLY-RATE-9   PIC X(5).                     @\n015100     05  TR-AC4-STATE-EXEMPTION-9   PIC S99.                      @\n015200     05  TR-AC4-STATE-EXEMPTION-X   REDEFINES                     @\n015300         TR-AC4-STATE-EXEMPTION-9   PIC XX.                       @\n015400     05  TR-AC4-FED-EXEMPTION-9     PIC S99.                      @\n015500     05  TR-AC4-FED-EXEMPTION-X     REDEFINES                     @\n015600         TR-AC4-FED-EXEMPTION-9     PIC XX.                       @\n015700     05  TR-AC4-FILING-STATUS       PIC X.                        @\n015800         88  TR-AC4-VALID-FILING-STATUS VALUES ARE                @\n015900                                    'U', 'H', 'J', 'S'.           @\n016000     05  TR-AC4-HEALTH-INSURANCE-9  PIC S9(3)V99.                 @\n016100     05  TR-AC4-HEALTH-INSURANCE-X  REDEFINES                     @\n016200         TR-AC4-HEALTH-INSURANCE-9  PIC X(5).                     @\n016300     05  TR-AC4-DENTAL-INSURANCE-9  PIC S9(3)V99.                 @\n016400     05  TR-AC4-DENTAL-INSURANCE-X  REDEFINES                     @\n016500         TR-AC4-DENTAL-INSURANCE-9  PIC X(5).                     @\n016600     05  TR-AC4-THRIFT-PLAN-PCT-9   PIC S99V9.                    @\n016700     05  TR-AC4-THRIFT-PLAN-PCT-X   REDEFINES                     @\n016800         TR-AC4-THRIFT-PLAN-PCT-9   PIC X(3).                     @\n016900     05  TR-AC4-HEALTH-CARE-FLEX-9  PIC S9(5)V99.                 @\n017000     05  TR-AC4-HEALTH-CARE-FLEX-X  REDEFINES                     @\n017100         TR-AC4-HEALTH-CARE-FLEX-9  PIC X(7).                     @\n017200     05  TR-AC4-CHILD-CARE-FLEX-9   PIC S9(5)V99.                 @\n017300     05  TR-AC4-CHILD-CARE-FLEX-X   REDEFINES                     @\n017400         TR-AC4-CHILD-CARE-FLEX-9   PIC X(7).                     @\n017500     05  FILLER                     PIC X(8).                     @\n017600 01  TRANSACTION-ADD-CHANGE5.                                     @\n017700     05  TR-AC5-TYPE                PIC XX.                       @     20\n017800         88  TR-ADD5                  VALUE 'A5'.                 @     30\n017900         88  TR-CHANGE5               VALUE 'C5'.                 @     30\n018000     05  TR-AC5-SOCIAL-SECURITY-NBR PIC X(9).                     @\n018100     05  TR-AC5-CREDIT-UNION-9      PIC S9(7)V99.                 @\n018200     05  TR-AC5-CREDIT-UNION-X      REDEFINES                     @\n018300         TR-AC5-CREDIT-UNION-9      PIC X(9).                     @\n018400     05  TR-AC5-UGF-9               PIC S9(5)V99.                 @\n018500     05  TR-AC5-UGF-X               REDEFINES                     @\n018600         TR-AC5-UGF-9               PIC X(7).                     @\n018700     05  TR-AC5-CHILDREN-INSURANC-9 PIC S9(3)V99.                 @\n018800     05  TR-AC5-CHILDREN-INSURANC-X REDEFINES                     @\n018900         TR-AC5-CHILDREN-INSURANC-9 PIC X(5).                     @\n019000     05  TR-AC5-SPOUSE-INSURANCE-9  PIC S9(3)V99.                 @\n019100     05  TR-AC5-SPOUSE-INSURANCE-X  REDEFINES                     @\n019200         TR-AC5-SPOUSE-INSURANCE-9  PIC X(5).                     @\n019300     05  TR-AC5-SUPPLEMENTAL-LIFE-9 PIC S9(3)V99.                 @\n019400     05  TR-AC5-SUPPLEMENTAL-LIFE-X REDEFINES                     @\n019500         TR-AC5-SUPPLEMENTAL-LIFE-9 PIC X(5).                     @\n019600     05  TR-AC5-LONG-TERM-DISBLTY-9 PIC S9(3)V99.                 @\n019700     05  TR-AC5-LONG-TERM-DISBLTY-X REDEFINES                     @\n019800         TR-AC5-LONG-TERM-DISBLTY-9 PIC X(5).                     @\n019900     05  TR-AC5-EMPLOYEE-ASSOC-9    PIC S9V99.                    @\n020000     05  TR-AC5-EMPLOYEE-ASSOC-X    REDEFINES                     @\n020100         TR-AC5-EMPLOYEE-ASSOC-9    PIC X(3).                     @\n020200     05  TR-AC5-TAX-IMPUTED-INC-9   PIC S9(5)V99.                 @\n020300     05  TR-AC5-TAX-IMPUTED-INC-X   REDEFINES                     @\n020400         TR-AC5-TAX-IMPUTED-INC-9   PIC X(7).                     @\n020500     05  TR-AC5-NONEL-PTO-ALLOT-9   PIC S99V99.                   @\n020600     05  TR-AC5-NONEL-PTO-ALLOT-X   REDEFINES                     @\n020700         TR-AC5-NONEL-PTO-ALLOT-9   PIC X(4).                     @\n020800     05  TR-AC5-EL-PTO-ALLOT-9      PIC S99V99.                   @\n020900     05  TR-AC5-EL-PTO-ALLOT-X      REDEFINES                     @\n021000         TR-AC5-EL-PTO-ALLOT-9      PIC X(4).                     @\n021100     05  FILLER                     PIC X(15).                    @\n021200 01  TRANSACTION-CHANGE6.                                         @\n021300     05  TR-CHG6-TYPE               PIC XX.                       @     20\n021400         88  TR-CHANGE6               VALUE 'C6'.                 @     30\n021500     05  TR-CHG6-SOCIAL-SECURITY-NBR PIC X(9).                    @\n021600     05  TR-CHG6-NONEL-PTO-CARRY-9  PIC S99V99.                   @\n021700     05  TR-CHG6-NONEL-PTO-CARRY-X  REDEFINES                     @\n021800         TR-CHG6-NONEL-PTO-CARRY-9  PIC X(4).                     @\n021900     05  TR-CHG6-NONEL-PTO-TAKEN-9  PIC S99V99.                   @\n022000     05  TR-CHG6-NONEL-PTO-TAKEN-X  REDEFINES                     @\n022100         TR-CHG6-NONEL-PTO-TAKEN-9  PIC X(4).                     @\n022200     05  TR-CHG6-ELECT-PTO-BOUGHT-9 PIC S99V99.                   @\n022300     05  TR-CHG6-ELECT-PTO-BOUGHT-X REDEFINES                     @\n022400         TR-CHG6-ELECT-PTO-BOUGHT-9 PIC X(4).                     @\n022500     05  TR-CHG6-ELECT-PTO-SOLD-9   PIC S99V99.                   @\n022600     05  TR-CHG6-ELECT-PTO-SOLD-X   REDEFINES                     @\n022700         TR-CHG6-ELECT-PTO-SOLD-9   PIC X(4).                     @\n022800     05  TR-CHG6-ELECT-PTO-TAKEN-9  PIC S99V99.                   @\n022900     05  TR-CHG6-ELECT-PTO-TAKEN-X  REDEFINES                     @\n023000         TR-CHG6-ELECT-PTO-TAKEN-9  PIC X(4).                     @\n023100     05  TR-CHG6-CUR-REGULAR-EARN-9 PIC S9(7)V99.                 @\n023200     05  TR-CHG6-CUR-REGULAR-EARN-X REDEFINES                     @\n023300         TR-CHG6-CUR-REGULAR-EARN-9 PIC X(9).                     @\n023400     05  TR-CHG6-CUR-HOLIDAY-EARN-9 PIC S9(5)V99.                 @\n023500     05  TR-CHG6-CUR-HOLIDAY-EARN-X REDEFINES                     @\n023600         TR-CHG6-CUR-HOLIDAY-EARN-9 PIC X(7).                     @\n023700     05  TR-CHG6-CUR-PTO-EARNINGS-9 PIC S9(5)V99.                 @\n023800     05  TR-CHG6-CUR-PTO-EARNINGS-X REDEFINES                     @\n023900         TR-CHG6-CUR-PTO-EARNINGS-9 PIC X(7).                     @\n024000     05  TR-CHG6-CUR-FLEX-DOLLARS-9 PIC S9(5)V99.                 @\n024100     05  TR-CHG6-CUR-FLEX-DOLLARS-X REDEFINES                     @\n024200         TR-CHG6-CUR-FLEX-DOLLARS-9 PIC X(7).                     @\n024300     05  TR-CHG6-CUR-HEALTHY-RTRN-9 PIC S9(5)V99.                 @\n024400     05  TR-CHG6-CUR-HEALTHY-RTRN-X REDEFINES                     @\n024500         TR-CHG6-CUR-HEALTHY-RTRN-9 PIC X(7).                     @\n024600     05  FILLER                     PIC X(12).                    @\n024700 01  TRANSACTION-CHANGE7.                                         @\n024800     05  TR-CHG7-TYPE               PIC XX.                       @     20\n024900         88  TR-CHANGE7               VALUE 'C7'.                 @     30\n025000     05  TR-CHG7-SOCIAL-SECURITY-NBR PIC X(9).                    @\n025100     05  TR-CHG7-CUR-MEDICAL-WAIV-9 PIC S9(5)V99.                 @\n025200     05  TR-CHG7-CUR-MEDICAL-WAIV-X REDEFINES                     @\n025300         TR-CHG7-CUR-MEDICAL-WAIV-9 PIC X(7).                     @\n025400     05  TR-CHG7-CUR-BONUS-9        PIC S9(5)V99.                 @\n025500     05  TR-CHG7-CUR-BONUS-X        REDEFINES                     @\n025600         TR-CHG7-CUR-BONUS-9        PIC X(7).                     @\n025700     05  TR-CHG7-CUR-UGF-BONUS-9    PIC S9(5)V99.                 @\n025800     05  TR-CHG7-CUR-UGF-BONUS-X    REDEFINES                     @\n025900         TR-CHG7-CUR-UGF-BONUS-9    PIC X(7).                     @\n026000     05  TR-CHG7-CUR-FLOAT-HOL-9    PIC S9(5)V99.                 @\n026100     05  TR-CHG7-CUR-FLOAT-HOL-X    REDEFINES                     @\n026200         TR-CHG7-CUR-FLOAT-HOL-9    PIC X(7).                     @\n026300     05  TR-CHG7-YTD-REG-EARN-9     PIC S9(7)V99.                 @\n026400     05  TR-CHG7-YTD-REG-EARN-X     REDEFINES                     @\n026500         TR-CHG7-YTD-REG-EARN-9     PIC X(9).                     @\n026600     05  TR-CHG7-YTD-HOL-EARN-9     PIC S9(5)V99.                 @\n026700     05  TR-CHG7-YTD-HOL-EARN-X     REDEFINES                     @\n026800         TR-CHG7-YTD-HOL-EARN-9     PIC X(7).                     @\n026900     05  TR-CHG7-YTD-PTO-EARNINGS-9 PIC S9(5)V99.                 @\n027000     05  TR-CHG7-YTD-PTO-EARNINGS-X REDEFINES                     @\n027100         TR-CHG7-YTD-PTO-EARNINGS-9 PIC X(7).                     @\n027200     05  TR-CHG7-YTD-FLEX-DOLLARS-9 PIC S9(5)V99.                 @\n027300     05  TR-CHG7-YTD-FLEX-DOLLARS-X REDEFINES                     @\n027400         TR-CHG7-YTD-FLEX-DOLLARS-9 PIC X(7).                     @\n027500     05  FILLER                     PIC X(11).                    @\n027600 01  TRANSACTION-CHANGE8.                                         @\n027700     05  TR-CHG8-TYPE               PIC XX.                       @     20\n027800         88  TR-CHANGE8               VALUE 'C8'.                 @     30\n027900     05  TR-CHG8-SOCIAL-SECURITY-NBR PIC X(9).                    @\n028000     05  TR-CHG8-YTD-HEALTHY-RETRN-9 PIC S9(5)V99.                @\n028100     05  TR-CHG8-YTD-HEALTHY-RETRN-X REDEFINES                    @\n028200         TR-CHG8-YTD-HEALTHY-RETRN-9 PIC X(7).                    @\n028300     05  TR-CHG8-YTD-MEDICAL-WAIV-9 PIC S9(5)V99.                 @\n028400     05  TR-CHG8-YTD-MEDICAL-WAIV-X REDEFINES                     @\n028500         TR-CHG8-YTD-MEDICAL-WAIV-9 PIC X(7).                     @\n028600     05  TR-CHG8-YTD-BONUS-9        PIC S9(5)V99.                 @\n028700     05  TR-CHG8-YTD-BONUS-X        REDEFINES                     @\n028800         TR-CHG8-YTD-BONUS-9        PIC X(7).                     @\n028900     05  TR-CHG8-YTD-UGF-BONUS-9    PIC S9(5)V99.                 @\n029000     05  TR-CHG8-YTD-UGF-BONUS-X    REDEFINES                     @\n029100         TR-CHG8-YTD-UGF-BONUS-9    PIC X(7).                     @\n029200     05  TR-CHG8-YTD-FLOAT-HOL-9   PIC S9(5)V99.                  @\n029300     05  TR-CHG8-YTD-FLOAT-HOL-X   REDEFINES                      @\n029400         TR-CHG8-YTD-FLOAT-HOL-9   PIC X(7).                      @\n029500     05  TR-CHG8-CUR-FED-TAX-9      PIC S9(7)V99.                 @\n029600     05  TR-CHG8-CUR-FED-TAX-X      REDEFINES                     @\n029700         TR-CHG8-CUR-FED-TAX-9      PIC X(9).                     @\n029800     05  TR-CHG8-CUR-FICA-MHI-9     PIC S9(5)V99.                 @\n029900     05  TR-CHG8-CUR-FICA-MHI-X     REDEFINES                     @\n030000         TR-CHG8-CUR-FICA-MHI-9     PIC X(7).                     @\n030100     05  TR-CHG8-CUR-OASDI-9        PIC S9(5)V99.                 @\n030200     05  TR-CHG8-CUR-OASDI-X        REDEFINES                     @\n030300         TR-CHG8-CUR-OASDI-9        PIC X(7).                     @\n030400     05  FILLER                     PIC X(11).                    @\n030500 01  TRANSACTION-CHANGE9.                                         @\n030600     05  TR-CHG9-TYPE               PIC XX.                       @     20\n030700         88  TR-CHANGE9               VALUE 'C9'.                 @     30\n030800     05  TR-CHG9-SOCIAL-SECURITY-NBR PIC X(9).                    @\n030900     05  TR-CHG9-CUR-STATE-TAX-9    PIC S9(5)V99.                 @\n031000     05  TR-CHG9-CUR-STATE-TAX-X    REDEFINES                     @\n031100         TR-CHG9-CUR-STATE-TAX-9    PIC X(7).                     @\n031200     05  TR-CHG9-YTD-FED-TAX-9      PIC S9(7)V99.                 @\n031300     05  TR-CHG9-YTD-FED-TAX-X      REDEFINES                     @\n031400         TR-CHG9-YTD-FED-TAX-9      PIC X(9).                     @\n031500     05  TR-CHG9-YTD-FICA-MHI-9     PIC S9(5)V99.                 @\n031600     05  TR-CHG9-YTD-FICA-MHI-X     REDEFINES                     @\n031700         TR-CHG9-YTD-FICA-MHI-9     PIC X(7).                     @\n031800     05  TR-CHG9-YTD-OASDI-9        PIC S9(5)V99.                 @\n031900     05  TR-CHG9-YTD-OASDI-X        REDEFINES                     @\n032000         TR-CHG9-YTD-OASDI-9        PIC X(7).                     @\n032100     05  TR-CHG9-YTD-STATE-TAX-9    PIC S9(5)V99.                 @\n032200     05  TR-CHG9-YTD-STATE-TAX-X    REDEFINES                     @\n032300         TR-CHG9-YTD-STATE-TAX-9    PIC X(7).                     @\n032400     05  TR-CHG9-CUR-THRIFT-PLAN-9  PIC S9(5)V99.                 @\n032500     05  TR-CHG9-CUR-THRIFT-PLAN-X  REDEFINES                     @\n032600         TR-CHG9-CUR-THRIFT-PLAN-9  PIC X(7).                     @\n032700     05  TR-CHG9-CUR-MED-INS-9      PIC S9(5)V99.                 @\n032800     05  TR-CHG9-CUR-MED-INS-X      REDEFINES                     @\n032900         TR-CHG9-CUR-MED-INS-9      PIC X(7).                     @\n033000     05  TR-CHG9-CUR-DENTAL-INS-9   PIC S9(5)V99.                 @\n033100     05  TR-CHG9-CUR-DENTAL-INS-X   REDEFINES                     @\n033200         TR-CHG9-CUR-DENTAL-INS-9   PIC X(7).                     @\n033300     05  FILLER                     PIC X(11).                    @\n033400 01  TRANSACTION-CHANGEA.                                         @\n033500     05  TR-CHGA-TYPE               PIC XX.                       @     20\n033600         88  TR-CHANGEA               VALUE 'CA'.                 @     30\n033700     05  TR-CHGA-SOCIAL-SECURITY-NBR PIC X(9).                    @\n033800     05  TR-CHGA-CUR-HLTHCARE-FLX-9 PIC S9(5)V99.                 @\n033900     05  TR-CHGA-CUR-HLTHCARE-FLX-X REDEFINES                     @\n034000         TR-CHGA-CUR-HLTHCARE-FLX-9 PIC X(7).                     @\n034100     05  TR-CHGA-CUR-CHILCARE-FLX-9 PIC S9(5)V99.                 @\n034200     05  TR-CHGA-CUR-CHILCARE-FLX-X REDEFINES                     @\n034300         TR-CHGA-CUR-CHILCARE-FLX-9 PIC X(7).                     @\n034400     05  TR-CHGA-YTD-THRIFT-PLAN-9  PIC S9(5)V99.                 @\n034500     05  TR-CHGA-YTD-THRIFT-PLAN-X  REDEFINES                     @\n034600         TR-CHGA-YTD-THRIFT-PLAN-9  PIC X(7).                     @\n034700     05  TR-CHGA-YTD-MEDICAL-INS-9  PIC S9(5)V99.                 @\n034800     05  TR-CHGA-YTD-MEDICAL-INS-X  REDEFINES                     @\n034900         TR-CHGA-YTD-MEDICAL-INS-9  PIC X(7).                     @\n035000     05  TR-CHGA-YTD-DENTAL-INS-9   PIC S9(5)V99.                 @\n035100     05  TR-CHGA-YTD-DENTAL-INS-X   REDEFINES                     @\n035200         TR-CHGA-YTD-DENTAL-INS-9   PIC X(7).                     @\n035300     05  TR-CHGA-YTD-HLTHCARE-FLX-9 PIC S9(5)V99.                 @\n035400     05  TR-CHGA-YTD-HLTHCARE-FLX-X REDEFINES                     @\n035500         TR-CHGA-YTD-HLTHCARE-FLX-9 PIC X(7).                     @\n035600     05  TR-CHGA-YTD-CHILCARE-FLX-9 PIC S9(5)V99.                 @\n035700     05  TR-CHGA-YTD-CHILCARE-FLX-X REDEFINES                     @\n035800         TR-CHGA-YTD-CHILCARE-FLX-9 PIC X(7).                     @\n035900     05  TR-CHGA-CUR-CREDIT-UNION-9 PIC S9(5)V99.                 @\n036000     05  TR-CHGA-CUR-CREDIT-UNION-X REDEFINES                     @\n036100         TR-CHGA-CUR-CREDIT-UNION-9 PIC X(7).                     @\n036200     05  FILLER                     PIC X(13).                    @\n036300 01  TRANSACTION-CHANGEB.                                         @\n036400     05  TR-CHGB-TYPE               PIC XX.                       @     20\n036500         88  TR-CHANGEB               VALUE 'CB'.                 @     30\n036600     05  TR-CHGB-SOCIAL-SECURITY-NBR PIC X(9).                    @\n036700     05  TR-CHGB-CUR-UGF-9          PIC S9(5)V99.                 @\n036800     05  TR-CHGB-CUR-UGF-X          REDEFINES                     @\n036900         TR-CHGB-CUR-UGF-9          PIC X(7).                     @\n037000     05  TR-CHGB-CUR-CHILDREN-INS-9 PIC S9(5)V99.                 @\n037100     05  TR-CHGB-CUR-CHILDREN-INS-X REDEFINES                     @\n037200         TR-CHGB-CUR-CHILDREN-INS-9 PIC X(7).                     @\n037300     05  TR-CHGB-CUR-SPOUSE-INS-9   PIC S9(5)V99.                 @\n037400     05  TR-CHGB-CUR-SPOUSE-INS-X   REDEFINES                     @\n037500         TR-CHGB-CUR-SPOUSE-INS-9   PIC X(7).                     @\n037600     05  TR-CHGB-CUR-LTD-INS-9      PIC S9(5)V99.                 @\n037700     05  TR-CHGB-CUR-LTD-INS-X      REDEFINES                     @\n037800         TR-CHGB-CUR-LTD-INS-9      PIC X(7).                     @\n037900     05  TR-CHGB-CUR-EMPL-ASSOC-9   PIC S9(5)V99.                 @\n038000     05  TR-CHGB-CUR-EMPL-ASSOC-X   REDEFINES                     @\n038100         TR-CHGB-CUR-EMPL-ASSOC-9   PIC X(7).                     @\n038200     05  TR-CHGB-YTD-CREDIT-UNION-9 PIC S9(5)V99.                 @\n038300     05  TR-CHGB-YTD-CREDIT-UNION-X REDEFINES                     @\n038400         TR-CHGB-YTD-CREDIT-UNION-9 PIC X(7).                     @\n038500     05  TR-CHGB-YTD-UGF-9          PIC S9(5)V99.                 @\n038600     05  TR-CHGB-YTD-UGF-X          REDEFINES                     @\n038700         TR-CHGB-YTD-UGF-9          PIC X(7).                     @\n038800     05  TR-CHGB-YTD-CHILDREN-INS-9 PIC S9(5)V99.                 @\n038900     05  TR-CHGB-YTD-CHILDREN-INS-X REDEFINES                     @\n039000         TR-CHGB-YTD-CHILDREN-INS-9 PIC X(7).                     @\n039100     05  FILLER                     PIC X(13).                    @\n039200 01  TRANSACTION-CHANGEC.                                         @\n039300     05  TR-CHGC-TYPE               PIC XX.                       @     20\n039400         88  TR-CHANGEC               VALUE 'CC'.                 @     30\n039500     05  TR-CHGC-SOCIAL-SECURITY-NBR PIC X(9).                    @\n039600     05  TR-CHGC-YTD-SPOUSE-INS-9   PIC S9(5)V99.                 @\n039700     05  TR-CHGC-YTD-SPOUSE-INS-X   REDEFINES                     @\n039800         TR-CHGC-YTD-SPOUSE-INS-9   PIC X(7).                     @\n039900     05  TR-CHGC-YTD-LTD-INSUR-9    PIC S9(5)V99.                 @\n040000     05  TR-CHGC-YTD-LTD-INSUR-X    REDEFINES                     @\n040100         TR-CHGC-YTD-LTD-INSUR-9    PIC X(7).                     @\n040200     05  TR-CHGC-YTD-EMPLOYEE-ASS-9  PIC S9(5)V99.                @\n040300     05  TR-CHGC-YTD-EMPLOYEE-ASS-X  REDEFINES                    @\n040400         TR-CHGC-YTD-EMPLOYEE-ASS-9  PIC X(7).                    @\n040500     05  TR-CHGC-CUR-NONEL-PTO-TKN-9 PIC S999V99.                 @\n040600     05  TR-CHGC-CUR-NONEL-PTO-TKN-X REDEFINES                    @\n040700         TR-CHGC-CUR-NONEL-PTO-TKN-9 PIC X(5).                    @\n040800     05  TR-CHGC-CUR-NONEL-PTO-BAL-9 PIC S999V99.                 @\n040900     05  TR-CHGC-CUR-NONEL-PTO-BAL-X REDEFINES                    @\n041000         TR-CHGC-CUR-NONEL-PTO-BAL-9 PIC X(5).                    @\n041100     05  TR-CHGC-CUR-EL-PTO-TKN-9   PIC S999V99.                  @\n041200     05  TR-CHGC-CUR-EL-PTO-TKN-X   REDEFINES                     @\n041300         TR-CHGC-CUR-EL-PTO-TKN-9   PIC X(5).                     @\n041400     05  TR-CHGC-CUR-EL-PTO-BOT-9   PIC S999V99.                  @\n041500     05  TR-CHGC-CUR-EL-PTO-BOT-X   REDEFINES                     @\n041600         TR-CHGC-CUR-EL-PTO-BOT-9   PIC X(5).                     @\n041700     05  TR-CHGC-CUR-EL-PTO-SOLD-9  PIC S999V99.                  @\n041800     05  TR-CHGC-CUR-EL-PTO-SOLD-X  REDEFINES                     @\n041900         TR-CHGC-CUR-EL-PTO-SOLD-9  PIC X(5).                     @\n042000     05  TR-CHGC-CUR-EL-PTO-TAKEN-9 PIC S999V99.                  @\n042100     05  TR-CHGC-CUR-EL-PTO-TAKEN-X REDEFINES                     @\n042200         TR-CHGC-CUR-EL-PTO-TAKEN-9 PIC X(5).                     @\n042300     05  TR-CHGC-CUR-EL-PTO-BAL-9   PIC S999V99.                  @\n042400     05  TR-CHGC-CUR-EL-PTO-BAL-X   REDEFINES                     @\n042500         TR-CHGC-CUR-EL-PTO-BAL-9   PIC X(5).                     @\n042600     05  FILLER                     PIC X(13).                    @\n042700 01  TRANSACTION-CHANGED.                                         @\n042800     05  TR-CHGD-TYPE               PIC XX.                       @     20\n042900         88  TR-CHANGED               VALUE 'CD'.                 @     30\n043000     05  TR-CHGD-SOCIAL-SECURITY-NBR PIC X(9).                    @\n043100     05  TR-CHGD-YTD-NONEL-PTO-TKN-9 PIC S999V99.                 @\n043200     05  TR-CHGD-YTD-NONEL-PTO-TKN-X REDEFINES                    @\n043300         TR-CHGD-YTD-NONEL-PTO-TKN-9 PIC X(5).                    @\n043400     05  TR-CHGD-YTD-NONEL-PTO-BAL-9 PIC S999V99.                 @\n043500     05  TR-CHGD-YTD-NONEL-PTO-BAL-X REDEFINES                    @\n043600         TR-CHGD-YTD-NONEL-PTO-BAL-9 PIC X(5).                    @\n044000     05  TR-CHGD-YTD-EL-PTO-BOT-9   PIC S999V99.                  @\n044100     05  TR-CHGD-YTD-EL-PTO-BOT-X   REDEFINES                     @\n044200         TR-CHGD-YTD-EL-PTO-BOT-9   PIC X(5).                     @\n044300     05  TR-CHGD-YTD-EL-PTO-SOLD-9  PIC S999V99.                  @\n044400     05  TR-CHGD-YTD-EL-PTO-SOLD-X  REDEFINES                     @\n044500         TR-CHGD-YTD-EL-PTO-SOLD-9  PIC X(5).                     @\n044600     05  TR-CHGD-YTD-EL-PTO-TKN-9   PIC S999V99.                  @\n044700     05  TR-CHGD-YTD-EL-PTO-TKN-X   REDEFINES                     @\n044800         TR-CHGD-YTD-EL-PTO-TKN-9   PIC X(5).                     @\n044900     05  TR-CHGD-YTD-EL-PTO-BAL-9   PIC S999V99.                  @\n045000     05  TR-CHGD-YTD-EL-PTO-BAL-X   REDEFINES                     @\n045100         TR-CHGD-YTD-EL-PTO-BAL-9   PIC X(5).                     @\n045200     05  FILLER                     PIC X(34).                    @\n045300                                                                  @\n045400 FD  ERROR-REPORT                                                 @\n045500     BLOCK CONTAINS 0 RECORDS                                     @\n045600     RECORD CONTAINS 133 CHARACTERS                               @\n045700     RECORDING MODE IS F                                          @\n045800     LABEL RECORDS ARE STANDARD.                                  @\n045900 01  ERROR-LINE.                                                  @     10\n046000     05  ER-CC                      PIC X.                        @     20\n046100     05  ER-DATA                    PIC X(132).                   @     30\n046200 01  ERROR-VSAM-LINE.                                             @\n046300     05  FILLER                     PIC X.                        @\n046400     05  ER-VSAM-LIT1               PIC X(17).                    @\n046500     05  ER-VSAM-STATUS-CODE        PIC XX.                       @\n046600     05  ER-VSAM-LIT2               PIC XX.                       @\n046700     05  ER-VSAM-MSG                PIC X(80).                    @\n046800     05  FILLER                     PIC X(31).                    @\n046900 01  ERROR-TRANSACTION-LINE.                                      @\n047000     05  FILLER                     PIC X.                        @\n047100     05  ER-TRAN-ERROR-MSG          PIC X(37).                    @\n047200     05  FILLER                     PIC X.                        @\n047300     05  ER-TRAN-RECORD             PIC X(80).                    @\n047400     05  FILLER                     PIC X(14).                    @\n047500                                                                  @\n047600 FD  TRANSACTION-REPORT                                           @\n047700     BLOCK CONTAINS 0 RECORDS                                     @\n047800     RECORD CONTAINS 133 CHARACTERS                               @\n047900     RECORDING MODE IS F                                          @\n048000     LABEL RECORDS ARE STANDARD.                                  @\n048100 01  TRANSACTION-LINE.                                            @     10\n048200     05  TL-CC                      PIC X.                        @\n048300     05  TL-DATA                    PIC X(132).                   @\n048400 01  TL-EOJ-COUNTS.                                               @     10\n048500     05  FILLER                     PIC X.                        @     20\n048600     05  TL-EOJ-COUNTER             PIC ZZ,ZZZ,ZZ9.               @     30\n048700     05  FILLER                     PIC X.                        @     20\n048800     05  TL-EOJ-COUNT-NAME          PIC X(121).                   @     20\n048900                                                                  @\n049000 WORKING-STORAGE SECTION.                                         @\n049100 77  FILLER                         PIC X(36)  VALUE              @\n049200     'PAYMAINT WORKING STORAGE BEGINS HERE'.                      @\n049300 01  WS-SWITCHES-AND-INDICATORS.                                  @\n049400     05  WS-END-OF-TRANFILE-SWITCH  PIC X VALUE 'N'.              @\n049500         88  WS-END-OF-TRANFILE-DATA  VALUE IS 'Y'.               @\n049600         88  WS-MORE-DATA-TO-PROCESS  VALUE IS 'N'.               @\n049700     05  WS-UPDATE-SWITCH           PIC X VALUE ' '.              @\n049800         88  WS-UPDATE-RUN            VALUE 'U'.                  @\n049900         88  WS-VERIFY-RUN            VALUE 'V'.                  @\n050000     05  WS-ERROR-INDICATOR         PIC X VALUE 'S'.              @\n050100         88  WS-SUCCESSFUL-OPERATION  VALUE 'S'.                  @\n050200         88  WS-OPERATION-FAILED      VALUE 'F'.                  @\n050300     05  WS-TRAN-RECORD-READ-SWITCH PIC X VALUE 'N'.              @\n050400         88  WS-TRAN-RECORD-ALREADY-READ VALUE 'Y'.               @\n050500     05  WS-CHANGE-ERROR-INDICATOR  PIC X.                        @\n050600         88  WS-CHANGE-SUCCESSFUL     VALUE 'N'.                  @\n050700         88  WS-CHANGE-FAILED         VALUE 'Y'.                  @\n050800                                                                  @\n050900 01  WS-MISCELLANEOUS-WORK-AREAS.                                 @\n051000     05  WS-ERROR-RECORDS-WRITTEN   PIC S9(8) COMP-3 VALUE +0.    @\n051100     05  WS-TRANSACTIONS-READ       PIC S9(8) COMP-3 VALUE +0.    @\n051200     05  WS-DELETE-TRANSACTIONS-READ PIC S9(5) COMP-3 VALUE +0.   @\n051300     05  WS-ADD-TRANSACTIONS-READ   PIC S9(5) COMP-3 VALUE +0.    @\n051400     05  WS-CHANGE-TRANSACTIONS-READ PIC S9(5) COMP-3 VALUE +0.   @\n051500     05  WS-PAYROLL-RECORDS-READ    PIC S9(5) COMP-3 VALUE +0.    @\n051600     05  WS-PAYROLL-RECORDS-WRITTEN PIC S9(5) COMP-3 VALUE +0.    @\n051700     05  WS-PAYROLL-RECORDS-UPDATED PIC S9(5) COMP-3 VALUE +0.    @\n051800     05  WS-PAYROLL-RECORDS-DELETED   PIC S9(5) COMP-3 VALUE +0.  @\n051900     05  WS-PAYROLL-RECORDS-MARKED    PIC S9(5) COMP-3 VALUE +0.  @\n052000     05  WS-CLEARED-PAYROLL-RECORD  PIC X(564).                   @\n052100     05  WS-LINE-COUNT              PIC S99 COMP-3 VALUE +0.      @\n052200     05  WS-LINE-SPACING            PIC 9 VALUE 1.                @\n052300     05  WS-PAGE-NUMBER             PIC S9(4) COMP-3 VALUE +0.    @\n052400     05  WS-TODAYS-DATE.                                          @\n052500         10  WS-TODAYS-YEAR         PIC X(4).                     @\n052600         10  WS-TODAYS-MONTH        PIC XX.                       @\n052700         10  WS-TODAYS-DAY          PIC XX.                       @\n052800     05  WS-HELD-ADDS               PIC S9 COMP-3.                @\n052900     05  WS-HOLD-ADD1               PIC X(80).                    @\n053000     05  WS-HOLD-ADD2               PIC X(80).                    @\n053100     05  WS-HOLD-ADD3               PIC X(80).                    @\n053200     05  WS-HOLD-ADD4               PIC X(80).                    @\n053300     05  WS-HOLD-ADD5               PIC X(80).                    @\n053400                                                                  @\n053500 01  WS-HEADING-LINE-1.                                           @\n053600     05  FILLER                     PIC X VALUE '2'.              @\n053700     05  FILLER                     PIC X(8) VALUE 'SKELETON'.    @\n053800     05  FILLER                     PIC X VALUE ' '.              @\n053900     05  WS-HEADING-DATE.                                         @\n054000         10  WS-HEADING-MONTH       PIC X(2).                     @\n054100         10  FILLER                 PIC X VALUE '/'.              @\n054200         10  WS-HEADING-DAY         PIC XX.                       @\n054300         10  FILLER                 PIC X VALUE '/'.              @\n054400         10  WS-HEADING-YEAR        PIC X(4).                     @\n054500     05  FILLER                     PIC X(42) VALUE SPACES.       @\n054600     05  FILLER                     PIC X(21) VALUE               @\n054700                                   'CENTERED REPORT TITLE'.       @\n054800     05  FILLER                     PIC X(41) VALUE SPACES.       @\n054900     05  FILLER                     PIC X(5) VALUE 'PAGE '.       @\n055000     05  WS-HEADING-PAGE-NUMBER     PIC ZZZ9.                     @\n055100                                                                  @\n055200 01  WS-VSAM-ERROR-DATA.                                          @\n055300     05 WS-VSAM-FILE-STATUS         PIC XX    VALUE 'ZZ'.         @\n055400         88  WS-VSAM-SUCCESSFUL       VALUE '00'.                 @\n055500         88  WS-DUPLICATE-KEY-OK      VALUE '02'.                 @\n055600         88  WS-LENGTH-DIFF-OK        VALUE '04'.                 @\n055700         88  WS-OPENCLOSE-OPT-OK      VALUE '07'.                 @\n055800         88  WS-END-OF-FILE           VALUE '10'.                 @\n055900         88  WS-RELKEY-PAST-END       VALUE '14'.                 @\n056000         88  WS-KEY-SEQ-ERROR         VALUE '21'.                 @\n056100         88  WS-DUPL-KEY-WRITE-ERROR  VALUE '22'.                 @\n056200         88  WS-RECD-NOT-FOUND        VALUE '23'.                 @\n056300         88  WS-WRITE-PAST-END-ERROR  VALUE '24'.                 @\n056400         88  WS-PERMANENT-ERROR       VALUE '30'.                 @\n056500         88  WS-BOUNDARY-VIOLATION    VALUE '34'.                 @\n056600         88  WS-FILE-NOT-FOUND        VALUE '35'.                 @\n056700         88  WS-OPEN-FAILED           VALUE '37'.                 @\n056800         88  WS-OPEN-FOR-CLOSE-LOCK   VALUE '38'.                 @\n056900         88  WS-OPEN-CONFLICT-INFO    VALUE '39'.                 @\n057000         88  WS-OPEN-FOR-OPEN-FILE    VALUE '41'.                 @\n057100         88  WS-CLOSE-FOR-NOT-OPEN    VALUE '42'.                 @\n057200         88  WS-REWRITE-SEQUENCE-ERROR VALUE '43'.                @\n057300         88  WS-REWRITE-SIZE-ERROR    VALUE '44'.                 @\n057400         88  WS-NO-NEXT-RECORD-ERROR  VALUE '46'.                 @\n057500         88  WS-READ-FOR-OUTPUT-FILE  VALUE '47'.                 @\n057600         88  WS-WRITE-FOR-INPUT-FILE  VALUE '48'.                 @\n057700         88  WS-DEL-REWRITE-NOT-IO    VALUE '49'.                 @\n057800         88  WS-IMPLEMENTOR-ERROR     VALUE '90'.                 @\n057900         88  WS-PASSWORD-FAIL         VALUE '91'.                 @\n058000         88  WS-LOGIC-ERROR           VALUE '92'.                 @\n058100         88  WS-RESOURCE-NOT-AVAIL    VALUE '93'.                 @\n058200         88  WS-FILE-POSITION-ERROR   VALUE '94'.                 @\n058300         88  WS-INCOMPLETE-INFO-ERROR VALUE '95'.                 @\n058400         88  WS-OPEN-MISSING-DD       VALUE '96'.                 @\n058500         88  WS-OPEN-VERIFY-OK        VALUE '97'.                 @\n058600     05  WS-VSAM-ERROR-MSG-TABLE.                                 @\n058700         10 FILLER                  PIC X(80) VALUE               @\n058800            '02READ SUCCESSFUL. RECORD HAS DUPLICATE KEY. DUPLICAT@\n058900-           'E KEYS OK FOR THE FILE.    '.                        @\n059000         10 FILLER                  PIC X(80) VALUE               @\n059100            '04READ SUCCESSFUL. RECORD LENGTH DIFFERS FROM FIXED F@\n059200-           'ILE ATTRIBUTES FOR THE FILE'.                        @\n059300         10 FILLER                  PIC X(80) VALUE               @\n059400            '07CLOSE OR OPEN SUCCESSFUL. REEL OPTION IGNORED AS FI@\n059500-           'LE IS ON A NON-REEL DEVICE.'.                        @\n059600         10 FILLER                  PIC X(80) VALUE               @\n059700            '10READ FAILED DUE TO NORMAL END OF FILE OR OPTIONAL F@\n059800-           'ILE NOT PRESENT.           '.                        @\n059900         10 FILLER                  PIC X(80) VALUE               @\n060000            '14READ FAILED. RELATIVE RECORD NUMBER GIVEN IS GREATE@\n060100-           'R THAN SIZE OF KEY FIELD.  '.                        @\n060200         10 FILLER                  PIC X(80) VALUE               @\n060300            '21REWRITE FAILED. IT WOULD HAVE RESULTED KEYS BEING O@\n060400-           'UT OF SEQUENCE IN THE FILE.'.                        @\n060500         10 FILLER                  PIC X(80) VALUE               @\n060600            '22WRITE FAILED. IT WOULD HAVE CREATED A RECORD WITH A@\n060700-           'DUPLICATE KEY IN THE FILE. '.                        @\n060800         10 FILLER                  PIC X(80) VALUE               @\n060900            '23READ OR START FAILED. THE REQUESTED RECORD CANNOT B@\n061000-           'E FOUND IN THE FILE.       '.                        @\n061100         10 FILLER                  PIC X(80) VALUE               @\n061200            '24WRITE FAILED. BEYOND END OF EXTERNALLY DEFINED FILE@\n061300-           ' LIMITS OR REL KEY TOO BIG.'.                        @\n061400         10 FILLER                  PIC X(80) VALUE               @\n061500            '30PERMANENT ERROR CONDITION WITH NO FURTHER INFORMATI@\n061600-           'ON AVAILABLE.              '.                        @\n061700         10 FILLER                  PIC X(80) VALUE               @\n061800            '34BOUNDARY VIOLATION. ATTEMPTED TO WRITE BEYOND THE E@\n061900-           'XTERNALLY DEFINED FILE AREA'.                        @\n062000         10 FILLER                  PIC X(80) VALUE               @\n062100            '35OPEN FAILED. NON-OPTIONAL FILE NOT PRESENT FOR AN O@\n062200-           'PEN INPUT, I-O OR EXTEND.  '.                        @\n062300         10 FILLER                  PIC X(80) VALUE               @\n062400            '37OPEN FAILED. FILE DOES NOT SUPPORT THE OPEN OPTION @\n062500-           'SPECIFIED.                 '.                        @\n062600         10 FILLER                  PIC X(80) VALUE               @\n062700            '38OPEN FAILED. THE FILE WAS PREVIOUSLY CLOSED WITH LO@\n062800-           'CK.                        '.                        @\n062900         10 FILLER                  PIC X(80) VALUE               @\n063000            '39OPEN FAILED. CONFLICT BETWEEN PROGRAM SPECIFIED AND@\n063100-           'AND ACTUAL FILE ATTRIBUTES.'.                        @\n063200         10 FILLER                  PIC X(80) VALUE               @\n063300            '41OPEN FAILED. FILE WAS ALREADY OPEN.'.              @\n063400         10 FILLER                  PIC X(80) VALUE               @\n063500            '42CLOSE FAILED. FILE WAS NOT OPEN.'.                 @\n063600         10 FILLER                  PIC X(80) VALUE               @\n063700            '43REWRITE FAILED. LAST PREVIOUS OPERATION WAS NOT A S@\n063800-           'UCCESSFUL READ.            '.                        @\n063900         10 FILLER                  PIC X(80) VALUE               @\n064000            '44(RE)WRITE FAILED. RECORD SIZE DIFFERS FROM ORIGINAL@\n064100-           'OR OUTSIDE OF SIZE LIMITS. '.                        @\n064200         10 FILLER                  PIC X(80) VALUE               @\n064300            '46READ FAILED. READING PAST END OF FILE OR PRECEDING @\n064400-           'READ FAILED.               '.                        @\n064500         10 FILLER                  PIC X(80) VALUE               @\n064600            '47READ FAILED. FILE WAS NOT OPEN FOR INPUT OR I-O.'. @\n064700         10 FILLER                  PIC X(80) VALUE               @\n064800            '48WRITE FAILED. FILE WAS NOT OPEN FOR I-O, OUTPUT, OR@\n064900-           ' EXTEND MODE.              '.                        @\n065000         10 FILLER                  PIC X(80) VALUE               @\n065100            '49DELETE OR REWRITE FAILED. FILE WAS NOT OPEN IN THE @\n065200-           'I-O MODE.                  '.                        @\n065300         10 FILLER                  PIC X(80) VALUE               @\n065400            '90IMPLEMENTOR DEFINED CONDITION WITH NO ADDITIONAL IN@\n065500-           'FORMATION.                 '.                        @\n065600         10 FILLER                  PIC X(80) VALUE               @\n065700            '91PASSWORD FAILURE.'.                                @\n065800         10 FILLER                  PIC X(80) VALUE               @\n065900            '92LOGIC ERROR.'.                                     @\n066000         10 FILLER                  PIC X(80) VALUE               @\n066100            '93RESOURCE NOT AVAILABLE.'.                          @\n066200         10 FILLER                  PIC X(80) VALUE               @\n066300            '94NO FILE POSITION INDICATOR FOR SEQUENTIAL REQUEST. @\n066400-           ' '.                                                  @\n066500         10 FILLER                  PIC X(80) VALUE               @\n066600            '95INVALID OR INCOMPLETE FILE INFORMATION.'.          @\n066700         10 FILLER                  PIC X(80) VALUE               @\n066800            '96OPEN FAILED. NO DD STATEMENT FOUND FOR OPTIONAL FIL@\n066900-           'E OPENED FOR OUTPUT/EXTEND.'.                        @\n067000         10 FILLER                  PIC X(80) VALUE               @\n067100            '97OPEN SUCCESSFUL. FILE INTEGRITY WAS VERIFIED.'.    @\n067200         10 FILLER                  PIC X(80) VALUE               @\n067300            '  UNKNOWN VSAM FILE STATUS CODE RECEIVED.'.          @\n067400     05  WS-VSAM-ERROR-ENTRY REDEFINES WS-VSAM-ERROR-MSG-TABLE    @\n067500                                    OCCURS 32 TIMES               @\n067600                                    INDEXED BY IX.                @\n067700         10 WS-VSAM-ERROR-CODE      PIC XX.                       @\n067800         10 WS-VSAM-ERROR-MESSAGE   PIC X(78).                    @\n067900                                                                  @\n068000 LINKAGE SECTION.                                                 @\n068100 01  LS-EXEC-PARM-FIELD.                                          @\n068200     05  LS-EXEC-PARM-LENGTH        PIC S9(4) COMP.               @\n068300     05  LS-EXEC-PARM-DATA          PIC X(8).                     @\n068400                                                                  @\n068500 PROCEDURE DIVISION USING LS-EXEC-PARM-FIELD.                     @\n068600                                                                  @\n068700 A100-EXECUTIVE-CONTROL.                                          @\n068800     PERFORM A200-INITIALIZATION THRU A200-EXIT.                  @\n068900     PERFORM B100-MAINLINE-PROCESSING THRU B100-EXIT UNTIL        @\n069000         WS-END-OF-TRANFILE-DATA.                                 @\n069100     PERFORM Z100-END-OF-PROCESSING THRU Z100-EXIT.               @\n069200     GOBACK.                                                      @\n069300 A100-EXIT. EXIT.                                                 @\n069400                                                                  @\n069500 A200-INITIALIZATION.                                             @\n069600     IF LS-EXEC-PARM-LENGTH = 6 AND LS-EXEC-PARM-DATA = 'VERIFY'  @\n069700         MOVE 'V' TO WS-UPDATE-SWITCH                             @\n069800     ELSE                                                         @\n069900         IF LS-EXEC-PARM-LENGTH = 6 AND                           @\n070000             LS-EXEC-PARM-DATA = 'UPDATE'                         @\n070100                 MOVE 'U' TO WS-UPDATE-SWITCH                     @\n070200         ELSE                                                     @\n070300             DISPLAY 'PAYMAINT ABENDING: BAD EXEC PARM FIELD.'    @\n070400             CALL 'COBABEND'.                                     @\n070500     OPEN INPUT  TRANSACTION-FILE,                                @\n070600          OUTPUT ERROR-REPORT, TRANSACTION-REPORT,                @\n070700          I-O    PAYROLL-MASTER-FILE.                             @\n070800     IF WS-VSAM-FILE-STATUS = '00' OR '97'                        @\n070900          MOVE '00' TO WS-VSAM-FILE-STATUS                        @\n071000          GO TO A100-EXIT                                         @\n071100     ELSE                                                         @\n071200          PERFORM X100-VSAM-ERRORS THRU X100-EXIT.                @\n071300     ACCEPT WS-TODAYS-DATE FROM DATE YYYYMMDD.                    @\n071400     MOVE WS-TODAYS-YEAR TO WS-HEADING-YEAR.                      @\n071500     MOVE WS-TODAYS-MONTH TO WS-HEADING-MONTH.                    @\n071600     MOVE WS-TODAYS-DAY TO WS-HEADING-DAY.                        @\n071700     MOVE SPACES TO TRANSACTION-LINE.                             @\n071800     MOVE SPACES TO ERROR-LINE.                                   @\n071900     MOVE SPACES TO PAYROLL-RECORD.                               @\n072000     MOVE 'A' TO PR-STATUS-INDICATOR                              @\n072100     MOVE ZEROS TO PR-SEMI-MONTHLY-SALARY, PR-STATE-EXEMPTION,    @\n072200         PR-FED-EXEMPTION, PR-HEALTH-INSURANCE,                   @\n072300         PR-DENTAL-INSURANCE, PR-THRIFT-PLAN-PERCENT,             @\n072400         PR-HEALTH-CARE-FLEX, PR-CHILD-CARE-FLEX,                 @\n072500         PR-CREDIT-UNION, PR-UGF, PR-CHILDREN-INSURANCE,          @\n072600         PR-SPOUSE-INSURANCE, PR-SUPPLEMENTAL-LIFE,               @\n072700         PR-LONG-TERM-DISABILITY, PR-EMPLOYEE-ASSOCIATION,        @\n072800         PR-TAXABLE-IMPUTED-INCOME, PR-NONELECTIVE-PTO-CARRYOVER, @\n072900         PR-NONELECTIVE-PTO-ALLOTTED, PR-NONELECTIVE-PTO-TAKEN,   @\n073000         PR-ELECTIVE-PTO-ALLOTTED, PR-ELECTIVE-PTO-BOUGHT,        @\n073100         PR-ELECTIVE-PTO-SOLD, PR-ELECTIVE-PTO-TAKEN,             @\n073200         PR-CUR-REGULAR-EARNINGS, PR-CUR-HOLIDAY-EARNINGS,        @\n073300         PR-CUR-PTO-EARNINGS, PR-CUR-FLEX-DOLLARS,                @\n073400         PR-CUR-HEALTHY-RETURNS, PR-CUR-MEDICAL-WAIVED,           @\n073500         PR-CUR-BONUS, PR-CUR-UGF-BONUS,                          @\n073600         PR-CUR-FLOATING-HOLIDAY, PR-YTD-REGULAR-EARNINGS,        @\n073700         PR-YTD-HOLIDAY-EARNINGS, PR-YTD-PTO-EARNINGS,            @\n073800         PR-YTD-FLEX-DOLLARS, PR-YTD-HEALTHY-RETURNS,             @\n073900         PR-YTD-MEDICAL-WAIVED, PR-YTD-BONUS,                     @\n074000         PR-YTD-UGF-BONUS, PR-YTD-FLOATING-HOLIDAY,               @\n074100         PR-CUR-FED-TAX, PR-CUR-FICA-MHI,                         @\n074200         PR-CUR-OASDI, PR-CUR-STATE-TAX,                          @\n074300         PR-YTD-FED-TAX, PR-YTD-FICA-MHI,                         @\n074400         PR-YTD-OASDI, PR-YTD-STATE-TAX,                          @\n074500         PR-CUR-THRIFT-PLAN, PR-CUR-MEDICAL-INSURANCE,            @\n074600         PR-CUR-DENTAL-INSURANCE, PR-CUR-HEALTH-CARE-FLEX,        @\n074700         PR-CUR-CHILD-CARE-FLEX, PR-YTD-THRIFT-PLAN,              @\n074800         PR-YTD-MEDICAL-INSURANCE, PR-YTD-DENTAL-INSURANCE,       @\n074900         PR-YTD-HEALTH-CARE-FLEX, PR-YTD-CHILD-CARE-FLEX,         @\n075000         PR-CUR-CREDIT-UNION, PR-CUR-UGF,                         @\n075100         PR-CUR-CHILDREN-INSURANCE, PR-CUR-SPOUSE-INSURANCE,      @\n075200         PR-CUR-LTD-INSURANCE, PR-CUR-EMPLOYEE-ASSOC,             @\n075300         PR-YTD-CREDIT-UNION, PR-YTD-UGF,                         @\n075400         PR-YTD-CHILDREN-INSURANCE, PR-YTD-SPOUSE-INSURANCE,      @\n075500         PR-YTD-LTD-INSURANCE, PR-YTD-EMPLOYEE-ASSOC,             @\n075600         PR-CUR-NONELECTIVE-PTO-TAKEN,                            @\n075700         PR-CUR-NONELECTIVE-PTO-BALANCE,                          @\n075800         PR-CUR-ELECTIVE-PTO-TAKEN, PR-CUR-ELECTIVE-PTO-BOUGHT,   @\n075900         PR-CUR-ELECTIVE-PTO-SOLD, PR-CUR-ELECTIVE-PTO-TAKEN,     @\n076000         PR-CUR-ELECTIVE-PTO-BALANCE,                             @\n076100         PR-YTD-NONELECTIVE-PTO-TAKEN,                            @\n076200         PR-YTD-NONELECTIVE-PTO-BALANCE,                          @\n076300         PR-YTD-ELECTIVE-PTO-TAKEN,                               @\n076400         PR-YTD-ELECTIVE-PTO-BOUGHT, PR-YTD-ELECTIVE-PTO-SOLD,    @\n076500         PR-YTD-ELECTIVE-PTO-TAKEN, PR-YTD-ELECTIVE-PTO-BALANCE.  @\n076600     MOVE PAYROLL-RECORD TO WS-CLEARED-PAYROLL-RECORD.            @\n076700 A200-EXIT. EXIT.                                                 @\n076800                                                                  @\n076900 B100-MAINLINE-PROCESSING.                                        @\n077000     PERFORM T100-READ-TRANSACTION-FILE THRU T100-EXIT.           @\n077100     IF WS-MORE-DATA-TO-PROCESS                                   @\n077200        PERFORM D100-PROCESS-THE-RECORD THRU D100-EXIT.           @\n077300 B100-EXIT. EXIT.                                                 @\n077400                                                                  @\n077500 D100-PROCESS-THE-RECORD.                                         @\n077600     MOVE 'S' TO WS-ERROR-INDICATOR                               @\n077700     MOVE TR-SOCIAL-SECURITY-NBR TO PR-SOCIAL-SECURITY-NBR.       @\n077800     PERFORM T200-READ-PAYROLL-MASTER THRU T200-EXIT.             @\n077900     IF WS-OPERATION-FAILED                                       @\n078000         GO TO D100-EXIT.                                         @\n078100     IF TR-DELETE                                                 @     30\n078200         PERFORM D200-PROCESS-DELETES THRU D200-EXIT              @\n078300     ELSE IF TR-ADD                                               @     30\n078400         PERFORM D300-PROCESS-ADDS THRU D300-EXIT                 @\n078500     ELSE IF TR-CHANGE                                            @     40\n078600         PERFORM D400-PROCESS-CHANGES THRU D400-EXIT              @\n078700     ELSE                                                         @\n078800         MOVE 'INVALID TRANSACTION CODE IN COLUMN 1:' TO          @\n078900             ER-TRAN-ERROR-MSG                                    @\n079000         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT.          @\n079100 D100-EXIT. EXIT.                                                 @\n079200                                                                  @\n079300 D200-PROCESS-DELETES.                                            @\n079400     ADD +1 TO WS-DELETE-TRANSACTIONS-READ.                       @\n079500     IF WS-RECD-NOT-FOUND                                         @\n079600         MOVE 'DELETE FOR RECORD NOT ON FILE:' TO                 @\n079700             ER-TRAN-ERROR-MSG                                    @\n079800         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n079900         GO TO D200-EXIT.                                         @\n080000     PERFORM T500-DELETE-PAYROLL-MASTER THRU T500-EXIT.           @\n080100     IF WS-SUCCESSFUL-OPERATION                                   @\n080200         ADD +1 TO WS-PAYROLL-RECORDS-DELETED.                    @\n080300 D200-EXIT. EXIT.                                                 @\n080400                                                                  @\n080500***************************************************************** @\n080600* PROCESS ADD TRANSACTIONS. EACH ADD TRANSACTION REQUIRES 5     * @\n080700* TRANSACTIONS, WHICH MUST BE ENTERED IN SEQUENCE: A1, A2, A3,  * @\n080800* A4, AND A5. IF ANY RECORDS ARE MISSING OR OUT OF ORDER, THE   * @\n080900* TRANSACTION IS DROPPED.                                       * @\n081000***************************************************************** @\n081100 D300-PROCESS-ADDS.                                               @\n081200     ADD +1 TO WS-ADD-TRANSACTIONS-READ.                          @\n081300     MOVE WS-CLEARED-PAYROLL-RECORD TO PAYROLL-RECORD.            @\n081400     IF WS-RECD-NOT-FOUND                                         @\n081500         NEXT SENTENCE                                            @\n081600     ELSE                                                         @\n081700         MOVE 'ADD FOR RECORD ALREADY ON FILE:' TO                @\n081800             ER-TRAN-ERROR-MSG                                    @\n081900         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n082000         GO TO D300-EXIT.                                         @\n082100     IF TR-ADD1                                                   @\n082200         NEXT SENTENCE                                            @\n082300     ELSE                                                         @\n082400         MOVE 'ADD TRANSACTION RECORDS OUT OF ORDER' TO           @\n082500             ER-TRAN-ERROR-MSG                                    @\n082600         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n082700         GO TO D300-EXIT.                                         @\n082800     IF TR-AC1-SOCIAL-SECURITY-NBR IS NUMERIC                     @\n082900         MOVE TR-AC1-SOCIAL-SECURITY-NBR TO                       @\n083000             PR-SOCIAL-SECURITY-NBR                               @\n083100     ELSE                                                         @\n083200         MOVE 'INVALID SOCIAL SECURITY NUMBER' TO                 @\n083300             ER-TRAN-ERROR-MSG                                    @\n083400         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n083500         GO TO D300-EXIT.                                         @\n083600     IF TR-AC1-LAST-NAME IS NAME-CHARACTERS                       @\n083700         MOVE TR-AC1-LAST-NAME TO                                 @\n083800             PR-LAST-NAME                                         @\n083900     ELSE                                                         @\n084000         MOVE 'LAST NAME CONTAINS INVALID CHARACTERS' TO          @\n084100             ER-TRAN-ERROR-MSG                                    @\n084200         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n084300         GO TO D300-EXIT.                                         @\n084400     IF TR-AC1-FIRST-NAME IS NAME-CHARACTERS                      @\n084500         MOVE TR-AC1-FIRST-NAME TO                                @\n084600             PR-FIRST-NAME                                        @\n084700     ELSE                                                         @\n084800         MOVE 'FIRST NAME CONTAINS INVALID CHARACTERS' TO         @\n084900             ER-TRAN-ERROR-MSG                                    @\n085000         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n085100         GO TO D300-EXIT.                                         @\n085200     IF TR-AC1-INITIAL IS ALPHABETIC                              @\n085300         MOVE TR-AC1-INITIAL TO                                   @\n085400             PR-INITIAL                                           @\n085500     ELSE                                                         @\n085600         MOVE 'FIRST NAME CONTAINS INVALID CHARACTERS' TO         @\n085700             ER-TRAN-ERROR-MSG                                    @\n085800         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n085900         GO TO D300-EXIT.                                         @\n086000     IF TR-AC1-NAME-SUFFIX IS ALPHABETIC                          @\n086100         MOVE TR-AC1-NAME-SUFFIX TO                               @\n086200             PR-NAME-SUFFIX                                       @\n086300     ELSE                                                         @\n086400         MOVE 'NAME SUFFIX CONTAINS INVALID CHARACTERS' TO        @\n086500             ER-TRAN-ERROR-MSG                                    @\n086600         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n086700         GO TO D300-EXIT.                                         @\n086800     IF TR-AC1-ADDRESS-LINE-1 IS ADDRESS-CHARACTERS               @\n086900         MOVE TR-AC1-ADDRESS-LINE-1 TO                            @\n087000             PR-ADDRESS-LINE-1                                    @\n087100     ELSE                                                         @\n087200         MOVE 'NAME SUFFIX CONTAINS INVALID CHARACTERS' TO        @\n087300             ER-TRAN-ERROR-MSG                                    @\n087400         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n087500         GO TO D300-EXIT.                                         @\n087600     MOVE TRANSACTION-ADD-CHANGE1 TO WS-HOLD-ADD1.                @\n087700     MOVE 1 TO WS-HELD-ADDS.                                      @\n087800*    ************************************************************ @\n087900*    * THE SECOND (A2) TRANSACTION IS READ AND PROCESSED.       * @\n088000*    ************************************************************ @\n088100     PERFORM T100-READ-TRANSACTION-FILE THRU T100-EXIT.           @\n088200     IF WS-END-OF-TRANFILE-DATA                                   @\n088300         MOVE 'MISSING RECORDS FOR ADD TRANSACTION' TO            @\n088400             ER-TRAN-ERROR-MSG                                    @\n088500         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n088600         GO TO D300-EXIT.                                         @\n088700     IF TR-ADD2                                                   @\n088800         MOVE 'N' TO WS-TRAN-RECORD-READ-SWITCH                   @\n088900     ELSE                                                         @\n089000         MOVE 'ADD TRANSACTION RECORDS OUT OF ORDER' TO           @\n089100             ER-TRAN-ERROR-MSG                                    @\n089200         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n089300         MOVE 'Y' TO WS-TRAN-RECORD-READ-SWITCH                   @\n089400         GO TO D300-EXIT.                                         @\n089500     MOVE TRANSACTION-ADD-CHANGE2 TO WS-HOLD-ADD2.                @\n089600     MOVE 2 TO WS-HELD-ADDS.                                      @\n089700     IF TR-AC2-SOCIAL-SECURITY-NBR IS EQUAL TO                    @\n089800         PR-SOCIAL-SECURITY-NBR                                   @\n089900             NEXT SENTENCE                                        @\n090000     ELSE                                                         @\n090100         MOVE 'SOCIAL SECURITY MISMATCH ON A2' TO                 @\n090200             ER-TRAN-ERROR-MSG                                    @\n090300         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n090400         GO TO D300-EXIT.                                         @\n090500     IF TR-AC2-ADDRESS-LINE2 IS ADDRESS-CHARACTERS                @\n090600         MOVE TR-AC2-ADDRESS-LINE2 TO                             @\n090700             PR-ADDRESS-LINE-2                                    @\n090800     ELSE                                                         @\n090900         MOVE 'ADDRESS LINE 2 CONTAINS INVALID CHARACTERS' TO     @\n091000             ER-TRAN-ERROR-MSG                                    @\n091100         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n091200         GO TO D300-EXIT.                                         @\n091300     IF TR-AC2-CITY IS NAME-CHARACTERS                            @\n091400         MOVE TR-AC2-CITY TO                                      @\n091500             PR-CITY                                              @\n091600     ELSE                                                         @\n091700         MOVE 'CITY CONTAINS INVALID CHARACTERS' TO               @\n091800             ER-TRAN-ERROR-MSG                                    @\n091900         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n092000         GO TO D300-EXIT.                                         @\n092100     IF TR-AC2-STATE IS ALPHABETIC                                @\n092200         MOVE TR-AC2-STATE TO                                     @\n092300             PR-STATE                                             @\n092400     ELSE                                                         @\n092500         MOVE 'STATE CONTAINS INVALID CHARACTERS' TO              @\n092600             ER-TRAN-ERROR-MSG                                    @\n092700         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n092800         GO TO D300-EXIT.                                         @\n092900     IF TR-AC2-ZIP-5 IS NUMERIC AND                               @\n093000        TR-AC2-ZIP-5 IS NOT EQUAL TO SPACES                       @\n093100             MOVE TR-AC2-ZIP-5 TO                                 @\n093200                 PR-ZIP-5                                         @\n093300     ELSE                                                         @\n093400         MOVE 'ZIP-5 CONTAINS INVALID CHARACTERS' TO              @\n093500             ER-TRAN-ERROR-MSG                                    @\n093600         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n093700         GO TO D300-EXIT.                                         @\n093800     IF TR-AC2-ZIP-LAST-4 IS NUMERIC OR                           @\n093900        TR-AC2-ZIP-LAST-4 IS EQUAL TO ALL SPACES                  @\n094000             MOVE TR-AC2-ZIP-LAST-4 TO                            @\n094100                 PR-ZIP-LAST4                                     @\n094200     ELSE                                                         @\n094300         MOVE 'ZIP-LAST-4 CONTAINS INVALID CHARACTERS' TO         @\n094400             ER-TRAN-ERROR-MSG                                    @\n094500         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n094600         GO TO D300-EXIT.                                         @\n094700*    ************************************************************ @\n094800*    * THE THIRD (A3) TRANSACTION IS READ AND PROCESSED.        * @\n094900*    ************************************************************ @\n095000     PERFORM T100-READ-TRANSACTION-FILE THRU T100-EXIT.           @\n095100     IF WS-END-OF-TRANFILE-DATA                                   @\n095200         MOVE 'MISSING RECORDS FOR ADD TRANSACTION' TO            @\n095300             ER-TRAN-ERROR-MSG                                    @\n095400         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n095500         GO TO D300-EXIT.                                         @\n095600     IF TR-ADD3                                                   @\n095700         MOVE 'N' TO WS-TRAN-RECORD-READ-SWITCH                   @\n095800     ELSE                                                         @\n095900         MOVE 'ADD TRANSACTION RECORDS OUT OF ORDER' TO           @\n096000             ER-TRAN-ERROR-MSG                                    @\n096100         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n096200         MOVE 'Y' TO WS-TRAN-RECORD-READ-SWITCH                   @\n096300         GO TO D300-EXIT.                                         @\n096400     MOVE TRANSACTION-ADD-CHANGE3 TO WS-HOLD-ADD3.                @\n096500     MOVE 3 TO WS-HELD-ADDS.                                      @\n096600     IF TR-AC3-SOCIAL-SECURITY-NBR IS EQUAL TO                    @\n096700         PR-SOCIAL-SECURITY-NBR                                   @\n096800             NEXT SENTENCE                                        @\n096900     ELSE                                                         @\n097000         MOVE 'SOCIAL SECURITY MISMATCH ON A3' TO                 @\n097100             ER-TRAN-ERROR-MSG                                    @\n097200         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n097300         GO TO D300-EXIT.                                         @\n097400     IF TR-AC3-EMPLOYEE-TYPE IS EQUAL TO 'S' OR 'H' OR 'P' OR 'C' @\n097500         MOVE TR-AC3-EMPLOYEE-TYPE TO                             @\n097600             PR-EMPLOYEE-TYPE                                     @\n097700     ELSE                                                         @\n097800         MOVE 'INVALID EMPLOYEE TYPE' TO                          @\n097900             ER-TRAN-ERROR-MSG                                    @\n098000         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n098100         GO TO D300-EXIT.                                         @\n098200     IF TR-AC3-JOB-TITLE IS NAME-CHARACTERS                       @\n098300         MOVE TR-AC3-JOB-TITLE TO                                 @\n098400             PR-JOB-TITLE                                         @\n098500     ELSE                                                         @\n098600         MOVE 'JOB TITLE CONTAINS INVALID CHARACTERS' TO          @\n098700             ER-TRAN-ERROR-MSG                                    @\n098800         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n098900         GO TO D300-EXIT.                                         @\n099000     IF TR-AC3-DEPARTMENT IS NAME-CHARACTERS                      @\n099100         MOVE TR-AC3-DEPARTMENT TO                                @\n099200             PR-DEPARTMENT                                        @\n099300     ELSE                                                         @\n099400         MOVE 'DEPARTMENT HAS INVALID CHARACTERS' TO              @\n099500             ER-TRAN-ERROR-MSG                                    @\n099600         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n099700         GO TO D300-EXIT.                                         @\n099800     IF TR-AC3-COST-CENTER IS ALPHANUMERIC-DATA                   @\n099900         MOVE TR-AC3-COST-CENTER TO                               @\n100000             PR-COST-CENTER                                       @\n100100     ELSE                                                         @\n100200         MOVE 'COST CENTER HAS INVALID CHARACTERS' TO             @\n100300             ER-TRAN-ERROR-MSG                                    @\n100400         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n100500         GO TO D300-EXIT.                                         @\n100600*    ************************************************************ @\n100700*    * THE FOURTH (A4) TRANSACTION IS READ AND PROCESSED.       * @\n100800*    ************************************************************ @\n100900     PERFORM T100-READ-TRANSACTION-FILE THRU T100-EXIT.           @\n101000     IF WS-END-OF-TRANFILE-DATA                                   @\n101100         MOVE 'MISSING RECORDS FOR ADD TRANSACTION' TO            @\n101200             ER-TRAN-ERROR-MSG                                    @\n101300         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n101400         GO TO D300-EXIT.                                         @\n101500     IF TR-ADD4                                                   @\n101600         MOVE 'N' TO WS-TRAN-RECORD-READ-SWITCH                   @\n101700     ELSE                                                         @\n101800         MOVE 'ADD TRANSACTION RECORDS OUT OF ORDER' TO           @\n101900             ER-TRAN-ERROR-MSG                                    @\n102000         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n102100         MOVE 'Y' TO WS-TRAN-RECORD-READ-SWITCH                   @\n102200         GO TO D300-EXIT.                                         @\n102300     MOVE TRANSACTION-ADD-CHANGE4 TO WS-HOLD-ADD4.                @\n102400     MOVE 4 TO WS-HELD-ADDS.                                      @\n102500     IF TR-AC4-SOCIAL-SECURITY-NBR IS EQUAL TO                    @\n102600         PR-SOCIAL-SECURITY-NBR                                   @\n102700             NEXT SENTENCE                                        @\n102800     ELSE                                                         @\n102900         MOVE 'SOCIAL SECURITY MISMATCH ON A4' TO                 @\n103000             ER-TRAN-ERROR-MSG                                    @\n103100         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n103200         GO TO D300-EXIT.                                         @\n103300     IF TR-AC4-LOCATION IS NAME-CHARACTERS AND                    @\n103400        TR-AC4-LOCATION IS EQUAL TO SPACES                        &\n103500             MOVE TR-AC4-LOCATION TO                              @\n103600                 PR-LOCATION                                      @\n103700     ELSE                                                         @\n103800         MOVE 'LOCATION CONTAINS INVALID CHARACTERS' TO           @\n103900             ER-TRAN-ERROR-MSG                                    @\n104000         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n104100         GO TO D300-EXIT.                                         @\n104200     IF TR-AC4-SEMI-MTHLY-SALARY-X IS NUMERIC                     @\n104300         MOVE TR-AC4-SEMI-MTHLY-SALARY-9 TO                       @\n104400             PR-SEMI-MONTHLY-SALARY                               @\n104500     ELSE                                                         @\n104600         IF TR-AC4-HOURLY-RATE-X IS NUMERIC AND                   @\n104700             TR-AC4-BLANKS IS EQUAL TO SPACES                     @\n104800                 MOVE TR-AC4-HOURLY-RATE-9 TO                     @\n104900                     PR-HOURLY-RATE                               @\n105000         ELSE                                                     @\n105100             MOVE 'INVALID HOURLY RATE' TO                        @\n105200                 ER-TRAN-ERROR-MSG                                @\n105300             PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT @\n105400             GO TO D300-EXIT.                                     @\n105500     IF TR-AC4-STATE-EXEMPTION-X IS NUMERIC                       @\n105600         MOVE TR-AC4-STATE-EXEMPTION-9 TO                         @\n105700             PR-STATE-EXEMPTION                                   @\n105800     ELSE                                                         @\n105900         MOVE 'INVALID STATE EXEMPTION' TO                        @\n106000             ER-TRAN-ERROR-MSG                                    @\n106100         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n106200         GO TO D300-EXIT.                                         @\n106300     IF TR-AC4-FED-EXEMPTION-X IS NUMERIC                         @\n106400         MOVE TR-AC4-FED-EXEMPTION-9 TO                           @\n106500             PR-FED-EXEMPTION                                     @\n106600     ELSE                                                         @\n106700         MOVE 'INVALID FED EXEMPTION' TO                          @\n106800             ER-TRAN-ERROR-MSG                                    @\n106900         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n107000         GO TO D300-EXIT.                                         @\n107100     IF TR-AC4-VALID-FILING-STATUS                                @\n107200         MOVE TR-AC4-FILING-STATUS TO                             @\n107300             PR-FILING-STATUS                                     @\n107400     ELSE                                                         @\n107500         MOVE 'FILING STATUS IS INVALID' TO                       @\n107600             ER-TRAN-ERROR-MSG                                    @\n107700         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n107800         GO TO D300-EXIT.                                         @\n107900     IF TR-AC4-HEALTH-INSURANCE-X IS NUMERIC                      @\n108000         MOVE TR-AC4-HEALTH-INSURANCE-9 TO                        @\n108100             PR-HEALTH-INSURANCE                                  @\n108200     ELSE                                                         @\n108300         MOVE 'HEALTH-INSURANCE IS INVALID' TO                    @\n108400             ER-TRAN-ERROR-MSG                                    @\n108500         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n108600         GO TO D300-EXIT.                                         @\n108700     IF TR-AC4-DENTAL-INSURANCE-X IS NUMERIC                      @\n108800         MOVE TR-AC4-DENTAL-INSURANCE-9 TO                        @\n108900             PR-DENTAL-INSURANCE                                  @\n109000     ELSE                                                         @\n109100         MOVE 'DENTAL INSURANCE IS INVALID' TO                    @\n109200             ER-TRAN-ERROR-MSG                                    @\n109300         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n109400         GO TO D300-EXIT.                                         @\n109500     IF TR-AC4-THRIFT-PLAN-PCT-X IS NUMERIC                       @\n109600         MOVE TR-AC4-THRIFT-PLAN-PCT-9 TO                         @\n109700             PR-THRIFT-PLAN-PERCENT                               @\n109800     ELSE                                                         @\n109900         MOVE 'INVALID THRIFT-PLAN-PCT' TO                        @\n110000             ER-TRAN-ERROR-MSG                                    @\n110100         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n110200         GO TO D300-EXIT.                                         @\n110300     IF TR-AC4-HEALTH-CARE-FLEX-X IS NUMERIC                      @\n110400         MOVE TR-AC4-HEALTH-CARE-FLEX-9 TO                        @\n110500             PR-HEALTH-CARE-FLEX                                  @\n110600     ELSE                                                         @\n110700         MOVE 'HEALTH-CARE-FLEX INVALID' TO                       @\n110800             ER-TRAN-ERROR-MSG                                    @\n110900         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n111000         GO TO D300-EXIT.                                         @\n111100     IF TR-AC4-CHILD-CARE-FLEX-X IS NUMERIC                       @\n111200         MOVE TR-AC4-CHILD-CARE-FLEX-9 TO                         @\n111300             PR-CHILD-CARE-FLEX                                   @\n111400     ELSE                                                         @\n111500         MOVE 'INVALID CHILD-CARE-FLEX' TO                        @\n111600             ER-TRAN-ERROR-MSG                                    @\n111700         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n111800         GO TO D300-EXIT.                                         @\n111900*    ************************************************************ @\n112000*    * THE FIFTH (A5) TRANSACTION IS READ AND PROCESSED.        * @\n112100*    ************************************************************ @\n112200     PERFORM T100-READ-TRANSACTION-FILE THRU T100-EXIT.           @\n112300     IF WS-END-OF-TRANFILE-DATA                                   @\n112400         MOVE 'MISSING RECORDS FOR ADD TRANSACTION' TO            @\n112500             ER-TRAN-ERROR-MSG                                    @\n112600         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n112700         GO TO D300-EXIT.                                         @\n112800     IF TR-ADD5                                                   @\n112900         MOVE 'N' TO WS-TRAN-RECORD-READ-SWITCH                   @\n113000     ELSE                                                         @\n113100         MOVE 'ADD TRANSACTION RECORDS OUT OF ORDER' TO           @\n113200             ER-TRAN-ERROR-MSG                                    @\n113300         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n113400         MOVE 'Y' TO WS-TRAN-RECORD-READ-SWITCH                   @\n113500         GO TO D300-EXIT.                                         @\n113600     MOVE TRANSACTION-ADD-CHANGE5 TO WS-HOLD-ADD5.                @\n113700     MOVE 5 TO WS-HELD-ADDS.                                      @\n113800     IF TR-AC5-SOCIAL-SECURITY-NBR IS EQUAL TO                    @\n113900         PR-SOCIAL-SECURITY-NBR                                   @\n114000             NEXT SENTENCE                                        @\n114100     ELSE                                                         @\n114200         MOVE 'SOCIAL SECURITY MISMATCH ON A5' TO                 @\n114300             ER-TRAN-ERROR-MSG                                    @\n114400         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n114500         GO TO D300-EXIT.                                         @\n114600     IF TR-AC5-CREDIT-UNION-X IS NUMERIC                          @\n114700         MOVE TR-AC5-CREDIT-UNION-9 TO                            @\n114800             PR-CREDIT-UNION                                      @\n114900     ELSE                                                         @\n115000         MOVE 'INVALID CREDIT-UNION AMOUNT' TO                    @\n115100             ER-TRAN-ERROR-MSG                                    @\n115200         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n115300         GO TO D300-EXIT.                                         @\n115400     IF TR-AC5-UGF-X IS NUMERIC                                   @\n115500         MOVE TR-AC5-UGF-9 TO                                     @\n115600             PR-UGF                                               @\n115700     ELSE                                                         @\n115800         MOVE 'UGF AMOUNT INVALID' TO                             @\n115900             ER-TRAN-ERROR-MSG                                    @\n116000         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n116100         GO TO D300-EXIT.                                         @\n116200     IF TR-AC5-CHILDREN-INSURANC-X IS NUMERIC                     @\n116300         MOVE TR-AC5-CHILDREN-INSURANC-9 TO                       @\n116400             PR-CHILDREN-INSURANCE                                @\n116500     ELSE                                                         @\n116600         MOVE 'INVALID CHILDREN-INSURANCE' TO                     @\n116700             ER-TRAN-ERROR-MSG                                    @\n116800         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n116900         GO TO D300-EXIT.                                         @\n117000     IF TR-AC5-SPOUSE-INSURANCE-X IS NUMERIC                      @\n117100         MOVE TR-AC5-SPOUSE-INSURANCE-9 TO                        @\n117200             PR-SPOUSE-INSURANCE                                  @\n117300     ELSE                                                         @\n117400         MOVE 'INVALID SPOUSE-INSURANCE' TO                       @\n117500             ER-TRAN-ERROR-MSG                                    @\n117600         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n117700         GO TO D300-EXIT.                                         @\n117800     IF TR-AC5-SUPPLEMENTAL-LIFE-X IS NUMERIC                     @\n117900         MOVE TR-AC5-SUPPLEMENTAL-LIFE-9 TO                       @\n118000             PR-SUPPLEMENTAL-LIFE                                 @\n118100     ELSE                                                         @\n118200         MOVE 'INVALID SUPPLEMENTAL-LIFE' TO                      @\n118300             ER-TRAN-ERROR-MSG                                    @\n118400         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n118500         GO TO D300-EXIT.                                         @\n118600     IF TR-AC5-LONG-TERM-DISBLTY-X IS NUMERIC                     @\n118700         MOVE TR-AC5-LONG-TERM-DISBLTY-9 TO                       @\n118800             PR-LONG-TERM-DISABILITY                              @\n118900     ELSE                                                         @\n119000         MOVE 'INVALID LONG-TERM-DISABILITY' TO                   @\n119100             ER-TRAN-ERROR-MSG                                    @\n119200         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n119300         GO TO D300-EXIT.                                         @\n119400     IF TR-AC5-EMPLOYEE-ASSOC-X IS NUMERIC                        @\n119500         MOVE TR-AC5-EMPLOYEE-ASSOC-9 TO                          @\n119600             PR-EMPLOYEE-ASSOCIATION                              @\n119700     ELSE                                                         @\n119800         MOVE 'EMPLOYEE-ASSOC INVALID               ' TO          @\n119900             ER-TRAN-ERROR-MSG                                    @\n120000         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n120100         GO TO D300-EXIT.                                         @\n120200     IF TR-AC5-TAX-IMPUTED-INC-X IS NUMERIC                       @\n120300         MOVE TR-AC5-TAX-IMPUTED-INC-9 TO                         @\n120400             PR-TAXABLE-IMPUTED-INCOME                            @\n120500     ELSE                                                         @\n120600         MOVE '                                     ' TO          @\n120700             ER-TRAN-ERROR-MSG                                    @\n120800         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n120900         GO TO D300-EXIT.                                         @\n121000     IF TR-AC5-NONEL-PTO-ALLOT-X IS NUMERIC                       @\n121100         MOVE TR-AC5-NONEL-PTO-ALLOT-9 TO                         @\n121200             PR-NONELECTIVE-PTO-ALLOTTED                          @\n121300     ELSE                                                         @\n121400         MOVE 'INVALID NONELECTIVEO-ALLOTTED' TO                  @\n121500             ER-TRAN-ERROR-MSG                                    @\n121600         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n121700         GO TO D300-EXIT.                                         @\n121800     IF TR-AC5-EL-PTO-ALLOT-X IS NUMERIC                          @\n121900         MOVE TR-AC5-EL-PTO-ALLOT-9 TO                            @\n122000             PR-ELECTIVE-PTO-ALLOTTED                             @\n122100     ELSE                                                         @\n122200         MOVE 'INVALID ELECTIVE-PTO-ALLOTTED' TO                  @\n122300             ER-TRAN-ERROR-MSG                                    @\n122400         PERFORM X510-TRANSACTION-SEQUENCE-ERR THRU X510-EXIT     @\n122500         GO TO D300-EXIT.                                         @\n122600     PERFORM T300-WRITE-PAYROLL-MASTER THRU T300-EXIT.            @\n122700     IF WS-SUCCESSFUL-OPERATION                                   @\n122800         ADD +1 TO WS-PAYROLL-RECORDS-DELETED.                    @\n122900 D300-EXIT. EXIT.                                                 @\n123000                                                                  @\n123100                                                                  @\n123200 D400-PROCESS-CHANGES.                                            @\n123300     ADD +1 TO WS-CHANGE-TRANSACTIONS-READ.                       @\n123400     IF WS-RECD-NOT-FOUND                                         @\n123500         MOVE 'CHANGE FOR RECORD NOT ON FILE:' TO                 @\n123600             ER-TRAN-ERROR-MSG                                    @\n123700         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n123800         GO TO D400-EXIT.                                         @\n123900     MOVE 'Y' TO WS-CHANGE-ERROR-INDICATOR.                       @\n124000     EVALUATE TR-AC1-TYPE                                         @\n124100         WHEN 'C1' PERFORM D401-PROCESS-C1 THRU D401-EXIT         @\n124200         WHEN 'C2' PERFORM D402-PROCESS-C2 THRU D402-EXIT         @\n124300         WHEN 'C3' PERFORM D403-PROCESS-C3 THRU D403-EXIT         @\n124400         WHEN 'C4' PERFORM D404-PROCESS-C4 THRU D404-EXIT         @\n124500         WHEN 'C5' PERFORM D405-PROCESS-C5 THRU D405-EXIT         @\n124600         WHEN 'C6' PERFORM D406-PROCESS-C6 THRU D406-EXIT         @\n124700         WHEN 'C7' PERFORM D407-PROCESS-C7 THRU D407-EXIT         @\n124800         WHEN 'C8' PERFORM D408-PROCESS-C8 THRU D408-EXIT         @\n124900         WHEN 'C9' PERFORM D409-PROCESS-C9 THRU D409-EXIT         @\n125000         WHEN 'CA' PERFORM D40A-PROCESS-CA THRU D40A-EXIT         @\n125100         WHEN 'CB' PERFORM D40B-PROCESS-CB THRU D40B-EXIT         @\n125200         WHEN 'CC' PERFORM D40C-PROCESS-CC THRU D40C-EXIT         @\n125300         WHEN 'CD' PERFORM D40D-PROCESS-CD THRU D40D-EXIT         @\n125400         WHEN OTHER                                               @\n125500         MOVE 'INVALID CHANGE SEQUENCE NUMBER' TO                 @\n125600             ER-TRAN-ERROR-MSG                                    @\n125700         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n125800         GO TO D400-EXIT.                                         @\n125900     IF WS-CHANGE-SUCCESSFUL                                      @\n126000         PERFORM T400-UPDATE-PAYROLL-MASTER THRU T400-EXIT        @\n126100             IF WS-SUCCESSFUL-OPERATION                           @\n126200                 ADD +1 TO WS-PAYROLL-RECORDS-DELETED.            @\n126300 D400-EXIT. EXIT.                                                 @\n126400                                                                  @\n126500 D401-PROCESS-C1.                                                 @\n126600     IF TR-AC1-LAST-NAME IS EQUAL TO SPACES                       @\n126700         NEXT SENTENCE                                            @\n126800     ELSE                                                         @\n126900         IF TR-AC1-LAST-NAME IS NAME-CHARACTERS                   @\n127000             MOVE TR-AC1-LAST-NAME TO PR-LAST-NAME                @\n127100         ELSE                                                     @\n127200             MOVE 'INVALID LAST NAME' TO                          @\n127300                 ER-TRAN-ERROR-MSG                                @\n127400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n127500             GO TO D401-EXIT.                                     @\n127600     IF TR-AC1-FIRST-NAME IS EQUAL TO SPACES                      @\n127700         NEXT SENTENCE                                            @\n127800     ELSE                                                         @\n127900         IF TR-AC1-FIRST-NAME IS NAME-CHARACTERS                  @\n128000             MOVE TR-AC1-FIRST-NAME TO PR-FIRST-NAME              @\n128100         ELSE                                                     @\n128200             MOVE 'INVALID FIRST NAME' TO                         @\n128300                 ER-TRAN-ERROR-MSG                                @\n128400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n128500             GO TO D401-EXIT.                                     @\n128600     IF TR-AC1-INITIAL IS EQUAL TO SPACES                         @\n128700         NEXT SENTENCE                                            @\n128800     ELSE                                                         @\n128900         IF TR-AC1-INITIAL IS ALPHABETIC                          @\n129000             MOVE TR-AC1-INITIAL TO PR-INITIAL                    @\n129100         ELSE                                                     @\n129200             MOVE 'INVALID MIDDLE INITIAL' TO                     @\n129300                 ER-TRAN-ERROR-MSG                                @\n129400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n129500             GO TO D401-EXIT.                                     @\n129600     IF TR-AC1-NAME-SUFFIX IS ADDRESS-CHARACTERS                  @\n129700         MOVE TR-AC1-NAME-SUFFIX TO PR-NAME-SUFFIX                @\n129800     ELSE                                                         @\n129900         MOVE 'INVALID NAME SUFFIX' TO                            @\n130000             ER-TRAN-ERROR-MSG                                    @\n130100         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n130200         GO TO D401-EXIT.                                         @\n130300     IF TR-AC1-ADDRESS-LINE-1 IS ADDRESS-CHARACTERS               @\n130400         MOVE TR-AC1-ADDRESS-LINE-1 TO PR-ADDRESS-LINE-1          @\n130500     ELSE                                                         @\n130600         MOVE 'INVALID ADDRESS LINE 1' TO                         @\n130700             ER-TRAN-ERROR-MSG                                    @\n130800         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n130900         GO TO D401-EXIT.                                         @\n131000     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n131100 D401-EXIT. EXIT.                                                 @\n131200                                                                  @\n131300 D402-PROCESS-C2.                                                 @\n131400     IF TR-AC2-ADDRESS-LINE2 IS EQUAL TO SPACES                   @\n131500         NEXT SENTENCE                                            @\n131600     ELSE                                                         @\n131700         IF TR-AC2-ADDRESS-LINE2 IS EQUAL TO ALL '#'              @\n131800             MOVE SPACES TO PR-ADDRESS-LINE-2                     @\n131900         ELSE                                                     @\n132000             IF TR-AC2-ADDRESS-LINE2 IS ADDRESS-CHARACTERS        @\n132100                 MOVE TR-AC2-ADDRESS-LINE2 TO                     @\n132200                     PR-ADDRESS-LINE-2                            @\n132300             ELSE                                                 @\n132400                 MOVE 'INVALID ADDRESS LINE 2' TO                 @\n132500                     ER-TRAN-ERROR-MSG                            @\n132600                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n132700                 GO TO D402-EXIT.                                 @\n132800     IF TR-AC2-CITY IS EQUAL TO SPACES                            @\n132900         NEXT SENTENCE                                            @\n133000     ELSE                                                         @\n133100         IF TR-AC2-CITY IS NAME-CHARACTERS                        @\n133200             MOVE TR-AC2-CITY TO PR-CITY                          @\n133300         ELSE                                                     @\n133400             MOVE 'INVALID CITY' TO                               @\n133500                 ER-TRAN-ERROR-MSG                                @\n133600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n133700             GO TO D402-EXIT.                                     @\n133800     IF TR-AC2-STATE IS EQUAL TO SPACES                           @\n133900         NEXT SENTENCE                                            @\n134000     ELSE                                                         @\n134100         IF TR-AC2-STATE IS ALPHABETIC                            @\n134200             MOVE TR-AC2-STATE TO PR-STATE                        @\n134300         ELSE                                                     @\n134400             MOVE 'INVALID STATE' TO                              @\n134500                 ER-TRAN-ERROR-MSG                                @\n134600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n134700             GO TO D402-EXIT.                                     @\n134800     IF TR-AC2-ZIP-5 IS EQUAL TO SPACES                           @\n134900         NEXT SENTENCE                                            @\n135000     ELSE                                                         @\n135100         IF TR-AC2-ZIP-5 IS NUMERIC                               @\n135200             MOVE TR-AC2-ZIP-5 TO PR-ZIP-5                        @\n135300         ELSE                                                     @\n135400             MOVE 'INVALID ZIP-5' TO                              @\n135500                 ER-TRAN-ERROR-MSG                                @\n135600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n135700             GO TO D402-EXIT.                                     @\n135800     IF TR-AC2-ZIP-LAST-4 IS EQUAL TO SPACES                      @\n135900         NEXT SENTENCE                                            @\n136000     ELSE                                                         @\n136100         IF TR-AC2-ZIP-LAST-4 IS EQUAL TO ALL '#'                 @\n136200             MOVE SPACES TO PR-ZIP-LAST4                          @\n136300         ELSE                                                     @\n136400             IF TR-AC2-ZIP-LAST-4 IS NUMERIC                      @\n136500                 MOVE TR-AC2-ZIP-LAST-4 TO PR-ZIP-LAST4           @\n136600             ELSE                                                 @\n136700                 MOVE 'INVALID ZIP-LAST-4' TO                     @\n136800                     ER-TRAN-ERROR-MSG                            @\n136900                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n137000                 GO TO D402-EXIT.                                 @\n137100     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n137200 D402-EXIT. EXIT.                                                 @\n137300                                                                  @\n137400 D403-PROCESS-C3.                                                 @\n137500     IF TR-AC3-EMPLOYEE-TYPE IS EQUAL TO SPACE                    @\n137600         NEXT SENTENCE                                            @\n137700     ELSE                                                         @\n137800         IF TR-AC3-EMPLOYEE-TYPE = 'S' OR 'H' OR 'P' OR 'C'       @\n137900             MOVE TR-AC3-EMPLOYEE-TYPE TO                         @\n138000                     PR-EMPLOYEE-TYPE                             @\n138100             ELSE                                                 @\n138200                 MOVE 'INVALID EMPLOYEE TYPE' TO                  @\n138300                     ER-TRAN-ERROR-MSG                            @\n138400                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n138500                 GO TO D403-EXIT.                                 @\n138600     IF TR-AC3-JOB-TITLE IS EQUAL TO SPACE                        @\n138700         NEXT SENTENCE                                            @\n138800     ELSE                                                         @\n138900         IF TR-AC3-JOB-TITLE IS NAME-CHARACTERS                   @\n139000             MOVE TR-AC3-JOB-TITLE TO PR-JOB-TITLE                @\n139100             ELSE                                                 @\n139200                 MOVE 'INVALID JOB TITLE' TO                      @\n139300                     ER-TRAN-ERROR-MSG                            @\n139400                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n139500                 GO TO D403-EXIT.                                 @\n139600     IF TR-AC3-DEPARTMENT IS EQUAL TO SPACE                       @\n139700         NEXT SENTENCE                                            @\n139800     ELSE                                                         @\n139900         IF TR-AC3-DEPARTMENT IS NAME-CHARACTERS                  @\n140000             MOVE TR-AC3-DEPARTMENT TO PR-DEPARTMENT              @\n140100             ELSE                                                 @\n140200                 MOVE 'INVALID DEPARTMENT' TO                     @\n140300                     ER-TRAN-ERROR-MSG                            @\n140400                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n140500                 GO TO D403-EXIT.                                 @\n140600     IF TR-AC3-COST-CENTER IS EQUAL TO SPACE                      @\n140700         NEXT SENTENCE                                            @\n140800     ELSE                                                         @\n140900         IF TR-AC3-COST-CENTER IS ADDRESS-CHARACTERS              @\n141000             MOVE TR-AC3-COST-CENTER TO PR-COST-CENTER            @\n141100             ELSE                                                 @\n141200                 MOVE 'INVALID COST-CENTER' TO                    @\n141300                     ER-TRAN-ERROR-MSG                            @\n141400                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n141500                 GO TO D403-EXIT.                                 @\n141600     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n141700 D403-EXIT. EXIT.                                                 @\n141800                                                                  @\n141900 D404-PROCESS-C4.                                                 @\n142000     IF TR-AC4-LOCATION IS EQUAL TO SPACES                        @\n142100         NEXT SENTENCE                                            @\n142200     ELSE                                                         @\n142300         IF TR-AC4-LOCATION IS ADDRESS-CHARACTERS                 @\n142400             MOVE TR-AC4-LOCATION TO                              @\n142500                     PR-LOCATION                                  @\n142600             ELSE                                                 @\n142700                 MOVE 'INVALID LOCATION' TO                       @\n142800                     ER-TRAN-ERROR-MSG                            @\n142900                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n143000                 GO TO D404-EXIT.                                 @\n143100     IF TR-AC4-DENTAL-INSURANCE-X IS EQUAL TO SPACES              @\n143200         NEXT SENTENCE                                            @\n143300     ELSE                                                         @\n143400         IF TR-AC4-DENTAL-INSURANCE-X IS NUMERIC                  @\n143500             MOVE TR-AC4-DENTAL-INSURANCE-9 TO                    @\n143600                     PR-DENTAL-INSURANCE                          @\n143700             ELSE                                                 @\n143800                 MOVE 'INVALID DENTAL-INSURANCE' TO               @\n143900                     ER-TRAN-ERROR-MSG                            @\n144000                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n144100                 GO TO D404-EXIT.                                 @\n144200     IF TR-AC4-SEMI-MTHLY-SALARY-X IS NUMERIC                     @\n144300         MOVE TR-AC4-SEMI-MTHLY-SALARY-9 TO                       @\n144400                 PR-SEMI-MONTHLY-SALARY                           @\n144500     ELSE                                                         @\n144600         IF TR-AC4-BLANKS IS EQUAL TO SPACES AND                  @\n144700            TR-AC4-HOURLY-RATE-X IS NUMERIC                       @\n144800                MOVE TR-AC4-HOURLY-RATE-9 TO                      @\n144900                    PR-HOURLY-RATE                                @\n145000         ELSE                                                     @\n145100             IF TR-AC4-SEMI-MTHLY-SALARY-X IS EQUAL TO SPACES     @\n145200                 NEXT SENTENCE                                    @\n145300         ELSE                                                     @\n145400             MOVE 'INVALID SEMI-MTHLY-SALARY' TO                  @\n145500                 ER-TRAN-ERROR-MSG                                @\n145600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n145700             GO TO D404-EXIT.                                     @\n145800     IF TR-AC4-STATE-EXEMPTION-X IS EQUAL TO SPACES               @\n145900         NEXT SENTENCE                                            @\n146000     ELSE                                                         @\n146100         IF TR-AC4-STATE-EXEMPTION-X IS NUMERIC                   @\n146200             MOVE TR-AC4-STATE-EXEMPTION-9 TO                     @\n146300                     PR-STATE-EXEMPTION                           @\n146400             ELSE                                                 @\n146500                 MOVE 'INVALID STATE-EXEMPTION' TO                @\n146600                     ER-TRAN-ERROR-MSG                            @\n146700                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n146800                 GO TO D404-EXIT.                                 @\n146900     IF TR-AC4-FED-EXEMPTION-X IS EQUAL TO SPACES                 @\n147000         NEXT SENTENCE                                            @\n147100     ELSE                                                         @\n147200         IF TR-AC4-FED-EXEMPTION-X IS NUMERIC                     @\n147300             MOVE TR-AC4-FED-EXEMPTION-9 TO                       @\n147400                     PR-FED-EXEMPTION                             @\n147500             ELSE                                                 @\n147600                 MOVE 'INVALID FED-EXEMPTION' TO                  @\n147700                     ER-TRAN-ERROR-MSG                            @\n147800                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n147900                 GO TO D404-EXIT.                                 @\n148000     IF TR-AC4-FILING-STATUS IS EQUAL TO SPACES                   @\n148100         NEXT SENTENCE                                            @\n148200     ELSE                                                         @\n148300         IF TR-AC4-VALID-FILING-STATUS                            @\n148400             MOVE TR-AC4-FILING-STATUS TO                         @\n148500                     PR-FILING-STATUS                             @\n148600             ELSE                                                 @\n148700                 MOVE 'INVALID FILING STATUS' TO                  @\n148800                     ER-TRAN-ERROR-MSG                            @\n148900                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n149000                 GO TO D404-EXIT.                                 @\n149100     IF TR-AC4-HEALTH-INSURANCE-X IS EQUAL TO SPACES              @\n149200         NEXT SENTENCE                                            @\n149300     ELSE                                                         @\n149400         IF TR-AC4-HEALTH-INSURANCE-X IS NUMERIC                  @\n149500             MOVE TR-AC4-HEALTH-INSURANCE-9 TO                    @\n149600                     PR-HEALTH-INSURANCE                          @\n149700             ELSE                                                 @\n149800                 MOVE 'INVALID HEALTH-INSURANCE' TO               @\n149900                     ER-TRAN-ERROR-MSG                            @\n150000                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n150100                 GO TO D404-EXIT.                                 @\n150200     IF TR-AC4-DENTAL-INSURANCE-X IS EQUAL TO SPACES              @\n150300         NEXT SENTENCE                                            @\n150400     ELSE                                                         @\n150500         IF TR-AC4-DENTAL-INSURANCE-X IS NUMERIC                  @\n150600             MOVE TR-AC4-DENTAL-INSURANCE-9 TO                    @\n150700                     PR-DENTAL-INSURANCE                          @\n150800             ELSE                                                 @\n150900                 MOVE 'INVALID DENTAL-INSURANCE' TO               @\n151000                     ER-TRAN-ERROR-MSG                            @\n151100                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n151200                 GO TO D404-EXIT.                                 @\n151300     IF TR-AC4-THRIFT-PLAN-PCT-X IS EQUAL TO SPACES               @\n151400         NEXT SENTENCE                                            @\n151500     ELSE                                                         @\n151600         IF TR-AC4-THRIFT-PLAN-PCT-X IS NUMERIC                   @\n151700             MOVE TR-AC4-THRIFT-PLAN-PCT-9 TO                     @\n151800                     PR-THRIFT-PLAN-PERCENT                       @\n151900             ELSE                                                 @\n152000                 MOVE 'INVALID THRIFT-PLAN-PCT' TO                @\n152100                     ER-TRAN-ERROR-MSG                            @\n152200                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n152300                 GO TO D404-EXIT.                                 @\n152400     IF TR-AC4-HEALTH-CARE-FLEX-X IS EQUAL TO SPACES              @\n152500         NEXT SENTENCE                                            @\n152600     ELSE                                                         @\n152700         IF TR-AC4-HEALTH-CARE-FLEX-X IS NUMERIC                  @\n152800             MOVE TR-AC4-HEALTH-CARE-FLEX-9 TO                    @\n152900                     PR-HEALTH-CARE-FLEX                          @\n153000             ELSE                                                 @\n153100                 MOVE 'INVALID HEALTH-CARE-FLEX' TO               @\n153200                     ER-TRAN-ERROR-MSG                            @\n153300                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n153400                 GO TO D404-EXIT.                                 @\n153500     IF TR-AC4-CHILD-CARE-FLEX-X IS EQUAL TO SPACES               @\n153600         NEXT SENTENCE                                            @\n153700     ELSE                                                         @\n153800         IF TR-AC4-CHILD-CARE-FLEX-X IS NUMERIC                   @\n153900             MOVE TR-AC4-CHILD-CARE-FLEX-9 TO                     @\n154000                     PR-CHILD-CARE-FLEX                           @\n154100             ELSE                                                 @\n154200                 MOVE 'INVALID CHILD-CARE-FLEX' TO                @\n154300                     ER-TRAN-ERROR-MSG                            @\n154400                 PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT   @\n154500                 GO TO D404-EXIT.                                 @\n154600     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n154700 D404-EXIT. EXIT.                                                 @\n154800                                                                  @\n154900 D405-PROCESS-C5.                                                 @\n155000     IF TR-AC5-CREDIT-UNION-X IS EQUAL TO SPACES                  @\n155100         NEXT SENTENCE                                            @\n155200     ELSE                                                         @\n155300         IF TR-AC5-CREDIT-UNION-X IS NUMERIC                      @\n155400             MOVE TR-AC5-CREDIT-UNION-9 TO                        @\n155500                 PR-CREDIT-UNION                                  @\n155600         ELSE                                                     @\n155700             MOVE 'INVALID CREDIT UNION AMOUNT' TO                @\n155800                 ER-TRAN-ERROR-MSG                                @\n155900             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n156000             GO TO D405-EXIT.                                     @\n156100     IF TR-AC5-UGF-X IS EQUAL TO SPACES                           @\n156200         NEXT SENTENCE                                            @\n156300     ELSE                                                         @\n156400         IF TR-AC5-UGF-X IS NUMERIC                               @\n156500             MOVE TR-AC5-UGF-9 TO                                 @\n156600                 PR-UGF                                           @\n156700         ELSE                                                     @\n156800             MOVE 'INVALID UGF' TO                                @\n156900                 ER-TRAN-ERROR-MSG                                @\n157000             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n157100             GO TO D405-EXIT.                                     @\n157200     IF TR-AC5-CHILDREN-INSURANC-X IS EQUAL TO SPACES             @\n157300         NEXT SENTENCE                                            @\n157400     ELSE                                                         @\n157500         IF TR-AC5-CHILDREN-INSURANC-X IS NUMERIC                 @\n157600             MOVE TR-AC5-CHILDREN-INSURANC-9 TO                   @\n157700                 PR-CHILDREN-INSURANCE                            @\n157800         ELSE                                                     @\n157900             MOVE 'INVALID CHILDREN-INSURANCE' TO                 @\n158000                 ER-TRAN-ERROR-MSG                                @\n158100             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n158200             GO TO D405-EXIT.                                     @\n158300     IF TR-AC5-SPOUSE-INSURANCE-X IS EQUAL TO SPACES              @\n158400         NEXT SENTENCE                                            @\n158500     ELSE                                                         @\n158600         IF TR-AC5-SPOUSE-INSURANCE-X IS NUMERIC                  @\n158700             MOVE TR-AC5-SPOUSE-INSURANCE-9 TO                    @\n158800                 PR-SPOUSE-INSURANCE                              @\n158900         ELSE                                                     @\n159000             MOVE 'INVALID SPOUSE-INSURANCE' TO                   @\n159100                 ER-TRAN-ERROR-MSG                                @\n159200             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n159300             GO TO D405-EXIT.                                     @\n159400     IF TR-AC5-SUPPLEMENTAL-LIFE-X IS EQUAL TO SPACES             @\n159500         NEXT SENTENCE                                            @\n159600     ELSE                                                         @\n159700         IF TR-AC5-SUPPLEMENTAL-LIFE-X IS NUMERIC                 @\n159800             MOVE TR-AC5-SUPPLEMENTAL-LIFE-9 TO                   @\n159900                 PR-SUPPLEMENTAL-LIFE                             @\n160000         ELSE                                                     @\n160100             MOVE 'INVALID SUPPLEMENTAL-LIFE' TO                  @\n160200                 ER-TRAN-ERROR-MSG                                @\n160300             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n160400             GO TO D405-EXIT.                                     @\n160500     IF TR-AC5-LONG-TERM-DISBLTY-X IS EQUAL TO SPACES             @\n160600         NEXT SENTENCE                                            @\n160700     ELSE                                                         @\n160800         IF TR-AC5-LONG-TERM-DISBLTY-X IS NUMERIC                 @\n160900             MOVE TR-AC5-LONG-TERM-DISBLTY-9 TO                   @\n161000                 PR-LONG-TERM-DISABILITY                          @\n161100         ELSE                                                     @\n161200             MOVE 'INVALID LONG-TERM-DISABILITY' TO               @\n161300                 ER-TRAN-ERROR-MSG                                @\n161400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n161500             GO TO D405-EXIT.                                     @\n161600     IF TR-AC5-EMPLOYEE-ASSOC-X IS EQUAL TO SPACES                @\n161700         NEXT SENTENCE                                            @\n161800     ELSE                                                         @\n161900         IF TR-AC5-EMPLOYEE-ASSOC-X IS NUMERIC                    @\n162000             MOVE TR-AC5-EMPLOYEE-ASSOC-9 TO                      @\n162100                 PR-EMPLOYEE-ASSOCIATION                          @\n162200         ELSE                                                     @\n162300             MOVE 'INVALID EMPLOYEE-ASSOCIATION' TO               @\n162400                 ER-TRAN-ERROR-MSG                                @\n162500             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n162600             GO TO D405-EXIT.                                     @\n162700     IF TR-AC5-TAX-IMPUTED-INC-X IS EQUAL TO SPACES               @\n162800         NEXT SENTENCE                                            @\n162900     ELSE                                                         @\n163000         IF TR-AC5-TAX-IMPUTED-INC-X IS NUMERIC                   @\n163100             MOVE TR-AC5-TAX-IMPUTED-INC-9 TO                     @\n163200                 PR-TAXABLE-IMPUTED-INCOME                        @\n163300         ELSE                                                     @\n163400             MOVE 'INVALID TAXABLE-IMPUT' TO                      @\n163500                 ER-TRAN-ERROR-MSG                                @\n163600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n163700             GO TO D405-EXIT.                                     @\n163800     IF TR-AC5-NONEL-PTO-ALLOT-X IS EQUAL TO SPACES               @\n163900         NEXT SENTENCE                                            @\n164000     ELSE                                                         @\n164100         IF TR-AC5-NONEL-PTO-ALLOT-X IS NUMERIC                   @\n164200             MOVE TR-AC5-NONEL-PTO-ALLOT-9 TO                     @\n164300                 PR-NONELECTIVE-PTO-ALLOTTED                      @\n164400         ELSE                                                     @\n164500             MOVE 'INVALID NONELECTIVE-PTO-ALLOTTED' TO           @\n164600                 ER-TRAN-ERROR-MSG                                @\n164700             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n164800             GO TO D405-EXIT.                                     @\n164900     IF TR-AC5-EL-PTO-ALLOT-X IS EQUAL TO SPACES                  @\n165000         NEXT SENTENCE                                            @\n165100     ELSE                                                         @\n165200         IF TR-AC5-EL-PTO-ALLOT-X IS NUMERIC                      @\n165300             MOVE TR-AC5-EL-PTO-ALLOT-9 TO                        @\n165400                 PR-ELECTIVE-PTO-ALLOTTED                         @\n165500         ELSE                                                     @\n165600             MOVE 'INVALID ELECTIVE-PTO-ALLOTTED' TO              @\n165700                 ER-TRAN-ERROR-MSG                                @\n165800             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n165900             GO TO D405-EXIT.                                     @\n166000     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n166100 D405-EXIT. EXIT.                                                 @\n166200                                                                  @\n166300 D406-PROCESS-C6.                                                 @\n166400     IF TR-CHG6-NONEL-PTO-CARRY-X IS EQUAL TO SPACES              @\n166500         NEXT SENTENCE                                            @\n166600     ELSE                                                         @\n166700         IF TR-CHG6-NONEL-PTO-CARRY-X IS NUMERIC                  @\n166800             MOVE TR-CHG6-NONEL-PTO-CARRY-9     TO                @\n166900                 PR-NONELECTIVE-PTO-CARRYOVER                     @\n167000         ELSE                                                     @\n167100             MOVE 'INVALID NONELECTIVE PTO CARRYOVER' TO          @\n167200                 ER-TRAN-ERROR-MSG                                @\n167300             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n167400             GO TO D406-EXIT.                                     @\n167500     IF TR-CHG6-NONEL-PTO-TAKEN-X IS EQUAL TO SPACES              @\n167600         NEXT SENTENCE                                            @\n167700     ELSE                                                         @\n167800         IF TR-CHG6-NONEL-PTO-TAKEN-X IS NUMERIC                  @\n167900             MOVE TR-CHG6-NONEL-PTO-TAKEN-9     TO                @\n168000                 PR-NONELECTIVE-PTO-TAKEN                         @\n168100         ELSE                                                     @\n168200             MOVE 'INVALID NONELECTIVE PTO TAKEN' TO              @\n168300                 ER-TRAN-ERROR-MSG                                @\n168400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n168500             GO TO D406-EXIT.                                     @\n168600     IF TR-CHG6-ELECT-PTO-BOUGHT-X IS EQUAL TO SPACES             @\n168700         NEXT SENTENCE                                            @\n168800     ELSE                                                         @\n168900         IF TR-CHG6-ELECT-PTO-BOUGHT-X IS NUMERIC                 @\n169000             MOVE TR-CHG6-ELECT-PTO-BOUGHT-9 TO                   @\n169100                 PR-ELECTIVE-PTO-BOUGHT                           @\n169200         ELSE                                                     @\n169300             MOVE 'INVALID ELECTIVE PTO BOUGHT' TO                @\n169400                 ER-TRAN-ERROR-MSG                                @\n169500             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n169600             GO TO D406-EXIT.                                     @\n169700     IF TR-CHG6-ELECT-PTO-SOLD-X IS EQUAL TO SPACES               @\n169800         NEXT SENTENCE                                            @\n169900     ELSE                                                         @\n170000         IF TR-CHG6-ELECT-PTO-SOLD-X IS NUMERIC                   @\n170100             MOVE TR-CHG6-ELECT-PTO-SOLD-9 TO                     @\n170200                 PR-ELECTIVE-PTO-SOLD                             @\n170300         ELSE                                                     @\n170400             MOVE 'INVALID ELECTIVE-PTO-SOL' TO                   @\n170500                 ER-TRAN-ERROR-MSG                                @\n170600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n170700             GO TO D406-EXIT.                                     @\n170800     IF TR-CHG6-ELECT-PTO-TAKEN-X IS EQUAL TO SPACES              @\n170900         NEXT SENTENCE                                            @\n171000     ELSE                                                         @\n171100         IF TR-CHG6-ELECT-PTO-TAKEN-X IS NUMERIC                  @\n171200             MOVE TR-CHG6-ELECT-PTO-TAKEN-9 TO                    @\n171300                 PR-ELECTIVE-PTO-TAKEN                            @\n171400         ELSE                                                     @\n171500             MOVE 'INVALID ELECTIVE-PTO-TAKEN' TO                 @\n171600                 ER-TRAN-ERROR-MSG                                @\n171700             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n171800             GO TO D406-EXIT.                                     @\n171900     IF TR-CHG6-CUR-REGULAR-EARN-X IS EQUAL TO SPACES             @\n172000         NEXT SENTENCE                                            @\n172100     ELSE                                                         @\n172200         IF TR-CHG6-CUR-REGULAR-EARN-X IS NUMERIC                 @\n172300             MOVE TR-CHG6-CUR-REGULAR-EARN-9 TO                   @\n172400                 PR-CUR-REGULAR-EARNINGS                          @\n172500         ELSE                                                     @\n172600             MOVE 'INVALID CUR-REGULAR-EARNINGS' TO               @\n172700                 ER-TRAN-ERROR-MSG                                @\n172800             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n172900             GO TO D406-EXIT.                                     @\n173000     IF TR-CHG6-CUR-HOLIDAY-EARN-X IS EQUAL TO SPACES             @\n173100         NEXT SENTENCE                                            @\n173200     ELSE                                                         @\n173300         IF TR-CHG6-CUR-HOLIDAY-EARN-X IS NUMERIC                 @\n173400             MOVE TR-CHG6-CUR-HOLIDAY-EARN-9 TO                   @\n173500                 PR-CUR-HOLIDAY-EARNINGS                          @\n173600         ELSE                                                     @\n173700             MOVE 'INVALID CUR-HOLIDAY-EARNINGS' TO               @\n173800                 ER-TRAN-ERROR-MSG                                @\n173900             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n174000             GO TO D406-EXIT.                                     @\n174100     IF TR-CHG6-CUR-PTO-EARNINGS-X IS EQUAL TO SPACES             @\n174200         NEXT SENTENCE                                            @\n174300     ELSE                                                         @\n174400         IF TR-CHG6-CUR-PTO-EARNINGS-X IS NUMERIC                 @\n174500             MOVE TR-CHG6-CUR-PTO-EARNINGS-9 TO                   @\n174600                 PR-CUR-PTO-EARNINGS                              @\n174700         ELSE                                                     @\n174800             MOVE 'INVALID CUR-PTO-EARNINGS' TO                   @\n174900                 ER-TRAN-ERROR-MSG                                @\n175000             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n175100             GO TO D406-EXIT.                                     @\n175200     IF TR-CHG6-CUR-FLEX-DOLLARS-X IS EQUAL TO SPACES             @\n175300         NEXT SENTENCE                                            @\n175400     ELSE                                                         @\n175500         IF TR-CHG6-CUR-FLEX-DOLLARS-X IS NUMERIC                 @\n175600             MOVE TR-CHG6-CUR-FLEX-DOLLARS-9 TO                   @\n175700                 PR-CUR-FLEX-DOLLARS                              @\n175800         ELSE                                                     @\n175900             MOVE 'INVALID CUR-FLEX-DOLLARS' TO                   @\n176000                 ER-TRAN-ERROR-MSG                                @\n176100             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n176200             GO TO D406-EXIT.                                     @\n176300     IF TR-CHG6-CUR-HEALTHY-RTRN-X IS EQUAL TO SPACES             @\n176400         NEXT SENTENCE                                            @\n176500     ELSE                                                         @\n176600         IF TR-CHG6-CUR-HEALTHY-RTRN-X IS NUMERIC                 @\n176700             MOVE TR-CHG6-CUR-HEALTHY-RTRN-9 TO                   @\n176800                 PR-CUR-HEALTHY-RETURNS                           @\n176900         ELSE                                                     @\n177000             MOVE 'INVALID CUR-HEALTHY-RETURNS' TO                @\n177100                 ER-TRAN-ERROR-MSG                                @\n177200             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n177300             GO TO D406-EXIT.                                     @\n177400     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n177500 D406-EXIT. EXIT.                                                 @\n177600                                                                  @\n177700 D407-PROCESS-C7.                                                 @\n177800     IF TR-CHG7-CUR-MEDICAL-WAIV-X IS EQUAL TO SPACES             @\n177900         NEXT SENTENCE                                            @\n178000     ELSE                                                         @\n178100         IF TR-CHG7-CUR-MEDICAL-WAIV-X IS NUMERIC                 @\n178200             MOVE TR-CHG7-CUR-MEDICAL-WAIV-9 TO                   @\n178300                 PR-CUR-MEDICAL-WAIVED                            @\n178400         ELSE                                                     @\n178500             MOVE 'INVALID CURRENT MEDICAL WAIVED' TO             @\n178600                 ER-TRAN-ERROR-MSG                                @\n178700             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n178800             GO TO D407-EXIT.                                     @\n178900     IF TR-CHG7-CUR-MEDICAL-WAIV-X IS EQUAL TO SPACES             @\n179000         NEXT SENTENCE                                            @\n179100     ELSE                                                         @\n179200         IF TR-CHG7-CUR-MEDICAL-WAIV-X IS NUMERIC                 @\n179300             MOVE TR-CHG7-CUR-MEDICAL-WAIV-9 TO                   @\n179400                 PR-CUR-MEDICAL-WAIVED                            @\n179500         ELSE                                                     @\n179600             MOVE 'INVALID CUR-MEDICAL-WAIVED' TO                 @\n179700                 ER-TRAN-ERROR-MSG                                @\n179800             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n179900             GO TO D407-EXIT.                                     @\n180000     IF TR-CHG7-CUR-BONUS-X IS EQUAL TO SPACES                    @\n180100         NEXT SENTENCE                                            @\n180200     ELSE                                                         @\n180300         IF TR-CHG7-CUR-BONUS-X IS NUMERIC                        @\n180400             MOVE TR-CHG7-CUR-BONUS-9 TO                          @\n180500                 PR-CUR-BONUS                                     @\n180600         ELSE                                                     @\n180700             MOVE 'INVALID CUR-BONUS' TO                          @\n180800                 ER-TRAN-ERROR-MSG                                @\n180900             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n181000             GO TO D407-EXIT.                                     @\n181100     IF TR-CHG7-CUR-UGF-BONUS-X IS EQUAL TO SPACES                @\n181200         NEXT SENTENCE                                            @\n181300     ELSE                                                         @\n181400         IF TR-CHG7-CUR-UGF-BONUS-X IS NUMERIC                    @\n181500             MOVE TR-CHG7-CUR-UGF-BONUS-9 TO                      @\n181600                 PR-CUR-UGF-BONUS                                 @\n181700         ELSE                                                     @\n181800             MOVE 'INVALID CUR-UGF-BONUS' TO                      @\n181900                 ER-TRAN-ERROR-MSG                                @\n182000             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n182100             GO TO D407-EXIT.                                     @\n182200     IF TR-CHG7-CUR-FLOAT-HOL-X IS EQUAL TO SPACES                @\n182300         NEXT SENTENCE                                            @\n182400     ELSE                                                         @\n182500         IF TR-CHG7-CUR-FLOAT-HOL-X IS NUMERIC                    @\n182600             MOVE TR-CHG7-CUR-FLOAT-HOL-9 TO                      @\n182700                 PR-CUR-FLOATING-HOLIDAY                          @\n182800         ELSE                                                     @\n182900             MOVE 'INVALID CUR-FLOATING-HOLIDAY' TO               @\n183000                 ER-TRAN-ERROR-MSG                                @\n183100             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n183200             GO TO D407-EXIT.                                     @\n183300     IF TR-CHG7-YTD-REG-EARN-X IS EQUAL TO SPACES                 @\n183400         NEXT SENTENCE                                            @\n183500     ELSE                                                         @\n183600         IF TR-CHG7-YTD-REG-EARN-X IS NUMERIC                     @\n183700             MOVE TR-CHG7-YTD-REG-EARN-9 TO                       @\n183800                 PR-YTD-REGULAR-EARNINGS                          @\n183900         ELSE                                                     @\n184000             MOVE 'INVALID YTD-REGULAR-EARNINGS' TO               @\n184100                 ER-TRAN-ERROR-MSG                                @\n184200             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n184300             GO TO D407-EXIT.                                     @\n184400     IF TR-CHG7-YTD-HOL-EARN-X IS EQUAL TO SPACES                 @\n184500         NEXT SENTENCE                                            @\n184600     ELSE                                                         @\n184700         IF TR-CHG7-YTD-HOL-EARN-X IS NUMERIC                     @\n184800             MOVE TR-CHG7-YTD-HOL-EARN-9 TO                       @\n184900                 PR-YTD-HOLIDAY-EARNINGS                          @\n185000         ELSE                                                     @\n185100             MOVE 'INVALID YTD-HOLIDAY-EARNINGS' TO               @\n185200                 ER-TRAN-ERROR-MSG                                @\n185300             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n185400             GO TO D407-EXIT.                                     @\n185500     IF TR-CHG7-YTD-PTO-EARNINGS-X IS EQUAL TO SPACES             @\n185600         NEXT SENTENCE                                            @\n185700     ELSE                                                         @\n185800         IF TR-CHG7-YTD-PTO-EARNINGS-X IS NUMERIC                 @\n185900             MOVE TR-CHG7-YTD-PTO-EARNINGS-9 TO                   @\n186000                 PR-YTD-PTO-EARNINGS                              @\n186100         ELSE                                                     @\n186200             MOVE 'INVALID YTD-PTO-EARNINGS' TO                   @\n186300                 ER-TRAN-ERROR-MSG                                @\n186400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n186500             GO TO D407-EXIT.                                     @\n186600     IF TR-CHG7-YTD-FLEX-DOLLARS-X IS EQUAL TO SPACES             @\n186700         NEXT SENTENCE                                            @\n186800     ELSE                                                         @\n186900         IF TR-CHG7-YTD-FLEX-DOLLARS-X IS NUMERIC                 @\n187000             MOVE TR-CHG7-YTD-FLEX-DOLLARS-9 TO                   @\n187100                 PR-YTD-FLEX-DOLLARS                              @\n187200         ELSE                                                     @\n187300             MOVE 'INVALID YTD-FLEX-DOLLARS' TO                   @\n187400                 ER-TRAN-ERROR-MSG                                @\n187500             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n187600             GO TO D407-EXIT.                                     @\n187700     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n187800 D407-EXIT. EXIT.                                                 @\n187900                                                                  @\n188000 D408-PROCESS-C8.                                                 @\n188100     IF TR-CHG8-YTD-HEALTHY-RETRN-X IS EQUAL TO SPACES            @\n188200         NEXT SENTENCE                                            @\n188300     ELSE                                                         @\n188400         IF TR-CHG8-YTD-HEALTHY-RETRN-X IS NUMERIC                @\n188500             MOVE TR-CHG8-YTD-HEALTHY-RETRN-9 TO                  @\n188600                 PR-YTD-HEALTHY-RETURNS                           @\n188700         ELSE                                                     @\n188800             MOVE 'INVALID YTD-HEALTHY-RETURNS' TO                @\n188900                 ER-TRAN-ERROR-MSG                                @\n189000             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n189100             GO TO D408-EXIT.                                     @\n189200     IF TR-CHG8-YTD-MEDICAL-WAIV-X IS EQUAL TO SPACES             @\n189300         NEXT SENTENCE                                            @\n189400     ELSE                                                         @\n189500         IF TR-CHG8-YTD-MEDICAL-WAIV-X IS NUMERIC                 @\n189600             MOVE TR-CHG8-YTD-MEDICAL-WAIV-9 TO                   @\n189700                 PR-YTD-MEDICAL-WAIVED                            @\n189800         ELSE                                                     @\n189900             MOVE 'INVALID YTD-MEDICAL-WAIVED' TO                 @\n190000                 ER-TRAN-ERROR-MSG                                @\n190100             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n190200             GO TO D408-EXIT.                                     @\n190300     IF TR-CHG8-YTD-BONUS-X IS EQUAL TO SPACES                    @\n190400         NEXT SENTENCE                                            @\n190500     ELSE                                                         @\n190600         IF TR-CHG8-YTD-BONUS-X IS NUMERIC                        @\n190700             MOVE TR-CHG8-YTD-BONUS-9 TO                          @\n190800                 PR-YTD-BONUS                                     @\n190900         ELSE                                                     @\n191000             MOVE 'INVALID YTD-BONUS' TO                          @\n191100                 ER-TRAN-ERROR-MSG                                @\n191200             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n191300             GO TO D408-EXIT.                                     @\n191400     IF TR-CHG8-YTD-UGF-BONUS-X IS EQUAL TO SPACES                @\n191500         NEXT SENTENCE                                            @\n191600     ELSE                                                         @\n191700         IF TR-CHG8-YTD-UGF-BONUS-X IS NUMERIC                    @\n191800             MOVE TR-CHG8-YTD-UGF-BONUS-9 TO                      @\n191900                 PR-YTD-UGF-BONUS                                 @\n192000         ELSE                                                     @\n192100             MOVE 'INVALID YTD-UGF-BONUS' TO                      @\n192200                 ER-TRAN-ERROR-MSG                                @\n192300             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n192400             GO TO D408-EXIT.                                     @\n192500     IF TR-CHG8-YTD-FLOAT-HOL-X IS EQUAL TO SPACES                @\n192600         NEXT SENTENCE                                            @\n192700     ELSE                                                         @\n192800         IF TR-CHG8-YTD-FLOAT-HOL-X IS NUMERIC                    @\n192900             MOVE TR-CHG8-YTD-FLOAT-HOL-9 TO                      @\n193000                 PR-YTD-FLOATING-HOLIDAY                          @\n193100         ELSE                                                     @\n193200             MOVE 'INVALID YTD-FLOATING-HOLIDAY' TO               @\n193300                 ER-TRAN-ERROR-MSG                                @\n193400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n193500             GO TO D408-EXIT.                                     @\n193600     IF TR-CHG8-CUR-FED-TAX-X IS EQUAL TO SPACES                  @\n193700         NEXT SENTENCE                                            @\n193800     ELSE                                                         @\n193900         IF TR-CHG8-CUR-FED-TAX-X IS NUMERIC                      @\n194000             MOVE TR-CHG8-CUR-FED-TAX-9 TO                        @\n194100                 PR-CUR-FED-TAX                                   @\n194200         ELSE                                                     @\n194300             MOVE 'INVALID CUR-FED-TAX' TO                        @\n194400                 ER-TRAN-ERROR-MSG                                @\n194500             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n194600             GO TO D408-EXIT.                                     @\n194700     IF TR-CHG8-CUR-FICA-MHI-X IS EQUAL TO SPACES                 @\n194800         NEXT SENTENCE                                            @\n194900     ELSE                                                         @\n195000         IF TR-CHG8-CUR-FICA-MHI-X IS NUMERIC                     @\n195100             MOVE TR-CHG8-CUR-FICA-MHI-9 TO                       @\n195200                 PR-CUR-FICA-MHI                                  @\n195300         ELSE                                                     @\n195400             MOVE 'INVALID CUR-FICA-MHI' TO                       @\n195500                 ER-TRAN-ERROR-MSG                                @\n195600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n195700             GO TO D408-EXIT.                                     @\n195800     IF TR-CHG8-CUR-OASDI-X IS EQUAL TO SPACES                    @\n195900         NEXT SENTENCE                                            @\n196000     ELSE                                                         @\n196100         IF TR-CHG8-CUR-OASDI-X IS NUMERIC                        @\n196200             MOVE TR-CHG8-CUR-OASDI-9 TO                          @\n196300                 PR-CUR-OASDI                                     @\n196400         ELSE                                                     @\n196500             MOVE 'INVALID CUR-OASDI' TO                          @\n196600                 ER-TRAN-ERROR-MSG                                @\n196700             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n196800             GO TO D408-EXIT.                                     @\n196900     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n197000 D408-EXIT. EXIT.                                                 @\n197100                                                                  @\n197200 D409-PROCESS-C9.                                                 @\n197300     IF TR-CHG9-CUR-STATE-TAX-X IS EQUAL TO SPACES                @\n197400         NEXT SENTENCE                                            @\n197500     ELSE                                                         @\n197600         IF TR-CHG9-CUR-STATE-TAX-X IS NUMERIC                    @\n197700             MOVE TR-CHG9-CUR-STATE-TAX-9 TO                      @\n197800                 PR-CUR-STATE-TAX                                 @\n197900         ELSE                                                     @\n198000             MOVE 'INVALID CUR-STATE-TAX' TO                      @\n198100                 ER-TRAN-ERROR-MSG                                @\n198200             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n198300             GO TO D409-EXIT.                                     @\n198400     IF TR-CHG9-YTD-FED-TAX-X IS EQUAL TO SPACES                  @\n198500         NEXT SENTENCE                                            @\n198600     ELSE                                                         @\n198700         IF TR-CHG9-YTD-FED-TAX-X IS NUMERIC                      @\n198800             MOVE TR-CHG9-YTD-FED-TAX-9 TO                        @\n198900                 PR-YTD-FED-TAX                                   @\n199000         ELSE                                                     @\n199100             MOVE 'INVALID YTD-FED-TAX' TO                        @\n199200                 ER-TRAN-ERROR-MSG                                @\n199300             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n199400             GO TO D409-EXIT.                                     @\n199500     IF TR-CHG9-YTD-FICA-MHI-X IS EQUAL TO SPACES                 @\n199600         NEXT SENTENCE                                            @\n199700     ELSE                                                         @\n199800         IF TR-CHG9-YTD-FICA-MHI-X IS NUMERIC                     @\n199900             MOVE TR-CHG9-YTD-FICA-MHI-9 TO                       @\n200000                 PR-YTD-FICA-MHI                                  @\n200100         ELSE                                                     @\n200200             MOVE 'INVALID YTD-FICA-MHI' TO                       @\n200300                 ER-TRAN-ERROR-MSG                                @\n200400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n200500             GO TO D409-EXIT.                                     @\n200600     IF TR-CHG9-YTD-OASDI-X IS EQUAL TO SPACES                    @\n200700         NEXT SENTENCE                                            @\n200800     ELSE                                                         @\n200900         IF TR-CHG9-YTD-OASDI-X IS NUMERIC                        @\n201000             MOVE TR-CHG9-YTD-OASDI-9 TO                          @\n201100                 PR-YTD-OASDI                                     @\n201200         ELSE                                                     @\n201300             MOVE 'INVALID YTD-OASDI' TO                          @\n201400                 ER-TRAN-ERROR-MSG                                @\n201500             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n201600             GO TO D409-EXIT.                                     @\n201700     IF TR-CHG9-YTD-STATE-TAX-X IS EQUAL TO SPACES                @\n201800         NEXT SENTENCE                                            @\n201900     ELSE                                                         @\n202000         IF TR-CHG9-YTD-STATE-TAX-X IS NUMERIC                    @\n202100             MOVE TR-CHG9-YTD-STATE-TAX-9 TO                      @\n202200                 PR-YTD-STATE-TAX                                 @\n202300         ELSE                                                     @\n202400             MOVE 'INVALID YTD-STATE-TAX' TO                      @\n202500                 ER-TRAN-ERROR-MSG                                @\n202600             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n202700             GO TO D409-EXIT.                                     @\n202800     IF TR-CHG9-CUR-THRIFT-PLAN-X IS EQUAL TO SPACES              @\n202900         NEXT SENTENCE                                            @\n203000     ELSE                                                         @\n203100         IF TR-CHG9-CUR-THRIFT-PLAN-X IS NUMERIC                  @\n203200             MOVE TR-CHG9-CUR-THRIFT-PLAN-9 TO                    @\n203300                 PR-CUR-THRIFT-PLAN                               @\n203400         ELSE                                                     @\n203500             MOVE 'INVALID CUR-THRIFT-PLAN' TO                    @\n203600                 ER-TRAN-ERROR-MSG                                @\n203700             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n203800             GO TO D409-EXIT.                                     @\n203900     IF TR-CHG9-CUR-MED-INS-X IS EQUAL TO SPACES                  @\n204000         NEXT SENTENCE                                            @\n204100     ELSE                                                         @\n204200         IF TR-CHG9-CUR-MED-INS-X IS NUMERIC                      @\n204300             MOVE TR-CHG9-CUR-MED-INS-9 TO                        @\n204400                 PR-CUR-MEDICAL-INSURANCE                         @\n204500         ELSE                                                     @\n204600             MOVE 'INVALID CUR-MEDICAL-INSURANCE' TO              @\n204700                 ER-TRAN-ERROR-MSG                                @\n204800             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n204900             GO TO D409-EXIT.                                     @\n205000     IF TR-CHG9-CUR-DENTAL-INS-X IS EQUAL TO SPACES               @\n205100         NEXT SENTENCE                                            @\n205200     ELSE                                                         @\n205300         IF TR-CHG9-CUR-DENTAL-INS-X IS NUMERIC                   @\n205400             MOVE TR-CHG9-CUR-DENTAL-INS-9 TO                     @\n205500                 PR-CUR-DENTAL-INSURANCE                          @\n205600         ELSE                                                     @\n205700             MOVE 'INVALID CUR-DENTAL-INSURANCE' TO               @\n205800                 ER-TRAN-ERROR-MSG                                @\n205900             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n206000             GO TO D409-EXIT.                                     @\n206100     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n206200 D409-EXIT. EXIT.                                                 @\n206300                                                                  @\n206400 D40A-PROCESS-CA.                                                 @\n206500     IF TR-CHGA-CUR-HLTHCARE-FLX-X IS EQUAL TO SPACES             @\n206600         NEXT SENTENCE                                            @\n206700     ELSE                                                         @\n206800         IF TR-CHGA-CUR-HLTHCARE-FLX-X IS NUMERIC                 @\n206900             MOVE TR-CHGA-CUR-HLTHCARE-FLX-9 TO                   @\n207000                 PR-CUR-HEALTH-CARE-FLEX                          @\n207100         ELSE                                                     @\n207200             MOVE 'INVALID CUR-HEALTH-CARE-FLEX' TO               @\n207300                 ER-TRAN-ERROR-MSG                                @\n207400             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n207500             GO TO D40A-EXIT.                                     @\n207600     IF TR-CHGA-CUR-CHILCARE-FLX-X IS EQUAL TO SPACES             @\n207610         NEXT SENTENCE                                            @\n207620     ELSE                                                         @\n207630         IF TR-CHGA-CUR-CHILCARE-FLX-X IS NUMERIC                 @\n207640             MOVE TR-CHGA-CUR-CHILCARE-FLX-9 TO                   @\n207650                 PR-CUR-CHILD-CARE-FLEX                           @\n207660         ELSE                                                     @\n207670             MOVE 'INVALID CUR-CHILD-CARE-FLEX' TO                @\n207680                 ER-TRAN-ERROR-MSG                                @\n207690             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n207691             GO TO D40A-EXIT.                                     @\n207693     IF TR-CHGA-YTD-THRIFT-PLAN-X IS EQUAL TO SPACES              @\n207694         NEXT SENTENCE                                            @\n207695     ELSE                                                         @\n207696         IF TR-CHGA-YTD-THRIFT-PLAN-X IS NUMERIC                  @\n207697             MOVE TR-CHGA-YTD-THRIFT-PLAN-9 TO                    @\n207698                 PR-YTD-THRIFT-PLAN                               @\n207699         ELSE                                                     @\n207700             MOVE 'INVALID YTD-THRIFT-PLAN' TO                    @\n207701                 ER-TRAN-ERROR-MSG                                @\n207710             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n207720             GO TO D40A-EXIT.                                     @\n207730     IF TR-CHGA-YTD-MEDICAL-INS-X IS EQUAL TO SPACES              @\n207740         NEXT SENTENCE                                            @\n207750     ELSE                                                         @\n207760         IF TR-CHGA-YTD-MEDICAL-INS-X IS NUMERIC                  @\n207770             MOVE TR-CHGA-YTD-MEDICAL-INS-9 TO                    @\n207780                 PR-YTD-MEDICAL-INSURANCE                         @\n207790         ELSE                                                     @\n207800             MOVE 'INVALID YTD-MEDICAL-INSURANCE' TO              @\n207810                 ER-TRAN-ERROR-MSG                                @\n207820             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n207830             GO TO D40A-EXIT.                                     @\n207840     IF TR-CHGA-YTD-DENTAL-INS-X IS EQUAL TO SPACES               @\n207850         NEXT SENTENCE                                            @\n207860     ELSE                                                         @\n207870         IF TR-CHGA-YTD-DENTAL-INS-X IS NUMERIC                   @\n207880             MOVE TR-CHGA-YTD-DENTAL-INS-9 TO                     @\n207890                 PR-YTD-DENTAL-INSURANCE                          @\n207900         ELSE                                                     @\n207910             MOVE 'INVALID YTD-DENTAL-INSURANCE' TO               @\n207920                 ER-TRAN-ERROR-MSG                                @\n207930             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n207940             GO TO D40A-EXIT.                                     @\n207950     IF TR-CHGA-YTD-HLTHCARE-FLX-X IS EQUAL TO SPACES             @\n207960         NEXT SENTENCE                                            @\n207970     ELSE                                                         @\n207980         IF TR-CHGA-YTD-HLTHCARE-FLX-X IS NUMERIC                 @\n207990             MOVE TR-CHGA-YTD-HLTHCARE-FLX-9 TO                   @\n208000                 PR-YTD-HEALTH-CARE-FLEX                          @\n208010         ELSE                                                     @\n208020             MOVE 'INVALID YTD-HEALTH-CARE-FLEX' TO               @\n208030                 ER-TRAN-ERROR-MSG                                @\n208040             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n208050             GO TO D40A-EXIT.                                     @\n208060     IF TR-CHGA-YTD-CHILCARE-FLX-X IS EQUAL TO SPACES             @\n208070         NEXT SENTENCE                                            @\n208080     ELSE                                                         @\n208090         IF TR-CHGA-YTD-CHILCARE-FLX-X IS NUMERIC                 @\n208100             MOVE TR-CHGA-YTD-CHILCARE-FLX-9 TO                   @\n208110                 PR-YTD-CHILD-CARE-FLEX                           @\n208120         ELSE                                                     @\n208130             MOVE 'INVALID YTD-CHILD-CARE-FLEX' TO                @\n208140                 ER-TRAN-ERROR-MSG                                @\n208150             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n208160             GO TO D40A-EXIT.                                     @\n208170     IF TR-CHGA-CUR-CREDIT-UNION-X IS EQUAL TO SPACES             @\n208180         NEXT SENTENCE                                            @\n208190     ELSE                                                         @\n208200         IF TR-CHGA-CUR-CREDIT-UNION-X IS NUMERIC                 @\n208210             MOVE TR-CHGA-CUR-CREDIT-UNION-9 TO                   @\n208220                 PR-CUR-CREDIT-UNION                              @\n208230         ELSE                                                     @\n208240             MOVE 'INVALID CUR-CREDIT-UNION' TO                   @\n208250                 ER-TRAN-ERROR-MSG                                @\n208260             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n208270             GO TO D40A-EXIT.                                     @\n208400     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n208500 D40A-EXIT. EXIT.                                                 @\n208600                                                                  @\n208700 D40B-PROCESS-CB.                                                 @\n208800     IF TR-CHGB-CUR-UGF-X IS EQUAL TO SPACES                      @\n208900         NEXT SENTENCE                                            @\n209000     ELSE                                                         @\n209100         IF TR-CHGB-CUR-UGF-X IS NUMERIC                          @\n209200             MOVE TR-CHGB-CUR-UGF-9 TO                            @\n209300                 PR-CUR-UGF                                       @\n209400         ELSE                                                     @\n209500             MOVE 'INVALID CUR-UGF' TO                            @\n209600                 ER-TRAN-ERROR-MSG                                @\n209700             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n209800             GO TO D40B-EXIT.                                     @\n209900     IF TR-CHGB-CUR-CHILDREN-INS-X IS EQUAL TO SPACES             @\n209910         NEXT SENTENCE                                            @\n209920     ELSE                                                         @\n209930         IF TR-CHGB-CUR-CHILDREN-INS-X IS NUMERIC                 @\n209940             MOVE TR-CHGB-CUR-CHILDREN-INS-9 TO                   @\n209950                 PR-CUR-CHILDREN-INSURANCE                        @\n209960         ELSE                                                     @\n209970             MOVE 'INVALID CUR-CHILDREN-INSURANCE' TO             @\n209980                 ER-TRAN-ERROR-MSG                                @\n209990             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n209991             GO TO D40B-EXIT.                                     @\n209993     IF TR-CHGB-CUR-SPOUSE-INS-X IS EQUAL TO SPACES               @\n209994         NEXT SENTENCE                                            @\n209995     ELSE                                                         @\n209996         IF TR-CHGB-CUR-SPOUSE-INS-X IS NUMERIC                   @\n209997             MOVE TR-CHGB-CUR-SPOUSE-INS-9 TO                     @\n209998                 PR-CUR-SPOUSE-INSURANCE                          @\n209999         ELSE                                                     @\n210000             MOVE 'INVALID CUR-SPOUSE-INSURANCE' TO               @\n210001                 ER-TRAN-ERROR-MSG                                @\n210010             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n210020             GO TO D40B-EXIT.                                     @\n210030     IF TR-CHGB-CUR-LTD-INS-X IS EQUAL TO SPACES                  @\n210040         NEXT SENTENCE                                            @\n210050     ELSE                                                         @\n210060         IF TR-CHGB-CUR-LTD-INS-X IS NUMERIC                      @\n210070             MOVE TR-CHGB-CUR-LTD-INS-9 TO                        @\n210080                 PR-CUR-LTD-INSURANCE                             @\n210090         ELSE                                                     @\n210100             MOVE 'INVALID CUR-LTD-INSURANCE' TO                  @\n210110                 ER-TRAN-ERROR-MSG                                @\n210120             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n210130             GO TO D40B-EXIT.                                     @\n210140     IF TR-CHGB-CUR-EMPL-ASSOC-X IS EQUAL TO SPACES               @\n210150         NEXT SENTENCE                                            @\n210160     ELSE                                                         @\n210170         IF TR-CHGB-CUR-EMPL-ASSOC-X IS NUMERIC                   @\n210180             MOVE TR-CHGB-CUR-EMPL-ASSOC-9 TO                     @\n210190                 PR-CUR-EMPLOYEE-ASSOC                            @\n210200         ELSE                                                     @\n210210             MOVE 'INVALID CUR-EMPLOYEE-ASSOC' TO                 @\n210220                 ER-TRAN-ERROR-MSG                                @\n210230             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n210240             GO TO D40B-EXIT.                                     @\n210250     IF TR-CHGB-YTD-CREDIT-UNION-X IS EQUAL TO SPACES             @\n210260         NEXT SENTENCE                                            @\n210270     ELSE                                                         @\n210280         IF TR-CHGB-YTD-CREDIT-UNION-X IS NUMERIC                 @\n210290             MOVE TR-CHGB-YTD-CREDIT-UNION-9 TO                   @\n210300                 PR-YTD-CREDIT-UNION                              @\n210310         ELSE                                                     @\n210320             MOVE 'INVALID YTD-CREDIT-UNION' TO                   @\n210330                 ER-TRAN-ERROR-MSG                                @\n210340             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n210350             GO TO D40B-EXIT.                                     @\n210360     IF TR-CHGB-YTD-UGF-X IS EQUAL TO SPACES                      @\n210370         NEXT SENTENCE                                            @\n210380     ELSE                                                         @\n210390         IF TR-CHGB-YTD-UGF-X IS NUMERIC                          @\n210400             MOVE TR-CHGB-YTD-UGF-9 TO                            @\n210410                 PR-YTD-UGF                                       @\n210420         ELSE                                                     @\n210430             MOVE 'INVALID YTD-UGF' TO                            @\n210440                 ER-TRAN-ERROR-MSG                                @\n210450             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n210460             GO TO D40B-EXIT.                                     @\n210470     IF TR-CHGB-YTD-CHILDREN-INS-X IS EQUAL TO SPACES             @\n210480         NEXT SENTENCE                                            @\n210490     ELSE                                                         @\n210500         IF TR-CHGB-YTD-CHILDREN-INS-X IS NUMERIC                 @\n210510             MOVE TR-CHGB-YTD-CHILDREN-INS-9 TO                   @\n210520                 PR-YTD-CHILDREN-INSURANCE                        @\n210530         ELSE                                                     @\n210540             MOVE 'INVALID YTD-CHILDREN-INSURANCE' TO             @\n210550                 ER-TRAN-ERROR-MSG                                @\n210560             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n210570             GO TO D40B-EXIT.                                     @\n210700     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n210800 D40B-EXIT. EXIT.                                                 @\n210900                                                                  @\n211000 D40C-PROCESS-CC.                                                 @\n211100     IF TR-CHGC-YTD-SPOUSE-INS-X IS EQUAL TO SPACES               @\n211200         NEXT SENTENCE                                            @\n211300     ELSE                                                         @\n211400         IF TR-CHGC-YTD-SPOUSE-INS-X IS NUMERIC                   @\n211500             MOVE TR-CHGC-YTD-SPOUSE-INS-9 TO                     @\n211600                 PR-YTD-SPOUSE-INSURANCE                          @\n211700         ELSE                                                     @\n211800             MOVE 'INVALID YTD-SPOUSE-INSURANCE' TO               @\n211900                 ER-TRAN-ERROR-MSG                                @\n212000             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212100             GO TO D40C-EXIT.                                     @\n212200     IF TR-CHGC-YTD-LTD-INSUR-X IS EQUAL TO SPACES                @\n212210         NEXT SENTENCE                                            @\n212220     ELSE                                                         @\n212230         IF TR-CHGC-YTD-LTD-INSUR-X IS NUMERIC                    @\n212240             MOVE TR-CHGC-YTD-LTD-INSUR-9 TO                      @\n212250                 PR-YTD-LTD-INSURANCE                             @\n212260         ELSE                                                     @\n212270             MOVE 'INVALID YTD-LTD-INSURANCE' TO                  @\n212280                 ER-TRAN-ERROR-MSG                                @\n212290             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212291             GO TO D40C-EXIT.                                     @\n212293     IF TR-CHGC-YTD-EMPLOYEE-ASS-X IS EQUAL TO SPACES             @\n212294         NEXT SENTENCE                                            @\n212295     ELSE                                                         @\n212296         IF TR-CHGC-YTD-EMPLOYEE-ASS-X IS NUMERIC                 @\n212297             MOVE TR-CHGC-YTD-EMPLOYEE-ASS-9 TO                   @\n212298                 PR-YTD-EMPLOYEE-ASSOC                            @\n212299         ELSE                                                     @\n212300             MOVE 'INVALID YTD-EMPLOYEE-ASSOC' TO                 @\n212301                 ER-TRAN-ERROR-MSG                                @\n212310             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212320             GO TO D40C-EXIT.                                     @\n212330     IF TR-CHGC-CUR-NONEL-PTO-TKN-X IS EQUAL TO SPACES            @\n212340         NEXT SENTENCE                                            @\n212350     ELSE                                                         @\n212360         IF TR-CHGC-CUR-NONEL-PTO-TKN-X IS NUMERIC                @\n212370             MOVE TR-CHGC-CUR-NONEL-PTO-TKN-9 TO                  @\n212380                 PR-CUR-NONELECTIVE-PTO-TAKEN                     @\n212390         ELSE                                                     @\n212400             MOVE 'INVALID CUR-NONELECTIVE-PTO-TKN' TO            @\n212410                 ER-TRAN-ERROR-MSG                                @\n212420             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212430             GO TO D40C-EXIT.                                     @\n212440     IF TR-CHGC-CUR-NONEL-PTO-BAL-X IS EQUAL TO SPACES            @\n212450         NEXT SENTENCE                                            @\n212460     ELSE                                                         @\n212470         IF TR-CHGC-CUR-NONEL-PTO-BAL-X IS NUMERIC                @\n212480             MOVE TR-CHGC-CUR-NONEL-PTO-BAL-9 TO                  @\n212490                 PR-CUR-NONELECTIVE-PTO-BALANCE                   @\n212500         ELSE                                                     @\n212510             MOVE 'INVALID CUR-NONELECTIVE-PTO-BALANCE' TO        @\n212520                 ER-TRAN-ERROR-MSG                                @\n212530             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212540             GO TO D40C-EXIT.                                     @\n212550     IF TR-CHGC-CUR-EL-PTO-TKN-X IS EQUAL TO SPACES               @\n212560         NEXT SENTENCE                                            @\n212570     ELSE                                                         @\n212580         IF TR-CHGC-CUR-EL-PTO-TKN-X IS NUMERIC                   @\n212590             MOVE TR-CHGC-CUR-EL-PTO-TKN-9 TO                     @\n212600                 PR-CUR-ELECTIVE-PTO-TAKEN                        @\n212610         ELSE                                                     @\n212620             MOVE 'INVALID CUR-EECTIVEL-PTO-TAKEN' TO             @\n212630                 ER-TRAN-ERROR-MSG                                @\n212640             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212650             GO TO D40C-EXIT.                                     @\n212660     IF TR-CHGC-CUR-EL-PTO-BOT-X IS EQUAL TO SPACES               @\n212670         NEXT SENTENCE                                            @\n212680     ELSE                                                         @\n212690         IF TR-CHGC-CUR-EL-PTO-BOT-X IS NUMERIC                   @\n212700             MOVE TR-CHGC-CUR-EL-PTO-BOT-9 TO                     @\n212710                 PR-CUR-ELECTIVE-PTO-BOUGHT                       @\n212720         ELSE                                                     @\n212730             MOVE 'INVALID CUR-ELECTIVE-PTO-BOUGH' TO             @\n212740                 ER-TRAN-ERROR-MSG                                @\n212750             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212760             GO TO D40C-EXIT.                                     @\n212770     IF TR-CHGC-CUR-EL-PTO-SOLD-X IS EQUAL TO SPACES              @\n212780         NEXT SENTENCE                                            @\n212790     ELSE                                                         @\n212800         IF TR-CHGC-CUR-EL-PTO-SOLD-X IS NUMERIC                  @\n212810             MOVE TR-CHGC-CUR-EL-PTO-SOLD-9 TO                    @\n212820                 PR-CUR-ELECTIVE-PTO-SOLD                         @\n212830         ELSE                                                     @\n212840             MOVE 'INVALID CUR-ELECTIVE-PTO-SOLD' TO              @\n212850                 ER-TRAN-ERROR-MSG                                @\n212860             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212870             GO TO D40C-EXIT.                                     @\n212880     IF TR-CHGC-CUR-EL-PTO-TAKEN-X IS EQUAL TO SPACES             @\n212890         NEXT SENTENCE                                            @\n212900     ELSE                                                         @\n212910         IF TR-CHGC-CUR-EL-PTO-TAKEN-X IS NUMERIC                 @\n212920             MOVE TR-CHGC-CUR-EL-PTO-TAKEN-9 TO                   @\n212930                 PR-CUR-ELECTIVE-PTO-TAKEN                        @\n212940         ELSE                                                     @\n212950             MOVE 'INVALID CUR-ELLECTIVE-PTO-TAKEN' TO            @\n212960                 ER-TRAN-ERROR-MSG                                @\n212970             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n212980             GO TO D40C-EXIT.                                     @\n212993     IF TR-CHGC-CUR-EL-PTO-BAL-X IS EQUAL TO SPACES               @\n213000         NEXT SENTENCE                                            @\n213010     ELSE                                                         @\n213020         IF TR-CHGC-CUR-EL-PTO-BAL-X IS NUMERIC                   @\n213030             MOVE TR-CHGC-CUR-EL-PTO-BAL-9 TO                     @\n213040                 PR-CUR-ELECTIVE-PTO-BALANCE                      @\n213050         ELSE                                                     @\n213060             MOVE 'INVALID CUR-ELECTIVE-PTO-BALAN' TO             @\n213070                 ER-TRAN-ERROR-MSG                                @\n213080             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n213090             GO TO D40C-EXIT.                                     @\n213200     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n213300 D40C-EXIT. EXIT.                                                 @\n213400                                                                  @\n213500 D40D-PROCESS-CD.                                                 @\n213600     IF TR-CHGD-YTD-NONEL-PTO-TKN-X IS EQUAL TO SPACES            @\n213700         NEXT SENTENCE                                            @\n213800     ELSE                                                         @\n213900         IF TR-CHGD-YTD-NONEL-PTO-TKN-X IS NUMERIC                @\n214000             MOVE TR-CHGD-YTD-NONEL-PTO-TKN-9 TO                  @\n214100                 PR-YTD-NONELECTIVE-PTO-TAKEN                     @\n214200         ELSE                                                     @\n214300             MOVE 'INVALID YTD-NONELECTIVE-PTO-TAKEN' TO          @\n214400                 ER-TRAN-ERROR-MSG                                @\n214500             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n214600             GO TO D40D-EXIT.                                     @\n214700     IF TR-CHGD-YTD-NONEL-PTO-BAL-X IS EQUAL TO SPACES            @\n214710         NEXT SENTENCE                                            @\n214720     ELSE                                                         @\n214730         IF TR-CHGD-YTD-NONEL-PTO-BAL-X IS NUMERIC                @\n214740             MOVE TR-CHGD-YTD-NONEL-PTO-BAL-9 TO                  @\n214750                 PR-YTD-NONELECTIVE-PTO-BALANCE                   @\n214760         ELSE                                                     @\n214770             MOVE 'INVALID YTD-NONEECTIVEL-PTO-BALANCE' TO        @\n214780                 ER-TRAN-ERROR-MSG                                @\n214790             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n214791             GO TO D40D-EXIT.                                     @\n214793     IF TR-CHGD-YTD-EL-PTO-TKN-X IS EQUAL TO SPACES               @\n214794         NEXT SENTENCE                                            @\n214795     ELSE                                                         @\n214796         IF TR-CHGD-YTD-EL-PTO-TKN-X IS NUMERIC                   @\n214797             MOVE TR-CHGD-YTD-EL-PTO-TKN-9 TO                     @\n214798                 PR-YTD-ELECTIVE-PTO-TAKEN                        @\n214799         ELSE                                                     @\n214800             MOVE 'INVALID YTD-ELECTIVE-PTO-TAKEN' TO             @\n214801                 ER-TRAN-ERROR-MSG                                @\n214810             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n214820             GO TO D40D-EXIT.                                     @\n214830     IF TR-CHGD-YTD-EL-PTO-BOT-X IS EQUAL TO SPACES               @\n214840         NEXT SENTENCE                                            @\n214850     ELSE                                                         @\n214860         IF TR-CHGD-YTD-EL-PTO-BOT-X IS NUMERIC                   @\n214870             MOVE TR-CHGD-YTD-EL-PTO-BOT-9 TO                     @\n214880                 PR-YTD-ELECTIVE-PTO-BOUGHT                       @\n214890         ELSE                                                     @\n214900             MOVE 'INVALID YTD-ELECTIVE-PTO-BOUGHT' TO            @\n214910                 ER-TRAN-ERROR-MSG                                @\n214920             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n214930             GO TO D40D-EXIT.                                     @\n214940     IF TR-CHGD-YTD-EL-PTO-SOLD-X IS EQUAL TO SPACES              @\n214950         NEXT SENTENCE                                            @\n214960     ELSE                                                         @\n214970         IF TR-CHGD-YTD-EL-PTO-SOLD-X IS NUMERIC                  @\n214980             MOVE TR-CHGD-YTD-EL-PTO-SOLD-9 TO                    @\n214990                 PR-YTD-ELECTIVE-PTO-SOLD                         @\n215000         ELSE                                                     @\n215010             MOVE 'INVALID YTD-ELECTIVE-PTO-SOLD' TO              @\n215020                 ER-TRAN-ERROR-MSG                                @\n215030             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n215040             GO TO D40D-EXIT.                                     @\n215050     IF TR-CHGD-YTD-EL-PTO-TKN-X IS EQUAL TO SPACES               @\n215060         NEXT SENTENCE                                            @\n215070     ELSE                                                         @\n215080         IF TR-CHGD-YTD-EL-PTO-TKN-X IS NUMERIC                   @\n215090             MOVE TR-CHGD-YTD-EL-PTO-TKN-9 TO                     @\n215100                 PR-YTD-ELECTIVE-PTO-TAKEN                        @\n215110         ELSE                                                     @\n215120             MOVE 'INVALID YTD-ELECTIVE-PTO-TAKEN' TO             @\n215130                 ER-TRAN-ERROR-MSG                                @\n215140             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n215150             GO TO D40D-EXIT.                                     @\n215160     IF TR-CHGD-YTD-EL-PTO-BAL-X IS EQUAL TO SPACES               @\n215170         NEXT SENTENCE                                            @\n215180     ELSE                                                         @\n215190         IF TR-CHGD-YTD-EL-PTO-BAL-X IS NUMERIC                   @\n215200             MOVE TR-CHGD-YTD-EL-PTO-BAL-9 TO                     @\n215210                 PR-YTD-ELECTIVE-PTO-BALANCE                      @\n215220         ELSE                                                     @\n215230             MOVE 'INVALID YTD-ELECTIVE-PTO-BALANCE' TO           @\n215240                 ER-TRAN-ERROR-MSG                                @\n215250             PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT       @\n215260             GO TO D40D-EXIT.                                     @\n215400     MOVE 'N' TO WS-CHANGE-ERROR-INDICATOR.                       @\n215500 D40D-EXIT. EXIT.                                                 @\n215600                                                                  @\n215700 E100-WRITE-ERROR-REPORT.                                         @\n215800     WRITE ERROR-LINE AFTER ADVANCING 1 LINE.                     @\n215900     ADD +1 TO WS-ERROR-RECORDS-WRITTEN.                          @\n216000 E100-EXIT. EXIT.                                                 @\n216100                                                                  @\n216200 T100-READ-TRANSACTION-FILE.                                      @\n216300     IF WS-TRAN-RECORD-ALREADY-READ                               @\n216400         MOVE 'N' TO WS-TRAN-RECORD-READ-SWITCH                   @\n216500         GO TO T100-EXIT.                                         @\n216600     READ TRANSACTION-FILE                                        @\n216700         AT END                                                   @\n216800             MOVE 'Y' TO WS-END-OF-TRANFILE-SWITCH                @\n216900             GO TO T100-EXIT.                                     @     30\n217000     ADD +1 TO WS-TRANSACTIONS-READ.                              @     30\n217100 T100-EXIT. EXIT.                                                 @\n217200                                                                  @\n217300 T200-READ-PAYROLL-MASTER.                                        @\n217400     MOVE 'S' TO WS-ERROR-INDICATOR                               @\n217500     READ PAYROLL-MASTER-FILE.                                    @\n217600     IF WS-VSAM-SUCCESSFUL OR                                     @\n217700         WS-DUPLICATE-KEY-OK OR                                   @\n217800         WS-LENGTH-DIFF-OK OR                                     @\n217900         WS-RECD-NOT-FOUND                                        @\n218000         ADD +1 TO WS-PAYROLL-RECORDS-READ                        @\n218100     ELSE                                                         @\n218200         MOVE 'PAYROLL FILE READ FAILED:' TO                      @\n218300             ER-TRAN-ERROR-MSG                                    @\n218400         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n218500         PERFORM X100-VSAM-ERRORS THRU X100-EXIT                  @\n218600         MOVE 'F' TO WS-ERROR-INDICATOR.                          @\n218700 T200-EXIT. EXIT.                                                 @\n218800                                                                  @\n218900 T300-WRITE-PAYROLL-MASTER.                                       @\n219000     MOVE 'S' TO WS-ERROR-INDICATOR.                              @\n219100     IF WS-VERIFY-RUN GO TO T300-EXIT.                            @\n219200     WRITE PAYROLL-RECORD.                                        @\n219300     IF WS-VSAM-SUCCESSFUL OR WS-DUPLICATE-KEY-OK                 @\n219400         ADD +1 TO WS-PAYROLL-RECORDS-WRITTEN                     @\n219500     ELSE                                                         @\n219600         MOVE 'PAYROLL FILE WRITE FAILED:' TO                     @\n219700             ER-TRAN-ERROR-MSG                                    @\n219800         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n219900         PERFORM X100-VSAM-ERRORS THRU X100-EXIT                  @\n220000         MOVE 'F' TO WS-ERROR-INDICATOR.                          @\n220100 T300-EXIT. EXIT.                                                 @\n220200                                                                  @\n220300 T400-UPDATE-PAYROLL-MASTER.                                      @\n220400     MOVE 'S' TO WS-ERROR-INDICATOR                               @\n220500     IF WS-VERIFY-RUN GO TO T400-EXIT.                            @\n220600     REWRITE PAYROLL-RECORD.                                      @\n220700     IF WS-VSAM-SUCCESSFUL                                        @\n220800         ADD +1 TO WS-PAYROLL-RECORDS-UPDATED                     @\n220900     ELSE                                                         @\n221000         MOVE 'PAYROLL FILE REWRITE FAILED:' TO                   @\n221100             ER-TRAN-ERROR-MSG                                    @\n221200         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n221300         PERFORM X100-VSAM-ERRORS THRU X100-EXIT                  @\n221400         MOVE 'F' TO WS-ERROR-INDICATOR.                          @\n221500 T400-EXIT. EXIT.                                                 @\n221600                                                                  @\n221700 T500-DELETE-PAYROLL-MASTER.                                      @\n221800     MOVE 'S' TO WS-ERROR-INDICATOR                               @\n221900     IF WS-VERIFY-RUN GO TO T500-EXIT.                            @\n222000     IF PR-ACTIVE-RECORD                                          @\n222100         MOVE 'D' TO PR-STATUS-INDICATOR                          @\n222200         REWRITE PAYROLL-RECORD                                   @\n222300         IF WS-VSAM-SUCCESSFUL                                    @\n222400             ADD +1 TO WS-PAYROLL-RECORDS-MARKED                  @\n222500         ELSE                                                     @\n222600             NEXT SENTENCE                                        @\n222700     ELSE                                                         @\n222800         DELETE PAYROLL-MASTER-FILE RECORD                        @\n222900         IF WS-VSAM-SUCCESSFUL                                    @\n223000             ADD +1 TO WS-PAYROLL-RECORDS-DELETED.                @\n223100     IF WS-VSAM-SUCCESSFUL                                        @\n223200         NEXT SENTENCE                                            @\n223300     ELSE                                                         @\n223400         MOVE 'PAYROLL FILE DELETE FAILED:' TO                    @\n223500             ER-TRAN-ERROR-MSG                                    @\n223600         PERFORM X500-TRANSACTION-ERRORS THRU X500-EXIT           @\n223700         PERFORM X100-VSAM-ERRORS THRU X100-EXIT                  @\n223800         MOVE 'F' TO WS-ERROR-INDICATOR.                          @\n223900 T500-EXIT. EXIT.                                                 @\n224000                                                                  @\n224100 X100-VSAM-ERRORS.                                                @\n224200     MOVE 'N' TO WS-ERROR-INDICATOR.                              @\n224300     PERFORM X200-SEARCH-VSAM-ERROR-TABLE                         @\n224400         VARYING IX FROM 1 BY 1 UNTIL                             @\n224500         WS-OPERATION-FAILED.                                     @\n224600     MOVE WS-VSAM-FILE-STATUS TO ER-VSAM-STATUS-CODE.             @\n224700     MOVE WS-VSAM-ERROR-MESSAGE(IX) TO ER-VSAM-MSG.               @\n224800     MOVE  'VSAM FILE STATUS=' TO ER-VSAM-LIT1.                   @\n224900     MOVE ': ' TO ER-VSAM-LIT2.                                   @\n225000     MOVE '1' TO ER-CC.                                           @\n225100     PERFORM E100-WRITE-ERROR-REPORT THRU E100-EXIT.              @\n225200 X100-EXIT. EXIT.                                                 @\n225300                                                                  @\n225400 X200-SEARCH-VSAM-ERROR-TABLE.                                    @\n225500     IF WS-VSAM-ERROR-CODE(IX) = WS-VSAM-FILE-STATUS OR ' '       @\n225600     MOVE 'Y' TO WS-ERROR-INDICATOR.                              @\n225700 X200-EXIT. EXIT.                                                 @\n225800                                                                  @\n225900 X500-TRANSACTION-ERRORS.                                         @\n226000     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 2 LINES.        @\n226100     MOVE TRANSACTION-RECORD TO ER-TRAN-RECORD.                   @\n226200     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 1 LINE.         @\n226300     MOVE SPACES TO ERROR-LINE.                                   @\n226400 X500-EXIT. EXIT.                                                 @\n226500                                                                  @\n226600 X510-TRANSACTION-SEQUENCE-ERR.                                   @\n226700     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 2 LINES.        @\n226800     MOVE 'FOLLOWING TRANSACTIONS WERE DROPPED:' TO               @\n226900         ER-TRAN-ERROR-MSG.                                       @\n227000     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 1 LINE.         @\n227100     MOVE WS-HOLD-ADD1 TO ER-TRAN-RECORD.                         @\n227200     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 1 LINE.         @\n227300     IF WS-HELD-ADDS = 1                                          @\n227400         GO TO X510-EXIT.                                         @\n227500     MOVE WS-HOLD-ADD2 TO ER-TRAN-RECORD.                         @\n227600     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 1 LINE.         @\n227700     IF WS-HELD-ADDS = 2                                          @\n227800         GO TO X510-EXIT.                                         @\n227900     MOVE WS-HOLD-ADD3 TO ER-TRAN-RECORD.                         @\n228000     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 1 LINE.         @\n228100     IF WS-HELD-ADDS = 3                                          @\n228200         GO TO X510-EXIT.                                         @\n228300     MOVE WS-HOLD-ADD4 TO ER-TRAN-RECORD.                         @\n228400     WRITE ERROR-TRANSACTION-LINE AFTER ADVANCING 1 LINE.         @\n228500     IF WS-HELD-ADDS = 1                                          @\n228600         GO TO X510-EXIT.                                         @\n228700 X510-EXIT.                                                       @\n228800     MOVE SPACES TO ERROR-LINE.                                   @\n228900     EXIT.                                                        @\n229000                                                                  @\n229100 Y100-PRINT-A-LINE.                                               @\n229200     WRITE TRANSACTION-LINE AFTER ADVANCING WS-LINE-SPACING.      @\n229300     ADD WS-LINE-SPACING TO WS-LINE-COUNT.                        @\n229400     IF WS-LINE-COUNT IS GREATER THAN 60                          @\n229500         PERFORM Y200-PRINT-HEADING THRU Y200-EXIT.               @\n229600 Y100-EXIT. EXIT.                                                 @\n229700                                                                  @\n229800 Y200-PRINT-HEADING.                                              @\n229900     ADD +1 TO WS-PAGE-NUMBER.                                    @\n230000     MOVE WS-PAGE-NUMBER TO WS-HEADING-PAGE-NUMBER.               @\n230100     MOVE WS-HEADING-LINE-1 TO TRANSACTION-LINE.                  @\n230200     WRITE TRANSACTION-LINE AFTER ADVANCING PAGE.                 @\n230300     MOVE 2 TO WS-LINE-COUNT.                                     @\n230400     MOVE SPACES TO TRANSACTION-LINE.                             @\n230500 Y200-EXIT. EXIT.                                                 @\n230600                                                                  @\n230700 Z100-END-OF-PROCESSING.                                          @\n230800     MOVE 'INPUT RECORDS READ' TO TL-EOJ-COUNT-NAME.              @     20\n230900     MOVE WS-TRANSACTIONS-READ TO TL-EOJ-COUNTER.                 @     30\n231000     PERFORM Y100-PRINT-A-LINE THRU Y100-EXIT.                    @\n231100     MOVE 'OUTPUT RECORDS WRITTEN' TO TL-EOJ-COUNT-NAME.          @     20\n231200     MOVE WS-ERROR-RECORDS-WRITTEN TO TL-EOJ-COUNTER.             @\n231300     PERFORM Y100-PRINT-A-LINE THRU Y100-EXIT.                    @\n231400     CLOSE TRANSACTION-FILE,                                      @\n231500           ERROR-REPORT,                                          @\n231600           TRANSACTION-REPORT,                                    @\n231700           PAYROLL-MASTER-FILE.                                   @\n231800 Z100-EXIT. EXIT.                                                 @\n./ ADD NAME=PAYRECF  0106-01289-01296-1310-00142-00144-00000-BC0THOR\n000100*****************************************************************\n000200* VSAM PAYROLL FILE RECORD DESCRIPTOR FOR COBOL CLASS PROGRAMS. *\n000300* KEY IS SOCIAL SECURITY NUMBER IN POSITIONS 2-10               *\n000400* FIRST BYTE OF RECORD IS USED AS A DELETED RECORD INDICATOR.   *\n000500* THIS DATA RECORD IS 564 BYTES LONG.                           *\n000600*****************************************************************\n000700 01  PAYROLL-RECORD.\n000800     05  PR-STATUS-INDICATOR                PIC X.\n000900         88  PR-ACTIVE-RECORD                 VALUE 'A'.\n001000         88  PR-DELETED-RECORD                VALUE 'D'.\n001100     05  PR-SOCIAL-SECURITY-NBR             PIC X(9).\n001200     05  PR-EMPLOYEE-NAME.\n001300         10  PR-LAST-NAME                   PIC X(12).\n001400         10  PR-FIRST-NAME                  PIC X(12).\n001500         10  PR-INITIAL                     PIC X.\n001600         10  PR-NAME-SUFFIX                 PIC XXX.\n001700     05  PR-ADDRESS-LINE-1                  PIC X(25).\n001800     05  PR-ADDRESS-LINE-2                  PIC X(25).\n001900     05  PR-CITY                            PIC X(24).\n002000     05  PR-STATE                           PIC XX.\n002100     05  PR-ZIP-5                           PIC X(5).\n002200     05  PR-ZIP-LAST4                       PIC X(4).\n002300     05  PR-EMPLOYEE-TYPE                   PIC X.\n002400         88  PR-SALARIED                      VALUE 'S'.\n002500         88  PR-HOURLY                        VALUE 'H'.\n002600         88  PR-PART-TIME                     VALUE 'P'.\n002610         88  PR-CONTRACTOR                    VALUE 'C'.\n002700     05  PR-JOB-TITLE                       PIC X(35).\n002800     05  PR-DEPARTMENT                      PIC X(20).\n002801     05  PR-LOCATION                        PIC X(20).\n002802     05  PR-COST-CENTER                     PIC XX.\n002803     05  PR-EARNINGS.\n002810         10  PR-SEMI-MONTHLY-SALARY         PIC S9(7)V99\n002820                                              COMP-3.\n002900         10  FILLER REDEFINES PR-SEMI-MONTHLY-SALARY.\n003000             15  FILLER                     PIC XX.\n003100             15  PR-HOURLY-RATE             PIC S9(3)V99\n003200                                              COMP-3.\n003300     05  PR-TAX-DATA.\n003310         10  PR-EXEMPTIONS.\n003400             15  PR-STATE-EXEMPTION         PIC S99 COMP-3.\n003500             15  PR-FED-EXEMPTION           PIC S99 COMP-3.\n003600         10  PR-FILING-STATUS               PIC X.\n003700             88  PR-SINGLE                    VALUE 'U'.\n003800             88  PR-HEAD-OF-HOUSEHOLD         VALUE 'H'.\n003900             88  PR-MARRIED-JOINT             VALUE 'J'.\n004000             88  PR-MARRIED-SEPARATE          VALUE 'S'.\n004010     05  PR-BEFORE-TAX-DEDUCTIONS           COMP-3.\n004011         10  PR-HEALTH-INSURANCE            PIC S9(3)V99.\n004012         10  PR-DENTAL-INSURANCE            PIC S9(3)V99.\n004020         10  PR-THRIFT-PLAN-PERCENT         PIC S99V9.\n004030         10  PR-HEALTH-CARE-FLEX            PIC S9(5)V99.\n004040         10  PR-CHILD-CARE-FLEX             PIC S9(5)V99.\n004100     05  PR-AFTER-TAX-DEDUCTIONS            COMP-3.\n004400         10  PR-CREDIT-UNION                PIC S9(7)V99.\n004500         10  PR-UGF                         PIC S9(5)V99.\n004600         10  PR-CHILDREN-INSURANCE          PIC S9(3)V99.\n004700         10  PR-SPOUSE-INSURANCE            PIC S9(3)V99.\n004800         10  PR-SUPPLEMENTAL-LIFE           PIC S9(3)V99.\n004900         10  PR-LONG-TERM-DISABILITY        PIC S9(3)V99.\n005000         10  PR-EMPLOYEE-ASSOCIATION        PIC S9V99.\n005300     05  PR-TAXABLE-IMPUTED-INCOME          PIC S9(5)V99 COMP-3.\n005400     05  PR-NONELECTIVE-PTO                 COMP-3.\n005500         10  PR-NONELECTIVE-PTO-CARRYOVER   PIC S99V99.\n005600         10  PR-NONELECTIVE-PTO-ALLOTTED    PIC S99V99.\n005700         10  PR-NONELECTIVE-PTO-TAKEN       PIC S99V99.\n005710     05  PR-ELECTIVE-PTO                    COMP-3.\n005720         10  PR-ELECTIVE-PTO-ALLOTTED       PIC S99V99.\n005730         10  PR-ELECTIVE-PTO-BOUGHT         PIC S99V99.\n005740         10  PR-ELECTIVE-PTO-SOLD           PIC S99V99.\n005750         10  PR-ELECTIVE-PTO-TAKEN          PIC S99V99.\n005800     05  PR-CURRENT-EARNINGS                COMP-3.\n005900         10  PR-CUR-REGULAR-EARNINGS        PIC S9(7)V99.\n006000         10  PR-CUR-HOLIDAY-EARNINGS        PIC S9(5)V99.\n006100         10  PR-CUR-PTO-EARNINGS            PIC S9(5)V99.\n006200         10  PR-CUR-FLEX-DOLLARS            PIC S9(5)V99.\n006300         10  PR-CUR-HEALTHY-RETURNS         PIC S9(5)V99.\n006400         10  PR-CUR-MEDICAL-WAIVED          PIC S9(5)V99.\n006500         10  PR-CUR-BONUS                   PIC S9(5)V99.\n006600         10  PR-CUR-UGF-BONUS               PIC S9(5)V99.\n006700         10  PR-CUR-FLOATING-HOLIDAY        PIC S9(5)V99.\n006710     05  PR-YTD-EARNINGS                    COMP-3.\n006720         10  PR-YTD-REGULAR-EARNINGS        PIC S9(7)V99.\n006730         10  PR-YTD-HOLIDAY-EARNINGS        PIC S9(5)V99.\n006740         10  PR-YTD-PTO-EARNINGS            PIC S9(5)V99.\n006750         10  PR-YTD-FLEX-DOLLARS            PIC S9(5)V99.\n006760         10  PR-YTD-HEALTHY-RETURNS         PIC S9(5)V99.\n006770         10  PR-YTD-MEDICAL-WAIVED          PIC S9(5)V99.\n006780         10  PR-YTD-BONUS                   PIC S9(5)V99.\n006790         10  PR-YTD-UGF-BONUS               PIC S9(5)V99.\n006791         10  PR-YTD-FLOATING-HOLIDAY        PIC S9(5)V99.\n006800     05  PR-CURRENT-TAXES                   COMP-3.\n006900         10  PR-CUR-FED-TAX                 PIC S9(7)V99.\n007000         10  PR-CUR-FICA-MHI                PIC S9(5)V99.\n007100         10  PR-CUR-OASDI                   PIC S9(5)V99.\n007200         10  PR-CUR-STATE-TAX               PIC S9(5)V99.\n007210     05  PR-YTD-TAXES                       COMP-3.\n007220         10  PR-YTD-FED-TAX                 PIC S9(7)V99.\n007230         10  PR-YTD-FICA-MHI                PIC S9(5)V99.\n007240         10  PR-YTD-OASDI                   PIC S9(5)V99.\n007250         10  PR-YTD-STATE-TAX               PIC S9(5)V99.\n007300     05  PR-CURRENT-B4-TAX-DEDUCTIONS   COMP-3.\n007400         10  PR-CUR-THRIFT-PLAN             PIC S9(5)V99.\n007500         10  PR-CUR-MEDICAL-INSURANCE       PIC S9(5)V99.\n007600         10  PR-CUR-DENTAL-INSURANCE        PIC S9(5)V99.\n007700         10  PR-CUR-HEALTH-CARE-FLEX        PIC S9(5)V99.\n007800         10  PR-CUR-CHILD-CARE-FLEX         PIC S9(5)V99.\n007810     05  PR-YTD-BEFORE-TAX-DEDUCTIONS COMP-3.\n007820         10  PR-YTD-THRIFT-PLAN             PIC S9(5)V99.\n007830         10  PR-YTD-MEDICAL-INSURANCE       PIC S9(5)V99.\n007840         10  PR-YTD-DENTAL-INSURANCE        PIC S9(5)V99.\n007850         10  PR-YTD-HEALTH-CARE-FLEX        PIC S9(5)V99.\n007860         10  PR-YTD-CHILD-CARE-FLEX         PIC S9(5)V99.\n007870     05  PR-CURRENT-AFTR-TAX-DEDUCTIONS    COMP-3.\n007900         10  PR-CUR-CREDIT-UNION            PIC S9(5)V99.\n008000         10  PR-CUR-UGF                     PIC S9(5)V99.\n008100         10  PR-CUR-CHILDREN-INSURANCE      PIC S9(5)V99.\n008200         10  PR-CUR-SPOUSE-INSURANCE        PIC S9(5)V99.\n008300         10  PR-CUR-LTD-INSURANCE           PIC S9(5)V99.\n008400         10  PR-CUR-EMPLOYEE-ASSOC          PIC S9(5)V99.\n008410     05  PR-YTD-AFTER-TAX-DEDUCTIONS COMP-3.\n008420         10  PR-YTD-CREDIT-UNION            PIC S9(5)V99.\n008430         10  PR-YTD-UGF                     PIC S9(5)V99.\n008440         10  PR-YTD-CHILDREN-INSURANCE      PIC S9(5)V99.\n008450         10  PR-YTD-SPOUSE-INSURANCE        PIC S9(5)V99.\n008460         10  PR-YTD-LTD-INSURANCE           PIC S9(5)V99.\n008470         10  PR-YTD-EMPLOYEE-ASSOC          PIC S9(5)V99.\n008500     05  PR-CURRENT-PTO                     COMP-3.\n008600         10  PR-CUR-NONELECTIVE-PTO-TAKEN   PIC S999V99.\n008700         10  PR-CUR-NONELECTIVE-PTO-BALANCE PIC S999V99.\n008800         10  PR-CUR-ELECTIVE-PTO-TAKEN      PIC S999V99.\n008900         10  PR-CUR-ELECTIVE-PTO-BOUGHT     PIC S999V99.\n008910         10  PR-CUR-ELECTIVE-PTO-SOLD       PIC S999V99.\n008930         10  PR-CUR-ELECTIVE-PTO-BALANCE    PIC S999V99.\n008940     05  PR-YTD-PTO                         COMP-3.\n008950         10  PR-YTD-NONELECTIVE-PTO-TAKEN   PIC S999V99.\n008960         10  PR-YTD-NONELECTIVE-PTO-BALANCE PIC S999V99.\n008970         10  PR-YTD-ELECTIVE-PTO-TAKEN      PIC S999V99.\n008980         10  PR-YTD-ELECTIVE-PTO-BOUGHT     PIC S999V99.\n008990         10  PR-YTD-ELECTIVE-PTO-SOLD       PIC S999V99.\n008992         10  PR-YTD-ELECTIVE-PTO-BALANCE    PIC S999V99.\n009000     05  PR-FILLER                          PIC X(57).\n./ ADD NAME=REL4000C 0101-01302-01302-1141-00080-00080-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. REL4000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000     SELECT INVMASTS ASSIGN TO INVMASTS.\n001100     SELECT INVMASTR ASSIGN TO INVMASTR\n001200                     ORGANIZATION IS RELATIVE\n001300                     ACCESS IS RANDOM\n001400                     RELATIVE KEY IS INVMASTR-RR-NUMBER.\n001500*\n001600 DATA DIVISION.\n001700*\n001800 FILE SECTION.\n001900*\n002000 FD  INVMASTS.\n002100*\n002200 01  SEQUENTIAL-RECORD-AREA  PIC X(70).\n002300*\n002400 FD  INVMASTR.\n002500*\n002600 01  RELATIVE-RECORD-AREA    PIC X(70).\n002700*\n002800 WORKING-STORAGE SECTION.\n002900*\n003000 01  SWITCHES.\n003100     05  INVMAST-EOF-SWITCH      PIC X    VALUE \"N\".\n003200         88  INVMAST-EOF                  VALUE \"Y\".\n003300*\n003400 01  KEY-FIELDS.\n003500     05  INVMASTR-RR-NUMBER      PIC 9(5).\n003600*\n003700 01  INVENTORY-MASTER-RECORD.\n003800     05  IM-ITEM-NO              PIC X(5).\n003900     05  IM-DESCRIPTIVE-DATA.\n004000         10  IM-ITEM-DESC        PIC X(40).\n004100         10  IM-UNIT-COST        PIC S9(3)V99.\n004200         10  IM-UNIT-PRICE       PIC S9(3)V99.\n004300     05  IM-INVENTORY-DATA.\n004400         10  IM-REORDER-POINT    PIC S9(5).\n004500         10  IM-ON-HAND          PIC S9(5).\n004600         10  IM-ON-ORDER         PIC S9(5).\n004700*\n004800 PROCEDURE DIVISION.\n004900*\n005000 000-CREATE-INVENTORY-FILE.\n005100*\n005200     OPEN INPUT  INVMASTS\n005300          OUTPUT INVMASTR.\n005400     PERFORM 100-CREATE-INVENTORY-RECORD\n005500         UNTIL INVMAST-EOF.\n005600     CLOSE INVMASTS\n005700           INVMASTR.\n005800     STOP RUN.\n005900*\n006000 100-CREATE-INVENTORY-RECORD.\n006100*\n006200     PERFORM 110-READ-SEQUENTIAL-RECORD.\n006300     IF NOT INVMAST-EOF\n006400         PERFORM 120-WRITE-RELATIVE-RECORD.\n006500*\n006600 110-READ-SEQUENTIAL-RECORD.\n006700*\n006800     READ INVMASTS INTO INVENTORY-MASTER-RECORD\n006900         AT END\n007000             MOVE \"Y\" TO INVMAST-EOF-SWITCH.\n007100*\n007200 120-WRITE-RELATIVE-RECORD.\n007300*\n007400     COMPUTE INVMASTR-RR-NUMBER =\n007500         FUNCTION NUMVAL (IM-ITEM-NO) - 10000.\n007600     WRITE RELATIVE-RECORD-AREA FROM INVENTORY-MASTER-RECORD\n007700         INVALID KEY\n007800             DISPLAY \"WRITE ERROR ON INVMASTR FOR ITEM NUMBER \"\n007900                 IM-ITEM-NO\n008000             MOVE \"Y\" TO INVMAST-EOF-SWITCH.\n./ ADD NAME=RPT1000C 0101-01302-01302-1142-00177-00177-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. RPT1000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000*\n001100     SELECT CUSTMAST ASSIGN TO CUSTMAST.\n001200     SELECT SALESRPT ASSIGN TO SALESRPT.\n001300*\n001400 DATA DIVISION.\n001500*\n001600 FILE SECTION.\n001700*\n001800 FD  CUSTMAST.\n001900*\n002000 01  CUSTOMER-MASTER-RECORD.\n002100     05  CM-BRANCH-NUMBER        PIC 9(2).\n002200     05  CM-SALESREP-NUMBER      PIC 9(2).\n002300     05  CM-CUSTOMER-NUMBER      PIC 9(5).\n002400     05  CM-CUSTOMER-NAME        PIC X(20).\n002500     05  CM-SALES-THIS-YTD       PIC S9(5)V9(2).\n002600     05  CM-SALES-LAST-YTD       PIC S9(5)V9(2).\n002700*\n002800 FD  SALESRPT.\n002900*\n003000 01  PRINT-AREA      PIC X(132).\n003100*\n003200 WORKING-STORAGE SECTION.\n003300*\n003400 01  SWITCHES.\n003500     05  CUSTMAST-EOF-SWITCH     PIC X    VALUE \"N\".\n003600*\n003700 01  PRINT-FIELDS.\n003800     05  PAGE-COUNT      PIC S9(3)   VALUE ZERO.\n003900     05  LINES-ON-PAGE   PIC S9(3)   VALUE +55.\n004000     05  LINE-COUNT      PIC S9(3)   VALUE +99.\n004100     05  SPACE-CONTROL   PIC S9.\n004200*\n004300 01  TOTAL-FIELDS.\n004400     05  GRAND-TOTAL-THIS-YTD   PIC S9(7)V99   VALUE ZERO.\n004500     05  GRAND-TOTAL-LAST-YTD   PIC S9(7)V99   VALUE ZERO.\n004600*\n004700 01  CURRENT-DATE-AND-TIME.\n004800     05  CD-YEAR         PIC 9999.\n004900     05  CD-MONTH        PIC 99.\n005000     05  CD-DAY          PIC 99.\n005100     05  CD-HOURS        PIC 99.\n005200     05  CD-MINUTES      PIC 99.\n005300     05  FILLER          PIC X(9).\n005400*\n005500 01  HEADING-LINE-1.\n005600     05  FILLER          PIC X(7)    VALUE \"DATE:  \".\n005700     05  HL1-MONTH       PIC 9(2).\n005800     05  FILLER          PIC X(1)    VALUE \"/\".\n005900     05  HL1-DAY         PIC 9(2).\n006000     05  FILLER          PIC X(1)    VALUE \"/\".\n006100     05  HL1-YEAR        PIC 9(4).\n006200     05  FILLER          PIC X(11)   VALUE SPACE.\n006300     05  FILLER          PIC X(20)   VALUE \"YEAR-TO-DATE SALES R\".\n006400     05  FILLER          PIC X(20)   VALUE \"EPORT               \".\n006500     05  FILLER          PIC X(8)    VALUE \"  PAGE: \".\n006600     05  HL1-PAGE-NUMBER PIC ZZZ9.\n006700     05  FILLER          PIC X(52)   VALUE SPACE.\n006800*\n006900 01  HEADING-LINE-2.\n007000     05  FILLER          PIC X(7)    VALUE \"TIME:  \".\n007100     05  HL2-HOURS       PIC 9(2).\n007200     05  FILLER          PIC X(1)    VALUE \":\".\n007300     05  HL2-MINUTES     PIC 9(2).\n007400     05  FILLER          PIC X(58)   VALUE SPACE.\n007500     05  FILLER          PIC X(10)   VALUE \"RPT1000\".\n007600     05  FILLER          PIC X(52)   VALUE SPACE.\n007700*\n007800 01  HEADING-LINE-3.\n007900     05  FILLER      PIC X(20)   VALUE \"CUST                \".\n008000     05  FILLER      PIC X(20)   VALUE \"            SALES   \".\n008100     05  FILLER      PIC X(20)   VALUE \"      SALES         \".\n008200     05  FILLER      PIC X(72)   VALUE SPACE.\n008300*\n008400 01  HEADING-LINE-4.\n008500     05  FILLER      PIC X(20)   VALUE \"NUM    CUSTOMER NAME\".\n008600     05  FILLER      PIC X(20)   VALUE \"           THIS YTD \".\n008700     05  FILLER      PIC X(20)   VALUE \"     LAST YTD       \".\n008800     05  FILLER      PIC X(72)   VALUE SPACE.\n008900*\n009000 01  CUSTOMER-LINE.\n009100     05  CL-CUSTOMER-NUMBER  PIC 9(5).\n009200     05  FILLER              PIC X(2)     VALUE SPACE.\n009300     05  CL-CUSTOMER-NAME    PIC X(20).\n009400     05  FILLER              PIC X(3)     VALUE SPACE.\n009500     05  CL-SALES-THIS-YTD   PIC ZZ,ZZ9.99-.\n009600     05  FILLER              PIC X(4)     VALUE SPACE.\n009700     05  CL-SALES-LAST-YTD   PIC ZZ,ZZ9.99-.\n009800     05  FILLER              PIC X(78)    VALUE SPACE.\n009900*\n010000 01  GRAND-TOTAL-LINE.\n010100     05  FILLER              PIC X(27)    VALUE SPACE.\n010200     05  GTL-SALES-THIS-YTD  PIC Z,ZZZ,ZZ9.99-.\n010300     05  FILLER              PIC X(1)     VALUE SPACE.\n010400     05  GTL-SALES-LAST-YTD  PIC Z,ZZZ,ZZ9.99-.\n010500     05  FILLER              PIC X(78)    VALUE SPACE.\n010600*\n010700 PROCEDURE DIVISION.\n010800*\n010900 000-PREPARE-SALES-REPORT.\n011000*\n011100     OPEN INPUT  CUSTMAST\n011200          OUTPUT SALESRPT.\n011300     PERFORM 100-FORMAT-REPORT-HEADING.\n011400     PERFORM 200-PREPARE-SALES-LINES\n011500         UNTIL CUSTMAST-EOF-SWITCH = \"Y\".\n011600     PERFORM 300-PRINT-GRAND-TOTALS.\n011700     CLOSE CUSTMAST\n011800           SALESRPT.\n011900     STOP RUN.\n012000*\n012100 100-FORMAT-REPORT-HEADING.\n012200*\n012300     MOVE FUNCTION CURRENT-DATE TO CURRENT-DATE-AND-TIME.\n012400     MOVE CD-MONTH   TO HL1-MONTH.\n012500     MOVE CD-DAY     TO HL1-DAY.\n012600     MOVE CD-YEAR    TO HL1-YEAR.\n012700     MOVE CD-HOURS   TO HL2-HOURS.\n012800     MOVE CD-MINUTES TO HL2-MINUTES.\n012900*\n013000 200-PREPARE-SALES-LINES.\n013100*\n013200     PERFORM 210-READ-CUSTOMER-RECORD.\n013300     IF CUSTMAST-EOF-SWITCH = \"N\"\n013400         PERFORM 220-PRINT-CUSTOMER-LINE.\n013500*\n013600 210-READ-CUSTOMER-RECORD.\n013700*\n013800     READ CUSTMAST\n013900         AT END\n014000             MOVE \"Y\" TO CUSTMAST-EOF-SWITCH.\n014100*\n014200 220-PRINT-CUSTOMER-LINE.\n014300*\n014400     IF LINE-COUNT >= LINES-ON-PAGE\n014500         PERFORM 230-PRINT-HEADING-LINES.\n014600     MOVE CM-CUSTOMER-NUMBER  TO CL-CUSTOMER-NUMBER.\n014700     MOVE CM-CUSTOMER-NAME    TO CL-CUSTOMER-NAME.\n014800     MOVE CM-SALES-THIS-YTD   TO CL-SALES-THIS-YTD.\n014900     MOVE CM-SALES-LAST-YTD   TO CL-SALES-LAST-YTD.\n015000     MOVE CUSTOMER-LINE TO PRINT-AREA.\n015100     WRITE PRINT-AREA AFTER ADVANCING SPACE-CONTROL LINES.\n015200     ADD 1 TO LINE-COUNT.\n015300     ADD CM-SALES-THIS-YTD TO GRAND-TOTAL-THIS-YTD.\n015400     ADD CM-SALES-LAST-YTD TO GRAND-TOTAL-LAST-YTD.\n015500     MOVE 1 TO SPACE-CONTROL.\n015600*\n015700 230-PRINT-HEADING-LINES.\n015800*\n015900     ADD 1 TO PAGE-COUNT.\n016000     MOVE PAGE-COUNT     TO HL1-PAGE-NUMBER.\n016100     MOVE HEADING-LINE-1 TO PRINT-AREA.\n016200     WRITE PRINT-AREA AFTER ADVANCING PAGE.\n016300     MOVE HEADING-LINE-2 TO PRINT-AREA.\n016400     WRITE PRINT-AREA AFTER ADVANCING 1 LINES.\n016500     MOVE HEADING-LINE-3 TO PRINT-AREA.\n016600     WRITE PRINT-AREA AFTER ADVANCING 2 LINES.\n016700     MOVE HEADING-LINE-4 TO PRINT-AREA.\n016800     WRITE PRINT-AREA AFTER ADVANCING 1 LINES.\n016900     MOVE ZERO TO LINE-COUNT.\n017000     MOVE 2 TO SPACE-CONTROL.\n017100*\n017200 300-PRINT-GRAND-TOTALS.\n017300*\n017400     MOVE GRAND-TOTAL-THIS-YTD TO GTL-SALES-THIS-YTD.\n017500     MOVE GRAND-TOTAL-LAST-YTD TO GTL-SALES-LAST-YTD.\n017600     MOVE GRAND-TOTAL-LINE     TO PRINT-AREA.\n017700     WRITE PRINT-AREA AFTER ADVANCING 2 LINES.\n./ ADD NAME=RPT2000C 0101-01302-01302-1143-00211-00211-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. RPT2000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000*\n001100     SELECT CUSTMAST ASSIGN TO CUSTMAST.\n001200     SELECT SALESRPT ASSIGN TO SALESRPT.\n001300*\n001400 DATA DIVISION.\n001500*\n001600 FILE SECTION.\n001700*\n001800 FD  CUSTMAST.\n001900*\n002000 01  CUSTOMER-MASTER-RECORD.\n002100     05  CM-BRANCH-NUMBER        PIC 9(2).\n002200     05  CM-SALESREP-NUMBER      PIC 9(2).\n002300     05  CM-CUSTOMER-NUMBER      PIC 9(5).\n002400     05  CM-CUSTOMER-NAME        PIC X(20).\n002500     05  CM-SALES-THIS-YTD       PIC S9(5)V9(2).\n002600     05  CM-SALES-LAST-YTD       PIC S9(5)V9(2).\n002700*\n002800 FD  SALESRPT.\n002900*\n003000 01  PRINT-AREA      PIC X(132).\n003100*\n003200 WORKING-STORAGE SECTION.\n003300*\n003400 01  SWITCHES.\n003500     05  CUSTMAST-EOF-SWITCH     PIC X   VALUE \"N\".\n003600*\n003700 01  CALCULATED-FIELDS.\n003800     05  CHANGE-AMOUNT           PIC S9(7)V99.\n003900*\n004000 01  PRINT-FIELDS.\n004100     05  PAGE-COUNT      PIC S9(3)   VALUE ZERO.\n004200     05  LINES-ON-PAGE   PIC S9(3)   VALUE +55.\n004300     05  LINE-COUNT      PIC S9(3)   VALUE +99.\n004400     05  SPACE-CONTROL   PIC S9.\n004500*\n004600 01  TOTAL-FIELDS.\n004700     05  GRAND-TOTAL-THIS-YTD    PIC S9(7)V99    VALUE ZERO.\n004800     05  GRAND-TOTAL-LAST-YTD    PIC S9(7)V99    VALUE ZERO.\n004900*\n005000 01  CURRENT-DATE-AND-TIME.\n005100     05  CD-YEAR         PIC 9999.\n005200     05  CD-MONTH        PIC 99.\n005300     05  CD-DAY          PIC 99.\n005400     05  CD-HOURS        PIC 99.\n005500     05  CD-MINUTES      PIC 99.\n005600     05  FILLER          PIC X(9).\n005700*\n005800 01  HEADING-LINE-1.\n005900     05  FILLER          PIC X(7)    VALUE \"DATE:  \".\n006000     05  HL1-MONTH       PIC 9(2).\n006100     05  FILLER          PIC X(1)    VALUE \"/\".\n006200     05  HL1-DAY         PIC 9(2).\n006300     05  FILLER          PIC X(1)    VALUE \"/\".\n006400     05  HL1-YEAR        PIC 9(4).\n006500     05  FILLER          PIC X(11)   VALUE SPACE.\n006600     05  FILLER          PIC X(20)   VALUE \"YEAR-TO-DATE SALES R\".\n006700     05  FILLER          PIC X(20)   VALUE \"EPORT               \".\n006800     05  FILLER          PIC X(8)    VALUE \"  PAGE: \".\n006900     05  HL1-PAGE-NUMBER PIC ZZZ9.\n007000     05  FILLER          PIC X(52)   VALUE SPACE.\n007100*\n007200 01  HEADING-LINE-2.\n007300     05  FILLER          PIC X(7)    VALUE \"TIME:  \".\n007400     05  HL2-HOURS       PIC 9(2).\n007500     05  FILLER          PIC X(1)    VALUE \":\".\n007600     05  HL2-MINUTES     PIC 9(2).\n007700     05  FILLER          PIC X(58)   VALUE SPACE.\n007800     05  FILLER          PIC X(10)   VALUE \"RPT2000\".\n007900     05  FILLER          PIC X(52)   VALUE SPACE.\n008000*\n008100 01  HEADING-LINE-3.\n008200     05  FILLER      PIC X(20)   VALUE \"CUST                \".\n008300     05  FILLER      PIC X(20)   VALUE \"            SALES   \".\n008400     05  FILLER      PIC X(20)   VALUE \"      SALES         \".\n008500     05  FILLER      PIC X(20)   VALUE \"CHANGE     CHANGE   \".\n008600     05  FILLER      PIC X(52)   VALUE SPACE.\n008700*\n008800 01  HEADING-LINE-4.\n008900     05  FILLER      PIC X(20)   VALUE \"NUM    CUSTOMER NAME\".\n009000     05  FILLER      PIC X(20)   VALUE \"           THIS YTD \".\n009100     05  FILLER      PIC X(20)   VALUE \"     LAST YTD       \".\n009200     05  FILLER      PIC X(20)   VALUE \"AMOUNT    PERCENT   \".\n009300     05  FILLER      PIC X(52)   VALUE SPACE.\n009400*\n009500 01  CUSTOMER-LINE.\n009600     05  CL-CUSTOMER-NUMBER   PIC 9(5).\n009700     05  FILLER               PIC X(2)       VALUE SPACE.\n009800     05  CL-CUSTOMER-NAME     PIC X(20).\n009900     05  FILLER               PIC X(3)       VALUE SPACE.\n010000     05  CL-SALES-THIS-YTD    PIC ZZ,ZZ9.99-.\n010100     05  FILLER               PIC X(4)       VALUE SPACE.\n010200     05  CL-SALES-LAST-YTD    PIC ZZ,ZZ9.99-.\n010300     05  FILLER               PIC X(4)       VALUE SPACE.\n010400     05  CL-CHANGE-AMOUNT     PIC ZZ,ZZ9.99-.\n010500     05  FILLER               PIC X(3)       VALUE SPACE.\n010600     05  CL-CHANGE-PERCENT    PIC ZZ9.9-.\n010700     05  FILLER               PIC X(55)      VALUE SPACE.\n010800*\n010900 01  GRAND-TOTAL-LINE.\n011000     05  FILLER               PIC X(27)      VALUE SPACE.\n011100     05  GTL-SALES-THIS-YTD   PIC Z,ZZZ,ZZ9.99-.\n011200     05  FILLER               PIC X(1)       VALUE SPACE.\n011300     05  GTL-SALES-LAST-YTD   PIC Z,ZZZ,ZZ9.99-.\n011400     05  FILLER               PIC X(1)       VALUE SPACE.\n011500     05  GTL-CHANGE-AMOUNT    PIC Z,ZZZ,ZZ9.99-.\n011600     05  FILLER               PIC X(3)       VALUE SPACE.\n011700     05  GTL-CHANGE-PERCENT   PIC ZZ9.9-.\n011800     05  FILLER               PIC X(55)      VALUE SPACE.\n011900*\n012000 PROCEDURE DIVISION.\n012100*\n012200 000-PREPARE-SALES-REPORT.\n012300*\n012400     OPEN INPUT  CUSTMAST\n012500          OUTPUT SALESRPT.\n012600     PERFORM 100-FORMAT-REPORT-HEADING.\n012700     PERFORM 200-PREPARE-SALES-LINES\n012800         UNTIL CUSTMAST-EOF-SWITCH = \"Y\".\n012900     PERFORM 300-PRINT-GRAND-TOTALS.\n013000     CLOSE CUSTMAST\n013100           SALESRPT.\n013200     STOP RUN.\n013300*\n013400 100-FORMAT-REPORT-HEADING.\n013500*\n013600     MOVE FUNCTION CURRENT-DATE TO CURRENT-DATE-AND-TIME.\n013700     MOVE CD-MONTH   TO HL1-MONTH.\n013800     MOVE CD-DAY     TO HL1-DAY.\n013900     MOVE CD-YEAR    TO HL1-YEAR.\n014000     MOVE CD-HOURS   TO HL2-HOURS.\n014100     MOVE CD-MINUTES TO HL2-MINUTES.\n014200*\n014300 200-PREPARE-SALES-LINES.\n014400*\n014500     PERFORM 210-READ-CUSTOMER-RECORD.\n014600     IF CUSTMAST-EOF-SWITCH = \"N\"\n014700         IF CM-SALES-THIS-YTD >= 10000\n014800             PERFORM 220-PRINT-CUSTOMER-LINE.\n014900*\n015000 210-READ-CUSTOMER-RECORD.\n015100*\n015200     READ CUSTMAST\n015300         AT END\n015400             MOVE \"Y\" TO CUSTMAST-EOF-SWITCH.\n015500*\n015600 220-PRINT-CUSTOMER-LINE.\n015700*\n015800     IF LINE-COUNT > LINES-ON-PAGE\n015900         PERFORM 230-PRINT-HEADING-LINES.\n016000     MOVE CM-CUSTOMER-NUMBER   TO CL-CUSTOMER-NUMBER.\n016100     MOVE CM-CUSTOMER-NAME     TO CL-CUSTOMER-NAME.\n016200     MOVE CM-SALES-THIS-YTD    TO CL-SALES-THIS-YTD.\n016300     MOVE CM-SALES-LAST-YTD    TO CL-SALES-LAST-YTD.\n016400     COMPUTE CHANGE-AMOUNT =\n016500         CM-SALES-THIS-YTD - CM-SALES-LAST-YTD.\n016600     MOVE CHANGE-AMOUNT TO CL-CHANGE-AMOUNT.\n016700     IF CM-SALES-LAST-YTD = ZERO\n016800         MOVE 999.9 TO CL-CHANGE-PERCENT\n016900     ELSE\n017000         COMPUTE CL-CHANGE-PERCENT ROUNDED =\n017100             CHANGE-AMOUNT * 100 / CM-SALES-LAST-YTD\n017200             ON SIZE ERROR\n017300                 MOVE 999.9 TO CL-CHANGE-PERCENT.\n017400     MOVE CUSTOMER-LINE TO PRINT-AREA.\n017500     WRITE PRINT-AREA AFTER ADVANCING SPACE-CONTROL LINES.\n017600     ADD 1 TO LINE-COUNT.\n017700     ADD CM-SALES-THIS-YTD TO GRAND-TOTAL-THIS-YTD.\n017800     ADD CM-SALES-LAST-YTD TO GRAND-TOTAL-LAST-YTD.\n017900     MOVE 1 TO SPACE-CONTROL.\n018000*\n018100 230-PRINT-HEADING-LINES.\n018200*\n018300     ADD 1 TO PAGE-COUNT.\n018400     MOVE PAGE-COUNT     TO HL1-PAGE-NUMBER.\n018500     MOVE HEADING-LINE-1 TO PRINT-AREA.\n018600     WRITE PRINT-AREA AFTER ADVANCING PAGE.\n018700     MOVE HEADING-LINE-2 TO PRINT-AREA.\n018800     WRITE PRINT-AREA AFTER ADVANCING 1 LINES.\n018900     MOVE HEADING-LINE-3 TO PRINT-AREA.\n019000     WRITE PRINT-AREA AFTER ADVANCING 2 LINES.\n019100     MOVE HEADING-LINE-4 TO PRINT-AREA.\n019200     WRITE PRINT-AREA AFTER ADVANCING 1 LINES.\n019300     MOVE ZERO TO LINE-COUNT.\n019400     MOVE 2 TO SPACE-CONTROL.\n019500*\n019600 300-PRINT-GRAND-TOTALS.\n019700*\n019800     MOVE GRAND-TOTAL-THIS-YTD TO GTL-SALES-THIS-YTD.\n019900     MOVE GRAND-TOTAL-LAST-YTD TO GTL-SALES-LAST-YTD.\n020000     COMPUTE CHANGE-AMOUNT =\n020100         GRAND-TOTAL-THIS-YTD - GRAND-TOTAL-LAST-YTD.\n020200     MOVE CHANGE-AMOUNT TO GTL-CHANGE-AMOUNT.\n020300     IF GRAND-TOTAL-LAST-YTD = ZERO\n020400         MOVE 999.9 TO GTL-CHANGE-PERCENT\n020500     ELSE\n020600         COMPUTE GTL-CHANGE-PERCENT ROUNDED =\n020700             CHANGE-AMOUNT * 100 / GRAND-TOTAL-LAST-YTD\n020800             ON SIZE ERROR\n020900                 MOVE 999.9 TO GTL-CHANGE-PERCENT.\n021000     MOVE GRAND-TOTAL-LINE TO PRINT-AREA.\n021100     WRITE PRINT-AREA AFTER ADVANCING 2 LINES.\n./ ADD NAME=RPT3000C 0102-01302-01302-1144-00288-00288-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. RPT3000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000*\n001100     SELECT CUSTMAST ASSIGN TO CUSTMAST.\n001200     SELECT SALESRPT ASSIGN TO SALESRPT.\n001300*\n001400 DATA DIVISION.\n001500*\n001600 FILE SECTION.\n001700*\n001800 FD  CUSTMAST.\n001900*\n002000 01  CUSTOMER-MASTER-RECORD.\n002100     05  CM-BRANCH-NUMBER        PIC 9(2).\n002200     05  CM-SALESREP-NUMBER      PIC 9(2).\n002300     05  CM-CUSTOMER-NUMBER      PIC 9(5).\n002400     05  CM-CUSTOMER-NAME        PIC X(20).\n002500     05  CM-SALES-THIS-YTD       PIC S9(5)V9(2).\n002600     05  CM-SALES-LAST-YTD       PIC S9(5)V9(2).\n002700*\n002800 FD  SALESRPT.\n002900*\n003000 01  PRINT-AREA      PIC X(132).\n003100*\n003200 WORKING-STORAGE SECTION.\n003300*\n003400 01  SWITCHES.\n003500     05  CUSTMAST-EOF-SWITCH     PIC X   VALUE \"N\".\n003600     05  FIRST-RECORD-SWITCH     PIC X   VALUE \"Y\".\n003700*\n003800 01  CONTROL-FIELDS.\n003900     05  OLD-BRANCH-NUMBER       PIC 99.\n004000*\n004100 01  CALCULATED-FIELDS.\n004200     05  CHANGE-AMOUNT           PIC S9(7)V99.\n004300*\n004400 01  PRINT-FIELDS.\n004500     05  PAGE-COUNT      PIC S9(3)   VALUE ZERO.\n004600     05  LINES-ON-PAGE   PIC S9(3)   VALUE +55.\n004700     05  LINE-COUNT      PIC S9(3)   VALUE +99.\n004800     05  SPACE-CONTROL   PIC S9.\n004900*\n005000 01  TOTAL-FIELDS.\n005100     05  BRANCH-TOTAL-THIS-YTD   PIC S9(6)V99    VALUE ZERO.\n005200     05  BRANCH-TOTAL-LAST-YTD   PIC S9(6)V99    VALUE ZERO.\n005300     05  GRAND-TOTAL-THIS-YTD    PIC S9(7)V99    VALUE ZERO.\n005400     05  GRAND-TOTAL-LAST-YTD    PIC S9(7)V99    VALUE ZERO.\n005500*\n005600 01  CURRENT-DATE-AND-TIME.\n005700     05  CD-YEAR         PIC 9999.\n005800     05  CD-MONTH        PIC 99.\n005900     05  CD-DAY          PIC 99.\n006000     05  CD-HOURS        PIC 99.\n006100     05  CD-MINUTES      PIC 99.\n006200     05  FILLER          PIC X(9).\n006300*\n006400 01  HEADING-LINE-1.\n006500     05  FILLER          PIC X(7)    VALUE \"DATE:  \".\n006600     05  HL1-MONTH       PIC 9(2).\n006700     05  FILLER          PIC X(1)    VALUE \"/\".\n006800     05  HL1-DAY         PIC 9(2).\n006900     05  FILLER          PIC X(1)    VALUE \"/\".\n007000     05  HL1-YEAR        PIC 9(4).\n007100     05  FILLER          PIC X(15)   VALUE SPACE.\n007200     05  FILLER          PIC X(20)   VALUE \"YEAR-TO-DATE SALES R\".\n007300     05  FILLER          PIC X(20)   VALUE \"EPORT               \".\n007400     05  FILLER          PIC X(12)   VALUE \"      PAGE: \".\n007500     05  HL1-PAGE-NUMBER PIC ZZZ9.\n007600     05  FILLER          PIC X(44)   VALUE SPACE.\n007700*\n007800 01  HEADING-LINE-2.\n007900     05  FILLER          PIC X(7)    VALUE \"TIME:  \".\n008000     05  HL2-HOURS       PIC 9(2).\n008100     05  FILLER          PIC X(1)    VALUE \":\".\n008200     05  HL2-MINUTES     PIC 9(2).\n008300     05  FILLER          PIC X(66)   VALUE SPACE.\n008400     05  FILLER          PIC X(10)   VALUE \"RPT3000\".\n008500     05  FILLER          PIC X(44)   VALUE SPACE.\n008600*\n008700 01  HEADING-LINE-3.\n008800     05  FILLER      PIC X(8)    VALUE \"BRANCH  \".\n008900     05  FILLER      PIC X(20)   VALUE \"CUST                \".\n009000     05  FILLER      PIC X(20)   VALUE \"            SALES   \".\n009100     05  FILLER      PIC X(20)   VALUE \"      SALES         \".\n009200     05  FILLER      PIC X(20)   VALUE \"CHANGE     CHANGE   \".\n009300     05  FILLER      PIC X(44)   VALUE SPACE.\n009400*\n009500 01  HEADING-LINE-4.\n009600     05  FILLER      PIC X(8)    VALUE \" NUM    \".\n009700     05  FILLER      PIC X(20)   VALUE \"NUM    CUSTOMER NAME\".\n009800     05  FILLER      PIC X(20)   VALUE \"           THIS YTD \".\n009900     05  FILLER      PIC X(20)   VALUE \"     LAST YTD       \".\n010000     05  FILLER      PIC X(20)   VALUE \"AMOUNT    PERCENT   \".\n010100     05  FILLER      PIC X(44)   VALUE SPACE.\n010200*\n010300 01  CUSTOMER-LINE.\n010400     05  FILLER               PIC X(2)       VALUE SPACE.\n010500     05  CL-BRANCH-NUMBER     PIC X(2).\n010600     05  FILLER               PIC X(4)       VALUE SPACE.\n010700     05  CL-CUSTOMER-NUMBER   PIC 9(5).\n010800     05  FILLER               PIC X(2)       VALUE SPACE.\n010900     05  CL-CUSTOMER-NAME     PIC X(20).\n011000     05  FILLER               PIC X(3)       VALUE SPACE.\n011100     05  CL-SALES-THIS-YTD    PIC ZZ,ZZ9.99-.\n011200     05  FILLER               PIC X(4)       VALUE SPACE.\n011300     05  CL-SALES-LAST-YTD    PIC ZZ,ZZ9.99-.\n011400     05  FILLER               PIC X(4)       VALUE SPACE.\n011500     05  CL-CHANGE-AMOUNT     PIC ZZ,ZZ9.99-.\n011600     05  FILLER               PIC X(3)       VALUE SPACE.\n011700     05  CL-CHANGE-PERCENT    PIC ZZ9.9-.\n011800     05  FILLER               PIC X(47)      VALUE SPACE.\n011900*\n012000 01  BRANCH-TOTAL-LINE.\n012100     05  FILLER               PIC X(23)      VALUE SPACE.\n012200     05  FILLER               PIC X(14)      VALUE \"BRANCH TOTAL\".\n012300     05  BTL-SALES-THIS-YTD   PIC ZZZ,ZZ9.99-.\n012400     05  FILLER               PIC X(3)       VALUE SPACE.\n012500     05  BTL-SALES-LAST-YTD   PIC ZZZ,ZZ9.99-.\n012600     05  FILLER               PIC X(3)       VALUE SPACE.\n012700     05  BTL-CHANGE-AMOUNT    PIC ZZZ,ZZ9.99-.\n012800     05  FILLER               PIC X(3)       VALUE SPACE.\n012900     05  BTL-CHANGE-PERCENT   PIC ZZ9.9-.\n013000     05  FILLER               PIC X(47)      VALUE \" *\".\n013100*\n013200 01  GRAND-TOTAL-LINE.\n013300     05  FILLER               PIC X(23)      VALUE SPACE.\n013400     05  FILLER               PIC X(12)      VALUE \"GRAND TOTAL\".\n013500     05  GTL-SALES-THIS-YTD   PIC Z,ZZZ,ZZ9.99-.\n013600     05  FILLER               PIC X(1)       VALUE SPACE.\n013700     05  GTL-SALES-LAST-YTD   PIC Z,ZZZ,ZZ9.99-.\n013800     05  FILLER               PIC X(1)       VALUE SPACE.\n013900     05  GTL-CHANGE-AMOUNT    PIC Z,ZZZ,ZZ9.99-.\n014000     05  FILLER               PIC X(3)       VALUE SPACE.\n014100     05  GTL-CHANGE-PERCENT   PIC ZZ9.9-.\n014200     05  FILLER               PIC X(47)      VALUE \" **\".\n014300*\n014400 PROCEDURE DIVISION.\n014500*\n014600 000-PREPARE-SALES-REPORT.\n014700*\n014800     OPEN INPUT  CUSTMAST\n014900          OUTPUT SALESRPT.\n015000     PERFORM 100-FORMAT-REPORT-HEADING.\n015100     PERFORM 300-PREPARE-SALES-LINES\n015200         UNTIL CUSTMAST-EOF-SWITCH = \"Y\".\n015300     PERFORM 500-PRINT-GRAND-TOTALS.\n015400     CLOSE CUSTMAST\n015500           SALESRPT.\n015600     STOP RUN.\n015700*\n015800 100-FORMAT-REPORT-HEADING.\n015900*\n016000     MOVE FUNCTION CURRENT-DATE TO CURRENT-DATE-AND-TIME.\n016100     MOVE CD-MONTH   TO HL1-MONTH.\n016200     MOVE CD-DAY     TO HL1-DAY.\n016300     MOVE CD-YEAR    TO HL1-YEAR.\n016400     MOVE CD-HOURS   TO HL2-HOURS.\n016500     MOVE CD-MINUTES TO HL2-MINUTES.\n016600*\n016700 300-PREPARE-SALES-LINES.\n016800*\n016900     PERFORM 310-READ-CUSTOMER-RECORD.\n017000     IF CUSTMAST-EOF-SWITCH = \"N\"\n017100         IF FIRST-RECORD-SWITCH = \"Y\"\n017200             PERFORM 320-PRINT-CUSTOMER-LINE\n017300             MOVE \"N\" TO FIRST-RECORD-SWITCH\n017400             MOVE CM-BRANCH-NUMBER TO OLD-BRANCH-NUMBER\n017500         ELSE\n017600             IF CM-BRANCH-NUMBER > OLD-BRANCH-NUMBER\n017700                 PERFORM 360-PRINT-BRANCH-LINE\n017800                 PERFORM 320-PRINT-CUSTOMER-LINE\n017900                 MOVE CM-BRANCH-NUMBER TO OLD-BRANCH-NUMBER\n018000             ELSE\n018100                 PERFORM 320-PRINT-CUSTOMER-LINE\n018200     ELSE\n018300         PERFORM 360-PRINT-BRANCH-LINE.\n018400*\n018500 310-READ-CUSTOMER-RECORD.\n018600*\n018700     READ CUSTMAST\n018800         AT END\n018900             MOVE \"Y\" TO CUSTMAST-EOF-SWITCH.\n019000*\n019100 320-PRINT-CUSTOMER-LINE.\n019200*\n019300     IF LINE-COUNT > LINES-ON-PAGE\n019400         PERFORM 330-PRINT-HEADING-LINES.\n019500     IF FIRST-RECORD-SWITCH = \"Y\"\n019600         MOVE CM-BRANCH-NUMBER TO CL-BRANCH-NUMBER\n019700     ELSE\n019800         IF CM-BRANCH-NUMBER > OLD-BRANCH-NUMBER\n019900             MOVE CM-BRANCH-NUMBER TO CL-BRANCH-NUMBER\n020000         ELSE\n020100             MOVE SPACE TO CL-BRANCH-NUMBER.\n020200     MOVE CM-CUSTOMER-NUMBER   TO CL-CUSTOMER-NUMBER.\n020300     MOVE CM-CUSTOMER-NAME     TO CL-CUSTOMER-NAME.\n020400     MOVE CM-SALES-THIS-YTD    TO CL-SALES-THIS-YTD.\n020500     MOVE CM-SALES-LAST-YTD    TO CL-SALES-LAST-YTD.\n020600     COMPUTE CHANGE-AMOUNT =\n020700         CM-SALES-THIS-YTD - CM-SALES-LAST-YTD.\n020800     MOVE CHANGE-AMOUNT TO CL-CHANGE-AMOUNT.\n020900     IF CM-SALES-LAST-YTD = ZERO\n021000         MOVE 999.9 TO CL-CHANGE-PERCENT\n021100     ELSE\n021200         COMPUTE CL-CHANGE-PERCENT ROUNDED =\n021300             CHANGE-AMOUNT * 100 / CM-SALES-LAST-YTD\n021400             ON SIZE ERROR\n021500                 MOVE 999.9 TO CL-CHANGE-PERCENT.\n021600     MOVE CUSTOMER-LINE TO PRINT-AREA.\n021700     PERFORM 350-WRITE-REPORT-LINE.\n021800     MOVE 1 TO SPACE-CONTROL.\n021900     ADD CM-SALES-THIS-YTD TO BRANCH-TOTAL-THIS-YTD.\n022000     ADD CM-SALES-LAST-YTD TO BRANCH-TOTAL-LAST-YTD.\n022100*\n022200 330-PRINT-HEADING-LINES.\n022300*\n022400     ADD 1 TO PAGE-COUNT.\n022500     MOVE PAGE-COUNT     TO HL1-PAGE-NUMBER.\n022600     MOVE HEADING-LINE-1 TO PRINT-AREA.\n022700     PERFORM 340-WRITE-PAGE-TOP-LINE.\n022800     MOVE HEADING-LINE-2 TO PRINT-AREA.\n022900     MOVE 1 TO SPACE-CONTROL.\n023000     PERFORM 350-WRITE-REPORT-LINE.\n023100     MOVE HEADING-LINE-3 TO PRINT-AREA.\n023200     MOVE 2 TO SPACE-CONTROL.\n023300     PERFORM 350-WRITE-REPORT-LINE.\n023400     MOVE HEADING-LINE-4 TO PRINT-AREA.\n023500     MOVE 1 TO SPACE-CONTROL.\n023600     PERFORM 350-WRITE-REPORT-LINE.\n023700     MOVE 2 TO SPACE-CONTROL.\n023800*\n023900 340-WRITE-PAGE-TOP-LINE.\n024000*\n024100     WRITE PRINT-AREA AFTER ADVANCING PAGE.\n024200     MOVE 1 TO LINE-COUNT.\n024300*\n024400 350-WRITE-REPORT-LINE.\n024500*\n024600     WRITE PRINT-AREA AFTER ADVANCING SPACE-CONTROL LINES.\n024700     ADD SPACE-CONTROL TO LINE-COUNT.\n024800*\n024900 360-PRINT-BRANCH-LINE.\n025000*\n025100     MOVE BRANCH-TOTAL-THIS-YTD TO BTL-SALES-THIS-YTD.\n025200     MOVE BRANCH-TOTAL-LAST-YTD TO BTL-SALES-LAST-YTD.\n025300     COMPUTE CHANGE-AMOUNT =\n025400         BRANCH-TOTAL-THIS-YTD - BRANCH-TOTAL-LAST-YTD.\n025500     MOVE CHANGE-AMOUNT TO BTL-CHANGE-AMOUNT.\n025600     IF BRANCH-TOTAL-LAST-YTD = ZERO\n025700         MOVE 999.9 TO BTL-CHANGE-PERCENT\n025800     ELSE\n025900         COMPUTE BTL-CHANGE-PERCENT ROUNDED =\n026000             CHANGE-AMOUNT * 100 / BRANCH-TOTAL-LAST-YTD\n026100             ON SIZE ERROR\n026200                 MOVE 999.9 TO BTL-CHANGE-PERCENT.\n026300     MOVE BRANCH-TOTAL-LINE TO PRINT-AREA.\n026400     MOVE 1 TO SPACE-CONTROL.\n026500     PERFORM 350-WRITE-REPORT-LINE.\n026600     MOVE 2 TO SPACE-CONTROL.\n026700     ADD BRANCH-TOTAL-THIS-YTD TO GRAND-TOTAL-THIS-YTD.\n026800     ADD BRANCH-TOTAL-LAST-YTD TO GRAND-TOTAL-LAST-YTD.\n026900     MOVE ZERO TO BRANCH-TOTAL-THIS-YTD.\n027000     MOVE ZERO TO BRANCH-TOTAL-LAST-YTD.\n027100*\n027200 500-PRINT-GRAND-TOTALS.\n027300*\n027400     MOVE GRAND-TOTAL-THIS-YTD TO GTL-SALES-THIS-YTD.\n027500     MOVE GRAND-TOTAL-LAST-YTD TO GTL-SALES-LAST-YTD.\n027600     COMPUTE CHANGE-AMOUNT =\n027700         GRAND-TOTAL-THIS-YTD - GRAND-TOTAL-LAST-YTD.\n027800     MOVE CHANGE-AMOUNT TO GTL-CHANGE-AMOUNT.\n027900     IF GRAND-TOTAL-LAST-YTD = ZERO\n028000         MOVE 999.9 TO GTL-CHANGE-PERCENT\n028100     ELSE\n028200         COMPUTE GTL-CHANGE-PERCENT ROUNDED =\n028300             CHANGE-AMOUNT * 100 / GRAND-TOTAL-LAST-YTD\n028400             ON SIZE ERROR\n028500                 MOVE 999.9 TO GTL-CHANGE-PERCENT.\n028600     MOVE GRAND-TOTAL-LINE TO PRINT-AREA.\n028700     MOVE 2 TO SPACE-CONTROL.\n028800     PERFORM 350-WRITE-REPORT-LINE.\n./ ADD NAME=RPT5000C 0101-01302-01302-1145-00346-00346-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID. RPT5000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000*\n001100     SELECT CUSTMAST ASSIGN TO CUSTMAST.\n001200     SELECT SALESRPT ASSIGN TO SALESRPT.\n001300*\n001400 DATA DIVISION.\n001500*\n001600 FILE SECTION.\n001700*\n001800 FD  CUSTMAST.\n001900*\n002000 01  CUSTOMER-MASTER-RECORD.\n002100     05  CM-BRANCH-NUMBER        PIC 9(2).\n002200     05  CM-SALESREP-NUMBER      PIC 9(2).\n002300     05  CM-CUSTOMER-NUMBER      PIC 9(5).\n002400     05  CM-CUSTOMER-NAME        PIC X(20).\n002500     05  CM-SALES-THIS-YTD       PIC S9(5)V9(2).\n002600     05  CM-SALES-LAST-YTD       PIC S9(5)V9(2).\n002700*\n002800 FD  SALESRPT.\n002900*\n003000 01  PRINT-AREA      PIC X(132).\n003100*\n003200 WORKING-STORAGE SECTION.\n003300*\n003400 01  SWITCHES.\n003500     05  CUSTMAST-EOF-SWITCH     PIC X   VALUE \"N\".\n003600         88  CUSTMAST-EOF                VALUE \"Y\".\n003700     05  FIRST-RECORD-SWITCH     PIC X   VALUE \"Y\".\n003800         88  FIRST-RECORD                VALUE \"Y\".\n003900*\n004000 01  CONTROL-FIELDS.\n004100     05  OLD-BRANCH-NUMBER       PIC 9(2).\n004200     05  OLD-SALESREP-NUMBER     PIC 9(2).\n004300*\n004400 01  CALCULATED-FIELDS.\n004500     05  CHANGE-AMOUNT           PIC S9(7)V99.\n004600*\n004700 01  PRINT-FIELDS.\n004800     05  PAGE-COUNT      PIC S9(3)   VALUE ZERO.\n004900     05  LINES-ON-PAGE   PIC S9(3)   VALUE +55.\n005000     05  LINE-COUNT      PIC S9(3)   VALUE +99.\n005100     05  SPACE-CONTROL   PIC S9.\n005200*\n005300 01  TOTAL-FIELDS.\n005400     05  SALESREP-TOTAL-THIS-YTD PIC S9(6)V99    VALUE ZERO.\n005500     05  SALESREP-TOTAL-LAST-YTD PIC S9(6)V99    VALUE ZERO.\n005600     05  BRANCH-TOTAL-THIS-YTD   PIC S9(6)V99    VALUE ZERO.\n005700     05  BRANCH-TOTAL-LAST-YTD   PIC S9(6)V99    VALUE ZERO.\n005800     05  GRAND-TOTAL-THIS-YTD    PIC S9(7)V99    VALUE ZERO.\n005900     05  GRAND-TOTAL-LAST-YTD    PIC S9(7)V99    VALUE ZERO.\n006000*\n006100 01  CURRENT-DATE-AND-TIME.\n006200     05  CD-YEAR         PIC 9999.\n006300     05  CD-MONTH        PIC 99.\n006400     05  CD-DAY          PIC 99.\n006500     05  CD-HOURS        PIC 99.\n006600     05  CD-MINUTES      PIC 99.\n006700     05  FILLER          PIC X(9).\n006800*\n006900 01  HEADING-LINE-1.\n007000     05  FILLER          PIC X(7)    VALUE \"DATE:  \".\n007100     05  HL1-MONTH       PIC 9(2).\n007200     05  FILLER          PIC X(1)    VALUE \"/\".\n007300     05  HL1-DAY         PIC 9(2).\n007400     05  FILLER          PIC X(1)    VALUE \"/\".\n007500     05  HL1-YEAR        PIC 9(4).\n007600     05  FILLER          PIC X(18)   VALUE SPACE.\n007700     05  FILLER          PIC X(20)   VALUE \"YEAR-TO-DATE SALES R\".\n007800     05  FILLER          PIC X(20)   VALUE \"EPORT               \".\n007900     05  FILLER          PIC X(15)   VALUE \"         PAGE: \".\n008000     05  HL1-PAGE-NUMBER PIC ZZZ9.\n008100     05  FILLER          PIC X(37)   VALUE SPACE.\n008200*\n008300 01  HEADING-LINE-2.\n008400     05  FILLER          PIC X(7)    VALUE \"TIME:  \".\n008500     05  HL2-HOURS       PIC 9(2).\n008600     05  FILLER          PIC X(1)    VALUE \":\".\n008700     05  HL2-MINUTES     PIC 9(2).\n008800     05  FILLER          PIC X(72)   VALUE SPACE.\n008900     05  FILLER          PIC X(8)    VALUE \"RPT5000\".\n009000     05  FILLER          PIC X(39)   VALUE SPACE.\n009100*\n009200 01  HEADING-LINE-3.\n009300     05  FILLER      PIC X(20)   VALUE \"BRCH  SLSREP  CUST  \".\n009400     05  FILLER      PIC X(20)   VALUE SPACE.\n009500     05  FILLER      PIC X(14)   VALUE \"      SALES  \".\n009600     05  FILLER      PIC X(20)   VALUE \"      SALES         \".\n009700     05  FILLER      PIC X(20)   VALUE \"CHANGE     CHANGE   \".\n009800     05  FILLER      PIC X(38)   VALUE SPACE.\n009900*\n010000 01  HEADING-LINE-4.\n010100     05  FILLER      PIC X(20)   VALUE \"NUM    NUM     NUM  \".\n010200     05  FILLER      PIC X(20)   VALUE \" CUSTOMER NAME      \".\n010300     05  FILLER      PIC X(14)   VALUE \"     THIS YTD\".\n010400     05  FILLER      PIC X(20)   VALUE \"     LAST YTD       \".\n010500     05  FILLER      PIC X(20)   VALUE \"AMOUNT    PERCENT   \".\n010600     05  FILLER      PIC X(38)   VALUE SPACE.\n010700*\n010800 01  CUSTOMER-LINE.\n010900     05  FILLER               PIC X(1)       VALUE SPACE.\n011000     05  CL-BRANCH-NUMBER     PIC X(2).\n011100     05  FILLER               PIC X(5)       VALUE SPACE.\n011200     05  CL-SALESREP-NUMBER   PIC X(2).\n011300     05  FILLER               PIC X(4)       VALUE SPACE.\n011400     05  CL-CUSTOMER-NUMBER   PIC 9(5).\n011500     05  FILLER               PIC X(2)       VALUE SPACE.\n011600     05  CL-CUSTOMER-NAME     PIC X(20).\n011700     05  FILLER               PIC X(3)       VALUE SPACE.\n011800     05  CL-SALES-THIS-YTD    PIC ZZ,ZZ9.99-.\n011900     05  FILLER               PIC X(4)       VALUE SPACE.\n012000     05  CL-SALES-LAST-YTD    PIC ZZ,ZZ9.99-.\n012100     05  FILLER               PIC X(4)       VALUE SPACE.\n012200     05  CL-CHANGE-AMOUNT     PIC ZZ,ZZ9.99-.\n012300     05  FILLER               PIC X(3)       VALUE SPACE.\n012400     05  CL-CHANGE-PERCENT    PIC ZZ9.9-.\n012500     05  FILLER               PIC X(41)      VALUE SPACE.\n012600*\n012700 01  SALESREP-TOTAL-LINE.\n012800     05  FILLER               PIC X(27)      VALUE SPACE.\n012900     05  FILLER               PIC X(9)       VALUE \"SALESREP \".\n013000     05  FILLER               PIC X(7)       VALUE \"TOTAL  \".\n013100     05  STL-SALES-THIS-YTD   PIC ZZZ,ZZ9.99-.\n013200     05  FILLER               PIC X(3)       VALUE SPACE.\n013300     05  STL-SALES-LAST-YTD   PIC ZZZ,ZZ9.99-.\n013400     05  FILLER               PIC X(3)       VALUE SPACE.\n013500     05  STL-CHANGE-AMOUNT    PIC ZZZ,ZZ9.99-.\n013600     05  FILLER               PIC X(3)       VALUE SPACE.\n013700     05  STL-CHANGE-PERCENT   PIC ZZ9.9-.\n013800     05  FILLER               PIC X(41)      VALUE \" *\".\n013900*\n014000 01  BRANCH-TOTAL-LINE.\n014100     05  FILLER               PIC X(27)      VALUE SPACE.\n014200     05  FILLER               PIC X(16)      VALUE \"BRANCH TOTAL\".\n014300     05  BTL-SALES-THIS-YTD   PIC ZZZ,ZZ9.99-.\n014400     05  FILLER               PIC X(3)       VALUE SPACE.\n014500     05  BTL-SALES-LAST-YTD   PIC ZZZ,ZZ9.99-.\n014600     05  FILLER               PIC X(3)       VALUE SPACE.\n014700     05  BTL-CHANGE-AMOUNT    PIC ZZZ,ZZ9.99-.\n014800     05  FILLER               PIC X(3)       VALUE SPACE.\n014900     05  BTL-CHANGE-PERCENT   PIC ZZ9.9-.\n015000     05  FILLER               PIC X(41)      VALUE \" **\".\n015100*\n015200 01  GRAND-TOTAL-LINE.\n015300     05  FILLER               PIC X(27)      VALUE SPACE.\n015400     05  FILLER               PIC X(14)      VALUE \"GRAND TOTAL\".\n015500     05  GTL-SALES-THIS-YTD   PIC Z,ZZZ,ZZ9.99-.\n015600     05  FILLER               PIC X(1)       VALUE SPACE.\n015700     05  GTL-SALES-LAST-YTD   PIC Z,ZZZ,ZZ9.99-.\n015800     05  FILLER               PIC X(1)       VALUE SPACE.\n015900     05  GTL-CHANGE-AMOUNT    PIC Z,ZZZ,ZZ9.99-.\n016000     05  FILLER               PIC X(3)       VALUE SPACE.\n016100     05  GTL-CHANGE-PERCENT   PIC ZZ9.9-.\n016200     05  FILLER               PIC X(41)      VALUE \" ***\".\n016300*\n016400 PROCEDURE DIVISION.\n016500*\n016600 000-PREPARE-SALES-REPORT.\n016700*\n016800     OPEN INPUT  CUSTMAST\n016900          OUTPUT SALESRPT.\n017000     PERFORM 100-FORMAT-REPORT-HEADING.\n017100     PERFORM 300-PREPARE-SALES-LINES\n017200         WITH TEST AFTER\n017300         UNTIL CUSTMAST-EOF.\n017400     PERFORM 500-PRINT-GRAND-TOTALS.\n017500     CLOSE CUSTMAST\n017600           SALESRPT.\n017700     STOP RUN.\n017800*\n017900 100-FORMAT-REPORT-HEADING.\n018000*\n018100     MOVE FUNCTION CURRENT-DATE TO CURRENT-DATE-AND-TIME.\n018200     MOVE CD-MONTH   TO HL1-MONTH.\n018300     MOVE CD-DAY     TO HL1-DAY.\n018400     MOVE CD-YEAR    TO HL1-YEAR.\n018500     MOVE CD-HOURS   TO HL2-HOURS.\n018600     MOVE CD-MINUTES TO HL2-MINUTES.\n018700*\n018800 300-PREPARE-SALES-LINES.\n018900*\n019000     PERFORM 310-READ-CUSTOMER-RECORD.\n019100     EVALUATE TRUE\n019200         WHEN CUSTMAST-EOF\n019300             PERFORM 355-PRINT-SALESREP-LINE\n019400             PERFORM 360-PRINT-BRANCH-LINE\n019500         WHEN FIRST-RECORD\n019600             PERFORM 320-PRINT-CUSTOMER-LINE\n019700             MOVE \"N\" TO FIRST-RECORD-SWITCH\n019800             MOVE CM-SALESREP-NUMBER TO OLD-SALESREP-NUMBER\n019900             MOVE CM-BRANCH-NUMBER TO OLD-BRANCH-NUMBER\n020000         WHEN CM-BRANCH-NUMBER > OLD-BRANCH-NUMBER\n020100             PERFORM 355-PRINT-SALESREP-LINE\n020200             PERFORM 360-PRINT-BRANCH-LINE\n020300             PERFORM 320-PRINT-CUSTOMER-LINE\n020400             MOVE CM-SALESREP-NUMBER TO OLD-SALESREP-NUMBER\n020500             MOVE CM-BRANCH-NUMBER TO OLD-BRANCH-NUMBER\n020600         WHEN CM-SALESREP-NUMBER > OLD-SALESREP-NUMBER\n020700             PERFORM 355-PRINT-SALESREP-LINE\n020800             PERFORM 320-PRINT-CUSTOMER-LINE\n020900             MOVE CM-SALESREP-NUMBER TO OLD-SALESREP-NUMBER\n021000         WHEN OTHER\n021100             PERFORM 320-PRINT-CUSTOMER-LINE\n021200     END-EVALUATE.\n021300*\n021400 310-READ-CUSTOMER-RECORD.\n021500*\n021600     READ CUSTMAST\n021700         AT END\n021800             SET CUSTMAST-EOF TO TRUE.\n021900*\n022000 320-PRINT-CUSTOMER-LINE.\n022100*\n022200     IF LINE-COUNT > LINES-ON-PAGE\n022300         PERFORM 330-PRINT-HEADING-LINES.\n022400     EVALUATE TRUE\n022500         WHEN FIRST-RECORD\n022600             MOVE CM-SALESREP-NUMBER TO CL-SALESREP-NUMBER\n022700             MOVE CM-BRANCH-NUMBER TO CL-BRANCH-NUMBER\n022800         WHEN CM-BRANCH-NUMBER > OLD-BRANCH-NUMBER\n022900             MOVE CM-SALESREP-NUMBER TO CL-SALESREP-NUMBER\n023000             MOVE CM-BRANCH-NUMBER TO CL-BRANCH-NUMBER\n023100         WHEN CM-SALESREP-NUMBER > OLD-SALESREP-NUMBER\n023200             MOVE CM-SALESREP-NUMBER TO CL-SALESREP-NUMBER\n023300             MOVE SPACE TO CL-BRANCH-NUMBER\n023400         WHEN OTHER\n023500             MOVE SPACE TO CL-SALESREP-NUMBER\n023600             MOVE SPACE TO CL-BRANCH-NUMBER\n023700     END-EVALUATE.\n023800     MOVE CM-CUSTOMER-NUMBER   TO CL-CUSTOMER-NUMBER.\n023900     MOVE CM-CUSTOMER-NAME     TO CL-CUSTOMER-NAME.\n024000     MOVE CM-SALES-THIS-YTD    TO CL-SALES-THIS-YTD.\n024100     MOVE CM-SALES-LAST-YTD    TO CL-SALES-LAST-YTD.\n024200     COMPUTE CHANGE-AMOUNT =\n024300         CM-SALES-THIS-YTD - CM-SALES-LAST-YTD.\n024400     MOVE CHANGE-AMOUNT TO CL-CHANGE-AMOUNT.\n024500     IF CM-SALES-LAST-YTD = ZERO\n024600         MOVE 999.9 TO CL-CHANGE-PERCENT\n024700     ELSE\n024800         COMPUTE CL-CHANGE-PERCENT ROUNDED =\n024900             CHANGE-AMOUNT * 100 / CM-SALES-LAST-YTD\n025000             ON SIZE ERROR\n025100                 MOVE 999.9 TO CL-CHANGE-PERCENT.\n025200     MOVE CUSTOMER-LINE TO PRINT-AREA.\n025300     PERFORM 350-WRITE-REPORT-LINE.\n025400     MOVE 1 TO SPACE-CONTROL.\n025500     ADD CM-SALES-THIS-YTD TO SALESREP-TOTAL-THIS-YTD.\n025600     ADD CM-SALES-LAST-YTD TO SALESREP-TOTAL-LAST-YTD.\n025700     ADD CM-SALES-THIS-YTD TO BRANCH-TOTAL-THIS-YTD.\n025800     ADD CM-SALES-LAST-YTD TO BRANCH-TOTAL-LAST-YTD.\n025900*\n026000 330-PRINT-HEADING-LINES.\n026100*\n026200     ADD 1 TO PAGE-COUNT.\n026300     MOVE PAGE-COUNT     TO HL1-PAGE-NUMBER.\n026400     MOVE HEADING-LINE-1 TO PRINT-AREA.\n026500     PERFORM 340-WRITE-PAGE-TOP-LINE.\n026600     MOVE HEADING-LINE-2 TO PRINT-AREA.\n026700     MOVE 1 TO SPACE-CONTROL.\n026800     PERFORM 350-WRITE-REPORT-LINE.\n026900     MOVE HEADING-LINE-3 TO PRINT-AREA.\n027000     MOVE 2 TO SPACE-CONTROL.\n027100     PERFORM 350-WRITE-REPORT-LINE.\n027200     MOVE HEADING-LINE-4 TO PRINT-AREA.\n027300     MOVE 1 TO SPACE-CONTROL.\n027400     PERFORM 350-WRITE-REPORT-LINE.\n027500     MOVE 2 TO SPACE-CONTROL.\n027600*\n027700 340-WRITE-PAGE-TOP-LINE.\n027800*\n027900     WRITE PRINT-AREA AFTER ADVANCING PAGE.\n028000     MOVE 1 TO LINE-COUNT.\n028100*\n028200 350-WRITE-REPORT-LINE.\n028300*\n028400     WRITE PRINT-AREA AFTER ADVANCING SPACE-CONTROL LINES.\n028500     ADD SPACE-CONTROL TO LINE-COUNT.\n028600*\n028700 355-PRINT-SALESREP-LINE.\n028800*\n028900     MOVE SALESREP-TOTAL-THIS-YTD TO STL-SALES-THIS-YTD.\n029000     MOVE SALESREP-TOTAL-LAST-YTD TO STL-SALES-LAST-YTD.\n029100     COMPUTE CHANGE-AMOUNT =\n029200         SALESREP-TOTAL-THIS-YTD - SALESREP-TOTAL-LAST-YTD.\n029300     MOVE CHANGE-AMOUNT TO STL-CHANGE-AMOUNT.\n029400     IF SALESREP-TOTAL-LAST-YTD = ZERO\n029500         MOVE 999.9 TO STL-CHANGE-PERCENT\n029600     ELSE\n029700         COMPUTE STL-CHANGE-PERCENT ROUNDED =\n029800             CHANGE-AMOUNT * 100 / SALESREP-TOTAL-LAST-YTD\n029900             ON SIZE ERROR\n030000                 MOVE 999.9 TO STL-CHANGE-PERCENT.\n030100     MOVE SALESREP-TOTAL-LINE TO PRINT-AREA.\n030200     MOVE 1 TO SPACE-CONTROL.\n030300     PERFORM 350-WRITE-REPORT-LINE.\n030400     MOVE 2 TO SPACE-CONTROL.\n030500     MOVE ZERO TO SALESREP-TOTAL-THIS-YTD.\n030600     MOVE ZERO TO SALESREP-TOTAL-LAST-YTD.\n030700*\n030800 360-PRINT-BRANCH-LINE.\n030900*\n031000     MOVE BRANCH-TOTAL-THIS-YTD TO BTL-SALES-THIS-YTD.\n031100     MOVE BRANCH-TOTAL-LAST-YTD TO BTL-SALES-LAST-YTD.\n031200     COMPUTE CHANGE-AMOUNT =\n031300         BRANCH-TOTAL-THIS-YTD - BRANCH-TOTAL-LAST-YTD.\n031400     MOVE CHANGE-AMOUNT TO BTL-CHANGE-AMOUNT.\n031500     IF BRANCH-TOTAL-LAST-YTD = ZERO\n031600         MOVE 999.9 TO BTL-CHANGE-PERCENT\n031700     ELSE\n031800         COMPUTE BTL-CHANGE-PERCENT ROUNDED =\n031900             CHANGE-AMOUNT * 100 / BRANCH-TOTAL-LAST-YTD\n032000             ON SIZE ERROR\n032100                 MOVE 999.9 TO BTL-CHANGE-PERCENT.\n032200     MOVE BRANCH-TOTAL-LINE TO PRINT-AREA.\n032300     MOVE 2 TO SPACE-CONTROL.\n032400     PERFORM 350-WRITE-REPORT-LINE.\n032500     ADD BRANCH-TOTAL-THIS-YTD TO GRAND-TOTAL-THIS-YTD.\n032600     ADD BRANCH-TOTAL-LAST-YTD TO GRAND-TOTAL-LAST-YTD.\n032700     MOVE ZERO TO BRANCH-TOTAL-THIS-YTD.\n032800     MOVE ZERO TO BRANCH-TOTAL-LAST-YTD.\n032900*\n033000 500-PRINT-GRAND-TOTALS.\n033100*\n033200     MOVE GRAND-TOTAL-THIS-YTD TO GTL-SALES-THIS-YTD.\n033300     MOVE GRAND-TOTAL-LAST-YTD TO GTL-SALES-LAST-YTD.\n033400     COMPUTE CHANGE-AMOUNT =\n033500         GRAND-TOTAL-THIS-YTD - GRAND-TOTAL-LAST-YTD.\n033600     MOVE CHANGE-AMOUNT TO GTL-CHANGE-AMOUNT.\n033700     IF GRAND-TOTAL-LAST-YTD = ZERO\n033800         MOVE 999.9 TO GTL-CHANGE-PERCENT\n033900     ELSE\n034000         COMPUTE GTL-CHANGE-PERCENT ROUNDED =\n034100             CHANGE-AMOUNT * 100 / GRAND-TOTAL-LAST-YTD\n034200             ON SIZE ERROR\n034300                 MOVE 999.9 TO GTL-CHANGE-PERCENT.\n034400     MOVE GRAND-TOTAL-LINE TO PRINT-AREA.\n034500     MOVE 2 TO SPACE-CONTROL.\n034600     PERFORM 350-WRITE-REPORT-LINE.\n./ ADD NAME=SEQ1000C 0104-01302-01311-1322-00151-00146-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID.  SEQ1000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000\n001100     SELECT RCTTRAN  ASSIGN TO RCTTRAN.\n001300     SELECT OLDMAST  ASSIGN TO OLDMAST.\n001500     SELECT NEWMAST  ASSIGN TO NEWMAST\n001700                     FILE STATUS IS NEWMAST-FILE-STATUS.\n001800     SELECT ERRTRAN  ASSIGN TO ERRTRAN\n002000                     FILE STATUS IS ERRTRAN-FILE-STATUS.\n002100*\n002200 DATA DIVISION.\n002300*\n002400 FILE SECTION.\n002410\n002500*\n002600 FD  RCTTRAN\n002610     RECORDING MODE IS F\n002620     LABEL RECORDS ARE STANDARD.\n002700*\n002800 01  TRANSACTION-RECORD      PIC X(23).\n002900*\n003000 FD  OLDMAST\n003010     RECORDING MODE IS F\n003020     LABEL RECORDS ARE STANDARD.\n003100*\n003200 01  OLD-MASTER-RECORD       PIC X(70).\n003300*\n003400 FD  NEWMAST\n003410     RECORDING MODE IS F\n003420     LABEL RECORDS ARE STANDARD.\n003500*\n003600 01  NEW-MASTER-RECORD       PIC X(70).\n003700*\n003800 FD  ERRTRAN\n003810     RECORDING MODE IS F\n003820     LABEL RECORDS ARE STANDARD.\n003900*\n004000 01  ERROR-TRANSACTION       PIC X(23).\n004100*\n004200 WORKING-STORAGE SECTION.\n004300*\n004400 01  SWITCHES.\n004500     05  FIRST-EXECUTION-SWITCH          PIC X   VALUE \"Y\".\n004600         88  FIRST-EXECUTION                     VALUE \"Y\".\n004700     05  ALL-RECORDS-PROCESSED-SWITCH    PIC X   VALUE \"N\".\n004800         88  ALL-RECORDS-PROCESSED               VALUE \"Y\".\n004900*\n005000 01  FILE-STATUS-FIELDS.\n005100     05  NEWMAST-FILE-STATUS     PIC XX.\n005200         88  NEWMAST-SUCCESSFUL          VALUE \"00\".\n005300     05  ERRTRAN-FILE-STATUS     PIC XX.\n005400         88  ERRTRAN-SUCCESSFUL          VALUE \"00\".\n005500*\n005600 01  RECEIPT-TRANSACTION.\n005700     05  RT-ITEM-NO              PIC X(5).\n005800     05  RT-VENDOR-NO            PIC X(5).\n005900     05  RT-RECEIPT-DATE         PIC X(8).\n006000     05  RT-RECEIPT-QUANTITY     PIC S9(5).\n006100*\n006200 01  INVENTORY-MASTER-RECORD.\n006300     05  IM-ITEM-NO              PIC X(5).\n006400     05  IM-DESCRIPTIVE-DATA.\n006500         10  IM-ITEM-DESC        PIC X(40).\n006600         10  IM-UNIT-COST        PIC S9(3)V99.\n006700         10  IM-UNIT-PRICE       PIC S9(3)V99.\n006800     05  IM-INVENTORY-DATA.\n006900         10  IM-REORDER-POINT    PIC S9(5).\n007000         10  IM-ON-HAND          PIC S9(5).\n007100         10  IM-ON-ORDER         PIC S9(5).\n007200*\n007300 PROCEDURE DIVISION.\n007400*\n007500 000-UPDATE-INVENTORY-MASTER.\n007600*\n007700     OPEN INPUT  RCTTRAN\n007800                 OLDMAST\n007900          OUTPUT NEWMAST\n008000          EXTEND ERRTRAN.\n008100     MOVE LOW-VALUE TO IM-ITEM-NO.\n008200     PERFORM 300-PROCESS-RECEIPT-TRAN\n008300         UNTIL ALL-RECORDS-PROCESSED.\n008400     CLOSE RCTTRAN\n008500           OLDMAST\n008600           NEWMAST\n008700           ERRTRAN.\n008800     STOP RUN.\n008900*\n009000 300-PROCESS-RECEIPT-TRAN.\n009100*\n009200     PERFORM 310-READ-RECEIPT-TRANSACTION.\n009300     PERFORM 320-PROCESS-INVENTORY-MASTER\n009400         UNTIL IM-ITEM-NO >= RT-ITEM-NO.\n009500     IF      IM-ITEM-NO = HIGH-VALUE\n009600         AND RT-ITEM-NO = HIGH-VALUE\n009700         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH\n009800     ELSE\n009900         IF IM-ITEM-NO = RT-ITEM-NO\n010000             PERFORM 350-APPLY-RECEIPT-TRANSACTION\n010100         ELSE\n010200             PERFORM 360-WRITE-ERROR-TRANSACTION.\n010300*\n010400 310-READ-RECEIPT-TRANSACTION.\n010500*\n010600     READ RCTTRAN INTO RECEIPT-TRANSACTION\n010700         AT END\n010800             MOVE HIGH-VALUE TO RT-ITEM-NO.\n010900*\n011000 320-PROCESS-INVENTORY-MASTER.\n011100*\n011200     IF FIRST-EXECUTION\n011300         PERFORM 330-READ-OLD-MASTER\n011400         MOVE \"N\" TO FIRST-EXECUTION-SWITCH\n011500     ELSE\n011600         PERFORM 340-WRITE-NEW-MASTER\n011700         PERFORM 330-READ-OLD-MASTER.\n011800*\n011900 330-READ-OLD-MASTER.\n012000*\n012100     READ OLDMAST INTO INVENTORY-MASTER-RECORD\n012200         AT END\n012300             MOVE HIGH-VALUE TO IM-ITEM-NO.\n012400*\n012500 340-WRITE-NEW-MASTER.\n012600*\n012700     WRITE NEW-MASTER-RECORD FROM INVENTORY-MASTER-RECORD.\n012800     IF NOT NEWMAST-SUCCESSFUL\n012900         DISPLAY \"WRITE ERROR ON NEWMAST FOR ITEM NUMBER \"\n013000             IM-ITEM-NO\n013100         DISPLAY \"FILE STATUS CODE IS \" NEWMAST-FILE-STATUS\n013200         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH.\n013300*\n013400 350-APPLY-RECEIPT-TRANSACTION.\n013500*\n013600     ADD RT-RECEIPT-QUANTITY TO IM-ON-HAND.\n013700     SUBTRACT RT-RECEIPT-QUANTITY FROM IM-ON-ORDER.\n013800*\n013900 360-WRITE-ERROR-TRANSACTION.\n014000*\n014100     WRITE ERROR-TRANSACTION FROM RECEIPT-TRANSACTION.\n014200     IF NOT ERRTRAN-SUCCESSFUL\n014300         DISPLAY \"WRITE ERROR ON ERRTRAN FOR ITEM NUMBER \"\n014400             RT-ITEM-NO\n014500         DISPLAY \"FILE STATUS CODE IS \" ERRTRAN-FILE-STATUS\n014600         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH.\n./ ADD NAME=SEQ2000C 0101-01302-01302-1149-00213-00213-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID.  SEQ2000C.\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000\n001100     SELECT MNTTRAN  ASSIGN TO MNTTRAN.\n001200     SELECT OLDMAST  ASSIGN TO OLDMAST.\n001300     SELECT NEWMAST  ASSIGN TO NEWMAST\n001400                     FILE STATUS IS NEWMAST-FILE-STATUS.\n001500     SELECT ERRTRAN  ASSIGN TO ERRTRAN\n001600                     FILE STATUS IS ERRTRAN-FILE-STATUS.\n001700*\n001800 DATA DIVISION.\n001900*\n002000 FILE SECTION.\n002100*\n002200 FD  MNTTRAN.\n002300*\n002400 01  TRANSACTION-RECORD      PIC X(61).\n002500*\n002600 FD  OLDMAST.\n002700*\n002800 01  OLD-MASTER-RECORD       PIC X(70).\n002900*\n003000 FD  NEWMAST.\n003100*\n003200 01  NEW-MASTER-RECORD.\n003300*\n003400     05  NM-ITEM-NO              PIC X(5).\n003500     05  NM-DESCRIPTIVE-DATA.\n003600         10  NM-ITEM-DESC        PIC X(40).\n003700         10  NM-UNIT-COST        PIC S9(3)V99.\n003800         10  NM-UNIT-PRICE       PIC S9(3)V99.\n003900     05  NM-INVENTORY-DATA.\n004000         10  NM-REORDER-POINT    PIC S9(5).\n004100         10  NM-ON-HAND          PIC S9(5).\n004200         10  NM-ON-ORDER         PIC S9(5).\n004300*\n004400 FD  ERRTRAN.\n004500*\n004600 01  ERROR-TRANSACTION       PIC X(61).\n004700*\n004800 WORKING-STORAGE SECTION.\n004900*\n005000 01  SWITCHES.\n005100     05  ALL-RECORDS-PROCESSED-SWITCH    PIC X   VALUE \"N\".\n005200         88  ALL-RECORDS-PROCESSED               VALUE \"Y\".\n005300     05  NEED-TRANSACTION-SWITCH         PIC X   VALUE \"Y\".\n005400         88  NEED-TRANSACTION                    VALUE \"Y\".\n005500     05  NEED-MASTER-SWITCH              PIC X   VALUE \"Y\".\n005600         88  NEED-MASTER                         VALUE \"Y\".\n005700     05  WRITE-MASTER-SWITCH             PIC X   VALUE \"N\".\n005800         88  WRITE-MASTER                        VALUE \"Y\".\n005900*\n006000 01  FILE-STATUS-FIELDS.\n006100     05  NEWMAST-FILE-STATUS     PIC XX.\n006200         88  NEWMAST-SUCCESSFUL          VALUE \"00\".\n006300     05  ERRTRAN-FILE-STATUS     PIC XX.\n006400         88  ERRTRAN-SUCCESSFUL          VALUE \"00\".\n006500*\n006600 01  MAINTENANCE-TRANSACTION.\n006700     05  MT-TRANSACTION-CODE     PIC X.\n006800         88  DELETE-RECORD               VALUE \"1\".\n006900         88  ADD-RECORD                  VALUE \"2\".\n007000         88  CHANGE-RECORD               VALUE \"3\".\n007100     05  MT-MASTER-DATA.\n007200         10  MT-ITEM-NO          PIC X(5).\n007300         10  MT-ITEM-DESC        PIC X(40).\n007400         10  MT-UNIT-COST        PIC S9(3)V99.\n007500         10  MT-UNIT-PRICE       PIC S9(3)V99.\n007600         10  MT-REORDER-POINT    PIC S9(5).\n007700*\n007800 01  INVENTORY-MASTER-RECORD.\n007900     05  IM-ITEM-NO              PIC X(5).\n008000     05  IM-DESCRIPTIVE-DATA.\n008100         10  IM-ITEM-DESC        PIC X(40).\n008200         10  IM-UNIT-COST        PIC S9(3)V99.\n008300         10  IM-UNIT-PRICE       PIC S9(3)V99.\n008400     05  IM-INVENTORY-DATA.\n008500         10  IM-REORDER-POINT    PIC S9(5).\n008600         10  IM-ON-HAND          PIC S9(5).\n008700         10  IM-ON-ORDER         PIC S9(5).\n008800*\n008900 PROCEDURE DIVISION.\n009000*\n009100 000-MAINTAIN-INVENTORY-FILE.\n009200*\n009300     OPEN INPUT  OLDMAST\n009400                 MNTTRAN\n009500          OUTPUT NEWMAST\n009600                 ERRTRAN.\n009700     PERFORM 300-MAINTAIN-INVENTORY-RECORD\n009800         UNTIL ALL-RECORDS-PROCESSED.\n009900     CLOSE MNTTRAN\n010000           OLDMAST\n010100           NEWMAST\n010200           ERRTRAN.\n010300     STOP RUN.\n010400*\n010500 300-MAINTAIN-INVENTORY-RECORD.\n010600*\n010700     IF NEED-TRANSACTION\n010800         PERFORM 310-READ-INVENTORY-TRANSACTION\n010900         MOVE \"N\" TO NEED-TRANSACTION-SWITCH.\n011000     IF NEED-MASTER\n011100         PERFORM 320-READ-OLD-MASTER\n011200         MOVE \"N\" TO NEED-MASTER-SWITCH.\n011300     PERFORM 330-MATCH-MASTER-TRAN.\n011400     IF WRITE-MASTER\n011500         PERFORM 340-WRITE-NEW-MASTER\n011600         MOVE \"N\" TO WRITE-MASTER-SWITCH.\n011700*\n011800 310-READ-INVENTORY-TRANSACTION.\n011900*\n012000     READ MNTTRAN INTO MAINTENANCE-TRANSACTION\n012100         AT END\n012200             MOVE HIGH-VALUE TO MT-ITEM-NO.\n012300*\n012400 320-READ-OLD-MASTER.\n012500*\n012600     READ OLDMAST INTO INVENTORY-MASTER-RECORD\n012700         AT END\n012800             MOVE HIGH-VALUE TO IM-ITEM-NO.\n012900*\n013000 330-MATCH-MASTER-TRAN.\n013100*\n013200     IF IM-ITEM-NO > MT-ITEM-NO\n013300         PERFORM 350-PROCESS-HI-MASTER\n013400     ELSE IF IM-ITEM-NO < MT-ITEM-NO\n013500         PERFORM 360-PROCESS-LO-MASTER\n013600     ELSE\n013700         PERFORM 370-PROCESS-MAST-TRAN-EQUAL.\n013800\n013900 340-WRITE-NEW-MASTER.\n014000*\n014100     WRITE NEW-MASTER-RECORD.\n014200     IF NOT NEWMAST-SUCCESSFUL\n014300         DISPLAY \"WRITE ERROR ON NEWMAST FOR ITEM NUMBER \"\n014400             IM-ITEM-NO\n014500         DISPLAY \"FILE STATUS CODE IS \" NEWMAST-FILE-STATUS\n014600         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH.\n014700*\n014800 350-PROCESS-HI-MASTER.\n014900*\n015000     IF ADD-RECORD\n015100         PERFORM 380-APPLY-ADD-TRANSACTION\n015200     ELSE\n015300         PERFORM 390-WRITE-ERROR-TRANSACTION.\n015400*\n015500 360-PROCESS-LO-MASTER.\n015600*\n015700     MOVE INVENTORY-MASTER-RECORD TO NEW-MASTER-RECORD.\n015800     MOVE \"Y\" TO WRITE-MASTER-SWITCH.\n015900     MOVE \"Y\" TO NEED-MASTER-SWITCH.\n016000*\n016100 370-PROCESS-MAST-TRAN-EQUAL.\n016200*\n016300     IF IM-ITEM-NO = HIGH-VALUES\n016400         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH\n016500     ELSE\n016600         IF DELETE-RECORD\n016700             PERFORM 400-APPLY-DELETE-TRANSACTION\n016800         ELSE\n016900             IF CHANGE-RECORD\n017000                 PERFORM 410-APPLY-CHANGE-TRANSACTION\n017100             ELSE\n017200                 PERFORM 390-WRITE-ERROR-TRANSACTION.\n017300*\n017400 380-APPLY-ADD-TRANSACTION.\n017500*\n017600     MOVE MT-ITEM-NO TO NM-ITEM-NO.\n017700     MOVE MT-ITEM-DESC TO NM-ITEM-DESC.\n017800     MOVE MT-UNIT-COST TO NM-UNIT-COST.\n017900     MOVE MT-UNIT-PRICE TO NM-UNIT-PRICE.\n018000     MOVE MT-REORDER-POINT TO NM-REORDER-POINT.\n018100     MOVE ZERO TO NM-ON-HAND\n018200                  NM-ON-ORDER.\n018300     MOVE \"Y\" TO WRITE-MASTER-SWITCH.\n018400     MOVE \"Y\" TO NEED-TRANSACTION-SWITCH.\n018500*\n018600 390-WRITE-ERROR-TRANSACTION.\n018700*\n018800     WRITE ERROR-TRANSACTION FROM MAINTENANCE-TRANSACTION.\n018900     IF NOT ERRTRAN-SUCCESSFUL\n019000         DISPLAY \"WRITE ERROR ON ERRTRAN FOR ITEM NUMBER \"\n019100             MT-ITEM-NO\n019200         DISPLAY \"FILE STATUS CODE IS \" ERRTRAN-FILE-STATUS\n019300         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH\n019400     ELSE\n019500         MOVE \"Y\" TO NEED-TRANSACTION-SWITCH.\n019600*\n019700 400-APPLY-DELETE-TRANSACTION.\n019800*\n019900     MOVE \"Y\" TO NEED-MASTER-SWITCH.\n020000     MOVE \"Y\" TO NEED-TRANSACTION-SWITCH.\n020100\n020200*\n020300 410-APPLY-CHANGE-TRANSACTION.\n020400*\n020500     IF MT-ITEM-DESC NOT = SPACE\n020600         MOVE MT-ITEM-DESC TO IM-ITEM-DESC.\n020700     IF MT-UNIT-COST NOT = ZERO\n020800         MOVE MT-UNIT-COST TO IM-UNIT-COST.\n020900     IF MT-UNIT-PRICE NOT = ZERO\n021000         MOVE MT-UNIT-PRICE TO IM-UNIT-PRICE.\n021100     IF MT-REORDER-POINT NOT = ZERO\n021200         MOVE MT-REORDER-POINT TO IM-REORDER-POINT.\n021300     MOVE \"Y\" TO NEED-TRANSACTION-SWITCH.\n./ ADD NAME=SKELETNC 0116-01288-01302-1150-00196-00132-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.                                         @\n000200 PROGRAM-ID.    SKELETNC.                                         @\n000300 AUTHOR. PROGRAMMER-NAME.                                         @\n000400***************************************************************** @\n000500*REMARKS. SKELETON FOR WRITING NEW PROGRAMS IN COBOL.           * @\n000600*      1. CHANGE ALL 'SKELETNC' TO YOUR PROGRAM NAME            * @\n000700*      2. CHANGE THE AUTHOR STATEMENT ABOVE TO SHOW YOUR NAME AS* @\n000800*         PROGRAMMER.                                           * @\n000900*      3. IN FILE-CONTROL BELOW, INCLUDE SELECT STATEMENTS FOR  * @\n001000*         ALL FILES USED BY THE PROGRAM.                        * @\n001100*      4. IN THE FILE SECTION BELOW, DESCRIBE ALL THE FILES TO  * @\n001200*         BE USED BY THE PROGRAM. THIS WOULD INCLUDE AN FD AND  * @\n001300*         AT LEAST ONE DATA RECORD DESCRIPTION FOR EACH FILE.   * @\n001400*      5. NOTE THAT COBOL STATEMENTS ARE CONTAINED BETWEEN      * @\n001500*         COLUMN 1 AND 71. COLUMN 72 IS USED AS A CONTINUATION  * @\n001600*         INDICATOR AND MUST BE BLANK EXCEPT WHEN CONTINUING A  * @\n001700*         NON-NUMERIC LITERAL. THE @ CHARACTERS ARE SET UP IN   * @\n001800*         COLUMN 73 AS AN AID TO PREVENT RUNNING PAST COLUMN 71.* @\n001900*         THEY MAY BE DELETED WHEN FINISHED CODING IF DESIRED.  * @\n002000*      6. THE REMARKS SECTION SHOULD BE USED TO DESCRIBE THE    * @\n002100*         PROGRAM AFTER DELETING THESE NOTES.                   * @\n002200***************************************************************** @\n002300 ENVIRONMENT DIVISION.                                            @\n002400 CONFIGURATION SECTION.                                           @\n002410 SPECIAL-NAMES.                                                   @\n002420     C01 IS TOP-OF-PAGE.                                          @\n002500 INPUT-OUTPUT SECTION.                                            @\n002600 FILE-CONTROL.                                                    @\n002700     SELECT INPUT-FILE ASSIGN TO INPUT1.                          @\n002800     SELECT OUTPUT-FILE ASSIGN TO OUTPUT1.                        @\n002900     SELECT PRINT-FILE ASSIGN TO PRINT1.                          @\n003000 DATA DIVISION.                                                   @\n003100 FILE SECTION.                                                    @\n003200 FD  INPUT-FILE                                                   @\n003300     BLOCK CONTAINS 0 RECORDS                                     @\n003400     RECORD CONTAINS 80 CHARACTERS                                @\n003500     RECORDING MODE IS F                                          @\n003600     LABEL RECORDS ARE STANDARD.                                  @\n003700 01  INPUT-RECORD-1.                                              @     10\n003800     05  IR1-FIELD1                 PIC XX.                       @     20\n003900     05  IR1-FIELD2                 PIC X(14).                    @     30\n004000     05  IR1-FIELD3                 PIC Z(5).                     @     30\n004100     05  FILLER                     PIC X(59).                    @     40\n004200 01  INPUT-RECORD-2.                                              @\n004300     05  IR2-FIELD1                 PIC XX.                       @\n004400     05  IR2-FIELD2                 PIC X(25).                    @\n004500     05  FILLER                     PIC X.                        @\n004600     05  IR2-FIELD3                 PIC X(7).                     @\n004700     05  IR2-FIELD4                 PIC X(2).                     @\n004800     05  IR2-FIELD5                 PIC X(25).                    @\n004900     05  IR2-FIELD6                 PIC X(18).                    @\n005000                                                                  @\n005100 FD  OUTPUT-FILE                                                  @\n005200     BLOCK CONTAINS 0 RECORDS                                     @\n005300     RECORD CONTAINS 40 TO 225 CHARACTERS                         @\n005400     RECORDING MODE IS V                                          @\n005500     LABEL RECORDS ARE STANDARD.                                  @\n005600 01  OUTPUT-RECORD-1.                                             @     10\n005700   05  OR1-FIELD1                   PIC XX.                       @     20\n005800   05  OR1-FILLD2                   PIC X(14).                    @     30\n005900   05  OR1-FIELD3                   PIC Z(5).                     @     30\n006000   05  OR1-FIELD4                   PIC X(204).                   @     40\n006100 01  OUTPUT-RECORD-2.                                             @     10\n006200   05  OR2-FIELD1                   PIC XX.                       @     20\n006300   05  OR2-FIELD2                   PIC X(25).                    @     30\n006400   05  OR2-FIELD3                   PIC S9(5)V99 COMP.            @     30\n006500   05  OR2-FIELD4                   PIC X(77).                    @     40\n006600   05  OR2-FIELD5                   PIC X(7).                     @\n006700 01  OUTPUT-RECORD-3.                                             @     10\n006800   05  OR3-FIELD1                   PIC XX.                       @     20\n006900   05  OR3-FIELD2                   PIC X(12).                    @     30\n007000   05  OR3-FIELD3                   PIC S9(5)V99 COMP-3.          @     30\n007100   05  OR3-FIELD4                   PIC X(22).                    @     40\n007200                                                                  @\n007300 FD  PRINT-FILE                                                   @\n007400     BLOCK CONTAINS 0 RECORDS                                     @\n007500     RECORD CONTAINS 133 CHARACTERS                               @\n007600     RECORDING MODE IS F                                          @\n007700     LABEL RECORDS ARE STANDARD.                                  @\n007800 01  PRINT-RECORD-1.                                              @     10\n007900     05  PR1-CC                     PIC X.                        @\n008000     05  PR1-DATA                   PIC X(132).                   @\n008100 01  PR1-EOJ-COUNTS.                                              @     10\n008200   05  FILLER                       PIC X.                        @     20\n008300   05  PR-EOJ-COUNTER               PIC ZZ,ZZZ,ZZ9.               @     30\n008400   05  FILLER                       PIC X.                        @     20\n008500   05  PR-EOJ-COUNT-NAME            PIC X(121).                   @     20\n008600                                                                  @\n008700 WORKING-STORAGE SECTION.                                         @\n008800 77  FILLER                         PIC X(36)  VALUE              @\n008900     'SKELETNC WORKING STORAGE BEGINS HERE'.                      @\n009000 01  WS-SWITCHES-AND-INDICATORS.                                  @\n009100     05  WS-END-OF-INPUT1-SWITCH    PIC X VALUE 'N'.              @\n009200         88  WS-END-OF-INPUT1-DATA    VALUE IS 'Y'.               @\n009300         88  WS-MORE-DATA-TO-PROCESS  VALUE IS 'N'.               @\n009400                                                                  @\n009500 01  WS-MISCELLANEOUS-WORK-AREAS.                                 @\n009600     05  WS-OUTPUT1-RECORD-COUNTER  PIC S9(8) COMP-3 VALUE +0.    @\n009700     05  WS-INPUT1-RECORD-COUNTER   PIC S9(8) COMP-3 VALUE +0.    @\n009800     05  WS-LINE-COUNT              PIC S99 COMP-3 VALUE +0.      @\n009900     05  WS-LINE-SPACING            PIC 9 VALUE 1.                @\n010000     05  WS-PAGE-NUMBER             PIC S9(4) COMP-3 VALUE +0.    @\n010100     05  WS-TODAYS-DATE.                                          @\n010200         10  WS-TODAYS-YEAR         PIC X(4).                     @\n010300         10  WS-TODAYS-MONTH        PIC XX.                       @\n010400         10  WS-TODAYS-DAY          PIC XX.                       @\n010500                                                                  @\n010600 01  WS-HEADING-LINE-1.                                           @\n010700     05  FILLER                     PIC X VALUE '2'.              @\n010800     05  FILLER                     PIC X(8) VALUE 'SKELETNC'.    @\n010900     05  FILLER                     PIC X VALUE ' '.              @\n011000     05  WS-HEADING-DATE.                                         @\n011100         10  WS-HEADING-MONTH       PIC X(2).                     @\n011200         10  FILLER                 PIC X VALUE '/'.              @\n011300         10  WS-HEADING-DAY         PIC XX.                       @\n011400         10  FILLER                 PIC X VALUE '/'.              @\n011500         10  WS-HEADING-YEAR        PIC X(4).                     @\n011600     05  FILLER                     PIC X(42) VALUE SPACES.       @\n011700     05  FILLER                     PIC X(21) VALUE               @\n011800                                   'CENTERED REPORT TITLE'.       @\n011900     05  FILLER                     PIC X(41) VALUE SPACES.       @\n012000     05  FILLER                     PIC X(5) VALUE 'PAGE '.       @\n012100     05  WS-HEADING-PAGE-NUMBER     PIC ZZZ9.                     @\n012200                                                                  @\n012300 LINKAGE SECTION.                                                 @\n012400 01  EXEC-PARM-FIELD.                                             @\n012500     05  EXEC-PARM-LENGTH           PIC S9(4) COMP.               @\n012600     05  EXEC-PARM-DATA             PIC X(104).                   @\n012700                                                                  @\n012800 PROCEDURE DIVISION USING EXEC-PARM-FIELD.                        @\n012900                                                                  @\n013000 A100-EXECUTIVE-CONTROL.                                          @\n013100     PERFORM A100-INITIALIZATION.                                 @\n013200     PERFORM B100-MAINLINE-PROCESSING UNTIL                       @\n013210         WS-END-OF-INPUT1-DATA.                                   @\n013300     PERFORM Z100-END-OF-PROCESSING.                              @\n013400     GOBACK.                                                      @\n013500                                                                  @\n013600 A100-INITIALIZATION.                                             @\n013700     OPEN INPUT INPUT-FILE,                                       @\n013800          OUTPUT OUTPUT-FILE, PRINT-FILE.                         @\n013900     ACCEPT WS-TODAYS-DATE FROM DATE YYYYMMDD.                    @\n014000     MOVE WS-TODAYS-YEAR TO WS-HEADING-YEAR.                      @\n014100     MOVE WS-TODAYS-MONTH TO WS-HEADING-MONTH.                    @\n014200     MOVE WS-TODAYS-DAY TO WS-HEADING-DAY.                        @\n014300                                                                  @\n014400 B100-MAINLINE-PROCESSING.                                        @\n014500     PERFORM C100-READ-INPUT-FILE THRU C100-EXIT.                 @\n014600     IF WS-MORE-DATA-TO-PROCESS                                   @\n014700        PERFORM D100-PROCESS-THE-RECORD THRU D100-EXIT.           @\n014800     PERFORM E100-WRITE-OUTPUT-FILE THRU E100-EXIT.               @\n014900                                                                  @\n015000 C100-READ-INPUT-FILE.                                            @\n015100     READ INPUT-FILE                                              @\n015200         AT END                                                   @\n015201             MOVE 'Y' TO WS-END-OF-INPUT1-SWITCH                  @\n015210             GO TO C100-EXIT.                                     @     30\n015220     ADD +1 TO WS-INPUT1-RECORD-COUNTER.                          @     30\n015300 C100-EXIT. EXIT.                                                 @\n015400                                                                  @\n015500 D100-PROCESS-THE-RECORD.                                         @\n015600     IF WS-END-OF-INPUT1-DATA                                     @\n015700         GO TO D100-EXIT.                                         @\n015800 D100-EXIT. EXIT.                                                 @\n015900                                                                  @\n016000 E100-WRITE-OUTPUT-FILE.                                          @\n016100     WRITE OUTPUT-RECORD-1.                                       @\n016200     ADD 1 TO WS-OUTPUT1-RECORD-COUNTER.                          @\n016300 E100-EXIT. EXIT.                                                 @\n016400                                                                  @\n016500 Y100-PRINT-A-LINE.                                               @\n016600     WRITE PRINT-RECORD-1 AFTER ADVANCING WS-LINE-SPACING.        @\n016700     ADD WS-LINE-SPACING TO WS-LINE-COUNT.                        @\n016800     IF WS-LINE-COUNT IS GREATER THAN 60                          @\n016900         PERFORM Y200-PRINT-HEADING THRU Y200-EXIT.               @\n017000 Y100-EXIT. EXIT.                                                 @\n017100                                                                  @\n017200 Y200-PRINT-HEADING.                                              @\n017300     ADD 1 TO WS-PAGE-NUMBER.                                     @\n017400     MOVE WS-PAGE-NUMBER TO WS-HEADING-PAGE-NUMBER.               @\n017500     MOVE WS-HEADING-LINE-1 TO PRINT-RECORD-1.                    @\n017600     WRITE PRINT-RECORD-1 AFTER ADVANCING TOP-OF-PAGE.            @\n017700     MOVE 2 TO WS-LINE-COUNT.                                     @\n017800     MOVE SPACES TO PRINT-RECORD-1.                               @\n017900 Y200-EXIT. EXIT.                                                 @\n018000                                                                  @\n018100 Z100-END-OF-PROCESSING.                                          @\n018200     MOVE 'INPUT RECORDS READ' TO PR-EOJ-COUNT-NAME.              @     20\n018300     MOVE WS-INPUT1-RECORD-COUNTER TO PR-EOJ-COUNTER.             @     30\n018400     PERFORM Y100-PRINT-A-LINE THRU Y100-EXIT.                    @\n018500     MOVE 'OUTPUT RECORDS WRITTEN' TO PR-EOJ-COUNT-NAME.          @     20\n018600     MOVE WS-OUTPUT1-RECORD-COUNTER TO PR-EOJ-COUNTER.            @\n018700     PERFORM Y100-PRINT-A-LINE THRU Y100-EXIT.                    @\n018800     CLOSE INPUT-FILE,                                            @\n018900           OUTPUT-FILE,                                           @\n019000           PRINT-FILE.                                            @\n./ ADD NAME=SRT1000C 0101-01302-01302-1152-00196-00196-00000-BC0THOR\n000100 IDENTIFICATION DIVISION.\n000200*\n000300 PROGRAM-ID.  SRT1000C\n000400*\n000500 ENVIRONMENT DIVISION.\n000600*\n000700 INPUT-OUTPUT SECTION.\n000800*\n000900 FILE-CONTROL.\n001000*\n001100     SELECT RCTTRAN  ASSIGN TO RCTTRAN.\n001200     SELECT OLDMAST  ASSIGN TO OLDMAST.\n001300     SELECT NEWMAST  ASSIGN TO NEWMAST\n001400                     FILE STATUS IS NEWMAST-FILE-STATUS.\n001500     SELECT ERRTRAN  ASSIGN TO ERRTRAN\n001600                     FILE STATUS IS ERRTRAN-FILE-STATUS.\n001700     SELECT SORTWORK ASSIGN TO SORTWORK.\n001800*\n001900 DATA DIVISION.\n002000*\n002100 FILE SECTION.\n002200*\n002300 FD  RCTTRAN.\n002400*\n002500 01  TRANSACTION-RECORD      PIC X(23).\n002600*\n002700 FD  OLDMAST.\n002800*\n002900 01  OLD-MASTER-RECORD       PIC X(70).\n003000*\n003100 FD  NEWMAST.\n003200*\n003300 01  NEW-MASTER-RECORD       PIC X(70).\n003400*\n003500 FD  ERRTRAN.\n003600*\n003700 01  ERROR-TRANSACTION       PIC X(23).\n003800*\n003900 SD  SORTWORK.\n004000*\n004100 01  SORT-WORK-AREA.\n004200     05  SW-ITEM-NO          PIC X(5).\n004300     05  FILLER              PIC X(18).\n004400*\n004500 WORKING-STORAGE SECTION.\n004600*\n004700 01  SWITCHES.\n004800     05  TRANSACTION-EOF-SWITCH          PIC X   VALUE \"N\".\n004900         88  TRANSACTION-EOF                     VALUE \"Y\".\n005000     05  VALID-TRANSACTION-SWITCH        PIC X   VALUE \"Y\".\n005100         88  VALID-TRANSACTION                   VALUE \"Y\".\n005200     05  FIRST-EXECUTION-SWITCH          PIC X   VALUE \"Y\".\n005300         88  FIRST-EXECUTION                     VALUE \"Y\".\n005400     05  ALL-RECORDS-PROCESSED-SWITCH    PIC X   VALUE \"N\".\n005500         88  ALL-RECORDS-PROCESSED               VALUE \"Y\".\n005600*\n005700 01  FILE-STATUS-FIELDS.\n005800     05  NEWMAST-FILE-STATUS     PIC XX.\n005900         88  NEWMAST-SUCCESSFUL          VALUE \"00\".\n006000     05  ERRTRAN-FILE-STATUS     PIC XX.\n006100         88  ERRTRAN-SUCCESSFUL          VALUE \"00\".\n006200*\n006300 01  RECEIPT-TRANSACTION.\n006400     05  RT-ITEM-NO              PIC X(5).\n006500     05  RT-VENDOR-NO            PIC X(5).\n006600     05  RT-RECEIPT-DATE         PIC X(8).\n006700     05  RT-RECEIPT-QUANTITY-X   PIC X(5).\n006800     05  RT-RECEIPT-QUANTITY REDEFINES RT-RECEIPT-QUANTITY-X\n006900                                 PIC 9(5).\n007000*\n007100 01  INVENTORY-MASTER-RECORD.\n007200     05  IM-ITEM-NO              PIC X(5).\n007300     05  IM-DESCRIPTIVE-DATA.\n007400         10  IM-ITEM-DESC        PIC X(40).\n007500         10  IM-UNIT-COST        PIC S9(3)V99.\n007600         10  IM-UNIT-PRICE       PIC S9(3)V99.\n007700     05  IM-INVENTORY-DATA.\n007800         10  IM-REORDER-POINT    PIC S9(5).\n007900         10  IM-ON-HAND          PIC S9(5).\n008000         10  IM-ON-ORDER         PIC S9(5).\n008100*\n008200 PROCEDURE DIVISION.\n008300*\n008400 000-UPDATE-INVENTORY-FILE.\n008500*\n008600     OPEN INPUT  OLDMAST\n008700                 RCTTRAN\n008800          OUTPUT NEWMAST\n008900                 ERRTRAN.\n009000     SORT SORTWORK\n009100         ON ASCENDING KEY SW-ITEM-NO\n009200         INPUT PROCEDURE IS 100-EDIT-RECEIPT-TRANSACTIONS\n009300         OUTPUT PROCEDURE IS 400-UPDATE-INVENTORY-RECORDS.\n009400     CLOSE RCTTRAN\n009500           OLDMAST\n009600           NEWMAST\n009700           ERRTRAN.\n009800     STOP RUN.\n009900*\n010000 100-EDIT-RECEIPT-TRANSACTIONS.\n010100*\n010200     PERFORM 200-EDIT-RECEIPT-TRAN\n010300         UNTIL TRANSACTION-EOF.\n010400*\n010500 200-EDIT-RECEIPT-TRAN.\n010600*\n010700     PERFORM 210-READ-RECEIPT-TRANSACTION.\n010800     IF NOT TRANSACTION-EOF\n010900         PERFORM 220-EDIT-TRANSACTION-FIELDS\n011000         IF VALID-TRANSACTION\n011100             PERFORM 230-RELEASE-VALID-TRANSACTION\n011200         ELSE\n011300             PERFORM 240-WRITE-ERROR-TRANSACTION.\n011400*\n011500 210-READ-RECEIPT-TRANSACTION.\n011600*\n011700     READ RCTTRAN INTO RECEIPT-TRANSACTION\n011800         AT END\n011900             MOVE \"Y\" TO TRANSACTION-EOF-SWITCH.\n012000*\n012100 220-EDIT-TRANSACTION-FIELDS.\n012200*\n012300     MOVE \"Y\" TO VALID-TRANSACTION-SWITCH.\n012400     IF       RT-ITEM-NO NOT NUMERIC\n012500           OR RT-VENDOR-NO NOT NUMERIC\n012600           OR RT-RECEIPT-QUANTITY-X NOT NUMERIC\n012700         MOVE \"N\" TO VALID-TRANSACTION-SWITCH.\n012800*\n012900 230-RELEASE-VALID-TRANSACTION.\n013000*\n013100     RELEASE SORT-WORK-AREA FROM RECEIPT-TRANSACTION.\n013200*\n013300 240-WRITE-ERROR-TRANSACTION.\n013400*\n013500     WRITE ERROR-TRANSACTION FROM RECEIPT-TRANSACTION.\n013600     IF NOT ERRTRAN-SUCCESSFUL\n013700         DISPLAY \"WRITE ERROR ON ERRTRAN FOR ITEM NUMBER \"\n013800             RT-ITEM-NO\n013900         DISPLAY \"FILE STATUS CODE IS \" ERRTRAN-FILE-STATUS.\n014000*\n014100*300-SORT-VALID-TRANSACTIONS.  DUMMY MODULE DONE BY SORT PROGRAM.\n014200*\n014300 400-UPDATE-INVENTORY-RECORDS.\n014400*\n014500     MOVE LOW-VALUE TO IM-ITEM-NO.\n014600     PERFORM 500-PROCESS-RECEIPT-TRAN\n014700         UNTIL ALL-RECORDS-PROCESSED.\n014800*\n014900 500-PROCESS-RECEIPT-TRAN.\n015000*\n015100     PERFORM 510-RETURN-RECEIPT-TRANSACTION.\n015200     PERFORM 520-PROCESS-INVENTORY-MASTER\n015300         UNTIL IM-ITEM-NO >= RT-ITEM-NO.\n015400     IF     IM-ITEM-NO = HIGH-VALUE\n015500        AND RT-ITEM-NO = HIGH-VALUE\n015600         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH\n015700     ELSE\n015800         IF IM-ITEM-NO = RT-ITEM-NO\n015900             PERFORM 550-APPLY-RECEIPT-TRANSACTION\n016000         ELSE\n016100             PERFORM 240-WRITE-ERROR-TRANSACTION.\n016200*\n016300 510-RETURN-RECEIPT-TRANSACTION.\n016400*\n016500     RETURN SORTWORK INTO RECEIPT-TRANSACTION\n016600         AT END\n016700             MOVE HIGH-VALUE TO RT-ITEM-NO.\n016800*\n016900 520-PROCESS-INVENTORY-MASTER.\n017000*\n017100     IF FIRST-EXECUTION\n017200         PERFORM 530-READ-OLD-MASTER\n017300         MOVE \"N\" TO FIRST-EXECUTION-SWITCH\n017400     ELSE\n017500         PERFORM 540-WRITE-NEW-MASTER\n017600         PERFORM 530-READ-OLD-MASTER.\n017700*\n017800 530-READ-OLD-MASTER.\n017900*\n018000     READ OLDMAST INTO INVENTORY-MASTER-RECORD\n018100         AT END\n018200             MOVE HIGH-VALUE TO IM-ITEM-NO.\n018300*\n018400 540-WRITE-NEW-MASTER.\n018500*\n018600     WRITE NEW-MASTER-RECORD FROM INVENTORY-MASTER-RECORD.\n018700     IF NOT NEWMAST-SUCCESSFUL\n018800         DISPLAY \"WRITE ERROR ON NEWMAST FOR ITEM NUMBER \"\n018900             IM-ITEM-NO\n019000         DISPLAY \"FILE STATUS CODE IS \" NEWMAST-FILE-STATUS\n019100         MOVE \"Y\" TO ALL-RECORDS-PROCESSED-SWITCH.\n019200*\n019300 550-APPLY-RECEIPT-TRANSACTION.\n019400*\n019500     ADD RT-RECEIPT-QUANTITY TO IM-ON-HAND.\n019600     SUBTRACT RT-RECEIPT-QUANTITY FROM IM-ON-ORDER.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPCLAS": {"ttr": 6922, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x16\\x1f\\x01\\x02\\x16\\x1f\\t&%z%z\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-10T00:00:00", "modifydate": "2002-06-10T09:26:00", "lines": 9594, "newlines": 9594, "modlines": 0, "user": "BC0THOR"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT565/FILE565.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT565", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}