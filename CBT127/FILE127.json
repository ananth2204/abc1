{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011301000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1116934, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE127.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1116934, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1116934, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE127.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x12\\x0b'", "DS1TRBAL": "b'X0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xcc\\x00\\x03\\x00\\xcd\\x00\\x06\\x00\\x13'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " **FILE 127 REPLACEMENT FROM: CLARK HUNTER\n **                           COMPUWARE CORPORATION\n **                           SOUTHFIELD, MICHIGAN\n **                           313-540-0900\n **\n **COMMENTS FROM V232 VERSION OF CBT TAPE WITH MY UPDATES:\n **\n **FILE 127 IS IN IEBUPDTE FORMAT FROM CHRYSLER AND CONTAINS :\n              1. DASD SEEK ANALYSIS PROGRAM . THIS PROGRAM READS IN\n              GTF DATA AND SUMMARIZED DASD SIO/IO RECORDS .\n              THIS PROGRAM IS IN IEBUPDTE SYSIN FORMAT AND REQUIRES\n              THE VTOC MACROS THAT ARE CONTAINED IN EITHER FILE\n              112 OR FILE 198\n\n                   BY DEVICE CALCULATE NUMBER SIO CC = 0-3\n                    TOTAL CYLINDERS SEEKED\n                    AVERAGE CYLINDERS SEEKED\n                    AVERAGE IO TIME\n                    MAX. IO TIME OVER RUN\n              **10JAN85 FIXED FOR XA, MISC PROGRAM BUGS FIXED\n\n              2. A SAMPLE IEECVXIT PROGRAM\n                 **10JAN85 REMOVED DUE TO LACK OF INTEREST\n              3. SUBROUTINE TO PRODUCE A NICE PRINTABLE HEADER\n                 DATE\n              4  TSO CP FOR STANDALONE DIDOCS (DCMS) AUTO UPDATE\n                 **10JAN85 REMOVED DUE TO LACK OF INTEREST\n              5  PROGRAM TO LOCATE, ALLOC, DUMP THE MVS/SE2\n                 SMF D.S.\n                 **10JAN85 REMOVED DUE TO LACK OF INTEREST\n              6  COMPANY USER MODS IN SMP4 FORMAT\n                 **10JAN85 REMOVED DUE TO LACK OF INTEREST\n              7  SEE NEW STUFF BELOW:\n PDS CONTAINS:\n  MACROS:  - @ENT @RET @STCK CLEAR CONV ENTER ENTERX LEAVE MSG\n             PDEDSNAM REGS SYSGET SYSPUT  TSCVDATE\n             VTCALL VTEXCP VTFMT VTOC VTOCMSG VTOCOM VTOCPARS\n\n $DOC      - THIS FILE.\n JCL       - SAMPLE JCL USED TO DUMP PDS.\n             AND TRY TO CHECK THAT I DIDNT FORGET ANY MACROS.\n TSGTFMAP  - PGM TO REDUCE GTF SIO/IO TRACE RECORDS.\n             SEE COMMENTS AT BEGINNING OF PROGRAM FOR HOW TO RUN.\n             USES SUBR: TSCVDATE, VTOCEXCP\n             NOW SUPPORTS XA FORMAT OF GTF RECORDS\n TSCALL    - TSOCP TO CALL PROGRAMS FROM \"TASKLIB\"/STEPLIB/\n             LNKLST/LPALIB. IDEA IS TO NOT USE TSO \"CALL\" WITH\n             HARDCODED LOADLIBS THAT HAVE TO BE OPENED.\n TSCVDAT   - SUBROUTINE TO MAKE NICE PRINTABLE DATE FOR HEADINGS.\n TSDYNLXA  - PGM XA DYNALIST TO LIST ESOTERIC UNITNAMES\n             (NOTE: USES ESTAES TO EXECUTE UNAUTHORIZED!!)\n TSENQSP3  - TSOCP (AKA $DENQ) SCAN FOR GENERIC SYSDSN ENQS,\n             LOOK FOR ENQ LOCKOUTS, LOOK FOR RESERVE ENQS.\n             (NOTE USES GQSCAN)\n TSSPACE   - TSOCP TO LIST SPACE, IXVTOC STATUS, PATH(CHAN/CHPID),\n             LSPACE(FREE) SPACE, #USERS, DEVTYPE, AND ADDRESS\n             FOR DASD. CAN ASK FOR ALL DASD WITH LESS THAN\n             N PATHS TO SEE IF ANY DASD PATHS ARE MISSING.\n TSSYSTEM  - TSOCP SHOW RELEASE, CPUTYPE, CPUSERIAL#, SYSRES,\n             REAL STORAGE, HOW LONG SINCE (IPL/SET IPS).\n VTOC      - TSOCP VTOC - FIXED TO SP3/XA UCBSCAN,\n             HANDLES 123 EXTENTS WITH DF/EF.\n             (NOTE I USE ENTRY VTOCEXCP FOR VTOC READING IN TSGTFMAP)\n ** SORRY THERE ISNT A LOT OF NEW DOC, BUT I WOULDNT GET THIS STUFF\n ** OUT UNTIL 1986 IF I DID THAT.\n ** EVERYTHING HAS BEEN USED ON SP3 AND XA2.1.1.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JCL": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//SYS326  JOB (90,0031),'MVS-PERFORMANCE',\n// CLASS=B,\n// MSGCLASS=8,\n// TIME=9,\n// COND=(0,LT),  ===> FAILSAFE?\n//*RESTART=TRYIT,\n// MSGLEVEL=(1,1),NOTIFY=SYS326\n/*JOBPARM S=ANY,R=432\n//* TITLE MAKE SHARE TAPE\n//*--DUMP MEMBERS TO TAPE ------------------------------------------*\n//UNLOAD EXEC PGM=TSPDSUNL\n//STEPLIB  DD DSN=ISTA.SH.LOADLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//I1       DD DSN=SYS326.X.ASM,DISP=SHR\n//O1 DD  DSN=SYS326.T.PDSUNL,DISP=(,CATLG,DELETE),\n// LABEL=(,NL),UNIT=TAPE,VOL=(,RETAIN,SER=IBMDTR), $\n//*UNIT=DISK,VOL=SER=ISTSO1,SPACE=(TRK,(30,30)),\n// DCB=(LRECL=80,BLKSIZE=6160,RECFM=FB)\n O I=I1,O=O1,T=IEBUPDTE\n//UNUSED   DD  DATA,DLM=$$ JCL TO RESTORE/SAMPLE ASMS\n//*--RELOAD JCL--------------------------------------------------------\n//RELOADPD EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=*\n//SYSIN   DD   DSN=SYS326.T.PDSUNL,DISP=(OLD,DELETE),\n//           UNIT=TAPE,VOL=SER=IBMDTR,LABEL=(1,NL),  $\n//           DCB=*.UNLOAD.O1\n//SYSUT2  DD   DSN=&&PDS,DISP=(,PASS),\n//           UNIT=WORK,SPACE=(CYL,(1,1,15)),\n//           DCB=(LRECL=80,RECFM=FB,BLKSIZE=6160)\n//*--ASSEMBLY OF A PROGRAM----------------------------------------\n//ASMXX   PROC MEM=,DSNI='&&PDS',MAC1='SYS1.MACLIB'\n//*SMXX   PROC MEM=,DSNI='SYS326.X.ASM',MAC1='SYS1.MACLIB' $TEST\n//ASM     EXEC PGM=IEV90,PARM='NOLOAD,DECK,XREF(SHORT),BATCH'\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DSN=&DSNI(&MEM),DISP=(SHR,PASS)\n//SYSUT1   DD  UNIT=WVIO,SPACE=(1024,(250,250))\n//SYSUT2   DD  UNIT=WVIO,SPACE=(1024,(250,250))\n//SYSUT3   DD  UNIT=WVIO,SPACE=(1024,(250,250))\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=19040\n//         DD  DSN=SYSX.AMODGEN,DISP=SHR\n//         DD  DSN=*.SYSIN,DISP=(SHR,PASS),VOL=REF=*.SYSIN\n//         DD  DSN=&MAC1,DISP=SHR\n//SYSPUNCH DD  DSN=&OBJ,DISP=(,PASS),\n//           UNIT=WVIO,SPACE=(CYL,(1,1)),\n//           DCB=(LRECL=80,RECFM=FB,BLKSIZE=2960)\n//*--\n//LKED    EXEC PGM=IEWL,PARM=(NCAL)\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DSN=&X(&MEM),UNIT=WVIO,SPACE=(TRK,(2,2,1)) $$FIX\n//SYSLIN   DD  DSN=&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  DUMMY\n//   PEND\n//TS0      EXEC ASMXX,MEM=TSCALL\n//TS1      EXEC ASMXX,MEM=TSCVDAT\n//LKED.SYSIN DD *\n ALIAS TSCVDATE\n//TS2      EXEC ASMXX,MEM=TSENQSP3\n//LKED.SYSIN DD *\n ALIAS $DENQ\n//TS3      EXEC ASMXX,MEM=TSDYNLXA\n//TS4      EXEC ASMXX,MEM=TSGTFMAP\n//TS5      EXEC ASMXX,MEM=TSSPACE\n//LKED.SYSIN DD *\n ALIAS SPACE\n//TS6      EXEC ASMXX,MEM=TSSYSTEM\n//TS7      EXEC ASMXX,MEM=VTOC,\n// MAC1='SYS326.SPF.MACLIB' - VTOC FREE/ALLOC MACROS\n//LKED.SYSIN DD *\n ALIAS VTOCEXCP\n$$\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@ENT": {"ttr": 521, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SUBR    @ENT  &BASES,&SAVE,&CSECT,&DSA=NO\n.*\n.* THIS MACRO COURTESY OF SHARE INC.\n.* MVS PERFORMANCE PROJECT, CBT MODS TAPE, VTOC SYSTEM\n.* SUBMITTER RODGER MILLER, FIREMANS FUND\n.*\n.*   THIS MACRO, USED WITH THE @RET  MACRO, WILL PERFORM\n.*   STANDARD HOUSEKEEPING FOR A CSECT, INCLUDING SAVEAREA\n.*   CONSTRUCTION AND CHAINING, AND GETTING SOME STORAGE,\n.*   IF THAT IS DESIRED.\n.*   THE LEAVE MACRO WILL FREE THE GOTTEN STORAGE\n.*   THE OPERANDS ARE\n.*       &SUBR    @ENT   &BASES,&SAVE,&CSECT\n.*    WHERE\n.*       &SUBR    IS THE NAME OF THE CSECT\n.*       &BASES   ARE THE BASE REGISTERS FOR THE ROUTINE\n.*       &SAVE    IS THE LABEL FOR A SAVEAREA, OR A SUBPOOL\n.*                AND LENGTH FOR THE GETMAIN\n.*       &CSECT   TO CONTINUE AN EXISTING CSECT WITH ENTRY\n.*                POINT &SUBR\n.*\n.*    EXAMPLES -\n.*               @ENT 13,*\n.*\n.*       THIS WILL GENERATE NON-REENTRANT CODE, USING SAVEAREA\n.*       AS THE SAVE AREA LABEL, AND REGISTER 13 FOR THE BASE\n.*       REGISTER.\n.*\n.*       RENTMOD  @ENT (12,11),(,LDSECT)\n.*\n.*       THIS WILL GENERATE REENTRANT CODE WITH REGISTERS 12 AND\n.*       11 FOR BASE REGISTERS.  A GETMAIN WILL BE DONE FOR THE\n.*       DEFAULT SUBPOOL (0) WITH A LENGTH 'LDSECT'.\n.*\n         GBLC  &LV,&SP\n         LCLA  &K,&N\n         LCLC  &AREA,&B(16),&SUBNAME,&S\n&SUBNAME SETC  '&SUBR'\n         AIF   ('&SUBNAME' NE '').SUBSPEC\n&SUBNAME SETC  'MAIN'         DEFAULT CSECT NAME\n.SUBSPEC AIF   ('&CSECT' EQ '').NOTENT  IS IT AN ENTRY POINT?\n&CSECT   CSECT\n&SUBNAME DS    0F\n         AGO   .CSSPEC\n.NOTENT  ANOP\n&SUBNAME CSECT\n.CSSPEC  ANOP\n         SAVE  (14,12),T,&SUBNAME-&SYSDATE-&SYSTIME  SAVE REGS\n         AIF   ('&BASES(1)' EQ '15' OR '&BASES' EQ '').R15SET\n         AIF   ('&BASES(1)' EQ '13' AND '&SAVE' NE '').R15SET\n         LR    &BASES(1),15  SET FIRST BASE REG\n.R15SET  CNOP  0,4\n&S       SETC  '&SUBNAME'\n         AIF   (N'&SAVE EQ 2).P4   SUBPOOL, SIZE SPEC?\n         AIF   ('&SAVE' EQ '').P3  NO SAVEAREA - DEFAULT\n&AREA    SETC  '&SAVE'\n         AIF   ('&SAVE' NE '*').P2\n&AREA    SETC  'SAVEAREA'\n.P2      AIF   ('&BASES(1)' NE '13').P4\n&S       SETC  '*'\n         USING &SUBNAME,15\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n         BAL   13,*+76        SKIP AROUND THE SAVEAREA\n         DROP  15\n         AGO   .P4\n.P3      AIF   ('&BASES(1)' NE '13').P4\n         MNOTE 8,'*** CONTENTS OF REG 13 ARE LOST.  NO SAVE AREA WAS ESX\n               TABLISHED.'\n.P4      AIF   ('&BASES(1)' NE '14' OR '&SAVE' EQ '').P5\n         MNOTE 8,'*** MACRO RESTRICTION - REG 14 MUST NOT BE USED AS THX\n               E FIRST BASE REGISTER IF A SAVE AREA IS USED.'\n.P5      AIF   ('&BASES' EQ '').P9\n&N       SETA  N'&BASES\n.P6      ANOP\n&K       SETA  &K+1\n&B(&K)   SETC  ','.'&BASES(&K)'\n         AIF   (N'&SAVE EQ 1).PE\n         AIF   ('&BASES(&K)' NE '13').P7\n         MNOTE 8,'*** REG 13 MAY NOT BE USED AS A BASE REGISTER FOR REEX\n               NTRANT CODE.'\n         AGO   .P7\n.PE      AIF   ('&BASES(&K+1)' NE '13' OR '&SAVE' EQ '').P7\n         MNOTE 8,'*** WHEN USING A SAVE AREA, REG 13 MAY NOT BE USED ASX\n                A SECONDARY BASE REGISTER.'\n.P7      AIF   ('&BASES(&K+1)' NE '').P6\n         USING &S&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&B(X\n               11)&B(12)&B(13)&B(14)&B(15)&B(16)\n&K       SETA  1\n         AIF   ('&BASES(1)' NE '13' OR '&SAVE' EQ '').P8\n&AREA    DC    18F'0'\n.P8      AIF   (&K GE &N).P10\n         LA    &BASES(&K+1),X'FFF'(&BASES(&K))\n         LA    &BASES(&K+1),1(&BASES(&K+1))\n&K       SETA  &K+1\n         AGO   .P8\n.P9      USING &SUBNAME,15\n.P10     AIF   (N'&SAVE GE 2).P13\n         AIF   ('&SAVE' EQ '' OR '&BASES(1)' EQ '13').P12\n         AIF   ('&SAVE'(1,1) GE '0').P16  NUMERIC MEANS A PASSED AREA\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n.P11     BAL   13,*+76       SKIP AROUND THE SAVEAREA\n&AREA    DC    18F'0'\n.P12     MEXIT\n.P13     ANOP\n&LV      SETC  '&SAVE(2)'\n&SP      SETC  '0'\n         AIF   ('&SAVE(1)' EQ '').P14\n&SP      SETC  '&SAVE(1)'\n.P14     CNOP  0,4          DO A GETMAIN FOR THE AREA\n         BAL   1,*+8          POINT THE SP AND LV\nENT&SYSNDX DC  AL1(&SP)       SUBPOOL FOR THE GETMAIN\n         DC    AL3(&LV)       LENGTH OF THE GETMAIN\n         L     0,0(1)         GET THE DATA IN REG 1\n         SVC   10             ISSUE THE GETMAIN\n.*                            CHAIN THE SAVEAREAS\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         AIF   ('&DSA' NE 'YES').NODSA                        11/04/79\nDSA      DSECT                                                11/04/79\n         DS    9D                  INITIAL SAVE AREA          11/04/79\n         USING DSA,13              TELL ASM                   11/04/79\n         AIF   ('&CSECT' NE '').DSA1 NO MAINLINE CSECT        11/04/79\n&SUBNAME CSECT                     CONTINUE NORMAL CSECT      11/04/79\n         AGO   .NODSA              EXIT                       11/04/79\n.DSA1    ANOP                                                 11/04/79\n&CSECT   CSECT                     CONTINUE NORMAL CSECT      11/04/79\n.NODSA   ANOP                                                 11/04/79\n         AIF   ('&SAVE(3)' NE 'C').P15   CLEAR THE SAVEAREA?\n         LA    4,12(13)       YES, POINT PAST THE CHAIN\n         L     5,ENT&SYSNDX   GET THE SIZE\n         LA    6,12           MINUS THE CHAIN AREA (12 BYTES )\n         SR    5,6            GIVES THE AMOUNT TO CLEAR\n         SR    7,7            CLEAR THE FROM COUNT AND CLEAR BYTE\n         MVCL  4,6            WHEE, CLEAR IT OUT\n         LM    0,7,20(2)      RESTORE THE ORIGINAL REGISTERS\n         MEXIT\n.P15     ANOP\n         LM    0,2,20(2)      RESTORE ORIGINAL REGS\n         MEXIT\n.P16     L     1,&AREA+0(1)   NUMERIC &SAVE IMPLIES A PASSED SAVEAREA\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         LM    0,2,20(2)      RESTORE ORIGINAL REGS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@RET": {"ttr": 525, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    @RET  &EQ,&RC=,&FREE=YES\n.*..................................>> SEE @ENT MACRO FOR CREDITS\n         GBLC  &LV,&SP                 GLOBALS-SET IN @ENT\n&NAME    LR    2,13                    SAVE CURRENT SAVE AREA\n         L     13,4(13)                GET CALLER SAVE AREA\n         AIF   ('&RC' EQ '').L0        SKIP IF R15 ALREADY SET\n         LA    15,&RC                  LOAD THE RETURN CODE\n.L0      STM   15,1,16(13)             STORE RETURN REGS\n         AIF   ('&LV' EQ '').L1        ANYTHING TO FREE?\n         AIF   ('&FREE' EQ 'NO').L1    OVERRIDE FREE CODE?     25JUL84\n         FREEMAIN R,LV=&LV,SP=&SP,A=(2) FREE THE AREA\n.L1      RETURN (14,12),T              RETURN TO CALLER\n         AIF   ('&EQ' NE 'EQ').L4      REGISTERS TOO?\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nRA       EQU   10\nRB       EQU   11\nRC       EQU   12\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.L4      MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@STCK": {"ttr": 527, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   @STCK  &TYPE\n         LCLC   &L\n.**********************************************************************\n.****    THIS MACRO WILL PROVIDE THE DAY, DATE, AND TIME FROM\n.****    THE TIME-OF-DAY CLOCK IN GREGORIAN (ENGLISH) FORMAT.\n.**********************************************************************\n.****    TYPE SHOULD BE: 'BOTH' - GEN CODE AND DATA AREAS.\n.****                    'CODE' - GEN CODE ONLY.\n.****                    'DATA' - GEN DATA AREA ONLY.\n.**********************************************************************\n.****    DATA AREAS ARE SHOWN BELOW:\n.****\n.****  STCK     DC   CL28'MM/DD/YY HH:MM:SS DOW YY.DDD'\n.****\n.****  STCKDATE DS   CL8    THE DATE IN MM/DD/YY FORMAT\n.****\n.****  STCKTIME DS   CL8    THE TIME IN HH:MM:SS FORMAT\n.****\n.****  STCKDOW  DS   CL3    CHAR DAY OF WEEK\n.****\n.****  STCKDATJ DS   CL6    YY.DDD - JULIAN DATE\n.****\n.****  STCKWRK1 DS   D      WORK AREA\n.****  STCKWRK2 DS   D      WORK AREA\n.****\n.****  STCKDOWX DS   H      A BINARY NUMBER (HEX) RELATIVE TO\n.****                       THE DAY OF THE WEEK AS FOLLOWS\n.****                       0=MONDAY, 1=TUESDAY, 2=WEDNESDAY,\n.****                       3=THURSDAY, 4=FRIDAY,\n.****                       5=SATURDAY, 6=SUNDAY\n.****  STCKDDDX DS   H      A BINARY NUMBER-DAY IN YEAR 1-366\n.****  STCKYYX  DS   H      A BINARY NUMBER-YEAR\n.****  STCKMMX  DS   H      A BINARY NUMBER-MONTH (1-12)\n.****  STCKDDX  DS   H      A BINARY NUMBER-DAY-OF-MONTH (1-31)\n.****\n.****  STCKSTCK DS   CL8    THE STCK TO BE CONVERTED\n.****\n.****    NOTE THAT THE CALLER MUST PROVIDE A REGISTER SAVE AREA\n.****    THAT BEGINS ON A DOUBLEWORD BOUNDARY TO BE USED AS A\n.****    WORK AREA BY THIS ROUTINE (R-13 BASED).\n.****\n.**********************************************************************\n&L       SETC  '&SYSNDX'\n&LABEL   DS    0H                 STORE THE TIME-OF-DAY CLOCK\n         AIF    ('&TYPE' EQ 'DATA').GEN ONLY DO DATA\n         AIF    ('&TYPE' EQ 'BOTH').CODE DO CODE\n         AIF    ('&TYPE' EQ 'CODE').CODE DO CODE\n         MNOTE 8,'INVALID TYPE:  &TYPE , MUST BE DATA,BOTH, OR CODE'\n.CODE    ANOP\n*\n**             GET INPUT, ADJUST TIME ZONE\n*\n         LM    R0,R1,STCKSTCK          LOAD INTO WORK REGS\n         L     R15,16                  GET CVT ADDRESS\n         A     R0,304(R15)             ADD LOCAL TIME DEVIATION\n         SRDL  R0,12                   ISOLATE NUMBER OF MICROSECONDS\n*              MINUTES\n         D     R0,=F'60000000'         DIVIDE BY 60M (R1=MINUTES AFT EP\n         LR    R15,R0                  COPY REMAINDER OF MICS TO GET SE\n         SR    R14,R14                 CLEAR FOR DIVIDE\n*              SECONDS\n         D     R14,=F'951424'          DIVIDE TO GET REMAINING SECONDS\n         LR    R14,R15                 COPY TO WORK REG\nS&L.B    SL    R14,=F'60'              DECREMENT BY 60 SECONDS\n         BM    S&L.S                   LESS THAN SIXTY, CONTINUE\n         SL    R15,=F'60'              MORE THAN SIXTY, ADJUST FOR LEAP\n         AL    R1,=F'1'                BUMP MINUTES\n         B     S&L.B                   CHECK AGAIN\n*\n**             DISPLAYABLE TIME HH:MM:SS\n*\nS&L.S    CVD   R15,STCKWRK1            CONVERT SECONDS TO PACKED FORMAT\n         UNPK  STCKWRK2(4),STCKWRK1    UNPACK SECONDS FOR PRINT\n         OI    STCKWRK2+3,X'F0'        SET UP FOR PRINTING\n         MVC   STCKTIME+6(2),STCKWRK2+2 MOVE THE SECONDS\n*\n         XR    R0,R0\n         D     R0,=F'60'               DIVIDE INTO HOURS AND MINUTES\n         CVD   R0,STCKWRK1             CONVERT MINUTES TO PACKED\n         UNPK  STCKWRK2(4),STCKWRK1    UNPACK MINUTES FOR PRINT\n         OI    STCKWRK2+3,X'F0'        SET UP FOR PRINTING\n         MVC   STCKTIME+3(2),STCKWRK2+2 MOVE THE MINUTES\n*\n         XR    R0,R0                   CLEAR\n         D     R0,=F'24'               R1=DAYS AND R0=HOURS\n         CVD   R0,STCKWRK1             CONVERT HOURS TO PACKED\n         UNPK  STCKWRK2(4),STCKWRK1    UNPACK HOURS FOR PRINT\n         OI    STCKWRK2+3,X'F0'        SET UP FOR PRINTING\n         MVC   STCKTIME+0(2),STCKWRK2+2 MOVE THE HOURS\n*\n         MVI   STCKTIME+2,C':'         ADD COLIN\n         MVI   STCKTIME+5,C':'         ADD COLIN\n*\n**             DAY-OF-WEEK\n*\n         LR    R15,R1                  COPY NUMBER OF DAYS\n         XR    R14,R14                 CLEAR\n         D     R14,=F'7'               GET DAY INDEX\n         STC   R14,STCKDOWX            SET RELATIVE DAY OF WEEK\n         MH    R14,=H'3'               WEEKDAY: 0,3,..\n         LA    R14,S&L.W(R14)          GET 3CHAR DAY\n         MVC   STCKDOW,0(R14)          MAKE DISPLAYABLE\n*\n**             JULIAN\n*\n         XR    R0,R0                   CLEAR EVEN REG\n         S     R1,=F'365'              # OF DAYS SINCE JAN 1, 1901\n         D     R0,=F'1461'             # COMPLETED LEAP YRS\n         SLA   R1,2                    * LEAP YEARS BY 4\n         LR    R14,R1                  SAVE\n         STH   R1,STCKYYX              SAVE BINARY YEAR FOR CALLER\n         LR    R1,R0                   REMANDER\n         SR    R0,R0                   CLEAR R0\n         D     R0,=F'365'              # COMPLETED YRS (NOT INCL LEAPS)\n         AR    R1,R14                  # OF LEAPS*4\n         LA    R1,1(,R1)               +1 FOR 1900 ADJUST ABOVE\n         LR    R14,R1                  SAVE BINARY YEAR\n         AH    R0,=H'1'                JAN 1 IS XX001 NOT XX000\n         LR    R15,R0                  SAVE BINARY DAY(1-366)\n         STH   R0,STCKDDDX             SAVE BINARY DAY FOR CALLER\n         MH    R1,=H'1000'             YY OVER 3 DIGITS\n         AR    R1,R0                   ADD DAYS\n         CVD   R1,STCKWRK2             DEC VERSION 0..YYDDDS\n         MVC   STCKWRK1(7),=X'4021204B202020'\n         ED    STCKWRK1(7),STCKWRK2+5  JULIAN\n         MVC   STCKDATJ,STCKWRK1+1     KILL BLANK\n*\n**             GREGORIAN\n*\n         CVD   R14,STCKWRK1            DEC. YEAR\n         UNPK  STCKDATE+6(2),STCKWRK1+6(2) UNPACK INTO OUT AREA\n         LA    R1,S&L.T                LOAD ADDR OF TABLE\n         N     R14,=F'3'               SEE IF MULT OF 4\n         BNZ   S&L.NL                  NOT 0, BRANCH\n         LA    R1,S&L.TL               LEAP YEAR\nS&L.NL   LR    R0,R1                   SAVE TABLE ADDR\nS&L.L    IC    R14,0(R1)               LOAD CHAR FROM TABLE\n         LA    R1,1(R1)                INDEX TABLE POINTER\n         SR    R15,R14                 SUBTRACT FROM WORK VALUE\n         BP    S&L.L                   STILL POSITIVE, DO AGAIN\n         AR    R15,R14                 ELSE, ADD IT BACK\n         STH   R15,STCKDDX             SAVE BINARY DAY FOR CALLER\n         CVD   R15,STCKWRK1            CONVERT TO DEC\n         UNPK  STCKDATE+3(2),STCKWRK1+6(2) UNPACK DAY\n         SR    R1,R0                   GET MONTH INDEX FROM TABLE\n         STH   R1,STCKMMX              SAVE BINARY MONTH FOR CALLER\n         CVD   R1,STCKWRK1             CONVERT TO DEC\n         UNPK  STCKDATE(2),STCKWRK1+6(2)  UNPACK MONTH INTO OUT\n         OI    STCKDATE+1,C'0'         INSURE NUMERICS\n         OI    STCKDATE+4,C'0'         INSURE NUMERICS\n         OI    STCKDATE+7,C'0'         INSURE NUMERICS\n         MVI   STCKDATE+2,C'/'         ADD SLASH\n         MVI   STCKDATE+5,C'/'         ADD SLASH\n*\n**             CONSTANTS\n*\n         B     S&L.E                    BR AROUND CONSTANTS\nS&L.W    DC    C'MONTUEWEDTHUFRISATSUN' DAYS OF WEEK\nS&L.T    DC    AL1(31,28,31,30,31,30,31,31,30,31,30,31) MONTH TABLE\nS&L.TL   DC    AL1(31,29,31,30,31,30,31,31,30,31,30,31) LEAP YEAR\n         AIF    ('&TYPE' EQ 'CODE').NOGEN ONLY DO CODE\n.GEN     ANOP\nSTCK     DC    0C'MM/DD/YY HH:MM:SS DOW YY.DDD'\nSTCKDATE DC    C'  /  /  '             MM/DD/YY\n         DC    C' '                    FILLER                  25JUN84\nSTCKTIME DC    C'  :  :  '             HH:MM:SS\n         DC    C' '                    FILLER                  25JUN84\nSTCKDOW  DC    C'XXX'                  DAY OF THE WEEK\n         DC    C' '                    FILLER                  25JUN84\nSTCKDATJ DC    C'YY.DDD'               JULIAN DATE\n         DC    C' '                    FILLER                  25JUN84\nSTCKWRK1 DS    D                       WORK\nSTCKWRK2 DS    D                       WORK\nSTCKSTCK DS    D                       STORE CLOCK INPUT\nSTCKDOWX DC    H'00'                   REL. DAY OF THE WEEK\nSTCKDDDX DC    H'00'                   BINARY DAY IN YEAR (1-366)\nSTCKYYX  DC    H'00'                   BINARY YEAR\nSTCKMMX  DC    H'00'                   BINARY MONTH (1-12)\nSTCKDDX  DC    H'00'                   BINARY DAY-OF-MONTH (1-31)\n.NOGEN   ANOP\nS&L.E    DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLEAR": {"ttr": 531, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    CLEAR &FIELD,&CHAR,&LENGTH\n         LCLC  &FILL,&L\n&L       SETC  'L'''\n&FILL    SETC  '&CHAR'\n         AIF   ('&CHAR' NE '').CHSPEC\n&FILL    SETC  '40'\n.CHSPEC  ANOP\n&NAME    MVI   &FIELD,X'&FILL'   SET THE FIRST POSITION\n         AIF   ('&LENGTH' EQ '').NOLSPEC\n         MVC   &FIELD+1(&LENGTH),&FIELD  FILL THE ENTIRE FIELD\n         MEXIT\n.NOLSPEC ANOP\n         MVC   &FIELD+1(&L&FIELD-1),&FIELD  FILL THE ENTIRE FIELD\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONV": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   CONV  &TO,&FROM,&LEN,&EDMASK,&SCOMP\n         LCLC  &L,&FIRSTFR,&EDM,&COMP\n         LCLA  &COUNT\n&L       SETC  'L'''\n         AIF   ('&LABEL' EQ '').NOLABEL  SKIP LABEL IF NOT PRESENT\n&LABEL   DS    0H             SET THE LABEL\n.NOLABEL ANOP\n&EDM     SETC  'EDMASK'      DEFAULT EDIT MASK\n         AIF   ('&EDMASK' EQ '').DEFMASK  IF NOT ENTERED USE DEFAULT\n&EDM     SETC  '&EDMASK'     USE THE ENTERED VALUE\n.DEFMASK ANOP\n&COMP    SETC  'BLANKS'      DEFAULT COMPARISON CHARS\n         AIF   ('&SCOMP' EQ '').DEFCOMP  NOT ENTERED, USE THE DEFAULT\n&COMP    SETC  '&SCOMP'      GET WHAT THE GUY WANTS\n.DEFCOMP ANOP\n&FIRSTFR SETC  '&FROM'(1,1)   GET FIRST CHAR OF &FROM\n         AIF   ('&FIRSTFR' EQ '(').REGISTR\n         L     R1,&FROM       GET THE DATA TO CONVERT\n         CVD   R1,DOUBLE      CONVERT TO PACKED DECIMAL\n         AGO   .INDEC\n.REGISTR ANOP\n&COUNT   SETA  K'&FROM-2\n&FIRSTFR SETC  '&FROM'(2,&COUNT)  STRIP THE PERRONS\n         CVD   &FIRSTFR,DOUBLE   CONVERT TO PACKED DECIMAL\n.INDEC   ANOP\n         MVC   CHARS,&EDM     PUT IN THE EDIT MASK\n         ED    CHARS,DOUBLE   CONVERT TO CHARACTERS\n         AIF   ('&LEN' NE '').LENSET\n         MVC   &TO,CHARS+16-&L&TO  MOVE IN THE NUMBER\n         CLC   CHARS(16-&L&TO),&COMP   WAS THERE AN OVERFLOW?\n         BE    *+10           NO, EVERYTHING WAS OK\n         MVC   &TO,STARS      BAD NEWS, NOTE IT\n         MEXIT\n.LENSET  ANOP\n         MVC   &TO.(&LEN),CHARS+16-&LEN MOVE IN THE NUMBER\n         CLC   CHARS(16-&LEN),&COMP   WAS THERE AN OVERFLOW?\n         BE    *+10           NO, EVERYTHING WAS OK\n         MVC   &TO.(&LEN),STARS   BAD NEWS, NOTE IT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENTER": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SUBR    ENTER &BASES,&SAVE,&CSECT\n.*   THIS MACRO, USED WITH THE LEAVE MACRO, WILL PERFORM\n.*   STANDARD HOUSEKEEPING FOR A CSECT, INCLUDING SAVEAREA\n.*   CONSTRUCTION AND CHAINING, AND GETTING SOME STORAGE,\n.*   IF THAT IS DESIRED.\n.*   THE LEAVE MACRO WILL FREE THE GOTTEN STORAGE\n.*   THE OPERANDS ARE\n.*       &SUBR    ENTER  &BASES,&SAVE,&CSECT\n.*    WHERE\n.*       &SUBR    IS THE NAME OF THE CSECT\n.*       &BASES   ARE THE BASE REGISTERS FOR THE ROUTINE\n.*       &SAVE    IS THE LABEL FOR A SAVEAREA, OR A SUBPOOL\n.*                AND LENGTH FOR THE GETMAIN\n.*       &CSECT   TO CONTINUE AN EXISTING CSECT WITH ENTRY\n.*                POINT &SUBR\n.*\n.*    EXAMPLES -\n.*               ENTER 13,*\n.*\n.*       THIS WILL GENERATE NON-REENTRANT CODE, USING SAVEAREA\n.*       AS THE SAVE AREA LABEL, AND REGISTER 13 FOR THE BASE\n.*       REGISTER.\n.*\n.*       RENTMOD  ENTER (12,11),(,LDSECT)\n.*\n.*       THIS WILL GENERATE REENTRANT CODE WITH REGISTERS 12 AND\n.*       11 FOR BASE REGISTERS.  A GETMAIN WILL BE DONE FOR THE\n.*       DEFAULT SUBPOOL (0) WITH A LENGTH 'LDSECT'.\n.*\n         GBLC  &LV,&SP\n         LCLA  &K,&N\n         LCLC  &AREA,&B(16),&SUBNAME,&S\n&SUBNAME SETC  '&SUBR'\n         AIF   ('&SUBNAME' NE '').SUBSPEC\n&SUBNAME SETC  'MAIN'         DEFAULT CSECT NAME\n.SUBSPEC AIF   ('&CSECT' EQ '').NOTENT  IS IT AN ENTRY POINT?\n&CSECT   CSECT\n&SUBNAME DS    0F\n         AGO   .CSSPEC\n.NOTENT  ANOP\n&SUBNAME CSECT\n.CSSPEC  ANOP\n         SAVE  (14,12),T,&SUBNAME   SAVE THE REGISTERS\n         AIF   ('&BASES(1)' EQ '15' OR '&BASES' EQ '').R15SET\n         AIF   ('&BASES(1)' EQ '13' AND '&SAVE' NE '').R15SET\n         LR    &BASES(1),15  SET FIRST BASE REG\n.R15SET  CNOP  0,4\n&S       SETC  '&SUBNAME'\n         AIF   (N'&SAVE EQ 2).P4   SUBPOOL, SIZE SPEC?\n         AIF   ('&SAVE' EQ '').P3  NO SAVEAREA - DEFAULT\n&AREA    SETC  '&SAVE'\n         AIF   ('&SAVE' NE '*').P2\n&AREA    SETC  'SAVEAREA'\n.P2      AIF   ('&BASES(1)' NE '13').P4\n&S       SETC  '*'\n         USING &SUBNAME,15\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n         BAL   13,*+76        SKIP AROUND THE SAVEAREA\n         DROP  15\n         AGO   .P4\n.P3      AIF   ('&BASES(1)' NE '13').P4\n         MNOTE 8,'*** CONTENTS OF REG 13 ARE LOST.  NO SAVE AREA WAS ESX\n               TABLISHED.'\n.P4      AIF   ('&BASES(1)' NE '14' OR '&SAVE' EQ '').P5\n         MNOTE 8,'*** MACRO RESTRICTION - REG 14 MUST NOT BE USED AS THX\n               E FIRST BASE REGISTER IF A SAVE AREA IS USED.'\n.P5      AIF   ('&BASES' EQ '').P9\n&N       SETA  N'&BASES\n.P6      ANOP\n&K       SETA  &K+1\n&B(&K)   SETC  ','.'&BASES(&K)'\n         AIF   (N'&SAVE EQ 1).PE\n         AIF   ('&BASES(&K)' NE '13').P7\n         MNOTE 8,'*** REG 13 MAY NOT BE USED AS A BASE REGISTER FOR REEX\n               NTRANT CODE.'\n         AGO   .P7\n.PE      AIF   ('&BASES(&K+1)' NE '13' OR '&SAVE' EQ '').P7\n         MNOTE 8,'*** WHEN USING A SAVE AREA, REG 13 MAY NOT BE USED ASX\n                A SECONDARY BASE REGISTER.'\n.P7      AIF   ('&BASES(&K+1)' NE '').P6\n         USING &S&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&B(X\n               11)&B(12)&B(13)&B(14)&B(15)&B(16)\n&K       SETA  1\n         AIF   ('&BASES(1)' NE '13' OR '&SAVE' EQ '').P8\n&AREA    DC    18F'0'\n.P8      AIF   (&K GE &N).P10\n         LA    &BASES(&K+1),X'FFF'(&BASES(&K))\n         LA    &BASES(&K+1),1(&BASES(&K+1))\n&K       SETA  &K+1\n         AGO   .P8\n.P9      USING &SUBNAME,15\n.P10     AIF   (N'&SAVE GE 2).P13\n         AIF   ('&SAVE' EQ '' OR '&BASES(1)' EQ '13').P12\n         AIF   ('&SAVE' GE '0').P16  NUMERIC MEANS A PASSED AREA\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n.P11     BAL   13,*+76       SKIP AROUND THE SAVEAREA\n&AREA    DC    18F'0'\n.P12     MEXIT\n.P13     ANOP\n&LV      SETC  '&SAVE(2)'\n&SP      SETC  '0'\n         AIF   ('&SAVE(1)' EQ '').P14\n&SP      SETC  '&SAVE(1)'\n.P14     CNOP  0,4          DO A GETMAIN FOR THE AREA\n         BAL   1,*+8          POINT THE SP AND LV\nENT&SYSNDX DC  AL1(&SP)       SUBPOOL FOR THE GETMAIN\n         DC    AL3(&LV)       LENGTH OF THE GETMAIN\n         L     0,0(1)         GET THE DATA IN REG 1\n         SVC   10             ISSUE THE GETMAIN\n.*                            CHAIN THE SAVEAREAS\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         LM    0,2,20(2)      RESTORE ORIGINAL REGS\n         MEXIT\n.P16     L     1,&AREA+0(1)   NUMERIC &SAVE IMPLIES A PASSED SAVEAREA\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         LM    0,2,20(2)      RESTORE ORIGINAL REGS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENTERX": {"ttr": 774, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SUBR    ENTERX &BASES,&SAVE,&CSECT\n.*   THIS MACRO, USED WITH THE LEAVE MACRO, WILL PERFORM\n.*   STANDARD HOUSEKEEPING FOR A CSECT, INCLUDING SAVEAREA\n.*   CONSTRUCTION AND CHAINING, AND GETTING SOME STORAGE,\n.*   IF THAT IS DESIRED.\n.*   THE LEAVE MACRO WILL FREE THE GOTTEN STORAGE\n.*   THE OPERANDS ARE\n.*       &SUBR    ENTER  &BASES,&SAVE,&CSECT\n.*    WHERE\n.*       &SUBR    IS THE NAME OF THE CSECT\n.*       &BASES   ARE THE BASE REGISTERS FOR THE ROUTINE\n.*       &SAVE    IS THE LABEL FOR A SAVEAREA, OR A SUBPOOL\n.*                AND LENGTH FOR THE GETMAIN\n.*       &CSECT   TO CONTINUE AN EXISTING CSECT WITH ENTRY\n.*                POINT &SUBR\n.*\n.*    EXAMPLES -\n.*               ENTER 13,*\n.*\n.*       THIS WILL GENERATE NON-REENTRANT CODE, USING SAVEAREA\n.*       AS THE SAVE AREA LABEL, AND REGISTER 13 FOR THE BASE\n.*       REGISTER.\n.*\n.*       RENTMOD  ENTER (12,11),(,LDSECT)\n.*\n.*       THIS WILL GENERATE REENTRANT CODE WITH REGISTERS 12 AND\n.*       11 FOR BASE REGISTERS.  A GETMAIN WILL BE DONE FOR THE\n.*       DEFAULT SUBPOOL (0) WITH A LENGTH 'LDSECT'.\n.*\n         GBLC  &LV,&SP\n         LCLA  &K,&N\n         LCLC  &AREA,&B(16),&SUBNAME,&S\n&SUBNAME SETC  '&SUBR'\n         AIF   ('&SUBNAME' NE '').SUBSPEC\n&SUBNAME SETC  'MAIN'         DEFAULT CSECT NAME\n.SUBSPEC AIF   ('&CSECT' EQ '').NOTENT  IS IT AN ENTRY POINT?\n&CSECT   CSECT\n&SUBNAME DS    0F\n         AGO   .CSSPEC\n.NOTENT  ANOP\n&SUBNAME CSECT\n.CSSPEC  ANOP\n         SAVE  (14,12),T,&SUBNAME   SAVE THE REGISTERS\n         AIF   ('&BASES(1)' EQ '15' OR '&BASES' EQ '').R15SET\n         AIF   ('&BASES(1)' EQ '13' AND '&SAVE' NE '').R15SET\n         LR    &BASES(1),15  SET FIRST BASE REG\n.R15SET  CNOP  0,4\n&S       SETC  '&SUBNAME'\n         AIF   (N'&SAVE EQ 2).P4   SUBPOOL, SIZE SPEC?\n         AIF   ('&SAVE' EQ '').P3  NO SAVEAREA - DEFAULT\n&AREA    SETC  '&SAVE'\n         AIF   ('&SAVE' NE '*').P2\n&AREA    SETC  'SAVEAREA'\n.P2      AIF   ('&BASES(1)' NE '13').P4\n&S       SETC  '*'\n         USING &SUBNAME,15\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n         BAL   13,*+76        SKIP AROUND THE SAVEAREA\n         DROP  15\n         AGO   .P4\n.P3      AIF   ('&BASES(1)' NE '13').P4\n         MNOTE 8,'*** CONTENTS OF REG 13 ARE LOST.  NO SAVE AREA WAS ESX\n               TABLISHED.'\n.P4      AIF   ('&BASES(1)' NE '14' OR '&SAVE' EQ '').P5\n         MNOTE 8,'*** MACRO RESTRICTION - REG 14 MUST NOT BE USED AS THX\n               E FIRST BASE REGISTER IF A SAVE AREA IS USED.'\n.P5      AIF   ('&BASES' EQ '').P9\n&N       SETA  N'&BASES\n.P6      ANOP\n&K       SETA  &K+1\n&B(&K)   SETC  ','.'&BASES(&K)'\n         AIF   (N'&SAVE EQ 1).PE\n         AIF   ('&BASES(&K)' NE '13').P7\n         MNOTE 8,'*** REG 13 MAY NOT BE USED AS A BASE REGISTER FOR REEX\n               NTRANT CODE.'\n         AGO   .P7\n.PE      AIF   ('&BASES(&K+1)' NE '13' OR '&SAVE' EQ '').P7\n         MNOTE 8,'*** WHEN USING A SAVE AREA, REG 13 MAY NOT BE USED ASX\n                A SECONDARY BASE REGISTER.'\n.P7      AIF   ('&BASES(&K+1)' NE '').P6\n         USING &S&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&B(X\n               11)&B(12)&B(13)&B(14)&B(15)&B(16)\n&K       SETA  1\n         AIF   ('&BASES(1)' NE '13' OR '&SAVE' EQ '').P8\n&AREA    DC    18F'0'\n.P8      AIF   (&K GE &N).P10\n         LA    &BASES(&K+1),X'FFF'(&BASES(&K))\n         LA    &BASES(&K+1),1(&BASES(&K+1))\n&K       SETA  &K+1\n         AGO   .P8\n.P9      USING &SUBNAME,15\n.P10     AIF   (N'&SAVE GE 2).P13\n         AIF   ('&SAVE' EQ '' OR '&BASES(1)' EQ '13').P12\n         AIF   ('&SAVE(1,1)' GE '0').P16  NUMERIC MEANS A PASSED AREA\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n.P11     BAL   13,*+76       SKIP AROUND THE SAVEAREA\n&AREA    DC    18F'0'\n.P12     MEXIT\n.P13     ANOP\n&LV      SETC  '&SAVE(2)'\n&SP      SETC  '0'\n         AIF   ('&SAVE(1)' EQ '').P14\n&SP      SETC  '&SAVE(1)'\n.P14     CNOP  0,4          DO A GETMAIN FOR THE AREA\n         BAL   1,*+8          POINT THE SP AND LV\nENT&SYSNDX DC  AL1(&SP)       SUBPOOL FOR THE GETMAIN\n         DC    AL3(&LV)       LENGTH OF THE GETMAIN\n         L     0,0(1)         GET THE DATA IN REG 1\n         SVC   10             ISSUE THE GETMAIN\n.*                            CHAIN THE SAVEAREAS\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         LA    4,12(13)       YES, POINT PAST THE CHAIN\n         L     5,ENT&SYSNDX   GET THE SIZE\n         LA    6,12           MINUS THE CHAIN AREA (12 BYTES )\n         SR    5,6            GIVES THE AMOUNT TO CLEAR\n         SR    7,7            CLEAR THE FROM COUNT AND CLEAR BYTE\n         MVCL  4,6            WHEE, CLEAR IT OUT\n         LM    0,7,20(2)      RESTORE THE ORIGINAL REGISTERS\n         MEXIT\n.P16     L     1,&AREA+0(1)   NUMERIC &SAVE IMPLIES A PASSED SAVEAREA\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         LM    0,2,20(2)      RESTORE ORIGINAL REGS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LEAVE": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LEAVE &EQ,&RC=\n         GBLC  &LV,&SP\n&NAME    LR    2,13\n         L     13,4(13)\n         AIF   ('&RC' EQ '').L0\n         LA    15,&RC         LOAD THE RETURN CODE\n.L0      STM   15,1,16(13)  STORE RETURN REGS\n         AIF   ('&LV' EQ '').L1  ANYTHING TO FREE?\n         FREEMAIN R,LV=&LV,SP=&SP,A=(2)  FREE THE AREA\n.L1      RETURN (14,12),T     RETURN FROM WHENCE WE CAME\n         AIF   ('&EQ' NE 'EQ').L4  REGISTERS TOO?\n         REGS\n*                 LEAVE CHANGED 4/15/80 TO NOT USE \"COPY\"      CJH\n.L4      MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSG": {"ttr": 779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    MSG   &TEXT\n         LCLA  &A\n&A       SETA  K'&TEXT-2+4  SUBTRACT QUOTES, ADD PREFIX FOUR BYTES\n&NAME    DC    H'&A',H'0',C&TEXT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDEDSNAM": {"ttr": 781, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         PDEDSNAM\n*\n*        DEFINE A DSECT FOR THE DSNAME PARSE DESCRIPTION\n*\nPDEDSNAM DSECT\nPDEDSN   DS    A              POINTER TO DSNAME\nPDEDSNL  DS    H              LENGTH OF DSNAME\nPDEDFLG1 DS    X              DATA SET NAME FLAGS\nPDEDFLD1 EQU   X'80'          ONE IF THE DSNAME IS PRESENT\nPDEDFLQ1 EQU   X'40'          ONE IF THE DSNAME IS WITHIN QUOTES\nPDEDMEM  DS    A              POINTER TO MEMBER NAME\nPDEDMEML DS    H              LENGTH OF MEMBER NAME\nPDEDFLG2 DS    X              MEMBER   NAME FLAGS\nPDEDFLD2 EQU   X'80'          ONE IF THE MEMBER IS PRESENT\nPDEDPASS DS    A              POINTER TO PASSWORD\nPDEDPASL DS    H              LENGTH OF PASSWORD\nPDEDFLG3 DS    X              PASSWORD      FLAGS\nPDEDFLD3 EQU   X'80'          ONE IF THE PASSWORD IS PRESENT\nPDEDCHAN DS    0F             CHAIN ADDRESS\nPDEDCHNF DS    X              CHAIN FLAGS ( X'FF' FOR END )\nPDEDCHN  DS    AL3            TRUE CHAIN POINTER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGS": {"ttr": 783, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         REGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nRA       EQU   10\nRB       EQU   11\nRC       EQU   12\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSGET": {"ttr": 785, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SYM     SYSGET &EODAD=EODAD,&DDNAME=SYSIN,&LRECL=80,&RECFM=,          X\n               &BLKSIZE=80\n         AIF   (K'&SYM EQ 0).NOSYM\n         AIF   (K'&SYM GT 5).ERRSYM\n         AIF   (K'&DDNAME GT 8).DDNERR\n         AIF   (K'&EODAD GT 8).ERREOD\n       MNOTE *,'DCB = DDNAME=&DDNAME,DSORG=PS,MACRF=GL,EODAD=&EODAD'\n       MNOTE *,'          DD CARD CHANGES WILL WORK FOR '\n       MNOTE *,'      LRECL=&LRECL,BLKSIZE=&BLKSIZE,RECFM=&RECFM'\n***********************************************************************\n*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *\n***********************************************************************\n         DS    0H\n&SYM     ST    14,&SYM.14 .            SAVE RETURN REG\n         TM    &SYM.DCB+48,X'10' .     IS DCB OPEN\n         BC    1,&SYM.1 .              YES - BYPASS OPEN CODE\n         OPEN  (&SYM.DCB,(INPUT))\n         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN\n         BC    1,&SYM.1 .              YES\n         WTO   '&SYM.DCB IS NOT OPEN - CHECK DD CARD',ROUTCDE=11\n         B     &SYM.EOD\n&SYM.1   GET   &SYM.DCB\n         L     14,&SYM.14 .            RESTORE RETURN REG\n         BR    14 .                    RETURN\n&SYM.XIT CLC   &SYM.DCB+62(2),=H'0' .  IS BLOCK SIZE THERE\n         BNE   &SYM.3 .                IF SO SKIP\n         MVC   &SYM.DCB+62(2),=H'&BLKSIZE' .MOVE IN SIZE\n&SYM.3   CLC   &SYM.DCB+82(2),=H'0' .  IS LRECL HERE\n         BNE   &SYM.4 .                IF SO SKIP\n         MVC   &SYM.DCB+82(2),=H'&LRECL' .   MOVE IN LRECL\n&SYM.4   CLI   &SYM.DCB+36,X'00' .     IS RECFM THERE\n         BNE   &SYM.5 .                BRANCH IF THERE\n         MVI   &SYM.DCB+36,X'90' .     MOVE IN DEFAULT RECFM FB\n&SYM.5   BR    14 .                    RETURN TO OPEN\n&SYM.EOD CLOSE &SYM.DCB\n         FREEPOOL &SYM.DCB\n         B     &EODAD .                GO TO USERS EODAD RTN\n&SYM.14  DS    1F .                    RETURN REG SAVE AREA\n&SYM.LST DC    X'85' .                 DCB OPEN EXIT\n         DC    AL3(&SYM.XIT) .         POINTER TO XIT RTN\n&SYM.DCB DCB   DDNAME=&DDNAME,DSORG=PS,MACRF=(GL),EODAD=&SYM.EOD,      ,\n               EXLST=&SYM.LST,RECFM=&RECFM\n         AGO   .END\n.ERRSYM MNOTE 8,'8,*** LABEL ON SYSGET MACRO MUST BE LESS THAN SIX'\n         AGO   .END\n.NOSYM  MNOTE 8,'8,*** SYSGET MACRO MUST HAVE A LABEL'\n         AGO   .END\n.DDNERR MNOTE 8,'8,*** DDNAME LARGER THAN EIGHT CHARACTERS'\n         AGO   .END\n.ERREOD MNOTE 8,'8,*** MAXIMUM LABEL SIZE IS EIGHT CHARACTERS'\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSPUT": {"ttr": 787, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&SYM     SYSPUT &DDNAME=SYSPUNCH,&LRECL=80,&RECFM=,&BLKSIZE=80\n         AIF   (K'&SYM GT 5).ERRSYM\n         AIF   (K'&SYM EQ 0).NOSYM\n         AIF   (K'&DDNAME GT 8).DDNERR\n       MNOTE *,'DCB = DDNAME=&DDNAME,DSORG=PS,MACRF=PM'\n       MNOTE *,'             DD CARD CHANGES WILL WORK FOR'\n       MNOTE *,'      LRECL=&LRECL,BLKSIZE=&BLKSIZE,RECFM=&RECFM'\n***********************************************************************\n*        THIS MACRO COURTESY OF D.R.CHANEY, MILWAUKEE, FE-246         *\n***********************************************************************\n&SYM     DS    0H\n         STM   14,1,&SYM.14 .          SAVE REGS\n         TM    &SYM.DCB+48,X'10' .     IS DCB OPEN\n         BC    1,&SYM.1 .              YES - BYPASS OPEN CODE\n         OPEN  (&SYM.DCB,(OUTPUT))\n         TM    &SYM.DCB+48,X'10' .     DID DCB OPEN\n         BC    1,&SYM.1 .              YES\n         B     &SYM.1S\n&SYM.1   L     0,&SYM.14+12 .          SET DATA REG\n         PUT   &SYM.DCB,(0)\n&SYM.1S  DS    0H\n         LM    14,1,&SYM.14 .          RESTORE REGS\n         BR    14 .                    RETURN\n&SYM.XIT CLC   &SYM.DCB+62(2),=H'0' .  IS BLKSIZE THERE\n         BNE   &SYM.3 .                IF SO SKIP\n         MVC   &SYM.DCB+62(2),=H'&BLKSIZE' MOVE IN BLKSIZE\n&SYM.3   CLC   &SYM.DCB+82(2),=H'0' .  IS LRECL THERE\n         BNE   &SYM.4 .                IF SO SKIP\n         MVC   &SYM.DCB+82(2),=H'&LRECL' MOVE IN LRECL\n&SYM.4   CLI   &SYM.DCB+36,X'00' .     IS RECFM THERE\n         BNE   &SYM.5 .                BRANCH IF THERE\n         MVI   &SYM.DCB+36,X'90' .     MOVE IN DEFAULT RECFM FB\n&SYM.5   BR    14 .                    RETURN TO OPEN\n&SYM.14  DS    4F .                    REG SAVE AREA\n&SYM.LST DC    X'85' .                 OPEN EXIT LIST\n         DC    AL3(&SYM.XIT) .         ENTRY FOR OPEN EXIT\n&SYM.DCB DCB   DDNAME=&DDNAME,DSORG=PS,MACRF=(PM),EXLST=&SYM.LST,      X\n               RECFM=&RECFM\n         AGO   .END\n.ERRSYM MNOTE 8,'8,*** LABEL ON SYSPUT MACRO MUST BE LESS THAN SIX'\n         AGO   .END\n.NOSYM  MNOTE 8,'8,*** SYSPUT MACRO MUST HAVE A LABEL'\n         AGO   .END\n.DDNERR MNOTE 8,'8,*** DDNAME LARGER THAN EIGHT CHARACTERS'\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSCALL": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TSCALL   TITLE 'INVOKE LNKLST/JOBLIB PROGRAMS FROM TSO WITHOUT CALL'\n*\n******** ***************************** *********************** *******\n***      SYNTAX: TSCALL PROGRAM 'PARMS'\n***      ATTRIBUTES: RENT RUSE REFR\n***      IF A \"TASKLIB\" DD IS PRESENT, IT IS USED AS A TASKLIB.\n******** ***************************** *********************** *******\n*\nTSCALL   @ENT  R12,(0,DSALEN,C),DSA=YES\n         LR    R10,R1\n         USING CPPL,R10                SAVE CP PARM LIST\n*\n**       INIT\n*\n         LA    R1,DSAPARML             SETUP CALLEE \"O/S\" PARM\n         ST    R1,DSAPARM@\n         OI    DSAPARM@,X'80'\n*\n         MVC   DSAPUPT,CPPLUPT         GIVE PARSE ADDRS OF UPT\n         MVC   DSAPECT,CPPLECT          \" ECT\n         MVC   DSAPPCL,=V(TSCALPCL)    PARSE LIST\n         LA    R1,DSAWANS\n         ST    R1,DSAPANS               \" ANSWER AREA POINTER\n         MVC   DSAPCBUF,CPPLCBUF        \" CBUF\n         LA    R1,DSAWECB\n         ST    R1,DSAPECB               \" ECB\n         LA    R1,DSAPUPT              PARSE LIST\n         CALLTSSR EP=IKJPARS           GO PARSE\n         LTR   R15,R15                 PROBLEMS?\n         BNZ   PARSEERX                YES-GET OUT\n         ICM   R9,15,DSAWANS           PUT PARSE ANSWER ADDRS IN R9\n         BZ    PARSEERX                NO-FORGET IT\n         USING IKJPARMD,R9             TELL ASM\n*\n**       COPY PARM DATA FROM TSO TO MY PARM AREA\n*\n         LH    R2,PARM+4               PASS CALLERS PARM L'\n         STH   R2,DSAPARML             SAVE AS O/S PARM L'\n         LTR   R2,R2                   NONE?\n         BZ    NOPARM\n         BCTR  R2,R0\n         L     R1,PARM\nMVEPARM  MVC   DSAPARMA(0),0(R1)       MOVE 1 BYTE\n         EX    R2,MVEPARM              THEN EXECUTE WITH RIGHT L\nNOPARM   DS    0H\n*\n**       COPY PROGRAM NAME\n*\n         MVC   DSANAME,=CL8' '         SET W/ BLANKS\n         L     R1,MEMBER           PT TO NAME OF UTILITY WANTED\n         LH    R2,MEMBER+4         PUT LENGTH IN R2 FOR CLC\n         BCTR  R2,R0\nMVC      MVC   DSANAME(0),0(R1)              SAVE NAME\n         EX    R2,MVC                        SAVE 8CHAR NAME\n         OC    DSANAME,=CL8' '         PAD W/ BLANKS\n*\n         DROP  R9\n         IKJRLSA DSAWANS               RELEASE PARSE STOR\n*\n         MVC   DSAATTS(DSAATTL),SSAATTS COPY MODEL TO WORK\n         NI    DSAATTS+8,255-X'02'     NO TASKLIB YET\n*\n**       SEE IF TASKLIB SPECIFIED\n*\n         L     R5,16                   CVT\n         L     R5,0(,R5)               CVTTCBP TCB WORDS\n         L     R5,4(,R5)               CURRENT TCB\n         L     R5,12(,R5)              TCBTIO (TIOT)\n         LA    R5,24(R5)               GET 1ST DDNAME\n         XR    R6,R6                   CLEAR WORK\nDDLOOP   EQU   *                       SCAN TIOT\n         CLC   0(4,R5),=F'0'           END?\n         BE    NOTASKLB                YES-NO TASKLIB\n         CLC   4(8,R5),=CL8'TASKLIB'   MATCH?\n         BE    TASKLIB                 YES-OPEN IT\n         IC    R6,0(R5)                NO-TRY NEXT ENTRY\n         AR    R5,R6                      \"\n         B     DDLOOP                  LOOP\nTASKLIB  DS    0H\n         TPUT  TASKTPUT,L'TASKTPUT     INFORM CALLER\n         OI    DSAATTS+8,X'02'         SHOW TASKLIB IN ATT LIST\n         MVC   DSATASKS(SSATASKL),SSATASKS COPY MODEL TO WORK\n         XC    DSAWF,DSAWF             CREATE OPEN LIST\n         MVI   DSAWF,X'80'             \"\n         LA    R2,DSATASK              GET WORK DCB\n         STCM  R2,7,DSAATT+49          ADD TASKLIB DCB\n         OPEN  ((R2),INPUT),MF=(E,DSAWF) OPEN TASKLIB\nNOTASKLB DS    0H\n*                                                              25JUN84\n**       SEE IF IN LPA                                         25JUN84\n*                                                              25JUN84\n         L     R2,CVTPTR               CVT ADDR\n         L     R2,CVTQLPAQ-CVT(0,R2)   LPA CDE(+188N)\n         L     R2,0(0,R2)              1ST CDE\n         USING CDENTRY,R2                                      25JUN84\nCDECHK   CLC   DSANAME,CDNAME          MATCH?\n         BE    DOATTACH                YES-GO\n         ICM   R2,7,CDCHAIN            NEXT CDE\n         BNZ   CDECHK                  NO, GO CHECK NEXT\n         DROP  R2                                              25JUN84\n*                                                              25JUN84\n**       LPDE                                                  25JUN84\n*                                                              25JUN84\n         L     R2,CVTPTR               CVT\n         L     R2,CVTLPDIA-CVT(R2)     LPDE CHAIN(+360N)\n         USING LPDE,R2                                         25JUN84\nLPDECHK  DS    0H                      END?\n         CLI   LPDENAME,X'FF'          END?\n         BE    LPDEEND                 NOT FOUND-TRY BLDL\n         CLC   DSANAME,LPDENAME        MATCH\n         BE    LPDEHIT                 YES-DO ATTACH\n         LA    R2,40(0,R2)             NEXT LPDE(NO MAC NAME)\n         B     LPDECHK                 CHECK NEXT\nLPDEHIT  DS    0H                      LAST CHANCE             25JUN84\n         B     DOATTACH\n         DROP  R2                                              25JUN84\nLPDEEND  DS    0H                      LAST CHANCE             25JUN84\n*\n**             SETUP - BLDL\n*\n         MVC   DSABFF,=H'1'        1 ENTRY\n         MVC   DSABLL,=AL2(DSABEND-DSABNAME) ENTRY LENGTH\n         MVC   DSABNAME,DSANAME\n         ICM   R2,7,DSAATT+49          SEE IF TASKLIB\n         BZ    DOBLDL\n         L     R2,CVTPTR               NO-USE LINKLIB DCB\n         L     R2,CVTLINK-CVT(R2)      LINKLIB DCB\n         LA    R2,0                    NO-USE TASK LIST\nDOBLDL   DS    0H\n         LA    R3,DSABLDL\n         BLDL  (R2),(R3)               LOCATE IT\n         LTR   R15,R15                 FOUND??\n         BZ    DOATTACH                NO-JUST SAY NOT FOUND\n         ST    R15,DSAECB              SET RETURN CODE\n         TPUT  BLDLERR,L'BLDLERR\n         B     DOCLOSE                 SEE IF TASKLIB TO CLOSE\nDOATTACH DS    0H\n*\n**             ATTACH THE PROGRAM\n*\n         LA    R1,DSAPARM@             O/S PARM\n         LA    R5,DSAECB               TASK ECB\n         LA    R3,DSANAME              EPLOC NAME\n         ATTACH EPLOC=(R3),ECB=(R5),SF=(E,DSAATT)\n         ST    R1,DSATCB               SAVE TCB ADDR\n         WAIT  1,ECB=DSAECB            WAIT\n         DETACH DSATCB                 DETACH EM\nDOCLOSE  DS    0H\n         ICM   R1,7,DSAATT+49          SEE IF TASKLIB\n         BZ    TERME                   NO-RETURN\n         CLOSE (R1),MF=(E,DSAWF)       CLOSE TASKLIB\n         B     TERME\nTERME    DS    0H                      RETURN W/ UTILITY RC\n         XR    R15,R15\n         ICM   R15,7,DSAECB+1\nTERMEX   DS    0H\n         @RET  EQ\nPARSEERX DS    0H\n         TPUT  PARSERR,L'PARSERR   YES-GIVE IT UP\n         LA    R15,12                  SEVERE ERROR\n         B     TERMEX\nPARSERR  DC    C'TSCALL - PARSE ENDED WITH ERROR'\nTASKTPUT DC    C'TSCALL - TASKLIB BEING HONORED'\nBLDLERR  DC    C'TSCALL - PROGRAM NOT FOUND IN SYSTEM'\n         PUSH  PRINT\n         PRINT NOGEN\nSSATASKS DS    0D                      START OF TASKLIB DCB\nSSATASK  DCB   DDNAME=TASKLIB,DSORG=PO,MACRF=R\nSSATASKL EQU   *-SSATASKS              LENGTH\nSSAATTS  DS    0D                      START OF ATTACH LIST\nSSAATT   ATTACH EPLOC=*-*,ECB=*-*,TASKLIB=*-*,SZERO=NO,SF=L\nSSAATTL  EQU   *-SSAATTS               LENGTH\n         POP   PRINT\n         LTORG ,\n******** ***** *********************** PARSE\nTSCALPCL IKJPARM\nMEMBER   IKJIDENT 'STRING',MAXLNTH=8,PROMPT='UTILITY NAME',    XXXXXXXXX\n               OTHER=ALPHANUM,FIRST=ALPHA\nPARM     IKJPOSIT QSTRING\n         IKJENDP\n******** ***** *********************** D S A\nDSA      DSECT\nDSAWF    DS    F                       WORK WORD\nDSANAME  DC    CL8' '                  PROGRAM TO ATTACH\n*\nDSAPARM@ DC    AL1(128),AL3(0)         PARM PTR\nDSAPARML DC    H'0'                    PARM LENGTH\nDSAPARMA DC    CL100' '                PARM\n*\nDSAECB   DC    F'0'                    TASK ECB\nDSATCB   DS    F                       TASK TCB\n*\nDSATASKS DS    0D                      START OF TASKLIB DCB\nDSATASK  DCB   DDNAME=TASKLIB,DSORG=PO,MACRF=R\nDSATASKL EQU   *-DSATASKS              LENGTH\n*\nDSAATTS  DS    0D                      START OF ATTACH LIST\nDSAATT   ATTACH EPLOC=*-*,ECB=*-*,TASKLIB=*-*,SZERO=NO,SF=L\nDSAATTL  EQU   *-DSAATTS               LENGTH\n*\n*                                      PARSE PARM LIST\nDSAPUPT  DC    A(0)                    UPT\nDSAPECT  DC    A(0)                    ECT\nDSAPECB  DC    A(DSAWECB)              ECB\nDSAPPCL  DC    A(*-*)                  TSCALPCL\nDSAPANS  DC    A(DSAWANS)              ANS\nDSAPCBUF DC    A(0)\nDSAPUWA  DC    A(0)\nDSAWECB  DC    A(0)\nDSAWANS  DC    A(0)\n         DS    0D\n*        BLDL\nDSABLDL  DS    0F\nDSABFF   DS    H                   # ENTRIES\nDSABLL   DS    H                   ENTRY LENGTH\nDSABNAME DS    CL8                 NAME\nDSABTTR  DS    XL3                 TTR\nDSABK    DS    X\nDSABZ    DS    X\nDSABC    DS    X\nDSABDATA DS    XL100               DATA\nDSABATR1 EQU   DSABNAME+22         ATR1\nDSABEND  EQU   *                   LEN\nDSALEN   EQU   *-DSA\n**                                     DSECTS\n         PRINT NOGEN\n         IKJCPPL ,                     CPPL\n         IKJPSCB ,                     PSCB\n         IHACDE  ,                     CDE\n         IHALPDE ,                     LPDE\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSCVDAT": {"ttr": 1030, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE ' TSCVDAT GIVE DATE/DAY/TIME/LINE CTRS. TO PGMR.'\n*              RENT,REUS,REFR\n*              ALIAS TSCVDATE\nTSCVDAT  @ENT  R12,(0,DSASIZE),DSA=YES\n         LR    R2,R1                        SAVE PARM REGS\n         ST    R1,GETSAVE\n         L     R2,0(R2)\n         ST    R2,PARMSAVE\n         MVC   DSADATA(DSADLEN),MOVEDATA  MOVE CONSTANTS\n         TIME  DEC                     GET THE TIME\n         ST    R0,XTIME\n         ST    R1,XDATE\n*----------------------------------------------------------------------\n*        SUBROUTINES TO FORMAT THE DATE AND TIME\n*----------------------------------------------------------------------\nFTIME    DS    0H\n         MVC   XTIME1(8),=X'21204B20204B2020'\n         ED    XTIME1-1(9),XTIME       EDIT THE TIME\n*\n*        FORMAT TODAY'S DATE\n*\nFDATE    DS    0H\n         UNPK  DBLWORK(5),XDATE+1(3)   UNPACK DATE AND MOVE TO\n         MVC   XDATE1(2),DBLWORK       THE OUTPUT AREAS\n         MVC   XDATE1+3(3),DBLWORK+2\n         MVC   XDATE1+21(2),DBLWORK\n         XC    DBLWORK,DBLWORK\n         MVC   DBLWORK+5(3),XDATE+1\n         MVO   DBLWORK+5(3),DBLWORK+4(2) MAKE 00YYDDDS INTO 00000YYS\n         CVB   R0,DBLWORK\n         ST    R0,BINYEAR\n         MVI   MONMSK+10,28\n         TM    BINYEAR+3,X'03'    IS IT A LEAP YEAR?\n         BNZ   FDATE1             NO.\n         MVI   MONMSK+10,29       YES, CORRECT TABLE\nFDATE1   DS    0H\n         XC    DBLWORK,DBLWORK\n         MVC   DBLWORK+6(2),XDATE+2\n         CVB   R2,DBLWORK\n         ST    R2,BINDAYS         SAVE FOR LATER\n         XR    R0,R0\n         LA    R1,11\nFDATE2   DS    0H\n         IC    R0,MONMSK(R1)\n         SR    R2,R0\n         BNP   FDATE3\n         BCT   R1,FDATE2\n         B     FDATE4\n*\nMOVEDATA DC    YL1(31,30,31,30,31,31,30,31,30,31,28,31)\n         DC    C'0'        USED FOR EDIT\n         DC    C'HH.MM.SS'\n         DC    C' '\n         DC    C'YY.DDD/WWW/MMM DD, 19YY'\n*\nDAYTAB   DC    C'TUEWEDTHUFRISATSUNMON'\nMONTAB   DC    C'DECNOVOCTSEPAUGJULJUNMAYAPRMARFEBJAN'\nLINECTR1 DS    0CL18\n         DC    X'072C',X'080C',X'066C',X'056C'    LINE CTRS FOR PRINTER\n         DC    10C' '\n*\nFDATE3   DS    0H\n         AR    R2,R0       CORRECT OVERDRAW\nFDATE4   DS    0H\n         CVD   R2,DBLWORK\n         OI    DBLWORK+7,X'F'\n         UNPK  XDATE1+15(2),DBLWORK\n         MH    R1,=H'3'     CALC. MONTH\n         LA    R1,MONTAB(R1)\n         MVC   XDATE1+11(3),0(R1)\n*\n*        DAY OF WEEK\n*\n         L     R1,BINYEAR\n         SH    R1,=H'69'\n         BNP   THEEND\n         XR    R0,R0\n         D     R0,=F'4'\n         MH    R1,=H'5'\n         AR    R0,R1\n         A     R0,BINDAYS\n         SRDA  R0,32\n         D     R0,=F'7'\n         MH    R0,=H'3'\n         LR    R1,R0\n         LA    R1,DAYTAB(R1)\n         MVC   XDATE1+7(3),0(R1)\n         MVC   LINECTR2,LINECTR1       MOVE DEFAULT COUNTERS\n         L     R2,PARMSAVE\n         CLI   8(R2),C'1'           IS IT NEW VERSION FOR LINE CTRS?\n         BE    MOVECTRS\n         MVC   0(32,R2),XTIME1         MOVE DATE DATA TO PGMR\n         B     THEEND\nMOVECTRS DS    0H\n         MVC   0(50,R2),XTIME1         MOVE DATE/LINE CTRS TO PGMR\nTHEEND   DS    0H\n         @RET  EQ,RC=0\n         LTORG\n         DS    0D\nDSA      DSECT\nDSADATA  EQU   *                       START OF COPY\nMONMSK   DC    YL1(31,30,31,30,31,31,30,31,30,31,28,31)\n         DC    C'0'                    USED FOR EDIT\nXTIME1   DC    C'HH.MM.SS'\n         DC    C' '\nXDATE1   DC    C'YY.DDD/WWW/MMM DD, 19YY'\nDSADLEN  EQU   *-DSADATA               END OF COPY\nLINECTR2 DS    0CL18\n         DC    8C' '                          DUMMY AREA FOR LINE CTRS\n         DC    10C' '                          FILLER AREA\n* WARNING DON''T PUT ANYTHING BETWEEN HERE AND XTIME1 '\n         DC    0D'0'\nXDATE    DC    F'0'\nXTIME    DC    F'0'\nBINYEAR  DC    F'0'\nBINDAYS  DC    F'0'\nMSAVE    DS    18F'0'\nGETSAVE  DS    F'0'\nPARMSAVE DS    F'0'\nDBLWORK  DS    D'0'\n         DS    D'0'\nDSASIZE  EQU   *-DSA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSCVDATE": {"ttr": 1033, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&N       TSCVDATE &PR=TSCV\n*\n**             T S C V D A T E   D A T A   A R E A   M A P\n*                                                     MOD DATE 12-17-79\n&N       DS    0CL32\n&PR.TIME DS    0CL8                HH.MM.SS\n&PR.TIMH DS    CL2                  HH\n         DS    C                        PERIOD\n&PR.TIMM DS    CL2                  MM\n         DS    C                        PERIOD\n&PR.TIMS DS    CL2                  SS\n         DS    C                        BLANK\n&PR.JULN DS    CL6                 YY.DDD\n         DS    C                        SLASH\n&PR.DOW  DS    CL3                 WWW DAY OF WEEK\n         DS    C                        SLASH\n&PR.MON  DS    CL3                 MONTH\n         DS    C                        BLANK\n&PR.DAY  DS    CL2                 DD\n         DS    CL2                      COMMA BLANK\n&PR.YEAR DS    CL4                 19XX\n&PR.CONS DS    0C                  CONSTANTS\n&PR.3800 DS    CL2                 DEFAULT LINE CTR 3800\n&PR.3211 DS    CL2                                  3211\n&PR.3284 DS    CL2                                  3284\n&PR.MICR DS    CL2                                  MICRO\n         DS    CL10                FILLER FOR EXPANSION\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSDYNLXA": {"ttr": 1035, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET CBT910     AT LEVEL 002 AS OF 09/21/83\n***********************************************************************\n***********************************************************************\n*******             C. B. T.         8/83               LMB-CBT *******\n*******                                                         *******\n*******                                                         *******\n******* UPDATED WITH UCB CODING CONVENTIONS FOR X-A         CBT *******\n******* THIS CODE SHOULD RUN UNDER MVS SP AND X-A           CBT *******\n*******                                                     CBT *******\n******* CONVERTED TO RUN UN-AUTHORIZED                           CJH **\n******* THIS MODULE HAS BEEN CONVERTED TO PUTLINE/GETLINE.  CBT *******\n***********************************************************************\nCBT910   CSECT\nCBT910   AMODE 31\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nEDTLUVSP EQU   X'000'\nLUVENTNO EQU   X'000'\nLUVENTLN EQU   X'004'\nLUVENTRY EQU   X'008'\nLUVUNAME EQU   X'000'\nLUVVALUE EQU   X'008'\n         EJECT\n         USING *,R15\n         BC    15,PROLOG\n         DC    CL8'CBT910  '       MODULE NAME\n         DC    CL8'&SYSDATE'      DATE MODULE COMPILED\n         DC    CL8'&SYSTIME'      TIME MODULE COMPILED\n         DROP  15\nPROLOG   EQU   *\n         STM   R14,R12,12(R13)    SAVE REGS\n         LR    R11,R15            SET UP BASE REG\n         USING CBT910,R11\n         GETMAIN R,LV=LDYNAMIC    LEN OF DYNAMIC AREA\n         LR    R10,R1\n         ST    R13,4(R10)         SAVE HSA IN LSA\n         ST    R10,8(R13)         SAVE LSA IN HSA\n         L     R1,24(R13)         RESTORE REG ONE\n         LR    R13,R10            SET UP NEW SAVE AREA\n         USING DYNMAREA,R13\n         ST    R1,CPPLADDR\n         MVI   MSGWORK,X'40'      CLEAR MSG BUFFER\n         MVC   MSGWORK+1(120),MSGWORK\n         MVI   NAMETAB,X'40'      CLEAR NAME TABLE TO BLANKS\n         MVC   NAMETAB+1(255),NAMETAB\n         MVC   NAMETAB+256(255),NAMETAB\n         MVC   NAMETAB+511(255),NAMETAB\n         MVC   NAMETAB+766(255),NAMETAB\n         MVC   NAMETAB+1021(255),NAMETAB\n         MVC   NAMETAB+1276(255),NAMETAB\n         MVC   NAMETAB+1531(255),NAMETAB\n         MVC   NAMETAB+1786(14),NAMETAB\n         SPACE 2\nLOAD     L     R1,CVTPTR          CVT ADDRESS\n         USING CVTMAP,R1          ADDRESS TO DSECT\n         L     R1,CVTJESCT        JES CONTROL TABLE\n         USING JESCT,R1           ADDRESS TO DSECT\n         L     R15,JESCTEXT            EXTENSION\n         L     R15,JESGB4UV-JESPEXT(R15) ADR OF IEFGB4UV\n         ST    R15,DSAGB4UV\n         L     R1,JESEDT          EDT\n         DROP  R1\n         L     R10,EDTLUVSP(,R1)  LOOK-UP SECTION\n         L     R0,LUVENTNO(,R10)  # OF UNIT NAMES\n         L     R8,LUVENTLN(,R10)  LENGTH OF ENTRY\n         LA    R15,LUVENTRY(,R10)      FIRST ENTRY\n         LA    R1,NAMETAB\nTABLSCAN MVC   0(8,R1),0(R15)\n         MVI   8(R1),C' '\n         LA    R1,9(R1)           INCREMENT OUTPUT STAK\n         LA    R15,0(R8,R15)      INCREMENT NAMET POINTER\n         BCT   R0,TABLSCAN\n         EJECT\nREPEAT   EQU   *                           AXC\n         LA    R2,NAMETAB                      NAME\nNAMESOUT EQU   *\n         MVC   MSGOUT(72),0(R2)   MOVE OUT 8 NAMES\n         BAL   R4,PUTLINE         GO PRINT IT OUT\n         LA    R2,72(R2)\n         CLI   0(R2),C' '\n         BNE   NAMESOUT\nGET      MVC   MSGOUT(L'MSGENTER),MSGENTER\n         BAL   R4,PUTLINE\nGET1     BAL   R4,GETLINE\n         MVC   UNITNAME(8),=CL8' '\n         L     R1,INPUTADR\n         LH    R7,0(R1)\n         CLC   0(2,R1),=X'0004'   A NULL RETURN?\n         BC    12,GET             NO REPLY GO ASK AGAIN\n         CLI   4(R1),C'='                THE ABILITY TO REPEAT AXC\n         BE    REPEAT                    THE ABILITY TO REPEAT AXC\nGET2     DS    0H\n         MVC   MSGOUT(80),4(R1)\n         BAL   R4,PUTLINE\n         CLI   4(R2),C'*'\n         BE    GET1\n         LA    R1,4(R1)       POINT TO INPUT DATA\n         LR    R2,R1\n         BC    15,COMPRIT\n         MVC   UNITNAME(0),0(R2)\nCOMPRIT  EX    R7,*-6\n         TR    UNITNAME(8),TRTABLE\n         CLC   END,UNITNAME\n         BE    EODAD\n***********************************************************************\n***********************************************************************\n* CHECK THAT THE CLASS NAME ENTERED IS VALID. THIS IS DONE\n* BY COMPARING THE NAME (GENERIC OR ESOTERIC) AGAINST THE\n* CLASS NAMES IN THE EDT LOOK UP SECTION.\n* A DSECT FOR EDT SHOULD BE SUBSTITUTED WHEN AVAILABLE.\n***********************************************************************\n***********************************************************************\n         L     R0,LUVENTNO(,R10)   # CLASS TYPES IN EDT\n         LA    R15,LUVENTRY(,R10)   1ST ENTRY\nNAMESCAN CLC   UNITNAME,0(R15)\n         BE    HAVENAME\n         LA    R15,0(R8,R15)        GET NEXT ENTRY\n         BCT   R0,NAMESCAN\n         MVC   MSGOUT(8),UNITNAME\n         BAL   R4,PUTLINE\n         MVC   MSGOUT(27),=CL27' ******* INVALID CLASS NAME'\n         BAL   R4,PUTLINE\n         STIMER REAL,BINTVL==F'500'  WAIT 5 SEC TO SINK IN\n         B     GET\n***********************************************************************\n* THE DEVICE NAME ENTERED IS VALID (IT WAS FOUND AGAIN IN\n* THE EDT LOOKUP SECTION.  MOVE UNITNAME TO KEY 1 STORAGE\n* AND INVOKE IEFAB4UV TO RETURN ASSOCIATED UCB ADDRESSES.\n* R0, R1, R2, R8, R7, R14 CAN BE REUSED NOW.\n***********************************************************************\nHAVENAME SR   R1,R1               INITIALIZE IT\n         L    R2,CVTPTR           GET CVT POINTER\n         L    R2,0(R2)            OLD-NEW POINTER\n         L    R2,4(R2)            OUT TCB POINTER\n         ST   R6,TCBHOLD          HOLD ADDR OF TCB\n         USING TCB,R6\n**********YOU MUST BE SUPERVISOR MODE TO GETMAIN KEY1 SP:\n*$       SR   R1,R1\n*$       SVC  888\n*$       TESTAUTH FCTN=1\n*$       LTR   R15,R15\n*$       BNZ   NOAUTH                  RATS\n         L    R9,SPNO236               SUBPOOL 236 (KEY 1)\n*$       MODESET MODE=SUP\n         GETMAIN R,LV=LKEY1SP,SP=(R9)  FOR KEY SUBPOOL STORAGE\n**********MUST BE KEY0 (OR KEY1) TO MOVE INTO SP236 (WRITE PROTECTED):\n*$       MODESET EXTKEY=ZERO\n         ST   R1,KEY1ADDR         SAVE KEY1 GETMAIN'D AREA PTR\n         LR   R7,R1              PTR TO KEY1 STORAGE\n         USING KEY1SP,R7         ADDR TO DSECT\n***********************************************************************\n* SET UP PARAMETER LIST FOR KEY 1 STORAGE FOR IEFAB4UV\n***********************************************************************\n         LA   R1,UNITABLE\n         ST   R1,UTBLPTR\n         LA   R1,FLAGS\n         ST   R1,FLAGPTR\n         LA   R1,ATTRAREA\n         ST   R1,ATTRPTR\n         MVC  UNAME(8),UNITNAME\n         MVC  FLAGS,FLAGSET\n******KEY0 NO LONGER NEEDED, ALL INFO ALREADY MOVED INTO SP236 STORAGE:\n         ST   R6,TCBHOLD\n         USING TCB,R6\n*$       MODESET EXTKEY=TCB,WORKREG=9\n*$       LA   R1,4\n*$       SVC  888\n*$       LINK EP=IEFAB4UV\n         ESTAE MYESTAE,CT,PARAM=(R13)\n         LA   R1,PARMLIST\n         L     R15,DSAGB4UV\n         BALR  R14,R15\n         ST    R15,DSAGB4RC            SAVE RC\n         ESTAE 0\n*\n         L     R15,DSAGB4RC            RESTORE RC\n         LTR  R15,R15             HAVE UCBS BEEN RETURNED?\n         BC   8,GOTUCBS           UCBS RETURNED GO LOOK AT THEN\n         CH   R15,=H'4'           R15=4\n         BC   8,NONAME            SAY CLASS NAME NOT FOUND\n         CH   R15,=H'16'          R16=16\n         BC   8,NOSTORGE          NO STORAGE AVAIL FOR UCB LIST\n         BC   15,ABENDIT          ABEND ALL OTHER RETURN CODES\n***********************************************************************\n* UCBS RETURNED IN SUBPOOL 230 STORAGE. KEY 1 STORAGE CAN\n* NOW BE FREED,  THEN PROCESS THE UCB LIST AND FREE\n* SUBPOOL 230 STORAGE PRIOR TO EOJ.\n***********************************************************************\nGOTUCBS  MVC  UCBLIST,UCBPTR      SAVE PTR TO UCB LIST\n         L    R9,SPNO236\n         L    R1,KEY1ADDR\n         FREEMAIN R,LV=LKEY1SP,SP=(R9),A=(R1)\n         L     R9,UCBLIST         PTR TO UCB LIST\n         CLI   0(R9),X'E6'        IS THIS THE UCB LIST?\n         BC    7,NOTUCBLS         NOT UCB LIST SEND MSG\n         MVC   LISTLEN,0(R9)      HOLD LEN OF LIST\n         DROP  R7                 FROM KEY1 PARM DSECT\n         L     R7,4(R9)           NUMBER OF UCBS IN LIST\n         LA    R9,8(R9)           ADDRESS OF 1ST UCB PTR\n         L     R15,0(R9)          FIRST UCB PTR\nGETUCB   EQU   *\n         USING UCBOB,R15\n         MVC   MSGOUT+4(3),UCBNAME\n         TM    UCBDVCLS,UCB3DACC        DIRECT ACCESS?\n         BZ    NOTDA                    NO\n         TM    UCBSTAT,UCBONLI          ONLINE?\n         BZ    NOTONL\n         CLI   UCBVOLI,X'00'            YES, VOLID KNOWN?\n         BE    NOTDA                    NO\n         MVI   MSGOUT+8,C'-'\n         MVC   MSGOUT+10(6),UCBVOLI\n         B     NOTDA\nNOTONL   EQU   *\n         MVI   MSGOUT+8,C'-'\n         MVC   MSGOUT+10(7),=CL7'OFFLINE'\n         SPACE 2\nNOTDA    DS    0H\n         BAL   R4,PUTLINE\n         BCT   R7,NOTTHIS\n         B     GET\nNOTTHIS  DS    0H\n         LA    R9,4(,R9)\n         L     R15,0(R9)\n         BC    15,GETUCB\nGETLINE  STM   R0,R15,SAVEREGS    SAVE CALLER'S REGS\n         L     R2,CPPLADDR        ADDR OF CPPL\n         USING CPPL,R2\n         L     R3,CPPLUPT         UPT ADDR\n         L     R4,CPPLECT         ECT ADDR\n         XC    ECB,ECB            CLEAR OUT ECB\n         XC    GTPBX(8),GTPBX     CLEAR GET PARMLIST TO ZEROS\n         XC    IOPLX(16),IOPLX    CLEAR PARM LIST TO ZEROS\n         LA    R1,IOPLX           ADDR OF LIST\n         GETLINE PARM=GTPBX,UPT=(R3),ECT=(R4),ECB=ECB,                 X\n               TERMGET=(EDIT,WAIT),INPUT=(ISTACK,LOGICAL),             X\n               MF=(E,(1))\n         LA    R5,GTPBX           ADDRESSABILITY FOR THE GTPB\n         USING GTPB,R5\n         L     R6,GTPBIBUF        ADDR OF INPUT LINE\n         ST    R6,INPUTADR        SAVE ADDR OF INPUT BUFFER\n         LM    R0,R15,SAVEREGS    RESTORE CALLER'S REGS\n         BR    R4\n         EJECT\nPUTLINE  MVC   MSGCNTL,PUTCNTL    MOVE IN PUTLINE CONTROL CHARS\n         STM   R0,R15,SAVEREGS    SAVE CALLER'S REGS\n         LA    R5,MSGWORK         ADDR OF MSG BUFFER\n         L     R2,CPPLADDR        ADDR OF CPPL\n         USING CPPL,R2\n         LA    R1,PUTLPARM        ADDR OF PLIST\n         USING IOPL,R1\n         MVC   IOPLECT,CPPLECT    MOVE ADDR OF ECT TO PLIST\n         MVC   IOPLUPT,CPPLUPT    MOVE ADDR OF UPT TO PLIST\n         LA    R0,ECB             ADDR OF ECB\n         ST    R0,IOPLECB         STORE INTO PLIST\n         XC    ECB,ECB            CLEAR ECB TO ZEROS\n         XC    PTPB(16),PTPB      CLEAR PLIST TO ZEROS\n         PUTLINE PARM=PTPB,ECB=ECB,                                    X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               OUTPUT=((R5),TERM,SINGLE,DATA),                         X\n               MF=(E,(1))\n         MVI   MSGWORK,X'40'      CLEAR BUFFER TO SPACES\n         MVC   MSGWORK+1(120),MSGWORK\n         LM    R0,R15,SAVEREGS    RESTORE CALLER'S REGS\n         BR    R4                 RETURN TO CALLER\nNONAME   MVC   MSGOUT(27),=CL27'  CLASS NAME NOT FOUND - RETRY'\n         BAL   R4,PUTLINE\n         BC    15,GET\nNOSTORGE MVC   MSGOUT(27),=CL27'  NO STORAGE AVAIL FOR UCB LIST'\n         BAL   R4,PUTLINE\n         BC    15,EODAD\nNOTUCBLS MVC   MSGOUT(27),=CL27'  UCB LIST NOT BEING SEARCHED'\n         BAL   R4,PUTLINE\n         BC    15,EODAD\nABENDIT  MVC   MSGOUT(10),=CL10'  ABEND IT'\n         BAL   R4,PUTLINE\n         BC    15,EODAD\nNOAUTH   MVC   MSGOUT(27),=CL27'  NOT AUTHORIZED'\n         BAL   R4,PUTLINE\n         BC    15,QUIT\nEODAD    L     R6,TCBHOLD\n         USING TCB,R6\n*$       SR    R1,R1              PREPARE FOR AUTHORIZATION\n*$       SVC   888                TO PREPARE FOR KEY=1\n*$       MODESET MODE=SUP         TO PREPARE FOR KEY=1\n         L     R0,LISTLEN         SUBPOOL 230 + LEN OF STORAGE\n         L     R1,UCBLIST         PTR TO GETMAIN'D AREA\n         LTR   R1,R1              IS A FREEMAIN REQUIRED\n         BC    8,EODADB           NO BRANCH AROUND IT\n         N     R0,=X'00FFFFFF'         FORCE SUBPOOL 0 *$\n*$       MODESET EXTKEY=SCHED\n         SVC   10                 FREEMAIN OF SUBPOOL 230\nEODADB   DS    0H\n*$       MODESET KEY=ZERO,MODE=PROB\n*$       MODESET EXTKEY=TCB,WORKREG=9\n*$       LA    R1,4\n*$       SVC   888\nQUIT     DS    0H\n         LR    R1,R13             DYNAMIC AREA ADDR\n         LA    R0,LDYNAMIC        SIZE OF AREA\n         L     R13,4(,R13)        PREV SAVE AREA\n         LA    R1,0(,R1)          CLEAR HI ORDER\n         SVC   10                 FREEMAIN\n         LM    R14,R12,12(R13)    RESTORE REGS\n         LA    R15,0              RETURN CODE\n         MVI   12(R13),X'FF'      INDICATE RETURN\n         BR    R14                GO BACK TO TMP\n         LTORG\nMYESTAE  DS    0H\n         PUSH  USING\n         USING MYESTAE,R15\n         USING SDWA,R1\n         CH    R0,=H'12'               Q/SDWA\n         BE    MYESQUIT                N/GET OUT\n         SP    MYESCTR,=P'1'           LOOP FAILSAFE\n         BZ    MYESQUIT\n         CLC   =X'0C2000',SDWACMPC     PRIV OP INTERRUPT?\n         BNE   MYESA78                 YES-SKIP IT\n         L     R0,SDWANXT1             NEW INSTR AFTER PRIVOP\n         B     MYESRTRY\nMYESA78  DS    0H\n         CLC   =X'B78000',SDWACMPC     GETMAIN/FREEMAIN FAIL\n         BNE   MYESQUIT\n         ICM   R0,15,SDWASRSV+15*4     GET ORIG R15\n         N     R0,=X'FFFF00FF'         SET SUBPOOL TO ZERO\n         STCM  R0,15,SDWASRSV+15*4     NEW R15\n         L     R0,SDWANXT2\n         SH    R0,=H'2'                BACKUP\nMYESRTRY DS    0H\n         SETRP RC=4,RETADDR=(R0),FRESDWA=YES,DUMP=NO,RETREGS=YES\n         BR    R14\nMYESQUIT DS    0H\n         SETRP RC=0,FRESDWA=NO,DUMP=YES\n         BR    R14\nMYESCTR  DC    P'01024'                LOOP PROTECTION\n         POP   USING\n         LTORG\nALLBLANK DS    200CL9' '\n         DS    0F\nSPNO236  DC    X'00000000'        SUBPOOL 236 *$ USE SP0\nSPNO230  DC    X'00000000'        SUBPOOL 230 *$ USE SP0\nFLAGSET  DC    XL2'1000'          BIT 3 SET FOR UCB SEARCH\nPUTCNTL  DC    H'121'             CONTROL CHARS FOR PUTLINE\n         DC    H'0'\nMSGENTER DC C'ENTER GROUP NAME OR ''='' TO REPEAT OR ''END'' TO END'\nEND      DC    C'END'\n         DS    0D        TO DEFINE WHOLE FF BYTES OF A TABLE\nTRTABLE  DC    XL256'00'\n         ORG   TRTABLE+X'40'\n         DC    X'40'                    BLANK\n         ORG   TRTABLE+X'60'\n         DC    X'60'                    - (DASH)\n         ORG   TRTABLE+X'81'\n         DC    X'C1C2C3C4C5C6C7C8C9'    ABCDEFGHI\n         ORG   TRTABLE+X'91'\n         DC    X'D1D2D3D4D5D6D7D8D9'    JKLMNOPQR\n         ORG   TRTABLE+X'A2'\n         DC    X'E2E3E4E5E6E7E8E9'      STUVWXYZ\n         ORG   TRTABLE+X'C1'\n         DC    X'C1C2C3C4C5C6C7C8C9'    ABCDEFGHI\n         ORG   TRTABLE+X'D1'\n         DC    X'D1D2D3D4D5D6D7D8D9'    JKLMNOPQR\n         ORG   TRTABLE+X'E2'\n         DC    X'E2E3E4E5E6E7E8E9'      STUVWXYZ\n         ORG   TRTABLE+X'F0'\n         DC    X'F0F1F2F3F4F5F6F7F8F9'  123456789\n         ORG   TRTABLE+X'100'\nGETLIST  GETLINE INPUT=(TERM,PHYSICAL),                                X\n               TERMGET=(EDIT,WAIT),MF=L\nDYNMAREA DSECT\nSAVEAREA DS    18F                      SAVE AREA\nSAVEREGS DS    16F                      FOR PUTLINE\nCPPLADDR DS    F\n******THE FOLLOWING ARE FOR PUTLINE:\nMSGWORK  DS    0CL121\nMSGCNTL  DS    F                  CONTROL WORD FOR PUTLINE\nMSGOUT   DS    CL120              FOR PUTLINE\nPUTLPARM DS    10A\nECB      DS    F\nPTPB     DS    4F\n******THE FOLLOWING ARE FOR GETLINE:\nGTPBX    DS    2F\nIOPLX    DS    4F                 I-O PARM LIST FOR GETLINE\nINPUTADR DS    F                  ADDR FOR INPUT BFFER\nINPUTCTL DS    F                  CNTL BYTES OF INPUT BUFFER\nUNITNAME DC    CL8' '\n         DC    C' '\nNAMETAB  DS    0F\n         DC    200CL9' '\n         DS    0F\nTCBHOLD  DS    F\nDSAGB4UV DS    F                       EP OF IEFGB4UV\nDSAGB4RC DS    F                       RC \"\nKEY1ADDR DS    F\nLISTLEN  DS    F\nUCBLIST  DS    F                   PTR TO UCB LIST\n         DS    0D\nLDYNAMIC EQU   *-DYNMAREA          SIZE OF DYNAM AREA\n***********************************************************************\n* DSECT FOR KEY1 SUBPOOL GETMAIN'D STORAGE\n***********************************************************************\nKEY1SP   DSECT                     GETMAIN DSECT FOR KEY1 SUBPOOL\nPARMLIST DS    2F                  PARMLIST MAPPING\n         ORG   PARMLIST\nUTBLPTR  DS    F                   ADDRESS OF 100-BYTE WORK AREA\nFLAGPTR  DS    F                   ADDR OF DEVTYPE BYTE TO BE SEARCHED\n         DS    0F\nUNITABLE DS    CL20\n         ORG   UNITABLE\nUNAME    DS    8C\nUCBPTR   DS    F\nATTRPTR  DS    F\n         DS    F\n*\nFLAGS    DS    XL2\nATTRAREA DS    CL10\nLKEY1SP  EQU   *-KEY1SP\n***********************************************************************\n*        DSECTS\n***********************************************************************\n         PUSH  PRINT\n         PRINT  OFF                    SAVE-A-TREE\n         EJECT\n         IEFUCBOB ,\n         EJECT\n         IEFJESCT ,\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IKJTCB ,\n         EJECT\n         IKJCPPL ,\n         EJECT\n         IKJPPL ,\n         EJECT\n         IKJIOPL ,\n         EJECT\n         IKJGTPB ,\n         EJECT\n         IHASDWA ,\n         POP   PRINT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSENQSP3": {"ttr": 1286, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TSENQSP3 TITLE 'LIST DATA FROM GRS BY RNAME JOBNAME QNAME'\n*********************************************************************\n* ALIAS  $DENQ                                                      *\n* FUNCTION - DISPLAY 1) USERS                                       *\n*                    2) DISPOSITION                                 *\n*                    3) WAITING FOR DATASETS                        *\n*                    4) SYSTEM                                      *\n*                    5) MUST COMPLETE FLAG                          *\n*                    6) RESERVE FLAG                                *\n*                    7) GLOBAL FLAG                                 *\n*                    8) OWNERSHIP FLAG                              *\n*                    FOR THE SPECIFIED DATASET.                     *\n*                                                                   *\n* COMMAND SYNTAX - $DENQ DSNAME JOBNAME QNAME                       *\n* DEFAULTS NO OPERANDS: LOOK FOR ENQS  (SEE LIST OF QNAMES)         *\n*          IF DSNAME = \"RES\" THEN SHOW ALL RESERVES (\" \")           *\n*          QNAME DEFAULTS TO SYSDSN IF DSNAME SPECIFIED             *\n*          QNAME DEFAULTS TO QNAME LIST IF LOOKING FOR ENQS/RES     *\n*                                                                   *\n* 1) DO NOT USE QUOTES AROUND THE DATASET NAME                      *\n* 2) WORKS FOR A FULL OR PARTIAL QUALIFIED DATASET NAME             *\n*                                                                   *\n* NOTE - THIS CODE HAS NOT BEEN TESTED WITH A GRS RING.             *\n*        SCOPE=GLOBAL WILL HAVE TO BE SPECIFIED ON THE GQSCAN MACRO *\n*        AND THE GQSCAN HAS TO RUN AUTHORIZED KEY ZERO.             *\n*                                                                   *\n* NOTE - THE 'SYSNAME' IN IEASYS00 SHOULD SPECIFY YOUR SMFID TO     *\n*        GET THE CORRECT SYSTEM NAME IN THE 'SYSTEM' FIELD,         *\n*        OTHERWISE (NONA) NONAME WILL BE DISPLAYED.                 *\n*                                                                   *\n*********************************************************************\n*\nTSENQSP3 @ENT  R12,(0,DSALEN,C),DSA=YES CSECT @ENT BASE,(SP,L',CLEAR)\n         LR    R3,R1                   LOAD CPPL PTR\n         USING CPPL,R3\n*                                                              15OCT84\n*------- ----- INITIALIZE CONSTANTS                            15OCT84\n*                                                              15OCT84\n         MVI   JOBNAME,C' '            CLEAR AREA              15OCT84\n         MVC   JOBNAME+1(JOBLINEL-1),JOBNAME                   15OCT84\n         MVI   ULINE,C'-'              DASHES                  15OCT84\n         MVC   ULINE+1(L'ULINE-1),ULINE                        15OCT84\n         MVC   SCAND(SCANDLEN),SCANC                           15OCT84\n*------- ----- SET SYSTEM ID                                   15OCT84\n         L     R9,16                   CVTPTR\n         L     R4,196(R9)              CVTSMCA\n         MVC   TITLE,=CL32'SHARE - DATASET USAGE DISPLAY -'\n         MVC   TITLVER,=C' - V1.1'     RELEASE #\n         MVC   TITLF1,=C' - '          FILLER                  15OCT84\n         MVC   TITLSID,SMCASID-SMCABASE(R4)   SYSTEM ID\n*\n         L     R14,CPPLCBUF            GET COMMAND BUFFER\n         LH    R15,2(R14)              GET OPERAND OFFSET\n*\n         LA    R15,4(R15,R14)          POINT TO OPERAND\n         MVC   REQQNM,QNAMES           DEFAULT QNAME           15OCT84\n         LA    R1,QNAMES               CURRENT QNAME           15OCT84\n         ST    R1,REQQNMC              \"                       15OCT84\n         MVC   REQJOB,BLANKS           OUTPUT AREA             15OCT84\n         MVC   REQJOBL,=H'1'           DEFAULT=ANY JOB         15OCT84\n         MVI   REQJOB,C'*'                                     15OCT84\n         MVC   REQDSN,BLANKS           OUTPUT AREA             15OCT84\n         MVC   REQDSNL,=H'1'           DEFAULT=ANY DSN         15OCT84\n         MVI   REQDSN,C'*'                                     15OCT84\n         L     R1,CPPLECT              GET ECT\n         TM    ECTSWS-ECT(R1),ECTNOPD  NO OPERANDS?            15OCT84\n         BNO   GETPARMS                NO-SCAN                 15OCT84\n         MVI   DSAENQWT,C'Y'           ONLY LOOK FOR ENQS      15OCT84\n         B     GETEND                  SKIP OPR SCAN           15OCT84\nGETPARMS DS    0H                                              15OCT84\n         CLI   0(R15),C' '             ANY OPERANDS            15OCT84\n         BE    INVPARM                 NO-ERROR                15OCT84\n         LR    R0,R15                  REMEMBER                15OCT84\n         AH    R14,0(,R14)             POINT TO END OF BUFFER\n         LA    R1,REQDSN               OUTPUT AREA             15OCT84\nGETDSN   DS    0H                                              15OCT84\n         CR    R15,R14                 END OF OF 1ST OP        15OCT84\n         BNL   GETDSNXX                OUT OF PARMS            15OCT84\n         MVC   0(1,R1),0(R15)          MOVE 1 BYTE OF DSN      15OCT84\n         LA    R1,1(R1)                                        15OCT84\n         LA    R15,1(R15)                                      15OCT84\n         CLI   0(R15),C' '             END OF DSN              15OCT84\n         BE    GETDSNXX                YES-DO CALCS            15OCT84\n         CLI   0(R1),C' '              DONT OVERRUN OUTPUT     15OCT84\n         BE    GETDSN                  SPACE AVAIL-CONTINUE    15OCT84\n         B     INVPARM                 DSNAME OVER 44 CHAR     15OCT84\nGETDSNXX DS    0H                                              15OCT84\n         LR    R1,R15                  L'DSN                   15OCT84\n         SR    R1,R0                                           15OCT84\n         STH   R1,REQDSNL                                      15OCT84\n*                                                              15OCT84\n*------- GET JOBNAME SEARCH IF ANY                             15OCT84\n*                                                              15OCT84\n         LA    R1,REQJOB               START OF OUTPUT         15OCT84\nGETSKP1  DS    0H                                              15OCT84\n         LR    R0,R15                  SHOW ZERO L' IF EXIT    15OCT84\n         CR    R15,R14                 END OF ALL PARMS        15OCT84\n         BNL   GETJOBXX                YES-END                 15OCT84\n         CLI   0(R15),C' '             JOBNAME?                15OCT84\n         BNE   GETJOB                  YES-DOIT                15OCT84\n         LA    R15,1(R15)                                      15OCT84\n         B     GETSKP1                 FIND START OF JOBNAME   15OCT84\nGETJOB   DS    0H                                              15OCT84\n         CR    R15,R14                 END OF 2ND PARM?        15OCT84\n         BNL   GETJOBXX                                        15OCT84\n         MVC   0(1,R1),0(R15)          MOVE 1 BYTE OF JOBNAME  15OCT84\n         LA    R1,1(,R1)                                       15OCT84\n         LA    R15,1(,R15)                                     15OCT84\n         CLI   0(R15),C' '             END OF JOBNAME          15OCT84\n         BE    GETJOBXX                                        15OCT84\n         CLI   0(R1),C' '              AVAIL BYTE?             15OCT84\n         BE    GETJOB                  YES-CONTINUE            15OCT84\n         B     INVPARM                 JOBNAME OVER 8 CHAR     15OCT84\nGETJOBXX DS    0H                                              15OCT84\n         LR    R1,R15                  L'JOBNAME               15OCT84\n         SR    R1,R0                                           15OCT84\n         STH   R1,REQJOBL                                      15OCT84\n*                                                              15OCT84\n*------- GET QNAME OVERRIDE IF ANY                             15OCT84\n*                                                              15OCT84\nGETSKP2  DS    0H                                              15OCT84\n         LR    R0,R15                  SHOW ZERO L' IF EXIT    15OCT84\n         CR    R15,R14                 END OF ALL PARMS        15OCT84\n         BNL   GETQNMXX                YES-END                 15OCT84\n         CLI   0(R15),C' '             QNAME?                  15OCT84\n         BNE   GETQNMS                 YES-DOIT                15OCT84\n         LA    R15,1(R15)                                      15OCT84\n         B     GETSKP2                 FIND START OF JOBNAME   15OCT84\nGETQNMS  DS    0H                                              15OCT84\n         LA    R1,REQQNM               START OF OUTPUT         15OCT84\n         MVC   REQQNM,=CL8'*'          KILL SYSDSN DEF.        15OCT84\nGETQNM   DS    0H                                              15OCT84\n         CR    R15,R14                 END OF 3RD PARM?        15OCT84\n         BNL   GETQNMXX                                        15OCT84\n         MVC   0(1,R1),0(R15)          MOVE 1 BYTE OF QNAME    15OCT84\n         LA    R1,1(,R1)                                       15OCT84\n         LA    R15,1(,R15)                                     15OCT84\n         CLI   0(R15),C' '             MORE                    15OCT84\n         BE    GETQNMXX                NO-DO CALCS             15OCT84\n         CLI   0(R1),C' '              AVAIL BYTE?             15OCT84\n         BE    GETQNM                  YES-CONTINUE            15OCT84\n         B     GETQNMXX                ?$?TEMP-STOP AT 8       15OCT84\n         B     INVPARM                 QNAME OVER 8 CHAR       15OCT84\nGETQNMXX DS    0H                                              15OCT84\n         LR    R1,R15                  L'QNAME                 15OCT84\n         SR    R1,R0                                           15OCT84\n         STH   R1,REQQNML                                      15OCT84\nGETFINI  DS    0H                                              15OCT84\n         OC    REQQNM,BLANKS           UPPER CASE              15OCT84\n         OC    REQJOB,BLANKS                                   15OCT84\n         OC    REQDSN,BLANKS                                   15OCT84\n*                                                              15OCT84\n         CLC   =C'ENQ ',REQDSN         SPECIAL DSN             15OCT84\n         BNE   NODSNSP1                NO                      15OCT84\n         MVI   DSAENQWT,C'Y'           YES-FIXUP DATA          15OCT84\n         MVC   REQDSN(3),=C'*  '       PUT BACK DEFAULT        15OCT84\n         MVC   REQDSNL,=H'1'           DEFAULT=ANY DSN         15OCT84\nNODSNSP1 DS    0H                                              15OCT84\n*                                                              15OCT84\n         CLC   =C'RES ',REQDSN         SPECIAL DSN             15OCT84\n         BNE   NODSNSP2                NO                      15OCT84\n         MVI   DSARESSW,C'Y'           YES-FIXUP DATA          15OCT84\n         MVC   REQDSN(3),=C'*  '       PUT BACK DEFAULT        15OCT84\n         MVC   REQDSNL,=H'1'           DEFAULT=ANY DSN         15OCT84\nNODSNSP2 DS    0H                                              15OCT84\nGETEND   DS    0H                                              15OCT84\n*                                                              15OCT84\n*------- FORMAT TIME                                           15OCT84\n*                                                              15OCT84\n         STCK  STCKSTCK\n         @STCK CODE                    FORMAT TOD CLOCK        15OCT84\n         MVC   TITLTOD,STCK                                    15OCT84\n         TPUT  CLEAR,L'CLEAR,FULLSCR   CLEAR SCREEN\n         TPUT  TITLE,TITLEL            ADR PRINT TITLE AND TIME\n         TPUT  BLANKS,L'BLANKS         PRINT BLANK\n*                                                              15OCT84\n*------- ----- DO  G Q S C A N                                 15OCT84\n*                                                              15OCT84\nRESCAN   DS    0H                      LOOP THRU SELECTED QNMS 15OCT84\n         LA    R7,REQDSN               ADR OF DSN MINOR NAME\n         LA    R8,SCANAREA             ADR OF RETURNED DATA\n         L     R10,=A(SCANLEN)         L'  OF RETURNED DATA\n         LA    R9,REQQNM               ADR OF QNAME MAJOR NAME\nSCAN     GQSCAN AREA=((R8),(R10)),     ADR AND LENGTH OF INFO  RETURNEDX\n               REQLIM=MAX,             MAX NUM OF OWNERS TO BE RETURNEDX\n               SCOPE=ALL,              ALL SYSTEMS IN GRS RING         X\n               RESNAME=((R9)),                                 15OCT84 X\n               MF=(E,SCAND)                                    15OCT84\n*------- ----- ----------------------- SYSDSN/DSN/L'DSN        15OCT84\n*------- ----- IF YOU ARE AT THE NEW GRS (VSAM SUPPORT)        15OCT84\n*------- ----- TRY THE FOLLOWING:                              15OCT84\n*?$?           RESNAME=((R9),(R7),(R4),GENERIC)                15OCT84\n*------- ----- -----------------------                         15OCT84\n         B     BRTABLE(R15)            BRANCH TO APPROPRIATE ROUTINE\nBRTABLE  B     CODE00                  ALLS OK\n         B     CODE04                  NO RESOURCES MATCHED REQUEST\n         B     CODE08                  GQSCAN AREA TOO SMALL\n         B     CODE0C                  ENCOUNTERED ERROR DATA AREA NG\n         B     CODE10                  INVALID SYSNAME\n***\nCODE04   DS    0H                      DSNAME NOT FOUND\n         CLI   DSAENQWT,C'Y'           EXCEPTIONS ONLY         15OCT84\n         BE    CKRESCAN                YES-TRY MORE QNAMES     15OCT84\n         CLI   DSARESSW,C'Y'           RESERVES ONLY           15OCT84\n         BE    CKRESCAN                YES-TRY MORE QNAMES     15OCT84\n         CLC   =C'$ ',REQDSN           SPECIAL DEBUG DSN       15OCT84\n         BE    CKRESCAN                YES-TRY MORE QNAMES     15OCT84\n         TPUT  CODE04M,L'CODE04M\n         B     RETURN\nCODE08   TPUT  CODE08M,L'CODE08M       GQSCAN AREA TOO SMALL\n         B     RETURN\nCODE0C   TPUT  CODE0CM,L'CODE0CM       ERROR IN GQSCAN\n         B     RETURN\nCODE10   TPUT  CODE10M,L'CODE10M       INVALID SYSNAME\n         B     RETURN\nINVPARM  TPUT  PMSG,L'PMSG             INVALID DSN SPECIFIED\n         B     RETURN\n*                                                              15OCT84\n*------- GQSCAN ANSWER: R0=AL2(RIBLNGTH,RIBELENG)              15OCT84\n*                       R1=AL4(#RIBS RETURNED)                 15OCT84\n*                                                              15OCT84\nCODE00   DS    0H                                              15OCT84\n         LA    R10,SCANAREA            ADR OF GQSCAN AREA\n         ST    R0,RIBLNGTH             STORE RIB AND RIBE LENGTH\n         ST    R1,RIBNUMB              NUMBER OF RIBS RETURNED 15OCT84\nRIBLOOP  DS    0H                      LOOP POINT FOR GENERIC  15OCT84\n         USING RIB,R10                 RESOURCE INFORMATION BLOCK\n         LR    R11,R10                 SAVE RIB POINTER\n         AH    R11,RIBLNGTH            POINT TO RIB VARIABLE SECTION\n         AH    R11,RIBVLEN             POINT TO FIRST RIBE\n         USING RIBE,R11                RESOURCE INFORMATION BLOCK EXT\n         L     R9,RIBNRIBE             LOAD THE # OF RIBE'S\n         CLI   DSAENQWT,C'Y'           ONLY ENQ LOCKOUTS?      15OCT84\n         BNE   ENQEND                  NO-NORMAL PATH          15OCT84\n         L     R0,RIBNTWE              GET # WAITING EXC       15OCT84\n         A     R0,RIBNTWS              ADD # WAITING SHR       15OCT84\n         BZ    BUMPRIB                 ZERO-NO WAITS-SKIP      15OCT84\nENQEND   DS    0H                                              15OCT84\n*                                                              15OCT84\n*------- SEE IF DSNAME MATCH                                   15OCT84\n*                                                              15OCT84\n         CLI   REQDSN,C'*'             ANY?                    15OCT84\n         BE    MOVEDSN                                         15OCT84\n         CLC   =C'$ ',REQDSN           SPECIAL DEBUG -ALLDSNS  15OCT84\n         BE    MOVEDSN                                         15OCT84\n         LA    R0,REQDSN               GET DSN (OR PARTIAL)    15OCT84\n         LH    R1,REQDSNL                                      15OCT84\n         LR    R14,R10                 CALC ADR OF RIBRNAME    15OCT84\n         AH    R14,RIBLNGTH            GET TO VARIABLE SECT.   15OCT84\n         LA    R14,RIBRNAME-RIBVAR(R14) SENDING AREA           15OCT84\n         LR    R15,R1                  USE CALLER L'           15OCT84\n         CLCL  R0,R14                  SEE IF HIT              15OCT84\n         BNE   BUMPRIB                 NO-TRY NEXT SYSDSN      15OCT84\n*                                                              15OCT84\n*------- MOVE RNAME (DSNAME)                                   15OCT84\n*                                                              15OCT84\nMOVEDSN  DS    0H                                              15OCT84\n         LA    R0,DSN                  MOVE DSNAME             15OCT84\n         LA    R1,L'DSN                                        15OCT84\n         LR    R14,R10                 CALC ADR OF RIBRNAME    15OCT84\n         AH    R14,RIBLNGTH            GET TO VARIABLE SECT.   15OCT84\n         LA    R14,RIBRNAME-RIBVAR(R14) SENDING AREA           15OCT84\n         XR    R15,R15                                         15OCT84\n         IC    R15,RIBRNMLN                                    15OCT84\n         ICM   R15,8,=C' '             FILL CHAR               15OCT84\n         MVCL  R0,R14                  SHOW DSNAME FOUND       15OCT84\n         OC    DSN,BLANKS              MAKE SURE PRINTABLE     15OCT84\n*                                                              15OCT84\n*------- SHOW USERS OF THIS RNAME (SYSDSN)                     15OCT84\n*                                                              15OCT84\nSEARCH   DS    0H                                              15OCT84\n         CLI   REQJOB,C'*'             ONLY SOME JOBS          15OCT84\n         BE    SHOWDSN                 NO-FORMAT LINE&DISPLAY  15OCT84\n         LA    R0,REQJOB               GET DSN (OR PARTIAL)    15OCT84\n         LH    R1,REQJOBL                                      15OCT84\n         LA    R14,RIBEJBNM            JOBNAME                 15OCT84\n         LR    R15,R1                  USE CALLER L'           15OCT84\n         CLCL  R0,R14                  SEE IF HIT              15OCT84\n         BNE   BUMPRIBE                  N0-SKIP EM            15OCT84\nSHOWDSN  DS    0H                      FORMAT LINE DISPLAY     15OCT84\n         MVC   JOBNAME(8),RIBEJBNM     JOBNAME OF REQUESTOR\n         MVC   SYSTEM,RIBESYSN         SYSTEM NAME OF REQUESTOR\n         CLC   =C'NONAME',SYSTEM       DEFAULT                 15OCT84\n         BNE   SKIPSYSN                NO-USE SPECIFIED DATA   15OCT84\n         MVC   SYSTEM,REQQNM           DEFAULT-SHOW QNAME      15OCT84\nSKIPSYSN DS    0H                                              15OCT84\n*\n         MVC   EXCLFLAG,=C'SHR'\n         TM    RIBERFLG,RIBETYPE       IS THIS EXCL OR SHARED?\n         BO    SHARED\n         MVC   EXCLFLAG,=C'EXC'\nSHARED   DS    0H\n*\n         MVC   MCFLAG,=C'VIP!'\n         TM    RIBERFLG,RIBEMC         IS MUST COMPLETE?\n         BO    MUSTC\n         MVC   MCFLAG,=C'    '\nMUSTC    DS    0H\n*\n         MVC   RESVFLAG,=C'RESV'\n         TM    RIBERFLG,RIBERESV       IS THIS RESERVE REQUEST?\n         BO    RESERVE                 Y\n         MVC   RESVFLAG,=C'NRES'\n         CLI   DSARESSW,C'Y'           ONLY SELECT RESERVES?   15OCT84\n         BE    BUMPRIBE                YES-SKIP THIS NRES ITEM 15OCT84\nRESERVE  DS    0H\n*\n         MVC   GLOBFLAG,=C'GLB'\n         TM    RIBERFLG,RIBERESC       IS THIS RESERVE REQUEST GLOBAL?\n         BO    GLOBAL\n         MVC   GLOBFLAG,=C'LCL'\nGLOBAL   DS    0H\n*\n         MVC   OWNFLAG,=C'OWN'\n         TM    RIBESFLG,RIBESTAT       IS THIS GUY THE OWNER?\n         BO    OWNER\n         MVC   OWNFLAG,=C'WTE'\nOWNER    DS    0H\n*\nTPUTIT   DS    0H                      PRINT IT\n         TPUT  JOBLINE,JOBLINEL                                15OCT84\n         MVI   DSAHIT,C'Y'             SHOW AT LEAST 1 HIT     15OCT84\n***\nBUMPRIBE AH    R11,RIBELENG            POINT TO NEXT RIBE\n         BCT   R9,SEARCH               AND DO IT FOR NEXT USER\nBUMPRIB  DS    0H                                              15OCT84\n*                                                              15OCT84\n*------- SKIP  TO NEXT RIB SECTION                             15OCT84\n*                                                              15OCT84\n         L     R14,RIBNRIBE            # OF RIBE IN THIS RIB   15OCT84\n         MH    R14,RIBELENG            * L' = L'ALL RIBES      15OCT84\n         AH    R14,RIBLNGTH            + L'RIB                 15OCT84\n         AH    R14,RIBVLEN             + L'RIB VAR.            15OCT84\n         AR    R10,R14                 NEXT RIB+VRIB+RIBE(S)   15OCT84\n         L     R14,RIBNUMB             DECREMENT TOTALS        15OCT84\n         SH    R14,=H'1'                                       15OCT84\n         ST    R14,RIBNUMB             DECREMENT TOTALS        15OCT84\n         BNZ   RIBLOOP                 NEXT RIB                15OCT84\nRIBFINI  DS    0H                                              15OCT84\n*                                                              15OCT84\n*------- SEE IF ANY HITS                                       15OCT84\n*                                                              15OCT84\nCKRESCAN DS    0H                                              15OCT84\n         CLC   =C'$ ',REQDSN           SPECIAL DEBUG DSNAME    15OCT84\n         BE    FORCSCAN                                        15OCT84\n         CLI   DSAENQWT,C'Y'           LOOKING FOR ENQS?       15OCT84\n         BE    FORCSCAN                YES-RESCAN              15OCT84\n         CLI   DSARESSW,C'Y'           LOOKING FOR RESERVES    15OCT84\n         BE    FORCSCAN                YES-RESCAN              15OCT84\n         B     NORESCAN                NO                      15OCT84\n*                                                              15OCT84\n*------- SCAN  NEXT QNAME IN MY TABLE                          15OCT84\n*                                                              15OCT84\nFORCSCAN DS    0H                                              15OCT84\n         L     R1,REQQNMC              GET CURRENT             15OCT84\n         LA    R1,8(R1)                NEXT QNAME              15OCT84\n         CLI   0(R1),C'9'              9+=END                  15OCT84\n         BE    NORESCAN                YES-END                 15OCT84\n         ST    R1,REQQNMC              SAVE NEW CURRENT        15OCT84\n         MVC   REQQNM,0(R1)            COPY \"                  15OCT84\n         B     RESCAN                                          15OCT84\nNORESCAN DS    0H                                              15OCT84\n         CLI   DSAHIT,C'Y'             FILLED IN?              15OCT84\n         BE    RETURN                  OK                      15OCT84\n         TPUT  NFOUND,L'NFOUND         NEXT RIB                15OCT84\nRETURN   @RET  EQ,RC=0\n*                                                              15OCT84\n******** ***** S T A T I C  S T O R A G E (READ-ONLY)          15OCT84\n*                                                              15OCT84\nMVPARM   MVC   REQDSN(*-*),0(R5)\n*\nCODE04M  DC    CL50'NOT IN USE OR NOT A FULLY QUALIFIED DATA SET NAME'\nCODE08M  DC    CL50'GQSCAN AREA TOO SMALL - RETRY COMMAND'\nCODE0CM  DC    CL50'ERROR ENCOUNTERED - RETRY COMMAND'\nCODE10M  DC    CL50'INVALID SYSNAME - RETRY COMMAND'\nPMSG     DC    CL50'INVALID PARAMETER SPECIFIED'\nNFOUND   DC    CL50'NO MATCHES FOR REQUEST FOUND'\n*\nCLEAR    DC    X'C1115D7E1140403C4040001DC813'  CLEAR SCREEN\nBLANKS   DC    CL72' '\nQNAMES   DC    CL8'SYSDSN'                                     15OCT84\n         DC    CL8'SPFEDIT '                                   10JAN85\n         DC    CL8'SPFDSN  '                                   10JAN85\n         DC    CL8'SYSIEA01'                                   15OCT84\n         DC    CL8'SYSIEFSD'                                   15OCT84\n         DC    CL8'SYSIEWLP'                                   15OCT84\n         DC    CL8'SYSIGGV1'                                   15OCT84\n         DC    CL8'SYSIGGV2'                                   15OCT84\n         DC    CL8'SYSIKJBC'                                   15OCT84\n         DC    CL8'SYSIKJUA'                                   15OCT84\n         DC    CL8'SYSSMF01'                                   15OCT84\n         DC    CL8'SYSVSAM'                                    15OCT84\n         DC    CL8'SYSVTOC'                                    15OCT84\n         DC    CL8'SYSZCAXW'                                   15OCT84\n         DC    CL8'SYSZCOMM'                                   15OCT84\n         DC    CL8'SYSZJES2'                                   15OCT84\n         DC    CL8'SYSZJWTP'                                   15OCT84\n         DC    CL8'SYSZOPEN'                                   15OCT84\n         DC    CL8'SYSZPCCB'                                   15OCT84\n         DC    CL8'SYSZRPLW'                                   15OCT84\n         DC    CL8'SYSZSIPS'                                   15OCT84\n         DC    CL8'SYSZSMF1'                                   15OCT84\n         DC    CL8'SYSZTIOT'                                   15OCT84\n         DC    CL8'SYSZVARY'                                   15OCT84\n         DC    CL8'SYSZVOLS'                                   15OCT84\n         DC    CL8'SYSZWTOR'                                   15OCT84\n         DC    CL8'99999999'           SPARES                  15OCT84\n         DC    CL8'99999999'                                   15OCT84\n         DC    CL8'99999999'                                   15OCT84\n         DC    CL8'99999999'                                   15OCT84\n         DC    CL8'99999999'                                   15OCT84\n         DC    CL8'99999999'                                   15OCT84\n*------- ----- ----------------------- -----------------------\nSCANC    GQSCAN MF=L                   SKELETON\n*------- ----- ----------------------- -----------------------\n         LTORG ,                                               15OCT84\n         PRINT NOGEN\n*                                                              15OCT84\n******** ***** D Y N A M I C  S T O R A G E (MODIFIABLE)       15OCT84\n*                                                              15OCT84\nDSA      DSECT                         CONTINUE DYNAMIC STOR   15OCT84\n         DS    0F\nRIBLNGTH DC    H'0'                    L' FIXED PORTION OF RIB\nRIBELENG DC    H'0'                    L' RIBE\nRIBNUMB  DC    F'0'                    # RIBS RETURNED\n         DS    0F\nREQDSNL  DC    H'0'\nREQDSN   DS    CL44' '\nREQJOBL  DC    H'0'\nREQJOB   DS    CL8' '\nREQQNML  DC    H'0'\nREQQNM   DS    XL8                     ENQ NAME\nREQQNMC  DS    F                       POINTER TO CURR \"QNAME\"\nSCAND    GQSCAN MF=L                   SKELETON\nSCANDLEN EQU   *-SCAND                                         15OCT84\n*------- ----- ----------------------- -----------------------\nTITLE    DC    CL32'SHARE - DATASET USAGE DISPLAY -'\nTITLSID  DC    CL04'XSID'              SYSTEM ID\nTITLF1   DC    C' - '                  FILLER\nTITLTOD  DC    CL28' '                 TIME OF DAY\nTITLVER  DC    C' - VX.Y'              RELEASE\nTITLEL   EQU   *-TITLE                                         15OCT84\n*------- ----- ----------------------- -----------------------\n         @STCK DATA                    @STCK WORK DATA         15OCT84\n*------- ----- ----------------------- -----------------------\nJOBLINE  DS    0CL72\nMCFLAG   DS    CL4                     SYSTEM MUST COMP = VIPJ\n         DC    C' '\nJOBNAME  DS    CL8                     JOBNAME\n         DC    C' '\nEXCLFLAG DS    CL3                     SHR/EXC\n         DC    C' '\nOWNFLAG  DS    CL3                     OWM/WTE\n         DC    C' '\nRESVFLAG DS    CL4                     RES/BLANKS\n         DC    C' '\nGLOBFLAG DS    CL3                     GBL/LCL\n         DC    C' '\nSYSTEM   DS    CL8                     SYSTEM NAME\n         DC    C' '\nDSN      DS    CL44                    DSNAME\nJOBLINEL EQU   *-JOBLINE                                       -\n*------- ----- ----------------------- -----------------------\nULINE    DS   0CL72\n         DC    72C'-'\nULINEL   EQU   *-ULINE\n*------- ----- ----------------------- -----------------------\nDSAENQWT DS    X'0'                    'Y'=ONLY WTE TASKS\nDSARESSW DS    X'0'                    'Y'=ONLY RESERVES\nDSAHIT   DS    X'0'                    'Y'=AT LEAST 1 ANSWER\n         DS    0F\nSCANSAVE DS    18F                     18 WORD SAVEAREA REQ FOR GQSCAN\n         DS    0F\nSCANAREA DS    400000XL1               SCAN INFO AREA\nSCANLEN  EQU   *-SCANAREA              SCAN INFO AREA\nDSALEN   EQU   *-DSA                                           15OCT84\n         IKJCPPL\n         IKJECT\n         IEESMCA\n         ISGRIB\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSGTFMAP": {"ttr": 1540, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TSGTFMAP TITLE 'TSGTFMAP-SHOW DISK USAGE FROM GTF DATA -V2M3- 20SEP84'\n***********************************************************************\n* DESC: READ GTF DATA AND SUMMARIZE DASD SIO/IO RECORDS.\n*        BY DEVICE: CALCULATE NUMBER SIO CC = 0-3,\n*              TOTAL CYLINDERS SEEKED,\n*              AVERAGE CYLINDERS SEEKED,\n*              AVERAGE IO TIME,\n*              MAX. IO TIME OVER RUN,\n*              BUILD TWO ARRAYS FOR DRIVE/JOB STATS.\n*              OPTIONALLY PRODUCE A HISTOGRAM OF SEEKS\n*--------------------------------------------------------------------*\n*        DRIVE ARRAY:\n*        SLOT SIZE(IN CYLINDERS) = ((LINESIZE-OFFSET)/\n*              (#DIGITS DISPLAYED PER SLOT))\n*        EXAMPLE: ((133-11)/3)=40 SETS OF NUMBERS CAN FIT\n*              ON A LINE.\n*        THIS ARRAY IS USED AS FOLLOWS:\n*         DT(N,M)=DT(N,M)+1 WHERE:\n*          N=FROM SLOT #,\n*          M=TO   SLOT #.\n*         IF HISTOGRAM OPTION IS USED, ARRAY IS NOW A VECTOR.\n*          DT(N)=DT(N)+1 WHERE N IS CYL #.\n*--------------------------------------------------------------------*\n*        JOB ARRAY:\n*        JOB TABLE IS AN N BY N MATRIX,\n*           WHERE N IS NUMBER OF JOBS IN INCORE TABLE.\n*        THIS ARRAY IS USED AS FOLLOWS:\n*         JT(N,M)=JT(N,M)+1 WHERE:\n*          N=JOB# THAT WAS HELD UP.\n*          M=JOB# THAT HELD JOB N UP.\n*         HELD UP MEANS JOB N HAD TO SEEK MORE THAN 'SEEKINTF' CYLS.\n*--------------------------------------------------------------------*\n*        JCL:  //MAP EXEC PGM=TSGTFMAP,REGION=(100K+6K*#DASD),\n*              // PARM='XXXX,Y...Y'\n*              //*      XXXX=HIST OR MATR, DEFAULT=HIST\n*              //*      (MATR=MATRIX OPTION, HIST=HISTOGRAM OPTION.)\n*              //* Y...Y=JOBNAME PREFIXES FOR CONTENTION MATRIX20SEP84\n*              //*       WITH A SLASH BETWEEN THEM             20SEP84\n*              //*EG PARM='HIST,PDB/P/TSO /IMS/JES2'           20SEP84\n*              //*       NOTE: TABLE IS SCANNED LEFT TO RIGHT  20SEP84\n*              //*              ... SO WATCH COMMON PREFIXES   20SEP84\n*              //*             BLANKS ARE ALLOWED FOR EXACT HIT20SEP84\n*              //SYSPRINT DD SYSOUT=C\n*              //SYSUT1   DD DSN=GTFDATA,DISP=SHR\n*--------------------------------------------------------------------*\n*        ABEND SUMMARY\n*             ABEND 1 - PROGRAM BUG - NO ROOM FOR A DASD IN TABLE\n*                       TABLE SIZE CALCULATED FROM SYSTEM, MUST FIT.\n*             ABEND 2 - GTF CONTROL RECORD DOESNT SPECIFY TIME=YES\n*             ABEND 4 - PROGRAM BUG - CANT FIND STRING ENTRY FOR A\n*                       DASD DEV. EVERY DASD BELONGS TO A STRING.\n*             ABEND 5 - GTF RECORD FOR A DASD THAT IS NOT ONLINE.\n*                       RUN JOB SOON AFTER GTF TRACE RUN.\n*             ABEND 6 - BAD F3 DSCB READ\n*             ABEND 7 - PROGRAM BUG - UNEXPECTED BLANK DSNAME\n*             ABEND 8 - TOO MANY DATASETS ON VOLUME\n*                       DSN TABLE OFFSET GREATER THAN 65K\n*             ABEND 123-COULDNT LOCATE IOS SCAN ROUTINE        20SEP84\n*--------------------------------------------------------------------*\n****     SUMMARY OF CHANGES FOR  02MAR94 V2.2\n*              FIX LOOP FOR NON DUAL DENSITY DRIVES\n*              FIX BUG IN MATRIX OPTION\n*              ALLOC CPUID=2 (3083)\n*              ADD 3375, 3380 DISK ATTRIBUTES\n*              DONT DISPLAY VOLUME IF I/O COUNT < TOTAL IO/256\n*              UPDATE MY ADDRESS INFO\n****     SUMMARY OF CHANGES FOR  06NOV84\n*              CALCULATE IO RATES\n*              ALLOW FOR CONCATENATED GTF IN PUTS FROM ANOTHER CPU\n*               (NOTE I AM NOT TRYING TO SYNC TWO GTF INPUTS)\n*              SUPPORT FOR CDC 33502 DOUBLE DENSITY DISK\n****     SUMMARY OF CHANGES FOR  28OCT79\n*              WORK WITH MOD TO CCWTRACE TO GET RESERVE/RELEASE TIMES\n*              ADD DATA ON RESERVE TIMES ETC.\n*              GIVE DEVICE STATUS ON REPORTS (PRIV,PUB,STORAGE)\n*              SUPPORT DEFERED CONDITION CODES\n****     SUMMARY OF CHANGES FOR  15OCT79\n*              ADD EXTRA CHECKING FOR BAD SIO/IO RECORDS\n*               CHECK FOR VALID JOBNAME IN RECORDS W/ BAD CTR\n*               CHECK FOR SEEK WITHIN PHYSICAL LIMITS OF DEV TYPE\n*                                              W/ BAD CTR\n*              BYPASS CCWTRACE RECORDS\n*               MAX CPUID IS 2\n*              ADD DSN TO HISTOGRAM OPTION                     15OCT79\n*              RE-ORG BASE REGS FOR EASY EXPANSION             15OCT79\n*              ADD NUMBER OF RESERVES                          15OCT79\n****     SUMMARY OF CHANGES FOR  20MAY84:\n*              CYLINDER SEEK HISTOGRAM\n*              CSW BREAKDOWN FOR SIO CC=1\n*              DYNAMIC INITIALIZATION OF MAXIMUM # DASD SUPPORTED\n*              SOME INITIAL CODE FOR AN I/O CONCURRENCE (NOT WORKING)\n*--------------------------------------------------------------------*\n****     SUMMARY OF CHANGES FOR 20SEP84 (V2.3)                 20SEP84\n*              ADD XA SUPPORT TO UCB LOOKUP ROUTINES           20SEP84\n*              ADD SSCH/RSCH RECORD SUPPORT(XA)                20SEP84\n*              CHECK THAT TIME=YES SPECIFIED IN CTRL REC       20SEP84\n*--------------------------------------------------------------------*\n****           CUSTOMIZATION NOTES                             06NOV84\n*              CHANGE \"DDADRS\" FOR LIST OF DUAL DENSITY DISKS  06NOV84\n*              CHANGE \"STCYLS\" FOR MAX CYLS OF DUAL DENSITY    06NOV84\n*              SPF/EDIT LOOK FOR ? FOR SPECIAL CODE            06NOV84\n*              SET \"SEEKINTF\"-JOB INTERFERENCE SEEK THRESHOLD  20SEP84\n*              COMMENT AREA \"NONSEQ\"-UNUSUAL CONTITIONS        20SEP84\n*--------------------------------------------------------------------*\n****           FUTURES                                         15OCT79\n*              ADD IO CONCURRENCE TABLE                        15OCT79\n*              COMPENSATE FOR FIXED HEAD                       15OCT79\n*              SAVE TABLES FOR FUTURE RE-RUNS                  15OCT79\n*--------------------------------------------------------------------*\n*        QUESTIONS:\n*              CLARK HUNTER  PHONE: 313-540-0900\n*              COMPUWARE CORPORATION\n*              32100 TELEGRAPH ROAD\n*              BIRMINGHAM, MICHIGAN  48010\n***********************************************************************\n         TITLE 'DO SETUP, READ GTF RECORDS, GOTO DEPENDANT ROUTINE   '\nTSGTFMAP @ENT  R12,(0,DSASIZE),DSA=YES    SAVE AREAS/CHAIN/BASING\n         PRINT NOGEN                SAVE PAPER/TREES\n         USING DSA,R13              SAVE AREA / WORKING STORE\n         USING DVTAB,R11            DEVICE TABLE POINTER\n         USING GTFREC,R10           GTF RECORD POINTER\n         ST    R1,PARMSAVE         SAVE PARM LIST PTR\n         L     R9,=A(UTSUBS)       SET STATIC AREA/UTILITY SUBS15OCT79\n         USING UTSUBS,R9           TELL ASM                    15OCT79\n         L     R12,@SETUP          GET SETUP RTN               15OCT79\n         BR    R12                 DO SETUP                    15OCT79\n         LTORG ,                   LITERAL NEEDED TO SET UP    15OCT79\nGETREC   DS    0H                   GET NEXT GTF RECORD\n         BAL   R14,GET             GET GTF RECORD\n         LR    R10,R1              COPY ADDR PTR\n*                                                              20SEP84\n         CLI   GTID,0              CONTROL RECORD ID\n         BE    CTLREC                  YES\n*                                                              20SEP84\n         CLC   GTLEN,=H'55'        MIN LENGTH HANDLED\n         BL    BYPASS              TOO SHORT\n*                                                              20SEP84\n**       VALIDATE GTF RECORD ID                                20SEP84\n*                                                              20SEP84\n         CLI   GTID,X'FF'          TRACE RECORD ID\n         BE    GETTRACE            NO-SKIP\n         B     BYPASS                  NO-INVALID\nGETTRACE DS    0H                      TRACE RECORD            20SEP84\n*                                                              15OCT79\n**       CHECK  FOR INVALID RECS                               15OCT79\n*                                                              15OCT79\n         CLI   GTFMT,0             FORMAT IDENTIFIER\n         BNE   BYPASS              NO-BYPASS\n         CLC   =AL2(2),GTCPUID     MAX CPUID                   15OCT79\n         BL    BYPASS                                          15OCT79\n         MVC   WD,GTJOB            COPY JOBNAME                15OCT79\n         OC    WD,=CL8' '          UPPER CASE IT               15OCT79\n         CLC   WD,GTJOB            SAME                        15OCT79\n         BNE   BYPASS2             JOBNAME INVALID             15OCT79\n         CLC   GTEVNT,=X'5100'     SIO REC\n         BE    SIOREC              YES\n         CLC   GTEVNT,=X'5105'     SSCH REC                    20SEP84\n         BE    SSCHREC             YES                         20SEP84\n         CLC   GTEVNT,=X'5106'     RSCH REC                    20SEP84\n         BE    RSCHREC             YES                         20SEP84\n         CLC   GTEVNT,=X'5200'     I/O W/ VALID UCB\n         BE    IOREC               YES\n         CLC   GTEVNT,=X'5101'     I/O W/EOS INTERRUPTION\n         BE    IOREC               YES\n         CLC   GTEVNT,=X'2100'     PCI I/O\n         BE    IORECPCI            YES\n         CLC   GTEVNT,=X'5201'     I/O W/O VALID UCB\n         BE    IORECBAD            YES-BAD\n         B     BYPASS              ALL ELSE FAILS TOO\nIORECPCI DS    0H                  PCI\n         AP    TOTPCI,=P'1'        BUMP\n         B     GETREC              LOOP\nIORECBAD DS    0H                  I/O W/O VALID UCB\n         AP    TOTBAD,=P'1'        BUMP\n         B     GETREC              LOOP\nSIORECBD DS    0H                  SIO SEEK ADDR BAD           15OCT79\n         AP    TOTSIOBD,=P'1'      BUMP                        15OCT79\n         B     GETREC              LOOP                        15OCT79\nBYPASS   DS    0H                  BYPASSED RECORD(MANY REASONS)\n         AP    TOTBYPAS,=P'1'      BUMP CTR\n         B     GETREC              LOOP\nBYPASS2  DS    0H                  BYPASSED JOBNAME INVALID    15OCT79\n         AP    TOTBYP2,=P'1'       BUMP CTR                    15OCT79\n         B     GETREC              LOOP                        15OCT79\nGETEOD2  DS    0H                  END-OF-FILE                 15OCT79\n*                                                              28OCT79\n**             SEE IF ANY UNPROCESSED SIO RECORDS              28OCT79\n*                                                              28OCT79\n         L     R1,DVVROOT          GET DEVICE VECTOR TABLE     28OCT79\n         ST    R1,EODCURDV         SET 1ST DEVICE              28OCT79\n         LA    R0,GETHSIO1         SET SIO RTN RETURN          28OCT79\n         ST    R0,DSSIORET         SET RETURN                  28OCT79\nGETHSIO1 DS    0H                  NEXT DEVICE                 28OCT79\n         L     R1,EODCURDV         GET DEVICE VECT ENTRY       28OCT79\n         L     R11,DVVPTR-DVVTAB(R1) GET DEVICE TABLE ENTRY    28OCT79\n         OC    DVVPTR-DVVTAB+1(3,R1),DVVPTR-DVVTAB+1(R1) END   28OCT79\n         BZ    GETHSIO2            GO TO END OF DATA RTNS      28OCT79\n         LA    R1,DVVSIZ(R1)       BUMP TO NEXT VECTOR         28OCT79\n         ST    R1,EODCURDV         SAVE FOR NEXT TIME          28OCT79\n         OC    DVLSIO0(2),DVLSIO0  \"GTLEN\" \u00ac=0 IF REC HELD     28OCT79\n         BZ    GETHSIO1            NO-NEXT DEVICE ENTRY        28OCT79\n         LA    R10,DVLSIO0         YES-GET HELD RECORD         28OCT79\n         B     SIOENT3             PROCESS RECORD              28OCT79\nGETHSIO2 DS    0H                  RESET BASE REG, GO TO TOTS  28OCT79\n         L     R12,@EODRTN         GET END OF DATA RTN         15OCT79\n         BR    R12                 GO TO IT                    15OCT79\n         TITLE 'GTF CONTROL RECORD - START OF A TRACE                '\n*                                                              20SEP84\n**       SAVE START TIME OF GTF RUN\n*                                                              20SEP84\nCTLREC   DS    0H                  GET ITEM\n         CLI   GTFMT,X'01'         FORMAT ID=CONTROL RECORD\n         BNE   BYPASS              NO-MAYBE LOST EVENTS, ETC\n         TM    GTCROP4,GTC4TIME        IS TIME=YES SPEC'D\n         BO    CTLRECTM                Y/CONTINUE\n         WTO   'TSGTFMAP-TIME=YES NOT SPECIFIED IN TRACE',             X\n               ROUTCDE=(11)\n         ABEND 2,DUMP\nCTLRECTM DS    0H\n         CLI   STRTTM,0                ANY YET                 DDMMM84\n         BE    CTLSETTM                NO-SET IT               DDMMM84\n         CLC   STRTTM,GTCRTOD      SAVE OLDEST TIME            06NOV84\n         BL    CTLSETND                                        06NOV84\nCTLSETTM DS    0H                                              DDMMM84\n         MVC   STRTTM,GTCRTOD      SAVE TIME\nCTLSETND DS    0H                                              DDMMM84\n         B     GETREC              GO TO NEXT PHASE\n         TITLE '              I / O  R E C O R D '\nIOREC    DS    0H\n         CLC   =X'5105',DSASIORC+(GTEVNT-GTFREC) SSCH REC      20SEP84\n         BE    IORECXA                 XA DATA                 20SEP84\n         CLC   =X'5106',DSASIORC+(GTEVNT-GTFREC) RSCH REC      20SEP84\n         BE    IORECXA                 XA DATA                 20SEP84\n         B     IORECCTN                NOT XA DATA             20SEP84\nIORECXA  DS    0H\n*        XC    DSAIOREC,DSAIOREC       CLEAR FAKE IO REC AREA  20SEP84\n         MVC   DSAIOREC(GTYDEV-GTFREC),GTFREC MOVE COMMON PART 20SEP84\n         MVC   DSAIOREC+(GTIDEV-GTFREC)(L'GTIDEV),GTYDEV DEV # 20SEP84\n         MVC   DSAIOREC+(GTICSW-GTFREC)(L'GTICSW),GTYCSW CSW # 20SEP84\n         MVC   DSAIOREC+(GTISENSE-GTFREC)(L'GTISENSE),GTYSENSE 20SEP84\n         LA    R10,DSAIOREC            POINT TO FAKE SIO REC.  20SEP84\nIORECCTN DS    0H\n         AP    TOTIO,=P'1'          BUMP TOT\n         LH    R11,GTIDEV           GET DEV ADDR\n         BAL   R14,UTDDTST          SEE IF DOUBLE DENSITY      06NOV84\n         B     *+8                  NO                         06NOV84\n         N     R11,=X'FFFFFFDF'     TURN OFF X'20' BIT         06NOV84\n         BAL   R14,UTGET            LOCATE DEVICE TABLE PTR\n         B     GETREC               +0 RETURN = NOT FOUND\n*                                                              28OCT79\n**       SEE IF UNPROCESSED SIO RECORD PRESENT                 28OCT79\n*                                                              28OCT79\n         OC    DVLSIO0(2),DVLSIO0   IS GTLEN NOT ZERO IN SAVE  28OCT79\n         BZ    IORECE3              YES-NO PENDING SIO REC     28OCT79\n         ST    R10,DSSAVR10        SAVE CURR. GTF REC PTR      28OCT79\n         LA    R0,IORECE2          SET SIO RTN RETURN POINT    28OCT79\n         ST    R0,DSSIORET                                     28OCT79\n*                                                              28OCT79\n**             COPY SIOCC, STAT    FROM IO REC TO SAVED SIO    28OCT79\n*                                                              28OCT79\n         IC    R0,GTICSW           GET CC                      28OCT79\n         SLL   R0,4                POSITION LIKE SIO CC        28OCT79\n         STC   R0,DVLSIO0+GTSIOCC-GTFREC SET SIOF CC           28OCT79\n         MVC   DVLSIO0+GTSSTAT-GTFREC(2),GTICSW+4 SET STAT     28OCT79\n         LA    R10,DVLSIO0         POINT TO UNPROCESSED REC    28OCT79\n         B     SIOENT3             PROCESS SIO REC             28OCT79\nIORECE2  DS    0H                  RETURN FROM SIO RTN         28OCT79\n         XC    DVLSIO0(2),DVLSIO0  SHOW NO REC THERE           28OCT79\n         L     R10,DSSAVR10        RESTORE IO REC PTR          28OCT79\n         TM    GTICSW,X'03'        ANY CSW CC                  28OCT79\n         BZ    IORECE3             NO-PROCESS AS IO REC        28OCT79\n         LH    R15,DVSIOFCC        YES-BUMP SIOF CC NOT ZERO   28OCT79\n         AH    R15,=H'1'                                       28OCT79\n         ST    R15,DVSIOFCC                                    28OCT79\n         B     GETREC              DONT PROCESS IO REC FURTHR  28OCT79\nIORECE3  DS    0H                  CONTINUE                    28OCT79\n         OC    DVLTIME,DVLTIME      IS THERE A PREV SIO REC.\n         BZ    IODEFR               NO - SEE IF ANY IO WAS DEFERED\n         ICM   R0,15,GTTIME         GET IO TIME\n         ICM   R1,15,GTTIME+4       GET IO TIME\n         LM    R2,R3,DVLTIME       GET SIO TIME\n         XC    DVLTIME,DVLTIME      SHOW NO SIO TIME\n         XC    DVL0TIME,DVL0TIME    SHOW NO SIO TIME\n         BAL   R14,UTTIMDIF        CALC TIME DIF IN MILLISEC*10\n         C     R1,DVMAXIO           CHECK AGAINST MAX SO FAR\n         BL    *+8                  NO - SKIP\n         ST    R1,DVMAXIO           YES-SAVE NEW MAX\n         LR    R0,R1               SAVE VALUE\n         AL    R1,DVAVGIO           ADD IO TIME TO TOTAL\n         ST    R1,DVAVGIO           STORE\n         LH    R15,DVLJOBI         GET LAST JOB INDEX\n         AL    R0,DVJTIOTM(R15)    ADD TO LAST JOBS TIME\n         ST    R0,DVJTIOTM(R15)    UPDATE\n*        CALC DEFERED I/O TIMES\nIODEFR   DS    0H                  CALC HOW LONG LAST SIO.NE.ZERO\n         BAL   R14,UTDEFR          CALC DEFER TIME\n         B     GETREC              NEXT RECORD\n         TITLE '               S I O  R E C O R D'\nSSCHREC  DS    0H                  PROCESS SSCH RECORD\n         XC    DSASIORC,DSASIORC       CLEAR FAKE SIO REC AREA 20SEP84\n         MVC   DSASIORC(GTXDEV-GTFREC),GTFREC MOVE COMMON PART 20SEP84\n         MVC   DSASIORC+(GTSDEV-GTFREC)(L'GTSDEV),GTXDEV DEV # 20SEP84\n         MVC   DSASIORC+(GTSIOCC-GTFREC)(L'GTSIOCC),GTXIOCC SIO CC\n         MVC   DSASIORC+(GTSSEEK-GTFREC)(L'GTSSEEK),GTXSEEK SEEK ADR\n         LA    R10,DSASIORC            POINT TO FAKE SIO REC.  20SEP84\n         B     SIOREC\nRSCHREC  DS    0H                  PROCESS RSCH RECORD\n         XC    DSASIORC,DSASIORC       CLEAR FAKE SIO REC AREA 20SEP84\n         MVC   DSASIORC(GTRDEV-GTFREC),GTFREC MOVE COMMON PART 20SEP84\n         MVC   DSASIORC+(GTSDEV-GTFREC)(L'GTSDEV),GTRDEV DEV # 20SEP84\n         MVC   DSASIORC+(GTSIOCC-GTFREC)(L'GTSIOCC),GTRIOCC SIO CC\n         MVC   DSASIORC+(GTSSEEK-GTFREC)(L'GTSSEEK),GTRSEEK SEEK ADR\n         LA    R10,DSASIORC            POINT TO FAKE SIO REC.  20SEP84\nSIOREC   DS    0H                  PROCESS SIO RECORD\n         CLC   STOPTM,GTTIME       SAVE OLDEST TIME            06NOV84\n         BH    *+10                                            06NOV84\n         MVC   STOPTM,GTTIME       SAVE TIME(LAST GTF RECORD@EOD)\n         AP    TOTSIO,=P'1'        BUMP TOT\n         XR    R11,R11\n         ICM   R11,3,GTSDEV        GET ADDR\n         BAL   R14,UTDDTST         SEE IF DOUBLE DENSITY       06NOV84\n         B     *+8                 NO                          06NOV84\n         N     R11,=X'FFFFFFDF'    TURN OFF X'20' BIT          06NOV84\n         BAL   R14,UTGET           GET DEVICE TABLE PTR\n         B     GETREC              +0=NOT FOUND\n         TM    DVFLAG1,DVF1DD      SEE IF DOUBLE DENSITY\n         BZ    SIODDEND            NO-NORMAL PROCESS           06NOV84\n         LH    R0,DVCYL            GET MAX CYL (CDC33502=1110  06NOV84\n         SRL   R0,1                1/2 (CDC33502=555CYL)       06NOV84\n         XR    R1,R1               CLEAR                       06NOV84\n         ICM   R1,3,GTSSEEK+3      GET CYL#                    06NOV84\n         TM    GTSDEV+1,X'20'      UPPER HALF                  06NOV84\n         BO    SIODDUP             YES                         06NOV84\n         AR    R1,R0                REMAP SEEK TO MIDDLE OF    06NOV84\n*                                   PACK (E.G.                 06NOV84\n*                                   FOR CDC PACKS:             06NOV84\n*              INSIDE         OUTSIDE                          06NOV84\n*              CYL------> <-------CYL                          06NOV84\n*              554------0 0-------554                          06NOV84\n*               ADR=2B0     ADR=290   (X'020' TELLS WHICH ONE  06NOV84\n*              MY REMAP:                                       06NOV84\n*              0------554 555----1109                          06NOV84\n*                                                              28OCT79\n         STCM  R1,3,GTSSEEK+3       SAVE (3350:555-1109)       06NOV84\n         B     SIODDEND             FINI                       06NOV84\nSIODDUP  DS    0H                                              06NOV84\n         LCR   R1,R1                GET NEG. (-554 /  -0)      06NOV84\n         AR    R1,R0                ADD MAX  (   1 / 555)      06NOV84\n         BCTR  R1,0                 ADJUST FOR ZERO 0-554      06NOV84\n         STCM  R1,3,GTSSEEK+3       ADJUSTED SEEK ADDR         06NOV84\nSIODDEND DS    0H                                              06NOV84\n**             SEE IF UNPROCESSED  SIO RECORD                  28OCT79\n*                                                              28OCT79\n         OC    DVLSIO0(2),DVLSIO0  IF GTLEN NOT = ZERO         28OCT79\n         BZ    SIOENT2             NO-NO RECORD PRESENT        28OCT79\n         ST    R10,DSSAVR10        YES-SAVE CURRENT REC PTR    28OCT79\n         LA    R0,SIOENT1          MAKE SIO RTN RETURN HERE    28OCT79\n         ST    R0,DSSIORET                                     28OCT79\n         LA    R10,DVLSIO0         PROCESS RECORD NOW          28OCT79\n* IDEAL IS TO SAVE SIO CC=0 RECORDS IN HOLD AREA BY DEVICE     28OCT79\n* SO IF A IO RECORD WITH DEFERED STATUS COMES IN, IT CAN BE    28OCT79\n* MOVE INTO THE HELDSIO RECORD AND PROCESSED WITH VALID STATUS 28OCT79\n*IF ANOTHER SIO TO SAVE DEVICE COMES IN, ASSUME SIOF           28OCT79\n* WAS NOT ISSUED, AND PROCESS THE HELD RECORD, THEN PROCESS    28OCT79\n* THE CURRENT SIO RECORD (SAVE IT IF CC=0, PROCESS IF CC\u00ac=0)   28OCT79\n         B     SIOENT3             CONTINUE WITH HELD RECORD   28OCT79\nSIOENT1  DS    0H                  RETURN FROM HELD REC        28OCT79\n         XC    DVLSIO0(2),DVLSIO0  CLEAR \"GTLEN\" TO SHOW AVAL  28OCT79\n         L     R10,DSSAVR10        RESTORE R10 TO CURR REC     28OCT79\n         B     SIOENT2             CONTINUE WITH CURR REC      28OCT79\n*                                                              28OCT79\n**             SAVE RECORD IF CC=0 (MAY GET CC IN IO REC)      28OCT79\n*                                                              28OCT79\nSIOENT2  DS    0H                                              28OCT79\n         LA    R0,GETREC           SET RETURN TO GET NEXT REC  28OCT79\n         ST    R0,DSSIORET                                     28OCT79\n         TM    GTSIOCC,X'30'       IS SIO CC=0                 28OCT79\n         BNZ   SIOENT3             NO-CANT BE SIOF, PROCESS    28OCT79\n         LA    R14,DVLSIO0         MAY BE SIOF, SAVE REC       28OCT79\n         LA    R15,L'DVLSIO0        WAITING FOR IO REC FOR     28OCT79\n         LH    R1,GTLEN              DEVICE                    28OCT79\n         LA    R0,GTFREC            IF IOCC=\u00ac0 MOVE IOREC      28OCT79\n         MVCL  R14,R0                STATUS TO SIO REC         28OCT79\n         B     GETREC              GET NEXT                    28OCT79\nSIOENT3  DS    0H                  PROCESS A RECORD            28OCT79\n         TM    GTSIOCC,X'30'        ANY COND CODES             06NOV84\n         BNZ   SIONDEFR             NO                         06NOV84\n         BAL   R14,UTDEFR          CALC DEFER TIME IF ANY\nSIONDEFR DS    0H                                              06NOV84\n         BAL   R14,UTFNDJOB        LOCATE INDEX IN JOB TABLE\n         IC    R1,GTSIOCC           GET SIO CC\n         N     R1,=X'00000030'      MASK\n         SRL   R1,2                 SHIFT R 2 TO GET SIOCC*4\n         LA    R15,TOTSIO0(R1)     GET PACKED CTR\n         AP    0(L'TOTSIO0,R15),=P'1' BUMP\n         L     R15,DVSIO0(R1)       BUMP SIO CTR\n         AH    R15,=H'1'            \"\n         ST    R15,DVSIO0(R1)       \"\n         CH    R1,=AL2(1*4)        SIO CC=1\n         BNE   SIO1END             NO\n         LA    R0,(DVSIO1XE-DVSIO1XS)/(DVSIO1XL) # ENTRIES\n         LA    R14,DVSIO1XS        START OF STATUS CODES\nSIO1LOC  DS    0H                  FIND MATCH OR ADD NEW CODE\n         CLC   GTSSTAT,DVSIO1XS-DVSIO1XS(R14)\n         BE    SIO1UPD             YES-BUMP COUNTERS\n         CLC   DVSIO1XS-DVSIO1XS(L'DVSIO1XS,R14),=H'0' ZERO\n         BZ    SIO1UPD             END-OF-TABLE - ADD NEW ENTRY\n         LA    R14,DVSIO1XL(R14)   TRY NEXT\n         BCT   R0,SIO1LOC          LOOP\n         B     SIO1END             NOMATCH AND TABLE FULL - * SKIP *\nSIO1UPD  DS    0H                  ADD OR BUMP ENTRY\n         MVC   DVSIO1XS-DVSIO1XS(L'DVSIO1XS,R14),GTSSTAT ADD/OVLY DATA\n         ICM   R15,15,DVSIO1XC-DVSIO1XS(R14) BUMP COUNTER\n         AH    R15,=H'1'\n         STCM  R15,15,DVSIO1XC-DVSIO1XS(R14) BUMP COUNTER\nSIO1END  DS    0H\n         LR    R14,R1              GET SIO CC\n         MH    R14,=AL2(JT#)       * ROW SIZE = SIO ROW XX (INDEX)\n         AH    R14,DVCJOBI         ADD CURRENT JOB INDEX 0,4,8...\n*                                   =SIO(SIOCC,JOB)\n         L     R15,DVJTSIO0(R14)   BUMP SIO CC BY 1\n         AH    R15,=H'1'           \"\n         ST    R15,DVJTSIO0(R14)\n         LTR   R1,R1                SIO CC = 0\n         BNZ   SIO1REC              NO - NEXT PHASE\n         MVC   DVL0TIME,GTTIME     REMEMBER LAST SIO0 FOR CONCURRENCE\n*                                                              15OCT79\n**             PROCESS RESERVE/RLS (REQUIRES CCWTRACE MOD)     15OCT79\n*                                                              15OCT79\n         OC    GTSSEEK,GTSSEEK     NULL SEEK ADDR              15OCT79\n         BNZ   SIONSEK0            NO-REAL SEEK                15OCT79\n         MVC   GTSSEEK,DVLSEEK     MAKE SEEK ADDR = LAST SEEK  15OCT79\nSIONSEK0 DS    0H                                              15OCT79\n         TM    GTSFLB,GTSRESV      CCW MOD COPIES IOQFLB       28OCT79\n         BZ    SIONRESV             TO GTSSEEK+1 (UNUSED       28OCT79\n*                                    NO DATA CELL ANYMORE)     28OCT79\n         L     R15,DVRESV          CURRENT # RESERVES          15OCT79\n         AH    R15,=H'1'           BUMP                        15OCT79\n         ST    R15,DVRESV                                      15OCT79\n         MVC   DVLRESTM,GTTIME     REMEMBER TIME OF RESERVE    28OCT79\nSIONRESV DS    0H                  TRY RELEASE                 28OCT79\n         TM    GTSFLB,GTSRLSE      RELEASE                     28OCT79\n         BZ    SIONRLS             NO                          28OCT79\n         L     R15,DVRLS           CURRENT # RESERVES          15OCT79\n         AH    R15,=H'1'           BUMP                        15OCT79\n         ST    R15,DVRLS                                       15OCT79\n         BAL   R14,UTRESV          UPDATE RESERVE TIME         28OCT79\nSIONRLS  DS    0H                                              28OCT79\n*                                                              28OCT79\n**             PROCESS SEEK INFO                               28OCT79\n*                                                              28OCT79\n         ICM   R1,3,GTSSEEK+3       GET SEEK CYL\n**       VALID SEEK ADDR               NONSEQ.                 15OCT79\n         CH    R1,DVCYL            CHECK AGAINST DEV LIMITS    15OCT79\n         BH    SIORETBD            SKIP RECORD                 02MAR94\n         CLI   PRTOPT,C'H'         HISTOGRAM OPTION\n         BNE   SIOMATRX            NO-CALC ADDR IN SEEK MATRIX\n**       HISTOGRAM - JUST GO DOWN TO CYL ENTRY IN VECTOR\n         SLL   R1,2                CYL# * 4 = OFFSET IN VECTOR\n         L     R0,DVXREF(R1)       GET CURRENT SEEK COUNT\n         AH    R0,=H'1'            BUMP\n         ST    R0,DVXREF(R1)       UPDATE\n         B     SIOSKPX             GO AROUND MATRIX CODE\nSIOMATRX DS    0H\n         LH    R15,DVDELTA          GET SLOT SIZE IN CYL\n         BAL   R14,DIVIDE           CALC SLOT #\n         SLL   R1,2                SLOT# * 4\n         L     R15,DVLROW          LAST ROW ADDR IN SEEK ARRAY\n         AR    R15,R1              + OFFSET = ENTRY\n         L     R0,0(R15)           DT(FROM,TO)=DT(FROM,TO)+1\n         AH    R0,=H'1'            \"\n         ST    R0,0(R15)           \"\n         MH    R1,DVSLOTS          CALC NEW FROM ROW ADDR\n         LA    R1,DVXREF(R1)       \"\n         ST    R1,DVLROW           SAVE FOR NEXT SIO\nSIOSKPX  DS    0H\n         XR    R0,R0\n         ICM   R0,3,DVLSEEK+3      LAST SEEK CYL\n         SH    R0,GTSSEEK+3        CALC DIFFERENCE\n         LPR   R0,R0               POSITIVE\n         LR    R3,R0               SAVE FOR JOB ARRAY\n         A     R0,DVTOTCYL         BUMP TOT CYL SEEKED\n         ST    R0,DVTOTCYL         \"\n         LR    R0,R3               REFRESH\n         LH    R1,DVCJOBI          GET CURR INDEX\n         A     R0,DVJTSEEK(R1)     BUMP JOB'S CYL SEEKED\n         ST    R0,DVJTSEEK(R1)     \"\n*        UPDATE JT TABLE\n         CH    R3,SEEKINTF         CYL SEEKED ENOUGH\n         BL    SIONOINT            NO - JOB NOT HELD UP\n         LH    R1,DVLJOBI          GET LAST JOB #(CAUSED PROB)\n         LH    R14,DVCJOBI         GET CURRENT JOB INDEX\n         MH    R14,=AL2(JT#)       *L'=OFFSET TO ARRAY ROW\n         LA    R14,DVJTXREF(R14)    + BASE ADDR = ROW ADDR\n         L     R2,0(R14,R1)        JT(N,M)=JT(N,M)+1\n         AH    R2,=H'1'            \"\n         ST    R2,0(R14,R1)        \"\nSIONOINT DS    0H                  UPDATE FILEDS\n*        UPDATE HOLD INFO\n         MVC   DVLJOBI,DVCJOBI     LAST JOB INDEX\n         MVC   DVLSEEK,GTSSEEK     LAST SEEK\n         MVC   DVLJOB,GTJOB        LAST JOB\n         MVC   DVLTIME,GTTIME      LAST TIME\n         B     SIORET              LOOP\n*        SIO 1 AND 2 RECORDS\nSIO1REC  DS    0H                  SEE IF IO HAD TO BE DEFERED\n         MVC   DVLJOBI,DVCJOBI     UPDATE LAST JOB INDEX\n         CH    R1,=H'3'            SIO=3 NOT OPERATIONAL\n         BE    SIORET              YES-RETURN\n         OC    DVDEFRTM,DVDEFRTM    UNHANDLED DEFER            06NOV84\n         BNZ   SIORET               YES-USE EARLIEST TIME      06NOV84\n         MVC   DVDEFRTM,GTTIME     SAVE TIME\n*        I/O INTERRUPT WILL BE STOP OF DEFERED TIME\n*        - OR SIO CC=0 WILL BE STOP OF DEFERED TIME\nSIORET   DS    0H                  END OF SIO PROCESSING\n         L     R14,DSSIORET                                    28OCT79\n         BR    R14                                             28OCT79\nSIORETBD DS    0H                  END OF SIO PROCESSING       02MAR94\n         AP    TOTSIOBD,=P'1'                                  02MAR94\n         B     SIORET                                          02MAR94\n         TITLE '             S E T U P'\nSETUP    DS    0H\n         PUSH  USING                                           15OCT79\n         USING SETUP,R12           NEW BASE REG                15OCT79\n*                                                              15OCT79\n**             SEE IF MVS/XA                                   15OCT79\n*                                                              15OCT79\n         L     R1,CVTPTR               CVT                     20SEP84\n         TM    CVTDCB-CVT(R1),CVTMVSE  EXECUTING ON MVS/XA     20SEP84\n         BZ    SETNOTXA                NO-SKIP                 20SEP84\n         MVI   DSAXA,DSAXAYES          YES-SHOW IT             20SEP84\nSETNOTXA DS    0H                                              20SEP84\n*                                                              15OCT79\n**             SETUP TO GET VTOC INFO                          15OCT79\n*                                                              15OCT79\n         LOAD  EP=VTOCEXCP,ERRET=SETNVTOC VTOC READER EP       20SEP84\n         B     SETVTOCE                SET ENTRY               20SEP84\nSETNVTOC DS    0H                      S806                    20SEP84\n         WTO   'TSGTFMAP-DATASET NAMES UNAVAILABLE',ROUTCDE=(11)\n         LA    R0,0                    ZERO=SKIP               20SEP84\nSETVTOCE DS    0H                      S806                    20SEP84\n         ST    R0,VADEXCP          SAVE ENTRY POINT            15OCT79\n         L     R1,=A(WORKEXCP-DSA) GET OFFSET TO EXCP WORK     15OCT79\n         LA    R1,DSA(R1)          GET WORKEXCP ADDR           15OCT79\n         ST    R1,VTCWEXCP         SAVE FOR VTOCEXCP           15OCT79\n*                                                              15OCT79\n**             SCAN DEVICE TABLES LOOKING FOR GREATEST # CYL   15OCT79\n*                                                              15OCT79\n         LA    R14,STCYLS          GET DEVICE TABLE            15OCT79\n         XR    R0,R0               CLEAR                       15OCT79\nSETMAXCY DS    0H                                              15OCT79\n         CLI   0(R14),X'FF'        END OF TABLE                15OCT79\n         BE    SETMAXCX            DONE                        15OCT79\n         CH    R0,(STCYLMAX-STCYLS)(R14)  CHECK AGAINST MAX    15OCT79\n         BH    *+8                 SMALLER THAN CURRENT        15OCT79\n         LH    R0,(STCYLMAX-STCYLS)(R14)  CHECK AGAINST MAX    15OCT79\n         LA    R14,(STCYLS1-STCYLS)(R14) NEXT DEV TYPE         15OCT79\n         B     SETMAXCY            LOOP                        15OCT79\nSETMAXCX DS    0H                  END                         15OCT79\n         STH   R0,MAXCYL           SET HIGHEST # CYLS          15OCT79\n**       CALC NUMB OF ONLINE DASDS IN SYSTEM\n         LA    R4,X'0FF'               START AT CHANNEL 1 (-1) 20SEP84\n         MVC   DSADVMAX,=H'1'      ONE SPOT FOR DUMMY ENTRY\nSETMXDA  DS    0H\n         AH    R4,=H'1'                NET DEVICE ADDR         20SEP84\n         CH    R4,=H'4095'         END OF TABLE-SET MAX DASD   20SEP84\n         BH    SETMXEND\n         LR    R11,R4                  COPY DEV ADR            20SEP84\n         BAL   R14,UTGETUCB            GET UCB ADDR            20SEP84\n         B     SETMXDA                 +0=NOT FOUND            20SEP84\n         LR    R6,R11                  COPY ANSWER             20SEP84\n         CLI   UCBDVCLS(R6),X'20'  DASD\n         BNE   SETMXDA             NO-SKIP\n         TM    UCBSTAT(R6),X'80'   ONLINE\n         BNO   SETMXDA             NO-SKIP\n         CLI   UCBVOLI(R6),0       VALID VOLSER                06NOV84\n         BE    SETMXDA             NO-SKIP                     06NOV84\n*              SEE IF DOUBLE DENS                              06NOV84\n         ICM   R11,3,UCBCHAN(R6)   PICK UP CUA                 06NOV84\n         BAL   R14,UTDDTST         DUAL DENSITY TEST           06NOV84\n         B     SETMXDDN            NO-CONTINUE                 06NOV84\n         TM    UCBCHAN+1(R6),X'20' PRIMARY VOLUME              06NOV84\n         BO    SETMXDA             NO-SKIP IT                  06NOV84\nSETMXDDN DS    0H                                              06NOV84\n*        NOW SEE IF THIS IS PRIMARY PATH\n*        RE-SCAN UCBS, SEE IF UCB FOUND VIA A LOWER ADDR\n         CLI   DSAXA,DSAXAYES          EXECUTING ON MVS/XA     20SEP84\n         BE    SETMXINC                YES-NO LOOKUP TABLE     20SEP84\n*                                      SO NO NEED TO SCAN      20SEP84\n         MVC   DSADAADR,=F'255'        START AT CHANNEL 1 (-1) 20SEP84\nSETMXDUP DS    0H\n         L     R11,DSADAADR            BUMP DEV ADR            20SEP84\n         AH    R11,=H'1'                                       20SEP84\n         ST    R11,DSADAADR            SAVE IT                 20SEP84\n         CH    R11,=H'4095'                                    20SEP84\n         BH    SETMXINC                SHOULD FIND DEVICE AGAI\n         BAL   R14,UTGETUCB            TRY TO FIND UCB         20SEP84\n         B     SETMXDUP                NF - TRY AGAIN          20SEP84\n         CR    R11,R6                  SAME UCB\n         BNE   SETMXDUP                NO-TRY AGAIN\n         C     R4,DSADAADR             SAME DEV ADDR\n         BNE   SETMXDA             NO-MUST HAVE HIT 1ST PATH ALREADY\nSETMXINC DS    0H\n         LH    R0,DSADVMAX                                     20SEP84\n         AH    R0,=H'1'            BUMP NUMB OF ONLINE DASDS\n         STH   R0,DSADVMAX         SET SYSTEM MAX DASD\n         B     SETMXDA             NEXT\nSETMXEND DS    0H\n         ZAP   PACKS(4),=P'0'      ZERO FIRST PACKED COUNTER\n         MVC   PACKS+4(PACKE-PACKS-4),PACKS  ZERO REST (64 MAX)\n         MVI   HDR1,C' '           BLANK HDR\n         MVC   HDR1+1(L'HDR1-1),HDR1  \"\n         MVI   HDR1,C'1'           SKIP CHAN 1 ASA\n         LA    R1,HDRDATE          GET ANSWER AREA             28OCT79\n         ST    R1,WD               MAKE PARM                   28OCT79\n         MVI   WD,X'80'                                        28OCT79\n         LA    R1,WD               CALL PARM                   28OCT79\n         LINK  EP=TSCVDATE,ERRET=SETNDATE\nSETNDATE DS    0H                                              28OCT79\n         MVC   HDRTITLE,LOGO       MOVE HEADER\n         LA    R1,HDR1             GET HDR\n         BAL   R14,PUT             1ST WRITE CAUSES OPEN\n         MVC   LINESIZE,PUTDCB+X'52' COPY LRECL\n*        SET REPORT FORMAT\n         MVI   PRTOPT,C'H'         DEFAULT (H=HISTOGRAM,M=MATRIX)\n         L     R1,PARMSAVE         GET O/S PARM\n         L     R14,0(R1)               GET JCL PARM\n         LH    R15,0(R14)              GET L' PARM             20SEP84\n         ICM   R15,8,=C'/'             SLASH FILL              20SEP84\n         LA    R14,2(R14)              START OF PARM           20SEP84\n         LA    R0,DSAPARM              PARM SAVE AREA          20SEP84\n         LA    R1,L'DSAPARM            L' \"                    20SEP84\n         MVCL  R0,R14                  COPY PARM               20SEP84\n         MVI   DSAPARM+L'DSAPARM-1,C'/' ENSURE 1\"/\"            20SEP84\n         MVI   PRTOPT,C'M'         SET MATRIX OPTION\n         CLC   =C'MATR',DSAPARM    MATRIX\n         BE    SETPREND            YES-LEAVE 'M' IN\n         MVI   PRTOPT,C'H'         HISTOGRAM\n         CLC   =C'HIST',DSAPARM\nSETPREND DS    0H\n*                                                              20SEP84\n**             OVERLAY MY DEFAULT TABLE WITH PARM INFO         20SEP84\n*                                                              20SEP84\n         LA    R1,DSAPARM+5            OVERRIDE STRING         20SEP84\n         LA    R0,JT#                                          20SEP84\n         LA    R14,JOBS                MY JOBNAME TABLE        20SEP84\nSETJNXT  DS    0H                                              20SEP84\n         CLI   0(R1),C'/'              NO MORE INPUT           20SEP84\n         BE    SETJEND                 YES-EXIT                20SEP84\n         LH    R2,=H'-1'               #CHAR-1 OF JOBNAME      20SEP84\n         LA    R15,JOBSNAM-JOBS(R14)   START OF NEXT JOBNAME   20SEP84\nSETJNXT2 DS    0H                                              20SEP84\n         MVC   0(1,R15),0(R1)          MOVE A BYTE             20SEP84\n         AH    R2,=H'1'                CALC L'-1 SO FAR        20SEP84\n         LA    R15,1(,R15)             NEXT OUTPUT BYTE        20SEP84\n         LA    R1,1(,R1)               NEXT INPUT BYTE         20SEP84\n         CH    R2,=H'7'                AT 8-1=7 (JOBSNAME FULL 20SEP84\n         BE    SETJLEN                 YES-SET L'-1            20SEP84\n         CLI   0(R1),C'/'              SEPERATOR               20SEP84\n         BNE   SETJNXT2                NO-CONTINUE MOVE        20SEP84\n         LA    R1,1(,R1)               YES-SKIP SEPERATOR      20SEP84\nSETJLEN  DS    0H                                              20SEP84\n         STC   R2,JOBS#CHR-JOBS(R14)   SET L'-1 OF JOBNAME     20SEP84\n         LA    R14,(JOB1-JOBS)(,R14)   NEXT JOBNAME TABLE SLOT 20SEP84\n         BCT   R0,SETJNXT              SEE IF MORE INPUT       20SEP84\nSETJEND  DS    0H                                              20SEP84\n******** ***** *********************** *********************** 20SEP84\n         LH    R0,LINESIZE         GET LINE SIZE\n         AH    R0,=H'10'           + 10\n         GETMAIN R,LV=(0)          GET PRINT LINE\n         ST    R1,@PL              SAVE ADDR\n         LH    R1,STMAXDSP         DIGITS IN DEVICE ARRAY DISPLAY\n         XR    R0,R0               CLEAR\nSETOVFLO DS    0H                  CALC LARGEST DISPLAY NUMBER (999)\n         MH    R0,=H'10'           SHIFT LEFT 1 DECIMAL\n         AH    R0,=H'9'            ADD 9\n         BCT   R1,SETOVFLO         LOOP TO GET STMAXDSP 9(S)\n         ST    R0,EODOVFLO         SAVE 999\n*        SETUP MOVE INSTR FOR SEEK COUNT\n         MVC   EXMVC,MVC           MOVE MODEL\n         MVC   EXMVC2,MVC2         MOVE MODEL OF *** MOVE\n         MVC   EXMVC3,MVC          MOVE MODEL FORM EDIT AREA\n         LH    R6,EXMVC+4          GET END OF EDIT AREA\n         N     R6,=X'0000FFFF'     CLEAR TO S TYPE CON\n         SH    R6,STMAXDSP         BACK UP BY DISPLAY DIGITS\n         STCM  R6,3,EXMVC+4        SAVE S-TYPE ADDR OF EDIT AREA\n         AH    R6,STMAXDSP         GET BACK TO ORIG. S-TYPE\n         SH    R6,STJOBDSP         BACK UP FOR JOB DISPLAY DIGITS\n         STCM  R6,3,EXMVC3+4       SAVE S-TYPE\n         LH    R0,STMAXDSP         GET # DISPLAY DIGITS\n         BCTR  R0,0                -1\n         STC   R0,EXMVC+1          PUT IN MVC INSTR\n         STC   R0,EXMVC2+1\n         LH    R0,STJOBDSP         GET JOB ARRAY DISPLAY DIGITS\n         BCTR  R0,0                -1\n         STC   R0,EXMVC3+1         SET MVC L'\n*        CALC. # OF SLOTS FOR A DRIVE\n         LH    R1,LINESIZE         GET LINE SIZE\n         SH    R1,LINEOFST         -MARGIN INFO\n         LH    R15,STMAXDSP        GET # DISPLAY DIGITS\n         BAL   R14,DIVIDE          CALC # SLOTS ON A LINE\n         STH   R1,DVSLOTS          SAVE IT\n         MH    R1,DVSLOTS          SQUARE FOR DEVICE ARRAY\n         CLI   PRTOPT,C'H'         HISTOGRAM\n         BNE   SETSIZE             NO\n         LH    R1,MAXCYL           YES-4BYTE ENTRIES PER CYL\nSETSIZE  DS    0H\n         SLL   R1,2                *4BYTES/COUNTER\n         LA    R1,DVFIXSIZ(R1)     +FIX PREFIX SIZE\n         ST    R1,DVSIZE           =SIZE OF A DEVICE ENTRY(6K)\n*        GET DEVICE VECTOR TABLE\n         LH    R0,DSADVMAX         GET MAX DEVICES\n         MH    R0,=AL2(DVVSIZ)     *SIZE OF VECTOR TABLE ENTRY(6)\n         ST    R0,DVVSIZE          SAVE SIZE\n         GETMAIN R,LV=(0)          GET TABLE\n         ST    R1,DVVROOT          SAVE ADD\n         BAL   R14,CLRIT           CLEAR CORE\n*        SEARCH FOR DASD UCBS TO FILL VECTOR TABLE\n         L     R1,DVVROOT          GET START OF VECTOR TABLE\n         A     R1,DVVSIZE          +SIZE=END+1\n         SH    R1,=AL2(DVVSIZ)     BACKUP TO LAST\n         MVI   0(R1),X'FF'         MARK LAST\n*        SEARCH UCB LOOKUP TABLE FOR DASDS\n         MVC   STSIZ#,=F'2'            START AT 1 STRING(+FUDG 20DEC84\n         LA    R4,X'0FF'               START AT CHANNEL 1 (-1)\n         L     R5,DVVROOT          MY LOOKUP TABLE\n         USING DVVTAB,R5           TELL ASM\nSETDASD  DS    0H                  LOOK FOR DASD\n         AH    R4,=H'1'                NEXT ADDR               20SEP84\n         CH    R4,=H'4095'                                     20SEP84\n         BH    SETDASDE                END-NEXT SECTION        20SEP84\n         LR    R11,R4                  COPY                    20SEP84\n         BAL   R14,UTGETUCB            GET UCB ADR             20SEP84\n         B     SETDASD                 +0=NOT FOUND            20SEP84\n         LR    R6,R11                  COPY                    20SEP84\n         CLI   UCBDVCLS(R6),X'20'  DASD\n         BNE   SETDASD             NO-LOOP\n*              SEE IF DOUBLE DENS                              06NOV84\n         ICM   R11,3,UCBCHAN(R6)   PICK UP CUA                 06NOV84\n         BAL   R14,UTDDTST         DUAL DENSITY TEST           06NOV84\n         B     SETDADDN            NO-CONTINUE                 06NOV84\n         TM    UCBCHAN+1(R6),X'20' PRIMARY VOLUME              06NOV84\n         BO    SETDASD             NO-SKIP IT                  06NOV84\nSETDADDN DS    0H                                              06NOV84\n*              OTHER CHAN PATH                                 06NOV84\n         CLI   DSAXA,DSAXAYES          XA                      20SEP84\n         BE    SETDASD2                YES-SKIP ALT PATH TEST  20SEP84\n         MVC   DSADAADR,=F'255'        START AT CHANNEL 1 (-1) 20SEP84\nSETDASD1 DS    0H                  SEE IF ANOTHER PATH\n         L     R11,DSADAADR            BUMP DEV ADR            20SEP84\n         AH    R11,=H'1'                                       20SEP84\n         ST    R11,DSADAADR            SAVE IT                 20SEP84\n         CH    R11,=H'4095'                                    20SEP84\n         BH    SETDASD                 AT-END STRANGE NONSEQ.  20SEP84\n         BAL   R14,UTGETUCB            GET UCB ADR             20SEP84\n         B     SETDASD1                NOT FOUND - LOOP        20SEP84\n         CR    R11,R6                  SAME UCB\n         BNE   SETDASD1                NO-LOOP\n         C     R4,DSADAADR             SAME PTR\n         BNE   SETDASD                 NO-ANOTHER PATH\nSETDASD2 DS    0H                      CHECK STRING            20SEP84\n         TM    UCBCHAN+1(R6),X'07' SEE IF 1ST DRIVE IN STRING\n         BNZ   SETNSTR             NO\n         L     R0,STSIZ#           GET CURRENT NUMB OF STRINGS\n         AH    R0,=H'1'            BUMP\n         ST    R0,STSIZ#\nSETNSTR  DS    0H                  END-OF-STRING CALC\n         TM    UCBSTAT(R6),X'80'   DASD ONLINE\n         BNO   SETDASD             NO-SKIP IT\n         CLI   UCBVOLI(R6),0       VALID VOLSER                06NOV84\n         BE    SETDASD             NO-SKIP                     06NOV84\n         LA    R14,STCYLS          GET MY DEVICE CHAR TABLE\nSETDEVCK DS    0H                  LOC DEVICE ATTR\n         CLC   0(1,R14),UCBUNTYP(R6)  MATCH ON UCB TYPE\n         BE    SETDEVOK            YES - GOOD DEV\n         LA    R14,STCYLS1-STCYLS(R14)  BUMP\n         CLI   0(R14),X'FF'        END OF TABLE\n         BE    SETDASD             YES-SKIP HIM\n         B     SETDEVCK            LOOP\nSETDEVOK DS    0H                  GOOD DASD\n         CLI   0(R5),X'FF'         ROOM FOR THIS ONE\n         BE    ABEND1              NO-PROGRAM BUG\n         ST    R6,DVVUCB         SAVE UCB ADDR\n         LA    R5,DVVSIZ(R5)       BUMP PTR\n         B     SETDASD\nABEND1   DS    0H                                              15OCT79\n         WTO   'TSGTFMAP-BUG-NO ROOM FOR DVTAB',ROUTCDE=(11)   15OCT79\n         ABEND 1,DUMP              NO-BLOW\nSETDASDE DS    0H                  NOW BUILD DEVICE TABLES\n         S     R5,DVVROOT          BACK UP TO LAST BUILT\n         LR    R1,R5               PUT IN WORK\n         LA    R15,DVVSIZ          SIZE OF VECTOR ENTRY\n         BAL   R14,DIVIDE          GET # GOOD DASDS IN SYS\n         LR    R0,R1               PUT IN WORK\n         MH    R0,DVSIZE+2         *DEVICE ENTRY SIZE(6K)\n         GETMAIN R,LV=(0)          GET DEVICE TABLE\n         LR    R11,R1              SET PTR TO FIRST\n         BAL   R14,CLRIT           CLEAR CORE\n         L     R5,DVVROOT          GET VECTOR PTR\nSETDT    DS    0H                  BUILD DEVICE ENTRIES\n         ICM   R6,15,DVVUCB            GET UCB ADDR\n         BZ    SETDTEND            END-OF-TABLE\n         ST    R11,DVVPTR          STORE PTR TO DEVICE ENTRY\n         MVC   DVCHAN,UCBCHAN(R6)  HEX ADDR (LAST USED PATH)   06NOV84\n         MVC   DVUCB,UCBNAME(R6)   MOVE DISPLAY ADDR\n         MVC   DVVOLI,UCBVOLI(R6)  MOVE VOLSER\n         MVC   DVSTAB,UCBSTAB(R6)  SAVE DEVICE STATUS (PRIV..  28OCT79\n         STCM  R6,15,DVUCBPTR      STORE UCB ADDR IN DEV TABLE\n*              SEE IF DUAL DENSITY                             06NOV84\n         ICM   R11,3,DVCHAN        GET ADDR                    06NOV84\n         BAL   R14,UTDDTST         IS IT DUAL DENSITY          06NOV84\n         B     SETDDNO             NO                          06NOV84\n         L     R11,DVVPTR          REFRESH R11                 06NOV84\n         OI    DVFLAG1,DVF1DD      SET DUAL DENSITY FLAG       06NOV84\n*              LOCATE SECONDARY VOLSER FOR DOUBLE DENS DISK    06NOV84\n         XR    R14,R14                                         06NOV84\n         ICM   R14,3,DVCHAN        COPY ADDR                   06NOV84\n         O     R14,=X'00000020'    FLIP ON SECONDARY VOLUME    06NOV84\n         SRDL  R14,8               PUT CU/DEV ADDR IN R15      06NOV84\n         SRL   R15,28              PUT CU/DEV IN LOW END       06NOV84\n         LR    R11,R15                 COPY                    20SEP84\n         BAL   R14,UTGETUCB            GET UCB ADDR            20SEP84\n         B     SETDDNO2                NO-SKIP                 30APR84\n         CLI   UCBVOLI(R14),0          VALID VOLSER            20SEP84\n         BE    SETDDNO2                NO-SKIP                 30APR84\n         MVC   DVVOLI2,UCBVOLI(R14)    MOVE ALT VOLUME         20SEP84\n         MVC   DVSTAB2,UCBSTAB(R14)    MOVE ALT VOL STATUS     20SEP84\n         B     SETDDNO2                FINI                    30APR84\n******** ***** *********************** *********************** 20SEP84\nSETDDNO  DS    0H                                              06NOV84\n         L     R11,DVVPTR          REFRESH R11                 06NOV84\nSETDDNO2 DS    0H                                              06NOV84\n*        CALC # OF CYLS IN A SLOT\n         LA    R14,STCYLS          DEVICE CHAR TABLE\nSETCYLLP DS    0H                  LOOK FOR DEVICE\n         CLC   0(1,R14),UCBUNTYP(R6)  MATCH\n         BE    SETCYL              YES-LOAD\n         LA    R14,STCYLS1-STCYLS(R14) BUMP\n         CLI   0(R14),X'FF'        END -\n         BNE   SETCYLLP            NO - LOOP\nSETCYL   DS    0H                  SET UP DEVICE CHAR\n         MVC   DVTYPE,(STCYLNAM-STCYLS)(R14)  NAME (3330)\n         MVC   DVTRK,(STCYLTRK-STCYLS)(R14)  TRACKS PER CYL\n         MVC   DVCYL,(STCYLMAX-STCYLS)(R14)  CYL PER VOLUME    15OCT79\n         LH    R15,DVSLOTS         GET # OF SLOTS\n         LH    R1,(STCYLMAX-STCYLS)(R14)   GET # CYLS ON PACK\n         BAL   R14,DIVIDE          STRAIGHT DIVIDE\n         AH    R1,=H'1'            ROUND UP TO HANDLE PARTIAL\n         STH   R1,DVDELTA           ROW\n         LA    R15,DVXREF          GET START OF DEVICE ARRAY\n         ST    R15,DVLROW          SAVE AS LAST ROW SEEKED\n         LA    R5,DVVSIZ(R5)       NEXT DEVICE VECTOR PTR\n         A     R11,DVSIZE          NEXT DEVICE ENTRY\n         B     SETDT               DO NEXT DEVICE\n         DROP  R5                  TELL ASM\nMVC2     MVC   0(*-*,R5),=CL10'**********'  OVERFLOW MODEL INSTR\nMVC      MVC   0(*-*,R5),WE+L'WE   MODEL FOR MOVE IN REPORT\nSETDTEND DS    0H                                              20SEP84\n*        GETMAIN CORE FOR STRING TABLE\n*        THIS TABLE SHOULD BE GETMAINED/FREEMAINED AT EOJ\n*         SINCE IT IS ONLY USED THERE.\nSETST    DS    0H                  GETMAIN STRING TABLE\n         L     R0,STSIZ#           GET # OF STRINGS\n         MH    R0,=AL2(STSIZE)\n         GETMAIN R,LV=(0)\n         ST    R1,STROOT           SAVE ADDR\n         BAL   R14,CLRIT           CLEAR CORE\nSETRET   DS    0H                  RETURN FROM SETUP\n         L     R12,@BASE           RESTORE MAIN BASE REG\n         POP   USING                                           15OCT79\n         B     GETREC                                          15OCT79\n TITLE 'E N D  O F  D A T A  -  C A L C  D E P E N D A N T  D A T A'\nEODRTN   DS    0H                  END-OF-FILE ON INPUT\n         PUSH  USING                                           15OCT79\n         USING EODRTN,R12          NEW BASE REG                15OCT79\n         LM    R0,R1,STOPTM        GET TIME OF LAST GTF REC\n         LM    R2,R3,STRTTM        GET STOP TIME\n         BAL   R14,UTTIMDIF        CALC DIF IN MILLISEC*10\n         LH    R15,=H'10'          NORMALIZE *10 OUT\n         BAL   R14,DIVIDER         CALC GTF RUN TIME IN MILLI-SEC\n         LH    R15,=H'1000'        NOW DO IT IN SECONDS        06NOV84\n         BAL   R14,DIVIDER         CALC GTF RUN TIME IN SEC    06NOV84\n         ST    R1,TOTTM            SAVE ELAPSED TIME\n*        CALC  SIO0 RATE                                       06NOV84\n         ZAP   WD,TOTSIO0          GET BINARY                  06NOV84\n         CVB   R1,WD               GET GOOD SIOS               06NOV84\n         MH    R1,=H'10'           TIMES 10 FOR PRECISION      06NOV84\n         L     R15,TOTTM           GET RUN TIME                06NOV84\n         BAL   R14,DIVIDER         GET RATE IO/SEC *10         06NOV84\n         ST    R1,TOTSIO0R         SAVE RATE                   06NOV84\n*        CALC SUMMARY DATA BY STRING\n         L     R1,DVVROOT          GET DEVICE VECTOR TABLE\n         ST    R1,EODCURDV         SET 1ST DEVICE\nEODSTNX1 DS    0H                  NEXT DEVICE\n         L     R1,EODCURDV         GET DEVICE VECT ENTRY\n         L     R11,DVVPTR-DVVTAB(R1) GET DEVICE TABLE ENTRY\n         OC    DVVPTR-DVVTAB+1(3,R1),DVVPTR-DVVTAB+1(R1) END OF DEVS\n         BZ    EODSTEN1            YES-STRING-CALC-COMPLETE\n         LA    R1,DVVSIZ(R1)       BUMP TO NEXT VECTOR\n         ST    R1,EODCURDV         SAVE FOR NEXT TIME\n         MVC   EODSTUCB,DVUCB      GET EBCDIC ADDR\n         MVI   EODSTUCB+2,C'0'     ASSUME ZERO STRING\n         XR    R6,R6               CLEAR WORKER\n         ICM   R6,15,DVUCBPTR       GET UCB ADDR\n         TM    UCBCHAN+1(R6),X'08' HI OR LO STRING\n         BZ    *+8                 ZERO STRING-OK\n         MVI   EODSTUCB+2,C'8'     MAKE XX8 STRING\n         L     R2,STSIZ#           GET NUMB OF STRINGS\n         L     R3,STROOT           GET FIRST STRING\n         USING STTAB,R3            TELL ASM\nEODSTNX2 DS    0H                  CALC STRING STATS\n         OC    STUCB,STUCB         END OF STRING TABLE\n         BZ    EODSTADD            YES-ADD NEW STRING\n         CLC   STUCB,EODSTUCB      FOUND RIGHT STRING\n         BE    EODSTHIT            YES\n         LA    R3,STSIZE(R3)       BUMP TO NEXT STRING TABLE\n         BCT   R2,EODSTNX2         TRY NEXT STRING TABLE ENTRY\nABEND4   DS    0H                                              15OCT79\n         WTO   'TSGTFMAP-BUG-NO STRING FOR A DEV',ROUTCDE=(11) 15OCT79\n         WTO   'TSGTFMAP-ABEND4 SKIPPED.........',ROUTCDE=(11) 20DEC84\n         B     EODSTNX1                                        20DEC84\n         ABEND 4,DUMP              RAN OF OF CALCULATED STRING ENTRIES\nEODSTADD DS    0H                  ADD A NEW STRING\n         MVC   STUCB,EODSTUCB      MOVE EBCDIC NAME\nEODSTHIT DS    0H                  UPDATE A STRING ENTRY\n         OC    DVSIO0,DVSIO0       ANY DEVICE ACTIVITY\n         BZ    EODSTNX1            NO\n*\n         L     R0,DVSIO0           ADD DEV SIO 0 TO STRING\n         A     R0,STSIO0\n         ST    R0,STSIO0\n*\n         L     R0,DVSIO1           SIO 1\n         A     R0,STSIO1\n         ST    R0,STSIO1\n*\n         L     R0,DVSIO2           SIO 2\n         A     R0,STSIO2\n         ST    R0,STSIO2\n*\n         L     R0,DVSIO3           SIO 3\n         A     R0,STSIO3\n         ST    R0,STSIO3\n*\n         L     R0,DVRESV           RESERVES                    28OCT79\n         A     R0,STRESV                                       28OCT79\n         ST    R0,STRESV                                       28OCT79\n*\n         L     R0,STNUMB           GET CURR NUMB OF DEV ON STRING\n         AH    R0,=H'1'\n         ST    R0,STNUMB\n*\n         L     R0,DVAVGIO          AVG IO TIME\n         A     R0,STAVGIO\n         ST    R0,STAVGIO\n*\n         L     R0,DVTOTCYL         CYL SEEKED\n         A     R0,STTOTCYL\n         ST    R0,STTOTCYL\n*\n         L     R0,DVDEFRIO         AVG DEFER TIME\n         A     R0,STDEFRIO\n         ST    R0,STDEFRIO\n*\n         CLC   DVDEFRMX,STDEFRMX   LOCATE HIGHEST DEFER TIME\n         BL    *+10                LOWER THAN CURR. MAX.\n         MVC   STDEFRMX,DVDEFRMX   STORE NEW LIMIT\n*\n         L     R0,DVAVGRES         BUMP STRING RESERVE DATA    28OCT79\n         A     R0,STAVGRES                                     28OCT79\n         ST    R0,STAVGRES         UPDATE                      28OCT79\n         B     EODSTNX1\n TITLE 'E N D  O F  D A T A  -  P R I N T  S T R I N G  S T A T S  '\nEODSTEN1 DS    0H                  PRINT GRAND TOTALS\n*        PRINT JOB TOTALS\n         BAL   R14,CLRPL           CLEAR PRINT LINE\n         L     R1,@PL              GET PRINT LINE\n         MVI   0(R1),C'0'          DOUBLE SPACE\n         MVC   1(10,R1),=C'JOB TOTALS'\n         BAL   R14,PUT             PRINT IT\n         LA    R2,(PRTCNTE-PRTCNTS)/(PRTCNT1-PRTCNTS)\n         LA    R3,PRTCNTS          #OF CTRS/STRT OF TABLE\n         BAL   R14,UTEODP          PRINT PACKED DATA\n         LA    R2,(PRTBCNTE-PRTBCNTS)/(PRTBCNT1-PRTBCNTS) NUMB OF ENTS\n         LA    R3,PRTBCNTS         START OF FORMAT TABLE\n         ST    R13,UTEODBAS        SAVE BASE INFO FOR FORMATTER\n         BAL   R14,UTEODB          PRINT TABLE\n*\n**             PRINT GTF RUN START / END\n*\n         MVC   STCKSTCK,STRTTM         MOVE START TIME         DDMMM84\n         BAL   R14,UTSTCK              MAKE PRINTABLE          DDMMM84\n         L     R1,@PL                                          DDMMM84\n         MVC   11(28,R1),STCK          MOVE ENGLISH START TIME DDMMM84\n         MVC   11+L'STCK(15,R1),=C'=GTF START TIME'            DDMMM84\n         BAL   R14,PUT                 PRINT IT                DDMMM84\n*                                                              DDMMM84\n         MVC   STCKSTCK,STOPTM         MOVE STOP  TIME         DDMMM84\n         BAL   R14,UTSTCK              MAKE PRINTABLE          DDMMM84\n         L     R1,@PL                                          DDMMM84\n         MVC   11(28,R1),STCK                                  DDMMM84\n         MVC   11+L'STCK(15,R1),=C'=GTF STOP  TIME'            DDMMM84\n         BAL   R14,PUT                 PRINT IT                DDMMM84\n*\n**             CALC STRING DATA AND PRINT\n*\n         L     R3,STROOT           GET 1ST STRING\nEODSTNX3 DS    0H                  NEXT STRING\n         L     R0,STSIZ#           NUMB OF STRINGS\n         MH    R0,=AL2(STSIZE)     * SIZE = OFFSET TO END+1\n         A     R0,STROOT            + BASE = END+1\n         CR    R0,R3               OFF END\n         BNH   EODSTEND            YES\n         OC    STSIO0,STSIO0       ANY SIOS\n         BZ    EODSTBM1            NO-SKIP\n         L     R1,STAVGIO          GET TOTAL IO TIME * 10MS\n         L     R15,STSIO0          GET # GOOD SIOS\n         MH    R15,=H'10'          ADJUST FOR *10 FACTOR\n         BAL   R14,DIVIDER         GET AVG IO TIME ON STRING MILLISEC\n         ST    R1,STAVGIO          SAVE AVERAGE\n         L     R1,STTOTCYL         GET TOTAL CYLS SEEKED\n         L     R15,STSIO0          GOOD SIO\n         BAL   R14,DIVIDER         GET AVG CYL SEEKED\n         ST    R1,STTOTCYL         AVG CYL SEEKED\n*\n**       NORMALIZE STRING AVG DEFER TIME\n*\n         L     R1,STDEFRIO         GET DEFERED TIME *10MS\n         L     R15,STSIO1          GET # OF DEFERED SIOS\n         MH    R15,=H'10'          ADJUST FOR *10\n         BAL   R14,DIVIDER\n         ST    R1,STDEFRIO         SAVE AVG DEFERED TIME\n*\n**       NORMALIZE STRING MAX DEFER TIME\n*\n         L     R1,STDEFRMX         GET MAX STRING DEFER *10\n         LH    R15,=H'10'          SETUP DIVISOR\n         BAL   R14,DIVIDER         DIVIDE AND ROUND\n         ST    R1,STDEFRMX         STORE MAX DEFER IN MILLI-SEC\n*                                                              28OCT79\n**       NORMALIZE STRING AVG DEFER TIME                       28OCT79\n*                                                              28OCT79\n         L     R1,STAVGRES         GET RESERVE TIME *10MS      28OCT79\n         L     R15,STRESV          GET # OF RESERVES           28OCT79\n         MH    R15,=H'10'          ADJUST FOR *10              28OCT79\n         BAL   R14,DIVIDER                                     28OCT79\n         ST    R1,STAVGRES         SAVE AVG DEFERED TIME       28OCT79\n*\n**       PRINT STRING DATA\n*\n         BAL   R14,CLRPL           CLR PRINT LINE\n         L     R1,@PL              GET PRINT LINE\n         MVI   0(R1),C'0'          DBL SPACE\n         MVC   1(3,R1),STUCB       MOVE NAME OF STRING\n         MVC   5(6,R1),=C'STRING'  STRING IN TITLE\n         BAL   R14,PUT\n         ST    R3,UTEODBAS         SAVE BASE ADDR FOR FORMATTER\n         LA    R2,(EOD2CNTE-EOD2CNTS)/(EOD2CNT1-EOD2CNTS) NUMB OF FLDS\n         LA    R3,EOD2CNTS         GET FORMAT DATA\n         BAL   R14,UTEODB          PRINT STRING DATA\n         L     R3,UTEODBAS         RESTORE R3\nEODSTBM1 DS    0H                  NEXT STRING ENTRY\n         LA    R3,STSIZE(R3)\n         B     EODSTNX3\n         DROP  R3                  FINI W/ STRING\nEODSTEND DS    0H                  FINI W/ STRING\n TITLE 'E N D  O F  D A T A  -  P R I N T  E A C H  D E V I C E    '\n         L     R1,DVVROOT          FIRST VECTOR ENTRY\n         ST    R1,EODCURDV         SAVE\nEODLOOP  DS    0H             NOW PRINT DATA FOR EACH DASD\n         BAL   R14,CLRPL           CLEAR PRT LINE TO BLANKS\n         L     R1,EODCURDV         PICK UP CURRENT DEVICE PTR\n         OC    DVVPTR+1-DVVTAB(L'DVVPTR-1,R1),DVVPTR+1-DVVTAB(R1)\n         BZ    EODJOB              END OF TABLE - DONE\n         L     R11,DVVPTR-DVVTAB(R1) GET DEVICE TABLE\n         LA    R1,DVVSIZ(R1)       BUMP TO NEXT DEVICE PTR\n         ST    R1,EODCURDV         SAVE FOR NEXT TIME\n         OC    DVSIO0,DVSIO0       NO-SIOS - SKIP\n         BZ    EODLOOP             TRY NEXT DEVICE\n         ZAP   WD,TOTSIO           SEE IF I/OS TOO LOW         02MAR94\n         CVB   R0,WD                                           02MAR94\n         SRL   R0,8                IOS/256(ROUND DOWN)         02MAR94\n         C     R0,DVSIO0                                       02MAR94\n         BH    EODLOOP             I/O  TOO LOW - SKIP         02MAR94\n*                                                              15OCT79\n**      MAP VTOC    TRACK TO DSN                               15OCT79\n*                                                              15OCT79\n         L     R0,=A(DSDSNTL#)     GET DEFAULT BUFFER SIZE     15OCT79\n         ST    R0,DSDSNTL          SAVE                        15OCT79\nEODDSN0  DS    0H                                              15OCT79\n         CLI   PRTOPT,C'H'         ONLY MAP FOR HISTOGRAM      15OCT79\n         BNE   EODDSNX             YES-BYPASS SECTION          15OCT79\n         ICM   R1,15,DVDSNO        OLD TABLE                   15OCT79\n         BZ    EODDSN1             NO-GET 1ST                  15OCT79\n         SH    R1,=H'4'            TABLE-4 = LENGTH            15OCT79\n         L     R0,0(R1)            LENGTH                      15OCT79\n         FREEMAIN R,A=(1),LV=(0)                               15OCT79\n         L     R1,DVDSNT           FREE UP DSN TABLE           15OCT79\n         SH    R1,=H'4'            BACK UP TO L'               15OCT79\n         L     R0,0(R1)                                        15OCT79\n         FREEMAIN R,A=(1),LV=(0)                               15OCT79\nEODDSN1  DS    0H                                              15OCT79\n         LH    R1,DVCYL            CYL/VOLUME                  15OCT79\n         MH    R1,DVTRK            TRKS/CYL                    15OCT79\n         LA    R1,4(R1,R1)         2BYTES/TRK +4BYTE L'        15OCT79\n         LR    R0,R1               COPY                        15OCT79\n         GETMAIN R,LV=(0)                                      15OCT79\n         ST    R0,0(R1)            SAVE L'                     15OCT79\n         LA    R1,4(R1)            SKIP L'                     15OCT79\n         ST    R1,DVDSNO           DSN OFFSET TABLE            15OCT79\n         LR    R14,R1              START OF CLEAR              15OCT79\n         LR    R15,R0              WHOLE TABLE L'              15OCT79\n         SH    R15,=H'4'           DONT CLEAR LEN WORD         15OCT79\n         XR    R0,R0                                           15OCT79\n         XR    R1,R1                                           15OCT79\n         MVCL  R14,R0              CLEAR OFFSET TABLE          15OCT79\n         L     R0,DSDSNTL          GETMAIN DSNAME TABLE        15OCT79\n         GETMAIN R,LV=(0)                                      15OCT79\n         ST    R0,0(R1)            SAVE TBL ADDR               15OCT79\n         LA    R1,4(R1)            TABLE START                 15OCT79\n         ST    R1,DVDSNT           SAVE TBL START PTR          15OCT79\n         LA    R1,1(R1)            MAKE SURE NON-ZERO DISPL.   15OCT79\n         ST    R1,DSDSNTC          SAVE NXT AVAL BYTE          15OCT79\n         SH    R1,=H'100'          BACK UP 100 BYTES           15OCT79\n         AR    R1,R0               GET END MINUS 99            15OCT79\n         ST    R1,DSDSNTE          SAVE LIMIT                  15OCT79\n*                                                              15OCT79\n**       MAP   VOLUME                                          15OCT79\n*                                                              15OCT79\n         MVC   VOLID,DVVOLI        COPY VOLSER                 15OCT79\nEODDSNVO DS    0H                  SECONDARY VOLSER EP         06NOV84\n*?$?    DUE TO ACF2 SECURITY, FILTER OUT UNALLOWED VOLSERS     02MAR94\n         CLC   =C'XPC',DVVOLI      FORBIDDEN VOLSER-X.....     02MAR94\n         BE    EODDSNX             YES-SIMULATE EOF            02MAR94\n         CLC   =F'0',VADEXCP       VTOCEXCP UNAVAIL?           02MAR94\n         BE    EODDSNX             YES-SIMULATE EOF            02MAR94\n         VTEXCP OPEN                                           15OCT79\n         USING FMT1,R10                                        15OCT79\nEODDSNL  DS    0H                  READ VTOC FOR F1 DSCB       15OCT79\n         VTEXCP READ                                           15OCT79\n         CH    R15,=H'4'           EOF                         15OCT79\n         BE    EODDSNX             YES-DONE                    15OCT79\n         L     R10,DSCBADDR        GET ADR OF DSCB             15OCT79\n         LA    R10,8(R10)          SKIP COUNT FIELD            15OCT79\n         CLI   DS1FMTID,C'4'       F4 (VTOC)                   28OCT79\n         BE    EODDSNL4            YES-DUMMY UP A DS           28OCT79\n         CLI   DS1FMTID,C'1'       F1 DSCB                     15OCT79\n         BNE   EODDSNL             NO-READ MORE                15OCT79\n         XC    FMT3,FMT3           CLEAR F3 DSCB AREA          15OCT79\n         CLI   DS1EXT1,0           ANY EXTENTS                 15OCT79\n         BE    EODDSNL             NO-SKIP                     15OCT79\n         OC    DS1PTRDS,DS1PTRDS   ANY F3 DSCB                 15OCT79\n         BZ    EODDSNL1            NO                          15OCT79\n         MVC   DS3PTRDS,DS1PTRDS   MOVE CCHHR ADDR OF F3       15OCT79\n         VTEXCP CCHH               READ BY CCHHR               15OCT79\n         LTR   R15,R15             ERRORS                      15OCT79\n         BZ    EODDSNL1            NO-OK                       15OCT79\nABEND6   DS    0H                                              15OCT79\n         ST    R15,WD              SAVE FOR DIAG.              15OCT79\n         WTO   'TSGTFMAP-BAD READ FOR F3 DSCB',ROUTCDE=(11)    15OCT79\n         ABEND 6,DUMP                                          15OCT79\nEODDSNL4 DS    0H                  DUMMY UP FMT4 LIKE D.S.     28OCT79\n         MVC   DS1DSNAM,=CL44' *V*T*O*C*'                      28OCT79\n*                                  SINCE I KNOW VTOC IS ONE    06NOV84\n*                                  EXTENT, I WILL FAKE IT      06NOV84\n*                                  TO LOOK LINE 2 EXTENTS      06NOV84\n*                                  EXT 1 = VOL LABEL TRK       06NOV84\n*                                  EXT 2 = OLD EXT 1           06NOV84\n         MVC   DS1EXT2,DS1EXT1     MAKE 2 LOOK LIKE 1          06NOV84\n         MVI   DS1EXT2+1,1         SET 2ND EXT                 06NOV84\n         MVC   DS1EXT1,=X'00000000000000000001' EXT=1TRK@CYL0  06NOV84\nEODDSNL1 DS    0H                                              15OCT79\n         L     R2,DSDSNTC          GET CURR DSN AREA           15OCT79\n         MVC   2(44,R2),DS1DSNAM   MOVE WHOLE DSNAME           15OCT79\n         LA    R1,1+1+43(R2)       GET LAST BYTE OF DSN        15OCT79\n         LA    R0,44               MAX NAME                    15OCT79\nEODDSNLP DS    0H                                              15OCT79\n         CLI   0(R1),C' '          NON-BLANK YET               15OCT79\n         BNE   EODDSNMX            YES-SAVE DSN LENGTH         15OCT79\n         BCTR  R1,0                BACK UP                     15OCT79\n         BCT   R0,EODDSNLP                                     15OCT79\n         WTO   'TSGTFMAP-BUG-NULL DSNAME',ROUTCDE=(11)         15OCT79\nABEND7   ABEND 7,DUMP                                          15OCT79\nEODDSNMX DS    0H                                              15OCT79\n         STC   R0,0(R2)            SAVE TRUE DSN L'            15OCT79\n         LA    R5,DS1EXT1          1ST EXTENT PTR              15OCT79\nEODDSNNX DS    0H                  NEXT EXTENT                 15OCT79\n         LH    R2,2(R5)            CC LOW                      15OCT79\n         LH    R3,6(R5)            SAME TRICK FOR HI TRACK     15OCT79\n*              IF DUAL DENSITY, REMAP TRACK LIKE SEEK ADDR     06NOV84\n*              THE DISCUSSION SHOWN IN SIOREC ROUTINE          06NOV84\n         TM    DVFLAG1,DVF1DD      DUAL DENSITY?               06NOV84\n         BZ    EODDSNDD            NO                          06NOV84\n         LH    R0,DVCYL            GET DUAL VOL #CYL           06NOV84\n         SRL   R0,1                GET SINGLE VOLUME CYL       06NOV84\n         CLC   VOLID,DVVOLI        PRIMARY VOLSER?             06NOV84\n         BNE   EODDSND2            NO-ASSUME SECONDARY         06NOV84\n*CDC33502-MAP 0-554    TO 555  -1109                           06NOV84\n         AR    R2,R0               ADJUST TO MIDDLE            06NOV84\n         AR    R3,R0               \"                           06NOV84\n         B     EODDSNDD            CONTINUE                    06NOV84\nEODDSND2 DS    0H                  SECONDARY VOLUME            06NOV84\n*CDC33502-MAP 0-554    TO 554  -0                              06NOV84\n         LCR   R2,R2               GET NEG                     06NOV84\n         AR    R2,R0                                           06NOV84\n         BCTR  R2,0                REMAP                       06NOV84\n         LCR   R3,R3               GET NEG                     06NOV84\n         AR    R3,R0                                           06NOV84\n         BCTR  R3,0                NOTE NOW R2>R3 STRT>END     06NOV84\nEODDSNDD DS    0H                  FINI                        06NOV84\n         MH    R2,DVTRK            *TRKS/CYL=TRACK             15OCT79\n         AH    R2,4(R5)            PLUS TRK LOW=TRACK STRT     15OCT79\n         MH    R3,DVTRK                                        15OCT79\n         AH    R3,8(R5)            LAST TRACK                  15OCT79\n         CR    R2,R3               DID REMAP CAUSE             06NOV84\n         BL    EODDSNDE            NO-OK                       06NOV84\n         ST    R2,WD               YES-SWAP REGS               06NOV84\n         LR    R2,R3                \"                          06NOV84\n         L     R3,WD                 \"                         06NOV84\nEODDSNDE DS    0H                                              06NOV84\n         L     R0,DSDSNTC          GET DSNAME ENTRY PTR        15OCT79\n         S     R0,DVDSNT            -TABLE START = OFFSET      15OCT79\n         CL    R0,=X'0000FFFF'     MAX OFFSET                  15OCT79\n         BNH   EODDSNOX            OK                          15OCT79\n         CLI   DSABEND8,1          HAVE MSG BEEN ISSUED ONCE   06NOV84\n         BE    ABEND8              YES-SKIP IT                 06NOV84\n         MVI   DSABEND8,1          SHOW ITS BEEN SENT          06NOV84\n         WTO   'TSGTFMAP-TOO MANY DATASETS ON VOLUME',ROUTCDE=(11)\nABEND8   DS    0H                                              15OCT79\n*        ABEND 8,DUMP                                          15OCT79\n         XR    R0,R0               DONT ABEND, MAP TO ZERO     06NOV84\n         B     EODDSNOX            NOP IF YOU WANT ABEND       06NOV84\nEODDSNOX DS    0H                                              15OCT79\n         SLL   R2,1                1ST TRACK * 2               15OCT79\n         SLL   R3,1                LAST TRACK * 2              15OCT79\n         A     R2,DVDSNO           +BASE = OFFSET TABLE ENTRY  15OCT79\n         A     R3,DVDSNO           \"                           15OCT79\n*\n**       MAKE EVERY OFFSET ENTRY CORRESPONDING BETWEEN         15OCT79\n**       START AND END TRACK POINT TO DSN TABLE                15OCT79\n*                                                              15OCT79\nEODDSNTO DS    0H                                              15OCT79\n         STCM  R0,3,0(R2)          SAVE DSN OFFSET             15OCT79\n         LA    R2,2(R2)            NEXT TRACK SLOT             15OCT79\n         CR    R2,R3               OVER LAST TRACK YET         15OCT79\n         BNH   EODDSNTO            NO-LOOP                     15OCT79\n         L     R2,DSDSNTC          GET CURRENT DSN INFO        15OCT79\n         MVI   1(R2),C' '          MAKE EXTENT INFO BLANK      15OCT79\n         XR    R1,R1                                           15OCT79\n         ICM   R1,1,1(R5)          GET EXTENT # 0-F            15OCT79\n         BZ    EODDSNXX            EXTENT ZERO SHOWS BLANK     15OCT79\n         N     R1,=F'15'           FORCE EXTENT 0-F            02MAR94\n         CLI   1(R5),9             IS EXTENT IN RANGE 1-9      15OCT79\n         BH    EODDSNX2            YES - A-F                   15OCT79\n         AH    R1,=AL2(C'0')       NO MAKE 01-09 TO F1-F9      15OCT79\n         B     EODDSNX3            SKIP                        15OCT79\nEODDSNX2 DS    0H                                              15OCT79\n         AH    R1,=AL2(C'A'-10)    XLATE A-F TO C1-C6          15OCT79\nEODDSNX3 DS    0H                                              15OCT79\n         STC   R1,1(R2)            SAVE EXTENT INDICATOR       15OCT79\nEODDSNXX DS    0H                                              15OCT79\n*                                                              15OCT79\n**             BUMP R5 TO NEXT EXTENT FIELD                    15OCT79\n*                                                              15OCT79\n         XR    R1,R1                                           15OCT79\n         IC    R1,1(R5)            PICK UP THIS EXTENT #       15OCT79\n         LA    R5,1(R1)            GET NEXT EXTENT #           15OCT79\n         SLL   R5,2                *4 0,4,8,...                15OCT79\n         EX    0,EODDSNEX(R5)      GET ADDR OF EXTENT          15OCT79\n*                                                              15OCT79\n**       UPDATE NEXT AVAL. BYTE IN DSN TABLE                   15OCT79\n*                                                              15OCT79\nEODDSN2  DS    0H                                              15OCT79\n         XR    R1,R1                                           15OCT79\n         L     R2,DSDSNTC          NEXT AVAL.                  15OCT79\n         IC    R1,0(R2)            DSN L'                      15OCT79\n         LA    R1,2(R1,R2)         NEXT=L'DSN+1+1              15OCT79\n*                                  1 FOR DSNL', 1FOR EXTENTID  15OCT79\n         ST    R1,DSDSNTC          NEXT AVAL.                  15OCT79\n*       R2==> AL1(L'DSN),CL1'EXTENT#',CL1-44'DSNAME'           02MAR94\n         MVC   0(46,R1),0(R2)      COPY L', DSN FOR NEXT EXTNT 27OCT79\n*                                   (IF ANY);IF NOT IT WILL BE 27OCT79\n*                                   OVERLAID BY NEXT DSN INFO  27OCT79\n         C     R1,DSDSNTE          OVER TABLE LIMITS           15OCT79\n         BNH   EODDSN3             NO-SEE IF MORE EXTENTS      15OCT79\n         TS    DSDSNTSW            ALREADY ISSUED WTO?         02MAR94\n         BNZ   EODDSN2S            SKIP WTO                    02MAR94\n         WTO   'TSGTFMAP-DSN TABLE TOO SMALL',ROUTCDE=(11)     15OCT79\nEODDSN2S DS    0H                                              02MAR94\n*       DUE TO SOFTWARE PROBLEMS-DONT TRY TO INCREASE TBL SIZE 02MAR94\n*--- FOR DEBUGGING:                                            02MAR94\n*         - MAKE FOLLOWING INSTR AN 0C1 TO SEE TABLES          02MAR94\n*           (IF YOU DONT, PROG ABENDS W/ 80A AND OLD TABLE     02MAR94\n*            IS ALREADY FREEMAINED)                            02MAR94\n*         - MAKE FOLLOWING INSTRUCTION A NOOP AND PROG WILL    02MAR94\n*           RUN WITH DEFAULT TABLE SIZE. DATASETS OUT OF       02MAR94\n*           TABLE SHOW AS BLANKS IN REPORT.                    02MAR94\n         B     EODDSN2X            NORMAL PATH                 02MAR94\n         MVI   2(R2),C'?'          SHOW ENTRY UNDEPENDABLE     02MAR94\n         ST    R2,DSDSNTC          RE-USE LAST ENTRY           02MAR94\n         B     EODDSNX             SIMULATE EOF                02MAR94\n*       PRECEEDING CODE WILL CAUSE LAST TABLE ENTRY TO BE      02MAR94\n*       USED OVER-AND-OVER AGAIN. SO THE DSNS FOR SEEKS WILL   02MAR94\n*       BE INCORRECT.                                          02MAR94\nEODDSN2X DS    0H                                              02MAR94\n         L     R0,DSDSNTL          TRY AGAIN W/ DOUBLE TBL SIZ 15OCT79\n         SLL   R0,1                                            15OCT79\n         ST    R0,DSDSNTL                                      15OCT79\n         B     EODDSN0             START OVER AGAIN            15OCT79\n*                                                              15OCT79\n**             SEE IF ANOTHER EXTENT                           15OCT79\n*                                                              15OCT79\nEODDSN3  DS    0H                                              15OCT79\n         CLI   0(R5),0             NULL EXTENT?                15OCT79\n         BNE   EODDSNNX            DO NEXT EXTENT              15OCT79\n         B     EODDSNL             NO-GET NEXT D.S.            15OCT79\nEODDSNEX LA    R5,DS1EXT1          EXECUTED INSTRS TO GET EXT  15OCT79\n         LA    R5,DS1EXT2          DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS1EXT3          DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3EXTNT+00      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3EXTNT+10      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3EXTNT+20      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3EXTNT+30      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+00      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+10      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+20      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+30      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+40      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+50      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+60      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+70      DATASET EXTENT FIELD        15OCT79\n         LA    R5,DS3ADEXT+80      DATASET EXTENT FIELD        15OCT79\n         LA    R5,=X'0000'         DUMMY UP 17TH EXTENT        15OCT79\nEODDSNX  DS    0H                                              15OCT79\n         CLC   VOLID,DVVOLI2       DONE WITH SECONDARY VOL?    06NOV84\n         BE    EODDSNDX            YES-EXIT                    06NOV84\n         CLI   DVVOLI2,0           IS THERE A SECONDARY VOL    06NOV84\n         BE    EODDSNDX            NO-EXIT                     02MAR94\n         MVC   VOLID,DVVOLI2       YES-RERUN W/ SECONDARY      06NOV84\n         B     EODDSNVO                                        06NOV84\nEODDSNDX DS    0H                                              15OCT79\n**       FINISHED MAPPING PACK                                 15OCT79\n*------------------------------------------------------------* 15OCT79\n*        CALC AVG CYL SEEKED\n         L     R1,DVTOTCYL         GET TOTAL CYL SEEKED\n         L     R15,DVSIO0          GET GOOD SIOS\n         BAL   R14,DIVIDER         TOT CYL / SIO 0\n         ST    R1,DVAVGCYL         STORE AVG. CYL SEEKED\n*        CALC AVG IO TIME IN MILLI-SEC\n         L     R1,DVAVGIO          GET SUM OF IO TIME(TIMES 10)\n         L     R15,DVSIO0          GET GOOD SIOS\n         MH    R15,=H'10'          (TIMES 10) TO OFFSET IO TIME\n         BAL   R14,DIVIDER         GET AVG. I/O TIME (IN MILLISEC)\n         ST    R1,DVAVGIO          SAVE\n         L     R1,DVMAXIO          GET LONGEST IO TIME\n         LH    R15,=H'10'          GET 10 TO NORMALIZE\n         BAL   R14,DIVIDER         GET LONGEST IO TIME IN MILLISEC\n         ST    R1,DVMAXIO          SAVE IT\n*        CALC AVG DEFERED TIME IN MS\n         L     R1,DVDEFRIO         GET DEFERED IO TIME\n         L     R15,DVSIO1          GET # OF DEFRS\n         MH    R15,=H'10'          ADJUST FOR *10 FACTOR\n         BAL   R14,DIVIDER         GET AVG DEFR TIME\n         ST    R1,DVDEFRIO\n*        CALC MAX DEFERED TIME IN MS\n         L     R1,DVDEFRMX         GET DEFERED IO TIME\n         LH    R15,=H'10'          ADJUST FOR *10 FACTOR\n         BAL   R14,DIVIDER         GET AVG DEFR TIME\n         ST    R1,DVDEFRMX\n*        CALC AVG RESERVED TIME IN MS                          28OCT79\n         L     R1,DVAVGRES         GET RESERVED IO TIME        28OCT79\n         L     R15,DVRESV          GET # OF RESERVES           28OCT79\n         MH    R15,=H'10'          ADJUST FOR *10 FACTOR       28OCT79\n         BAL   R14,DIVIDER         GET AVG RESV TIME           28OCT79\n         ST    R1,DVAVGRES                                     28OCT79\n*        CALC  SIO0 RATE                                       06NOV84\n         L     R1,DVSIO0           GET GOOD SIOS               06NOV84\n         MH    R1,=H'10'           TIMES 10 FOR PRECISION      06NOV84\n         L     R15,TOTTM           GET RUN TIME                06NOV84\n         BAL   R14,DIVIDER         GET RATE IO/SEC *10         06NOV84\n         ST    R1,DVSIO0R          SAVE RATE                   06NOV84\n*        SET UP TO NORMALIZE COUNTS IN XREF ARRAY\n         LH    R2,DVSLOTS          GET # OF SLOTS TO MAP PACK\n         MH    R2,DVSLOTS          SQUARE IT FOR # OF ARRAY ENTRIES\n         CLI   PRTOPT,C'H'         HISTOGRAM\n         BNE   EODNHIST            NO\n         LH    R2,MAXCYL           YES-1 ENTRY/CYL\nEODNHIST DS    0H\n         XR    R3,R3               CLEAR\n         LA    R4,DVXREF           GET START OF ARRAY\nEODMAX   DS    0H                  LOOK FOR HIGHEST ENTRY\n         C     R3,0(R4)            COMPARE AGAINST CURRENT\n         BH    *+8                 NOT A NEW HIGH\n         L     R3,0(R4)            NEW-HIGH - PICK UP\n         LA    R4,4(R4)            BUMP TO NEXT ENTRY\n         BCT   R2,EODMAX           LOOP\n         ST    R3,DVMAXHIT         SAVE HIGHEST HIT PT.\n         CLI   PRTOPT,C'H'         HISTOGRAM PRINT\n         BE    EODMAXOK            YES-DONT HORMALIZE\n         C     R3,EODOVFLO         WOULD MAX OVERFLOW A PRT ENTRY\n         BL    EODMAXOK            NO-NO NEED TO NORMALIZE\n         LH    R2,DVSLOTS          GET SLOTS AGAIN\n         MH    R2,DVSLOTS          SQUARE TO GET ARRAY SIZE\n         LA    R4,DVXREF           START OF ARRAY\n         LR    R14,R3              SAVE MAX HIT POINT SIZE\n         SRL   R14,1               1/2\nEODNORM  DS    0H                  NORMALIZE WHOLE ARRAY TO PRT SIZE\n         XR    R0,R0               CLEAR\n         L     R1,0(R4)            GET ENTRIES NUMBER\n         M     R0,EODOVFLO         X 999 - PRT ELEMENT SIZE\n         ALR   R1,R14              ADD FOR HALF ADJUST\n         BC    8+4,*+8             DID OVERFLOW OCCUR\n         AH    R0,=H'1'            YES-BUMP 1ST REG\n         DR    R0,R3               GET NORMALIZED SIZE\n         ST    R1,0(R4)            STORE NORMALIZED ENTRY\n         LA    R4,4(R4)            BUMP TO NEXT ARRAY ELEMENT\n         BCT   R2,EODNORM          LOOP\nEODMAXOK DS    0H\n*        CALC JOB AVGS\n         LA    R2,JT#              GET # OF JOBS\nEODJTAVG DS    0H\n         LA    R3,JT#              GET # OF JOBS\n         SR    R3,R2               GET INDEX FROM 0,1,2...\n         SLL   R3,2                4 BYTES PER COUNTER\n*        AVG DEFER TIME BY JOB\n         L     R1,DVJTDFRT(R3)     GET THIS JOB\n         L     R15,DVJTSIO1(R3)    GET # OF DEFERS\n         MH    R15,=H'10'          ADJUST FOR *10\n         BAL   R14,DIVIDER         DIVIDE/ROUND\n         ST    R1,DVJTDFRT(R3)     STORE\n*        AVG I/O TIME FOR A JOB\n         L     R1,DVJTIOTM(R3)     GET THIS JOB\n         L     R15,DVJTSIO0(R3)    GET # OF IOS\n         MH    R15,=H'10'          ADJUST FOR *10\n         BAL   R14,DIVIDER         DIVIDE/ROUND\n         ST    R1,DVJTIOTM(R3)     STORE\n*        AVG SEEK FOR A JOB\n         L     R1,DVJTSEEK(R3)     GET CYLS SEEKED\n         L     R15,DVJTSIO0(R3)    GET IOS\n         BAL   R14,DIVIDER         DIVIDE\n         ST    R1,DVJTSEEK(R3)     STORE AVG CYL\n         BCT   R2,EODJTAVG         RE-DO AVGS FOR NEXT JOB\n*        SETUP HDR\n         LA    R1,HDR1             GET HEADER\n         MVC   HDRUCB,DVUCB        SET UCB ADDR IN HDR\n         MVC   HDRTYPE,DVTYPE      SET TYPE (3330)\n         MVC   HDRVOLI,DVVOLI      SET VOLID\n*              XLATE UCBSTAB                                   28OCT79\n         MVC   HDRSTAB,=CL4'PRIV'                              28OCT79\n         TM    DVSTAB,UCBBPRV      PRIVATE                     28OCT79\n         BO    EODPUTDD            YES-TEST DUAL DENS          06NOV84\n*                                                              28OCT79\n         MVC   HDRSTAB,=CL4'STOR'                              28OCT79\n         TM    DVSTAB,UCBBSTR      STORAGE                     28OCT79\n         BO    EODPUTDD            YES-TEST DUAL DENS          06NOV84\n*                                                              28OCT79\n         MVC   HDRSTAB,=CL4'PUB '                              28OCT79\n         TM    DVSTAB,UCBBPUB      PUBLIC                      28OCT79\n         BO    EODPUTDD            YES-TEST DUAL DENS          06NOV84\nEODPUTDD DS    0H                                              06NOV84\n         TM    DVFLAG1,DVF1DD      DUAL DENSITY                06NOV84\n         BZ    EODPUTHD            NO-PRINT HEADER             06NOV84\n         MVC   HDRVOLI2,DVVOLI2    SET VOLID SECONDARY VOLSER  06NOV84\n         MVC   HDRVOL2X,=C'(-)'    SHOW MINUS                  06NOV84\n*              XLATE UCBSTAB                                   06NOV84\n         MVC   HDRSTAB2,=CL4'PRIV'                             06NOV84\n         TM    DVSTAB2,UCBBPRV     PRIVATE                     06NOV84\n         BO    EODPUTHD            YES-PRINT HDR               06NOV84\n*                                                              06NOV84\n         MVC   HDRSTAB2,=CL4'STOR'                             06NOV84\n         TM    DVSTAB2,UCBBSTR     STORAGE                     06NOV84\n         BO    EODPUTHD            YES-PRINT HDR               06NOV84\n*                                                              06NOV84\n         MVC   HDRSTAB2,=CL4'PUB '                             06NOV84\n         TM    DVSTAB2,UCBBPUB     PUBLIC                      06NOV84\n         BO    EODPUTHD            YES-PRINT HDR               06NOV84\nEODPUTHD DS    0H                                              28OCT79\n         BAL   R14,PUT             SKIP TO CH 1\n         LA    R0,(DVSIO1XE-DVSIO1XS)/(DVSIO1XL) # ENTRIES\n         LA    R14,DVSIO1XS        START\n         LA    R15,EODSIO1S        MODIFY HEADERS WITH PRINTABLE HEX\nEODXCONV DS    0H\n         UNPK  5(5,R15),DVSIO1XS-DVSIO1XS(L'DVSIO1XS+1,R14) 0-F=F0-FF\n         MVI   9(R15),C' '         BLANK LAST BYTE\n         TR    5(4,R15),TRTAB-240  XLATE TO PRINTABLE\n         LA    R14,DVSIO1XL(R14)   NEXT ENTRY\n         LA    R15,(EODCNT1-EODCNTS)(R15) NEXT HEADER\n         BCT   R0,EODXCONV\n         LA    R2,(EODCNTE-EODCNTS)/(EODCNT1-EODCNTS)  GET # TOTS\n         LA    R3,EODCNTS          GET START OF DEV. TOTS\n         BAL   R14,CLRPL           BLANK PRINT LINE\n         L     R1,@PL              GET PRINT LINE\n         MVI   0(R1),C'0'          DBL SPACE\n         ST    R11,UTEODBAS        STORE BASING FOR TABLE\n         BAL   R14,UTEODB          FORMAT DATA\n         BAL   R14,CLRPL           CLEAR PRINT LINE\n         L     R1,@PL              GET PRINT LINE\n         CLI   PRTOPT,C'H'         HISTOGRAM\n         BE    EODPRTHS            YES-GOTO SUBROUTINE\n         MVC   0(L'HDR2,R1),HDR2   GET 2ND HEADER\n         BAL   R14,PUT             PRINT IT\n         BAL   R14,CLRPL           CLEAR PRINT\n         L     R1,@PL              GET PRINT LINE\n         MVC   1(9,R1),=C'    TRACK' SET UP ARRAY LINES\n         LH    R2,DVSLOTS          GET # OF PRINT SLOTS\n         LR    R5,R1               GET ADDR OF PRINT LINE\n         AH    R5,LINEOFST         BUMP TO START OF ARRAY DATA\nEODHDR2  DS    0H                  DISPLAY SLOT # IN HDR\n         LR    R0,R2               GET COUNT DOWN CTR\n         SH    R0,DVSLOTS          SUBTRACT MAX. (0,-1,-2,..MAX)\n         CVD   R0,WD               MAKE PACKED\n         MVC   WE,MASK             SET MASK\n         ED    WE,WD+2             EDIT IT IN (NO SIGN DISPLAYED)\n         EX    0,EXMVC             MOVE IT IN PRINT LINE\n         AH    R5,STMAXDSP         NEXT SLOT ADDR IN PRT LINE\n         BCT   R2,EODHDR2          LOOP\n         BAL   R14,PUT             PRINT ARRAY HEADER\n         BAL   R14,CLRPL           CLEAR PRINT LINE\n         L     R1,@PL              GET PRT LINE ADDR\n         BAL   R14,PUT             PRINT A BLANK LINE\n         LA    R4,DVXREF           GET START OF ARRAY\n         LH    R3,DVSLOTS          GET # OF SLOTS\nEODNXT   DS    0H                  PRINT A ROW OF DEV ARRAY\n         LR    R0,R3               GET CURRENT DOWN CTR\n         SH    R0,DVSLOTS          - MAX = NEG SLOT #\n         CVD   R0,WD               PACKED\n         L     R1,@PL              GET PRINT LINE\n         MVC   PLSLOT(,R1),=X'40212020' SET EDIT MASK\n         ED    PLSLOT(,R1),WD+6    SET SLOT # (NO SIGN SHOWN)\n         MH    R0,DVDELTA          GET # OF CYLS IN A SLOT\n         MH    R0,DVTRK            * # OF TRK IN A CYL\n         CVD   R0,WD               MAKE PACKED\n         MVC   PLTRACK(6,R1),=X'402021202020' SET EDIT MASK\n         ED    PLTRACK(6,R1),WD+5  EDIT STARTING TRACK # IN\n         LR    R5,R1               GET START OF PRINT LINE\n         AH    R5,LINEOFST         ADD OFFSET TO START OF ARRAY DATA\n         LH    R2,DVSLOTS          GET # OF SLOTS ON PRT LINE\nEODROW   DS    0H                  RUN THRU ALL COL. IN A ROW\n         L     R0,0(R4)            GET COUNTER\n         LTR   R0,R0               IS COUNT ZERO\n         BZ    EODZERO             YES-SPECIAL CASE\n         CVD   R0,WD               NO-MAKE PACKED\n         MVC   WE,MASK             SET EDIT MASK\n         ED    WE,WD+2             EDIT IT IN\nEODMVC   DS    0H                  MOVE COUNT FROM WORK AREA\n         EX    0,EXMVC             MOVE SPECIFIED DIGITS IN\nEODBUMP  DS    0H                  NEXT COL. IN A ROW\n         LA    R4,4(R4)            BUMP TO NEXT CTR\n         AH    R5,STMAXDSP         BUMP SLOT ADDR IN PRT LINE\n         BCT   R2,EODROW           NEXT COLUMN IN ROW\n         L     R1,@PL              GET PRT LINE\n         BAL   R14,PUT             PRINT WHOLE ROW\n         BCT   R3,EODNXT           LOOP FOR NEXT ROW\n         B     EODJPRNT            PRINT JOB INTERFERENCE RPT\n**       PRINT SEEK ADDRESSES IN HISTOGRAM FORMAT\nEODPRTHS DS    0H\n         LH    R3,MAXCYL           SET UP LOOP FOR EACH CYLINDER\n         LA    R4,DVXREF           CYL ZERO CTR\n         BAL   R14,CLRPL           CLEAR PRINTLINE\n         XC    DSCUMIO,DSCUMIO     CLEAR CUMULATIVE IO CTR     06NOV84\n         L     R1,@PL\n         MVC   0(33,R1),=C'0   TRACK E CUM_I/O  DATASET_NAME'  06NOV84\n         MVI   PLEXTNT(R1),C'X'    EXTENT ID                   06NOV84\n         BAL   R14,PUT\n         BAL   R14,CLRPL           CLEAR LINE                  15OCT79\nEODRNXH  DS    0H\n         CLC   =F'0',0(R4)         NULL CTR?\n         BE    EODRNXCY            YES-NEXT CYLINDER\n         L     R1,@PL\n         LR    R0,R3               GET COUNT DOWN CTR\n         SH    R0,MAXCYL           TURN IT INTO COUNT UP (NEG\n         MH    R0,DVTRK            CALC STARTING TRACK #\n         LPR   R2,R0               SAVE REL. TRK #  (POSITIVE  15OCT79\n         LR    R0,R2               SAVE REL. TRK #  (POSITIVE  06NOV84\n         TM    DVFLAG1,DVF1DD      DUAL DENSITY                06NOV84\n         BZ    EODRNXT             NO-CONTINUE                 06NOV84\n         LH    R14,DVCYL           GET DEV. MAX CYL            06NOV84\n         SRL   R14,1               1/2                         06NOV84\n         MH    R14,DVTRK           *TRKS/CYL                   06NOV84\n         SR    R0,R14              GET (-/+) CYL OFFSET        06NOV84\n         BP    EODRNXT             PRIMARY VOLUME              06NOV84\n         AH    R0,DVTRK            START SECONDARY AT \"0-\"     06NOV84\n         MVI   PLCYLERR(R1),C'-'   SHOW SECONDARY              06NOV84\n         LPR   R0,R0               GET POSITIVE TRK            06NOV84\nEODRNXT  DS    0H                                              06NOV84\n         CVD   R0,WD               PRINT IT\n         MVC   PLTRACK(L'PLTRACK,R1),=X'40202120202020' MASK   06NOV84\n         ED    PLTRACK(L'PLTRACK,R1),WD+5 TRACK OFFSET         06NOV84\n*                                                              15OCT79\n**       GET DSN OF D.S. ON 1ST TRACK OF CYL                   15OCT79\n*                                                              15OCT79\n         SLL   R2,1                *2 - 2BYTE TABLE ENTRY      15OCT79\n         A     R2,DVDSNO           DVDSNO IS A TABLE OF        15OCT79\n*                                  OFFSETS -2BYTES FOR EVERY   15OCT79\n*                                  TRACK ON PACK.              15OCT79\n         XR    R14,R14                                         15OCT79\n         ICM   R14,3,0(R2)         GET OFFSET INTO DVDSNT      15OCT79\n         BZ    EODRNXH1            NO OFFSET - LEAVE BLANK     15OCT79\n         A     R14,DVDSNT          ADD TO BASE TO GET DSN ENT. 15OCT79\n*                                  A DSN ENTRY IS:             15OCT79\n*                                   1BYTE TRUE LENGTH OF DSN   15OCT79\n*                                   VAR. BYTE DSN              15OCT79\n         L     R1,@PL              GET PRINTLINE               15OCT79\n         MVC   PLEXTNT(1,R1),1(R14) MOVE EXTENT ID BLANK,1-F   15OCT79\n         XR    R1,R1                                           15OCT79\n         IC    R1,0(R14)           GET DSN LENGTH              15OCT79\n         LA    R0,2(R14)           GET DSN ADDR                15OCT79\n         L     R14,@PL             GET PRINT LINE              15OCT79\n         LA    R14,PLDSN(R14)      SKIP TO DSN ADDR            15OCT79\n         LR    R15,R1              COPY LENGTH OF DSN          15OCT79\n         MVCL  R14,R0              MOVE DSN IN                 15OCT79\nEODRNXH1 DS    0H                                              15OCT79\n*                                                              15OCT79\n**             SEE IF D.S. TAKES   WHOLE CYLINDER              15OCT79\n*                                                              15OCT79\n         LH    R0,DVTRK            TRKS/CYL                    15OCT79\n         ICM   R1,3,0(R2)          GET OFFSET FOR 1ST TRK D.S  15OCT79\nEODRNXCK DS    0H                  MAKE SURE ALL TRKS ON CYL   15OCT79\n         CLM   R1,3,0(R2)           HAVE SAME OFFSET OR ZERO   15OCT79\n         BNE   EODRNXCB            NO-MARK MULTI-D.S. CYL      15OCT79\nEODRNXCL DS    0H                  RESTART POINT IF NO D.S.    15OCT79\n         LA    R2,2(R2)            NEXT TRACK DSN OFFSET       15OCT79\n         BCT   R0,EODRNXCK         LOOP THRU CYLINDER          15OCT79\n         B     EODRNXCX            ALL TRACK HAVE SAME D.S.    15OCT79\nEODRNXCB DS    0H                                              15OCT79\n         OC    0(2,R2),0(R2)       FREE TRACK?                 15OCT79\n         BZ    EODRNXCL            DONT MARK-D.S. IS ONLY USR  15OCT79\n         L     R1,@PL              PRINT LINE                  15OCT79\n         MVI   PLCYLERR(R1),C'$'   SHOW MULTI-D.S. CYL         15OCT79\nEODRNXCX DS    0H                  DONE                        15OCT79\n*              SHOW CUMULATIVE IOS                             06NOV84\n         L     R1,@PL              GET PRINT LINE              06NOV84\n         L     R0,DSCUMIO          GET IO HITS SO FAR          06NOV84\n         A     R0,0(R4)             PLUS THIS CYL              06NOV84\n         ST    R0,DSCUMIO            SAVE                      06NOV84\n         CVD   R0,WD               MAKE PRINTABLE              06NOV84\n         MVC   PLCUMIO(L'PLCUMIO,R1),=X'4020202020202120'      06NOV84\n         ED    PLCUMIO(L'PLCUMIO,R1),WD+4                      06NOV84\n*                                                              06NOV84\n         L     R1,0(R4)            GET CYL COUNT\n         LH    R0,LINESIZE         CALC # OF AVALIABLE PRINT POS.\n         SH    R0,LINEOFST         # = LINESIZE-STARTING OFFSET\n         STH   R0,WD\n         MH    R1,WD               R1=(SEEK COUNT)*(MAX PRINT POS.)\n         L     R15,DVMAXHIT        HIGHEST SEEK COUNT FOR THIS PACK\n         BAL   R14,DIVIDER\n*        R1=# OF ASTERISKS FOR NORMALIZED COUNTER\n**       NOW MOVE ASTERISKS INTO PRINT LINE\n         XR    R15,R15             FROM LEN=0\n         ICM   R15,8,=C'*'         FILL CHAR=C'*'\n         XR    R14,R14             FROM ADDR=0\n         L     R0,@PL              TO ADDR\n         AH    R0,LINEOFST         \"\n         MVCL  R0,R14              INSERT ASTERISKS\n         L     R1,@PL\n         BAL   R14,PUT\n         BAL   R14,CLRPL           BLANK PRINT LINE\nEODRNXCY DS    0H\n         LA    R4,4(R4)            NEXT CYL CTR\n         BCT   R3,EODRNXH          LOOP THRU ALL CYLINDERS\nEODJPRNT DS    0H\n*        PRINT JOB TOTALS FOR A DEVICE\n         LA    R6,JTPRT2#          GET NUMBER OF JOB LINES\n         LA    R4,DVJTXREF         GET START OF ARRAY\n         BAL   R14,CLRPL           CLEAR PRINT LINE\n         L     R1,@PL              GET PRT LINE ADDR\n         BAL   R14,PUT             PRINT IT\n*        PUT   JOBNAMES IN COLUMNS                             06NOV84\n         LA    R2,JT#              GET # JOBNAMES              06NOV84\n         LA    R14,JOBS            START OF TABLE              06NOV84\n         L     R1,@PL              PRINT LINE                  06NOV84\n         LA    R5,PLJSTART(R1)     START OF ARRAY IN PRT LINE  06NOV84\nEODJTIT  DS    0H                  NEXT TITLE JOBNAME          06NOV84\n         MVC   0(L'JOBSNAM,R5),(JOBSNAM-JOBS)(R14) COL TITLES  06NOV84\n         LA    R14,JOB1-JOBS(R14)  NEXT JOBNAME                06NOV84\n         AH    R5,STJOBDSP         NEXT COLUMN                 06NOV84\n         BCT   R2,EODJTIT           DOIT                       06NOV84\n         BAL   R14,PUT             PRINT IT                    06NOV84\nEODJNXT  DS    0H                  PRT JOB + NAMES WHO HELD HIM UP\n         BAL   R14,CLRPL           CLEAR PRINT LINE\n         L     R1,@PL              GET PRT LINE ADDR\n         LA    R14,JTPRT2#         GET # OF JOB LINES\n         SR    R14,R6              GET INDEX TO CURRENT JOB\n         MH    R14,=AL2(JOB1-JOBS) GET OFFSET TO ROW LIT.\n         LA    R14,JOBS(R14)       + BASE ADDR = START OF LIT.\n         MVC   PLJNAM(L'JOBSNAM,R1),(JOBSNAM-JOBS)(R14) NAME   06NOV84\n         LA    R5,PLJSTART(R1)     GET START OF ARRAY IN PRT LINE\n         LA    R2,JT#              GET # OF JOBS MONITORED\nEODJROW  DS    0H                  PRINT A ROW\n         L     R0,0(R4)            GET INTERFERENCE COUNT\n         CVD   R0,WD               MAKE PACKED\n         MVC   WE,MASK             SET EDIT MASK\n         ED    WE,WD+2             EDIT IT\n         EX    0,EXMVC3            MOVE DATA INTO PRT LINE\n         LA    R4,4(R4)            NEXT CTR\n         AH    R5,STJOBDSP         NEXT SLOT IN PRT LINE\n         BCT   R2,EODJROW          GET NEXT COLUMN\n         BAL   R14,PUT             PRINT A ROW\n         BCT   R6,EODJNXT          NEXT JOB\n         B     EODLOOP             NEXT DASD DEVICE\nEODZERO  DS    0H                  SPECIAL CASE OF DASD SIO ZERO\n         CR    R2,R3               IS ZERO ON DIAGONAL\n         BE    EODPLUS             YES - MARK DIAGONAL W/ +\n         MVC   WE,=C'           .' ELSE MARK NULLS W/ PERIODS\n*        IDEA IS TO MAKE COLUMNS HAVE PERIODS DOWN THEM\n*         AND DIAGONAL TO HAVE PLUSES.\n         B     EODMVC              MOVE DATA IN PRT LINE\nEODPLUS  DS    0H                  SET DATA TO PLUS\n         MVC   WE,=C'           +' SET WORK AREA TO PLUS\n         B     EODMVC              MOVE DATA IN PRT LINE\nEODJOB   DS    0H                  EOJ\n         NOPR  0            TEST   MAKE A DC H'0' FOR DUMP\n         LA    R15,0               SET RC\n*        SOMEDAY IM GOING TO CLOSE FILES AND FREE GOTTEN CORE\n         @RET  EQ,RC=0,FREE=NO     RETURN TO O/S\n         POP   USING               GO BACK TO NORMAL           15OCT79\n         TITLE 'C O M M O N   U T I L I T I E S '\nUTSUBS   DS    0D\n*************************************************************\n*         LOCATE DEVICE ENTRY FROM CHAN. ADDR\n*************************************************************\n**INPUT: R11=X'00000CUU' ADDRESS/XA:DEVICE #\n**OUTPUT:R11=UCB ADDR IF UTGETUCB ENTRY\n**       R11=UCB ADDR IF UTGET    ENTRY\n**WORK:  R15,R0-R3\n**RETURN:R14+0=NOT FOUND, R14+4=FOUND\n*************************************************************\nUTGETUCB DS    0H                  ONLY GET UCB ADDR\n         MVI   DSAUCBO,C'Y'            Y=ONLY GET UCB ADR      20SEP84\n         B     UTGETC                  CONTINUE                20SEP84\nUTGET    DS    0H                  ENTRY\n         MVI   DSAUCBO,C'N'            N=GET DEVICE ENTRY-R11  20SEP84\nUTGETC   DS    0H                  CONTINUE\n         ST    R14,UTGETSAV        SAVE RETURN\n         LR    R14,R11             COPY ADDR\n         SRDL  R14,8               PUT CU/DEV ADDR IN R15\n         SRL   R15,28              PUT CU/DEV IN LOW END\n         L     R1,CVTPTR           CVT\n         CLI   DSAXA,DSAXAYES          XA?                     20SEP84\n         BE    UTGETXA                 YES-GOTO XA ROUTINE     20SEP84\n*                                                              15OCT79\n**       THIS CODE GOTTEN FROM IECIOSCN                        15OCT79\n*                                                              15OCT79\n         L     R1,CVTILK1(R1)      LOOKUP 1\n         XR    R3,R3               CLEAR\n         IC    R3,0(R14,R1)        GET CHANNEL INDEX\n         ALR   R15,R3              ADD CU/DEV\n         ALR   R15,R15             TIMES 2\n         LR    R3,R11              GET A FRESH COPY OF ADDR\n         N     R3,=F'15'           MASK OFF CHAN/CU\n         AH    R3,0(R15,R1)        ADD DEVICE INDEX\n         ALR   R3,R3               DOUBLE\n         L     R1,CVTPTR           CVT\n         L     R1,CVTILK2(R1)      LOOKUP 2\n         LH    R14,0(R1,R3)        GET UCB ADDR\n         N     R14,=X'0000FFFF'    MASK OFF IF OVER 32K\n         LR    R11,R14             COPY TO OUTPUT REG\nUTGETXAC DS    0H                      XA-CONTINUE POINT       20SEP84\n         L     R1,UTGETSAV         GET RETURN ADDR\n         LTR   R11,R11             UCB HOLE ENTRY?\n         BZR   R1                  YES-RET +0 - UCB NOT FOUND\n         CLI   UCBDVCLS(R11),X'20' DASD DEVICE RECORD          15OCT79\n         BNER  R1                  NO-RETURN +0 N.F.           15OCT79\n         TM    UCBSTAT(R11),X'80'  DASD ONLINE                 15OCT79\n         BO    UTGEND1             YES-CONTINUE                15OCT79\n         BR    R1                  LET THRU                    15OCT79\n******** ***** *********************** *********************** 20SEP84\n******** ***** *********************** *********************** 20SEP84\nUTGETXA  DS    0H                      XAXAXAXAXAXAXAXAXAXAXA  20SEP84\n*                                                              20SEP84\n**             CANT USE MACRO SINCE SUPERVISOR TEST IMBEDDED   20SEP84\n*                                                              20SEP84\n*        IOSLOOK UCB=(R2),DEV=(R11)     RC=0=OK, 4=INVALID\nIECIUPRM EQU   1                   PARM REG - UCB RETURNED\nIECIUDEV EQU   6                   DEVICE ADDRESS\nIECIUSAV EQU   13                  SAVE AREA PTR\nIECIURTN EQU   14                  RETURN ADDRESS\nIECIUR15 EQU   15                  BRANCH ADDR AND RETURN CODE\n         MVC   DSAPREFX,0(R13)         SAVE SAVEAREA PREFIX    20SEP84\n         STM   0,15,0(IECIUSAV)               SAVE REGS\n         LR    IECIUDEV,R11                   GET DEVICE ADDR\n*                                             *FROM CALLER\n         L     IECIUR15,CVTPTR                GET CVTPTR\n         L     IECIUR15,CVTIXAVL-CVT(0,IECIUR15) GET IOCM PTR\n         L     IECIUR15,IOCGENA-IOCOM(0,IECIUR15) GET IECVGENA PTR\n*        BAL   IECIURTN,12(0,IECIUR15)         CALL IECVGENA\n         L     R0,12(0,IECIUR15)       GET BRANCH INSTR        20SEP84\n         N     R0,=X'00000FFF'         GET OFFSET              20SEP84\n         LR    R14,R15                 COPY IECVGENA BASE      20SEP84\n         AR    R14,R0                  ADD OFFSET              20SEP84\n         XR    R2,R2                   WORK REG                20SEP84\n*SOME ASS PUT A SUPERVISOR INSTRUCTION IN THE CODE JUST TO     20SEP84\n*        TRIP UP MORTAL CALLERS, SO SKIP IT!                   20SEP84\n         LA    R0,8                    TRY TO SKIP SUPVR TEST  20SEP84\nUTGETXAS DS    0H                                              20SEP84\n         CLI   0(R14),X'18'            LR INSTR AFTER TEST?    20SEP84\n         BE    CALLGENA                YES-GO                  20SEP84\n         LA    R14,2(R14)              NEXT INSTR SLOT         20SEP84\n         BCT   R0,UTGETXAS             TRY AGAIN               20SEP84\n         WTO   'IECVGENA CODE BYPASS FAILED',ROUTCDE=(11)      20SEP84\n         ABEND 123                     RATS                    20SEP84\nCALLGENA BALR  R14,R14                 GO TO IOSVLOOK          20SEP84\n         ST    IECIUPRM,(R11)*4(0,IECIUSAV) SET UCB ADDR RETND\n*                                       IN SAVEAREA REGISTER\nIECIU003 LM    0,14,0(IECIUSAV)               RESTORE REGS\n         MVC   0(12,R13),DSAPREFX      RESTORE SAVE PREFIX     20SEP84\n         B     UTGETXAC                GOTO COMMON CODE        30APR84\n******** ***** *********************** *********************** 20SEP84\nABEND5   DS    0H                                              15OCT79\n         WTO   'TSGTFMAP-GTF RECORD FOR OFFLINE DASD',ROUTCDE=(11)\n         ABEND 5,DUMP                                          15OCT79\nUTGEND1  DS    0H                  UCB LOCATED IN R11\n         CLI   DSAUCBO,C'Y'            ONLY GET UCB?           20SEP84\n         BE    4(R1)                   YES-EXIT W/ R11=UCB     20SEP84\n         L     R14,DVVROOT         GET START OF VECTOR TABLE\n         USING DVVTAB,R14          TELL ASM\nUTGLOOP  DS    0H                  FIND SAME UCB PTR\n         CLI   0(R14),X'FF'        END OF VECTOR TABLE\n         BER   R1                  YES-RETURN?????\n         C     R11,DVVUCB          FIND SAME UCB PTR\n         BE    UTGFND              FOUND\n         LA    R14,DVVSIZ(R14)     BUMP TO NEXT VECTOR ENTRY\n         B     UTGLOOP             TRY AGAIN\nUTGFND   DS    0H                  FOUND IT\n         L     R11,DVVPTR          GET PTR TO DEVICE TABLE\n         B     4(R1)               RETURN +4 = GOOD DEV\n         DROP  R14                     TELL ASM                20SEP84\n******** CALC DEFERED TIME\nUTDEFR   DS    0H                  CALC DEFER TIME\n         ST    R14,UTDEFRSV        SAVE RETURN\n         OC    DVDEFRTM,DVDEFRTM   WAS THERE A BUSY BEFORE\n         BZ    UTDEFRET            NO-NEXT PHASE\n         LM    R2,R3,DVDEFRTM      GET TIME OF SIO-BUSY\n         ICM   R0,15,GTTIME        GET I/O INTERRUPT TIME\n         ICM   R1,15,GTTIME+4      GET I/O INTERRUPT TIME\n         BAL   R14,UTTIMDIF        GO CALC DIF IN MILLISEC*10\n         C     R1,DVDEFRMX         COMPARE TO MAX SO FAR\n         BL    *+8                 LO-SKIP UPDATE\n         ST    R1,DVDEFRMX         STORE NEW LIMIT\n         LR    R0,R1               SAVE DEFER\n         AL    R1,DVDEFRIO         ADD TO DEFER TIME SO FAR\n         ST    R1,DVDEFRIO         STORE\n         LH    R15,DVLJOBI         GET INDEX TO LAST SIO JOB\n         AL    R0,DVJTDFRT(R15)    ADD TO TOTAL DEFER TIME\n         ST    R0,DVJTDFRT(R15)    STORE\n         XC    DVDEFRTM,DVDEFRTM   RESET LAST BUSY TIME\nUTDEFRET DS    0H                  RETURN\n         L     R14,UTDEFRSV        GET RETURN\n         BR    R14                 RETURN\n******** DEV RESERVE TIME                                      28OCT79\nUTRESV   DS    0H                                              28OCT79\n         ST    R14,UTDEFRSV        SAVE RETURN                 28OCT79\n         OC    DVLRESTM,DVLRESTM   WAS THERE A RESERVE BEFORE  28OCT79\n         BZ    UTRESRET            NO-STRANGE (MAYBE STARTUP   28OCT79\n         LM    R2,R3,DVLRESTM      GET TIME OF RESERVE         28OCT79\n         ICM   R0,15,GTTIME        GET I/O INTERRUPT TIME      28OCT79\n         ICM   R1,15,GTTIME+4      GET I/O INTERRUPT TIME      28OCT79\n         BAL   R14,UTTIMDIF        GO CALC DIF IN MILLISEC*10  28OCT79\n         AL    R1,DVAVGRES         ADD TO RESERVE TIME SO FAR  28OCT79\n         ST    R1,DVAVGRES         STORE                       28OCT79\nUTRESRET DS    0H                  RETURN                      28OCT79\n         L     R14,UTDEFRSV        GET RETURN                  28OCT79\n         BR    R14                 RETURN                      28OCT79\n*                                                              06NOV84\n******** SEE IF ADDR IN R11 IS A DUAL DENSITY DISK             06NOV84\n*                                                              06NOV84\nUTDDTST  DS    0H                  SEE IF DUAL DENSITY ADDR    06NOV84\n         ST    R11,WD              SAVE ADDR                   06NOV84\n         STCM  R14,7,WD+5          SAVE RETURN                 06NOV84\n         LA    R14,DDMAP           GET LIST OF DUAL VOLUME AD  06NOV84\n         SRL   R11,4               GET CHAN,CU ADDR IN A BYTE  06NOV84\n         STC   R11,WD+4            SAVE IT                     06NOV84\nUTDDLOOP DS    0H                                              06NOV84\n         CLC   WD+4(1),0(R14)      HIT?                        06NOV84\n         BE    UTDDHIT             YES                         06NOV84\n         BL    UTDDMISS            TABLE IN SEQUENCE,NO HIT    06NOV84\n         LA    R14,1(R14)          NEXT CHAN,CUA               06NOV84\n         B     UTDDLOOP            LOOP                        06NOV84\nUTDDHIT  DS    0H                                              06NOV84\n         L     R11,WD              RESTORE                     06NOV84\n         ICM   R14,7,WD+5                                      06NOV84\n         B     4(R14)              RETURN +4 = HIT(DUAL DENS)  06NOV84\nUTDDMISS DS    0H                                              06NOV84\n         L     R11,WD              RESTORE                     06NOV84\n         L     R14,WD+4                                        06NOV84\n         BR    R14                 RETURN +0 = NOHIT           06NOV84\n*                                                              06NOV84\n******** CLEAR PRINT LINE TO BLANKS\n*                                                              06NOV84\nCLRPL    DS    0H                  CLEAR PRINT LINE\n         L     R0,@PL              ADDR OF PRT LINE\n         LH    R1,LINESIZE         GET LINE SIZE\n         L     R15,=X'40000000'    SET FILL CHAR TO BLANK\n         MVCL  R0,R14              MOVE BLANKS IN\n         BR    R14                 RETURN\n*                                                              06NOV84\n******** FIND JOB INDEX FOR A GTF RECORD\n*                                                              06NOV84\nUTFNDJOB DS    0H                  FIND A JOB INDEX\n         LA    R3,JOBS             GET JOB NAME TABLE\n         LA    R2,JT#              GET # OF ENTRIES\n         XR    R15,R15             CLEAR\nUTFNDJB  DS    0H                  LOCATE JOB WHO CAUSED PROBLEM\n         IC    R15,JOBS#CHR-JOBS(R3)  GET L'-1 OF JOBNAME\n         EX    R15,UTFNDCLC        FOUND JOBNAME?\n         BE    UTFNDSIO            YES\n         LA    R3,(JOB1-JOBS)(R3)  NO - BUMP TO NEXT\n         BCT   R2,UTFNDJB          LOOP\n         SH    R3,=AL2(JOB1-JOBS)  NOT FOUND - BACK UP 1 ENTRY\n         LA    R2,1                ADJUST LOOP REG\nUTFNDSIO DS    0H                  NOW UPDATE ARRAY ENTRY\n         LA    R0,JT#              MAX JOBNAMES\n         SR    R0,R2                -LOOP REG = JOB #\n         SLL   R0,2                EACH COUNTER IS 4 BYTES\n         STH   R0,DVCJOBI          STORE AS CURRENT JOB INDEX\n         BR    R14                 RETURN\nUTFNDCLC CLC   JOBSNAM-JOBS(0,R3),GTJOB\n*        DISPLAY BINARY TOTALS FROM TABLE\nUTEODB   DS    0H                  PRINT DEVICE TOTS\n         ST    R14,UTEODSAV        SAVE RETURN\nUTEODB2  DS    0H\n         L     R1,@PL              GET ADDR OF PRINT LINE\n         LH    R14,L'EODCNTS(R3)   GET OFFSET TO TOT CTR.\n         A     R14,UTEODBAS        GET ADDR OF CTR\n         L     R14,0(R14)          GET CTR\n         CVD   R14,WD              MAKE PACKED\n         MVC   1+L'MASK2+1(L'EODCNTS,R1),0(R3) MOVE TOT NAME   06NOV84\n         MVC   1(L'MASK2,R1),MASK2 MOVE EDIT MASK\n         CLI   1+L'MASK2+1+L'EODCNTS-1(R1),C'$' SPECIAL EDIT   06NOV84\n         BNE   UTEODB3             NO                          06NOV84\n         MVI   1+L'MASK2+1+L'EODCNTS-1(R1),C' ' CLEAR ID       06NOV84\n         MVC   1(L'MASK2,R1),MASK3 MOVE EDIT MASK              06NOV84\nUTEODB3  DS    0H                                              06NOV84\n         ED    1(L'MASK2,R1),WD+4  EDIT TOT IN\n         MVI   1+L'MASK2(R1),C'='  SET =\n         BAL   R14,PUT             PRINT DEV TOTAL\n         BAL   R14,CLRPL           CLEAR AND SET SINGLE SPACE\n         LA    R3,L'EODCNTS+2(R3)  BUMP TO NEXT TOT DESC. SET\n         BCT   R2,UTEODB2          LOOP\n         L     R14,UTEODSAV        RESTORE SAVE\n         BR    R14                 RETURN\n*                                                              DDMMM84\n******** CLEAR A SECTION OF CORE\n*                                                              DDMMM84\nCLRIT    DS    0H                  CLEAR\n         XR    R0,R1               SWAP REGS 1 AND 0\n         XR    R1,R0               \"\n         XR    R0,R1               \"\n         XR    R15,R15             CLEAR R15\n         MVCL  R0,R14              PAD WHOLE THING W/ ZEROS\n         BR    R14                 RETURN\n*                                                              DDMMM84\n******** DISPLAY PACKED TOTALS FROM TABLE\n*                                                              DDMMM84\nUTEODP   DS    0H                  DISPLAY TOTALS\n         ST    R14,UTEODSAV        SAVE RETURN\nUTEODP2  DS    0H\n         L     R1,@PL              GET OUTPUT PLINE ADDR\n         LH    R14,L'PRTCNTS(R3)   GET OFFSET FROM STRT OF CTRS\n         LA    R14,PACKS(R14)      GET ADDR OF CTRS\n         MVC   1(L'MASK2,R1),MASK2 MOVE EDIT MASK\n         ED    1(L'MASK2,R1),0(R14) EDIT CTR IN\n         MVI   1+L'MASK2(R1),C'='  FORMAT CTR COUNTS\n         MVC   1+L'MASK2+1(L'PRTCNTS,R1),0(R3) MOVE CTR NAME IN\n         BAL   R14,PUT             PUT OUT COUNTER\n         BAL   R14,CLRPL           CLEAR AND SINGLE SPACE\n         LA    R3,L'PRTCNTS+2(R3)  BUMP TO NEXT LITERAL/OFFSET SET\n         BCT   R2,UTEODP2          DO NEXT TOTAL COUNT\n         L     R14,UTEODSAV        RESTORE R14\n         BR    R14                 RETURN\n*                                                              DDMMM84\n******** DIVIDE AND ROUND\n*                                                              DDMMM84\nDIVIDER  DS    0H                  DIVIDE R1 BY R15\n         LR    R0,R15              PUT IN R0 FOR HALF ADJUST\n         SRL   R0,1                1/2\n         AR    R1,R0               ADD TO DIVISOR\n*                                                              DDMMM84\n******** DIVIDE WITHOUT ROUND\n*                                                              DDMMM84\nDIVIDE   DS    0H                  DIVIDE W/OUT HALF ADJUST\n         XR    R0,R0               CLEAR\n         LTR   R15,R15             CK DIVIDE BY ZERO\n         BZR   R14                 LEAVE DATA ALONE\n         DR    R0,R15              DIVIDE R1 BY R15 REMANDER=R0\n         BR    R14                 RETURN\n*                                                              DDMMM84\n******** CALC TIME DIFFERENCE FROM 2 TOD FIELDS\n*                                                              DDMMM84\n*        R0,R1 = HIGHER TIME IN TOD FORMAT\n*        R2,R3 = LOWER TIME IN TOD FORMAT\nUTTIMDIF DS    0H                  TIME DIFFERENCE\n         ST    R14,UTTIMSAV        SAVE RETURN ADDR\n         SLR   R1,R3                CALC DIFFERENCE\n         BC    2+1,*+8              \"\n         SH    R0,=H'1'             \"\n         SR    R0,R2                \"\n         SRDL  R0,12                CONVERT TO MICRO SECS\n         L     R15,=F'100'          CONVERT TO MILLISEC*10\n         BAL   R14,DIVIDER         DIVIDE AND ROUND\n         L     R14,UTTIMSAV        GET RETURN\n         BR    R14                 RETURN\n*                                                              DDMMM84\n**       CONVERT TOD CLOCK FORMAT TO ENGLISH                   DDMMM84\n*                                                              DDMMM84\n*INPUT:  STCKSTCK = DATA                                       DDMMM84\n*OUTOUT: STCK     = ENGLISH                                    DDMMM84\n*WORK:   R0,1,14,15                                            DDMMM84\nUTSTCK   DS    0H                                              DDMMM84\n         ST    R14,UTSTCKSV                                    DDMMM84\n         PUSH  PRINT                                           DDMMM84\n         PRINT GEN                                             DDMMM84\n         @STCK CODE                    CALL MACRO              DDMMM84\n         POP   PRINT                                           DDMMM84\n         L     R14,UTSTCKSV                                    DDMMM84\n         BR    R14                                             DDMMM84\n         TITLE '                   S T A T I C  S T O R A G E'\nSTATIC   DS     0H\n@BASE    DC    A(TSGTFMAP)         MAIN BASE ADDR              15OCT79\n@SETUP   DC    A(SETUP)            INIT RTN                    15OCT79\n@EODRTN  DC    A(EODRTN)           EOD-REPORT                  15OCT79\nGET      SYSGET DDNAME=SYSUT1,RECFM=VB,EODAD=GETEOD2,BLKSIZE=4092,     X\n               LRECL=4088\nPUT      SYSPUT DDNAME=SYSPRINT,RECFM=FBA,BLKSIZE=3990,LRECL=133\n*        TABLE FOR COUNTER NAMES AND OFFSETS TO COUNTERS\n*        MAKES EASY TO ADD MORE LATER\n         DS    0H\nEODCNTS  DS    0CL16\n         DC    CL16'TOTAL SIO 0',AL2(DVSIO0-DVTAB)\nEODCNT1  EQU   *\n         DC    CL16'TOTAL SIO 1',AL2(DVSIO1-DVTAB)\n*  **  ** BREAKDOWN OF SIO CC=1 BY 1ST 6 CSW STATUS CODES\nEODSIO1S DS    0CL16               TYPES OF SIO CC=1\n         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+0*DVSIO1XL)\n         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+1*DVSIO1XL)\n         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+2*DVSIO1XL)\n         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+3*DVSIO1XL)\n         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+4*DVSIO1XL)\n         DC    CL16' CSW-XXXX  ',AL2(DVSIO1XS-DVTAB+2+4*DVSIO1XL)\n*  **  ** END OF BREAKDOWN\n         DC    CL16'TOTAL SIO 2',AL2(DVSIO2-DVTAB)\n         DC    CL16'TOTAL SIO 3',AL2(DVSIO3-DVTAB)\n         DC    CL16'TOTAL RESERVES',AL2(DVRESV-DVTAB)          15OCT79\n         DC    CL16'TOTAL RELEASES',AL2(DVRLS-DVTAB)           28OCT79\n         DC    CL16'TOTAL SIOF CC\u00ac=0',AL2(DVSIOFCC-DVTAB)      28OCT79\n         DC    CL16'CYLINDERS SEEKED',AL2(DVTOTCYL-DVTAB)\n         DC    CL16'         AVERAGE',AL2(DVAVGCYL-DVTAB)\n         DC    CL16'AVERAGE IO MSEC',AL2(DVAVGIO-DVTAB)\n         DC    CL16'MAX     IO MSEC',AL2(DVMAXIO-DVTAB)\n         DC    CL16'HIGHEST HIT PT.',AL2(DVMAXHIT-DVTAB)\n         DC    CL16'AVG DEFER MSEC.',AL2(DVDEFRIO-DVTAB)\n         DC    CL16'MAX DEFER MSEC.',AL2(DVDEFRMX-DVTAB)\n         DC    CL16'AVG RESV  MSEC.',AL2(DVAVGRES-DVTAB)       28OCT79\n         DC    CL16'SIO0/SEC       $',AL2(DVSIO0R-DVTAB)       06NOV84\n*                                  NOTE $ USES EDIT W/ DECIMA  06NOV84\nEODCNTE  EQU   *              END OF TABLE\n******\nEOD2CNTS DS    0CL16               STRING DATA FIELDS\n         DC    CL16'TOTAL SIO 0',AL2(STSIO0-STTAB)\nEOD2CNT1 EQU   *\n         DC    CL16'TOTAL SIO 1',AL2(STSIO1-STTAB)\n         DC    CL16'TOTAL SIO 2',AL2(STSIO2-STTAB)\n         DC    CL16'TOTAL SIO 3',AL2(STSIO3-STTAB)\n         DC    CL16'TOTAL RESERVES',AL2(STRESV-STTAB)          28OCT79\n         DC    CL16'AVG IO TIME',AL2(STAVGIO-STTAB)\n         DC    CL16'AVG CYL SEEKED',AL2(STTOTCYL-STTAB)\n         DC    CL16'AVG DEFR TIME ',AL2(STDEFRIO-STTAB)\n         DC    CL16'MAX DEFR TIME ',AL2(STDEFRMX-STTAB)\n         DC    CL16'AVG RESV TIME ',AL2(STAVGRES-STTAB)        28OCT79\n         DC    CL16'ACTIVE DEVICES',AL2(STNUMB-STTAB)\nEOD2CNTE EQU   *\n*\n*        ANOTHER TABLE TO DISPLAY EOJ TOTS BY DEVICE\n         DS    0H\nPRTCNTS  DS    0CL16\n         DC    CL16'TOTAL REC IN',AL2(TOTRECIN-PACKS)\nPRTCNT1  EQU   *\n         DC    CL16'TOTAL SIO',AL2(TOTSIO-PACKS)\n         DC    CL16'TOTAL SIO 0',AL2(TOTSIO0-PACKS)\n         DC    CL16'TOTAL SIO 1',AL2(TOTSIO1-PACKS)\n         DC    CL16'TOTAL SIO 2',AL2(TOTSIO2-PACKS)\n         DC    CL16'TOTAL SIO 3',AL2(TOTSIO3-PACKS)\n         DC    CL16'TOTAL IO ',AL2(TOTIO-PACKS)\n         DC    CL16'TOTAL PCI',AL2(TOTPCI-PACKS)\n         DC    CL16'TOTAL BAD',AL2(TOTBAD-PACKS)\n         DC    CL16'TOTAL BYPASSED',AL2(TOTBYPAS-PACKS)\n         DC    CL16'TOTAL BAD JOB ',AL2(TOTBYP2-PACKS)         15OCT79\n         DC    CL16'TOTAL BAD SEEK',AL2(TOTSIOBD-PACKS)        15OCT79\nPRTCNTE  EQU   *\n*\n*        BINARY FIELDS FOR WHOLE JOB\nPRTBCNTS DS    0CL16\n         DC    CL16'GTF RUN (SECS)',AL2(TOTTM-DSA)\nPRTBCNT1 EQU   *\n         DC    CL16'SIO0/SEC       $',AL2(TOTSIO0R-DSA)\n*              NOTE $ CALLS FOR SPECIAL EDIT                   06NOV84\nPRTBCNTE EQU   *                   END OF FILEDS\n*\n*\n*?       TABLE OF JOBS TO MONITOR CONTENTION AMONG THEM\nJOBS     DS    0H\nJOBS#CHR DS    0AL1\n         DC    AL1(2)         L' -1 OF NAME\nJOBSNAM  DS    0CL8\n         DC    CL8'TSO     '\nJOB1     EQU   *\n         DC    AL1(0),CL8'T'\n         DC    AL1(0),CL8'P'\n         DC    AL1(3),CL8'JES2'\n         DC    AL1(2),CL8'IMS'\n         DC    AL1(3),CL8'VTAM'\n         DC    AL1(7),CL8'*MASTER*'\n         DC    AL1(3),CL8'CICS'\n         DC    AL1(4),CL8'OTHER'\nJOBE     EQU   *\nJT#      EQU   (JOBE-JOBS)/(JOB1-JOBS)  CALC # OF JOBS IN TABLE\n         DC    AL1(0),CL8'SIO 0'   EXTENDED TABLE ROW LABELS\n         DC    AL1(0),CL8'SIO 1'\n         DC    AL1(0),CL8'SIO 2'\n         DC    AL1(0),CL8'SIO 3'\n         DC    AL1(0),CL8'DEFR TIM'\n         DC    AL1(0),CL8'IO TIME '\nJOBE2    EQU   *\nJTPRT2#  EQU   (JOBE2-JOBS)/(JOB1-JOBS) # OF ENTRIES IN EXTENDED TAB\n*\n*        DEVICE CHARACTERISTICS TABLE\nSTCYLS   DS    0H                  TABLE OF DEVICE TYPE TO MAX. CYLS\n         DC    X'0900'             DEVICE TYPE\nSTCYLMAX EQU   *\n         DC    H'404'              MAX CYLS\nSTCYLNAM EQU   *\n         DC    CL8'3330'           EBCDIC NAME\nSTCYLTRK EQU   *\n         DC    H'19'               TRACKS PER CYLINDER\nSTCYLS1  DS    0H                  FOR SIZE OF ENTRY CALC\n         DC    X'0D00',H'808',CL8'3330-1',H'19'\n         DC    X'0B00',H'1110',CL8'3350  ',H'30' ?CDC33502     06NOV84\n         DC    X'0800',H'0200',CL8'2314  ',H'20'               02MAR94\n         DC    X'0A00',H'0696',CL8'3340  ',H'12'               02MAR94\n         DC    X'0C00',H'0959',CL8'3375  ',H'12'               02MAR94\n         DC    X'0E00',H'0885',CL8'3380  ',H'15'               02MAR94\n*              USING 1110 (VICE 555) CDC DUAL DENSITY DISK     06NOV84\n         DC    H'-1',H'9999',CL8'UNKNOWN',H'19'\n*                                                              06NOV84\n*        LIST OF CHANNEL AND CONTROL UNIT ADDRESSES OF DUALS   06NOV84\n*         KEEP IN ASCENDING ORDER                              06NOV84\n*         IF YOU DONT HAVE ANY DUALS, JUST LEAVE FF AT END IN  06NOV84\nDDMAP    DS    0X                  LIST OF CHAN,CUA OF DUAL    06NOV84\n*                                  DENSITY DISKS               06NOV84\n* KEEP    IN   SEQUENCE!!!         INCLUDE ALTERNATES          06NOV84\n*        DC    X'4042A0A2'         40X,42X OPTCHAN=A           06NOV84\n*        DC    X'C0C2E0E2'         C0X,C2X OPTCHAN=E           06NOV84\n*        DC    X'64667476'         64X,66X OPTCHAN=7           06NOV84\n*        DC    X'E4E6F4F6'         E4X,E6X OPTCHAN=F           06NOV84\n         DC    X'FFFF'             FAIL SAFE FOR END OF TABLE  06NOV84\n*****************? S T A T I C  C O N S T A N T S ********************\nSTMAXDSP DC    H'3'                MAX DIGITS IN DEV ARRAY REPT\nSTJOBDSP DC    H'8'                DIGITS IN JOB REPORT\nLINEOFST DC    H'64'               OFFSET IN PRINTLINE FOR DATA\n*                                  +0=CARRIAGE                 15OCT79\n*                                  +4=TRACK# L'=6              15OCT79\n*                                  +11=CUM I/O L'=8            06NOV84\n*                                  +20=DSN L'=44               06NOV84\nSEEKINTF DC    H'20'            ???# OF CYLS MOVED FOR SIG. CONTENTION\nMASK     DC    X'402020202020202020202120' EDIT MASK\nMASK2    DC    X'40206B2020206B202120' EDIT MASK  Z,ZZZ,ZZ9\nMASK3    DC    X'402020204B2021204B20' EDIT MASK  ZZZ,ZZ9.9    06NOV84\nTRTAB    DC    C'0123456789ABCDEF' XLATE MASK\nLOGO     DC    C'D A S D  M A P P E R  V 2.3' HEADER           06NOV84\nHDR2     DC    C'0   FROM  /   TO SLOT NUMBER'  HDR FOR DEV ARRAY DISP\n         LTORG\n*        EQUATES\n*        U C B\nUCBDVCLS EQU   18,1\nUCBCHAN  EQU   4,2\nUCBNAME  EQU   13,3\nUCBSTAT  EQU   3,1\nUCBUNTYP EQU   19,1\nUCBVOLI  EQU   28,6\nUCBSTAB  EQU   34,1                                            28OCT79\nUCBBPRV  EQU   X'10'               PRIVATE                     28OCT79\nUCBBPUB  EQU   X'08'               PUBLIC                      28OCT79\nUCBBSTR  EQU   X'04'               STORAGE                     28OCT79\n*        C V T\nCVTPTR   EQU   X'10'\nCVT      EQU   0\nCVTILK1  EQU   X'24'\nCVTILK2  EQU   X'28'\nCVTDCB   EQU   X'74'                   OPERATING SYSTEM        20SEP84\nCVTMVSE  EQU   X'80'                   CVTDCB BITS - MVS/XA    20SEP84\nCVTIXAVL EQU   X'7C'                   IOS COMM AREA IOCOM     20SEP84\n*        I O C O M\nIOCOM    EQU   0                                               20SEP84\nIOCGENA  EQU   X'54'                   IOSGEN SUBR             20SEP84\n         TITLE 'D Y N A M I C  S T O R A G E'\nDSA      DSECT\nDSAPREFX DS    XL12                    IBM \"IOSLOOK\" USES      20SEP84\n*                                      SAVE AREA PREFIX???     20SEP84\nDSAPARMS DS    F                   RES\nPACKS    EQU   *                   START OF PACKED COUNTERS\nTOTRECIN DS    PL4                 TOTAL RECS IN\nTOTSIO   DS    PL4                 TOTAL SIO RECS\nTOTSIO0  DS    PL4\nTOTSIO1  DS    PL4\nTOTSIO2  DS    PL4\nTOTSIO3  DS    PL4\nTOTIO    DS    PL4                 TOTAL IO RECS\nTOTPCI   DS    PL4                 TOTAL PCI RECS\nTOTBAD   DS    PL4                 TOTAL BAD RECS\nTOTBYPAS DS    PL4                 TOTAL BYPASSES RECS\nTOTSIOBD DS    PL4                 TOTAL BAD SEEK ADDR RECS    15OCT79\nTOTBYP2  DS    PL4                 TOTAL BAD JOBNAME           15OCT79\nPACKE    EQU   *                   END OF PACKED COUNTERS\nUTTIMSAV DS    F                   TIME UTILITY SAVE\nSTRTTM   DS    XL8                 START OF GTF RUN\nSTOPTM   DS    XL8                 STOP OF GTF RUN\nTOTTM    DS    XL8                 DELTA TIME\nUTSTCKSV DS    F                       TOD CONVERTER SAVE      DDMMM84\nUTSTCKDA @STCK DATA                    DO DSECT                DDMMM84\nTOTSIO0R DS    F                   SIO 0 RATE\nUTEODSAV DS    F                   PRINT FORMAT UTILITY SAVE\nPARMSAVE DS    F                   R1 FROM CALLER\nSTROOT   DS    F                   ADDR OF STRING TABLE\nSTSIZ#   DS    F                   NUMBER OF STRINGS IN SYS\nEODSTUCB DS    CL3                 WORK AREA-HOLDS STRING\nLINESIZE DS    H                   REPORT LINE SIZE\nDSADVMAX DS    H                   NUMB. DASDS + 1\nMAXCYL   DS    H                   MAX # CYL ON ANY PACK\nUTEODBAS DS    F                   BASE ADDR FOR FORMAT UTILITY\nDVVROOT  DS    F                   PTR TO DEV VECTOR TABLE\nDVVSIZE  DS    F                   SIZE OF DVV TABLE\nDVSLOTS  DS    H                   # SLOTS FOR A PACK\nDVSIZE   DS    F                   SIZE OF A DEVICE TABLE ENTRY\nUTDEFRSV DS    F                   DEFR UTILITY SAVE AREA\nEODCURDV DS    F                   PLACE HOLDER DURING EOD\nUTGETSAV DS    F                   UTILITY ROUTINE SAVE AREA\nDVDSNO   DS    F                   ADDR OF TABLE OF OFFSETS    15OCT79\n*                                  1/TRACK OF DASD L'=2        15OCT79\nDVDSNT   DS    F                   ADDR OF DSN TABLE           15OCT79\nDSDSNTL  DS    F                   LEN. OF DSN TABLE           15OCT79\nDSDSNTC  DS    F                   NEXT AVAL. BYTE             15OCT79\nDSDSNTE  DS    F                   END - 100BYTES              15OCT79\n*                                  ENTRY FORMAT:               15OCT79\n*                                  +0=L' ONE BYTE TRUE LENGTH  15OCT79\n*                                  +1=DSNAME                   15OCT79\n*                                  +2=EXTENT I.D.              15OCT79\n*                                   BLANK,1-9,A-F              15OCT79\nDSDSNTL# EQU   65500               MAX # BYTES OF DSN ON ANY   15OCT79\n*                                  DASD                        15OCT79\nDSSAVR10 DS    F                   SAVE R10 (CURR REC PTR)     28OCT79\nDSSIORET DS    F                   RETURN AFTER SIO REC DONE   28OCT79\nWD       DS    D                   DOUBLE WORD WORK AREA\nDSABEND8 DS    X                   SWITCH FOR WARNING MSG      06NOV84\nDSDSNTSW DS    X                   \"DSN TABLE TOO SMALL\"WTO-SW 02MAR94\nDSAXA    DS    X                       MVS/XA INDICATOR        20SEP84\nDSAXAYES EQU   C'Y'                    Y IF EXECUTING ON XA    20SEP84\nDSCUMIO  DS    F                   CUMULATIVE IO IN RPT        06NOV84\n@PL      DS    F                   PTR TO PRINT LINE\nPLCC     EQU   0,1                 PRINTLINE CARRIAGE          15OCT79\nPLSLOT   EQU   0,4                 SLOT # FOR MATRIX OPTION    15OCT79\n*                                  EDITS TO 1-3 REALLY         15OCT79\nPLTRACK  EQU   4,6                 TRACK#                      15OCT79\n*                                  EDITS TO 5-9 REALLY         15OCT79\nPLCYLERR EQU   10,1                $ IF D.S. DOESNT OWN CYL    15OCT79\nPLCUMIO  EQU   11,8                CUMULATIVE IO               06NOV84\nPLDSN    EQU   20,44               DSNAME                      06NOV84\nPLEXTNT  EQU   20+43,1             EXTENT ID BLANK,1-9,A-F     06NOV84\n*              JOB INFO TABLE                                  06NOV84\nPLJNAM   EQU   5,L'JOBSNAM         JOBNAME (IN ROW)            06NOV84\nPLJSTART EQU   14                  START OF DATA               06NOV84\nWF       DS    F                   WORK AREA\nWE       DS    CL12                MAX SIZE DISPLAY AREA FOR NUMERICS\n         DS    0H                  ALIGN\nEXMVC    DS    XL6                 EXECUTED MVC INSTRUCTION\nEXMVC2   DS    XL6                 EXECUTED MVC INSTRUCTION\nEXMVC3   DS    XL6                 EXECUTED MVC INSTRUCTION\nEODOVFLO DS    F                   MAX SIZE FIELD THAT CAN BE PRINTED\nHDR1     DS    CL133               HEADER AREA\nHDRDATE  EQU   HDR1+L'HDR1-32,32   HEADER DATE/TIME\nPRTOPT   DS    C                   REPORT OPTION SWITCH\nHDRTITLE EQU   HDR1+(L'HDR1/2)-(L'LOGO/2),L'LOGO  CENTER OF HDR\nHDRUCB   EQU   HDR1+1,3            EBCDIC UCB ADDR\nHDRTYPE  EQU   HDR1+5,8            EBCDIC DEV TYPE\nHDRVOLI2 EQU   HDR1+14,6           VOLSER                      06NOV84\nHDRVOL2X EQU   HDR1+20,3           '(-)' REMINDER FOR DUAL DE  06NOV84\nHDRSTAB2 EQU   HDR1+23,4           VOL2 STATUS(PRIV,PUB,STOR)  06NOV84\nHDRVOLI  EQU   HDR1+28,6           SECONDARY VOLSER FOR DUAL   06NOV84\nHDRSTAB  EQU   HDR1+35,4           VOL STATUS (PRIV,PUB,STOR)  06NOV84\nHDRCLR   EQU   HDR1+1,19           BLANK AREA\nDSAUCBO  DS    X                       Y=ONLY GET UCB ADR\n*                                      FOR UTGET/UTGETUCB SUB.\nDSADAADR DS    F                       SAVE CURR DEV ADR\nDSASIORC DS    XL80                    BUILD FAKE SIO FROM SSCH20SEP84\nDSAIOREC DS    XL80                    BUILD FAKE IO FROM XAIO 20SEP84\nDSAPARM  DS    CL101               SAVE AREA FOR PARM          20SEP84\n         TITLE 'D Y N A M I C  S T O R A G E - VTOC READER'\n         VTEXCP EQ                 SET UP EXCP EQUATES         15OCT79\n         VTOCOM NODSECT                                        15OCT79\nWORKEXCP DS    4XL256              WORK AREA FOR VTOC RDR      15OCT79\nDSASIZE  EQU   *-DSA-72            SIZE OF DSA\nFMT1     DSECT                                                 15OCT79\n         IECSDSL1 1                                            15OCT79\n         TITLE 'D E V I C E  T A B L E'\nDVTAB    DSECT                     DEVICE TABLE\nDVUCB    DS    CL3                 EBCDIC UCB ADDR\nDVFLAG1  DS    X                   FLAG                        06NOV84\nDVF1DD   EQU   X'80'               DUAL DENSITY DEVICE         06NOV84\nDVUCBPTR DS    F                   UCB PTR(ADDR)\nDVCHAN   DS    XL2                 0CUU LAST USED HEX ADDR     06NOV84\nDVTYPE   DS    CL8                 EBCDIC TYPE\nDVVOLI   DS    CL6                 VOLSER\nDVSTAB   DS    X                   VOL STATUS B FROM UCBSTAB   28OCT79\nDVVOLI2  DS    CL6                 SECONDARY VOLSER IF DUAL D  06NOV84\nDVSTAB2  DS    X                   VOL STATUS B FROM UCBSTAB   06NOV84\nDVSIO0   DS    F                   SIO ZERO COUNT\nDVSIO1   DS    F                   \" 1\nDVSIO2   DS    F                   \" 2\nDVSIO3   DS    F                   \" 3\nDVSIO0R  DS    F                   SIO 0 RATE (*10)            06NOV84\n*        FOR SIO CC=1 TABLE FOR 1ST 6 STATUS CODES/COUNTS\nDVSIO1XS DS    XL2                 SIO1 STATUS\nDVSIO1XC DS    XL4                 SIO1 CTR\nDVSIO1XL EQU   *-DVSIO1XS          1 ENTRY SIZE\n         DS    (5*DVSIO1XL)X       REST OF TABLE\nDVSIO1XE EQU   *\nDVRESV   DS    F                   NUMBER OF RESERVES          15OCT79\nDVRLS    DS    F                   NUMBER OF RELEASES          28OCT79\nDVSIOFCC DS    F                   NUMBER OF SIOF W/ DEFER CC  28OCT79\nDVDELTA  DS    H                   CYLINDERS PER PRINT SLOT\nDVTRK    DS    H                   TRACKS PER CYLINDER\nDVCYL    DS    H                   CYLINDERS PER DEVICE\nDVLJOBI  DS    H                   LAST USER OF DEV(JOB TAB INDEX)\nDVCJOBI  DS    H                   CURR USER OF DEV(JOB TAB INDEX)\n         DS    0D                  ALIGN\nDVL0TIME DS    XL8                 TIME OF LAST SIO0(CALC CONCURRENCE)\nDVLTIME  DS    XL8                 TIME OF LAST SIO0(CALC I/O TIME)\nDVLRESTM DS    XL8                 TIME OF LAST RESERVE        28OCT79\nDVLJOB   DS    CL8                 LAST JOB NAME\nDVDEFRTM DS    XL8                 TIME OF LAST SIO .NE. 0\nDVDEFRIO DS    F                   CUM/AVG DEFR IO TIME\nDVDEFRMX DS    F                   MAX DEFR IO TIME\nDVAVGRES DS    F                   AVG RESERVE TIME            28OCT79\nDVLROW   DS    F                   ROW OF ARRAY WHERE HEAD LEFT\nDVTOTCYL DS    F                   TOTAL CYLINDERS SEEKED\nDVAVGIO  DS    F                   AVG. I/O TIME\nDVMAXIO  DS    F                   MAX. I/O TIME\nDVMAXHIT DS    F                   MAX. DEV ARRAY ENTRY\nDVAVGCYL DS    F                   AVG. CYL. SEEKED\nDVLSEEK  DS    XL8                 MBBCCHHR OF LAST SEEK\nDVCURJOB DS    H                   INDEX TO CURRENT JOB USER\nDVTOTTIM DS    2F                  RESV.\nDVLSIO0  DS    XL100               HOLD AREA FOR SIO CC=0      28OCT79\n********* JOB INFO BY DEVICE\nDVJTXREF DS    (JT#*JT#)F         JOB INTERFERENCE ARRAY\nDVJTSIO0 DS    (JT#)F              SIO CCODE\nDVJTSIO1 DS    (JT#)F              SIO CCODE\nDVJTSIO2 DS    (JT#)F              SIO CCODE\nDVJTSIO3 DS    (JT#)F              SIO CCODE\nDVJTDFRT DS    (JT#)F              TOT/AVG DEFER TIME\nDVJTIOTM DS    (JT#)F              TOT/AVG I/O TIME\nDVJTSEEK DS    (JT#)F              TOT/AVG CYL SEEKED\n         DS    0F                  ALIGN\nDVFIXSIZ EQU   *-DVTAB             SIZE OF FIXED DEV. TABLE AREA\nDVXREF   EQU   *                   START OF SEEK ARRAY\n         TITLE 'S T R I N G  T A B L E '\nSTTAB    DSECT STRING TABLE\nSTUCB    DS    CL3                 EBCDIC NAME\nSTSIO0   DS    F                   SIO 0\nSTSIO1   DS    F                   SIO 1\nSTSIO2   DS    F                   SIO 2\nSTSIO3   DS    F                   SIO 3\nSTRESV   DS    F                   RESERVES                    28OCT79\nSTAVGIO  DS    F                   AVG IO TIME\nSTTOTCYL DS    F                   AVG CYL SEEK\nSTDEFRIO DS    F                   AVG DEFR TIME\nSTDEFRMX DS    F                   MAX DEFR TIME\nSTAVGRES DS    F                   AVG RESERVE TIME            28OCT79\nSTNUMB   DS    F                   NUMBER OF DEVICES ON STRING\nSTSIZE   EQU   *-STTAB             SIZE OF TABLE\n******\n******   TITLE 'D E V I C E  V E C T O R  T A B L E '\n******\nDVVTAB   DSECT                     DEVICE VECTOR TABLE\nDVVPTR   DS    F                   PTR TO DEVICE TABLES\nDVVUCB   DS    F                   PTR TO UCB\nDVVSIZ   EQU   *-DVVTAB            SIZE OF ENTRY\n         TITLE 'G T F  R E C O R D S'\nGTFREC   DSECT                     GTF RECORDS\nGTLEN    DS    H                   LENGTH\n         DS    H                   RESV\nGTID     DS    X                   RECORD ID\nGTFMT    DS    X                   FORMAT ID\nGTTIME   DS    XL8                 TIME STAMP IF TIME=YES\nGTEVNT   DS    XL2                 EVENT IDENTIFIER\nGTASCB   DS    XL4                 PTR TO ACSB\nGTCPUID  DS    XL2                 CPU ID\nGTJOB    DS    XL8                 JOBNAME\nGTSCCWR  DS    XL4                 REAL ADDR OF CCW\nGTSCCWV  DS    XL4                 VIRT ADDR OF CCW\nGTSPURGE DS    XL4                 CTRL BLK USED BY PURGE\nGTSIOCC  DS    XL1                 SIO CONDITION CODE\nGTSDEV   DS    XL2                 DEV ADDR\nGTSCAW   DS    XL4                 CAW\nGTSSTAT  DS    XL2                 STATUS\nGTSSEEK  DS    XL8                 SEEK ADDR\nGTSFLB   EQU   GTSSEEK+1,1         FROM IOQFLB (RESERVE/RLSE)  27OCT79\n*                                  LOCAL MOD TO AHLTSIO FROM   27OCT79\n*                                   CCWTRACE GIVES INFO        27OCT79\nGTSRESV  EQU   X'80'               RESERVE FLAG                27OCT79\nGTSRLSE  EQU   X'40'               RELEASE FLAG                27OCT79\nGTSFLAG  DS    XL6                 FLAGS\nGTSAFF   EQU   GTSFLAG+0,1         FROM IOSAFF (IOSB FIELD)    15OCT79\nGTSPATH  EQU   GTSFLAG+1,2         IOSPATH                     15OCT79\nGTSOPT   EQU   GTSFLAG+3,1         IOSOPT                      15OCT79\nGTSBYP   EQU   X'80'               BYPASS IOS CHAN PROG PREFX  15OCT79\nGTSRELSE EQU   X'01'               STAND ALONE RELEASE ISSUED  15OCT79\nGTSFMSK  EQU   GTSFLAG+4,1         IOSFMSK (SET FILE MASK)     15OCT79\nGTSDVRID EQU   GTSFLAG+5,1         IOSDVRID (DRIVER ID)        15OCT79\nGTSIOSID EQU   X'00'               RSVD FOR IOS                15OCT79\nGTSMISID EQU   X'01'               MISC DRIVER                 15OCT79\nGTSXCPID EQU   X'02'               EXCP DRIVER                 15OCT79\nGTSVSAID EQU   X'03'               VSAM DRIVER                 15OCT79\nGTSATMID EQU   X'04'               VTAM DRIVER                 15OCT79\nGTSTCMID EQU   X'05'               TCAM DRIVER                 15OCT79\nGTSOLTID EQU   X'06'               OLTEP DRIVER                15OCT79\nGTSFCHID EQU   X'07'               PCI FETCH DRIVER            15OCT79\nGTSJESID EQU   X'08'               JES3 DRIVER                 15OCT79\nGTSSS1ID EQU   X'09'               SS1/DSM DRIVER              15OCT79\nGTSPRGID EQU   X'0A'               IECVIOPM PURGE DRIVER       15OCT79\nGTSVPSID EQU   X'0B'               VPSS DRIVER                 15OCT79\n*        SSCH RECORD               *XAXAXA********\n         ORG   GTSCCWR             RE-ALIGN                    20SEP84\nGTXDEV   DS    XL2                     DEVICE NUMBER           20SEP84\nGTXCCWR  DS    XL4                 REAL ADDR OF CCW\nGTXCCWV  DS    XL4                 VIRT ADDR OF CCW\nGTXDSID  DS    XL4                 IOS DSID\nGTXIOCC  DS    XL1                 SSCH CONDITION CODE\nGTXORB   DS    XL12                ORB?\nGTXSEEK  DS    XL8                 SEEK ADDR\nGTXPATH  DS    XL1                     IOSGPMSK\nGTXOPT   DS    XL1                     IOSOPT\nGTXFMSK  DS    XL1                     IOSFMSK\nGTXDVRID DS    XL1                     DRIVER ID\nGTXIOSLV DS    XL1                     IOS LEVEL\nGTXUCBLV DS    XL1                     UCBLEVEL\n*        RSCH RECORD               *XAXAXA********\n         ORG   GTSCCWR             RE-ALIGN                    20SEP84\nGTRDEV   DS    XL2                     DEVICE NUMBER           20SEP84\nGTRCCWR  DS    XL4                 REAL ADDR OF CCW\nGTRCCWV  DS    XL4                 VIRT ADDR OF CCW\nGTRDSID  DS    XL4                 IOS DSID\nGTRIOCC  DS    XL1                 RSCH CONDITION CODE\nGTRSEEK  DS    XL8                 SEEK ADDR\nGTRPATH  DS    XL1                     IOSGPMSK\nGTROPT   DS    XL1                     IOSOPT\nGTRFMSK  DS    XL1                     IOSFMSK\nGTRDVRID DS    XL1                     DRIVER ID\nGTRIOSLV DS    XL1                     IOS LEVEL\nGTRUCBLV DS    XL1                     UCBLEVEL\n*        I/O RECORD (NON-XA)       ***************\n         ORG   GTSCCWR             RE-ALIGN\nGTIOPSW  DS    XL8                 I/O OLD PSW\nGTIRQTCB DS    XL4                 RQE TCB\nGTICSW   DS    XL8                 CSW\nGTICCWR  DS    XL4                 REAL ADDR OF CCW\nGTICCWV  DS    XL4                 VIRT \"\nGTISENSE DS    XL2                 SENSE\nGTIDEV   DS    XL2                 DEVICE ADDR\nGTIPURGE DS    XL4                 PURGE CTRL BLOCK\nGTIFLAG  DS    XL9                 FLAGS\n*        I/O RECORD (XA)                                       20SEP84\n         ORG   GTSCCWR                RE-ALIGN                 20SEP84\nGTYDEV   DS    XL2                 DEVICE NUMBER               20SEP84\nGTYOPSW  DS    XL8                     I/O OLD PSW             20SEP84\nGTYIRB   DS    XL16                    IRB                     20SEP84\nGTYCSW   EQU   GTYIRB+4,8              CSW                     20SEP84\nGTYRQTCB DS    XL4                     TCB                     20SEP84\nGTYSENSE DS    XL2                     SENSE                   20SEP84\nGTYFLAG  DS    XL2                     FLAGS                   20SEP84\nGTYDVRID DS    XL1                     DRIVER ID               20SEP84\nGTYIOSLV DS    XL1                     IOS LEVEL               20SEP84\nGTYUCBLV DS    XL1                     UCB LEVEL               20SEP84\n*\n*        TIME STAMP CONTROL RECORD\n         ORG   GTTIME\nGTCRTZON DS    XL4                 TIME ZONE\nGTCRTOD  DS    XL8                 TOD CLOCK\nGTCROP1  DS    X                   OPTION 1\nGTC1SYSM EQU   X'80'                                           20SEP84\nGTC1SYSP EQU   X'40'                                           20SEP84\nGTC1SYS  EQU   X'20'                                           20SEP84\nGTC1USR  EQU   X'10'                                           20SEP84\nGTC1TRC  EQU   X'08'                                           20SEP84\nGTC1DSP  EQU   X'04'                                           20SEP84\n*TC1XXX  EQU   X'02'                                           20SEP84\nGTC1PCI  EQU   X'01'                                           20SEP84\nGTCROP2  DS    X                   OPTION 2\nGTC2SVC  EQU   X'80'                                           20SEP84\nGTC2SVCP EQU   X'40'                                           20SEP84\nGTC2SIO  EQU   X'20'                                           20SEP84\nGTC2SIOP EQU   X'10'                                           20SEP84\nGTC2PI   EQU   X'08'                                           20SEP84\nGTC2PIP  EQU   X'04'                                           20SEP84\nGTC2IO   EQU   X'02'                                           20SEP84\nGTC2IOP  EQU   X'01'                                           20SEP84\nGTCROP3  DS    X                   OPTION 3\nGTC3EXT  EQU   X'80'                                           20SEP84\nGTC3RNIO EQU   X'40'                                           20SEP84\nGTC3SRM  EQU   X'20'                                           20SEP84\nGTC3RR   EQU   X'10'                                           20SEP84\nGTC3SLIP EQU   X'08'                                           20SEP84\nGTC3CCW  EQU   X'04'                                           20SEP84\nGTC3CCWP EQU   X'02'                                           20SEP84\nGTC3IOEQ EQU   X'01'                   IO=SIO                  20SEP84\nGTCROP4  DS    X                   OPTION 4\nGTC4CCWI EQU   X'80'                                           20SEP84\nGTC4CCWS EQU   X'40'                                           20SEP84\nGTC4JOBP EQU   X'20'                                           20SEP84\nGTC4ASDP EQU   X'10'                                           20SEP84\nGTC4USRP EQU   X'08'                                           20SEP84\n*TC4RES  EQU   X'04'                                           20SEP84\n*TC4RES  EQU   X'02'                                           20SEP84\nGTC4TIME EQU   X'01'                   IO=SIO                  20SEP84\nGTCROP5  DS    X                   OPTION 4\nGTC5SSCH EQU   X'80'                                           20SEP84\nGTC5SSCP EQU   X'40'                                           20SEP84\nGTC5MSCH EQU   X'20'                                           20SEP84\nGTC5HSCH EQU   X'10'                                           20SEP84\nGTC5CSCH EQU   X'08'                                           20SEP84\n*TC5RES  EQU   X'04'                                           20SEP84\n*TC5RES  EQU   X'02'                                           20SEP84\nGTC5SSEQ EQU   X'01'                   IO=SSCH                 20SEP84\nGTCROPX  DS    XL3                     RESERVED\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSPACE": {"ttr": 2565, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TSSPACE  TITLE 'TSO CP TO PRINT DASD SPACE INFO  12JUN94 - HUNTER'\n********************************************************************\n*                  T-S-D-S-P-A-C-E\n*      PROGRAM TO PRINTOUT AVAILABLE SPACE ON A DISK DRIVE\n*      USES LSPACE (SVC 78)  FUNCTION\n*      ALSO DETERMINES IF PACK HAS INDEXED VTOC\n*      PRODUCED FROM DISASEMBLY OF ORIGINAL OBJECT MODULE\n*      W F HARTMAN MAY 1981\n*            CODE FROM CBTV224   - CLARK\n*      RE-WORKED:\n*        RENT; %FREE SPACE; UNIT NAME; NO. USERS;ALT PATH, PATH MASK\n*        ADDED XA SUPPORT                                      DDMMM84\n********************************************************************\n         MACRO\n&N       @ED   &OU,&WK\n&N       MVC   &OU,OTMASK               MOVE MASK\n         L     R0,&WK                   GET DATA\n         CVD   R0,WD                    MAKE PACKED\n         ED    &OU,WD+4                 EDIT IT\n         MEND\n         PRINT NOGEN\nTSSPACE @ENT   R12,(0,DSAEND-DSA,C),DSA=YES\n         XC    WKCLRS(WKCLRL),WKCLRS   CLEAR COUNTERS\n         LA    R2,PPL                  GET ADDRESS OF PPL\n         USING PPL,R2                  TELL ASSEMBLER\n         MVC   UPT,4(R1)               COPY  UPT\n         MVC   ECT,12(R1)              COPY  ECT\n         LA    R0,ECB                  GET ADDRESS OF NEW ECB\n         ST    R0,ECBP                 SAVE ECB ADDRESS\n         XC    ECB,ECB                 ZERO ECB\n         MVC   PCL,ADDPCL              GET ADD OF PCL\n         LA    R0,ANS                  GET ADD OF ANSWER WORD\n         ST    R0,ANSW                 PUT IN PPL\n         MVC   COMBUF,0(R1)            PUT ADD OF CBUFF IN PPL\n         XC    WK,WK                   ZERO USER WORK AREA\n         LA    R1,PPL                  GET ADD OF PPL\n         CALLTSSR EP=IKJPARS           GO PARSE IT\n         DROP  R2\n         LTR   R15,R15                 TEST  RETURN CODE\n         BNZ   ERROR                   ERROR GO TELL USER\n*\n**       SAY   HELLO\n*\n         LA    R0,HDR1E-HDR1S          L' MSG\n         LA    R1,HDR1S\n         TPUT (R1),(R0)  TPUT MESSAGE\n         LA    R0,HDR2E-HDR2S          L' MSG\n         LA    R1,HDR2S\n         TPUT (R1),(R0)  TPUT MESSAGE\n*\n         MVI   UNIT,C' '               UNIT=C' '=NO HITS\n*\n         L     R6,ANS                  GET ADDRESS OF ANSWER AREA\n*---                                   PROCESS PATH INFO       25JUN84\n         USING IKJPARMD,R6                                     25JUN84\n         CLC   =H'1',MINPATHK          FIRST KEYWORD SPEC'D    25JUN84\n         BNE   SKPPATH                 NO-SKIP                 25JUN84\n         L     R14,MINPATHI            DATA ADR                25JUN84\n         LH    R15,MINPATHI+4          L'                      25JUN84\n         BCTR  R15,0                   L' -1                   25JUN84\nMINPATHX PACK  WD,0(*-*,R14)           EXECUTED                25JUN84\n         EX    R15,MINPATHX             \"\"\"\"\"\"                 25JUN84\n         CVB   R0,WD                                           25JUN84\n         ST    R0,MINPATHD             SAVE MIN PATHS REQD     25JUN84\nSKPPATH  DS    0H                                              25JUN84\n*---     ---   PROCESS VOLSERS                                 25JUN84\n         LA    R6,VOL                  PDL DSECT ENTRY\n         DROP  R6                                              25JUN84\n         TM    6(R6),X'80'             IS IT REQUST FOR SPEC VOL\n         BO    GETVOL                  YES GO PROCESS\n         SR    R6,R6                   NO-ALL VOLUMES\n         B     SKPVOL                  SKIP\nGETVOL   DS    0H\n         MVI   VOLSER,C' '\n         MVC   VOLSER+1(5),VOLSER\n         L     R7,0(R6)                GET ADDRESS OF VOLUME\n         LH    R8,4(R6)                GET LENGTH OF VOLUME\n         BCTR  R8,R0                   MACHINE LENGTH\n         LA    R9,VOLSER               ADDRESS OF MESSAGE\n         EX    R8,EXMVC                MOVE VOLUME IN\nSKPVOL   DS    0H\n         TITLE 'SCAN UCBS'\n*\n***            THIS CODE COPIED FROM (TSUCBSCN)\n*\nLOCUCB   DS    0H  -----------------FORMAT IOS SCAN PARM LIST\n         XC    DSXAWORK,DSXAWORK       ZERO OUT UCB WORKAREA\n         LA    R1,DSXAWORK             ADDR OF UCB WORKAREA\n         ST    R1,DSXAWA               STORE IT IN PARM LIST\n         LA    R1,DSXACLAS             PTR TO DEV CLAS TO SEARCH\n         ST    R1,DSXADEVT             STORE IN PARM LIST\n         MVI   DSXACLAS,UCB3DACC       ONLY SEARCH DASD\n         LA    R1,DSXAUCBP             AREA TO STORE UCB ADDR\n         ST    R1,DSXAUCB              IN PARM LIST\n         OI    DSXAUCB,X'80'           SIGNIFY END OF PARMLIST\nUCBLOOP  DS    0H\nLOCUCB1  DS    0H  -----------------SCAN FOR A UCB---------\n         L     R15,CVTPTR\n         MVC   DSADCB,CVTDCB-CVT(R15)  SAVE OP SYS TYPE\n*        ICM   R15,15,X'434'(R15)      CVTUCBSC VALID?(IOSVSUCB)\n         ICM   R15,15,CVTUCBSC-CVT(R15) CVTUCBSC VALID?(IOSVSUCB)\n         BZ    LOCUCBE0                ZERO=OLD MVS\n***>>>>>>----UCB SCAN SERVICE FOR MVS/SP1.2 AND ABOVE:-----<<<<<<***\n** PARM:(100BYTE-WORK,1BYTE-DEV-CLASS,1WORD-UCB-PTR)              **\n**RETURN CODES: R15 = 00-UCB RETURNED; 04-NO MORE UCBS            **\n         LA    R1,DSXALIST             PTR TO PARM LIST\n         BALR  R14,R15                 BRANCH TO IT\n         B     LOCUCBXX                COMMON ENTRY POINT\n***>>>>>>----- EMULATION UCB SCAN SERVICE FOR OLD MVS------<<<<<<***\nLOCUCBE0 DS    0H\n         ICM   R14,B'1111',DSXAEUCB    BR IF THIS IS\n         BNZ   LOCUCBE1                SECOND OR LATER CALL\n         L     R14,CVTPTR              ADDR-UCB VECTOR TABLE\n         L     R14,X'24'(R14)         *XA  CVTILK2-CVT(R14)\n         ST    R14,DSXAEILK            SAVE(TO CHECK FOR DUPS)\nLOCUCBE1 DS    0H\n         SR    R1,R1                   ZERO UCB ADDR PTR\nLOCUCBE3 DS    0H\n         LA    R14,2(,R14)             NEXT PTR(1ST UCB SKIPPED)\n         ICM   R1,B'0011',0(R14)       ADDR OF UCB\n         BZ    LOCUCBE3                BR IF NULL ENTRY\n         LA    R15,4                   SHOW NO HITS (CC UNCHANGED)\n         BO    LOCUCBEX                BR IF END\n         LA    R15,0                   SHOW HITS (CC UNCHANGED)\nLOCUCBE5 DS    0H\n         CLC   DSXACLAS,UCBTBYT3-UCBCMSEG(R1) BR IF THIS UCB\n         BNE   LOCUCBE3                IS NOT DESIRED CLASS\n         ST    R1,DSXAUCB              PROVIDE ADDR OF UCB\n         ST    R14,DSXAEUCB            REMEMBER WHERE TO RESUME\n***>>>>> CHECK FOR DUPLICATE CHANNEL PATH\n         L     R14,DSXAEILK            ADDR OF FIRST UCB PTR\nLOCUCBE7 DS    0H\n         CL    R14,DSXAEUCB            EXIT IF NO DUPLICATE\n         BE    LOCUCBEX                CHANNEL PATH FOUND(R15=0)\n         LA    R14,2(,R14)             ADDR OF NEXT PTR\n         CLC   0(2,R14),DSXAUCB+2      CONTINUE LOOP IF THIS IS NOT\n         BNE   LOCUCBE7                DUPLICATE CHANNEL PATH\n         L     R14,DSXAEUCB            SETUP TO RESUME SCAN\n         B     LOCUCBE3                AND GO RE-ENTER LOOP\nLOCUCBEX DS    0H\n***>>>>>>       UCB SCAN ROUTINE - COMMON RETURN POINT     <<<<<<***\nLOCUCBXX DS    0H\n         LTR   R15,R15                 GOT ONE?\n         BNZ   UCBEND                  NO\n         L     R8,DSXAUCBP GET ADR OF  UCB FROM PTR\n         USING UCBCMSEG,R8\n         CLI   UCBID,UCBSTND           IS ADDRESS VALID\n         BNE   UCBSKP                  NO\n         CLI   UCBDVCLS,UCB3DACC       IS IT DASDI\n         BNE   UCBSKP                  NO   SKIP\n         TM    UCBSTAT,UCBONLI         IS IT ONLINE\n         BNO   UCBSKP                  NO  SKIP\n         TM    UCBSTAT,UCBCHGS         IS IT CHANGING STATUS\n         BO    UCBSKP                  YES SKIP\n         LTR   R6,R6                   TEST IF ONLY ONE VOLUME WANTED\n         BZ    SNGVOL                  NO GO PROCESS\n         LH    R0,4(R6)                GET L' VOLSER\n         L     R14,0(R6)               GET VOLSER(FAMILY)\n         LA    R15,UCBVOLI             OP2\n         CLC   =C'ALL ',0(R14)         ALL SPECIFIED           25JUN84\n         BE    SNGVOL                  YES-PROCESS IT          25JUN84\nCLCVOL   DS    0H                      CHECK VOLSER\n         CLI   0(R14),C' '             SHORT VOLSER\n         BE    SNGVOL                  YES-MATCH\n         CLC   0(1,R14),0(R15)         COMPARE VOLSER\n         BNE   UCBSKP                  DONT WANT\n         LA    R14,1(R14)              NEXT\n         LA    R15,1(R15)              \"\n         BCT   R0,CLCVOL               LOOP\n         BNE   UCBSKP                  DO NOT WANT\nSNGVOL   DS    0H\n         TITLE 'PROCESS THIS ONLINE DASD UCB ----------------'\n         MVI   OUTMESS,C' '             CLEAR OUTPUT AREA\n         MVC   OUTMESS+1(OUTMESSL-1),OUTMESS\n         MVC   UNIT,UCBNAME            XXX UBIT ADR\n         MVC   VOLSER,UCBVOLI          VOLSER\n*------- ----- SHOW NUMBER OF USERS\n         XR    R1,R1\n         IC    R1,UCBUSER              CONCURRENT USERS(+26X)\n         TM    DSADCB,DSADCBXA         MVS/XA?                 DDMMM84\n         BZ    *+8                     NO                      DDMMM84\n         LH    R1,UCBUSER              2BYTES IN XA            DDMMM84\n         CVD   R1,WD                   PACKED \"   \"\n         UNPK  OUTMUSER,WD             DISPLAY \"  \"\n         OI    OUTMUSER+L'OUTMUSER-1,C'0' FIX SIGN\n*------- ----- SEE IF ALT PATH\n         TM    DSADCB,DSADCBXA         MVS/XA?                 DDMMM84\n         BZ    NOTXA                   NO                      DDMMM84\n         LH    R15,=H'-24'             UCBCHPS (8CHIPIDS)      DDMMM84\n         AR    R15,R8                  GET ADDR OF UCBSHPS     DDMMM84\n         UNPK  OUTMALTC(9),0(5,R15)    HANDLE 1ST 4 PATHS      DDMMM84\n         MVI   OUTMALTC+8,C' '         FIX UNPK DAMAGE         DDMMM84\n         TR    OUTMALTC(8),HEXTR-X'F0' MAKE DISPLAY ABLE       DDMMM84\n         LH    R15,=H'-28'             UCBLPM 1=AVAIL          DDMMM84\n         AR    R15,R8                  GET ADDR \"              DDMMM84\n         IC    R15,0(R15)              GET PATH BYTE           DDMMM84\n         B     DOPATHXA                CONTINUE                DDMMM84\nNOTXA    DS    0H                      SP3 (&BELOW)            DDMMM84\n         TM    UCBFL5,X'01'           *XA UCBALTPH  ALTPATH?\n         BZ    SKPALT                  NO\n         L     R15,CVTPTR              CVT(+10)\n         L     R15,CVTILCH-CVT(R15)    LCH(+8C)\n         SR    R14,R14\n         IC    R14,UCBCMSEG+X'A'      *XA UCBLCI LCH INDEX(+A)\n         SLL   R14,5                   LCH DISPL\n         LA    R15,0(R14,R15)          LCH ENTRY\n         L     R14,LCHTCH-LCH(R15)     TCH PATH TABLE(+10)\n         LA    R14,2(R14)              PROPER SLOT\n         MVC   OUTMALTC,0(R14)         CHANNEL NUMBER\n         TR    OUTMALTC,HEXTR\n*------- ----- SHOW PATH DATA\n         IC    R15,UCBCMSEG+X'8'      *XAUCBCHM\nDOPATHXA DS    0H                      XA ENTRY (HANDLE 1ST 4  DDMMM84\n         SRL   R15,4                   ISOLATE NIBBLE\n         N     R15,=F'15'              \"\n*------- ----- SHOW NUMBER OF ONLINE PATHS\n         XR    R14,R14                                         25JUN84\n         IC    R14,PTHONTAB(R15)       XLATE TO ONLINE PATHS\n         TM    DSADCB,DSADCBXA         XA                      DDMMM84\n         BZ    DOPATHTR                NO-CONTINUE             DDMMM84\n         SH    R14,=H'4'                                       DDMMM84\n* A PATH BIT IN NON-XA: 0=ONLINE, 1=OFFLINE                    DDMMM84\n* A PATH BIT IN XA:     0=OFFLINE, 1=ONLINE                    DDMMM84\n         LPR   R14,R14                 FLIP FOR XA LOGIC       DDMMM84\nDOPATHTR DS    0H                                              DDMMM84\n         STC   R14,OUTMPTHN            SAVE # PATHS\n         TR    OUTMPTHN,HEXTR\n*------- ----- SEE IF MINPATHS SPEC'D\n         OC    MINPATHD,MINPATHD       NON-ZERO                25JUN84\n         BZ    SKPMINCK                NO-SKIP CHECK           25JUN84\n         C     R14,MINPATHD            PATHS AT OR ABOVE MIN   25JUN84\n         BNL   UCBSKP                  YES-SKIP EM             25JUN84\nSKPMINCK DS    0H                      CONTINUE                25JUN84\n*------- ----- SHOW PATH MASK\n         SLL   R15,2                   *4=0,4,8,...\n         LA    R14,PATHMASK(R15)       CONVER PATH TO BITS\n         MVC   OUTMPTHM,0(R14)         NIBBLE IN BITS C'XXXX'\nSKPALT   DS    0H                      SKIP IF NO ALTS\n*------- ----- LSPACE\n         LA    R0,UCBCMSEG             UCB ADR\n         LA    R1,WORKA\n         SVC   78                      ISSUE LSPACE\n         MVC   OUTMESSV,VOLSER         VOLSER\n         MVC   OUTMESSU,UNIT           ADDR\n*------- ----- SEE IF INDEXED\n         CVAFTST  UCB=(R8)             TEST  VTOC\n         B     BRTBL(R15)              TEST  RETURN CODE\nBRTBL    B     RC0\n         B     RC4\n         B     RC8                     INDEXED\n         B     RC12\n         B     RC16\nRC8      MVC   INFLAG,=C'I '\nRC4      DS    0H\nRC0      DS    0H\n*------- ----- GET DEV INFO\n*                                      CALC % FULL\n         LA    R15,STCYLS              GET DEVICE TABLE\nDEVLOC   DS    0H\n         CLC   UCBUNTYP,(STCYLS-STCYLS)(R15)\n         BE    DEVGOT\n         CLI   (STCYLS-STCYLS)(R15),X'FF'\n         BE    DEVGOT\n         LA    R15,(STCYLS1-STCYLS)(R15)  NEXT\n         B     DEVLOC                  LOOP\nDEVGOT   DS    0H\n         MVC   OUTMESSD,(STCYLNAM-STCYLS)(R15) DEV. NAME\n         LH    R14,(STCYLTTK-STCYLS)(R15)       #TRKS/VOL\n         A     R14,WKTOTTTK            TOT TRKS SEEN\n         ST    R14,WKTOTTTK\n*\n         LH    R14,(STCYLMAX-STCYLS)(R15)       #CYLS/VOL\n         A     R14,WKTOTCYL            TOT CYLS SEEN\n         ST    R14,WKTOTCYL\n*\n         PACK  WD,WA#CYL               # FREE CYL\n         CVB   R0,WD                   \"\n         LR    R14,R0\n         A     R14,WKFRECYL            TOT FREE CYLS\n         ST    R14,WKFRECYL\n*\n         MH    R0,(STCYLTRK-STCYLS)(R15)       #TRKS/CYL\n         PACK  WD,WA#TRK               # FREE TRKS\n         CVB   R14,WD                  \"\n         AR    R0,R14                  TOTAL FREE TRKS ON VOL\n*\n         LR    R14,R0\n         A     R14,WKFRETRK            TOT FREE TRKS - ALLVOL\n         ST    R14,WKFRETRK\n*\n         SRDA  R0,32                   SHIFT TO R1\n         M     R0,=F'100'              FOR % CALC\n         A     R1,=F'50'               \"\n         LH    R14,(STCYLTTK-STCYLS)(R15)\n         DR    R0,R14                  CALC % FREE\n         CVD   R1,WD                   ANSWER\n         UNPK  OUTMESSP,WD\n         OI    OUTMESSP+L'OUTMESSP-1,C'0' FIX SIGN\n*\n         LA    R0,OUTMESSL\n         LA    R1,OUTMESS\n         TPUT (R1),(R0)  TPUT MESSAGE\nTESTONE  LTR   R6,R6\n         B     UCBSKP                  TRY MORE VOLSERS GROUP\n*****    BNZ   SECVOL\nUCBSKP   DS    0H                      INCREMENT BY 2\n         B     UCBLOOP                 CONTINUE SEARCHING SVC TABLE\nUCBEND   LTR   R6,R6                   IS IT ALL\n         BZ    DONE                    YES\n         CLI   UNIT,C' '               WERE ANY VOLSERS FOUND\n         BNE   DONE                    YES-NO MSG\n         MVC   OUTMESS(25),NOVOL\n         MVC   OUTMESS+7(6),VOLSER\n         LA    R0,25\n         LA    R1,OUTMESS              VOL NOT FOUND\n         TPUT (R1),(R0)                TPUT MESSAGE\nSECVOL   L     R6,8(R6)\n         LA    R6,0(R6)\n         LTR   R6,R6                   IS THERE A SECOND VOLUME\n         BNZ   GETVOL\nDONE     IKJRLSA   ANS                 FREE PARSE AREA\nDONE1    DS    0H                      TO FREE\n         @ED   OTFRECYL,WKFRECYL\n         @ED   OTFRETRK,WKFRETRK\n         @ED   OTTOTCYL,WKTOTCYL\n         @ED   OTTOTTTK,WKTOTTTK\n         LA    R0,HDR3E-HDR3S           L' MSG\n         LA    R1,HDR3S\n         TPUT (R1),(R0)  TPUT MESSAGE\n         LA    R0,L'OTTOTS              L' MSG\n         LA    R1,OTTOTS\n         TPUT (R1),(R0)  TPUT MESSAGE\n         @RET  EQ,RC=0\nRC12     TPUT  NOVIB,L'NOVIB\n         B     TESTONE\nRC16     TPUT  NOTDA,L'NOTDA\n         B     TESTONE\nERROR    TPUT  ERRMESS,L'ERRMESS           TGET/TPUT\n         B     DONE1\nEXMVC    MVC   0(0,9),0(7)\nADDPCL   DC    V(PARSEPCL)\n         DC    H'0016'\nNOVIB    DC    C'VIB NOT INIT'\nNOTDA    DC    C'NOT DASDI   '\nERRMESS  DC    C'PARSE FAILED'\nVOLMESS  DC    C'VOL VVVVVV '\nUNITMESS DC    C'UNIT UUU '\nNOVOL    DC    C'VOLUME VVVVVV NOT MOUNTED'\nHDR1S    DC    C'SPACE-2.1 IX SPACE=  --F R E E-- / -CONTIG-'\n         DC    C' DEV   % NO. -PATH- ALT.PATH'\nHDR1E    EQU   *\nHDR2S    DC    C'         VTOC      #CYL,#TRK,#EXT/#CYL,#TRK'\n         DC    C'     FRE USR #/MASK /CHPIDS '\nHDR2E    EQU   *\nHDR3S    DC    C' TOTAL-CYL TOTAL-TRK  FREE-CYL  FREE-TRK'\n*              C' Z,ZZZ,ZZ9 Z,ZZZ,ZZ9 Z,ZZZ,ZZ9 Z,ZZZ,ZZ9'\nHDR3E    EQU   *\nOTMASK   DC    X'40206B2020206B202120'  Z,ZZZ,ZZ9\n*\n*        DEVICE CHARACTERISTICS TABLE\nSTCYLS   DS    0H                  TABLE OF DEVICE TYPE TO MAX. CYLS\n         DC    X'0900'             DEVICE TYPE\nSTCYLMAX EQU   *\n         DC    H'404'              MAX CYLS\nSTCYLNAM EQU   *\n         DC    CL4'3330'           EBCDIC NAME\nSTCYLTRK EQU   *\n         DC    H'19'               TRACKS PER CYLINDER\nSTCYLTTK EQU   *\n         DC    AL2(404*19)         TRACKS PER VOL\nSTCYLS1  DS    0H                  FOR SIZE OF ENTRY CALC\n         DC    X'0D00',H'0808',CL4'3331',H'19',AL2(0808*19)\n         DC    X'0B00',H'0555',CL4'3350',H'30',AL2(0555*30)\n         DC    X'0800',H'0200',CL4'2314',H'20',AL2(0200*20)\n         DC    X'0A00',H'0696',CL4'3340',H'12',AL2(0696*12)\n         DC    X'0C00',H'0959',CL4'3375',H'12',AL2(0959*12)\n         DC    X'0E00',H'0885',CL4'3380',H'15',AL2(0885*15)\n         DC    X'FFFF',H'9999',CL4'UNKN',H'19',AL2(99*99)\nHEXTR    DC    C'0123456789ABCDEF'\n*                  0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F  - MASK BITS\nPTHONTAB DC    AL1(4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0) - # ZEROS\nPATHMASK DC    C'0000',C'0001',C'0010',C'0011'      0-3 MASK\n         DC    C'0100',C'0101',C'0110',C'0111'      4-7 MASK\n         DC    C'1000',C'1001',C'1010',C'1011'      8-B MASK\n         DC    C'1100',C'1101',C'1110',C'1111'      C-F MASK\n         PUSH  PRINT                                           25JUN84\n         PRINT  GEN                                            25JUN84\nPARSEPCL IKJPARM  DSECT=IKJPARMD\nVOL      IKJIDENT 'VOLUME',UPPERCASE,MAXLNTH=6,FIRST=ALPHANUM,       XXX\n               OTHER=ALPHANUM,LIST\nMINPATHK IKJKEYWD ,                                            25JUN84\n         IKJNAME 'MINPATHS',SUBFLD=MINPATHS                    25JUN84\nMINPATHS IKJSUBF\nMINPATHI IKJIDENT 'MINPATHS',MAXLNTH=1,                        25JUN84 X\n               FIRST=NUMERIC,                                  25JUN84 X\n               PROMPT='MINIMUM NUMBER OF PATHS TO DEVICE'      25JUN84\n         IKJENDP\n         POP   PRINT                                           25JUN84\n*        EQUATES\nDSA      DSECT\n*        WORK AREA FOR  TSSPACE CP\nANS      DS    F\nECB      DS    F\nPPL      DS    0F\nUPT      DS    F\nECT      DS    F\nECBP     DS    F\nPCL      DS    F\nANSW     DS    F\nCOMBUF   DS    F\nDSADCB   DS    X                       COPY OF CVTDCB - OP SYS\nDSADCBXA EQU   X'80'                   XA OPERATING SYSTEM\nWK       DS    F\nWKCLRS   EQU   *                        CLEAR AREA AT INIT\nMINPATHD DS    F                       MINIMUM NUMBER OF PATHS\nWKFRETRK DS    F                        TOT FREE TRKS ON ALL V\nWKFRECYL DS    F                        TOT FREE CYLS ON ALL V\nWKTOTCYL DS    F                        TOT      CYLS ON ALL V\nWKTOTTTK DS    F                        TOT      TRKS ON ALL V\nWKCLRL   EQU   *-WKCLRS\nWD       DS    D\nWLOOKUP  DS    F\n******** ***** OUTPUT TOTALS\nOTTOTS   DC    C' TOTAL CYL TOTAL TRK  FREE CYL  FREE TRK'\n*              C' Z,ZZZ,ZZ9 Z,ZZZ,ZZ9 Z,ZZZ,ZZ9 Z,ZZZ,ZZ9'\nOTTOTCYL EQU   OTTOTS+00,10\nOTTOTTTK EQU   OTTOTS+10,10\nOTFRECYL EQU   OTTOTS+20,10\nOTFRETRK EQU   OTTOTS+30,10\n******** ***** OUTPUT MESSAGE\nOUTMESS  DS    CL79                    MESSAGE AREA\n         ORG   OUTMESS                 RE-MAP\nOUTMESSV DS    CL6,C                   VOLSER\nOUTMESSU DS    CL3,C                   UNIT\nINFLAG   DS    CL2                     INDEXED VTOC FLAG AREA\nWORKA    DS    CL30                    AREA FOR LSPACE RETURN\nWA#CYL   EQU   WORKA+06,4              FREE CYL\nWA#TRK   EQU   WORKA+11,4              FREE TRK\nWA#EXT   EQU   WORKA+16,4              EXTENTS\nWA#CCYL  EQU   WORKA+21,4              CONTIG. CYL\nWA#CTRK  EQU   WORKA+26,4              CONTIG. TRK\n         DS    C                       FILLER\nOUTMESSD DS    CL4,C                   DEV NAME 3380/3350\nOUTMESSP DS    CL2,C                   %FULL\nOUTMUSER DS    CL3,C                   UCBUSER-CONC. USERS\nOUTMPTHN DS    C,CL1                   PATHS ONLINE\nOUTMPTHM DS    CL4,CL1                 PATH MASK\nOUTMALTX DS    CL3,CL6                 ALT CHAN(OR CHPIDS IN XA)\nOUTMALTC EQU   OUTMALTX+1,1            ALT CHAN(MIDDLE POS.)\nOUTMESSF EQU   OUTMESS+L'OUTMESS-*     FILLER (ASM ERR IF TOO LONG)\n         DS    (OUTMESSF)X             FILLER (ASM ERR IF TOO LONG)\nOUTMESSL EQU   *-OUTMESS\n******** ***** ************************ **********************\nVOLSER   DS   CL6       VOLSER\nUNIT     DS   CL3       UNIT\n******** ***** ************************ **********************\n*\n***            THIS CODE COPIED FROM (TSUCBSCN)\n*\n******** ***** *********************** START OF UCB LOOKUP DSA\nDSXALIST DS    0F                      PARMLIST FOR UCB\nDSXAWA   DS    F                       %100-BYTE WORK AREA\nDSXADEVT DS    F                       %DEV TYPE TO SEARCH\nDSXAUCB  DS    F                       %UCB FULL WORD PTR\n         DS    0D                      FOLLOWING MUST BE ALIGNED\nDSXAWORK DS    CL100                   UCB WORK AREA\nDSXAEUCB EQU   DSXAWORK+00,04          EMULATION CURR. UCB PTR\nDSXAEILK EQU   DSXAWORK+04,04          EMULATION CVTILK2 ADDR\nDSXACLAS DS    CL1                     DEVICE CLASS TO SEARCH\nDSXAUCBP DS    F                       %UCB\n******** ***** *********************** END OF UCB LOOKUP DSA\nDSAEND   EQU  *                         LENGTH OF WORK\n         IEFUCBOB ,                    UCB\n         CVT   DSECT=YES               CVT\nLCH      DSECT                         LCH\n         ORG   LCH+16\nLCHTCH   DS    A\nCSD      DSECT                         CSD\n         ORG   CSD+8\nCSDCPUAL DS    XL2\nCPU1     EQU   X'40'\nCPU2     EQU   X'20'\n         END  ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSYSTEM": {"ttr": 2819, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TSSYSTEM TITLE 'S Y S T E M   C O N F I G U R A T I O N   DISPLAY'\n*FROM CBT#213 FILE300 30NOV83\n*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*\n*                                                                     *\n*TSSYSTEM IS THE OS/MVS VERSION OF THE SYSTEM CONFIGURATION DISPLAY   *\n*     COMMAND.  IT SHOWS A TSO USER THE OPERATING SYSTEM, RELEASE,    *\n*     CPU MODEL, SERIAL NUMBER(S), AND MAIN STORAGE SIZE, AND DATE.   *\n*     TIME SINCE IPL (OR LAST SET IPS)\n*NOTE: FOR MVS/XA AMODE SHOULD BE 31 C.HUNTER 5SEP84\n*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*\n         MACRO\n         $MSG  &P=B\n.*       ***** MACRO USED TWICE, ONCE TO MAP CONSTANT DATA\n.*       ***** THEN IN DSECT FOR RENT-DYNAMIC STOR\n&P.TYPE  DC    CL1'R'\n&P.RLSE  DC    CL2'03'\n         DC    C'.'\n&P.LEVL  DC    CL2'0A'\n         DC    C' '\n&P.MODL  DC    CL4'S370'\n         DC    C' #'\n&P.SNUM  DC    CL6'/UNKN'\n&P.CORE  DC    X'402020202120',C'K '\n         DC    C'IPL-'\n&P.IPLV  DC    CL6'SYSRES'\n&P.HH    DC    X'40202120'         _HHH\n         DC    C'=HRS(MASTER TRAN TIME) '\n&P.DATE  DC    X'21204B202020' YY.DDD\n         DC    C'=TODAY'\n         MEND\n         SPACE 2\nTSSYSTEM @ENT  R11,(,DSAEND-DSA),DSA=YES\nTSSYSTEM AMODE 31                      RMCT/OUCB ABOVE 16M\n*SYSMVS  CSECT\n*        SPACE\n*        JVDENTER DSA=(DSAEND-DSAWRK),VERSION=&SYSPARM\n*        USING    DSAWRK,R13\n         EJECT\n         L     R10,CVTPTR\n         USING CVT,R10\n         L     R3,CVTSYSAD\n         LA    R5,0(R10)\n         S     R5,F8\n         MVC   BUFFER(BUFEND-BUFFER),MASK\n         MVC   BRLSE,4(R5)\n         MVC   BLEVL,6(R5)\n         LA    R15,16\n         IC    R14,CVTDCB\n         N     R14,VSMASK\n         SRL   R14,1\n         L     R9,CVTEORM\n         SRA   R9,10\n         LA    R9,1(R9)\n         CVD   R9,DWD\n         ED    BCORE,DWD+5\n         MVC   BIPLV,UCBVOLI-UCBOB(R3)\n         ED    BDATE,CVTDATE+1\n         L     R14,CVTPCCAT            PCCAVT (+2FC)\n         ICM   R4,15,0(R14)            UNIPROCESSOR ONLY!!\n         BNZ   MCPUINFO                MOVE CPU INFO           DDMMM84\n         ICM   R4,15,4(R14)            TRY CPU 1\n         BNZ   MCPUINFO                MOVE CPU INFO           DDMMM84\n         ICM   R4,15,8(R14)            TRY CPU 2\n         BNZ   MCPUINFO                MOVE CPU INFO           DDMMM84\n         ICM   R4,15,12(R14)           TRY CPU 3 (3084)\n         BNZ   MCPUINFO                MOVE CPU INFO           DDMMM84\n         B     MCPUSKIP                SKIP IT                 DDMMM84\nMCPUINFO DS    0H                                              DDMMM84\n         MVC   BSNUM,4+2(R4)           PCCACPID SERIAL # (6)\n         MVC   BMODL,4+8(R4)           \"        MODEL  # (4)\n*        MVC   BVERS,4+0(R4)           \"        VERSION#(2)    DDMMM84\nMCPUSKIP DS    0H                                              DDMMM84\n*\n**             CALC TIME FROM IPL  (OR SET IPS)\n*\n         L     R14,CVTOPCTP        SRM'S RMCT\n         USING RMCT,R14\n         L     R15,CVTASVT         ASVT\n         USING ASVT,R15\n         L     R2,ASVTFRST+4       MASTER SCHEDULER ASCB(I HOPE)\n         USING ASCB,R2\n         L     R1,ASCBOUCB         *MASTER* OUCB\n         USING OUCB,R1\n         L     R0,RMCTTOD          CURRENT TOD\n         S     R0,OUCBTMO          GET DELTA = (TIME SINCE IPL)\n         DROP  R1\n         SRDL  R0,32               CONVER TO SECONDS\n         D     R0,=F'1024'         CONVERT TO SECONDS.\n         SR    R0,R0               IGNORE REMAINDER.\n         A     R1,=F'1800'         ROUND\n         D     R0,=F'3600'         DIVIDE TO GET HOURS.\n         CVD   R1,DWD              CONVERT HOURS -\n         ED    BHH,DWD+6           - TO PRINTABLE FORMAT.\n         DROP  R14,R15,R2\n         EJECT\n         LA    R7,BUFEND-BUFFER\n         TPUT  BUFFER,(R7)\n         SPACE\n*        JVDLEAVE\n         @RET  EQ,RC=0\n         EJECT\nVSMASK   DC    F'2'\nF8       DC    F'8'\nMASK     EQU   *                   KEEP IN SYNC WITH B.... DSA FIELDS\n         $MSG  P=M                 MAP CONSTANTS FOR MESSAGE\n         LTORG\n*\n**\n*\nDSA      DSECT\n*SSA     DS   18F\nBUFFER   EQU  *\n         $MSG  P=B                 MAP MESSAGE AREA\nBUFEND   EQU   *\nDWD      DS    D\nDSAEND   EQU   *\n*        SPACE\n*        JVDEQU\n         EJECT\nCVT      DSECT\n         CVT   LIST=YES,DSECT=YES\n         IHAASVT\n         IHAASCB\n         IRAOUCB\n*        IRARMCT\nRMCT     DSECT\n         ORG   RMCT+X'7C'\nRMCTTOD  DS    F\n         IEFUCBOB\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTCALL": {"ttr": 2822, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     VTCALL &RTN,&TEST\n&LAB     LA    R1,VTOCOM      POINT TO THE COMMON AREA\n         L     R15,VAD&RTN    POINT TO THE ROUTINE\n         AIF ('&TEST' NE 'TEST').NOTEST\n         LTR   R15,R15       SEE IF THE ROUTINE IS PRESENT\n         BZ    *+6           DON'T CALL IT IF IT'S NOT THERE\n.NOTEST  ANOP\n         BALR  R14,R15        THEN CALL IT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTEXCP": {"ttr": 2824, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   VTEXCP  &FUNC\n         AIF   ('&FUNC' NE 'EQ').CALL\nVTCOPEN  EQU   1              DEFINE FUNCTION CODES FOR VTOCEXCP\nVTCCLOSE EQU   2\nVTCREAD  EQU   0\nVTCCCHH  EQU   3\n         MEXIT\n.CALL    ANOP                 CALL VTOCEXCP\n&LABEL   MVI   VTCEFUNC,VTC&FUNC   SET THE FUNCTION CODE\n         VTCALL EXCP          GO GET A DSCB\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTFMT": {"ttr": 2826, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         VTFMT\n*\n*        THIS DSECT DESCRIBES THE FORMATTED DSCB\n*\nVTFMT    DSECT\nVTFNEXT  DS    A              POINTER TO NEXT DSCB\nVTFALLOC DS    F              ALLOCATION IN UNITS AS DEFINED BY THE\n*                               COMMAND.  KBYTES, MBYTES, TRACKS, OR\n*                               CYLS MAY BE THE UNIT.\nVTFUSED  DS    F                AMOUNT USED, SAME UNIT\nVTFUNUSD DS    F                AMOUNT UNUSED, SAME UNIT\nVTFPCT   DS    H                PERCENT USED,  0-100\nVTFVOLUM DS    CL6            VOLUME SERIAL NUMBER\nVTFCREDT DS    XL3            CREATION DATE YYDDD\nVTFEXPDT DS    XL3            EXPIRATION DATE YYDDD\nVTFLSTAC DS    XL3            LAST ACCESS DATE YYDDD\nVTFNOEPV DS    AL1            NUMBER OF EXTENTS PER VOLUME\nVTFDSORG DS    CL3            DATA SET ORGANIZATION\n*                               PS, PO, DA, VS, IS, PERHAPS U\nVTFRECFM DS    CL5            RECORD FORMAT\n*                               F,V, OR U, B, T, S, A, M\nVTFLRECL DS    H              LOGICAL RECORD LENTGH\nVTFBLKSZ DS    H              BLOCK SIZE\nVTFROUND DS    C             R IF ROUND WAS SPECIFIED\nVTFPROT  DS    C              PASSWORD PROTECTION FLAG\nVTFCATLG DS    C              CATALOG INDICATION\nVTFSECAM DS    XL2           SECONDARY AMOUNT\nVTFSECAL DS    C              SECONDARY ALLOCATION TYPE\n*                               C FOR CYL, T FOR TRKS, B FOR BLOCKS\n*                               R FOR BLOCKS WITH ROUND\nVTFDSTYP DS    C              DATA SET TYPE, USER MAY DEFINE\n*                               S = SYSTEM TEMPORARY DATA SET\n*                               T = TEST DATA SET\n*                               P = PRODUCTION DATA SET\nVTFACTON DS    CL8            REQUESTED ACTION OR COMMENT\nVTFDSNL  DS    H              LENGTH OF DSNAME\nVTFMTL   EQU   *-VTFMT        FIXED LENGTH OF THIS DSECT\nVTFDSN   DS    44C            VARIABLE LENGTH FIELD\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOC": {"ttr": 2828, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "VTOCCMD  TITLE 'VTOC COMMAND - LIST DATA SETS AND ATTRIBUTES'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* FUNCTION -   PROVIDE THE ABILITY FOR A TSO USER OR A BATCH JOB      *\n*              TO LIST THE CONTENTS OF VARIOUS VOLUMES, WITH A        *\n*              FAIR AMOUNT OF SELECTION.                              *\n*                                                                     *\n*                                                                     *\n* OPERATION -  ACCEPT FROM THE TSO USER OR BATCH JOB A COMMAND        *\n*              WITH THE FOLLOWING SYNTAX.  THEN CHECK THE COMMAND     *\n*              AND LOOP THROUGH, GETTING A DSCB, FORMATTING IT,       *\n*              PERFORMING THE DATA SET NAME AND LIMIT CHECKS, AND     *\n*              CALLING AN EXIT ROUTINE IF DESIRED, THEN PUT THE       *\n*              ENTRY IN THE CORRECT SORT SEQUENCE.                    *\n*              FINALLY CALL THE PRINT ROUTINE TO PRINT THE            *\n*              SPECIFIED ITEMS, HEADERS, AND BREAKS, OR JUST          *\n*              THE TOTALS.                                            *\n*                                                                     *\n*                                                                     *\n* INPUT -      STANDARD COMMAND PROCESSOR PARAMETER LIST              *\n*              POINTED TO BY REGISTER 1                               *\n*                                                                     *\n*                                                                     *\n* OUTPUT -     TO SYSOUT, A LIST OF THE REQUESTED DATA SETS AND       *\n*              THEIR ATTRIBUTES.                                      *\n*                                                                     *\n*                                                                     *\n* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *\n*                                                                     *\n*                                                                     *\n*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *\n*              FIREMAN'S FUND INSURANCE  CPSD 2N                      *\n*              ONE LUCAS GREEN                                        *\n*              SAN RAFAEL, CA  94911                                  *\n*              ADDED ICF (123 EXTENT SUPPORT) CLARK            25JUN84\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\n         MACRO\n&LABEL   VTOCEXCP  &FUNC\n         AIF   ('&FUNC' NE 'EQ').CALL\nVTCOPEN  EQU   1              DEFINE FUNCTION CODES FOR VTOCEXCP\nVTCCLOSE EQU   2\nVTCREAD  EQU   0\n         MEXIT\n.CALL    ANOP                 CALL VTOCEXCP\n&LABEL   MVI   VTCEFUNC,VTC&FUNC   SET THE FUNCTION CODE\n         VTCALL EXCP          GO GET A DSCB\n         MEND\n*\n*        MACRO FOR INITIALIZING SUBROUTINE WORK AREA ADDRESSES\n*\n         MACRO\n&LABEL   WORKADDR &RTN,&PRMADDR\n&LABEL   L     R1,=A(WORK&RTN-WORKAREA)  GET THE OFFSET ( OVER 4K )\n         LA    R1,0(R1,R13)   RELOCATE IT\n         ST    R1,&PRMADDR   THEN STORE IT FOR THE ROUTINES\n         MEND\n*\n         EJECT\nVTOCCMD  ENTERX 12,(1,LENWORK,C)     DO THE HOUSEKEEPING\n         LR    R2,R1          SAVE ADDR OF CPPL\n         SPACE\n         USING WORKAREA,WORKREG\n         EJECT\n         BAL   R14,PARSINIT   PERFORM THE PARSING\n         LTR   R15,R15        TEST THE RETURN CODE\n         BNZ   RETURN         BAD NEWS, GET OUT\n         VTCALL PRNT         INITIALIZE FOR PRINTING\n         L     R9,ADDRANSR    ADDR OF PARSE DESCRIPTOR LIST\n         USING PDL,R9         RETURNED BY PARSE\n*\n*\n*        SCAN SORT PARSE LIST AND BUILD SORT FIELD TABLE\n*\n*\nSORTPAR  LA    R4,SUBSORT     SORT PARSE LIST\n         LA    R5,SORTTAB     SORT FIELD TABLE\n         XC    0(64,R5),0(R5) CLEAR SORT FIELD TABLE\n         MVC   0(4,R5),SORTTABX DEFAULT TO DSNAME\n         SPACE 1\nSORTPAR1 LA    R1,SORTTABX-12 SORT COMPARE TABLE\n         SPACE 1\nSORTPAR2 LA    R1,12(0,R1)    POINT TO NEXT COMPARE ENTRY\n         CLC   0(4,R1),=F'0'  END OF TABLE\n         BE    SORTPAR3       ITEM NOT FOUND, IGNORE\n         L     R6,0(0,R4)     POINT TO TEXT\n         LH    R3,4(0,R4)     TEXT LENGTH\n         LTR   R3,R3          IGNORE IF ZERO\n         BZ    SORTPAR3\n         BCTR  R3,0\n         EX    R3,SORTCOMP    FIELD NAME MATCH\n         BE    SORTPAR4       YES\n         B     SORTPAR2       NO, TRY NEXT\n         SPACE 1\nSORTPAR3 ICM   R4,7,9(R4)     NEXT ITEM\n         BNZ   SORTPAR1       CONTINUE IF MORE\n         B     SORTPAR5\n         SPACE 1\nSORTPAR4 MVC   0(4,R5),0(R1)  SET UP SORT FIELD\n         ICM   R4,7,9(R4)     ASCENDING/DESCENDING INDICATOR\n         BZ    PARMERR        ERROR IF MISSING\n         L     R6,0(0,R4)     INDICATOR ADDR\n         CLC   4(2,R4),=F'0'  ERROR IF MISSING\n         BE    PARMERR\n         MVC   0(1,R5),0(R6)  A/D INDICATOR\n         LA    R5,4(0,R5)\n         CLI   0(R6),C'A'     ASCENDING SORT\n         BE    SORTPAR3       YES, OK\n         CLI   0(R6),C'D'     DESCENDING SORT\n         BNE   PARMERR        NO, ERROR\n         B     SORTPAR3       CHECK IF ANY MORE\n         SPACE 1\nSORTCOMP CLC   4(0,R1),0(R6)\n         SPACE 1\nSORTPAR5 LA    R3,SORTKTAB-12 SORT HEADER INDEX TABLE\nSORTK1   LA    R3,12(0,R3)    NEXT ENTRY\n         CLC   0(4,R3),=F'0'  END OF TABLE\n         BE    SORTK3         YES\n         CLC   SORTTAB+1(1),1(R3)  ENTRY MATCH\n         BNE   SORTK1         NO, CHECK NEXT\n         SR    R4,R4\n         LH    R5,2(0,R3)     LOAD TABLE LENGTH\n         D     R4,=F'12'      TABLE ENTRIES\n         LA    R5,1(0,R5)\n         LA    R6,VTCSORTH\n         L     R4,4(0,R3)     LOAD TABLE BEGIN ADDR\n         CLI   SORTTAB,C'D'   DESCENDING SORT\n         BE    SORTK2         YES\n         L     R4,8(0,R3)     LOAD TABLE END ADDR\nSORTK2   MVC   0(12,R6),0(R4)\n         LA    R4,12(0,R4)\n         LA    R6,12(0,R6)\n         CLI   SORTTAB,C'D'   DESCENDING SORT\n         BE    *+8            YES\n         S     R4,=F'24'\n         BCT   R5,SORTK2\n         B     SORTK4\nSORTK3   MVC   VTCSORTH(12),=3F'0'\nSORTK4   MVC   0(12,R6),=3F'0'\n*\n*        CHECK THROUGH THE UCB'S TO SELECT THE VOLUMES TO PROCESS\n*\n*\n**  FIND A VOLUME SERIAL NUMBER\n*\n         LA    R3,VOLS        POINT TO THE PDL\nLOOP1    L     R5,0(R3)       GET THE ADDRESS OF THE TEXT\n         LH    R4,4(R3)       ALSO GET ITS LENGTH\n         LTR   R4,R4          FOR EXECUTES, GET THE LENGTH\n         BZ    PHASE2         NO MORE VOLUMES, CONTINUE TO NEXT PHASE\n         BCTR  R4,0           MAKE IT READY FOR THE EX INSTR\n         MVC   VOLSER,BLANKS   INITIALIZE FIELD\n         EX    R4,MOVVOL\n*\n**  VOLUME FOUND - VERIFY AND CHECK FOR GLOBAL OR SPECIAL REQUESTS\n*\n         CH    R4,H5          IS THE ENTIRE NAME THERE?\n         BE    VOLSET         YES, IT'S A SPECIFIC VOLUME\n         MVI   FLAG,X'01'     IT'S A GENERIC REQUEST\n         CH    R4,H2          CHECK FOR THE ALL KEYWORD, FIRST LENGTH\n         BNE   VOLSET         NOT A GLOBAL REQUEST\n         CLC   0(3,R5),CHARALV  IS THIS THE KEYWORD 'ALLV'?\n         BE    VOLSETV        NO, NOT A GLOBAL REQUEST\n         CLC   0(3,R5),CHARALL  IS THIS THE KEYWORD 'ALL'?\n         BNE   VOLSET         NO, NOT A GLOBAL REQUEST\nSETGLOB  DS    0H\n         MVI   FLAG,X'02'   GLOBAL REQUEST\n         B     VOLSET\n*\n**  FIND THE A(UCB)\n*\nVOLSETV  MVI   FLAG,X'82'   GLOBAL REQUEST FOR VIRTUAL\nLOCUCB   DS    0H  -----------------FORMAT IOS SCAN PARM LIST\nVOLSET   DS    0H\n         XC    DSXAWORK,DSXAWORK       ZERO OUT UCB WORKAREA\n         LA    R1,DSXAWORK             ADDR OF UCB WORKAREA\n         ST    R1,DSXAWA               STORE IT IN PARM LIST\n         LA    R1,DSXACLAS             PTR TO DEV CLAS TO SEARCH\n         ST    R1,DSXADEVT             STORE IN PARM LIST\n         MVI   DSXACLAS,UCB3DACC       ONLY SEARCH DASD\n         LA    R1,DSXAUCBP             AREA TO STORE UCB ADDR\n         ST    R1,DSXAUCB              IN PARM LIST\n         OI    DSXAUCB,X'80'           SIGNIFY END OF PARMLIST\nLOCUCB1  DS    0H  -----------------SCAN FOR A UCB---------\nNEXTUCB  DS    0H  -----------------SCAN FOR A UCB---------\n         L     R15,CVTPTR\n         ICM   R15,15,X'434'(R15)      CVTUCBSC VALID?(IOSVSUCB)\n         BZ    LOCUCBE0                ZERO=OLD MVS\n***>>>>>>----UCB SCAN SERVICE FOR MVS/SP1.2 AND ABOVE:-----<<<<<<***\n** PARM:(100BYTE-WORK,1BYTE-DEV-CLASS,1WORD-UCB-PTR)              **\n**RETURN CODES: R15 = 00-UCB RETURNED; 04-NO MORE UCBS            **\n         LA    R1,DSXALIST             PTR TO PARM LIST\n         BALR  R14,R15                 BRANCH TO IT\n         B     LOCUCBXX                COMMON ENTRY POINT\n***>>>>>>----- EMULATION UCB SCAN SERVICE FOR OLD MVS------<<<<<<***\nLOCUCBE0 DS    0H\n         ICM   R14,B'1111',DSXAEUCB    BR IF THIS IS\n         BNZ   LOCUCBE1                SECOND OR LATER CALL\n         L     R14,CVTPTR              ADDR-UCB VECTOR TABLE\n         L     R14,X'24'(R14) CVTILK2-CVT(R14) ADDR-UCB VECTOR TABLE\n         ST    R14,DSXAEILK            SAVE(TO CHECK FOR DUPS)\nLOCUCBE1 DS    0H\n         SR    R1,R1                   ZERO UCB ADDR PTR\nLOCUCBE3 DS    0H\n         LA    R14,2(,R14)             NEXT PTR(1ST UCB SKIPPED)\n         ICM   R1,B'0011',0(R14)       ADDR OF UCB\n         BZ    LOCUCBE3                BR IF NULL ENTRY\n         LA    R15,4                   SHOW NO HITS (CC UNCHANGED)\n         BO    LOCUCBEX                BR IF END\n         LA    R15,0                   SHOW HITS (CC UNCHANGED)\nLOCUCBE5 DS    0H\n         CLC   DSXACLAS,UCBTBYT3-UCBCMSEG(R1) BR IF THIS UCB\n         BNE   LOCUCBE3                IS NOT DESIRED CLASS\n         ST    R1,DSXAUCB              PROVIDE ADDR OF UCB\n         ST    R14,DSXAEUCB            REMEMBER WHERE TO RESUME\n***>>>>> CHECK FOR DUPLICATE CHANNEL PATH\n         L     R14,DSXAEILK            ADDR OF FIRST UCB PTR\nLOCUCBE7 DS    0H\n         CL    R14,DSXAEUCB            EXIT IF NO DUPLICATE\n         BE    LOCUCBEX                CHANNEL PATH FOUND(R15=0)\n         LA    R14,2(,R14)             ADDR OF NEXT PTR\n         CLC   0(2,R14),DSXAUCB+2      CONTINUE LOOP IF THIS IS NOT\n         BNE   LOCUCBE7                DUPLICATE CHANNEL PATH\n         L     R14,DSXAEUCB            SETUP TO RESUME SCAN\n         B     LOCUCBE3                AND GO RE-ENTER LOOP\nLOCUCBEX DS    0H\n***>>>>>>       UCB SCAN ROUTINE - COMMON RETURN POINT     <<<<<<***\nLOCUCBXX LTR   R15,R15                 GOT ONE?\n         BNZ   NOTMNT                  NO\n         L     R6,DSXAUCBP GET ADR OF  UCB FROM PTR\n         TM    FLAG,X'02'   CHECK FOR GLOBAL\n         BO    FNDGBL   IT IS\n         TM    FLAG,X'01'   CHECK FOR SPECIAL REQUESTS\n         BO    SPECUCB   IT IS\n         CLC   VOLSER,28(R6)   COMPARE FULL VOLSER\n         BE    FNDUCB   FOUND IT\n         B     INCR1\nSPECUCB  DS    0H\n         CLC   CHARALX,VOLSER          ALLX                    25JUN84\n         BNE   CHKVOL                  NO-COMPARE FIRST X CHAR 25JUN84\n         CLI   28(R6),C'X'             X VOLSERS?              25JUN84\n         BE    INCR1                   YES-SKIP IT             25JUN84\n         B     CHKRDY                  NO-HIT                  25JUN84\nCHKVOL   DS    0H\n         EX    R4,CLCVOL   COMPARE FIRST X CHARACTERS ONLY\n         BE    CHKRDY\nINCR1    DS    0H\n         B     NEXTUCB   TRY NEXT UCB\n*\n*        VARIOUS ERRORS, LET THE PERSON KNOW\n*\nNOTMNT   TM    FLAG,X'04'     WAS A VOLUME  FOUND?\n         BO    NEXTVOL        YES, LOOK FOR THE NEXT SPEC\n         MVC   MSGTEXT2,MSGNOTMT  NO, GET THE ERROR MESSAGE\nSETVOL   MVC   MSGTEXT2+5(6),VOLSER ADD THE VOLUME SERIAL NUMBER\n         VTOCMSG MSGTEXT2     AND ISSUE THE MESSAGE\n         B     NEXTVOL       GO GET THE NEXT VOLUME FROM PARSE\nPENDING  MVC   MSGTEXT2,MSGPEND   SET UP THE MESSAGE\n*\n*        SEE IF THIS IS A GENERIC OR GLOBAL REQUEST\n*\n         TM    FLAG,X'03'    WAS IT ALL OR A PARTIAL VOLUME SERIAL?\n         BNZ   INCR1         IN EITHER CASE, SKIP THE MESSAGE\n*                            THEN FIND MORE VOLUMES\n*\n*        OUTPUT THE OFFLINE PENDING MESSAGE\n         B     SETVOL         THEN ADD THE VOLUME\nOFFLINE  MVC   MSGTEXT2,MSGOFFLN SET UP THE MESSAGE\n         B     SETVOL         THEN ADD THE VOLUME\n*\n**  FOR GLOBAL REQUESTS JUST LIST ONLINE PACKS\n*\nFNDGBL   TM    3(R6),X'80'   ONLINE BIT\n         BZ    INCR1   NOPE\n*\n**  FOR GLOBAL AND SPECIAL REQUESTS, CHECK FOR DEVICE READY\n*\nCHKRDY   TM    6(R6),X'40'   TEST READY BIT\n         BO    INCR1   NOT READY\n         TM    FLAG,X'80'   GLOBAL REQUEST FOR VIRTUAL\n         BO    CHKVIRT\n         TM    FLAG,X'02'   GLOBAL REQUEST\n         BZ    FNDUCB\n         TM    17(R6),X'08'  VIRTUAL UCB\n         BO    INCR1   YES\n         B     FNDUCB\nCHKVIRT  TM    17(R6),X'08'  VIRTUAL UCB\n         BZ    INCR1   NO\n*\n**  MOVE UCB INFORMATION TO OUTPUT LINE\n*\nFNDUCB   MVC   VOLID,28(R6)   MOVE VOLID\n         MVC   ADDR,13(R6)   MOVE UNIT ADDRESS\n         OI    FLAG,X'04'      NOTE THE VOLUME AS FOUND\n*\n**  IF OFFLINE, DO NOT PROCESS\n*\n         TM    3(R6),X'40'   PENDING BIT - SHOULD BE OFF\n         BO    PENDING\n         TM    3(R6),X'80'   ONLINE BIT - SHOULD BE ON\n         BZ    OFFLINE\n*\n*        NOW GET DSCB'S FROM THE VOLUME\n*\n*\n*        SET UP THE PARM LIST FOR VTOCEXCP\n*\n         VTOCEXCP OPEN        OPEN THE VTOC\n         LTR   R15,R15        DID IT OPEN OK?\n         BNE   RETURN         NO, JUST EXIT\nREADDSCB CLI   TABFULL,0     CHECK FOR FULL TABLES\n         BNE   ENDVTOC       IF FULL, TRY END OF VTOC TO CLEAR\n         VTOCEXCP READ        GET A DSCB\n         CH    R15,H4         CHECK THE RETURN CODE\n         BE    ENDVTOC        END OF VTOC\n         BH    RETURN         BAD ERROR, VTOCEXCP GAVE THE MESSAGE\n*\n*        CHECK THE DATA SET QUALIFICATIONS, LIMIT, AND, OR\n*\n         VTCALL CHEK          CALL THE CHECK ROUTINE\n         LTR   R15,R15        DOES THIS DATA SET GET PASSED ON?\n         BNZ   READDSCB       NO, GET ANOTHER\n*                             YES, CONTINUE PROCESSING\n*\n*        FORMAT THE DSCB INFORMATION\n*\n         TM    VTCFMTCK,VTCFMTCD WAS FORMAT CALLED BY CHECK?\n         BO    CALLEXIT       YES, DON'T CALL IT AGAIN\n         VTCALL FORM          CALL THE FORMATTING ROUTINE\n         LTR   R15,R15        DID IT FUNCTION?\n         BNZ   READDSCB       NO, GET ANOTHER DSCB\n*\n*        CALL THE EXIT ROUTINE IF ONE WAS SPECIFIED\n*\nCALLEXIT VTCALL EXIT,TEST     CALL THE EXIT ROUTINE\n         LTR   R15,R15        SHOULD THE DATA SET BE PASSED ON?\n         BNZ   READDSCB       NO, GET ANOTHER DSCB\n*\n*        SORT THE ENTRIES INTO THE NEW LIST\n*\n         VTCALL SORT          CALL THE SORT ROUTINE\n         B     READDSCB       GET ANOTHER DSCB\n*\n*        END OF THE VOLUME, CHECK FOR MORE\n*\nENDVTOC  VTOCEXCP CLOSE FIRST CLOSE THE VTOC\n*\nENDVOL   TM    FLAG,X'03'         IS THIS A GENERIC VOLUME SEARCH\n         BNZ   INCR1              YES, SEARCH FOR MORE\nNEXTVOL  ICM   R3,B'0111',25(R3)  GET THE NEXT VOLUME FROM THE PDL\n         BP    LOOP1              THERE IS ANOTHER, GET IT\n*\n*        PRINT THE SELECTED ITEMS FOR THE SELECTED DATA SETS\n*\nPHASE2   DS    0H\n         VTCALL PRNT          CALL THE PRINT ROUTINE\n         B     EXIT0\n         EJECT\n*\n*        PROCESSING IS COMPLETE, EXEUNT\n*\nPARMERR  LA    R15,16\n         B     RETURN\nEXIT0    SR    R15,R15\n         SPACE 3\nRETURN   LTR   R2,R15         NORMAL EXIT?\n         BZ    RETURN1        YES, LEAVE EVERY THING ALONE\n         SPACE 2\n         LA    R1,PARMLIST    AREA FOR STACK PARM LIST\n         USING IOPL,R1        AN ERROR WAS FOUND, FLUSH THE STACK\n         SPACE\n         MVC   IOPLUPT,ADDRUPT\n         MVC   IOPLECT,ADDRECT\n         LA    R0,ATTNECB\n         MVI   ATTNECB,0\n         ST    R0,IOPLECB\n         SPACE 2\n         STACK PARM=PARMLIST+16,DELETE=ALL,MF=(E,(1))\n         SPACE 3\n         TCLEARQ INPUT        CLEAR INPUT BUFFERS\n         SPACE 3\nRETURN1  DS    0H\n         BAL   R14,FREEPDL    FREE THE PARSE STROAGE\n         MVI   VTCEPRNT,15    TELL PRINT TO CLEAN UP HIS ACT\n*                                CLOSE DATA SETS AND FREE MAIN STORAGE\n         VTCALL PRNT          CALL THE PRINT ROUTINE\n         SPACE\n         LR    R15,R2          GET THE RETURN CODE AGAIN\n         LEAVE EQ\nWORKREG  EQU   13\n*\n*        PARSE INITIALIZATION\n*\n         SPACE 3\nPARSINIT DS    0H\n         ST    R2,CPPLADDR    AND THE CPPL ADDRESS\n         USING CPPL,R2        BASE FOR COMMAND PARM LIST\n         MVC   ADDRUPT,CPPLUPT ADDR OF USER PROFILE TABLE\n         MVC   ADDRPSCB,CPPLPSCB\n         MVC   ADDRECT,CPPLECT ADDR OF ENVIROMENT TABLE\n         MVC   ADDRCBUF,CPPLCBUF\n         DROP  R2\n         SPACE 3\n*\n*        PUT THE WORK AREA ADDRESSES INTO THE PARM LISTS\n*\n         WORKADDR MSG,VTCWMSG     WORK AREA FOR VTOCMSG\n         WORKADDR EXCP,VTCWEXCP   WORK AREA FOR VTOCEXCP\n         WORKADDR CHEK,VTCWCHEK   WORK AREA FOR VTOCCHEK\n         WORKADDR FORM,VTCWFORM   WORK AREA FOR VTOCFORM\n         WORKADDR EXIT,VTCWEXIT   WORK AREA FOR VTOCEXIT\n         WORKADDR SORT,VTCWSORT   WORK AREA FOR VTOCSORT\n         WORKADDR PRNT,VTCWPRNT   WORK AREA FOR VTOCPRNT\n         SPACE 3\n*        SET UP THE ADDRESSES FOR CALLING\n*\n         MVC   VADMSG(RTNADLEN),RTNADDRS  MOVE IN THE ADDRESSES\n*\n*\n*\n*        BUILD PARSE PARAMETER LIST AND INVOKE\n*        IKJPARS TO ANALYZE COMMAND OPERANDS\n*\n         SPACE 3\nGOPARSE  DS    0H\n         ST    R14,R14PARSE   SAVE THE RETURN ADDRESS\n         LA    R1,PARSELST    AREA FOR PARSE PARAMETERS\n         USING PPL,R1         BASE FOR PARSE PARAMETER LIST\n         SPACE 2\n         MVC   PPLUPT,ADDRUPT PASS UPT ADDRESS\n         MVC   PPLECT,ADDRECT AND ECT ADDRESS\n         MVC   PPLCBUF,ADDRCBUF AND COMMAND BUFFER ADDR\n         SPACE\n         ST    WORKREG,PPLUWA ALSO WORK AREA ADDR FOR VALIDITY EXITS\n         SPACE\n         LA    R0,ATTNECB     ECB FOR ATTN INTERRUPTS\n         MVI   ATTNECB,0      CLEAR ECB\n         ST    R0,PPLECB      PASSE TO PARSE\n         SPACE\n         LA    R0,ADDRANSR    PASS ADDR OF WORD WHERE PARSE\n         ST    R0,PPLANS      RETURNS PDL ADDRESS\n         SPACE\n         MVC   PPLPCL,ADDRPCL STORE PCL ADDRESS\n         SPACE 3\n         CALLTSSR EP=IKJPARS  INVOKE PARSE\n         DROP  R1\n         SPACE 2\n         LA    R14,MAXPARSE   RETURN CODE LIMIT\n         SPACE\n         CR    R15,R14        VERIFY RETURN CODE WITHIN LIMITS\n         BH    PARSEBAD       NO, ERROR\n         SPACE\n         B     *+4(R15)       PROCESS RETURN CODE\n         SPACE\nPARSERET B     PARSEOK         0- SUCESSFUL\n         B     PARSEERR        4- PARSE UNABLE TO PROMPT\n         B     PARSEERR        8- USER ENTERED ATTENTION\n         B     PARSEBAD       12- INVALID PARAMETERS\n         B     PARSEBAD       16- PARSE INTERNAL FAILURE\n         B     PARSEERR       20 - VALIDITY CHECK ERROR\nMAXPARSE EQU   *-PARSERET\n         SPACE 5\nPARSEBAD DS    0H\n         MVC   MSGTEXT2+4(L'MSGPARSE),MSGPARSE\n         LA    R1,MSGTEXT2+4+L'MSGPARSE\n         SPACE\n         CVD   R15,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         UNPK  0(2,R1),DOUBLE\n         SPACE\n         LA    R0,MSGTEXT2-2\n         SR    R1,R0\n         SLL   R1,16\n         ST    R1,MSGTEXT2\n         SPACE 2\n         VTOCMSG MSGCMDER,MSGTEXT2    PUT OUT 'COMMAND ERROR' MSG\n         SPACE 3\nPARSEERR LA    R15,12         ERROR CODE 12 - COMMAND FAILED\n         B     PARSERTN       RETURN FROM PARSE\n         SPACE\nPARSEOK  SR    R15,R15        CLEAR THE RETURN CODE\nPARSERTN L     R14,R14PARSE   GET THE RETURN LOCATION\n         BR    R14            AND GET OUT OF HERE\n         SPACE\n         EJECT\n*\n*        PARSE CLEANUP ROUTINE\n*\n         SPACE 3\nFREEPDL  DS    0H\n         SPACE\n         ST    R14,R14SAVE\n         SPACE\n         IKJRLSA ADDRANSR     RELEASE THE STORAGE\n         SPACE 2\n         XC    ADDRANSR,ADDRANSR\n         SPACE\n         L     R14,R14SAVE\n         BR    R14\n         EJECT\n*\n*\n*        CONSTANTS\n*\n*\n         LTORG\nRTNADDRS DC    V(VTOCMSG)\n         DC    A(0)           DUMMY ENTRY FOR THE EXIT ROUTINE\n         DC    V(VTOCEXCP)\n         DC    V(VTOCCHEK)\n         DC    V(VTOCFORM)\n         DC    V(VTOCPRNT)\n         DC    V(VTOCSORT)\nRTNADLEN EQU   *-RTNADDRS\nADDRPCL  DC    A(PCLMAIN)     ADDR OF MAIN PARSE CONTROL LIST\nFMIN1    DC    X'0000FFFF'    END OF UCB LIST\nBLANKS   DC    CL8' '         BALNKS\nH2       DC    H'2'\nH4       DC    H'4'\nH5       DC    H'5'\n*\n*\n*\n*\n*\nCHARALL  DC    CL3'ALL'\nCHARALV  DC    CL3'ALV'\nCHARALX  DC    CL3'ALX'\nMOVVOL   MVC   VOLSER(0),0(R5)\nCLCVOL   CLC   VOLSER(0),28(R6)\n         EJECT\nSORTTABX DC    AL2(VTFDSN-VTFMT),AL2(43),CL8'DSNAME'\n         DC    AL2(VTFVOLUM-VTFMT),AL2(5),CL8'VOLUME'\n         DC    AL2(VTFALLOC-VTFMT),AL2(3),CL8'ALLOC'\n         DC    AL2(VTFUSED-VTFMT),AL2(3),CL8'USED'\n         DC    AL2(VTFUNUSD-VTFMT),AL2(3),CL8'UNUSED'\n         DC    AL2(VTFPCT-VTFMT),AL2(1),CL8'PCT'\n         DC    AL2(VTFNOEPV-VTFMT),AL2(0),CL8'EX'\n         DC    AL2(VTFDSORG-VTFMT),AL2(2),CL8'DSO'\n         DC    AL2(VTFRECFM-VTFMT),AL2(4),CL8'RFM'\n         DC    AL2(VTFLRECL-VTFMT),AL2(1),CL8'LRECL'\n         DC    AL2(VTFBLKSZ-VTFMT),AL2(1),CL8'BLKSZ'\n         DC    AL2(VTFCREDT-VTFMT),AL2(2),CL8'CDATE'\n         DC    AL2(VTFEXPDT-VTFMT),AL2(2),CL8'EXPDT'\n         DC    AL2(VTFLSTAC-VTFMT),AL2(2),CL8'REFDT'\n         DC    F'0'\n         EJECT\n*\n*        PROGRAM MESSAGES\n*\n         SPACE 2\n         PRINT NOGEN\n         SPACE\nMSGPARSE MSG   ' PARSE ERROR CODE '\nMSGCMDER MSG   ' COMMAND SYSTEM ERROR'\nMSGNOTMT MSG   ' VVVVVV VOLUME IS NOT MOUNTED'\nMSGOFFLN MSG   ' VVVVVV VOLUME IS OFFLINE'\nMSGPEND  MSG   ' VVVVVV VOLUME IS PENDING OFFLINE'\n*\n*\n         EJECT\n         DS    0F\nSORTKTAB DC    AL2(VTFDSN-VTFMT),AL2(DSNSORTE-DSNSORT)\n         DC    A(DSNSORT),A(DSNSORTE)\n         DC    AL2(VTFVOLUM-VTFMT),AL2(VOLSORTE-VOLSORT)\n         DC    A(VOLSORT),A(VOLSORTE)\n         DC    AL2(VTFUSED-VTFMT),AL2(USESORTE-USESORT)\n         DC    A(USESORT),A(USESORTE)\n         DC    AL2(VTFALLOC-VTFMT),AL2(ALCSORTE-ALCSORT)\n         DC    A(ALCSORT),A(ALCSORTE)\n         DC    AL2(VTFUNUSD-VTFMT),AL2(UNUSORTE-UNUSORT)\n         DC    A(UNUSORT),A(UNUSORTE)\n         DC    AL2(VTFPCT-VTFMT),AL2(PCTSORTE-PCTSORT)\n         DC    A(PCTSORT),A(PCTSORTE)\n         DC    AL2(VTFNOEPV-VTFMT),AL2(EXTSORTE-EXTSORT)\n         DC    A(EXTSORT),A(EXTSORTE)\n         DC    AL2(VTFDSORG-VTFMT),AL2(DSOSORTE-DSOSORT)\n         DC    A(DSOSORT),A(DSOSORTE)\n         DC    AL2(VTFRECFM-VTFMT),AL2(RFMSORTE-RFMSORT)\n         DC    A(RFMSORT),A(RFMSORTE)\n         DC    AL2(VTFLRECL-VTFMT),AL2(LRCSORTE-LRCSORT)\n         DC    A(LRCSORT),A(LRCSORTE)\n         DC    AL2(VTFBLKSZ-VTFMT),AL2(BLKSORTE-BLKSORT)\n         DC    A(BLKSORT),A(BLKSORTE)\n         DC    AL2(VTFCREDT-VTFMT),AL2(CDTSORTE-CDTSORT)\n         DC    A(CDTSORT),A(CDTSORTE)\n         DC    AL2(VTFLSTAC-VTFMT),AL2(RDTSORTE-RDTSORT)\n         DC    A(RDTSORT),A(RDTSORTE)\n         DC    AL2(VTFEXPDT-VTFMT),AL2(EDTSORTE-EDTSORT)\n         DC    A(EDTSORT),A(EDTSORTE)\n         DC    2F'0'\n         SPACE 3\nDSNSORT  DC    A(0),AL2(0),CL6'Z'\n         DC    A(0),AL2(1),CL6'TV'\n         DC    A(0),AL2(1),CL6'TM'\n         DC    A(0),AL2(2),CL6'T.Z'\n         DC    A(0),AL2(2),CL6'T.Y'\n         DC    A(0),AL2(2),CL6'T.X'\n         DC    A(0),AL2(2),CL6'T.W'\n         DC    A(0),AL2(2),CL6'T.V'\n         DC    A(0),AL2(2),CL6'T.U'\n         DC    A(0),AL2(2),CL6'T.T'\n         DC    A(0),AL2(2),CL6'T.S'\n         DC    A(0),AL2(2),CL6'T.R'\n         DC    A(0),AL2(2),CL6'T.Q'\n         DC    A(0),AL2(2),CL6'T.P'\n         DC    A(0),AL2(2),CL6'T.O'\n         DC    A(0),AL2(2),CL6'T.N'\n         DC    A(0),AL2(2),CL6'T.M'\n         DC    A(0),AL2(2),CL6'T.L'\n         DC    A(0),AL2(2),CL6'T.K'\n         DC    A(0),AL2(2),CL6'T.J'\n         DC    A(0),AL2(2),CL6'T.I'\n         DC    A(0),AL2(2),CL6'T.H'\n         DC    A(0),AL2(2),CL6'T.G'\n         DC    A(0),AL2(2),CL6'T.F'\n         DC    A(0),AL2(2),CL6'T.E'\n         DC    A(0),AL2(2),CL6'T.D'\n         DC    A(0),AL2(2),CL6'T.C'\n         DC    A(0),AL2(2),CL6'T.B'\n         DC    A(0),AL2(2),CL6'T.A'\n         DC    A(0),AL2(1),CL6'SY'\n         DC    A(0),AL2(1),CL6'SV'\n         DC    A(0),AL2(1),CL6'PV'\n         DC    A(0),AL2(2),CL6'P.Z'\n         DC    A(0),AL2(2),CL6'P.Y'\n         DC    A(0),AL2(2),CL6'P.X'\n         DC    A(0),AL2(2),CL6'P.W'\n         DC    A(0),AL2(2),CL6'P.V'\n         DC    A(0),AL2(2),CL6'P.U'\n         DC    A(0),AL2(2),CL6'P.T'\n         DC    A(0),AL2(2),CL6'P.S'\n         DC    A(0),AL2(2),CL6'P.R'\n         DC    A(0),AL2(2),CL6'P.Q'\n         DC    A(0),AL2(2),CL6'P.P'\n         DC    A(0),AL2(2),CL6'P.O'\n         DC    A(0),AL2(2),CL6'P.N'\n         DC    A(0),AL2(2),CL6'P.M'\n         DC    A(0),AL2(2),CL6'P.L'\n         DC    A(0),AL2(2),CL6'P.K'\n         DC    A(0),AL2(2),CL6'P.J'\n         DC    A(0),AL2(2),CL6'P.I'\n         DC    A(0),AL2(2),CL6'P.H'\n         DC    A(0),AL2(2),CL6'P.G'\n         DC    A(0),AL2(2),CL6'P.F'\n         DC    A(0),AL2(2),CL6'P.E'\n         DC    A(0),AL2(2),CL6'P.D'\n         DC    A(0),AL2(2),CL6'P.C'\n         DC    A(0),AL2(2),CL6'P.B'\n         DC    A(0),AL2(2),CL6'P.A'\n         DC    A(0),AL2(0),CL6'N'\nDSNSORTE DC    A(0),AL2(0),CL6' '\n         SPACE 3\nVOLSORT  DC    A(0),AL2(4),CL6'33509'\n         DC    A(0),AL2(4),CL6'33508'\n         DC    A(0),AL2(4),CL6'33507'\n         DC    A(0),AL2(4),CL6'33506'\n         DC    A(0),AL2(4),CL6'33505'\n         DC    A(0),AL2(4),CL6'33504'\n         DC    A(0),AL2(4),CL6'33503'\n         DC    A(0),AL2(4),CL6'33502'\n         DC    A(0),AL2(4),CL6'33501'\n         DC    A(0),AL2(4),CL6'33500'\n         DC    A(0),AL2(4),CL6'33309'\n         DC    A(0),AL2(4),CL6'33308'\n         DC    A(0),AL2(4),CL6'33307'\n         DC    A(0),AL2(4),CL6'33306'\n         DC    A(0),AL2(4),CL6'33305'\n         DC    A(0),AL2(4),CL6'33304'\n         DC    A(0),AL2(4),CL6'33303'\n         DC    A(0),AL2(4),CL6'33302'\n         DC    A(0),AL2(4),CL6'33301'\n         DC    A(0),AL2(4),CL6'33300'\n         DC    A(0),AL2(0),CL6'T'\n         DC    A(0),AL2(0),CL6'R'\n         DC    A(0),AL2(0),CL6'P'\n         DC    A(0),AL2(0),CL6'M'\n         DC    A(0),AL2(0),CL6'I'\n         DC    A(0),AL2(0),CL6'H'\nVOLSORTE DC    A(0),AL2(0),CL6' '\n         SPACE 3\nUSESORT  DS    0F\nUNUSORT  DS    0F\nALCSORT  DC    A(0),AL2(3),XL4'0000F000',XL2'00'\n         DC    A(0),AL2(3),XL4'0000C000',XL2'00'\n         DC    A(0),AL2(3),XL4'0000A000',XL2'00'\n         DC    A(0),AL2(3),XL4'00008000',XL2'00'\n         DC    A(0),AL2(3),XL4'00006000',XL2'00'\n         DC    A(0),AL2(3),XL4'00005000',XL2'00'\n         DC    A(0),AL2(3),XL4'00004000',XL2'00'\n         DC    A(0),AL2(3),XL4'00003000',XL2'00'\n         DC    A(0),AL2(3),XL4'00002000',XL2'00'\n         DC    A(0),AL2(3),XL4'00001000',XL2'00'\n         DC    A(0),AL2(3),XL4'00000C00',XL2'00'\n         DC    A(0),AL2(3),XL4'00000800',XL2'00'\n         DC    A(0),AL2(3),XL4'00000400',XL2'00'\n         DC    A(0),AL2(3),XL4'00000300',XL2'00'\n         DC    A(0),AL2(3),XL4'00000200',XL2'00'\n         DC    A(0),AL2(3),XL4'00000100',XL2'00'\n         DC    A(0),AL2(3),XL4'000000C0',XL2'00'\n         DC    A(0),AL2(3),XL4'00000080',XL2'00'\n         DC    A(0),AL2(3),XL4'00000040',XL2'00'\n         DC    A(0),AL2(3),XL4'00000010',XL2'00'\nUSESORTE DS    0F\nUNUSORTE DS    0F\nALCSORTE DC    A(0),AL2(3),XL6'00'\n         SPACE 3\nPCTSORT  DC    A(0),AL2(1),XL2'0064',XL4'00'\n         DC    A(0),AL2(1),XL2'005A',XL4'00'\n         DC    A(0),AL2(1),XL2'0050',XL4'00'\n         DC    A(0),AL2(1),XL2'0046',XL4'00'\n         DC    A(0),AL2(1),XL2'003C',XL4'00'\n         DC    A(0),AL2(1),XL2'0032',XL4'00'\n         DC    A(0),AL2(1),XL2'0028',XL4'00'\n         DC    A(0),AL2(1),XL2'001E',XL4'00'\n         DC    A(0),AL2(1),XL2'0014',XL4'00'\n         DC    A(0),AL2(1),XL2'000A',XL4'00'\nPCTSORTE DC    A(0),AL2(1),XL6'00'\n         SPACE 3\nEXTSORT  DC    A(0),AL2(0),CL6'0'\nEXTSORTE DC    A(0),AL2(0),CL6'0'\n         SPACE 3\nDSOSORT  DC    A(0),AL2(1),CL6'VS'\n         DC    A(0),AL2(1),CL6'PS'\n         DC    A(0),AL2(1),CL6'PO'\n         DC    A(0),AL2(1),CL6'DA'\nDSOSORTE DC    A(0),AL2(1),CL6' '\n         SPACE 3\nRFMSORT  DC    A(0),AL2(1),CL6'VS'\n         DC    A(0),AL2(2),CL6'VBS'\n         DC    A(0),AL2(1),CL6'VB'\n         DC    A(0),AL2(0),CL6'V'\n         DC    A(0),AL2(0),CL6'U'\n         DC    A(0),AL2(1),CL6'FS'\n         DC    A(0),AL2(2),CL6'FBS'\n         DC    A(0),AL2(1),CL6'FB'\n         DC    A(0),AL2(0),CL6'F'\nRFMSORTE DC    A(0),AL2(0),CL6' '\n         SPACE 3\nLRCSORT  DS    0F\nBLKSORT  DC    A(0),AL2(1),XL2'4650',XL4'00'\n         DC    A(0),AL2(1),XL2'3A98',XL4'00'\n         DC    A(0),AL2(1),XL2'2EE0',XL4'00'\n         DC    A(0),AL2(1),XL2'2328',XL4'00'\n         DC    A(0),AL2(1),XL2'1770',XL4'00'\n         DC    A(0),AL2(1),XL2'0BB8',XL4'00'\n         DC    A(0),AL2(1),XL2'07D0',XL4'00'\n         DC    A(0),AL2(1),XL2'0640',XL4'00'\n         DC    A(0),AL2(1),XL2'04B0',XL4'00'\n         DC    A(0),AL2(1),XL2'0320',XL4'00'\n         DC    A(0),AL2(1),XL2'0258',XL4'00'\n         DC    A(0),AL2(1),XL2'0190',XL4'00'\n         DC    A(0),AL2(1),XL2'00C8',XL4'00'\n         DC    A(0),AL2(1),XL2'00A0',XL4'00'\n         DC    A(0),AL2(1),XL2'0078',XL4'00'\n         DC    A(0),AL2(1),XL2'0050',XL4'00'\n         DC    A(0),AL2(1),XL2'0028',XL4'00'\nBLKSORTE DS    0F\nLRCSORTE DC    A(0),AL2(1),XL6'00'\n         SPACE 3\nCDTSORT  DS    0F\nEDTSORT  DS    0F\nRDTSORT  DC    A(0),AL2(2),AL1(99),AL2(0),XL3'00'\n         DC    A(0),AL2(2),AL1(83),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(83),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(83),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(83),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(82),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(82),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(82),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(82),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(81),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(81),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(81),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(81),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(80),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(80),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(80),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(80),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(79),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(79),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(79),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(79),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(78),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(78),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(78),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(78),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(77),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(77),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(77),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(77),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(76),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(76),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(76),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(76),AL2(000),XL3'00'\n         DC    A(0),AL2(2),AL1(75),AL2(300),XL3'00'\n         DC    A(0),AL2(2),AL1(75),AL2(200),XL3'00'\n         DC    A(0),AL2(2),AL1(75),AL2(100),XL3'00'\n         DC    A(0),AL2(2),AL1(75),AL2(000),XL3'00'\nEDTSORTE DS    0F\nRDTSORTE DS    0F\nCDTSORTE DC    A(0),AL2(2),XL6'00'\n         EJECT\n*\n*\n*        P A R S E   C O N T R O L   L I S T\n*\n*\n         SPACE 3\n         COPY  VTOCPARS\n         EJECT\n*\n*        DYNAMIC WORK AREA\n*\n         SPACE 3\nWORKAREA DSECT\nMAINSAVE DS    18A\n         SPACE\n         VTOCEXCP EQ          DEFINE VTOCEXCP CODES\n         SPACE\nPARSELST DS    8A             AREA FOR PARSE PARAMETER LIST\n         SPACE\nR14SAVE  DS    A\nR14PARSE DS    A\n******** ***** *********************** START OF UCB LOOKUP DSA\nDSXALIST DS    0F                      PARMLIST FOR UCB\nDSXAWA   DS    F                       %100-BYTE WORK AREA\nDSXADEVT DS    F                       %DEV TYPE TO SEARCH\nDSXAUCB  DS    F                       %UCB FULL WORD PTR\n         DS    0D                      FOLLOWING MUST BE ALIGNED\nDSXAWORK DS    CL100                   UCB WORK AREA\nDSXAEUCB EQU   DSXAWORK+00,04          EMULATION CURR. UCB PTR\nDSXAEILK EQU   DSXAWORK+04,04          EMULATION CVTILK2 ADDR\nDSXACLAS DS    CL1                     DEVICE CLASS TO SEARCH\nDSXAUCBP DS    F                       %UCB\n******** ***** *********************** END OF UCB LOOKUP DSA\n*\n*        VTOC COMMAND COMMON AREA\n*\n         PRINT GEN\n         VTOCOM  NODSECT\n         PRINT NOGEN\n         SPACE 3\n*\n*        WORK AREAS FOR SUBROUTINES\n*\nWORKMSG  DS    XL256\nWORKEXCP DS    4XL256\nWORKCHEK DS    XL256\nWORKFORM DS    2XL256\nWORKEXIT DS    8XL256\nWORKSORT DS    XL256\nWORKPRNT DS    10XL256\n         DS    0D\nLENWORK  EQU   *-WORKAREA\n         SPACE 3\n         VTFMT\n         SPACE 3\n         PDEDSNAM\n         SPACE 3\n         IKJPPL\n         SPACE 3\n         IKJIOPL\n         SPACE 3\n         IKJPSCB\n         SPACE 3\n         IKJECT\n         SPACE 3\n         IKJCPPL\n         SPACE 3\n         IKJUPT\n         SPACE 3\n         PRINT NOGEN\n         IEFUCBOB                      UCB MAPPING MACRO\n         CVT   DSECT=YES\n         END\nVTOCCHEK TITLE 'VTOC COMMAND - CHECK  ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* FUNCTION -   CHECK THE CONDITIONS SPECIFIED ON THE VTOC COMMAND.    *\n*              SEE IF THE DATA SET PASSED SHOULD BE PROCESSED.        *\n*              THE LIMIT, ENDING, CONTAINING, CCHH, LIMIT, AND,       *\n*              AND OR KEYWORDS ARE PROCESSED BY THIS ROUTINE.         *\n*                                                                     *\n* OPERATION -  FIRST GET THE LENGTH OF THE DSNAME AND SAVE IT.        *\n*              THEN GET THE FORMAT 3 DSCB, IF ONE EXISTS.  TRY        *\n*              EACH KEYWORD TO SEE IF IT WILL EXCLUDE THE DATA        *\n*              SET FROM FURTHER PROCESSING.                           *\n*                                                                     *\n* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *\n*              POINTED TO BY REGISTER 1                               *\n*              USE PARSE DATA, FORMAT 1, 3, AND 4 DSCB'S              *\n*              FOR DSORG, RECFM, ALLOC, USED, PROT, CATLG, OR SECAL   *\n*              CALL VTOCFORM TO FORMAT THE PARMS.  USE FORMATTED DSCB *\n*                                                                     *\n* OUTPUT -     A RETURN CODE OF 0 TO CONTINUE PROCESSING OR 8 TO      *\n*              EXCLUDE THIS DATA SET.                                 *\n*                                                                     *\n* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *\n*                                                                     *\n*                                                                     *\n*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *\n*              ICF SUPPORT C. HUNTER  (313) 540-0900           25JUN84\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n*        MACROS FOR CHECK ROUTINE\n*\n         MACRO\n&LABEL   VTCHL &KEY           CALL THE KEYWORD CHECK ROUTINE\n&LABEL   L     R1,SUB&KEY.OPER    GET THE OPERATOR VALUE\n         BAL   R8,GETOPER    TRANSLATE TO A NUMBER\n         ST    R15,REFOPER     SAVE IT TOO\n         LA    R1,SUB&KEY.VALU   GET THE VALUE PDL\n         ST    R1,REFVAL      SAVE THAT ADDRESS THREE\n         CLI   FLAGNM&KEY,0  HAS IT BEEN CONVERTED?\n         BNE   VTP&SYSNDX    YES, SKIP ALONG\n         MVI   FLAGNM&KEY,1  NOTE IT AS CONVERTED\n         BAL   R8,PDLNUM     GO CONVERT IT\n         ST    R15,NUMBER&KEY      SAVE THE VALUE\n         LA    R4,SUB&KEY.KEY  POINT TO THE IKJIDENT FOR THE KEYWORD\n         BAL   R8,GETKEY     CONVERT TEXT TO A NUMERIC KEY\n         STC   R15,NUMKEY&KEY  SAVE THAT NUMERIC KEY\n         LTR   R15,R15       WAS IT SUCCESSFUL?\n         BNZ   VTP&SYSNDX    YES, SKIP ALONG\n*        ISSUE A MESSAGE - A BAD LIM, AND, OR KEYWORD\n         MVC   MSGTEXT2,KEYERR  START THE ERROR MESSAGE\n         L     R1,0(R4)      POINT TO THE TEXT\n         MVC   MSGTEXT2+49(6),0(R1)  THEN ADD IT TO THE MESSAGE\n         VTOCMSG MSGTEXT2    ISSUE THE ERROR MESSAGE\nVTP&SYSNDX DS  0H\n         SR    R1,R1         CLEAR A REGISTER\n         ICM   R1,1,NUMKEY&KEY GET THE KEYWORD VALUE\n         BZ    VTE&SYSNDX    IF NOT SET, SKIP THE EVALUATION\n         ST    R1,REFKEY      SAVE THE ADDRESS\n         LA    R1,NUMBER&KEY  GET THE ADDRESS OF CONVERTED NUMBER\n         ST    R1,REFNUM      SAVE IT'S ADDRESS\n         BAL   R8,LIMEVAL     GO EVALUATE THE EXPRESSION\nVTE&SYSNDX DS  0H\n         MEND\n         SPACE 3\n         MACRO\n&LABEL   VTANDOR &NUM         EVALUATE, THEN DO AND OR OR FUNCTION\n&LABEL   CLI   ANDOR&NUM.K+1,0  WAS THIS KEYWORD SET?\n         BE    LIMCOMP        NO, JUST CHECK THE FINAL RESULT\n         VTCHL &NUM           YES, EVALUATE\n         CLI   ANDOR&NUM.K+1,1  WAS IT AN AND ?\n         BE    VTA&SYSNDX     YES, DO THE AND\n         O     R15,LIMVAL     NO, OR IT\n         B     VTE&SYSNDX     FINISHED WITH THIS EXPRESSION\nVTA&SYSNDX N   R15,LIMVAL     AND THE EXPRESSION VALUE\nVTE&SYSNDX ST  R15,LIMVAL     SAVE THE VALUE\n         MEND\n         MACRO                                                 25JUN84\n         $FORMEX &I                                            25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+00-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+10-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+20-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+30-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+00-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+10-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+20-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+30-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+40-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+50-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+60-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84\n         MEND                                                  25JUN84\n*\n         EJECT\nVTOCCHEK ENTER 12,12          DO THE HOUSEKEEPING\n         LR    R11,R1         SAVE ADDR OF VTOCOM\n         USING VTOCOM,R11     SET ITS ADDRESSABILITY\n         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER\n         USING PDL,R9         SET ITS ADDRESSABILITY\n         USING CHEKWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA\n*\n*        SEE WHAT THE FORMAT ID IS\n*\nCHEKFMT  L     R7,DSCBADDR    POINT TO THE DSCB\n         LA    R7,8(R7)       GET PAST THE HEADER\n         USING DSCB1,R7       SET ADDRESSABILITY\n         CLI   FORMATK+1,0    DID HE SPECIFY VARIOUS DSCB'S\n         BNE   CHEKFMTI       YES, GO DO HIS CHECKS\nCHEKFMTI DS    0H             NOT YET PROGRAMMED\n*\n*        STANDARD IS ONLY TO ALLOW FORMAT ONES TO GO\n*\n         CLI   DS1FMTID,C'1'  IS THIS A FORMAT 1?\n         BNE   CHECKOUT       NO, EXCLUDE IT FROM FURTHER PROCESSING\n*\n*              FIRST SEE HOW BIG THE DSNAME IS\n*\n         LA    R1,DS1FMTID    POINT PAST THE DSNAME\n         TRT   DS1DSNAM,BLKTRTAB  FIND THE FIRST BLANK\n         SR    R1,R7          SUBTRACT TO GET THE LENGTH\n         STH   R1,DSNLEN      SAVE THE DSNAME LENGTH\n         LR    R3,R1          KEEP THE LENGTH FOR LATER\n*\n*        GET THE FORMAT 3 DSCB, IF IT EXISTS\n*\n         LA    R1,FMT3                 GET 1ST F3              25JUN84\nCHEKF3XC DS    0H                                              25JUN84\n         CLC   =XL10'0',0(R1)          CLEAR TIL EMPTY FOUND   25JUN84\n         BE    CHEKFMT3                                        25JUN84\n         XC    0(L'FMT3,R1),0(R1)      CLEAR F3                25JUN84\n         LA    R1,L'FMT3(R1)           NEXT F3                 25JUN84\n         B     CHEKF3XC                LOOP                    25JUN84\nCHEKFMT3 DS    0H                                              25JUN84\n         XC    FMT3,FMT3      CLEAR IT FIRST\n         CLC   DS1PTRDS,=XL5'0000000000'  IS THERE A FORMAT 3?\n         BE    FMT3NO         NO, SKIP ALONG\n*\n*        SET UP THE CAMLST\n*\nCHEKF3RD DS    0H                      READ F3S                25JUN84\n         MVC   CAMSEEK(4),CAMSCON  MOVE IN THE FIRST WORD OF CAMLST\n         LA    R1,DS1PTRDS    GET THE CCHHR ADDRESS\n         ST    R1,CAMSEEK+4   SAVE IT\n         LA    R1,VOLID       POINT TO THE VOLUME SERIAL\n         ST    R1,CAMSEEK+8   SAVE IT\n         LA    R1,FMT3        POINT TO THE AREA FOR THE DSCB3\n         ST    R1,CAMSEEK+12  SAVE IT\nCHEKF3R3 DS    0H                      READ F3S                25JUN84\n         OBTAIN CAMSEEK       GET THE DSCB\n         LTR   R15,R15        TEST THE RETURN CODE\n         BNZ   OBT3ERR        BAD NEWS, ISSUE THE MESSAGE\n         L     R1,CAMSEEK+12           GET F3 READ             25JUN84\n         CLC   =XL5'0',DS3PTRDS-FMT3(R1) MORE F3? (ICF)        25JUN84\n         BE    CHEKF3NO                NO                      25JUN84\n         LA    R0,DS3PTRDS-FMT3(R1)    NEXT F3 ADDR            25JUN84\n         ST    R0,CAMSEEK+4            SAVE IT                 25JUN84\n         LA    R0,L'FMT3(R1)           NEXT AVAIL F3 AREA      25JUN84\n         ST    R0,CAMSEEK+12           SAVE IT                 25JUN84\n         B     CHEKF3R3                READ NEXT F3DSCB        25JUN84\nCHEKF3NO DS    0H                                              25JUN84\n*\n*        PROCESS THE LEVEL KEYWORD\n*\nFMT3NO   CLI   LEVKEY+1,0     WAS LEVEL SPECIFIED?\n         BE    LEVEND         NO, SKIP ON\n         LA    R4,LEVEL       YES, POINT TO THE PDE\n         USING PDEDSNAM,R4    SET ADDRESSABILITY\n         LR    R2,R7          POINT TO THE START OF THE DSNAME\nLEVNEXT  SR    R5,R5          CLEAR FOR INSERT\n         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH\n         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT\n         L     R6,PDEDSN      POINT TO THE LEVEL\n         CR    R3,R5          COMPARE LENGTHS\n         BL    LEVINC         THIS LEVEL IS LONGER THAN DSN, NO MATCH\n         BCTR  R5,0           MINUS ONE FOR THE EX\n         EX    R5,COMPARE     CHECK THE LENGTHS\n         BE    LEVEND         IT MATCHES, ALLOW IT\nLEVINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT LEVEL PDE POINTER\n         BNZ   LEVNEXT        IF IT'S THERE, KEEP LOOKING\n         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME\nLEVEND   DS    0H\n         DROP  R4             FINISHED WITH THE PDE\n*\n*        PROCESS THE ENDING KEYWORD\n*\n         CLI   ENDKEY+1,0     WAS ENDING SPECIFIED?\n         BE    ENDEND         NO, SKIP ON\n         LA    R4,ENDING      YES, POINT TO THE PDE\n         USING PDEDSNAM,R4    SET ADDRESSABILITY\nENDNEXT  SR    R5,R5          CLEAR FOR INSERT\n         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH\n         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT\n         L     R6,PDEDSN      POINT TO THE ENDING\n         CR    R3,R5          COMPARE LENGTHS\n         BL    ENDINC         THIS ENDING IS LONGER THAN DSN, NO MATCH\n         LR    R2,R7          POINT TO THE START OF THE DSNAME\n         AR    R2,R3          POINT TO THE END\n         SR    R2,R5          BACKUP TO COMPARE THIS LENGTH\n         BCTR  R5,0           MINUS ONE FOR THE EX\n         EX    R5,COMPARE     CHECK THE LENGTHS\n         BE    ENDEND         IT MATCHES, ALLOW IT\nENDINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT ENDING PDE POINTER\n         BNZ   ENDNEXT        IF IT'S THERE, KEEP LOOKING\n         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME\nENDEND   DS    0H\n         DROP  R4             FINISHED WITH THE PDE\n*\n*        PROCESS THE CONTAINING KEYWORD\n*\n         CLI   CONTAINK+1,0   WAS CONTAINING SPECIFIED?\n         BE    CONEND         NO, SKIP ON\n         LA    R4,CONTAIN     YES, POINT TO THE PDE\n         USING PDEDSNAM,R4    SET ADDRESSABILITY\nCONNEXT  SR    R5,R5          CLEAR FOR INSERT\n         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH\n         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT\n         L     R6,PDEDSN      POINT TO THE CONTAINING\n         CR    R3,R5          COMPARE LENGTHS\n         BL    CONINC         THIS CONTAIN IS LONGER THAN DSN, NO MATCH\n         LR    R1,R7          POINT TO THE START OF THE DSNAME\n         AR    R1,R3          POINT TO THE END\n         SR    R1,R5          BACKUP TO COMPARE THIS LENGTH - LAST ONE\n         LR    R2,R7          POINT TO THE START OF THE DSNAME\n         BCTR  R5,0           MINUS ONE FOR THE EX\nCONCOMP  EX    R5,COMPARE     CHECK THE LENGTHS\n         BE    CONEND         IT MATCHES, ALLOW IT\n         LA    R2,1(R2)       CHECK THE WHOLE DSNAME\n         CR    R2,R1          CHECK FOR THE END OF THE REAL DSN\n         BNH   CONCOMP        NOT THERE YET\nCONINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT CONTAINING PDE POINTER\n         BNZ   CONNEXT        IF IT'S THERE, KEEP LOOKING\n         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME\nCONEND   DS    0H\n         DROP  R4             FINISHED WITH THE PDE\n*\n*        NOW THE BIG MESS, CHECK FOR LIMIT, AND'S, AND OR'S\n*\n         CLI   LIMITK+1,0     WAS LIMIT SPECIFIED\n         BE    LIMEND         NO, THEN THERE CAN BE NO AND'S OR OR'S\n         NI    VTCFMTCK,255-VTCFMTCC  TURN OFF THE ROUTINE CALL FLAG\n         VTCHL L              EVALUATE THE LIMIT 1=TRUE 0=FALSE\n         ST    R15,LIMVAL     SAVE THE ANSWER\n         VTANDOR 1            CHECK AND1 OR OR1\n         VTANDOR 2            CHECK AND2 OR OR2\n         VTANDOR 3            CHECK AND3 OR OR3\nLIMCOMP  L     R15,LIMVAL     GET THE RESULT OF ALL THIS\n         LTR   R15,R15        TEST IT\n         BZ    CHECKOUT       IT GETS EXCLUDED\nLIMEND   DS    0H\n         B     CHECKIN        ALL TESTS PASSED, INCLUDE THIS ONE\n         SPACE 5\n*\n*        EVALUATION ROUTINE FOR   KEYWORD  OPER  VALUE\n*\nLIMEVAL  L     R5,REFKEY      GET THE KEYWORD VALUE\n         MH    R5,H12         MULTIPLY IT BY 12\n         A     R5,ATABTITL    THEN RELOCATE IT\n         SR    R10,R10         CLEAR THE ROUTINE POINTER\n         TM    1(R5),X'80'    IS IT A FORMATTED ITEM?\n         BO    LIMFORM        YES, GO DO IT\n         SR    R6,R6         CLEAR A REGISTER\n         IC    R6,2(R5)      GET THE OFFSET INTO VTFMT\n         IC    R10,1(R5)      GET THE ROUTINE NUMBER\n         LTR   R10,R10         SEE IF IT'S A GOOD NUMBER\n         BP    LIMEVAL1       IT'S ALL RIGHT\nLIMABEND ABEND 702,DUMP       CRASH AND BURN\nLIMEVAL1 B     *(R10)         AND GO TO IT        +00\n         B     LIMDATE        CDATE, EXPDT, REFDT +04\n         B     LIMLUSE        *** DUMMY ENTRY *** +08\n         B     LIMFORM        FORM , USED SPACE   +12\n         B     LIMFORM        UNUSED SPACE        +16\n         B     LIMFORM        PCT USED            +20\n         B     LIMEXT         EXTENTS             +24\n         B     LIMBLREC       LRECL, BLKSZ, SEC Q +28\n         B     LIMCCHH       CCHH CHECKING        +32\n         SPACE 5\n*\n*        PERFORM THE FORMATTED ITEM CHECKING\n*\nLIMFORM  DS    0H\n         TM    VTCFMTCK,VTCFMTCC  WAS FORMAT CALLED BEFORE FOR THIS DS\n         BO    LIMFCALD       YES, DON'T CALL IT AGAIN\n         VTCALL FORM          NO, CALL IT TO GET THE ITEMS\n         OI    VTCFMTCK,VTCFMTCC+VTCFMTCD  THEN SET THE SWITCHES\nLIMFCALD SR    R2,R2          CLEAR A WORK REG\n         A     R6,FORMATAD   RELOCATE THE BLOCK\n         B     *+4(R10)         AND GO TO IT\n         B     LIMFORMA      FORMATTED ITEM\n         B     LIMABEND       CDATE, EXPDT\n         B     LIMABEND       LAST USE DATE\n         B     LIMALLOC       ALLOC, USED SPACE\n         B     LIMUNUSD       UNUSED SPACE\n         B     LIMPCT         PCT USED\nLIMFORMA DS    0H\n         IC    R2,2(R5)       GET THE OFFSET IN VTFMT\n         A     R2,FORMATAD    THEN RELOCATE IT\n         L     R4,REFVAL      GET THE VALUE PDE\n         LH    R3,4(R4)       GET THE LENGTH OF THE STRING\n         L     R1,0(R4)       AND ITS ADDRESS\n*\n*        DO THE ACTUAL COMPARE\n*\n         BCTR  R3,0           DOWN ONE FOR AN EX\n         EX    R3,COMPLIM     COMPARE AS SPECIFIED\nCOMPDONE DS    0H             GET THE OPERATOR ADDRESS\n         BL    COMPLOW        CHECK THE OPERATOR, VALUE LESS THAN ITEM\n         BE    COMPEQ         CHECK THE OPERATOR, KEYWORD EQUALS VALUE\n*                             KEYWORD IS GREATER THAN THE VALUE\nCOMPHI   CLI   REFOPER+3,NE       WAS OPERATOR NE\n         BE    COMPYES        HIGH SATISFIES THE EXPRESSION\n         CLI   REFOPER+3,GT       ALSO FOR GT\n         BE    COMPYES        HIGH SATISFIES THE EXPRESSION\n         CLI   REFOPER+3,GE       AND FOR GE\n         BE    COMPYES        HIGH SATISFIES THE EXPRESSION\n         B     COMPNO         THIS ONE DOESN'T FIT\n*                             KEYWORD IS EQUAL TO THE VALUE\nCOMPEQ   CLI   REFOPER+3,EQ       WAS OPERATOR EQ\n         BE    COMPYES        EQ   SATISFIES THE EXPRESSION\n         CLI   REFOPER+3,LE       ALSO FOR LE\n         BE    COMPYES        EQ   SATISFIES THE EXPRESSION\n         CLI   REFOPER+3,GE       AND FOR GE\n         BE    COMPYES        EQ   SATISFIES THE EXPRESSION\n         B     COMPNO         THIS ONE DOESN'T FIT\n*                             KEYWORD IS LESS THAN THE VALUE\nCOMPLOW  CLI   REFOPER+3,NE       WAS OPERATOR NE\n         BE    COMPYES        LOW  SATISFIES THE EXPRESSION\n         CLI   REFOPER+3,LT       ALSO FOR LT\n         BE    COMPYES        LOW  SATISFIES THE EXPRESSION\n         CLI   REFOPER+3,LE       AND FOR LE\n         BE    COMPYES        LOW  SATISFIES THE EXPRESSION\n         B     COMPNO         THIS ONE DOESN'T FIT\n*\n*        IT FITS OR IT DOESN'T\n*\nCOMPYES  LA    R15,1          SET A TRUE VALUE\n         BR    R8             THEN RETURN\nCOMPNO   SR    R15,R15        SET A FALSE VALUE\n         BR    R8             THEN RETURN\n*\n*        SPECIAL ROUTINES TO CHECK NON-FORMATTED ITEMS\n*\nLIMDATE  DS    0H\n*\n*        COMPARE DATES\n*\n         LA    R14,DS1CREDT  POINT TO CREATION DATE\n         CLI   REFKEY+3,CDATE      IS THAT IT?\n         BE    LIMDGET       YES, THIS IS IT\n         LA    R14,DS1EXPDT  POINT TO EXPIRATION DATE\n         CLI   REFKEY+3,EXPDT      IS THAT IT?\n         BE    LIMDGET       YES, THIS IS IT\n         LA    R14,DS1REFD   NO, USE REFERENCE DATE\nLIMDGET  SR    R15,R15       CLEAR A WORK REG\n         IC    R15,0(R14)    GET THE YEAR\n         MH    R15,H1000     TIMES 1000\n         SR    R1,R1         CLEAR ANOTHER WORK REG\n         ICM   R1,3,1(R14)    GET THE DAYS\n         AR    R15,R1        PUT THE DATE TOGETHER\n         L     R1,REFNUM     GET THE ADDRESS OF THE VALUE\n         L     R1,0(R1)      GET THE VALUE ITSELF\n         CR    R15,R1        COMPARE THEM\n         B     COMPDONE      GO CHECK OPERANDS\nLIMLUSE  DS    0H\n*\n*        LAST USE DATE\n*\n         SR    R14,R14       CLEAR THE DATE\n         CLC   ZERO,75(R7)   CHECK FOR NO DATA\n         BE    LIMLUCMP      RIGHT, SKIP ON\n         MVC   CHEKDBLW+5(3),75(R7)  MOVE IN THE LAST USE DATE\n         CVB   R14,CHEKDBLW  CONVERT IT TO BINARY\nLIMLUCMP L     R1,REFNUM     GET THE ADDRESS OF THE VALUE\n         L     R1,0(R1)      GET THE VALUE\n         CR    R14,R1        DO THE COMPARE\n         B     COMPDONE      THEN CHASE DOWN THE OPERANDS\nLIMEXT   DS    0H\n*\n*        EXTENTS\n*\n         L     R1,REFNUM     GET THE COMPARE VALUE ADDRESS\n         CLC   DS1NOEPV,3(R1)        COMPARE THEM\n         B     COMPDONE      GO CHECK OPERANDS\nLIMBLREC DS    0H\n*\n*        LRECL, BLKSZ, SECQ\n*\n         L     R1,REFNUM     GET THE ADDRESS OF THE COMPARE VALUE\n         L     R15,0(R1)      THEN GET THE VALUE ITSELF\n         CLI   REFKEY+3,BLKSZ      BLOCK SIZE?\n         BNE   LIMB1         NO, KEEP CHECKING\n         LH    R1,DS1BLKL    COMPARE TO THE BLOCK SIZE\n         CR    R1,R15        COMPARE THEM\n         B     COMPDONE      GO SIFT THROUGH THE OPERANDS\nLIMB1    CLI   REFKEY+3,LRECL  LOGICAL RECORD LENGTH\n         BNE   LIMB2         NO, KEEP GOING\n         LH    R1,DS1LRECL   COMPARE TO THE LRECL\n         CR    R1,R15        COMPARE THEM\n         B     COMPDONE      GO CHECK THE OPERANDS\nLIMB2    MVC   HWORK,DS1SCALO+2 GET THE SECONDARY QUANTITY\n         LH    R1,HWORK      DO THE COMPARE\n         CR    R1,R15        COMPARE THEM\n         B     COMPDONE      THEN CHECK THE OPERANDS\n*\n*        SPACE CHECKING ROUTINES\n*\nLIMALLOC DS    0H\n*\n*        ALLOC AND USED\n*\n         L     R1,REFNUM     GET THE ADDRESS OF THE CONVERTED NUMBER\n         L     R1,0(R1)      GET THE VALUE\n         L     R15,0(R6)     GET THE AMOUNT\n         CR    R15,R1        COMPARE THEM\n         B     COMPDONE      THEN CHECK THE OPERANDS\nLIMUNUSD DS    0H\n*\n*        UNUSED\n*\n         L     R6,FORMATAD   POINT TO THE FORMATTED VTOC\n         USING VTFMT,R6      SET ADDRESSABILITY\n         ICM   R14,15,VTFUSED      GET THE AMOUNT USED\n         BM    LIMUNUAL      IF MINUS, WE DON'T KNOW\n         L     R14,VTFALLOC  GET ALLOC\n         S     R14,VTFUSED   MINUS THE AMOUNT USED\nLIMUNUAL L     R1,REFNUM     GET THE ENTERED VALUE\n         L     R1,0(R1)      NOW ITS VALUE FOR REAL\n         CR    R14,R1        COMPARE THE VALUES\n         B     COMPDONE      THEN GO CHECK THE OPERANDS\nLIMPCT   DS    0H\n*\n*        PER CENT\n*\n         L     R6,FORMATAD   POINT TO THE FORMATTED VTOC\n         USING VTFMT,R6      SET ADDRESSABILITY\n         SR    R14,R14       CLEAR A REGISTER\n         ICM   R15,15,VTFUSED      GET THE AMOUNT USED\n         BM    LIMP100       IF UNKNOWN USED, SET 100 PER CENT\n         CLC   VTFALLOC,ZERO ZERO ALLOCATED SPACE?\n         BNE   LIMPCTOK      NO, CONTINUE\n         CLC   VTFUSED,ZERO  ZERO USED SPACE?\n         BE    LIMPCOMP      YES, PCT IS ZERO\n*              ZERO ALLOCATED, NONZERO USED, INCLUDE THIS ONE\n         B     COMPYES\nLIMP100  LA    R15,100       SET UP 100 PER CENT\n         B     LIMPCOMP      GO COMPARE\nLIMPCTOK M     R14,F100      MULTIPLY BY 100 PERCENT\n         D     R14,VTFALLOC  DIVIDE BY THE ALLOCATION\nLIMPCOMP L     R1,REFNUM     GET THE VALUE ADDRESS\n         L     R1,0(R1)      THEN THE VALUE\n         CR    R15,R1        THEN COMPARE THEM\n         B     COMPDONE      THEN GO SIFT THROUGH THE OPERANDS\n*\n*        CCHH CHECKING IS NOT QUITE STANDARD BECAUSE THERE MAY\n*        MAY BE UP TO 16 EXTENTS TO COMPARE.  THE DATA MAY BE\n*        CC OR CCHH FORMATS.  THE DATA SET MAY BE EQUAL TO,\n*        LESS THAN, AND GREATER THAN ANY PARTICULAR VALUE.\n*\nLIMCCHH  DS    0H\n*\n*        FIRST SEE IF THE CCHH WAS CONVERTED\n*              CONVERT IT IF NOT, SKIP IF IT'S DONE\n*\n         L     R5,REFNUM     GET THE ADDRESS OF THE COMPARISON VALUE\n         L     R4,0(R5)      GET THE VALUE\n         ICM   R6,3,4(R5)    GET THE COMPARE LENGTH\n         BP    LIMCSET       IF IT'S SET, THE CONVERSION IS DONE\n*                      IT WASN'T SET, CONVERT FROM CHARS TO BINARY\n         L     R1,REFVAL     GET THE ADDRESS OF THE IKJIDENT\n         L     R2,0(R1)      POINT TO THE TEXT\n         LH    R3,4(R1)      GET THE LENGTH OF THE TEXT\n*        IT SHOULD BE 4 OR 8 CHARACTERS\n         XC    DOUBLE,DOUBLE CLEAR OUT A PLACE TO WORK\n         CH    R3,H4         IS IT A CYLINDER ONLY?\n         BH    LIMCCON2      NO, TRY FOR A CCHH\n         BE    LIMCCON1      YES, JUST CONVERT IT\n         VTOCMSG CCHHLEN     LESS THAN FOUR CHARS, ISSUE A MSG\nLIMCCON1 LA    R6,1          SET THE COMPARE LENGTH\n         B     LIMCMOVE      GO MOVE IT IN\nLIMCCON2 LA    R6,3          SET THE COMPARE LENGTH\n         CH    R3,H8         WAS IT A CCHH?\n         BE    LIMCMOVE      YES, JUST THE RIGHT LENGTH\n         VTOCMSG CCHHLEN     WARN THE PERSON\n         CH    R3,H8         CHECK AGAIN\n         BL    LIMCMOVE      IS IT OVER 8 CHARS?\n         LH    R3,H8         YES, SET IT FOR THE MAX - IGNORE RR\nLIMCMOVE BCTR  R3,0          MINUS ONE FOR THE EX\n         EX    R3,MOVECCHH   MOVE IN THE CHARS\n         TR    DOUBLE,DECTABLE TRANSLATE HEX EBCDIC TO HEX BINARY\n         PACK  CYLH(5),DOUBLE(9)  SQUISH OUT THE ZONES\n         L     R4,CYLH       GET THE CCHH\n         ST    R4,0(R5)      SAVE IT FOR LATER\n         STH   R6,4(R5)      SAVE THE LENGTH TOO\nLIMCSET  DS    0H            THE NUMBER IS CONVERTED\n*\n*        COMPARE THE EXTENTS TO THE CCHH VALUE.\n*        ANY EXTENT MAY BE LT, EQ, AND GT A PARTICULAR\n*        VALUE, AND ALL THE EXTENTS MUST BE CHECKED.\n*\n         MVI   CCHHCOMP,0    CLEAR THE FLAGS\n         SR    R2,R2         CLEAR A REG FOR AN EXTENT COUNTER\n         ICM   R2,1,DS1NOEPV GET THE NUMBER OF EXTENTS\n         BZ    COMPNO        NO EXTENTS, JUST GO SEE\n*\n*        GET EACH EXTENT AND PROCESS IT\n*\n         SR    R1,R1         FIRST EXTENT\nEXTNEXT  LR    R3,R1         GET THE CURRENT EXTENT\n         CH    R3,GETEXMAX             MAX EXTENTS             25JUN84\n         BH    LIMCOPER                TOO MANY - SKIP         25JUN84\n         SLL   R3,1                    MULT. BY 2              25JUN84\n         LH    R3,GETEXT(R3)           GET EXTENT OFFSET       25JUN84\n         CH    R1,=H'2'                IS EXTENT IN F1 OR F3   25JUN84\n         BH    EXTNXF3                 F3                      25JUN84\n         LA    R3,DS1EXT1(R3)          +F1 BASE = ADDR OF EXT  25JUN84\n         B     EXTNXFX                 CONTINUE                25JUN84\nEXTNXF3  DS    0H                                              25JUN84\n         LA    R3,FMT3(R3)             +F3 BASE = ADDR OF EXT  25JUN84\nEXTNXFX  DS    0H                                              25JUN84\n*\n*        CHECK THE BOTTOM OF THE EXTENT\n*\n         NI    CCHHCOMP,255-CCHHX TURN OFF THE STRADDLE FLAG\n         EX    R6,CLCEXTLO    DO THE COMPARE\n         BH    SETH1         THE FIELD IS HIGHER THAN THE VALUE\n         BE    SETEQ1        THE FIELD IS EQUAL TO THE VALUE\n         OI    CCHHCOMP,CCHHLOW+CCHHX  LOWER -  POSSIBLE STRADDLE\n         B     CHECKHI       GO CHECK THE TOP OF THIS EXTENT\nSETH1    OI    CCHHCOMP,CCHHHIGH  SET THE FLAG\n         B     CHECKHI       GO CHECK THE TOP OF THIS EXTENT\nSETEQ1   OI    CCHHCOMP,CCHHEQ   SET THE FLAG\n*\n*        CHECK THE TOP OF THE EXTENT\n*\nCHECKHI  EX    R6,CLCEXTHI   DO THE COMPARE\n         BE    SETEQ2        EQUAL, GO SET IT\n         BL    EXTSET        LOW, GO SET IT\n*\n*        THIS IS THE ONLY SLIGHTLY TRICKY PART, A STRADDLE\n*        IF THE BOTTOM OF THE EXTENT IS LOWER THAN THE VALUE AND THE\n*        TOP OF THE EXTENT IS HIGHER THAN THE VALUE, THEN THE\n*        EQ FLAG SHOULD BE SET TOO.\n*\n         OI    CCHHCOMP,CCHHHIGH  SET THE HIGH FLAG\n         TM    CCHHCOMP,CCHHX     WAS THE BOTTOM LOWER THAN THE VALUE?\n         BZ    EXTSET        NO, SKIP ON\nSETEQ2   OI    CCHHCOMP,CCHHEQ    SET THE EQ FLAG\n*\n*        FINISHED WITH THAT EXTENT, CHECK FOR MORE\n*\nEXTSET   DS    0H\n         LA    R1,1(R1)      INCREMENT THE EXTENT COUNTER\n         CR    R1,R2         CHECK THE EXTENT COUNTER\n         BNL   LIMCOPER      THAT'S ALL FOLKS\n         TM    CCHHCOMP,CCHHHIGH+CCHHEQ+CCHHLOW  ARE THEY ALL SET?\n         BNO   EXTNEXT       NO, CONTINUE LOOKING\n*                            YES, STOP NOW - ALL THE FLAGS ARE SET\nLIMCOPER L     R4,REFOPER    GET THE NUMERIC VALUE OF THE KEY\n         IC    R4,CCHHTAB(R4)  GET A FLAG MASK\n         EX    R4,CCHHOPER   CHECK TO SEE IF THE CONDITION IS SET\n         BZ    COMPNO        NOT THERE\n         B     COMPYES       YES\n*\n*        EXECUTED INSTRUCTIONS TO GET THE ADDRESS OF THIS EXTENT\n*\nGETEXT   DC    AL2(DS1EXT1-DS1EXT1)    1ST EXTENT OFFSET       25JUN84\n         DC    AL2(DS1EXT2-DS1EXT1)    2ND \"                   25JUN84\n         DC    AL2(DS1EXT3-DS1EXT1)    3RD \"                   25JUN84\n         $FORMEX ,                     4-16 EXT                25JUN84\n         $FORMEX X1                    17-   EXTENT            25JUN84\n         $FORMEX X2                    30-   EXTENT            25JUN84\n         $FORMEX X3                    43-   EXTENT            25JUN84\n         $FORMEX X4                    56-   EXTENT            25JUN84\n         $FORMEX X5                    69-   EXTENT            25JUN84\n         $FORMEX X6                    82-   EXTENT            25JUN84\n         $FORMEX X7                    95-   EXTENT            25JUN84\n         $FORMEX X8                    108-  EXTENT            25JUN84\n         $FORMEX X9                    121-  EXTENT            25JUN84\nGETEXMAX DC    AL2((*-GETEXT)/2)       MAX                     25JUN84\n*                                                              25JUN84\n*\n*        ISSUE ERROR MESSAGES AND RETURN\n*\nOBT3ERR  VTOCMSG OBT3ERRM   OBTAIN ERROR MESSAGE\nCHECKOUT LA    R15,8          EXCLUDE THIS DATA SET\n         B     CHEKRET        RETURN\n*\nCHECKIN  SR    R15,R15        CLEAR THE REGISTER, PROCESS THIS DATA SET\nCHEKRET  LEAVE EQ\n*\n*\n         EJECT\n*\n*        ROUTINES USED ABOVE\n*\n         EJECT\n*\n*        PDLNUM - CONVERT FROM CHARACTERS ( EBCDIC ) TO AN INTEGER\n*              BINARY FORM, PASSED BACK VIA REGISTER 15\n*              A PARSE PDE IS THE INPUT AS SHOWN IN THE SAMPLE BELOW\n*                       LA    R1,PDL     POINT TO THE PARSE DECRIPTION\n*                       BAL   R8,PDLNUM  GO CONVERT TO NUMERICS\n*              THE ROUTINE WILL TERMINATE IF IT FINDS NON-NUMERICS\n*                 ANY CHARACTERS OTHER THEN 0-9, +, -\n*              REGISTERS 1, 2, 5, 6, AND 7 ARE USED\n*\nPDLNUM   STM   R1,R8,PDLNSAVE SAVE THE REGISTERS\n         LH    R2,4(R1)       GET THE STRING ADDRESS\n         L     R1,0(R1)       GET THE STRING ADDRESS\n         MVI   PDLMINUS,0     CLEAR THE NEGATIVE NUMBER FLAG\n         SR    R5,R5          CLEAR THE CHARACTER COUNTER\n         SR    R15,R15        CLEAR THE ANSWER\nPDLLOOP  LA    R6,0(R5,R1)    POINT TO THIS DIGIT\n         LA    R5,1(R5)       GET TO THE NEXT DIGIT\n         CR    R5,R2          IS THIS THE END OF THE STRING?\n         BH    PDLFINI        YES, EXIT\n         SR    R7,R7          CLEAR A WORK REGISTER\n         IC    R7,0(R6)       GET THE CHARACTER\n         SH    R7,PDLH240     SUBTRACT THE CHARACTER C'0'\n         BM    PDLSP          IF NEGATIVE, CHECK SPECIAL CHARACTERS\n         MH    R15,PDLH10     IT'S A DIGIT, MULTIPLY PRIOR NUM BY TEN\n         AR    R15,R7         ADD ON THE NEW DIGIT\n         B     PDLLOOP        AND LOOP FOR MORE\n*\n*        CHECK FOR SPECIAL CHARACTERS\n*\nPDLSP    CLI   0(R6),C' '     IS IT A BLANK?\n         BE    PDLLOOP        THEN IT'S OK\n         CLI   0(R6),C'+'     IS IT A PLUS?\n         BE    PDLLOOP        THAT'S ALSO OK\n         CLI   0(R6),C'-'     IS IT A MINUS?\n         BNE   PDLFINI        NO, JUST QUIT\n         MVI   PDLMINUS,1     YES, NOTE IT\n         B     PDLLOOP        AND LOOK FOR MORE\n*\n*        QUIT, AFTER SETTING R15 TO NEGATIVE IF NEEDED\n*\nPDLFINI  CLI   PDLMINUS,1     WAS A MINUS SIGN FOUND?\n         BNE   PDLLEAVE       NO, EXIT\n         LNR   R15,R15        YES, MAKE IT NEGATIVE\nPDLLEAVE LM    R1,R8,PDLNSAVE RESTORE THE REGISTERS\n         BR    R8             RETURN\nPDLH10   DC    H'10'\nPDLH240  DC    H'240'\n         EJECT\n*\n*        ROUTINE TO CONVERT A TEXT DSCB ITEM\n*        INTO ITS KEY NUMBER\n*        INPUT IS REG 4 - IKJIDENT PTR\n*        OUTPUT IS REG 15 - KEY NUMBER\n*        ENTRY VIA BAL   R8,GETKEY\n*\nGETKEY   L     R1,ATABTITL     POINT TO THE TABLE\n         LA    R1,12(R1)     POINT TO THE FIRST ENTRY\n         LA    R15,1           SET UP THE KEY NUMBER COUNTER\n         L     R6,0(R4)      POINT TO THE ENTERED TEXT\n         ICM   R3,3,4(R4)    GET THE LENGTH OF THE ENTERED TEXT\n         BNP   GETKNOTF      NOT FOUND IF ZERO\n         BCTR  R3,0          MINUS ONE FOR THE EX\nGETKLOOP LA    R2,4(R1)      POINT TO THE COMPARISON TEXT\n         CLI   0(R2),C' '    IS IT HERE?\n         BNE   GETKSTD       YES, THIS IS IT\n         LA    R2,1(R2)      NO, MOVE OVER ONE MORE\n         CLI   0(R2),C' '    IS IT HERE?\n         BNE   GETKSTD       YES, THIS IS IT\n         LA    R2,1(R2)      NO, MOVE OVER ONE MORE\nGETKSTD  EX    R3,GETKCOMP   COMPARE THE KEY TEXT\n         BE    GETKFND       I FOUND IT\n         LA    R1,12(R1)     GET TO THE NEXT KEY\n         LA    R15,1(R15)    INCREMENT THE KEY COUNTER\n         CH    R15,H26       CHECK FOR THE END OF THE TABLE\n         BNH   GETKLOOP      NOT YET, KEEP LOOKING\n*\n*        KEY WAS NOT FOUND, SEND BACK A ZERO\n*\nGETKNOTF SR    R15,R15       SET UP THE ZERO AND RETURN\nGETKFND  BR    R8            JUST RETURN\nGETKCOMP CLC   0(0,R6),0(R2) EXECUTED TEXT COMPARE\nH26      DC    H'26'\n         EJECT\n*\n*        ROUTINE TO CONVERT THE OPERATOR TEXT\n*        INTO A NUMERIC VALUE\n*\nGETOPER  LA    R15,1         NUMERIC VALUE COUNTER\nGETOLOOP LR    R14,R15       GET THE NUMBER\n         SLA   R14,1         MULTIPLY BY 2\n         LA    R14,OPERS(R14)      RELOCATE IT\n         CLC   0(2,R14),0(R1)      IS THIS THE TEXT?\n         BE    GETOFND       YES, RETURN THE NUMBER\n         LA    R15,1(R15)    NO, TRY THE NEXT ONE\n         CH    R15,H7        CHECK FOR THE END\n         BL    GETOLOOP      NOT THERE YET, KEEP TRYING\n         VTOCMSG OPERERR,OPERERR2  ISSUE THE MESSAGE\n         LA    R15,1         SET THE DEFAULT OPERATOR, EQ\nGETOFND  BR    R8            THEN RETURN\n         EJECT\n*\n*        PROGRAM CONSTANTS\n*\nCOMPLIM  CLC   0(0,R2),0(R1)  COMPARE KEYWORD TO VALUE\nMOVECCHH MVC   DOUBLE(0),0(R2)\nCLCEXTLO CLC   2(0,R3),0(R5)\nCLCEXTHI CLC   6(0,R3),0(R5)\nCCHHOPER TM    CCHHCOMP,0\nCCHHTAB  DC    X'0040A0206080C0'  CCHHCOMP FLAGS\nOPERS    DC    C'  EQNELTLEGTGE'\n*    FOR  EQ, NE, LT, LE, GT, GE\nEDMASK   DC    XL16'40202020202020202020202020202120'\nBLANKS   DC    CL16'                '\nSTARS    DC    CL16'****************'\nBLKTRTAB DC    XL64'00',X'04',XL192'00'\nCAMSCON  CAMLST SEEK,*,*,*\nCOMPARE  CLC   0(0,R6),0(R2)  EXECUTED COMPARE\nDECTABLE EQU   *-C'A'   CONVERT EBCDIC HEX TO BINARY\n         DC    X'0A0B0C0D0E0F'\n         DC    (C'0'-C'F'-1)X'FF'  FILLER\n         DC    X'00010203040506070809'\n*\n*\n*\nH3       DC    H'3'\nH4       DC    H'4'\nH7       DC    H'7'\nH8       DC    H'8'\nH10      DC    H'10'\nH12      DC    H'12'\nZERO     DC    F'0'\nF100     DC    F'100'\nH1000    DC    H'1000'\nF127     DC    F'127'\n*\n*\n         PRINT NOGEN\n*\n*        PROGRAM MESSAGES\n*\nOBT3ERRM MSG   ' VTOCCHEK - ERROR IN OBTAIN FOR FORMAT 3 DSCB '\nKEYERR   MSG   ' VTOCCHEK - LIM, AND, OR OR SUBPARM ERROR - XXXXXX '\nCCHHLEN  MSG   ' VTOCCHEK - CCHH SHOULD BE 4 OR 8 HEX CHARACTERS '\nOPERERR  MSG   ' VTOCCHEK - OPERATOR WAS NOT EQ, NE, LT, LE, GT, OR GE'\nOPERERR2 MSG   '          - WILL ASSUME EQ'\n*\n         EJECT\n*\n*\n*        P A R S E   C O N T R O L   L I S T\n*\n*\n         PRINT OFF\n         COPY  VTOCPARS\n         PRINT ON\n*\n*        DYNAMIC WORK AREA\n*\n         SPACE 3\nCHEKWORK DSECT\n         DS    18A            PRINT ROUTINE SAVE AREA\nCHARS    DS    CL16           CONVERSION TO CHARACTERS\nCAMSEEK  CAMLST SEEK,*,*,*\nCAMLEN   EQU   *-CAMSEEK\n         DS    0D\nCYLH     DS    F\n         DS    X              PAD FOR CCHH\nEQ       EQU   1              EQUATES FOR OPERATOR VALUES\nNE       EQU   2\nLT       EQU   3\nLE       EQU   4\nGT       EQU   5\nGE       EQU   6\nHWORK    DS    H\nLIMVAL   DS    F\nNUMBERL  DS    F\nNUMLENL  DS    H\nFLAGNML  DS    X\nNUMKEYL  DS    X\nNUMBER1  DS    F\nNUMLEN1  DS    H\nFLAGNM1  DS    X\nNUMKEY1  DS    X\nNUMBER2  DS    F\nNUMLEN2  DS    H\nFLAGNM2  DS    X\nNUMKEY2  DS    X\nNUMBER3  DS    F\nNUMLEN3  DS    H\nFLAGNM3  DS    X\nNUMKEY3  DS    X\nREFKEY   DS    F\nREFOPER  DS    F\nREFVAL   DS    A\nREFNUM   DS    A\nPDLNSAVE DS    8A             REGISTER SAVE AREA FOR PDLNUM RTN\nPDLMINUS DC    X'00'\nCHEKDBLW DS    D\nCCHHCOMP DS    X\nCCHHHIGH EQU   X'80'\nCCHHEQ   EQU   X'40'\nCCHHLOW  EQU   X'20'\nCCHHX    EQU   X'08'\n         DS    0D\nLENWORK  EQU   *-CHEKWORK\n*\n*        VTOC COMMAND COMMON AREA\n*\n         PRINT NOGEN\n         VTOCOM\n         SPACE 3\n*\n*        FORMATTED DSCB\n*\n         VTFMT\n         SPACE 3\n         PDEDSNAM\n         SPACE 3\n         SPACE 3\nDSCB1    DSECT\n         IECSDSL1 1\n         END\nVTOCEXCP TITLE 'VTOC COMMAND - VTOC READING SUBROUTINE'\n***********************************************************************\n*        SPACE\n* AUTHOR;  R. F. MORSE, MIT INSTRUMENTATION LABORATORY  AUG 5,1968.\n* MODIFIED;   E.BANK, FIREMAN'S FUND  MAY 15,1975.\n* MODIFIED;   R.MILLER  FIREMAN'S FUND  MAR 20,1977.\n* MODIFIED;   C.HUNTER  CHRYSLER PARTS  SEP 19,1979.             9257\n* FUNCTION; THIS SUBROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)\n*        FROM A DIRECT-ACCESS DEVICE AND PRESENTS IT TO THE CALLER\n*        ONE RECORD (DSCB) AT A TIME.\n*\n* OPERATION; THIS ROUTINE IS A SPECIALIZED SEQUENTIAL ACCESS METHOD\n*        FOR VTOC'S.  ITS ADVANTAGE OVER ORDINARY BSAM IS THAT IT READS\n*        AN ENTIRE TRACK IN ONE REVOLUTION, THUS SAVING CONSIDERABLE\n*        TIME.  THE ROUTINE HAS THREE CALL MODES;\n*\n*        0 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN THE 3RD\n*              PARAMETER.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES,\n*              CONTAINING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA\n*              (96 BYTES) FOR ONE DSCB.  RETURN CODES (REGISTER 15)\n*              ARE;\n*                      0 - NORMAL;\n*                      4 - END OF FILE, NO DATA PRESENTED;\n*                      8 - PERMANENT I/O ERROR.  THE KEY AND DATA AREAS\n*                          WILL BE SET TO ZEROS; THE COUNT AREA WILL\n*                          CONTAIN THE CORRECT CCHHR.  SINCE READING\n*                          IS DONE A TRACK AT A TIME, ALL THE DSCB'S\n*                          FOR THAT TRACK WILL BE MARKED IN ERROR.\n*                          READING MAY CONTINUE ON TO THE NEXT TRACK.\n*\n*        1 - OPEN.  THE SECOND PARAMETER SHOULD POINT TO\n*              A  6-BYTE FIELD CONTAINING THE VOLSER TO BE USED FOR THE\n*              ALLOCATION.\n*              RETURN CODES ( REG 15 )  ARE DIRECT FROM DYNAMIC ALLOC.\n*                      0 - NORMAL;\n*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);\n*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS\n*                          DEVICE, OR DEVICE TYPE UNKNOWN.\n*\n*        2 - CLOSE.  NO ARGUMENTS ARE REQUIRED OR RETURNED.  RETURN\n*              CODE ( REG 15 ) IS FROM DYNAMIC UNALLOCATION.\n*        3 - READ BY CCHHR (USED TO GET F2 AND F3 DSCBS FROM F1) 9257\n*              CODE ( REG 15 ) IS FROM OBTAIN                    9257\n*              INPUT: IN 'DS3PTRDS'                              9257\n         SPACE\n* ENTRY POINTS:  ENTRY IS ALWAYS TO 'VTOCEXCP'.\n*        ARGUMENTS ARE:\n*                      1 - A(FULL-WORD BINARY ENTRY TYPE);\n*                      2 - A(PTR FOR DSCB);\n*                      3 - A(VOLSER).\n* DATA SETS:  READS VOLUME TABLE OF CONTENTS FROM ANY DIRECT-ACCESS\n*        DEVICE.  USES EXCP TO EXECUTE A CHAINED CHANNEL PROGRAM TO\n*        READ AN ENTIRE TRACK AT A TIME.\n*\n* EXTERNAL ROUTINES:  USES SUPERVISOR ROUTINE 'IECPCNVT' TO CONVERT\n*        A RELATIVE TRACK NUMBER TO AN ABSOLUTE ADDRESS.\n         SPACE\n* EXITS - NORMAL;  RETURNS TO CALLER VIA R14 WITH RETURN\n*        CODE IN REGISTER 15.       (SEE ABOVE FOR RETURN CODE VALUES.)\n*\n* TABLES AND WORK AREAS;  USES AN AREA PROVIDED BY THE CALLER FOR\n*        ITS SAVEAREA AND FOR WORKING STORAGE IMMEDIATELY FOLLOWING\n*        THE PRIOR SAVEAREA.  IT USES GETMAIN TO OBTAIN AN AREA FOR\n*        THE DSCB'S TO BE READ INTO.  THIS COULD BE AS LARGE AS\n*        8K FOR 3350'S.  IT IS FREED BY THE FINAL CALL.\n*\n* ATTRIBUTES;  REENTRANT, REFRESHABLE.\n         EJECT\n* ENTER HERE AND PERFORM STANDARD REGISTER SAVE AREA HOUSEKEEPING.\n         SPACE\nVTOCEXCP ENTER 12,8                    USE THE PROVIDED SAVEAREA\n         USING VTOCWORK,R13   SET ADDRESSABILITY FOR WORK AREA\n         LR    R11,R1                  SAVE PARAMETER REGISTER\n         USING VTOCOM,R11              SET ADDRESSABILITY\n*\n*        POINT TO THE DCB FOR LATER REFERENCES\n*\n         LA    RDCB,VTOCDCB   POINT TO IT\n         USING IHADCB,RDCB    SET ADDRESSABILITY\n         SPACE\n* SELECT MODE FROM CONTENTS AT ADDRESS IN REGISTER 1.\n         SPACE\n         SR    RWA,RWA                 CLEAR THE REGISTER\n         IC    RWA,VTCEFUNC            GET CALL MODE\n         SLL   RWA,2                   MODE TIMES 4\n         B     *+4(RWA)                BRANCH ON MODE\n         SPACE\n         B     GETDSB                  MODE 0, GET A DSCB\n         B     OPEN                    MODE 1, OPEN A NEW VTOC\n         B     CLOSE                   MODE 2, CLOSE\n         B     READCCHH                MODE 3, READ BY CCHHR     9257\n*        B     RETURN0                 MODE 3 NOT DEFINED, NO OP\n         SPACE 3\n***********\n* RETURNS *\n***********\n         SPACE\nRETURN0  SR    R15,R15                 CLEAR THE RETURN CODE\nRETURN   LEAVE EQ                      EXIT WITH THE CURRENT RET CODE\n         EJECT\n*********************\n* MODE 0 - GET DSCB *\n*********************\n         SPACE\n* IF END-OF-FILE WAS REACHED, RETURN AT ONCE.\n         SPACE\nGETDSB   LA    R15,4                   SET THE RETURN CODE, IN CASE\n         TM    MODESW,EOFSW            TEST END-OF-FILE BIT\n         BO    RETURN                  RETURN CODE 4 IF ON\n         SPACE\n* IF CHANNEL PROGRAM HAS BEEN STARTED, GO TO CHECK IT.  OTHERWISE,\n* ASSUME THERE IS AT LEAST ONE FULL BUFFER.\n         SPACE\n         TM    MODESW,XCPRUN           TEST IF EXCP ISSUED\n         BO    XCPTEST                 BRANCH IF SO\n         SPACE\n* SET BUFFER ADDRESS TO NEXT DSCB AND TEST IF LAST ON TRACK.  IF NOT,\n* EXIT WITH ITS ADDRESS IN R1.\n         SPACE\n         L     RWA,DSCBADR             LOAD BUFFER POINTER\n         LA    RWA,148(RWA)            ADVANCE TO NEXT DSCB\nNDXSTORE ST    RWA,DSCBADR             STORE UPDATED POINTER\n         C     RWA,DSCBLIM             TEST IF LAST DSCB IN BUFFER\n         BNL   LASTDSCB                BRANCH IF SO\n         LR    R1,RWA                  PASS ADDRESS TO USER\nGETOUT   ST    R1,DSCBADDR             STORE IT FOR THE CALLER\n         TM    MODESW,RDERR            TEST IF ERROR ON THIS TRACK\n         BZ    RETURN0                 RETURN CODE 0 IF NOT\n         LA    R15,8                   SET THE RETURN CODE\n         B     RETURN                  RETURN CODE 8 IF ERROR\n         SPACE\n* IF THIS IS THE LAST DSCB, MOVE IT TO THE INTERNAL BUFFER AND START\n* READING THE NEXT TRACK.\n         SPACE\nLASTDSCB MVC   BUFF(148),0(RWA)        MOVE LAST DSCB\n         L     RWB,TTRN                LOAD RELATIVE TRACK NUMBER\n         AL    RWB,=X'00010000'        INCREMENT TO NEXT TRACK\n         ST    RWB,TTRN\n         BAL   RRET,EXCP               START CHANNEL PROGRAM\n         LA    R1,BUFF                 LOAD DSCB ADDRESS FOR CALLER\n         B     GETOUT                  TO RETURN\n         EJECT\n* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.\n         SPACE\nXCPTEST  WAIT  ECB=VTOCECB\n         SPACE\n         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF\n         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE\n         BNE   PERMERR                 BRANCH IF ERROR\nSETDSCBA L     RWA,DSCBSTRT            SET BUFFER POINTER TO 1ST DSCB\n         B     NDXSTORE\n         SPACE\n* PERMANENT ERROR FOR THIS TRACK.  ZERO THE DSCB'S AND FILL IN THE\n* CCHHR PORTIONS OF THE COUNT AREAS.\n         SPACE\nPERMERR  OI    MODESW,RDERR            SIGNAL READ ERROR\n         NI    IOBFLAG1,X'FB'          TURN OFF BIT 5 OF IOB FLAG\n         NI    DCBIFLGS,X'3F'          TURN OFF BITS 0 AND 1\n         L     RWA,DSCBSTRT            LOAD ADDRESS OF FIRST DSCB\n         LA    RWB,1                   LOAD RECORD NUMBER\n         SPACE\nDSCBELUP XC    0(148,RWA),0(RWA)       ZERO DSCB BUFFER\n         MVC   0(4,RWA),IOBSEEK+3      INSERT CCHH IN COUNT FIELD\n         STC   RWB,4(RWA)              INSERT R IN COUNT FIELD\n         LA    RWA,148(RWA)            POINT TO NEXT BUFFER\n         LA    RWB,1(RWB)              INCREMENT RECORD NUMBER\n         C     RWA,DSCBLIM             TEST FOR LAST BUFFER\n         BNH   DSCBELUP\n         VTOCMSG TRACKERR       ISSUE THE ERROR MESSAGE\n         B     SETDSCBA                BRANCH TO RESET BUFFER POINTER\n         EJECT\n*****************\n* MODE 1 - OPEN *\n*****************\n         SPACE\n* ENTER WITH A DDNAME IN SECOND PARAMETER POSITION.  PERFORM CLOSE\n* SUBROUTINE FIRST TO BE SURE EVERYTHING IS INITIALIZED.\n         SPACE\nOPEN     DS    0H\n         BAL   RRET,CLOSESUB           CALL CLOSE SUBROUTINE\n         SPACE\n*\n*        INITIALIZE THE DATA AREAS\n*\n*        FIRST THE DCB\n         MVC   VTOCDCB(DCBLEN),VTOCDCBM  SET UP THE DCB\n*\n*        SET UP THE JFCB LISTS\n*\n         LA    R1,JEXLST      POINT TO THE EXIT LIST\n         STCM  R1,B'0111',DCBEXLSA  PUT IT INTO THE DCB\n         LA    R1,JFCBAREA    POINT TO THE JFCB AREA\n         ST    R1,JEXLST      AND PUT THAT INTO THE EXIT LIST\n         MVI   JEXLST,X'87'   END OF LIST, JFCB EXIT\n         MVI   OPENLIST,X'80' END OF THE OPEN LIST TOO\n*        INITIALIZE THE IOB\n         MVC   VTOCIOB(IOBCONL),IOBCONST START IT OUT\n         LA    R1,VTOCECB     GET THE ECB ADDRESS\n         ST    R1,IOBECB      AND STORE IT INTO THE IOB\n         ST    RDCB,IOBDCB    STORE THE DCB ADDRESS INTO THE IOB\n*        INITIALIZE THE CAMLST\n         MVC   DSCBFMT4(4),DSCBCON SET UP THE FIRST WORD\n         LA    R1,IOBSEEK+3   SEEK ADDRESS\n         ST    R1,DSCBFMT4+4  INTO THE CAMLST\n         LA    R1,VOLID       VOLUME SERIAL NUMBER\n         ST    R1,DSCBFMT4+8  INTO THE CAMLST\n         LA    R1,FMT4        DSCB AREA\n         ST    R1,DSCBFMT4+12 INTO THE CAMLST\n*        INITIALIZE THE CAMLST FOR READING BY CCHHR (FMT4)       9257\n         MVC   DSCBFMT3(12),DSCBFMT4 SET UP LIKE FMT4 CAMLST     9257\n         LA    R1,DSCBCCHH    SEEK ADDRESS                       9257\n         ST    R1,DSCBFMT3+4  INTO THE CAMLST                    9257\n         LA    R1,FMT3        DSCB AREA                          9257\n         ST    R1,DSCBFMT3+12 INTO THE CAMLST                    9257\n*\n*        ALLOCATE THE VTOC OF THE CHOSEN PACK\n*\n         LA    R1,ADDR        POINT TO THE UNIT ADDRESS\n         ST    R1,UNITADDR    SAVE THE ADDRESS\n         LA    R1,3           ALSO GET THE LENGTH\n         STH   R1,UNITLEN     AND SAVE IT FOR DYNAMIC ALLOCATION MACRO\n         LA    R1,VOLID       POINT TO THE VOLUME SERIAL\n         ST    R1,VOLADDR     SAVE THE ADDRESS\n         LA    R1,6           ALSO GET THE LENGTH\n         STH   R1,VOLLEN      AND SAVE IT FOR DYNAMIC ALLOCATION MACRO\n*        ALLOC DSN=VTOCNM,VOL=VOLADDR,UNIT=UNITADDR,DISP=SHR,\n         ALLOC DSN=VTOCNM,VOL=VOLADDR,UNIT='SYSALLDA',DISP=SHR,  9257  X\n               DDNTO=DCBDDNAM,ERROR=S99FAIL\n         MVC   FMT3(8),DCBDDNAM    GIVE CALLER A COPY OF DYNAMIC 9257\n         OI    MODESW,ALLOCSW          SET ALLOCATE FLAG ON\n         SPACE\n* OPEN THE VTOC.\n         SPACE\n*\n*        FIRST READ THE JFCB TO SWITCH THE DSNAME TO HEX 04'S\n*\n         RDJFCB ((RDCB)),MF=(E,OPENLIST)  READ THE JFCB\n         LTR   R15,R15        TEST THE RETURN CODE\n         BNZ   ERRJFCB        BAD NEWS\n         LA    R1,JFCBAREA    POINT TO THE JFCB\n         USING JFCB,R1        SET UP ADDRESSABILITY\n         MVI   JFCBDSNM,X'04' PUT IN THE FIRST ONE\n         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM  PROPAGATE IT\n         OI    JFCBTSDM,JFCNWRIT  DON'T REWRITE IT\n         DROP  R1\n         OPEN  ((RDCB),(INPUT)),MF=(E,OPENLIST),TYPE=J  OPEN THE VTOC\n         TM    DCBOFLGS,OPENBIT        TEST IF OPEN WORKED\n         BZ    OPENERR                 ERROR IF OPEN FAILED\n         SPACE\n* ISSUE AN OBTAIN FOR THE FIRST DSCB ON THE VTOC ( FORMAT 4 )\nD3       STM   R2,R13,EXCPSAVE         SAVE OUR REGS\n         LA    R3,EXCPSAVE    POINT TO THE REGISTER SAVE AREA\n         ICM   R0,B'1111',=X'00000100' FIRST DSCB\n         L     R1,DCBDEBAD             DEB ADDRESS\n         LA    R2,IOBSEEK              SAVE ADDRESS OF CCHHR\n         L     R15,CVT                 GET ADDRESS OF CVT\n         L     R15,CVTPCNVT(R15)       GET ADDRESS OF CONVERT ROUTINE\n         BALR  R14,R15                 GO TO CONVERT ROUTINE\n         LM    R2,R13,0(R3)            GET MY REGS BACK\n         OBTAIN DSCBFMT4               GET FORMAT 4 DSCB\n         LTR   R15,R15                 DID WE GET IT\n         BNZ   OBTERR                  NO - THEN ERROR, KEEP R15\n         CLI   DS4IDFMT,X'F4'          MAKE SURE WE HAVE FORMAT 4\n         BNE   NOTFMT4                 NO - THEN ERROR\n         IC    R15,DS4DEVDT            GET NUMBER OF DSCBS PER TRACK\n         ST    R15,NDSCBS              SAVE THE NUMBER OF DSCBS\n         OC    NDSCBS,NDSCBS           MAKE SURE NOT ZERO\n         BZ    DSCBNUM0                YES - GO TELL CALLER\n*\n* OBTAIN CORE FOR CHANNEL PROGRAM AND DSCB BUFFERS.\n         SPACE\n         LA    R0,156                  CORE FOR ONE DSCB AND ITS CCW\n         MH    R0,NDSCBS+2             TIMES NUMBER PER TRACK\n         AH    R0,=H'15'               PLUS 1 CCW AND ROUNDING\n         N     R0,=X'FFFFFFF8'         ROUND TO DOUBLE-WORD MULTIPLE\n         ST    R0,CBSIZE               SAVE SIZE OF GOTTEN CORE\n         GETMAIN  R,LV=(0)             GET TRACK BUFFERS\n         ST    R1,CBADDR               SAVE ADDRESS OF GOTTEN CORE\n         OI    MODESW,CBGOT            INDICATE CORE GOTTEN\n         SPACE\n* GENERATE CHANNEL PROGRAM.  IT CONSISTS OF A 'READ R0' ORDER WITH\n* THE SKIP FLAG ON, FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR\n* EACH DSCB.\n         SPACE\n         L     RWA,NDSCBS              NUMBER OF DSCB'S\n         SLL   RWA,3                   TIMES   8\n         LA    RWA,8(RWA,R1)           PLUS 8 AND BASE = 1ST BUFFER ADD\n         ST    RWA,DSCBSTRT            SAVE ADDRESS OF FIRST BUFFER\n         SPACE\n         ST    R1,IOBSTART             ADDRESS OF CHANNEL PROGRAM\n         MVC   0(8,R1),INITCCW         INSERT FIRST CCW\n         LA    RWB,8(R1)               PLACE FOR NEXT CCW\n         LA    RWC,1                   BUFFER COUNTER\n         SPACE\nCCWLOOP  MVC   0(8,RWB),READCCW        INSERT READ CCW FOR ONE DSCB\n         ST    RWA,0(RWB)              SET ITS BUFFER ADDRESS\n         MVI   0(RWB),READCKD          RESTORE COMMAND CODE\n         C     RWC,NDSCBS              TEST BUFFER COUNTER\n         BNL   LASTCCW                 BRANCH IF LAST BUFFER\n         LA    RWB,8(RWB)              INCREMENT CCW ADDRESS\n         LA    RWA,148(RWA)            INCREMENT BUFFER ADDRESS\n         LA    RWC,1(RWC)              INCREMENT BUFFER COUNTER\n         B     CCWLOOP                 DO NEXT BUFFER\n         SPACE\nLASTCCW  NI    4(RWB),X'FF'-CC         TURN OFF COMMAND CHAIN BIT\n         ST    RWA,DSCBLIM             SAVE ADDRESS OF LAST DSCB BUFFER\n         SPACE\n* SET OTHER THINGS AND START PROGRAM TO FILL BUFFER.\n         SPACE\n         SR    R0,R0\n         ST    R0,TTRN                 SET RELATIVE TRACK NUMBER TO 0\n         NI    MODESW,X'FF'-XCPRUN-RDERR-EOFSW   SET FLAGS OFF\n         BAL   RRET,EXCP               START CHANNEL PROGRAM\n         B     RETURN0                 INDICATE SUCCESSFUL OPEN\n         EJECT\n******************\n* MODE 2 - CLOSE *\n******************\n         SPACE\nCLOSE    BAL   RRET,CLOSESUB           CALL CLOSED CLOSE SUBROUTINE\n         B     RETURN0\n         SPACE 2\n* IF THE CHANNEL PROGRAM IS RUNNING, WAIT FOR IT BEFORE TAKING FURTHER\n* ACTION.\n         SPACE\nCLOSESUB DS    0H\n         TM    MODESW,XCPRUN           TEST IF CHANNEL PROGRAM RUNNING\n         BZ    NOEXCP                  BRANCH IF NOT\n         WAIT  ECB=VTOCECB             WAIT UNTIL COMPLETE\n         NI    MODESW,X'FF'-XCPRUN     TURN RUNNING SWITCH OFF\nNOEXCP   DS    0H\n         SPACE\n* CLOSE THE DCB.\n         SPACE\n         TM    DCBOFLGS,OPENBIT        TEST IF DCB OPEN\n         BZ    NOCLOSE                 BRANCH IF NOT\n         CLOSE ((RDCB)),MF=(E,OPENLIST)   CLOSE THE VTOC\nNOCLOSE  DS    0H\n         SPACE\n* FREE UP THE DDNAME AND VOLUME\n         SPACE\n         TM    MODESW,ALLOCSW          DID WE ALLOCATE A DEVICE\n         BNO   NOALLOC                 NO  - THEN NOTHING TO FREEUP\n         LA    R1,DCBDDNAM   POINT TO THE DDNAME\n         ST    R1,DDNPDL     SAVE IT FOR FREE\n         LA    R1,8          GET THE DDNAME LENGTH\n         STH   R1,DDNPDL+4   SAVE IT FOR FREE\n         FREE  UNALC,DDN=DDNPDL,ERROR=S99FAIL  FREE THE DDNAME\n         NI    MODESW,X'FF'-ALLOCSW    TURN OFF ALLOCATE SW\n         SPACE\nNOALLOC  DS    0H\n         SPACE\n* RELEASE CORE OBTAINED FOR DSCB BUFFERS.\n         SPACE\n         TM    MODESW,CBGOT            TEST IF CORE GOTTEN\n         BZ    NOFREE                  BRANCH IF NOT\n         LM    R0,R1,CBSIZE            LOAD SIZE AND LOCATION\n         FREEMAIN  R,LV=(0),A=(1)      FREE CORE\n         NI    MODESW,X'FF'-CBGOT      SET CORE GOTTEN BIT OFF\nNOFREE   DS    0H\n         SPACE\n         NI    MODESW,X'FF'-RDERR      CLEAR ERROR SWITCH\n         BR    RRET\n         EJECT\n******************************                                   9257\n* MODE 3 - GET DSCB BY CCHHR *                                   9257\n******************************                                   9257\nREADCCHH DS    0H                                                9257\n         MVC   DSCBCCHH,DS3PTRDS       COPY CALLERS CCHHR        9257\n         OBTAIN DSCBFMT3               GET DSCB INTO FMT3 FIELD  9257\n         LTR   R15,R15                 DID WE GET IT             9257\n         BNZ   OBTERR                  NO - THEN ERROR, KEEP R15 9257\n         B     RETURN0                 YES-GOOD IO               9257\n         EJECT                                                   9257\n****************\n* EXCP ROUTINE *\n****************\n         SPACE\n* CONVERT RELATIVE TRACK ADDRESS IN 'TTRN' TO ABSOLUTE SEEK ADDRESS IN\n* 'IOBSEEK', USING SUPERVISOR CONVERSION ROUTINE.\n         SPACE\nEXCP     DS    0H\n         STM   R2,R13,EXCPSAVE         SAVE IMPORTANT REGISTERS\n         LA    R3,EXCPSAVE             SAVE REGS FOR RESTORING AFTER CL\n         L     R0,TTRN                 LOAD RELATIVE TRACK NUMBER\n         L     R1,DCBDEBAD             LOAD DEB ADDRESS\n         LA    R2,IOBSEEK              LOAD ADDR TO RECEIVE MBBCCHHR\n         L     R15,CVT                 LOAD CVT ADDRESS\n         L     R15,CVTPCNVT(R15)       LOAD ADDR OF CONVERT ROUTINE\n         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR\n*                                      THAT CLOBBERED BASE REG\n         LM    R2,R13,0(R3)            RESTORE REGISTERS\n         LTR   R15,R15                 TEST IF EXTENT VIOLATED (RC=4)\n         BNZ   SETEOF                  IF SO, MEANS END-OF-FILE\n         CLC   DS4HPCHR,IOBSEEK+3      CHECK FOR THE LAST FMT1\n         BL    SETEOF                  IF SO, PRETEND END-OF-FILE\n         SPACE\n* ZERO ECB AND START CHANNEL PROGRAM.\n         SPACE\n         SR    R0,R0\n         ST    R0,VTOCECB              CLEAR ECB\n         NI    MODESW,X'FF'-RDERR      RESET ERROR SWITCH\n         EXCP  VTOCIOB                 START CHANNEL PROGRAM\n         OI    MODESW,XCPRUN           SET 'RUNNING' FLAG\n         BR    RRET\n         SPACE\n* WHEN EXTENT IS VIOLATED, SET END-FILE AND EXIT VIA CLOSE ROUTINE.\n         SPACE\nSETEOF   OI    MODESW,EOFSW            SET END-OF-FILE BIT\n         BR    RRET                    EXIT                      9257\n         EJECT\n********************************\n* DAIRFAIL ROUTINE             *\n********************************\nS99FAIL  LR    RRCODE,R15     SAVE THE RETURN CODE               9257\n         S99FAIL MF=(E,S99FLIST,S99FLEN)  ISSUE THE APPROPRIATE MSG\n         LR    R15,RRCODE     RELOAD THE RETURN CODE\n         B     RETURN         AND THEN EXIT\n         SPACE 3\n*\n*        VARIOUS OTHER ERROR ROUTINES\n*\nOPENERR  VTOCMSG OPENERRM  ISSUE THE MESSAGE\n         B     ERRET          THEN RETURN\nOBTERR   VTOCMSG OBTERRM  ISSUE THE MESSAGE\n         B     ERRET          THEN RETURN\nNOTFMT4  VTOCMSG NOTFMT4M  ISSUE THE MESSAGE\n         B     ERRET          THEN RETURN\nDSCBNUM0 VTOCMSG DSCBNUMM  ISSUE THE MESSAGE\n         B     ERRET          THEN RETURN\n*\nERRJFCB  VTOCMSG ERRJFCBM   ERROR IN READING JFCB\n*\nERRET    LA    R15,8          SET AN ERROR RETURN CODE\n         B     RETURN         THEN EXIT\n*\n         EJECT\n********************************\n* CONSTANTS, VARIABLES, ETC... *\n********************************\n         SPACE\n*        ERROR MESSAGES\n*\nOPENERRM MSG   ' VTOCEXCP - ERROR IN OPENING VTOC '\nOBTERRM  MSG   ' VTOCEXCP - ERROR IN OBTAIN '\nNOTFMT4M MSG   ' VTOCEXCP - FORMAT 4 DSCB WAS NOT FIRST'\nDSCBNUMM MSG   ' VTOCEXCP - THE FORMAT 4 DSCB HAS DSCB S/TRK = 0 '\nTRACKERR MSG   ' VTOCEXCP - A READ ERROR OCCURRED ON THE VTOC '\nERRJFCBM MSG   ' VTOCEXCP - A RDJFCB ERROR OCCURRED '\n         SPACE\nINITCCW  CCW   READR0,0,CC+SLI+SKIP,8\nREADCCW  CCW   READCKD,0,CC,148\n         SPACE\nDSCBCON  CAMLST SEEK,0,0,0   FILLED IN WITH IOBSEEK+3, VOLID, FMT4\n         EJECT\n* DATA CONTROL BLOCK\n         PRINT   GEN\nVTOCDCBM DCB   DDNAME=VTOCDD,MACRF=(E),EXLST=1\nDCBLEN   EQU   *-VTOCDCBM\n         SPACE\n* IOB FOR CHANNEL PROGRAM\n         SPACE\nIOBCONST DS    0D\n         DC    X'42000000'     COMMAND CHAIN, NOT RELATED\n         DC    A(0)            ECB ADDRESS\n         DC    2F'0'\n         DC    A(0)            CHANNEL PROGRAM BEGINNING\n         DC    A(0)            DCB ADDRESS\n         DC    X'03000000'\n         DC    F'0'\n         DC    D'0'            INITIAL SEEK ADDRESS\nIOBCONL  EQU   *-IOBCONST\n* VTOC NAME FOR ALLOCATION\nVTOCNM   DC    A(VTOCNAME)\n         DC    Y(12)\nVTOCNAME DC    CL12'FORMAT4.DSCB'   DATA SET NAME FOR VTOC\n*\n*\n         LTORG\n         EJECT\n* SECTION DEFINITION AND REGISTER ASSIGNMENTS;\n         SPACE 2\nRWA      EQU   2\nRWB      EQU   3\nRWC      EQU   4\nRDCB     EQU   8              DCB POINTER\nRRCODE   EQU   10              RETURN CODE REGISTER\nRRET     EQU   9               LOCAL SUBROUTINE EXIT REGISTER\n         SPACE 3\n* TAGS FOR CHANNEL COMMANDS AND FLAG BITS:\n         SPACE\nREADR0   EQU   X'16'           READ RECORD 0\nREADCKD  EQU   X'1E'           READ COUNT, KEY, AND DATA\n         SPACE\nCC       EQU   X'40'           COMMAND CHAIN FLAG\nSLI      EQU   X'20'           SUPPRESS LENGTH INDICATION FLAG\nSKIP     EQU   X'10'           SKIP DATA TRANSFER FLAG\n         SPACE 3\n* COMMUNICATION VECTOR TABLE (CVT) DEFINITIONS:\n         SPACE\nCVT      EQU   16              LOCATION OF CVT BASE ADDRESS\nCVTPCNVT EQU   28              OFFSET TO CONVERT ROUTINE ADDRESS\n         EJECT\n*\n*        AREA USED BY VTOCREAD, PASSED VIA R13\n*\nVTOCWORK DSECT\n         DS    18F             SAVE AREA\n         SPACE\nEXCPSAVE DS    18F             INTERNAL SAVE AREA\nCBSIZE   DS    2F              SIZE AND LOCATION OF GOTTEN CORE\nCBADDR   EQU   CBSIZE+4\nNDSCBS   DS    F               NUMBER OF DSCB'S PER TRACK\nDSCBSTRT DS    F               ADDRESS OF 1ST DSCB BUFFER\nDSCBLIM  DS    F               ADDRESS OF LAST DSCB BUFFER\nDSCBADR  DS    F               ADDRESS OF CURRENT DSCB\nTTRN     DS    F               RELATIVE TRACK NUMBER\nVOLADDR  DS    A               FAKE PDL FOR ALLOC MACRO - ADDRESS\nVOLLEN   DS    H                       AND LENGTH OF VOLID\nUNITADDR DS    A               FAKE PDL FOR ALLOC MACRO - ADDRESS\nUNITLEN  DS    H                       AND LENGTH OF UNIT ADDRESS\nDDNPDL   DS    2F            SPACE FOR DDNAME PDL\n         SPACE\n* MODE SWITCH AND BIT DEFINITIONS\n         SPACE\nMODESW   DC    X'00'\nCBGOT    EQU   X'80'           CORE GOTTEN FOR BUFFER\nXCPRUN   EQU   X'40'           CHANNEL PROGRAM STARTED BUT NOT CHECKED\nRDERR    EQU   X'20'           PERMANENT I/O ERROR\nEOFSW    EQU   X'10'           END-OF-FILE SENSED\nALLOCSW  EQU   X'08'           ALLOCATE VOLUME FLAG\n         SPACE\nVTOCDCB  DCB   DDNAME=VTOCDD,MACRF=(E),EXLST=1\n         SPACE\nOPENBIT  EQU   X'10'\nOPENLIST DS    2F\n         SPACE\n* IOB FOR CHANNEL PROGRAM\n         SPACE\nVTOCIOB  DS    0D\nIOBFLAG1 DC    X'42000000'     COMMAND CHAIN, NOT RELATED\nIOBECB   DC    A(VTOCECB)\n         DC    2F'0'\nIOBSTART DC    A(0)            CHANNEL PROGRAM BEGINNING\nIOBDCB   DC    A(VTOCDCB)\n         DC    X'03000000'\n         DC    F'0'\nIOBSEEK  DC    D'0'            INITIAL SEEK ADDRESS\n         SPACE\n* EVENT CONTROL BLOCK FOR CHANNEL PROGRAM:\n         SPACE\nVTOCECB  DC    F'0'            EVENT CONTROL BLOCK\n         SPACE 3\n* INTERNAL BUFFER FOR LAST DSCB\nBUFF     DS    XL148\n         SPACE 2\nDSCBFMT4 CAMLST SEEK,IOBSEEK+3,VOLID,FMT4\nDSCBFMT3 CAMLST SEEK,IOBSEEK+3,VOLID,FMT3                        9257\nDSCBCCHH DS    XL5                      FOR READING DSCB DIRECT  9257\n         SPACE\n*   WORK AREA FOR DYNAMIC ALLOCATION\n         DYNSPACE\nS99FLIST DS    XL(S99FLEN)\n         SPACE\n*\n*        JFCB EXIT LIST AND AREA\n*\nJEXLST   DS    F\nJFCBAREA DS    XL176\n         DS    0D\nVTOCWLEN EQU   *-VTOCWORK\n         SPACE 2\n         PRINT GEN\n         VTOCOM\n         PRINT NOGEN\n         SPACE 2\n         IEFZB4D0\n         SPACE 2\n         IEFZB4D2\n         SPACE 2\n         DCBD  DEVD=DA,DSORG=PS\n         SPACE 2\nJFCB     DSECT\n         IEFJFCBN\n         END\nVTOCFORM TITLE 'VTOC COMMAND - FORMAT ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* FUNCTION -   FORMAT THE DATA INTO THE VTFMT  DSECT FROM THE         *\n*              FORMAT 1 ( AND 3 IF NEEDED ) DSCB.  THIS ROUTINE       *\n*              ALSO GETS THE AREA TO CONTAIN THE FORMATTED            *\n*              DSCB INFORMATION.                                      *\n*                                                                     *\n* OPERATION -  FIRST GET AN AREA FROM THE CURRENT BLOCK, OR GET       *\n*              A BLOCK ( 32K ) OF STORAGE TO USE FOR THE FORMATTED    *\n*              DSCB'S.  MOVE THE DATA OVER FROM THE FORMAT 1 DSCB.    *\n*              THE SPACE CALCULATIONS MAY NEED THE FORMAT 3 DSCB.     *\n*              CATALOG INFORMATION IS OBTIANED VIA LOCATE.  SOME      *\n*              OF THE DSCB INFORMATION IS CONVERTED HERE.             *\n*                                                                     *\n* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *\n*              POINTED TO BY REGISTER 1                               *\n*              USE PARSE DATA, CURRENT FORMATTED DSCB, LOCATE         *\n*                                                                     *\n* OUTPUT -     THE FORMATTED DSCB INFORMATION WITH ITS ADDRESS IN     *\n*              FORMATAD.                                              *\n*                                                                     *\n* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *\n*                                                                     *\n*                                                                     *\n*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *\n*         MODIFIED   BY C.    HUNTER  (313) 497-0524            0102  *\n*         MODIFIED   BY C.    HUNTER  (313) 540-0900           25JUN84*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\n         EJECT\n         MACRO\n&LAB     DS1TST  &FIELD,&VALUE,&CODE\n&LAB     TM    DS1&FIELD,X'&VALUE'  TEST IT\n         BNO   D&SYSNDX       IF NOT THERE, SKIP ALONG\n         MVC   VTF&FIELD,=CL3'&CODE'\nD&SYSNDX DS    0H\n         MEND\n         MACRO                                                 25JUN84\n         $FORMEX &I                                            25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+00-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+10-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+20-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+30-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+00-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+10-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+20-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+30-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+40-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+50-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+60-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84\n         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84\n         MEND                                                  25JUN84\n*\n*\n         EJECT\nVTOCFORM ENTER 12,16          DO THE HOUSEKEEPING\n         LR    R11,R1         SAVE ADDR OF VTOCOM\n         USING VTOCOM,R11     SET ITS ADDRESSABILITY\n         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER\n         USING PDL,R9         SET ITS ADDRESSABILITY\n         USING FORMWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA\n         SPACE 3\n*\n*        CHECK FOR THE FIRST TIME THROUGH\n*        IF SO, PERFORM SOME INITIALIZATION\n*\n         CLI   FIRSTFRM,0     IS THIS THE FIRST TIME?\n         BNE   GETAREA        NO, KEEP ON TRUCKIN'\n*\n*        ROUTINE INITIALIZATION\n*\n         MVI   FIRSTFRM,255   NOTE THE INITIALIZATION AS DONE\n         MVC   CAMLOC(CAMLEN),CAMCONST  SET UP THE CAMLST\n*\n*        FIND OR GET AN AREA FOR THE FORMATTED DSCB\n*              FIRST SEE HOW BIG IT IS\n*\nGETAREA  L     R7,DSCBADDR    POINT TO THE DSCB\n         LA    R7,8(R7)       GET PAST THE HEADER\n         USING DSCB1,R7       SET ADDRESSABILITY\n         LH    R1,DSNLEN     GET THE DSNAME LENGTH\n         LA    R4,VTFMTL(R1)  GET THE FORMATTED DSCB LENGTH\n*\n*        SEE IF THE CURRENT BLOCK CAN HANDLE IT\n*\nFORMFIT  L     R3,VTCCURLN    GET THE CURRENT AVAILABLE\n         SR    R3,R4          SEE IF IT WILL FIT\n         BM    GOGETMN        NO, GET ANOTHER BLOCK\n*\n*        NO SWEAT, GET THE SPACE FROM THIS BLOCK\n*\n         ST    R3,VTCCURLN    STORE THE NEW ( REDUCED ) CURRENT LENGTH\n         L     R3,VTCCURAD    POINT TO THE CURRENT ADDRESS\n         LA    R5,0(R3,R4)    POINT TO THE END OF THE BLOCK\n         ST    R5,VTCCURAD    AND PLACE THE NEW AVAILABLE ADDRESS\n*\n*        NOW FILL IN THE DATA IN THE FORMATTED DSCB\n*\n         USING VTFMT,R3       SET FORMATTED DSCB ADDRESSABILITY\n         ST    R3,FORMATAD    SAVE THIS BLOCK'S ADDRESS\n         XC    VTFNEXT,VTFNEXT  CLEAR THE SORT POINTER\n         MVC   VTFVOLUM,VOLID SAVE THE VOLUME SERIAL NUMBER\n         LH    R1,DSNLEN     GET THE LENGTH OF THE DSNAME\n         STH   R1,VTFDSNL     SAVE THE DSNAME LENGTH\n         BCTR  R1,0           SUBTRACT ONE FOR THE EX\n         EX    R1,MOVEDSN     MOVE IN THE DSNAME\n         MVC   VTFNOEPV,DS1NOEPV  NUMBER OF EXTENTS\n         MVC   VTFLRECL,DS1LRECL  LOGICAL RECORD LENGTH\n         MVC   VTFBLKSZ,DS1BLKL   BLOCK SIZE\n*\n*     MOVE IN THE CREATION DATE, EXPIRATION DATE, AND LAST ACCESS DATE\n*\n         MVC   VTFCREDT,DS1CREDT  MOVE OVER CREATION DATE\n         MVC   VTFEXPDT,DS1EXPDT  MOVE OVER EXPIRATION DATE\n         MVC   VTFLSTAC,DS1REFD   MOVE OVER LAST ACCESS DATE\n*\n*        FORMAT THE RECORD FORMAT INTO CHARACTERS\n*\n*\n         MVC   VTFRECFM,BLANKS  BLANK THE FIELD TO START\n         MVC   VTFACTON,BLANKS  ANOTHER BLANK FIELD\n         MVI   VTFDSTYP,C' ' AND STILL ANOTHER\n         LA    R2,VTFRECFM    POINT TO THE FIELD\n         TM    DS1RECFM,X'C0' UNKNOWN RECFM?\n         BZ    RECFM2         YES, TROUBLE\n         TM    DS1RECFM,X'40' IS IT FIXED?\n         BNZ   RECFM3         NO, KEEP TRYING\n         MVI   0(R2),C'F'     YES, SET UP THE FIRST CHAR\n         LA    R2,1(R2)       AND BUMP THE POINTER\n         B     RECFM2         CHECK OTHER ATTRIBUTES\nRECFM3   TM    DS1RECFM,X'80' SEE IF IT'S V OR U\n         BZ    RECFM4         VARIABLE RECFM\n         MVI   0(R2),C'U'     RECFM = U\n         B     RECFM4A        ADD TO THE POINTER AND KEEP LOOKING\nRECFM4   MVI   0(R2),C'V'     VARIABLE\nRECFM4A  LA    R2,1(R2)       GET PAST THIS CHAR\nRECFM2   DS    0H\nRECFM5   TM    DS1RECFM,X'10' IS IT BLOCKED?\n         BZ    RECFM6         NO, SKIP ON\n         MVI   0(R2),C'B'     YES, SET THE SYMBOL\n         LA    R2,1(R2)       GET PAST THE CHAR\nRECFM6   TM    DS1RECFM,X'08' IS IT SPANNED OR STANDARD?\n         BZ    RECFM6A        NO\n         MVI   0(R2),C'S'     YES, SET IT\n         LA    R2,1(R2)       GET PAST THIS CHARACTER\nRECFM6A  TM    DS1RECFM,X'20' CHECK TRACK OVERFLOW\n         BZ    RECFM7         NO DICE\n         MVI   0(R2),C'T'     YES, SET IT\n         LA    R2,1(R2)       PUSH THE POINTER ON\nRECFM7   TM    DS1RECFM,X'04' IS IT ASA CONTROL\n         BZ    RECFM8         NO, SKIP ON\n         MVI   0(R2),C'A'     YES, SET IT\n         LA    R2,1(R2)       GET PAST THIS CHAR\nRECFM8   TM    DS1RECFM,X'02' HOW ABOUT MACHINE CARRIAGE CONTROL\n         BZ    RECFM9         NO, SKIP ON\n         MVI   0(R2),C'M'     YES, SET IT\nRECFM9   DS    0H\n*\n*        FORMAT THE DSORG\n*\n         MVC   VTFDSORG,=CL3'   '  CLEAR THE FIELD\n         DS1TST DSORG,80,IS   TRY ISAM\n         DS1TST DSORG,40,PS   TRY SEQUENTIAL\n         DS1TST DSORG,20,DA   TRY DIRECT ACCESS\n         DS1TST DSORG,02,PO   TRY PARTITIONED\n         CLC   DS1DSORG(2),=X'0008'  IS IT VSAM?\n         BNE   DSORG05       NO, KEEP LOOKING\n         MVC   VTFDSORG,=CL3'VS ' YES, FLAG IT\nDSORG05  TM    DS1DSORG,X'01'      IS IT UNMOVEABLE?\n         BNO   DSORG06       NO, KEEP ON TRUCKIN'\n         MVI   VTFDSORG+2,C'U'     YES, NOTE IT\nDSORG06  DS    0H\n*\n*        FORMAT THE SECONDARY ALLOCATION\n*\n         SR    R1,R1          CLEAR A WORK REGISTER\n         IC    R1,DS1SCALO    GET THE ALLOCATION FLAG\n         SRL   R1,6           REMOVE THE BOTTOM 6 BITS ( 75 CENTS )\n         IC    R2,SECAL(R1)   GET THE CHARACTER CODE\n         STC   R2,VTFSECAL    AND SAVE IT FOR LATER\n         MVC   VTFSECAM,DS1SCALO+2  SAVE THE SECONDARY AMOUNT TOO\n         MVI   VTFROUND,C'N'  SET CODE FOR NO ROUND\n         TM    DS1SCALO,X'01' SEE IF ROUND WAS SET\n         BNO   PROTFORM       NO, THE CODE IS SET RIGHT\n         MVI   VTFROUND,C'R'  YES, RESET THE CODE\n*\n*        FORMAT THE PASSWORD PROTECTION\n*\nPROTFORM TM    DS1DSIND,X'14' CHECK THE PASSWORD BITS\n         BO    PROTWRIT       WRITE PROTECT IS X'14'\n         BM    PROTREAD       READ PROTECT IS X'10'\n         MVI   VTFPROT,C'N'   NO PASSWORD PROTECTION\n         B     PROTEND        END OF PROTECTION FORMATTING\nPROTWRIT MVI   VTFPROT,C'W'   SET CODE FOR WRITE PROTECT\n         B     PROTEND        THEN CHECK OTHER ITEMS\nPROTREAD MVI   VTFPROT,C'R'   SET CODE FOR READ/WRITE PROTECT\nPROTEND  DS    0H             END OF PROTECTION FORMATTING\n*\n*        FORMAT THE CATLG\n*\n         MVI   VTFCATLG,C' ' INITIALIZE IT TO BLANKS\n         CLI   CATK+1,0       SHOULD WE DO THE LOCATE?\n         BE    CATEND         NO, SKIP PAST IT\n*\n*        SET UP THE CAMLST\n*\n         LA    R1,DS1DSNAM    POINT TO THE DSNAME\n         ST    R1,CAMLOC+4    SAVE IT IN THE CAMLST\n         LA    R1,LOCWORK     LOCATE WORKAREA\n         ST    R1,CAMLOC+12   SAVE IT IN THE CAMLST\n         LOCATE CAMLOC        CHECK THE CATALOG\n         LTR   R15,R15        TEST THE CATALOG RETURN CODE\n         BZ    CATOK          ZERO, THERE IS AN ENTRY\n         MVI   VTFCATLG,C'N'  SET CODE FOR NOT CATALOGED\n         CH    R15,H8         SEE IF THAT'S THE CASE\n         BE    CATEND         YES, LET IT STAND\n         MVI   VTFCATLG,C'E'  CATALOG ERROR, PROBLEMS\n*\n*        CATALOG ENTRY IS THERE, SEE THAT THE VOLUME IS THIS ONE\n*\nCATOK    MVI   VTFCATLG,C'C'  SET UP AS A GOOD ENTRY\n         CLC   VOLID,LOCWORK+6  COMPARE THE VOLUME SERIAL NUMBERS\n         BE    CATEND         GOOD, WE'RE DONE\n         MVI   VTFCATLG,C'W'  WRONG VOLUME, NOT CATALOGED\nCATEND   DS    0H\n*\n*        FORMAT THE ALLOCATION AND USED QUANTITIES\n*\n         SPACE\n*        CHECK THROUGH THE EXTENTS\n         SPACE\n         SR    R2,R2          CLEAR A WORK REGISTER\n         ICM   R2,B'0001',DS1NOEPV  GET THE NUMBER OF EXTENTS\n         BZ    SPACEND        NO EXTENTS MEANS NO SPACE\n         SR    R4,R4          ZERO THE SPACE COUNTER FOR THE DATA SET\n*\n*        GET EACH EXTENT AND PROCESS IT\n*\n         SR    R6,R6          FIRST EXTENT\nEXTNEXT  LR    R5,R6          GET THE CURRENT EXTENT NUMBER\n         CH    R5,GETEXMAX             MAX EXTENTS             25JUN84\n         BH    SPACEND                 TOO MANY - SKIP         25JUN84\n         SLL   R5,1                    MULT. BY 2              25JUN84\n         LH    R5,GETEXT(R5)           GET EXTENT OFFSET       25JUN84\n         CH    R6,=H'2'                IS EXTENT IN F1 OR F3   25JUN84\n         BH    EXTNXF3                 F3                      25JUN84\n         LA    R5,DS1EXT1(R5)          +F1 BASE = ADDR OF EXT  25JUN84\n         B     EXTNXFX                 CONTINUE                25JUN84\nEXTNXF3  DS    0H                                              25JUN84\n         LA    R5,FMT3(R5)             +F3 BASE = ADDR OF EXT  25JUN84\nEXTNXFX  DS    0H                                              25JUN84\n*\n*        PROCESS THIS EXTENT\n*\n         USING XTDSECT,R5     SET ADDRESSABILITY\n         CLI   XTFLAGS,XTNOEXT  IS THERE AN EXTENT\n         BE    NOEXT          NO, THE EXTENT ISN'T THERE\n         CLI   XTFLAGS,XTCYLBD  IS IT ON CYLINDER BOUNDARIES\n         BNE   FORMALOC       NO, DO IT FOR CYLS AND TRACKS\n*\n*        CYLINDER BOUNDS - BE SURE THE ALLOCATION IS CORRECT\n*\n         ICM   R1,B'0011',XTLOWHH GET THE LOWER TRACK\n         BZ    LOWOK          IT'S ZERO\n         MVC   VTFACTON(6),=C'CYLERR'  NOTE THE ERROR\n         MVI   VTFACTON+6,C'L'  ON THE LOW CCHH\nLOWOK    LH    R1,XTHIHH      GET THE HIGH TRACK\n         LA    R1,1(R1)       ADD ONE FOR ZERO ADDRESSING\n         CH    R1,DS4DEVSZ+2  IS THIS THE NUMBER OF TRACKS/CYL\n         BE    FORMALOC       YES, GO CALCULATE\n         MVC   VTFACTON(6),=C'CYLERR'  NOTE THE ERROR\n         MVI   VTFACTON+7,C'H'  ON THE HIGH CCHH\n*\n*        GET THE SPACE FOR NON-CYLINDER ALLOCATIONS\n*\nFORMALOC LH    R1,XTHICC      GET THE HIGH CYLINDER\n         SH    R1,XTLOWCC     MINUS THE LOW CYLINDER\n         MH    R1,DS4DEVSZ+2  TIMES THE NUMBER OF TRACKS PER CYLINDER\n         LH    R8,XTHIHH      GET THE HIGH TRACK\n         SH    R8,XTLOWHH     MINUS THE LOW TRACK\n         AR    R8,R1          TRACKS IN THIS EXTENT ( MINUS 1 )\n         LA    R4,1(R4,R8)    ADD THE TRACKS TOGETHER FOR THIS DATA SET\n*\n*        GET THE NEXT EXTENT\n*\nNOEXT    LA    R6,1(R6)       INCREMENT THE EXTENT COUNTER\n         CR    R6,R2          CHECK FOR THE END\n         BL    EXTNEXT        NOT YET, KEEP GOING\n*\n*        ALL THE EXTENTS ARE SUMMED REGISTER 4 HAS THE SUM\n*\n         BAL   R8,SPACUNIT    CHANGE IT TO THE APPROPRIATE UNITS\n         ST    R4,VTFALLOC    STORE IT FOR LATER\nSPACEND  DS    0H\n*\n*        GET THE TRACKS USED\n*\n         SR    R4,R4          CLEAR THE TRACK ( WOO WOO )\n         CLC   DS1LSTAR,ZEROES IS THE TRACK USED COUNTER SET?\n         BNE   USEDOK         YES, ACCEPT IT\n*        NO, SEE IF THE ZERO IS VALID\n         TM    DS1DSORG,X'40' IS IT SEQUENTIAL?\n         BO    USEDOK0        YES,THE ZERO IS VALID\n         CLC   DS1DSORG(4),ZEROES  MAYBE IT WASN'T EVER OPENED  0102\n         BE    USEDOK0        THEN NO SPACE USED IS OK\n         TM    DS1DSORG,X'0C' CHECK FOR AN INVALID DSORG\n*        BO    USEDOK0        NO SPACE USED IS STILL OK   *NOP* 0102\n         MVC   VTFUSED,VTFALLOC SET A FLAG UNUSED SPACE UNKNOWN 0102\n         B     USEDEND        USED SPACE IS SET\n*\n*        THE TRACKS USED COUNTER SEEMS OK\n*\nUSEDOK   LH    R4,DS1LSTAR    GET THE LAST TRACK USED\n         LA    R4,1(R4)       ADD ONE ( ZERO ADDRESSING )\n         BAL   R8,SPACUNIT    CONVERT TO APPROPRIATE UNITS\nUSEDOK0  ST    R4,VTFUSED     SAVE THE AMOUNT OF SPACE USED\nUSEDEND  DS    0H\n         L     R14,VTFALLOC   ALLOCATED TRACKS\n         S     R14,VTFUSED    MINUS USED TRACKS\n         ST    R14,VTFUNUSD   EQUALS UNUSED TRACKS\n         SR    R14,R14\n         SR    R15,R15\n         CLC   VTFALLOC(4),=F'0'\n         BE    USEDEND1\n         L     R15,VTFUSED    USED TRACKS\n         M     R14,=F'100'    MULT BY 100 TO GET PCT\n         D     R14,VTFALLOC   DIVIDE BY ALLOC TO GET PCT USED\nUSEDEND1 STH   R15,VTFPCT     SAVE PCT USED\n*\n*        RETURN\n*\nFORMRET  LEAVE EQ,RC=0\n*\n*\n         EJECT\n*\n*        ROUTINES USED ABOVE\n*\n*\n*        CONVERT FROM TRACKS TO THE APPROPRIATE UNITS\n*              KBYTES, MBYTES, TRKS, OR CYLS\n*\nSPACUNIT LH    R1,SPACEK      GET THE UNIT TYPE\n         SLL   R1,2           MULTIPLY BY 4\n         B     *+4(R1)        THEN BRANCH TO THE CORRECT ROUTINE\n         B     SPACTRK        R1=0  KILOBYTES\n         B     SPACTRK        R1=1  KILOBYTES\n         B     SPACTRK        R1=2  MEGABYTES\n         B     SPACTRK        R1=3  TRACKS\n         B     SPACTRK        R1=4  CYLINDERS\n*        TRACKS\nSPACTRK  BR    R8             WAS SET WHEN WE STARTED\n*        CYLINDERS\nSPACCYL  SR    R0,R0          CLEAR A REGISTER\n         LR    R1,R4          GET THE NUMBER OF TRACKS\n         LH    R4,DS4DEVSZ+2  GET THE NUMBER OF TRACKS PER CYLINDER\n         SRL   R4,2           DIVIDE BY 2 FOR ROUNDING\n         AR    R1,R4          ADD IT IN\n         LH    R4,DS4DEVSZ+2  GET THE NUMBER OF TRACKS PER CYLINDER\n         DR    R0,R4          DIVIDE TO GET ROUNDED CYLINDERS\n         LR    R4,R1          GET THE ANSWER BACK INTO R4\n         BR    R8             THEN RETURN\n*        KILOBYTES\nSPACKB   MH    R4,DS4DEVTK    MULTIPLY BY BYTES PER TRACK\n         SR    R0,R0          CLEAR THE TOP\n         LR    R1,R4          GET THE NUMBER TO DIVIDE\n         A     R1,F500        ADD UP TO ROUND\n         D     R0,F1000       DIVIDE TO GET KILOBYTES\n         LR    R4,R1          GET THE ANSWER BACK INTO R4\n         BR    R8             THEN RETURN\n*        MEGABYTES\nSPACMB   MH    R4,DS4DEVTK    MULTIPLY BY BYTES PER TRACK\n         SR    R0,R0          CLEAR THE TOP\n         LR    R1,R4          GET THE NUMBER TO DIVIDE\n         A     R1,F500000     ADD UP TO ROUND\n         D     R0,F1000000    DIVIDE TO GET MEGABYTES\n         LR    R4,R1          GET THE ANSWER BACK INTO R4\n         BR    R8             THEN RETURN\n*\n*        GET A NEW BLOCK OF MAIN STORAGE\n*\nGOGETMN  GETMAIN R,LV=VTCGETMS  GET SOME\n         ST    R1,VTCCURAD    SET UP THE AVAILABLE ADDRESS\n         LA    R2,VTCGETMS/1024   GET THE SIZE OF THE BLOCK IN K\n         SLL   R2,10          GET IT INTO BYTES ( TIMES 1024 )\n         ST    R2,VTCCURLN    SO THE FORMATTED DSCB'S CAN USE IT\n*\n*        SAVE THE BLOCK ADDRESS IN THE VTCGETMN TABLE\n*\n         LA    R2,VTCGETMN    POINT TO THE TABLE\n         LA    R5,VTCGETMX    GET THE NUMBER OF ENTRIES IN THE TABLE\nGOGETTAB ICM   R3,B'1111',0(R2) GET THIS ENTRY\n         BNZ   GOGETINC       IF NOT ZERO, KEEP LOOKING\n         ST    R1,0(R2)       SAVE THE NEW ENTRY\n         B     FORMFIT        THEN GO ALLOCATE A FORMATTED DSCB\n*\n*        THIS ENTRY WAS TAKEN, GET THE NEXT ONE\n*\nGOGETINC LA    R2,4(R2)       POINT TO THE NEXT ENTRY\n         BCT   R5,GOGETTAB    COUNT AND LOOP\n*\n*        TABLE OVERFLOW  - ISSUE ERROR MSG\n*              SET A FLAG TO STOP INPUT\n*\n         VTOCMSG TABOVFLW,TABOVSEC  ISSUE A MESSAGE\n         MVI   TABFULL,255    SET A STOP FLAG\n         B     FORMRET        RETURN FROM FORMATTING\n         EJECT\n*\n*\n*\n*        PROGRAM CONSTANTS\n*\n         SPACE\n*        INSTRUCTIONS EXECUTED TO GET THE NEXT EXTENT\nGETEXT   DC    AL2(DS1EXT1-DS1EXT1)    1ST EXTENT OFFSET       25JUN84\n         DC    AL2(DS1EXT2-DS1EXT1)    2ND \"                   25JUN84\n         DC    AL2(DS1EXT3-DS1EXT1)    3RD \"                   25JUN84\n         $FORMEX ,                     4-16 EXT                25JUN84\n         $FORMEX X1                    17-   EXTENT            25JUN84\n         $FORMEX X2                    30-   EXTENT            25JUN84\n         $FORMEX X3                    43-   EXTENT            25JUN84\n         $FORMEX X4                    56-   EXTENT            25JUN84\n         $FORMEX X5                    69-   EXTENT            25JUN84\n         $FORMEX X6                    82-   EXTENT            25JUN84\n         $FORMEX X7                    95-   EXTENT            25JUN84\n         $FORMEX X8                    108-  EXTENT            25JUN84\n         $FORMEX X9                    121-  EXTENT            25JUN84\nGETEXMAX DC    AL2((*-GETEXT)/2)       MAX                     25JUN84\n*                                                              25JUN84\nMOVEDSN  MVC   VTFDSN(0),DS1DSNAM   EXECUTED COMPARE\nZEROES   DC    2F'0'\nFMIN1    DC    F'-1'\nF500     DC    F'500'\nF1000    DC    F'1000'\nF500000  DC    F'500000'\nF1000000 DC    F'1000000'\nBLANKS   DC    CL8'                '\nCAMCONST CAMLST NAME,*,,*\nH8       DC    H'8'\nSECAL    DC    C'ABTC'        SECONDARY ALLOCATION CODES\n*              ABSOLUTE TRK, BLOCKS, TRACKS, CYLINDERS\n*\n*\n*\n         PRINT NOGEN\n*\n*        PROGRAM MESSAGES\n*\nTABOVFLW MSG   ' THE VTOC TABLES (1.6 MEG) ARE NOT LARGE ENOUGH TO HANDX\n               LE THIS REQUEST'\nTABOVSEC MSG   ' PARTIAL PROCESSING WILL CONTINUE '\n*\n*\n*\n*\n*\n*\n         EJECT\n*\n*\n*        P A R S E   C O N T R O L   L I S T\n*\n*\n         PRINT OFF\n         COPY  VTOCPARS\n         PRINT ON\n*\n*        DYNAMIC WORK AREA\n*\n         SPACE 3\nFORMWORK DSECT\n         DS    18A            PRINT ROUTINE SAVE AREA\nFIRSTFRM DS    X              INITIALIZATION FOR THIS ROUTINE\nCHARS    DS    CL16           CONVERSION TO CHARACTERS\nCAMLOC   CAMLST NAME,*,,*\nCAMLEN   EQU   *-CAMLOC\n         DS    0D\nLOCWORK  DS    265C\n         SPACE\n         DS    0D\nLENWORK  EQU   *-FORMWORK\n*\n*        VTOC COMMAND COMMON AREA\n*\n         PRINT NOGEN\n         VTOCOM\n         SPACE 3\n*\n*        FORMATTED DSCB\n*\n         PRINT GEN\n         VTFMT\n         PRINT NOGEN\n         SPACE 3\n         PDEDSNAM\n         SPACE 3\n         SPACE 3\nDSCB1    DSECT\n         IECSDSL1 1\n         SPACE 3\n*        FORMAT 1 AND 3 EXTENT DESCRIPTION\nXTDSECT  DSECT\nXTFLAGS  DS    X\nXTNOEXT  EQU   X'00'          NO EXTENT\nXTDATAB  EQU   X'01'          DAT BLOCKS\nXTOVFLW  EQU   X'02'          OVERFLOW AREA\nXTINDEX  EQU   X'04'          INDEX AREA\nXTUSRLAB EQU   X'40'          USER LABEL EXTENT\nXTSHRCYL EQU   X'80'          SHARING CYLINDERS\nXTCYLBD  EQU   X'81'          CYLINDER BOUNDARIES\nXTSEQ    DS    X              EXTENT SEQUENCE NUMBER\nXTLOWCC  DS    H              LOWER CYLINDER\nXTLOWHH  DS    H              LOWER TRACK\nXTHICC   DS    H              UPPER CYLINDER\nXTHIHH   DS    H              UPPER TRACK\n         END\nVTOCMSG  TITLE 'VTOC COMMAND - MESSAGE ROUTINE'\n*\n*   VTOC ERROR MESSAGE ROUTINE, R1 POINTS TO VTOC COMMON AT ENTRY\n*\nVTOCMSG  ENTER 12,0           DO THE STANDARD HOUSEKEEPING\n         LR    R11,R1         GET THE PARM REGISTER\n         USING VTOCOM,R11     SET ADDRESSABILITY\n         SPACE\n         LM    R0,R1,MSGADDRS GET THE MESSAGE(S) TO SEND\n         LTR   R0,R0          SECOND LEVEL MSG?\n         BZ    ERRORM1        NO\n         SPACE\n         MVC   MSGTEXT1,0(R1) INSURE MSG IN WORK AREA\n         LA    R1,MSGTEXT1\n         SPACE\n         LH    R14,0(R1)      LENGTH OF FIRST LEVEL MSG\n         LA    R15,0(R14,R1)  ADDR OF END OF MSG\n         LA    R14,1(R14)     JUMP MSG LENGTH\n         STH   R14,0(R1)\n         MVI   0(R15),C'+'    INDICATE SECOND LEVEL MSG EXISTS\n         SPACE 2\n         SR    R14,R14        CLEAR CHAIN FIELD\n         LA    R15,1          ONE SEGMENT IN 2ND MSG\n         STM   R14,R0,PUTOLD2 CREATE SECOND-LEVEL\n*                             OUTPUT LINE DESCRIPTOR ('OLD')\n         LA    R0,PUTOLD2\n         SPACE 3\nERRORM1  LR    R14,R0         NEXT 'OLD' ADDR OR ZERO\n         LA    R15,1          ONE SEGMENT\n         LR    R0,R1          MSG ADDR\n         STM   R14,R0,PUTOLD1 FIRST LEVEL 'OLD'\n         SPACE\n         LA    R1,PARMLIST\n         USING IOPL,R1\n         SPACE\n         MVC   IOPLECT,ADDRECT\n         MVC   IOPLUPT,ADDRUPT\n         SPACE\n         LA    R0,ATTNECB\n         ST    R0,IOPLECB\n         MVI   ATTNECB,0\n         SPACE 3\n         XC    PARMLIST+16(4),PARMLIST+16\n         PUTLINE PARM=PARMLIST+16,MF=(E,(1)),                          X\n               OUTPUT=(PUTOLD1,TERM,MULTLVL,INFOR)\n         SPACE 3\n         LEAVE EQ\n         SPACE 3\n         IKJIOPL\n         SPACE 3\n         VTOCOM\n         END\nVTOCPRNT TITLE 'VTOC COMMAND - PRINT ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* FUNCTION -   PRINT THE DATA PASSED TO IT.  IT WILL USE THE DDNAME   *\n*              SYSOUT IF IT IS ALLOCATED, AND WILL USE THE VTOCMSG    *\n*              ROUTINE IF NOT.  IT CAN ALSO PUT OUT THE DATA TO       *\n*              AN OUTPUT DATA SET.  TOTALS ARE COMPUTED HERE.         *\n*                                                                     *\n* OPERATION -  FOR UNSORTED DATA, GET THE CURRENT ENTRY, ADD TO THE   *\n*              TOTALS, AND OUTPUT IT.  IF THE DATA IS SORTED, THE     *\n*              ACTION IS MORE COMPLEX, BECAUSE ALL THE DATA SETS      *\n*              ARE TO BE OUTPUT.  THE TOTALS AND BREAKS MAY BE        *\n*              NEEDED AT ANY POINT.                                   *\n*                                                                     *\n* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *\n*              POINTED TO BY REGISTER 1                               *\n*              USE PARSE DATA, CURRENT FORMATTED DSCB, SORTED LIST    *\n*                                                                     *\n* OUTPUT -     TO SYSOUT, A LIST OF THE REQUESTED DATA SETS AND       *\n*              THEIR ATTRIBUTES, WITH TOTALS AND BREAKS AS NEEDED.    *\n*              ALSO TO THE OUTPUT DATA SET, IF NEEDED.  IF SYSOUT     *\n*              IS NOT ALLOCATED, VTOCMSG IS USED FOR OUTPUT.          *\n*                                                                     *\n* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *\n*                                                                     *\n*                                                                     *\n*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\n*        MACRO FOR DEFINING FAKE PDE FOR A DEFAULT LIST\n*\n         EJECT\nVTOCPRNT ENTER 12,20          DO THE HOUSEKEEPING\n         LR    R11,R1         SAVE ADDR OF VTOCOM\n         USING VTOCOM,R11     SET ITS ADDRESSABILITY\n         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER\n         USING PDL,R9         SET ITS ADDRESSABILITY\n         USING PRNTWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA\n         SPACE 3\n*\n*        CHECK FOR THE PRINT CLEAN - CLOSE AND FREEMAIN\n*\n         CLI   VTCEPRNT,0     IS IT TIME\n         BNE   PRNTCLEN       YES, GO DO IT\n*\n*        CHECK FOR THE FIRST TIME THROUGH\n*        IF SO, SET UP THE DCB'S AND OPEN THEM\n*\n         CLI   FIRSTIM,0      IS THIS THE FIRST TIME?\n         BNE   CHKSORT        NO, KEEP ON TRUCKIN'\n         B     PRTINIT    INITIALIZE FOR PRINTING\n*\n*        CHECK TO SEE IF THE DATA IS SORTED\n*\nCHKSORT  CLI   SORTK+1,2      IS THIS NOSORT?\n         BNE   SORTED         NO, THE ENTRIES ARE SORTED\n*\n*        NOSORT WAS SPECIFIED.  ONLY THE CURRENT ENTRY IS AVAILABLE\n*\n         L     R3,FORMATAD    POINT TO THE ENTRY\n         USING VTFMT,R3       FORMATTED DSCB ADDRESSABILITY\n         LTR   R3,R3          IS IT THERE?\n         BZ    CHEKTOT        NO, SEE IF A TOTAL HAS BEEN OUTPUT\n         XC    FORMATAD,FORMATAD  CLEAR THE ADDRESS FOR LATER\n*\n*        ADD TO THE TOTALS\n*\n         BAL   R8,ADDTOT      GO DO IT\n*\n*        SEE IF THE OUTPUT DATA SET IS WANTED\n*\n         TM    OUTDCB+48,X'10'  IS THE DCB OPEN?\n         BNO   NOOUTPT        NO, SKIP ALONG\n         BAL   R8,OUTPUT      YES, GO DO IT\n*\n*        SEE IF THERE'S PRINTING TO DO\n*\nNOOUTPT  CLI   PRINTK+1,2     WAS NOPRINT SPECIFIED?\n         BE    VTRET          YES, WE'RE DONE FOR NOW\n         BAL   R8,PRINT       NO, PRINT OUT THE ENTRY\n*\n*        RETURN FROM WHENCE WE CAME\n*\nVTRET    LEAVE EQ,RC=0        EXEUNT\n*\n*        NOSORT, CHECK FOR OUTPUTTING THE TOTALS\n*\nCHEKTOT  TM    ENDTOTAL,ENTOTOUT  WAS THE TOTAL OUTPUT BEFORE?\n         BO    VTRET          YES, JUST RETURN\n         BAL   R8,PRNTOT      NO, OUTPUT THE TOTAL\n         OI    ENDTOTAL,ENTOTOUT  REMEMBER THE TOTAL IS OUT\n         B     VTRET          THEN RETURN\n         EJECT\n*\n*        THE DATA IS SORTED, SO THE LISTS MUST BE EMPTIED.\n*        CHECK EACH ITEM FOR A TOTAL AND FOR A BREAK\n*        OUTPUT TO PRINT AND/OR THE OUTPUT DATA SET\n*\n*\n*        FIRST GET THE TOTAL AND BREAK COUNTS FOR COMPARES\n*\nSORTED   LA    R1,TOTALN      POINT TO THE TOTAL PDL\n         BAL   R8,PDLNUM      CONVERT IT TO A NUMBER\n         LTR   R15,R15        IS IT ZERO?\n         BNZ   SETTNUM        NO, IT'S GOOD\n         OI    ENDTOTAL,ENDTONLY  YES, TOTALS AT THE END ONLY\nSETTNUM  BCTR  R15,0          CUT IT DOWN ONE\n         STH   R15,NUMTOTAL   SET THE TOTAL COUNT\n         LA    R1,BREAK       POINT TO THE BREAK PDL\n         BAL   R8,PDLNUM      CONVERT IT TO A NUMBER\n         LTR   R15,R15        IS IT ZERO?\n         BNZ   SETBNUM        NO, IT'S GOOD\n         OI    ENDTOTAL,NOBREAK   YES, BREAK  AT THE END ONLY\nSETBNUM  BCTR  R15,0          CUT IT DOWN ONE\n         STH   R15,NUMBREAK   SET THE BREAK COUNT\n*\n*        START GOING THROUGH THE LISTS, PROCESS THE ENTRIES\n*\n         LA    R4,VTCSORTH    POINT TO THE LISTS\n         LA    R5,VTCSORTE    POINT TO THE END OF THE LISTS\n         ST    R5,ADDREND     SAVE THE ADDRESS\nNEWLIST  L     R3,0(R4)       GET THE FIRST ENTRY FROM THIS LIST\n         LTR   R3,R3          ANYTHING ON THIS LIST?\n         BZ    NEXTLIST       NO, GET ANOTHER LIST\n*\n*        THIS IS AN ENTRY, DO THE TOTALS, PRINT, AND OUTPUT\n*        CHECK FOR TOTALS AND BREAKS FIRST\n*\nGOTENTRY CLI   PRINTK+1,2     WAS NOPRINT SET?\n         BE    CHKOUTPT       YES, SKIP INTERIM TOTALS\n         MVI   TOTLAST,0      SET UP FLAG FOR TOTAL AS LAST ACTION\n*        NOTE - EXTENSION - OUTPUT INTERIM TOTALS WITH THE KEY\n         TM    ENDTOTAL,ENDTONLY  END TOTAL ONLY?\n         BO    CHKBREAK       YES, SEE ABOUT BREAKS\n         LH    R2,NUMTOTAL    GET THE LENGTH TO COMPARE\n         L     R1,LASTKEY     GET THE LAST ENTRY\n         EX    R2,COMPKEY     SEE IF THIS IS THE SAME\n         BE    CHKBREAK       YES, KEEP COUNTING\n*\n*        THIS ONE IS DIFFERENT, PRINT THE TOTALS FIRST\n*\n         BAL   R8,PRNTOT      PRINT THE TOTALS\n*\n*        CHECK FOR A BREAK\n*\nCHKBREAK TM    ENDTOTAL,NOBREAK   NO BREAKS THIS TIME?\n         BO    SKPBREAK       YES, SKIP PAST BREAKS\n         LH    R2,NUMBREAK    GET THE LENGTH TO COMPARE\n         L     R1,LASTKEY     GET THE LAST ENTRY\n         EX    R2,COMPKEY     SEE IF THIS IS THE SAME\n         BE    SKPBREAK       YES, KEEP COUNTING\n*\n*        THIS ONE IS DIFFERENT, GET A NEW PAGE\n*\n         MVC   LINECT,LINEMAX BE SURE THE NEXT ITEM GETS A NEW PAGE\n         MVI   TOTLAST,0      DON'T SKIP A LINE AFTER TOTAL\n         LA    R1,VTFDSN     POINT TO THE DSNAME\n         ST    R1,LASTKEY    SAVE THE ADDRESS FOR BREAK COMPARES\n*\n*        PRINT THE ITEM\n*\nSKPBREAK CLI   TOTLAST,0      WAS A TOTAL NOT FOLLOWED BY A BREAK?\n         BE    SKPBREA2       NO, CONTINUE NORMALLY\n         MVC   MSGBL,MSGBLC   YES, SET UP A BLANK MESSAGE\n         LA    R1,MSGBL       POINT TO IT\n         BAL   R8,PRNTLINE    THEN PUTPUT IT\nSKPBREA2 BAL   R8,PRINT       FINAL FORMAT AND PRINT\n*\n*        CHECK FOR DATA SET OUTPUT\n*\nCHKOUTPT TM    OUTDCB+48,X'10'     IS IT OPEN AND READY\n         BNO   GOTOT          NO, GO DO THE TOTALS\n         BAL   R8,OUTPUT      YES, PUT OUT THE DATA SET ENTRY\n*\n*        ADD UP THE TOTALS\n*\nGOTOT    BAL   R8,ADDTOT      SUM THEM\n*\n*        GET THE NEXT ENTRY\n*\n         ICM   R3,B'1111',VTFNEXT  FOLLOW THE CHAIN\n         BNZ   GOTENTRY       SOMETHING'S THERE, USE IT\n*\n*        END OF THIS LIST, TRY THE NEXT LIST\n*\nNEXTLIST LA    R4,12(0,R4)    MOVE OVER ONE\n         C     R4,ADDREND     WAS THAT THE LAST LIST?\n         BL    NEWLIST        NO, KEEP TRYING\n*\n*        END OF THE LISTS, OUTPUT THE FINAL TOTAL AND RETURN\n*\n         BAL   R8,PRNTOT      LIST THE TOTAL\n*\n*        CLEAR OUT THE PRINT LISTS\n*\n         XC    VTCSORTH+000(256),VTCSORTH  CLEAR 64 ENTRIES\n         XC    VTCSORTH+256(256),VTCSORTH+256 CLEAR 64 ENTRIES\n         XC    VTCSORTH+512(256),VTCSORTH+512 CLEAR 64 ENTRIES\n         XC    VTCSORTH+768(256),VTCSORTH+768 CLEAR 64 ENTRIES\n         B     VTRET          THEN GET OUT OF HERE\n         EJECT\n*\n*        PRINT CLEANUP ROUTINE - CLOSE DCB'S FIRST\n*\nPRNTCLEN TM    SYSOUT+48,X'10'  IS SYSOUT OPEN?\n         BNO   PRNTCLO        NO, CHECK THE OUTDCB\n         CLOSE (SYSOUT),MF=(E,OPENLIST)  DO THE CLOSE\nPRNTCLO  TM    OUTDCB+48,X'10'  IS OUTDCB OPEN?\n         BNO   PRNTFREE       NO, SKIP DOWN TO THE FREEMAINS\n         CLOSE (OUTDCB),MF=(E,OPENLIST)  DO THE CLOSE\n*\n*        FREE UP THE STORAGE\n*\nPRNTFREE LA    R2,VTCGETMN    POINT TO THE TABLE\n         LA    R5,VTCGETMX    GET THE NUMBER OF ENTRIES IN THE TABLE\nPRNTFRL  ICM   R3,B'1111',0(R2)  GET THE STORAGE ADDRESS\n         BZ    VTRET          IF ZERO, WE'RE DONE\n         FREEMAIN R,LV=VTCGETMS,A=(R3)  FREE IT\n         XC    0(4,R2),0(R2)  CLEAR THE ADDRESS\n         LA    R2,4(R2)       GET THE NEXT BLOCK ADDRESS\n         BCT   R5,PRNTFRL     AND LOOP UNTIL DONE\n         B     VTRET          THEN RETURN\n*\n         EJECT\n*\n*        ROUTINES USED ABOVE\n*              ADDTOT - ADD TO THE CURRENT TOTALS\n*              PRNTOT - PRINT OUT THE TOTALS AND CLEAR THEM\n*              PRINT  - PRINT OUT AN ENTRY\n*              OUTPUT - OUTPUT THE DATA SET ENTRY\n*              PDLNUM - GET A NUMBER FROM A PDL ENTRY\n*              PRNTLINE - INTERNAL ROUTINE TO COUNT LINES, OUTPUT HEAD\n*\nADDTOT   L     R1,TOTDS       NUMBER OF DATA SETS\n         LA    R1,1(R1)       ADD ONE\n         ST    R1,TOTDS       STORE IT BACK\n         L     R1,TOTALLOC    TOTAL ALLOCATION\n         A     R1,VTFALLOC    ADD IN THIS DATA SET\n         ST    R1,TOTALLOC    STORE IT BACK\n         L     R1,TOTUSED     TOTAL USED SPACE\n         A     R1,VTFUSED     ADD IN THIS DATA SET\n         ST    R1,TOTUSED     STORE IT BACK\n         BR    R8             RETURN\n*\n         EJECT\n*\n*        PRINT THE TOTALS\n*              FIRST FORMAT THEM, THEN PUT THE LINE OUT TO SYSOUT\n*              OR USE VTOCMSG TO LIST IT\n*\nPRNTOT   ST    R8,PRNTTOT8   SAVE THE RETURN ADDRESS\n         MVC   MSGWORK(MSGTLEN),MSGTOTC  INIT THE MSG\n         CONV  MSGWORK+4+11,TOTDS,5  CONVERT NO OF DATA SETS\n         CONV  MSGWORK+4+28,TOTALLOC,8  CONVERT ALLOCATION\n         CONV  MSGWORK+4+51,TOTUSED,8   CONVERT USED SPACE\n         MVC   MSGWORK+4+37(6),SPACTYPE MOVE IN THE UNITS\n         MVC   MSGWORK+4+60(6),SPACTYPE MOVE IN THE UNITS\n*\n*        NOW OUTPUT THE MESSAGE\n*\n         MVI   MSGWORK+4,C'0' ADD A CARRIAGE CONTROL\n         LA    R1,MSGWORK     POINT TO THE TOTAL LINE\n         BAL   R8,PRNTLINE    PUT OUT THE TOTAL LINE\n         MVI   TOTLAST,1      NOTE THAT A TOTAL WAS THE LAST ITEM\n         L     R8,PRNTTOT8    GET THE RETURN ADDRESS\n         BR    R8             THEN RETURN\n         EJECT\n*\n*        PRINT OUT THE FORMATTED DSCB\n*              FIRST FORMAT IT\n*\nPRINT    ST    R8,PRINTR8     SAVE REGISTER 8 FOR RETURNING\n         MVI   WORKLINE+4,C' ' BLANK OUT THE LINE\n         MVC   WORKLINE+5(250),WORKLINE+4 SO INDIVIUAL FIELDS DON'T\n         L     R2,VTPRNTLS   GET THE PRINT ITEM LIST\n         LA    R1,WORKLINE+4  POINT TO THE WORK  LINE\nPRTLOOP  SR    R6,R6          GET THE RESERVED WORD NUMBER\n         IC    R6,0(R2)       FROM THE TOP BYTE\n         MH    R6,H12         MULTIPLY BY 12 FOR THE TABLE ENTRIES\n         LA    R6,TABTITL(R6) THEN RELOCATE THE MESS\n         SR    R7,R7          CLEAR A REGISTER\n         IC    R7,0(R6)       GET THE EXECUTE LENGTH\n         LA    R5,1(R1)       SAVE A PLACE TO MOVE FIELD INTO\n         LA    R1,1(R1,R7)    MOVE THE POINTER OVER\n         LA    R0,WORKLINE+4  POINT TO THE BEGINNING AGAIN\n         SR    R1,R0          AND FIND THE CURRENT LENGTH\n         CH    R1,LINELEN     IS IT TOO LONG?\n         BNL   PRTEND         YES, WE'RE DONE\n         AR    R1,R0          NO, KEEP GOING\n*\n*        MOVE IN OR CONVERT THIS ITEM\n*\n         SR    R14,R14       CLEAR A REG FOR LENGTH OF RTN NO\n         IC    R14,1(R6)     GET THE LENGTH OR ROUTINE\n         N     R14,F127      CLEAR THE TOP BIT\n         SR    R15,R15       CLEAR A REG FOR VTFMT\n         IC    R15,2(R6)       DISPLACEMENT\n         AR    R15,R3        RELOCATE IT\n*\n*        DECIDE WHERE TO PUT IT\n*\n         TM    1(R6),X'80'   IS IT IN CHARS\n         BNO   PRTRTN        NO, USE THE SPECIAL ROUTINE\n         SR    R7,R14        GET THE DIFFERENCE IN LENGTHS\n         SRL   R7,1          GET HALF THE DIFFERENCE\n         AR    R5,R7         PUT THE DATA HERE\n         EX    R14,PRTMOVE   MOVE IN THE CHARACTERS\nPRTINC   LA    R2,1(R2)            GET THE NEXT CHAIN POINTER\n         CLI   0(R2),0       ARE WE DONE?\n         BNE   PRTLOOP        GO GET MORE ITEMS\nPRTEND   LA    R1,WORKLINE   POINT TO THIS LINE\n         BAL   R8,PRNTLINE   THEN GO PRINT IT\n         L     R8,PRINTR8     GET THE RETURN ADDRESS\n         BR    R8             RETURN\nPRTMOVE  MVC   0(0,R5),0(R15)  EXECUTED MOVE\n*\n*        VARIOUS ROUTINES TO FORMAT BEFORE MOVING IN THE DATA\n*\nPRTRTN   LTR   R14,R14       BE SURE THE OFFSET IS OK\n         BP    PRTRTN1        IT SEEMS ALL RIGHT\n         ABEND 701,DUMP       CRASH AND BURN\nPRTRTN1  B     *(R14)        GO DO YOUR THING\n         B     PRDATES        4  CDATE, EXPDT\n         B     PRLSTUS        8  LSTUS\n         B     PRALLOC       12  ALLOC, USED\n         B     PRUNUSED      16  ALLOC - USED\n         B     PRPCT         20  100 * USED / ALLOC\n         B     PREXT         24  EXT\n         B     PRBLREC       28  BLKSZ LRECL\n         B     PRDSN         32  DSNAME\n*\n*\n*        CDATE AND EXPDT\n*\nPRDATES  SR    R14,R14       CLEAR REG FOR YEAR\n         IC    R14,0(R15)    GET THE YEAR\n         USING DUMMD,R5      ALLOW CONV TO USE SYMBOL\n         CONV  DUMMA,(R14),2 CONVERT YEAR\n         ICM   R14,B'0011',1(R15)  GET THE DAY\n         CONV  DUMMA+2,(R14),3,EDMASK0,COMP0  CONVERT THE DAY\n         B     PRTINC        GO GET MORE PRINT ITEMS\n*\n*        LAST USE DATE\n*\nPRLSTUS  MVC   CHARS,EDMASK   SET UP THE EDIT MASK\n         ED    CHARS(6),0(R15)  CONVERT TO CHARACTERS\n         MVC   0(5,R5),CHARS+1  THEN MOVE THEM IN\n         B     PRTINC        GO GET MORE PRINT ITEMS\n*\n*        ALLOCATION AND USED\n*\nPRALLOC  ICM   R14,B'1111',0(R15)  GET THE AMOUNT\n         BM    PRUNKN6       IF NEGATIVE, IT'S NOT KNOWN\n         CONV  DUMMA,(R14),6 CONVERT THE NUMBER\n         B     PRTINC        GO GET MORE PRINT ITEMS\nPRUNKN6  MVC   0(6,R5),BLANKS  UNKNOWN AMOUNT, LEAVE IT BLANK\n         B     PRTINC        GO GET MORE PRINT ITEMS\n*\n*        UNUSED SPACE\n*\nPRUNUSED ICM   R14,B'1111',VTFUSED  GET THE   USED SPACE\n         BM    PRUNKN6       IF NOT KNOWN, SKIP ALONG\n         L     R14,VTFALLOC  GET THE ALLOCATED SPACE\n         S     R14,VTFUSED   MINUS THE USED SPACE GIVES UNUSED\n         BZ    PRTINC        IF NO UNUSED SPACE, LEAVE BLANK\n         CONV  DUMMA,(R14),6 CONVERT FOR PRINTING\n         B     PRTINC        GO GET MORE PRINT ITEMS\n*\n*        PCT - PERCENTAGE USED\n*\nPRPCT    SR    R6,R6         CLEAR THE TOP PART OF THE NUMBER\n         ICM   R7,B'1111',VTFUSED   GET THE AMOUNT OF USED SPACE\n         BM    PRUNKN3       IF NOT KNOWN, LEAVE BLANK\n         CLC   VTFALLOC,ZERO IS THE ALLOCATION ZERO?\n         BNE   PRPCTM        NO, DO THE STANDARD STUFF\n         CLC   VTFUSED,ZERO  IS THE USED SPACE ZERO?\n         BE    PRUNKN3       YES, JUST USE BLANKS\nPRPCTERR MVC   0(3,R5),=C'ERR'  NO, IT'S AN ERROR\n         B     PRTINC        THEN GO TRY FOR MORE\nPRPCTM   M     R6,F100       MULTIPLY BY 100 FOR PERCENT\n         D     R6,VTFALLOC   DIVIDE BY ALLOC TO GET THE PERCENT\n         LTR   R7,R7         IS IT LESS THAN ZERO?\n         BM    PRPCTERR      YES, FLAG THE ERROR\n         C     R7,F100       ALSO CHECK FOR OVER 100 PERCENT\n         BH    PRPCTERR      THAT'S ALSO AN ERROR\n         CONV  DUMMA,(R7),3  CONVERT FOR PRINTING\n         B     PRTINC        GO GET MORE PRINT ITEMS\nPRUNKN3  MVC   0(3,R5),BLANKS BLANK THE UNKNOWN\n         B     PRTINC        GO GET MORE PRINT ITEMS\n*\n*        EXTENTS\n*\nPREXT    SR    R14,R14       CLEAR REG FOR YEAR\n         IC    R14,0(R15)    GET THE YEAR\n         CONV  DUMMA,(R14),2 CONVERT THE EXTENTS\n         B     PRTINC        GO GET MORE PRINT ITEMS\n*\n*        LRECL AND BLKSZ\n*\nPRBLREC  LH    R14,0(R15)    GET THE DATA ( HALFWORD )\n         CONV  DUMMA,(R14),5  CONVERT THE DATA\n         B     PRTINC        GO GET MORE PRINT ITEMS\n*\n*        DATA SET NAME\n*\nPRDSN    LH    R14,VTFDSNL   GET THE DSNAME LENGTH\n         CH    R14,DSNLENGT  CHACK FOR MAX LENGTH\n         BL    PRDMOVE       THIS DSN IS SHORT ENOUGH\n         LH    R14,DSNLENGT  CUT IT DOWN\nPRDMOVE  BCTR  R14,0         COUNT DOWN ONE FOR THE EX\n         EX    R14,PRTMOVE   MOVE IN THE DSNAME\n         AH    R1,DSNLENOF   CORRECT THE LINE POINTER\n         B     PRTINC        GO GET MORE PRINT ITEMS\n         EJECT\n*\n*        OUTPUT THE FORMATTED DSCB AS IT IS\n*\nOUTPUT   CLEAR OUTWORK       CLEAR THE OUTPUT REC\n         LH    R2,VTFDSNL     GET THE LENGTH OF THE DSNAME\n         LA    R2,VTFMTL-1(R2)  GET THE FULL LENGTH MINUS ONE\n         EX    R2,OUTMOVE    MOVE IN THE ACTUAL RECORD\n         PUT   OUTDCB,OUTWORK    OUTPUT THE RECORD\n         BR    R8             RETURN\nOUTMOVE  MVC   OUTWORK(0),0(R3)  EXECUTED MOVE\n         EJECT\n*\n*        PDLNUM - CONVERT FROM CHARACTERS ( EBCDIC ) TO AN INTEGER\n*              BINARY FORM, PASSED BACK VIA REGISTER 15\n*              A PARSE PDE IS THE INPUT AS SHOWN IN THE SAMPLE BELOW\n*                       LA    R1,PDL     POINT TO THE PARSE DECRIPTION\n*                       BAL   R8,PDLNUM  GO CONVERT TO NUMERICS\n*              THE ROUTINE WILL TERMINATE IF IT FINDS NON-NUMERICS\n*                 ANY CHARACTERS OTHER THEN 0-9, +, -\n*              REGISTERS 1, 2, 5, 6, AND 7 ARE USED\n*\nPDLNUM   STM   R1,R8,PDLNSAVE SAVE THE REGISTERS\n         LH    R2,4(R1)       GET THE STRING ADDRESS\n         L     R1,0(R1)       GET THE STRING ADDRESS\n         MVI   PDLMINUS,0     CLEAR THE NEGATIVE NUMBER FLAG\n         SR    R5,R5          CLEAR THE CHARACTER COUNTER\n         SR    R15,R15        CLEAR THE ANSWER\nPDLLOOP  LA    R6,0(R5,R1)    POINT TO THIS DIGIT\n         LA    R5,1(R5)       GET TO THE NEXT DIGIT\n         CR    R5,R2          IS THIS THE END OF THE STRING?\n         BH    PDLFINI        YES, EXIT\n         SR    R7,R7          CLEAR A WORK REGISTER\n         IC    R7,0(R6)       GET THE CHARACTER\n         SH    R7,PDLH240     SUBTRACT THE CHARACTER C'0'\n         BM    PDLSP          IF NEGATIVE, CHECK SPECIAL CHARACTERS\n         MH    R15,PDLH10     IT'S A DIGIT, MULTIPLY PRIOR NUM BY TEN\n         AR    R15,R7         ADD ON THE NEW DIGIT\n         B     PDLLOOP        AND LOOP FOR MORE\n*\n*        CHECK FOR SPECIAL CHARACTERS\n*\nPDLSP    CLI   0(R6),C' '     IS IT A BLANK?\n         BE    PDLLOOP        THEN IT'S OK\n         CLI   0(R6),C'+'     IS IT A PLUS?\n         BE    PDLLOOP        THAT'S ALSO OK\n         CLI   0(R6),C'-'     IS IT A MINUS?\n         BNE   PDLFINI        NO, JUST QUIT\n         MVI   PDLMINUS,1     YES, NOTE IT\n         B     PDLLOOP        AND LOOK FOR MORE\n*\n*        QUIT, AFTER SETTING R15 TO NEGATIVE IF NEEDED\n*\nPDLFINI  CLI   PDLMINUS,1     WAS A MINUS SIGN FOUND?\n         BNE   PDLLEAVE       NO, EXIT\n         LNR   R15,R15        YES, MAKE IT NEGATIVE\nPDLLEAVE LM    R1,R8,PDLNSAVE RESTORE THE REGISTERS\n         BR    R8             RETURN\nPDLH10   DC    H'10'\nPDLH240  DC    H'240'\n         EJECT\n*\n*        PRNTLINE - GET EACH LINE FOR SYSOUT, THEN COUNT THE LINES\n*              OUTPUT HEADERS AND TITLE LINES AS NECESSARY\n*\nPRNTLINE STM   R1,R8,PRTLSAVE SAVE THE REGISTERS\n         TM    SYSOUT+48,X'10' IS SYSOUT OPEN FOR BUSINESS?\n         BNO   PRNTTERM       NO, IT'S NOT OPEN, USE VTOCMSG\n         CLI   HEADK+1,2     NOHEADING REQUEST?\n         BE    PRNTLIN       YES, JUST OUTPUT THE DATA LINE\n*\n*        DO THE LINE COUNTING\n*\n         LH    R2,LINECT      GET THE LINE COUNT\n         CLI   4(R1),C'1'     IS IT REQUESTING A NEW PAGE?\n         BE    PRNTPAGE       YES, DO IT\n         CLI   0(R1),C'-'     SKIP 3 LINES\n         BE    PRNTSKP3       YES, TRY IT\n         CLI   0(R1),C'0'     SKIP 2 LINES?\n         BE    PRNTSKP2       YES, DO IT\n         B     PRNTSKP1       JUST SKIP ONE\nPRNTSKP3 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT\nPRNTSKP2 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT\nPRNTSKP1 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT\n         STH   R2,LINECT      SAVE THE LINE COUNT\n         CH    R2,LINEMAX     DOES THIS OVERFLOW  HE PAGE?\n         BL    PRNTLIN        NO, JUST PUT OUT THIS LINE\n*\n*        PRINT OUT THE PAGE HEADER AND ITEM TITLES\n*\nPRNTPAGE LH    R6,PAGECT      GET THE PAGE COUNT\n         LA    R6,1(R6)       ADD ONE TO IT\n         STH   R6,PAGECT      THEN STORE IT BACK\n         L     R7,PAGEADDR    GET THE PLACE TO PUT THE PAGE\n         USING DUMMD,R7       DUMMY DSECT\n         CONV  DUMMA,(R6),5   GET THE CHARACTERS\n         DROP  R7\n         ST    R1,PRNTLSAV    SAVE THE INPUT REG1\n         PUT   SYSOUT,PRNTHEAD  OUTPUT THE HEADER\n         PUT   SYSOUT,PRNTTITL  OUTPUT THE ITEM TITLES\n         L     R1,PRNTLSAV    GET THE ORIGINAL LINE\n         MVI   4(R1),C'0'     ALWAYS SKIP THE FIRST LINE AFTER NEW PAGE\n         LA    R7,5           SET THE LINE COUNT\n         STH   R7,LINECT      SAVE IT FOR LATER\nPRNTLIN  CLEAR OUTWORK       CLEAR A PRINT RECORD\n         LH    R6,0(R1)      GET THE RECORD LENGTH\n         SH    R6,H5         MINUS 4 FOR PREFIX, 1 FOR EX\n         LA    R3,4(R1)      POINT TO THE TEXT\n         EX    R6,OUTMOVE    THEN MOVE IN THE LINE\n         PUT   SYSOUT,OUTWORK      AND FINALLY PRINT IT\n         B     PRNTLRET       THEN RETURN\n*\n*        SIMPLER CHECKING FOR VTOCMSG OUTPUT\n*\nPRNTTERM LH    R2,LINECT      GET THE LINE COUNT\n         LA    R2,1(R2)       IGNORE CARRIAGE CONTROL\n         STH   R2,LINECT      SAVE IT BACK\n         LR    R6,R1          SAVE THE ORIGINAL REG 1\n         MVI   4(R1),C' '    BLANK THE CARRIAGE CONTROL\n         CLI   HEADK+1,2     NOHEADING REQUEST?\n         BE    PRNTTLIN       YES, JUST OUTPUT THE DATA LINE\n         CH    R2,LINEMAX     NEED A NEW TITLE?\n         BL    PRNTTLIN       NO, KEEP GOING\n         VTOCMSG PRNTTITH     YES, PUT IT OUT\n         MVC   LINECT,H2      RESET THE LINE COUNT\nPRNTTLIN VTOCMSG 0(R6)        OUTPUT THE PASSED LINE\nPRNTLRET LM    R1,R8,PRTLSAVE RESTORE THE REGISTERS\n         BR    R8             THEN RETURN\n         EJECT\nPRTINIT  MVI   FIRSTIM,10    FLAG THE INITIALIZATION AS DONE\n         LA    R1,TABTITL    POINT TO THE BUG TABLE\n         ST    R1,ATABTITL   LET CHECK KNOW WHERE IT IS\n*\n*        SET UP THE CHARACTERS FOR TYPE OF SPACE ALLOC.\n*\n         LH    R2,SPACEK      GET THE SPACE TYPE KEYWORD\n         SLA   R2,3           MULTIPLY BY 8\n         LA    R2,TABSPACE(R2)  RELOCATE IT\n         MVC   SPACTYPE,0(R2) SAVE THE CHARACTERS\n         CLI   PRINTK+1,2     IS THIS NOPRINT?\n         BE    NOOPEN         YES, SKIP THE OPEN\n         MVC   SYSOUT(SYSOUTL),SYSOUTC  INITIALIZE THE DCB\n         MVI   OPENLIST,X'80' TERMINATE THE LIST\n         LA    R1,JFCB       POINT TO THE JFCB\n         ST    R1,DCBEXIT    AND PUT THE ADDR IN THE DCB EXIT\n         MVI   DCBEXIT,X'87' NOTE IT AS A JFCB EXIT\n         LA    R1,DCBEXIT    POINT TO THE EXIT LIST\n         LA    R2,SYSOUT     AND TO THE DCB FOR ADDRESSABILITY\n         USING IHADCB,R2     TELL THE ASSEMBLER ABOUT IT\n         STCM  R1,B'0111',DCBEXLSA  STUFF IT INTO THE DCB\n         TM    CHARSPL+6,X'80'  CHARS PER LINE ENTERED?\n         BZ    RDJFCB        NO, CONTINUE ALONG\n         LA    R1,CHARSPL    YES, POINT TO THE PDL\n         BAL   R8,PDLNUM     CONVERT TO A NUMBER\n         STH   R15,DCBLRECL  SAVE THE NEW LRECL\n         STH   R15,LINELEN   ALSO THE LINE LENGTH\n         TM    BLKSZSET+6,X'80'  BLOCKSIZE ENTERED?\n         BZ    BLKEQREC      NO, BLOCKSIZE EQUALS LRECL\n         LA    R1,BLKSZSET      POINT TO THE PDL\n         BAL   R8,PDLNUM     GET THE NUMBER\nBLKEQREC STH   R15,DCBPRECL  STUFF IT AWAY\n         DROP  R2            FINISHED WITH THE DCB\nRDJFCB   RDJFCB ((R2)),MF=(E,OPENLIST)  SEE IF IT'S THERE\n         LTR   R15,R15       WAS IT THERE?\n         BNZ   NOOPEN        NO, SKIP ALONG\n         OPEN  ((R2),OUTPUT),MF=(E,OPENLIST)  OPEN THE PRINT DCB\n*\n*        INITIALIZE PRINT VARIABLES\n*\n*        SET LINES/PAGE AND LINESIZE\n*\nNOOPEN   MVC   LINEMAX,DEFLMAX  SET THE DEFAULT NUMBER OF LINES/PAGE\n         TM    LINESPP+6,X'80'     LINES PER PAGE ENTERED?\n         BZ    DEFLINPP     NO, SKIP ON\n         LA    R1,LINESPP    YES, POINT TO THE PDL\n         BAL   R8,PDLNUM     CONVERT TO A NUMBER\n         STH   R15,LINEMAX   AND SAVE IT\nDEFLINPP MVC   LINECT,LINEMAX SET UP TO PAGE ON THE FIRST WRITE\n         TM    CHARSPL+6,X'80'     CHARS PER LINE ENTERED?\n         BO    LENSET        YES, USE IT\n         MVC   LINELEN,DEFLEN SET UP A DEFAULT LENGTH\n         TM    SYSOUT+48,X'10' DO WE USE SYSOUT?\n         BO    LENSET         YES, USE WHAT WE'VE GOT\n*        GET THE TERMINAL LINE SIZE TO SEE IF IT MAKES SENSE\n         GTSIZE\n         LTR   R1,R1          SEE IF IT'S GOOD\n         BZ    LENSET         NO, JUST A ZERO, KEEP THE DEFAULTS\n         BCTR  R1,0           CUT IT DOWN ONE TO AVOID A MESS\n         STH   R1,LINELEN     SAVE THIS LENGTH\n         LTR   R0,R0          FOR DISPLAYS, IT'S SCREEN SIZE\n         BZ    LENSET         KEEP WHAT WE'VE GOT\n         TM    LINESPP+6,X'80'  WAS LINES PER PAGE ENTERED?\n         BO    LENSET           YES, DON'T OVERRIDE IT\n         STH   R0,LINEMAX     AND SAVE THE NEW PAGE LOCATION\nLENSET   DS    0H\n*\n*        SET UP THE PAGE COUNTER\n*\nPAGEAD   LH    R1,LINELEN     GET THE LENGTH OF THE LINE\n         SH    R1,H10         MINUS TEN CHARACTERS\n         LA    R1,PRNTHEAD(R1) THEN RELOCATE IT\n         CLEAR PRNTHEAD       CLEAR THE LINE FIRST\n         MVC   0(4,R1),CPAGE  MOVE IN THE CHARACTERS PAGE\n         LA    R1,5(R1)       MOVE OVER 5 MORE\n         ST    R1,PAGEADDR    THIS IS THE PLACE\n*\n*        BUILD THE PRINT HEADER LINE\n*\n         TM    HEADING+6,X'80' IS A USER HEADING PRESENT\n         BO    USERHEAD       YES, USE IT\n         MVC   PRNTHEAD(L'DEFHEAD),DEFHEAD  NO, GET A DEFAULT\n*\n*        ADD THE COMMAND BUFFER TO THE HEADING\n*\n         LH    R1,LINELEN    GET THE LINE LENGTHE\n         SH    R1,H32        MINUS SPACES FOR PAGE, START OF HDR\n         BNP   OUTOPEN       IF IT'S SHORT, SKIP ON\n         L     R14,ADDRCBUF  POINT TO THE COMMAND BUFFER\n         CH    R1,0(R14)     COMPARE LENGTHS\n         BL    CBUFBIG       THE COMMAND BUFFER TOO BIG\n         LH    R1,0(R14)     GET THE COMMAND BUFFER SIZE\nCBUFBIG  SH    R1,H5         MINUS 1 FOR EX, 4 FOR CBUF PREFIX\n         EX    R1,MOVEHED    MOVE THE CBUF TO THE DEFAULT HEADER\n         B     OUTOPEN        GO SET UP THE PAGE COUNTER\nUSERHEAD LH    R1,HEADING+4   GET THE LENGTH\n         BCTR  R1,0           MINUS ONE FOR THE EX\n         L     R2,HEADING     POINT TO THE USER HEAD\n         EX    R1,MOVEHEAD    THEN MOVE IT IN\nOUTOPEN  DS    0H\n*\n*        SET UP THE WORK LINE\n*\n         LH    R1,LINELEN    GET THE LINE LENGTH\n         LA    R1,4(R1)      ADD FOUR FOR THE PREFIX\n         STH   R1,WORKLINE   OUTPUT TEXT\n         STH   R1,PRNTTITH    ITEM TITLES\n*        GET THE PRINT SPECIFICATION\n*\n         LA    R1,DEFPRNT\n         ST    R1,VTPRNTLS   SAVE THE PRINT ITEM LIST ADDRESS\n         TM    SUBPRTKY+6,X'80'  WERE ANY ITEMS SET UP\n         BE    PRTITSET      NO, THE DEFAULT LIST IS OK\n*\n*        GET THE ADD, REPLACE, DELETE, AND NEW ITEMS\n*        AND BUILD THE NEW LIST\n*\n*        FIRST CONVERT THE ENTERED TEXT INTO NUMERIC KEYS\n*\n         LA    R4,SUBPRTIT   POINT TO THE ITEMS\n         LA    R5,VTPRNTEN   POINT TO THE OUTPUT KEYS\n         LA    R0,VTPRNTEX   POINT TO THE END OF THE LIST\nENTKEY   BAL   R8,GETKEY     GET A KEY\n         STC   R15,0(R5)     SAVE IT\n         LA    R5,1(R5)      GET TO THE NEXT ONE\n         CR    R0,R5         CHECK FOR THE END\n         BNH   ENTKEND       IF THAT'S ALL\n         ICM   R4,7,9(R4)    GET THE CHAIN POINTER\n         BNZ   ENTKEY        AND KEEP GOING IF THERE'S MORE\nENTKEND  DS    0H            THE KEYS ARE ENTERED INTO THE LIST\n*\n*        MERGE THE ENTERED ITEMS AND THE DEFAULT LIST INTO A NEW LIST\n*\n         LA    R6,VTPRNTL    POINT TO THE NEW LIST\n         ST    R6,VTPRNTLS   SAVE IT'S ADDRESS\n         LA    R4,VTPRNTEN   POINT TO THE ENTERED ITEMS\n         LA    R2,DEFPRNT    POINT TO THE DEFAULT LIST\n         LR    R3,R2         POINT TO THE BEGINNING - NO DEFAULT IF NEW\n         L     R1,SUBPRTKY   POINT TO THE KEYWORD\n         CLI   0(R1),C'N'    IS THIS A NEW LIST?\n         BE    PRTINEW       YES, SKIP PAST DEFAULT COPY\n         LA    R3,DEFPRNTE   POINT TO THE END OF THE DEFAULT LIST\n*\n*        ADD, REPLACE, DELETE - COPY THE DEFAULT LIST\n*\nPRTICOPY CR    R2,R3         IS THIS THE END OF THE DEFAULT LIST?\n         BNL   PRTITSET      YES, END OF PROCESSING FOR PRINT ITEMS\n*\n*        CHECK FOR ENTERED ITEMS THAT ARE ALSO\n*              IN THE DEFAULT LIST.\n*\nPRTICDLP CLC   0(1,R2),0(R4) IS THIS THE SAME ITEM\n         BE    PRTIFND       YES, SEE WHAT TO DO\n         LA    R4,1(R4)      NO, GET TO THE NEXT ITEM\n         CLI   0(R4),0       WAS THIS THE LAST ENTERED ITEM?\n         BNE   PRTICDLP      NO, KEEP LOOKING\n         LA    R4,VTPRNTEN   POINT BACK TO THE TOP OF THE LIST\n*\n*        ADD THIS ITEM TO THE NEW LIST\n*\nPRTICSKP MVC   0(1,R6),0(R2) MOVE IN THE NEW KEY\n         LA    R6,1(R6)      POINT PAST IT\nPRTICDEL LA    R2,1(R2)      GO DOWN THE DEFAULT LIST\n         B     PRTICOPY      THEN KEEP ON CHECKING\n*\n*        AN ITEM WAS ENTERED AND WAS IN THE DEFAULT LIST\n*        FOR DELETE, JUST DELETE ITEMS\n*        FOR ADD AND REPLACE, DELETE ALL BUT THE FIRST ITEM\n*              TO AVOID DUPLICATES\n*              IF IT IS THE FIRST ITEM, INSERT THE ENTERED LIST\n*\nPRTIFND  LA    R0,VTPRNTEN   POINT TO THE FIRST ITEM\n         CR    R0,R4         COMPARE WITH THE ITEM FOUND\n         BH    PRTICDEL      NOT THE FIRST ITEM, DELETE IT\n         CLI   0(R1),C'D'    IS THIS DELETE TIME?\n         BE    PRTICDEL      THEN JUST DELETE IT\n         CLI   0(R1),C'R'    IS THIS A REPLACE?\n         BE    PRTIREPA      YES, IGNORE THIS DEFAULT ITEM\n*\n*        ADD THE DEFAULT ITEM FIRST\n*\nPRTIASKP MVC   0(1,R6),0(R2) MOVE IN THE NEW KEY\n         LA    R6,1(R6)      POINT PAST IT\n*\n*        MOVE THE ITEMS IN FROM THE ADD OR REPLACE LIST\n*\nPRTIREPA LA    R2,1(R2)      GET PAST THE DEFAULT LIST ITEM\nPRTIREP  LA    R4,1(R4)      GET PAST THE FIRST ENTRY\nPRTINEXT CLI   0(R4),0       IS THIS THE LAST ITEM?\n         BE    PRTICOPY      YES, SEE ABOUT MORE DEFAULTS\n*\n*        ADD AN ENTERED ITEM TO THE LIST\n*\nPRTINSKP MVC   0(1,R6),0(R4) MOVE IN THE NEW KEY\n         LA    R6,1(R6)      POINT PAST IT\n         B     PRTIREP       GO GET MORE ENTERED ITEMS\n*\n*        NEW LIST, JUST USE IT AS ENTERED\n*\nPRTINEW  LA    R1,VTPRNTEN   POINT TO THE ENTERED LIST\n         ST    R1,VTPRNTLS   THEN SAVE ITS ADDRESS FOR LATER\nPRTITSET DS    0H\n*\n*        BUILD THE TITLE LINE FOR THE DSNAME FIELDS\n*\n         CLEAR PRNTTITL        BLANK OUT THE TITLE LINE\n         MVC   PRNTTITL+1(139),PRNTTITL  SO THE WHOLE THING IS GOOD\n         L     R2,VTPRNTLS   GET THE PRINT ITEM LIST\n         LA    R1,PRNTTITL    POINT TO THE TITLE LINE\nTITLOOP  SR    R6,R6          GET THE RESERVED WORD NUMBER\n         IC    R6,0(R2)       FROM THE TOP BYTE\n         MH    R6,H12         MULTIPLY BY 12 FOR THE TABLE ENTRIES\n         LA    R6,TABTITL(R6) THEN RELOCATE THE MESS\n         SR    R7,R7          CLEAR A REGISTER\n         IC    R7,0(R6)       GET THE EXECUTE LENGTH\n         EX    R7,MOVETIT     MOVE IN THE TITLE\n         LA    R1,1(R1,R7)    MOVE THE POINTER OVER\n         CLI   0(R2),DSNAME  IS THIS THE DSNAME KEY\n         BE    TITDSN        YES, SPECIAL PROCESSING\n         LA    R0,PRNTTITL    POINT TO THE BEGINNING AGAIN\n         SR    R1,R0          AND FIND THE CURRENT LENGTH\n         CH    R1,LINELEN     IS IT TOO LONG?\n         BNL   TITOVER        YES, PULL BACK\n         AR    R1,R0          NO, KEEP GOING\nTITINC   LA    R2,1(R2)            GET THE NEXT CHAIN POINTER\n         CLI   0(R2),0       ARE WE DONE?\n         BNE   TITLOOP        GO GET MORE TITLES\n         B     TITEND         ALL DONE\nTITDSN   LR    R6,R1         SAVE THE ADDRESS POINTER\n         LA    R1,DSNPLN     POINT TO THE PDL FOR DSN LENGTH\n         BAL   R8,PDLNUM     GO TRANSLATE IT\n         LTR   R15,R15       WAS IT THERE?\n         BP    TITDSN2       YES, USE IT\n         LA    R15,44        NO, SET THE DEFAULT\nTITDSN2  STH   R15,DSNLENGT  SAVE THE LENGTH\n         SH    R15,H9        SUBTRACT THE 9 CHARS MOVED ALREADY\n*              MINUS ONE FOR EX, PLUS ONE FOR SPACE\n         MVI   0(R6),C' '    GET AN INITIAL BLANK\n         EX    R15,DSNBLMOV  MOVE IN THE BLANKS\n         LA    R1,1(R15,R6)  RESET THE POINTER ( INCLUDE A SPACE )\n         LA    R15,1(R15)    ADD ON THE SPACE CHARACTER\n         STH   R15,DSNLENOF  SAVE THE OFFSET\n         B     TITINC        ALLOW DSNAME TO OVERFLOW THE LINE\n*\n*        TITLE RAN OFF THE END, CUT IT OFF\n*\nTITOVER  SR    R1,R7          SUBTRACT PAST THIS FIELD\n         AR    R1,R0          RELOCATE IT\n         BCTR  R1,0           THEN GET THE LAST CHARACTER\n         MVC   0(9,R1),BLANKS THEN BLANK IT OUT\nTITEND   TM    SYSOUT+48,X'10' IS THE DCB OPEN\n         BNO   CKOUTPT       NO, TERMINAL OUTPUT, NO CC\n         MVI   PRNTTITL,C'0'  ALWAYS SKIP A LINE FOR IT\nCKOUTPT  CLI   OUTPUTK+1,1    OUTPUT THIS RUN?\n         BNE   VTRET          YES, SKIP THE OPEN, JUST RETURN\n         MVC   OUTDCB(OUTDCBL),OUTDCBC  INITIALIZE THE DCB\n         MVI   OPENLIST,X'80' TERMINATE THE LIST\n         OPEN  (OUTDCB,OUTPUT),MF=(E,OPENLIST)  OPEN THE DATA SET DCB\n         B     VTRET          RETURN, INITIALIZATION IS DONE\n         EJECT\n*\n*        ROUTINE TO CONVERT A TEXT DSCB ITEM\n*        INTO ITS KEY NUMBER\n*        INPUT IS REG 4 - IKJIDENT PTR\n*        OUTPUT IS REG 15 - KEY NUMBER\n*        ENTRY VIA BAL   R8,GETKEY\n*\nGETKEY   L     R1,ATABTITL     POINT TO THE TABLE\n         LA    R1,12(R1)     POINT TO THE FIRST ENTRY\n         LA    R15,1           SET UP THE KEY NUMBER COUNTER\n         L     R6,0(R4)      POINT TO THE ENTERED TEXT\n         ICM   R3,3,4(R4)    GET THE LENGTH OF THE ENTERED TEXT\n         BNP   GETKNOTF      NOT FOUND IF ZERO\n         BCTR  R3,0          MINUS ONE FOR THE EX\nGETKLOOP LA    R2,4(R1)      POINT TO THE COMPARISON TEXT\n         CLI   0(R2),C' '    IS IT HERE?\n         BNE   GETKSTD       YES, THIS IS IT\n         LA    R2,1(R2)      NO, MOVE OVER ONE MORE\n         CLI   0(R2),C' '    IS IT HERE?\n         BNE   GETKSTD       YES, THIS IS IT\n         LA    R2,1(R2)      NO, MOVE OVER ONE MORE\nGETKSTD  EX    R3,GETKCOMP   COMPARE THE KEY TEXT\n         BE    GETKFND       I FOUND IT\n         LA    R1,12(R1)     GET TO THE NEXT KEY\n         LA    R15,1(R15)    INCREMENT THE KEY COUNTER\n         CH    R15,H26       CHECK FOR THE END OF THE TABLE\n         BNH   GETKLOOP      NOT YET, KEEP LOOKING\n*\n*        KEY WAS NOT FOUND, SEND BACK A ZERO\n*\nGETKNOTF SR    R15,R15       SET UP THE ZERO AND RETURN\nGETKFND  BR    R8            JUST RETURN\nGETKCOMP CLC   0(0,R6),0(R2) EXECUTED TEXT COMPARE\nH26      DC    H'26'\n         EJECT\n*\n*        PROGRAM CONSTANTS\n*\nZERO     DC    F'0'\nF100     DC    F'100'\nF127     DC    F'127'\nDEFLMAX  DC    H'60'          DEFAULT LINES PER PAGE\nDEFLEN   DC    H'132'         DEFAULT CHARS PER LINE\nH2       DC    H'2'\nH5       DC    H'5'\nH9       DC    H'9'\nH10      DC    H'10'\nH12      DC    H'12'\nH18      DC    H'18'\nH32      DC    H'32'\nMOVETIT  MVC   0(0,R1),3(R6)  MOVE IN THE TITLE\nCOMPKEY  CLC   0(0,R1),VTFDSN  EXECUTED COMPARE\nMOVEHEAD MVC   PRNTHEAD(0),0(R2)\nMOVEHED  MVC   PRNTHEAD+21(0),4(R14)  MOVE CMD BUF TO DEFAULT HEADER\nDSNBLMOV MVC   1(0,R6),0(R6)  BLANK OUT THE DSN SPACE IN THE TITLE\nCPAGE    DC    C'PAGE'\nEDMASK   DC    XL16'40202020202020202020202020202120'\nEDMASK0  DC    XL16'F0202020202020202020202020202120'\nSKIP     DC    C'0'\nCOMP0    DC    CL16'0000000000000000'\nBLANKS   DC    CL16'                '\nSTARS    DC    CL16'****************'\nTABSPACE DC    CL8'TRKS'\n         DC    CL8'TRKS'\n         DC    CL8'TRKS'\n         DC    CL8'TRKS'\n         DC    CL8'TRKS'\n*\n         PRINT NOGEN\nSYSOUTC  DCB   DSORG=PS,DDNAME=VTOCOUT,MACRF=PM,                       X\n               RECFM=FBA,LRECL=150,BLKSIZE=1500\nOUTDCBC  DCB   DSORG=PS,DDNAME=OUTPUT,MACRF=PM,                        X\n               RECFM=FB,LRECL=100,BLKSIZE=6000\n*\n*        PROGRAM MESSAGES\n*\n         SPACE 2\n         SPACE\nMSGTOTC  MSG   '  TOTALS -  NNNN DATA SETS, MMMMMMMM UUUUUU ALLOC, LLLLX\n               LLLL UUUUUU USED '\nMSGTLEN  EQU   *-MSGTOTC\nMSGBLC   MSG   '                '\n*\nDEFHEAD  DC    CL20'1 VTOC COMMAND  V-84'\n*\n*        DEFAULT PRINT LIST\n*\nDEFPRNT  DC    AL1(ALLOC)\n         DC    AL1(UNUSED)\n         DC    AL1(PCT)\n         DC    AL1(EXT)\n         DC    AL1(DSORG)\n         DC    AL1(RECFM)\n         DC    AL1(LRECL)\n         DC    AL1(BLKSZ)\n         DC    AL1(CDATE)\n         DC    AL1(LSTUS)\n         DC    AL1(VOLUME)\n         DC    AL1(DSNAME)\n         DC    AL1(EXPDT)\n         DC    AL1(SECQ)\n         DC    AL1(SECT)\n         DC    AL1(ROUND)\n         DC    AL1(PASS)\n         DC    AL1(ACTION)\n         DC    AL1(TYPE)\n         DC    AL1(0)        END OF THE LIST\nDEFPRNTE EQU   *\nDEFPRNTL EQU   *-DEFPRNT\n*\n*        TABLE OF PRINT ITEM LENGTHS AND TITLES\n*\n*        ENTRIES IN THE TABLE FOR EACH FORMATTED ITEM -\n*        FIRST BYTE IS FIELD LENGTH FOR OUTPUT ( MINUS ONE FOR EX )\n*        SECOND BYTE - X'80' BIT INDICATES A CHARACTER FIELD\n*                            THEN BITS 0-7 GIVE VTFMT LENGTH\n*                      OTHERWISE IT'S A KEY TO WHICH ROUTINE TO USE\n*        THIRD BYTE - OFFSET IN FORMATTED DSCB, VTFMT\n*        4-12 TH BYTES, THE TITLE FOR THE FIELD\n*\n*\nTABTITL  DC    XL12'00'  DUMMY ENTRY FOR 0 ADDRESSING\n         DC    AL1(8),AL1(128+7),AL1(VTFACTON-VTFMT),CL9' ACTION  '  1\n         DC    AL1(6),AL1(128+5),AL1(VTFVOLUM-VTFMT),CL9' VOLUME  '  2\n         DC    AL1(5),AL1(000+4),AL1(VTFCREDT-VTFMT),CL9' CDATE   '  3\n         DC    AL1(5),AL1(000+4),AL1(VTFLSTAC-VTFMT),CL9' REFDT   '  4\n         DC    AL1(5),AL1(000+4),AL1(VTFEXPDT-VTFMT),CL9' EXPDT   '  5\n         DC    AL1(6),AL1(00+12),AL1(VTFALLOC-VTFMT),CL9'  ALLOC  '  6\n         DC    AL1(6),AL1(00+16),AL1(VTFALLOC-VTFMT),CL9' UNUSED  '  7\n         DC    AL1(3),AL1(00+20),AL1(VTFALLOC-VTFMT),CL9' PCT     '  8\n         DC    AL1(2),AL1(00+24),AL1(VTFNOEPV-VTFMT),CL9' EXT     '  9\n         DC    AL1(3),AL1(128+2),AL1(VTFDSORG-VTFMT),CL9' DSO     ' 10\n         DC    AL1(3),AL1(128+3),AL1(VTFRECFM-VTFMT),CL9' RFM     ' 11\n         DC    AL1(5),AL1(00+28),AL1(VTFBLKSZ-VTFMT),CL9' BLKSZ   ' 12\n         DC    AL1(5),AL1(00+28),AL1(VTFLRECL-VTFMT),CL9' LRECL   ' 13\n         DC    AL1(4),AL1(128+0),AL01(VTFPROT-VTFMT),CL9' PASS    ' 14\n         DC    AL1(3),AL1(128+0),AL1(VTFCATLG-VTFMT),CL9' CAT     ' 15\n         DC    AL1(4),AL1(128+0),AL1(VTFSECAL-VTFMT),CL9' SECT    ' 16\n         DC    AL1(5),AL1(00+28),AL1(VTFSECAM-VTFMT),CL9'  SECQ   ' 17\n         DC    AL1(4),AL1(00+36),AL1(VTFVOLUM-VTFMT),CL9' UNIT    ' 18\n         DC    AL1(5),AL1(128+0),AL1(VTFROUND-VTFMT),CL9' ROUND   ' 19\n         DC    AL1(4),AL1(128+0),AL1(VTFDSTYP-VTFMT),CL9' TYPE    ' 20\n         DC    AL1(6),AL1(00+12),AL01(VTFUSED-VTFMT),CL9'   USED  ' 21\n         DC    AL1(8),AL1(00+32),AL1(VTFVOLUM-VTFMT),CL9'   CCHH  ' 22\n         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY3  ' 23\n         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY4  ' 24\n         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY5  ' 25\n         DC    AL1(8),AL1(00+32),AL001(VTFDSN-VTFMT),CL9' DSNAME  ' 26\n         EJECT\n*\n*\n*        P A R S E   C O N T R O L   L I S T\n*\n*\n         PRINT OFF\n         COPY  VTOCPARS\n         PRINT ON\n*\n*        DYNAMIC WORK AREA\n*\n         SPACE 3\nPRNTWORK DSECT\n         DS    18A            PRINT ROUTINE SAVE AREA\nTOTDS    DS    F              TOTAL COUNTER\nTOTALLOC DS    F              TOTAL ALLOCATION\nTOTUSED  DS    F              TOTAL USED\nFTOTDS   DS    F              FINAL TOTAL DATA SETS\nFTOTALLC DS    F              FINAL TOTAL ALLOC\nFTOTUSED DS    F              FINAL TOTAL USED\nPRNTLSAV DS    A\nPRINTR8  DS    A\nPRNTTOT8 DS    A\nADDREND  DS    A\nPAGEADDR DS    A\nOPENLIST DS    2A             PARM LIST FOR OPEN\nPDLNSAVE DS    8A             REGISTER SAVE AREA FOR PDLNUM RTN\nPRTLSAVE DS    8A             REGISTER SAVE AREA FOR PRNTLINE RTN\nLASTKEY  DS    A              ADDRESS OF LAST KEY FOR SUBTOTALS, BREAKS\nNUMBREAK DS    H              CHARACTERS TO COMPARE FOR BREAK\nNUMTOTAL DS    H              CHARACTERS TO COMPARE FOR SUBTOTALS\n         PRINT NOGEN\nSYSOUT   DCB   DSORG=PS,DDNAME=VTOCOUT,MACRF=PM,                       X\n               RECFM=FBA,LRECL=150,BLKSIZE=1500\nSYSOUTL  EQU   *-SYSOUT\nOUTDCB   DCB   DSORG=PS,DDNAME=OUTPUT,MACRF=PM,                        X\n               RECFM=FB,LRECL=100,BLKSIZE=6000\nOUTDCBL  EQU   *-OUTDCB\nENDTOTAL DS    X              PROGRAM SWITCHES\nENTOTOUT EQU   X'80'          THE FINAL TOTALS HAVE BEEN OUTPUT\nENDTONLY EQU   X'10'          NO SUBTOTALS, END TOTALS ONLY\nNOBREAK  EQU   X'08'          NO BREAKS\nFIRSTIM  DS    X              INITIALIZATION FOR THIS ROUTINE\nPDLMINUS DC    X'00'\nTOTLAST  DS    X\nSPACTYPE DS    CL6          CHARACTERS FOR SPACE UNITS\nDSNLENGT DS    H\nDSNLENOF DS    H\nCHARS    DS    CL16           CONVERSION TO CHARACTERS\nMSGWORK  DS    CL256          AREA FOR BUILDING MESSAGES\nWORKLINE DS    CL256          AREA FOR DATA SET\nPRNTHDRH DS    F\nPRNTHEAD DS    CL256          AREA FOR HEADER\nPRNTTITH DS    F\nPRNTTITL DS    CL256          AREA FOR ITEM TITLES\nMSGBL    DS    CL20           AREA FOR BLANK LINE\nOUTWORK  DS    CL256          WORKING AREA FOR OUTPUT\nDCBEXIT  DS    F\nJFCB     DS    XL176\n         SPACE\nVTPRNTLS DS    A             PRINT ITEM LIST ADDRESS\nVTPRNTL  DS    40C           PRINT ITEM LIST ( IF MODIFIED )\nVTPRNTEN DS    40C\nVTPRNTEX DS    C\n         SPACE\n         DS    0D\nLENWORK  EQU   *-PRNTWORK\n*\n*        VTOC COMMAND COMMON AREA\n*\n         PRINT NOGEN\n         VTOCOM\n         SPACE 3\n*\n*        FORMATTED DSCB\n*\n         VTFMT\n         SPACE 3\n         PDEDSNAM\n         SPACE 3\nDUMMD    DSECT\nDUMMA    DS    C              DUMMY ENTRY TO USE FOR CONV\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         END\nVTOCSORT TITLE 'VTOC COMMAND - SORT  ROUTINE'\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* FUNCTION -   PUT THIS FORMATTED DSCB INTO THE SORTED LIST.          *\n*                                                                     *\n* OPERATION -  IF THIS IS A NOSORT RUN, JUST CALL THE PRINT ROUTINE.  *\n*              TO BUILD THE SORTED LIST, FIRST DO A SIMPLE HASH       *\n*              ON THE FIRST CHARACTER.  BUILD UP TO 256 SEPARATE      *\n*              LISTS TO SAVE SORT TIME.  THEN SEARCH THROUGH THESE    *\n*              LISTS SEQUENTIALLY.                                    *\n*                                                                     *\n* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *\n*              POINTED TO BY REGISTER 1                               *\n*              USE PARSE DATA, CURRENT FORMATTED DSCB, SORTED LIST    *\n*                                                                     *\n* OUTPUT -     THE FORMATTED DSCB IS PLACED INTO THE SORTED LIST.     *\n*                                                                     *\n* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *\n*                                                                     *\n*                                                                     *\n*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\nVTOCSORT ENTER 12,24          DO THE HOUSEKEEPING\n         LR    R11,R1         SAVE ADDR OF VTOCOM\n         USING VTOCOM,R11     SET ITS ADDRESSABILITY\n         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER\n         USING PDL,R9         SET ITS ADDRESSABILITY\n         USING SORTWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA\n         SPACE 3\n*\n*        IS THIS A NOSORT RUN ?\n*        IF SO, JUST CALL PRINT\n*\n         CLI   SORTK+1,2      IS THIS NOSORT?\n         BNE   GOSORT         NO, KEEP ON TRUCKIN'\n         VTCALL PRNT          YES, CALL PRINT AND GET OUT\n         B     SORTRET        GET OUT OF HERE\n*\n*        PUT THIS ENTRY WHERE IT BELONGS\n*\nGOSORT   L     R3,FORMATAD    POINT TO THE FORMATTED DSCB\n         USING VTFMT,R3       SET ADDRESSABILITY\n         LA    R6,SORTTAB     POINT TO THE SORT FIELDS TABLE\n         SR    R4,R4\n         IC    R4,1(0,R6)     LOAD HIGH KEY OFFSET\n         LA    R4,VTFMT(R4)   POINT TO HIGH KEY\n         LA    R2,VTCSORTH-12 SORT HEADER AREA\nGOSORT1  LA    R2,12(0,R2)    NEXT ENTRY\n         LH    R5,4(0,R2)     LOAD COMAPRE LENGTH\n         CLI   0(R6),C'D'     DESCENDING SORT\n         BE    GOSORT3        YES\n         B     GOSORT4        NO\nGOSORT2  ICM   R5,B'1111',0(R2) GET THE HEAD OF THE LIST\n         BNZ   NOTFIRST       IF NON-ZERO, SEARCH THE LIST\n*\n*        FIRST ENTRY ON THE LIST, IT'S EASY\n*\n         ST    R3,0(R2)       START UP THE LIST\n         B     SORTRET        THEN RETURN\nGOSORT3  EX    R5,GOSORTCL    COMPARE TO GET CORRECT LIST\n         BL    GOSORT1\n         B     GOSORT2\nGOSORT4  EX    R5,GOSORTCL    COMPARE TO GET CORRECT LIST\n         BH    GOSORT1\n         B     GOSORT2\n*\n*        FIND A SLOT FOR THIS ENTRY\n*              FIRST GET THE SHORTER DSN LENGTH\n*\nNOTFIRST SR    R1,R1\n         IC    R1,1(0,R6)     OFFSET OF SORT FIELD\n         LA    R7,0(R1,R5)    LOAD PREV ENTRY FIELD ADDR\n         LA    R8,0(R1,R3)    LOAD NEW ENTRY FIELD ADDR\n         C     R1,=A(VTFDSN-VTFMT)  DSN\n         BNE   NOTFRST1\n         LH    R1,VTFDSNL-VTFMT(0,R3)\n         CH    R1,VTFDSNL-VTFMT(0,R5)\n         BNH   NOTFRST0\n         LH    R1,VTFDSNL-VTFMT(0,R5)\nNOTFRST0 BCTR  R1,0\n         B     NOTFRST2\nNOTFRST1 LH    R1,2(0,R6)     LOAD SORT FIELD EXEC LENGTH\nNOTFRST2 CLI   0(R6),C'D'     DESCENDING SORT\n         BE    NOTFRST4       YES\nNOTFRST3 EX    R1,COMPVTF     COMPARE THE FIELDS\n         BL    NEXTENT        LIST ENTRY IS LOWER, UP THE CHAIN\n         BE    CHECKNXT       IDENTICAL, CHECK NEXT FIELD\n         B     INSERT\nNOTFRST4 EX    R1,COMPVTF     COMPARE THE FIELDS\n         BH    NEXTENT        LIST ENTRY IS LOWER, UP THE CHAIN\n         BE    CHECKNXT       IDENTICAL, CHECK NEXT FIELD\n*\n*        THE NEW ENTRY GOES HERE\n*\nINSERT   ST    R3,0(R2)       SAVE THE NEW POINTER\n         ST    R5,VTFNEXT     JUST BEFORE THIS LIST ENTRY\n         B     SORTRET        THEN EXIT\n*\n*\nCHECKNXT LA    R6,4(0,R6)     NEXT SORT FIELD\n         CLC   0(4,R6),=F'0'  ANY MORE FIELDS\n         BE    INSERT         NO, PUT IT HERE\n         B     NOTFIRST       YES, CHECK IT\n*\n*        GET THE NEXT ENTRY ON THIS LIST\n*\nNEXTENT  LA    R2,VTFNEXT-VTFMT(R5)  POINT BACK TO THIS ENTRY\n         LA    R6,SORTTAB     RELOAD SORT FIELD TABLE ADDR\n         ICM   R5,B'1111',VTFNEXT-VTFMT(R5)  GET THE NEXT ENTRY\n         BNZ   NOTFIRST       THERE IS ONE, CHECK IT\n         ST    R3,0(R2)       LAST ENTRY ON THE LIST, PUT IT THERE\n*\n*        RETURN\n*\nSORTRET  LEAVE EQ,RC=0\n*\n*\n*\n*        PROGRAM CONSTANTS\n*\nCOMPVTF  CLC   0(0,R7),0(R8)     EXECUTED COMPARE\nGOSORTCL CLC   0(0,R4),6(R2)     EXECUTED COMPARE\n*\n*\n         PRINT NOGEN\n         EJECT\n*\n*\n*        P A R S E   C O N T R O L   L I S T\n*\n*\n         PRINT OFF\n         COPY  VTOCPARS\n         PRINT ON\n*\n*        DYNAMIC WORK AREA\n*\n         SPACE 3\nSORTWORK DSECT\n         DS    18A            PRINT ROUTINE SAVE AREA\n         SPACE\n         DS    0D\nLENWORK  EQU   *-SORTWORK\n*\n*        VTOC COMMAND COMMON AREA\n*\n         PRINT NOGEN\n         VTOCOM\n         SPACE 3\n*\n*        FORMATTED DSCB\n*\n         VTFMT\n         SPACE 3\n         PDEDSNAM\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTOCMSG": {"ttr": 4611, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     VTOCMSG &MSG1,&MSG2    FIRST LEVEL MESSAGE, OPTIONAL SECOND\n&LAB     LA    R1,&MSG1       POINT TO THE FIRST MESSAGE\n         AIF   ('&MSG2' EQ '').NOSEC  IF NO SECOND LEVEL MSG\n         LA    R0,&MSG2       POINT TO THE SECOND MESSAGE\n         AGO   .SETMSG        SET UP THE MESSAGES\n.NOSEC   SR    R0,R0          NO SECOND LEVEL MESSAGE\n.SETMSG  STM   R0,R1,MSGADDRS SAVE THE MESSAGE ADDRESSES\n*        THEN JUST CALL THE MESSAGE ISSUING ROUTINE\n         VTCALL MSG           AWAY WE GO\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCOM": {"ttr": 4613, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         VTOCOM  &TYPE\n*\n*        THIS IS THE VTOC COMMAND COMMON AREA\n*\n         AIF   ('&TYPE' EQ 'NODSECT').NODSECT\nVTOCOM   DSECT\n         AGO   .NODS\n.NODSECT ANOP\nVTOCOM   DS    0D\n.NODS    ANOP\n*\n*        WORKING STORAGE AREAS FOR THE VARIOUS ROUTINES\n*\nVTCWMSG  DS    A              WORKING STORAGE FOR THE MSG  ROUTINE\nVTCWEXIT DS    A              WORKING STORAGE FOR THE EXIT ROUTINE\nVTCWEXCP DS    A              WORKING STORAGE FOR THE EXCP ROUTINE\nVTCWCHEK DS    A              WORKING STORAGE FOR THE CHEK ROUTINE\nVTCWFORM DS    A              WORKING STORAGE FOR THE FORM ROUTINE\nVTCWPRNT DS    A              WORKING STORAGE FOR THE PRNT ROUTINE\nVTCWSORT DS    A              WORKING STORAGE FOR THE SORT ROUTINE\n*\n*        ADDRESSES OF THE ROUTINES\n*\nVADMSG   DC    V(VTOCMSG)     ADDRESS OF THE MESSAGE ROUTINE\nVADEXIT  DC    V(VTOCEXIT)    ADDRESS OF THE EXIT ROUTINE\nVADEXCP  DC    V(VTOCEXIT)    ADDRESS OF THE EXCP ROUTINE\nVADCHEK  DC    V(VTOCEXIT)    ADDRESS OF THE CHECK ROUTINE\nVADFORM  DC    V(VTOCEXIT)    ADDRESS OF THE FORMAT ROUTINE\nVADPRNT  DC    V(VTOCEXIT)    ADDRESS OF THE PRINT ROUTINE\nVADSORT  DC    V(VTOCEXIT)    ADDRESS OF THE SORT ROUTINE\n*\n*        TSO COMMAND PROCESSOR AND PARSE DATA\n*\nADDRUPT  DS    A              USER PROFILE TABLE\nADDRECT  DS    A              ENVIRONMENT CONTROL TABLE\nADDRPSCB DS    A              PROTECTED STEP CONTROL BLOCK\nADDRCBUF DS    A              COMMAND BUFFER\n         SPACE\nADDRANSR DS    A              PARSE ANSWER OR PDL ADDRESS\n         SPACE\nPARMLIST DS    8A             INTERNAL PARM AREA ( MSG )\nATTNECB  DS    F              ECB FOR ATTENTIONS\nDOUBLE   DS    D\n         SPACE\nMSGADDRS DS    2A             ADDRESSES OF MESSAGES FOR VTOCMSG\nMSGTEXT1 DS    XL124\nMSGTEXT2 DS    XL124\n         SPACE 3\nPUTOLD1  DS    3F\nPUTOLD2  DS    3F\n*\n*        PARAMETER LIST FOR THE EXIT ROUTINE\n*\nEXITLIST DS    0F\nEXITAREA DS    A       WORKAREA LOCATION\nDSCBADDR DS    A       ADDRESS OF THE DSCB\nFORMATAD DS    A       ADDRESS OF THE FORMATTED DSCB\nCPPLADDR DS    A       ADDRESS OF THE CPPL\nACTIONAD DS    A       ADDRESS OF THE RECOMMENDED OR REQUESTED ACTION\n*\n*        INTER ROUTINE FLAGS\n*\nVTCEFUNC DS    X              VTOCEXCP FUNCTION FLAG\nVTCFMTCK DS    X              FORMAT IS CALLED BY CHECK RTN\nVTCFMTCD EQU   X'80'          FORMAT WAS CALLED BY CHECK\nVTCFMTCC EQU   X'08'          FORMAT WAS CALLED BY CHECK THIS CALL\n*\nTABFULL  DS    X             FLAG TABLES FULL, STOP INPUT\nLOCAT    DS    X              FLAG TO PERFORM CATALOG LOCATE\nVTCEPRNT DS    X               PRINT END AND CLEANUP FLAG\nDSNLEN   DS    H              LENGTH OF THE DSNAME (NON-BLANKS)\nATABTITL DS    A              ADDRESS OF TABLE OF TITLES, LENGTHS\n*\n*\n*\n*        WORKING STORAGE FOR VOLUME UCB SEARCH\n*\nADDR     DS    CL3     UCB ADDRESS IN CHARACTERS\nVOLSER   DS    CL6     VOLUME SERIAL NUMBER FROM PARSE\nVOLID    DS    CL6     CURRENT VOLUME SERIAL NUMBER TO PROCESS\nFLAG     DS    X       UCB SEARCH FLAG\nLASTADR  DS    F       LAST UCB ADDRESS FOUND ( NO DUP'S )\n*\n*\n*\nSORTTAB  DS    16F\n*\n* EACH ENTRY CONTAINS A KEY OFFSET (2 BYTES) AND A KEY LENGTH (2 BYTES)\n* THIS TABLE IS BUILT AT PARSE TIME ACCORDING TO THE SORT PARAMETERS\n* SPECIFIED. THE 1ST PARM IS THE HIGH KEY AND SO ON.\n*\n*\n*\n*        ADDRESSES OF GETMAIN FOR FORMATTED DATA\n*\nVTCCURAD DS    A             CURRENT AVAILABLE ADDRESS\nVTCCURLN DS    A             CURRENT AVAILABLE LENGTH\nVTCGETMN DS    50A           ADDRESSES OF BLOCKS\nVTCGETMX EQU  (*-VTCGETMN)/4  NUMBER OF BLOCKS  MAXIMUM\nVTCGETMS EQU   32768          GETMAIN SIZE\n*\n*        HASH SORT TABLE, POINTERS TO FIRST ENTRIES\n*\nVTCSORTH DS    256A           POINT TO FORMATED ENTRIES\nVTCSORTE EQU   *              END OF LIST\n*\n*        PRINT ENTRIES - PAGE AND LINE COUNTERS\n*\nLINECT   DS    H              LINE COUNT\nLINEMAX  DS    H              MAXIMUM LINES PER PAGE\nPAGECT   DS    H              PAGE COUNT\nLINELEN  DS    H              LENGTH OF THE PRINT LINE\n*\n*\n*          VARIOUS ITEMS\n*\nFMT4     DS    XL44           SPACE FOR DSCB NAME\n         IECSDSL1 4          SAVE EACH FORMAT 4 DSCB\n         DS    0D\nFMT3     DS    0XL148         SPACE FOR FORMAT3 DSCB\n         IECSDSL1 3\n         ORG   FMT3+148       NEXT SLOT\nFMT3X1   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X2   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X3   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X4   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X5   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X6   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X7   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X8   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\nFMT3X9   DS    XL148          SPACE FOR EXTRA FORMAT3 DSCBS\n         DS    0D\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCPARS": {"ttr": 4616, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         PUSH  PRINT\n         PRINT NOGEN\nPCLMAIN  IKJPARM DSECT=PDL\n         SPACE 2\nVOLS     IKJPOSIT DSNAME,VOLSER,LIST,                                  $\n               PROMPT='VOLUMES TO SEARCH AND OTHER PARAMETERS',        $\n               HELP=('VOLUME SERIAL NUMBERS WHICH ARE TO BE SEARCHED FO$\n               DATA SETS TO LIST')\n         SPACE 2\nLEVKEY   IKJKEYWD\n         IKJNAME 'LEVEL',SUBFLD=SUBLEV\n         SPACE 2\nENDKEY   IKJKEYWD\n         IKJNAME 'ENDING',SUBFLD=SUBEND\n         SPACE 2\nCONTAINK IKJKEYWD\n         IKJNAME 'CONTAINING',SUBFLD=SUBCONT\n         SPACE 2\n         SPACE 2\nSPACEK   IKJKEYWD DEFAULT='TRKS'\n         IKJNAME 'TRKS'\n         SPACE 2\nCATK     IKJKEYWD\n         IKJNAME 'CAT'\n         SPACE 2\nSORTK    IKJKEYWD\n         IKJNAME 'SORT',SUBFLD=SUBSORTS\n         IKJNAME 'NOSORT'\n         SPACE 2\nBREAKK   IKJKEYWD\n         IKJNAME 'BREAK',SUBFLD=SUBBREAK\n         SPACE 2\nLIMITK   IKJKEYWD\n         IKJNAME 'LIMIT',SUBFLD=SUBLIMIT\n         SPACE 2\nANDOR1K  IKJKEYWD\n         IKJNAME 'AND1',SUBFLD=SUBAO1,ALIAS='AND'\n         IKJNAME 'OR1',SUBFLD=SUBAO1,ALIAS='OR'\n         SPACE 2\nANDOR2K  IKJKEYWD\n         IKJNAME 'AND2',SUBFLD=SUBAO2\n         IKJNAME 'OR2',SUBFLD=SUBAO2\n         SPACE 2\nANDOR3K  IKJKEYWD\n         IKJNAME 'AND3',SUBFLD=SUBAO3\n         IKJNAME 'OR3',SUBFLD=SUBAO3\n         SPACE 2\nPRINTK   IKJKEYWD\n         IKJNAME 'PRINT',SUBFLD=SUBPRINT\n         IKJNAME 'NOPRINT'\n         SPACE 2\nCHARSK   IKJKEYWD\n         IKJNAME 'CHARS',SUBFLD=SUBCHARS\n         SPACE 2\nLINESK   IKJKEYWD\n         IKJNAME 'LINES',SUBFLD=SUBLINES\n         SPACE 2\nHEADK    IKJKEYWD\n         IKJNAME 'HEADING',SUBFLD=SUBHEAD\n         IKJNAME 'NOHEADING'\n         SPACE 2\nTOTALK   IKJKEYWD\n         IKJNAME 'TOTALS',SUBFLD=SUBTOTAL\n         SPACE 2\nOUTPUTK  IKJKEYWD\n         IKJNAME 'OUTPUT'\n         SPACE 2\nFORMATK  IKJKEYWD\n         IKJNAME 'FORMAT',SUBFLD=SUBFORMT\n         SPACE 2\nDSNPLNK  IKJKEYWD\n         IKJNAME 'DSNLEN',SUBFLD=SUBDSNLN\n         SPACE 5\nSUBLEV   IKJSUBF\nLEVEL    IKJPOSIT DSNAME,LIST,                                         X\n               PROMPT='BEGINNING CHARACTERS OF DSNAMES TO PROCESS'\n         SPACE 2\nSUBEND   IKJSUBF\nENDING   IKJPOSIT DSNAME,LIST,                                         X\n               PROMPT='ENDING CHARACTERS OF DSNAMES TO PROCESS'\n         SPACE 2\nSUBCONT  IKJSUBF\nCONTAIN  IKJPOSIT DSNAME,LIST,                                         X\n               PROMPT='CHARACTER STRING CONTAINED IN DSNAMES TO PROCESSX\n               '\n         SPACE 2\nSUBSORTS IKJSUBF\nSUBSORT  IKJIDENT 'SORT FIELDS',LIST,FIRST=ALPHA,MAXLNTH=6\n         SPACE 2\nSUBBREAK IKJSUBF\nBREAK    IKJIDENT 'NUMBER OF CHARACTERS FOR A BREAK',FIRST=NUMERIC,    X\n               OTHER=NUMERIC,MAXLNTH=2,DEFAULT='3'\n         SPACE 2\nSUBCHARS IKJSUBF\nCHARSPL  IKJIDENT 'NUMBER OF CHARACTERS PER LINE   ',FIRST=NUMERIC,    X\n               OTHER=NUMERIC,MAXLNTH=3\nBLKSZSET IKJIDENT 'PHYSICAL BLOCK SIZE',FIRST=NUMERIC,OTHER=NUMERIC,   X\n               MAXLNTH=5\n         SPACE 2\nSUBLINES IKJSUBF\nLINESPP  IKJIDENT 'NUMBER OF LINES PER PAGE        ',FIRST=NUMERIC,    X\n               OTHER=NUMERIC,MAXLNTH=3\n         SPACE 2\nSUBPRINT IKJSUBF\nSUBPRTKY IKJIDENT 'ADD, REP, NEW, OR DEL',                             X\n               FIRST=ALPHA,OTHER=ALPHA,MAXLNTH=3\nSUBPRTIT IKJIDENT 'ITEMS TO PRINT',LIST,FIRST=ALPHA,MAXLNTH=6\n         SPACE 2\nSUBHEAD  IKJSUBF\nHEADING  IKJPOSIT QSTRING\n         SPACE 2\nSUBTOTAL IKJSUBF\nTOTALN   IKJIDENT 'NUMBER OF CHARACTERS FOR TOTALS',FIRST=NUMERIC,     X\n               OTHER=NUMERIC,MAXLNTH=2,DEFAULT='0'\n         SPACE 3\nSUBLIMIT IKJSUBF\nSUBLKEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8\n         SPACE 2\nSUBLOPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X\n               MAXLNTH=2,                                              X\n               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'\n         SPACE 2\nSUBLVALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'\n         SPACE 3\nSUBAO1   IKJSUBF\nSUB1KEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8\n         SPACE 2\nSUB1OPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X\n               MAXLNTH=2,                                              X\n               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'\n         SPACE 2\nSUB1VALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'\n         SPACE 2\nSUBAO2   IKJSUBF\nSUB2KEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8\n         SPACE 2\nSUB2OPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X\n               MAXLNTH=2,                                              X\n               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'\n         SPACE 2\nSUB2VALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'\n         SPACE 2\nSUBAO3   IKJSUBF\nSUB3KEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8\n         SPACE 2\nSUB3OPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X\n               MAXLNTH=2,                                              X\n               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'\n         SPACE 2\nSUB3VALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'\n         SPACE 2\nSUBFORMT IKJSUBF\nFORMATSP IKJIDENT 'FORMAT TYPES TO OUTPUT',LIST,FIRST=NUMERIC,         X\n               MAXLNTH=1,DEFAULT='1'\n         SPACE 2\nSUBDSNLN IKJSUBF\nDSNPLN   IKJIDENT 'LENGTH OF DSNAME TO PRINT',FIRST=NUMERIC,           X\n               OTHER=NUMERIC,MAXLNTH=2,DEFAULT='44'\nDSNLNTYP IKJKEYWD DEFAULT='TRUNCATE'\n         IKJNAME 'TRUNCATE'\n         IKJNAME 'MULTILINE'\n         IKJENDP\n         SPACE 2\n         POP   PRINT\nACTION   EQU   1\nVOLUME   EQU   2\nCDATE    EQU   3\nLSTUS    EQU   4\nEXPDT    EQU   5\nALLOC    EQU   6\nUNUSED   EQU   7\nPCT      EQU   8\nEXT      EQU   9\nDSORG    EQU   10\nRECFM    EQU   11\nBLKSZ    EQU   12\nLRECL    EQU   13\nPASS     EQU   14\nCAT      EQU   15\nSECT     EQU   16\nSECQ     EQU   17\nUNIT     EQU   18\nROUND    EQU   19\nTYPE     EQU   20\nUSED     EQU   21\nCCHH     EQU   22\nDUMMY3   EQU   23\nDUMMY4   EQU   24\nDUMMY5   EQU   25\nDSNAME   EQU   26\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT127/FILE127.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT127", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}