{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011148000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1998724, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 47, "INMDSNAM": "CBT.V500.FILE069.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE069.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00#\\x08'", "DS1TRBAL": "b'\\x93\\x8e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00m\\x00\\x01\\x00o\\x00\\x06\\x00$'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"ADD": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00:\\x00:\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.5.1\n*\n*\n         MACRO                   HEADER STATEMENT\n&LABEL   ADD   &NUMB1,&NUMB2     PROTOTYPE STATEMENT\n         LCLC  &LAB              DECLARE SETC SYMBOL FOR EDITED LABEL\n         LCLC  &ERRSW            DECLARE SETC SYMB FOR PARM VALIDATION\n&ERRSW   SETC  '0'               INIT ERRSW TO INDICATE NO ERRORS\n&LAB     SETC  '&LABEL'\n         AIF   (K'&LAB LE 8).LABOK    CHECK LABEL LENGTH\n&LAB     SETC  '&LABEL'(1,8)     SELECT FIRST 8 CHARACTERS\n         MNOTE *,'LABEL EXCEEDS 8 CHARACTERS---LEFT MOST 8 USED'\n.LABOK   ANOP\n.*\n.* THE FOLLOWING AIF INSTRUCTIONS VALIDATE THE VALUE SPECIFIED FOR\n.* THE SYMBOLIC PARAMETER &NUMB1\n.*\n         AIF   (T'&NUMB1 EQ 'O').NON1\n         AIF   (T'&NUMB1 NE 'N').INVN1\n         AIF   (&NUMB1 GT 4095).BIGN1\n.*\n.* THE FOLLOWING AIF INSTRUCTIONS VALIDATE THE VALUE SPECIFIED FOR\n.* THE SYMBOLIC PARAMETER &NUMB2\n.*\n.V2      AIF   (T'&NUMB2 EQ 'O').NON2\n         AIF   (T'&NUMB2 NE 'N').INVN2\n         AIF   (&NUMB2 GT 4095).BIGN2\n         AIF   ('ERRSW' EQ '0').GENCODE\n         MEXIT\n.GENCODE ANOP\n.*\n.* THE FOLLOWING MODEL STATEMENTS ARE GENERATED IF THE VALUES FOR\n.* &NUMB1 AND &NUMB2 ARE SPECIFIED CORRECTLY\n.*\n&LAB     LA    R14,&NUMB1\n         LA    R15,&NUMB2\n         AR    R14,R15\n         MEXIT\n.*\n.* MNOTES FOR THE VALIDATION OF &NUMB1 AND &NUMB2\n.*\n.NON1    MNOTE 8,'FIRST NUMBER OMITTED---MACRO NOT GENERATED'\n&ERRSW   SETC  '1'                 TURN ON ERRSW TO INDICATE PARM ERROR\n         AGO   .V2\n.INVN1   MNOTE 8,'FIRST NUMBER IS INVALID---MACRO NOT GENERATED'\n&ERRSW   SETC  '1'                 TURN ON ERRSW TO INDICATE PARM ERROR\n         AGO   .V2\n.BIGN1   MNOTE 8,'FIRST NUMBER EXCEEDS 4095---MACRO NOT GENERATED'\n&ERRSW   SETC  '1'                 TURN ON ERRSW TO INDICATE PARM ERROR\n         AGO   .V2\n.NON2    MNOTE 8,'SECOND NUMBER OMITTED---MACRO NOT GENERATED'\n         MEXIT\n.INVN2   MNOTE 8,'SECOND NUMBER IS INVALID---MACRO NOT GENERATED'\n         MEXIT\n.BIGN2   MNOTE 8,'SECOND NUMBER EXCEEDS 4095---MACRO NOT GENERATED'\n.*\n         MEND                    TRAILER STATEMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BLDTBL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x002\\x002\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.5.3\n*\n*\n         MACRO\n&LABEL   BLDTBL\n         LCLA  &POS,&TOTPOS\n         LCLB  &OKBIT\n         LCLC  &LAB,&MM,&DD,&DATE\n&POS     SETA  1                   INITIALIZE RUNNING POS PARM COUNT\n&TOTPOS  SET   N'&SYSLIST          TOTAL POS PARMS SPECIFIED\n         AIF   (&TOTPOS EQ 0).NOPARMS    CHECK IF ANY POS PARMS SPEC\n&MM      SETC  '&SYSDATE'(1,2)           EXTRACT MONTH\n&DD      SETC  '&SYSDATE'(4,2)           EXTRACT DAY\n         AIF   ('&DD' LT '04' OR '&DD' GT '25').INVDATE  CHK VALID DATE\n&DATE    SETC  '&MM'.'&DD'\n&LAB     SETC  '&LABEL'\n         AIF   (K'&LAB LE 8).LABOK       CHECK LABEL LENGTH\n&LAB     SETC  '&LABEL'(1,8)             SELECT FIRST 8 CHARACTERS\n.LABOK   ANOP\n&LAB     DS    0H\n.LOOP    ANOP\n.*\n.* SET UP VALIDATION LOGIC FOR POS PARM IN SETB INSTRUCTION\n.*\n&OKBIT   SETB  ((K'&SYSLIST(&POS,1) EQ 4)  AND                         -\n               (K'&SYSLIST(&POS,2) LE 8)   AND                         -\n               (T'&SYSLIST(&POS,1) NE 'O') AND                         -\n               (T'&SYSLIST(&POS,2) NE 'O'))\n         AIF   (&OKBIT EQ 0).INVPARM     CHK IF POS PARM OK\n.*\n.* DEFINE TABLE ENTRY\n.*\n         DC    C'&SYSLIST(&POS,1)',C'&DATE',CL8'&SYSLIST(&POS,2)'\n.INCRPOS ANOP\n&POS     SETA  &POS+1                    INCR POS PARM COUNT\n         AIF   (&POS GT &TOTPOS).TBLEND  CHECK FOR POS PARM END\n         AGO   .LOOP\n.TBLEND  DC    16XL1'FF'                 INDICATE TABLE END\n         MEXIT\n.*\n.* MNOTES FOR ERROR CONDITIONS\n.*\n.NOPARMS MNOTE 8,'NO TABLE ENTRIES SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n.INVDATE MNOTE 4,'MACRO NOT GENERATED BECAUSE OF INVALID DATE'\n         MEXIT\n.INVPARM MNOTE 4,'POSITIONAL PARAMETER NUMBER &POS: &SYSLIST(&POS) IS I-\n         AGO   .INCRPOS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEAA0301": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00u\\x00u\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE A.3.1\n*\n*\n//-------- JOB  ----\n//CALLASM  EXEC ASMACLG\n//C.SYSLIB DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=USER.MACLIB,DISP=SHR\n//C.SYSIN  DD   *\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\nINVKASM1 CSECT\n         INITL 3,EQU=R\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\nNXTSRCDD BAL   R6,GETSRCDD         GET A REPLACEMENT DDNAME FOR SYSIN\n         LTR   R15,R15             CHECK IF END OF DDNAMES\n         BNZ   RETURN              IF YES, TERMINATE PROGRAM\n         BAL   R6,INVKASM          IF NO, INVOKE ASSEMBLER\n         B     NXTSRCDD            GET NEXT REPLACEMENT DDNAME\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE REPLACEMENT DDNAMES OF SYSIN FROM A\n*    TABLE ONE AT A TIME.\n***********************************************************************\n*\nGETSRCDD L     R10,SRCDDPTR        LOAD PTR FOR NEXT DDNAME\n         CLI   0(R10),SRCDDEND     CHK IF END-OF-TBL\n         BE    SETDDEND            IF YES, INDICATE IT\n         MVC   SRCDDNM,0(R10)      IF NO, MOVE NEXT DDN INTO PARM-LIST\n         LA    R10,8(0,R10)        INCR TO NEXT DDNAME IN TBL\n         ST    R10,SRCDDPTR        STORE THE PTR FOR THE NEXT DDNAME\n         LA    R15,0               INDICATE NEXT DDN IN ASM PARM-LIST\n         BR    R6                  RETURN TO CALLING ROUTINE\nSETDDEND LA    R15,4               INDICATE END-OF-TABLE\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE ASSEMBLER.\n***********************************************************************\n*\nINVKASM  LINK  EP=ASMA90,PARAM=(OPTLIST,DDNLIST),VL=1\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS TO MVS OR TO THE\n*    CALLING PROGRAM.\n***********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n*\n*\n***********************************************************************\n*     PARAMETER-LISTS FOR DYNAMIC INVOCATION OF THE ASSEMBLER\n***********************************************************************\n*\n         DS    0H\nOPTLIST  DC    AL2(OPTLEN)\nOPTIONS  DC    C'XREF(SHORT),NOOBJECT'\nOPTLEN   EQU   *-OPTIONS\n*\n*\n         DS    0H\nDDNLIST  DC    AL2(DDNLEN)\nDDNAMES  DC    XL8'00'         SYSLIN\n         DC    XL8'00'         N/A\n         DC    XL8'00'         N/A\n         DC    XL8'00'         SYSLIB\nSRCDDNM  DC    CL8' '          SYSIN\n         DC    CL8'LISTING'    SYSPRINT\nDDNLEN   EQU   *-DDNAMES\n*\n*\n***********************************************************************\n*     TABLE OF REPLACEMENT DDNAMES FOR SYSIN\n***********************************************************************\n*\nSRCDDPTR DC    A(SRCDDTBL)\n*\n*\nSRCDDTBL EQU   *\n         DC    CL8'SOURCE01'\n         DC    CL8'SOURCE02'\n         DC    CL8'SOURCE03'\n         DC    AL1(SRCDDEND)\n*\nSRCDDEND EQU   X'FF'\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n//*\n//*\n//G.SYSUT1   DD UNIT=VIO,SPACE=(CYL,(1,1)),DCB=BUFNO=2\n//G.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=USER.MACLIB,DISP=SHR\n//G.LISTING  DD SYSOUT=*\n//G.SOURCE01 DD DSN=USER.TEST.SRCLIB(PRGM01),DISP=SHR\n//G.SOURCE02 DD DSN=USER.TEST.SRCLIB(PRGM02),DISP=SHR\n//G.SOURCE03 DD DSN=USER.TEST.SRCLIB(PRGM03),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEAA0302": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xfb\\x00\\xfb\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 251, "newlines": 251, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE A.3.2\n*\n*\n//-------- JOB  ----\n//CALLASM  EXEC ASMACLG\n//C.SYSLIB DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=USER.MACLIB,DISP=SHR\n//C.SYSIN  DD *\n*\n*\nINVKASM2 CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R\n         USING S99RBP,R10      DEFINE REG FOR SVC99 REQ-BLK-PTR DSECT\n         USING S99RB,R11       DEFINE REG FOR SVC99 REQ-BLOCK DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\nNXTSRCNM BAL   R6,GETSRCNM         GET PGM NAMES FROM SRC LIB DIR\n         LTR   R15,R15             CHECK IF END-OF-DIR\n         BNZ   RETURN              IF YES, TERMINATE PROGRAM\n         BAL   R6,DYNALLOC         IF NO, DYN ALLOC SRC LIB AND PGM\n         BAL   R6,LINKASM          LINK TO ASSEMBLER\n         BAL   R6,UNALLOC          DYN UNALLOC SRC LIB AND PGM\n         B     NXTSRCNM            GET NEXT PROGRAM NAME\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS ALL THE PROGRAM NAMES FROM THE SOURCE\n*    LIBRARY DIRECTORY ONE AT A TIME. ALIASES ARE IGNORED.\n***********************************************************************\n*\nGETSRCNM READDIR SRCDIR            GET PGM NAMES FROM LIB DIR\n         C     R15,BIN4            CHECK FOR ALIAS NAME\n         BE    GETSRCNM            IF YES, IGNORE\n         MVC   PGMNAME,$MEMBER     PUT PGM NAME INTO DA-MEMB TEXT UNIT\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE DYNAMICALLY ALLOCATES THE SOURCE LIBRARY AND THE\n*    MEMBER (PROGRAM SOURCE NAME).\n***********************************************************************\n*\nDYNALLOC BAL   R7,SETRBA01         SETUP RB FOR ALLOC\n         BAL   R7,SETRBPTR         SETUP RB PTR\n         BAL   R7,DOSVC99          ISSUE SVC 99\n         BR    R6                  RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST BLOCK FOR ALLOCATION.\n***********************************************************************\n*\nSETRBA01 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBAL    SET ALLOCATION VERB\n         LA    R10,TUPTRA01        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST-BLOCK-POINTER.\n***********************************************************************\n*\nSETRBPTR LA    R10,RBPTR           SET ADRBLTY FOR RBPTR DSECT\n         LA    R11,REQBLK          LD ADR OF RB\n         ST    R11,S99RBPTR        STORE RB ADR INTO RB PTR\n         OI    S99RBPTR,S99RBPND   TURN ON HIGH ORDER BIT\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES SVC 99 VIA THE DYNALLOC MACRO.\n***********************************************************************\n*\nDOSVC99  LA    R1,RBPTR            LD ADR OF RB PTR INTO R1 FOR SVC 99\n         DYNALLOC                  ISSUE SVC 99\n         LTR   R15,R15             CHK RC\n         BNZ   CHKERR              IF NOT ZERO, CHK ERROR/INFO FIELDS\n         BR    R7                  IF OK, RETURN TO CALLING ROUTINE\nCHKERR   LH    R8,S99ERROR\n         LH    R9,S99INFO\n         ABEND 900,DUMP\n*\n*\n***********************************************************************\n*    THIS ROUTINE LINKS TO THE ASSEMBLER.\n***********************************************************************\n*\nLINKASM  LINK  EP=ASMA90,PARAM=(OPTLIST,DDNLIST),VL=1\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE UNALLOCATES THE DDNAME ALLOCATED IN THE DYNALLOC\n*    ROUTINE.\n***********************************************************************\n*\nUNALLOC  BAL   R7,SETRBU01         SETUP RB FOR UNALLO\n         BAL   R7,SETRBPTR         SETUP RB PTR\n         BAL   R7,DOSVC99          ISSUE SVC 99\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST BLOCK FOR UNALLOC.\n***********************************************************************\n*\nSETRBU01 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBUN    SET ALLOCATION VERB\n         LA    R10,TUPTRU01        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n*\n*\n***********************************************************************\n*     CONSTANTS\n***********************************************************************\n*\nBIN4     DC    F'4'\n*\n*\n***********************************************************************\n*     PARAMETER-LISTS FOR DYNAMIC ALLOCATION OF SOURCE LIBRARY AND\n*     MEMBER (PROGRAM SOURCE) NAME\n***********************************************************************\n*\n*\n***********************************************************************\n*    SVC99 REQ-BLOCK-POINTER AND REQUEST BLOCK\n***********************************************************************\n*\nRBPTR    DS    F\nREQBLK   DS    CL(S99RBEND-S99RB)\nREQBLKLN EQU   L'REQBLK\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LISTS\n***********************************************************************\n*\nTUPTRA01 DS    0F\n         DC    A(TUDDN)            ADR OF TU FOR DDNAME\n         DC    A(TUDSN)            ADR OF TU FOR DSNAME\n         DC    A(TUMEMB)           ADR OF TU FOR MEMBER NAME\n         DC    A(TUDISP1)          ADR OF TU FOR DS STATUS\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDISP2)        ADR OF TU FOR DS NORM TERM DISP\n*\nTUPTRU01 DS    0F\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDDN)          ADR OF TU FOR DDNAME\n*\n*\n***********************************************************************\n*    TEXT UNITS\n***********************************************************************\n*\nTUDDN    DC    AL2(DALDDNAM)       TU KEY FOR DDNAME\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(8)              LENGTH OF DDNAME\n         DC    CL8'SOURCE'         DDNAME\n*\nTUDSN    DC    AL2(DALDSNAM),AL2(1),AL2(44)\nLIBNAME  DC    CL44'USER.TEST.SRCLIB'        DATASET NAME\n*\nTUMEMB   DC    AL2(DALMEMBR),AL2(1),AL2(8)\nPGMNAME  DS    CL8                           MEMBER NAME\n*\nTUDISP1  DC    AL2(DALSTATS),AL2(1),AL2(1),X'01'    OLD\n*\nTUDISP2  DC    AL2(DALNDISP),AL2(1),AL2(1),X'08'    KEEP\n*\n*\n***********************************************************************\n*     END OF PARAMETER-LISTS FOR DYNAMIC ALLOCATION\n***********************************************************************\n*\n*\n***********************************************************************\n*     PARAMETER-LISTS FOR DYNAMIC INVOCATION OF ASSEMBLER\n***********************************************************************\n*\n         DS    0H\nOPTLIST  DC    AL2(OPTLEN)\nOPTIONS  DC    C'XREF(SHORT),OBJECT'\nOPTLEN   EQU   *-OPTIONS\n*\n*\n         DS    0H\nDDNLIST  DC    AL2(DDNLEN)\nDDNAMES  DC    CL8'OBJECT'     SYSLIN\n         DC    XL8'00'         N/A\n         DC    XL8'00'         N/A\n         DC    XL8'00'         SYSLIB\n         DC    CL8'SOURCE'     SYSIN\n         DC    CL8'LISTING'    SYSPRINT\nDDNLEN   EQU   *-DDNAMES\n*\n*\n***********************************************************************\n*     END OF PARAMETER-LISTS FOR ASSEMBLER\n***********************************************************************\n*\n*\n***********************************************************************\n*     DSECTS FOR DYNAMIC ALLOCATION\n***********************************************************************\n*\n         IEFZB4D0        GENS DSECT FOR REQ BLOCK, TEXT UNIT, ETC.\n         IEFZB4D2        GENS TABLE OF EQUATES FOR TU KEYS\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n*\n         END\n//*\n//*\n//G.SYSUT1   DD UNIT=VIO,SPACE=(CYL,(1,1)),DCB=BUFNO=10\n//G.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=USER.MACLIB,DISP=SHR\n//G.LISTING  DD SYSOUT=*\n//G.OBJECT   DD SYSOUT=*\n//G.SRCDIR   DD DSN=USER.TEST.SRCLIB,DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0301": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.3.1\n*\n*\n//OBJMOD1 DD DSN=USER.SEQOBJ01,DISP=SHR\n//OBJLIB1 DD DSN=USER.OBJLIB1,DISP=SHR\n//OBJLIB2 DD DSN=USER.OBJLIB2,DISP=SHR\n//LOADLIB DD DSN=USER.PRIVLOAD,DISP=SHR\n//SYSLMOD DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN  DD *\n    INCLUDE OBJMOD1\n    INCLUDE OBJLIB1(OBJMOD2,OBJMOD3,CNTL01)\n    INCLUDE LOADLIB(LOADMOD1)\n    NAME    PROGABC(R)\n//\n\nThe member CNTL01 contains the following:\n\n    INCLUDE OBJLIB1(OBJMOD4)\n    INCLUDE OBJLIB2(OBJMODA)\n    INCLUDE OBJLIB2(OBJMODB)\n    INCLUDE LOADLIB(LOADMODX)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CEBB0302": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.3.2\n*\n*\n//LOADLIB1 DD DSN=ACCP.LOADLIB,DISP=SHR\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE LOADLIB1(CALCRATE)\n    INCLUDE SYSLMOD(PROG001)\n    NAME    PROG001(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0303": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.3.3\n*\n*\n//LKED     EXEC PGM=IEWL,PARM='LIST,XREF,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD SPACE=(TRK,10),UNIT=SYSDA\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE SYSLMOD(PROGABC)\n    ALIAS   LMABC\n    NAME    PROGABC(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0304": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.3.4\n*\n*\n//SYSLIB   DD DSN=USER.PRODOBJS,DISP=SHR\n//TESTOBJ1 DD DSN=USER.TESTOBJS,DISP=SHR\n//SYSLMOD  DD DSN=TEST.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE SYSLMOD(PAYROLL)\n    LIBRARY TESTOBJ1(NYTAX,NJTAX)\n    NAME    PAYROLL(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0305": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.3.5\n*\n*\n//SYSLIB   DD DSN=TEST.LOADLIB,DISP=SHR\n//USERLIB  DD DSN=USER.LOADLIB,DISP=SHR\n//SYSLMOD  DD DSN=TEST.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE USERLIB(PRGM001)\n    LIBRARY (RTN006)\n    NAME    PRGM001\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0401": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.4.1\n*\n*\n//USERLOAD DD DSN=USER.LOADLIB,DISP=SHR\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n  INCLUDE USERLOAD(PROGAA)\n  INCLUDE USERLOAD(PROGBB)\n  NAME    MAINPROG(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0402": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.4.2\n*\n*\n//USERLOAD DD DSN=USER.LOADLIB,DISP=SHR\n//SYSLMOD  DD DSN=PROD.LOADLIB(MAINPROG),DISP=SHR\n//SYSLIN   DD *\n  INCLUDE USERLOAD(PROGAA)\n  INCLUDE USERLOAD(PROGBB)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0601": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.1\n*\n*\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    CHANGE  SOCSEC(FICA)\n    INCLUDE SYSLMOD(PAYROLL)\n    NAME    PAYROLL(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0602": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.2\n*\n*\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    CHANGE  TAX01(NYTAX),TAX02(NJTAX)\n    INCLUDE SYSLMOD(PAYROLL)\n    NAME    PAYROLL(R)\n    CHANGE  TAX01(NYTAX)\n    INCLUDE SYSLMOD(STATENY)\n    NAME    STATENY(R)\n    CHANGE  TAX02(NJTAX)\n    INCLUDE SYSLMOD(STATENJ)\n    NAME    STATENJ(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0603": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.3\n*\n*\n//USERLIB  DD DSN=USER.LOADLIB,DISP=SHR\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE USERLIB(NYTAX99)\n    REPLACE NYTAX98(NYTAX99)\n    INCLUDE SYSLMOD(PAYROLL)\n    NAME    PAYROLL(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0604": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.4\n*\n*\n//SYSLMOD  DD DSN=TEST.LOADLIB,DISP=SHR\n//SYSLIN   DD DSN=&&OBJMOD,DISP=(OLD,DELETE)\n//         DD *\n    REPLACE FUNC02V5(FUNC02V6)\n    INCLUDE SYSLMOD(MAINPROG)\n    NAME    MAINPROG(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0605": {"ttr": 785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.5\n*\n*\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    REPLACE FUNC09\n    INCLUDE SYSLMOD(PAYROLL)\n    NAME    PAYROLL(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0606": {"ttr": 787, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.6\n*\n*\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSIN    DD *\n    INCLUDE  SYSLMOD(PAYROLL)\n    IDENTIFY NYTAX99('CONTAINS 1999 NYS TAX TABLES')\n    NAME     PAYROLL(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0607": {"ttr": 789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.7\n*\n*\n//SYSLMOD  DD DSN=USER.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE SYSLMOD(MAINPGM)\n    ALIAS   PROG01\n    ALIAS   PROG01A,PROG01B\n    NAME    MAINPGM(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0608": {"ttr": 791, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.8\n*\n*\n//SYSLMOD  DD DSN=USER.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE SYSLMOD(VALIDATE)\n    ENTRY   INIT\n    NAME    VALIDATE(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0609": {"ttr": 793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.6.9\n*\n*\n//USERLIB  DD DSN=USER.LOADLIB,DISP=SHR\n//SYSLMOD  DD DSN=PROD.LOADLIB,DISP=SHR\n//SYSLIN   DD *\n    INCLUDE USERLIB(LOAD01A)\n    INCLUDE USERLIB(LOAD01B)\n    ALIAS   PROG01\n    NAME    MAINPGM1\n    INCLUDE USERLIB(LOAD02A)\n    INCLUDE USERLIB(LOAD02B)\n    NAME    MAINPGM2(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0801": {"ttr": 795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.8.1\n*\n*\n         ATTACH EP=IEWL,PARAM=NULLOPT,VL=1\n         ...\nNULLOPT  DC    H'0'\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0802": {"ttr": 797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.8.2\n*\n*\n         LINK  EP=IEWL,PARAM=(LKOPT01,ALTDDN01),VL=1\n         ...\n         DS    0H\nLKOPT1   DC    AL2(LKOPT1X-LKOPT1-2)\n         DC    C'LIST,XREF,REUS,NCAL'\nLKOPT1X  EQU   *\n         ...\n         DS    0H\nALTDDN1  DC    AL2(ALTDDN1X-ALTDDN1-2)\n         DC    CL8'SYSCNTL'    SYSLIN\n         DC    XL8'00'\n         DC    CL8'SYSLOAD'    SYSLMOD\n         DC    CL8'SYSALC'     SYSLIB\nALTDDN1X EQU   *\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CEBB0803": {"ttr": 799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01h\\x01h\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 360, "newlines": 360, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE B.8.3\n*\n*\n//-------- JOB  ----\n//ASMLINK  EXEC ASMACLG\n//C.SYSLIB DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=USER.MACLIB,DISP=SHR\n//C.SYSIN  DD   *\n*\n*\nDYNASMLK CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R         SET UP BASE REGS AND SAVEAREA\n         USING S99RBP,R10      DEFINE REG FOR SVC99 REQ-BLK-PTR DSECT\n         USING S99RB,R11       DEFINE REG FOR SVC99 REQ-BLOCK DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\nNXTSRCNM BAL   R6,GETSRCNM         GET PGM NAMES FROM SRC LIB DIR\n         LTR   R15,R15             CHECK IF END-OF-DIR\n         BNZ   RETURN              IF YES, TERMINATE PROGRAM\n         BAL   R6,DYNALL01         IF NO, DYN ALLOC SRC LIB AND PGM NM\n         BAL   R6,DYNALL02         DYN ALLOC OBJ LIB AND OBJMOD NAME\n         BAL   R6,INVKASM          INVOKE THE ASSEMBLER\n         BAL   R6,INVKLKED         INVOKE THE LINKAGE EDITOR\n         BAL   R6,UNALL01          DYN UNALLOC SRC LIB AND PGM NAME\n         BAL   R6,UNALL02          DYN UNALLOC OBJ LIB AND OBJMOD NAME\n         B     NXTSRCNM            GET NEXT PROGRAM NAME\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS ALL THE PROGRAM NAMES FROM THE SOURCE\n*    LIBRARY DIRECTORY ONE AT A TIME. ALIASES ARE IGNORED.\n***********************************************************************\n*\nGETSRCNM READDIR SRCDIR            GET PGM NAMES FROM LIB DIR\n         C     R15,BIN4            CHECK FOR ALIAS NAME\n         BE    GETSRCNM            IF YES, IGNORE\n         MVC   SRCNAME,$MEMBER     PUT PGM NAME INTO DA-MEMB TEXT UNIT\n         MVC   OBJNAME,$MEMBER     PUT PGM NAME INTO DA-MEMB TEXT UNIT\n         MVC   PGMNAME,$MEMBER     PUT PGM NAME INTO LKED PARM LIST\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE DYNAMICALLY ALLOCATES THE SOURCE LIBRARY AND THE\n*    MEMBER (PROGRAM SOURCE NAME).\n***********************************************************************\n*\nDYNALL01 BAL   R7,SETRBA01         SETUP RB FOR ALLOC\n         BAL   R7,SETRBPTR         SETUP RB PTR\n         BAL   R7,DOSVC99          ISSUE SVC 99\n         BR    R6                  RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST BLOCK FOR ALLOCATION\n*    OF THE SOURCE LIBRARY AND THE MEMBER NAME.\n***********************************************************************\n*\nSETRBA01 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBAL    SET ALLOCATION VERB\n         LA    R10,TUPTRA01        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST-BLOCK-POINTER.\n***********************************************************************\n*\nSETRBPTR LA    R10,RBPTR           SET ADRBLTY FOR RBPTR DSECT\n         LA    R11,REQBLK          LD ADR OF RB\n         ST    R11,S99RBPTR        STORE RB ADR INTO RB PTR\n         OI    S99RBPTR,S99RBPND   TURN ON HIGH ORDER BIT\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES SVC 99 VIA THE DYNALLOC MACRO.\n***********************************************************************\n*\nDOSVC99  LA    R1,RBPTR            LD ADR OF RB PTR INTO R1 FOR SVC 99\n         DYNALLOC                  ISSUE SVC 99\n         LTR   R15,R15             CHK RC\n         BNZ   CHKERR              IF NOT ZERO, CHK ERROR/INFO FIELDS\n         BR    R7                  IF OK, RETURN TO CALLING ROUTINE\nCHKERR   LH    R8,S99ERROR\n         LH    R9,S99INFO\n         ABEND 900,DUMP\n*\n*\n***********************************************************************\n*    THIS ROUTINE DYNAMICALLY ALLOCATES THE OBJECT LIBRARY AND THE\n*    MEMBER (OBJECT MODULE NAME).\n***********************************************************************\n*\nDYNALL02 BAL   R7,SETRBA02         SETUP RB FOR ALLOC OBJECT DDNAME\n         BAL   R7,SETRBPTR         SETUP RB PTR\n         BAL   R7,DOSVC99          ISSUE SVC 99\n         BR    R6                  RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST BLOCK FOR ALLOCATION\n*    OF THE OBJECT LIBRARY AND THE MEMBER NAME.\n***********************************************************************\n*\nSETRBA02 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBAL    SET ALLOCATION VERB\n         LA    R10,TUPTRA02        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE ASSEMBLER.\n***********************************************************************\n*\nINVKASM  LINK  EP=ASMA90,PARAM=(AOPTLIST,ADDNLIST),VL=1\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE LINKAGE EDITOR.\n***********************************************************************\n*\nINVKLKED LINK  EP=HEWL,PARAM=(LOPTLIST,LDDNLIST),VL=1\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE UNALLOCATES THE DDNAME ALLOCATED IN THE DYNALL01\n*    ROUTINE.\n***********************************************************************\n*\nUNALL01  BAL   R7,SETRBU01         SETUP RB FOR UNALLO OF SRC LIB\n         BAL   R7,SETRBPTR         SETUP RB PTR\n         BAL   R7,DOSVC99          ISSUE SVC 99\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST BLOCK FOR THE\n*    UNALLOCATION OF THE SOURCE LIBRARY.\n***********************************************************************\n*\nSETRBU01 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBUN    SET ALLOCATION VERB\n         LA    R10,TUPTRU01        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE UNALLOCATES THE DDNAME ALLOCATED IN THE DYNALL02\n*    ROUTINE.\n***********************************************************************\n*\nUNALL02  BAL   R7,SETRBU02         SETUP RB FOR UNALLO OF OBJ LIB\n         BAL   R7,SETRBPTR         SETUP RB PTR\n         BAL   R7,DOSVC99          ISSUE SVC 99\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE SVC99 REQUEST BLOCK FOR THE\n*    UNALLOCATION OF THE OBJECT LIBRARY.\n***********************************************************************\n*\nSETRBU02 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBUN    SET ALLOCATION VERB\n         LA    R10,TUPTRU02        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n*\n*\n***********************************************************************\n*     CONSTANTS\n***********************************************************************\n*\nBIN4     DC    F'4'\n*\n*\n***********************************************************************\n*     PARAMETER-LISTS FOR DYNAMIC ALLOCATION OF SOURCE LIBRARY AND\n*     MEMBER (PROGRAM SOURCE) NAME\n***********************************************************************\n*\n*\n***********************************************************************\n*    SVC99 REQ-BLOCK-POINTER AND REQUEST BLOCK\n***********************************************************************\n*\nRBPTR    DS    F\nREQBLK   DS    CL(S99RBEND-S99RB)\nREQBLKLN EQU   L'REQBLK\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LISTS FOR SVC99\n***********************************************************************\n*\nTUPTRA01 DS    0F\n         DC    A(TUDDN01)          ADR OF TU FOR DDNAME OF SRC LIB\n         DC    A(TUDSN01)          ADR OF TU FOR DSNAME OF SRC LIB\n         DC    A(TUMEMB01)         ADR OF TU FOR MEMBER NAME OF SRC\n         DC    A(TUDISP1)          ADR OF TU FOR DS STATUS\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDISP2)        ADR OF TU FOR DS NORM TERM DISP\n*\nTUPTRA02 DS    0F\n         DC    A(TUDDN02)          ADR OF TU FOR DDNAME OF OBJ LIB\n         DC    A(TUDSN02)          ADR OF TU FOR DSNAME OF OBJ LIB\n         DC    A(TUMEMB02)         ADR OF TU FOR MEMBER NAME OF OBJ\n         DC    A(TUDISP1)          ADR OF TU FOR DS STATUS\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDISP2)        ADR OF TU FOR DS NORM TERM DISP\n*\nTUPTRU01 DS    0F\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDDN01)        ADR OF TU FOR DDNAME OR SRC LIB\n*\nTUPTRU02 DS    0F\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDDN02)        ADR OF TU FOR DDNAME OR OBJ LIB\n*\n*\n***********************************************************************\n*    TEXT UNITS FOR SVC99\n***********************************************************************\n*\nTUDDN01  DC    AL2(DALDDNAM)       TU KEY FOR DDNAME\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(8)              LENGTH OF DDNAME\n         DC    CL8'SOURCE'         DDNAME OF SOURCE LIBRARY\n*\nTUDDN02  DC    AL2(DALDDNAM)       TU KEY FOR DDNAME\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(8)              LENGTH OF DDNAME\n         DC    CL8'OBJECT'         DDNAME OF OBJECT LIBRARY\n*\nTUDSN01  DC    AL2(DALDSNAM),AL2(1),AL2(44)\nSRCLIB   DC    CL44'USER.TEST.SRCLIB'     DATASET NAME OF SRCLIB\n*\nTUDSN02  DC    AL2(DALDSNAM),AL2(1),AL2(44)\nOBJLIB   DC    CL44'USER.TEST.OBJLIB'     DATASET NAME OF OBJLIB\n*\nTUMEMB01 DC    AL2(DALMEMBR),AL2(1),AL2(8)\nSRCNAME  DS    CL8                           MEMBER NAME OF SOURCE\n*\nTUMEMB02 DC    AL2(DALMEMBR),AL2(1),AL2(8)\nOBJNAME  DS    CL8                           MEMBER NAME OF OBJECT\n*\nTUDISP1  DC    AL2(DALSTATS),AL2(1),AL2(1),X'01'    OLD\n*\nTUDISP2  DC    AL2(DALNDISP),AL2(1),AL2(1),X'08'    KEEP\n*\n*\n***********************************************************************\n*     END OF PARAMETER-LISTS FOR DYNAMIC ALLOCATION\n***********************************************************************\n*\n*\n***********************************************************************\n*     PARAMETER-LISTS FOR DYNAMIC INVOCATION OF THE ASSEMBLER\n***********************************************************************\n*\n         DS    0H\nAOPTLIST DC    AL2(AOPTLEN)\nAOPTIONS DC    C'XREF(SHORT),OBJECT'\nAOPTLEN  EQU   *-AOPTIONS\n*\n*\n         DS    0H\nADDNLIST DC    AL2(ADDLSTLN)\nADDNAMES DC    CL8'OBJECT'     SYSLIN\n         DC    XL8'00'         N/A\n         DC    XL8'00'         N/A\n         DC    XL8'00'         SYSLIB\n         DC    CL8'SOURCE'     SYSIN\n         DC    CL8'LISTING'    SYSPRINT\nADDLSTLN EQU   *-ADDNAMES\n*\n*\n***********************************************************************\n*     PARAMETER-LISTS FOR DYNAMIC INVOCATION OF THE LINKAGE EDITOR\n***********************************************************************\n*\n         DS    0H\nLOPTLIST DC    AL2(LOPTLEN)\nLOPTIONS DC    C'XREF,NCAL,LIST'\nLOPTLEN  EQU   *-LOPTIONS\n*\n*\n         DS    0H\nLDDNLIST DC    AL2(LDDLSTLN)\nLDDNAMES DC    CL8'OBJECT'     SYSLIN\nPGMNAME  DS    CL8             LOD MOD NAME\n         DC    XL8'00'         SYSLMOD\n         DC    XL8'00'         SYSLIB\n         DC    XL8'00'         N/A\n         DC    CL8'LISTING'    SYSPRINT\nLDDLSTLN EQU   *-LDDNAMES\n*\n*\n***********************************************************************\n*     END OF PARAMETER-LISTS FOR THE LINKAGE EDITOR\n***********************************************************************\n*\n*\n***********************************************************************\n*     DSECTS FOR DYNAMIC ALLOCATION\n***********************************************************************\n*\n         IEFZB4D0        GENS DSECT FOR REQ BLOCK, TEXT UNIT, ETC.\n         IEFZB4D2        GENS TABLE OF EQUATES FOR TU KEYS\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n*\n         END\n//*\n//*\n//G.SYSUT1   DD UNIT=VIO,SPACE=(CYL,(1,1)),DCB=BUFNO=10\n//G.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=USER.MACLIB,DISP=SHR\n//G.LISTING  DD SYSOUT=*\n//G.SRCDIR   DD DSN=USER.TEST.SRCLIB,DISP=SHR\n//G.SYSLMOD  DD DSN=USER.TEST.LOADLIB,DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE020301": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O!\\x03\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T21:03:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.3.1\n*\n*\nLABEL1    DS    0H\n          (Previous Subroutine)\n          ...\n          BR    R6          RETURN TO CALLER\n*    THIS SUBROUTINE READS A LOGICAL RECORD FROM THE EMPLOYEE MASTER\n*    FILE USING A QSAM GET IN LOCATE MODE. REGISTER 10 IS LOADED WITH\n*    THE POINTER OF THE RECORD TO SET THE PROPER ADDRESSABILITY FOR\n*    THE MAPPING DSECT.\nREADEREC  GET   EMPLMSTR    READ EMPLOYEE MASTER FILE\n          LR    R10,R1      LOAD DSECT REG WITH LOGICAL REC ADDRESS\n          BR    R6          RETURN TO CALLER\n*    COMMENTS FOR NEXT SUBROUTINE\nLABEL2    DS    0H\n          (Next Subroutine)\n          ...\n          BR    R6          RETURN TO CALLER\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE020302": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.3.2\n*\n*\nLABEL1    DS    0H\n          (Previous Subroutine)\n          ...\n          BR    R6          RETURN TO CALLER\n          SPACE 4\n*    THIS SUBROUTINE READS A LOGICAL RECORD FROM THE EMPLOYEE MASTER\n*    FILE USING A QSAM GET IN LOCATE MODE. REGISTER 10 IS LOADED WITH\n*    THE POINTER OF THE RECORD TO SET THE PROPER ADDRESSABILITY FOR\n*    THE MAPPING DSECT.\n          SPACE 2\nREADEREC  GET   EMPLMSTR    READ EMPLOYEE MASTER FILE\n          LR    R10,R1      LOAD DSECT REG WITH LOGICAL REC ADDRESS\n          BR    R6          RETURN TO CALLER\n          SPACE 4\n*    COMMENTS FOR NEXT SUBROUTINE\n          SPACE 2\nLABEL2    DS    0H\n          (Next Subroutine)\n          ...\n          BR    R6          RETURN TO CALLER\n          SPACE 4\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE020303": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00$\\x00$\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.3.3\n*\n*\nLABEL1    DS    0H\n          (Previous Subroutine)\n          ...\n          BR    R6          RETURN TO CALLER\n*\n*\n*\n*\n*    THIS SUBROUTINE READS A LOGICAL RECORD FROM THE EMPLOYEE MASTER\n*    FILE USING A QSAM GET IN LOCATE MODE. REGISTER 10 IS LOADED WITH\n*    THE POINTER OF THE RECORD TO SET THE PROPER ADDRESSABILITY FOR\n*    THE MAPPING DSECT.\n*\n*\nREADEREC  GET   EMPLMSTR    READ EMPLOYEE MASTER FILE\n          LR    R10,R1      LOAD DSECT REG WITH LOGICAL REC ADDRESS\n          BR    R6          RETURN TO CALLER\n*\n*\n*\n*\n*    COMMENTS FOR NEXT SUBROUTINE\n*\n*\nLABEL2    DS    0H\n          (Next Subroutine)\n          ...\n          BR    R6          RETURN TO CALLER\n*\n*\n*\n*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE020401": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.4.1\n*\n*\nBLDTBL   L     R10,TBLPTR            LOAD ADR OF CUR TBL SLOT\n         MVC   0(ENTLEN,R10),ENTRY   MOVE ENTRY INTO TABLE\n         LA    10,ENTLEN(0,R10)      INCR TO NEXT TABLE SLOT\n         ST    R10,TBLPTR            STORE ADR OF NEXT TBL SLOT\n         BR    R8                    RETURN TO CALLER\n         ...\nENTLEN   EQU   25\nTBLPTR   DS    F\nENTRY    DS    CL25\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE020501": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01`\\x01`\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 352, "newlines": 352, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.5.1\n*\n*\n         TITLE ...\n*\n*\n********************************************************************\n*\n*    PROGRAM PROLOGUE COMMENTS GO HERE\n*\n********************************************************************\n*\n*\nREPORT   CSECT\n*\n*\n********************************************************************\n*    INITIALIZATION\n********************************************************************\n*\n         INITL 3,EQU=R\n*\n*\n********************************************************************\n*    MAINSTREAM OF PROGRAM\n********************************************************************\n*\n         BAL   R6,GETPARM\n         BAL   R6,OPEN\n         BAL   R6,GETCNTL\nNEXTREC  BAL   R6,READSMF\n         BAL   R6,PROCREC\n         BAL   R6,SETLINE\n         BAL   R6,DOREPORT\n         B     NEXTREC\nSMFEND   BAL   R6,DOTOTALS\n         BAL   R6,CLOSE\n         B     RETURN\n*\n*\n********************************************************************\n********************************************************************\n*    MAJOR ROUTINES AND SUBROUTINES\n********************************************************************\n********************************************************************\n*\n********************************************************************\n*    THIS ROUTINE OBTAINS THE CONTROL INFORMATION SPECIFIED VIA\n*    THE PARM PARAMETER OF THE JCL EXEC STATEMENT.\n********************************************************************\n*\nGETPARM  DS    0H\n         ...\n         BR    R6\n*\n*\n********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n********************************************************************\n*\nOPEN     DS    0H\n         ...\n         BR    R6\n*\n*\n********************************************************************\n*    THIS ROUTINE OBTAINS THE CONTROL INFORMATION SPECIFIED VIA\n*    THE SYSIN DATASET.\n********************************************************************\n*\nGETCNTL  DS    0H\n         ...\n         BR    R6\n*\n*\n********************************************************************\n*    THIS ROUTINE READS SMF RECORDS AND RETURNS ONLY THE ONES\n*    WHICH FULFILL THE SPECIFIED REQUIREMENTS. THIS ROUTINE\n*    BRANCHES AND LINKS TO THE SELREC SUBROUTINE WHICH DETERMINES\n*    WHICH RECORDS ARE TO BE PROCESSED BY RETURNING A RC IN\n*    REGISTER 15. RC=0 INDICATES THAT THE RECORD SATISFIES ALL THE\n*    SPECIFIED SELECTION CRITERIA AND SHOULD BE PROCESSED AND A\n*    NON-ZERO RC INDICATES THAT THE RECORD IS TO BE BYPASSED AND\n*    THE NEXT SMF RECORD IS TO BE READ.\n********************************************************************\n*\nREADSMF  DS    0H\n         ...\n         BAL   R7,SELREC\n         ...\n         B     READSMF\n*\n*\n*********************************************************************\n*    THIS SUBROUTINE SELECTS THE APPROPRIATE SMF RECORDS FOR\n*    PROCESSING. IT BRANCHES AND LINKS TO A SEPARATE SUBROUTINE\n*    TO CHECK FOR EACH SELECTION CRITERION. IF THE CALLED SUBROUTINE\n*    RETURNS CONTROL WITH RC=0 SET IN REGISTER 15, THEN THE SELECTION\n*    CRITERION WAS SATISFIED AND THE NEXT SUBROUTINE IS CALLED. IF\n*    THE CALLED SUBROUTINE RETURNS CONTROL WITH A NON-ZERO RC SET IN\n*    REGISTER 15, THEN THE SELECTION CRITERION WAS NOT SATISFIED AND\n*    THAT PARTICULAR SMF RECORD IS TO BE IGNORED, INDICATED BY\n*    RETURNING CONTROL TO THE CALLING ROUTINE WITH A NON-ZERO RC IN\n*    REGISTER 15. IF ALL THE SELECTION CRITERIA ARE SATISFIED, THEN\n*    THIS SUBROUTINE RETURNS CONTROL TO THE CALLING ROUTINE WITH\n*    RC=0 SET IN REGISTER 15 TO INDICATE THAT THE RECORD SHOULD BE\n*    PROCESSED.\n*********************************************************************\n*\nSELREC   BAL   R8,CHKRECID\n         ...\n         BAL   R8,CHKDATE\n         ...\n         BAL   R8,CHKTIME\n         ...\n         BAL   R8,CHKINDEX\n         ...\n         BR    R7\n*\n*\n********************************************************************\n*    THIS SUBROUTINE CHECKS THE RECORD-TYPE ID OF EACH SMF RECORD\n*    READ AND SETS RC=0 IN REGISTER 15 IF THE RECORD-TYPE ID IS ONE\n*    OF THE REQUIRED ONES.\n********************************************************************\n*\nCHKRECID DS    0H\n         ...\n         BR    R8\n*\n*\n********************************************************************\n*    THIS SUBROUTINE CHECKS THE JOB-SUBMITTED-DATE FIELD OF THE SMF\n*    RECORDS. SETS RC=0 IN REGISTER 15 IF THE DATE IS WITHIN THE\n*    SPECIFIED RANGE.\n********************************************************************\n*\nCHKDATE  DS    0H\n         ...\n         BR    R8\n*\n*\n********************************************************************\n*    THIS SUBROUTINE CHECKS THE JOB-SUBMITTED-TIME FIELD OF THE SMF\n*    RECORDS. SETS RC=0 IN REGISTER 15 IF THE TIME IS WITHIN THE\n*    SPECIFIED RANGE.\n********************************************************************\n*\nCHKTIME  DS    0H\n         ...\n         BR    R8\n*\n*\n********************************************************************\n*    THIS SUBROUTINE CHECKS THE HIGH LEVEL INDEX OF THE DATASET-NAME\n*    FIELD OF THE SMF RECORDS. SETS RC=0 IN REGISTER 15 IF THE\n*    HIGH LEVEL INDEX IS ONE OF THE SPECIFIED ONES.\n********************************************************************\n*\nCHKINDEX DS    0H\n         ...\n         BR    R8\n*\n*\n********************************************************************\n*    THIS ROUTINE PROCESSES THE SELECTED SMF RECORDS.\n********************************************************************\n*\nPROCREC  DS    0H\n         ...\n         BAL   R7,PROC14\n         ...\n         BAL   R7,PROC15\n         ...\n         BAL   R7,PROC64\n         ...\n         BR    R6\n*\n*\n********************************************************************\n*    THIS SUBROUTINE PROCESSES THE SMF TYPE-14 RECORDS.\n********************************************************************\n*\nPROC14   BAL   R8,GETDATE\n         BAL   R8,GETTIME\n         ...\n         BAL   R8,GETEXCP\n         ...\n         BR    R7\n*\n*\n********************************************************************\n*    THIS SUBROUTINE PROCESSES THE SMF TYPE-15 RECORDS.\n********************************************************************\n*\nPROC15   BAL   R8,GETDATE\n         BAL   R8,GETTIME\n         ...\n         BAL   R8,GETEXCP\n         ...\n         BR    R7\n*\n*\n********************************************************************\n*    THIS SUBROUTINE PROCESSES THE SMF TYPE-64 RECORDS.\n********************************************************************\n*\nPROC64   BAL   R8,GETDATE\n         BAL   R8,GETTIME\n         ...\n         BAL   R8,GETEXCP\n         ...\n         BR    R7\n*\n*\n********************************************************************\n*    THIS ROUTINE SETS UP THE DETAIL PRINT LINE FOR THE REPORT.\n********************************************************************\n*\nSETLINE  DS    0H\n         ...\n         BR    R6\n*\n*\n********************************************************************\n*    THIS ROUTINE PRINTS EACH DETAIL LINE OF THE REPORT AND CHECKS\n*    THE LINE COUNTER TO DETERMINE WHEN A NEW PAGE IS REQUIRED.\n********************************************************************\n*\nDOREPORT DS    0H\n         ...\n         BAL   R7,NEWPAGE\n         ...\n         BR    R6\n*\n*\n********************************************************************\n*    THIS SUBROUTINE PRINTS THE HEADERS FOR THE FIRST PAGE AND EACH\n*    NEW PAGE OF THE REPORT, RESETS THE LINE COUNTER TO ZERO AND\n*    INCREMENTS THE PAGE NUMBER.\n********************************************************************\n*\nNEWPAGE  DS    0H\n         ...\n         BR    R7\n*\n*\n******************************************************************\n*    THIS ROUTINE PRINTS THE TOTALS LINE ON THE REPORT AT SMF\n*    END-OF-DATA.\n******************************************************************\n*\nDOTOTALS DS    0H\n         ...\n         BR    R6\n*\n*\n******************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n******************************************************************\n*\nCLOSE    DS    0H\n         ...\n         BR    R6\n*\n*\n******************************************************************\n******************************************************************\n*    COMMON SUBROUTINES\n******************************************************************\n******************************************************************\n*\n******************************************************************\n*    THIS SUBROUTINE EXTRACTS THE JOB-SUBMITTED-DATE FROM THE SMF\n*    RECORDS AND EDITS IT IN THE FORMAT YY.DDD.\n******************************************************************\n*\nGETDATE  DS    0H\n         ...\n         BR    R8\n*\n*\n******************************************************************\n*    THIS SUBROUTINE EXTRACTS THE JOB-SUBMITTED-TIME FROM THE SMF\n*    RECORDS AND EDITS IT IN THE FORMAT HH/MM/SS.\n******************************************************************\n*\nGETTIME  DS    0H\n         ...\n         BR    R8\n*\n*\n******************************************************************\n*    THIS SUBROUTINE EXTRACTS THE EXCP COUNT FROM THE SMF RECORDS\n*    AND EDITS IT IN THE FORMAT NN,NNN,NNN.\n******************************************************************\n*\nGETEXCP  DS    0H\n         ...\n         BR    R8\n*\n*\n******************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n******************************************************************\n*\nRETURN   ...\n*\n*\n******************************************************************\n*    CONSTANTS AND WORK AREAS\n******************************************************************\n*\nZERO     DC    P'0'\nONE      DC    P'1'\nMAXLINES DC    PL2'55'\nLINECTR  DC    PL2'55'\nPAGECTR  DC    PL2'0'\nEDWORK01 DS    CL4\nEDMASK01 DC    X'40202020'\n         ...\n*\n*\n******************************************************************\n*    DCB MACROS\n******************************************************************\n*\nSYSIN    DCB   ...\nSMFDATA  DCB   ...\nREPORT   DCB   ...\n*\n*\n******************************************************************\n*    DSECTS\n******************************************************************\n*\n$SMF14   DSECT\n*\n$SMF15   DSECT\n*\n$SMF64   DSECT\n*\n#LINE    DSECT\n*\n*\n******************************************************************\n*    END OF PROGRAM\n******************************************************************\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE020601": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.6.1\n*\n*\n         MACRO\n&LABEL   WTOREGS &MSG\n         GBLC  &WTOREGS\n         AIF   ('&MSG'(1,1) NE '''').ERR01\n         AIF   ('&WTOREGS' EQ '1').START\n&WTOREGS SETC  '1'\n         WTOREGS0\n.START   STM   0,15,##SVREGS\n         WTO   &MSG\n         BAL   R14,##DSPLY\n         LM    0,15,##SVREGS\n         DS    0H\n         MEXIT\n.ERR01   MNOTE 4,'*** MESSAGE NOT ENCLOSED IN APOSTHOPHIES --- MACRO NO-\n               T GENERATED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE020602": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00w\\x00w\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.6.2\n*\n*\n         MACRO\n         WTOREGS0\n         B     ##BYPASS\n*\n##DSPLY  ST    14,##SAVR14\n         LA    10,4\n         LA    11,4\n         LA    15,##SVREGS\n         LA    14,##R00\n##SETLNE LA    0,4\n         BAL   1,##NXTR\n         LA    14,6(0,14)\n         BCT   10,##SETLNE\n         LA    10,4\n         LA    14,4(0,14)\n         BCT   11,##SETLNE\n         B     ##DOWTOS\n*\n##NXTR   MVI   ##BYTE1,X'00'\n         MVI   ##BYTE2,X'00'\n         MVZ   ##BYTE1,0(15)\n         MVN   ##BYTE2,0(15)\n         TR    ##BYTE1,##TRTBL\n         TR    ##BYTE2,##TRTBL\n         MVC   0(1,14),##BYTE1\n         MVC   1(1,14),##BYTE2\n         LA    14,2(0,14)\n         LA    15,1(0,15)\n         BCT   0,##NXTR\n         BR    1\n*\n##DOWTOS LA    R1,##WLST1\n         WTO   MF=(E,(R1))\n         LA    R1,##WLST2\n         WTO   MF=(E,(R1))\n         LA    R1,##WLST3\n         WTO   MF=(E,(R1))\n         LA    R1,##WLST4\n         WTO   MF=(E,(R1))\n         L     14,##SAVR14\n         BR    R14\n*\n         CNOP  0,4\n##WLST1  DC    AL2(##WLST1X-##WLST1)\n         DC    X'8000'\n         DC    C'R00='\n##R00    DS    CL8\n         DC    C'  R01='\n##R01    DC    CL8'XXXXXXXX'\n         DC    C'  R02='\n##R02    DS    CL8\n         DC    C'  R03='\n##R03    DC    CL8'XXXXXXXX'\n##WLST1X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n         CNOP  0,4\n##WLST2  DC    AL2(##WLST2X-##WLST2)\n         DC    X'8000'\n         DC    C'R04='\n##R04    DS    CL8\n         DC    C'  R05='\n##R05    DS    CL8\n         DC    C'  R06='\n##R06    DS    CL8\n         DC    C'  R07='\n##R07    DS    CL8\n##WLST2X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n         CNOP  0,4\n##WLST3  DC    AL2(##WLST3X-##WLST3)\n         DC    X'8000'\n         DC    C'R08='\n##R08    DS    CL8\n         DC    C'  R09='\n##R09    DC    CL8'XXXXXXXX'\n         DC    C'  R10='\n##R10    DS    CL8\n         DC    C'  R11='\n##R11    DS    CL8\n##WLST3X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n         CNOP  0,4\n##WLST4  DC    AL2(##WLST4X-##WLST4)\n         DC    X'8000'\n         DC    C'R12='\n##R12    DS    CL8\n         DC    C'  R13='\n##R13    DS    CL8\n         DC    C'  R14='\n##R14    DS    CL8\n         DC    C'  R15='\n##R15    DS    CL8\n##WLST4X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n##SAVR14 DS    F\n##SVREGS DS    16F\n##BYTE1  DC    X'00'\n##BYTE2  DC    X'00'\n##TRTBL  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6F1'\n         DC    15XL1'00',X'F2',15XL1'00',X'F3',15XL1'00',X'F4'\n         DC    15XL1'00',X'F5',15XL1'00',X'F6',15XL1'00',X'F7'\n         DC    15XL1'00',X'F8',15XL1'00',X'F9',15XL1'00',X'C1'\n         DC    15XL1'00',X'C2',15XL1'00',X'C3',15XL1'00',X'C4'\n         DC    15XL1'00',X'C5',15XL1'00',X'C6'\n*\n##BYPASS DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030301": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.1\n*\n*\n         MACRO\n&TBLNAME HEXTBL\n&TBLNAME DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'    00-0F\n         DC    X'F1',X15'00'                          10-1F\n         DC    X'F2',X15'00'                          20-2F\n         DC    X'F3',X15'00'                          30-3F\n         DC    X'F4',X15'00'                          40-4F\n         DC    X'F5',X15'00'                          50-5F\n         DC    X'F6',X15'00'                          60-6F\n         DC    X'F7',X15'00'                          70-7F\n         DC    X'F8',X15'00'                          80-8F\n         DC    X'F9',X15'00'                          90-9F\n         DC    X'C1',X15'00'                          A0-AF\n         DC    X'C2',X15'00'                          B0-BF\n         DC    X'C3',X15'00'                          C0-CF\n         DC    X'C4',X15'00'                          D0-DF\n         DC    X'C5',X15'00'                          E0-EF\n         DC    X'C6',X15'00'                          F0-FF\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030302": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.2\n*\n*\n         MACRO\n&TBLNAME TRTBL &ASTERIK=*,&HYPHEN=-,&PERCENT=%,&PLUS=+,&QUES=?\n&TBLNAME DC    256AL1(*-&TBLNAME)    GEN 256-BYTE TBL OF X'00' TO X'FF'\n         ORG   &TBLNAME+C'*'         SET TBL PTR TO ASTERISK POS\n         DC    C'&ASTERIK'           ASTERISK TRANS CHAR\n         ORG   &TBLNAME+C'-'         SET TBL PTR TO HYPEN POS\n         DC    C'&HYPHEN'            HYPHEN TRANS CHAR\n         ORG   &TBLNAME+C'%'         SET TBL PTR TO PERCENT SIGN POS\n         DC    C'&PERCENT'           PERCENT SIGN TRANS CHAR\n         ORG   &TBLNAME+C'+'         SET TBL PTR TO PLUS SIGN POS\n         DC    C'&PLUS'              PLUS SIGN TRANS CHAR\n         ORG   &TBLNAME+C'?'         SET TBL PTR TO QUESTION MARK POS\n         DC    C'&QUES'              QUESTION MARK TRANS CHAR\n         ORG   &TBLNAME+256          ADJ LOC CTR PASSED END-OF-TBL\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030303": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.3\n*\n*\n         MACRO\n&LABEL   GETPARM &PARM\n&LABEL   B     *+106               BRANCH AROUND PARM HOLD AREA\n&PARM    DC    102CL1' '           DEFINE MAX LEN OF JCL PARM + 2 FOR\n*                                  ALIGNMENT AND TO SET DELIMITER\n         L     1,0(0,1)            LOAD JCL PARM ADR INTO REG 1\n         LH    15,0(0,1)           LOAD LEN OF JCL PARM INTO REG 15\n         LTR   15,15               WAS JCL PARM SPECIFIED?\n         BZ    *+24                IF NO, BRANCH OUT OF MACRO\n         BCTR  15,0                IF YES, DECR REG 15 FOR EX INSTR\n         EX    15,*+8              MOVE JCL PARM INTO PARM HOLD AREA\n         B     *+10                BRANCH AROUND MVC INSTR\n         MVC   &PARM,2(1)          SUBJECT INSTR FOR EX INSTR\n         LA    15,1(0,15)          INCR REG 15 BACK TO PARM LENGTH\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030304": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.4\n*\n*\n         MACRO\n&LABEL   PUTTBL &TABLE,&ENTRY,&ENTLEN,&KEYLEN\n&LABEL   LA    14,&TABLE              LOAD ADR OF BG OF TBL INTO REG 14\n$SCANTBL CLI   0(14),X'00'            CHK FOR VACANT SPOT IN TBL\n         BE    $INSTBL                IF YES, BRANCH TO INSERT RTN\n         CLC   0(&KEYLEN,14),&ENTRY   CHK FOR DUPL ENTRY\n         BE    $UPDTBL                IF YES, BRANCH TO UPDATE RTN\n         CLI   0(14),X'FF'            CHK FOR END OF TBL\n         BE    $TBLEND                IF YES, BRANCH TO TBLEND RTN\n         LA    14,&ENTLEN.(0,14)      INCR TO NEXT TABLE SLOT\n         B     $SCANTBL               BRANCH BACK TO BG OF LOOP\n$INSTBL  MVC   0(&ENTLEN,14),&ENTRY   MOVE NEW ENTRY INTO TBL\n         LA    15,0                   NEW ENTRY, SET RC = 0\n         B     $PTBLEND               BRANCH OUT OF MACRO\n$UPDTBL  MVC   0(&ENTLEN,14),&ENTRY   REPLACE DUPL ENTRY\n         LA    15,4                   REPLACE ENTRY, SET RC = 4\n         B     $PTBLEND               BRANCH OUT OF MACRO\n$TBLEND  LA    15,8                   END OF TBL, SET RC = 8\n$PTBLEND DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030501": {"ttr": 1297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00:\\x00:\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.5.1\n*\n*\n         MACRO                   HEADER STATEMENT\n&LABEL   ADD   &NUMB1,&NUMB2     PROTOTYPE STATEMENT\n         LCLC  &LAB              DECLARE SETC SYMBOL FOR EDITED LABEL\n         LCLC  &ERRSW            DECLARE SETC SYMB FOR PARM VALIDATION\n&ERRSW   SETC  '0'               INIT ERRSW TO INDICATE NO ERRORS\n&LAB     SETC  '&LABEL'\n         AIF   (K'&LAB LE 8).LABOK    CHECK LABEL LENGTH\n&LAB     SETC  '&LABEL'(1,8)     SELECT FIRST 8 CHARACTERS\n         MNOTE *,'LABEL EXCEEDS 8 CHARACTERS---LEFT MOST 8 USED'\n.LABOK   ANOP\n.*\n.* THE FOLLOWING AIF INSTRUCTIONS VALIDATE THE VALUE SPECIFIED FOR\n.* THE SYMBOLIC PARAMETER &NUMB1\n.*\n         AIF   (T'&NUMB1 EQ 'O').NON1\n         AIF   (T'&NUMB1 NE 'N').INVN1\n         AIF   (&NUMB1 GT 4095).BIGN1\n.*\n.* THE FOLLOWING AIF INSTRUCTIONS VALIDATE THE VALUE SPECIFIED FOR\n.* THE SYMBOLIC PARAMETER &NUMB2\n.*\n.V2      AIF   (T'&NUMB2 EQ 'O').NON2\n         AIF   (T'&NUMB2 NE 'N').INVN2\n         AIF   (&NUMB2 GT 4095).BIGN2\n         AIF   ('ERRSW' EQ '0').GENCODE\n         MEXIT\n.GENCODE ANOP\n.*\n.* THE FOLLOWING MODEL STATEMENTS ARE GENERATED IF THE VALUES FOR\n.* &NUMB1 AND &NUMB2 ARE SPECIFIED CORRECTLY\n.*\n&LAB     LA    R14,&NUMB1\n         LA    R15,&NUMB2\n         AR    R14,R15\n         MEXIT\n.*\n.* MNOTES FOR THE VALIDATION OF &NUMB1 AND &NUMB2\n.*\n.NON1    MNOTE 8,'FIRST NUMBER OMITTED---MACRO NOT GENERATED'\n&ERRSW   SETC  '1'                 TURN ON ERRSW TO INDICATE PARM ERROR\n         AGO   .V2\n.INVN1   MNOTE 8,'FIRST NUMBER IS INVALID---MACRO NOT GENERATED'\n&ERRSW   SETC  '1'                 TURN ON ERRSW TO INDICATE PARM ERROR\n         AGO   .V2\n.BIGN1   MNOTE 8,'FIRST NUMBER EXCEEDS 4095---MACRO NOT GENERATED'\n&ERRSW   SETC  '1'                 TURN ON ERRSW TO INDICATE PARM ERROR\n         AGO   .V2\n.NON2    MNOTE 8,'SECOND NUMBER OMITTED---MACRO NOT GENERATED'\n         MEXIT\n.INVN2   MNOTE 8,'SECOND NUMBER IS INVALID---MACRO NOT GENERATED'\n         MEXIT\n.BIGN2   MNOTE 8,'SECOND NUMBER EXCEEDS 4095---MACRO NOT GENERATED'\n.*\n         MEND                    TRAILER STATEMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030502": {"ttr": 1299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00E\\x00E\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.5.2\n*\n*\n         MACRO\n&LABEL   PUTTBL &TABLE,&ENTRY,&ENTLEN,&KEYLEN\n         LCLC   &LBL\n&LBL     SETC  '$'.'PTB'.'&SYSNDX'(2,3)    DEFINE LABEL BASE\n.*\n.* VERIFY THAT BOTH &ENTLEN AND &KEYLEN ARE SELF-DEFINING TERMS\n.*\n         AIF   (T'&ENTLEN EQ 'N' AND T'&KEYLEN EQ 'N').VRFY255\n         MNOTE 4,'SPECIFIED ENTRY-LENGTH OR SPECIFIED KEY-LENGTH NOT VA-\n               LID---MACRO NOT GENERATED'\n         MEXIT\n.*\n.* VERIFY THAT BOTH &ENTLEN AND &KEYLEN ARE LESS THAN 256\n.*\n.VRFY255 AIF   (&ENTLEN LE 255 AND &KEYLEN LE 255).CHKREL\n         MNOTE 4,'SPECIFIED ENTRY-LENGTH OR SPECIFIED KEY-LENGTH EXCEED-\n               S 255---MACRO NOT GENERATED'\n         MEXIT\n.*\n.* VERIFY THAT &ENTLEN IS GREATER THAN OR EQUAL TO &KEYLEN\n.*\n.CHKREL  AIF   (&ENTLEN GE &KEYLEN).CHKREGT\n         MNOTE 4,'SPECIFIED KEY-LENGTH IS GREATER THAN SPECIFIED ENTRY--\n               LENGTH---MACRO NOT GENERATED'\n         MEXIT\n.*\n.* CHECK IF &TABLE IS SPECIFIED AS A REGISTER\n.*\n.CHKREGT AIF   ('&TABLE'(1,1) EQ '(').REGTBL\n         LA    14,&TABLE                LD ADR OF BG OF TBL INTO REG 14\n         AGO   .B1\n.REGTBL  LR    14,&TABLE(1)             LD ADR OF BG OF TBL INTO REG 14\n.B1      ANOP\n&LBL.A   CLI   0(14),X'00'              CHK FOR VACANT SPOT IN TBL\n         BE    &LBL.B                   IF YES, BRANCH TO INSERT RTN\n.*\n.* CHECK IF &ENTRY IS SPECIFIED AS A REGISTER\n.*\n.CHKREGE AIF   ('&ENTRY'(1,1) EQ '(').REGENT1\n         CLC   0(&KEYLEN,14),&ENTRY     CHK FOR DUPL ENTRY\n         AGO   .B2\n\n.REGENT1 CLC   0(&KEYLEN,14),0(&ENTRY(1)) CHK FOR DUPL ENTRY\n.B2      BE    &LBL.C                   IF YES, BRANCH TO UPDATE RTN\n         CLI   0(14),X'FF'              CHK FOR END OF TBL\n         BE    &LBL.D                   IF YES, BRANCH TO TBLEND RTN\n         LA    14,&ENTLEN.(0,14)        INCR TO NEXT TABLE SLOT\n         B     &LBL.A                   BRANCH BACK TO BG OF LOOP\n         AIF   ('&ENTRY'(1,1) EQ '(').REGENT2\n&LBL.B   MVC   0(&ENTLEN,14),&ENTRY     MOVE NEW ENTRY INTO TBL\n         AGO   .B3\n.REGENT2 ANOP\n&LBL.B   MVC   0(&ENTLEN,14),0(&ENTRY(1)) MOVE NEW ENTRY INTO TBL\n.B3      LA    15,0                     NEW ENTRY, SET RC = 0\n         B     &LBL.E                   BRANCH OUT OF MACRO\n         AIF   ('&ENTRY'(1,1) EQ '(').REGENT3\n&LBL.C   MVC   0(&ENTLEN,14),&ENTRY     REPLACE DUPL ENTRY\n         AGO   .B4\n.REGENT3 ANOP\n&LBL.C   MVC   0(&ENTLEN,14),0(&ENTRY(1)) REPLACE DUPL ENTRY\n.B4      LA    15,4                     REPLACE ENTRY, SET RC = 4\n         B     &LBL.E                   BRANCH OUT OF MACRO\n&LBL.D   LA    15,8                     END OF TBL, SET RC = 8\n&LBL.E   DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030503": {"ttr": 1301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x002\\x002\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.5.3\n*\n*\n         MACRO\n&LABEL   BLDTBL\n         LCLA  &POS,&TOTPOS\n         LCLB  &OKBIT\n         LCLC  &LAB,&MM,&DD,&DATE\n&POS     SETA  1                   INITIALIZE RUNNING POS PARM COUNT\n&TOTPOS  SET   N'&SYSLIST          TOTAL POS PARMS SPECIFIED\n         AIF   (&TOTPOS EQ 0).NOPARMS    CHECK IF ANY POS PARMS SPEC\n&MM      SETC  '&SYSDATE'(1,2)           EXTRACT MONTH\n&DD      SETC  '&SYSDATE'(4,2)           EXTRACT DAY\n         AIF   ('&DD' LT '04' OR '&DD' GT '25').INVDATE  CHK VALID DATE\n&DATE    SETC  '&MM'.'&DD'\n&LAB     SETC  '&LABEL'\n         AIF   (K'&LAB LE 8).LABOK       CHECK LABEL LENGTH\n&LAB     SETC  '&LABEL'(1,8)             SELECT FIRST 8 CHARACTERS\n.LABOK   ANOP\n&LAB     DS    0H\n.LOOP    ANOP\n.*\n.* SET UP VALIDATION LOGIC FOR POS PARM IN SETB INSTRUCTION\n.*\n&OKBIT   SETB  ((K'&SYSLIST(&POS,1) EQ 4)  AND                         -\n               (K'&SYSLIST(&POS,2) LE 8)   AND                         -\n               (T'&SYSLIST(&POS,1) NE 'O') AND                         -\n               (T'&SYSLIST(&POS,2) NE 'O'))\n         AIF   (&OKBIT EQ 0).INVPARM     CHK IF POS PARM OK\n.*\n.* DEFINE TABLE ENTRY\n.*\n         DC    C'&SYSLIST(&POS,1)',C'&DATE',CL8'&SYSLIST(&POS,2)'\n.INCRPOS ANOP\n&POS     SETA  &POS+1                    INCR POS PARM COUNT\n         AIF   (&POS GT &TOTPOS).TBLEND  CHECK FOR POS PARM END\n         AGO   .LOOP\n.TBLEND  DC    16XL1'FF'                 INDICATE TABLE END\n         MEXIT\n.*\n.* MNOTES FOR ERROR CONDITIONS\n.*\n.NOPARMS MNOTE 8,'NO TABLE ENTRIES SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n.INVDATE MNOTE 4,'MACRO NOT GENERATED BECAUSE OF INVALID DATE'\n         MEXIT\n.INVPARM MNOTE 4,'POSITIONAL PARAMETER NUMBER &POS: &SYSLIST(&POS) IS I-\n         AGO   .INCRPOS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030601": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00q\\x00q\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.6.1\n*\n*\n         MACRO\n&LABEL   INITL &EQU=,&ID=,&SA=\n         LCLA  &POS,&TOTOPD,&DISP,&STOPSW,&REG13SW\n         LCLC  &SVAR,&LBL,&PRFX\n         LCLC  &REGS,&REG1,&REG2\n         AIF   (T'&LABEL NE 'O').B1\n         MNOTE *,'NO LABEL SPECIFIED'\n         AGO   .CHKEQU\n.B1      AIF   (K'&LABEL LE 8).LABOK\n         MNOTE 'LABEL EXCEEDS 8 CHARACTERS---LEFT MOST 8 USED'\n.LABOK   ANOP\n&LBL     SETC  '&LABEL'(1,8)\n.CHKEQU  AIF   (T'&EQU EQ 'O').B8\n         AIF   (K'&EQU LE 6).EQUOK\n         MNOTE 'EQU PREFIX EXCEEDS 6 CHARACTERS---LEFT MOST 6 USED'\n.EQUOK   ANOP\n&PRFX    SETC  '&EQU'(1,6)\n.B8      ANOP\n&SVAR    SETC  'SVAR'.'&SYSNDX'\n&TOTOPD  SETA  N'&SYSLIST\n         AIF   (&TOTOPD EQ 0).NOREG\n         AIF   (&TOTOPD LE 15).PROCEED\n         MNOTE 0,'MORE THAN 15 REGISTERS HAVE BEEN SPECIFIED---SURPLUS -\n               ONES HAVE BEEN IGNORED'\n&TOTOPD  SETA  15\n.PROCEED ANOP\n         AIF   (T'&EQU NE 'O').EQUTBL\n.B2      ANOP\n         AIF   (T'&ID NE 'O').SETID\n.B3      ANOP\n.ULOOP   ANOP\n&POS     SETA  &POS+1\n         AIF   (&POS GT &TOTOPD).USING\n         AIF   ('&SYSLIST(&POS)' EQ '13').REG13\n         AIF   ('&SYSLIST(&POS)' EQ '0').INVREG\n.B4      ANOP\n&REGS    SETC  '&REGS'.','.'&PRFX'.'&SYSLIST(&POS)'\n         AGO   .ULOOP\n.USING   ANOP\n         AIF   (&REG13SW EQ 1).USING13\n&LBL     STM   &PRFX.14,&PRFX.12,12(&PRFX.13)\n         BALR  &PRFX.&SYSLIST(1),0\n         USING *&REGS\n.B5      ANOP\n&POS     SETA  1\n         AIF   (&TOTOPD EQ 1).REST\n.NXLOAD  ANOP\n&POS     SETA  &POS+1\n         AIF   (&POS GT &TOTOPD).REST\n&REG1    SETC  '&SYSLIST(&POS-1)'\n&REG2    SETC  '&SYSLIST(&POS)'\n         LA    &PRFX.&REG2,2048\n         LA    &PRFX.&REG2,2048(&PRFX.&REG1,&PRFX.&REG2)\n         AGO   .NXLOAD\n.REG13   AIF   (&POS GT 1).INVREG\n&REG13SW SETA  1\n         AGO   .B4\n.USING13 ANOP\n         AIF   (T'&SA EQ 'O').B6\n&SVAR    SETC  '&SA'(1,8)\n.B6      ANOP\n&LBL     STM   &PRFX.14,&PRFX.12,12(&PRFX.13)\n         LR    &PRFX.2,&PRFX.13\n         BALR  &PRFX.12,0\n         BAL   &PRFX.13,76(0,&PRFX.12)\n&SVAR    DC    18F'0'\n         USING &SVAR&REGS\n         AGO   .B5\n.REST    AIF   (&REG13SW EQ 1).B7\n         GETMAIN R,LV=72,SP=1\n         ST    &PRFX.13,4(0,&PRFX.1)\n         ST    &PRFX.1,8(0,&PRFX.13)\n         LR    &PRFX.13,&PRFX.1\n         L     &PRFX.1,4(0,&PRFX.13)\n         L     &PRFX.1,24(0,&PRFX.1)\n         MEXIT\n.B7      ST    &PRFX.2,4(0,&PRFX.13)\n         ST    &PRFX.13,8(0,&PRFX.2)\n         MEXIT\n.EQUTBL  ANOP\n&PRFX.0  EQU   0\n&PRFX.1  EQU   1\n&PRFX.2  EQU   2\n&PRFX.3  EQU   3\n&PRFX.4  EQU   4\n&PRFX.5  EQU   5\n&PRFX.6  EQU   6\n&PRFX.7  EQU   7\n&PRFX.8  EQU   8\n&PRFX.9  EQU   9\n&PRFX.10 EQU   10\n&PRFX.11 EQU   11\n&PRFX.12 EQU   12\n&PRFX.13 EQU   13\n&PRFX.14 EQU   14\n&PRFX.15 EQU   15\n         AIF   (&REG13SW EQ 1).B5\n         AGO   .B2\n.SETID   B     12(0,&PRFX.15)\n         AIF   ('&ID'(1,1) EQ '*').CSECTNM\n         DC    CL8'&ID'\n         AGO   .B3\n.CSECTNM DC    CL8'&SYSECT'\n         AGO   .B3\n.NOREG   MNOTE 12,'NO REGISTERS SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n.INVREG  MNOTE 12,'INVALID REGISTER SPECIFIED---MACRO GENERATION TERMIN-\n               ATED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE030602": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00)\\x00)\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.6.2\n*\n*\n         MACRO\n&LABEL   RCNTL &RC=,&SA=\n         LCLC  &SVAR\n         AIF   (K'&LABEL LE 8).LABOK\n         MNOTE 0,'LABEL CONTAINS MORE THAN 8 CHARACTERS---MACRO NOT GEN-\n               ERATED'\n         MEXIT\n.LABOK   ANOP\n         AIF   (T'&SA EQ 'O').NOSA\n         AIF   ('&SA'(1,1) EQ '(').SAREG\n&SVAR    SETC  '&SA'(1,8)\n&LABEL   LA    13,&SVAR+4\n         AGO   .CHKRC\n.SAREG   ANOP\n&LABEL   L     13,4(0,&SA(1))\n         AGO   .CHKRC\n.NOSA    ANOP\n&LABEL   L     13,4(0,13)\n.CHKRC   AIF   (T'&RC EQ 'O').NORC\n         AIF   ('&RC'(1,1) EQ '(').RCREG\n         AIF   (T'&RC NE 'N').RCINVAL\n         AIF   (&RC GT 4095).RCINVAL\n         LA    15,&RC\n         AGO   .RCOK\n.RCREG   AIF   (&RC(1) EQ 15).RCOK\n         MNOTE 0,'INVALID REGISTER SPECIFIED FOR RETURN CODE---RC IGNOR-\n               ED'\n         AGO   .NORC\n.RCINVAL MNOTE 0,'RETURN CODE SPECIFIED IS INVALID---RC IGNORED'\n         AGO   .NORC\n.RCOK    L     14,12(0,13)\n         LM    0,12,20(13)\n         BR    14\n         MEXIT\n.NORC    LM    14,12,12(13)\n         BR    14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040301": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.3.1\n*\n*\n         EXTRACT TCBINFO,STCB1ADR,FIELDS=(ASID,PRI,CMC)\n         ...\nSTCB1ADR DS    F\nTCBINFO  DS    0F\nTCBASID  DS    F\nTCBPRIO  DS    F\nTCBCMCD  DS    F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040302": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.3.2\n*\n*\n         EXTRACT TIOTADR,'S',FIELDS=TIOT\n         L     R10,TIOTADR\n         MVC   JOBNAME,0(R10)\n         ...\nTIOTADR  DS    F\nJOBNAME  DS    CL8\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040501": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.5.1\n*\n*\n         BAL   R6,DOBLDL           BUILD BLDL-LIST FOR REQR PRGMS\n         BAL   R6,LOADPGMS         LOAD REQUIRED PRGMS\n         ...\nDOBLDL   BLDL  0,BLDLIST           SEARCH CURRENT LOAD LIBS\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nLOADPGMS LOAD  DE=P1ENTRY\n         ST    R0,P1EPADR          SAVE EPA OF PRGM01\n         LOAD  DE=P2ENTRY\n         ST    R0,P2EPADR          SAVE EPA OF PRGM02\n         LOAD  DE=P3ENTRY\n         ST    R0,P3EPADR          SAVE EPA OF PRGM03\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nBLDLIST  DC    H'3'                SPECIFY 3 DIR ENTRIES REQUESTED\n         DC    H'60'               ONLY 1ST 60 BYTES OF EACH ENTRY REQR\nP1ENTRY  DC    CL8'PRGM01'\n         DS    CL52\nP2ENTRY  DC    CL8'PRGM02'\n         DS    CL52\nP3ENTRY  DC    CL8'PRGM03'\n         DS    CL52\n         ...\nP1EPADR  DS    F\nP2EPADR  DS    F\nP3EPADR  DS    F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040502": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.5.2\n*\n*\n         BAL   R6,OPENLIB\n         BAL   R6,LOADPGM\n         ...\nOPENLIB  OPEN  PRIVLIB\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6\n         ...\nLOADPGM  LOAD  EP=PROG02,DCB=PRIVLIB\n         ST    R0,EPAP2            SAVE ENTRY POINT OF PROG02\n         BR    R6\n         ...\nEPAP2    DS    F\nPRIVLIB  DCB   DSORG=PO,MACRF=R,DDNAME=PRIVLIB\n*\n*\n*\n*\n* JCL DD STSTEMENT:\n*\n*\n*    //PRIVLIB DD DSN=USER.LOADLIB1,DISP=SHR\n*    //        DD DSN=USER.LOADLIB2,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040503": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00(\\x00(\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.5.3\n*\n*\nLOAD03   LA    R7,CHKERR3          LOAD ADR OF RECVRY CHK RTN\n         LOAD  EP=PROG03,ERRET=LOADERR3\n         BR    R6                  RETURN TO CALLING RTN\nCHKERR3  C     R15,BIN4            CHK IF RECOVERY POSSIBLE\n         BE    LOAD03              IF YES, TRY LOAD AGAIN\n         ABEND ...                 IF NO, ABEND\n         ...\nLOADERR3 C     R1,ERR106           CHK FOR S106 ABEND\n         BE    CHKER106            IF S106, CHK REASON CODE\n         C     R1,ERR806           CHK FOR S806 ABEND\n         BE    NOPROG              IF YES, IND PGM NOT FOUND\n         LA    R15,8               INDICATE NON-RECVRY ERROR\n         BR    R7                  RETURN TO LOAD RTN\nCHKER106 C     R15,BIN12           CHK REASON CODE FOR NO VIR STOR\n         BE    NOVSTOR             IF YES, ATTEMPT RECVRY\n         LA    R15,8               INDICATE NON-RECRY ERROR\n         BR    R7                  RETURN TO LOAD RTN\nNOVSTOR  CLI   RCVRYSW,C'1'        CHK IF RECRY ALREADY ATTEMPTED\n         BE    NOVSRCRY            IF YES, NON-RECVRY ERROR\n         DELETE ...                DELETE NOT NEEDED PRGMS\n         FREEMAIN ...              FREE NOT NEEDED VIRT STORAGE\n         MVI   RCVRYSW,C'1'        INDICATE RECVRY ATTEMPTED\n         LA    R15,4               INDICATE TRY LOAD AGAIN\n         BR    R7                  RETURN TO LOAD RTN\nNOVSRCRY WTO   '*** INSUFFICIENT VIRTUAL STORAGE FOR PROG03 ***'\n         LA    R15,8               IND NON-RECRY ERROR\n         BR    R7                  RETURN TO LOAD RTN\nNOPROG   WTO   '*** PROGRAM PROG03 NOT FOUND ***'\n         LA    R15,8               IND NON-RECRY ERROR\n         BR    R7                  RETURN TO LOAD RTN\n         ...\nRCVRYSW  DC    C'0'\nBIN4     DC    F'4'\nBIN12    DC    F'12'\nERR106   DC    X'00000106'\nERR806   DC    X'00000806'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040601": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00(\\x00(\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.6.1\n*\n*\n* CALLING PROGRAM:\n*\n*\n         LA    R10,CODE2\n         LINK  EP=PROG02,PARAM=(CODE1,(R10),RESPONSE)\n         LTR   R15,R15             TEST RC FROM CALLED PROGRAM\n         BZ    LISTRESP\n         ...\nLISTRESP MVC   #INFO01,RESPONSE\n         ...\nCODE1    DC    C'123'\nCODE2    DC    C'XYZ'\nRESPONSE DS    CL10\nLINE     DS    0CL133\n         ...\n#INFO01  DS    CL10\n*\n*\n*\n*\n* CALLED PROGRAM:\n*\n*\nPROG02   CSECT\n         INITL 3,EQU=R\n         L     R10,0(0,R1)         LOAD ADDR OF 1ST PARM (CODE1)\n         L     R11,4(0,R1)         LOAD ADDR OF 2ND PARM (CODE2)\n         L     R12,8(0,R1)         LOAD ADDR OF 3RD PARM (RESPONSE)\n         ...\n         MVC   0(L'INFORM01,R12),INFORM01  PUT REPLY INTO 3RD PARM AREA\n         ...\n         RCNTL RC=0\n         ...\nINFORM01 DC    CL10'...'           INFORMATION FOR CODE: ABC/XYZ\n         ...\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040602": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.6.2\n*\n*\nGETNXADR   TM    0(R1),X'80'       CHK FOR HI ORDER BIT ON\n           BO    PARMEND           IF ON, END OF PARMLIST\n           L     R10,0(0,R1)       LOAD PARM ADR IN REG 10\n           LA    R1,4(0,R1)        INCR TO NEXT FWD ADR\n           LA    R15,0             IND THAT PARM ADR IS NOT LAST ONE\n           BR    R6                RETURN TO CALLING RTN\nPARMEND    L     R10,0(0,R1)       LOAD LAST PARM ADR INTO REG 10\n           LA    R15,4             IND THAT THIS IS LAST ADR\n           BR    R6                RETURN TO CALLING RTN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040701": {"ttr": 1556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.7.1\n*\n*\n         BAL   R6,GETMAIN\n         B     DOXCTL\n         ...\nGETMAIN  GETMAIN EC,LV=x,A=PARMADR\n         ...\n         BR    R6\n         ...\nDOXCTL   L     R13,4(0,R13)        RESTORE ADR OF PREV PROG SA\n         L     R14,12(0,R13)       RESTORE RET ADR OF PREV PROG\n         L     R1,PARMADR          LOAD PARMLIST ADR\n         XCTL  (R2,R12),EP=PROG04\n         ...\nPARMADR  DS    F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040801": {"ttr": 1558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00(\\x00(\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.8.1\n*\n*\n* PARENT TASK:\n*\n*\n         ATTACH EP=PROGS1\n         ...\n         ATTACH EP=PROGS2,DCB=PRIVLIB,TASKLIB=ST2LIB\n*\n*\n*\n*\n* SUBTASK-1:\n*\n*\n         LOAD  EP=PROGS1A\n*\n*\n*\n*\n* SUBTASK-2:\n*\n*\n         LOAD  EP=PROGS2A\n         ...\n         LOAD  EP=PROGS2B,DCB=PRIVLIB2\n*\n*\n*\n*\n* SELECTED JCL DD STATEMENTS FOR JOB STEP:\n*\n*\n*    //STEPLIB  DD DSN=USER.LOADLIB,DISP=SHR\n*    //PRIVLIB  DD DSN=PRIV.LOADLIB,DISP=SHR\n*    //PRIVLIB2 DD DSN=PRIV.LOADLIB2,DISP=SHR\n*    //ST2LIB   DD DSN=SUBT.LOADLIB,DISP=SHR\n*    //         DD DSN=SUBT.LOADLIB2,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040802": {"ttr": 1560, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.8.2\n*\n*\n* PARENT TASK:\n*\n*\n         ATTACH EP=PROGSUB1,PARAM=EXECIND\n         ...\nSTOPSUB  MVI   EXECIND,C'S'        DIRECT SUBTASK TO STOP\n         BR    R7                  RETURN TO CALLING RTN\n         ...\nEXECIND  DC    C'E'                INIT INDICATOR, \"E\" FOR EXECUTE\n*\n*\n*\n*\n* SUBTASK:\n*\n*\nCHKIND   L     R10,INDADR          LOAD ADR OF EXECIND PARM FIELD\n         CLI   0(R10),'S'          CHK IF PARENT IS REQ TERMINATION\n         BE    STASKEND            IF YES, TERMINATE\n         BR    R7                  IF NO, RETURN TO CALLING RTN\n         ...\nINDADR   DS    F\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE040803": {"ttr": 1562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.8.3\n*\n*\nATTACHS1 XC    ECBS1,ECBS1         CLEAR ECB FOR ATTACH\n         ATTACH EP=INQUIRY,PARAM=(REQCODE,REQINFO),ECB=ECBS1\n         ST    R1,TCBADRS1         SAVE TCB ADR OF SUBTASK\n         BR    R7                  RETURN TO CALLING RTN\n         ...\nCHKECBS1 TM    ECBS1,X'40'         CHECK IF POST BIT ON\n         BO    S1END               IF YES, DETACH SUBTASK\n         LA    R15,4               INDICATE SUBTASK NOT COMPLETE\n         BR    R7                  RETURN TO CALLING RTN\nS1END    DETACH TCBADRS1           REMOVE SUBTASK'S TCB\n         LA    R15,0               INDICATE SUBTASK COMPLETE\n         BR    R7                  RETURN TO CALLING RTN\n         ...\nMAINEND  WAIT  1,ECB=ECBS1         PARENT TASK INACTIVE/END,\n*                                  WAIT FOR SUBTASK END\n         DETACH TCBADRS1           REMOVE SUBTASK'S TCB\n         BR    R7                  RETURN TO CALLING RTN\n         ...\nECBS1    DS    F\nTCBADRS1 DS    F\nREQCODE  DS    CL4\nREQINFO  DS    CL20\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040901": {"ttr": 1564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.9.1\n*\n*\n* WAIT FOR ONE EVENT:\n*\n*\n         WAIT ECB=ECB01\n         ...\nECB01    DC    F'0'\n*\n*\n*\n*\n* WAIT FOR MULTIPLE EVENTS:\n*\n*\n         WAIT  3,ECBLIST=ECBLIST1\n         ...\nECBLIST1 DC    A(ECB01)\n         DC    A(ECB02)\n         DC    A(ECB03)\n         DC    A(ECB04)\n         DC    X'80'\n         DC    AL3(ECB05)\n*\nECB01    DC    F'0'\nECB02    DC    F'0'\nECB03    DC    F'0'\nECB04    DC    F'0'\nECB05    DC    F'0'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040902": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.9.2\n*\n*\nTESTECB  TM    ECB01,X'40'         TEST IF ECB HAS BEEN POSTED\n         BO    POSTED              YES, ECB POSTED\n         BR    R6                  NO, CONTIN PROC, CHK AGAIN LATER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE040903": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.9.3\n*\n*\nPOSTECB  L     R12,ECBADR          LOAD ECB ADR\n         L     R10,0(0,R12)        LOAD CONTENTS OF ECB\n         L     R11,NEWECB          LOAD CONTENTS OF NEW ECB\n         TM    0(R12),X'80'        CHECK IF WAIT ISSUED\n         BO    DOPOST              IF YES, ISSUE POST MACRO\n         CS    R10,R11,0(R12)      IF NO, TRY QUICK POST\n         BC    4,DOPOST            IF UNSUCCESSFUL, ISSUE POST MACRO\n         BR    R6                  IF OK, RETURN TO CALLING RTN\nDOPOST   POST  (R12),255\n         BR    R6                  RETURN TO CALLING RTN\n\nECBADR   DS    F\nNEWECB   DC    X'400000FF'         ECB WITH POST BIT ON AND CC=255\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041001": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.10.1\n*\n*\n         BAL   R6,UPDATE          UPDATE EMPLY INFO FILE\n         ...\nUPDATE   BAL   R7,DOENQ           DO ENQ BEFORE UPDATE\n         LTR   R15,R15            CHK IF IN CONTROL OF RESOURCE\n         BZ    DOUPDT             IF YES, DO UPDATE\n         MVI   NOUPDTSW,C'1'      IF NO, INDICATE IT\n         BR    R6                 RET TO CALLING RTN, TRY UPDATE LATER\nDOUPDT   MVI   NOUPDTSW,C'0'      INDICATE UPDATE WILL BE DONE\n         ...                      DO UPDATE\n         BAL   R7,DODEQ           DO DEQ AFTER UPDATE\n         BR    R6                 RETURN TO CALLING RTN\n         ...\nDOENQ    ENQ   (QNAME,RNAME,E,,SYSTEMS),RET=USE\n         BR    R7                 RETURN TO CALLING RTN\n         ...\nDODEQ    DEQ   (QNAME,RNAME,,SYSTEMS),RET=HAVE\n         BR    R7                 RETURN TO CALLING RTN\n         ...\nNOUPDTSW DC    C'0'\nQNAME    DC    CL8'EMPINFO'\nRNAME    DC    C'DEPT850'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041002": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.10.2\n*\n*\n         ENQ   (QNAME1,RNAME1,S,,STEP,QNAME2,RNAME2,E,,STEP),RET=TEST\n         LTR   R15,R15            TEST IF ALL SPEC RSRCS ARE AVAIL\n         BZ    RSRCAVAL           YES, ALL SPEC RSRCS ARE AVAIL\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041101": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.11.1\n*\n*\n         BAL   R6,GETVSER          OBTAIN VOLSER FROM USER\n         BAL   R6,SCANUCBS         SCAN UCB TABLE FOR VOLSER\n         BAL   R6,GETUADR          GET CORRESPONDING UNIT ADR\n         BAL   R6,DPLYINFO         MODIFY AND DSPLY WTO MSG\n         ...\nDPLYINFO MVC   W1VOLSER,VOLSER     MOVE VOLSER INTO WTO MSG\n         MVC   W1UNADR,UNITADR     MOVE UNIT ADR INTO WTO MSG\n         LA    R1,WTOLST1          SET R1 TO POINT TO WTO LIST\n         WTO   MF=(E,(R1))         ISSUE EXEC FORM OF WTO\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nWTOLST1  DC    AL2(WTOLST1X-WTOLST1)\n         DC    H'0'\n         DC    C'VOLSER '\nW1VOLSER DS    CL6\n         DC    C' IS MOUNTED ON '\nW1UNADR  DS    CL3\nWTOLST1X EQU   *\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041102": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.11.2\n*\n*\n         CNOP  0,4\nWTO1LST  DC    AL2(WTO1LSTX-WTO1LST)\n         DC    X'8000'             INDICATE DESC/ROUTCDE INCLUDED\n         DC    C'*** ACTUAL MESSAGE ***'\nWTO1LSTX EQU   *\n         DC    X'0000'             DESC DEFAULT\n         DC    X'0020'             ROUTCDE=11\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041201": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00!\\x00!\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.12.1\n*\n*\nWTOR01   XC    ECB01,ECB01         CLEAR ECB BEFORE WTOR\n         MVC   REPLY01,BLANKS      INIT REPLY AREA TO BLANKS\n         WTO   '*** REPLY \"F1\" FOR FUNCTION-1 PROCESSING;'\n         WTO   '*** REPLY \"F2\" FOR FUNCTION-2 PROCESSING; OR'\n         WTOR  '*** REPLY \"T\" TO TERMINATE PROGRAM',REPLY01,2,ECB01\n         WAIT  1,ECB=ECB01         WAIT FOR REPLY\n         CLC   REPLY01,=C'F1'      CHK REPLY FOR FUNC-1 PROC\n         BE    SETF1               IF YES, IND IT\n         CLC   REPLY01,=C'F2'      CHK REPLY FOR FUNC-2 PROC\n         BE    SETF2               IF YES, IND IT\n         CLC   REPLY01,=C'T '      CHK REPLY FOR TERMINATION\n         BE    SETEND              IF YES, IND IT\n         WTO   '*** INVALID REPLY ***'\n         B     WTOR01              REISSUE WTOR\nSETF1    DS    0H\n         ...\n         BR    R6                  RETURN TO CALLING RTN\n*\nSETF2    DS    0H\n         ...\n         BR    R6                  RETURN TO CALLING RTN\n*\nSETEND   DS    0H\n         ...\n         BR    R6                  RETURN TO CALLING RTN\n*\nECB01    DS    F\nREPLY01  DS    CL2\nBLANKS   DC    CL2' '\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE041202": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00*\\x00*\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.12.2\n*\n*\n         BAL   R6,WTOR02           ISSUE OUTSTANDING WTOR\nCONTIN   BAL   R6,PROCESS          PROCESS A UNIT OR WORK\n         BAL   R6,TESTWR02         CHECK IF WTOR HAS REPLY\n         B     CONTIN              CONTINUE PROCESSING\n*\nWTOR02   XC    ECB02,ECB02         CLEAR ECB FOR WTOR\n         L     R10,=A(L'REPLY02)   LOAD REPLY LEN IN R10 FOR WTOR\n         WTOR  '*** REPLY \"S\" FOR ORDERLY SHUTDOWN ***',REPLY02,(R10), -\n               ECB02\n         BR    R6                  RETURN TO CALLING RTN\n*\nPROCESS  CLI   SDSW,C'1'           CHECK IF SHUTDOWN REQUESTED\n         BE    SHUTDOWN            IF YES, GO TO SHUTDOWN RTN\n         ...                       IF NO, PERFORM NORMAL PROCESSING\n         BR    R6                  RETURN TO CALLING RTN\n*\nSHUTDOWN DS    0H\n         ...                       PERFORM SHUTDOWN PROCESSING\n*\nTESTWR02 TM    ECB02,X'40'         CHECK IF WTOR ECB POSTED\n         BO    CHKREPLY            IF YES, CHECK REPLY\n         BR    R6                  IF NO, RETURN TO CALLING RTN\nCHKREPLY CLI   REPLY02,C'S'        CHK IF SHUTDOWN REQ\n         BE    SETSD               IF YES, IND IT\n         CLI   REPLY02,X'A2'       CHECK FOR LOWER CASE \"S'\n         BE    SETSD               IF YES, IND IT\n         WTO   '*** INVALID REPLY ***'\n         ST    R6,SAVR6            SAVE RETURN ADDRESS\n         BAL   R6,WTOR02           REISSUE WTOR\n         L     R6,SAVR6            RESTORE RETURN ADDRESS\n         BR    R6                  RETURN TO CALLING RTN\nSETSD    MVI   SDSW,C'1'           INDICATE SHUTDOWN REQUESTED\n         BR    R6                  RETURN TO CALLING RTN\n*\nECB02    DS    F\nSAVR6    DS    F\nREPLY02  DS    CL1\nSDSW     DC    C'0'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE041203": {"ttr": 1809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00 \\x00 \\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.12.3\n*\n*\nWTOR03   XC    ECB03,ECB03         CLEAR ECB FOR WTOR\n         WTO   '*** ERRORS DETECTED IN PARAMETERS FOR JOB jjjjjjjj ***'\n         WTO   '*** SHOULD PROCESSING CONTINUE WITH DEFAULTS ... ***'\n         WTOR  '*** REPLY \"Y\" FOR YES, OR \"T\" TO TERMINATE JOB ***',   -\n               REPLY03,1,ECB03\nSETWAIT  STIMER WAIT,DINTVL=WR3WTTME\n         TM    ECB03,X'40'         CHECK IF ECB POSTED\n         BO    CHKREPLY            IF YES, CHECK REPLY\n         WTO   '*** OPERATOR, PLEASE REPLY TO OUTSTANDING MESSAGE FOR J-\n               OB: xxxxxxxx ***',DESC=11\n         B     SETWAIT             REISSUE WAIT\nCHKREPLY CLI   REPLY03,C'Y'        CHK IF DEFAULT REQ\n         BE    SETDFLT             IF YES, IND IT\n         CLI   REPLY03,C'T'        CHK IF TERMINATION REQ\n         BE    SETTERM             IF YES, IND IT\n         WTO   '*** INVALID REPLY ***'\n         B     WTOR03              REISSUE WTOR\nSETDFLT  MVI   DFLTSW,C'1'         IND DEFAULT USAGE\n         BR    R6                  RETURN TO CALLING RTN\nSETTERM  MVI   TERMSW,C'1'         IND TERMINATION\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nECB03    DS    F\nREPLY03  DS    CL1\nDFLTSW   DC    C'0'\nTERMSW   DC    C'0'\n         DS    0D\nWR3WTTME DC    C'00001500'         15 SECONDS WAIT TIME\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE041301": {"ttr": 1811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.1\n*\n*\n         GETMAIN EC,LV=2000,A=VSADR\n         LTR   R15,R15               CHK IF GM ALLO OK\n         BNZ   GMERR\n         L     R10,VSADR             LOAD VS ADR INTO REG 10 (TO USE IT)\n         BR    R6                    RETURN TO CALLING RTN\n         ...\nVSADR    DS    F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041302": {"ttr": 1813, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.2\n*\n*\n         GETMAIN LU,LA=GMLENS,A=GMADRS,SP=10\n         ...\nGMLENS   DS    0F\nGMLEN1   DC    A(1000)\nGMLEN2   DC    A(5000)\nGMLEN3   DC    X'80'\n         DC    AL3(2000)\n*\nGMADRS   DS    0F\nGMADR1   DS    F\nGMADR2   DS    F\nGMADR3   DS    F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041303": {"ttr": 1815, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.3\n*\n*\nGETVS    GETMAIN VC,LA=GMREQLEN,A=GMRESP\n         LTR   R15,R15             CHECK IF VS OBTAINED\n         BZR   R6                  IF YES, RET TO CALLING RTN\n         B     NOVS                IF NO, VS NOT AVAILABLE\n         ...\nGMREQLEN DS    0F\nGMMIN    DC    A(4096)             MINIMUM STOR REQUESTED\nGMMAX    DC    A(16384)            MAXIMUM STOR REQUESTED\n*\nGMRESP   DS    0F\nGMVADR   DS    F                   RETURNED ADR OF ALLO STOR\nGMVLEN   DS    F                   RETURNED LEN OF ALLO STOR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041304": {"ttr": 1817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.4\n*\n*\n         LA    R10,25              LOAD SP NUMBER INTO R10\n         GETMAIN RC,LV=4096,SP=(R10)\n         LTR   R15,R15             CHECK IF VS OBTAINED\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041305": {"ttr": 1819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.5\n*\n*\n         FREEMAIN EC,LV=2000,A=VSADR\n         LTR   R15,R15             CHECK IF VS RELEASED\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041306": {"ttr": 1821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.6\n*\n*\n         L     R10,GMLEN2\n         LA    R11,GMADR2\n         FREEMAIN EU,LV=(R10),A=(R11),SP=10\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041307": {"ttr": 1823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.7\n*\n*\n         MVC   FMLEN1,GMLEN3       MOVE LEN OF 1ST VS AREA\n         NI    FMLEN1,X'7F'        TURN OFF HI ORDER BIT\n         MVC   FMADR1,GMADR3       MOVE ADR OF 1ST VS AREA\n         MVC   FMLEN2,GMVLEN       MOVE LEN OF 2ND VS AREA\n         OI    FMLEN2,X'80'        TURN ON HI ORDER BIT\n         MVC   FMADR2,GMVADR       MOVE ADR OF 2ND VS AREA\n         FREEMAIN LC,LA=FMLENS,A=FMADRS\n         LTR   R15,R15             CHECK FOR GOOD FREEMAIN\n         ...\nFMLENS   DS    0F\nFMLEN1   DS    F                   LEN OF STOR AREA-1\nFMLEN2   DS    F                   LEN OF STOR AREA-2\n*\nFMADRS   DS    0F\nFMADR1   DS    F                   ADR OF STOR AREA-1\nFMADR2   DS    F                   ADR OF STOR AREA-2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041308": {"ttr": 1825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.13.8\n*\n*\n         FREEMAIN RC,SP=25\n         LTR   R15,R15\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041401": {"ttr": 1827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.14.1\n*\n*\n         STIMER WAIT,DECINTVL=WAITTIME\n         ...\n         ...   *** CODE TO RECEIVE CONTROL AFTER STIMER WAIT ***\n         ...\n         DS    0D\nWAITTIME DC    C'00073000'         7 MINS, 30 SECS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041402": {"ttr": 1829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x008\\x008\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.14.2\n*\n*\nMAINPGM  CSECT\nR0       EQU   0\n         ...\nR15      EQU   15\n         STM   R14,R12,12(R13)    SAVE REGS INTO CALLERS SA\n         BALR  R3,0               LOAD 1ST BASE REGISTER\n         USING *,R3,R4            ASSIGN R3 AND R4 AS BASE REGS\nBASEBG   LA    R4,4095            \\ LOAD 2ND BASE REGISTER\n         LA    R4,1(R3,R4)        /\n         ...\n         ...                      *** CODE FOR SA LINKAGE ***\n         ...\n         B     MAINCODE           BRANCH TO MAIN PROGRAM\n*\nXOFFSET  EQU   EXITRTN-BASEBG     OFFSET BETW 1ST BASE REG ADR AND EXIT\n*\nEXITRTN  STM   R14,R12,12(R13)    SAVE REGS IN SYS PROV SA\n         LR    R3,R15             LD MAIN PGM BASE REG WITH EXIT EPA\n         LA    R15,XOFFSET        LD OFFSET OF EXIT FROM MAIN PGM BASE\n         SR    R3,R15             LOAD 1ST BASE REG TO ADR SET BY\n*                                 MAIN PGM\n         LA    R4,4095            \\ LOAD 2ND BASE REG TO ADR SET\n         LA    R4,1(R3,R4)        / BY THE MAIN PGM\n         LR    R12,R13            SAVE ADR OF SYS PROV SA\n         LA    R13,EXITSA         LOAD ADR OF EXIT SA\n         ST    R12,4(0,R13)       SAVE SYS PROV SA ADR IN OWN SA\n         ST    R13,8(0,R12)       SAVE OWN SA ADR IN SYS PROV SA\n         ...\n         ...                      *** CODE FOR EXIT ROUTINE ***\n         ...\n         MVI   EXITSW,C'1'        SET SW TO IND TIME INTV EXPIRED\n         ...\n         ...\n         L     R13,4(0,R13)       RESTORE SYS PROV SA ADR\n         LM    R14,R12,12(R13)    RESTORE REGISTERS\n         BR    R14                RETURN TO MVS\nEXITSA   DS    18F\n*\nMAINCODE ...                      *** CODE FOR MAIN PROGRAM ***\n         ...\n         STIMER TASK,EXITRTN,DINTVL=TIME01\n         ...\n         ...                      *** CODE FOR MAIN PROGRAM ***\n         ...\n         CLI   EXITSW,C'1'        CHK IF TIME INTV EXPIRED\n         BE    TIMEEND\n         ...\n*\nTIME01   DC    C'00100000'        TASK TIME INTERVAL - 10 MINUTES\nEXITSW   DC    C'0'               SW FOR TIME INTV EXPIRATION\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041501": {"ttr": 1831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.15.1\n*\n*\n         STIMER TASK,EXITRTN,DINTVL=TIMEINTV\n         ...\n         TTIMER ,MIC,TIMELEFT\n         LA    R8,0                CLEAR R8 FOR MR INSTR\n         L     R9,TIMELEFT         EXTRACT HI-ORDER 4 BYTES\n         L     R10,ONEMEG          LD R10 WITH 1024 X 1024 FOR DR INSTR\n         MR    R8,R10              HI-ORDER 4 BYTES VALUE X 1024 X 1024\n         L     R10,ONEMIL          LD R10 WITH 1 MILLION FOR DR INSTR\n         DR    R8,R10              DIV BY 1 MILLION TO GET SECONDS\n         CVD   R9,PKSECS           CONV BIN SECS INTO PACK SECS\n         ...\nTIMELEFT DS    D\nONEMEG   DC    X'00100000'         1024 X 1024\nONEMIL   DC    A(1000000)          1,000,000\nPKSECS   DS    D\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041502": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.15.2\n*\n*\n         STIMER REAL,EXITRTN,TOD=JOBTIME\n         ...\nNEXTDATA BAL   R6,GETDATA          RECEIVE DATA\n         BAL   R6,VALIDATE         VALIDATE DATA\n         BAL   R6,EDIT             EDIT DATA\n         BAL   R6,PUTFILE          WRITE RECS TO ACTIVE FILE\n         BAL   R6,CHKTIME          CHECK IF TIME TO SUBMIT JOB\n         B     NEXTDATA            PROCESS NEXT GROUP OF DATA\n*\nDATAEND  TTIMER CANCEL             ALL DATA PROC, CANCEL TIME EXIT\n         BAL   R7,CLOSE            CLOSE FILES\n         BAL   R7,SUBMIT           SUBMIT JOB\n         ...\nCHKTIME  CLI   TIMESW,C'1'         CHK IF TIME EXIT ENTERED\n         BNER  R6                  IF NO, CONTIN PROC\n         BAL   R7,FLIPFILE         IF YES, FLIP FLOP OUTPUT FILES\n         BAL   R7,SUBMIT           SUBMIT JOB\n         ...\n*\nEXITRTN  ...                       INITIALIZE AS C.E. 4.14.2\n         MVI   TIMESW,C'1'         INDICATE THAT TIME EXIT ENTERED\n         ...\n         BR    R14                 RETURN TO MVS\n         ...\nTIMESW   DC    C'0'\nJOBTIME  DC    C'18000000'         TOD = 6:00 PM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041503": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x002\\x002\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.15.3\n*\n*\n         BAL   R6,SETTIMER         SET PROGRAM TIMER\nCONTIN   BAL   R6,PROCESS          PERFORM SOME PROCESSING\n         BAL   R6,CHKTIME          CHK IF A TIME INTV HAS ELAPSED\n         B     CONTIN              PERFORM SOME MORE PROCESSING\n         ...\nSETTIMER STIMER REAL,DINTVL=TIMEINTV    *** NOTICE, NO EXIT ADR ***\n         LA    R10,TIMETBL         LOAD BG ADR OF TIME TBL\n         ST    R10,TMTBLPTR        STORE ADR OF 1ST ENTRY\n         BR    R6                  RETURN TO CALLING RTN\n*\nPROCESS  ...\n         BR    R6                  RETURN TO CALLING RTN\n*\nCHKTIME  CLI   TMENDSW,C'1'        CHK IF ALL TIME INTV PROCESSED\n         BER   R6                  IF YES, RET TO CALLING RTN\n         TTIMER ,MIC,TIMELEFT      IF NO, GET TIME LEFT\n         BAL   R7,CVTOSECS         CONVERT MICROSECS INTO PACKED SECS\n         L     R10,TMTBLPTR        LOAD CURRENT TIME TBL ENTRY ADR\n         CP    SECSLEFT,0(8,R10)   CHK IF CURRENT TIME INTV ELAPSED\n         BNH   DOACTION            IF YES, PERFORM ACTION\n         BR    R6                  IF NO, RET TO CALLING RTN\nDOACTION BAL   R7,PERFORM          PERFORM TIME DEPENDENT ACTION\n         CP    0(8,R10),PACKZERO   CHK IF LAST TIME INTERVAL\n         BE    ALLDONE             IF YES, INDICATE IT\n         LA    R10,8(0,R10)        IF NO, INCR TO NXT TIME TBL ENT ADR\n         ST    R10,TMTBLPTR        STORE NEW TIME TBL ENTRY ADR\n         BR    R6                  RETURN TO CALLING RTN\nALLDONE  MVI   TMENDSW,C'1'        INDICATE ALL TIME INTV PROCESSED\n         BR    R6                  RETURN TO CALLING RTN\n*\nCVTOSECS ...                       *** SEE C.E. 4.15.1 ***\n         BR    R7                  RETURN TO CALLING RTN\n*\nPERFORM  ...                       PERFORM ACTION FOR EACH INTERVAL\n         BR    R7                  RETURN TO CALLING RTN\n         ...\n*\nTMENDSW  DC    C'0'\nTIMEINTV DC    C'01000000'         1 HOUR TIME INTERVAL FOR STIMER\nTIMETBL  DC    PL8'3000'           10 MINUTES ELAPSED (3000 SECS LEFT)\n         DC    PL8'900'            45 MINUTES ELAPSED (900 SECS LEFT)\n         DC    PL8'0'              1 HOUR ELAPSED (O SECS LEFT)\nTMTBLPTR DS    F\nTIMELEFT DS    D\nSECSLEFT DS    D                   PACKED SECONDS FROM CVTOSECS RTN\nPACKZERO DC    P'0'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041601": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.16.1\n*\n*\n         TIME  DEC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041701": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.17.1\n*\n*\n         OPEN  (SNAPDCB,(OUTPUT))\n         ...\n         SNAP  DCB=SNAPDCB,STORAGE=(BG1,END1,BG2,END2,(R10),(R11)),    -\n               ID=10,STRHDR=(HDR1,,HDR2),SDATA=(CB),                   -\n               PDATA=(PSW,REGS,SPLS)\n         ...\nBG1      EQU   *\n         ...   SECTION OF PROGRAM TO BE DUMPED\nEND1     EQU   *\n         ...\nBG2      EQU   *\n         ...   SECTION OF PROGRAM TO BE DUMPED\nEND2     EQU   *\n         ...\nHDR1     DC    AL1(L'HDR1TXT)\nHDR1TXT  DC    C'*** STORAGE AREA-1 ***'\nHDR2     DC    AL1(L'HDR2TXT)\nHDR2TXT  DC    C'*** STORAGE AREA-2 ***'\n         ...\nSNAPDCB  DCB   DSORG=PS,MACRF=W,RECFM=VBA,BLKSIZE=1632,LRECL=125,      -\n               DDNAME=SNAPDUMP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041702": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00(\\x00(\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.17.2\n*\n*\n         OPEN  (SNAPDCB,(OUTPUT))\n         ...\n         ST    R10,BGADR5\n         ST    R11,ENDADR5\n         OI    ENDADR5,X'80'       SET END OF ADDRESS INDICATOR\n         SNAP  DCB=SNAPDCB,LIST=DUMPLST1,STRHDR=HDRLST1,               -\n               PDATA=(PSW,REGS,JPA),SDATA=(CB,DM)\n         ...\nBG3      EQU   *\n         ...   SECTION OF PROGRAM TO BE DUMPED\nEND3     EQU   *\n         ...\nBG4      EQU   *\n         ...   SECTION OF PROGRAM TO BE DUMPED\nEND4     EQU   *\n         ...\nDUMPLST1 DC    A(BG3)\n         DC    A(END3)\n         DC    A(BG4)\n         DC    A(END4)\nBGADR5   DS    F\nENDADR5  DS    F\n*\nHDRLST1  DC    A(HDR3)\n         DC    A(HDR4)\n         DC    X'80',AL3(HDR5)\n*\nHDR3     DC    AL1(L'HDR3TXT)\nHDR1TXT  DC    C'*** STORAGE AREA-3 ***'\nHDR4     DC    AL1(L'HDR4TXT)\nHDR2TXT  DC    C'*** STORAGE AREA-4 ***'\nHDR5     DC    AL1(L'HDR5TXT)\nHDR3TXT  DC    C'*** STORAGE AREA-5 ***'\n         ...\nSNAPDCB  DCB   DSORG=PS,MACRF=W,RECFM=VBA,BLKSIZE=1632,LRECL=125,      -\n               DDNAME=SNAPDUMP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041703": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x98\\x00\\x98\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.17.3\n*\n*\n         MACRO\n&LABEL   SNAPA &BGADR,&ENDADR,&DATA=O,&SNAP=O\n         GBLA  &SNAPA\n         GBLC  &SNAPA1\n         LCLA  &SUB,&OPT,&JLPA,&CB,&SPLS,&NOADRSW\n         LCLC  &LBL\n&SNAPA   SETA  &SNAPA+1\n&LBL     SETC  '$'.'SNP'.'&SYSNDX'(2,3)\n         AIF   (&SNAPA GT 1).B7\n&SNAPA1  SETC  '&LBL'\n.B7      ANOP\n&LABEL   STM   14,1,&SNAPA1\n         AIF   (&SNAPA GT 1).B1\n         B     &LBL.A\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=W,BLKSIZE=882,LRECL=125,       -\n               DDNAME=SNAPDUMP\n&SNAPA1  DS    4F\n&LBL.A   EQU   *\n         OPEN  (SNAPDCB,(OUTPUT))\n.B1      AIF   ('&SNAP' EQ 'NO').ENDX\n         AIF   (T'&BGADR EQ 'O').NOADR\n         AIF   (T'&ENDADR EQ 'O').NOADR\n         AIF   ('&BGADR'(1,1) EQ '(').BGREG\n         LA    14,&BGADR\n.B6      AIF   ('&ENDADR'(1,1) EQ '(').ENDREG\n         LA    15,&ENDADR\n         AGO   .B2\n.NOADR   ANOP\n&NOADRSW SETA  1\n.B2      ANOP\n         AIF   ('&DATA' EQ 'O').SNAP0\n&SUB     SETA  N'&DATA+1\n.B3      ANOP\n&SUB     SETA  &SUB-1\n         AIF   (&SUB EQ 0).NOMORE\n         AIF   ('&DATA(&SUB)' EQ 'ALL').SNAP1\n         AIF   ('&DATA(&SUB)' EQ 'JLPA').JLPA\n         AIF   ('&DATA(&SUB)' EQ 'CB').CB\n         AIF   ('&DATA(&SUB)' EQ 'SPLS').SPLS\n         MNOTE 'INVALID CODE SPECIFIED---CODE IGNORED'\n         AGO   .B3\n.JLPA    ANOP\n&JLPA    SETA  1\n         AGO   .B3\n.CB      ANOP\n&CB      SETA  1\n         AGO   .B3\n.SPLS    ANOP\n&SPLS    SETA  1\n         AGO   .B3\n.BGREG   AIF   ('&BGADR' EQ '(14)').B6\n         LR    14,&BGADR(1)\n         AGO   .B6\n.ENDREG  AIF   ('&ENDADR' EQ '(15)').B2\n         LR    15,&ENDADR(1)\n         AGO   .B2\n.NOMORE  ANOP\n         AIF   (&JLPA EQ 1).MKJPA\n.B4      AIF   (&CB EQ 1).MKCB\n.B5      AIF   (&SPLS EQ 1).MKSPLS\n         AGO   .CHKOPT\n.MKJPA   ANOP\n&OPT     SETA  &OPT+100\n         AGO   .B4\n.MKCB    ANOP\n&OPT     SETA  &OPT+10\n         AGO   .B5\n.MKSPLS  ANOP\n&OPT     SETA  &OPT+1\n.CHKOPT  AIF   (&OPT EQ 111).SNAP1\n         AIF   (&OPT EQ 110).SNAP2\n         AIF   (&OPT EQ 101).SNAP3\n         AIF   (&OPT EQ 100).SNAP4\n         AIF   (&OPT EQ 11).SNAP5\n         AIF   (&OPT EQ 10).SNAP6\n         AIF   (&OPT EQ 1).SNAP7\n.SNAP0   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP0A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),PDATA=REGS,ID=&SNAPA\n         AGO   .END\n.SNAP0A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=REGS,ID=&SNAPA\n         AGO   .END\n.SNAP1   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP1A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,ALLPA,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP1A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,ALLPA,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP2   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP2A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,ALLPA,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP2A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,ALLPA,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP3   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP3A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),                        -\n               PDATA=(REGS,ALLPA,SPLS),ID=&SNAP\n         AGO   .END\n.SNAP3A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,ALLPA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP4   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP4A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),PDATA=(REGS,ALLPA),     -\n               ID=&SNAPA\n         AGO   .END\n.SNAP4A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,ALLPA),ID=&SNAPA\n         AGO   .END\n.SNAP5   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP5A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP5A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP6   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP6A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP6A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP7   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP7A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),PDATA=(REGS,SPLS),      -\n               ID=&SNAPA\n         AGO   .END\n.SNAP7A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,SPLS),ID=&SNAPA\n.END     ANOP\n*\n         MNOTE *,'ID # FOR THIS SNAP IS &SNAPA'\n*\n.ENDX    LM    14,1,&SNAPA1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041801": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.18.1\n*\n*\n         ABEND 900,DUMP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041802": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.18.2\n*\n*\n         ABEND (R10),,STEP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE041803": {"ttr": 2067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.18.3\n*\n*\n         ABEND X'213',DUMP,,SYSTEM,DUMPOPT=DMOPT01\n         ...\nDMOPT01  SNAP  PDATA=(PSW,REGS),SDATA=(CB,DM,SWA),MF=L\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050101": {"ttr": 2069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.1.1\n*\n*\nPROGRAM  CSECT\nR0       EQU   0                   DEFINE SYMBOLS\n         ...                         FOR\nR15      EQU   15                  REGISTERS\n         STM   R14,R12,12(R13)     SAVE REGS 14 THRU 12 INTO CALLERS SA\n         LR    R2,R13              SAVE CALLERS SA ADDR IN REG 2\n         BALR  R12,0               LOAD REG 12 WITH NEXT INSTR ADDR\n         BAL   R13,76(0,R12)       LOAD REG 13 WITH ADDR OF OWN SA ADDR\n*                                  AND 1ST 4K OF PROGRAM ADDRBLTY,\n*                                  THEN BRANCH AROUND OWN SA\nSAVEAREA DS    18F                 DEFINE OWN 72 BYTE SAVEAREA\n         USING SAVEAREA,R13,R3,R4  TELL ASMBLR, REGS 13, 3, & 4 WILL BE\n*                                  BASE REGS AND RELATIVE ADDR OF THEM\n         LA    R3,4095             LOAD REG 3 WITH 4K-1 FOR NEXT INSTR\n         LA    R3,1(R13,R3)        LOAD REG 3 WITH ADR 4K PAST REG 13\n         LA    R4,4095             LOAD REG 4 WITH 4K-1 FOR NEXT INSTR\n         LA    R4,1(R3,R4)         LOAD REG 4 WITH ADR 4K PAST REG 3\n         ST    R2,4(0,R13)         SAVE CALLERS SA ADR INTO OWN SA+4\n         ST    R13,8(0,R2)         SAVE OWN SA ADDR INTO CALLERS SA+8\n*\n*        ...                       MAINSTREAM OF PROGRAM STARTS HERE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050201": {"ttr": 2071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.2.1\n*\n*\n         L     R1,0(0,R1)         LOAD JCL PARM LEN/DATA ADR INTO REG 1\n         LH    R15,0(0,R1)        LOAD LEN OF JCL PARM INTO REG 15\n         LA    R1,2(0,R1)         LOAD ADR OF JCL PARM INTO REG 1\n*\n*\n         LTR   R15,R15            TEST REG 15 FOR ZERO\n         BZ    NOPARM             IF ZERO, NO PARM SPECIFIED\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050202": {"ttr": 2073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.2.2\n*\n*\n         LINK  EP=ASMA90,PARAM=APARMLST,VL=1\n         ...\nAPARMLST DC    H'APARMEND-APARMVAL'\nAPARMVAL DC    C'XREF,NOLOAD'\nAPARMEND EQU   *\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050203": {"ttr": 2075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.2.3\n*\n*\n         LINK  EP=IEBCOPY,PARAM=DUMYPARM,VL=1\n         ...\nDUMYPARM DC    H'0'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050301": {"ttr": 2077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x16\\x00\\x16\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.3.1\n*\n*\n0000  EMPLYREC DSECT\n0000  EMPNAME  DS    CL20      EMPLOYEE NAME\n0014  EMPADDR  DS    0CL37     HOME ADDRESS\n0014  EMPSTRET DS    CL15         STREET\n0023  EMPSTATE DS    CL2          STATE\n0025  EMPCITY  DS    CL15         CITY\n0034  EMPZIP   DS    CL5          ZIP CODE\n0039  EMPSSNO  DS    CL9       SOCIAL SECURITY NUMBER\n0042  EMPSDATE DS    CL6       WORK START DATE\n0048  EMPRDATE DS    CL6       REVIEW DATE\n004E  EMPBFLGS DS    CL1       BENEFIT FLAGS\n      EMPBBLIN EQU   X'80'        BIT FOR BASIC LIFE INSURANCE\n      EMPBELIN EQU   X'40'        BIT FOR EXTENDED LIFE INSURANCE\n      EMPBBHIN EQU   X'20'        BIT FOR BASIC HEALTH INSURANCE\n      EMPBMSUR EQU   X'10'        BIT FOR MAJOR SURGERY\n      EMPBDENT EQU   X'08'        BIT FOR DENTAL PLAN\n004F  EMPDEPT  DS    CL10      DEPARTMENT\n0059  EMPSALRY DS    CL9       SALARY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050302": {"ttr": 2079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.3.2\n*\n*\nMAINPGM CSECT\n        ...\n*       MACHINE INSTRUCTIONS, MACROS, AND ASSEMBLER INSTRUCTIONS\n        ...\nDSECT01 DSECT\nD1FLD01 DS    CL10\nD1FLD02 DS    CL10\nD1FLD03 DS    CL10\n*\nMAINPGM CSECT                      CONTINUATION OF CSECT\n        ...\n*       MACHINE INSTRUCTIONS, MACROS, AND ASSEMBLER INSTRUCTIONS\n        ...\n        END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050303": {"ttr": 2081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.3.3\n*\n*\n         USING EMPLYREC,R10         TELL ASM TO USE REG 10 FOR DSECT\n         ...\n         L     R10,EMRECADR         LOAD ADR OF I/O AREA INTO DSECT REG\n         MVC   ##NAME,EMPNAME       REFERENCE A FIELD MAPPED BY DSECT\n         MVC   ##SALARY,EMPSALRY    REFERENCE A FIELD MAPPED BY DSECT\n         ...\nEMRECADR DS    F                    ADDRESS OF I/O AREA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050304": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.3.4\n*\n*\n         USING DSECT01,R10         DEFINE REG FOR DSECT01 DSECT\nRTN001   L     R10,AREA1ADR        LOAD ADR OF AREA MAPPED BY DSECT\n         ...                       REF FIELDS DEFINED IN DSECT01 DSECT\n         BR    R6                  RETURN TO CALLING RTN\n         DROP  R10                 RELEASE DSECT REG\n         ...\n         USING DSECT02,R10         DEFINE REG FOR DSECT02 DSECT\nRTN002   L     R10,AREA2ADR        LOAD ADR OF AREA MAPPED BY DSECT\n         ...                       REF FIELDS DEFINED IN DSECT02 DSECT\n         BR    R6                  RETURN TO CALLING RTN\n         DROP  R10                 RELEASE DSECT REG\n         ...\nAREA1ADR DS    F                   ADDRESS OF AREA MAPPED BY DSECT01\nAREA2ADR DS    F                   ADDRESS OF AREA MAPPED BY DSECT02\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050305": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.3.5\n*\n*\n         LA    R10,IOAREA\n         MVC   ##SALARY,EMPSALRY-EMPLYREC(R10)\n         ...\nEMPLYREC DSECT\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050401": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.4.1\n*\n*\n         MVZ   BYTE1,CHARA\n         MVN   BYTE2,CHARA\n         ...\nCHARA    DC    X'C1'\n*\n*\n* BEFORE EXECUTION:\n*\nBYTE1    DC    X'00'\nBYTE2    DC    X'00'\n*\n*\n* AFTER EXECUTION:\n*\nBYTE1    DC    X'C0'\nBYTE2    DC    X'01'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050402": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.4.2\n*\n*\nHEXTBL   DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'    00-0F\n         DC    X'F1',XL15'00'                         10-1F\n         DC    X'F2',XL15'00'                         20-2F\n         DC    X'F3',XL15'00'                         30-3F\n         DC    X'F4',XL15'00'                         40-4F\n         DC    X'F5',XL15'00'                         50-5F\n         DC    X'F6',XL15'00'                         60-6F\n         DC    X'F7',XL15'00'                         70-7F\n         DC    X'F8',XL15'00'                         80-8F\n         DC    X'F9',XL15'00'                         90-9F\n         DC    X'C1',XL15'00'                         A0-AF\n         DC    X'C2',XL15'00'                         B0-BF\n         DC    X'C3',XL15'00'                         C0-CF\n         DC    X'C4',XL15'00'                         D0-DF\n         DC    X'C5',XL15'00'                         E0-EF\n         DC    X'C6',XL15'00'                         F0-FF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050403": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.4.3\n*\n*\nTRNSLTXC L     R0,HEXLEN           LOAD LENGTH OF HEX STRING TO TRANS\n         LA    R14,HEXLIST         LOAD ADR OF HEX STRING TO TRANS\n         LA    R15,CHARLIST        LOAD ADR OF RECV AREA FOR TRANS\nNEXTCHAR MVZ   BYTE1,0(R14)        ISOLATE HIGH ORDER HEX DIGIT\n         MVN   BYTE2,0(R14)        ISOLATE LOW ORDER HEX DIGIT\n         TR    BYTE1,HEXTBL        TRANS HI ORDER HEX DIGIT INTO CHAR\n         TR    BYTE2,HEXTBL        TRANS LO ORDER HEX DIGIT INTO CHAR\n         MVC   0(1,R15),BYTE1    MOVE 1ST TRANS HEX CHAR INTO RECV AREA\n         MVC   1(1,R15),BYTE2    MOVE 2ND TRANS HEX CHAR INTO RECV AREA\n         LA    R14,1(0,R14)        INCR TO NEXT HEX BYTE\n         LA    R15,2(0,R15)        INCR TO NEXT RECV AREA SLOT\n         BCT   R0,NEXTCHAR         TRANS NEXT HEX BYTE\n         BR    R6                  ALL HEX BYTES TRANS, RET TO CALLING\n*                                  RTN\n         ...\nHEXLIST  DC    C'ABC123',X'04AF'   HEX BYTES TO CONVERT INTO CHAR\nHEXLEN   DC    A(*-HEXLIST)        LENGTH OF HEX STRING TO TRANS\nCHARLIST DS    CL(L'HEXLIST*2)     RECV AREA FOR TRANS\nBTYE1    DC    X'00'\nBYTE2    DC    X'00'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050501": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00#\\x00#\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.5.1\n*\n*\n         LA    R0,ZDNOLEN          LD LENGTH OF FIELD TO VALIDATE\n         LA    R10,ZDNUMB          LD ADR OF FIELD TO VALIDATE\n         BAL   R7,VALDTZD          VALIDATE FIELD FOR ZONED DEC DATA\n         LTR   R15,R15             CHK IF FIELD CONTAIN VALID DATA\n         BZ    DATAOK              IF O, FIELD CONTAINS VALID ZD NUMB\n         B     DATAINV             IF NOT, FIELD CONTAINS INV ZD NUMB\n*\n*\n***********************************************************************\n*   THIS SUBROUTINE CHECKS IF A FIELD OF DATA CONTAINS ZONED DECIMAL\n*   NUMBERS. THIS SUBROUTINE PERFORMES THE VALIDATION BY VERIFYING THAT\n*   EACH BYTE OF THE FIELD IS IN THE RANGE X'F0' TO X'F9'. AN RC IS SET\n*   IN REGISTER 15 FOR THE CALLING ROUTINE; X'00' INDICATES VALID DATA,\n*   X'04' INDICATES INVALID DATA.\n***********************************************************************\n*\nVALDTZD  DS    OH\nNEXTDIG  CLI   0(R10),X'F0'        COMPARE A BYTE OF FIELD TO ZD ZERO\n         BL    BADZDD              IF LESS THAN ZD 0, BAD ZD DATA\n         CLI   0(R10),X'F9'        COMPARE A BYTE OF FIELD TO ZD NINE\n         BH    BADZDD              IF GREATER THAN ZD 9, BAD ZD DATA\n         LA    R10,1(0,R10)        INCR TO NEXT BYTE OF FIELD\n         BCT   R0,NEXTDIG          IF MORE BYTES, COMPARE NEXT ONE\n         LA    R15,0               IF NO MORE BYTES, DATA OK---IND IT\n         BR    R7                  RETURN TO CALLING RTN\nBADZDD   LA    R15,4               INDICATE BAD ZD DATA\n         BR    R7                  RETURN TO CALLING RTN\n*                                  VALIDATED FOR ZONED DECIMAL DATA\nZDNOLEN  EQU   L'ZDNUMB            CONTAINS THE LENGTH OF ZDNUMB\nZDNUMB   DC    ...                 THE FIELD WHICH IS TO BE VALIDATED\n*                                  FOR ZONED DECIMAL DATA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050502": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.5.2\n*\n*\nVALDTZD  TRT   ZDNUMB,TABLE        COMPARE ALL BYTES OF FIELD\n         BC    8,DATAOK            IF CC=0, ALL BYTES CONTAIN ZD\n         LA    R15,4               IF NOT, BAD DATA---IND IT\n         BR    R7                  RETURN TO CALLING RTN\nDATAOK   LA    R15,0               IND GOOD ZD DATA\n         BR    R7                  RETURN TO CALLING RTN\n*\nZDNUMB   DC    ...                 THE FIELD WHICH IS TO BE VALIDATED\n*                                  FOR ZONED DECIMAL DATA\nTABLE    DC    256XL1'01'\n         ORG   TABLE+C'0'\n         DC    10XL1'00'\n         ORG   TABLE+256\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050503": {"ttr": 2319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x003\\x003\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.5.3\n*\n*\n         MACRO\n&LABEL   VALNUMB &ADR,&LEN\n         LCLC  &LBL\n&LBL     SETC  '$'.'VAL'.'&SYSNDX'(2,3)\n         AIF   (T'&ADR EQ 'O').NOADR\n         AIF   ('&ADR'(1,1) EQ '(').REGA\n         AIF   (T'&LEN EQ 'O').ADRONLY\n         AIF   (T'&LEN NE 'N').INVLEN\n&LABEL   TRT   &ADR.(&LEN),&LBL.A\n         AGO   .BC\n.ADRONLY ANOP\n&LABEL   TRT   &ADR,&LBL.A\n.BC      BC    8,&LBL.B\n         B     &LBL.C\n         AGO   .REST\n.REGA    AIF   (T'&LEN EQ 'O').NOLEN\n         AIF   ('&LEN'(1,1) EQ '(').REGAL\n&LABEL   TRT   0(&LEN,&ADR(1)),&LBL.A\n         BC    8,&LBL.B\n         B     &LBL.C\n         AGO   .REST\n.REGAL   ANOP\n&LABEL   BCTR  &LEN(1),0\n         EX    &LEN(1),&LBL.E\n         LA    &LEN(1),1(0,&LEN(1))\n         BC    8,&LBL.B\n         B     &LBL.C\n&LBL.E   TRT   0(0,&ADR(1)),&LBL.A\n.REST    ANOP\n&LBL.A   DC    256XL1'01'\n         ORG   &LBL.A+C'0'\n         DC    10XL1'00'\n         ORG   &LBL.A+256\n&LBL.B   LA    R15,0\n         B     &LBL.D\n&LBL.C   LA    R15,4\n         B     &LBL.D\n&LBL.D   DS    0H\n         MEXIT\n.NOADR   MNOTE 4,'DATA FIELD ADDRESS NOT SPECIFIED---MACRO NOT GENERATE-\n               D'\n         MEXIT\n.NOLEN   MNOTE 4,'LENGTH NOT SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n.INVLEN  MNOTE 4,'INVALID LENGTH SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050504": {"ttr": 2321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\'\\x00\\'\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.5.4\n*\n*\nTABLE1   DC    256XL1'01'\n         ORG   TABLE1+X'00'\n         DC    XL10'00'\n         ORG   TABLE1+X'10'\n         DC    XL10'00'\n         ORG   TABLE1+X'20'\n         DC    XL10'00'\n         ...\n         ORG   TABLE1+X'90'\n         DC    XL10'00'\n         ORG   TABLE1+256\n*\nTABLE2   DC    256XL1'01'\n         ORG   TABLE2+X'0C'\n         DC    X'00'\n         ORG   TABLE2+X'1C'\n         DC    X'00'\n         ...\n         ORG   TABLE2+X'9C'\n         DC    X'00'\n         ORG   TABLE2+X'0D'\n         DC    X'00'\n         ORG   TABLE2+X'1D'\n         DC    X'00'\n         ...\n         ORG   TABLE2+X'9D'\n         DC    X'00'\n         ORG   TABLE2+X'0F'\n         DC    X'00'\n         ORG   TABLE2+X'1F'\n         DC    X'00'\n         ...\n         ORG   TABLE2+X'9F'\n         DC    X'00'\n         ORG   TABLE2+256\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050505": {"ttr": 2323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.5.5\n*\n*\nTABLE2   DC    256XL1'01'\n         ORG   TABLE2+X'C0'\n         DC    XL10'00'\n         ORG   TABLE2+X'D0'\n         DC    XL10'00'\n         ORG   TABLE2+X'F0'\n         DC    XL10'00'\n         ORG   TABLE2+256\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050506": {"ttr": 2325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x005\\x005\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.5.6\n*\n*\n         LA    R0,PDNOLEN          LD LENGTH OF FIELD TO VALIDATE\n         LA    R10,PDNUMB          LD ADR OF FIELD TO VALIDATE\n         BAL   R7,VALDTPD          VALIDATE FIELD FOR PACKED DEC DATA\n         LTR   R15,R15             CHK IF FIELD CONTAIN VALID DATA\n         BZ    DATAOK              IF O, FIELD CONTAINS VALID PD NUMB\n         B     DATAINV             IF NOT, FIELD CONTAINS INV PD NUMB\n*\n*\n***********************************************************************\n*   THIS SUBROUTINE CHECKS IF A FIELD OF DATA CONTAINS PACKED DECIMAL\n*   NUMBERS. THIS SUBROUTINE PERFORMS THE VALIDATION BY USING TWO\n*   TRANSLATION TABLES. ONE TABLE TO VALIDATE ALL THE BYTES EXCEPT THE\n*   LAST ONE AND THE OTHER TABLE TO VALIDATE THE LAST BYTE (THE ONE\n*   WHICH CONTAINS THE SIGN). AN RC IS SET IN REGISTER 15 FOR THE\n*   CALLING ROUTINE; X'00' INDICATES VALID DATA, X'04' INDICATES\n*   INVALID DATA.\n***********************************************************************\n*\nVALDTPD  C     R0,BINONE           CHK IF FIELD CONTAINS ONLY 1 BYTE\n         BE    CHKSIGN             IF YES, DO ONLY LAST BYTE TEST\n         C     R0,BIN16            CHK IF LEN OF FIELD EXCEEDS 16 BYTES\n         BH    PDATAINV            IF YES, PD FIELD TOO LONG\n         LR    R14,R0              LD FD LEN INTO R14 FOR S + EX INSTR\n         LR    R15,R10             LD ADR OF BG OF FIELD INTO R15 (SAVE\n*                                  R10)\n         S     R14,BINTWO          DECR LEN BY 2, 1 FOR SIGN, 1 FOR EX\n         EX    R14,TRT1            CHK IF ALL BYTES (EXCEPT SIGN) VALID\n         BC    8,CHKSIGN           IF ALL BYTES OK, CHK SIGN BYTE\n         LA    R15,4               IF NOT, IND IT\n         BR    R7                  RETURN TO CALLING RTN\nTRT1     TRT   0(0,R10),TABLE1     TRT INSTR FOR EX\nCHKSIGN  LR    R14,R0              LD FD LEN IN R14 FOR LA INSTR\n         LA    R15,0(R14,R10)      LD ADR OF BYTE PAST FIELD\n         BCTR  R15,0               SET ADR TO POINT TO SIGN (LAST) BYTE\n         UNPK  0(1,R15),0(1,R15)   REVERSE SIGN AND DIGIT FOR TABLE2\n         TRT   0(1,R15),TABLE2     CHK IF LAST BYTE VALID\n         UNPK  0(1,R15),0(1,R15)   RESTORE LAST BYTE\n         BC    8,PDATAOK           CHK IF LAST BYTE OK\nPDATAINV LA    R15,4               IF NOT, IND IT\n         BR    R7                  RETURN TO CALLING RTN\nPDATAOK  LA    R15,0               DATA OK, IND IT\n         BR    R7                  RETURN TO CALLING RTN\n*\nBINONE   DC    F'1'\nBINTWO   DC    F'2'\nBIN16    DC    F'16'\nPDNOLEN  EQU   L'PDNUMB           CONTAINS THE LEN OF PDNUMB (IN BYTES)\nPDNUMB   DC    ...                THE FIELD WHICH IS TO BE VALIDATED\n*                                 FOR PACKED DECIMAL DATA\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050601": {"ttr": 2327, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\"\\x00\"\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.6.1\n*\n*\n//jobname    JOB   ---\n//STEP1      EXEC ASMAC\n//C.SYSPUNCH DD   DSN=USER.OBJLIB(SUBRTN),DISP=SHR\n//C.SYSIN DD *\n*\n*\nSUBRTN   CSECT\n         INITL 3,EQU=R\n         ...\n         RCNTL RC=0\n         END\n//*\n//*\n//STEP2      EXEC ASMACLG\n//C.SYSIN    DD   *\n*\n*\nMAIN     CSECT\n         INITL 3,EQU=R\n         ...\n         CALL  SUBRTN\n         ...\n         RCNTL RC=0\n         END\n//*\n//*\n//L.OBJLIB   DD   DSN=USER.OBJLIB,DISP=SHR\n//L.SYSIN    DD   *\n  INCLUDE OBJLIB(SUBRTN)\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE050602": {"ttr": 2329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00#\\x00#\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.6.2\n*\n*\nSUBRTN   CSECT\n         EXTRN TABLE               INDICATE TABLE IS IN ANOTHER CSECT\n         INITL 3,EQU=R\n         L     R10,0(0,R1)         LD ADR OF 1ST PARM (P1)\n         L     R11,4(0,R2)         LD ADR OF 2ND PARM (P2)\n         L     R12,TBLADR          LD ADR OF TABLE\n         ...\n         RCNTL RC=0\nTBLADR   DC    A(TABLE)            ADR OF TABLE (RESOLVED BY L.E.)\n         END\n*\n*\nMAIN     CSECT\n         ENTRY TABLE             INDICATE THAT TABLE IS LOCATED IN THIS\n*                                CSECT AND MAY BE REF BY ANOTHER CSECT\n         INITL 3,EQU=R\n         ...\n         CALL  SUBRTN,PARM=(P1,P2)   CALL SUBRTN AND PASS IT THE ADRS\n*                                    OF THE PARAMETERS P1 AND P2\n         ...\n         RCNTL RC=0\nP1       DC    C'PARM-1'\nP2       DC    C'PARM-2'\n*\nTABLE    DC    C'ENTRY-1'\n         DC    C'ENTRY-2'\n         DC    C'ENTRY-3'\n         ...\n         DC    C'ENTRY-N'\n         DC    X'FF'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050701": {"ttr": 2331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xe0\\x00\\xe0\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 224, "newlines": 224, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.7.1\n*\n*\n         TITLE 'REENTRANT I/O PROGARM EXAMPLE'\n*\n*\n***********************************************************************\n*\n*        EXAMPLE OF REENTRANT I/O PROGRAM\n*\n*        FILE-1 IS READ AND SELECTED FIELDS FROM EACH RECORD\n*        ARE USED TO CREATE THE RECORDS OF FILE-2.\n*\n*        ALSO A RECORD COUNTER IS MAINTAINED IN THE PROGRAM AND\n*        ITS CONTENTS IS USED AS ONE OF THE FIELDS OF THE RECORDS\n*        OF FILE-2.\n*\n*        REGISTER 9 IS USED TO HOLD THE ADDRESS OF THE FIRST\n*        GETMAINED AREA DURING THE ENTIRE EXECUTION OF THE PROGRAM.\n*\n***********************************************************************\n*\n*\nRENTIO   CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING WORKAREA,R9         DEFINE REG FOR WA DSECT\n         USING RECORD1,R11         DEFINE REG FOR REC1 DSECT\n         USING RECORD2,R12         DEFINE REG FOR REC2 DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,GETMAIN1         GET STOR FOR WORKAREA\n         BAL   R6,GETMAIN2         GET STOR FOR MACRO EXPNS, I/O AREAS\n         BAL   R6,BLDCNTLS         MOVE MACRO EXPNS INTO GM AREA\n         BAL   R6,OPENFLS          OPEN FILES\nNEXTREC  BAL   R6,GETREC           READ A RECORD\n         BAL   R6,BLDREC           BUILD OUTPUT RECORD\n         BAL   R6,PUTREC           WRITE A RECORD\n         B     NEXTREC             PROCESS NEXT RECORD\nRECEND   BAL   R6,CLOSEFLS         CLOSE FILES\n         B     RETURN              RETURN TO MVS OR TO CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS STORAGE FOR THE PROGRAM WORKAREA AND SAVES\n*    THAT ADDRESS IN REGISTER 9.\n***********************************************************************\n*\nGETMAIN1 GETMAIN RU,LV=WKARLEN\n         LR    R9,R1               SET ADRBLTY FOR WA DSECT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS STORAGE FOR THE I/O MACRO EXPANSIONS AND\n*    THE I/O AREAS AND SAVES THE ADRRESSES OF THOSE STORAGE AREAS\n*    IN FIELDS OF THE PREVIOUS GETMAINED AREA.\n***********************************************************************\n*\nGETMAIN2 GETMAIN RU,LV=OPENLEN\n         ST    R1,OPENADR\n         GETMAIN RU,LV=CLOSELEN\n         ST    R1,CLOSEADR\n         GETMAIN RU,LV=DCB1LEN\n         ST    R1,DCB1ADR\n         GETMAIN RU,LV=DCB2LEN\n         ST    R1,DCB2ADR\n         GETMAIN RU,LV=REC2LEN\n         ST    R1,REC2ADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE COPIES THE I/O MACRO EXPANSIONS INTO THE\n*    GETMAINED STORAGE AREAS.\n***********************************************************************\n*\nBLDCNTLS L     R10,OPENADR\n         MVC   0(OPENLEN,R10),OPEN\n         L     R10,CLOSEADR\n         MVC   0(CLOSELEN,R10),CLOSE\n         L     R10,DCB1ADR\n         MVC   0(DCB1LEN,R10),DCB1\n         L     R10,DCB2ADR\n         MVC   0(DCB2LEN,R10),DCB2\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE DCBS FROM THE GETMAINED AREAS\n*    AND ZEROS THE RECORD COUNTER FOR FILE-2\n***********************************************************************\n*\nOPENFLS  L     R1,OPENADR          LOAD ADR OF OPEN LIST FROM GM AREA\n         L     R10,DCB1ADR         LOAD ADR OF DCB1 FROM GM AREA\n         L     R11,DCB2ADR         LOAD ADR OF DCB2 FROM GM AREA\n         OPEN  ((R10),,(R11)),MF=(E,(R1))   DO REENTRANT OPEN\n         ZAP   REC2CTR,ZERO        CLEAR RECORD COUNTER\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A RECORD FORM FILE-1.\n***********************************************************************\n*\nGETREC   L     R10,DCB1ADR         LOAD ADR OF DCB1 FROM GM AREA\n         GET   (R10)               DO REENTRANT GET\n         LR    R11,R1              SET ADRBLTY FOR REC1 DSECT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CREATES THE RECORDS FOR FILE-2.\n***********************************************************************\n*\nBLDREC   L     R12,REC2ADR         SET ADRBLTY FOR REC2 DSECT\n         AP    REC2CTR,ONE         INCR RECORD COUNTER\n         MVC   ORECNUM,REC2CTR\n         MVC   OFIELD1,IFIELD2\n         MVC   OFIELD2,IFIELD4\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE WRITES THE RECORDS INTO FILE-2.\n***********************************************************************\n*\nPUTREC   L     R10,DCB2ADR         LOAD ADR OF DCB2 FROM GM AREA\n         L     R12,REC2ADR         LD ADR OF REC2 I/O AREA FROM GM AREA\n         PUT   (R10),(R12)         DO REENTRANT PUT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE DCBS FROM THE GETMAINED AREAS\n***********************************************************************\n*\nCLOSEFLS L     R1,CLOSEADR         LOAD ADR OF CLOSE LIST FROM GM AREA\n         L     R10,DCB1ADR         LOAD ADR OF DCB1 FROM GM AREA\n         L     R11,DCB2ADR         LOAD ADR OF DCB2 FROM GM AREA\n         CLOSE ((R10),,(R11)),MF=(E,(R1))   DO REENTRANT CLOSE\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n***********************************************************************\n*    CONSTANTS USED BY PROGRAM\n***********************************************************************\n*\nZERO     DC    P'0'\nONE      DC    P'1'\n*\n*\n***********************************************************************\n*    LIST FORM OF I/O MACRO INSTRUCTIONS\n***********************************************************************\n*\nOPEN     OPEN  (DCB1,(INPUT),DCB2,(OUTPUT)),MF=L\nOPENLEN  EQU   (*-OPEN)\n*\nCLOSE    CLOSE (DCB1,,DCB2),MF=L\nCLOSELEN EQU   (*-CLOSE)\n*\n*\n***********************************************************************\n*    DCB MACRO INSTRUCTIONS\n***********************************************************************\n*\nFILE1DCB DCB   DSORG=PS,MACRF=GL,RECFM=FB,LRECL=80,EODAD=RECEND,       -\n               DDNAME=INDATADD\nDCB1LEN  EQU   (*-FILE1DCB)\n*\nFILE2DCB DCB   DSORG=PS,MACRF=PM,RECFM=FB,LRECL=50,DDNAME=OUTDATDD     -\nDCB2LEN  EQU   (*-FILE2DCB)\n*\n*\n***********************************************************************\n*    DSECTS USED BY PROGRAM\n***********************************************************************\n*\nWORKAREA DSECT\nOPENADR  DS    F                   ADDR OF OPEN LIST IN GM AREA\nCLOSEADR DS    F                   ADDR OF CLOSE LIST IN GM AREA\nDCB1ADR  DS    F                   ADDR OF DCB1 IN GM AREA\nDCB2ADR  DS    F                   ADDR OF DCB2 IN GM AREA\nREC2ADR  DS    F                   ADDR OF OUT REC I/O AREA IN GM AREA\nREC2CTR  DS    PL5                 ADDR OF RECORD COUNTER\nWKARLEN  EQU   (*-WORKAREA)\n*\nRECORD1  DSECT\nIFIELD1  DS    CL15\nIFIELD2  DS    CL20\nIFIELD3  DS    CL10\nIFIELD4  DS    CL25\nIFIELD5  DS    CL10\n*\nRECORD2  DSECT\nORECNUM  DS    CL5\nOFIELD1  DS    CL20\nOFIELD2  DS    CL25\nREC2LEN  EQU   (*-RECORD2)\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050801": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x88\\x00\\x88\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 136, "newlines": 136, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.8.1\n*\n*\nEXPDTBL  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         ...\n         BAL   R6,ALLOBASE             ALLOCATE TABLE BASE\nNEXTDATA BAL   R6,GETDATA              GET A DATA RECORD\n         BAL   R6,BLDTBL               PUT RECORD INTO TABLE\n         B     NEXTDATA                GET NEXT DATA RECORD\nDATAEND  BAL   R6,SETBLEND             SET END OF DATA INDICATOR\n         ...\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES THE VIRTUAL STORAGE FOR THE TABLE BASE. THE\n*    ADDRESS OF THE FIRST TABLE SLOT IS STORED IN SLOTPTR AND THE TOTAL\n*    NUMBER OF SLOTS IN THE BASE AREA IN STORED IN SLOTCT.\n***********************************************************************\n*\nALLOBASE GETMAIN EC,LV=GM1LEN,SP=10,A=GM1ADDR\n         MVC   SLOTPTR,GM1ADDR         STORE FIRST AVAIL SLOT ADDR\n         LA    R10,BASECT+1            LOAD NUMBER OF SLOTS IN GM1 AREA\n         ST    R10,SLOTCT              STORE NUMBER OF SLOTS\n         BR    R6                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE GETS THE DATA FOR THE EXPANDABLE TABLE FROM SOME\n*    EXTERNAL SOURCE AND PLACES THE DATA ENTRY INTO THE AREA DATA.\n***********************************************************************\n*\nGETDATA  DS    0H\n         ...                           GET DATA FROM EXTERNAL SOURCE\n         BR    R6                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE BUILDS THE EXPANDABLE TABLE BY INSERTING THE DATA,\n*    WHICH IS PASSED TO IT IN THE AREA DATA, INTO THE TABLE SLOTS. THE\n*    ADDRESS OF THE NEXT SLOT IN STORED IN SLOTPTR AND THE NUMBER OF\n*    SLOTS LEFT IN THE TABLE SEGMENT IS STORED IN SLOTCT. THIS ROUTINE\n*    DOES THE FOLLOWING:\n*        * INSERTS THE DATA ENTRY INTO THE TABLE SLOT POINTED TO BY\n*          SLOTPTR;\n*        * UPDATES SLOTPTR TO POINT TO THE NEXT TABLE SLOT;\n*        * UPDATES SLOTCT BY DECREMENTING THE COUNT BY ONE;\n*        * BRANCHES AND LINKS TO THE ALLOXTEN ROUTINE TO ALLOCATE\n*          VIRTUAL\n*          STORAGE FOR ANOTHER TABLE SEGMENT WHEN THE CURRENT SEGMENT\n*          IS EXHAUSTED.\n*    THE INITIAL VALUES OF SLOTPTR AND SLOTCT ARE SET EACH TIME THAT\n*    VIRTUAL STORAGE IS ALLOCATED FOR A NEW TABLE SEGMENT BY THE\n*    ROUTINE WHICH DOES THE ALLOCATION.\n***********************************************************************\n*\nBLDTBL   L     R10,SLOTCT              LOAD NUMBER OF AVAIL SLOTS\n         BCTR  R10,0                   DECR AVAIL SLOT COUNT\n         LTR   R10,R10                 CHECK IF LAST SLOT\n         BZ    LASTSLOT                IF YES, BRANCH\n         L     R11,SLOTPTR             LOAD ADR OF NEXT AVAIL SLOT\n         MVC   0(ENTRYLEN,R11),DATA    MOVE DATA INTO TABLE\n         LA    R11,ENTRYLEN(0,R11)     INCR TO NEXT SLOT ADDR\n         ST    R11,SLOTPTR             STORE ADR OF NEXT AVAIL SLOT\n         BR    R6                      RETURN TO CALLING RTN\nLASTSLOT MVC   SLOTXPTR,SLOTPTR        STORE ADR OF LAST SLOT\n         BAL   R7,ALLOXTEN             OBTAIN NEXT GM AREA\n         L     R11,SLOTXPTR            LOAD ADR OF LAST SLOT OF PREV GM\n         MVC   0(4,R11),BINONES        SET LINK WORD IN PREV GM AREA\n         MVC   4(4,R11),GMXADDR        STOR ADR OF NEXT GM INTO PREV GM\n         B     BLDTBL                  PUT CURRENT DATA ENTRY INTO TBL\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ALLOCATES VIRTUAL STORAGE FOR A TABLE EXTENSION.\n*    IT RECEIVES CONTROL EACH TIME THAT THE CURRENT TABLE SEGMENT IS\n*    EXHAUSTED AND INITIALIZES THE SLOTPTR AND SLOTCT AREAS EACH TIME\n*    THAT ADDITIONAL VIRTUAL STORAGE IS ALLOCATED.\n***********************************************************************\n*\nALLOXTEN GETMAIN EC,LV=GMXLEN,SP=10,A=GMXADDR\n         MVC   SLOTPTR,GMXADDR         STORE FIRST AVAIL SLOT ADDR\n         LA    R10,EXTENCT+1           LOAD NUMBER OF SLOTS IN GMX AREA\n         ST    R10,SLOTCT              STORE NUMBER OF SLOTS\n         BR    R7                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL WHEN ALL THE DATA IS INSERTED INTO\n*    THE TABLE AND PUTS AN END-OF-TABLE INDICATOR AFTER THE LAST DATA\n*    ENTRY.\n***********************************************************************\n*\nSETBLEND L     R11,SLOTPTR             LOAD ADR OF NEXT AVAIL SLOT\n         MVC   0(4,R11),BINZEROS       SET END-OF-DATA INDICATOR\n         BR    R6                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    DC/DS/EQU STATEMENTS\n***********************************************************************\n*\nENTRYLEN EQU   100                     LENGTH OF DATA ENTRY\nBASECT   EQU   500                     CAPACITY OF TABLE BASE\nEXTENCT  EQU   75                      CAPACITY OF EACH TABLE EXTENSION\nGM1LEN   EQU   (BASECT+1)*ENTRYLEN     LENGTH OF BASE GETMAIN\nGMXLEN   EQU   (EXTENCT+1)*ENTRYLEN    LEN OF EACH ADDITIONAL GETMAIN\nBINZEROS DC    4XL1'00'                END-OF-DATA INDICATOR\nBINONES  DC    4XL1'FF'                LINK INDICATOR\nGM1ADDR  DS    F                       ADR OF BG OF TABLE\nGMXADDR  DS    F                       ADR OF EACH TABLE EXTNSION\nSLOTPTR  DS    F                       RUNNING ADR OF NEXT AVAIL SLOT\nSLOTXPTR DS    F                       ADR OF LAST SLOT OF EACH GM AREA\nSLOTCT   DS    F                       RUNNING COUNT OF SLOTS AVAIL\nDATA     DS    CL100                   DATA ENTRY\n         ...\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050802": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.8.2\n*\n*\nBLDTBLV  L     R11,SLOTPTR         LOAD ADR OF NEXT AVAIL SLOT\n         BCTR  R10,0               DECR ENTRY LEN FOR EX INTR\n         EX    R10,MOVEDATA        MOVE NEW ENTRY INTO TABLE\n         LA    R10,5(0,R10)        RESTORE ENTRY LEN AND ADD LEN OF\n*                                  LEN-FIELD\n         ST    R10,0(0,R11)        APPEND ENTRY LENGTH TO BG OF ENTRY\n         LA    R11,0(R10,R11)      GET ADR OF NEXT AVAIL SLOT\n         ST    R11,SLOTPTR         SAVE ADR OF NEXT AVAIL SLOT\n         BR    R7                  RETURN TO CALLING RTN\nMOVEDATA MVC   4(0,R11),DATA       MVC INSTR FOR EX INSTR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050803": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.8.3\n*\n*\nGETENTRY L     R1,SLOTPTR          LD ADR OF CURRENT ENTRY\n         CLC   0(4,R1),BINZEROS    CHK IF CURRENT ENTRY IS TBL-END-IND\n         BE    TBLEND              IF YES, END-OF-TABLE\n         L     R14,0(0,R1)         LD LEN OF CURRENT ENTRY\n         LA    R11,0(R14,R1)       CALC ADR OF NEXT ENTRY\n         S     R14,BIN4            SUBT LEN OF ENTRY-LEN-FIELD\n         LA    R1,4(0,R1)          INCR PAST ENTRY-LEN-FIELD\n         CLC   0(4,R11),BINONES    CHK IF NEXT ENTRY IS LINK ENTRY\n         BE    GETNXSEG            IF YES, GET ADR OF NEXT TBL SEG\n         ST    R11,SLOTPTR         IF NO, SAVE ADR OF NEXT ENTRY\n         LA    R15,0               IND REG 1 CONTAINS CUR ENTRY ADR\n         BR    R7                  RETURN TO CALLING RTN\nGETNXSEG L     R11,4(0,R11)        LD ADR OF NEXT TBL SEG\n         ST    R11,SLOTPTR         SAVE ADR OF NEXT ENTRY\n         LA    R15,0               IND REG 1 CONTAINS CUR ENTRY ADR\n         BR    R7                  RETURN TO CALLING RTN\nTBLEND   LA    R15,4               IND END-OF-TABLE\n         BR    R7                  RETURN TO CALLING RTN\n         ...\nBIN4     DC    F'4'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050901": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00t\\x00t\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.9.1\n*\n*\n***********************************************************************\n*    MULTILEVEL TABLE FOR PRODUCT NUMBER 0123\n***********************************************************************\n*\n*\n*    TABLE OF PRODUCT SIZES\n*\nP0123TBL EQU   *\n         DC    C'S',CL3' ',A(P0123SQ)    SMALL\n         DC    C'M',CL3' ',A(P0123MQ)    MEDIUM\n         DC    C'L',CL3' ',A(P0123LQ)    LARGE\n         DC    X'FF'\n*\n*\n*    TABLE OF QUALITY FOR SMALL SIZE\n*\nP0123SQ  EQU   *\n         DC    C'S',CL3' ',A(P0123SSL)   SMALL STANDARD\n         DC    C'D',CL3' ',A(P0123SDL)   SMALL DELUXE\n         DC    X'FF'\n*\n*\n*    TABLE OF LOCATION/PRICE FOR STANDARD SMALL SIZE\n*\nP0123SSL EQU   *\n         DC    C'E',PL3'1000'            SMALL STANDARD EAST\n         DC    C'C',PL3'0710'            SMALL STANDARD CENTRAL\n         DC    C'W',PL3'0990'            SMALL STANDARD WEST\n         DC    X'FF'\n*\n*\n*    TABLE OF LOCATION/PRICE FOR DELUXE SMALL SIZE\n*\nP0123SDL EQU   *\n         DC    C'E',PL3'1495'            SMALL DELUXE EAST\n         DC    C'C',PL3'1200'            SMALL DELUXE CENTRAL\n         DC    C'W',PL3'1400'            SMALL DELUXE WEST\n         DC    X'FF'\n*\n*\n*    TABLE OF QUALITY FOR MEDIUM SIZE\n*\nP0123MQ  EQU   *\n         DC    C'S',CL3' ',A(P0123MSL)   MEDIUM STANDARD\n         DC    C'D',CL3' ',A(P0123MDL)   MEDIUM DELUXE\n         DC    X'FF'\n*\n*\n*    TABLE OF LOCATION/PRICE FOR STANDARD MEDIUM SIZE\n*\nP0123MSL EQU   *\n         DC    C'E',PL3'1500'            MEDIUM STANDARD EAST\n         DC    C'C',PL3'1150'            MEDIUM STANDARD CENTRAL\n         DC    C'W',PL3'1305'            MEDIUM STANDARD WEST\n         DC    X'FF'\n*\n*\n*    TABLE OF LOCATION/PRICE FOR DELUXE MEDIUM SIZE\n*\nP0123MDL EQU   *\n         DC    C'E',PL3'2180'            MEDIUM DELUXE EAST\n         DC    C'C',PL3'1725'            MEDIUM DELUXE CENTRAL\n         DC    C'W',PL3'2050'            MEDIUM DELUXE WEST\n         DC    X'FF'\n*\n*\n*    TABLE OF QUALITY FOR LARGE SIZE\n*\nP0123LQ  EQU   *\n         DC    C'S',CL3' ',A(P0123LSL)   LARGE STANDARD\n         DC    C'D',CL3' ',A(P0123LDL)   LARGE DELUXE\n         DC    X'FF'\n*\n*\n*    TABLE OF LOCATION/PRICE FOR STANDARD LARGE SIZE\n*\nP0123LSL EQU   *\n         DC    C'E',PL3'1990'            LARGE STANDARD EAST\n         DC    C'C',PL3'1490'            LARGE STANDARD CENTRAL\n         DC    C'W',PL3'1705'            LARGE STANDARD WEST\n         DC    X'FF'\n*\n*\n*    TABLE OF LOCATION/PRICE FOR DELUXE LARGE SIZE\n*\nP0123LDL EQU   *\n         DC    C'E',PL3'3000'            LARGE DELUXE EAST\n         DC    C'C',PL3'2300'            LARGE DELUXE CENTRAL\n         DC    C'W',PL3'2700'            LARGE DELUXE WEST\n         DC    X'FF'\n*\n*\n***********************************************************************\n*    DSECTS FOR MULTILEVEL TABLE\n***********************************************************************\n*\nDSIZETBL DSECT\n$SIZE    DS    CL1         SIZE CODE\n         DS    CL3         *** FOR ALIGNMENT ***\n$QTBLADR DS    CL4         POINTER TO CORRESPONDING QUALITY TABLE\n$SENTLEN EQU   *-DSIZETBL  ENTRY LENGTH\n*\nDQUALTBL DSECT\n$QUAL    DS    CL1         QUALITY CODE\n         DS    CL3         *** FOR ALIGNMENT ***\n$LTBLADR DS    CL4         POINTER TO CORRESPONDING LOCATION TABLE\n$QENTLEN EQU   *-DQUALTBL  ENTRY LENGTH\n*\nDLOCTBL  DSECT\n$LOC     DS    CL1         LOCATION CODE\n$PRICE   DS    PL3         PRICE\n$LENTLEN EQU   *-DLOCTBL   ENTRY LENGTH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE050902": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00E\\x00E\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.9.2\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE PRICE FOR PRODUCT NUMBER 0123.\n***********************************************************************\n*\nGETP0123 LA    R10,P0123TBL              LD ADR OF ML-TBL FOR PROD-0123\n         BAL   R8,GETPRICE               GET PRICE OF PROD-0123\n         BR    R7                        RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE OBTAINS THE PRICE OF THE PRODUCT SPECIFIED BY THE\n*    CALLING ROUTINE. WHEN THIS SUBROUTINE RECEIVES CONTROL, IT EXPECTS\n*    THE ADDRESS OF THE MULTI-LEVEL PRICE TABLE FOR THE PRODUCT WHOSE\n*    PRICE IS DESIRED, TO BE LOADED INTO REGISTER 10.\n***********************************************************************\n*\n         USING DSIZETBL,R10              DEF REG FOR SIZE-TABLE DSECT\nGETPRICE DS    0H\nNEXTSIZE CLI   $SIZE,TBLENDID            CHECK FOR END OF TABLE\n         BE    INVSIZE                   IF TBL END, INV SIZE SPEC\n         CLC   $SIZE,ARGSIZE             SEARCH FOR REQUIRED SIZE\n         BE    SETQTBL                   IF FOUND, LOAD QUAL TABLE\n         LA    R10,$SENTLEN(0,R10)       INCR TO NEXT SIZE ENTRY\n         B     NEXTSIZE                  SEARCH NEXT SIZE ENTRY\nINVSIZE  LA    R15,4                     INDICATE INVALID SIZE\n         BR    R8                        RETURN TO CALLING RTN\n*\nSETQTBL  L     R10,$QTBLADR              LOAD ADR OF CORRESPD QUAL TBL\n         DROP  R10                       MAKE R10 AVAILABLE FOR DSECT\n         USING DQUALTBL,R10              DEF REG FOR QUAL-TABLE DSECT\nNEXTQUAL CLI   $QUAL,TBLENDID            CHECK FOR END OF TABLE\n         BE    INVQUAL                   IF TBL END, INV QUAL SPEC\n         CLC   $QUAL,ARGQUAL             SEARCH FOR REQUIRED QUAL\n         BE    SETLTBL                   IF FOUND, LOAD LOC TABLE\n         LA    R10,$QENTLEN(0,R10)       INCR TO NEXT QUAL ENTRY\n         B     NEXTQUAL                  SEARCH NEXT QUAL ENTRY\nINVQUAL  LA    R15,8                     INDICATE INVALID QUAL\n         BR    R8                        RETURN TO CALLING RTN\n*\nSETLTBL  L     R10,$LTBLADR              LOAD ADR OF CORRESPD LOC TBL\n         DROP  R10                       MAKE R10 AVAIL FOR DSECT\n         USING DLOCTBL,R10               DEF REG FOR LOC-TBL DSECT\nNEXTLOC  CLC   $LOC,ARGLOC               SEARCH FOR REQUIRED LOC\n         BE    SETPRICE                  IF FOUND, GET PRICE\n         CLI   $LOC,$TBLENDID            CHECK FOR END OF TABLE\n         BE    INVLOC                    IF TBL END, INV LOC SPEC\n         LA    R10,$LENTLEN(0,R10)       INCR TO NEXT LOC ENTRY\n         B     NEXTLOC                   SEARCH NEXT LOC ENTRY\nINVLOC   LA    R15,12                    INDICATE INVALID LOC\n         BR    R8                        RETURN TO CALLING RTN\n*\nSETPRICE ZAP   PRICE,$PRICE              LOAD PRICE FOR CALLER\n         LA    R15,0                     INDICATE PRICE SEARCH OK\n         BR    R8                        RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    DC/DS/EQU STATEMENTS\n***********************************************************************\n*\nTBLENDID EQU   X'FF'\nARGSIZE  DS    CL1\nARGQUAL  DS    CL1\nARGLOC   DS    CL1\nPRICE    DS    PL3\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051001": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00(\\x00(\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.10.1\n*\n*\n         USING ENTRYMAP,R11        DEFINE REG FOR DSECT\n*\nPUTENTRY L     R10,LLENTONE        LOAD ADR OF FIRST LOG ENTRY OF LL\n         L     R12,LLENTNXT        LOAD ADR OF NEXT AVAIL SLOT OF LL\n         LA    R11,NEWENTRY        LOAD ADR OF NEW ENTRY\nNXTENTRY CLC   4(ENTKYLEN,R10),ENTRYKEY   COMPARE KEY OF A LL ENTRY\n*                                         TO KEY OF NEW ENTRY\n         BH    INSERT              IF HIGH, INSERT NEW ENTRY\n         BE    DUPENTRY            IF EQUAL, ENTRY ALREADY EXISTS\n         ST    R10,PRVENTRY        STORE ADR OF CURRENT ENTRY\n         L     R10,0(0,R10)        LOAD ADR OF NEXT ENTRY IN SEQ\n         B     NXTENTRY            COMPARE NEXT ENTRY KEY TO NEW KEY\n*\nINSERT   L     R10,PRVENTRY        LOAD ADR OF ENTRY BEFORE NEW ENTRY\n         MVC   0(4,R12),0(R10)     MOVE NEXT ENTRY PTR TO NEW ENTRY\n*                                  LINK FIELD\n         MVC   4(ENTRYLEN,R12),ENTRY      MOVE NEW ENTRY INTO NEXT\n*                                         SLOT+4 (PASSED LINK FIELD)\n         ST    R12,0(0,R10)        MOVE ADR OF NEW ENTRY INTO LINK\n*                                  FIELD OF PREV ENTRY\n         LA    R12,LLENTLEN(0,R12) CALC ADR OF NEW NEXT AVAIL SLOT\n         ST    R12,LLENTNXT        SAVE ADR OF NEXT AVAIL SLOT\n         BR    R6                  RETURN TO CALLING RTN\n*\nLLENTONE DS    F\nLLENTNXT DS    F\nPRVENTRY DS    F\nNEWENTRY DS    CL6\n*\nENTRYMAP DSECT\nENTRY    EQU   *\nENTKEY   DS    CL2\nENTKYLEN EQU   *-ENTKEY\nENTFLD01 DS    CL4\nENTRYLEN EQU   *-ENTRYMAP\nLLENTLEN EQU   ENTRYLEN+4\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051002": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x006\\x006\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.10.2\n*\n*\n         USING ENTRYMAP,R11        DEFINE REG FOR DESCT\n*\nPUTENTRY L     R10,LLENTONE        LOAD ADR OF FIRST LOG ENTRY OF LL\n         L     R12,LLENTNXT        LOAD ADR OF NEXT AVAIL SLOT OF LL\n         LA    R11,NEWENTRY        LOAD ADR OF NEW ENTRY\nNXTENTRY CLC   0(4,R10),BINONES    (2) CHECK FOR LOG END OF LL\n         BE    INSERTX             (2) IF END, INSERT NEW ENTRY AT END\n         CLC   4(ENTKYLEN,R10),ENTRYKEY   COMPARE KEY OF A LL ENTRY\n*                                         TO KEY OF NEW ENTRY\n         BH    INSERT              IF HIGH, INSERT NEW ENTRY\n         BE    DUPENTRY            IF EQUAL, ENTRY ALREADY EXISTS\n         ST    R10,PRVENTRY        STORE ADR OF CURRENT ENTRY\n         L     R10,0(0,R10)        LOAD ADR OF NEXT ENTRY IN SEQ\n         B     NXTENTRY            COMPARE NEXT ENTRY KEY TO NEW KEY\n*\nINSERT   L     R10,PRVENTRY        LOAD ADR OF ENTRY BEFORE NEW ENTRY\n         MVC   0(4,R12),0(R10)     MOVE NEXT ENTRY PTR TO NEW ENTRY\n*                                  LINK FIELD\n         MVC   4(ENTRYLEN,R12),ENTRY      MOVE NEW ENTRY INTO NEXT\n*                                         SLOT+4 (PASSED LINK FIELD)\n         ST    R12,0(0,R10)        MOVE ADR OF NEW ENTRY INTO LINK\n*                                  FIELD OF PREV ENTRY\n         LA    R12,LLENTLEN(0,R12) CALC ADR OF NEW NEXT AVAIL SLOT\n         ST    R12,LLENTNXT        SAVE ADR OF NEXT AVAIL SLOT\n         BR    R6                  RETURN TO CALLING RTN\n*\nINSERTX  MVC   4(ENTRYLEN,R12),ENTRY    (2) MOVE NEW ENTRY INTO NEXT\n*                                       SLOT+4 (PASSED LINK FIELD)\n         ST    R12,0(0,R10)        (2) MOVE ADR OF NEW ENTRY INTO LINK\n*                                  FIELD OF CURRENT LAST ENTRY\n         MVC   0(4,R12),BINONES    (2) MOVE END-OF-LL INDICATOR INTO\n*                                  LINK FIELD OF NEW LAST ENTRY\n         LA    R12,LLENTLEN(0,R12)      (2) CALC ADR OF NEXT AVAIL\n*                                       SLOT OF LL\n         ST    R12,LLENTNXT        (2) SAVE ADR OF NEXT AVAIL SLOT\n         BR    R6                  (2) RETURN TO CALLING RTN\n*\nBINONES  DC    4XL1'FF'\nLLENTONE DS    F\nLLENTNXT DS    F\nPRVENTRY DS    F\nNEWENTRY DS    CL6\n*\nENTRYMAP DSECT\nENTRY    EQU   *\nENTKEY   DS    CL2\nENTKYLEN EQU   *-ENTKEY\nENTFLD01 DS    CL4\nENTRYLEN EQU   *-ENTRYMAP\nLLENTLEN EQU   ENTRYLEN+4\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051003": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00D\\x00D\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.10.3\n*\n*\n         USING ENTRYMAP,R11        DEFINE REG FOR DESCT\n*\nPUTENTRY MVI   IN1SW,C'1'          (3) INIT NEW FIRST ENTRY SWITCH\n         L     R10,LLENTONE        LOAD ADR OF FIRST LOG ENTRY OF LL\n         L     R12,LLENTNXT        LOAD ADR OF NEXT AVAIL SLOT OF LL\n         LA    R11,NEWENTRY        LOAD ADR OF NEW ENTRY\nNXTENTRY CLC   0(4,R10),BINONES    (2) CHECK FOR LOG END OF LL\n         BE    INSERTX             (2) IF END, INSERT NEW ENTRY AT END\n         CLC   4(ENTKYLEN,R10),ENTRYKEY   COMPARE KEY OF A LL ENTRY\n*                                         TO KEY OF NEW ENTRY\n         BH    INSERT              IF HIGH, INSERT NEW ENTRY\n         BE    DUPENTRY            IF EQUAL, ENTRY ALREADY EXISTS\n         MVI   IN1SW,C'0'          (3) TURN OFF NEW FIRST ENTRY SW\n         ST    R10,PRVENTRY        STORE ADR OF CURRENT ENTRY\n         L     R10,0(0,R10)        LOAD ADR OF NEXT ENTRY IN SEQ\n         B     NXTENTRY            COMPARE NEXT ENTRY KEY TO NEW KEY\n*\nINSERT   CLI   IN1SW,C'1'          (3) CHECK IF NEW FIRST ENTRY SW SET\n         BE    INSERT1             (3) IF YES, INSERT NEW FIRST ENTRY\n         L     R10,PRVENTRY        LOAD ADR OF ENTRY BEFORE NEW ENTRY\n         MVC   0(4,R12),0(R10)     MOVE NEXT ENTRY PTR TO NEW ENTRY\n*                                  LINK FIELD\n         MVC   4(ENTRYLEN,R12),ENTRY      MOVE NEW ENTRY INTO NEXT\n*                                         SLOT+4 (PASSED LINK FIELD)\n         ST    R12,0(0,R10)        MOVE ADR OF NEW ENTRY INTO LINK\n*                                  FIELD OF PREV ENTRY\n         LA    R12,LLENTLEN(0,R12) CALC ADR OF NEW NEXT AVAIL SLOT\n         ST    R12,LLENTNXT        SAVE ADR OF NEXT AVAIL SLOT\n         BR    R6                  RETURN TO CALLING RTN\n*\nINSERT1  MVC   4(4,R12),0(R11)     (3) MOVE NEW ENTRY INTO NEXT SLOT+4\n*                                  (PASSED LINK FIELD)\n         ST    R10,0(0,R12)        (3) MOVE ADR OF OLD FIRST ENTRY INTO\n*                                  LINK FIELD OF NEW FIRST ENTRY\n         ST    R12,LLENTONE        (3) SAVE ADR OF NEW FIRST ENTRY\n         LA    R12,LLENTLEN(0,R12)      (3) CALC ADR OF NEXT AVAIL SLOT\n         ST    R12,LLENTNXT        (3) SAVE ADR OF NEXT AVAIL SLOT\n         BR    R6                  (3) RETURN TO CALLING RTN\n*\nINSERTX  MVC   4(ENTRYLEN,R12),ENTRY    (2) MOVE NEW ENTRY INTO NEXT\n*                                       SLOT+4 (PASSED LINK FIELD)\n         ST    R12,0(0,R10)        (2) MOVE ADR OF NEW ENTRY INTO LINK\n*                                  FIELD OF CURRENT LAST ENTRY\n         MVC   0(4,R12),BINONES    (2) MOVE END-OF-LL INDICATOR INTO\n*                                  LINK FIELD OF NEW LAST ENTRY\n         LA    R12,LLENTLEN(0,R12)      (2) CALC ADR OF NEXT AVAIL\n*                                       SLOT OF LL\n         ST    R12,LLENTNXT        (2) SAVE ADR OF NEXT AVAIL SLOT\n         BR    R6                  (2) RETURN TO CALLING RTN\n*\nIN1SW    DS    CL1\nBINONES  DC    4XL1'FF'\nLLENTONE DS    F\nLLENTNXT DS    F\nPRVENTRY DS    F\nNEWENTRY DS    CL6\n*\nENTRYMAP DSECT\nENTRY    EQU   *\nENTKEY   DS    CL2\nENTKYLEN EQU   *-ENTKEY\nENTFLD01 DS    CL4\nENTRYLEN EQU   *-ENTRYMAP\nLLENTLEN EQU   ENTRYLEN+4\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051004": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.10.4\n*\n*\nDSPLYLL  L     R10,LLENTONE            LOAD BG ADR OF LL\nNXTLLENT MVC   ENTRY(ENTRYLEN),4(R10)  MOVE ENTRY (WITHOUT LINK FIELD)\n         BAL   R7,PRINT                PRINT ENTRY\n         C     R10,BINONES             CHECK FOR END OF LL\n         BER   R6                      IF END, RETURN TO CALLING RTN\n         L     R10,0(0,R10)            IF NOT, LD ADR OF NEXT SEQ ENTRY\n         B     NXTLLENT                GET NEXT ENTRY\n*\nPRINT    PUT   REPORT,LINE             PRINT AN ENTRY OF LL\n         BR    R7                      RETURN TO CALLING RTN\n*\n         DS    0F\nBINONES  DC    4XL1'FF'                END-OF-LL INDICATOR\nLINE     DS    0CL133\n         DC    C' '\nENTRY    DC    CL132' '\n*\nREPORT   DCB   DSORG=PS,MACRF=PM,BLKSIZE=3990,LRECL=133,RECFM=FBA,     -\n               DDNAME=REPORT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051005": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.10.5\n*\n*\nINITLL   GETMAIN EC,LV=1000,A=LLADR\n         LTR   R15,R15                 CHECK IF GM OK\n         BNZ   NOSTOR                  IF NO, ...\n         MVC   LLENTONE,LLADR          INIT PTR TO BG OF LL\n         MVC   LLENTNXT,LLADR          INIT PTR TO NEXT SLOT OF LL\n         L     R10,LLADR               LOAD ADR OF BG OF LL\n         MVC   0(4,R10),BINONES        PUT END-OF-LL IND IN 1ST ENTRY\n         BR    R6                      RETURN TO CALLING RTN\n*\nLLADR    DS    F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051101": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.11.1\n*\n*\nVALDTINX STC   R15,LOWBYTE         EXTRACT LOW ORDER BYTE OF INX VALUE\n         TM    LOWBYTE,X'03'       IS INX MULT OF 4 (LOW 2 BITS 0)?\n         BZ    CHKINXSZ            IF YES, CHECK INX SIZE\n         B     INDXBAD1            IF NO, ERROR\nCHKINXSZ C     R15,MAXINX          CHK IF INX NOT LARGER THAN BR-TBL\n         BNH   INDEXOK             IF INX WITHIN BR-TBL, OK\n         B     INDXBAD2            IF NO, ERROR\nINDEXOK  BR    R8                  INDEX OK, RETURN TO CALLING RTN\nINDXBAD1 WTO   '*** INDEX VALUE NOT MULTIPLE OF FOUR ***',ROUTCDE=11\n         ABEND 901\nINDXBAD2 WTO   '*** INDEX VALUE TOO LARGE ***',ROUTCDE=11\n         ABEND 902\n         ...\nLOWBYTE  DS    CL1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051102": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.11.2\n*\n*\n         LINK  EP=PROGM01\n         BAL   R8,VALDTINX         SEE C.E. 5.11.1\n         B     BRNCHTBL(R15)       BRANCH INTO BRANCH-TABLE\n         ...\nBRNCHTBL B     RQUESTOK\n         B     WARNING\n         B     ERROR01\n         B     ERROR02\nBRTBLEND EQU   *\nMAXINX   DC    A(BRTBLEND-BRNCHTBL-4)    MAX ALLOW INX (DSPLM INTO TBL)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051103": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.11.3\n*\n*\n         BAL   R7,GETINFO\n         ...\nGETINFO  LINK  EP=INQUIRE,PARAM=(KEY1,KEY2,RECORD)\n         BAL   R8,VALDTINX     SEE C.E. 5.11.1\n         B     BRNCHTBL(R15)\n         ...\nBRNCHTBL BR    R7              REQ INFO RETURNED, RET TO CALLING RTN\n         DS    H               FOR ALIGNMENT\n         B     GETDATA1        GET ADDITIONAL DATA-1\n         B     GETDATA2        GET ADDITIONAL DATA-2\n         B     NOINFO          NO INFO AVAIL\nMAXINX   DC    A(*-BRNCHTBL-4)    MAX INDEX ALLOWED\n*\nGETDATA1 ...                   OBTAIN COMMON DATA-1\n         BR    R7              RETURN TO CALLING RTN\n*\nGETDATA2 ...                   OBTAIN COMMON DATA-2\n         BR    R7              RETURN TO CALLING RTN\n*\nNOINFO   ...                   PERFORM NO-INFO-AVAIL PROCESSING\n         BR    R7              RETURN TO CALLING RTN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051104": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.11.4\n*\n*\n         BAL   R7,GETINFO\n         ...\nGETINFO  LINK  EP=INQUIRE\n         BAL   R8,VALTINX          SEE CE 5.11.1\n         LA    R9,GETINFOX         LD RET ADR FOR SUBRTN\n         B     BRNCHTBL(R15)       BRANCH TO APPROPRIATE SUBRTN\nGETINFOX BR    R7                  RETURN TO CALLING RTN\n         ...\nBRNCHTBL BAL   R8,RTN1\n         BAL   R8,RTN2\n         BAL   R8,RTN3\nMAXINX   DC    A(*-BRNCHTBL-4)\n*\nRTN1     ...\n         BR    R9                  RETURN TO CALLING RTN\n*\nRTN2     ...\n         BR    R9                  RETURN TO CALLING RTN\n*\nRTN3     ...\n         BR    R9                  RETURN TO CALLING RTN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051201": {"ttr": 2833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xbf\\x00\\xbf\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 191, "newlines": 191, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.12.1\n*\n*\nSTCDEMO  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING CSCL,R10            DEFINE ADRBLTY REG FOR CSCL DSECT\n         USING CIB,R11             DEFINE ADRBLTY REG FOR CIB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,EXTRACT          GET ADR OF CMD SCHED COMM LIST\n         BAL   R6,CHKSTC           CHECK IF STARTED TASK\n         BAL   R6,SETCIBCT         SET CIB CHAIN COUNT\nLOOP     BAL   R6,PROCESS          PERFORM FUNCTION OF PROGRAM\n         BAL   R6,CHKECB           CHECK IF MODIFY/STOP CMD ENTERED\n         B     LOOP                CONTINUE PROCESSING\nPOSTED   BAL   R6,CHKCMD           CHECK IF MODIFY OR STOP CMD\n         B     LOOP                CONTINUE PROCESSING\nSTOPPROG B     RETURN              RETURN TO MVS\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE COMMAND SCHEDULE\n*    COMMUNICATIONS LIST (CSCL). THE CSCL CONTAINS THE ADDRESS OF THE\n*    COMMAND SCHEDULE COMMUNICATIONS ECB AND THE ADDRESS OF THE COMMAND\n*    INPUT BUFFER (CIB) WHICH ARE REQUIRED BY THE PROGRAM TO PROCESS\n*    ANY MODIFY AND STOP COMMANDS ISSUED BY THE OPERATOR.\n***********************************************************************\n*\nEXTRACT  EXTRACT CSCLADDR,FIELDS=COMM\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE VERIFIES THAT THE PROGRAM WAS INVOKED AS A STARTED\n*    TASK AND RELEASES THE ALLOCATED STORAGE FOR THE CIB WHICH CONTAINS\n*    THE START COMMAND.\n***********************************************************************\n*\nCHKSTC   L     R10,CSCLADDR        LOAD ADR OF CSCL, SET ADRBLTY FOR\n*                                  DSECT\n         CLC   COMCIBPT,BINZEROS   CHECK IF CIB PRESENT\n         BE    NOSTC               IF NO, NOT STARTED TASK\n         WTO   '*** STC TASK ***'  *** FOR TESING ONLY ***\n         BAL   R7,DELTCIB          DELETE START-CIB\n         BR    R6                  RETURN TO CALLING RTN\nNOSTC    WTO   '*** BATCH TASK---PROGRAM TERMINATED ***'\n         B     RETURN              RETURN TO MVS\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RELEASES THE STORAGE ALLOCATED FOR THE SPECIFIED\n*    CIB.\n***********************************************************************\n*\nDELTCIB  L     R10,CSCLADDR        LOAD ADR OF CSCL, SET ADRBLTY FOR\n*                                  DSECT\n         LA    R11,COMCIBPT        LOAD ADR OF PTR TO CIB CHAIN\n         L     R12,0(0,R11)        LOAD ADR OF CIB TO BE FREED\n         QEDIT ORIGIN=(R11),BLOCK=(R12)     FREE PROCESSED CIB\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS THE LIMIT FOR THE NUMBER OF MODIFY COMMANDS\n*    WHICH MAY BE SPECIFIED BY THE OPERATOR BEFORE THE CIBS CONTAINING\n*    THOSE COMMANDS MUST BE RELEASED.\n***********************************************************************\n*\nSETCIBCT L     R10,CSCLADDR        LOAD ADR OF CSCL, SET ADRBLTY FOR\n*                                  DSECT\n         LA    R11,COMCIBPT        LOAD ADR OF PTR TO CIB CHAIN\n         QEDIT ORIGIN=(R11),CIBCTR=1    SET CIB CHAIN COUNT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PERFORMS THE ACTUAL PROCESSING OF THE PROGRAM.\n***********************************************************************\n*\nPROCESS  DS    0H\n         ...                       PERFORM A UNIT OF PROCESSING\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL PERIODICALLY TO CHECK IF THE ECB OF\n*    THE COMMAND SCHEDULER HAS BEEN POSTED WHICH INDICATES THAT A\n*    MODIFY OR A STOP COMMAND WAS SPECIFIED BY THE OPERATOR.\n***********************************************************************\n*\nCHKECB   L     R10,CSCLADDR        LOAD ADR OF CSCL, SET ADRBLTY FOR\n*                                  DSECT\n         L     R11,COMECBPT        LOAD ADR OF CMD SCHED COMM ECB\n         TM    0(R11),X'40'        TEST IF ECB POSTED\n         BO    POSTED              IF YES, CHK COMMAND\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL WHEN THE COMMAND SCHEDULER ECB IS\n*    POSTED. THIS ROUTINE PROCESSES THE CIB (COMMAND ISSUED BY\n*    OPERATOR) POINTED TO BY THE CSCL.\n***********************************************************************\n*\nCHKCMD   L     R10,CSCLADDR        LOAD ADR OF CSCL, SET ADRBLTY FOR\n*                                  DSECT\n         L     R11,COMCIBPT        LOAD ADR OF CIB, SET ADRBLTY FOR\n*                                  DSECT\n         CLI   CIBVERB,CIBMODFY    CHECK IF MODIFY CMD\n         BE    MODIFY              IF YES, PROCESS MDFY CMD\n         CLI   CIBVERB,CIBSTOP     CHECK IF STOP CMD\n         BE    STOP                IF YES, PROCESS STOP CMD\n         WTO   '*** NOT MODIFY/STOP COMMAND ***'\n         ABEND 901\nMODIFY   WTO   '*** MODIFY COMMAND ACCEPTED ***'\n         BAL   R7,PROCMDFY         PERFORM MODIFY PROCESSING\n         BAL   R7,DELTCIB          DELETE MODIFY-CIB\n         BR    R6                  CONTINUE PROCESSING\nSTOP     WTO   '*** STOP COMMAND ISSUED---PROGRAM TERMINATED ***'\n         BAL   R7,PROCSTOP         PERFORM STOP PROCESSING\n         B     STOPPROG            RETURN TO MVS\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE PROCESSES ANY MODIFY COMMANDS ISSUED BY THE\n*    OPERATOR.\n***********************************************************************\n*\nPROCMDFY LH    R15,CIBDATLN        LOAD LENGTH OF MODIFY-DATA\n         BCTR  R15,0               DECR DATA LENGTH FOR EX INSTR\n         LA    R12,CIBDATA         LOAD ADR OF MODIFY-DATA\n         EX    R15,MVCBDATA        COPY MODIFY-DATA INTO USER AREA\n         ...                       PERFORM MODIFY PROCESSING\n         XC    MDFYDATA,MDFYDATA   CLEAR MODIFY-DATA USER AREA\n         BR    R7                  RETURN TO CALLING RTN\nMVCBDATA MVC   MDFYDATA(0),0(R12)  MVC INSTR FOR EX INSTR\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE PROCESSES THE STOP COMMAND ISSUED BY THE OPERATOR.\n***********************************************************************\n*\nPROCSTOP DS    0H\n         ...                       PERFORM STOP PROCESSING\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nBINZEROS DC    XL4'00'\nCSCLADDR DS    F\nMDFYDATA DC    XL100'00'\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\nCSCL     DSECT\n         IEZCOM                GENERATES CSCL DSECT\n*\nCIB      DSECT\n         IEZCIB                GENERATES CIB DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051202": {"ttr": 2837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.12.2\n*\n*\n         USING TIOT1,R10\n         ...\n         EXTRACT TIOTADR,FIELDS=(TIOT)\n         L     R10,TIOTADR\n         ...\n         MVC   PROCNAME,TIOCNJOB\n               or\n         MVC   PROCNAME,TIOCSTEP\n         ...\nTIOTADR  DS    F\nPROCNAME DS    CL8\n         ...\n         DSECT\n         IEFTIOT1\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE051301": {"ttr": 2839, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00n\\x00n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.13.1\n*\n*\n         CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R                INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN                OPEN JES2 INTERNAL READER\n         BAL   R6,ISSUCMDS            ISSUE COMMANDS\n         BAL   R6,CLOSE               CLOSE INTERNAL READER\n         B     RETURN                 RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE JES2 INTERNAL READER.\n***********************************************************************\n*\nOPEN     OPEN  (JES2IRDR,(OUTPUT))    OPEN IRDR\n         ...                          CHK FOR GOOD OPEN\n         BR    R6                     RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES ALL THE SPECIFIED COMMANDS IN THE COMMAND\n*    TABLE. IN ORDER TO ACCOMPLISH THIS TASK, THIS ROUTINE CALLS THE\n*    SUBROUTINES WITH THE FOLLOWING FUNCTIONS:\n*        * EXTRACT A COMMAND FROM THE COMMAND TABLE;\n*        * WRITE THE COMMAND TO THE JES2 INTERNAL READER.\n***********************************************************************\n*\nISSUCMDS LA    R10,COMMTBL            LD ADR OF BG OF CMD TBL\nNEXTCOMM BAL   R7,GETCOMM             GET A COMMAND FROM TBL\n         CLI   0(R10),X'00'           CHK FOR END-OF-TABLE\n         BER   R6                     IF END, RET TO CALLING RTN\n         BAL   R7,PUTCOMM             IF NOT END, ISSUE COMMAND\n         B     NEXTCOMM               GET NEXT CMD FROM TBL\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE EXTRACTS THE CURRENT COMMAND ENTRY FROM THE\n*    COMMAND TABLE AND MOVES THE COMMAND INTO THE I/O AREA USED BY THE\n*    JES2 INTERNAL READER AND THEN INCREMENTS THE POINTER TO THE NEXT\n*    COMMAND ENTRY. THE CURRENT COMMAND ENTRY IS POINTED TO BY REGISTER\n*    10.\n***********************************************************************\n*\nGETCOMM  MVC   COMMAND,0(R10)         MOVE CMD FROM TBL TO INTRDR BUF\n         LA    R10,80(0,R10)          INCR TO NEXT CMD\n         BR    R7                     RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE WRITES THE COMMAND TO THE JES2 INTERNAL READER.\n***********************************************************************\n*\nPUTCOMM  PUT   JES2IRDR,COMMAND       WRITE CMD TO INTRDR\n         BR    R7                     RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE JES2 INTERNAL READER.\n***********************************************************************\n*\nCLOSE    CLOSE JES2IRDR               CLOSE IRDR\n         BR    R6                     RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                   RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE COMMAND TABLE\n***********************************************************************\n*\nCOMMTBL  DS    0H\n         DC    CL80'/*$DA'            JES2 $DA COMMAND\n         DC    CL80'/*$VS,'D A,L'     MVS D A COMMAND\n         DC    CL80'/*$VS,'S xxxx'    MVS START COMMAND\n         DC    CL80'/*EOF'            REQD ONLY IF INTRDR IS NOT CLOSED\n         DC    X'00'                  END-OF-TBL INDICATOR\n*\n*\n***********************************************************************\n*    THE I/O AREA AND QSAM DCB FOR THE JES2 INTERNAL READER\n***********************************************************************\n*\nCOMMAND  DS    CL80\nJES2IRDR DCB   DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,DDNAME=JESIRDR\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051302": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00r\\x00r\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.13.2\n*\n*\nPUTIRDRV CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IFGRPL,R10          DEFINE REG FOR RPL DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPENRDR          OPEN INTERNAL RDR\n         BAL   R6,SENDJCL          WRITE JCL TO INTRDR\n         BAL   R6,GETJOBNO         GET JOB NUMB OF SUBM JOB\n         BAL   R6,CLOSERDR         CLOSE INTERNAL RDR\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE JES2 INTERNAL READER.\n***********************************************************************\n*\nOPENRDR  OPEN  (IRDRACB,(OUTPUT))\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SUBMITS THE JOB BY WRITTING ALL OF THE JCL STATEMENTS\n*    TO THE INTERNAL READER.\n***********************************************************************\n*\nSENDJCL  LA    R10,JCL             LOAD ADR OF BG OF JCL STREAM\nNEXTJCL  CLI   0(R10),X'00'        CHK FOR END-OF-JCL\n         BER   R6                  IF END, RET TO CALLING RTN\n         MVC   JCLSTMT,0(R10)      MOVE JCL STMT INTO VSAM WKAR\n         LA    R10,80(0,R10)       INCR TO NEXT JCL STMT\n         PUT   RPL=IRDRRPL         WRITE JCL STMT TO INTRDR\n         B     NEXTJCL             GET NEXT JCL STMT\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE JOB NUMBER OF THE SUBMITTED JOB.\n***********************************************************************\n*\nGETJOBNO ENDREQ RPL=IRDRRPL        INDICATE END-OF-JCL\n         LA    R10,IRDRRPL         SET ADRBLTY FOR RPL DSECT\n         MVC   JOBID,RPLRBAR       GET JOB NUMBER FROM RPL\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE JES2 INTERNAL READER.\n***********************************************************************\n*\nCLOSERDR CLOSE IRDRACB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE JCL STATEMENTS TO BE SUBMITTED\n***********************************************************************\n*\nJCL      DC    CL80'//DEMOJOB JOB  ACCTNO,NAME,CLASS=A'\n         DC    CL80'//STEP    EXEC PGM=IEFBR14'\n         DC    CL80'//'\n         DC    X'00'          END-OF-JCL INDICATOR\n*\n*\n***********************************************************************\n*    THE DC/DS STATEMENTS\n***********************************************************************\n*\nJOBID    DS    CL8\nJCLSTMT  DS    CL80\n*\n*\n***********************************************************************\n*    THE VSAM ACB AND RPL\n***********************************************************************\n*\nIRDRACB  ACB   AM=VSAM,MACRF=(ADR,SEQ,OUT),DDNAME=INTRDR\nIRDRRPL  RPL   AM=VSAM,ACB=IRDRACB,OPTCD=(ADR,SEQ,SYN,NUP,MVE),        -\n               AREA=JCLSTMT,AREALEN=80,RECLEN=80\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         IFGRPL                    GENERATES THE RPL DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051303": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.13.3\n*\n*\n         MGCR  CMDBUFF             INVOKE SVC 34, ISSUE COMMAND\n         ...\nCMDBUFF  DC    X'80'               IND FLAG-2 CONTAINS MEANINGFUL INFO\n         DC    AL1(CMDBUFFX-CMDBUFF)   LENGTH OF COMMAND BUFFER\n         DC    X'0000'             INDICATES TOKEN FIELD NOT PRESENT\n         DC    C'D A,L'            COMMAND\nCMDBUFFX EQU   *\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051304": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.13.4\n*\n*\n         MVC   COMMAND,J2COMM01    PUT JES2 CMD-1 INTO COMMAND BUFFER\n         BAL   R7,ISSUECMD         ISSUE JES2 COMMAND VIA SVC 34\n         MVC   COMMAND,J2COMM02    PUT JES2 CMD-2 INTO COMMAND BUFFER\n         BAL   R7,ISSUECMD         ISSUE JES2 COMMAND VIA SVC 34\n         ...\nISSUECMD MGCR  CMDBUFF             INVOKE SVC 34, ISSUE COMMAND\n         BR    R7                  RETURN TO CALLING RTN\n         ...\nCMDBUFF  DC    X'80'               IND FLAG-2 CONTAINS MEANINGFUL INFO\n         DC    AL1(CMDBUFFX-CMDBUFF)   LENGTH OF COMMAND BUFFER\n         DC    X'0000'             INDICATES TOKEN FIELD NOT PRESENT\nCOMMAND  DS    CL10                COMMAND AREA\nCMDBUFFX EQU   *\n         ...\nJ2COMM01 DC    CL10'$TI5,ABX'      JES2 COMMAND-1\nJ2COMM02 DC    CL10'$PI10'         JES2 COMMAND-2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051305": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.13.5\n*\n*\n         MGCR  CMDBUFF             INVOKE SVC 34, ISSUE COMMAND\n         ...\nCMDBUFF  DC    X'80'               IND FLAG-2 CONTAINS MEANINGFUL INFO\n         DC    AL1(CMDBUFFX-CMDBUFF)   LENGTH OF COMMAND BUFFER (NOT\n*                                      INCLUDING TOKEN FIELD)\n         DC    X'8000'             INDICATES TOKEN FIELD IS PRESENT\n         DC    C'S PROC01'         COMMAND\nCMDBUFFX EQU   *\nSTARTID  DC    X'00',C'S01'        TOKEN FIELD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051306": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01.\\x01.\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 302, "newlines": 302, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.13.6\n*\n*\n* THE CODE FOR ABNDNOTE:\n*\n*\nABNDNOTE CSECT\nABNDNOTE AMODE 31                  SPEC ADR MODE IS 31 BITS\nABNDNOTE RMODE ANY                 SPEC RES MODE IS ANYWHERE\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING CTXT,R10            DEFINE REG FOR CTXT DSECT\n         USING CTXTATTR,R11        DEFINE REG FOR CTXTATTR DSECT\n         USING CSAWORK,R12         DEFINE REG FOR CSAWORK DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,GETMSG           GET ADR OF MSG IEF450I\n         BAL   R6,CKJOBPFX         CHK IF PROD JOB\n         BAL   R6,GETCSA           ALLO CSA FOR PARM-LIST ADR\n         BAL   R6,BLDPARM          BUILD PARM-LIST IN CSA\n         BAL   R6,DOSTART          ISSUE START CMD VIA SVC 34\n         B     RETURN              RETURN TO MVS\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE BEGINNING OF MESSAGE\n*    IEF450I.\n***********************************************************************\n*\nGETMSG   L     R10,0(0,R1)         SET ADRBLTY FOR CTXT DSECT\n         L     R11,CTXTTXPJ        SET ADRBLTY FOR CTXTATTR DSECT\n         LA    R11,CTXTTMSG        LD ADR OF BG OF MESSAGE IEF450I\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE FIRST CHARACTER OF THE JOBNAME LOCATED IN\n*    MESSAGE IEF450I FOR THE PRODUCTION PREFIX (\"P\" IN FIRST POSITION).\n*    IF THE JOB IS NOT A PRODUCTION JOB, NO OTHER PROCESSING IS\n*    PERFORMED.\n***********************************************************************\n*\nCKJOBPFX CLI   8(R11),C'P'         CHK 1ST CHAR OF JOBNM FOR PROD JOB\n         BER   R6                  IF PROD JOB, RET TO CALLING RTN\n         B     RETURN              IF NOT PROD JOB, RETURN TO MVS\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE FROM THE CSA WHICH IS USED\n*    TO STORE THE PARAMETERS PASSED TO THE PROGRAM INITIATED VIA THE\n*    INTERNAL START COMMAND.\n***********************************************************************\n*\nGETCSA   GETMAIN RC,LV=CSAGMLEN,SP=241,LOC=BELOW\n         LTR   R15,R15             CHK IF CSA ALLOC OK\n         BNZ   RETURN              IF CSA UNAVAIL, RETURN TO MVS\n         LR    R12,R1              SET ADRBLTY FOR CSAWORK DSECT\n         ST    R1,CSATOKEN         STORE ALLO CSA ADR IN TOKEN FIELD\n         MVC   CSAJOBNM,BLANKS     BLANK OUT CSA JOBNAME FIELD\n         MVC   CSASTEPN,BLANKS     BLANK OUT CSA STEPNAME FIELD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE JOBNAME AND THE STEPNAME OF THE ABENDING\n*    PRODUCTION JOB FROM MESSAGE IEF450I AND INSERTS THEM INTO THE\n*    PARAMETER-LIST.\n***********************************************************************\n*\nBLDPARM  LA    R0,8                SET MAX JOBNAME COUNT\n         LA    R11,8(0,R11)        LD ADR OF BG OF JOBNM IN MSG IEF450I\n         LA    R10,CSAJOBNM        LD ADR OF JOBNAME PARM IN CSA\nNEXTJPOS CLI   0(R11),C' '         CHK FOR END OF JOBNAME\n         BE    GETSTEP             AT END, START TO EXTR STEPNAME\n         MVC   0(1,R10),0(R11)     MOVE A CHAR OF JOBNM TO PARM IN CSA\n         LA    R11,1(0,R11)        INCR JOBNAME IN MSG IEF450I\n         LA    R10,1(0,R10)        INCR JOBNAME PARM IN CSA\n         BCT   R0,NEXTJPOS         MOVE NEXT JOBNAME CHAR\nGETSTEP  LA    R0,8                AT JOBNAME END, SET MAX STEPNAME\n*                                  COUNT\n         LA    R11,1(0,R11)        INCR PAST BLANK BETW JBNM AND STEPNM\n         LA    R10,CSASTEPN        LD ADR OF STEPNAME PARM IN CSA\nNEXTSPOS CLI   0(R11),C' '         CHK FOR END OF STEPNAME\n         BER   R6                  AT END, RETURN TO CALLING RTN\n         MVC   0(1,R10),0(R11)     MOVE A CHAR OF STEPNM TO PARM IN CSA\n         LA    R11,1(0,R11)        INCR STEPNAME IN MSG IEF450I\n         LA    R10,1(0,R10)        INCR STEPNAME PARM IN CSA\n         BCT   R0,NEXTSPOS         MOVE NEXT STEPNAME CHAR\n         BR    R6                  AT STEPNAME END, RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES THE INTERNAL START COMMAND VIA THE MGCR MACRO\n*    (SVC 34).\n***********************************************************************\n*\nDOSTART  MVC   CSABUF34,MGCRBUFF   MOVE MSGBUF INTO CSA\n         LA    R0,0                ZERO REG 0 FOR SVC 34\n         LA    R10,CSABUF34        LD ADR OF MSGBUF IN CSA\n         MGCR  (R10)               ISSUE SVC 34\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS\n*\n*\n***********************************************************************\n*    CONSTANTS\n***********************************************************************\n*\nBLANKS   DC    CL8' '\n*\n*\n***********************************************************************\n*    PARAMETER-LIST FOR SVC 34\n***********************************************************************\n*\nMGCRBUFF DC    X'80'\n         DC    AL1(BUFFLEN)\n         DC    X'8000'             INDICATE TOKEN PRESENT\n         DC    C'S OPERALRT'\nMGCRBUFX EQU   *\nBUFFLEN  EQU   (MGCRBUFX-MGCRBUFF)\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         IEZVX100                  GENERATES CTXT, CTXTATTR DSECTS\n*\nCSAWORK  DSECT\nCSAJOBNM DS    CL8\nCSASTEPN DS    CL8\nCSABUF34 DS    CL(BUFFLEN)\nCSATOKEN DS    CL4\nCSAGMLEN ORG   *-CSAWORK\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n* THE CODE FOR OPERALRT:\n*\n*\nOPERALRT CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING CSCL,R10            DEFINE REG FOR CSCL DSECT\n         USING CSAPARM,R11         DEFINE REG FOR CSAPARM DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,EXTRACT          GET ADR OF C.S.C.L.\n         BAL   R6,GETPARM          GET CSA ADR FROM TOKEN FIELD\n         BAL   R6,DOWTOR           NOTIFY OPER OF ABEND VIA WTOR\n         BAL   R6,RELCSA           RELEASE CSA ALLO BY WTO/WTOR EXIT\n         B     RETURN              RETURN TO MVS\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE COMMAND SCHEDULER\n*    COMMUNICATIONS LIST (CSCL) WHICH CONTAINS THE TOKEN (PARAMETER-\n*    LIST ADDRESS) PASSED BY THE INTERNAL START COMMAND ISSUED BY THE\n*    WTO/WTOR EXIT.\n***********************************************************************\n*\nEXTRACT  EXTRACT CSCLADDR,FIELDS=(COMM)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE TOKEN CONTAINED IN THE CSCL. THE TOKEN\n*    CONTAINS THE ADDRESS OF THE VIRTUAL STORAGE ALLOCATED FROM THE CSA\n*    WHICH CONTAINS THE PARAMETER-LIST PASSED BY THE WTO/WTOR EXIT.\n***********************************************************************\n*\nGETPARM  L     R10,CSCLADDR        SET ADRBLTY FOR CSCL DSECT\n         TM    COMTOKEN,COMTOKHR   CHK IF TOKEN PRESENT\n         BNO   NOTOKEN             IF NO, ERROR\n         MVC   CSAADR,COMTOKEN     MOVE ADR OF ALLO CSA (CSAPARM)\n         BR    R6                  RETURN TO CALLING RTN\nNOTOKEN  WTO   '*** NO PARM SPECIFIED---PROGRAM TERMINATED ***'\n         WTO   '*** NOTIFY SYSTEMS PROGRAMMING DEPARTMENT ***'\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE INSERTS THE JOBNAME AND STEPNAME OF THE PRODUCTION\n*    JOB WHICH ABENDED INTO THE WTO-LIST. IT THEN ISSUES THE WTO/WTOR\n*    MACRO TO INFORM THE OPERATOR THAT A PRODUCTION JOB HAS ABENDED AND\n*    WAITS FOR A REPLY FROM THE OPERATOR WHICH INDICATES THAT THE\n*    OPERATOR SAW THE MESSEAGE AND IS PREPARING A TROUBLE REPORT.\n***********************************************************************\n*\nDOWTOR   L     R11,CSAADR          SET ADRBLTY FOR CSAPARM DSECT\n         MVC   WTO1JBNM,CSAJOBNM   MOVE JOBNAME INTO WTO-LIST\n         MVC   WTO1STEP,CSASTEPN   MOVE STEPNAME INTO WTO-LIST\nWTOR     LA    R1,WTOLST1          LOAD ADR OF WTO-LIST\n         WTO   MF=(E,(R1))         ISSUE EXEC-FORM OF WTO\n         XC    ECB,ECB             CLEAR ECB FOR WTOR\n         WTOR  '*** REPLY \"A\" TO ACKNOWLEDGE AND ISSUE TR ***',        -\n               REPLY,1,ECB\n         WAIT  1,ECB=ECB           WAIT FOR REPLY\n         CLI   REPLY,C'A'          CHK FOR PROPER REPLY\n         BER   R6                  IF REPLY OK, RET TO CALLING RTN\n         WTO   '*** INVALID REPLY ***'\n         B     WTOR                REISSUE WTOR\n*\n*\n***********************************************************************\n*    THIS ROUTINE RELEASES THE CSA STORAGE ALLOCATED BY THE WTO/WTOR\n*    EXIT.\n***********************************************************************\n*\nRELCSA   LA    R11,CSAADR          LOAD ADR OF CSAPARM ADR\n         FREEMAIN,EC,LV=100,SP=241,A(R11)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nCSCLADDR DS    F\nCSAADR   DS    F\nECB      DS    F\nREPLY    DS    CL1\n*\n*\n***********************************************************************\n*    THE WTO-LIST USED FOR INSERTING THE JOBNAME AND THE STEPNAME OF\n*    THE ABENDING JOB.\n***********************************************************************\n*\n         DS    0F\nWTOLST1  DC    AL2(WTOLST1X-WTOLST1)\n         DC    X'8000'\n         DC    C'*** OPERATIONS: JOB '\nWTO1JBNM DS    CL8\n         DC    C' HAS ABENDED AT STEP '\nWTO1STEP DS    CL8\n         DC    C' ***'\nWTOLST1X EQU   *\n         DC    X'4000'              DESC=2\n         DC    X'4000'              ROUT=2\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\nCSCL     DSECT\n         IEZCOM                     GENERATES CSCL DSECT\n*\nCSAPARM  DSECT\nCSAJOBNM DS    CL8\nCSASTEPN DS    CL8\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE051401": {"ttr": 3090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.14.1\n*\n*\n         USING PSA,R10             DEFINE REG FOR PSA DSECT\n         ...\n         LA    R10,0               LOAD ADR OF PSA\n         MVC   TCBADR,PSATOLD      EXTRACT TCB ADR\n         MVC   ASCBADR,PSAAOLD     EXTRACT ASCB ADR\n         ...\nTCBADR   DS    F\nASCBADR  DS    F\n         ...\n         IHAPSA                    GENERATES PSA DSECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE051402": {"ttr": 3092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.14.2\n*\n*\nGETINFO  ATTACH EP=IEFBR14\n         MVC   TCBADR,TCBOTC-TCB(R1)    STORE TCB ADR\n         EXTRACT ASID,FIELDS=(ASID)     GET ASID\n         L     R10,ASID\n         LOCASCB ASID=(R10)\n         ST    R1,ASCDADR               STORE ASCB ADR\n         BR    R7                       RETURN TO CALLING RTN\n         ...\nTCBADR   DS    F\nASID     DS    F\nASCBADR  DS    F\n         ...\n         IKJTCB                         GENERATES THE TCB DSECT\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE060101": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00b\\x00b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 6.1.1\n*\n*\nSPIE01   CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING PIE,R11             DEFINE REG FOR PIE DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         ...\n         BAL   R6,SETSPIE          ESTAB SPIE ENVIR\nNEXTREC  BAL   R6,READMSTR         READ A REC FROM MASTR FILE\n         BAL   R6,PROCESS          PROCESS RECORD\n         B     NEXTREC             READ NEXT REC\n         ...\n*\n*\n***********************************************************************\n*    THIS ROUTINE ESTABLISHES THE SPIE RECOVERY ENVIRONMENT. IT\n*    SPECIFIES THAT THE FOLLOWING INTERRUPTION TYPES ARE TO BE\n*    INTERCEPTED:\n*        * DATA EXCEPTION (7);\n*        * DECIMAL OVERFLOW (10);\n*        * DECIMAL DIVIDE (11).\n*    WHEN ONE OF THE SPECIFIED INTERRUPTION TYPES IS ENCOUNTERED,\n*    CONTROL IS PASSED TO THE RECOVERY ROUTINE DATACHK WHICH PROCESSES\n*    THE ABEND.\n***********************************************************************\n*\nSETSPIE  SPIE  DATACHK,(7,10,11)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL VIA THE SPIE SERVICE ROUTINE WHEN\n*    THE PROGRAM ENCOUNTERS AN S0C7, S0CA OR S0CB ABEND. WHEN THE ABEND\n*    PROCESSING IS COMPLETE, DATACHK RETURNS CONTROL TO THE NEXTREC\n*    ROUTINE OF THE MAIN PROGRAM.\n***********************************************************************\n*\nDATACHK  ST    R14,SAVR14          SAVE RETURN ADR TO SPIE\n         LR    R11,R1              SET ADRBLTY FOR PIE DSECT\n         CLI   PIEPSW+3,X'07'      CHK IF 07 INTERRUPTION TYPE\n         BE    INCR0C7             IF YES, INCR 0C7 ERROR CTR\n         B     INCR0CAB            IF NO, INCR 0CA/OCB ERROR CTR\nINCR0C7  AP    ERR1CTR,ONE         INCR 0C7 ERROR CTR\n         B     DODUMP              DUMP RECORD\nINCR0CAB AP    ERR2CTR,ONE         INCR 0CA/0CB ERROR CTR\nDODUMP   BAL   R7,DUMP             PRODUCE HEX DUMP OF RECORD\n         L     R10,=A(NEXTREC)     LOAD RETRY ADR TO MAIN PROG\n         ST    R10,PIEPSW+4        PUT RETRY ADR INTO PIE\n         L     R14,SAVR14          RESTORE REG 14\n         BR    R14                 PASS CNTRL TO NEXTREC RTN VIA SPIE\n*\n*\n***********************************************************************\n*    THE SUBROUTINE PRODUCES A HEX DUMP OF EACH RECORD WHICH CONATINS\n*    BAD DATA.\n***********************************************************************\n*\nDUMP     ...                       DO REQUIRED DUMP\n         BR    R7                  RETURN TO CALLING RTN\n         ...\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nSAVR14   DS    F\nONE      DC    P'1'\nERR1CTR  DC    PL3'0'              ERROR CTR FOR S0C7 ABENDS\nERR2CTR  DC    PL3'0'              ERROR CTR FOR S0CA/S0CB ABENDS\n         ...\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         IHAPIE                    GENERATES PIE DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE060102": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00$\\x00$\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 6.1.2\n*\n*\n* CALLING PROGRAM:\n*\n*\nPROG01   CSECT\n         ...\n         SPIE  EXIT01,(1,4,7)\n         ...\n         LINK  EP=PROG02\n         ...\n         END\n*\n*\n*\n*\n* CALLED PROGRAM:\n*\n*\nPROG02   CSECT\n         ...\nSETSPIE  SPIE  EXIT02,(11)\n         ST    R1,PICAADR          SAVE PREV PICA ADR\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nRETURN   L     R10,PICADDR         LOAD PREV PICA ADR\n         SPIE  MF=(E,(R10))        RESTORE SPIE ENVIR OF CALLING PROG\n         L     R13,4(0,R13)        RESTORE ADR OF PREV SA\n         LM    R14,R12,12(R13)     RESTORE REGS OF CALLING PROG\n         BR    R14                 RETURN TO CALLING PROG\n         ...\nPICAADR  DS    F\n         ...\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE060103": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00c\\x00c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 99, "newlines": 99, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 6.1.3\n*\n*\nESPIE01  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING EPIE,R11            DEFINE REG FOR EPIE DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         ...\n         BAL   R6,SETESPIE         ESTAB ESPIE ENVIR\nNEXTREC  BAL   R6,READMSTR         READ A REC FROM MASTR FILE\n         BAL   R6,PROCESS          PROCESS RECORD\n         B     NEXTREC             READ NEXT RECORD\n         ...\n*\n*\n***********************************************************************\n*    THIS ROUTINE ESTABLISHES THE ESPIE RECOVERY ENVIRONMENT. IT\n*    SPECIFIES THAT THE FOLLOWING INTERRUPTION TYPES ARE TO BE\n*    INTERCEPTED:\n*        * DATA EXCEPTION (7);\n*        * DECIMAL OVERFLOW (10);\n*        * DECIMAL DIVIDE (11).\n*    WHEN ONE OF THE SPECIFIED INTERRUPTION TYPES IS ENCOUNTERED,\n*    CONTRO IS PASSED TO THE RECOVERY ROUTINE DATACHK WHICH PROCESSES\n*    THE ABEND. THE RETRY ADDRESS IS PASSED TO DATACHK VIA THE PARAM\n*    PARAMETER.\n***********************************************************************\n*\nSETESPIE ESPIE SET,DATACHK,(7,10,11),PARAM=RETRYADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL VIA THE ESPIE SERVICE ROUTINE WHEN\n*    THE PROGRAM ENCOUNTERS A S0C7, S0CA OR S0CB ABEND. WHEN THE ABEND\n*    PROCESSING IS COMPLETE, DATACHK RETURNS CONTROL THE MAIN PROGRAM\n*    AT THE ADDRESS SPECIFIED VIA THE PARAM PARAMETER PASSED BY ESPIE.\n***********************************************************************\n*\nDATACHK  ST    R14,SAVR14          SAVE RETURN ADR TO ESPIE\n         LR    R11,R1              SET ADRBLTY FOR EPIE DSECT\n         L     R10,EPIEPARM        LOAD ADR OF PARM-LIST\n         L     R10,0(0,R10)        LOAD RETRY ADR TO MAIN PROG\n         CLI   EPIEINT+3,X'07'     CHK IF 07 INTERRUPTION TYPE\n         BE    INCR0C7             IF YES, INCR 0C7 ERROR CTR\n         AP    ERR2CTR,ONE         IF NO, INCR 0CA/0CB ERROR CTR\n         B     DODUMP              BYPASS THE INCR OF 0C7 ERR CTR\nINCR0C7  AP    ERR1CTR,ONE         INCR 0C7 ERROR CTR\nDODUMP   BAL   R7,DUMP             PRODUCE HEX DUMP OF REC\n         ST    R10,EPIEPSW+4       PUT RETRY RTN ADR INTO EPIE\n         L     R14,SAVR14          RESTORE REG 14\n         BR    R14                 PASS CNTRL TO NEXTREC RTN VIA ESPIE\n*\n*\n***********************************************************************\n*    THE SUBROUTINE PRODUCES A HEX DUMP OF EACH RECORD WHICH CONATINS\n*    BAD DATA.\n***********************************************************************\n*\nDUMP     ...                       DO REQUIRED DUMP\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\n         ...\nONE      DC    P'1'\nERR1CTR  DC    PL3'0'              ERROR CTR FOR S0C7 ABENDS\nERR2CTR  DC    PL3'0'              ERROR CTR FOR S0CA/S0CB ABENDS\nRETRYADR DC    A(NEXTREC)\n         ...\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         IHAEPIE                   GENERATES EPIE DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE060104": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00#\\x00#\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 6.1.4\n*\n*\n* CALLING PROGRAM:\n*\n*\nPROG01   CSECT\n         ...\n         ESPIE SET,EXIT01,(1,4,7)\n         ...\n         LINK  EP=PROG02\n         ...\n         END\n*\n*\n*\n*\n* CALLED PROGRAM:\n*\n*\nPROG02   CSECT\n         ...\nSETESPIE ESPIE SET,EXIT02,(11)\n         ST    R1,TOKEN            SAVE TOKEN OF PREV ESPIE ENVIR\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nRETURN   ESPIE RESET,TOKEN         RESTORE ESPIE ENVIR OF CALLING PROG\n         L     R13,4(0,R13)        RESTORE ADR OF PREV SA\n         LM    R14,R12,12(R13)     RESTORE REGS OF CALLING PROG\n         BR    R14                 RETURN TO MVS OR CALLING PROG\n         ...\nTOKEN    DS    F\n         ...\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE060201": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 6.2.1\n*\n*\n         ESTAE EXITRTN,CT,PARAM=PARMLIST\n         ...\nEXITRTN  DS    0H\n         ...\nRETRYRTN DS    0H\n         ...\nSTATUS   DC    X'00'\n         ...\nPARMLIST DC    A(RETRYRTN)\n         DC    A(STATUS)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE060202": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\xb3\\x01\\xb3\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 435, "newlines": 435, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 6.2.2\n*\n*\nESTAE01  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETESTAE         SETUP ESTAE ENVIRONMENT\n         BAL   R6,ALLOCSA          ALLOCATE STORAGE FROM CSA\n         BAL   R6,BLDTBL           BUILD SECURITY TABLE\n         BAL   R6,ALLOBUFF         ALLO STOR FOR BUFF POOL & CNTL REC\n         BAL   R6,OPEN             OPEN DATASETS\nNXGROUP  BAL   R6,GETRECS          READ A GROUP OF RECS INTO BUF POOL\n         BAL   R6,PROCESS          PROCESS RECORDS IN BUFFER POOL\n         BAL   R6,PUTRECS          WRITE BUFFER POOL RECS INTO DATASET\n         B     NXGROUP             READ NEXT GROUP OF RECORDS\nDATAEND  BAL   R6,PUTCNTL          WRITE CONTROL RECORD\n         BAL   R6,CLOSE            CLOSE DATASETS\n         B     RETURN              RETURN TO MVS OR CALLING PROGRAM\n*\n*\n***********************************************************************\n*    THIS ROUTINE ESTABLISHES THE ESTAE RECOVERY ENVIRONMENT. WHEN A\n*    SYSTEM OR A USER ABEND IS ENCOUNTERED, THE RECOVERY EXIT ROUTINE\n*    RECVEXIT RECEIVES CONTROL AND THE ADDRESSES OF THE PARAMETERS\n*    POINTED TO BY PARMLIST ARE PASSED TO THE RECOVERY EXIT ROUTINE.\n***********************************************************************\n*\nSETESTAE ESTAE RECVEXIT,CT,TERM=YES,PARAM=PARMLIST\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE FROM THE CSA FOR THE\n*    SECURITY TABLE. WHEN THE CSA STORAGE IS SUCCESSFULLY ALLOCATED,\n*    AN INDICATOR BIT IS SET IN THE STATUS BYTE.\n***********************************************************************\n*\nALLOCSA  L     R10,CSALEN          LOAD LEN OF REQD CSA STOR\n         GETMAIN EC,LV=(R10),SP=241,A=CSAADR\n         OI    STATUS,INDCSA       INDICATE CSA ALLOCATED\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CREATES THE SECURITY TABLE IN THE CSA. WHEN THE\n*    CREATION OF THE TABLE IS SUCCESSFULLY COMPLETED, AN INDICATOR BIT\n*    IS SET IN THE STATUS BYTE.\n***********************************************************************\n*\nBLDTBL   ...\n         OI    STATUS,INDTBLOK     INDICATE TABLE CREATED OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE FOR THE BUFFER POOL AND THE\n*    CONTROL RECORD. THE LENGTH OF THE GETMAIN IS GOVERNED BY THE EQU\n*    SYMBOL GMLEN WHICH IS CALCULATED (BY THE ASSEMBLER) BY MULTIPLYING\n*    THE DESIRED NUMBER OF RECORDS (RECGROUP) IN THE BUFFER POOL BY THE\n*    RECORD LENGTH PLUS THE LENGTH OF THE CONTROL RECORD.\n***********************************************************************\n*\nALLOBUFF GETMAIN RC,LV=GMLEN       ALLOC STOR FOR BUFF POOL + CNTL REC\n         ...                       CHK IF GM OK\n         ST    R1,BUFFADR          SAVE ADR OF BG OF BUFF POOL\n         LA    R1,BUFFLEN(0,R1)    INCR PASS BUFF POOL TO CNTL REC\n         ST    R1,CNTLADR          SAVE ADR OF CNTL REC\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS. AN INDICATOR BIT IS SET IN THE\n*    STATUS BYTE WHEN THE OUTPUT DCB IS SUCCESSFULLY OPENED.\n***********************************************************************\n*\nOPEN     OPEN  (DCB1,,DCB,(OUTPUT))\n         ...                       CHECK IF OPEN OK\n         OI    STATUS,INDDCB2      INDICATE THAT OUTPUT DCB OPENED\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS RECGROUP NUMBER OF RECORDS FROM THE INPUT\n*    DATASET AND CALLS THE SUBROUTINE PUTBUFF AFTER EACH READ TO MOVE\n*    THE RECORD INTO THE BUFFER POOL.\n***********************************************************************\n*\nGETRECS  LA    R10,RECGROUP        SET NUMB OF RECS IN BUFF POOL\nNEXTREC  GET   DCB1                READ A LOGICAL REC\n         LR    R2,R1               SAVE ADR OF LOGICAL RECORD\n         BAL   R7,PUTBUFF          MOVE REC INTO A BUFF OF THE POOL\n         BCT   R10,NEXTREC         IF BUFF POOL NOT FILLED, READ REC\n         BR    R6                  IF FILLED, RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PROCESSES THE RECORDS IN THE BUFFER POOL. IN ORDER TO\n*    PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO THE SUBRTNS\n*    WHICH HAVE THE FOLLOWING FUNCTIONS:\n*        * VALIDATE EACH RECORD IN THE BUFFER POOL;\n*        * UPDATE THE RECORDS IN THE BUFFER POOL;\n*        * UPDATE THE CONTROL RECORD WHEN ALL THE RECORDS IN THE BUFFER\n*          POOL ARE PROCESSED.\n*    WHEN PROCESSING IS SUCCESSFULLY COMPLETED, THEN TWO INDICATOR BITS\n*    ARE SET IN THE STATUS BYTE: ONE BIT TO INDICATE THAT THE RECORDS\n*    WERE UPDATED AND THE OTHER BIT TO INDICATE THAT THE CONTROL RECORD\n*    WAS UPDATED.\n***********************************************************************\n*\nPROCESS  BAL   R7,VALIDATE         VALIDATE RECS IN BUFF POOL\n         BAL   R7,UPDRECS          UPDATE RECS IN BUFF POOL\n         BAL   R7,UPDCNTL          UPDATE CNTL REC IN VIR STOR\n         OI    STATUS,INDBUF       IND THAT ALL BUFF RECS UPDATED\n         OI    STATUS,INDCNTL      IND THAT CNTL REC UPDATED\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE WRITES THE UPDATED RERCORDS FROM THE BUFFER POOL INTO\n*    THE OUTPUT DATASET. WHEN ALL THE RECORDS FROM THE BUFFER POOL HAVE\n*    BEEN SUCCESSFULLY WRITTEN, THEN THE INDICATOR BIT IS RESET IN THE\n*    STATUS BYTE.\n***********************************************************************\n*\nPUTRECS  ...                       WRITE UPDATED RECORDS INTO DATASET\n         NI    STATUS,INDXBUF      IND THAT RECS IN BUFF POOL WRITTEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE WRITES THE CONTROL RECORD INTO THE OUTPUT DATASET\n*    WHEN ALL THE INPUT RECORDS ARE PROCESSED.\n***********************************************************************\n*\nPUTCNTL  L     R10,CNTLADR         LOAD ADR OF CNTL REC\n         PUT   DCB2,(R10)          WRITE CNTL REC\n         OI    STATUS,INDXCNTL     IND THAT CNTL REC WRITTEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS. THE INDICATOR BIT IS RESET IN\n*    THE STATUS BYTE WHEN THE OUTPUT DCB IS SUCCESSFULLY CLOSED.\n***********************************************************************\n*\nCLOSE    CLOSE (DCB1,,DCB2)\n         NI    STATUS,INDXDCB2     INDICATE THAT OUTPUT DCB CLOSED\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*   THIS IS THE PARMLIST WHICH IS PASSED BY THE ESTAE SERVICE ROUTINE\n*   TO THE RECOVERY EXIT ROUTINE.\n***********************************************************************\n*\nPARMLIST DC    A(STATUS)           ADR OF STATUS BYTE\n         DC    A(CSAADR)           ADR OF FWD CONTAINING CSA STOR ADR\n         DC    A(CSALEN)           ADR OF FWD CONTAINING CSA STOR LEN\n         DC    A(DCB2)             ADR OF OUTPUT DCB ADR\nBUFFADR  DS    F                   ADR OF BG OF BUFFER POOL\nCNTLADR  DS    F                   ADR OF CONTROL RECORD\n*\n*** END OF PARMLIST ***\n*\nCSAADR   DS    F                   ADR OF ALLO CSA STOR\nCSALEN   DC    A(4096)             LENGTH OF ALLO CSA STOR\n*\n*\n***********************************************************************\n*    EQUS FOR STATUS INDICATOR BIT SETTINGS.\n***********************************************************************\n*\nSTATUS   DC    X'00'               STATUS BYTE CONTAINING INDICATORS\nINDCSA   EQU   X'80'               CSA ALLOCATED\nINDTBLOK EQU   X'40'               TABLE SUCCESSFULLY CREATED\nINDDCB2  EQU   X'20'               OUTPUT DCB OPENED\nINDXDCB2 EQU   X'DF'               OUTPUT DCB CLOSED\nINDBUFF  EQU   X'10'               BUFFER POOL CONTAINS RECS TO WRITE\nINDXBUFF EQU   X'EF'               RECS IN BUFFER POOL WRITTEN\nINDCNTL  EQU   X'01'               CONTROL RECORD NOT WRITTEN YET\nINDXCNTL EQU   X'FE'               CONTROL RECORD WRITTEN\n*\n*\n***********************************************************************\n*    EQUS USED TO CALCULATE GETMAIN LENGTH FOR BUFFER POOL AND CONTROL\n*    RECORD.\n***********************************************************************\n*\nLRECL    EQU   80                  LENGTH OF DATA RECS AND CNTL REC\nRECGROUP EQU   10                  DESIRED NUMBER OF RECS IN BUFF POOL\nBUFFLEN  EQU   LRECL*RECGROUP      LENGTH OF BUFF REQD FOR DATA RECS\nGMLEN    EQU   BUFFLEN+LRECL       GM LEN = BUFFLEN + CNTLREC LEN\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nDCB1     DCB   ...\nDCB2     DCB   ...\n*\n*\n*\n*\n***********************************************************************\n*    THE FOLLOWING CSECT IS THE ESTAE RECOVERY EXIT REFERENCED IN THE\n*    ESTAE MACRO IN THE MAIN PROGRAM.\n***********************************************************************\n*\nRECVEXIT CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         USING *,R3                DEFINE BASE REG\n         USING SDWA,R12            DEFINE REG FOR SDWA DSECT\n         LR    R3,R15              SET ADRBLTY FOR REVC EXIT RTN\n         ST    R14,SAVR14          SAVE RETURN ADR TO RTM\n*\n*\n***********************************************************************\n*    THE FOLLOWING CODE DETERMINES IF AN SDWA HAS BEEN PROVIDED.\n***********************************************************************\n*\n         C     R0,BIN12            CHK IF SDWA CREATED\n         BE    NOSDWA              PROCESS WITHOUT SDWA\n         B     YESSDWA             PROCESS USING SDWA\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF AN SDWA WAS NOT PROVIDED. THIS\n*    ROUTINE LOADS THE PARAMTER-LIST ADDRESS INTO THE REGISTER EXPECTED\n*    BY THE RECOVERY ROUTINE; BRANCHES AND LINKS TO THE RECOVERY\n*    ROUTINE; INDICATES THAT A SDWA WAS NOT PROVIDED; AND PASSES\n*    CONTROL TO THE RECOVERY-EXIT RETURN ROUTINE.\n***********************************************************************\n*\nNOSDWA   LR    R10,R2              LOAD ADR OF PARM-LIST\n         BAL   R6,RECVYRTN         DO RECOVERY\n         LA    R15,0               IND NO SDWA\n         B     EXITRET             EXIT RECOVERY-EXIT\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF AN SDWA WAS PROVIDED. THIS\n*    ROUTINE SAVES THE ADDRESS OF THE SDWA, LOADS THE PARAMTER-LIST\n*    ADDRESS INTO THE REGISTER EXPECTED BY THE RECOVERY ROUTINE,\n*    BRANCHES AND LINKS TO THE RECOVERY ROUTINE, INDICATES THAT AN\n*    SDWA WAS PROVIDED, AND PASSES CONTROL TO THE RECOVERY-EXIT\n*    RETURN ROUTINE.\n***********************************************************************\n*\nYESSDWA  LR    R12,R1              SET ADRBLTY FOR SDWA DSECT\n         L     R10,SDWAPARM        LOAD ADR OF PARM-LIST\n         BAL   R6,RECVYRTN         DO RECOVERY\n         LA    R15,4               IND SDWA PROVIDED\n         B     EXITRET             EXIT RECOVERY-EXIT\n*\n*\n***********************************************************************\n*    THE MAINSTREAM OF THE RECOVERY EXIT ROUTINE\n***********************************************************************\n*\nRECVYRTN BAL   R7,GETPARMS         GET PARM ADRS\n         BAL   R7,FREEMAIN         CHK IF CSA FREEMAIN REQUIRED\n         BAL   R7,PUTRECX          CHK IF BUFF WRITE REQUIRED\n         BAL   R7,PUTCNTLX         CHK IF CNTL-REC WRITE REQUIRED\n         BAL   R7,CLOSEX           CHK IF CLOSE REQUIRED\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESSES OF THE PARAMETERS SPECIFIED BY\n*    THE ESTAE MACRO AND PASSED TO THE RECOVERY ROUTINE BY RTM.\n***********************************************************************\n*\nGETPARMS L     R11,0(0,R10)        LD ADR OF PARM STATUS\n         ST    R11,STATADRX        STORE ADR OF STATUS\n         L     R11,4(0,R10)        LD ADR OF PARM CSAADR\n         ST    R11,GMADRX          STORE ADR OF ADR OF CSA STOR\n         L     R11,8(0,R10)        LD ADR OF PARM CSALEN\n         ST    R11,GMLENX          STORE ADR OF CSALEN\n         L     R11,12(0,R10)       LD ADR OF PARM DCB2\n         ST    R11,DCB2ADRX        STORE ADR OF DCB2\n         L     R11,16(0,R10)       LD ADR OF PARM BUFFADR\n         ST    R11,BUFFADRX        STORE ADR OF BG OF BUFF POOL\n         L     R11,20(0,R10)       LD ADR OF PARM CNTLADR\n         ST    R11,CNTLADRX        STORE ADR OF CNTL REC\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE STATUS BYTE TO DETERMINE IF THE ALLOCATED\n*    CSA STORAGE IS TO BE RELEASED. THIS DECISION IS MADE BY VERIFYING\n*    IF THE SECURITY TABLE WAS CREATED OK. IF THE TBL WAS SUCCESSFULLY\n*    CREATED, THEN THE CSA STORAGE REMAINS ALLOCATED.\n***********************************************************************\n*\nFREEMAIN L     R11,STATADRX        LOAD ADR OF STATUS FIELD\n         TM    0(R11),INDCSA       WAS CSA ALLO\n         BZR   R7                  IF NO, RETURN TO CALLING RTN\n         TM    0(R11),INDTBLOK     IF YES, CHK IF TBL CREATED OK\n         BOR   R7                  IF YES, RETURN TO CALLING RTN\n         L     R10,GMLENX          IF NO, RELEASE IT --- LOAD CSA LEN\n         LA    R11,GMADRX          LOAD ADR OF FWD WHICH HAS CSA ADR\n         FREEMAIN EU,LV=(R10),SP=241,A=(R11)\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE STATUS BYTE TO DETERMINE IF THE BUFF POOL\n*    CONTAINS RECORDS WHICH ARE TO BE WRITTEN INTO THE OUTPUT DATASET.\n***********************************************************************\n*\nPUTRECSX L     R11,STATADRX        LOAD ADR OF STATUS FIELD\n         TM    0(R11),INDBUFF      CHK IF BUFF HAS RECS TO WRITE\n         BZR   R7                  IF NO, RETURN TO CALLING RTN\n         ...                       IF YES, WRITE THEM\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE STATUS BYTE TO DETERMINE IF THE CONTROL\n*    RECORD, WHICH IS IN VIRTUAL SRORAGE, IS TO BE WRITTEN INTO THE\n*    OUTPUT DATASET.\n***********************************************************************\n*\nPUTCNTLX L     R11,STATADRX        LOAD ADR OF STATUS FIELD\n         TM    0(R11),INDCNTL      CHK IF CNTL REC HAS TO BE WRITTEN\n         BZR   R7                  IF NO, RETURN TO CALLING RTN\n         L     R11,DCB2ADRX        IF YES, LOAD DCB2 ADR\n         L     R12,CNTLADRX        LOAD CNTL REC ADR\n         PUT   (R11),(R12)         WRITE CNTL REC\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE STATUS BYTE TO DETERMINE IF THE OUTPUT DCB\n*    IS REQUIRED TO BE CLOSED.\n***********************************************************************\n*\nCLOSEX   L     R11,STATADRX        LOAD ADR OF STATUS FIELD\n         TM    0(R11),INDDCB2      CHK IF DCB2 OPENED\n         BZR   R7                  IF NO, RETURN TO CALLING RTN\n         L     R11,DCB2ADRX        IF YES, LOAD DCB2 ADR\n         CLOSE (R11)               CLOSE DCB2\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL WHEN THE RECOVERY EXIT ROUTINE IS TO\n*    RETURN CONTROL TO RTM. THIS ROUTINE CHECKS WHETHER OR NOT AN SDWA\n*    WAS PROVIDED AND CAUSES CONTROL TO BE RETURNED ACCORDINGLY.\n***********************************************************************\n*\nEXITRET  LTR   R15,R15             CHK IF SDWA PROVIDED\n         BZ    RETXSDWA            IF NO, RETURN WITHOUT SDWA\n         B     RETSDWA             IF YES, RETURN WITH SDWA\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL WHEN AN SDWA WAS NOT PROVIDED.\n***********************************************************************\n*\nRETXSDWA LA    R15,0               INDICATE --- CONTINUE WITH ABEND\n         L     R14,SAVR14          RESTORE RETURN ADR\n         BR    R14                 RETURN TO RTM\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL WHEN AN SDWA WAS PROVIDED.\n***********************************************************************\n*\nRETSDWA  SETRP WKAREA=(R12),RC=0,DUMP=NO   RC=0 --- CONTIN WITH ABEND\n         L     R14,SAVR14          RESTORE RETURN ADR\n         BR    R14                 RETURN TO RTM\n*\n*\n***********************************************************************\n*    THE FOLLOWING ARE THE FULLWORDS USED TO STORE THE PARAMETER\n*    ADDRESSES RECEIVED FROM THE ESTAE SERVICE ROUTINE AND THE\n*    FULLWORD TO SAVE THE RETURN ADDRESS TO RTM.\n***********************************************************************\n*\nSTATADRX DS    F                   ADR OF THE STATUS BYTE\nGMADRX   DS    F                   ADR OF THE ADR OF THE ALLO CSA STOR\nGMLENX   DS    F                   ADR OF THE LEN OF THE ALLO CSA STOR\nDCB2ADRX DS    F                   ADR OF THE OUTPUT DCB\nBUFFADRX DS    F                   ADR OF THE BG OF THE BUFFER POOL\nCNTLADRX DS    F                   ADR OF THE CONTROL RECORD\n*\nSAVR14   DS    F                   RETURN ADR TO RTM\n*\n*\n***********************************************************************\n*    CONSTANTS USED BY EXIT ROUTINE\n***********************************************************************\n*\nBIN12    DC    F'12'\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         IHASDWA                   GENERATES SDWA DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE060203": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01|\\x01|\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 380, "newlines": 380, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 6.2.3\n*\n*\nESTAE02  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING INFMJFCB,R10        DEFINE REG FOR JFCB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETESTAE         SETUP ESTAE ENVIRONMENT\n         BAL   R6,RDJFCB           READ JFCB INTO PROG AREA\nNEXTDSNM BAL   R6,SETDSNM          PUT REQD DATASET NAME INTO JFCB\n         BAL   R6,OPENJ            OPEN USING MODIFIED JFCB\n         BAL   R6,PROCESS          PROCESS DATASET\nDATAEND  BAL   R6,CLOSE            ALL RECS READ, CLOSE DCB\n         B     NEXTDSNM            ALLO NEXT DATASET\nDATAERR1 BAL   R6,CLOSE            S213 ABEND, CLOSE DCB\n         BAL   R6,DOERMSG1         DSPLY ERR MSG FOR S213\n         B     NEXTDSNM            ALLO NEXT DATASET\nDATAERR2 BAL   R6,CLOSE            SX37 ABEND, CLOSE DCB\n         BAL   R6,DOERMSG2         DSPLY ERR MSG FOR SX37\n         B     NEXTDSNM            ALLO NEXT DATASET\nDSNMEND  B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE ESTABLISHES THE ESTAE RECOVERY ENVIRONMENT. WHEN A\n*    SYSTEM OR A USER ABEND IS ENCOUNTERED, THE RECOVERY EXIT ROUTINE\n*    RECVEXIT RECEIVES CONTROL AND THE ADDRESSES OF THE PARAMETERS\n*    POINTED TO BY PARMLIST ARE PASSED TO THE RECOVERY EXIT ROUTINE.\n***********************************************************************\n*\nSETESTAE ESTAE RECVEXIT,CT,PARAM=PARMLIST\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCB INTO THE AREA DEFINED IN THE PROGRAM\n*    AND INITIALIZES THE DATASET NAME TABLE POINTER TO POINT TO THE\n*    FIRST ENTRY.\n***********************************************************************\n*\nRDJFCB   RDJFCB DCB01\n         ...                       CHK IF DD STMT IN JCL\n         LA    R10,DSNMTBL         LD ADR OF 1ST DSNM ENTRY OF TBL\n         ST    R10,DSNMPTR         STORE ADR OF NEXT ENTRY TO BE PROC\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS THE DATASET NAME OF THE CURRENT ENTRY OF THE\n*    DATASET NAME TABLE INTO THE JFCB AND INCREMENTS TO THE NEXT ENTRY.\n***********************************************************************\n*\nSETDSNM  L     R10,DSNMPTR         LD ADR OF DATASET ENTRY TO BE PROC\n         CLI   0(R10),X'00'        CHK FOR END-OF-TBL\n         BE    DSNMEND             IF YES, TERMINATE PROG\n         MVC   JFCBDSNM,0(R10)     IF NO, PUT DSNM INTO JFCB\n         LA    R10,ENTLEN(0,R10)   INCR TO NEXT DSNM ENTRY\n         ST    R10,DSNMPTR         STORE ADR OF NEXT ENTRY TO BE PROC\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE DCB AND ALLOCATES THE DATASET NAMED IN THE\n*    JFCB.\n***********************************************************************\n*\nOPENJ    OPEN  DCB01,TYPE=J        OPEN USING MDFY JFCB\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PROCESSES THE DATASET.\n***********************************************************************\n*\nPROCESS  ...                       PROCESS DATASET\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE DCB.\n***********************************************************************\n*\nCLOSE    CLOSE DCB01               CLOSE DCB OF CUR DATASET\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE DISPLAYS A MESSAGE ON THE HARDCOPY JOBLOG TO INDICATE\n*    THAT AN S213 ABEND WAS INTERCEPTED FOR THE SPECIFIED DATASET NAME.\n***********************************************************************\n*\nDOERMSG1 ...\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE DISPLAYS A MESSAGE ON THE HARDCOPY JOBLOG TO INDICATE\n*    THAT AN SX37 ABEND WAS INTERCEPTED FOR THE SPECIFIED DATASET NAME.\n***********************************************************************\n*\nDOERMSG2 ...\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE DATASET NAME TABLE. THIS TABLE CONTAINS THE NAMES OF ALL THE\n*    DATASETS WHICH ARE TO BE ALLOCATED AND PROCESSED.\n***********************************************************************\n*\nENTLEN   EQU   44\nDSNMTBL  DC    CL44'USER.FILE1'\n         DC    CL44'USER.FILE2'\n         DC    CL44'USER.FILE3'\n         DC    CL44'USER.FILE4'\n         DC    CL44'USER.FILE5'\n         DC    X'00'               END-OF-TBL INDICATOR\nDSNMPTR  DS    F                   POINTER TO CURRENT ENTRY\n*\n*\n***********************************************************************\n*   THIS IS THE PARMLIST WHICH IS PASSED BY THE ESTAE SERVICE ROUTINE\n*   TO THE RECOVERY EXIT ROUTINE.\n***********************************************************************\n*\nPARMLIST DC    A(ABCODTBL)\n         DC    A(RETRYTBL)\n*\n*\n***********************************************************************\n*    THE ABEND-CODE TABLE. THIS TABLE CONTAINS THE LIST OF ALL THE\n*    ABEND CODES FOR WHICH A RETRY IS TO BE PERFORMED. THE RETRY\n*    ADDRESS IS SPECIFIED IN THE CORRESPONDING ENTRY OF THE\n*    RETRY-ADDRESS TABLE.\n***********************************************************************\n*\nABCODTBL DC    X'21300000'         ABEND CODE-1 TO INTERCEPT\n         DC    X'B3700000'         ABEND CODE-2 TO INTERCEPT\n         DC    X'D3700000'         ABEND CODE-3 TO INTERCEPT\n         DC    X'E3700000'         ABEND CODE-4 TO INTERCEPT\n         DC    XL4'00'             END OF ABEND-CODE TABLE\n*\n*\n***********************************************************************\n*    THE RETRY-ADDRESS TABLE. THIS TABLE CONTAINS THE LIST OF ALL THE\n*    RETRY ADDRESSES WHICH CORRESPOND TO THE ENTRIES IN THE SAME\n*    RELATIVE LOCATION OF THE ABEND-CODE TABLE.\n***********************************************************************\n*\nRETRYTBL DC    A(DATAERR1)         RETRY ADR FOR ABEND CODE-1\n         DC    A(DATAERR2)         RETRY ADR FOR ABEND CODE-2\n         DC    A(DATAERR2)         RETRY ADR FOR ABEND CODE-3\n         DC    A(DATAERR2)         RETRY ADR FOR ABEND CODE-4\n         DC    XL4'00'             END OF RETRY-ADR TABLE\n*\n*\n***********************************************************************\n*    THE JFCB LIST AND THE DCB\n***********************************************************************\n*\n         CNOP  0,4\nJFCBPTR  DC    X'87'\n         DC    AL3(JFCB)\nJFCB     DS    44F\n*\nDCB01    DCB   DSORG=PS,MACRF=GL,EXLST=JFCBPTR,EODAD=DATAEND,          -\n               DDNAME=FILESDD\n*\n*\n*\n*\n*\n*\n*\n*\n***********************************************************************\n*    THE FOLLOWING CSECT IS THE ESTAE RECOVERY EXIT REFERENCED IN THE\n*    ESTAE MACRO IN THE MAIN PROGRAM.\n***********************************************************************\n*\nRECVEXIT CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         USING *,R3                DEFINE BASE REG\n         USING SDWA,R12            DEFINE REG FOR SDWA DSECT\n         LR    R3,R15              SET ADRBLTY FOR RECV EXIT RTN\n         ST    R14,SAVR14          SAVE RETURN ADR TO RTM\n*\n*\n***********************************************************************\n*    THE FOLLOWING CODE DETERMINES IF AN SDWA HAS BEEN PROVIDED.\n***********************************************************************\n*\n         C     R0,BIN12            CHK IF SDWA CREATED\n         BE    NOSDWA              PROCESS WITHOUT SDWA\n         B     YESSDWA             PROCESS USING SDWA\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF AN SDWA WAS NOT PROVIDED. THIS\n*    ROUTINE LOADS THE PARAMTER-LIST ADDRESS INTO THE REGISTER EXPECTED\n*    BY THE RECOVERY ROUTINE; BRANCHES AND LINKS TO THE RECOVERY\n*    ROUTINE; INDICATES THAT AN SDWA WAS NOT PROVIDED; AND PASSES\n*    CONTROL TO THE RECOVERY-EXIT RETURN ROUTINE.\n***********************************************************************\n*\nNOSDWA   LR    R10,R2              LD ADR OF PARM-LIST\n         ST    R1,ABCODE           STORE ABEND CODE\n         BAL   R6,RECVYRTN         DO RECOVERY\n         LA    R10,0               IND NO SDWA\n         B     EXITRET             EXIT RECOVERY-EXIT\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF AN SDWA WAS PROVIDED. THIS\n*    ROUTINE SAVES THE ADDRESS OF THE SDWA, LOADS THE PARAMTER-LIST\n*    ADDRESS INTO THE REGISTER EXPECTED BY THE RECOVERY ROUTINE,\n*    BRANCHES AND LINKS TO THE RECOVERY ROUTINE, INDICATES THAT AN\n*    SDWA WAS PROVIDED, AND PASSES CONTROL TO THE RECOVERY-EXIT RETURN\n*    ROUTINE.\n***********************************************************************\n*\nYESSDWA  LR    R12,R1              SET ADRBLTY FOR SDWA DSECT\n         L     R10,SDWAPARM        LOAD ADR OF PARM-LIST\n         XC    ABCODE,ABCODE       CLEAR ABEND CODE HOLD AREA\n         MVC   ABCODE(3),SDWACMPC  STORE ABEND CODE\n         BAL   R6,RECVYRTN         DO RECOVERY\n         LA    R10,4               IND SDWA PROVIDED\n         B     EXITRET             EXIT RECOVERY-EXIT\n*\n*\n***********************************************************************\n*    THE MAINSTREAM OF THE RECOVERY EXIT ROUTINE\n***********************************************************************\n*\nRECVYRTN BAL   R7,GETPARMS         GET PARM ADRS\n         BAL   R7,CHKABCOD         CHK ABEND CODE, DO ABEND OR RETRY\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESSES OF THE PARAMETERS SPECIFIED BY\n*    THE ESTAE MACRO AND PASSED TO THE RECOVERY ROUTINE BY RTM.\n***********************************************************************\n*\nGETPARMS L     R11,0(R10)          LD ADR OF PARM ABEND-CODE-TBL\n         ST    R11,ABTBLADR        SAVE ADR OF ABEND-CODE-TBL\n         L     R11,4(R10)          LD ADR OF PARM RCVRY-ADR-TBL\n         ST    R11,RETBLADR        SAVE ADR OF RCVRY-ADR-TBL\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE ABEND CODE TO DETERMINE IF IT IS ONE OF\n*    THE ONES FOR WHICH A RETRY IS REQUIRED. IF THE ABEND CODE IF FOUND\n*    IN THE ABEND-CODE TABLE, THEN THE RETRY ADDRESS IN THE SAME\n*    RELATIVE LOCATION IN THE RETRY-ADDRESS TABLE IS USED AS THE RETRY\n*    ADDRESS AND REGISTER 15 IS SET WITH A RETURN CODE OF X'04' TO\n*    INDICATE RETRY. IF THE ABEND CODE IS NOT FOUND IN THE ABEND-CODE\n*    TABLE, THEN THE ABEND IS TO CONTINUE AND REGISTER 15 IS SET WITH\n*    A RETURN CODE OF X'00' TO INDICATE ABEND.\n***********************************************************************\n*\nCHKABCOD L     R10,ABTBLADR        LD ADR OF ABEND-CODE-TBL\n         L     R11,RETBLADR        LD ADR OF RCVRY-ADR-TBL\nNXABCODE CLI   0(R10),X'00'        CHK FOR END-OF-TBL\n         BE    ABEND               IF END, DO ABEND\n         CLC   ABCODE,0(R10)       CHK IF ABEND CODE IN TBL\n         BE    RETRY               IF YES, DO RETRY\n         LA    R10,4(0,R10)        INCR TO NEXT ABEND CODE IN TBL\n         LA    R11,4(0,R11)        INCR TO NEXT RCVRY ADR IN TBL\n         B     NXABCODE            COMP ABEND CODE TO NEXT TBL ENTRY\nABEND    LA    R15,0               IND ABEND REQUIRED\n         BR    R7                  RETURN TO CALLING RTN\nRETRY    MVC   RETRYADR,0(R11)     EXTRACT CORRESPONDING RETRY ADR\n         LA    R15,4               IND RETRY REQUIRED\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL WHEN THE RECOVERY EXIT ROUTINE IS TO\n*    RETURN CONTROL TO RTM. THIS ROUTINE CHECKS WHETHER OR NOT AN SDWA\n*    WAS PROVIDED AND CAUSES CONTROL TO BE RETURNED ACCORDINGLY.\n***********************************************************************\n*\nEXITRET  LTR   R10,R10             CHK IF SDWA PROVIDED\n         BZ    RETSDWAX            RETURN WITHOUT SDWA\n         B     RETSDWA             RETURN USING SDWA\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL WHEN AN SDWA WAS NOT PROVIDED. IF\n*    REGISTER 15 CONTAINS A RETURN CODE OF X'00', THEN THE ABEND IS TO\n*    CONTINUE. IF REGISTER 15 CONTAINS A RETURN CODE OF X'04', THEN THE\n*    RETRY ADDRESS, WHICH WAS SELECTED FROM THE CHKABCOD ROUTINE, IS\n*    USED TO RETURN CONTROL TO THE MAIN PROGRAM.\n***********************************************************************\n*\nRETSDWAX LTR   R15,R15             CHK IF ABEND OR RETRY REQUIRED\n         BZ    DOABENDX            IF RC=0, DO ABEND\n         LA    R15,4               IND RETRY REQUIRED\n         L     R0,RETRYADR         LD RETRY ADR\n         L     R14,SAVR14          RESTORE RETURN ADR\n         BR    R14                 RETURN TO RTM\nDOABENDX LA    R15,0               IND ABEND REQUIRED\n         L     R14,SAVR14          RESTORE RETURN ADR\n         BR    R14                 RETURN TO RTM\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL WHEN AN SDWA WAS PROVIDED.  IF\n*    REGISTER 15 CONTAINS A RETURN CODE OF X'00', THEN THE ABEND IS TO\n*    CONTINUE. IF REGISTER 15 CONTAINS A RETURN CODE OF X'04', THEN THE\n*    RETRY ADDRESS, WHICH WAS SELECTED FROM THE CHKABCOD ROUTINE, IS\n*    USED TO RETURN CONTROL TO THE MAIN PROGRAM.\n***********************************************************************\n*\nRETSDWA  LTR   R15,R15             CHK IF ABEND OR RETRY REQUIRED\n         BZ    DOABEND             IF RC=0, DO ABEND\n         L     R10,RETRYADR        LD RETRY ADR\n         SETRP WKAREA=(R12),RC=4,RETADDR=(R10),RETREGS=YES,FRESDWA=YES\n*                                  RC=4 --- PROVIDE RETRY ADDRESS\n         L     R14,SAVR14          RESTORE RETURN ADR\n         BR    R14                 RETURN TO RTM\nDOABEND  SETRP WKAREA=(R12),RC=0   RC=0 --- CONTIN WITH ABEND\n         LR    R14,SAVR14          RESTORE RETURN ADR\n         BR    R14                 RETURN TO RTM\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS USED BY EXIT ROUTINE\n***********************************************************************\n*\nSAVR14   DS    F\nBIN12    DC    F'12'\nABCODE   DS    F\nABTBLADR DS    F\nRETBLADR DS    F\nRETRYADR DS    F\n*\n*\n***********************************************************************\n*    THE DESCTS\n***********************************************************************\n*\n         PRINT NOGEN\n         DSECT\n         IEFJFCBN                  GENERATES JFCB DSECT\n*\n         IHASDWA                   GENERATES SDWA DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070101": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xb3\\x00\\xb3\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 179, "newlines": 179, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.1.1\n*\n*\nREADTAPE CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING INFMJFCB,R10        DEFINE REG FOR JFCB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPENPRT          OPEN SYSPRINT\n         BAL   R6,RDJFCB           READ JFCB INTO PROG AREA\nNEXTFILE BAL   R6,MDFYJFCB         MODIFY JFCB---INCR FILE SEQ NUM\n         BAL   R6,OPENTAP          OPEN NEXT TAPE DATASET\nNEXTREC  BAL   R6,READREC          READ A REC FROM TAPE DATASET\n         BAL   R6,PRINT            PRINT A REC FROM TAPE DATASET\n         B     NEXTREC             READ NEXT REC FROM TAPE DATASET\nENDFILE  BAL   R6,CKENDVOL         CHECK IF END OF TAPE VOL\n         BAL   R6,CLOSETAP         CLOSE TAPE DATASET\n         B     NEXTFILE            PROCESS NEXT TAPE DATASET\nENDVOL   BAL   R6,CLOSE            LAST TAPE DATASET, CLOSE ALL DCBS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE SYSPRINT DCB.\n***********************************************************************\n*\nOPENPRT  OPEN  (SYSPRINT,(OUTPUT))\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCB AND COPIES IT FROM THE SWA INTO THE\n*    PROGRAMMER-SUPPLIED AREA.\n***********************************************************************\n*\nRDJFCB   LA    R10,JFCB            SETUP ADRBLTY FOR JFCB DSECT\n         RDJFCB SYSUT1\n         LTR   R15,R15             CHK IF DD STMT IN JCL\n         BNZ   NODD                IF RC NOT 0, DD MISSING\n         TM    JFCBLTYP,JFCBLP     CHK IF BLP SPECIFIED\n         BNO   NOBLP               IF NOT 1, NO BLP\n         BR    R6                  RETURN TO CALLING RTN\nNODD     WTO   '*** SYSUT1 JCL DD STATEMENT MISSING ***',              -\n               ROUTCDE=11\n         ABEND 901\nNOBLP    WTO   '*** LABEL=(1,BLP) NOT SPECIFIED FOR SYSUT1 ***',       -\n               ROUTCDE=11\n         ABEND 902\n*\n*\n***********************************************************************\n*    THIS ROUTINE MODIFIES THE JFCB. EACH TIME THIS ROUTINE RECEIVES\n*    CONTROL, IT INCREMENTS THE FILE-SEQUENCE-NUMBER BY ONE AND INSERTS\n*    THE NEW VALUE INTO THE JFCB.\n***********************************************************************\n*\nMDFYJFCB LA    R10,JFCB            SET ADRBLTY FOR JFCB DSECT\n         L     R11,FILENUM         LOAD PREV FILE SEQ NUM\n         LA    R11,1(0,R11)        INCR FILE SEQ NUM\n         ST    R11,FILENUM         STORE NEW FILE SEQ NUM\n         MVC   JFCBFLSQ,FILENUM+2  PUT NEW FILE SEQ NUM INTO JFCB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE TAPE DATASET DCB AND USES THE MODIFIED JFCB\n*    SUPPLIED BY THE PROGRAMMER TO POSITION THE TAPE VOLUME TO THE NEXT\n*    DATASET.\n***********************************************************************\n*\nOPENTAP  OPEN  SYSUT1,TYPE=J       OPEN, USE JFCB IN PROG\n         TM    DCBOFLGS,DCBOFOPN   CHK IF OPEN OK\n         BNO   OPENBAD             IF NOT 1, OPEN UNSUCCESSFUL\n         MVI   NORECSW,C'1'        INIT NO-REC-SW TO DETM END-OF-VOL\n         BR    R6                  RETURN TO CALLING RTN\nOPENBAD  WTO   '*** OPEN ERROR FOR FILEDD ***',ROUTCDE=11\n         ABEND 903\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A RECORD FROM THE CURRENT TAPE DATASET.\n***********************************************************************\n*\nREADREC  GET   SYSUT1              GET A RECORD FROM TAPE DS\n         MVI   NORECSW,C'0'        IND THAT DS CONTAINS A RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PRINTS THE RECORD READ FROM THE TAPE DATASET.\n***********************************************************************\n*\nPRINT    ...                       PRINT RECS FROM TAPE DATASETS\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS IF ALL THE DATASETS ON THE TAPE VOLUME HAVE\n*    BEEN PROCESSED.\n***********************************************************************\n*\nCKENDVOL CLI   NORECSW,C'1'        CHK IF IMED END-OF-FILE FROM LAST\n*                                  GET MACRO\n         BE    ENDVOL              IF YES, ALL DATASETS READ\n         CLI   NORECSW,X'00'       CHK IF VOL HAS ANY DATA\n         BE    NODATA              IF X'00', NO DATA ON TAPE\n         BR    R6                  IF NO, RET TO CALLING RTN\nNODATA   WTO   '*** TAPE VOLUME CONTAINS NO DATA ***',ROUTCDE=11\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE DCB FOR THE CURRENT TAPE DATASET.\n***********************************************************************\n*\nCLOSETAP CLOSE SYSUT1              CLOSE TAPE DCB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (SYSUT1,,SYSPRINT)  CLOSE ALL DCBS\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nFILENUM  DC    F'0'\nNORECSW  DC    X'00'\n*\n*\n***********************************************************************\n*    THE JFCB-LIST AND THE DCBS\n***********************************************************************\n*\nJFCB     DS    44F\nJFCBPTR  DC    X'87'\n         DC    AL3(JFCB)\n*\nSYSUT1   DCB   DSORG=PS,MACRF=GL,RECFM=U,BLKSIZE=32760,                -\n               EXLST=JFCBPTR,EODAD=ENDFILE,DDNAME=SYSUT1\nSYSPRINT DCB   ...\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         DSECT\n         IEFJFCBN              GENERATES JFCB DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070102": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xaf\\x00\\xaf\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 175, "newlines": 175, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.1.2\n*\n*\nREADDISK CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING INFMJFCB,R10        DEFINE REG FOR JFCB DSECT\n         USING IHADCB,R11          DEFINE REG FOR DCB DSECT\n         USING DSTBLMAP,R12        DEFINE REG FOR USER DSN-TBL DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,RDJFCB           READ JFCB INTO PROG AREA\nNEXTFILE BAL   R6,MDFYJFCB         MODIFY JFCB WITH NEXT DATASET NAME\n         BAL   R6,ENQ              ENQ ON DATASET NAME\n         BAL   R6,OPEN             OPEN NEXT DATASET\n         BAL   R6,PROCESS          PROCESS DATASET\nDATAEND  BAL   R6,CLOSE            CLOSE DATASET\n         BAL   R6,DEQ              DEQ ON DATASET NAME\n         B     NEXTFILE            ALLOCATE NEXT DATASET\nVOLEND   B     RETURN              ALL DATASETS ON VOL PROC, RETURN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCB AND COPIES IT FROM THE SWA INTO THE\n*    PROGRAMMER-SUPPLIED AREA.\n***********************************************************************\n*\nRDJFCB   RDJFCB FILEDCB\n         LTR   R15,R15             CHK IF DD STMT IN JCL\n         BNZ   NODD                IF RC NOT 0, DD STMT MISSING\n         BR    R6                  RETURN TO CALLING RTN\nNODD     WTO   '*** FILEDD NOT SPECIFIED IN JCL ***',ROUTCDE=11\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE MODIFIES THE JFCB. THE CURRENT DASD DATASET NAME FROM\n*    THE TABLE IS PUT INTO THE DATASET-NAME FIELD OF THE JFCB.\n***********************************************************************\n*\nMDFYJFCB LA    R10,JFCB            SET ADRBLTY FOR JFCB DSECT\n         L     R12,DSTBLPTR        LD CUR DSN ENTRY ADR, SET DSECT\n*                                  ADRBLTY\n         CLI   DSNAME,X'00'        CHK FOR LAST DSN ENTRY\n         BE    VOLEND              IF YES, ALL DSNMS PROCESSED\n         MVC   JFCBDSNM,DSNAME     PUT CUR DSN INTO JFCB\n         LA    R14,TBLENLEN(0,R12) INCR TO NEXT DSN ENTRY\n         ST    R14,DSTBLPTR        SAVE ADR OF NEXT DSN ENTRY\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ENQS THE DATASET WHICH WILL BE ALLOCATED VIA OPEN.\n***********************************************************************\n*\nENQ      MVC   RNAME,DSNAME        MOVE DSNAME FOR ENQ\n         L     R2,DSNMLEN          LOAD LEN OF RNAME\n         ENQ   (QNAME,RNAME,S,(R2),SYSTEMS)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE DCB AND ALLOCATES THE DSNAME SPECIFIED IN\n*    THE PROGRAMMER-SUPPLIED JFCB.\n***********************************************************************\n*\nOPEN     LA    R11,FILEDCB         SET ADRBLTY FOR DCB DSECT\n         OPEN  FILEDCB,TYPE=J      OPEN, USE JFCB IN PROG\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  IF YES, RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A RECORD FROM THE DATASET AND PROCESSES IT.\n***********************************************************************\n*\nPROCESS  GET   FILEDCB             READ A RECORD FROM DATASET\n         ...                       PROCESS A RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE DCB.\n***********************************************************************\n*\nCLOSE    CLOSE FILEDCB             CLOSE DATASET\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE DEQS THE DATASET.\n***********************************************************************\n*\nDEQ      L     R2,DSNMLEN\n         DEQ   (QNAME,RNAME,(R2),SYSTEMS)\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS FOR DASD DATASET NAME TABLE\n***********************************************************************\n*\nDSTBLPTR DC    A(DSNTBL)\n*\nDSNTBL   DS    0F\nTBLENTBG EQU   *\n         DC    A(L'DS01)\nDS01     DC    C'USER.FILE01'\n         DC    CL(45-L'DS01)' '\nTBLENTX  EQU   *\n         DC    A(L'DS02)\nDS02     DC    C'USER.FILE02'\n         DC    CL(45-L'DS02)' '\n         DC    A(L'DS03)\nDS03     DC    C'USER.FILE03'\n         DC    CL(45-L'DS03)' '\n         DC    F'0'                INDICATE END-OF-DSN TABLE\nTBLENLEN EQU   TBLENTX-TBLENTBG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS FOR ENQ/DEQ MACROS\n***********************************************************************\n*\nQNAME    DC    CL8'SYSDSN'\nRNAME    DS    CL44\n*\n*\n***********************************************************************\n*    THE JFCB-LIST AND THE DCB\n***********************************************************************\n*\nJFCB     DS    44F\nJFCBPTR  DC    X'87'\n         DC    AL3(JFCB)\n*\nFILEDCB  DCB   DSORG=PS,MACRF=GL,EXLST=JFCBPTR,EODAD=DATAEND,          -\n               DDNAME=FILEDD\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         DSECT\n         IEFJFCBN              GENERATES JFCB DSECT\n*\nDSTBLMAP DSECT\nDSNMLEN  DS    CL4\nDSNAME   DS    CL44\n         DS    CL1             REQD TO PREVENT ASM ERROR\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070103": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xa0\\x00\\xa0\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 160, "newlines": 160, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.1.3\n*\n*\nCHKBLKSZ CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING INFMJFCB,R10        DEFINE REG FOR JFCB DSECT\n         USING IHADCB,R11          DEFINE REG FOR DCB DESCT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,RDJFCB           READ JFCB INTO PROG AREA\n         BAL   R6,VALBLKSZ         VALIDATE BLKSZ SPEC ON JCL STMT\n         BAL   R6,MDFYJFCB         SET DEFAULT BLKSZ\n         BAL   R6,OPEN             OPEN DCB, CHK IF JFCB MDFY REQR\n         BAL   R6,PROCESS          PROCESS DATASET\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCB AND COPIES IT FROM THE SWA INTO THE\n*    PROGRAMMER-SUPPLIED AREA.\n***********************************************************************\n*\nRDJFCB   RDJFCB FILEDCB\n         LTR   R15,R15             CHK IF DD STMT IN JCL\n         BNZ   NODD                IF RC NOT 0, DD STMT MISSING\n         BR    R6                  RETURN TO CALLING RTN\nNODD     WTO   '*** FILEDD NOT SPECIFIED IN JCL ***',ROUTCDE=11\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE EXAMINES THE BLKSIZE SPECIFIED IN THE REFERENCED JCL\n*    STATEMENT ONLY FOR DISP=NEW DATASETS. IF ONE OF THE FOLLOWING\n*    CONDITIONS IS TRUE:\n*        * THE BLKSIZE IS OMITTED;\n*        * THE BLKSIZE IS NOT A MULTIPLE OF THE LRECL SPECIFIED IN THE\n*          DCB MACRO;\n*        * THE BLKSIZE IS LESS A PREDEFINED MINIMUM;\n*     THEN REGISTER 15 IS SET WITH A NON-ZERO RC TO INDICATE THAT THE\n*     SPECIFIED BLKSIZE IS TO BE REPLACED WITH THE DEFAULT BLKSIZE.\n***********************************************************************\n*\nVALBLKSZ LA    R10,JFCB            SET ADRBLTY FOR JFCB DSECT\n         LA    R11,FILEDCB         SET ADRBLTY FOR DCB DSECT\n         TM    JFCBIND2,JFCNEW     CHK IF DISP=NEW ON JCL STMT\n         BO    NEWDS               IF YES, CHK BLKSZ\n         LA    R15,0               IF NO, INDICATE BLKSZ OK\n         BR    R6                  RETURN TO CALLING RTN\nNEWDS    CLC   JFCBLKSI,BINZEROS   CHK IF BLKSZ IN JCL\n         BNE   CHKBSZ1             IF YES, CHK IT\n         LA    R15,4               IF NO, IND BLKSZ MOD REQR\n         BR    R6                  RETURN TO CALLING RTN\nCHKBSZ1  LH    R15,JFCBLKSI        LOAD R15 WITH BLKSZ FROM JCL\n         LA    R14,0               SET R14 TO ZERO FOR DR INSTR\n         LH    R12,DCBLRECL        LOAD R12 WITH LRECL FROM PROG\n         DR    R14,R12             DIVIDE LRECL INTO BLKSZ\n         LTR   R14,R14             CHK IF BLKSZ MULT OF LRECL (REMDR=0)\n         BZ    CHKBSZ2             IF YES, CHK MIN BLKSZ\n         LA    R15,4               IF NO, IND BLKSZ MOD REQR\n         BR    R6                  RETURN TO CALLING RTN\nCHKBSZ2  CLC   JFCBLKSI,MINBLKSZ   COMP JCL BLKSZ TO MIN BLKSZ\n         BNL   BLKSZOK             OK, IF JCL BLKSZ EQ OR GT MIN BLKSZ\n         LA    R15,4               IF LT MIN, IND BLKSZ MOD REQR\n         BR    R6                  RETURN TO CALLING RTN\nBLKSZOK  LA    R15,0               IND BLKSZ OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE MODIFIES THE JFCB IF REQUIRED (RC IN REGISTER 15 IS\n*    NON-ZERO). IF REQUIRED, THE DEFAULT BLKSIZE IS PUT INTO THE JFCB\n*    AND OVERRIDES THE ONE SPECIFIED IN THE JCL (IF ANY).\n***********************************************************************\n*\nMDFYJFCB LTR   R15,R15             CHK IF BLKSZ MOD REQUIRED\n         BZR   R6                  IF NO, RET TO CALLING RTN\n         MVC   JFCBLKSI,DFLTBSZ    IF YES, USE DEFAULT BLKSZ\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE DCB. IF THE RC IN REGISTER 15 IS NON-ZERO,\n*    THEN THE PROGRAMMER-SUPPLIED JFCB IS USED WITH THE NEW BLKSIZE.\n***********************************************************************\n*\nOPEN     LTR   R15,R15             CHK IF BLKSZ MOD REQUIRED\n         BNZ   OPENJ               IF YES, USE MOD JFCB FOR OPEN\n         OPEN  (FILEDCB,(OUTPUT))\n         B     CHKOPEN\nOPENJ    OPEN  (FILEDCB,(OUTPUT)),TYPE=J\n         B     CHKOPEN\nCHKOPEN  TM    DCBOFLGS,DCBOFOPN   CHK FOR GOOD OPEN\n         BNO   OPENBAD             IF NOT 1, OPEN UNSUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\nOPENBAD  WTO   '*** OPEN ERROR FOR FILEDD ***',ROUTCDE=11\n         ABEND 902\n*\n*\n***********************************************************************\n*    THIS ROUTINE DOES THE ACTUAL PROCESSING.\n***********************************************************************\n*\nPROCESS  ...\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    CONSTANTS\n***********************************************************************\n*\nBINZEROS DC    H'0'\nMINBLKSZ DC    H'4080'             MINIMUM BLKSIZE\nDFLTBSZ  DC    H'4080'             DEFAULT BLKSIZE\n*\n*\n***********************************************************************\n*    THE JFCB-LIST AND THE DCB\n***********************************************************************\n*\nJFCB     DS    44F\nJFCBPTR  DC    X'87'\n         DC    AL3(JFCB)\n*\nFILEDCB  DCB   DSORG=PS,MACRF=PM,EXLST=JFCBPTR,DDNAME=FILEDD,          -\n               LRECL=80,RECFM=FB\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         DSECT\n         IEFJFCBN              GENERATES JFCB DSECT\n*\n         DCBD  DSORG=PS        GENERATES PS-DCB DSECT\n*\n*\n**************************************************************************\n*    END OF PROGRAM\n**************************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070104": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x89\\x00\\x89\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.1.4\n*\n*\nREADVTOC CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING INFMJFCB,R10        DEFINE REG FOR JFCB DSECT\n         USING IECSDSF1,R11        DEFINE REG FOR DSCB-1 DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,RDJFCB           READ JFCB INTO PROG AREA\n         BAL   R6,MDFYJFCB         MODIFY JFCB WITH VTOC NAME\n         BAL   R6,OPEN             OPEN VTOC\nNEXTDSCB BAL   R6,READVTOC         READ A DSCB\n         BAL   R6,PROCESS          PROCESS FORMAT-1 DSCBS\n         B     NEXTDSCB            READ NEXT DSCB\nDSCBEND  BAL   R6,CLOSE            CLOSE VTOC\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCB AND COPIES IT FROM THE SWA INTO THE\n*    PROGRAMMER-SUPPLIED AREA.\n***********************************************************************\n*\nRDJFCB   RDJFCB VTOCDCB\n         LTR   R15,R15             CHK IF DD STMT IN JCL\n         BNZ   NODD                IF RC NOT 0, DD STMT MISSING\n         BR    R6                  RETURN TO CALLING RTN\nNODD     WTO   '*** VTOCDD NOT SPECIFIED IN JCL ***'\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE MODIFIES THE JFCB. THE DATASET NAME OF THE VTOC IS\n*    PUT INTO THE DATASET-NAME FIELD OF THE JFCB.\n************************************************************************\n*\nMDFYJFCB LA    R10,JFCB            SET ADRBLTY FOR JFCB DSECT\n         MVC   JFCBDSNM,VTOCNAME   PUT VTOC LABEL INTO JFCB DSNAME\n*                                  FIELD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE VTOC BY USING THE MODIFIED JFCB SUPPLIED\n*    BY THE PROGRAMMER.\n***********************************************************************\n*\nOPEN     OPEN  VTOCDCB,TYPE=J\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS DSCBS FROM THE VTOC AND CHECKS THEIR TYPE. ONLY\n*    FORMAT-1 DSCBS ARE RETURNED TO THE CALLING ROUTINE.\n***********************************************************************\n*\nREADVTOC LA    R11,DSCB            SET ADRBLTY FOR DSCB-1 DSECT\n         READ  VTOCDECB,SF,VTOCDCB,(R11)  READ A DSCB\n         CHECK VTOCDECB                   CHECK FOR GOOD READ\n         CLI   DS1FMTID,C'1'       CHECK IF FORMAT-1 DSCB\n         BNE   READVTOC            IF NO, READ ANOTHER DSCB\n         BR    R6                  IF YES, RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PROCESS THE FORMAT-1 DSCBS.\n***********************************************************************\n*\nPROCESS  DS    0H\n         ...                       PROCESS FORMAT-1 DSCB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE VTOC DCB.\n***********************************************************************\n*\nCLOSE    CLOSE VTOCDCB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nVTOCNAME DC    44XL1'04'           THE LABEL OF THE VTOC\nDSCB     DS    CL140\n*\n*\n***********************************************************************\n*    THE JFCB-LIST AND THE DCB\n***********************************************************************\n*\nJFCB     DS    44F\nJFCBPTR  DC    X'87'\n         DC    AL3(JFCB)\n*\nVTOCDCB  DCB   DSORG=PS,MACRF=R,EXLST=JFCBPTR,EODAD=DSCBEND,           -\n               KEYLEN=44,BLKSIZE=96,LRECL=96,RECFM=F,DDNAME=VTOCDD\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         DSECT\n         IEFJFCBN        GENERATES DSECT FOR JFCB\n*\n         DSECT\n         IECSDSL1 1      GENERATES DSECT FOR FORMAT-1 DSCB\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070201": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x87\\x00\\x87\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.2.1\n*\n*\nSVC99ALO CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING S99RBP,R10          DEFINE REG FOR REQ BLK PTR DSECT\n         USING S99RB,R11           DEFINE REG FOR REQ BLOCK DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETRB001         SETUP RB FOR ALLOC\n         BAL   R6,SETRBPTR         SETUP RB PTR\n         BAL   R6,DOSVC99          ISSUE SVC 99\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST BLOCK.\n***********************************************************************\n*\nSETRB001 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBAL    SET ALLOCATION VERB\n         LA    R10,TUPTR001        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST-BLOCK-POINTER.\n***********************************************************************\n*\nSETRBPTR LA    R10,RBPTR           SET ADRBLTY FOR RBPTR DSECT\n         LA    R11,REQBLK          LD ADR OF RB\n         ST    R11,S99RBPTR        STORE RB ADR INTO RB PTR\n         OI    S99RBPTR,S99RBPND   TURN ON HIGH ORDER BIT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES SVC 99 VIA THE DYNALLOC MACRO.\n***********************************************************************\n*\nDOSVC99  LA    R1,RBPTR            LD ADR OF RB PTR INTO R1 FOR SVC 99\n         DYNALLOC                  ISSUE SVC 99\n         LTR   R15,R15             CHK RC\n         BNZ   CHKERR              IF NOT ZERO, CHK ERROR/INFO FIELDS\n         BR    R6                  IF OK, RETURN TO CALLING RTN\nCHKERR   ...\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    SVC99 REQ-BLOCK-POINTER AND REQUEST BLOCK\n***********************************************************************\n*\nRBPTR    DS    F\nREQBLK   DS    CL(S99RBEND-S99RB)\nREQBLKLN EQU   L'REQBLK\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LIST\n***********************************************************************\n*\nTUPTR001 DS    0F\n         DC    A(TUDDNA1)          ADR OF TU FOR DDNAME\n         DC    A(TUDSNA1)          ADR OF TU FOR DSNAME\n         DC    A(TUDSSA1)          ADR OF TU FOR DS STATUS\n         DC    A(TUDNDA1)          ADR OF TU FOR DS NORM TERM DISP\n         DC    A(TUUNTA1)          ADR OF TU FOR UNIT\n         DC    A(TUVOLA1)          ADR OF TU FOR VOLSER\n         DC    A(TUBLKA1)          ADR OF TU FOR DCB BLKSZ\n         DC    A(TULRLA1)          ADR OF TU FOR DCB LRECL\n         DC    A(TURFMA1)          ADR OF TU FOR DCB RECFM\n         DC    A(TUCYLA1)          ADR OF TU FOR SPACE IN CYL\n         DC    A(TUPRMA1)          ADR OF TU FOR PRIM SPACE\n         DC    A(TUSECA1)          ADR OF TU FOR SEC SPACE\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TURLSA1)        ADR OF TU FOR SPACE RLSE\n*\n*\n***********************************************************************\n*    TEXT UNITS\n***********************************************************************\n*\nTUDDNA1  DC    AL2(DALDDNAM)       TU KEY FOR DDNAME\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(8)              LENGTH OF DDNAME\n         DC    CL8'DD1'            DDNAME\n*\nTUDSNA1  DC    AL2(DALDSNAM),AL2(1),AL2(44),CL44'USER.NEWDATA'\nTUDSSA1  DC    AL2(DALSTATS),AL2(1),AL2(1),X'04'\nTUDNDA1  DC    AL2(DALNDISP),AL2(1),AL2(1),X'02'\nTUUNTA1  DC    AL2(DALUNIT),AL2(1),AL2(5),C'SYSDA'\nTUVOLA1  DC    AL2(DALVLSER),AL2(1),AL2(6),C'123456'\nTUBLKA1  DC    AL2(DALBLKSZ),AL2(1),AL2(2),AL2(4080)\nTULRLA1  DC    AL2(DALLRECL),AL2(1),AL2(2),AL2(80)\nTURFMA1  DC    AL2(DALRECFM),AL2(1),AL2(1),X'90'\nTUCYLA1  DC    AL2(DALCYL),AL2(0)\nTUPRMA1  DC    AL2(DALPRIME),AL2(1),AL2(3),AL3(10)\nTUSECA1  DC    AL2(DALSECND),AL2(1),AL2(3),AL3(1)\nTURLSA1  DC    AL2(DALRLSE),AL2(0)\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         IEFZB4D0        GENS DSECT FOR REQ BLOCK, TEXT UNIT, ETC.\n         IEFZB4D2        GENS TABLE OF EQUATES FOR TU KEYS\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070202": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00 \\x00 \\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.2.2\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST BLOCK.\n***********************************************************************\n*\nSETRB002 ...\n         MVI   S99VERB,S99VRBDN    SET DDNAME ALLO VERB\n         LA    R10,TUPTR002        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LIST\n***********************************************************************\n*\nTUPTR002 DS    0F\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDDNA2)        ADR OF TU FOR DDNAME FOR RE-ALLO\n*\n*\n***********************************************************************\n*    TEXT UNIT\n***********************************************************************\n*\nTUDDNA2  DC    AL2(DDNDDNAM)       TU KEY FOR DDNAME ALLO\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(3)              LENGTH OF DDNAME\n         DC    C'DD1'              DDNAME\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070203": {"ttr": 4102, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00 \\x00 \\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.2.3\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST BLOCK.\n***********************************************************************\n*\nSETRB003 ...\n         MVI   S99VERB,S99VRBUN    SET UNALLOCATION VERB\n         LA    R10,TUPTR003        LD ADR OF BG OF TEXT-UNIT-PRT LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LIST\n***********************************************************************\n*\nTUPTR003 DS    0F\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDDNU1)        ADR OF TU FOR UNALLO DDNAME\n*\n*\n***********************************************************************\n*    TEXT UNIT\n***********************************************************************\n*\nTUDDNU1  DC    AL2(DUNDDNAM)       TU KEY FOR DDNAME UNALLO\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(8)              LENGTH OF DDNAME\n         DC    C'SYS00009'         DDNAME\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070204": {"ttr": 4104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\'\\x00\\'\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.2.4\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST BLOCK.\n***********************************************************************\n*\nSETRB004 ...\n         MVI   S99VERB,S99VRBCC    SET CONCATENATION VERB\n         LA    R10,TUPTR004        LD BG ADR OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LIST\n***********************************************************************\n*\nTUPTR004 DS    0F\n         DC    A(TUPCA)            ADR OF TU FOR PERM CONCAT ATTR\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDDNSC1)       ADR OF TU FOR CONCAT DDNAME LIST\n*\n*\n***********************************************************************\n*    TEXT UNITS\n***********************************************************************\n*\nTUPCA    DC    AL2(DCCPERMC)      TU KEY FOR PARM CONCAT ATTR\n         DC    AL2(0)             NO LEN/PARM VALUE REQUIRED\n*\nTUDDNSC1 DC    AL2(DCCDDNAM)      TU KEY FOR DDNAME CONCAT\n         DC    AL2(3)             NUMBER OF DDNAMES\n         DC    AL2(7)             LENGTH OF 1ST DDNAME\n         DC    C'PRIVLIB'         DDNAME-1, NAME ASSO WITH CONCAT GROUP\n         DC    AL2(8)             LENGTH OF 2ND DDNAME\n         DC    C'SYS00010'        DDNAME-2\n         DC    AL2(7)             LENGTH OF 3RD DDNAME\n         DC    C'TESTLIB'         DDNAME-3\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070205": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00 \\x00 \\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.2.5\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST BLOCK.\n***********************************************************************\n*\nSETRB005 ...\n         MVI   S99VERB,S99VRBDC    SET DECONCATENATION VERB\n         LA    R10,TUPTR005        LD BG ADR OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LIST\n***********************************************************************\n*\nTUPTR005 DS    0F\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TUDDND1)        ADR OF TU FOR DECONCAT DDNAME\n*\n*\n***********************************************************************\n*    TEXT UNIT\n***********************************************************************\n*\nTUDDND1  DC    AL2(DDCDDNAM)       TU KEY FOR DDNAME DECAT\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(7)              LENGTH OF DDNAME\n         DC    C'TESTLIB'          DDNAME ASSO WITH CONCAT GROUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070206": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00&\\x00&\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.2.6\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST BLOCK.\n***********************************************************************\n*\nSETRB006 ...\n         MVI   S99VERB,S99VRBIN    SET DYNM INFOR RETRV VERB\n         LA    R10,TUPTR006        LD BG ADR OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LIST\n***********************************************************************\n*\nTUPTR006 DS    0F\n         DC    A(TUDSNI1)          ADR OF TU FOR SPECIFIED DSNAME\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TURDDNI1)       ADR OF TU FOR RETURNED DDNAME\n*\n*\n***********************************************************************\n*    TEXT UNITS\n***********************************************************************\n*\nTUDSNI1  DC    AL2(DINDSNAM)       TU KEY FOR SPECIFIED DSNAME\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DC    AL2(44)             LENGTH OF DSNAME\nI1DSNAME DC    CL44'USER.WORK01'   SPECIFIED DSNAME\n*\nTURDDNI1 DC    AL2(DINRTDDN)       TU KEY FOR RETURNED DDNAME\n         DC    AL2(1)              NUMBER OF ENTRIES\n         DS    CL2                 RETURNED LENGTH OF DDNAME\nI1DDNAME DS    CL8                 RETURNED DDNAME\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE070207": {"ttr": 4110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xb1\\x00\\xb1\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 7.2.7\n*\n*\nSVC99INR CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING S99RBP,R10          DEFINE REG FOR REG BLK PTR DSECT\n         USING S99RB,R11           DEFINE REG FOR REQ BLOCK DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETRB007         SETUP RB FOR DYNM INFO RETV\n         BAL   R6,SETRBPTR         SETUP RB PTR\nNEXTINFO BAL   R6,SETRELNO         INCR REL NO AND STORE INTO TU\n         BAL   R6,DOSVC99          ISSUE SVC 99\n         BAL   R6,RETVINFO         OBTAIN DDN/DSN INFO\n         BAL   R6,PROCESS          PROCESS DDN/DSN INFO\n         B     NEXTINFO            GET NEXT DDN/DSN INFO\nINFOEND  B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST BLOCK.\n***********************************************************************\n*\nSETRB007 LA    R11,REQBLK          SET ADRBLTY FOR RB DSECT\n         XC    REQBLK,REQBLK       CLEAR RB\n         MVI   S99RBLN,REQBLKLN    SET RB LEN\n         MVI   S99VERB,S99VRBIN    SET DYNM INFO RETV VERB\n         LA    R10,TUPTR007        LD ADR OF BG OF TEXT-UNIT-PTR LIST\n         ST    R10,S99TXTPP        STORE THAT ADR INTO RB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SVC99 REQUEST-BLOCK-POINTER.\n***********************************************************************\n*\nSETRBPTR LA    R10,RBPTR           SET ADRBLTY FOR RBPTR DSECT\n         LA    R11,REQBLK          LD ADR OF RB\n         ST    R11,S99RBPTR        STORE RB ADR INTO RB PTR\n         OI    S99RBPTR,S99RBPND   TURN HIGH ORDER BIT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE INCREMENTS THE RELATIVE NUMBER OF THE ALLOCATION AND\n*    STORES THE NEW RELATIVE NUMBER INTO THE RELATIVE-NUMBER TEXT UNIT.\n***********************************************************************\n*\nSETRELNO L     R12,RELNO           LD LAST REL NUMB\n         LA    R12,1(0,R12)        INCR REL NUMB\n         ST    R12,RELNO           SAVE CUR REL NUMB\n         ST    R12,I2RELNO         STORE CUR REL NUMB INTO TU\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES SVC 99 VIA THE DYNALLOC MACRO.\n***********************************************************************\n*\nDOSVC99  LA    R1,RBPTR            LD ADR OF RB PTR INTO R1 FOR SVC 99\n         DYNALLOC                  ISSUE SVC 99\n         LTR   R15,R15             CHK RC\n         BNZ   CHKERR              IF NOT ZERO, CHK ERROR/INFO FIELDS\n         BR    R6                  IF OK, RETURN TO CALLING RTN\nCHKERR   ...\n*\n*\n***********************************************************************\n*    THIS ROUTINE EXTRACTS THE DDNAME AND DATASET NAME OF THE\n*    ALLOCATION ASSOCIATED WITH THE SPECIFIED RELATIVE NUMBER.\n***********************************************************************\n*\nRETVINFO MVC   DDNAME,DDNAME-1     CLEAR AREA FOR DDNAME\n         MVC   DSNAME,DSNAME-1     CLEAR AREA FOR DSNAME\n         LH    R12,I2DDNLEN        LD LEN OF RETURNED DDN\n         BCTR  R12,0               DECR LEN FOR EX INSTR\n         EX    R12,MOVEDDN         GET DDNAME\n         LH    R12,I2DSNLEN        LD LEN OF RETURNED DSN\n         BCTR  R12,0               DECR LEN FOR EX INSTR\n         EX    R12,MOVEDSN         GET DSNAME\n         CLI   I2LESW,X'80'        CHK IND FOR LAST DD STMT\n         BE    INFOEND             IF YES, GO TO END-DD-STMT RTN\n         BR    R6                  IF NO, RETURN TO CALLING RTN\nMOVEDDN  MVC   DDNAME(0),I2DDNAME  MVC INTR FOR EX\nMOVEDSN  MVC   DSNAME(0),I2DSNAME  MVC INTR FOR EX\n*\n*\n***********************************************************************\n*    THE ROUTINE PROCESSES THE DDN/DSN INFORMATION.\n***********************************************************************\n*\nPROCESS  ...                       PROCESS INFORMATION\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    SVC99 REQ-BLOCK-POINTER AND REQUEST BLOCK\n***********************************************************************\n*\nRBPTR    DS    F                   PTR TO SVC 99 REQ BLOCK\nREQBLK   DS    CL(S99RBEND-S99RB)  STORAGE FOR REQ BLOCK\nREQBLKLN EQU   L'REQBLK            LENGTH OF REQ BLOCK\n*\n*\n***********************************************************************\n*    TEXT-UNITS-POINTERS LIST\n***********************************************************************\n*\nTUPTR007 DS    0F\n         DC    A(TURLNOI2)         ADR OF TU FOR REL NUMB\n         DC    A(TURDDNI2)         ADR OF TU FOR RET-DDN\n         DC    A(TURDSNI2)         ADR OF TU FOR RET-DSN\n         DC    X'80'               INDICATES LAST TU ADDRESS\n         DC    AL3(TULESWI2)       ADR OF TU FOR LAST-DD-STMT IND\n*\n*\n***********************************************************************\n*    TEXT UNITS\n***********************************************************************\n*\nTURLNOI2 DC    AL2(DINRELNO),AL2(1),AL2(2)\nI2RELNO  DS    CL2                 RELATIVE NUMBER OF ALLOCATION\n*\nTURDDNI2 DC    AL2(DINRTDDN),AL2(1)\nI2DDNLEN DS    CL2                 RETURNED LENGTH OF DDNAME\nI2DDNAME DS    CL8                 RETURNED DDNAME\n*\nTURDSNI2 DC    AL2(DINRTDSN),AL2(1)\nI2DSNLEN DS    CL2                 RETURNED LENGTH OF DSNAME\nI2DSNAME DS    CL44                RETURNED DSNAME\n*\nTULESWI2 DC    AL2(DINRTLST),AL2(1),AL2(1)\nI2LESW   DS    CL1                 LAST DD-STMT INDICATOR\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nRELNO    DC    F'0'                REL NUM FOR DYNAM INFO RETRV\n         DC    C' '                USED TO BLANK DDNAME\nDDNAME   DS    CL8                 AREA TO SAVE DDN FROM INFO RETV\n         DC    C' '                USED TO BLANK DSNAME\nDSNAME   DS    CL44                AREA TO SAVE DSN FROM INFO RETV\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         IEFZB4D0        GENS DSECT FOR REQ BLOCK, TEXT UNIT, ETC.\n         IEFZB4D2        GENS TABLE OF EQUATES FOR TU KEYS\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080301": {"ttr": 4114, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x8e\\x00\\x8e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.3.1\n*\n*\n         ...\n         BAL   R6,OPENDIR          OPEN PDS DIRECTORY\nNXTENTRY BAL   R6,GETDRBLK         READ A PDS DIR BLOCK\n         BAL   R6,GETENTRY         GET INDIV PDS DIR ENTRY\n         ...                       PROCESS\n         B     NXTENTRY            GET NEXT PDS DIR ENTRY\nDIREND   BAL   R6,CLOSEDIR         DIR END, CLOSE PDS DIR\n         ...\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE DCB FOR THE PDS DIRECTORY.\n***********************************************************************\n*\nOPENDIR  OPEN  PODIRDCB            OPEN PDS DIR\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE USES QSAM TO READ AN ENTIRE PDS DIRECTORY BLOCK. WHEN\n*    THIS ROUTINE RETURNS CONTROL TO THE CALLING ROUTINE REGISTERS 14,\n*    15, 0 AND 1 ARE SAVED IN THE AREA SAVEREGS AND REGISTERS 1, 14 AND\n*    15 CONTAIN THE FOLLOWING CONTROL INFORMATION:\n*        * REGISTER  1 --- ADDRESS OF THE FIRST ENTRY OF THE PDS DIR\n*                          BLOCK;\n*        * REGISTER 14 --- NUMBER OF USED BYTES IN THE DIRECTORY BLOCK;\n*        * REGISTER 15 --- NUMBER OF BYTES OF DIR BLOCK PROCESSED,\n*                          INITIALLY SET TO 2 FOR DIR BLK COUNT FIELD.\n***********************************************************************\n*\nGETDRBLK CLI   GETDBSW,C'0'        CHK IF GET REQUIRED\n         BER   R6                  IF NO, RET TO CALLING RTN\n         GET   PODIRDCB,DIRBLOCK   GET A DIR BLOCK\n         MVI   GETDBSW,C'0'        INDICATE GET DONE\n         LA    R15,2               START RUNNING DIR BLK COUNT,\n*                                  2 BYTES FOR DIR COUNT FIELD\n         LH    R14,DIRBLOCK        LOAD REG14 WITH DIR BLK COUNT\n         LA    R1,DIRBLOCK+2       LOAD REG1 WITH FIRST ENTRY ADR\n         STM   R14,R1,SAVEREGS     SAVE REGS FOR GETENTRY RTN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE GETS THE NEXT PDS DIRECTORY ENTRY. WHEN THIS ROUTINE\n*    RECEIVES CONTROL, REGISTERS 14 THROUGH 1 ARE SAVED IN THE AREA\n*    SAVEREGS. THE REGISTERS IN SAVEREGS CONTAIN THE FOLLOWING CONTROL\n*    INFORMATION:\n*        * REGISTER 14 --- NUMBER OF USED BYTES IN THE DIRECTORY BLOCK;\n*        * REGISTER 15 --- NUMBER OF BYTES OF DIRECTORY BLOCK PROCESSED\n*                          SO FAR;\n*        * REGISTER  1 --- ADDRESS OF THE PREVIOUS ENTRY OF THE PDS\n*                          DIRECTORY BLOCK;\n*    WHEN THIS ROUTINE RETURNS CONTROL TO THE CALLING ROUTINE, THE\n*    FOLLOWING AREAS CONTAIN THE FOLLOWING INFORMATION:\n*        MEMBNAME --- THE MEMBER NAME OR ALIAS;\n*        TTRC     --- THE TTRC FIELD OF THE PDS DIR ENTRY;\n*        USERDATA --- ANY USERDATA CONTAINED IN THE PDS DIR ENTRY OR\n*                     BINARY ZEROS IF THERE IS NO USER-DATA.\n*    IN ADDITION, THE CONTROL INFORMATION IN REGISTERS 1 AND 15 IS\n*    UPDATED AND REGISTERS 14 THROUGH 1 ARE SAVED IN THE AREA SAVEREGS.\n***********************************************************************\n*\nGETENTRY LM    R14,R1,SAVEREGS     RESTORE REGS\n         CLC   0(8,R1),BINONES     CHK FOR LOGICAL END OF DIR\n         BE    DIREND              IF YES, END OF DIR\n         MVC   MEMBNAME,0(R1)      MOVE MEMBER NAME\n         MVC   TTRC,8(R1)          MOVE TTRC\n         XC    USERDATA,USERDATA      CLEAR USERDATA AREA FOR EX INSTR\n         MVC   UDATALEN+3(1),TTRC+3   MOVE ENTRY CONTROL FIELD\n         NI    UDATALEN+3(1),X'1F'    ZERO HIGH ORDER 3 BITS TO\n*                                     ISOLATE USERDATA LENGTH\n         L     R2,UDATALEN         LOAD REG2 WITH USERDATA LENGTH\n*                                  IN HALFWORDS\n         SLL   R2,1                CONVERT HALFWORDS TO BYTES\n         BAL   R7,GETUDATA         GET USERDATA\n         LA    R2,12(0,R2)         LOAD REG2 WITH ENTRY LENGTH,\n*                                  (MINIMUM 12 + USERDATA)\n         AR    R15,R2              ADD ENTRY LEN TO RUNNING DIR BLK CT\n         CR    R15,R14             COMPARE RUNNING DIR BLK COUNT TO\n*                                  DIR BLK COUNT\n         BNL   DRBLKEND            IF NOT LOW, ENTIRE DIR BLK PROCESSED\n         B     SETNXENT            IF MORE DIR, INCR REG1 TO NEXT ENTRY\nDRBLKEND MVI   GETDBSW,C'1'        IND THAT GET NEXT DIR BLK REQUIRED\n         BR    R6                  RETURN TO CALLING RTN\nSETNXENT LA    R1,0(R2,R1)         INCR REG1 TO NEXT DIR ENTRY ADR\n         STM   R14,R1,SAVEREGS     SAVE REGS FOR NEXT GETENTRY EXEC\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE GETS THE USERDATA OF THE PDS DIRECTORY. WHEN THIS\n*    SUBROUTINE RECEIVES CONTROL, REGISTER 2 CONTAINS THE LENGTH OF THE\n*    USERDATA IN BYTES AND REGISTER 1 CONTAINS THE ADDRESS OF THE\n*    BEGINNING OF THE PDS DIRECTORY ENTRY. WHEN THIS SUBROUTINE RETURNS\n*    CONTROL TO THE CALLING ROUTINE, THE AREA USERDATA CONTAINS THE\n*    USERDATA OF THE PDS DIRECTORY ENTRY OR BINARY ZEROS IF THE ENTRY\n*    CONTAINS NO USERDATA.\n***********************************************************************\n*\nGETUDATA LTR   R2,R2               CHK IF USERDATA PRESENT\n         BZR   R7                  IF NO, BACK TO CALLER\n         BCTR  R2,0                DECR REG2 LEN FOR EX INSTR\n         EX    R2,MOVUDATA         MOVE USER DATA\n         LA    R2,1(0,R2)          RESTORE REG2 LEN\n         BR    R7                  RETURN TO CALLING RTN\nMOVUDATA MVC   USERDATA(0),12(R1)  MOVE ONLY SPECIFIED USERDATA\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE DCB FOR THE PDS DIRECTORY.\n***********************************************************************\n*\nCLOSEDIR CLOSE PODIRDCB            CLOSE PDS DIR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nGETDBSW  DC    C'1'\nBINONES  DC    8XL1'FF'\nDIRBLOCK DS    CL256\nMEMBNAME DS    CL8\nTTRC     DS    CL4\nUSERDATA DS    CL62\nUDATALEN DC    F'0'\nSAVEREGS DS    4F\n*\n*\n***********************************************************************\n*    THE DCB FOR THE PDS DIRECTORY\n***********************************************************************\n*\nPODIRDCB DCB   DSORG=PS,MACRF=GM,BLKSIZE=256,LRECL=256,RECFM=F,        -\n               EODAD=DIREND,DDNAME=LIBDD\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080302": {"ttr": 4356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00O\\x00O\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.3.2\n*\n*\n         ...\n         BAL   R6,OPENDIR          OPEN PDS DIRECTORY\nNXTENTRY BAL   R6,GETDRBLK         READ A WHOLE DIRECTORY BLOCK\n         BAL   R6,GETENTRY         EXTRACT AN ENTRY FROM DIR BLOCK\n         ...\n         B     NXTENTRY            OBTAIN NEXT DIR ENTRY\nDIREND   BAL   R6,CLOSEDIR         CLOSE PDS DIR DCB\n         ...\n*\nOPENDIR  OPEN  PODIRDCB            OPEN PDS DIR DCB\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\nGETDRBLK CLI   GETDBSW,C'0'        CHK IF GET REQUIRED\n         BER   R6                  IF NO, RET TO CALLING RTN\n         READ  DIRDECB,SF,PODIRDCB,DIRBLOCK\n         CHECK DIRDECB\n         MVI   GETDBSW,C'0'        INDICATE GET DONE\n         LA    R15,2               START RUNNING DIR BLK COUNT\n         LH    R14,DIRDATA         LOAD REG14 WITH DIR BLK COUNT\n         LA    R1,DIRDATA+2        LOAD REG1 WITH FIRST ENTRY ADR\n         STM   R14,R1,SAVEREGS     SAVE REGS FOR GETENTRY RTN\n         BR    R6                  RETURN TO CALLING RTN\n*\nGETENTRY LM    R14,R1,SAVEREGS     RESTORE REGS\n         CLC   0(8,R1),BINONES     CHK FOR LOGICAL END OF DIR\n         BE    DIREND              IF YES, END OF DIR\n         MVC   MEMBNAME,0(R1)      MOVE MEMBER NAME\n         MVC   TTRC,8(R1)          MOVE TTRC FIELDS\n         XC    USERDATA,USERDATA      CLEAR USERDATA REC AREA\n         MVC   UDATALEN+3(1),TTRC+3   MOVE ENTRY CONTROL FIELD\n         NI    UDATALEN+3(1),X'1F'    ZERO HIGH ORDER 3 BITS TO\n*                                     ISOLATE USERDATA LENGTH\n         L     R2,UDATALEN         LOAD REG2 WITH USERDATA LENGTH\n*                                  IN HALFWORDS\n         SLL   R2,1                CONVERT HALFWORDS TO BYTES\n         BAL   R7,GETUDATA         GET USERDATA\n         LA    R2,12(0,R2)         LOAD REG2 WITH ENTRY LENGTH\n         AR    R15,R2              ADD ENTRY LENGTH TO RUNNING DIR BLK\n*                                  COUNT\n         CR    R15,R14             COMPARE RUNNING DIR BLK COUNT TO\n*                                  DIR BLK COUNT\n         BNL   DRBLKEND            IF NOT LOW, ENTIRE DIR BLK PROCESSED\n         B     SETNXENT            IF MORE DIR, INCR REG1 TO NEXT ENTRY\nDRBLKEND MVI   GETDBSW,C'1'        INDICATE THAT GET NEXT DIR BLK REQRD\n         BR    R6                  RETURN TO CALLING RTN\nSETNXENT LA    R1,0(R2,R1)         INCR REG1 TO NEXT DIR ENTRY\n         STM   R14,R1,SAVEREGS     SAVE REGS FOR NEXT GETENTRY EXEC\n         BR    R6                  RETURN TO CALLING RTN\n*\nGETUDATA LTR   R2,R2               CHK IF USERDATA PRESENT\n         BZR   R7                  IF NO, BACK TO CALLER\n         BCTR  R2,0                DECR REG2 LEN FOR EX INSTR\n         EX    R2,MOVUDATA         MOVE USER DATA\n         LA    R2,1(0,R2)          RESTORE REG2 LEN\n         BR    R7                  RETURN TO CALLING RTN\nMOVUDATA MVC   USERDATA(0),12(R1)  MVC FOR EX INSTR\n*\nCLOSEDIR CLOSE PODIRDCB            CLOSE PDS DIRECTORY DCB\n         BR    R6                  RETURN TO CALLING RTN\n*\nGETDBSW  DC    C'1'\nBINONES  DC    8XL1'FF'\nDIRBLOCK DS    0CL264\nDIRKEY   DS    CL8\nDIRDATA  DS    CL256\nMEMBNAME DS    CL8\nTTRC     DS    CL4\nUSERDATA DS    CL62\nUDATALEN DC    F'0'\nSAVEREGS DS    4F\n*\nPODIRDCB DCB   DSORG=PS,MACRF=R,KEYLEN=8,BLKSIZE=256,LRECL=256,        -\n               RECFM=F,EODAD=DIREND,DDNAME=LIBDD\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080303": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00O\\x00O\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.3.3\n*\n*\n         MACRO\n&LABEL   READDIR &DDNAME\n         GBLA  &RDIRSW             USED TO PREVENT DUPL GEN $-AREAS\n         LCLC  &LBL                USED TO GEN UNIQUE LABELS\n&LBL     SETC  '$'.'RDR'.'&SYSNDX'(2,3)   SET LABEL PREFIX\n&LABEL   LM    14,1,&LBL.A         RESTORE REG 14, 15, 0, 1 FROM PREV\n*                                  EXEC OF READDIR MACRO\n         ST    2,&LBL.B            SAVE REG 2\n         B     &LBL.O              BRANCH AROUND CONSTANTS\n&LBL.A   DS    4F                  SAVE AREA FOR REGS 14, 15, 0, 1\n&LBL.B   DS    F                   SAVE AREA FOR REG 2\n&LBL.C   DC    F'0'                AREA TO EXPAND DIR ENTRY SIZE FIELD\n*                                  TO FULLWORD\n         AIF   (&RDIRSW EQ 1).BYPASS   CHECK IF $-AREAS WERE DEFINED\n$MEMBER  DS    CL8                 MEMBER NAME\n$TTRC    DS    CL4                 TTRC FIELD\n&RDIRSW  SETA  1                   INDICATE THAT $MEMBER AND $TTRC\n*                                  ARE DEFINED\n.BYPASS  ANOP\n*        DCB   BLKSIZE=256,LRECL=256,RECFM=F,DDNAME=&DDNAME,           -\n*              MACRF=GM,DSORG=PS,EODAD=&LBL.J\n&LBL.D   DCB   BLKSIZE=256,LRECL=256,RECFM=F,DDNAME=&DDNAME,           -\n               MACRF=GM,DSORG=PS,EODAD=&LBL.J\n&LBL.E   DC    C'0'                OPEN SWITCH\n&LBL.H   DS    CL256               DIRECTORY AREA\n&LBL.N   DC    8XL1'FF'            END OF DIR INDICATOR\n&LBL.O   CLI   &LBL.E,C'1'         CHK IF DIR OPENED\n         BE    &LBL.F              IF YES, BRANCH AROUND OPEN AND\n*                                  FIRST GET\n*        OPEN  &LBL.D              OPEN DIR DCB\n         OPEN  &LBL.D\n         TM    &LBL.D+48,X'10'     CHECK IF PDS JCL DD STMT SPECIFIED\n         BNO   &LBL.P              IF NOT, INDICATE IT\n         MVI   &LBL.E,C'1'         SET OPEN SWITCH\n*        GET   &LBL.D,&LBL.H       GET DIR BLOCK\n&LBL.G   GET   &LBL.D,&LBL.H\n         LA    15,2                START RUNNING DIR BLOCK COUNT\n         LA    1,2(0,1)            INCR REG1 PAST DIR COUNT FIELD\n         LH    14,&LBL.H           LOAD REG14 WITH DIR BLOCK COUNT\n         B     &LBL.I              GET MEMBER NAME\n&LBL.F   MVC   &LBL.C+3(1),11(1)   EXPAND ENTRY SIZE FIELD TO FULLWORD\n         NI    &LBL.C+3,X'1F'      ZERO HIGH ORDER 3 BITS TO ISOLATE\n*                                  USERDATA LENGTH\n         L     2,&LBL.C            LOAD ENTRY USERDATA LEN (HALFWORDS)\n*                                  INTO REG2\n         LA    2,12(2,2)           LOAD ENTRY LENGTH (BYTES) INTO REG2\n         AR    15,2                ADD CURRENT ENTRY LEN TO RUNNING DIR\n*                                  BLOCK COUNT\n         CR    15,14               COMPARE RUNNING DIR BLOCK COUNT TO\n*                                  DIR BLOCK COUNT\n         BNL   &LBL.G              IF NOT LOW, ENTIRE DIR BLK PROCESSED\n         LA    1,0(2,1)            INCR REG1 TO NEXT ENTRY\n&LBL.I   CLC   0(8,1),&LBL.N       COMPARE FOR LOGICAL END OF DIR\n         BE    &LBL.J              IF EQUAL, DIR END\n         MVC   $MEMBER,0(1)        MOVE MEMBER NAME\n         MVC   $TTRC,8(1)          MOVE TTRC FIELD\n         TM    11(1),X'80'         CHK IF MEMBER NAME IS AN ALIAS\n         BO    &LBL.K              IF BIT ON, ALIAS\n         B     &LBL.L              NORMAL END\n&LBL.P   LA    R15,12              INDICATE PDS JCL DD STMT MISSING\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.J   MVI   &LBL.E,C'0'         ZERO OPEN SWITCH\n*        CLOSE &LBL.D              CLOSE DIR DCB\n         CLOSE &LBL.D\n         XC    $MEMBER,$MEMBER     CLEAR MEMBER NAME AT END OF DIR\n         LA    15,8                INDICATE END OF DIR\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.K   STM   14,1,&LBL.A         SAVE REG 14, 15, 1\n         LA    15,4                INDICATE ALIAS\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.L   STM   14,1,&LBL.A         SAVE REG 14, 15, 1\n         LA    15,0                NORMAL END\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.M   L     2,&LBL.B            RESTORE REG2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080401": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x94\\x00\\x94\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.4.1\n*\n*\nREADPDSQ CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IHADCB,R10          DEFINE REG FOR DCB DSECT\n         USING INFMJFCB,R11        DEFINE REG FOR JFCB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,RDJFCB           READ JFCB INTO PROG AREA\nNEXTMEMB BAL   R6,GETNAME          GET NEXT MEMBER NAME FROM PDS DIR\n         BAL   R6,SETNAME          PUT MEMBER NAME INTO JFCB\n         BAL   R6,OPEN             OPEN PDS, POS TO MEMBER\nNEXTREC  BAL   R6,READ             READ A RECORD OF MEMBER\n         BAL   R6,PROCMEMB         PROCESS RECORD\n         B     NEXTREC             GET NEXT MEMBER RECORD\nMEMBEND  BAL   R6,CLOSE            ALL MEMB RECS READ, CLOSE PDS\n         B     NEXTMEMB            GET NEXT MEMBER NAME\nMEMBENDX BAL   R6,CLOSE            ALL MEMBERS READ, CLOSE PDS\n         B     RETURN              RETURN TO MVS OR CALLING PROGRAM\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCB AND COPIES IT FROM THE SWA INTO THE\n*    PROGRAMMER-SUPPLIED AREA.\n***********************************************************************\n*\nRDJFCB   RDJFCB PDSQDCB\n         LTR   R15,R15             CHK IF DD STMT IN JCL\n         BNZ   NODDSTMT            DD STMT MISSING\n         BR    R6                  RETURN TO CALLING RTN\nNODDSTMT WTO   '*** DDNAME \"PDSDD\" IS NOT IN JOBSTREAM ***',ROUTCDE=11\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE USES THE READDIR MACRO TO OBTAIN THE MEMBER NAME IN\n*    THE NEXT PDS DIRECTORY ENTRY. ALIAS NAMES ARE IGNORED.\n***********************************************************************\n*\nGETNAME  READDIR PDSDD\n         LTR   R15,R15             CHECK IF PRIMARY NAME\n         BZR   R6                  IF YES, RET TO CALLING RET\n         C     R15,BIN4            CHECK IF ALIAS\n         BE    GETNAME             IF YES, IGNORE GET NEXT NAME\n         B     MEMBENDX            END OF DIR, BRNCH TO END-OF-MEMB RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE MODIFIES THE JFCB. THE NAME OF THE NEXT PDS MEMBER TO\n*    BE READ IS INSERTED INTO THE PDS-MEMBER-NAME FIELD OF THE JFCB.\n***********************************************************************\n*\nSETNAME  LA    R11,JFCB            SET ADRBLTY FOR PDS DCB DSECT\n         MVC   JFCBELNM,$MEMBER    MOVE CURRENT MEMB NAME INTO JFCB\n         OI    JFCBIND1,JFCPDS     IND THAT MEMB NAME SPEC IN JFCB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE PDS DCB USING THE INFORMATION IN THE\n*    MODIFIED JFCB. THE OPEN WILL CAUSE THE NEXT GET TO READ THE FIRST\n*    LOGICAL RECORD OF THE MEMBER WHOSE NAME IS SPECIFIED IN THE JFCB.\n***********************************************************************\n*\nOPEN     OPEN  PDSQDCB,TYPE=J      TELL OPEN TO USE MODIFIED JFCB\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE USES QSAM TO READ A LOGICAL RECORD OF THE MEMBER.\n***********************************************************************\n*\nREAD     GET   PDSQDCB             GET A MEMBER RECORD\n         LR    R2,R1               SAVE ADR OF RECORD IN REG 2\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PROCESSES EACH LOGICAL RECORD OF THE MEMBER.\n***********************************************************************\n*\nPROCMEMB ...                       PROC RECORDS OF MEMBER\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES PDS DCB.\n***********************************************************************\n*\nCLOSE    CLOSE PDSQDCB             CLOSE PDS\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nBIN4     DC    F'4'\n*\n*\n***********************************************************************\n*    THE JFCB-LIST AND THE DCB FOR THE PDS\n***********************************************************************\n*\nJFCB     DS    44F\nJFCBPTR  DC    X'87'\n         DC    AL3(JFCB)\n*\nPDSQDCB  DCB   DSORG=PS,MACRF=GL,EODAD=MEMBEND,EXLST=JFCBPTR,          -\n               DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         DCBD  DSORG=PS            GENERATES PS-DCB DSECT\n*\n         DSECT\n         IEFJFCBN                  GENERATES JFCB DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE080402": {"ttr": 4366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xe5\\x00\\xe5\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 229, "newlines": 229, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.4.2\n*\n*\nREADPDSB CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IHADCB,R10          DEFINE REG FOR DCB DSECT\n         USING LRECMAP,R11         DEFINE REG FOR LREC DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN             OPEN DATASETS\n         BAL   R6,GETMAIN          ALLO STOR FOR PDS BLOCK I/O AREA\n         BAL   R6,GETLRINF         CALC NUMB OF LRECS PER BLOCK\nNEXTMEMB BAL   R6,LOCMEMB          LOCATE SPEC MEMBER IN PDS\nNEXTLREC BAL   R6,GETLREC          GET A LOGICAL RECORD OF MEMBER\n         BAL   R6,PROCMEMB         PROCESS LOGICAL RECORD\n         B     NEXTLREC            GET NEXT LOGICAL RECORD OF MEMBER\nMEMBEND  B     NEXTMEMB            END-OF-MEMB, GET NEXT MEMBER\nMEMBENDX BAL   R6,CLOSE            ALL MEMBERS READ, CLOSE DATASETS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (SYSIN,,PDSBDCB)\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE BLKSIZE FROM THE PDS DCB AND ALLOCATES\n*    VIRTUAL STORAGE FOR THE PDS BLOCK I/O AREA.\n***********************************************************************\n*\nGETMAIN  LA    R10,PDSBDCB         SET ADRBLTY FOR PDS DCB DSECT\n         LH    R11,DCBBLKSI        LD PDS BLOCK SIZE\n         GETMAIN EC,LV=(R11),A=BLKADR\n         ...                       CHECK IF GM OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CALCULATES THE NUMBER OF LOGICAL RECORDS IN A FULL\n*    PHYSICAL BLOCK. THIS INFORMATION IS USED BY THE DEBLOCKING RTN.\n***********************************************************************\n*\nGETLRINF LA    R10,PDSBDCB         SET ADRBLTY FOR PDS DCB DSECT\n         LH    R12,DCBLRECL        LOAD PDS LRECL\n         ST    R12,LRECLEN         SAVE PDS LRECL\n         LA    R14,0               CLEAR REG 14 FOR DR INSTR\n         LH    R15,DCBBLKSI        LOAD PDS BLKSZ\n         DR    R14,R12             DIVIDE BLKSZ BY LRECL\n         ST    R15,LRECMAX         SAVE NUMB OF LRECS PER BLOCK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOCATES THE NEXT MEMBER TO BE PROCESSED. IN ORDER\n*    TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO THE\n*    SUBROUTINES WHICH PERFORM THE FOLLOWING FUNCTIONS:\n*        * READ THE NEXT MEMBER NAME FROM THE SYSIN DATASET;\n*        * SET THE DASD LOCATION IN THE PDS DCB TO THE BEGINNING OF THE\n*          MEMBER WHICH IS TO PROCESSED.\n***********************************************************************\n*\nLOCMEMB  BAL   R7,GETNAME          GET A SPECIFIED MEMBER NAME\n         BAL   R7,FINDMEMB         SET MEMB PTR IN PDS DCB\n         LTR   R15,R15             CHK IF MEMB FOUND\n         BNZ   LOCMEMB             IF NO, TRY NEXT SPEC MEMB\n         BR    R6                  IF YES, RET TO CALLING RET\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE READS THE NAME OF THE NEXT MEMBER, WHICH IS TO BE\n*    PROCESSED, FROM THE SYSIN DATASET.\n***********************************************************************\n*\nGETNAME  GET   SYSIN,MEMBNAME      GET A SPEC MEMB NAME FROM SEQ DS\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CAUSES THE LOCATION OF THE BEGINNING OF THE\n*    SPECIFIED MEMBER TO BE PLACED INTO THE PDS DCB.\n***********************************************************************\n*\nFINDMEMB FIND  PDSBDCB,MEMBNAME,D  FIND MEMB WITH NAME SPECIFIED\n         LTR   R15,R15             CHK IF SPEC MEMB FOUND\n         BNZ   NOMEMB              IF NO, IND MEMB NOT FOUND\n         BR    R7                  IF YES, RET TO CALLING RET\nNOMEMB   ...\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE NEXT LOGICAL RECORD OF THE MEMBER. IN ORDER\n*    TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO THE\n*    SUBROUTINES WHICH PERFORM THE FOLLOWING FUNCTIONS:\n*        * READ THE NEXT PHYSICAL BLOCK OF THE MEMBER;\n*        * DEBLOCK THE PHYSICAL BLOCK INTO LOGICAL RECORDS.\n***********************************************************************\n*\nGETLREC  BAL   R7,READBLOK         READ A MEMB BLOCK FROM PDS\n         BAL   R7,DEBLOCK          GET A LREC FROM BLOCK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE READS AN ENTIRE PHYSICAL BLOCK OF THE MEMBER AND\n*    SETS THE LOGICAL RECORD POINTER TO THE BEGINNING OF THE BLOCK AND\n*    SETS THE LOGICAL RECORD NUMBER COUNTER TO ONE.\n***********************************************************************\n*\nREADBLOK CLI   READSW,C'1'         CHK IF NEXT BLOCK READ REQUIRED\n         BNER  R7                  IF NOT, RET TO CALLING RET\n         MVI   READSW,C'0'\n         L     R11,BLKADR          LD ADR OF BLOCK I/O AREA\n         ST    R11,LRECPTR         INIT LREC PTR TO BG OF BLOCK\n         MVC   LRECCTR,ONE         INIT LREC CTR TO ONE\n         READ  RDDECB,SF,PDSBDCB,(R11)\n         CHECK RDRECB              CHECK IF READ OK\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE DEBLOCKS A PHYSICAL BLOCK OF THE PDS INTO LOGICAL\n*    RECORDS. IT USES THE INFORMATION IN LRECPTR (POINTER TO NEXT\n*    LOGICAL RECORD) AND LRECCTR (NUMBER OF THE NEXT LOGICAL RECORD IN\n*    THE BLOCK). THIS ROUTINE DOES THE FOLLOWING:\n*        * UPDATES THE VALUES IN LRECPTR AND LRECCTR;\n*        * CHECKS FOR END-OF-BLOCK (BY COMPARING THE NUMBER OF THE\n*          LOGICAL RECORD TO THE TOTAL LOGICAL RECORDS IN A BLOCK);\n*        * LOADS REGISTER 2 WITH THE ADDRESS OF THE CURRENT LOGICAL\n*          RECORD.\n*    THE INITIAL VALUES OF LRECPTR AND LRECCTR ARE SET BY THE READBLOK\n*    ROUTINE.\n***********************************************************************\n*\nDEBLOCK  L     R10,LRECCTR         LOAD CURR LREC CTR\n         L     R11,LRECPTR         LOAD CURR LREC PTR\n         LR    R2,R11              SAVE CURR LREC PTR IN REG 2\n         C     R10,LRECMAX         CHECK IF LAST LREC OF BLOCK\n         BE    LRECEND             IF YES, IND IT\n         LA    R10,1(0,R10)        INCR LREC COUNT\n         ST    R10,LRECCTR         SAVE LREC COUNT\n         L     R12,LRECLEN         LOAD PDS LRECL\n         LA    R11,0(R12,R11)      INCR TO NEXT LREC ADR\n         ST    R11,LRECPTR         SAVE NEXT LREC ADR\n         BR    R7                  RETURN TO CALLING RTN\nLRECEND  MVI   READSW,C'1'         IND THAT NEXT BLOCK READ REQUIRED\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PROCESSES EACH LOGICAL RECORD OF THE MEMBER.\n***********************************************************************\n*\nPROCMEMB LR    R11,R2              LD ADR OF LREC, SET DSECT ADRBLTY\n         ...\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (SYSIN,,PDSBDCB)    CLOSE ALL DCBS\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nREADSW   DC    C'1'\nONE      DC    F'1'\nBLKADR   DS    F\nLRECLEN  DS    F\nLRECPTR  DS    F\nLRECCTR  DS    F\nLRECMAX  DS    F\nMEMBNAME DS    D\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nSYSIN    DCB   DSORG=PS,MACRF=GM,EODAD=MEMBENDX,DDNAME=SYSIN\nPDSBDCB  DCB   DSORG=PO,MACRF=R,EODAD=MEMBEND,DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         DCBD  DSORG=PO            GENERATES PO-DCB DSECT\n         PRINT GEN\n*\n         DSECT\n         LRECMAP\n         ...                       FIELDS OF LOGICAL RECORD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080403": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.4.3\n*\n*\nLOCMEMB  BAL   R7,GETNAME          GET A SPECIFIED MEMBER NAME\n         BAL   R7,GETTTRK          GET TTRK OF MEMBER\n         LTR   R15,R15             CHK IF TTRK OF MEMB FOUND\n         BNZ   LOCMEMB             IF NO, TRY TO LOC NEXT MEMB\n         BAL   R7,FINDMEMB         IF YES, SET MEMB PTR IN PDS DCB\n         BR    R6                  RETURN TO CALLING RTN\n*\nGETNAME  GET   SYSIN,MEMBNAME      GET A SPEC MEMB NAME FROM SEQ DS\n         BR    R7                  RETURN TO CALLING RTN\n*\nGETTTRK  MVC   BLDLNAME,MEMBNAME   MOVE MEMB NAME INTO BLDL-LIST\n         BLDL  PDSBDCB,BLDLLST     READ DIR ENTRY FOR SPEC MEMB\n         LTR   R15,R15             CHK IF DIR ENTRY FOUND\n         BNZ   NOMEMB              IF NO, INDICATE IT\n         BR    R7                  RETURN TO CALLING RTN\nNOMEMB   ...\n         BR    R7                  RETURN TO CALLING RTN\n*\nFINDMEMB FIND  PDSBDCB,BLDLTTRK,C  FIND MEMB WITH TTRK SPECIFIED\n         BR    R7                  RETURN TO CALLING RTN\n*\nBLDLLST  DS    0CL16\nBLDLFFLL DC    X'0001',X000C'      1 ENTRY, 12 BYTES\nBLDLNAME DS    CL8\nBLDLTTRK DS    CL4\n*\nMEMBTTRK DS    CL4\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080501": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00X\\x00X\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.5.1\n*\n*\nWRTPDSQ  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R            INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN            OPEN DATASETS\nNEXTREC  BAL   R6,GETRECS         READ A RECORD OF THE MEMBER\n         BAL   R6,PUTRECS         WRITE A RECORD OF THE MEMBER INTO PDS\n         B     NEXTREC            READ NEXT RECORD\nRECEND   BAL   R6,CLOSE           CLOSE DATASETS AND UPDATE PDS DIR\n         B     RETURN             RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS AND CAUSES THE NEXT PUT TO THE PDS\n*    TO START WRITING AFTER THE LAST MEMBER IN THE PDS.\n***********************************************************************\n*\nOPEN     OPEN  (SEQIN,,PDSOUT,(OUTPUT))\n         ...                      CHECK FOR GOOD OPEN\n         BR    R6                 RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE RECORDS WHICH ARE TO BE PUT INTO THE PDS.\n***********************************************************************\n*\nGETRECS  GET   SEQIN,RECORD       READ MEMB REC FROM SEQ DATASET\n         BR    R6                 RETURN TO CALLED\n*\n*\n***********************************************************************\n*    THIS ROUTINE WRITES THE RECORDS INTO THE PDS.\n***********************************************************************\n*\nPUTRECS  PUT   PDSOUT,RECORD      WRITE MEMB REC INTO PDS\n         BR    R6                 RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS AND IMPLICITLY CAUSES THE STOW\n*    FUNCTION TO UPDATE THE DIRECTORY OF THE PDS.\n***********************************************************************\n*\nCLOSE    CLOSE (SEQIN,,PDSOUT)    CLOSE DATASETS AND UPDT DIR\n         BR    R6                 RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0               RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nRECORD   DS    CL80\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nSEQIN    DCB   DSORG=PS,MACRF=GM,EODAD=RECEND,DDNAME=SEQDD\nPDSOUT   DCB   DSORG=PS,MACRF=PM,DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080502": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\x04\\x01\\x04\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 260, "newlines": 260, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.5.2\n*\n*\nWRTPDSB  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IHADCB,R10          DEFINE REG FOR DCB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN             OPEN DATASETS\n         BAL   R6,GETMAIN          ALLOC STOR FOR I/O BLOCK AREA\n         BAL   R6,CALCRECS         FIND NUMB OF LRECS IN BLOCK\n         BAL   R6,GETNAME1         GET AND SAVE FIRST MEMBER NAME\nNEXTREC  BAL   R6,GETDATA          READ MEMB RECS, BLD BLOCK\n         BAL   R6,WRTPDS           WRITE WHOLE BLOCK INTO PDS\n         B     NEXTREC             GET NEXT MEMB REC\nMEMBEND  BAL   R6,LASTBLK          MEMB-RECS-END, WRITE LAST INCOMP\n*                                    BLOCK INTO PDS\n         BAL   R6,STOW             UPDATE PDS DIR\n         B     NEXTREC             GET NEXT MEMB RECORDS\nDATAEND  BAL   R6,LASTBLK          END-OF-MEMBS, WRITE LAST INCOMP\n*                                    BLOCK INTO PDS\n         BAL   R6,STOW             UPDATE PDS DIR FOR LAST MEMB\n         BAL   R6,CLOSE            CLOSE DATASETS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (SEQDCB,,PDSDCB,(OUTPUT))\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE BLKSIZE FROM THE PDS DCB AND ALLOCATES\n*    VIRTUAL STORAGE FOR THE PDS BLOCK I/O AREA.\n***********************************************************************\n*\nGETMAIN  LA    R10,PDSDCB          SET ADRBLTY FOR PDS DCB DSECT\n         LH    R11,DCBBLKSI        LD PDS BLKSZ FOR GETMAIN\n         GETMAIN EU,LV=(R11),A=BLKADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CALCULATES THE NUMBER OF LOGICAL RECORDS IN A FULL\n*    PHYSICAL BLOCK. THIS INFORMATION IS USED BY THE BLOCKING ROUTINE.\n***********************************************************************\n*\nCALCRECS LA    R10,PDSDCB          SET ADRBLTY FOR PDS DCB DSECT\n         LA    R14,0               CLEAR REG 14 FOR DR INSTR\n         LH    R15,DCBBLKSI        LD PDS BLKSZ\n         LH    R12,DCBLRECL        LD PDS LRECL\n         DR    R14,R12             DIVIDE LRECL INTO BLKSZ\n         ST    R15,BLKRECS         SAVE NUMB OF LRECS PER BLOCK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE FIRST RECORD OF THE SEQUENTIAL DATASET AND\n*    VERIFIES THAT IT CONTAINS A MEMBER NAME.\n***********************************************************************\n*\nGETNAME1 BAL   R7,GETSEQ           READ FIRST REC FROM SEQ DS\n         CLC   0(2,R2),ID          CHK FOR MEMB NAME ID\n         BNE   NONAME1             IF NO, NO MEMB NAME\n         MVC   SAVENAME,2(R2)      IF YES, SAVE MEMB NAME\n         BR    R6                  RETURN TO CALLING RTN\nNONAME1  WTO   '*** FIRST DATA RECORD DOES NOT CONTAIN MEMBER NAME ***'\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE READS A RECORD FROM THE SEQUENTIAL DATASET AND\n*    LOADS THE ADDRESS OF THAT RECORD INTO REGISTER 2.\n***********************************************************************\n*\nGETSEQ   GET   SEQDCB              GET A LREC OF MEMB FROM SEQ DS\n         LR    R2,R1               SAVE ADR OF LREC IN REG2\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE BUILDS A BLOCK OF DATA FOR THE PDS DATASET. IT\n*    CONTINUALLY BRANCHES AND LINKS TO THE GETSEQ SUBROUTINE TO READ A\n*    RECORD OF THE MEMBER FROM THE SEQUENTIAL DATASET UNTIL A WHOLE\n*    BLOCK IS BUILT.\n***********************************************************************\n*\nGETDATA  LA    R10,PDSDCB          SET ADRBLTY FOR PDS DCB DSECT\n         L     R11,BLKRECS         LD NUMB OF LRECS PER BLOCK\n         L     R12,BLKADR          LD ADR OF I/O BLOCK AREA\n         LA    R9,0                CLEAR REG 9 FOR LREC CTR\nNEXTGET  BAL   R7,GETSEQ           GET A LREC OF MEMB FROM SEQ DS\n         CLC   0(2,R2),ID          CHK FOR MEMB NAME ID\n         BE    SETNAME             IF YES, BG OF NEW MEMB, DO STOW\n         MVI   FULBLKSW,C'0'       IND BLOCK NOT WRITTEN YET\n         LA    R9,1(0,R9)          INCR LREC CTR\n         ST    R9,LRECCTR          SAVE LREC CTR\n         MVC   0(80,R12),0(R2)     MOVE LREC INTO BLOCK AREA\n         LA    R12,80(0,R12)       INCR TO NEXT LREC SLOT IN BLOCK\n         BCT   R11,NEXTGET         CHK IF BLOCK FULL\n         MVI   FULBLKSW,C'1'       IF FULL, IND IT\n         BR    R6                  RETURN TO CALLING RTN\nSETNAME  MVC   STOWNAME,SAVENAME   PUT CURR MEMB NAME INTO STOW-LIST\n         MVC   SAVENAME,2(R1)      RESTORE NEXT MEMB NAME\n         B     MEMBEND             BRANCH TO MEMB-END RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE WRITES A PHYSICAL BLOCK INTO THE PDS. THE SIZE OF THE\n*    BLOCK IS SPECIFIED IN THE PDS DCB.\n***********************************************************************\n*\nWRTPDS   L     R12,BLKADR          LD ADR OF I/O BLOCK AREA\n         WRITE WDECB,SF,PDSDCB,(R12)\n         CHECK WDECB               CHECK IF WRITE OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL EACH TIME WHEN ALL THE RECORDS OF A\n*    MEMBER HAVE BEEN READ FROM THE SEQUENTIAL DATASET. THIS ROUTINE\n*    CHECKS IF THE LAST BLOCK IS INCOMPLETE AND IS REQUIRED TO BE\n*    WRITTEN INTO THE PDS. THE PDS DCB BLKSIZE IS SET TO THE SHORT\n*    BLKSIZE BEFORE THE WRITE AND THEN THE DCB BLKSIZE IS RESTORED TO\n*    THE NORMAL BLKSIZE.\n***********************************************************************\n*\nLASTBLK  CLI   FULBLKSW,C'1'       CHK IF LAST BLOCK WRITTEN\n         BER   R6                  IF YES, RETURN\n         LA    R10,PDSDCB          IF NO, SET ADRBLTY FOR PDS DSECT\n         LA    R14,0               CLEAR REG 14 FOR MR INSTR\n         LH    R15,DCBLRECL        LD PDS LRECL\n         L     R12,LRECCTR         LD NUMB OF LRECS IN LAST BLOCK\n         LTR   R12,R12             CHK IF NO LRECS IN LAST BLOCK\n         BZ    NORECS              IF NO LRECS, ERROR\n         MR    R14,R12             CALC HOW MUCH OF BLOCK FULL\n         MVC   SAVBLKSZ,DCBBLKSI   SAVE PDS NORMAL BLKSZ\n         STH   R15,DCBBLKSI        PUT LEN OF LAST BLOCK INTO PDS DCB\n         ST    R6,SAVREG6          SAVE REG 6 FOR BAL INSTR\n         BAL   R6,WRTPDS           WRITE LAST BLOCK OF MEMB\n         L     R6,SAVREGS          RESTORE REG 6 AFTER BAL DONE\n         MVC   DCBBLKSI,SAVBLKSZ   RESTORE NORMAL PDS BLKSZ\n         BR    R6                  RETURN TO CALLING RTN\nNORECS   WTO   '*** NO DATA RECORDS IN SEQDD ***'\n         ABEND 902\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES THE STOW MACRO TO UPDATE THE DIRECTORY OF\n*    THE PDS.\n***********************************************************************\n*\nSTOW     STOW  PDSDCB,STOWLST,A    UPDATE PDS DIR\n         LTR   R15,R15             CHK RC\n         BZR   R6                  IF OK, RET TO CALLING RET\n         C     R15,BIN4            CHK IF DUP MEMB NAME\n         BE    DUPNAME             IF YES, NO UPDT, DSPLY WARN MSG\n         C     R15,BIN12           CHK FOR NO MORE DIR SPC\n         BE    NODIRSPC            NO MORE ROOM IN DIR, DSPLY MSG\n         ...                       CHECK OTHER RETURN CODES\nDUPNAME  MVC   WTO1NAME,STOWNAME   PUT DUPL NAME INTO WTO MSG\n         LA    R1,WTO1LST          LD LIST ADR FOR EXEC-FORM WTO\n         WTO   MF=(E,(R1))         ISSUE EXEC-FORM OF WTO\n         BR    R6                  RETURN TO CALLING RTN\nNODIRSPC WTO   '*** NO MORE DIRECTORY SPACE FOR NEW MEMBER ***',       -\n               ROUTCDE=11\n         ABEND 903\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (SEQDCB,,PDSDCB)    CLOSE ALL DCBS\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nFULBLKSW DC    C'0'\nID       DC    C'$$'\nBIN4     DC    F'4'\nBIN12    DC    F'12'\nBLKADR   DS    F\nBLKRECS  DS    F\nLRECCTR  DC    F'0'\nSAVREG6  DS    F\nSAVENAME DS    CL8\nSAVBLKSZ DS    CL2\n*\n*\n***********************************************************************\n*    THE WTO-LIST\n***********************************************************************\n*\n         CNOP  0,4\nWTO1LST  DC    AL2(WTO1LSTX-WTO1LST)\n         DC    H'0'\n         DC    C'*** SPECIFIED MEMBER NAME: '\nWTO1NAME DS    CL8\n         DC    C' ALREADY EXISTS IN LIBRARY---MEMBER NOT ADDED ***'\nWTO1LSTX EQU   *\n*\n*\n***********************************************************************\n*    THE STOW-LIST\n***********************************************************************\n*\nSTOWLST  DS    0CL12\nSTOWNAME DS    CL8\nSTOWTTR  DS    CL3\nSTOWC    DC    X'00'\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nSEQDCB   DCB   DSORG=PS,MACRF=GL,LRECL=80,RECFM=FB,EODAD=DATAEND,      -\n               DDNAME=SEQDD\nPDSDCB   DCB   DSORG=PO,MACRF=W,LRECL=80,DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         DSECT\n         DCBD  DSORG=PO            GENERATES PO-DCB DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080601": {"ttr": 4622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xbd\\x00\\xbd\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 189, "newlines": 189, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.6.1\n*\n*\nPDSUPDTQ CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING INFMJFCB,R10        DEFINE REG 10 FOR JFCB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,RDJFCB           READ JFCB INTO PROG AREA\nNEXTMEMB BAL   R6,GETNAME          GET NEXT QUAL MEMB NAME FROM DIR\n         BAL   R6,SETMEMB          PUT MEMB NAME INTO JFCB\n         BAL   R6,OPEN             OPEN PDS AND POS TO MEMB NAME\nNEXTREC  BAL   R6,GETMEMB          READ A LREC OF MEMB\n         BAL   R6,UPDTMEMB         UPDATE LREC\n         BAL   R6,PUTMEMB          REWRITE THE LREC\n         B     NEXTREC             GET NEXT LREC OF MEMB\nMEMBEND  BAL   R6,CLOSE            MEMB-END, CLOSE PDS AND UPDATE DIR\n         B     NEXTMEMB            GET NEXT QUAL MEMB\nMEMBENDX BAL   R6,CLOSE            END-OF-MEMBS, CLOSE PDS AND UPT DIR\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCBS AND COPIES THEM FROM THE SWA INTO THE\n*    PROGRAMMER-SUPPLIED AREA.\n***********************************************************************\n*\nRDJFCB   RDJFCB (PDSQDCBI,,PDSQDCBO,(OUTPUT))\n         LTR   R15,R15             CHK IF JCL DD STMT IN JOBSTREAM\n         BNZ   NODDNM              IF NO, ERROR\n         BR    R6                  IF YES, RET TO CALLING RTN\nNODDNM   WTO   '*** JCL DD STATEMENT(S) OMITTED ***',ROUTCDE=11\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE USES THE READDIR MACRO TO OBTAIN THE MEMBER NAME IN\n*    THE NEXT PDS DIRECTORY ENTRY. ALIASES ARE IGNORED.\n***********************************************************************\n*\nGETNAME  READDIR PDSDD             GET NEXT DIR ENTRY\n         LTR   R15,R15             CHECK IF PRIM NAME\n         BZ    CHKNAME             IF YES, CHK IF QUAL NAME\n         C     R15,BIN4            CHECK IF ALIAS\n         BE    GETNAME             IF YES, IGNORE\n         B     MEMBENDX            END-OF-DIR, BRANCH TO E-OF-D RTN\nCHKNAME  BAL   R7,TESTNAME         CHECK IF MEMB NAME OK FOR UPDT\n         LTR   R15,R15             CHECK RC FOR MEMB NAME OK\n         BNZ   GETNAME             IF NO, GET NEXT DIR ENTRY\n         BR    R6                  IF YES, RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE EXAMINES THE NAMES OF THE MEMBERS TO DETERMINE IF\n*    THEY ARE TO BE UPDATED. IT SETS AN RC OF X'00' IN REGISTER 15 IF\n*    THE MEMBER IS TO BE UPDATED AND SETS AN RC OF X'04' IF THE MEMBER\n*    IS NOT TO BE UPDATED.\n***********************************************************************\n*\nTESTNAME CLC   $MEMBER(2),=C'PR'   CHECK IF MEMB NAME ACCEPTABLE\n         BE    NAMEOK              IF YES, IND IT\n         CLC   $MEMBER+4,C'W'      CHECK IF MEMB NAME ACCEPTABLE\n         BE    NAMEOK              IF YES, IND IT\n         LA    R15,4               IND SKIP MEMB NAME\n         BR    R7                  RETURN TO CALLING RTN\nNAMEOK   LA    R15,0               IND MEMB NAME OK\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE MODIFIES THE JFCBS. THE NAME OF THE NEXT PDS MEMBER\n*    TO BE UPDATED IS INSERTED INTO THE PDS-MEMBER-NAME FIELD OF THE\n*    JFCBS ASSOCIATED WITH THE INPUT AND THE OUTPUT DCBS.\n***********************************************************************\n*\nSETMEMB  LA    R10,JFCBI           SET ADRBLTY FOR PDS DCB DSECT\n         MVC   JFCBELNM,$MEMBER    PUT MEMB NAME INTO INPUT JFCB\n         OI    JFCBIND1,JFCPDS     IND MEMB NAME SUPPLIED\n         LA    R10,JFCBO           SET ADRBLTY FOR PDS DCB DSECT\n         MVC   JFCBELNM,$MEMBER    PUT MEMB NAME INTO OUTPUT JFCB\n         OI    JFCBIND1,JFCPDS     IND MEMB NAME SUPPLIED\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE PDS DCBS USING THE INFORMATION IN THE\n*    MODIFIED JFCBS. THE OPEN WILL CAUSE THE NEXT GET TO START READING\n*    FROM THE FIRST LOGICAL RECORD OF THE MEMBER WHOSE NAME IS\n*    SPECIFIED IN THE JFCB OF THE INPUT PDS AND WILL CAUSE THE NEXT PUT\n*    TO START WRITING AFTER THE LAST MEMBER WHOSE NAME IS SPECIFIED IN\n*    THE JFCB OF THE OUTPUT PDS.\n***********************************************************************\n*\nOPEN     OPEN  (PDSQDCBI,,PDSQDCBO,(OUTPUT)),TYPE=J\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A RECORD FROM THE MEMBER WHOSE NAME IS\n*    SPECIFIED IN THE JFCB.\n***********************************************************************\n*\nGETMEMB  GET   PDSQDCBI,RECORD     GET A LREC OF MEMB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE UPDATES THE RECORDS OF THE MEMBER BEING PROCESSED.\n***********************************************************************\n*\nUPDTMEMB ...                       UPDATE RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE REWRITES THE RECORDS OF THE MEMBER WHOSE NAME IS\n*    SPECIFIED IN THE JFCB\n***********************************************************************\n*\nPUTMEMB  PUT   PDSQDCBO,RECORD     REWRITE THE LREC\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS AND IMPLICITLY CAUSES THE STOW\n*    FUNCTION TO UPDATE THE DIRECTORY OF THE OUTPUT PDS.\n***********************************************************************\n*\nCLOSE    CLOSE (PDSQDCBI,,PDSQDCBO)    CLOSE ALL DCBS\n         BR    R6                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nBIN4     DC    F'4'\nRECORD   DS    CL80\n*\n*\n***********************************************************************\n*    THE JFCB-LISTS AND THE DCBS\n***********************************************************************\n*\nJFCBI    DS    44F\nJFCBIPTR DC    X'87'\n         DC    AL3(JFCBI)\nJFCBO    DS    44F\nJFCBOPTR DC    X'87'\n         DC    AL3(JFCBO)\n*\nPDSDCB1I DCB   DSORG=PS,MACRF=GM,EODAD=MEMBEND,EXLST=JFCBIPTR,         -\n               DDNAME=PDSDD\nPDSDCB1O DCB   DSORG=PS,MACRF=PM,EXLST=JFCBOPTR,DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         DSECT\n         IEFJFCBN                  GENERATES THE JFCB DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080602": {"ttr": 4868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xaa\\x00\\xaa\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 170, "newlines": 170, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.6.2\n*\n*\nPDSUPDTB CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN             OPEN DATASETS\nNEXTMEMB BAL   R6,LOCMEMB          LOC SPECIFIED MEMB IN PDS\nNEXTREC  BAL   R6,READMEMB         READ A REC OF MEMB\n         BAL   R6,UPDTMEMB         UPDATE REC\n         BAL   R6,WRTMEMB          REWRITE REC OF MEMB\n         B     NEXTREC             READ NEXT REC OF MEMB\nMEMBEND  BAL   R6,STOW             MEMB-END, UPDATE DIR\n         B     NEXTMEMB            GET NEXT MEMB\nMEMBENDX BAL   R6,CLOSE            END-OF-MEMBS, CLOSE DATASETS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (SYSIN,,PDSBDCBI,,PDSBDCBO,(OUTPUT))\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOCATES THE NEXT MEMBER WHICH IS TO BE PROCESSED. IN\n*    ORDER TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO THE\n*    SUBROUTINES WHICH PERFORM THE FOLLOWING FUNCTIONS:\n*        * READ THE NEXT MEMBER NAME FROM THE SYSIN DATASET;\n*        * SET THE DASD LOCATION IN THE PDS DCB TO THE BEGINNING OF THE\n*          MEMBER WHICH IS TO PROCESSED.\n***********************************************************************\n*\nLOCMEMB  BAL   R7,GETNAME          GET A SPEC MEMB NAME FROM SEQ DS\n         BAL   R7,FIND             SET MEMB ADR IN PDS DCB\n         LTR   R15,R15             CHK IF SPEC MEMB IN PDS\n         BNZ   LOCMEMB             IF NO, GET NEXT SPEC MEMB\n         BR    R6                  IF YES, RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE READS THE NAME OF THE NEXT MEMBER, WHICH IS TO BE\n*    PROCESSED, FROM THE SYSIN DATASET.\n***********************************************************************\n*\nGETNAME  GET   SYSIN,MEMBNAME      GET A SPEC MEMB NAME\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CAUSES THE LOCATION OF THE BEGINNING OF THE\n*    SPECIFIED MEMBER TO BE PLACED INTO THE PDS DCB.\n***********************************************************************\n*\nFIND     FIND  PDSBDCBI,MEMBNAME,D\n         LTR   R15,R15             CHK IF MEMB IN PDS\n         BNZ   NOMEMB              IF NO, PROC CONDITION\n         BR    R7                  RETURN TO CALLING RTN\nNOMEMB   ...                       ISSUE WARN MSG, ETC.\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A RECORD OF THE SPECIFIED MEMBER FROM THE PDS.\n***********************************************************************\n*\nREADMEMB READ  RDECB,SF,PDSBDCBI,BLOCK\n         CHECK RDECB               CHECK IF READ OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE UPDATES THE RECORDS OF THE MEMBERS.\n***********************************************************************\n*\nUPDTMEMB ...                       UPDATE RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE REWRITES THE RECORDS OF THE MEMBERS TO THE PDS.\n***********************************************************************\n*\nWRTMEMB  WRITE WDECB,SF,PDSDCB2O,BLOCK\n         CHECK WDECB               CHECK IF WRITE OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES THE STOW MACRO TO UPDATE THE TTR OF THE\n*    DIRECTORY ENTRY OF THE PDS TO POINT TO THE UPDATED MEMBER.\n***********************************************************************\n*\nSTOW     MVC   STOWNAME,MEMBNAME   PUT MEMB NAME INTO STOW-LIST\n         STOW  PDSBDCBO,STOWLST,R      UPDATE DIR\n         LTR   R15,R15             CHK IF REPLACE OK\n         BZR   R6                  IF YES, RET TO CALLING RTN\n         C     R15,BIN12           CHK FOR NO DIR SPC\n         BE    NODIRSPC            IF YES, DSPLY ERROR MSG\n         ...                       CHECK OTHER RETURN CODES\nNODIRSPC WTO   '*** NO MORE DIRECTORY SPACE FOR NEW MEMBER ***',       -\n               ROUTCDE=11\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (SYSIN,,PDSBDCBI,,PDSBDCBO)\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nBIN12    DC    F'12'\nBLOCK    DS    CL1000\nMEMBNAME DS    CL8\n         DS    CL72\n*\n*\n***********************************************************************\n*    THE STOW-LIST\n***********************************************************************\n*\nSTOWLST  DS    0CL12\nSTOWNAME DS    CL8\nSTOWTTR  DS    CL3\nSTOWC    DC    X'00'\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nSYSIN    DCB   DSORG=PS,MACRF=GM,LRECL=80,RECFM=FB,EODAD=MEMBENDX,     -\n               DDNAME=SYSIN\nPDSBDCBI DCB   DSORG=PO,MACRF=R,EODAD=MEMBEND,DDNAME=PDSDD\nPDSBDCBO DCB   DSORG=PO,MACRF=W,DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080603": {"ttr": 4872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00Z\\x00Z\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.6.3\n*\n*\nPDSUPIPQ CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN             OPEN, POS TO JCL MEMB\nNEXTREC  BAL   R6,GETREC           READ A REC OF MEMB\n         BAL   R6,UPDTREC          UPDATE RECORD\n         BAL   R6,PUTREC           PUT MEMB REC IN-PLACE\n         B     NEXTREC             READ NEXT MEMB REC\nENDRECS  BAL   R6,CLOSE            CLOSE DATASET\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE DCB OF THE PDS AND CAUSES THE NEXT GET TO\n*    START READING FROM THE BEGINNING OF THE MEMBER SPECIFIED IN THE\n*    JCL.\n***********************************************************************\n*\nOPEN     OPEN  (PDSDCB,(UPDAT))\n         ...                       CHECK IF GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A RECORD OF THE MEMBER SPECIFIED IN THE JCL.\n***********************************************************************\n*\nGETREC   GET   PDSDCB              GET LREC IN LOCATE-MODE\n         LR    R2,R1               SAVE LREC ADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE UPDATES THE RECORDS OF THE MEMBER.\n***********************************************************************\n*\nUPDTREC  ...                       UPDATE RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE UPDATES-IN-PLACE THE RECORDS OF THE MEMBER.\n***********************************************************************\n*\nPUTREC   PUTX  PDSDCB              PUT RECORD IN-PLACE\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES DCB OF THE PDS.\n***********************************************************************\n*\nCLOSE    CLOSE PDSDCB              CLOSE DATASET\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE DCB\n***********************************************************************\n*\nPDSDCB   DCB   DSORG=PS,MACRF=(GL,PM),EODAD=ENDRECS,DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080604": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x90\\x00\\x90\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 144, "newlines": 144, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.6.4\n*\n*\nPDSUPIPB CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN             OPEN DATASETS\nNEXTMEMB BAL   R6,LOCMEMB          LOC SPECIFIED MEMB IN PDS\nNEXTREC  BAL   R6,READMEMB         READ A RECORD OF MEMB\n         BAL   R6,UPDTMEMB         UPDATE RECORD\n         BAL   R6,WRTMEMB          WRITE RECORD BACK TO PDS IN-PLACE\n         B     NEXTREC             READ NEXT REC OF MEMB\nMEMBEND  B     NEXTMEMB            MEMB-END, GET NEXT SPEC MEMB\nMEMBENDX BAL   R6,CLOSE            END-OF-MEMBS, CLOSE DATASETS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (SYSIN,,PDSBDCB,(UPDAT))\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOCATES THE NEXT MEMBER WHICH IS TO BE PROCESSED. IN\n*    ORDER TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO THE\n*    SUBROUTINES WHICH PERFORM THE FOLLOWING FUNCTIONS:\n*        * READ THE NEXT MEMBER NAME FROM THE SYSIN DATASET;\n*        * SET THE DASD LOCATION IN THE PDS DCB TO THE BEGINNING OF THE\n*          MEMBER WHICH IS TO BE PROCESSED.\n***********************************************************************\n*\nLOCMEMB  BAL   R7,GETNAME          GET A SPEC MEMB NAME FROM SEQ DS\n         BAL   R7,FIND             SET MEMB ADR IN PDS DCB\n         LTR   R15,R15             CHK IF SPEC MEMB IN PDS\n         BNZ   LOCMEMB             IF NO, GET NEXT SPEC MEMB\n         BR    R6                  IF YES, RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE READS THE NAME OF THE NEXT MEMBER THAT IS TO BE\n*    PROCESSED FROM THE SYSIN DATASET.\n***********************************************************************\n*\nGETNAME  ...                       SAME LOGIC AS IN C.E. 8.6.2\n         BR    R7\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CAUSES THE LOCATION OF THE BEGINNING OF THE\n*    SPECIFIED MEMBER TO BE PLACED INTO THE PDS DCB.\n***********************************************************************\n*\nFIND     ...                       SAME LOGIC AS IN C.E. 8.6.2\n         BR    R7\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A RECORD OF THE SPECIFIED MEMBER OF THE PDS.\n***********************************************************************\n*\nREADMEMB LA    R10,UDECB           LOAD ADR OF READ/WRITE LIST\n         READ  (R10),SF,MF=E       READ REC USING SUPPLIED LIST\n         CHECK (R10)               CHECK IF READ OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE UPDATES THE RECORDS OF THE MEMBERS.\n***********************************************************************\n*\nUPDTMEMB ...                       UPDATE RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE UPDATES-IN-PLACE THE RECORDS OF THE MEMBERS OF THE\n*    PDS.\n***********************************************************************\n*\nWRTMEMB  LA    R10,UDECB           LOAD ADR OF READ/WRITE LIST\n         WRITE (R10),SF,MF=E       WRITE IN-PLACE USING SUPPLIED LIST\n         CHECK (R10)               CHECK IF WRITE OK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (SYSIN,,PDSBDCB)    CLOSE ALL DCBS\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nBLOCK    DS    CL1000\n*\n*\n***********************************************************************\n*    THE LIST-FORM OF THE READ MACRO\n***********************************************************************\n*\nUPDTLST  READ  UDECB,SF,PDSBDCB,BLOCK,MF=L\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nSYSIN    DCB   DSORG=PS,MACRF=GL,LRECL=80,RECFM=FB,EODAD=MEMBENDX,     -\n               DDNAME=SYSIN\nPDSBDCB  DCB   DSORG=PO,MACRF=(R,W),EODAD=MEMBEND,DDNAME=PDSDD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080701": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.7.1\n*\n*\n         OPEN (PDSBDCB,(OUTPUT))\n         ...\n         STOW PDSBDCB,MEMBNAME,D   UPDATE DIRECTORY (DELETE MEMB)\n         ...                       CHECK RETURN CODE\nMEMBNAME DS   CL8\nPDSBDCB  DCB  DSORG=PO,...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080702": {"ttr": 4881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.7.2\n*\n*\n         OPEN  (PDSBDCB,(OUTPUT))\n         ...\n         MVC   STOWNAME,MEMBNAME   PUT EXISTING MEMB NAME INTO\n*                                  STOW-LIST\n         MVC   STOWNEWN,NEWNAME    PUT NEW MEMB NAME INTO STOW-LIST\n         STOW  PDSBDCB,STOWLST,C   UPDATE DIRECTORY (RENAME MEMB)\n         ...                       CHECK RETURN CODE\nSTOWLST  DS    0CL16\nSTOWNAME DS    CL8\nSTOWNEWN DS    CL8\n*\nMEMBNAME DS    CL8\nNEWNAME  DS    CL8\n*\nPDSBDCB  DCB   DSORG=PO,...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080703": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.7.3\n*\n*\n         OPEN  (PDSBDCB,(OUTPUT))\n         ...\n         MVC   BLDLNAME,MEMBNAME   PUT EXISTING MEMB NAME INTO\n*                                  BLDL-LIST\n         BLDL  PDSBDCB,BLDLLST     OBTAIN TTRC OF MEMB\n         ...\n         MVC   STOWNAME,ALIASNAM   PUT ALIAS NAME INTO STOW-LIST\n         MVC   STOWTTR,BLDLTTR     PUT LOC OF MEMB INTO STOW-LIST\n         STOW  PDSBDCB,STOWLST,A   UPDATE DIRECTORY (ADD ALIAS)\n         ...                       CHECK RETURN CODE\n*\nBLDLLST  DS    0CL16\nBLDLFFLL DC    X'0001',X'000C'     NUMB OF ENTRIES, MAX ENTRY LEN\nBLDLNAME DS    CL8\nBLDLTTR  DS    CL3\nBLDLK    DS    CL1\n*\nSTOWLST  DS    0CL12\nSTOWNAME DS    CL8\nSTOWTTR  DS    CL3\nSTOWC    DC    X'80'               HIGH ORDER BIT ON TO IND ALIAS\n*\nMEMBNAME DS    CL8\nALIASNAM DS    CL8\n*\nPDSBDCB  DCB   DSORG=PO,...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080704": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.7.4\n*\n*\n         OPEN  (PDSBDCB,(OUTPUT))\n         ...                                  WRITE NEW MEMB RECORDS\n         ...                                  INTO PDS\n         MVC   STOWNAME,MEMBNAME              PUT NEW MEMBER NAME INTO\n*                                             STOW-LIST\n         MVC   STOWUSER(L'USERDATA),USERDATA  MOVE USER DATA INTO\n*                                             STOW-LIST\n         MVC   STOWC,USERLEN                  INDICATE USERDATA LENGTH\n         STOW  PDSBDCB,STOWLST,A              UPDATE DIRECTORY\n         ...                                  CHECK RETURN CODE\nSTOWLST  DS    0CL74\nSTOWNAME DS    CL8\nSTOWTTR  DS    CL3\nSTOWC    DS    CL1\nSTOWUSER DS    CL62\n*\nMEMBNAME DS    CL8\nUSERDATA DC    CL40'...'           USERDATA FOR DIR ENTRY\nUSERLEN  DC    AL1(L'USERDATA/2)   LEN OF USERDATA IN HALFWORDS\n*\nPSDBDCB  DCB   DSORG=PO,...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE080705": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x009\\x009\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.7.5\n*\n*\n         OPEN  (PDSBDCB,(OUTPUT))\n         ...\n         MVC   BLDLNAME,MEMBNAME   PUT EXISTING MEMB NAME INTO\n*                                  BLDL-LIST\n         BLDL  PDSBDCB,BLDLLST     OBTAIN USERDATA OF MEMB\n         ...\n         MVC   USERDATA(USRLEN),BLDLUSER   EXTRACT CUR USERDATA\n         MVC   USERFLD1,UPDFLD1    UPDATE FLD-1 OF CUR USERDATA\n         MVC   USERFLD4,UPDFLD4    UPDATE FLD-4 OF CUR USERDATA\n         MVC   USERFLD5,NEWFLD5    INSERT FLD-5 INTO USERDATA\n         ...\n         BAL   R6,REWRITE          REWRITE MEMBER\n         ...\n         MVC   STOWNAME,MEMBNAME   PUT MEMB NAME INTO STOW-LIST\n         MVC   STOWC,BLDLC         PUT EXISTING C FIELD INTO STOW-LIST\n         NI    STOWC,X'E0'         ZERO OUT OLD LEN BITS\n         O     STOWC,USRLENHW      INSERT NEW LEN BITS\n         MVC   STOWUSER(L'USERDATA),USERDATA  MOVE NEW USERDATA\n         STOW  PDSBDCB,STOWLST,R   UPDATE DIRECTORY (REPLACE USERDATA)\n         ...\nBLDLLST  DS    0CL80\nBLDLFFLL DC    X'0001',X'004C'     NUMB ENTRIES, MAX ENTRY LEN\nBLDLNAME DS    CL8\nBLDLTTR  DS    CL3\nBLDLK    DS    CL1\nBLDLZ    DS    CL1\nBLDLC    DS    CL1\nBLDLUSER DS    CL62\n*\nSTOWLST  DS    0CL74\nSTOWNAME DS    CL8\nSTOWTTR  DS    CL3\nSTOWC    DS    CL1\nSTOWUSER DS    CL62\n*\nMEMBNAME DS    CL8\n*\nUSERDATA EQU   *\nUSERFLD1 DS    CL3                 EXISTING FIELD\nUSERFLD2 DS    CL4                 EXISTING FIELD\nUSERFLD3 DS    CL4                 EXISTING FIELD\nUSERFLD4 DS    CL5                 EXISTING FIELD\nUSERFLD5 DS    CL8                 NEW FIELD\nUSERFLDX EQU   *\n*\nUSRLEN   EQU   USERFLDX-USERDATA             LEN OF USERDATA IN BYTES\nUSRLENHW DC    AL1(USRLEN/2)                 LEN OF USERDATA IN HWDS\n*\nUPDFLD1  DC    CL3'...'\nUPDFLD4  DC    CL5'...'\nNEWFLD5  DC    CL8'...'\n*\nPSDBDCB  DCB   DSORG=PO,...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE090301": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 9.3.1\n*\n*\n         BAL   R6,GETMAIN1         GET A PAGE OF STORAGE\n         ...\n         BAL   R6,RLSEVS1          RELEASE THE PAGE OF STORAGE\n         ...\nGETMAIN1 GETMAIN EC,LV=4096,BNDRY=PAGE,A=PGADR\n         ...\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nRLSEVS1  L     R10,PGADR           LOAD ADR OF VS AREA TO BE RELEASED\n         LA    R11,4095(0,R10)     INCR TO LAST ADR OF THE VS AREA\n         LA    R11,1(0,R11)        INCR TO 1 BYTE PAST VS AREA TO BE\n*                                  RELEASED\n         PGRLSE LA=(R10),HA=(R11)\n         ...\n         BR    R6                  RETURN TO CALLING RTN\n         ...\nPGADR    DS    F\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE090302": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x06\\x00\\x06\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 9.3.2\n*\n*\n         PGLOAD R,A=(R10),ECB=PGECB\n         WAIT  1,ECB=PGECB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE090303": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 9.3.3\n*\n*\nLOADPGS  PGLOAD R,A=(R10),EA=(R11),ECB=PGECB,RELEASE=Y\n         BR    R6\n         ...\nCHKPGLD  TM    PGECB,X'40'         CHECK IF PGLOAD COMPLETE\n         BO    CHKCC               IF YES, CHK COMP CODE\n         BAL   R7,DOWORK           IF NO, DO OTHER WORK\n         B     CHKPGLD             CHECK AGAIN IF PGLOAD COMPLETE\nCHKCC    CLC   PGECB+1(3),BINZEROS CHECK COMP CODE\n         BER   R6                  IF OK, RETURN TO CALLER\n         ABEND ...                 PGLOAD FAILED\n         ...\nPGECB    DC    F'0'\nBINZEROS DC    F'0'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE090304": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 9.3.4\n*\n*\n         PGOUT R,A=(R10),EA=(R11)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100101": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.1.1\n*\n*\n//LKED         EXEC ASMFCL,PARM.LKED='AC=1,...'\n//LKED.SYSLMOD DD   DSN=USER.AUTHLIB(pgm-name),DISP=SHR\n//\n\n              or\n\n//L            EXEC ASMHCL,PARM.L='...'\n//L.SYSLMOD    DD   DSN=USER.AUTHLIB,DISP=SHR\n//L.SYSIN      DD   *\n  SETCODE AC(1)\n  NAME pgm-name\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE100201": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.2.1\n*\n*\n        MODESET MODE=SUP,KEY=ZERO\n\n        MODESET MODE=PROB,KEY=NZERO\n\n        MODESET MODE=SUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100301": {"ttr": 5139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.3.1\n*\n*\n         TESTAUTH FCTN=1,STATE=YES,KEY=YES\n         LTR   R15,R15\n         BZ    AUTH\n         B     NOAUTH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100302": {"ttr": 5141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.3.2\n*\n*\n         TESTAUTH STATE=YES\n         LTR   R15,R15\n         BZ    CHKKEY\n         B     NOAUTH\nCHKKEY   TESTAUTH KEY=YES\n         LTR   R15,R15\n         BZ    AUTH\n         B     NOAUTH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100401": {"ttr": 5143, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.4.1\n*\n*\n         PGFIX  R,A=(R10)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100402": {"ttr": 5145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.4.2\n*\n*\nFIXPGS   PGFIX R,A=(R10),EA=(R11),ECB=PGFXECB\n         BR    R6\n         ...\nCHKPGFX  TM    PGFXECB,X'40'       CHECK IF PGFIX COMPLETE\n         BO    CHKCC               IF YES, CHK COMP CODE\n         BAL   R7,DOWORK           IF NO, DO OTHER WORK\n         B     CHKPGFX             CHECK AGAIN IF PGFIX COMPLETE\nCHKCC    CLC   PGFXECB+1(3),BINZEROS     CHECK COMP CODE\n         BER   R6                  IF OK, RETURN TO CALLER\n         ABEND ...                 PGFIX FAILED\n         ...\nDOWORK   ...                       OTHER PROCESSING\n         BR    R7                  RETURN TO CALLING ROUTINE\n         ...\nPGFXECB  DC    F'0'\nBINZEROS DC    F'0'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100403": {"ttr": 5147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.4.3\n*\n*\n         PGFREE R,A=(R10),EA=(R11)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100501": {"ttr": 5149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00v\\x00v\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.5.1\n*\n*\n           USING JFCB,R10             DEFINE REG FOR JFCB DSECT\n           ...\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n           ...\n           BAL   R6,RDJFCB            READ JFCB INTO PROG AREA\n           BAL   R6,GETDSNM           GET SPECIFIED DATASET NAME\n           BAL   R6,GETTIOT           GET TIOT ADR\n           BAL   R6,GETUCB            GET UCB ADR FOR RESERVE\n           BAL   R6,RESERVE           ISSUE RESERVE\n           ...\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE JFCB AND COPIES IT FROM THE SWA INTO THE\n*    PROGRAMMER-SUPPLIED AREA.\n***********************************************************************\n*\nRDJFCB     RDJFCB (DCB01,(OUTPUT))\n           LTR   R15,R15              CHK IF DD STMT IN JCL\n           BNZ   NODDNM               IF NO, ERROR\n           BR    R6                   IF YES, RET TO CALLING RTN\nNODDNM1    WTO   '*** DDNAME \"LIBDD\" NOT IN SPECIFIED IN JCL ***',     -\n                 ROUTCDE=11\n           ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE GETS THE SPECIFIED DATASET NAME FROM THE JFCB. THE\n*    DATASET IS USED AS THE RNAME FOR THE RESERVE MACRO.\n***********************************************************************\n*\nGETDSNM    LA    R10,JFCB             SET ADRBLTY FOR JFCB DSECT\n           MVC   DSNAME,JFCBDSNM      EXTRACT SPEC DSNAME FROM JFCB\n           BR    R6                   RETURN TO CALLIN RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE GETS THE TIOT ADDRESS WHICH IS USED TO OBTAIN THE\n*    UCB ADDRESS.\n***********************************************************************\n*\nGETTIOT    EXTRACT TIOTADR,FIELDS=TIOT    GET TIOT ADR\n           BR    R6                       RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE GETS THE UCB ADDRESS BY SCANNING THE TIOT FOR THE\n*    DDNAME LIBDD. THE TIOT ENTRY FOR THAT DDNAME CONTAINS THE REQUIRED\n*    UCB ADDRESS.\n***********************************************************************\n*\nGETUCB     L     R10,TIOTADR          LOAD ADR OF TIOT\n           LA    R10,24(0,R10)        INCR PASS JOBNAME/STEPNAMES\n*                                     TO FIRST TIOT DDNAME ENTRY\n           LA    R11,0                CLEAR REG 11 FOR IC INSTR\nNEXTDDNM   CLC   0(4,R10),BINZEROS    CHECK FOR END OF TIOT\n           BE    NODDNM               IF END, DDNAME NOT FOUND\n           CLC   4(8,R10),DDNAME      CHK FOR DDNAME\n           BE    MVUCBADR             IF FOUND, GET UCB ADDRESS\n           IC    R11,0(0,R10)         STORE TIOT DDNAME ENTRY LEN\n           LA    R10,0(R11,R10)       INCR TO NEXT TIOT DDNAME ENTRY\n           B     NEXTDDNM             CHK NEXT DDN IN TIOT\nMVUCBADR   MVC   UCBADR,16(R10)       GET UCB ADR FROM TIOT DDN ENTRY\n           BR    R6                   RETURN TO CALLING RTN\nNODDNM2    WTO   '*** DDNAME \"LIBDD\" NOT IN SPECIFIED IN JCL ***',     -\n                 ROUTCDE=11\n           ABEND 902\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES THE RESERVE MACRO FOR THE UCB ALLOCATED BY THE\n*    JCL DD STATEMENT WITH THE DDNAME LIBDD AND USES THE SPECIFIED\n*    DATASET NAME AS THE RNAME.\n***********************************************************************\n*\nRESERVE    MVC   RNAME,DSNAME         USE DSNAME AS RNAME FOR RESERVE\n           RESERVE (QNAME,RNAME,E,,SYSTEMS),UCB=UCBADR\n           LTR   R15,R15              CHK IF RESERVE OK\n           BNZ   RSRVBAD              IF RC NOT 0, ERROR\n           BR    R6                   RETURN TO CALLING RTN\nRSRVBAD    WTO   '*** RESERVE ERROR ***',ROUTCDE=11\n           ABEND 903\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nBINZEROS   DC    F'0'\nDSNAME     DS    CL44\nDDNAME     DC    CL8'LIBDD'\nTIOTADR    DS    F\nUCBADR     DS    F\nQNAME      DC    CL8'USER'\nRNAME      DS    CL44\n*\n*\n***********************************************************************\n*    THE JFCB-LIST AND THE DCBS\n***********************************************************************\n*\nJFCB       DS    44F\nJFCBPTR    DC    X'87'\n           DC    AL3(JFCB)\n*\nDCB01      DCB   DSORG=PS,MACRF=PM,EXLST=JFCBPTR,DDNAME=LIBDD\n*\n*\n           ...\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE100601": {"ttr": 5152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.6.1\n*\n*\n         SETLOCK OBTAIN,TYPE=DISP,MODE=COND,REGS=USE\n         LTR   R15,R15\n         ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100602": {"ttr": 5154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.6.2\n*\n*\n         SETLOCK RELEASE,TYPE=SPIN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100701": {"ttr": 5156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.7.1\n*\n*\n         ENQ   (QNAME,RNAME,E,,SYSTEM)\n         SVCUPDTE 250,REPLACE,TYPE=3,EPNAME=IGC0025A\n         DEQ   (QNAME,RNAME,,SYSTEM)\n         ...\nQNAME    DC    CL8'SYSZSVC'\nRNAME    DC    C'TABLE'\n         ...\n         CVT   DSECT=YES\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100801": {"ttr": 5158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.8.1\n*\n*\n         SYSEVENT DONTSWAP         MAKE NON-SWAPABLE\n         ...\n         SYSEVENT OKSWAP           TELL SRM OK TO SWAP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE100802": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 10.8.2\n*\n*\n         LA    R1,SWAPECB\n         SYSEVENT TRANSWAP\n         LTR   R15,R15\n         BNZ   SWAPFAIL\n         WAIT  1,ECB=SWAPECB\n         ...\nSWAPFAIL DS    0H\n         ...\nSWAPECB  DC    F'0'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE110301": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01S\\x01S\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 339, "newlines": 339, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 11.3.1\n*\n*\nREADDASD CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,4,EQU=R           INITIALIZE PROGRAM\n         USING DEBBASIC,R10        DEFINE REG FOR BASIC-DEB DSECT\n         USING IHADCB,R11          DEFINE REG FOR DCB DSECT\n         USING IOBSTDRD,R12        DEFINE REG FOR IOB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETDSCTS         LOAD DSECT REGS\n         BAL   R6,SETIOB           SET REQUIRED IOB FIELDS\n         BAL   R6,GTRKINFO         GET CYL AND TRK CAPAC INFO\n         BAL   R6,OPEN             OPEN DCBS\n         BAL   R6,GET1EXTN         GET 1ST EXTENT OF DATASET\nNEXTREC  BAL   R6,READREC          READ A PHYSICAL RECORD\n         BAL   R6,PRINTREC         PRINT FIRST 10 BYTES OF RECORD\n         B     NEXTREC             READ NEXT RECORD\nENDDATA  BAL   R6,CLOSE            END-OF-DATA, CLOSE DCBS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE REGISTERS FOR THE DCB AND THE IOB DSECTS.\n***********************************************************************\n*\nSETDSCTS LA    R11,READDCB         LOAD DCB ADR FOR DSECT ADRBLTY\n         LA    R12,READIOB         LOAD IOB ADR FOR DSECT ADRBLTY\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS THE REQUIRED FIELDS OF THE IOB.\n***********************************************************************\n*\nSETIOB   MVI   IOBFLAG1,X'42'      IND CCW-CHAINING, NOT RELATED\n         MVC   IOBSTART,CCWADR     LOAD BG ADR OF CCW-LIST\n         MVC   IOBDCBPT,DCBADR     LOAD DCB ADR\n         MVC   IOBECBPT,ECBADR     LOAD ECB ADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE USES THE DEVTYPE MACRO TO OBTAIN THE NUMBER OF TRACKS\n*    PER CYLINDER FOR THE DASD DEVICE WHICH CONTAINS THE DATASET WHICH\n*    IS TO BE READ.\n***********************************************************************\n*\nGTRKINFO MVC   DDNAME,DCBDDNAM     EXTRACT DDNAME FROM DCB\n         DEVTYPE DDNAME,DEVTAREA,DEVTAB\n         LH    R10,CYLTRKS         LD NUMB OF TRKS PER CYL\n         BCTR  R10,0               DECR TO GET HI-TRK ADR (REL TO 0)\n         STH   R10,HITRKADR        SAVE HI-TRK ADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (READDCB,,SYSPRINT,(OUTPUT))\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE FIRST EXTENT FIELD IN THE\n*    DEB AND THEN BRANCHES AND LINKS TO THE GETNXEXT SUBROUTINE WHICH\n*    EXTRACTS THE BEGINNING CCHH OF THE EXTENT.\n***********************************************************************\n*\nGET1EXTN L     R10,DCBDEBAD        LD DEB ADR FOR DSECT ADRBLTY\n         MVC   TOTEXTN,DEBNMEXT    EXTRACT TOTAL NUMB OF EXTENTS\n         DROP  R10                 DROP REG FOR BASIC-DEB DSECT\n         USING DEBDASD,R10         DEFINE SAME REG FOR DASD-DEB DSECT\n         LA    R10,32(0,R10)       INCR TO BG OF EXTENTS AREA IN DEB\n         ST    R10,EXTNADR         SAVE 1ST EXTENT ADR FOR GETNXEXT RTN\n         XC    EXTNCTR,EXTNCTR     INIT EXTENT CTR TO ZERO\n         BAL   R8,GETNXEXT         GET CC AND HH OF 1ST EXTENT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE EXTRACTS THE BEGINNING CCHH OF THE NEXT EXTENT FOR\n*    THE CALLING ROUTINE. IT ALSO CHECKS FOR LAST-EXTENT, INCREMENTS\n*    TO THE NEXT EXTENT FIELD IN THE DEB AND SAVES THE EXTENT FIELD\n*    ADDRESS IN THE FULLWORD EXTNADR. THIS SUBROUTINE RECEIVES THE\n*    ADDRESS OF THE FIRST EXTENT FIELD IN THE DEB FROM THE ROUTINE\n*    GET1EXTN.\n***********************************************************************\n*\nGETNXEXT IC    R10,EXTNCTR         LD PREV EXTENT NUMB\n         LA    R10,1(0,R10)        INCR TO IND THIS EXTENT\n         STC   R10,EXTNCTR         SAVE THIS EXTENT NUMB\n         CLC   EXTNCTR,TOTEXTN     COMP THIS EXT NUMB TO TOT EXTENTS\n         BH    ENDDATA             IF HIGH, IND END-OF-DATA\n         L     R10,EXTNADR         LD ADR OF NEXT EXTENT FIELD IN DEB\n         MVC   CC,DEBSTRCC         PUT CC OF NEXT EXTENT INTO RECPTR\n         MVC   HH,DEBSTRHH         PUT HH OF NEXT EXTENT INTO RECPTR\n         LA    R10,16(0,R10)       INCR TO NEXT EXTENT FIELD IN DEB\n         ST    R10,EXTNADR         SAVE ADR OF NEXT ENTENT FIELD\n         BR    R8                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE NEXT PHYSICAL RECORD FROM THE DASD DATASET.\n*    IN ORDER TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO\n*    THE SUBROUTINES WHICH PERFORM THE FOLLOWING FUNCTIONS:\n*      * INCREMENT THE RECORD POINTER TO POINT TO THE NEXT RECORD WHICH\n*        IS TO BE READ;\n*      * ISSUE THE EXCP MACRO TO READ THE NEXT PHYSICAL RECORD OF THE\n*        DASD DATASET.\n***********************************************************************\n*\nREADREC  BAL   R7,SETRCPTR         SET CCHHR OF NEXT RECORD\n         BAL   R7,DOEXCP           ISSUE EXCP TO READ RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE INCREMENTS THE RECORD POINTER TO POINT TO THE NEXT\n*    RECORD WHICH IS TO BE READ AND MOVES THE NEW RECORD POINTER INTO\n*    THE IOB.\n***********************************************************************\n*\nSETRCPTR IC    R10,R               LOAD PREV REC NUMB\n         LA    R10,1(0,R10)        INCR REC NUMB TO NEXT RECORD\n         STC   R10,R               SAVE NEXT REC NUMB\n         MVC   IOBSEEK,RECPTR      MOVE NEW MBBCCHHR INTO IOB\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES THE EXCP MACRO TO READ THE PHYSICAL RECORD\n*    OF THE DASD DATASET POINTED TO BY RECPTR, CHECKS THE ECB\n*    COMPLETION CODE AND PERFORMS THE APPROPRIATE ACTION INDICATED BY\n*    THE COMPLETION CODE.\n***********************************************************************\n*\nDOEXCP   XC    READECB,READECB     CLEAR ECB FOR EXCP MACRO\n         EXCP  READIOB             ISSUE EXCP\n         WAIT  1,ECB=READECB       WAIT FOR I/O COMPLETION\n         TM    READECB,X'7F'       CHK FOR GOOD I/O\n         BNO   CHKECB              IF NO, EXAM ECB\n         BR    R7                  IF I/O GOOD, RET TO CALLING RTN\n*\nCHKECB   TM    READECB,X'41'       CHK FOR EXCEPTION COND\n         BO    CHKERR41            IF YES, EXAM ADDITIONAL INFO\n         TM    READECB,X'42'       CHK FOR END-OF-EXTENT\n         BO    SETNXEXT            IF YES, SET RECPTR FOR NEXT EXTENT\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\n*\nCHKERR41 TM    IOBUSTAT,X'01'      CHK IF END-OF-DATA IND SET\n         BO    ENDDATA             IF YES, GO TO END-OF-DATA RTN\n         TM    IOBSENS1,X'08'      CHK IF END-OF-TRACK IND SET\n         BO    SETNXTRK            IF YES, SET RECPTR FOR NEXT TRACK\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\n*\nSETNXTRK MVI   SECTOR,X'00'        RESET SECTOR NUMB FOR BG OF TRACK\n         MVI   R,X'01'             SET REC NUMB TO 1ST REC ON TRACK\n         LA    R10,0               CLEAR R10 FOR INCR TRK NUMB\n         LH    R10,HH              LD CUR TRK NUMB\n         LA    R10,1(0,R10)        INCR TRK NUMB\n         STH   R10,HH              PUT NEW TRK NUMB INTO RECPTR\n         BAL   R8,CHKNXTRK         VAL TRK NUMB, INCR CYL NUMB IF NEC\n         MVC   IOBSEEK,RECPTR      PUT NEW RECPTR INTO IOB\n         B     DOEXCP              RE-ISSUE EXCP MACRO\n*\nSETNXEXT MVI   SECTOR,X'00'        SET SECTOR TO ZERO (BG OF TRK)\n         MVI   R,X'01'             SET REC NUMB TO 1ST REC TO READ\n         IC    R10,M               LOAD CUR EXTENT NUMB\n         LA    R10,1(0,R10)        INCR EXTENT NUMB\n         STC   R10,M               PUT NEW EXTENT NUMB INTO RECPTR\n         BAL   R8,GETNXEXT         GET CCHH OF NEXT EXTENT\n         MVC   IOBSEEK,RECPTR      PUT NEW MBBCCHHR INTO IOB\n         B     DOEXCP              RE-ISSUE EXCP MACRO\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE VALIDATES THE NEW TRACK NUMBER AFTER THE TRACK\n*    NUMBER IS INCREMENTED TO DETERMINE IF IT EXCEEDS THE HI-TRACK\n*    ADDRESS OF A CYLINDER. IF IT DOES, THEN THE CYLINDER NUMBER IS\n*    INCREMENTED AND THE TRACK NUMBER IS SET TO ZERO.\n***********************************************************************\n*\nCHKNXTRK CLC   HH,HITRKADR         COMP NEW TRK NUMB TO HI-TRK ADR\n         BH    SETNXCYL            IF HIGH, INCR CYL NUMB\n         BR    R8                  IF NOT HIGH, RET TO CALLING RTN\nSETNXCYL XC    HH,HH               SET TRK NUMB TO ZERO (BG OF CYL)\n         LA    R10,0               CLEAR R10 FOR INCR CYL NUMB\n         LH    R10,CC              LD CUR CYL NUMB\n         LA    R10,1(0,R10)        INCR CYL NUMB\n         STH   R10,CC              PUT NEW CYL NUMB INTO RECPTR\n         BR    R8                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PRINTS THE FIRST 10 BYTES OF EACH RECORD READ.\n***********************************************************************\n*\nPRINTREC MVC   LINE+1(10),RECORD   MOVE 1ST 10 BYTES OF REC\n         PUT   SYSPRINT,LINE       PRINT 1ST 10 BYTES TO VERIFY READ\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF THE ATTEMPTED I/O IS\n*    UNSUCCESSFUL. THIS ROUTINE LOADs VARIOUS DIAGNOSTIC INFORMATION\n*    INTO REGISTERS 8, 9, 10, AND 11, AND THEN CAUSES AN ABEND WITH A\n*    DUMP.\n***********************************************************************\n*\nEXCPERR  L     R8,READECB          LOAD CONTENTS OF ECB INTO A REG\n         MVC   ERRINFO(1),EXTNCTR       EXTENT NUMBER\n         MVC   ERRINFO+1(1),IOBUSTAT    UNIT STATUS FIELD OF CSW\n         MVC   ERRINFO+2(1),IOBSENS0    BYTE-1 OF HARDWARE SENSE CODE\n         MVC   ERRINFO+3(1),IOBSENS1    BYTE-2 OF HARDWARE SENSE CODE\n         L     R9,ERRINFO          LOAD ERROR INFO WORD INTO A REG\n         L     R10,RECPTR          LOAD 1ST 4 BYTES OF RECORD PTR\n         L     R11,RECPTR+4        LOAD 2ND 4 BYTES OF RECORD PTR\n         L     R12,ERRID           LOAD ID TO FIND REGS IN DUMP\n         ABEND 900,DUMP            ISSUE ABEND MACRO WITH DUMP REQ\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (READDCB,,SYSPRINT)   CLOSE ALL DCBS\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS LIST REQUIRED FOR THE DEVTYPE MACRO.\n***********************************************************************\n*\nDEVTAREA DS    0CL24\n         DS    CL8\n         DS    CL2\nCYLTRKS  DS    CL2                 NUMBER OF TRACKS PER CYLINDER\n         DS    CL12\n*\n*\n***********************************************************************\n*    THIS AREA MAPS OUT THE RECORD-POINTER FOR THE NEXT RECORD WHICH IS\n*    TO BE READ.\n***********************************************************************\n*\n         DS    0F                  FOR ALIGNMENT FOR EXCPERR ROUTINE\nRECPTR   DS    0CL8\nM        DS    X'00'               EXTENT NUMBER (STARTING WITH 0)\nBB       DS    XL2'00'             BIN NUMBER (NO LONGER USED)\nCCHHR    DS    0CL5\nCCHH     DS    0CL4\nCC       DS    CL2                 CYLINDER NUMBER\nHH       DS    CL2                 HEAD (TRACK) NUMBER\nR        DC    X'00'               RECORD NUMBER\n*\n*\n***********************************************************************\n*    THE CCW-LIST, IOB AND ECB\n***********************************************************************\n*\nREADCCWS CCW   X'23',SECTOR,X'40',1      SET SECTOR CCW\nSEARCH   CCW   X'31',CCHHR,X'60',5       SEARCH ID EQUAL CCW\n         CCW   X'08',SEARCH,X'00',0      TIC CCW\n         CCW   X'06',RECORD,X'60',244    READ DATA CCW (SILI-BIT ON)\n         CCW   X'22',SECTOR,X'00',1      READ SECTOR CCW\n*\nREADIOB  DC    10F'0'                    AREA FOR IOB\nREADECB  DC    F'0'                      FULLWORD FOR ECB\n*\n*\n***********************************************************************\n*    OTHER DC/DS STATEMENTS\n***********************************************************************\n*\nSECTOR   DC    X'00'\nDDNAME   DS    CL8\nHITRKADR DS    H\nTOTEXTN  DS    CL1\nEXTNCTR  DS    CL1\nEXTNADR  DS    F\nRECORD   DS    CL244\nLINE     DC    CL133' '\nERRINFO  DS    F\nERRID    DC    4XL1'FF'\n*\nCCWADR   DC    A(READCCWS)\nDCBADR   DC    A(READDCB)\nECBADR   DC    A(READECB)\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nREADDCB  DCB   MACRF=E,DDNAME=TESTDATA\nSYSPRINT DCB   DSORG=PS,MACRF=PM,BLKSIZE=1330,LRECL=133,RECFM=FB,      -\n               DDNAME=SYSPRINT\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         DCBD  DSORG=XE            GENERATES EXCP-DCB DSECT\n         IEZDEB                    GENERATES DEB DSECT\n         IEZIOB                    GENERATES IOB DSECT\n         ORG   IOBCSTAT+1          POS TO RESIDUAL COUNT FIELD OF CSW\nIOBCSWCT DS    CL2                 PROVIDE LABEL FOR RES CT FIELD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n*\n         END\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE110302": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\xd7\\x01\\xd7\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 471, "newlines": 471, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 11.3.2\n*\n*\nWRTDASD  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING DEBBASIC,R9         DEFINE REG FOR BASIC-DEB DSECT\n         USING DEBDASD,R10         DEFINE REG FOR DASD-DEB DSECT\n         USING IHADCB,R11          DEFINE REG FOR DCB DSECT\n         USING IOBSTDRD,R12        DEFINE REG FOR IOB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETDSCTS         LOAD DSECT REGS\n         BAL   R6,SETIOB           SET REQUIRED IOB FIELDS\n         BAL   R6,GTRKINFO         GET CYL/TRK CAPAC INFO\n         BAL   R6,OPEN             OPEN DCBS\n         BAL   R6,GET1EXTN         GET 1ST EXTENT OF DATASET\nNEXTREC  BAL   R6,GETREC           READ A CARD-IMAGE RECORD\n         BAL   R6,WRTREC           WRITE THE RECORD TO DASD\n         B     NEXTREC             READ NEXT RECORD\nENDDATA  BAL   R6,WRTEND           END-OF-DATA, WRITE ZERO-CT REC\n         BAL   R6,CLOSE            CLOSE DCBS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE REGISTERS FOR THE DCB AND THE IOB DSECTS.\n***********************************************************************\n*\nSETDSCTS LA    R11,WRTDCB          LOAD DCB ADR FOR DSECT ADRBLTY\n         LA    R12,WRTIOB          LOAD IOB ADR FOR DSECT ADRBLTY\n         BR    R6                  RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS THE REQUIRED FIELDS OF THE IOB\n***********************************************************************\n*\nSETIOB   MVI   IOBFLAG1,X'42'      IND CCW-CHAINING, NOT RELATED\n         MVC   IOBSTART,CCWADR     LOAD BG ADR OF CCW-LIST\n         MVC   IOBDCBPT,DCBADR     LOAD DCB ADR\n         MVC   IOBECBPT,ECBADR     LOAD ECB ADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE USES THE DEVTYPE MACRO TO OBTAIN THE NUMBER OF TRACKS\n*    PER CYLINDER AND THE TRACK CAPACITY FOR THE DASD DEVICE WHICH IS\n*    TO CONTAIN THE DATASET WHICH IS TO BE WRITTEN; AND USES THE\n*    TRKCALC MACRO TO DETERMINE THE NUMBER OF 80-BYTE RECORDS WHICH CAN\n*    BE WRITTEN ON A TRACK OF THE SAME DEVICE TYPE.\n***********************************************************************\n*\nGTRKINFO MVC   DDNAME,DCBDDNAM     EXTRACT DDNAME FROM DCB\n         DEVTYPE DDNAME,DEVTAREA,DEVTAB\n         LH    R10,CYLTRKS         LD NUMB OF TRKS PER CYL\n         BCTR  R10,0               DECR TO GET HI-TRK ADR\n         STH   R10,HITRKADR        SAVE HI-TRK ADR (REL TO 0)\n         MVC   TRKBAL,TRKSIZE      SAVE TRK CAPAC\n         TRKCALC FUNCTN=TRKCAP,TYPE=UCBTBYT4,RKDD=RKDD,REGSAVE=YES\n         STC   R0,TRKRECS          SAVE NUMB OF 80-BYTE RECS/TRK\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n**************************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n**************************************************************************\n*\nOPEN     OPEN  (INRECS,,WRTDCB,(OUTPUT))\n         BR    R6                  RETURN TO CALLIN RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE FIRST EXTENT FIELD IN THE\n*    DEB AND THEN BRANCHES AND LINKS TO THE GETNXEXT SUBROUTINE WHICH\n*    EXTRACTS THE BEGINNING CCHH OF THE EXTENT.\n***********************************************************************\n*\nGET1EXTN L     R9,DCBDEBAD         LD DEB ADR FROM DCB, DSECT ADRBLTY\n         MVC   TOTEXTN,DEBNMEXT    EXTRACT TOTAL NUMB OF EXTENTS\n         LA    R10,32(0,R9)        INCR TO BG OF EXTENTS AREA IN DEB\n         ST    R10,EXTNADR         SAVE 1ST EXTENT ADR FOR GETNXEXT RTN\n         XC    EXTNCTR,EXTNCTR     INIT EXTENT CTR TO ZERO\n         BAL   R8,GETNXEXT         GET CC AND HH OF NEXT EXTENT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE EXTRACTS THE BEGINNING CCHH OF THE NEXT EXTENT FOR\n*    THE CALLING ROUTINE. IT ALSO CHECKS FOR LAST-EXTENT, INCREMENTS\n*    TO THE NEXT EXTENT FIELD IN THE DEB AND SAVES THE EXTENT FIELD\n*    ADDRESS IN THE FULLWORD EXTNADR. IF THERE ARE NO MORE EXTENTS,\n*    THIS SUBROUTINE ATTEMPTS TO ALLOCATE ANOTHER ONE VIA THE EOV\n*    MACRO. THIS SUBROUTINE RECEIVES THE ADDRESS OF THE FIRST EXTENT\n*    FIELD IN THE DEB FROM THE ROUTINE GET1EXTN.\n***********************************************************************\n*\nGETNXEXT IC    R10,EXTNCTR         LD PREV EXTENT NUMB\n         LA    R10,1(0,R10)        INCR TO IND THIS EXTENT\n         STC   R10,EXTNCTR         SAVE THIS EXTENT NUMB\n         CLC   EXTNCTR,TOTEXTN     COMP THIS EXT NUMB TO TOT EXTENTS\n         BH    DOEOV               IF ALL ALLO EXTENTS USED, TRY TO\n*                                  ALLO ANOTHER EXTENT\nLDNXEXT  L     R10,EXTNADR         LD ADR OF NEXT EXTENT FIELD IN DEB\n         MVC   CC,DEBSTRCC         PUT CC OF NEXT EXTENT INTO RECPTR\n         MVC   HH,DEBSTRHH         PUT HH OF NEXT EXTENT INTO RECPTR\n         MVC   RCNTCCHH,CCHH       PUT CCHH INTO COUNT AREA\n         LA    R10,16(0,R10)       INCR TO NEXT EXTENT FIELD IN DEB\n         ST    R10,EXTNADR         SAVE ADR OF NEXT EXTENT FIELD\n         BR    R8                  RETURN TO CALLING RTN\nDOEOV    EOV   WRTDCB              ALLO ANOTHER EXTENT\n         L     R9,DCBDEBAD         LD ADR OF DEB\n         MVC   TOTEXTN,DEBNMEXT    EXTRACT TOTAL NUMB OF EXTENTS\n         LA    R14,0               ZERO REG 14 FOR IC INSTR\n         IC    R14,TOTEXTN         LD NEW TOT EXTENT NUMB\n         BCTR  R14,0               DECR TOT EXTENT NUMB FOR SLL INSTR\n         SLL   R14,4               MULT TOT-EXTENT-NUMB MINUS 1 BY\n*                                  16 (EXTENT ENTRY LEN) TO GET\n*                                  NEW EXTENT OFFSET\n         LA    R10,32(R14,R9)      LD ADR OF NEW EXTENT ALLOCATED\n         ST    R10,EXTNADR         SAVE ADR OF NEW EXTENT FIELD\n         B     LDNXEXT             PROCESS EXTENT\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE RECORDS USED TO CREATE THE DASD DATASET.\n***********************************************************************\n*\nGETREC   GET   INRECS,RECDATA      READ A CARD-IMAGE RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE WRITES A NEW RECORD INTO THE DASD DATASET. IN ORDER\n*    TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO THE\n*    SUBROUTINES WHICH PERFORM THE FOLLOWING FUNCTIONS:\n*      * INCREMENT THE RECORD POINTER TO POINT TO THE NEXT RECORD\n*        LOCATION FOR WHICH THE NEW RECORD IS TO BE WRITTEN;\n*      * CHECK IF THE NEW RECORD FITS IN THE SPACE REMAINING ON THE\n*        TRACK;\n*      * OBTAIN THE NEW TRACK BALANCE AFTER THE NEW RECORD IS WRITTEN;\n*      * ISSUE THE EXCP MACRO TO WRITE THE NEXT PHYSICAL RECORD OF THE\n*        DASD DATASET.\n***********************************************************************\n*\nWRTREC   BAL   R7,SETRCPTR         SET RECPTR TO PREV RECORD\n         BAL   R7,CHKFIT           CHK IF NEW REC WILL FIT ON TRK\n         BAL   R7,GETRKBAL         GET TRK BAL AFTER REC WRITTEN\n         BAL   R7,DOEXCP           ISSUE EXCP MACRO TO WRITE RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE INCREMENTS THE RECORD POINTER TO POINT TO THE NEXT\n*    RECORD LOCATION FOR WHICH THE NEW RECORD IS TO BE WRITTEN AND\n*    MOVES THE NEW RECORD POINTER INTO THE IOB. SINCE A WHOLE (COUNT,\n*    KEY, AND DATA) NEW RECORD IS TO BE WRITTEN (FORMATTED), THE RECORD\n*    POINTER ACTUALLY POINTS TO THE PREVIOUS RECORD.\n***********************************************************************\n*\nSETRCPTR IC    R10,R               LOAD OLD PREV REC NUMB\n         LA    R10,1(0,R10)        INCR REC NUMB TO NEW PREV REC NUMB\n         STC   R10,R               SAVE NEW PREV REC NUMB\n         MVC   IOBSEEK,RECPTR      MOVE BMMCCHHR OF PREV REC INTO IOB\n         LA    R10,1(0,R10)        INCR TO CURRENT REC NUMB\n         STC   R10,RCNTR           PUT CUR REC NUMB INTO COUNT AREA\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CHECKS IF THE NEW RECORD FITS IN THE SPACE\n*    REMAINING ON THE TRACK. IF THE NEW RECORD WILL NOT FIT IN THE\n*    REMAINING SPACE ON THE TRACK, THEN THE RECORD POINTER IS\n*    INCREMENTED TO THE NEXT TRACK.\n***********************************************************************\n*\nCHKFIT   CLC   RCNTR,TRKRECS       COMP CUR REC NUMB WITH MAX RECS/TRK\n         BNHR  R7                  IF EQUAL/LOW, RET TO CALLING RTN\n         BAL   R8,SETNXTRK         IF HIGH, GET NEXT TRK ADR\n         B     WRTREC              WRITE RECORD TO NEXT TRK\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS THE RECORD POINTER TO POINT TO THE BEGINNING\n*    OF THE NEXT TRACK FOR THE NEXT NEW RECORD TO BE WRITTEN; BRANCHES\n*    AND LINKS TO THE CHKNXTRK ROUTINE TO VALIDATE THE TRACK NUMBER;\n*    AND RESETS THE RECORD NUMBER AND TRACK BALANCE FOR THE NEW TRACK.\n***********************************************************************\n*\nSETNXTRK DS    0H\n         WTO   '*** NEXT TRACK ***',ROUTCDE=11  *** FOR TESTING ONLY\n         MVI   SECTOR,X'00'        SET SECTOR NUMB TO BG OF TRK\n         MVI   R,X'FF'             INIT REC NUMB FOR NEW TRK\n         LH    R10,HH              LOAD CUR TRK NUMB\n         LA    R10,1(0,R10)        INCR TRK NUMB\n         STH   R10,HH              PUT NEW TRK NUMB INTO RECPTR\n         BAL   R9,CHKNXTRK         VAL TRK NUMB, INCR CYL NUMB IF NEC\n         MVC   TRKBAL,TRKSIZE      INIT TRK BALANCE FOR NEW TRK\n         MVC   RCNTCCHH,CCHH       PUT CUR CYL/TRK NUMB INTO COUNT AREA\n         BR    R8                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE VALIDATES THE NEW TRACK NUMBER AFTER THE TRACK\n*    NUMBER IS INCREMENTED TO DETERMINE IF IT EXCEEDS THE HI-TRACK\n*    ADDRESS OF A CYLINDER. IF IT DOES, THEN THE CYLINDER NUMBER IS\n*    INCREMENTED AND THE TRACK NUMBER IS SET TO ZERO.\n***********************************************************************\n*\nCHKNXTRK CLC   HH,HITRKADR         COMP NEW TRK NUMB TO HI-TRK ADR\n         BH    SETNXCYL            IF HIGH, INCR CYL NUMB\n         BR    R9                  IF NOT HIGH, RET TO CALLING RTN\nSETNXCYL XC    HH,HH               SET TRK NUMB TO ZERO (BG OF CYL)\n         LH    R10,CC              LOAD CUR CYL NUMB\n         LA    R10,1(0,R10)        INCR CYL NUMB\n         STH   R10,CC              PUT NEW CYL NUMB INTO RECPTR\n         BR    R9                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE USES THE TRKCALC MACRO TO OBTAIN WHAT THE TRACK\n*    BALANCE WILL BE AFTER THE RECORD IS WRITTEN. THIS VALUE IS USED TO\n*    UPDATE THE DCBTRBAL FIELD OF THE DCB, WHICH IS USED TO UPDATE THE\n*    FORMAT-1 DSCB, WHEN THE DATASET IS CLOSED.\n***********************************************************************\n*\nGETRKBAL MVC   RKDD(1),RCNTR       SET CUR REC NUMB FOR TRKCALC MACRO\n         TRKCALC FUNCTN=TRKBAL,TYPE=UCBTBYT4,RKDD=RKDD,REGSAVE=YES,    -\n               BALANCE=TRKBAL\n         STH   R0,TRKBAL           SAVE TRK BALANCE AFTER REC WRITTEN\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES THE EXCP MACRO TO WRITE THE NEXT PHYSICAL\n*    RECORD OF THE DASD DATASET, CHECKS THE ECB COMPLETION CODE AND\n*    PERFORMS THE APPROPRIATE ACTION INDICATED BY THE COMPLETION CODE.\n***********************************************************************\n*\nDOEXCP   XC    WRTECB,WRTECB       CLEAR ECB FOR EXCP MACRO\n         EXCP  WRTIOB              ISSUE EXCP\n         WAIT  1,ECB=WRTECB        WAIT FOR I/O COMPLETION\n         TM    WRTECB,X'7F'        CHK FOR GOOD I/O\n         BNO   CHKECB              IF NO, EXAM ECB\n         BR    R7                  IF I/O GOOD, RET TO CALLING RTN\n*\nCHKECB   TM    WRTECB,X'41'        CHK FOR EXCEPTION COND\n         BO    CHKEND              IF YES, CHK FOR INPUT END-OF-DATA\n         TM    WRTECB,X'42'        CHK FOR END-OF-EXTENT\n         BO    SETNXEXT            IF YES, ALLO NEW EXTENT\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\n*\nCHKEND   CLI   WRTENDSW,C'1'       CHK IF END-OF-DATA ON INPUT\n         BER   R7                  IF YES, RET TO CALLING RTN\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\n*\nSETNXEXT DS    0H\n         WTO   '*** NEXT EXTENT ***',ROUTCDE=11   *** FOR TESTING ONLY\n         IC    R10,M               LOAD CUR EXTENT NUMB\n         LA    R10,1(0,R10)        INCR EXTENT NUMB\n         STC   R10,M               PUT NEW EXTENT NUMB INTO RECPTR\n         BAL   R8,GETNXEXT         GET CCHH OF NEXT EXTENT\n         MVI   SECTOR,X'00'        SET SECTOR TO ZERO (BG OF TRK)\n         MVI   R,X'00'             SET REC NUMB OF RECPTR TO REC PREV\n*                                  OF 1ST REC TO WRITE\n         MVI   RCNTR,X'01'         SET COUNT REC NUMB TO 1ST TO WRITE\n         MVC   IOBSEEK,RECPTR      PUT NEW MBBCCHHR INTO IOB\n         B     DOEXCP              RE-ISSUE EXCP MACRO\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL WHEN ALL THE NEW DASD RECORDS ARE\n*    WRITTEN. THIS ROUTINE BRANCHES AND LINKS TO THE SUBROUTINES WHICH\n*    PERFORM THE FOLLOWING FUNCTIONS:\n*      * INCREMENT THE RECORD POINTER TO POINT TO THE LAST RECORD\n*        WRITTEN;\n*      * WRITE A ZERO-COUNT-RECORD AFTER THE LAST RECORD TO INDICATE\n*        END-OF-DATA;\n*      * UPDATE THE DCB WITH THE DASD LOCATION OF THE LAST RECORD AND\n*        THE TRACK BALANCE (NUMBER OF BYTES REMAINING ON THE TRACK\n*        INCLUDING THE SPACE OCCUPIED BY THE ZERO-COUNT-RECORD).\n***********************************************************************\n*\nWRTEND   BAL   R7,SETRCPTR         SET RECPTR TO LAST RECORD WRITTEN\n         XC    RCNTDLEN,RCNTDLEN   SET COUNT DATA-LEN TO ZERO\n         MVC   IOBSTART,CCWXADR    PUT ADR OF ZERO-CT-RECORD CCW-LIST\n*                                  INTO IOB\n         MVI   WRTENDSW,C'1'       IND INPUT END-OF-DATA\n         BAL   R7,DOEXCP           WRITE ZERO-CT-RECORD\n         BAL   R7,UPDTDCB          UPDATE DCB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE UPDATES THE DCB FIELDS DCBFDAD (POINTER TO LAST\n*    RECORD WRITTEN) AND DCBTRBAL (TRACK BALANCE) BEFORE THE DATASET\n*    IS CLOSED.\n***********************************************************************\n*\nUPDTDCB  MVC   DCBFDAD,IOBSEEK     MOVE DASD ADR (MBBCCHHR) OF LAST\n*                                  NON-ZERO CT RECORD WRITTEN INTO DCB\n         MVC   DCBTRBAL,TRKBAL     MOVE BYTES REMAINING ON TRACK INTO\n*                                  DCB\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS. FOR THE DASD DATASET JUST\n*    CREATED, THIS CLOSE CAUSES THE FIELDS DS1LSTAR AND DS1TRBAL OF\n*    THE FORMAT-1 DSCB TO BE UPDATED FROM THE CONTENTS OF THE\n*    CORRESPONDING FIELDS DCBFDAD AND DCBTRBAL, RESPECTIVELY, OF THE\n*    DCB.\n***********************************************************************\n*\nCLOSE    CLOSE (INRECS,,WRTDCB)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF THE ATTEMPTED I/O IS\n*    UNSUCCESSFUL. THIS ROUTINE LOADS VARIOUS DIAGNOSTIC INFORMATION\n*    INTO REGISTERS 8, 9, 10, 11, AND 12 AND THEN CAUSES AN ABEND WITH\n*    A DUMP.\n***********************************************************************\n*\nEXCPERR  L     R8,WRTECB           LOAD CONTENTS OF ECB INTO A REG\n         MVC   ERRINFO(1),EXTNCTR       EXTENT NUMBER\n         MVC   ERRINFO+1(1),IOBUSTAT    UNIT STATUS FIELD OF CSW\n         MVC   ERRINFO+2(1),IOBSENS0    BYTE-1 OF HARDWARE SENSE CODE\n         MVC   ERRINFO+3(1),IOBSENS1    BYTE-2 OF HARDWARE SENSE CODE\n         L     R9,ERRINFO          LOAD ERROR INFO WORD INTO A REG\n         L     R10,RECPTR          LOAD 1ST 4 BYTES OF REC-PTR\n         L     R11,RECPTR+4        LOAD 2ND 4 BYTES OF REC-PTR\n         L     R12,ERRID           LOAD ERR-ID TO FIND REGS IN DUMP\n         IC    R12,RCNTR           INSERT REC-ID FROM COUNT AREA\n         ABEND 900,DUMP            ISSUE ABEND MACRO AND REQ A DUMP\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING RTN\n*\n*\n***********************************************************************\n*    THIS LIST REQUIRED FOR THE DEVTYPE MACRO.\n***********************************************************************\n*\nDEVTAREA DS    0CL24\nUCBTYP   DS    0CL4\n         DS    CL3\nUCBTBYT4 DS    CL1\n         DS    CL4\n         DS    CL2\nCYLTRKS  DS    CL2                 NUMBER OF TRACKS PER CYLINDER\nTRKSIZE  DS    CL2                 TRACK CAPACITY IN BYTES\n         DS    CL2\n         DS    CL8\n*\n*\n***********************************************************************\n*    THIS AREA MAPS OUT THE RECORD-POINTER WHICH IS USED TO POINT TO\n*    THE RECORD AFTER WHICH THE NEW RECORD IS TO BE WRITTEN.\n***********************************************************************\n*\n         DS    0F                  FOR ALIGNMENT FOR THE EXCPERR RTN\nRECPTR   DS    0CL8\nM        DC    X'00'               EXTENT NUMBER (STARTING WITH ZERO)\nBB       DC    XL2'00'             BIN NUMBER (NO LONGER USED)\nCCHHR    DS    0CL5\nCCHH     DS    0CL4\nCC       DS    CL2                 CYLINDER NUMBER\nHH       DS    CL2                 HEAD (TRACK) NUMBER\nR        DC    X'FF'               RECORD NUMBER\n*\n*\n***********************************************************************\n*    THIS AREA MAPS OUT A COMPLETE (COUNT, KEY, AND DATA) DASD RECORD\n*    AND IS USED TO WRITE (FORMAT) THE NEW DASD RECORDS.\n***********************************************************************\n*\nRECORD   DS    0CL88               WHOLE RECORD (COUNT-KEY-DATA)\nRECCOUNT DS    0CL8                COUNT AREA OF RECORD\nRCNTCCHH DS    CL4                 CCHH OF RECORD\nRCNTR    DS    CL1                 RECORD NUMBER OF RECORD\nRCNTKLEN DC    X'00'               KEY LENGTH\nRCNTDLEN DC    X'0050'             DATA LENGTH\nRECDATA  DS    CL80                DATA AREA OF RECORD\n*\n*\n***********************************************************************\n*    OTHER DC/DS STATEMENTS\n***********************************************************************\n*\nWRTENDSW DC    C'0'\nDDNAME   DS    CL8\nSECTOR   DC    X'00'\nHITRKADR DS    H\nTRKBAL   DS    H\nTRKRECS  DS    CL1\nCYLNUM   DC    F'0'\nTRKNUM   DC    F'0'\nRKDD     DC    X'01000050'         USED BY TRKCALC MACRO\nTOTEXTN  DS    CL1\nEXTNCTR  DS    CL1\nEXTNADR  DS    F\nERRINFO  DS    F\nERRID    DC    4XL1'FF'\n*\nCCWADR   DC    A(WRTCCWS)\nCCWXADR  DC    A(WRTXCCWS)\nDCBADR   DC    A(WRTDCB)\nECBADR   DC    A(WRTECB)\n*\n*\n***********************************************************************\n*    THE CCW-LISTS, IOB, AND ECB\n***********************************************************************\n*\nWRTCCWS  CCW   X'23',SECTOR,X'40',1      SET SECTOR CCW\nSEARCH   CCW   X'31',CCHHR,X'60',5       SEARCH ID EQUAL CCW\n         CCW   X'08',SEARCH,X'00',0      TIC CCW\n         CCW   X'1D',RECORD,X'60',88     WRITE CKD CCW\n         CCW   X'22',SECTOR,X'00',1      READ SECTOR CCW\n*\nWRTXCCWS CCW   X'23',SECTOR,X'40',1      SET SECTOR CCW\nSEARCHX  CCW   X'31',CCHHR,X'60',5       SEARCH ID EQUAL CCW\n         CCW   X'08',SEARCHX,X'00',0     TIC CCW\n         CCW   X'1D',RECORD,X'20',8      WRITE CKD (ZERO-CT) CCW\n*\nWRTIOB   DC    10F'0'                    AREA FOR IOB\nWRTECB   DC    F'0'                      FULLWORD FOR ECB\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nINRECS   DCB   DSORG=PS,MACRF=GM,LRECL=80,RECFM=FB,EODAD=ENDDATA,      -\n               DDNAME=INRECS\nWRTDCB   DCB   MACRF=E,DDNAME=TESTFILE,DSORG=PS\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         DCBD  DSORG=XE            GENERATES EXCP-DCB DSECT\n         IEZDEB                    GENERATES DEB DSECT\n         IEZIOB                    GENERATES IOB DSECT\n         ORG   IOBCSTAT+1          POS TO RESIDUAL COUNT FIELD OF CSW\nIOBCSWCT DS    CL2                 PROVIDE LABEL FOR RES CT FIELD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n          END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE110303": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xaf\\x00\\xaf\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 175, "newlines": 175, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 11.3.3\n*\nTTRCONV  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IECSDSF1,R10        DEFINE REG FOR DSCB DSECT\n         USING IHADCB,R11          DEFINE REG FOR DCB DSECT\n         USING CVT,R12             DEFINE REG FOR CVT DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OBTAIN           READ DSCB-1 OF DATASET\n         BAL   R6,OPEN             OPEN DCB, CREATE DEB\n         BAL   R6,GETTTR           GET LAST REC PTR (TTR) OF DATASET\n         BAL   R6,GETDEB           GET DEB ADR\n         BAL   R6,CONVERT          CONVERT TTR TO MBBCCHHR\n         BAL   R6,LOADCCHH         LOAD MBBCCHHR INTO PARM REGS\n         BAL   R6,DUMPCCHH         DUMP MBBCCHHR (FOR TESTING ONLY)\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE FORMAT-1 DSCB OF THE DATASET. THE DSCB IS\n*    PLACED INTO THE AREA DSCB1.\n***********************************************************************\n*\nOBTAIN   OBTAIN READDSCB           READ FORMAT-1 DSCB OF DATASET\n         LTR   R15,R15             CHECK IF DATASET IN JCL\n         BNZ   NODSNM              IN NO, INDICATE IT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE DCB OF THE DATASET IN ORDER TO CAUSE THE\n*    DEB TO BE CREATED.\n***********************************************************************\n*\nOPEN     OPEN  TESTFILE            OPEN DCB\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE EXTRACTS THE LAST-RECORD-POINTER FIELD IN THE\n*    FORMAT-1 DSCB OF THE DATASET. THIS FIELD IS IN THE TTR FORMAT.\n***********************************************************************\n*\nGETTTR   LA    R10,DSCB1           SET ADRBLTY FOR DSCB DSECT\n         MVC   TTRN(3),DS1LSTAR    EXTRACT LAST-REC-PTR\n         L     R0,TTRN             LOAD TTRN INTO REG FOR IECPCNVT\n         BR    R6                  RETURN TO CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE EXTRACTS THE ADDRESS OF THE DEB FROM THE DCB. THE DEB\n*    ADDRESS IS REQUIRED BY THE CONVERSION PROGRAM.\n***********************************************************************\n*\nGETDEB   LA    R11,TESTFILE        SET ADRBLTY FOR DCB DSECT\n         L     R1,DCBDEBAD         EXTRACT DEB ADR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CONVERTS THE LAST-RECORD-POINTER FROM TTR FORMAT INTO\n*    THE EQUIVALENT MBBCCHHR FORMAT.\n***********************************************************************\n*\nCONVERT  L     R12,16              SET ADRBLTY FOR CVT DSECT\n         LA    R2,MBBCCHHR         LD ADR OF RECEIVING AREA\n         L     R15,CVTPCNVT        LD EPA OF IECPCNVT\n         BALR  R14,R15             BRANCH AND LINK TO IECPCNVT\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE RESULTING MBBCCHHR FROM THE CONVERSION INTO\n*    THE PARAMETER REGISTERS 0 AND 1 FOR THE CALLING PROGRAM.\n***********************************************************************\n*\nLOADCCHH L     R0,MBBCCHHR         LOAD 1ST 4 BYTES OF MBBCCHHR\n         L     R1,MBBCCHHR+4       LOAD 2ND 4 BYTES OF MBBCCHHR\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE IS USED ONLY DURING TESTING TO VERIFY THAT THE\n*    CONVERSION PROGRAM IS BEING CALLED PROPERLY. THE MBBCCHHR IS\n*    LOCATED IN REGISTERS 8 AND 9 AND THEN THE ABEND MACRO IS ISSUED\n*    REQUESTING A DUMP.\n***********************************************************************\n*\n*\nDUMPCCHH L     R8,MBBCCHHR         LOAD 1ST 4 BYTES OF MBBCCHHR\n         L     R9,MBBCCHHR+4       LOAD 2ND 4 BYTES OF MBBCCHHR\n         ABEND 900,DUMP            ISSUE ABEND MACRO WITH DUMP\n*\n***********************************************************************\n*    THIS SUBROUTINE DISPLAYS AN ERROR MESSAGE IF THE DATASET IS NOT\n*    SPECIFIED IN THE JCL AND THEN CAUSES AN ABEND.\n***********************************************************************\n*\nNODSNM   WTO   '*** DATASET NOT FOUND ON SPECIFIED DASD VOLUME ***',   -\n               ROUTCDE=11\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS (EXCEPT THE PARAMETER\n*    REGISTERS 0 AND 1) OF THE CALLING PROGRAM AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   L     R13,4(0,R13)        RESTORE ADR OF PREV SA\n         L     R14,12(0,R13)       RESTORE REG 14\n         LA    R15,0               SET RC=0 INTO REG 15\n         LM    R2,R12,28(R13)      RESTORE REGS 2 THRU 12\n         BR    R14                 RETURN TO CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nTTRN     DC    F'0'\nMBBCCHHR DS    D\n*\n*\n***********************************************************************\n*    THE CAMLST USED BY THE OBTAIN MACRO.\n***********************************************************************\n*\nREADDSCB CAMLST SEARCH,DSNAME,VOLSER,WORKAREA\nVOLSER   DC    CL6'STRG01'\nDSCB1    DS    0CL140\nDSNAME   DC    CL44'USER.TESTDATA'\nWORKAREA DS    CL140\n*\n*\n***********************************************************************\n*    THE DCB\n***********************************************************************\n*\nTESTFILE DCB   DSORG=PS,MACRF=E,DDNAME=TESTFILE\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n*\n         DSECT\n         IECSDSL1 1                GENERATES FORMAT-1 DSCB DSECT\n*\n         DSECT\n         DCBD  DSORG=PS            GENERATES PS-DCB DSECT\n*\n         DSECT\n         CVT   DSECT=YES           GENERATES CVT DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE110401": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xd7\\x00\\xd7\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 215, "newlines": 215, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 11.4.1\n*\n*\nREADMTV  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IOBSTDRD,R12        DEFINE REG FOR IOB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETDSCTS         LOAD DSECT REGISTER\n         BAL   R6,SETIOB           SET REQUIRED IOB FIELDS\n         BAL   R6,OPEN             OPEN DCBS\nNEXTREC  BAL   R6,READREC          READ A PHYSICAL RECORD\n         BAL   R6,PRINTREC         PRINT THE RECORD\n         B     NEXTREC             READ NEXT RECORD\nENDDATA  BAL   R6,REWIND           EOD, REWIND TAPE\n         BAL   R6,CLOSE            CLOSE DCBS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE REGISTER FOR THE IOB DSECT.\n***********************************************************************\n*\nSETDSCTS LA    R12,READIOB         LOAD IOB ADR FOR DSECT ADRBLTY\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS THE REQUIRED FIELDS OF THE IOB\n***********************************************************************\n*\nSETIOB   MVI   IOBFLAG1,X'42'      IND CCW-CHAINING, NOT RELATED\n         MVC   IOBSTART,CCWADR     LOAD BG ADR OF CCW LIST\n         MVC   IOBDCBPT,DCBADR     LOAD DCB ADR\n         MVC   IOBECBPT,ECBADR     LOAD ECB ADR\n         MVC   IOBINCAM,BINONE     READ FORWARD ONE BLOCK AT A TIME\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (READDCB,,SYSPRINT,(OUTPUT))\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE NEXT PHYSICAL RECORD FROM THE TAPE DATASET.\n*    IN ORDER TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO\n*    THE SUBROUTINES WHICH PERFORM THE FOLLOWING FUNCTIONS:\n*      * ISSUE THE EXCP MACRO TO READ THE NEXT PHYSICAL RECORD OF THE\n*        TAPE DATASET.\n*      * CALCULATE THE LENGTH OF THE RECORD READ.\n***********************************************************************\n*\nREADREC  BAL   R7,DOEXCP           ISSUE EXCP TO READ RECORD\n         BAL   R7,GETLEN           CALCULATE LENGTH OF RECORD READ\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES THE EXCP MACRO TO READ A PHYSICAL RECORD OF\n*    THE TAPE DATASET, CHECKS THE ECB COMPLETION CODE, AND PERFORMS THE\n*    APPROPRIATE ACTION INDICATED BY THE COMPLETION CODE.\n***********************************************************************\n*\nDOEXCP   XC    READECB,READECB     CLEAR ECB FOR EXCP MACRO\n         EXCP  READIOB             ISSUE EXCP\n         WAIT  1,ECB=READECB       WAIT FOR I/O COMPLETION\n         TM    READECB,X'7F'       CHECK FOR GOOD I/O\n         BNO   CHKECB              IF NO, EXAMINE ECB\n         BR    R7                  IF I/O GOOD, RET TO CALLING RTN\nCHKECB   TM    READECB,X'41'       CHK FOR EXCEPTION COND\n         BO    CHKERR41            IF YES, CHK FOR END-OF-DATA\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\nCHKERR41 TM    IOBUSTAT,X'01'      CHK FOR TAPE MARK (END-OF-DATA)\n         BO    ENDDATA             IF YES, GO TO END-OF-DATA RTN\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CALCULATES THE LENGTH OF THE RECORD READ BY\n*    SUBTRACTING THE RESIDUAL COUNT FROM THE MAXIMUM RECORD LENGTH.\n***********************************************************************\n*\nGETLEN   LH    R10,IOBCSWCT        LOAD RESIDUAL COUNT FROM CSW\n         LA    R11,MXRECLEN        LOAD MAXIMUM RECORD LENGTH\n         SR    R11,R10             SUBTRACT RES CT FROM MAX LEN\n         ST    R11,RECLEN          SAVE ACTUAL NUMB OF BYTES READ\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PRINTS THE VARIABLE-LENGTH RECORD READ FROM THE TAPE\n*    DATASET.\n***********************************************************************\n*\nPRINTREC L     R10,RECLEN          LOAD REC LEN\n         BCTR  R10,0               DECR REC LEN FOR EX INSTR\n         EX    R10,EXMVC           MOVE RECORD INTO PRINT LINE\n         PUT   SYSPRINT,LINE       PRINT RECORD\n         MVC   LINE,LINE-1         CLEAR PRINT LINE\n         BR    R6                  RETURN TO CALLING RTN\nEXMVC    MVC   LINE+1(0),RECORD    MVC FOR EX INSTR\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF THE ATTEMPTED I/O IS\n*    UNSUCCESSFUL. THIS ROUTINE LOAD VARIOUS DIAGNOSTIC INFORMATION\n*    INTO REGISTERS 8 AND 9 AND THEN CAUSES AN ABEND WITH A DUMP.\n***********************************************************************\n*\nEXCPERR  L     R8,READECB            LOAD CONTENTS OF ECB INTO A REG\n         MVC   ERRINFO+1(1),IOSUSTAT      UNIT STATUS FIELD OF CSW\n         MVC   ERRINFO+2(1),IOBSENS0      BYTE-1 OF HARDWARE SENSE CODE\n         MVC   ERRINFO+3(1),IOBSENS1      BYTE-2 OF HARDWARE SENSE CODE\n         L     R9,ERRINFO            LOAD ERROR INFO WORD INTO A REG\n         L     R10,ERRID             LOAD ID TO FIND REGS IN DUMP\n         ABEND 900,DUMP              ISSUE ABEND MACRO WITH A DUMP\n*\n*\n***********************************************************************\n*    THIS ROUTINE CAUSES THE REWINDING OF THE TAPE VOLUME.\n***********************************************************************\n*\nREWIND   MVC   IOBSTART,CCWADR2\n         BAL   R7,DOEXCP\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (READDCB,,SYSPRINT)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n***********************************************************************\n*    THE CCW, IOB AND ECB\n***********************************************************************\n*\nREADCCW  CCW   X'02',RECORD,X'20',MXRECLEN    READ CCW\nREWDCCW  CCW   X'07',0,X'00',1                REWIND CCW\n*\nREADIOB  DC    10F'0'              AREA FOR IOB\nREADECB  DC    F'0'                FULLWORD FOR ECB\n*\n*\n***********************************************************************\n*    OTHER DC/DS STATEMENTS\n***********************************************************************\n*\nMXRECLEN EQU   120\nBINONE   DC    H'1'\nRECLEN   DS    F\nRECORD   DS    CL(MXRECLEN)\n         DC    C' '\nLINE     DC    CL133' '\n*\nCCWADR   DC    A(READCCW)\nCCWADR2  DC    A(REWDCCW)\nDCBADR   DC    A(READDCB)\nECBADR   DC    A(READECB)\n*\nERRINFO  DC    F'0'\nERRID    DC    4XL1'FF'\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nREADDCB  DCB   MACRF=E,DDNAME=TESTFILE\nSYSPRINT DCB   DSORG=PS,MACRF=PM,BLKSIZE=1330,LRECL=133,RECFM=FB,      -\n               DDNAME=SYSPRINT\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n\n         PRINT NOGEN\n         IEZIOB                GENERATES IOB DSECT\n         ORG   IOBCSTAT+1      POS TO RESIDUAL COUNT FIELD OF CSW\nIOBCSWCT DS    CL2             PROVIDE LABEL FOR RES CT FIELD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE110402": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xcc\\x00\\xcc\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 204, "newlines": 204, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 11.4.2\n*\n*\nWRTMTV   CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IHADCB,R11          DEFINE REG FOR DCB DSECT\n         USING IOBSTDRD,R12        DEFINE REG FOR IOB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETDSCTS         LOAD DSECT REGISTERS\n         BAL   R6,SETIOB           SET REQUIRED IOB FIELDS\n         BAL   R6,OPEN             OPEN DCBS\nNEXTREC  BAL   R6,GETREC           READ A REC FOR THE TAPE DATASET\n         BAL   R6,WRTREC           WRITE A PHYSICAL REC TO TAPE\n         B     NEXTREC             PROCESS NEXT REC\nENDDATA  BAL   R6,WRTEND           EOD, INDICATE EOF1/EOF2 REQUIRED\n         BAL   R6,CLOSE            CLOSE DCBS\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE REGISTERS FOR THE DCB AND THE IOB DSECTS\n***********************************************************************\n*\nSETDSCTS LA    R11,WRTDCB           LOAD DCB ADR FOR DSECT ADRBLTY\n         LA    R12,WRTIOB           LOAD IOB ADR FOR DSECT ADRBLTY\n         BR    R6                   RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS THE REQUIRED FIELDS OF THE IOB\n***********************************************************************\n*\nSETIOB   MVI   IOBFLAG1,X'42'      IND CCW-CHAINING, NOT RELATED\n         MVC   IOBSTART,CCWADR     LOAD BG ADR OF CCW-LIST\n         MVC   IOBDCBPT,DCBADR     LOAD DCB ADR\n         MVC   IOBECBPT,ECBADR     LOAD ECB ADR\n         MVC   IOBINCAM,BINONE     WRITE FORWARD ONE BLOCK AT A TIME\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS ALL THE DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (INRECS,,WRTDCB(OUTPUT))\n         ...                       CHECK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS THE RECORDS USED TO CREATE THE TAPE DATASET.\n***********************************************************************\n*\nGETREC   GET   INRECS,RECORD       READ A RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE WRITES THE NEXT PHYSICAL RECORD TO THE TAPE DATASET.\n*    IN ORDER TO PERFORM THAT TASK, THIS ROUTINE BRANCHES AND LINKS TO\n*    THE SUBROUTINE WHICH PERFORMS THE FOLLOWING FUNCTION:\n*      * ISSUE THE EXCP MACRO TO WRITE THE NEXT PHYSICAL RECORD OF THE\n*        TAPE DATASET.\n***********************************************************************\n*\nWRTREC   BAL   R7,DOEXCP           ISSUE EXCP MACRO TO WRITE REC\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES THE EXCP MACRO TO WRITE A PHYSICAL RECORD\n*    TO THE TAPE DATASET, CHECKS THE ECB COMPLETION CODE AND PERFORMS\n*    THE APPROPRIATE ACTION INDICATED BY THE COMPLETION CODE.\n***********************************************************************\n*\nDOEXCP   XC    WRTECB,WRTECB       CLEAR ECB FOR EXCP MACRO\n         EXCP  WRTIOB              ISSUE EXCP MACRO\n         WAIT  1,ECB=WRTECB        WAIT FOR I/O COMPLETION\n         TM    WRTECB,X'7F'        CHECK FOR GOOD I/O\n         BNO   CHKECB              IF NO, EXAMINE ECB\n         BR    R7                  RETURN TO CALLING RTN\n*\nCHKECB   TM    WRTECB,X'41'        CHECK FOR EXCEPTION COND\n         BO    CHKERR41            IF YES, CHK FOR END OF TAPE\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\n*\nCHKERR41 TM    IOBUSTAT,X'01'      CHECK FOR END-OF-TAPE\n         BO    DOEOV               IF YES, CAUSE ANOTHER TAPE MOUNT\n         B     EXCPERR             IF NO, I/O ERROR, DUMP DIAG INFO\n*\nDOEOV    OI    DCBOFLGS,DCBOFLWR   IND EOV1/EOV2 LABELS, ETC. REQRD\n         EOV   WRTDCB              DO END-OF-VOLUME PROCESSING\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RECEIVES CONTROL IF THE ATTEMPTED I/O IS\n*    UNSUCCESSFUL. THIS ROUTINE LOAD VARIOUS DIAGNOSTIC INFORMATION\n*    INTO REGISTERS 8 AND 9 AND THEN CAUSES AN ABEND WITH A DUMP.\n***********************************************************************\n*\nEXCPERR  L     R8,WRTECB           LOAD CONTENTS OF ECB INTO A REG\n         MVC   ERRINFO+1(1),IOSUSTAT    UNIT STATUS FIELD OF CSW\n         MVC   ERRINFO+2(1),IOBSENS0    BYTE-1 OF HARDWARE SENSE CODE\n         MVC   ERRINFO+3(1),IOBSENS1    BYTE-2 OF HARDWARE SENSE CODE\n         L     R9,ERRINFO          LOAD ERROR INFO WORD INTO A REG\n         L     R10,ERRID           LOAD ID TO FIND REGS IN DUMP\n         ABEND 900,DUMP            ISSUE ABEND MACRO AND REQ DUMP\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS THE DCBOFLGS FIELD TO INDICATE TO DATA MGMT TO\n*    DO THE FOLLOWING AFTER THE DATASET IS CLOSED:\n*        * WRITE A TAPEMARK AFTER THE LAST RECORD OF THE DATASET;\n*        * WRITE THE EOF1/EOF2 LABELS IF THE JCL SPECIFIED STANDARD\n*          LABELS FOR THE DATASET;\n*        * WRITE A DOUBLE TAPE MARK AFTER THE EOF1/EOF2 LABELS (FOR A\n*          STANDARD LABEL DATASET) OR AFTER THE LAST RECORD OF THE\n*          DATASET (FOR A NON-LABELED DATASET) TO INDICATE THAT THE\n*          DATASET IS THE LAST ONE ON THE TAPE VOLUME.\n***********************************************************************\n*\nWRTEND   LA    R11,WRTDCB          SET ADRBLTY FOR DCB DSECT\n         OI    DCBOFLGS,DCBOFLWR   IND TO DATAMGMT TO DO EOD PROC\n         BR    R6                  RET TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES ALL THE DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (INRECS,,WRTDCB)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR THE CALLING PROG\n*\n*\n***********************************************************************\n*    CCW, IOB AND ECB\n***********************************************************************\n*\nWRTCCW   CCW   X'01',RECORD,X'20',80    WRITE CCW\n*\nWRTIOB   DC    10F'0'                   AREA FOR IOB\nWRTECB   DC    F'0'                     FULLWORD FOR ECB\n*\n*\n***********************************************************************\n*    OTHER DC/DS STATEMENTS\n***********************************************************************\n*\nBINONE   DC    H'1'\nRECORD   DS    CL80\n*\nCCWADR   DC    A(WRTCCW)\nDCBADR   DC    A(WRTDCB)\nECBADR   DC    A(WRTECB)\n*\nERRINFO  DC    F'0'\nID       DC    4XL1'FF'\n*\n*\n***********************************************************************\n*    THE DCBS\n***********************************************************************\n*\nINRECS   DCB   DSORG=PS,MACRF=GM,LRECL=80,RECFM=FB,EODAD=ENDDATA,      -\n               DDNAME=INRECS\nWRTDCB   DCB   MACRF=E,DDNAME=TESTFILE\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         DCBD  DSORG=XE        GENERATES EXCP-DCB DSECT\n         IEZIOB                GENERATES IOB DSECT\n         ORG   IOBCSTAT+1      POS TO RESIDUAL COUNT FIELD OF CSW\nIOBCSWCT DS    CL2             PROVIDE LABEL FOR RES CT FIELD\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE120601": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00T\\x00T\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.6.1\n*\n*\nIGC0025B CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R                  DEFINE EQU'S FOR REGISTERS\n         USING *,R6                    SETUP ADDRESSABILITY\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVEREGS             SAVE REGISTERS\n         BAL   R8,PUTADDRS             PUT TCB/ASCB ADRS INTO PARM AREA\n         B     RETURN                  RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS LR    R12,R14                 SAVE RETURN ADDRESS\n         LR    R11,R1                  SAVE CALLERS PARM AREA ADDRESS\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS THE ADDRESSES OF THE CALLER'S TCB AND ASCB\n*    IN THE PARM AREA PROVIDED BY THE CALLER. THE CALLER PASSES THE\n*    ADDRESS OF ITS PARM-LIST IN REGISTER 1. THE PARM AREA CONTAINS\n*    TWO FULLWORDS. THE FIRST FULLWORD CONTAINS THE ADDRESS OF THE AREA\n*    WHICH IS TO RECEIVE THE ADDRESS OF THE TCB AND THE SECOND FULLWORD\n*    CONTAINS THE ADDRESS OF THE AREA WHICH IS TO RECEIVE THE ADDRESS\n*    OF THE ASCB. THE SAVEREGS ROUTINE SAVES REGISTER 1 IN REGISTER 11.\n***********************************************************************\n*\nPUTADDRS L     R10,0(0,R11)           LOAD ADR OF 1ST WORD OF PARM\n         ST    R4,0(0,R10)            PUT TCB ADR INTO PROV AREA\n         L     R10,4(0,R11)           LOAD ADR OF 2ND WORD OF PARM\n         ST    R7,0(0,R10)            PUT ASCB ADR INTO PROV AREA\n         BR    R8                     RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE PARAMETER REGISTERS, RESTORES THE RETURN\n*    ADDRESS INTO REGISTER 14 AND RETURNS CONTROL TO THE FLIH.\n***********************************************************************\n*\nRETURN   LR    R1,R11                  RESTORE PARM AREA ADR\n         LA    R15,0                   LOAD RC IN A PARM REG\n         LR    R14,R12                 RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n***********************************************************************\n*    CODE TO INVOKE SVC IN CODING EXAMPLE 12.6.1.\n***********************************************************************\n         ...\n         LA    R1,PARMAREA             LOAD ADR OF PARM AREA\n         SVC   252                     ISSUE SVC TO RET TCB/ASCB ADRS\n         LTR   R15,R15                 CHECK RC\n         BNZ   NOADDRS                 IF NOT 0, ADRS NOT RETURNED\n         ...                           USE TCB/ASCB ADRS\nPARMAREA DS    0F\nTCBADR   DS    F\nASCBADR  DS    F\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE120602": {"ttr": 5899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00g\\x00g\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.6.2\n*\n*\nIGC0025C CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R                  DEFINE EQU'S FOR REGISTERS\n         USING *,R6                    SETUP ADDRESSABILITY\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVEREGS             SAVE REGISTERS\n         BAL   R8,SETKEY               SET PSW KEY TO THAT OF CALLER\n         BAL   R8,GETCSA               GET REQUESTED CSA STORAGE\n         BAL   R8,RSTORKEY             RESTORE PSW KEY TO ZERO\n         B     RETURN                  RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS LR    R12,R14                 SAVE RETURN ADDRESS\n         LR    R10,R0                 SAVE REQUESTED LENGTH OF CSA ALLO\n         WTO   '*** SVC 253 ENTERED ***',ROUTCDE=11    * TESTING ONLY *\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHANGES THE PSW STORAGE PROTECTION KEY TO THAT OF\n*    THE CALLING PROGRAM. THIS IS DONE SO THAT THE ALLOCATED CSA\n*    STORAGE IS SET TO THE PROTECTION KEY OF THAT OF THE CALLING\n*    PROGRAM INSTEAD OF THE PROTECTION KEY OF THE SVC ROUTINE WHICH IS\n*    KEY ZERO.\n***********************************************************************\n*\nSETKEY   MODESET KEY=NZERO             SET KEY TO THAT OF CALLER\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES FETCH-PROTECTED VIRTUAL STORAGE FROM THE\n*    CSA. THE LENGTH OF THE REQUESTED CSA STORAGE IS SPECIFIED VIA\n*    REGISTER 0 BY THE CALLER OF THE SVC. THE SAVEREGS ROUTINE SAVES\n*    REGISTER 0 IN REGISTER 10.\n***********************************************************************\n*\nGETCSA   GETMAIN RC,LV=(R10),SP=231    ALLO CSA STORAGE\n         LR    R11,R1                  SAVE ADDRESS OF CSA STORAGE\n         LR    R9,R15                  SAVE RC FROM GETMAIN\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE PSW STORAGE PROTECTION KEY BACK TO KEY\n*    ZERO. THIS IS REQUIRED OR THE SVC ROUTINE WILL ABEND WHEN IT\n*    RETURNES CONTROL.\n***********************************************************************\n*\nRSTORKEY MODESET KEY=ZERO              RESTORE KEY VALUE OF SVC\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE PARAMETER REGISTERS, RESTORES THE RETURN\n*    ADDRESS INTO REGISTER 14 AND RETURNS CONTROL TO THE FLIH.\n***********************************************************************\n*\nRETURN   LR    R1,R11                  LOAD ALLO CSA ADR IN A PARM REG\n         LR    R15,R9                  LOAD RC IN A PARM REG\n         LR    R14,R12                 RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n***********************************************************************\n*    CODE TO INVOKE SVC IN CODING EXAMPLE 12.6.2.\n***********************************************************************\n         ...\n         LA    R0,100                  SET LENGTH OF REQ CSA\n         SVC   253                     ISSUE SVC TO ALLO CSA\n         LTR   R15,R15                 CHECK RC\n         BNZ   NOCSA                   IF BAD, NO CSA AVAIL\n         MVC   0(100,R1),CSADATA       IF OK, MOVE DATA INTO CSA\n         ...\nNOCSA    ...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE120603": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00I\\x00I\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.6.3\n*\n*\nIGC253   CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R                  DEFINE EQU'S FOR REGISTERS\n         USING *,R6                    SETUP ADDRESSABILITY\n         USING TCB,R4                  DEFINE REG FOR TCB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVEREGS             SAVE REGISTERS\n         BAL   R8,GETCSA               GET REQUESTED CSA STORAGE\n         B     RETURN                  RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS LR    R12,R14                SAVE RETURN ADDRESS\n         LR    R10,R0                 SAVE REQUESTED LENGTH OF CSA ALLO\n         BR    R8                     RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES FETCH-PROTECTED VIRTUAL STORAGE FROM THE\n*    CSA AND ASSIGNES IT THE PSW STORAGE PROTECTION KEY OF THE CALLER\n*    OF THE SVC ROUTINE. THE LENGTH OF THE REQUESTED CSA STORAGE IS\n*    SPECIFIED VIA REGISTER 0 BY THE CALLER OF THE SVC. THE SAVEREGS\n*    ROUTINE SAVES REGISTER 0 IN REGISTER 10.\n***********************************************************************\n*\nGETCSA   IC    R2,TCBPKF               GET PSW PROT KEY OF CALLER\n         GETMAIN RC,LV=(R10),SP=231,BRANCH=YES,KEY=(R2)\n         LR    R11,R1                  SAVE ADDRESS OF CSA STORAGE\n         LR    R9,R15                  SAVE RC FROM GETMAIN\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE PARAMETER REGISTERS, RESTORES THE RETURN\n*    ADDRESS INTO REGISTER 14 AND RETURNS CONTROL TO THE FLIH.\n***********************************************************************\n*\nRETURN   LR    R1,R11                  LOAD ALLO CSA ADR IN A PARM REG\n         LR    R15,R9                  LOAD RC IN A PARM REG\n         LR    R14,R12                 RESTORE RETURN ADDRESS\n         BR    R14                     RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         IKJTCB                        GENERATES TCB DSECT\n*                                      REQR BY BRANCH-ENTRY GETMAIN\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE120604": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x8b\\x00\\x8b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.6.4\n*\n*\nIGC0025D CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R                  GENERATE EQU'S FOR REGISTERS\n         USING *,R6                    SETUP ADDRESSABILITY\n         USING TCB,R4                  DEFINE DESCT REG FOR TCB\n         USING IEZJSCB,R5              DEFINE DSECT REG FOR JSCB\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVEREGS             SAVE REGISTERS\n         BAL   R8,GETJSCB              GET JSCB ADR\n         BAL   R8,VERPW                VERIFY PASSWORD FROM CALLER\n         BAL   R8,SETAPF               SET REQ APF INDICATOR\n         B     RETURN                  RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS LR    R12,R14                 SAVE RETURN ADR\n         LR    R10,R0                  SAVE APF INDICATOR\n         LR    R11,R1                  SAVE USER SPECIFIED PW\n         WTO   '*** SVC 254 ENTERED ***',ROUTCDE=11    FOR TESTING ONLY\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE JSCB FROM THE TCB.\n***********************************************************************\n*\nGETJSCB  L     R5,TCBJSCB              LOAD JSCB ADR FROM TCB\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE VERIFIES THE PASSWORD RECEIVED FROM THE CALLER OF\n*    THIS SVC ROUTINE. THE PASSWORD IS SPECIFIED IN REGISTER 1. THE\n*    SAVEREGS ROUTINE SAVES REGISTER 1 IN REGISTER 11. IF THE PASSWORD\n*    IS OK, THEN THE REQUESTED SERVICE IS PERFORMED. IF THE PASSWORD\n*    IS INVALID, THEN AN RC OF X'08' IS SET AND CONTROL IS RETURNED TO\n*    THE CALLER WITHOUT THE REQUESTED SERVICE BEING PERFORMED.\n***********************************************************************\n*\nVERPW    C     R11,PASSWORD            CHECK CALLER'S PASSWORD\n         BER   R8                      IF OK, RET TO CALLING RTN\n         LA    R15,8                   IF BAD, INDICATE IT\n         B     RETURN                  RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS THE APF BIT AS REQUESTED BY THE CALLER OF THIS\n*    SVC ROUTINE. THE REQUESTED ACTION IS SPECIFIED IN REGISTER 0.\n*    THE SAVEREGS ROUTINE SAVES REGISTER 0 IN REGISTER 10. X'00'\n*    INDICATES APF ON, X'04' INDICATES APF OFF. IF THE CALLING\n*    PROGRAM SPECIFIES AN INVALID INDICATOR, THEN AN RC OF X'04' IS\n*    SET AND CONTROL IS RETURNED TO THE CALLER WITHOUT THE REQUESTED\n*    SERVICE BEING PERFORMED.\n***********************************************************************\n*\nSETAPF   C     R10,BIN0                CHK IF APF REQ IS FOR \"ON\"\n         BE    SETAON                  IF YES, DO IT\n         C     R10,BIN4                CHK IF APF REQ IS FOR \"OFF\"\n         BE    SETAOFF                 IF YES, DO IT\n         LA    R15,4                   INDICATE BAD REQ\n         BR    R8                      RETURN TO CALLING RTN\nSETAON   OI    JSCBOPTS,X'01'          SET APF ON\n         WTO   '*** AUTH ON ***',ROUTCDE=11      * FOR TESTING ONLY *\n         LA    R15,0                   SET GOOD RC\n         BR    R8                      RETURN TO CALLING RTN\nSETAOFF  NI    JSCBOPTS,X'FE'          SET APF OFF\n         WTO   '*** AUTH OFF ***',ROUTCDE=11     * FOR TESTING ONLY *\n         LA    R15,0                   SET GOOD RC CODE\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE RETURN ADDRESS INTO REGISTER 14 AND\n*    RETURNS CONTROL TO THE FLIH.\n***********************************************************************\n*\nRETURN   LR    R14,R12                 RESTORE RETURN ADR\n         BR    R14                     RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    CONSTANTS\n***********************************************************************\n*\nBIN0     DC    F'0'                    SET APF-ON INDICATOR\nBIN4     DC    F'4'                    SET APF-OFF INDICATOR\nPASSWORD DC    C'....'                 PASSWORD TO USE THIS SVC\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         IKJTCB                        GENERATES TCB DSECT\n         IEZJSCB                       GENERATES JSCB DSECT\n*\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n***********************************************************************\n*    CODE TO INVOKE SVC IN CODING EXAMPLE 12.6.3.\n***********************************************************************\n         ...\n         LA    R0,0                    SET AUTH-ON REQUEST\n         L     R1,PASSWORD             LOAD PW FOR SVC\n         SVC   254                     ISSUE SVC TO SET AUTH\n         C     R15,BIN0                CHECK RC\n         BE    AUTHON                  IF 0, AUTH ON\n         C     R15,BIN4                CHECK RC\n         BE    INVAUTH                 IF 4, BAD AUTH IND\n         B     INVPSWD                 IF 8, BAD PW\nAUTHON   ...                           PERFORM AUTH FUNCTION\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE120605": {"ttr": 6148, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00i\\x00i\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.6.5\n*\n*\nIGC0025E CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R                  GENERATE EQU'S FOR REGISTERS\n         USING *,R6                    SETUP ADDRESSABILITY\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVEREGS             SAVE REGISTERS\n         BAL   R8,DOREQ                DO PAGE FIX/FREE\n         B     RETURN                  RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS LR    R12,R14                 SAVE RETURN ADR\n         LR    R10,R0                  SAVE PG FIX/FREE INDICATOR\n         LR    R11,R1                  SAVE PG FIX/FREE ADR LIST\n         WTO   '*** SVC 255 ENTERED ***',ROUTCDE=11    * TESTING ONLY *\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PERFORMS THE PAGE-FIX/FREE AS REQUESTED BY THE CALLER\n*    OF THIS SVC ROUTINE. THE REQUESTED ACTION IS SPECIFIED IN REGISTER\n*    0. THE SAVEREGS ROUTINE SAVES REGISTER 0 IN REGISTER 10. X'00'\n*    INDICATES A PAGE-FIX, X'04' INDICATES A PAGE FREE. IF THE CALLING\n*    PROGRAM SPECIFIES AN INVALID INDICATOR, THEN AN RC OF X'04' IS\n*    SET AND CONTROL IS RETURNED TO THE CALLER WITHOUT THE REQUESTED\n*    SERVICE BEING PERFORMED. THE BEGINNING AND ENDING ADDRESSES OF THE\n*    PAGE-FIX/FREE ARE SPECIFIED AS TWO CONSECUTIVE FULLWORDS POINTED\n*    TO BY REGISTER 1. THE SAVEREGS ROUTINE SAVES REGISTER 1 IN\n*    REGISTER 11.\n***********************************************************************\n*\nDOREQ    L     R2,0(0,R11)             LOAD BG ADR TO FIX/FREE\n         L     R9,4(0,R11)             LOAD END ADR TO FIX/FREE\n         C     R10,BIN0                CHK FIX/FREE IND\n         BE    DOPGFIX                 IF 0, DO PAGE FIX\n         C     R10,BIN4                CHK FIX/FREE IND\n         BE    DOPGFREE                IF 4, DO PAGE FREE\n         LA    R15,4                   IF NOT 0 OR 4, SET INV IND\n         BR    R8                      RETURN TO CALLING RTN\nDOPGFIX  PGFIX R,A=(R2),EA=(R9),ECB=0\n         BR    R8                      RETURN TO CALLING RTN\nDOPGFREE PGFREE R,A=(R2),EA=(R9)\n         BR    R8                      RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE RETURN ADDRESS INTO REGISTER 14 AND\n*    RETURNS CONTROL TO THE FLIH.\n***********************************************************************\n*\nRETURN   LR    R14,R12                 RESTORE RETURN ADR\n         BR    R14                     RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    CONSTANTS\n***********************************************************************\n*\nBIN0     DC    F'0'                    PAGE FIX INDICATOR\nBIN4     DC    F'4'                    PAGE FREE INDICATOR\n*\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n***********************************************************************\n*    CODE TO INVOKE THE SVC IN CODING EXAMPLE 12.6.4.\n***********************************************************************\n         ...\n         LA    R0,0                    SET PAGE-FIX REQUEST\n         ST    R10,BGADDR              STOR BG ADR\n         ST    R11,ENDADDR             STOR END ADR\n         LA    R1,ADDRSPTR             LOAD ADR OF BG/END ADR-LIST\n         SVC   255                     ISSUE SVC TO PAGE FIX\n         LTR   R15,R15                 CHECK RC\n         BNZ   NOPGFIX                 IF NON-ZERO, BAD PGFIX\n         ...                           PROCESS\nADDRSPTR DS    0F\nBGADDR   DS    F\nENDADDR  DS    F\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE120701": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.7.1\n*\n*\n//jobname  JOB  ----\n//LKEDNUC  EXEC PGM=IEWL,PARM='LIST,XREF,NCAL,SCTR',REGION=4096K\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(5,1))\n//SVCLIB   DD   DSN=USER.SVCLIB,DISP=SHR\n//SYSLMOD  DD   DSN=SYS1.NUCLEUS,DISP=SHR\n//SYSLIN   DD   *\n  INSERT  IEAVNIP0\n  INSERT  IEAVFX00\n  INCLUDE SVCLIB(IGC247)\n  INCLUDE SVCLIB(IGC252)\n  INCLUDE SYSLMOD(IEANUC01)\n  NAME    IEANUC01(R)\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE120702": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.7.2\n*\n*\n//jobname  JOB   ----\n//ADDSVC   EXEC  SMPEPROC\n//SMPE.SMPCNTL   DD  *\n  SET BDY(GLOBAL).\n  RECEIVE SELECT(SVC250) SYSMOD.\n  SET BDY(MVSTRGT)\n  APPLY SELECT(SVC250).\n//SMPE.SMPPTFIN  DD  *\n++ USERMOD (SVC250).\n++ VER(Z038) FMID(fffffff).\n++ MOD(IGC250) DISTLIB(SVCLIB) LMOD(IEANUC01).\n   ****************************\n   * Object Module for IGC250 *\n   ****************************\n//SMPE.SVCLIB    DD  DSN=USER.SVCLIB,DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE120801": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xb8\\x00\\xb8\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 184, "newlines": 184, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 12.8.1\n*\n*\nLOADSVC  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,GETPARM          EXTRACT PARM DATA\n         BAL   R6,VERSVCNO         VERIFY SVC NUMBER\n         BAL   R6,CNVSVCNO         CONVERT SVC NUMBER TO BINARY\n         BAL   R6,SETMODE          SET PROGRAM TO SUPV STATE, KEY ZERO\n         BAL   R6,LOADNSVC         LOAD NEW SVC INTO CSA\n         BAL   R6,SETNWSVC         STORE NEW SVC EPA INTO SVC TBL\n         B     RETURN              RETURN TO MVS OR CALLING PROGRAM\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE SPECIFIED SVC NUMBER AND SVC ROUTINE NAME\n*    FROM THE PARM PARAMETER OF THE JCL EXEC STATEMENT.\n***********************************************************************\n*\nGETPARM  L     R1,0(0,R1)          LOAD ADR OF JCL PARM AREA\n         LH    R15,0(0,R1)         LOAD LEN OF SPECIFIED PARM\n         LTR   R15,R15             CHK IF PARM SPECIFIED\n         BZ    NOPARM              IF LEN=0, NO PARM SPECIFIED\n         BCTR  R15,0               DECR PARM LEN FOR EX INSTR\n         EX    R15,MOVE            MOVE PARM INTO PROC AREA\n         BR    R6                  RETURN TO CALLING RTN\nMOVE     MVC   SVCINFO(0),2(R1)    MOVE INSTR FOR EX\nNOPARM   WTO   '*** SVC NUMBER AND NAME NOT SPECIFIED---PROGRAM TERMINA-\n               TED ***',ROUTCDE=11\n         ABEND 901\n*\n*\n***********************************************************************\n*    THIS ROUTINE VERIFIES THAT THE SPECIFIED SVC NUMBER IS A DECIMAL\n*    NUMBER FROM 200 THROUGH 255.\n***********************************************************************\n*\nVERSVCNO LA    R0,3                SET NUMB OF DIGITS IN SVC NUMB\n         LA    R10,DECSVCNO        LD ADR OF AREA WITH SVC NUMB\nNXTSVCDG CLI   0(R10),C'0'         CHK IF A DIGIT IS LESS THAN 0\n         BL    INVSVCNO            IF YES, INVALID SVC NUMB\n         CLI   0(R10),C'9'         CHK IF A DIGIT IS MORE THAN 9\n         BH    INVSVCNO            IF YES, INVALID SVC NUMB\n         LA    R10,1(0,R10)        INCR TO NEXT SVC NUMB DIGIT\n         BCT   R0,NXTSVCDG         CHK NEXT DIGIT UNTIL ALL 3 CHECKED\n         CLC   DECSVCNO,=C'200'    CHK IF SVC NUMB IS LESS THAN 200\n         BL    INVSVCNO            IF YES, INVALID SVC NUMB\n         CLC   DECSVCNO,=C'255'    CHK IF SVC NUMB IS GREATER THAN 255\n         BH    INVSVCNO            IF YES, INVALID SVC NUMB\n         BR    R6                  RETURN TO CALLING RTN\nINVSVCNO WTO   '*** INVALID SVC NUBER SPECIFIED---PROGRAM TERMINATED **-\n               *',ROUTCDE=11\n         ABEND 902\n*\n*\n***********************************************************************\n*    THIS ROUTINE CONVERTS THE SPECIFIED DECIMAL SVC NUMBER INTO\n*    BINARY.\n***********************************************************************\n*\nCNVSVCNO PACK  PKSVCNO,DECSVCNO    PACK SPECIFIED ZONED DEC SVC NUMB\n         CVB   R10,PKSVCNO         CONV SVC NUMB INTO BINARY\n         ST    R10,SVCNUM          SAVE BIN SVC NUMB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS THE TASK INTO SUPERVISOR STATE AND PSW\n*    PROTECTION KEY ZERO VIA THE MODESET MACRO. THIS IS REQUIRED TO\n*    ISSUE THE SVCUPDTE MACRO.\n***********************************************************************\n*\nSETMODE  MODESET MODE=SUP,KEY=ZERO\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE NEW SVC ROUTINE INTO CSA. THE LOAD MACRO\n*    SPECIFIES THAT ONLY THE LIBRARY POINTED TO BY THE DDNAME SPECIFIED\n*    IN THE SVCLIB DCB IS TO BE SEARCHED FOR THE NEW SVC ROUTINE.\n***********************************************************************\n*\nLOADNSVC BAL   R7,OPENLIB          OPEN LOADLIB FOR LOAD MACRO\n         LOAD  EPLOC=SVCNAME,GLOBAL=(YES,P),DCB=SVCLIB,LSEARCH=YES\n         ST    R0,SVCEPA           SAVE EP ADR OF NEW SVC\n         BAL   R7,CLOSELIB         CLOSE LOADLIB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE LIBRARY WHICH CONTAINS THE NEW SVC ROUTINE.\n***********************************************************************\n*\nOPENLIB  OPEN  SVCLIB              OPEN PRIV LOADLIB THAT HAS SVC RTN\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE LIBRARY WHICH CONTAINS THE NEW SVC\n*    ROUTINE.\n***********************************************************************\n*\nCLOSELIB CLOSE SVCLIB              CLOSE PRIV LOADLIB\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES THE SVCUPDTE MACRO TO PUT THE ENTRY POINT\n*    ADDRESS OF THE NEW SVC ROUTINE INTO THE PROPER ENTRY IN THE SVC\n*    TABLE AND TO INDICATE THAT THE SVC ROUTINE IS A TYPE-3 SVC.\n***********************************************************************\n*\nSETNWSVC L     R10,SVCEPA          LOAD EP ADR OF SVC RTN\n         L     R11,SVCNUM          LOAD SVC NUMBER\n         ENQ   (QNAME,RNAME,E,,SYSTEM)\n         SVCUPDTE (R11),REPLACE,TYPE=3,EP=(R10)\n         DEQ   (QNAME,RNAME,,SYSTEM)\n         LTR   R15,R15             CHK IF SVC TBL UPDATE OK\n         BZR   R6                  IF YES, RET TO CALLING RTN\n         WTO   '*** ERROR UPDATING SVC TABLE---PROGRAM TERMINATED ***'\n         ABEND 903,DUMP\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nPKSVCNO  DS    D\nSVCNUM   DS    F\nSVCEPA   DS    F\nSVCINFO  DS    0CL12\nDECSVCNO DS    CL3\n         DS    CL1\nSVCNAME  DC    CL8' '\n*\n*\n***********************************************************************\n*    QNAME/RNAME FOR ENQ/DEQ FOR SVCUPDTE MACRO\n***********************************************************************\n*\nQNAME    DC    CL8'SYSZSVC'\nRNAME    DC    C'TABLE'\n*\n*\n***********************************************************************\n*    THE DCB FOR THE SVC ROUTINE LIBRARY USED BY THE LOAD MACRO\n***********************************************************************\n*\nSVCLIB   DCB   DSORG=PO,MACRF=R,DDNAME=SVCLIB\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         CVT   DSECT=YES           GENERATES CVT DSECT REQUIRED BY\n*                                  SVCUPDTE MACRO INSTRUCTION\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE130401": {"ttr": 6159, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00U\\x00U\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 13.4.1\n*\n*\nALLOCSA1 CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING R10,CVT             DEFINE REG FOR CVT DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,GETCSA           ALLOC STORAGE FROM CSA\n         BAL   R6,SETMODE          SET PROG INTO SUPV STATE, KEY ZERO\n         BAL   R6,SETCVT           PUT CSA STRG ADR INTO CVT USER FLD\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES NON-FETCH-PROTECTED VIRTUAL STORAGE FROM\n*    THE CSA AND ASSIGNS IT THE SAME PSW KEY AS THE ISSUING TASK.\n***********************************************************************\n*\nGETCSA   GETMAIN EC,LV=2048,SP=241,A=CSAADR\n         LTR   R15,R15             CHECK FOR SUCCESSFUL GETMAIN\n         BNZ   NOCSA               IF NON-ZERO, CSA STRG NOT AVAIL\n         BR    R6                  RETURN TO CALLING RTN\nNOCSA    WTO   '*** CSA STORAGE NOT AVAILABLE ***',ROUTCDE=11\n         LA    R15,4               SET UNSUCCESSFUL RC INDICATION\n         B     RETURNX             RETURN TO MVS WITH BAD RC\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS THE TASK INTO SUPERVISOR STATE AND PSW\n*    PROTECTION KEY ZERO VIA THE MODESET MACRO. THIS IS REQUIRED TO\n*    MOVE THE ADDRESS OF THE ALLOCATED CSA INTO THE CVT USER-FIELD.\n***********************************************************************\n*\nSETMODE  MODESET MODE=SUP,KEY=ZERO\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PLACES THE ADDRESS OF THE ALLOCATED CSA INTO THE\n*    CVT USER-FIELD.\n***********************************************************************\n*\nSETCVT   L     R10,16              LOAD REG 10 WITH CVT ADR\n         MVC   CVTUSER,CSAADR      MOVE CSA STRG ADR INTO CVT USER FLD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   LA    R15,0               SET RC=0\nRETURNX  L     R13,4(0,R13)        RESTORE PREV SA ADR\n         L     R14,12(0,R13)       RESTORE REG 14\n         LM    R0,R12,20(R13)      RESTORE REGS 0-12, R15 HAS RC\n         BR    R14                 RETURN TO MVS OR CALLING PROG\n*\nCSAADR   DS    F\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         CVT   DSECT=YES           GENERATES CVT DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE130402": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00k\\x00k\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 13.4.2\n*\n*\nALLOCSA2 CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n         INITL 5,EQU=R             INITIALIZE PROGRAM\n         USING R10,CVT             DEFINE REG FOR CVT DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETMODE          SET PROG INTO KEY ZERO, SUPV STATE\n         BAL   R6,SETLOCK          OBTAIN LOCAL LOCK\n         BAL   R6,GETCSA           ALLOC STORAGE FROM CSA\n         BAL   R6,RELLOCK          RELEASE LOCAL LOCK\n         BAL   R6,SETCVT           PUT CSA STRG ADR INTO CVT USER FLD\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS THE TASK INTO SUPERVISOR STATE AND PSW\n*    PROTECTION KEY ZERO VIA THE MODESET MACRO. THIS IS REQUIRED TO\n*    MOVE THE ADDRESS OF THE ALLOCATED CSA INTO THE CVT USER-FIELD.\n***********************************************************************\n*\nSETMODE  MODESET MODE=SUP,KEY=ZERO\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ISSUES THE SETLOCK MACRO TO OBTAIN THE LOCAL LOCK\n*    WHICH IS REQUIRED FOR A BRANCH-ENTRY GETMAIN MACRO.\n***********************************************************************\n*\nSETLOCK  SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE,               -\n               RELATED=(GETMAIN,CSA,RELLOCK)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE FROM THE CSA AND ASSIGNS\n*    PSW PROTECTION KEY=8 (NORMAL V=V JOBS) TO IT.\n***********************************************************************\n*\nGETCSA   GETMAIN RC,LV=4096,SP=231,BNDRY=PAGE,BRANCH=YES               -\n               KEY=8\n         LTR   R15,R15             CHECK FOR SUCCESSFUL GETMAIN\n         BNZ   NOCSA               IF NON-ZERO, CSA STRG NOT AVAIL\n         ST    R1,R11              SAVE ADR OF CSA AREA IN REG 11\n         BR    R6                  RETURN TO CALLING RTN\nNOCSA    LA    R15,4               SET UNSUCCESSFUL RC INDICATION\n         B     RETURNX             RETURN TO MVS WITH BAD RC\n*\n*\n***********************************************************************\n*    THIS ROUTINE RELEASES THE LOCAL LOCK.\n***********************************************************************\n*\nRELLOCK  SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,                          -\n               RELATED=(GETMAIN,CSA,SETLOCK)\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PLACES THE ADDRESS OF THE ALLOCATED CSA INTO THE\n*    CVT USER-FIELD.\n***********************************************************************\n*\nSETCVT   L     R10,16              LOAD REG 10 WITH CVT ADR\n         ST    R11,CVTUSER         STORE CSA STRG ADR INTO CVT USER FLD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   LA    R15,0               SET RC=0\nRETURNX  L     R13,4(0,R13)        RESTORE PREV SA ADR\n         L     R14,12(0,R13)       RESTORE REG 14\n         LM    R0,R12,20(R13)      RESTORE REGS 0-12, R15 HAS RC\n         BR    R14                 RETURN TO MVS OR CALLING PROG\n\n\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         PRINT NOGEN\n         CVT   DSECT=YES           GENERATES CVT DSECT\n         IHAPSA                    GENERATES PSA DSECT\n*                                  REQUIRED FOR SETLOCK MACRO\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE140601": {"ttr": 6404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.6.1\n*\n*\n* THE CALLING PROGRAM:\n*\nPROG01   CSECT\n         ...\n         LOAD  EP=PROG02        LOAD PROGRAM WHICH IS TO RECV CONTROL\n         ST    R0,R15           SAVE EP ADR AND AMODE OF CALLED PROGRAM\n         BASSM R14,R15          SET ADR MODE OF CALLED PGM, SAVE AMODE\n*                               OF CALLING PGM, BRANCH TO CALLED PROG\n         ...\n         END\n*\n*\n*\n*\n* THE CALLED PROGRAM:\n*\nPROG02   CSECT\n         ...\n         BSM   0,R14            SET AMODE OF CALLING PROG, RETURN\n*                               CONTROL TO CALLING PROG\n         ...\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE140602": {"ttr": 6406, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00V\\x00V\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.6.2\n*\n*\n* CODE FOR CSECT MAINRTN:\n*\nMAINRTN  CSECT\nMAINRTN  AMODE 31\nMAINRTN  RMODE 24\n         EXTRN SUBRTN01\n         EXTRN SUBRTN02\n*\n         INITL 3,EQU=R\n         ...\n         BAL   R6,DOSRTN01\n         ...\n         BAL   R6,DOSRTN02\n         ...\nDOSRTN01 L     R15,=A(SR01ADR)\n         L     R15,0(0,R15)\n         BASSM R14,R15\n         BR    R6\n*\nDOSRTN02 L     R15,=A(SR02ADR)\n         L     R15,0(0,R15)\n         BASSM R14,R15\n         BR    R6\n         ...\n         END\n*\n*\n*\n*\n* CODE FOR CSECT SUBRTN01:\n*\nSUBRTN01 CSECT\nSUBRTN01 AMODE 24\nSUBRTN01 RMODE 24\n         ENTRY SR01ADR\n*\n         INITL 3,EQU=R\n         ...\n         ...                       AMODE 24 DEPENDENT CODE\n         ...\nRETURN   L     R13,4(0,R13)\n         LM    R14,R12,12(R13)\n         BSM   0,R14\n         ...\nSR01ADR  DC    A(SUBRTN01)         POINTER-DEFINED VALUE FOR THIS CSECT\n         ...\n         END\n*\n*\n*\n*\n* CODE FOR CSECT SUBRTN02:\n*\nSUBRTN02 CSECT\nSUBRTN02 AMODE 31\nSUBRTN02 RMODE ANY\n         ENTRY SR02ADR\n*\n         INITL 3,EQU=R\n         ...\n         ...                       AMODE 31 DEPENDENT CODE\n         ...\nRETURN   L     R13,4(0,R13)\n         LM    R14,R12,12(R13)\n         BSM   0,R14\n         ...\nA31      EQU   X'80000000'\nSR02ADR  DC    A(A31+SUBRTN02)     POINTER-DEFINED VALUE FOR THIS CSECT\n         ...\n         END\n*\n*\n*\n*\n* LINK EDITOR CONTROL STATEMENTS\n*\n  INCLUDE OBJLIB(MAINRTN)\n  INCLUDE OBJLIB(SUBRTN01)\n  INCLUDE OBJLIB(SUBRTN02)\n  MODE    AMODE(31) RMODE(24)\n  ENTRY   MAINRTN\n  NAME    MAINRTN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE140603": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00w\\x00w\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.6.3\n*\n*\n         TITLE 'EXAMPLE OF A LINKAGE ASSIST PROGRAM'\n*\n*\n***********************************************************************\n*    THIS PROGRAM IS A LINKAGE ASSIST PROGRAM. IT RECEIVES CONTROL IN\n*    THE AMODE OF THE CALLING PROGRAM. IT CHECKS THE AMODE OF THE\n*    CALLING PROGRAM. IF THE AMODE IS 24-BIT, THEN THE HIGH-ORDER BYTE\n*    OF REGISTER 1 (THE PARAMETER REGISTER) IS SET TO BINARY ZEROS\n*    TO CREATE A VALID 31-BIT ADDRESS FOR THE CALLED PROGRAM. THIS\n*    PROGRAM THEN LOADS THE CALLED PROGRAM, CHANGES THE AMODE TO THAT\n*    REQUIRED BY THE CALLED PROGRAM AND BRANCHES TO IT. WHEN CONTROL\n*    IS RETURNED, THIS PROGRAM RESTORES THE REGISTERS AND AMODE TO\n*    THAT OF THE CALLING PROGRAM AND RETURNS CONTROL.\n***********************************************************************\n*\n*\nPROG02   CSECT\nPROG02   AMODE ANY                 RECV CNTL IN AMODE OF CALLING PROG\nPROG02   RMODE 24                  RESIDE BELOW 16 MB LINE TO\n*                                  ACCOMMODATE AMODE OF 24 OR 31\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAIN STREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,VALIDATE         CHK IF REG 1 NEEDS ADJUSTMENT\n         BAL   R6,LOAD             LOAD CALLED PROG\n         BAL   R6,BRANCH           BRANCH TO CALLED PROG\n         B     RETURN              RETURN TO CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE AMODE OF THE CALLING PROGRAM AND PASSES\n*    CONTROL TO THE SUBROUTINE WHICH DETERMINES IF REGISTER 1 NEEDS\n*    TO BE ADJUSTED.\n***********************************************************************\n*\nVALIDATE LA    R7,CHKAMODE         LD ADR OF CALLED RTN\n         BASSM R8,R7               SAVE AMODE OF CALLING PROG,\n*                                  BRANCH AND LINK TO CALLED RTN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CHECKS THE AMODE OF THE CALLING PROGRAM. IF THE\n*    AMODE IS 24, THEN THE HIGH-ORDER BYTE OF REGISTER 1 IS SET T0\n*    ZEROS.\n***********************************************************************\n*\nCHKAMODE ST    R8,AMODE            STORE AMODE FOR TM INSTR\n         TM    AMODE,X'80'         CHK AMODE OF CALLING PROG\n         BZ    FIXREG1             IF AMODE=24 (BIT0=0), FIX REG 1\n         ST    R1,PARMADR          STORE PARM ADR\n         BR    R8                  AMODE=31, RET TO CALLING RTN\nFIXREG1  ICM   R1,B'1000',=X'00'   SET BITS 0-7 OF PARM ADR TO ZEROS\n         ST    R1,PARMADR          STORE FIXED PARM ADR\n         BR    R8                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE CALLED PROGRAM AND SAVES THE POINTER-\n*    DEFINED VALUE RETURNED FROM THE LOAD MACRO.\n***********************************************************************\n*\nLOAD     LOAD  EP=PROG02X          LOAD CALLED PROG\n         ST    R0,EPADR            SAVE POINTER-DEFINED VALUE\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHANGES THE AMODE TO THAT OF THE CALLED PROGRAM\n*    AND BRANCHES AND LINKS TO THE CALLED PROGRAM.\n***********************************************************************\n*\nBRANCH   L     R1,PARMADR          LOAD PARM ADR FROM CALLING PROG\n         L     R15,EPADR           LOAD EP ADR AND AMODE OF CALLED PROG\n         BASSM R14,R15           SET AMODE AND BR AND LK TO CALLED PROG\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND THE AMODE TO THAT OF THE\n*    CALLING PROGRAM AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   L     R13,4(0,R13)        RESTORE SA ADR OF CALLING PROG\n         L     R14,12(0,R13)       RESTORE REG 14 OF CALLING PROG\n         LM    R0,R12,20(R13)      RESTORE REGS 0-12 OF CALLING PROG\n         BSM   0,R14               RESTORE AMODE OF CALLING PROG AND\n*                                  RETURN\n*\n*\n***********************************************************************\n*    THE STORAGE AREAS USED BY THIS PROGRAM.\n***********************************************************************\n*\nAMODE    DS    F\nPARMADR  DS    F\nEPADR    DS    F\n*\n*\n***********************************************************************\n*    END OF PROGRAM.\n***********************************************************************\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE140604": {"ttr": 6412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00k\\x00k\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 107, "newlines": 107, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.6.4\n*\n*\n* CALLED PROGRAM BEFORE CAPPING:\n*\n*\nPROG04  CSECT\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n        INITL 3,EQU=R\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n        BAL   R6,RTN01\n        BAL   R6,RTN02\n        BAL   R6,RTN03\n        B     RETURN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN  RCNTL RC=0\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n* CALLED PROGRAM AFTER CAPPING CODE ADDED:\n*\n*\nPROG04   CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R\n*\n*\n***********************************************************************\n*    CAPPING PROLOGUE. THIS ROUTINE PERFORMS THE FOLLOWING:\n*        * RECEIVES CONTROL IN AMODE OF CALLING PROGRAM;\n*        * SAVES AMODE OF CALLING PROGRAM;\n*        * CHANGES AMODE TO OWN AMODE.\n***********************************************************************\n*\nPROG04   AMODE ANY\nPROG04   RMODE 24\n*\nPROLOG   LA    R10,RETURN          LOAD ADR OF RETURN RTN\n         L     R11,OWNAMODE        LOAD OWN AMODE/PROLOGX RTN ADR\n         BSM   R10,R11             GET CALLERS AMODE/BRANCH TO PROLOGX\nPROLOGX  ST    R10,XAMODE          SAVE CALLERS AMODE/RETURN RTN ADR\n         B     MAINSTRM            BRANCH TO MAINSTREAM OF PROG\nOWNAMODE DC    A(PROLOGX)          OWN AMODE/PROLOGX RTN ADR\nXAMODE   DS    F                   SAVE AREA FOR CALLERS AMODE AND\n*                                  RETURN RTN ADR\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\nMAINSTRM BAL   R6,RTN01            *** LABEL ADDED ***\n         BAL   R6,RTN02\n         BAL   R6,RTN03\n         B     EPILOG              *** CHANGED ***\n*\n*\n***********************************************************************\n*    CAPPING EPLOG. THIS ROUTINE PERFORMS THE FOLLOWING:\n*        * RESTORES THE AMODE TO THAT OF THE CALLING PROGRAM;\n*        * BRANCHES TO THE ORIGINAL RETURN ROUTINE.\n***********************************************************************\n*\nEPILOG   L     R10,XAMODE        LOAD CALLING PROG AMODE/RETURN RTN ADR\n         BSM   0,R10             CHANGE AMODE, BRANCH TO RETURN RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE140801": {"ttr": 6415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xae\\x00\\xae\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.8.1\n*\n*\n         TITLE 'DEMO PROGRAM TO ILLUSTRATE HOW A 24-BIT AMODE PROGRAM U-\n               SES 31-BIT AMODE STORAGE'\n*\n*\n***********************************************************************\n*    THIS PROGRAM RECEIVES CONTROL IN 24-BIT ADDRESSING MODE. IT\n*    READS DATA RECORDS FROM A SEQUENTIAL DATASET. THE DATA RECORDS\n*    ARE MOVED INTO A VIRTUAL STORAGE TABLE LOCATED ABOVE THE 16 MB\n*    LINE. WHEN ALL THE DATA RECORDS ARE READ, THE DATA IS PROCESSED\n*    FROM THE TABLE. THE ROUTINE WHICH CREATES THE TABLE EXECUTES IN\n*    31-BIT ADDRESSING MODE.\n***********************************************************************\n*\n*\nXABLDTBL CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         ICM   R3,B'1000',=X'00'   ZERO BITS 0-7 OF 1ST BASE REG\n*\n*\n***********************************************************************\n*    MAIN STREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,OPEN             OPEN INPUT DCB\n         BAL   R6,GETVS31          ALLO VS ABOVE 16 MB LINE\nNEXTREC  BAL   R6,GETDATA          READ A DATA REC\n         BAL   R6,PUTTBL           PUT DATA REC INTO TBL\n         B     NEXTREC             READ NEXT REC\nDATAEND  BAL   R6,DOTBLEND         EOD, IND END OF TBL\n         BAL   R6,CLOSE            CLOSE INPUT DCB\n         BAL   R6,PROCTBL          PROCESS DATA IN TABLE\n         B     RETURN              RETURN TO MVS OR CALLING PGM\n*\n*\n***********************************************************************\n*    THIS ROUTINE OPENS THE INPUT DCB.\n***********************************************************************\n*\nOPEN     OPEN  SYSIN               OPEN INPUT DCB\n         ...                       CHK FOR GOOD OPEN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE ABOVE THE 16 MB LINE.\n***********************************************************************\n*\nGETVS31  GETMAIN RU,LV=4096,LOC=ANY,SP=10\n         ST    R1,TBLADR31         SAVE BG-OF-TBL ADR\n         ST    R1,TBLPTR31         SET TBL ENTRY PTR TO BG\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE READS A DATA RECORD.\n***********************************************************************\n*\nGETDATA  GET   SYSIN               READ A DATA REC\n         ST    R1,DATAADR          SAVE ADR OF DATA REC\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHANGES THE AMODE TO 31 AND PASSES CONTROL TO THE\n*    SUBROUTINE WHICH BUILDS THE TABLE IN VIRTUAL STORAGE ABOVE THE\n*    16 MB LINE.\n***********************************************************************\n*\nPUTTBL   L     R7,PTBL31X          LOAD ADR OF 31-BIT AMODE RTN TO\n*                                  BUILD TABLE\n         BASSM R8,R7               CHANGE AMODE TO 31, BRANCH AND LINK\n*                                  TO PTBL31 RTN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE COPIES THE RECORD READ FROM THE INPUT DATASET\n*    INTO THE TABLE ABOVE THE 16 MB LINE AND THEN CHANGES THE AMODE\n*    BACK TO 24.\n***********************************************************************\n*\nPTBL31   L     R10,TBLPTR31        LOAD ADR OF NEXT TBL SLOT\n         L     R11,DATAADR         LOAD ADR OF DATA REC\n         MVC   0(ENTLEN,R10),0(R11)     MOVE DATA REC INTO TBL\n         LA    R10,ENTLEN(0,R10)   INCR TO NEXT TBL SLOT\n         ST    R10,TBLPTR31        SAVE ADR OF NEXT TBL SLOT\n         BSM   0,R8              CHANGE AMODE TO 24, RET TO CALLING RTN\nPTBL31X  DC    A(A31+PTBL31)       POINTER-DEFINED VALUE OF PTBL31 RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CLOSES THE INPUT DATASET.\n***********************************************************************\n*\nCLOSE    CLOSE SYSIN               CLOSE INPUT DCB\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHANGES THE AMODE TO 31 AND PASSES CONTROL TO THE\n*    SUBROUTINE WHICH PUTS AN END-OF-TABLE INDICATOR AFTER THE LAST\n*    ENTRY OF THE TABLE.\n***********************************************************************\n*\nDOTBLEND L     R7,SETENDX          LOAD ADR OF 31-BIT AMODE RTN TO\n*                                  SET TBL-END INDICATOR\n         BASSM R8,R7               CHANGE AMODE TO 31, BRANCH AND LINK\n*                                  TO SETEND RTN\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE PUTS AN END-OF-TABLE INDICATOR AT THE LOGICAL\n*    END OF THE TABLE AND THEN CHANGES THE AMODE BACK TO 24.\n***********************************************************************\n*\nSETEND   L     R10,TBLPTR31        LOAD ADR OF NEXT TBL SLOT\n         MVC   0(L'TBLENDID,R10),TBLENDID     MOVE TBL-END IND INTO TBL\n         MVC   TBLPTR31,TBLADR31   SET TBL PTR TO BG\n         BSM   0,R8              CHANGE AMODE TO 24, RET TO CALLING RTN\nSETENDX  DC    A(A31+SETEND)       POINTER-DEFINED VALUE OF SETEND RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE PROCESSES THE DATA IN THE TABLE.\n***********************************************************************\n*\nPROCTBL  ...                       PROCESS DATA IN TABLE\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL TO MVS OR THE CALLING PROGRAM.\n***********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n***********************************************************************\n*    THE CONSTANTS AND WORK AREAS USED IN THIS PROGRAM.\n***********************************************************************\n*\nA31      EQU   X'80000000'         31-BIT AMODE INDICATOR\nENTLEN   EQU   80                  LENGTH OF ENTRIES PUT INTO TABLE\nTBLADR31 DS    F\nTBLPTR31 DS    F\nDATAADR  DS    F\nTBLENDID DC    4XL1'FF'            TBL-END INDICATOR\n*\n*\n***********************************************************************\n*    INPUT DCB\n***********************************************************************\n*\nSYSIN    DCB   DSORG=PS,MACRF=GL,LRECL=80,RECFM=FB,EODAD=DATAEND,      -\n               DDNAME=SYSIN\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE140901": {"ttr": 6660, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\xa3\\x01\\xa3\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 419, "newlines": 419, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.9.1\n*\n*\n* THE CALLING 31-BIT AMODE PROGRAM:\n*\n*\n         TITLE 'EXAMPLE OF A 31-BIT AMODE PROGRAM WHICH CALLS A 24-BIT -\n               AMODE PROGRAM TO PERFORM I/O'\n*\n*\n***********************************************************************\n*    THIS IS A 31-BIT AMODE PROGRAM WHICH PERFORMS I/O BY CALLING A\n*    24-BIT AMODE PROGRAM TO PERFORM THE ACTUAL I/O OPERATIONS.\n*    THE TWO PROGRAMS COMMUNICATE VIA A USER-DEFINED COMMUNICATIONS\n*    PARAMETER AREA (CPA) LOCATED BELOW THE 16 MB LINE. THIS PROGRAM\n*    PLACES THE FUNCTION-CODE OF THE DESIRED I/O OPERATION AND THE\n*    RECORD, IF APPLICABLE, INTO THE CPA AND CALLS THE I/O PROGRAM.\n***********************************************************************\n*\n*\nXAPROG01 CSECT\nXAPROG01 AMODE 31                  EXECUTES IN 31-BIT AMODE\nXAPROG01 RMODE ANY                 MAY RESIDE ANYWHERE IN VS\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROG\n         USING IOAREA,R1           DEF REG FOR PARM AREA DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,LOAD             LOAD I/O PROG\n         BAL   R6,GETMAIN          ALLO PARM AREA BELOW 16 MB LINE\n         BAL   R6,OPEN             REQ I/O PROG TO OPEN DCBS\nNEXTREC  BAL   R6,GETREC           REQ I/O PROG TO READ A RECORD\n         BAL   R6,UPDTREC          UPDATE RECORD\n         BAL   R6,PUTREC           REQ I/O PROG TO WRITE UPDATED REC\n         B     NEXTREC             READ NEXT RECORD\nDATAEND  BAL   R6,CLOSE            REQ I/O PROG TO CLOSE DCBS\n         B     RETURN              RETURN TO MVS OR CALLING PROGM\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE 24-BIT AMODE I/O PROGRAM AND SAVES THE\n*    POINTER-DEFINED VALUE RETURNED FROM THE LOAD MACRO.\n***********************************************************************\n*\nLOAD     LOAD  EP=IOPROG01\n         ST    R0,IOPGMEPA         SAVE POINTER-DEFINED VALUE\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE BELOW THE 16 MB LINE\n*    FOR THE COMMUNICATIONS PARAMETER AREA (CPA) FOR THE I/O PROGRAM.\n***********************************************************************\n*\nGETMAIN  GETMAIN RU,LV=84,LOC=BELOW\n         ST    R1,PARMADR          SAVE ADR OF VS FOR I/O PROG\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CALLS THE I/O PROGRAM AND REQUESTS AN OPEN OPERATION.\n*    THE I/O PROGRAM OPENS THE INPUT AND THE OUTPUT DCBS.\n***********************************************************************\n*\nOPEN     L     R1,PARMADR          LD PARM ADR FOR I/O PROG\n         MVI   IOFUNC,OPENIND      SET OPEN FUNC-CODE\n         L     R15,IOPGMEPA        LD PTR-DEF VALUE OF I/O PROG\n         BASSM R14,R15             CHANGE AMODE, BR AND LK TO I/O PROG\n         BAL   R7,CHECKRC          CHK RETURN CODE FORM I/O PROG\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CALLS THE I/O PROGRAM AND REQUESTS THAT A RECORD\n*    BE READ.\n***********************************************************************\n*\nGETREC   L     R1,PARMADR          LD PARM ADR FOR I/O PROG\n         MVI   IOFUNC,GETIND       SET GET FUNC-CODE\n         L     R15,IOPGMEPA        LD PTR-DEF VALUE OF I/O PROG\n         BASSM R14,R15             CHANGE AMODE, BR AND LK TO I/O PROG\n         BAL   R7,CHECKRC          CHK RETURN CODE FROM I/O PROG\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE UPDATES THE RECORD READ BY THE I/O PROGRAM.\n***********************************************************************\n*\nUPDTREC  ...                       UPDATE RECORD\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CALLS THE I/O PROGRAM AND REQUESTS THAT IT WRITE\n*    THE SPECIFIED RECORD (THE RECORD JUST UPDATED).\n***********************************************************************\n*\nPUTREC   L     R1,PARMADR          LD PARM ADR FOR I/O PROG\n         MVI   IOFUNC,PUTIND       SET PUT FUNC-CODE\n         L     R15,IOPGMEPA        LD PTR-DEF VALUE OF I/O PROG\n         BASSM R14,R15             CHANGE AMODE, BR AND LK TO I/O PROG\n         BAL   R7,CHECKRC          CHK RETURN CODE FROM I/O PROG\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CALLS THE I/O PROGRAM AND REQUESTS A CLOSE OPERATION.\n*    THE I/O PROGRAM CLOSES THE INPUT AND THE OUTPUT DCBS.\n***********************************************************************\n*\nCLOSE    L     R1,PARMADR          LD PARM ADR FOR I/O PROG\n         MVI   IOFUNC,CLOSEIND     SET CLOSE FUNC-CODE\n         L     R15,IOPGMEPA        LD PTR-DEF VALUE OF I/O PROG\n         BASSM R14,R15             CHANGE AMODE, BR AND LK TO I/O PROG\n         BAL   R7,CHECKRC          CHK RETURN CODE FROM I/O PROG\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE I/O COMPLETION INDICATOR RETURNED BY THE\n*    I/O PROGRAM.\n***********************************************************************\n*\nCHECKRC  L     R1,PARMADR          SET ADRBLTY FOR PARM DSECT\n         CLI   IORC,OKIND          CHK IF OPERATION WAS OK\n         BER   R7                  IF YES, RET TO CALLING RTN\n         CLI   IORC,EODIND         CHK IF END-OF-DATA\n         BE    DATAEND             IF YES, BR TO E-O-D RTN\n         CLI   IORC,OPNERIND       CHK IF OPEN ERROR\n         BE    OPENERR             IF YES, BR TO OPEN-ERROR RTN\n         CLI   IORC,IOERRIND       CHK IF I/O ERROR\n         BE    IOERR               IF YES, BR TO I/O-ERROR RTN\n         B     INVFUNC             IN NO, INVALID FUNC CODE SPECIFIED\n*\n*\n***********************************************************************\n*    THESE SUBROUTINES PROCESS THE VARIOUS ERROR INDICATIONS RETURNED\n*    BY THE I/O PROGRAM.\n***********************************************************************\n*\nOPENERR  ...                       OPEN ERROR\n*\nIOERR    ...                       I/O ERROR\n*\nINVFUNC  ...                       INV FUNC CODE SPECIFIED\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL TO MVS OR THE CALLING PROGRAM.\n***********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n***********************************************************************\n*    THE STORAGE AREAS USED IN THIS PROGRAM.\n***********************************************************************\n*\nIOPGMEPA DS    F\nPARMADR  DS    F\n*\n*\n***********************************************************************\n*    THE EQUS FOR THE FUNCTION CODES AND ERROR INDICATORS.\n***********************************************************************\n*\nOPENIND  EQU   01\nGETIND   EQU   02\nPUTIND   EQU   03\nCLOSEIND EQU   04\nOKIND    EQU   00\nEODIND   EQU   04\nOPNERIND EQU   08\nIOERRIND EQU   12\nINVIND   EQU   16\n*\n*\n***********************************************************************\n*    THIS DSECT IS USED TO MAP THE COMMUNICATIONS PARAMETER AREA.\n***********************************************************************\n*\nIOAREA   DSECT\nIOFUNC   DS    CL1                 SPECIFIED FUNC-CODE FOR REQ\nIORC     DS    CL1                 RC RETURNED FROM I/O PROG\n         DS    CL2\nIORECORD DS    CL80                RECORD RET FROM I/O PROG FOR GET\n*                                  RECORD PASSED TO I/O PROG FOR PUT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n*\n         END\n*\n*\n*\n*\n* THE CALLED 24-BIT AMODE I/O PROGRAM:\n*\n*\n         TITLE 'I/O PROGRAM FOR CALLING PROGRAM XAPROG01'\n*\n*\n***********************************************************************\n*    THIS 24-BIT AMODE PROGRAM PERFORMS THE I/O FOR THE CALLING 31-BIT\n*    AMODE PROGRAM XAPROG01. THE TWO PROGRAMS COMMUNICATE VIA A\n*    COMMUNICATIONS PARAMETER AREA (CPA) LOCATED BELOW THE 16 MB LINE.\n*    A FUNCTION-CODE IS RECEIVED FROM THE CALLING PROGRAM, VIA THE CPA,\n*    AND THIS PROGRAM PERFORMS THE REQUESTED OPERATION. THIS PROGRAM\n*    RETURNS THE RECORD, IF APPLICABLE, AND THE RETURN CODE, VIA THE\n*    CPA, TO THE CALLING PROGRAM.\n***********************************************************************\n*\n*\nIOPROG01 CSECT\nIOPROG01 AMODE 24                  AMODE=24 (DEFAULT) REQUIRED FOR I/O\nIOPROG01 RMODE 24                  RMODE=24 (DEFAULT) REQUIRED FOR I/O\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING IOAREA,R10          DEF REG FOR IOAREA DSECT\n         USING IHADCB,R11          DEF REG FOR DCB DSECT\n         LR    R10,R1              SET ADRBLTY FOR IOAREA DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,ROUTFUNC         PERFORM REQUESTED FUNC\n         B     RETURN              RETURN TO CALLING PROG\n*\n*\n***********************************************************************\n*    THE ROUTINE CHECKS THE FUNCTION-CODE RECEIVED FROM THE CALLING\n*    PROGRAM AND ROUTES CONTROL TO THE APPROPRIATE SUBROUTINE.\n***********************************************************************\n*\nROUTFUNC CLI   IOFUNC,OPENIND      CHK FOR OPEN REQ\n         BE    OPEN                IF YES, DO OPEN\n         CLI   IOFUNC,GETIND       CHK FOR GET REQ\n         BE    GETREC              IF YES, DO GET\n         CLI   IOFUNC,PUTIND       CHK FOR PUT REQ\n         BE    PUTREC              IF YES, DO PUT\n         CLI   IOFUNC,CLOSEIND     CHK FOR CLOSE REQ\n         BE    CLOSE               IF YES, DO CLOSE\n         MVI   IORC,INVIND         IF NO, IND INVALID FUNC-CODE\n         LA    R15,4               IND REQ WAS UNSUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE OPENS THE INPUT AND THE OUTPUT DCBS.\n***********************************************************************\n*\nOPEN     OPEN  (RECIN,,RECOUT,(OUTPUT))       OPEN DCBS\n         LA    R11,RECIN           SET DSECT ADRBLTY FOR INPUT DCB\n         TM    DCBOFLGS,DCBOFOPN   CHK IF OPEN OK\n         BNO   OPENERR             IF NO, IND IT\n         LA    R11,RECOUT          SET DSECT ADRBLTY FOR OUTPUT DCB\n         TM    DCBOFLGS,DCBOFOPN   CHK IF OPEN OK\n         BNO   OPENERR             IF NO, IND IT\n         MVI   IORC,OKIND          IF YES, IND OPEN OK\n         LA    R15,0               IND REQ WAS SUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\nOPENERR  MVI   IORC,OPNERIND       IND OPEN ERROR\n         LA    R15,4               IND REQ WAS UNSUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE PERFORMS A QSAM READ OF A RECORD AND RETURNS IT\n*    TO THE CALLING PROGRAM. IT ALSO RECEIVES CONTROL AT END-OF-DATA\n*    AND INDICATES THAT TO THE CALLING PROGRAM.\n***********************************************************************\n*\nGETREC   GET   RECIN,IORECORD      READ A RECORD\n         MVI   IORC,OKIND          IND GET OK\n         LA    R15,0               IND REQUEST WAS SUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\nDATAEND  MVI   IORC,EODIND         IND EOD\n         LA    R15,4               IND REQ WAS UNSUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE PERFORMS A QSAM WRITE OF THE RECORD RECEIVED FROM\n*    THE CALLING PROGRAM.\n***********************************************************************\n*\nPUTREC   PUT   RECOUT,IORECORD     WRITE A RECORD\n         MVI   IORC,OKIND          IND PUT OK\n         LA    R15,0               IND REQUEST WAS SUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CLOSES THE INPUT AND THE OUTPUT DCBS.\n***********************************************************************\n*\nCLOSE    CLOSE (RECIN,,RECOUT)     CLOSE DCBS\n         MVI   IORC,OKIND          IND CLOSE OK\n         LA    R15,0               IND REQUEST WAS SUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS IS THE I/O ERROR ANALYSIS ROUTINE DEFINED BY SYNAD AND\n*    RECEIVES CONTROL WHEN AN UNCORRECTABLE I/O ERROR OCCURS. IT USES\n*    THE SYNADAF MACRO TO ANALYZE THE I/O ERROR AND DISPLAYS VIA WTO\n*    THE ERROR MESSAGE GENERATED BY SYNADAF.\n***********************************************************************\n*\nIOERR    SYNADAF ACSMETH=QSAM      ALLO SA, ANALYZE I/O ERROR\n         MVI   IORC,IOERRIND       INDICATE I/O ERROR\n         MVC   IOERRMSG,50(R1)     EXTRACT I/O ERROR MSG FROM SYNADAF\n         SYNADRLS                  RELEASE SYNADAF SA AND MSG BUFFER\n         LA    R1,WTOLST           LD LIST-ADR FOR EXEC-FORM OF WTO\n         WTO   MF=(E,(R1))         ISSUE EXEC-FORM OF WTO\n         LA    R15,4               IND REQ WAS UNSUCCESSFUL\n         BR    R6                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND THE AMODE OF THE CALLING\n*    PROGRAM AND RETURNS CONTROL.\n***********************************************************************\n*\nRETURN   L     R13,4(0,R13)        RESTORE SA ADR OF CALLING PROG\n         L     R14,12(0,R13)       RESTORE REG 14 OF CALLING PROG\n         LM    R0,R12,20(R13)      RESTORE REGS 0-12 OF CALLING PROG\n         BSM   0,R14               CHANGE AMODE TO 31, RETURN TO\n*                                  CALLING PROG\n*\n***********************************************************************\n*    THE WTO-LIST FOR I/O ERROR MESSAGE RECEIVED FROM SYNADAF MACRO.\n***********************************************************************\n*\n         CNOP  0,4\nWTOLST   DC    AL2(WTOLSTX-WTOLST)\n         DC    X'8000'             INDICATE THAT DESC/ROUTCDE SPEC\nIOERRMSG DS    CL78\nWTOLSTX  EQU   *\n         DC    X'0000'             NO DESC\n         DC    X'0020'             ROUTCDE=11\n*\n*\n***********************************************************************\n*    THE INPUT AND THE OUTPUT DCBS.\n***********************************************************************\n*\nRECIN    DCB   DSORG=PS,MACRF=GM,LRECL=80,RECFM=FB,EODAD=DATAEND,      -\n               SYNAD=IOERR,DDNAME=RECINDD\nRECOUT   DCB   DSORG=PS,MACRF=PM,BLKSIZE=80,LRECL=80,RECFM=F,          -\n               SYNAD=IOERR,DDNAME=RECOUTDD\n*\n*\n***********************************************************************\n*    THE EQUS FOR THE FUNCTION CODES AND ERROR INDICATORS.\n***********************************************************************\n*\nOPENIND  EQU   01\nGETIND   EQU   02\nPUTIND   EQU   03\nCLOSEIND EQU   04\nOKIND    EQU   00\nEODIND   EQU   04\nOPNERIND EQU   08\nIOERRIND EQU   12\nINVIND   EQU   16\n*\n*\n***********************************************************************\n*    THE DSECTS USED BY THIS PROGRAM.\n***********************************************************************\n*\n***********************************************************************\n*        THE DSECT USED TO MAP THE COMMUNICATIONS PARAMETER AREA.\n***********************************************************************\n*\nIOAREA   DSECT\nIOFUNC   DS    CL1                 SPECIFIED FUNC-CODE FOR REQ\nIORC     DS    CL1                 RC RETURNED FROM I/O PROG\n         DS    CL2\nIORECORD DS    CL80                RECORD RET FROM I/O PROG FOR GET\n*                                  RECORD PASSED TO I/O PROG FOR PUT\n*\n*\n***********************************************************************\n*        THE DSECT TO MAP OUT THE DCBS.\n***********************************************************************\n*\n         PRINT NOGEN\n         DCBD  DSORG=PS\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE141001": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.10.1\n*\n*\n         PGSER R,LOAD,A=(R10),EA=(R11)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE141002": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 14.10.2\n*\n*\n         PGSER R,FIX,A=(R10),EA=(R11),ECB=FIXECB\n         ...\nFIXECB   DC    F'0'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150301": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\x96\\x01\\x96\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 406, "newlines": 406, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.3.1\n*\n*\nIGC0025C CSECT\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R              GENERATE EQU'S FOR REGS\n         USING *,R6                DEFINE BASE REG\n         USING CVT,R3              DEFINE REG FOR CVT DSECT\n         USING TCB,R4              DEFINE REG FOR TCB DSECT\n         USING SRB,R10             DEFINE REG FOR SRB DSECT\n         USING CSACOMAR,R11        DEFINE REG FOR CSACOMAR DSECT\n         USING WORKAREA,R12        DEFINE REG FOR WORKAREA DESCT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVREGS1         SAVE CONTENTS OF CONTROL REGS\n         BAL   R8,GETWKAR          ALLO WORKAREA FOR CALLING PROG\n         BAL   R8,GETCSA           ALLO CSA FOR WKAR AND SRB'S\n         BAL   R8,SAVEADRS         SAVE PROCESSING ADRS\n         BAL   R8,INITSRB1         SET UP SRB CONTROL BLOCK\n         BAL   R8,SCHDSRB1         SCHEDULE SRB IN TARGET A.S.\n         B     RETURN1             RETURN TO CALLING PROG VIA SVC FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVREGS1 LR    R2,R14              SAVE RETURN ADR\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES A WORKAREA FROM THIS ADDRESS SPACE FOR THE\n*    CALLING PROGRAM IN THE PSW STOR PROT KEY OF THE CALLING PROGRAM.\n***********************************************************************\n*\nGETWKAR  MODESET KEY=NZERO         SET PSW KEY TO THAT OF CALLER\n         GETMAIN RU,LV=WKARLEN,SP=0    ALLOC STOR FOR CALLER\n         LR    R12,R1              SET ADBLTY OF WKAR DSECT\n         ST    R12,WGMADR          SAVE WKAR ADR IN WORKAREA\n         MODESET KEY=ZERO          SET PSW KEY BACK TO ZERO\n         BR    R8                  RETURN TO CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE FROM FIXED, FETCH-PROTECTED\n*    CSA FOR USE BY THE SRB ROUTINES. THIS AREA IS USED TO CONTAIN THE\n*    SRB CONTROL BLOCK AND A WORKAREA. THE NAME OF THE DSECT FOR THE\n*    WORKAREA SECTION OF THIS STORAGE IS CALLED CSACOMAR.\n***********************************************************************\n*\nGETCSA   GETMAIN RU,LV=CSALEN,SP=227\n         LR    R10,R1              SET ADBLTY FOR SRB\n         LA    R11,SRBSIZE(0,R10)  SET ADBLTY FOR CSA WKAR\n         ST    R10,CCSAADR         SAVE ADR OF ALLO CSA\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE REQUIRED ADDRESSES FOR PROCESSING.\n***********************************************************************\n*\nSAVEADRS ST    R4,CTCB1ADR         SAVE ADR OF TCB OF ISSUING A.S.\n         ST    R7,CASCB1AD         SAVE ADR OF ASCB OF ISSUING A.S.\n         ST    R12,TCBUSER         SAVE ADR OF CALLER'S WKAR IN TCB\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SRB FOR THE SRB ROUTINE WHICH IS TO\n*    EXECUTE IN THE TARGET ADDRESS SPACE.\n***********************************************************************\n*\nINITSRB1 MVC   SRBID,SRB1          SET SRB ID\n         MVC   SRBCPAFF,BINONES    IND SRB OK TO EXEC IN ALL CPU'S\n         MVC   SRBPKF,BINZEROS     SET PSW KEY OF SRB RTN TO ZERO\n         MVC   SRBASCB,CVTUSER     SET ADR OF TARGET ASCB\n         LA    R5,DATASRB          LOAD EPA OF SRB ROUTINE\n         ST    R5,SRBEP            SET EPA OF SRB ROUTINE\n         LA    R5,DUMYRMTR         LOAD EPA OF DUMMY RECV RTN\n         ST    R5,SRBRMTR          SET ADR OF RECV RTN\n         ST    R11,SRBPARM         LOAD ADR OF CSA WKAR\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SCHEDULES THE SRB IN THE TARGET ADDRESS SPACE.\n***********************************************************************\n*\nSCHDSRB1 SCHEDULE SRB=(R10),SCOPE=LOCAL\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL TO THE CALLER VIA THE SVC FLIH.\n***********************************************************************\n*\nRETURN1  LR    R14,R2              RESTORE RETURN ADDRESS\n         LA    R15,0               SET RC=0\n         LR    R1,R12              RETURN ADR OF CALLER'S WKAR\n         BR    R14                 RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    DUMMY RECOVERY ROUTINE\n***********************************************************************\n*\nDUMYRMTR BR    R14\n*\n*\n***********************************************************************\n*    CONSTANTS\n***********************************************************************\n*\nBINZEROS DC    F'0'\nBINONES  DC    4XL1'FF'\nSRB1     DC    C'SRB1'           ID OF SRB WHICH EXEC IN TARGET A.S.\n*\n*\n         LTORG                   FORCE LITERALS TO ASM HERE FOR ADRBLTY\n         DROP                    RELEASE ALL REGS USED WITH USING STMTS\n*\n*\n*\n*\n***********************************************************************\n*    THE FOLLOWING CONTAINS THE CODE FOR THE SRB ROUTINE WHICH EXECUTES\n*    IN THE TARGET ADDRESS SPACE. ITS FUNCTIONS ARE THE FOLLOWING:\n*\n*        * MOVE THE DATA FROM THE TARGET A.S. TO THE CSA WKAR;\n*        * SCHEDULE AN SRB IN THE ORIGINATING A.S.\n*\n***********************************************************************\n*\n*\nDATASRB  DS    0H\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         USING *,R6                DEFINE BASE REG\n         USING SRB,R10             DEFINE REG FOR SRB DSECT\n         USING CSACOMAR,R11        DEFINE REG FOR CSACOMAR DSECT\n         LR    R6,R15              LOAD BASE REGISTER\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SRB ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVREGS2         SAVE CONTENTS OF CONTROL REGS\n         BAL   R8,GETJNAME         GET JOBNAME OF TARGET A.S.\n         BAL   R8,GETDATA          GET DATA FROM TARGET A.S.\n         BAL   R8,INITSRB2         INIT SRB FOR ORIG A.S.\n         BAL   R8,SCHDSRB2         SCHEDULE SRB FOR ORIG A.S.\n         B     RETURN2             RETURN TO DISPATCHER\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF THE CONTROL REGISTERS AND SETS\n*    ADDRESSABILITY FOR THE VARIOUS DSECTS.\n***********************************************************************\n*\nSAVEREG2 LR    R2,R14              SAVE RETURN ADDRESS\n         LR    R10,R0              SET ADBLTY FOR SRB DSECT\n         LR    R11,R1              SET ADBLTY FOR CSACOMAR DSECT\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE EXTRACTS THE JOBNAME ASSOCIATED WITH THE TARGET\n*    ADDRESS SPACE.\n***********************************************************************\n*\nGETJNAME L     R9,SRBASCB          LD ADR OF ASCB OF TARGET A.S.\n         L     R9,ASCBXTCB-ASCBEGIN(R9)     LOAD ADR OF TCB\n         L     R9,TCBTIO-TCB(R9)            LOAD ADR OF TIOT\n         MVC   CJOBNAME,0(R9)               MOVE JOBNAME INTO CSA WKAR\n         BR    R8                           RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE MOVES THE DATA FROM THE TARGET ADDRESS SPACE INTO THE\n*    CSA WORKAREA.\n***********************************************************************\n*\nGETDATA  L     R9,SRBASCB          LD ADR OF ASCB OF TARGET A.S.\n         L     R9,ASCBXTCB-ASCBEGIN(R9)     GET ADR OF TCB\n         L     R9,TCBUSER-TCB(R9)           GET ADR OF DATA BUFFER\n         MVC   CJOBDATA,0(R9)               MOVE DATA INTO CSA WKAR\n         BR    R8                           RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE SRB FOR THE SRB ROUTINE WHICH IS TO\n*    EXECUTE IN THE ORIGINATING ADDRESS SPACE. THE PREVIOUS SRB IS USED\n*    AND SELECTED FIELDS ARE UPDATED.\n***********************************************************************\n*\nINITSRB2 MVC   SRBID,SRB2          SET SRB ID\n         MVC   SRBASCB,CASCB1AD    SET ADR OF ORIG ASCB\n         LA    R5,POSTSRB          LD EPA OF SRB ROUTINE\n         ST    R5,SRBEP            SET EPA OF SRB ROUTINE\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SCHEDULES THE SRB IN THE ORIGINATING ADDRESS SPACE.\n***********************************************************************\n*\nSCHDSRB2 SCHEDULE SRB=(R10),SCOPE=LOCAL\n         BR    R8\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL TO THE DISPATCHER\n***********************************************************************\n*\nRETURN2  LR    R14,R2              RESTORE RETURN ADDRESS\n         LA    R15,0               SET RC=0\n         BR    R14                 RETURN CONTROL TO DISPATCHER\n*\n*\n***********************************************************************\n*    CONSTANTS\n***********************************************************************\n*\nSRB2     DC    C'SRB2'           ID OF SRB WHICH EXEC IN ORIG A.S.\n*\n*\n         LTORG                   FORCE LITERALS TO ASM HERE FOR ADRBLTY\n         DROP                    RELEASE ALL REGS USED WITH USING STMTS\n*\n*\n*\n*\n***********************************************************************\n*    THE FOLLOWING CONTAINS THE CODE FOR THE SRB ROUTINE WHICH EXECUTES\n*    IN THE ORIGINATING ADDRESS SPACE. ITS FUNCTIONS ARE THE FOLLOWING:\n*\n*        * MOVE THE DATA FROM THE CSA WKAR TO THE WKAR OF THE ORIG\n*          ADDRESS SPACE;\n*        * POST THE ECB TO INDICATE THAT THE DATA MOVEMENT IS COMPLETE;\n*        * RELEASE THE ALLOCATED CSA VIRTUAL STORAGE.\n*\n***********************************************************************\n*\n*\nPOSTSRB  DS    0H\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         USING *,R6                DEFINE BASE REGISTER\n         USING CVT,R3              DEFINE REG FOR CVT DSECT\n         USING TCB,R4              DEFINE REG FOR TCB DSECT\n         USING SRB,R10             DEFINE REG FOR SRB DSECT\n         USING CSACOMAR,R11        DEFINE REG FOR CSACOMAR DSECT\n         USING WORKAREA,R12        DEFINE REG FOR ORIG A.S. WKAR DSECT\n         LR    R6,R15              LOAD BASE REGISTER\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SRB ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVREGS3         SAVE CONTENTS OF CONTROL REGS\n         BAL   R8,LOADADRS         LOAD PROCESSING ADDRESSES\n         BAL   R8,MOVEINFO         MOVE INFO FROM CSA TO ORIG A.S.\n         BAL   R8,SETLLOCK         OBTAIN LOCAL LOCK FOR POST MACRO\n         BAL   R8,POSTAS1          POST ECB TO IND INFO MOVED\n         BAL   R8,RELLLOCK         RELEASE LOCAL LOCK\n         BAL   R8,FREECSA          RELEASE ALLO CSA STORAGE\n         B     RETURN3             RETURN TO DISPATCHER\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF THE CONTROL REGISTERS AND SETS\n*    ADDRESSABILITY FOR THE VARIOUS DSECTS.\n***********************************************************************\n*\nSAVREGS3 LR    R2,R14              SAVE RETURN ADDRESS\n         LR    R10,R0              SET ADBLTY FOR SRB DSECT\n         LR    R11,R1              SET ADBLTY FOR CSACOMAR DSECT\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE LOADS THE REQUIRED ADDRESSES FOR PROCESSING.\n***********************************************************************\n*\nLOADADRS L     R4,CTCB1ADR         SET ADBLTY FOR TCB DSECT\n         L     R12,TCBUSER         LD ADR FOR WKAR OF ORIG A.S.\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE MOVES THE JOBNAME AND DATA OF THE TARGET A.S. FROM\n*    THE CSA TO THE WORKAREA IN THE ORIGINATING A.S.\n***********************************************************************\n*\nMOVEINFO MVC   WJOBNAME,CJOBNAME       MOVE JOBNAME FROM CSA TO ORIG\n*                                      A.S.\n         MVC   WJOBDATA,CJOBDATA       MOVE DATA FROM CSA TO ORIG A.S.\n         BR    R8                      RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE LOCAL LOCK. THIS IS REQUIRED WHEN A\n*    BRANCH-ENTRY POST MACRO IS ISSUED.\n***********************************************************************\n*\nSETLLOCK SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE,               -\n               RELATED=(POSTAS1,RELLLOCK)\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE POSTS THE ECB LOCATED IN THE WKAR OF THE ORIGINATING\n*    A.S. TO INDICATE THAT THE DATA MOVEMENT FROM THE TARGET A.S. TO\n*    THE WORKAREA IN THE ORIGINATING A.S. VIA THE CSA IS COMPLETE.\n***********************************************************************\n*\nPOSTAS1  LA    R5,WECB             LOAD ADR OF ECB\n         POST  (R5),X'00',BRANCH=YES,RELATED=(WAIT-IN-ASCB1)\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RELEASES THE LOCAL LOCK.\n***********************************************************************\n*\nRELLLOCK SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,                          -\n               RELATED=(POSTAS1,SETLLOCK)\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RELEASES THE CSA STORAGE ALLOCATED BY THE SVC ROUTINE\n*    INVOKED BY THE ORIGINATING A.S.\n***********************************************************************\n*\nFREECSA  LA    R10,CCSAADR         LD ADR OF CSA POINTER\n         FREEMAIN RU,LV=CSALEN,SP=227,A=(R10)\n*        L     R3,16               LOAD ADR OF CVT\n*        XC    CVTUSER,CVTUSER     CLEAR CVTUSER TO IND DATA COPIED\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL TO THE DISPATCHER.\n***********************************************************************\n*\nRETURN3  LR    R14,R2              RESTORE RETURN ADDRESS\n         LA    R15,0               SET RC=0\n         BR    R14                 RETURN CONTROL TO DISPATCHER\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\nWORKAREA DSECT\nWGMADR   DS    F\nWECB     DS    F\nWJOBNAME DS    CL8\nWJOBDATA DS    CL100\nWKARLEN  EQU   *-WORKAREA\n*\nCSACOMAR DSECT\nCCSAADR  DS    F\nCTCB1ADR DS    F\nCASCB1AD DS    F\nCJOBNAME DS    CL8\nCJOBDATA DS    CL100\nCOMARLEN EQU   *-CSACOMAR\n*\nCSALEN   EQU   COMARLEN+SRBSIZE\n*\n         PRINT NOGEN\n         IHAASCB                  GENERATES ASCB DSECT\n         IHASRB                   GENERATES SRB DSECT\n         CVT   DSECT=YES          GENERATES CVT DSECT\n         IHAPSA                   GENERATES PSA DSECT (REQD BY SETLOCK)\n         IKJTCB                   GENERATES TCB DSECT\n*\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150302": {"ttr": 6920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xcd\\x00\\xcd\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 205, "newlines": 205, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.3.2\n*\n*\nAS1PROG  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING CVT,R10             DEFINE REG FOR CVT DSECT\n         USING WORKAREA,R12        DEFINE REG FOR WORKAREA DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\nGETDATA  BAL   R6,CHKDATA          CHECK IF ANY A.S. HAS DATA TO SEND\n         BAL   R6,SCHLDSRB         IF YES, SCHEDULE AN SRB\n         BAL   R6,PROCESS          PROCESS DATA FROM SRB + NORM PROC\n         BAL   R6,FREEMAIN         RELEASE WORKAREA ALLO BY SVC\n         B     GETDATA             GET MORE DATA FROM ANY A.S.\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE CVTUSER FIELD TO DETERMINE IF ANY ADDRESS\n*    SPACES HAVE DATA TO SEND TO THIS ADDRESS SPACE. IF THERE ARE NONE,\n*    THEN THIS ROUTINE PERFORMS A CYCLE OF NORMAL PROCESSING AND THEN\n*    CHECKS THE CVTUSER FIELD AGAIN. WHEN THE CVTUSER INDICATES THAT AN\n*    ADDRESS SPACE HAS DATA TO SEND, THIS ROUTINE TURNS ON DATASW AND\n*    RETURNS CONTROL TO THE CALLING ROUTINE.\n***********************************************************************\n*\nCHKDATA  BAL   R7,ENQ              SERIALIZE ACCESS TO CVTUSER\n         L     R10,16              LOAD ADR OF CVT\n         CLC   CVTUSER,BINZEROS    CHECK IF CVTUSER HAS ADR OF A.S.\n         BE    NODATA              IF NO, NO DATA TO BE RECEIVED\n         MVI   DATASW,C'1'         IF YES, TURN ON DATASW\n         BAL   R7,DEQ              RELEASE CVTUSER ENQ\n         BR    R6                  RETURN TO CALLING ROUTINE\nNODATA   MVI   DATASW,C'0'         IND NO DATA TO BE RECEIVED\n         BAL   R7,DEQ              RELEASE CVTUSER ENQ\n         WTO   '*** NO DATA ***'   *** FOR INITIAL TESTING ONLY ***\n         ABEND 901                 *** FOR INITIAL TESTING ONLY ***\n         BAL   R7,PROCESS1         DO A CYCLE OF NORM PROC\n         B     CHKDATA             CHK AGAIN IF ANY A.S. HAVE DATA\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES AN EXCLUSIVE ENQ TO SERIALIZE THE ACCESS\n*    TO CVTUSER.\n***********************************************************************\n*\nENQ      ENQ   (QNAME,RNAME,E,,SYSTEM)     DO ENQ\n         BR    R7                          RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES A DEQ TO RELEASE EXCLUSIVE ACCESS TO\n*    CVTUSER.\n***********************************************************************\n*\nDEQ      DEQ   (QNAME,RNAME,,SYSTEM)       DO DEQ\n         BR    R7                          RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS DATASW. IF THE SWITCH IS ON, THEN THE\n*    APPROPRIATE SVC ROUTINE IS INVOKED TO SCHEDULE AN SRB IN THE\n*    ADDRESS SPACE WHOSE ASCB ADDRESS IS STORED IN CVTUSER.\n***********************************************************************\n*\nSCHLDSRB SVC   253                 IF YES, ISSUE SVC TO SCHEDULE SRB\n         LR    R12,R1              SET ADBLTY FOR WORKAREA ALLO BY SVC\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE PERIODICALLY CHECKS IF ANY OUTSTANDING SRBS HAVE\n*    COMPLETED MOVING THE DATA FROM ANOTHER ADDRESS SPACE TO THIS ONE.\n*    NORMAL PROGRAM PROCESSING IS PERFORMED BETWEEN CHECKS.\n***********************************************************************\n*\nPROCESS  BAL   R7,CHKSRB           CHECK IF DATA MOVEMENT COMPLETE\n         BAL   R7,PROCESS1         DO A CYCLE OF NORM PROC\n         CLI   DATASW,C'1'         CHECK IF SRB OUTSTANDING\n         BE    PROCESS             IF YES, CHECK AGAIN FOR COMPLETION\n         BR    R6                  IF NO, RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CHECKS DATASW. IF THE SWITCH IS ON, THEN THE ECB\n*    IS CHECKED TO DETERMINE IF THE DATA MOVEMENT FROM THE TARGET\n*    ADDRESS SPACE TO THIS ADDRESS SPACE HAS BEEN COMPLETED.\n***********************************************************************\n*\nCHKSRB   TM    WECB,X'40'          IF YES, CHK ECB FOR COMPLETION\n         BO    PROCDATA            IF COMPLETE, PROCESS DATA FROM\n*                                  OTHER A.S.\n         BR    R7                  IF NOT, RET TO CALLING ROUTINE\nPROCDATA MVI   DATASW,C'0'         TURN OFF OUTSTANDING SRB SWITCH\n         BAL   R8,PROCESS2         PROC DATA RECEIVED FROM OTHER A.S.\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SIMULATES PROGRAM PROCESSING BY GOING INTO A\n*    FINITE I/O LOOP.\n***********************************************************************\n*\nPROCESS1 LA    R10,10\nOPEN     OPEN  (DCB,(OUTPUT))\n         PUT   DCB,RECORD\n         CLOSE DCB\n         BCT   R10,OPEN\n         BR    R7\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE PROCESSES THE DATA RECEIVED FROM THE OTHER ADDRESS\n*    SPACE. DURING TESTING, THIS ROUTINE DISPLAYS THE JOBNAME OF THE\n*    OTHER ADDRESS SPACE AND THE FIRST 8 BYTES OF THE DATA RECEIVED.\n***********************************************************************\n*\nPROCESS2 MVC   WTOJBNM,WJOBNAME    MOVE JOBNAME INTO WTO-LIST\n         MVC   WTODATA,WDATA       MOVE FIRST 8 BYTES OF DATA RECEIVED\n         LA    R1,WTOLST1          LD ADR OF WTO-LIST\n         WTO   MF=(E,(R1))         ISSUE EXEC-FORM OF WTO\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RELEASES THE WORKAREA ALLOCATED BY THE SVC ROUTINE.\n***********************************************************************\n*\nFREEMAIN LA    R10,WGMADR          LOAD ADR OF GETMAIN AREA POINTER\n         FREEMAIN EU,LV=WKARLEN,A=(R10)\n         ABEND 902                 *** FOR INITIAL TESTING ONLY ***\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL TO MVS OR\n*    THE CALLING PROGRAM\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE WTO-LIST FOR THE EXECUTE FORM OF THE WTO MACRO\n***********************************************************************\n*\n         DS    0F\nWTOLST1  DC    AL2(WTOLST1X-WTOLST1)\n         DC    H'0'\n         DC    C'*** JOBNAME: '\nWTOJBNM  DS    CL8\n         DC    C'  DATA: '\nWTODATA  DS    CL8\nWTOLST1X EQU   *\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nBINZEROS DC    F'0'\nDATASW   DC    C'0'\nQNAME    DC    CL8'USER'\nRNAME    DC    C'CVTUSER'\n*\n*\n***********************************************************************\n*    DATA RECORD AND DCB USED TO SIMULATE PROCESSING\n***********************************************************************\n*\nRECORD   DC    80CL1'A'\nDCB      DCB   DSORG=PS,MACRF=PM,BLKSIZE=80,LRECL=80,RECFM=F,          -\n               DDNAME=WORK\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\nWORKAREA DSECT\nWGMADR   DS    F\nWECB     DS    F\nWJOBNAME DS    CL8\nWDATA    DS    CL100\nWKARLEN  EQU   *-WORKAREA\n*\n         PRINT NOGEN\n         CVT   DSECT=YES           GENERATES THE CVT DSECT\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150303": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xf3\\x00\\xf3\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 243, "newlines": 243, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.3.3\n*\n*\n*\n*\n***********************************************************************\n***********************************************************************\n* THE CODE FOR THE SVC (254) ROUTINE\n***********************************************************************\n***********************************************************************\n*\n*\nIGC0025D CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R              GENERATE EQU'S FOR REGS\n         USING *,R6                DEFINE BASE REGISTER\n         USING CVT,R3              DEFINE REG FOR CVT DSECT\n         USING TCB,R4              DEFINE REG FOR TCB DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R8,SAVEREGS         SAVE CONTENTS OF CONTROL REGS\n         BAL   R8,SETASCB          PUT ASCB ADR INTO CVTUSER\n         BAL   R8,SETTCBU          PUT BUFFER ADR INTO TCBUSER\n         B     RETURN              RETURN TO CALLING PROG VIA SVC FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS LR    R2,R14              SAVE RETURN ADDRESS\n         LR    R11,R1              SAVE BUFFER ADDRESS\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE CVTUSER FIELD OF THE CVT. IF IT CONTAINS\n*    ZEROS, THEN THE ADDRESS OF THE ASCB, WHICH HAS DATA TO SEND, IS\n*    STORED. IF THE CVTUSER CONTAINS NONZEROS, THEN NO PROCESSING IS\n*    DONE AND RC=4 IS RETUNED TO THE CALLING PROGRAM.\n***********************************************************************\n*\nSETASCB  BAL   R9,ENQ              SERIALIZE ACCESS TO CVTUSER\n*        CLC   CVTUSER,BINZEROS    CHECK IF CVTUSER AVAILABLE\n*        BNE   INUSE               IF NO, INDICATE IN-USE\n         ST    R7,CVTUSER          IF YES, SET ASCB ADR IN CVTUSER\n         BAL   R9,DEQ              RELEASE CVTUSER ENQ\n         LA    R15,0               INDICATE ASCB ADR SET\n         BR    R8                  RETURN TO CALLING ROUTINE\nINUSE    BAL   R9,DEQ              RELEASE CVTUSER ENQ\n         LA    15,4                IND CVTUSER HAS OUTSTANDING REQUEST\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES AN EXCLUSIVE ENQ TO SERIALIZE THE ACCESS\n*    TO CVTUSER.\n***********************************************************************\n*\nENQ      ENQ   (QNAME,RNAME,E,,SYSTEM)\n         BR    R9                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE ISSUES A DEQ TO RELEASE EXCLUSIVE ACCESS TO\n*    CVTUSER.\n***********************************************************************\n*\nDEQ      DEQ   (QNAME,RNAME,,SYSTEM)\n         BR    R9                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE STORES THE BUFFER ADRRESS SPECIFIED BY THE CALLER\n*    INTO THE TCBUSER FIELD OF THE TCB IF THE ASCB ADDRESS WAS SET.\n***********************************************************************\n*\nSETTCBU  LTR   R15,R15             CHK IF ASCB ADR SET\n         BNZR  R8                  IF NO, RET TO CALLING ROUTINE\n         ST    R11,TCBUSER         IF YES, STORE BUFF ADR INTO TCBUSER\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL TO THE CALLER VIA THE SVC FLIH.\n***********************************************************************\n*\nRETURN   LR    R14,R2              RESTORE RETURN ADDRESS\n         BR    R14                 RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    THE CONSTANTS\n***********************************************************************\n*\nBINZEROS DC    F'0'\nQNAME    DC    CL8'USER'\nRNAME    DC    C'CVTUSER'\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\n         CVT   DSECT=YES           GENERATES CVT DSECT\n         IKJTCB                    GENERATES TCB DSECT\n*\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n***********************************************************************\n***********************************************************************\n* THE CODE FOR THE PROBLEM PROGRAM THAT EXECUTES IN THE TARGET\n* ADDRESS SPACE\n***********************************************************************\n***********************************************************************\n*\n*\nAS2PROG  CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,GETMAIN         ALLO STOR FOR DATA TO SEND\n         BAL   R6,GETDATA         OBTAIN DATA FOR OTHER A.S.\n         BAL   R6,MOVEDATA        MOVE DATA INTO GM STOR FOR OTHER A.S.\n         BAL   R6,SETADRS         SET UP ADRS FOR SRB COMMUNICATION\n         BAL   R6,PROCESS         PERFORM NORMAL PROG PROCESSING\n         B     RETURN             RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES VIRTUAL STORAGE WHICH IS TO CONTAIN THE\n*    DATA WHICH IS TO BE SENT TO THE OTHER ADDRESS SPACE.\n***********************************************************************\n*\nGETMAIN  GETMAIN EU,LV=BUFFLEN,A=BUFFADR\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE DATA WHICH IS TO BE SENT TO THE OTHER\n*    ADDRESS SPACE.\n***********************************************************************\n*\nGETDATA  DS    0H\n         ...                       OBTAIN DATA\n         BR    R6\n*\n*\n***********************************************************************\n*    THIS ROUTINE MOVES THE DATA, WHICH IS TO BE SENT TO THE OTHER\n*    ADDRESS SPACE, INTO THE BUFFER WHICH WILL BE POINTED TO BY\n*    TCBUSER.\n***********************************************************************\n*\nMOVEDATA L     R10,BUFFADR                LD ADR OF BUFFER\n         MVC   0(BUFFLEN,R10),BUFFDATA    MOVE DATA INTO BUFFER\n         BR    R6                         RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE SVC ROUTINE WHICH COMMUNICATES WITH THE\n*    SRB ROUTINE BY PUTTING THE ADDRESS OF THE ASCB OF THIS ADDRESS\n*    SPACE INTO CVTUSER AND BY PUTTING THE ADDRESS OF THE DATA BUFFER\n*    INTO TCBUSER.\n***********************************************************************\n*\nSETADRS  L     R1,BUFFADR             LD BUFFER ADR FOR SVC\n         SVC   254                    ISSUE SVC TO COMM WITH OTHER A.S.\n         BR    R6                     RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SIMULATES PROCESSING OF THIS ADDRESS SPACE WHILE THE\n*    SRBS ARE SCHEDULED AND COPY THE DATA FROM THIS ADDRESS SPACE TO\n*    THE ORIGINATING ADDRESS SPACE.\n***********************************************************************\n*\nPROCESS  OPEN  (DCB,(OUTPUT))\n         PUT   DCB,RECORD\n         CLOSE DCB\n         B     PROCESS\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE RESISTERS AND RETURNS CONTROL TO MVS OR\n*    THE CALLING PROGRAM\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE DC/DS STATEMENTS\n***********************************************************************\n*\nBUFFADR  DS    F\nBUFFDATA DC    100CL1'D'           TEST DATA TO SEND TO OTHER A.S.\nBUFFLEN  EQU   *-BUFFDATA\n*\n*\n***********************************************************************\n*    THE RECORD AND THE DCB USED FOR THE I/O LOOP FOR TESTING\n***********************************************************************\n*\nRECORD   DC    80CL1'A'\nDCB      DCB   DSORG=PS,MACRF=PM,BLKSIZE=80,LRECL=80,RECFM=F,          -\n               DDNAME=WORK\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150401": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.1\n*\n*\n****************************************************\n* THE CODE FOR THE SERVICE PROVIDER'S ADDRESS SPACE\n****************************************************\n*\n         AXRES AXLIST=AXLIST       REQUEST TO RESERVE AN AX FOR SP-AS\n         AXSET AX=AXVALUE          SET NEW AX VALUE FOR SP-AS\n         ...\nAXLIST   DS    0F\nAXCOUNT  DC    H'1'                RESERVE ONE AX\nAXVALUE  DS    H                   VALUE OF RESERVED AX\n*\n*\n****************************************************\n* THE CODE FOR THE USER'S ADDRESS SPACE\n****************************************************\n*\n          ATSET AX=AXVALUE,PT=YES,SSAR=YES    PROV SP-AS WITH ACCESS\n*                                             TO U-AS\n          ...\nAXVALUE   DS    H\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150402": {"ttr": 7176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.2\n*\n*\n         LXRES LXLIST=LXLIST       REQUEST TO RESERVE AN LX FOR SP-AS\n         ...\nLXLIST   DS    0F\nLXCOUNT  DC    F'1'                RESERVE ONE LX\nLXVALUE  DS    F                   VALUE OF RESERVED LX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150403": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00B\\x00B\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.3\n*\n*\nBLDETBL  BAL   R8,SETET01          SET UP ENTRY TABLE PARAMETER-LIST\n         ETCRE ENTRIES=ET01PGMS    CREATE ENTRY TABLE\n         ST    R0,ET01TKEN         SAVE RETURNED TOKEN\n         BR    R7                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CREATES THE EX=0 AND THE EX=1 ENTRIES IN THE ENTRY\n*    TABLE PARAMETER-LIST WHICH DEFINES THE PROGRAMS SERV01 AND SERV02.\n***********************************************************************\n*\n         USING ETD,R10             DEFINE REG FOR ENT-TBL HEADER DSECT\nSETET01  LA    R10,ETDHDR          POINT TO AREA FOR ENT-TBL HDR\n         MVC   ETDNUM,=H'2'        IND 2 PGMS ARE DEFINED IN PARM-LIST\n*\n         DROP  R10                 RELEASE REG 10 FOR REUSE\n         USING ETDELE,R10          DEFINE REG FOR E.T. ELEMENT DSECT\n*\n*  DEFINITION FOR PC ROUTINE SERV01\n*\n         LA    R10,ET01S01         POINT TO PARM AREA FOR SERV-PROG-1\n         MVI   ETDEX,X'00'         INDICATE EX=0\n         OI    ETDFLG,ETDSUP+ETDXM   IND SUPV MODE AND ADR SPACE SWITCH\n         MVC   ETDAKM,=X'FFFF'     IND CALLING PGM CAN HAVE ANY KEY\n         MVC   ETDEKM,=X'8000'     IND PC RTN CAN ACCESS STORAGE WHICH\n*                                  HAS KEY 0 AND CALLING PROG KEYS\n         MVC   ETDPAR,=C'OPT2'     SPECIFY PARM TO BE PASSED TO SERV01\n         XC    ETDPRO1,ETDPRO1     ZERO FIELD TO IND EPA SPECIFIED\n         MVC   ETDPRO2,EPAPC01     LOAD EPA OF SERV-PGM-1\n*\n*  DEFINITION FOR PC ROUTINE SERV02\n*\n         LA    R10,ETD01S02        POINT TO PARM AREA FOR SERV-PROG-2\n         MVI   ETDEX,X'01'         INDICATE EX=1\n         OI    ETDFLG,ETDSUP+ETDXM   IND SUPV MODE AND ADR SPACE SWITCH\n         MVC   ETDAKM,=X'8080'     IND CALLING PGM MUST HAVE KEY 0 OR 8\n         MVC   ETDEKM,=X'FFFF'     IND PC RTN CAN ACCESS STORAGE WHICH\n*                                  HAS ANY KEY\n         MVC   ETDPAR,=C'SW=5'     SPECIFY PARM TO BE PASSED TO SERV02\n         MVC   ETDPRO1(8),=CL8'SERV02'     MOVE NAME OF SERV-PGM-2\n*\n         BR    R8                  RETURN TO CALLING RTN\n*\n*\n***********************************************************************\n*    THE AREA FOR THE ENTRY TABLE AND THE SAVE AREA FOR THE RETURNED\n*    TOKEN FROM THE ETCRE MACRO\n***********************************************************************\n*\nET01PGMS DS    0F\nETD01HDR DS    CL(ETDLEN)          ENTRY TABLE HEADER\nETD01S01 DS    CL(ETDELEN)         EX=0 ENTRY FOR PGM SERV01\nETD01S02 DS    CL(ETDELEN)         EX=1 ENTRY FOR PGM SERV02\n*\nET01TKEN DS    F\n*\n*\n***********************************************************************\n*    THE DSECTS FOR THE ENTRY TABLE\n***********************************************************************\n*\n         IHAETD                    GENERATES DSECTS FOR ENTRY TABLE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150404": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.4\n*\n*\n         ETCON LXLIST=LXLIST,TKLIST=ET01LIST\n         ...\nLXLIST   DS    0F\nLXCOUNT  DS    F'1'                NUMB OF LX'S IN LIST\nLXVALUE  DS    F                   LX VALUE RESERVED BY SP-AS\n*\nET01LIST DS    0F\nET01CNT  DC    F'1'                NUMB OF ENT-TBL TOKENS IN LIST\nET01TKEN DS    F                   TOKEN OF ENTRY TABLE OF SP-AS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150405": {"ttr": 7182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.5\n*\n*\nPROVSERV LA    R2,1                            LOAD 1 FOR AXSET MACRO\n         AXSET AX=(R2)                     ASSIGN AX VALUE OF 1 TO SELF\n         LXRES LXLIST=LXLIST,SYSTEM=YES        RESERVE A SYSTEM LX\n         ETCON LXLIST=LXLIST,TKLIST=ET01LIST   CONNECT ET TO SYSTEM LT\n         BR    R7                              RETURN TO CALLING RTN\n         ...\nLXLIST   DS    0F\nLXCOUNT  DS    F'1'                NUMB OF LX'S IN LIST\nLXVALUE  DS    F                   SYS LX VALUE RESERVED BY SP-AS\n*\nET01LIST DS    0F\nET01CNT  DC    F'1'                NUMB OF ENT-TBL TOKENS IN LIST\nET01TKEN DS    F                   TOKEN OF ENTRY TABLE OF SP-AS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150406": {"ttr": 7184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.6\n*\n*\n         ATSET AX=AXVALUE,PT=NO,SSAR=NO    RELEASE ACCESS FROM SP-AS\n         ETDIS TKLIST=ET01TKEN             DISCONNECT ENTRY TABLE\n*                                          FROM LINKAGE TABLE\n         ...\nET01LIST DS    0F\nET01CNT  DC    F'1'                NUMB OF ENT-TBL TOKENS IN LIST\nET01TKEN DS    F                   TOKEN OF ENTRY TABLE OF SP-AS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150407": {"ttr": 7186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.7\n*\n*\nREMOVEXM BAL   R7,DESTRYET         DESTROY ENTRY TABLE\n         BAL   R7,FREELX           RELEASE RESERVED LX\n         BAL   R7,RSETAUTH         RESET ORIG AX VALUE AND REL RESV AX\n         BR    R6                  RETURN TO CALLING ROUTINE\n         ...\nDESTRYET ETDES TOKEN=ET01TKEN,PURGE=YES    DESTROY/PURGE ENTRY TBL\n         BR    R7                          RETURN TO CALLING ROUTINE\n*\nFREELX   LXFRE LXLIST=LXLIST       RELEASE RESERVED LX BACK TO MVS\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\nRSETAUTH LA    R10,0               LD ZERO FOR AXSET MACRO\n         AXSET AX=(R10)            RESET AX VALUE BACK TO ZERO\n         AXFRE AXLIST=AXLIST       RELEASE RESERVED AX BACK TO MVS\n         BR    R7                  RETURN TO CALLING ROUTINE\n         ...\nAXLIST   DS    0F\nAXCOUNT  DC    H'1'                NUMB OF AX'S IN LIST\nAXVALUE  DS    H                   VALUE OF RESERVED AX\n*\nLXLIST   DS    0F\nLXCOUNT  DS    F'1'                NUMB OF LX'S IN LIST\nLXVALUE  DS    F                   SYS LX VALUE RESERVED BY SP-AS\n*\nET01LIST DS    0F\nET01CNT  DC    F'1'                NUMB OF ENT-TBL TOKENS IN LIST\nET01TKEN DS    F                   TOKEN OF ENTRY TABLE OF SP-AS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150408": {"ttr": 7188, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.8\n*\n*\n         L     R2,LXVALUE          LOAD LX VALUE\n         IC    R2,EXVALUE          INSERT EX VALUE INTO LAST BYTE\n         PC    0(R2)               ISSUE PC INSTRUCTION\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150409": {"ttr": 7190, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\x8d\\x01\\x8d\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 397, "newlines": 397, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE 15.4.9\n*\n*\nSRVPROV1 CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING CVT,R10             DEFINE REG FOR CVT DESCT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETMODE          SET PROG INTO SUPV STATE, KEY ZERO\n         BAL   R6,GETCSA           ALLO CSA FOR STORING CONTROL INFO\n         BAL   R6,SETUPXM          SET UP CROSS MEMORY ENVIR\n         BAL   R6,PUTCSA           PUT CONTROL INFO INTO CSA FOR U-AS\n         BAL   R6,PROCESS          PERFORM MAIN PROC OF PROG\n         BAL   R6,REMOVEXM         REMOVE CROSS MEMORY ENVIR\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS THE PROGRAM INTO SUPERVISOR STATE AND PSW\n*    STORAGE PROTECTION KEY ZERO VIA THE MODESET MACRO. THIS IS\n*    REQUIRED TO ISSUE THE CROSS-MEMORY MACROS AND TO MODIFY THE\n*    CVTUSER FIELD OF THE CVT.\n***********************************************************************\n*\nSETMODE  MODESET MODE=SUP,KEY=ZERO\n         BR    R6                  RETURN TO CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES FIXED, FETCH-PROTECTED CSA VIRTUAL STORAGE\n*    AND PLACES THE ADDRESS IN CVTUSER. THIS STORAGE IS USED TO CONTAIN\n*    A COPY OF THE AX-LIST, LX-LIST, ENTRY TABLE TOKEN-LIST AND TO\n*    CONTAIN THE CREATION OF THE SERVICE-ID/PC NUMBER CROSS-REFERENCE\n*    TABLE.\n***********************************************************************\n*\nGETCSA   GETMAIN EU,LV=CSALEN,SP=227,A=CSAADR\n         L     R10,16              LOAD ADR OF CVT\n         MVC   CVTUSER,CSAADR      PUT CSA ADR INTO CVTUSER\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE CROSS-MEMORY ENVIRONMENT.\n***********************************************************************\n*\nSETUPXM  BAL   R7,SETAUTH          RESERVE AN AX AND ASSIGN IT TO SELF\n         BAL   R7,GETLX            RESERVE AN LX\n         BAL   R7,BLDETBL          CREATE ENTRY TABLE\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RESERVES AN AX VALUE AND ASSIGNS IT TO THIS A.S.\n***********************************************************************\n*\nSETAUTH  AXRES AXLIST=AXLIST       RESERVE AN AX VALUE\n         AXSET AX=AXVALUE          ASSIGN AX VALUE TO SELF\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RESERVES AN LX VALUE FROM A NONSYSTEM LINKAGE\n*    TABLE.\n***********************************************************************\n*\nGETLX    LXRES LXLIST=LXLIST       RESERVE AN LX VALUE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CREATES THE ENTRY TABLE TO DESCRIBE THE PC\n*    ROUTINES CONTAINED IN THIS PROGRAM.\n***********************************************************************\n*\nBLDETBL  BAL   R8,SETETBL          BUILT PARM-LIST FOR ETCRE MACRO\n         ETCRE ENTRIES=PCRTNS      CREATE ENTRY TABLE\n         ST    R0,ETTOKEN          SAVE TOKEN OF ENTRY TABLE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE PARAMETER-LIST USED BY THE ETCRE MACRO\n*    TO CREATE THE ENTRY TABLE.\n***********************************************************************\n*\n         DROP  R10                 REL REG FOR REUSE\n         USING ETD,R10             DEFINE REG FOR ENT-TBL HDR DSECT\n*\n*\n* ENTRY TABLE HEADER\n*\nSETETBL  LA    R10,ETDHDR          POINT TO AREA FOR ENT-TBL HDR\n         MVC   ETDNUM,=H'2'        IND 2 PGMS ARE DEFINED IN PARM-LIST\n         DROP  R10                 REL REG FOR REUSE\n         USING ETDELE,R10          DEFINE REG FOR E.T. ELEMENT DSECT\n*\n*\n* DEFINITION FOR SERVICE-1\n*\n         LA    R10,ETDSERV1        POINT TO PARM AREA FOR SERV-PROG-1\n         MVI   ETDEX,X'00'         INDICATE EX=0\n         OI    ETDFLG,ETDSUP+ETDXM   IND SUPV MODE AND ADR SPACE SWITCH\n         MVC   ETDAKM,=X'FFFF'     IND CALLING PROG CAN HAVE ANY KEY\n         MVC   ETDEKM,=X'8000'     IND PC RTN CAN ACCESS STORAGE WHICH\n*                                  HAS KEY 0 OR CALLING PROG KEYS\n         MVC   ETDPAR,=4XL1'11'    ENTRY PARM\n         XC    ETDPRO1,ETDPRO1     ZERO FIELD TO IND EPA SPECIFIED\n         MVC   ETDPRO2,=A(PCSERV01)     LOAD EPA OF PC ROUTINE\n*\n*\n* DEFINITION FOR SERVICE-2\n*\n         LA    R10,ETDSERV2        POINT TO PARM AREA FOR SERV-PROG-2\n         MVI   ETDEX,X'01'         INDICATE EX=1\n         OI    ETDFLG,ETDSUP+ETDXM   IND SUPV MODE AND ADR SPACE SWITCH\n         MVC   ETDAKM,=X'8080'    IND CALLING PROG CAN HAVE KEY 0 AND 8\n         MVC   ETDEKM,=X'FFFF'     IND PC RTN CAN ACCESS STORAGE WHICH\n*                                  HAS ANY KEY\n         MVC   ETDPAR,=4XL1'22'    ENTRY PARM\n         XC    ETDPRO1,ETDPRO1     ZERO FIELD TO IND EPA SPECIFIED\n         MVC   ETDPRO2,=A(PCSERV02)     LOAD EPA OF PC ROUTINE\n         BR    R8                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS CONTROL INFORMATION INTO THE CSA FOR USE BY THE\n*    USER ADDRESS SPACES WHICH ARE REQUIRED TO CALL THE PC ROUTINES\n*    CONTAINED IN THIS PROGRAM.\n***********************************************************************\n*\n         DROP  R10                 REL REG FOR REUSE\n         USING CSAMAP,R10          DEFINE REG FOR CSAMAP DSECT\nPUTCSA   L     R10,CSAADR          LD ADR OF ALLO CSA\n         BAL   R7,PUTLISTS         COPY CONTROL LISTS INTO CSA\n         BAL   R7,PUTXTBL          CREATE CROSS-REF TBL IN CSA\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE COPIES THE AX-LIST, LX-LIST AND THE ENTRY TABLE\n*    TOKEN-LIST INTO THE CSA FOR USE BY THE USER ADDRESS SPACES WHICH\n*    ARE REQUIRED TO CALL THE PC ROUTINES.\n***********************************************************************\n*\nPUTLISTS MVC   $AXCOUNT,AXCOUNT\n         MVC   $AXVALUE,AXVALUE\n         MVC   $LXCOUNT,LXCOUNT\n         MVC   $LXVALUE,LXVALUE\n         MVC   $ETCOUNT,ETCOUNT\n         MVC   $ETTOKEN,ETTOKEN\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CREATES IN THE CSA THE CROSS-REFERENCE TABLE\n*    EQUATING THE SERVICE-IDS TO THE CORRESPONDING PC NUMBERS OF THE\n*    PC ROUTINES. THIS TABLE IS USED BY THE USER ADDRESS SPACES WHICH\n*    ARE REQUIRED TO CALL THE PC ROUTINES.\n***********************************************************************\n*\n*\n* FOR SERVICE ID=1\n*\nPUTXTBL  XC    $SRV01ID,$SRV01ID   ZERO SERVICE ID\n         MVI   $SRV01ID+3,X'01'    SET SERVICE ID=1\n         MVC   $PCNUM01,LXVALUE    SET LX VALUE PART OF PC NUMB\n         MVI   $PCNUM01+3,X'00'    SET EX VALUE PART OF PC NUMB\n*\n*\n* FOR SERVICE ID=2\n*\n         XC    $SRV02ID,$SRV02ID   ZERO SERVICE ID\n         MVI   $SRV02ID+3,X'02'    SET SERVICE ID=2\n         MVC   $PCNUM02,LXVALUE    SET LX VALUE PART OF PC NUMB\n         MVI   $PCNUM02+3,X'01'    SET EX VALUE PART OF PC NUMB\n*\n*\n* END-OF-TABLE\n*\n*\n         MVC   $XREFEND,BINONES    INDICATE END OF CROSS-REF TBL\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE IS USED FOR TESTING ONLY. IT SIMULATES ADDRESS SPACE\n*    PROCESSING UNTIL THE ACTUAL PROCESSING ROUTINE IS WRITTEN.\n***********************************************************************\n*\nPROCESS  OPEN  (DCB,(OUTPUT))\n         PUT   DCB,RECORD\n         CLOSE DCB\n         B     PROCESS\n*\n*\n***********************************************************************\n*    THIS ROUTINE REMOVES THE CROSS-MEMORY ENVIRONMENT.\n***********************************************************************\n*\n         DROP  R10                 REL REG FOR REUSE\n         USING CVT,R10             DEFINE REG FOR CVT DSECT\nREMOVEXM L     R10,16              LOAD ADR OF CVT\n         XC    CVTUSER,CVTUSER     CLEAR CVTUSER\n         BAL   R7,DESTRYET         DESTROY/PURGE ENTRY TABLE\n         BAL   R7,FREELX           RELEASE RESERVED LX VALUE\n         BAL   R7,RSETAUTH         RESET ORIG AX VALUE AND REL RESV AX\n         BAL   R7,FREECSA          RELEASE ALLO CSA\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE DESTROYS THE ENTRY TABLE AND USES THE PURGE OPTION\n*    IN CASE THE USER ADDRESS SPACE HAS NOT DISCONNECTED IT FROM ITS\n*    LINKAGE TABLE.\n***********************************************************************\n*\nDESTRYET ETDES TOKEN=ETTOKEN,PURGE=YES    DESTROY/PURGE ENTRY TABLE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RELEASES THE RESERVED LX VALUE.\n***********************************************************************\n*\nFREELX   LXFRE LXLIST=LXLIST       RELEASE RESERVED LX VALUE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RESETS THE AX VALUE OF THE ADDRESS SPACE BACK TO\n*    ITS ORIGINAL VALUE AND RELEASES THE RESERVED AX VALUE.\n***********************************************************************\n*\nRSETAUTH LA    R10,0               LD ZERO FOR AXSET MACRO\n         AXSET AX=(R10)            RESET AX VALUE BACK TO ORIG ZERO\n         AXFRE AXLIST=AXLIST       RELEASE RESERVED AX VALUE\n         BR   R7                   RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RELEASES THE CSA STORAGE.\n***********************************************************************\n*\nFREECSA  FREEMAIN EU,LV=CSALEN,SP=227,A=CSAADR\n         BR    R7\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL TO MVS\n*    OR THE CALLING PROGRAM\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE DC/DS STATEMENTS\n***********************************************************************\n*\nCSAADR   DS    F\nBINONES  DC    4XL1'FF'\n*\n***********************************************************************\n*    THE AUTHORIZATION-VALUE (AX) LIST\n***********************************************************************\n*\nAXLIST   DS    0F\nAXCOUNT  DC    H'1'\nAXVALUE  DS    H\n*\n*\n***********************************************************************\n*    THE LINKAGE-VALUE (LX) LIST\n***********************************************************************\n*\nLXLIST   DS    0F\nLXCOUNT  DC    F'1'\nLXVALUE  DS    F\n*\n*\n***********************************************************************\n*    THE ENTRY-TABLE TOKEN LIST\n***********************************************************************\n*\nETLIST   DS    0F\nETCOUNT  DC    F'1'\nETTOKEN  DS    F\n*\n*\n***********************************************************************\n*    THE AREAS USED TO CREATE THE ENTRY TABLE PARAMETER-LIST\n***********************************************************************\n*\nPCRTNS   DS    0F\nETDHDR   DS    CL(ETDLEN)\nETDSERV1 DS    CL(ETDELEN)\nETDSERV2 DS    CL(ETDELEN)\n*\n*\n***********************************************************************\n*    THE RECORD AND THE DCB USED FOR THE I/O LOOP FOR TESTING\n***********************************************************************\n*\nRECORD   DC    80CL1'A'\nDCB      DCB   DSORG=PS,MACRF=PM,BLKSIZE=80,LRECL=80,RECFM=F,          -\n               DDNAME=WORK\n*\n*\n*\n*\n***********************************************************************\n***********************************************************************\n*    THE CODE FOR THE PCSERV01 PC ROUTINE\n***********************************************************************\n***********************************************************************\n*\n*\nPCSERV01 PCLINK STACK,SAVE=NO      SAVE STATUS\n         L     R1,0(0,R4)          LD PARM FROM E.T. INTO REG 1\n         PCLINK UNSTACK,THRU=(R14),SAVE=NO      RESTORE STATUS\n         PT    R3,R14              RETURN TO CALLER AND RESTORE STATE\n*\n*\n*\n*\n***********************************************************************\n***********************************************************************\n*    THE CODE FOR THE PCSERV02 PC ROUTINE\n***********************************************************************\n***********************************************************************\n*\n*\nPCSERV02 PCLINK STACK,SAVE=NO      SAVE STATUS\n         L     R1,0(0,R4)          LD PARM FROM E.T. INTO REG 1\n         PCLINK UNSTACK,THRU=(R14),SAVE=NO      RESTORE STATUS\n         PT    R3,R14              RETURN TO CALLER AND RESTORE STATE\n*\n*\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\nCSAMAP   DSECT\n*\n* AX-LIST IN CSA\n*\n$AXLIST  DS    0F\n$AXCOUNT DS    H\n$AXVALUE DS    H\n*\n* LX-LIST IN CSA\n*\n$LXLIST  DS    0F\n$LXCOUNT DS    F\n$LXVALUE DS    F\n*\n* ENTRY TABLE TOKEN-LIST IN CSA\n*\n$ETLIST  DS    0F\n$ETCOUNT DS    F\n$ETTOKEN DS    F\n*\n* SERVICE ID/PC NUMBER CROSS-REFERENCE TABLE IN CSA\n*\n$XREFTBL DS    0F\n$SRV01ID DS    F\n$PCNUM01 DS    F\n$SRV02ID DS    F\n$PCNUM02 DS    F\n$XREFEND DS    F\n*\nCSALEN   EQU   *-CSAMAP\n*\n         CVT  DSECT=YES        GENERATES THE CVT DSECT\n*\n         IHAETD                GENERATES THE ENTRY TABLE DSECTS\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150410": {"ttr": 7431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01.\\x01.\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 302, "newlines": 302, "modlines": 0, "user": "CARMINE"}, "text": "*\nCODING EXAMPLE 15.4.10\n*\n*\n*\n*\n***********************************************************************\n***********************************************************************\n* THE CODE FOR THE SVC (255) ROUTINE\n***********************************************************************\n***********************************************************************\n*\n*\nIGC0025E CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         REGEQU EQU=R              GENERATE EQU'S FOR REGS\n         USING *,R6                DEFINE BASE REGISTER\n         USING CVT,R3              DEFINE REG FOR CVT DSECT\n         USING CSAMAP,R10          DEFINE REG FOR CSAMAP DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF SVC ROUTINE\n***********************************************************************\n*\n         BAL   R7,SAVEREGS         SAVE CONTENTS OF CONTROL REGS\n         BAL   R7,GETPARMS         GET ADR OF CONTROL INFO IN CSA\n         BAL   R7,SETAUTH          SET AUTH FOR SP-AS\n         BAL   R7,CONNECT          CONNECT ENTRY TBL TO LINKAGE TBL\n         BAL   R7,GETPCNUM         FIND PC NUMB FOR SPEC SERV-ID\n         BAL   R7,DOPC             SAVE STATUS, ISSUE PC\n         B     RETURN              RETURN TO CALLING PROG VIA SVC FLIH\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS LR    R2,R14             SAVE RETURN ADDRESS\n         LR    R5,R0              SAVE SPECIFIED SERVICE-ID\n         LR    R8,R1              SAVE PARM REG 1\n         LR    R9,R15             SAVE PARM REG 15\n         BR    R7                 RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE ALLO CSA AREA WHICH\n*    CONTAINS THE AX-LIST, LX-LIST, ENTRY TABLE TOKEN-LIST AND THE\n*    SERVICE ID/PC NUMBER CROSS-REFERENCE TABLE.\n***********************************************************************\n*\nGETPARMS L     R10,CVTUSER         LD CSA ADR FORM CVTUSER\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE SERVICE-ID. IF ID=0 IS SPECIFIED, THEN\n*    THIS ROUTINE PROVIDES THE SP-AS WITH ACCESS TO THE U-AS.\n***********************************************************************\n*\nSETAUTH  LTR   R5,R5               CHK IF SP-AS ACCESS REQUESTED\n         BNZR  R7                  IF NO, RETURN TO CALLING RTN\n         LH    R11,$AXVALUE             LD AX OF SP-AS FOR ATSET MACRO\n         ATSET AX=(R11),PT=YES,SSAR=YES   SET AUTH FOR SP-AS\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE SPECIFIED SERVICE-ID. IF ID=0 IS\n*    SPECIFIED, THEN THIS ROUTINE CONNECTS THE ENTRY TABLE OF THE\n*    SP-AS TO THE LINKAGE TABLE OF THE U-AS.\n***********************************************************************\n*\nCONNECT  LTR   R5,R5              CHK IF CONNECTION REQUESTED\n         BNZR  R7                 IF NO, RETURN TO CALLING ROUTINE\n         LA    R11,$LXLIST        LD ADR OF LX-LIST FROM CSA\n         LA    R12,$ETLIST        LD ADR OF ET TOKEN-LIST FROM CSA\n         ETCON LXLIST=(R11),TKLIST=(R12)    CONNECT ET TO LT\n         BR    R7                 RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE SPECIFIED SERVICE-ID. IF THE ID IS NOT\n*    EQUAL TO ZERO, THEN THIS ROUTINE SCANS THE SERVICE ID/PC NUMBER\n*    CROSS-REFERENCE TABLE IN THE CSA TO OBTAIN THE REQUIRED PC NUMBER.\n*    IF THE SERVICE-ID CANNOT BE FOUND IN THE TABLE, THEN RC=4 IS SET\n*    IN REG 15. IF SERVICE-ID IS FOUND, THEN RC=0 IS SET IN REG 15 AND\n*    REG 10 POINTS TO THE PC NUMBER.\n***********************************************************************\n*\nGETPCNUM LTR   R5,R5               CHECK IF SPECIFIED SERV ID=0\n         BZR   R7                  IF YES, RET TO CALLING ROUTINE\n         LA    R10,$XREFTBL        LD ADR OF SERV-ID/PC-NUMB X-REF TBL\nNEXTSERV CLC   0(4,R10),BINONES    CHK IF END-OF-TBL\n         BE    INVPCNUM            IF YES, INV SERV-ID SPECIFIED\n         C     R5,0(R10)           COMP SPECIFIED SERV-ID WITH SERV-ID\n*                                  IN TBL\n         BE    SETPCNUM            IF EQUAL, GET CORRESPD PC NUMB\n         LA    R10,8(0,R10)        IF NOT, INCR TO NEXT ENTRY IN TBL\n         B     NEXTSERV            CHECK NEXT ENTRY\nSETPCNUM LA    R10,4(0,R10)        INCR PAST SERV-ID TO PC NUMB\n         LA    R15,0               IND PC NUMB FOUND\n         BR    R7                  RETURN TO CALLING ROUTINE\nINVPCNUM LA    R15,255             IND INVALID SERV-ID SPECIFIED\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE CHECKS THE SPECIFIED SERVICE-ID. IF THE ID IS NOT\n*    EQUAL TO ZERO, THEN THIS ROUTINE SAVES THE REGISTERS AND THE SASID\n*    AND THEN ISSUES THE PC INSTRUCTION TO CALL THE REQUESTED PC\n*    ROUTINE.\n***********************************************************************\n*\nDOPC     LTR   R5,R5               CHECK IF SPECIFIED SERV ID=0\n         BZR   R7                  IF YES, RET TO CALLING ROUTINE\n         LTR   R15,R15             CHECK IF VALID SERV-ID SPECIFIED\n         BNZR  R7                  IF NO, RET TO CALLING ROUTINE\n         STM   R2,R12,28(R13)      SAVE REGS 2-12 IN CALLERS S.A.\n         ESAR  R2                  OBTAIN SASID\n         ST    R2,16(0,R13)        SAVE SASID\n         L     R2,0(0,R10)         LOAD PC NUMBER\n         LR    R1,R8               RESTORE PARM REG 1\n         LR    R15,R9              RESTORE PARM REG 15\n         PC    0(R2)               ISSUE PC INSTR\n         L     R2,16(0,R13)        LOAD SASID\n         SSAR  R2                  RESET SECONDARY A.S.\n         LM    R2,R12,28(R13)      RESTORE REGS 2-12\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RETURNS CONTROL TO THE CALLING PROGRAM VIA THE SVC\n*    FLIH. THE PARAMETER REGISTERS 1 AND 15 AS SET BY THE PC ROUTINE\n*    ARE RETURNED TO THE CALLING PROGRAM.\n***********************************************************************\n*\nRETURN   LR    R14,R2              RESTORE THE RETURN ADDRESS\n         BR    R14                 RETURN TO CALLING PROG VIA FLIH\n*\n*\n***********************************************************************\n*    CONSTANTS\n***********************************************************************\n*\n         DS    0F\nBINONES  DC    4XL1'FF'\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\nCSAMAP   DSECT\n*\n*\n* AX-LIST IN CSA\n*\n$AXLIST  DS    0F\n$AXCOUNT DS    H\n$AXVALUE DS    H\n*\n*\n* LX-LIST IN CSA\n*\n$LXLIST  DS    0F\n$LXCOUNT DS    F\n$LXVALUE DS    F\n*\n*\n* ENTRY TABLE TOKEN-LIST IN CSA\n*\n$ETLIST  DS    0F\n$ETCOUNT DS    F\n$ETTOKEN DS    F\n*\n*\n* SERVICE ID/PC NUMBER CROSS-REFERENCE TABLE IN CSA\n*\n$XREFTBL DS    0F\n$SRV01ID DS    F\n$PCNUM01 DS    F\n$SRV02ID DS    F\n$PCNUM02 DS    F\n$XREFEND DS    F\n*\nCSALEN   EQU   *-CSAMAP\n*\n         CVT   DSECT=YES\n*\n*\n***********************************************************************\n*    END OF SVC ROUTINE\n***********************************************************************\n*\n         END\n*\n*\n*\n*\n***********************************************************************\n***********************************************************************\n* THE CODE FOR THE PROBLEM PROGRAM\n***********************************************************************\n***********************************************************************\n*\n*\nUSER01   CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETUP            SET UP AUTH AND LINKAGE FOR SP-AS\n         BAL   R6,CALLSRV1         CALL SERVICE ID-1\n         BAL   R6,CALLSRV2         CALL SERVICE ID-2\n         BAL   R6,CHKDATA          DUMP RETURNED DATA TO VERIFY\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE APPROPRIATE SVC ROUTINE AND REQUESTS THAT\n*    IT SET UP THE AUTHORIZATION AND LINKAGE FOR ACCESS TO/FROM THE\n*    SP-AS.\n***********************************************************************\n*\nSETUP    LA    R0,0                REQUEST AUTH/LINKAGE FOR SP-AS\n         SVC   255                 ISSUE SVC TO SET UP AUTH/LINKAGE\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE APPROPRIATE SVC ROUTINE AND REQUESTS\n*    THAT IT FIND THE CORRESPONDING PC NUMBER FOR SERVICE-ID=1 AND\n*    THEN CALL THAT PC ROUTINE.\n***********************************************************************\n*\nCALLSRV1 LA    R0,1                REQUEST CALL TO SERVICE ID-1\n         SVC   255                 ISSUE SVC TO SAVE STATUS AND TO\n*                                  CALL PC RTN\n         ST    R1,SRV1DATA         SAVE RETURNED DATA\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE APPROPRIATE SVC ROUTINE AND REQUESTS THAT\n*    IT FIND THE CORRESPONDING PC NUMBER FOR SERVICE-ID=2 AND THEN\n*    CALL THAT PC ROUTINE.\n***********************************************************************\n*\nCALLSRV2 LA    R0,2                REQUEST CALL TO SERVICE ID-2\n         SVC   255                 ISSUE SVC TO SAVE STATUS AND TO\n*                                  CALL PC RTN\n         ST    R1,SRV2DATA         SAVE RETURNED DATA\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE IS USED DURING TESTING ONLY. IT DUMPS THE RETURNED\n*    DATA FROM THE TWO CALLED PC ROUTINES.\n***********************************************************************\n*\nCHKDATA  L    R8,SRV1DATA          LD RETURNED DATA FROM SERV ID-1\n         L    R9,SRV2DATA          LD RETURNED DATA FROM SERV ID-2\n         ABEND 901,DUMP            DUMP RETURNED DATA\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL TO MVS OR\n*    THE CALLING PROGRAM.\n***********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n***********************************************************************\n*    THE DC/DS STATEMENTS\n***********************************************************************\n*\nSRV1DATA DS    F\nSRV2DATA DS    F\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150411": {"ttr": 7683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\xf5\\x01\\xf5\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 501, "newlines": 501, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.11\n*\n*\nSRVPROV2 CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n         USING CVT,R10             DEFINE REG FOR CVT DSECT\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETMODE          SET PROG INTO SUPV STATE, KEY ZERO\n         BAL   R6,GETCSA           ALLO CSA FOR STORING CONTROL INFO\n         BAL   R6,SETUPXM          SET UP CROSS MEMORY ENVIR\n         BAL   R6,PUTCSA           PUT CONTROL INFO INTO CSA FOR U-AS\n         BAL   R6,PROCESS          PERFORM MAIN PROCESSING OF PROG\n         BAL   R6,REMOVEXM         REMOVE CROSS MEMORY ENVIR\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS THE PROGRAM INTO SUPERVISOR STATE AND PSW\n*    KEY ZERO VIA THE MODESET MACRO. THIS IS REQUIRED TO ISSUE THE\n*    CROSS-MEMORY MACROS AND TO MODIFY THE CVTUSER FIELD OF THE CVT.\n***********************************************************************\n*\nSETMODE  MODESET MODE=SUP,KEY=ZERO\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE ALLOCATES FIXED, FETCH-PROTECTED CSA STORAGE AND\n*    PLACES THE ADDRESS IN CVTUSER. THIS STORAGE IS USED TO CONTAIN A\n*    COPY OF THE AX-LIST, LX-LIST, ENTRY TABLE TOKEN-LIST AND TO\n*    CONTAIN THE CREATION OF THE SERVICE-ID/PC NUMBER CROSS-REFERENCE\n*    TABLE.\n***********************************************************************\n*\nGETCSA   GETMAIN EU,LV=CSALEN,SP=227,A=CSAADR\n         L     R10,16              LOAD ADR OF CVT\n         MVC   CVTUSER,CSAADR      PUT CSA ADR IN CVTUSER\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SETS UP THE CROSS-MEMORY ENVIRONMENT.\n***********************************************************************\n*\nSETUPXM  BAL   R7,SETAUTH           RESERVE AN AX AND ASSIGN IT TO SELF\n         BAL   R7,GETLX             RESERVE AN LX\n         BAL   R7,BLDETBL           CREATE ENTRY TABLE\n         BR    R6                   RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RESERVES AN AX VALUE AND ASSIGNS IT TO THIS A.S.\n***********************************************************************\n*\nSETAUTH  AXRES AXLIST=AXLIST       RESERVE AN AX VALUE\n         AXSET AX=AXVALUE          ASSIGN THAT AX TO SELF\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RESERVES AN LX VALUE FROM A NON-SYSTEM LINKAGE\n*    TABLE.\n***********************************************************************\n*\nGETLX    LXRES LXLIST=LXLIST       RESERVE AN LX VALUE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CREATES THE ENTRY TABLE TO DESCRIBE THE PC ROUTINE\n*    CONTAINED IN THIS PROGRAM.\n***********************************************************************\n*\nBLDETBL  BAL   R8,SETETBL          BUILD PARM-LIST FOR ETCRE MACRO\n         ETCRE ENTRIES=PCRTNS      CREATE ENTRY TABLE\n         ST    R0,ETTOKEN          SAVE TOKEN OF ENTRY TABLE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE SETS UP THE PARAMETER-LIST USED BY THE ETCRE MACRO\n*    TO CREATE THE ENTRY TABLE.\n***********************************************************************\n*\n         DROP  R10                 RELEASE REG FOR REUSE\n         USING ETD,R10             DEFINE REG FOR ENT-TBL HDR DSECT\n*\n*\n* ENTRY TABLE HEADER\n*\nSETETBL  LA    R10,ETDHDR          POINT TO AREA FOR ENT-TBL HDR\n         MVC   ETDNUM,=H'1'        INDICATE ONE PC ROUTINE IS DEFINED\n         DROP  R10                 REL REG FOR REUSE\n         USING ETDELE,R10          DEFINE REG FOR E.T. ELEMENT DSECT\n*\n*\n* DEFINITION FOR SERVICE PROGRAM\n*\n         LA    R10,ETDSERV1        POINT TO PARM AREA FOR SERV-PROG\n         MVI   ETDEX,X'00'         INDICATE EX=0\n         OI    ETDFLG,ETDSUP+ETDXM    IND SUPV MODE AND ADR SPACE SWITCH\n         MVC   ETDAKM,=X'FFFF'     IND CALLING PROG CAN HAVE ANY KEY\n         MVC   ETDEKM,=X'8000'     IND PC RTN CAN ACCESS STORAGE WHICH\n*                                  HAS KEY 0 OR CALLING PROG KEYS\n         XC    ETDPRO1,ETDPRO1     ZERO FIELD TO IND EPA SPECIFIED\n         MVC   ETDPRO2,=A(PCSERV03)     LOAD EPA OF PC ROUTINE\n         BR    R8                  RETURN TO CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE PUTS CONTROL INFORMATION INTO THE CSA FOR USE BY THE\n*    USER ADDRESS SPACES WHICH ARE REQUIRED TO CALL THE PC ROUTINE\n*    CONTAINED IN THIS PROGRAM.\n***********************************************************************\n*\n         DROP  R10                 RELEASE REG FOR REUSE\n         USING CSAMAP,R10          DEFINE REG FOR CSAMAP DSECT\nPUTCSA   L     R10,CSAADR          LD ADR OF ALLO CSA\n         BAL   R7,PUTLISTS         COPY CONTROL LISTS INTO CSA\n         BAL   R7,PUTXTBL          CREATE CROSS-REF TBL IN CSA\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE COPIES THE AX-LIST, LX-LIST AND THE ENTRY TABLE\n*    TOKEN-LIST INTO THE CSA FOR USE BY THE USER ADDRESS SPACES WHICH\n*    ARE REQUIRED TO CALL THE PC ROUTINE.\n***********************************************************************\n*\nPUTLISTS MVC   $AXCOUNT,AXCOUNT\n         MVC   $AXVALUE,AXVALUE\n         MVC   $LXCOUNT,LXCOUNT\n         MVC   $LXVALUE,LXVALUE\n         MVC   $ETCOUNT,ETCOUNT\n         MVC   $ETTOKEN,ETTOKEN\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE CREATES IN THE CSA THE CROSS-REFERENCE TABLE\n*    EQUATING THE SERVICE-IDS TO THE CORRESPONDING PC NUMBERS OF THE PC\n*    ROUTINES. THIS TABLE IS USED BY THE USER ADDRESS SPACES WHICH\n*    ARE REQUIRED TO CALL THE PC ROUTINE.\n***********************************************************************\n*\nPUTXTBL  XC    $SRV01ID,$SRV01ID   ZERO SERVICE ID\n         MVI   $SRV01ID+3,X'03'    SET SERVICE ID=3\n         MVC   $PCNUM01,LXVALUE    SET LX VALUE PART OF PC NUMB\n         MVI   $PCNUM01+3,X'00'    SET EX VALUE PART OF PC NUMB\n         MVC   $XREFEND,BINONES    INDICATE END OF CROSS-REF TBL\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE IS USED FOR TESTING ONLY. IT SIMULATES ADDRESS SPACE\n*    PROCESSING UNTIL THE ACTUAL PROCESSING ROUTINE IS WRITTEN.\n***********************************************************************\n*\nPROCESS  OPEN  (DCB,(OUTPUT))\n         PUT   DCB,RECORD\n         CLOSE DCB\n         B     PROCESS\n*\n*\n***********************************************************************\n*    THIS ROUTINE REMOVES THE CROSS-MEMORY ENVIRONMENT.\n***********************************************************************\n*\n         DROP  R10                 RELEASE REG FOR REUSE\n         USING CVT,R10             DEFINE REG FOR CVT DSECT\nREMOVEXM L     R10,16              LOAD ADR OF CVT\n         XC    CVTUSER,CVTUSER     CLEAR CVTUSER\n         BAL   R7,DESTRYET         DESTROY/PURGE ENTRY TABLE\n         BAL   R7,FREELX           RELEASE RESERVED LX VALUE\n         BAL   R7,RSETAUTH         RESET ORIG AX VALUE AND REL RESV AX\n         BAL   R7,FREECSA          RELEASE ALLOC CSA\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE DESTROYS THE ENTRY TABLE AND USES THE PURGE OPTION\n*    IN CASE THE USER ADDRESS SPACE HAS NOT DISCONNECTED IT FROM ITS\n*    LINKAGE TABLE.\n***********************************************************************\n*\nDESTRYET ETDES TOKEN=ETTOKEN,PURGE=YES    DESTROY/PURGE ENTRY TABLE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RELEASES THE RESERVED LX VALUE.\n***********************************************************************\n*\nFREELX   LXFRE LXLIST=LXLIST       RELEASE RESERVED LX VALUE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RESETS THE AX VALUE OF THE ADDRESS SPACE BACK TO\n*    ITS ORIGINAL VALUE AND RELEASES THE RESERVED AX VALUE.\n***********************************************************************\n*\nRSETAUTH LA    R10,0\n         AXSET AX=(R10)\n         AXFRE AXLIST=AXLIST\n         BR    R7\n*\n*\n***********************************************************************\n*    THIS SUBROUTINE RELEASES THE CSA STORAGE.\n***********************************************************************\n*\nFREECSA  FREEMAIN EU,LV=CSALEN,SP=227,A=CSAADR\n         BR    R7\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL TO MVS OR\n*    THE CALLING PROGRAM.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE DC/DS STATEMENTS\n***********************************************************************\n*\nBINONES  DC    4XL1'FF'\nCSAADR   DS    F\n*\n*\n***********************************************************************\n*    THE AUTHORIZATION-VALUE (AX) LIST\n***********************************************************************\n*\nAXLIST   DS    0F\nAXCOUNT  DC    H'1'\nAXVALUE  DS    H\n*\n*\n***********************************************************************\n*    THE LINKAGE-VALUE (LX) LIST\n***********************************************************************\n*\nLXLIST   DS    0F\nLXCOUNT  DC    F'1'\nLXVALUE  DS    F\n*\n*\n***********************************************************************\n*    THE ENTRY-TABLE TOKEN LIST\n***********************************************************************\n*\nETLIST   DS    0F\nETCOUNT  DC    F'1'\nETTOKEN  DS    F\n*\n*\n***********************************************************************\n*    THE AREAS USED TO CREATE THE ENTRY TABLE PARAMETER-LIST\n***********************************************************************\n*\nPCRTNS   DS    0F\nETDHDR   DS    CL(ETDLEN)\nETDSERV1 DS    CL(ETDELEN)\n*\n*\n***********************************************************************\n*    THE RECORD AND DCB USED FOR THE I/O LOOP FOR TESTING\n***********************************************************************\n*\nRECORD   DC    80CL1'A'\nDCB      DCB   DSORG=PS,MACRF=PM,BLKSIZE=80,LRECL=80,RECFM=F,          -\n               DDNAME=WORK\n*\n*\n*\n*\n***********************************************************************\n***********************************************************************\n*    THE CODE FOR THE PCSERV03 PC ROUTINE\n***********************************************************************\n***********************************************************************\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         DROP R3                   RELEASE REG FOR REUSE\nPCSERV03 PCLINK STACK,SAVE=NO      SAVE STATUS OF CALLING PROG\n         BALR  R3,0                LOAD BASE REGISTER\n         USING *,R3                DEFINE BASE REGISTER\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PC ROUTINE\n***********************************************************************\n*\n         BAL   R6,SAVEREGS         SAVE CONTENTS OF CONTROL REGS\n         BAL   R6,GETPASCB         GET ADR OF ASCB OF PASID\n         BAL   R6,SETCMLOK         OBTAIN CML LOCK\n         BAL   R6,GETKEY           GET KEY FROM U-AS\n         BAL   R6,FINDDATA         GET CORRESPD DATA FROM TBL IN SP-AS\n         BAL   R6,MOVEDATA         MOVE DATA TO U-AS\n         BAL   R6,RELCMLOK         RELEASE CML LOCK\n         B     RETCALL             RETURN TO CALLING PROG IN U-AS\n*\n*\n***********************************************************************\n*    THIS ROUTINE SAVES THE CONTENTS OF ALL REGISTERS WHICH CONTAIN\n*    CONTROL INFORMATION.\n***********************************************************************\n*\nSAVEREGS ST    R14,SAVR14          SAVE STACK-ENTRY ADR\n         ST    R1,SKEYADR          SAVE ADR OF KEY IN U-AS\n         ST    R15,SBUFFADR        SAVE ADR OF REVC BUFF IN U-AS\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE ADDRESS OF THE ASCB FOR THE PRIMARY\n*    ADDRESS SPACE.\n***********************************************************************\n*\nGETPASCB EPAR  R1                  LD REG 1 WITH PASID\n         LOCASCB ASID=(R1)         GET ASCB ADR OF PASID\n         ST    R1,PASCBADR         SAVE ADR OF ASCB OF PRIM A.S.\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE OBTAINS THE CML LOCK TO MAKE THE U-AS NONSWAPPABLE\n*    DURING THE SYNCHRONOUS COMMUNICATION AND TO SERIALIZE THE USE OF\n*    THE PC ROUTINES IN THIS ADDRESS SPACE.\n***********************************************************************\n*\nSETCMLOK LA    R1,0                LD ZERO FOR SPKA INSTR\n         SPKA  0(R1)               SET PSW KEY TO ZERO\n         L     R11,PASCBADR        LD ADR OF ASCB OF PASID\n         SETLOCK OBTAIN,TYPE=CML,ASCB=(11),RELATED=(RELCMLOK),MODE=COND\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE COPIES THE SPECIFIED TABLE KEY FROM THE SECONDARY\n*    A.S. (THE INVOKING A.S.) TO THE PRIMARY A.S. (THIS A.S.).\n***********************************************************************\n*\nGETKEY   LA    R9,KEYLEN           LD LENGTH OF KEY AREA IN SP-AS\n         LA    R10,KEY             LD ADR OF KEY AREA IN SP-AS\n         L     R11,SKEYADR         LD ADR OF KEY AREA IN U-AS\n         LA    R12,X'80'           LD ACCESS PSW KEY\n         MVCP  0(R9,R10),0(R11),R12   MOVE KEY FROM U-AS TO SP-AS\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE SCANS THE TABLE LOCATED IN THE SP-AS TO LOCATE THE\n*    TABLE DATA ENTRY WHICH CORRESPONDS TO THE KEY SPECIFIED BY THE\n*    U-AS. IF THE KEY IS NOT LOCATED IN THE TABLE, THEN RC=4 IS SET IN\n*    REGISTER 15 AND CONTROL IS RETURNED TO THE CALLING PROGRAM. IF THE\n*    SPECIFIED KEY IS FOUND IN THE TABLE, THEN RC=0 IS SET IN REGISTER\n*    15 AND REGISTER 11 POINTS TO THE CORRESPONDING DATA ENTRY OF THE\n*    TABLE.\n***********************************************************************\n*\nFINDDATA LA    R11,TABLE           LOAD ADR OF TABLE\nNEXTENTY CLI   0(R11),X'FF'        CHECK FOR END-OF-TABLE\n         BE    INVKEY              IF YES, IND INVALID KEY\n         CLC   0(KEYLEN,R11),KEY      COMP SPEC KEY TO KEY IN TBL\n         BE    KEYOK                  IF EQUAL, LD ADR OF DATA\n         LA    R11,ENTRYLEN(0,R11)    IF NOT, INCR TO NEXT TBL ENTRY\n         B     NEXTENTY               CHECK NEXT TBL ENTRY\nKEYOK    LA    R11,KEYLEN(0,R11)   LD ADR OF CORRESPD DATA\n         LA    R15,0               IND KEY OK, DATA ADR LOADED\n         BR    R6                  RETURN TO CALLING ROUTINE\nINVKEY   LA    R15,4               IND INVALID KEY\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE COPIES THE DATA ENTRY FROM THE TABLE, WHICH\n*    CORRESPONDS TO THE SPECIFIED KEY, TO THE SECONDARY A.S. (THE\n*    INVOKING A.S.). THE TABLE IS LOCATED IN THE PRIMARY A.S.\n*    (THIS A.S.). WHEN THIS ROUTINE RECEIVES CONTROL, IT FIRST EXAMINES\n*    THE RC IN REGISTER 15. IF THE RC IS NONZERO, NO DATA IS COPIED TO\n*    THE U-AS. IF THE RC IN REGISTER 15 IS ZERO, THEN REGISTER 11\n*    POINTS TO THE DATA WHICH IS TO BE COPIED TO THE U-AS.\n***********************************************************************\n*\nMOVEDATA LTR   R15,R15             CHECK IF DATA FOUND\n         BNZR  R6                  IF NO, RET TO CALLING ROUTINE\n         LA    R9,DATALEN          LD LENGTH OF DATA ENTRY IN TBL\n         L     R10,SBUFFADR        LD ADR OF RECV BUFF IN U-AS\n         LA    R12,X'80'           LD ACCESS PSW KEY\n         MVCS  0(R9,R10),0(R11),R12   MOVE DATA FROM SP-AS TO U-AS\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RELEASES THE CML LOCK.\n***********************************************************************\n*\nRELCMLOK L     R11,PASCBADR        LD ADR OF ASCB OF PASID\n         ST    R15,SAVR15          SAVE RC\n         SETLOCK RELEASE,TYPE=CML,ASCB=(11),RELATED=(SETCMLOK)\n         L     R15,SAVR15          RESTORE RC\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE STATUS OF THE CALLING PROGRAM AND\n*    RETURNS CONTROL.\n***********************************************************************\n*\nRETCALL  L     R14,SAVR14          RESTORE ADR OF STACK ENTRY\n         PCLINK UNSTACK,THRU=(R14),SAVE=NO     RESTORE STATUS\n         PT    R3,R14              RETURN CONTROL TO CALLING PROG\n*\n*\n***********************************************************************\n*    DC/DS STATEMENTS\n***********************************************************************\n*\nSAVR14   DS    F\nSAVR15   DS    F\nSKEYADR  DS    F\nSBUFFADR DS    F\nPASCBADR DS    F\n*\n*\n***********************************************************************\n*    INFORMATION TABLE\n***********************************************************************\n*\nTABLE    DC    C'CODE01'\nKEYX     EQU   *\n         DC    CL20'INFO-01'\nENTRYX   EQU   *\n         DC    C'CODE02',CL20'INFO-02'\n         DC    C'CODE03',CL20'INFO-03'\n         DC    C'CODE04',CL20'INFO-04'\n         ...                       ADDITIONAL DATA ENTRIES\n         DC    X'FF'\nKEYLEN   EQU   KEYX-TABLE\nDATALEN  EQU   ENTRYLEN-KEYLEN\nENTRYLEN EQU   ENTRYX-TABLE\n*\nKEY      DS    CL(KEYLEN)\n*\n*\n***********************************************************************\n*    THE DSECTS\n***********************************************************************\n*\nCSAMAP   DSECT\n$AXLIST  DS    0F\n$AXCOUNT DS    H\n$AXVALUE DS    H\n*\n$LXLIST  DS    0F\n$LXCOUNT DS    F\n$LXVALUE DS    F\n*\n$ETLIST  DS    0F\n$ETCOUNT DS    F\n$ETTOKEN DS    F\n*\n$XREFTBL DS    0F\n$SRV01ID DS    F\n$PCNUM01 DS    F\n$SRV02ID DS    F\n$PCNUM02 DS    F\n$XREFEND DS    F\n*\nCSALEN   EQU   *-CSAMAP\n*\n         CVT  DSECT=YES           GENERATES CVT DSECT\n         IHAETD                   GENERATES ENTRY TABLE DSECTS\n         IHAPSA                   GENERATES PSA DSECT (REQD BY SETLOCK)\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE150412": {"ttr": 7692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00a\\x00a\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 15.4.12\n*\n*\nUSER02   CSECT\n*\n*\n***********************************************************************\n*    INITIALIZATION\n***********************************************************************\n*\n         INITL 3,EQU=R             INITIALIZE PROGRAM\n*\n*\n***********************************************************************\n*    MAINSTREAM OF PROGRAM\n***********************************************************************\n*\n         BAL   R6,SETUP            SET UP AUTH AND LINKAGE FOR SP-AS\n         BAL   R6,SRCHTBL          SEARCH TBL FOR SPECIFIC DATA ENTRY\n         BAL   R6,CHKDATA          VERIFY DATA BY DUMPING IT\n         BAL   R6,PROCESS          PROCESS DATA FROM TBL\n         B     RETURN              RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE APPROPRIATE SVC ROUTINE AND REQUESTS THAT\n*    IT SET UP THE REQUIRED AUTHORITY AND LINKAGE FOR ACCESS TO/FROM\n*    THE SP-AS.\n***********************************************************************\n*\nSETUP    LA    R0,0                 REQUEST AUTH/LINKAGE FOR SP-AS\n         SVC   255                  INVOKE SVC TO SET UP AUTH/LINKAGE\n         BR    R6                   RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE INVOKES THE APPROPRIATE SVC RTN TO CALL A SPECIFIC\n*    PC ROUTINE TO SEARCH A TABLE LOCATED IN THAT ADDRESS SPACE AND\n*    RETURN THE SPECIFIC DATA ENTRY WHICH CORRESPONDS TO THE SPECIFIED\n*    KEY.\n***********************************************************************\n*\nSRCHTBL  LA    R0,3                SPEC SERV-ID\n         LA    R1,KEY              LD ADR OF KEY FOR SVC\n         LA    R15,DATA            LD ADR OF RECV DATA AREA FOR SVC\n         SVC   255                 INVOKE SVC TO GET DATA\n         LTR   R15,R15             TEST FOR GOOD RC\n         BZR   R6                  IF OK, RET TO CALLING ROUTINE\n         WTO   '*** INVALID ID SPECIFIED ***',ROUTCDE=11\n         LA    R15,4               IND INVALID ID SPECIFIED\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE IS USED FOR TESTING ONLY. IT VERIFIES THAT THE\n*    CORRECT DATA FROM THE TABLE WAS RECEIVED FOR THE SPECIFIED KEY\n*    FROM THE CALLED PC ROUTINE.\n***********************************************************************\n*\nCHKDATA  L     R8,DATA             LOAD 1ST FOUR BYTES OF RECV DATA\n         L     R9,DATA+4           LOAD 2ND FOUR BYTES OF RECV DATA\n         ABEND 900,DUMP            DUMP REGS\n*\n*\n***********************************************************************\n*    THIS ROUTINE PERFORMS THE MAIN PROCESSING OF THE PROGRAM.\n***********************************************************************\n*\nPROCESS  LTR   R15,R15             CHK IF DATA RECEIVED FROM PC ROUTINE\n         BNZ   R6                  IF NO, RET TO CALLING ROUTINE\n*        ...                       IF YES, PROCESS DATA\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n***********************************************************************\n*    THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL TO MVS OR\n*    THE CALLING PROGRAM.\n***********************************************************************\n*\nRETURN   RCNTL RC=0                RETURN TO MVS OR CALLING PROG\n*\n*\n***********************************************************************\n*    THE DC/DS STATEMENTS\n***********************************************************************\n*\n         DS    0F\nKEY      DC    C'CODE02'           SPECIFIED ARGUMENT KEY\nDATA     DS    CL20                RECEIVING FIELD FOR DATA FROM SP-AS\n*\n*\n***********************************************************************\n*    END OF PROGRAM\n***********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160301": {"ttr": 7939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.3.1\n*\n*\nARDEMO1  CSECT\n         INITL 3,EQU=R\n*\n         LA    R10,255        PUT X'FF' INTO GPR 10\n         SAR   R8,R10         COPY GPR 10 INTO AR 8\n         CPYA  R5,R8          COPY AR 8 INTO AR 5\n         LAM   R1,R4,FULL4    COPY FULL4 INTO ARS 1, 2, 3 AND 4\n         EAR   R11,R3         COPY AR 3 INTO GPR 11\n         STAM  R2,R3,FULL2    COPY ARS 2 AND 3 INTO FULL2\n         LM    R8,R9,FULL2    COPY FULL2 INTO GPRS 8 AND 9\n         ABEND 500,DUMP       DUMP CONTENTS OF GPRS AND ARS\n*\n         DS    0F\nFULL2    DC    D'0'\nFULL4    DC    X'00001111'\n         DC    X'00022222'\n         DC    X'00333333'\n         DC    X'04444444'\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160302": {"ttr": 7941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.3.2\n*\n*\nARDEMO2  CSECT\n         INITL 3,EQU=R\n         B     DEMO0           DO DEMO FOR PRIMARY-MODE\n         B     DEMO512         DO DEMO FOR AR-MODE (* B DEMO0)\n*\nDEMO0    SAC   0               SET T0 PRIMARY-MODE\n         LA    R11,1           LOAD 1 INTO GPR 11\n         LA    R12,255         LOAD X'FF' INTO GPR 12\n         LAM   R11,R11,ALET    LOAD ALET INTO AR 11\n         LAE   R10,5(R12,R11)  LOAD ADDRESS INTO GPR 10 WHEN SAC=0\n         ABEND 500,DUMP        DUMP CONTENTS OF GPRS AND ARS\n*\n*\nDEMO512  SAC   512             SET TO AR-MODE\n         LA    R11,1           LOAD 1 INTO GPR 11\n         LA    R12,255         LOAD X'FF' INTO GPR 12\n         LAM   R11,R11,ALET    LOAD ALET INTO AR 11\n         LAE   R10,5(R12,R11)  LOAD ADDRESS INTO GPR 10 AND\n*                              LOAD AR 11 (ALET) INTO AR 10\n*                              WHEN SAC=512\n         ABEND 512,DUMP        DUMP CONTENTS OF GPRS AND ARS\n*\nALET     DC    F'10'           FOR DEMO PURPOSES ONLY\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160401": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.1\n*\n*\n         AMODE 31\n         RMODE ANY\n         ...\n         SETLOCK OBTAIN,TYPE=LOCAL\n*\n[name]   TCBTOKEN TYPE=TOTTOKEN,TCB=OWNERTCB,TTOKEN=TTOKEN\n*\n         SETLOCK RELEASE,TYPE=LOCAL\n         ...\nOWNERTCB DS    F           PROVIDED BY PROGRAM\nTTOKEN   DS    CL16        RETURNED BY TCBTOKEN MACRO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160402": {"ttr": 7945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.2\n*\n*\n         AMODE 31\n         RMODE ANY\n         ...\n         SETLOCK OBTAIN,TYPE=LOCAL\n         ...\n         TCBTOKEN TYPE=JOBSTEP,TTOKEN=TTOKEN\n         ...\n         SETLOCK RELEASE,TYPE=LOCAL\n         ...\nTTOKEN   DS    CL16        RETURNED BY TCBTOKEN MACRO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160403": {"ttr": 7947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.3\n*\n*\n          AMODE 31\n          RMODE ANY\n          ...\n          DSPSERV CREATE,SCOPE=SINGLE,STOKEN=DS01STOK,NAME=DS01NAME, -\n                GENNAME=YES,OUTNAME=DS01GNAM,\n                BLOCKS=(MAXBLKS,INITBLKS),ORIGIN=DS01ORGN\n          ...\nDS01STOK  DS    D\nDS01ORGN  DS    F\nDS01NAME  DC    CL8'@D1'\nDS01GNAME DS    CL8\nMAXBYTES  EQU   10000000          REQUIRE MAX OF 10 MILLION BYTES\nINITBYTES EQU   1000000           REQUIRE 1 MILLION BYTES INITIALLY\nMAXBLKS   DC    A((MAXBYTES+4095)/4096)   NUMB 0F BLOCKS REQUIRED\nINITBLKS  DC    A(INITBYTES+4095)/4096)   NUMB OF BLOCKS REQUIRED\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160404": {"ttr": 7949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.4\n*\n*\n          AMODE 31\n          RMODE ANY\n          ...\n          SAC   512\n          SYSSTATE ASCENV=AR\n          ...\n          DSPSERV CREATE,SCOPE=ALL,STOKEN=DS02STOK,NAME=DS01NAME,   -\n                GENNAME=YES,OUTNAME=DS02GNAM,KEY=PSWKEY,FPROT=YES,  -\n                BLOCKS=(MAXBLKS,INITBLKS),ORIGIN=DS02ORGN\n          ...\nDS02STOK  DS    D\nDS02ORGN  DS    F\nDS02NAME  DC    CL8'@D2'\nDS02GNAME DS    CL8\nPSWKEY    DC    X'70'\nMAXBLKS   DC    A(524288)    NUMB 0F 4K BLOCKS - 2G BYTES\nINITBLKS  DC    A(100000)    NUMB OF 4K BLOCKS - 4096M BYTES\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160405": {"ttr": 7951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.5\n*\n*\n         AMODE 31\n         RMODE ANY\n         ...\n[name]   ALESERV ADD,STOKEN=DS01STOK,ALET=DS01ALET,AL=WORKUNIT\n         ...\nDS01STOK DS    D        PROVIDED, RECEIVED FRON DSPSERV-CREATE MACRO\nDS01ALET DS    F        RECEIVED FROM ALESERV-ADD MACRO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160406": {"ttr": 7953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.6\n*\n*\n         AMODE 31\n         RMODE ANY\n         ...\n[name]   ALESERV ADD,STOKEN=DS02STOK,ALET=DS02ALET,AL=PASN\n         ...\nDS02STOK DS    D        PROVIDED, RECEIVED FRON DSPSERV-CREATE MACRO\nDS02ALET DS    F        RECEIVED FROM ALESERV-ADD MACRO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160407": {"ttr": 7955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xd4\\x00\\xd4\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 212, "newlines": 212, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.7\n*\n*\nDSPCTEST CSECT\n*\n*\n**********************************************************************\n* INITIALIZATION\n**********************************************************************\n*\nDSPCTEST AMODE 31                  \\ INDICATE 31-BIT ADDRESSING\nDSPCTEST RMODE ANY                 /\n         INITL 3,4,5,EQU=R         SET UP BASE REGS AND SAVEAREA\n         USING DSRECORD,R12        DEFINE REG FOR DSPC DSECT\n*\n*\n**********************************************************************\n* MAINSTREAM OF PROGRAM\n**********************************************************************\n*\n         BAL   R6,MAKEDS       CREATE DATA SPACE\n         BAL   R6,SETDSADR     SET UP ADDRESSABLITY TO DATASPACE\n         BAL   R6,SETARMOD     SET UP AR-MODE\n         BAL   R6,PUTDS        WRITE RECS INTO DATA SPACE\n         BAL   R6,UPDATEDS     UPDATE RECS IN DATA SPACE\n         BAL   R6,GETDS        READ RECS FROM DATA SPACE\n         BAL   R6,DUMPDATA     DUMP ADDRESS SPACE AND DATA SPACE\n         B     RETURN          RETURN TO MVS OR CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE CREATES THE DATA SPACE.\n**********************************************************************\n*\nMAKEDS   DSPSERV CREATE,TYPE=BASIC,STOKEN=DS01TOK,SCOPE=SINGLE,        -\n               BLOCKS=(MAXBLKS,INITBLKS),NUMBLKS=CURRBLKS,             -\n               NAME=DS01NAME,GENNAME=YES,OUTNAME=DS01GNAM,             -\n               ORIGIN=DSBEGADR\n         LTR   R15,R15            CHECK IF DSPSERV OK\n         BZR   R6                 IF OK, RETURN TO CALLING ROUTINE\n         LA    R10,901            IF NOT, SET USERCODE\n         B     ABEND              ABEND PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE SETS UP ADDRESSABILITY TO THE DATA SPACE.\n**********************************************************************\n*\nSETDSADR ALESERV ADD,STOKEN=DS01TOK,ALET=DS01ALET,AL=WORKUNIT\n         LA    R10,902            PRIME USERCODE IN REG 10\n         LTR   R15,R15            CHECK IF ALESERV OK\n         BNZ   ABEND              IF NOT, ABEND PROGRAM\n         LAM   R12,R12,DS01ALET   LOAD ALET OF D.S. INTO AR 12\n         L     R12,DSBEGADR       LOAD BG ADDR OF D.S. INTO GPR 12\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE PUTS THE CPU IN AR-MODE WHICH IS REQUIRED TO ACCESS\n* A DATA SPACE AND INDICATES AR-MODE TO THE FOLLOWING MACROS.\n**********************************************************************\n*\nSETARMOD SAC   512                SET AR-MODE\n         SYSSTATE ASCENV=AR       INDICATE AR-MODE TO FOLLOWING MACROS\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE COPIES DATA INTO THE DATA SPACE.\n**********************************************************************\n*\nPUTDS    MVC   DSFLD01,DATA01     \\   COPY INITIAL TEST DATA INTO\n         MVC   DSFLD02,DATA02      |  DATA SPACE\n         MVC   DSFLD03,DATA03     /\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE UPDATES DATA FIELDS IN THE DATA SPACE.\n**********************************************************************\n*\nUPDATEDS MVC   DSFLD01,DATA11     \\\n         MVC   DSFLD02A,DATA12A    \\  UPDATE FIELDS IN DATA SPACE\n         MVC   DSFLD02C,DATA12C    /\n         MVC   DSFLD04,DATA14     /\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE RETRIEVES DATA FROM THE DATA SPACE.\n**********************************************************************\n*\nGETDS    MVC   DATAX1,DSFLD01     \\\n         MVC   DATAX2,DSFLD02      \\ COPY DATA FIELDS FROM DATA SPACE\n         MVC   DATAX3,DSFLD03      / INTO FIELDS IN ADDRESS SPACE\n         MVC   DATAX4,DSFLD04     /\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE DUMPS THE ADDRESS SPACE AND FIRST 4K OF THE DATA SPACE\n* WITH USERCODE OF 999 AND REG 8 POINTS TO THE BEGINNING OF THE\n* RECORDS READ FROM THE DATA SPACE.\n**********************************************************************\n*\nDUMPDATA LA    R8,NEWDATA         POINT TO RECS READ FROM DATA SPACE\n         LA    R10,0              \\  SET BG ADDR OF DATA SPACE TO\n         ST    R10,DMBGADR        /  DUMP\n         LA    R10,4095           \\  SET END ADDR OF DATA SPACE TO\n         ST    R10,DMENDADR       /  DUMP\n         OI    DMENDADR,X'80'     INDICATE END OF ADDRESS LIST\n         MVC   DMSTOKEN,DS01TOK   PUT DATA SPACE TOKEN INTO ADDR LIST\n         ABEND 999,DUMP,DUMPOPX=DUMPLST\n*\n*\n**********************************************************************\n* THIS ROUTINE ABENDS PROGRAM USING USERCODE IN REGISTER 10.\n**********************************************************************\n*\nABEND    ABEND (R10),DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n**********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n**********************************************************************\n* WORKING STORAGE AND CONSTANTS\n**********************************************************************\n*\nDS01TOK  DS    D\nDS01ALET DS    F\nDS01NAME DC    C'D01$$$$$'\nDS01GNAM DS    CL8\nMAXBYTES EQU   1000000\nINITBYTS EQU   250000\nMAXBLKS  DC    A((MAXBYTES+4095)/4096)\nINITBLKS DC    A((INITBYTS+4095)/4096)\nCURRBLKS DS    CL4\nDSBEGADR DS    F\n*\n*\n**********************************************************************\n* INITIAL TEST DATA COPIED INTO THE DATA SPACE\n**********************************************************************\n*\nDATA01   DC    10CL1'A'\nDATA02   DC    50CL1'B'\nDATA03   DC    25CL1'C'\nDATA04   DC    20CL1'D'\n*\n*\n**********************************************************************\n* TEST DATA USED TO UPDATE FIELDS IN THE DATA SPACE\n**********************************************************************\n*\nDATA11   DC    10CL1'1'\nDATA12A  DC    10CL1'0'\nDATA12B  DC    20CL1'X'\nDATA12C  DC    5CL1'Y'\nDATA12D  DC    15CL1'Z'\nDATA13   DC    25CL1'3'\nDATA14   DC    20CL1'4'\n*\n*\n**********************************************************************\n* FIELDS IN ADDRESS SPACE IN WHICH DATA IS READ FROM THE DATA SPACE\n**********************************************************************\n*\nNEWDATA  DS    0CL105\nDATAX1   DS    CL10\nDATAX2   DS    CL50\nDATAX3   DS    CL25\nDATAX4   DS    CL20\n*\n*\n**********************************************************************\n* ADDRESS LIST FOR ABEND MACRO FOR DUMPING DATA FROM THE DATA SPACE\n**********************************************************************\n*\nDUMPLST0 DS    0D\nDMBGADR  DS    F\nDMENDADR DS    F\nDMSTOKEN DS    D\n*\nDUMPLST  SNAPX SDATA=SUM,DSPSTOR=DUMPLST0,MF=L\n*\n*\n**********************************************************************\n* MAPPING DSECT FOR THE FIELDS IN THE DATA SPACE\n**********************************************************************\n*\nDSRECORD DSECT\nDSFLD01  DS    CL10\nDSFLD02  DS    0CL50\nDSFLD02A DS    CL10\nDSFLD02B DS    CL20\nDSFLD02C DS    CL5\nDSFLD02D DS    CL15\nDSFLD03  DS    CL25\nDSFLD04  DS    CL20\n*\n*\n**********************************************************************\n* END OF PROGRAM\n**********************************************************************\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160408": {"ttr": 7960, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00*\\x00*\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.8\n*\n*\nThis coding example illustrates the use of the ABEND macro\ninstruction to dump one address range of a specific Data Space.\n\n\n         AMODE 31                   \\ INDICATE 31-BIT ADDRESSING\n         RMODE ANY                  /\n         ...\n         USING R12,DSAREA           DEFINE GPR FOR DSECT ADRSBLTY\n         ...\n         SAC   512                  \\  SET UP AR ENVIRONMENT\n         SYSSTATE ASCENV=AR         /\n         ...\n         L     R12,DS02ORGN         SET UP ADRSBLTY FOR DSPC FIELDS\n         LA    R10,DSAREA01         \\ LOAD BEG ADDR TO BE DUMPED\n         ST    R10,DMBGADR          /\n         LA    R10,DSAREAX          \\ LOAD END ADDR TO BE DUMPED\n         ST    R10,DMENDADR         /\n         OI    DMENDADR,X'80'       INDICATE END OF PARM-LIST\n         MVC   DMSTOKEN,DS02STOK    LOAD STOKEN OF DATA SPACE\n         ABEND 999,DUMP,DUMPOPX=DUMPLST\n         ...\n*\nDS02ORGN DS    F         BEG ADDR OF DATA SPACE FROM DSPSERV MACRO\nDS02STOK DS    D         STOKEN OF DATA SPACE FROM DSPSERV MACRO\n*\nDUMPLST0 DS    0D        \\\nDMBGADR  DS    F          \\  REQUIRED PARAMETER-LIST TO DUMP\nDMENDADR DS    F          /  SPECIFIC DATA SPACE AREAS\nDMSTOKEN DS    D         /\n*\nDUMPLST  SNAPX SDATA=SUM,DSPSTOR=DUMPLST0,MF=L\n*\nDSAREAS  DSECT           DSECT FOR DATA SPACE\nDSAREA01 DS    CL100\nDSAREA02 DS    CL150\nDSAREA03 DS    CL250\nDSAREA04 DS    CL200\nDSAREAX  EQU   *\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160409": {"ttr": 7962, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x004\\x004\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.9\n*\n*\n         AMODE 24                   DEFAULT AMODE\n         RMODE 24                   DEFAULT RMODE\n         ...\n         USING R12,DSAREA           DEFINE GPR FOR DSECT ADRSBLTY\n         ...\n         SAC   512                  \\ SET UP AR ENVIRONMENT\n         SYSSTATE ASCENV=AR         /\n         ...\n         L     R12,DS02ORGN         SET UP ADRSBLTY FOR DSP FIELDS\n         LA    R10,DSAREA01         \\ LOAD BEG ADDR1 TO BE DUMPED\n         ST    R10,DMBGADR1         /\n         LA    R10,DSAREA02         \\ LOAD END ADDR1 TO BE DUMPED\n         ST    R10,DMEDADR1         /\n         LA    R10,DSAREA05         \\ LOAD BEG ADDR2 TO BE DUMPED\n         ST    R10,DMBGADR2         /\n         LA    R10,DSAREA06         \\ LOAD END ADDR2 TO BE DUMPED\n         ST    R10,DMEDADR2         /\n         OI    DMENADR2,X'80'       INDICATE END OF PARM-LIST\n         MVC   DMTOKEN1,DS02STOK    LOAD STOKEN OF DSP INTO ENTRY1\n         MVC   DMTOKEN2,DS02STOK    LOAD STOKEN OF DSP INTO ENTRY2\n         ...\n         OPEN  (SNAPDCB,(OUTPUT))\n         SNAPX DCB=SNAPDCB,DSPSTOR=DUMPLST\n         ...\n*\nDS02ORGN DS    F         BEG ADDR OF DATA SPACE FROM DSPSERV MACRO\nDS02STOK DS    D         STOKEN OF DATA SPACE FROM DSPSERV MACRO\n*\nDUMPLST0 DS    0D        \\\nDMBGADR1 DS    F          \\\nDMENADR1 DS    F           \\  REQUIRED PARAMETER-LIST TO DUMP\nDMTOKEN1 DS    D            | TWO SPECIFIC DATA SPACE AREAS\nDMBGADR2 DS    F           /\nDMENADR2 DS    F          /\nDMTOKEN2 DS    D         /\n*\nDUMPLST  SNAPX SDATA=SUM,DSPSTOR=DUMPLST0,MF=L\nSNAPDCB  DCB   DSORG=PS,MACRF=W,BLKSIZE=1632,LRECL=125,RECFM=VBA,  -\n               DDNAME=SNAPDUMP\n*\nDSAREAS  DSECT\nDSAREA01 DS    CL100\nDSAREA02 DS    CL150\nDSAREA03 DS    CL250\nDSAREA04 DS    CL200\nDSAREA05 DS    CL500\nDSAREA06 DS    CL150\nDSAREAX  EQU   *\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160410": {"ttr": 8193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x01\\x08\\x01\\x08\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 264, "newlines": 264, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.10\n*\n*\n//-------- JOB  ----\n//STEP     EXEC ASMACL,PARM.L='AC(1)'\n//SYSLIB   DD   DSN=SYS1.MACLIB,DISP=SHR\n//         DD   DSN=SYS1.MODGEN,DISP=SHR\n//         DD   DSN=USER.MACLIB,DISP=SHR\n//C.SYSIN  DD   *\n*\n*\n**********************************************************************\n* INITIALIZATION\n**********************************************************************\n*\nPUTINLPA CSECT\n         INITL 3,EQU=R             SET UP BASE REGS AND SAVEAREA\n         USING CVT,R10             DEFINE REG FOR CVT DSECT\n         USING CDENTRY,R11         DEFINE REG FOR CDE DSECT\n         USING XTLST,R12           DEFINE REG FOR XL DSECT\n*\n*\n**********************************************************************\n* MAINSTREAM OF PROGRAM\n**********************************************************************\n*\n         BAL   R6,SVDSINFO         SAVE DS INFO FROM CALLING PGM\n         BAL   R6,SETMODE          SET SUPV STATE, PROT KEY ZERO\n         BAL   R6,CHKEXIST         CHECK IF LOADMOD ALREADY IN LPA\n         LTR   R15,R15             CHK RC TO DETRM IF LOADMOD PRESENT\n         BZ    RETURN              IF YES, RETURN TO MVS\n         BAL   R6,PUTLPA           IF NO, PUT NEW LOADMOD INTO LPA\n**TEST   BAL   R6,CHKLMOD          CHK NEW LMOD BY LOADING/DUMPING IT\n         B     RETURN              RETURN TO MVS OR CALLER\n*\n*\n**********************************************************************\n* THIS ROUTINE SAVES THE DATA RECEIVED FROM THE CALLING PROGRAM. THE\n* CALLING PROGRAM USES THE FOLLOWING GENERAL PURPOSE REGISTERS TO\n* PASS THE FOLLOWING DATA:\n*   GPR  8: ALET\n*   GPR  9: BEG ADDR OF DATA SPACE\n*   GRP 10: FIRST 4 BYTES OF STOKEN\n*   GRP 11: LAST 4 BYTES OF STOKEN.\n**********************************************************************\n*\nSVDSINFO  ST    R8,ALET            \\\n          ST    R9,DSORGIN          \\ RETRIEVE PASSED DATA FROM\n          ST    R10,STOKEN          / CALLING PROGRAM\n          ST    R11,STOKEN+4       /\n          BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE PUTS THIS PROGRAM INTO SUPERVISOR STATE AND PSW KEY 0.\n* THIS IS NECESSARY TO MODIFY THE LPA CDE CHAIN. A PROGRAM MUST BE\n* APF-AUTHORIZED IN ORDER TO ISSUE THE MODESET MACRO INSTRUCTION.\n**********************************************************************\n*\nSETMODE  MODESET KEY=ZERO,MODE=SUP\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE USES THE IBM SERVICE PROGRAM IEAQCDSR TO SCAN THE LPA\n* CDE QUEUE TO DETERMINE IF THE LOAD MODULE THAT IS TO BE ADDED TO\n* THE LPA IS ALREADY PRESENT.\n**********************************************************************\n*\nCHKEXIST L     R10,16              LOAD ADDRESS OF CVT\n         L     R8,CVTQLPAQ         LOAD ADR OF BG OF LPA CDE QUEUE\n         LA    R9,LMODNAME         LOAD ADDR OF NAME OF LOADMOD\n         L     R15,CVTQCDSR        LOAD ADDR OF IEAQCDSR\n         BALR  R14,R15             CALL IEAQCDSR\n         B     CDEFND              BRANCH TO CDE FOUND RTN\n         B     CDEXFND             BRANCH TO CDE NOT FOUND RTN\nCDEFND   WTO   '*** LOAD MODULE ALREADY IN LPA ***'\n         LA    R15,0               INDICATE LOADMOD PRESENT\n         BR    R6                  RETURN TO CALLING ROUTINE\nCDEXFND  WTO   '*** LOAD MODULE NOT IN LPA ***'\n         LA    R15,4               INDICATE LOADMOD NOT PRESENT\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE PASSES CONTROL TO ALL THE SUBROUTINES THAT PERFORM\n* THE REQUIRED FUNCTIONS NECESSARY TO INSERT A NEW LOAD MODULE INTO\n* THE LPA.\n**********************************************************************\n*\nPUTLPA   BAL   R7,GETMAIN          ALLOCATE STORAGE FROM CSA\n         BAL   R7,BLDCDE           BUILD NEW CDE\n         BAL   R7,BLDXL            BUILD NEW XL\n         BAL   R7,MAKELMOD         CREATE NEW LOADMOD FOR LPA\n         BAL   R7,SETLOCKS         OBTAIN LOCK FOR CDE CHAIN\n         BAL   R7,LINKCDE          INSERT NEW CDE INTO LPA CDE CHAIN\n         BAL   R7,RELLOCKS         RELEASE LOCK FOR CDE CHAIN\n         WTO   '*** LOAD MODULE PUT INTO LPA ***'\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE ALLOCATES VIRTUAL STORAGE FROM THE CSA. THE STORAGE IS\n* USED TO BUILD THE CDE, XL, AND THE ACTUAL LOAD MODULE. THE STORGAE\n* IS ALLOCATED FROM NONFETCH-PROTECTED, PAGEABLE STORAGE. A PROGRAM\n* MUST BE APF-AUTHORIZED OR EXECUTING IN SUPERVISOR STATE OR IN\n* PSW KEY 0 THOUGH 7 TO ALLOCATE VIRTUAL STORAGE FROM THE CSA.\n**********************************************************************\n*\nGETMAIN  GETMAIN EU,LV=GMLEN,SP=CSASPN,A=CSAADDR\n         LTR   R15,R15\n         BNZ   NOCSA\n         BR    R7                  RETURN TO CALLING ROUTINE\nNOCSA    WTO   '*** CSA STORAGE NOT AVAILABLE ***'\n         ABEND 901\n*\n*\n**********************************************************************\n* THIS ROUTINE CREATES THE CDE THAT POINTS TO THE NEW LOAD MODULE.\n**********************************************************************\n*\nBLDCDE   L     R11,CSAADDR         LD ADR OF ALLO CSA (BG OF NEW CDE)\n         LA    R12,CDELEN(0,R11)   LOAD ADDR OF BG OF NEW XL\n         ST    R12,CDXLMJP         INSERT ADDR OF NEW XL INTO NEW CDE\n         MVC   CDNAME,LMODNAME     INSERT NEW LOADMOD NAME INTO CDE\n         LA    R14,CDELEN+XLLEN(0,R11)    LOAD ADDR OF NEW LOADMOD\n         ST    R14,LMODADDR        SAVE ADDR OF NEW LOADMOD LOC IN CSA\n         ST    R14,CDENTPT         INSERT ADDR OF NEW LOADMOD INTO CDE\n*        OI    CDENTPT,CDEMODE     LOADMOD IN AMODE 31, IF REQUIRED\n         MVI   CDSP,CSASPN         INSERT CSA SUBPOOL NUMB INTO CDE\n         OI    CDATTRB,CDGLOBAL    LOADMOD LOADED TO GLOBAL\n         OI    CDATTR,CDNIP        MODIFIED LPA LOADMOD\n         OI    CDATTR2,CDXLE       XL BUILT FOR LOADMOD\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE CREATES THE XL (EXTENT LIST) USED WITH THE CDE OF THE\n* NEW LOAD MODULE.\n**********************************************************************\n*\nBLDXL    LA    R14,XLLEN           LOAD LENGTH OF XL\n         ST    R14,XTLLNTH         INSERT LENGTH OF XL INTO NEW XL\n         LA    R14,1               SET NUMB OF RELO FACTORS, MUST BE 1\n         ST    R14,XTLNRFAC        STORE NUMB OF RELOCATION FACTORS\n         L     R14,LMODLEN         LOAD LEN OF NEW LOADMOD\n         STCM  R14,B'0111',XTLMSBLN     INSERT LEN OF LOADMOD INTO XL\n         LA    R14,CDELEN+XLLEN(0,R11)  LOAD ADDR OF BG OF NEW LOADMOD\n         ST    R14,XTLMSBAD        INSERT ADDR OF NEW LOADMOD INTO XL\n         MVI   XTLMSBLA,X'80'      FIELD REQUIRES X'80'\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE CREATES THE ACTUAL LOAD MODULE USING THE INFORMATION\n* THAT WAS PASSED FROM THE CALLING PROGRAM.\n**********************************************************************\n*\nMAKELMOD L     R14,LMODADDR        LOAD BEG ADDR OF NEW LOAD MOD\n         MVC   0(80,R14),PRGMBEG   INSERT DATA FROM CALLING PROGRAM\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE OBTAINS THE LOCAL AND THE CMS LOCKS. THIS IS NECESSARY\n* FOR SERIALIZATION WHILE THE LPA CDE CHAIN IS BEING MODIFIED.\n**********************************************************************\n*\nSETLOCKS SETLOCK OBTAIN,MODE=UNCOND,TYPE=LOCAL,REGS=USE,               -\n               RELATED=(RELLOCKS)\n         SETLOCK OBTAIN,MODE=UNCOND,TYPE=CMS,REGS=USE,                 -\n               RELATED=(RELLOCLS)\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE INSERTS THE NEW CDE INTO THE ACTIVE LPA CDE CHAIN,\n* WHICH, IN EFFECT, ADDS THE NEW LOAD MODULE INTO THE LPA.\n**********************************************************************\n*\nLINKCDE  L     R1,CVTQLPAQ         LOAD ADDR OF BG OF LPA CDE Q\n         L     R14,CDCHAIN-CDENTRY(0,R1)     SAVE ADDR OF NEXT CDE\n*                                  CONTAINED IN FIRST CDE ON QUEUE\n         ST    R11,CDCHAIN-CDENTRY(0,R1)     INSERT ADDR OF NEW CDE\n*                                  INTO FIRST CDE ON QUEUE\n         ST    R14,CDCHAIN         INSERT ADDR OF NEXT CDE INTO\n*                                  NEW CDE\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE RELEASES THE LOCAL AND THE CMS LOCKS.\n**********************************************************************\n*\nRELLOCKS SETLOCK RELEASE,TYPE=ALL,REGS=USE,RELATED=(SETLOCKS)\n         BR    R7                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE LOADS THE LOAD MODULE THAT WAS JUST CREATED AND ADDED\n* TO THE LPA AREA, THEN ABENDS WITH A VIRTUAL STORAGE DUMP. GRP 8\n* POINTS TO THE BEGINNING OF THE LOAD MODULE AND GPR 9 POINTS TO THE\n* LAST BYTE +1 OF THE LOAD MODULE. THIS ROUTINE SHOULD BE USED FOR\n* TESTING ONLY.\n**********************************************************************\n*\nCHKLMOD  LOAD  EPLOC=LMODNAME\n         LR    R8,R0\n         LR    R9,R8\n         A     R9,LMODLEN\n         ABEND 999,DUMP\n         BR    R6\n*\n*\n**********************************************************************\n* THIS ROUTINE RESTORES THE REGISTERS AND RETURNS TO MVS OR THE\n* CALLING PROGRAM.\n**********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n**********************************************************************\n* CONSTANTS AND WORKING STORAGE\n**********************************************************************\n*\nCSASPN   EQU   241\nGMLEN    EQU   CDELEN+XLLEN+LMODLEN\nCSAADDR  DS    F\nLMODADDR DS    F\nLMODNAME DC    CL8'DSCNTL99'\nPRGMBEG  EQU   *\nALET     DS    F\nDSORGIN  DS    F\nSTOKEN   DS    CL8\n         DC    64CL1'A'\nLMODLEN  DC    A(*-PRGMBEG)\n*\n*\n**********************************************************************\n* DSECTS\n**********************************************************************\n*\n         IHAPSA\n*\n         CVT   DSECT=YES\n*\n         IHACDE\nCDELEN   EQU   *-CDENTRY\n*\n         IHAXTLST\nXLLEN    EQU   *-XTLST\n*\n*\n**********************************************************************\n* END OF PROGRAM\n**********************************************************************\n*\n         END\n//*\n//*\n//L.SYSLMOD DD DSN=SYS1.AUTHLIB(PUTINLPA),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160411": {"ttr": 8198, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x97\\x00\\x97\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 151, "newlines": 151, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.11\n*\n*\n//-------- JOB   ----\n//STEP     EXEC  ASMACL,PARM.L='AC(1)'\n//C.SYSLIB DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=USER.MACLIB,DISP=SHR\n//C.SYSIN  DD *\n*\n*\nMKCOMDSP CSECT\n*\n*\n**********************************************************************\n* INITIALIZATION\n**********************************************************************\n*\nMKCOMDSP AMODE 31              \\ INDICATE 31-BIT ADDRESSING\nMKCOMDSP RMODE ANY             /\n         INITL 3,4,5,EQU=R     SET UP BASE REGS AND SAVEARE\n*\n*\n**********************************************************************\n* MAINSTREAM OF PROGRAM\n**********************************************************************\n*\n         BAL   R6,SETMODE      SET SUPV STATE, PSW KEY ZERO\n         BAL   R6,MKUNSWAP     MAKE ADDR SPACE UNSWAPPABLE\n         BAL   R6,MAKEDS       CREATE DATA SPACE\n         BAL   R6,SETDSADR     SET UP ADDRESSABLITY TO DATASPACE\n         BAL   R6,PUTINLPA     PUT ALET INTO LMOD IN LPA\n         BAL   R6,DOWAIT       GO INTO WAIT STATE\n         B     RETURN          RETURN TO MVS OR CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE PUTS THE PROGRAM INTO SUPERVISOR STATE, PSW KEY 0. THE\n* PROGRAM MUST BE APF-AUTHORIZED IN ORDER TO ISSUE THIS MACRO.\n**********************************************************************\n*\nSETMODE  MODESET MODE=SUP,KEY=ZERO\n         BR    R6              RETURN TO CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE MAKES THE HOME ADDRESS SPACE IN WHICH THIS PROGRAMS\n* EXECUTES NONSWAPPABLE.\n**********************************************************************\n*\nMKUNSWAP SYSEVENT DONTSWAP\n         BR    R6              RETURN TO CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE CREATES THE SCOPE=COMMON DATA SPACE.\n**********************************************************************\n*\nMAKEDS   DSPSERV CREATE,TYPE=BASIC,STOKEN=DS99TOK,SCOPE=COMMON,        -\n               BLOCKS=MAXBLKS,NUMBLKS=CURRBLKS,                        -\n               KEY=PROTKEY,FPROT=NO,                                   -\n               NAME=DS99NAME,GENNAME=YES,OUTNAME=DS99GNAM,             -\n               ORIGIN=DS99ORGN\n         LTR   R15,R15            CHECK IF DSPSERV OK\n         BZR   R6                 IF OK, RETURN TO CALLING ROUTINE\n         LA    R10,901            IF NOT, SET USERCODE\n         B     ABEND              ABEND PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE PUTS THE DATA SPACE ENTRY ONTO THE PASN-AL OF THIS\n* ADDRESS SPACE AND NOTIFIES MVS TO PLACE THE ENTRY ONTO THE PASN-AL\n* OF ALL EXISTING ADDRESS SPACES.\n**********************************************************************\n*\nSETDSADR SYSSTATE ASCENV=AR       INDICATE AR-MODE TO FOLLOWING MACROS\n         ALESERV ADD,STOKEN=DS99TOK,ALET=DS99ALET,AL=PASN\n         LA    R10,902            PRIME USERCODE IN REG 10\n         LTR   R15,R15            CHECK IF ALESERV OK\n         BNZ   ABEND              IF NOT, ABEND PROGRAM\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE LINKS TO PROGRAM PUTINLPA AND PASSES THE FOLLOWING\n* DATA TO IT IN THE FOLLOWING GENERAL PURPOSE REGISTERS:\n*   GPR  8: ALET\n*   GPR  9: BEG ADDR OF DATA SPACE\n*   GRP 10: FIRST 4 BYTES OF STOKEN\n*   GRP 11: LAST 4 BYTES OF STOKEN.\n**********************************************************************\n*\nPUTINLPA L     R8,DS99ALET     \\\n         L     R9,DS99ORGN      \\  LOAD DATA TO BE PASSED TO CALLED\n         L     R10,DS99TOK      /  PROGRAM INTO GPRS\n         L     R11,DS99TOK+4   /\n         LINKX EP=PUTINLPA\n         BR    R6              RETURN TO CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE PUTS THE PROGRAM INTO A SHORT WAIT STATE. THIS IS FOR\n* DEMO PURPOSES ONLY. IF THIS PROGRAM HAD OTHER PROCESSING TO DO,\n* IT WOULD BE DONE AT THIS TIME. IF THE ONLY FUNCTION OF THIS\n* PROGRAM WERE TO CREATE A SCOPE=COMMON DATA SPACE, THEN THE PROGRAM\n* WOULD GO INTO A LONG WAIT.\n**********************************************************************\n*\nDOWAIT   STIMER WAIT,DINTVL=WAITTIME\n         BR    R6              RETURN TO CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE ABENDS THE PROGRAM USING USERCODE IN REGISTER 10.\n**********************************************************************\n*\nABEND    ABEND (R10),DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE RESTORES THE REGISTERS AND RETURNS TO MVS OR THE\n* CALLING PROGRAM.\n**********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n**********************************************************************\n* WORKING STORAGE AND CONSTANTS\n**********************************************************************\n*\nPROTKEY  DC    X'80'\nDS99TOK  DS    D\nDS99ALET DS    F\nDS99NAME DC    C'D01$$$$$'\nDS99GNAM DS    CL8\nMAXBLKS  DC    A(524288)\nCURRBLKS DS    CL4\nDS99ORGN DS    F\nWAITTIME DC    C'00100000'    TEN MINUTES\n*\n*\n**********************************************************************\n* END OF PROGRAM\n**********************************************************************\n*\n         END\n//*\n//*\n//L.SYSLMOD DD DSN=SYS1.AUTHLIB(MKCOMDSP),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160412": {"ttr": 8202, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xce\\x00\\xce\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 206, "newlines": 206, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.12\n*\n*\nDSACCESS CSECT\n*\n*\n**********************************************************************\n* INITIALIZATION\n**********************************************************************\n*\n         INITL 3,4,5,EQU=R     SET UP BASE REGS SAVEAREA\n         USING DSRECORD,R12    DEFINE REG FOR DATA SPACE DSECT\n*\n*\n**********************************************************************\n* MAINSTREAM OF PROGRAM\n**********************************************************************\n*\n         BAL   R6,GETDSINF     GET INFO FOR COMMON DATA SPACE\n         BAL   R6,SETARMOD     SET UP AR-MODE\n         BAL   R6,PUTDS        WRITE RECS INTO DATA SPACE\n         BAL   R6,UPDATEDS     UPDATE RECS IN DATA SPACE\n         BAL   R6,GETDS        READ RECS FROM DATA SPACE\n         BAL   R6,DUMPDATA     DUMP ADDRESS SPACE AND DATA SPACE\n         B     RETURN          RETURN TO MVS OR CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE LOADS THE LOAD MODULE (TABLE) CREATED BY THE PROGRAM\n* THAT CREATED THE SCOPE=COMMON DATA SPACE. THE LOAD MODULE IS IN THE\n* LPA AND CONTAINS THE FOLLOWING INFORMATION ABOUT THE DATA SPACE:\n*    +0 (4) - ALET\n*    +4 (4) - BEGINNING ADDRESS OF DATA SPACE\n*    +8 (8) - STOKEN\n* ALSO SETS UP ADDRESSABILITY TO DATA SPACE BY LOADING ALET INTO\n* AR AND LOADING DSECT GPR WITH BEG ADDR OF THE DATA SPACE.\n**********************************************************************\n*\nGETDSINF LOAD  EP=DSCNTL99        \\\n         LR    R10,R0              \\  RETRIEVE DATA SPACE INFO\n         MVC   DS01ALET,0(R10)      | FROM PROGRAM THAT CREATED THE\n         MVC   DSBEGADR,4(R10)     /  SCOPE=COMMON DATA SPACE\n         MVC   DS01TOK,8(R10)     /\n         LAM   R12,R12,DS01ALET   LOAD ALET OF D.S. INTO AR 12\n         L     R12,DSBEGADR       LOAD BG ADDR OF D.S. INTO GPR 12\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE PUTS THE CPU IN AR-MODE WHICH IS REQUIRED TO ACCESS\n* A DATA SPACE.\n**********************************************************************\n*\nSETARMOD SAC   512\n         SYSSTATE ASCENV=AR       INDICATE AR-MODE TO FOLLOWING MACROS\n*\n*\n**********************************************************************\n* THIS ROUTINE COPIES DATA INTO THE DATA SPACE.\n**********************************************************************\n*\nPUTDS    MVC   DSFLD01,DATA01     \\   COPY INITIAL TEST DATA INTO\n         MVC   DSFLD02,DATA02      |  DATA SPACE\n         MVC   DSFLD03,DATA03     /\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE UPDATES DATA FIELDS IN THE DATA SPACE.\n**********************************************************************\n*\nUPDATEDS MVC   DSFLD01,DATA11     \\\n         MVC   DSFLD02A,DATA12A    \\  UPDATE FIELDS IN DATA SPACE\n         MVC   DSFLD02C,DATA12C    /\n         MVC   DSFLD04,DATA14     /\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE RETRIEVES DATA FROM THE DATA SPACE.\n**********************************************************************\n*\nGETDS    MVC   DATAX1,DSFLD01     \\\n         MVC   DATAX2,DSFLD02      \\ COPY DATA FIELDS FROM DATA SPACE\n         MVC   DATAX3,DSFLD03      / INTO FIELDS IN ADDRESS SPACE\n         MVC   DATAX4,DSFLD04     /\n         BR    R6                 RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE DUMPS THE ADDRESS SPACE AND FIRST 4K OF THE DATA SPACE\n* WITH USERCODE OF 999. REG 8 POINTS TO THE BEGINNING OF THE RECORDS\n* READ FROM THE DATA SPACE. *** FOR TESTING ONLY ***\n**********************************************************************\n*\nDUMPDATA LA    R8,NEWDATA         POINT TO RECS READ FROM DATA SPACE\n         LA    R10,0              \\  SET BG ADDR OF DATA SPACE TO\n         ST    R10,DMBGADR        /  DUMP\n         LA    R10,4095           \\  SET END ADDR OF DATA SPACE TO\n         ST    R10,DMENDADR       /  DUMP\n         OI    DMENDADR,X'80'     INDICATE END OF ADDRESS LIST\n         MVC   DMSTOKEN,DS01TOK   PUT DATA SPACE TOKEN INTO ADDR LIST\n         ABEND 999,DUMP,DUMPOPX=DUMPLST\n*\n*\n**********************************************************************\n* THIS ROUTINE ABENDS THE PROGRAM USING USERCODE IN REGISTER 10.\n**********************************************************************\n*\nABEND    ABEND (R10),DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n**********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n**********************************************************************\n* WORKING STORAGE AND CONSTANTS\n**********************************************************************\n*\nDS01TOK  DS    D\nDS01ALET DS    F\nDS01NAME DC    C'D01$$$$$'\nDS01GNAM DS    CL8\nMAXBYTES EQU   1000000\nINITBYTS EQU   250000\nMAXBLKS  DC    A((MAXBYTES+4095)/4096)\nINITBLKS DC    A((INITBYTS+4095)/4096)\nCURRBLKS DS    CL4\nDSBEGADR DS    F\n*\n*\n**********************************************************************\n* INITIAL TEST DATA COPIED INTO THE DATA SPACE\n**********************************************************************\n*\nDATA01   DC    10CL1'A'\nDATA02   DC    50CL1'B'\nDATA03   DC    25CL1'C'\nDATA04   DC    20CL1'D'\n*\n*\n**********************************************************************\n* TEST DATA USED TO UPDATE FIELDS IN THE DATA SPACE\n**********************************************************************\n*\nDATA11   DC    10CL1'1'\nDATA12A  DC    10CL1'0'\nDATA12B  DC    20CL1'X'\nDATA12C  DC    5CL1'Y'\nDATA12D  DC    15CL1'Z'\nDATA13   DC    25CL1'3'\nDATA14   DC    20CL1'4'\n*\n*\n**********************************************************************\n* FIELDS IN ADDRESS SPACE IN WHICH DATA IS READ FROM THE DATA SPACE\n**********************************************************************\n*\nNEWDATA  DS    0CL105\nDATAX1   DS    CL10\nDATAX2   DS    CL50\nDATAX3   DS    CL25\nDATAX4   DS    CL20\n*\n*\n**********************************************************************\n* ADDRESS LIST FOR ABEND MACRO FOR DUMPING DATA FROM THE DATA SPACE\n**********************************************************************\n*\nDUMPLST0 DS    0D\nDMBGADR  DS    F\nDMENDADR DS    F\nDMSTOKEN DS    D\n*\nDUMPLST  SNAPX SDATA=SUM,DSPSTOR=DUMPLST0,MF=L\n*\n*\n**********************************************************************\n* MAPPING DSECT FOR THE FIELDS IN THE DATA SPACE\n**********************************************************************\n*\nDSRECORD DSECT\nDSFLD01  DS    CL10\nDSFLD02  DS    0CL50\nDSFLD02A DS    CL10\nDSFLD02B DS    CL20\nDSFLD02C DS    CL5\nDSFLD02D DS    CL15\nDSFLD03  DS    CL25\nDSFLD04  DS    CL20\n*\n*\n**********************************************************************\n* END OF PROGRAM\n**********************************************************************\n*\n         END\n//*\n//*\n//G.SYSUDUMP DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160413": {"ttr": 8451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.13\n*\n*\nThis coding example illustrates the use of the DSPSERV macro\ninstruction to increase the size of the Data Space created in\nCODING EXAMPLE 16.4.3 by 250,000 bytes.\n\n\n[name]   DSPSERV EXTENT,STOKEN=DS01STOK,BLOCKS=EXPBLKS\n         ...\nDS01STOK DS    D           PROVIDED, RECEIVED FROM DSPSERV-CREATE MACRO\nEXPBYTES EQU   250000      REQUIRED EXPANSION SIZE IN BYTES\nEXPBLKS  DC    A((EXPBYTES-4095)/4096)      REQUIRED BLOCKS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160414": {"ttr": 8453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.14\n*\n*\n         L     R10,DS01ORGN      LOAD BEG ADDR OF DATA SPACE\n         LA    R11,2             LOAD NUMBER OF BLOCKS\n         DSPSERV RELEASE,STOKEN=DS01STOK,START=(R10),BLOCKS=(R11)\n         ...\nDS01ORGN DS    F    PROVIDED, RECEIVED FROM THE DSPSERV-CREATE MACRO\nDS01STOK DS    D    PROVIDED, RECEIVED FROM THE DSPSERV-CREATE MACRO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160415": {"ttr": 8455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.4.15\n*\n*\nThis coding example illustrates the use of the ALESERV and DSPSERV\nmacro instructions to remove the entry of a Data Space from the\naccess list and to delete the Data Space.\n\n\n         ALESERV DELETE,ALET=DS01ALET\n         DSPSERV DELETE,STOKEN=DS01STOK\n         ...\nDS01ALET DS    F    PROVIDED, RECEIVED FROM ALESERV-ADD MACRO\nDS01STOK DS    D    PROVIDED, RECEIVED FROM DSPSERV-CREATE MACRO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160501": {"ttr": 8457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.5.1\n*\n*\n          AMODE 31\n          RMODE ANY\n          ...\n          DSPSERV CREATE,TYPE=HIPERSPACE,SHARE=NO,STOKEN=HS01STOK,   -\n                NAME=HS01NAME,GENNAME=YES,OUTNAME=HS01GNAM,          -\n                BLOCKS=(MAXBLKS,INITBLKS),ORIGIN=HS01ORGN\n   *      ...\nHS01STOK  DS    D                 RECEIVED FROM THE DSPSERV MACRO\nHS01ORGN  DS    F                 RECEIVED FROM THE DSPSERV MACRO\nHS01NAME  DC    CL8'$H1'\nHS01GNAME DS    CL8\nMAXBYTES  EQU   10000000          REQUIRE MAX OF 10 MILLION BYTES\nINITBYTES EQU   1000000           REQUIRE 1 MILLION BYTES INITIALLY\nMAXBLKS   DC    A((MAXBYTES+4095)/4096)   NUMB 0F BLOCKS REQUIRED\nINITBLKS  DC    A(INITBYTES+4095)/4096)   NUMB OF BLOCKS REQUIRED\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CE160502": {"ttr": 8459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.5.2\n*\n*\nThis coding example illustrates to use of the DSPSERV macro\ninstruction to create an ESO Hiperspace while executing in AR-mode.\nThe Hiperspace is created with fetch protection using PSW key 0 with\nan initial allocation of 4096 megabytes expandable to 2 gigabytes.\n\n\n          AMODE 31\n          RMODE ANY\n          ...\n          SAC   512\n          SYSSTATE ASCENV=AR\n          ...\n          DSPSERV CREATE,TYPE=HIPERSPACE,HSTYPE=ESO,                -\n                NAME=HS02NAME,GENNAME=YES,OUTNAME=HS02GNAM,         -\n                STOKEN=HS02STOK,KEY=PSWKEY,FPROT=YES,               -\n                BLOCKS=(MAXBLKS,INITBLKS),ORIGIN=HS02ORGN\n          ...\nHS02STOK  DS    D            RECEIVED FROM THE DSPSERV MACRO\nHS02ORGN  DS    F            RECEIVED FROM THE DSPSERV MACRO\nHS02NAME  DC    CL8'$H2'\nHS02GNAME DS    CL8\nPSWKEY    DC    X'00'\nMAXBLKS   DC    A(524288)    NUMB 0F 4K BLOCKS - 2G BYTES\nINITBLKS  DC    A(100000)    NUMB OF 4K BLOCKS - 4096M BYTES\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160503": {"ttr": 8461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.5.3\n*\n*\n         AMODE 31\n         RMODE ANY\n         ...\n[name]   ALESERV ADD,STOKEN=HS01STOK,ALET=HS01ALET,AL=PASN\n         ...\nHS01STOK DS    D        PROVIDED, RECEIVED FROM DSPSERV-CREATE MACRO\nHS01ALET DS    F        RECEIVED FROM ALESERV-ADD MACRO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CE160504": {"ttr": 8463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\xd1\\x00\\xd1\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 209, "newlines": 209, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.5.4\n*\n*\n//-------- JOB   ----\n//STEP     EXEC  ASMACLG\n//C.SYSLIB DD    DSN=SYS1.MACLIB,DISP=SHR\n//         DD    DSN=USER.MACLIB,DISP=SHR\n//C.SYSIN DD *\n*\n*\nHIPRTEST CSECT\n*\n*\n**********************************************************************\n* INITIALIZATION\n**********************************************************************\n*\nHIPRTEST AMODE 31                  \\ INDICATE 31-BIT ADDRESSING\nHIPRTEST RMODE ANY                 /\n         INITL 3,4,5,EQU=R         SET UP BASE REGS AND SAVEAREA\n*\n*\n**********************************************************************\n* MAINSTREAM OF PROGRAM\n**********************************************************************\n*\n         BAL   R6,MAKEHS           CREATE THE HIPERSPACE\n         BAL   R6,GETMAIN          OBTAIN 4K-BYTE WORK AREA\nNEXTREC  BAL   R6,GETREC           BUILD A 4K BLOCK OF DATA\n         BAL   R6,PUTHS            WRITE THE 4K DATA BLOCK INTO HIPSPC\n         B     NEXTREC             GET NEXT REC AND BUILD 4K BLOCK\nRECEND   BAL   R6,SETBGADR         SET HIPERSPACE BLOCK PTR TO BEG\nNXTHSBLK BAL   R6,GETHS            READ A 4K DATA BLOCK FROM HIPSPC\n         BAL   R6,DUMPREC          DUMP SPECIFIC HIPSPC BLOCK, ABEND PGM\n         B     NXTHSBLK            READ NEXT 4K BLOCK FROM HIPSPC\nHSEND    B     RETURN              RETURN TO MVS OR CALLING PROGRAM\n*\n*\n**********************************************************************\n* THIS ROUTINE CREATES THE HIPERSPACE.\n**********************************************************************\n*\nMAKEHS   DSPSERV CREATE,TYPE=HIPERSPACE,STOKEN=HS01TOK,NAME=HS01NAME,  -\n               GENNAME=YES,OUTNAME=HS01GNAM,BLOCKS=(MAXBLKS,INITBLKS), -\n               NUMBLKS=CURRBLKS,ORIGIN=HSBGADDR\n         MVC   HSBLKPTR,HSBGADDR   INIT BLOCK PTR TO BG OF HIPERSPACE\n         LTR   R15,R15             CHECK IF CREATE WAS OK\n         BZR   R6                  IF YES, RETURN TO CALLING ROUTINE\n         LA    R10,901             IF NO, LOAD ABEND CODE\n         B     ABEND               ABEND PROGRAM WITH A DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE OBTAINS A 4K-BYTE WORKAREA. THIS AREA IS USED TO\n* BUILD A BLOCK OF DATA THAT IS WRITTEN INTO THE HIPERSPACE.\n**********************************************************************\n*\nGETMAIN  GETMAIN EU,LV=4096,BNDRY=PAGE,A=GMADDR\n         LA    R10,RECORDS         LOAD ADDR OF BEG OF RECORDS\n         ST    R10,RECPTR          STORE PTR TO CURRENT RECORD\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE OBTAINS THE NEXT 1024-BYTE RECORD FROM A TABLE AND\n* EXTENDS THE RECORD TO A 4K BLOCK OF DATA BY PROPAGATING THE\n* LETTER \"Z\" INTO THE LAST 3K BYTES OF THE BLOCK.\n**********************************************************************\n*\nGETREC   L     R10,GMADDR          LOAD ADDR OF WORK AREA\n         L     R11,RECPTR          LOAD ADDR OF NEXT RECORD\n         CLI   0(R11),X'FF'        CHECK FOR END-OF-TABLE OF RECORDS\n         BE    RECEND              IF YES, GO TO END OF RECS ROUTINE\n         MOVE  (R10),(R11),1024    IF NO, MOVE RECORD INTO WORK AREA\n         LA    R11,1024(0,R11)     INCR TO ADDR OF NEXT RECORD\n         ST    R11,RECPTR          SAVE ADDR OF NEXT RECORD\n         LA    R10,1024(0,R10)     INCR TO PAD AREA OF BLOCK\n         MOVE  (R10),C'Z',3072     PROP \"Z\" INTO LAST 3K OF BLOCK\n         AP    ASRECCTR,ONE        INCR RECORD COUNTER\n         BR    R6                  RETURN TO CALLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE WRITES THE 4K BLOCK OF DATA INTO THE HIPERSPACE.\n**********************************************************************\n*\nPUTHS    L     R10,GMADDR          LOAD ADDR OF WORK AREA (DATA BLOCK)\n         ST    R10,ASBUFADR        STORE THAT ADDR INTO HS-ADDR-LIST\n         L     R10,HSBLKPTR        LOAD ADDR OF NEXT HIPERSPACE BLOCK\n         ST    R10,HSBLKADR        STORE THAT ADDR INTO HS-ADDR-LIST\n         LA    R10,4095(0,R10)     \\   INCR HIPERSPACE BLOCK PTR TO\n         LA    R10,1(0,R10)         |  NEXT HIPERSPACE BLOCK ADDR\n         ST    R10,HSBLKPTR        /   AND SAVE THE NEW ADDR\n         LA    R10,HSADRLST        LOAD ADDR OF HIPERSPACE-ADDR-LIST\n         ST    R10,HSRNGADR        PROVIDE THAT ADDR TO HSPSERV MACRO\n         HSPSERV SWRITE,STOKEN=HS01TOK,RANGLIST=HSRNGADR\n         LTR   R15,R15             CHECK IF WRITE IS OK\n         BZR   R6                  IF YES, RETURN TO CALLING ROUTINE\n         LA    R10,902             IF NO, LOAD ABEND CODE\n         B     ABEND               ABEND PROGRAM WITH A DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE RESETS THE CURRENT HIPERSPACE BLOCK POINTER TO THE\n* BEGINNING.\n**********************************************************************\n*\nSETBGADR MVC   HSBLKPTR,HSBGADDR   SET HIPSPC BLOCK PTR TO BEG\n         BR    R6                  RETURN TO CLLING ROUTINE\n*\n*\n**********************************************************************\n* THIS ROUTINE SEQUENTIALLY READS A 4K BLOCK OF DATA FROM THE\n* HIPERSPACE STARTING WITH THE FIRST BLOCK.\n**********************************************************************\n*\nGETHS    CP    HSBLKCTR,ASRECCTR   CHECK IF ALL HIPSPC BOCKS READ\n         BE    HSEND               IF YES, GO TO END-OF-HS-DATA RTN\n         L     R10,GMADDR          IF NO, LOAD ADDR OF 4K RECV AREA\n         ST    R10,ASBUFADR        STORE THAT ADDR INTO HS-ADDR-LIST\n         L     R10,HSBLKPTR        LOAD ADDR OF NEXT HIPERSPACE BLOCK\n         ST    R10,HSBLKADR        STORE THAT ADDR INTO HS-ADDR-LIST\n         LA    R10,4095(0,R10)     \\   INCR HIPERSPACE BLOCK PTR TO\n         LA    R10,1(0,R10)         |  NEXT HIPERSPACE BLOCK ADDR\n         ST    R10,HSBLKPTR        /   AND SAVE THE NEW ADDR\n         LA    R10,HSADRLST        LOAD ADDR OF HIPERSPACE-ADDR-LIST\n         ST    R10,HSRNGADR        PROVIDE THAT ADDR TO HSPSERV MACRO\n         AP    HSBLKCTR,ONE        INCR HIPSPC BLOCK COUNTER\n         HSPSERV SREAD,STOKEN=HS01TOK,RANGLIST=HSRNGADR\n         LTR   R15,R15             CHECK IF READ IS OK\n         BZR   R6                  IF YES, RETURN TO CALLING ROUTINE\n         LA    R10,903             IF NO, LOAD ABEND CODE\n         B     ABEND               ABEND PROGRAM WITH A DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE CHECKS FOR A SPECIFIC HIPERSPACE BLOCK NUMBER AFTER IT\n* IS READ FROM THE HIPERSPACE. WHEN FOUND, DUMPS RECORD AND ABENDS\n* THE PROGRAM.\n**********************************************************************\n*\nDUMPREC  DS    0H\n         L     R8,GMADDR           LOAD BG ADDR OF HS BLOCK INTO R8\n         LA    R9,4095(0,R8)       LOAD END ADDR OF HS BLOCK INTO R9\n         CP    HSBLKCTR,=P'2'      CHECK FOR SPECIFIC BLOCK NUMBER\n         BNER  R6                  IF NO, RETURN TO CALLING ROUTINE\n         LA    R10,999             IF YES, LOAD ABEND CODE\n         B     ABEND               ABEND PROGRAM WITH A DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE ABENDS THE PROGRAM WITH A DUMP AND USES THE ABEND\n* CODE THAT WAS PRELOADED INTO REGISTER 10.\n**********************************************************************\n*\nABEND    ABEND (R10),DUMP\n*\n*\n**********************************************************************\n* THIS ROUTINE RESTORES THE REGISTERS AND RETURNS CONTROL.\n**********************************************************************\n*\nRETURN   RCNTL RC=0\n*\n*\n**********************************************************************\n* WORKING STORAGE AND CONSTANTS\n**********************************************************************\n*\nHS01TOK  DS    D\nHS01NAME DC    C'H01'\nHS01GNAM DS    CL8\nMAXBYTES EQU   1000000\nINITBYTS EQU   250000\nMAXBLKS  DC    A((MAXBYTES+4095)/4096)\nINITBLKS DC    A((INITBYTS+4095)/4096)\nCURRBLKS DS    CL4\nGMADDR   DS    F\nRECPTR   DS    F\nHSRNGADR DS    F\nHSBGADDR DS    F\nHSBLKPTR DS    F\nONE      DC    P'1'\nASRECCTR DC    PL4'0'\nHSBLKCTR DC    PL4'0'\n*\nRECORDS  DC    1024CL1'A'\nRECLEN   EQU   *-RECORDS\n         DC    1024CL1'B'\n         DC    1024CL1'C'\n         DC    1024CL1'D'\n         DC    X'FF'\n*\nHSADRLST DS    0F\nASBUFADR DS    F\nHSBLKADR DS    F\nHSBLOCKS DC    A(1)\n*\n*\n**********************************************************************\n* END OF PROGRAM\n**********************************************************************\n*\n         END\n//*\n//*\n//G.SYSUDUMP DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CE160505": {"ttr": 8467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00<\\x00<\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.5.5\n*\n*\n         MACRO\n&LABEL   MOVE  &TO,&FROM,&LEN\n         LCLC  &X,&C\n         AIF   (T'&LEN EQ 'O').MISOPRD\n         AIF   (T'&FROM EQ 'O').MISOPRD\n         AIF   (T'&TO EQ 'O').MISOPRD\n&LABEL   DS    0H\n         AIF   ('&LEN'(1,1) EQ '(').LENREG\n         L     1,=F'&LEN'\n.B2      AIF   ('&TO'(1,1) EQ '(').TOREG\n         LA    14,&TO\n.B3      AIF   ('&FROM'(1,2) EQ 'X''').LITX\n         AIF   ('&FROM'(1,2) EQ 'C''').LITC\n         AIF   ('&FROM'(1,1) EQ '(').FROMREG\n         LA    15,&FROM\n         AGO   .B1\n.LITX    ANOP\n&X       SETC  '&FROM'(2,4)\n         LA    15,=256XL1&X\n         AGO   .B1\n.LITC    ANOP\n&C       SETC  '&FROM'(2,3)\n         LA    15,=256CL1&C\n.B1      C     1,=F'256'\n         AIF   ('&FROM'(1,2) EQ 'X''').NOINCR1\n         AIF   ('&FROM'(1,2) EQ 'C''').NOINCR1\n         BL    *+26\n         AGO   .B4\n.NOINCR1 BL    *+22\n.B4      ANOP\n         MVC   0(256,14),0(15)\n         LA    14,256(0,14)\n         AIF   ('&FROM'(1,2) EQ 'X''').NOINCR2\n         AIF   ('&FROM'(1,2) EQ 'C''').NOINCR2\n         LA    15,256(0,15)\n.NOINCR2 S     1,=F'256'\n         B     *-26\n         C     1,=F'0'\n         BE    *+22\n         S     1,=F'1'\n         EX    1,*+8\n         B     *+10\n         MVC   0(0,14),0(15)\n         AGO   .END\n.LENREG  AIF   ('&LEN(1)' EQ '1').B2\n         LR    1,&LEN(1)\n         AGO   .B2\n.TOREG   AIF   ('&TO(1)' EQ '14').B3\n         LR    14,&TO(1)\n         AGO   .B3\n.FROMREG AIF   ('&FROM(1)' EQ '15').B1\n         LR    15,&FROM(1)\n         AGO   .B1\n.MISOPRD MNOTE 'ONE OR MORE REQUIRED OPERANDS ARE MISSING---MACRO NOT GC\n               ENERATED'\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETPARM": {"ttr": 8469, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.3\n*\n*\n         MACRO\n&LABEL   GETPARM &PARM\n&LABEL   B     *+106               BRANCH AROUND PARM HOLD AREA\n&PARM    DC    102CL1' '           DEFINE MAX LEN OF JCL PARM + 2 FOR\n*                                  ALIGNMENT AND TO SET DELIMITER\n         L     1,0(0,1)            LOAD JCL PARM ADR INTO REG 1\n         LH    15,0(0,1)           LOAD LEN OF JCL PARM INTO REG 15\n         LTR   15,15               WAS JCL PARM SPECIFIED?\n         BZ    *+24                IF NO, BRANCH OUT OF MACRO\n         BCTR  15,0                IF YES, DECR REG 15 FOR EX INSTR\n         EX    15,*+8              MOVE JCL PARM INTO PARM HOLD AREA\n         B     *+10                BRANCH AROUND MVC INSTR\n         MVC   &PARM,2(1)          SUBJECT INSTR FOR EX INSTR\n         LA    15,1(0,15)          INCR REG 15 BACK TO PARM LENGTH\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXTBL": {"ttr": 8471, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.1\n*\n*\n         MACRO\n&TBLNAME HEXTBL\n&TBLNAME DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'    00-0F\n         DC    X'F1',X15'00'                          10-1F\n         DC    X'F2',X15'00'                          20-2F\n         DC    X'F3',X15'00'                          30-3F\n         DC    X'F4',X15'00'                          40-4F\n         DC    X'F5',X15'00'                          50-5F\n         DC    X'F6',X15'00'                          60-6F\n         DC    X'F7',X15'00'                          70-7F\n         DC    X'F8',X15'00'                          80-8F\n         DC    X'F9',X15'00'                          90-9F\n         DC    X'C1',X15'00'                          A0-AF\n         DC    X'C2',X15'00'                          B0-BF\n         DC    X'C3',X15'00'                          C0-CF\n         DC    X'C4',X15'00'                          D0-DF\n         DC    X'C5',X15'00'                          E0-EF\n         DC    X'C6',X15'00'                          F0-FF\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INITL": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00q\\x00q\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.6.1\n*\n*\n         MACRO\n&LABEL   INITL &EQU=,&ID=,&SA=\n         LCLA  &POS,&TOTOPD,&DISP,&STOPSW,&REG13SW\n         LCLC  &SVAR,&LBL,&PRFX\n         LCLC  &REGS,&REG1,&REG2\n         AIF   (T'&LABEL NE 'O').B1\n         MNOTE *,'NO LABEL SPECIFIED'\n         AGO   .CHKEQU\n.B1      AIF   (K'&LABEL LE 8).LABOK\n         MNOTE 'LABEL EXCEEDS 8 CHARACTERS---LEFT MOST 8 USED'\n.LABOK   ANOP\n&LBL     SETC  '&LABEL'(1,8)\n.CHKEQU  AIF   (T'&EQU EQ 'O').B8\n         AIF   (K'&EQU LE 6).EQUOK\n         MNOTE 'EQU PREFIX EXCEEDS 6 CHARACTERS---LEFT MOST 6 USED'\n.EQUOK   ANOP\n&PRFX    SETC  '&EQU'(1,6)\n.B8      ANOP\n&SVAR    SETC  'SVAR'.'&SYSNDX'\n&TOTOPD  SETA  N'&SYSLIST\n         AIF   (&TOTOPD EQ 0).NOREG\n         AIF   (&TOTOPD LE 15).PROCEED\n         MNOTE 0,'MORE THAN 15 REGISTERS HAVE BEEN SPECIFIED---SURPLUS -\n               ONES HAVE BEEN IGNORED'\n&TOTOPD  SETA  15\n.PROCEED ANOP\n         AIF   (T'&EQU NE 'O').EQUTBL\n.B2      ANOP\n         AIF   (T'&ID NE 'O').SETID\n.B3      ANOP\n.ULOOP   ANOP\n&POS     SETA  &POS+1\n         AIF   (&POS GT &TOTOPD).USING\n         AIF   ('&SYSLIST(&POS)' EQ '13').REG13\n         AIF   ('&SYSLIST(&POS)' EQ '0').INVREG\n.B4      ANOP\n&REGS    SETC  '&REGS'.','.'&PRFX'.'&SYSLIST(&POS)'\n         AGO   .ULOOP\n.USING   ANOP\n         AIF   (&REG13SW EQ 1).USING13\n&LBL     STM   &PRFX.14,&PRFX.12,12(&PRFX.13)\n         BALR  &PRFX.&SYSLIST(1),0\n         USING *&REGS\n.B5      ANOP\n&POS     SETA  1\n         AIF   (&TOTOPD EQ 1).REST\n.NXLOAD  ANOP\n&POS     SETA  &POS+1\n         AIF   (&POS GT &TOTOPD).REST\n&REG1    SETC  '&SYSLIST(&POS-1)'\n&REG2    SETC  '&SYSLIST(&POS)'\n         LA    &PRFX.&REG2,2048\n         LA    &PRFX.&REG2,2048(&PRFX.&REG1,&PRFX.&REG2)\n         AGO   .NXLOAD\n.REG13   AIF   (&POS GT 1).INVREG\n&REG13SW SETA  1\n         AGO   .B4\n.USING13 ANOP\n         AIF   (T'&SA EQ 'O').B6\n&SVAR    SETC  '&SA'(1,8)\n.B6      ANOP\n&LBL     STM   &PRFX.14,&PRFX.12,12(&PRFX.13)\n         LR    &PRFX.2,&PRFX.13\n         BALR  &PRFX.12,0\n         BAL   &PRFX.13,76(0,&PRFX.12)\n&SVAR    DC    18F'0'\n         USING &SVAR&REGS\n         AGO   .B5\n.REST    AIF   (&REG13SW EQ 1).B7\n         GETMAIN R,LV=72,SP=1\n         ST    &PRFX.13,4(0,&PRFX.1)\n         ST    &PRFX.1,8(0,&PRFX.13)\n         LR    &PRFX.13,&PRFX.1\n         L     &PRFX.1,4(0,&PRFX.13)\n         L     &PRFX.1,24(0,&PRFX.1)\n         MEXIT\n.B7      ST    &PRFX.2,4(0,&PRFX.13)\n         ST    &PRFX.13,8(0,&PRFX.2)\n         MEXIT\n.EQUTBL  ANOP\n&PRFX.0  EQU   0\n&PRFX.1  EQU   1\n&PRFX.2  EQU   2\n&PRFX.3  EQU   3\n&PRFX.4  EQU   4\n&PRFX.5  EQU   5\n&PRFX.6  EQU   6\n&PRFX.7  EQU   7\n&PRFX.8  EQU   8\n&PRFX.9  EQU   9\n&PRFX.10 EQU   10\n&PRFX.11 EQU   11\n&PRFX.12 EQU   12\n&PRFX.13 EQU   13\n&PRFX.14 EQU   14\n&PRFX.15 EQU   15\n         AIF   (&REG13SW EQ 1).B5\n         AGO   .B2\n.SETID   B     12(0,&PRFX.15)\n         AIF   ('&ID'(1,1) EQ '*').CSECTNM\n         DC    CL8'&ID'\n         AGO   .B3\n.CSECTNM DC    CL8'&SYSECT'\n         AGO   .B3\n.NOREG   MNOTE 12,'NO REGISTERS SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n.INVREG  MNOTE 12,'INVALID REGISTER SPECIFIED---MACRO GENERATION TERMIN-\n               ATED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MOVE": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00<\\x00<\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 16.5.5\n*\n*\n         MACRO\n&LABEL   MOVE  &TO,&FROM,&LEN\n         LCLC  &X,&C\n         AIF   (T'&LEN EQ 'O').MISOPRD\n         AIF   (T'&FROM EQ 'O').MISOPRD\n         AIF   (T'&TO EQ 'O').MISOPRD\n&LABEL   DS    0H\n         AIF   ('&LEN'(1,1) EQ '(').LENREG\n         L     1,=F'&LEN'\n.B2      AIF   ('&TO'(1,1) EQ '(').TOREG\n         LA    14,&TO\n.B3      AIF   ('&FROM'(1,2) EQ 'X''').LITX\n         AIF   ('&FROM'(1,2) EQ 'C''').LITC\n         AIF   ('&FROM'(1,1) EQ '(').FROMREG\n         LA    15,&FROM\n         AGO   .B1\n.LITX    ANOP\n&X       SETC  '&FROM'(2,4)\n         LA    15,=256XL1&X\n         AGO   .B1\n.LITC    ANOP\n&C       SETC  '&FROM'(2,3)\n         LA    15,=256CL1&C\n.B1      C     1,=F'256'\n         AIF   ('&FROM'(1,2) EQ 'X''').NOINCR1\n         AIF   ('&FROM'(1,2) EQ 'C''').NOINCR1\n         BL    *+26\n         AGO   .B4\n.NOINCR1 BL    *+22\n.B4      ANOP\n         MVC   0(256,14),0(15)\n         LA    14,256(0,14)\n         AIF   ('&FROM'(1,2) EQ 'X''').NOINCR2\n         AIF   ('&FROM'(1,2) EQ 'C''').NOINCR2\n         LA    15,256(0,15)\n.NOINCR2 S     1,=F'256'\n         B     *-26\n         C     1,=F'0'\n         BE    *+22\n         S     1,=F'1'\n         EX    1,*+8\n         B     *+10\n         MVC   0(0,14),0(15)\n         AGO   .END\n.LENREG  AIF   ('&LEN(1)' EQ '1').B2\n         LR    1,&LEN(1)\n         AGO   .B2\n.TOREG   AIF   ('&TO(1)' EQ '14').B3\n         LR    14,&TO(1)\n         AGO   .B3\n.FROMREG AIF   ('&FROM(1)' EQ '15').B1\n         LR    15,&FROM(1)\n         AGO   .B1\n.MISOPRD MNOTE 'ONE OR MORE REQUIRED OPERANDS ARE MISSING---MACRO NOT GC\n               ENERATED'\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PUTTBL": {"ttr": 8710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00E\\x00E\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.5.2\n*\n*\n         MACRO\n&LABEL   PUTTBL &TABLE,&ENTRY,&ENTLEN,&KEYLEN\n         LCLC   &LBL\n&LBL     SETC  '$'.'PTB'.'&SYSNDX'(2,3)    DEFINE LABEL BASE\n.*\n.* VERIFY THAT BOTH &ENTLEN AND &KEYLEN ARE SELF-DEFINING TERMS\n.*\n         AIF   (T'&ENTLEN EQ 'N' AND T'&KEYLEN EQ 'N').VRFY255\n         MNOTE 4,'SPECIFIED ENTRY-LENGTH OR SPECIFIED KEY-LENGTH NOT VA-\n               LID---MACRO NOT GENERATED'\n         MEXIT\n.*\n.* VERIFY THAT BOTH &ENTLEN AND &KEYLEN ARE LESS THAN 256\n.*\n.VRFY255 AIF   (&ENTLEN LE 255 AND &KEYLEN LE 255).CHKREL\n         MNOTE 4,'SPECIFIED ENTRY-LENGTH OR SPECIFIED KEY-LENGTH EXCEED-\n               S 255---MACRO NOT GENERATED'\n         MEXIT\n.*\n.* VERIFY THAT &ENTLEN IS GREATER THAN OR EQUAL TO &KEYLEN\n.*\n.CHKREL  AIF   (&ENTLEN GE &KEYLEN).CHKREGT\n         MNOTE 4,'SPECIFIED KEY-LENGTH IS GREATER THAN SPECIFIED ENTRY--\n               LENGTH---MACRO NOT GENERATED'\n         MEXIT\n.*\n.* CHECK IF &TABLE IS SPECIFIED AS A REGISTER\n.*\n.CHKREGT AIF   ('&TABLE'(1,1) EQ '(').REGTBL\n         LA    14,&TABLE                LD ADR OF BG OF TBL INTO REG 14\n         AGO   .B1\n.REGTBL  LR    14,&TABLE(1)             LD ADR OF BG OF TBL INTO REG 14\n.B1      ANOP\n&LBL.A   CLI   0(14),X'00'              CHK FOR VACANT SPOT IN TBL\n         BE    &LBL.B                   IF YES, BRANCH TO INSERT RTN\n.*\n.* CHECK IF &ENTRY IS SPECIFIED AS A REGISTER\n.*\n.CHKREGE AIF   ('&ENTRY'(1,1) EQ '(').REGENT1\n         CLC   0(&KEYLEN,14),&ENTRY     CHK FOR DUPL ENTRY\n         AGO   .B2\n\n.REGENT1 CLC   0(&KEYLEN,14),0(&ENTRY(1)) CHK FOR DUPL ENTRY\n.B2      BE    &LBL.C                   IF YES, BRANCH TO UPDATE RTN\n         CLI   0(14),X'FF'              CHK FOR END OF TBL\n         BE    &LBL.D                   IF YES, BRANCH TO TBLEND RTN\n         LA    14,&ENTLEN.(0,14)        INCR TO NEXT TABLE SLOT\n         B     &LBL.A                   BRANCH BACK TO BG OF LOOP\n         AIF   ('&ENTRY'(1,1) EQ '(').REGENT2\n&LBL.B   MVC   0(&ENTLEN,14),&ENTRY     MOVE NEW ENTRY INTO TBL\n         AGO   .B3\n.REGENT2 ANOP\n&LBL.B   MVC   0(&ENTLEN,14),0(&ENTRY(1)) MOVE NEW ENTRY INTO TBL\n.B3      LA    15,0                     NEW ENTRY, SET RC = 0\n         B     &LBL.E                   BRANCH OUT OF MACRO\n         AIF   ('&ENTRY'(1,1) EQ '(').REGENT3\n&LBL.C   MVC   0(&ENTLEN,14),&ENTRY     REPLACE DUPL ENTRY\n         AGO   .B4\n.REGENT3 ANOP\n&LBL.C   MVC   0(&ENTLEN,14),0(&ENTRY(1)) REPLACE DUPL ENTRY\n.B4      LA    15,4                     REPLACE ENTRY, SET RC = 4\n         B     &LBL.E                   BRANCH OUT OF MACRO\n&LBL.D   LA    15,8                     END OF TBL, SET RC = 8\n&LBL.E   DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PUTTBL2": {"ttr": 8712, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.4\n*\n*\n         MACRO\n&LABEL   PUTTBL &TABLE,&ENTRY,&ENTLEN,&KEYLEN\n&LABEL   LA    14,&TABLE              LOAD ADR OF BG OF TBL INTO REG 14\n$SCANTBL CLI   0(14),X'00'            CHK FOR VACANT SPOT IN TBL\n         BE    $INSTBL                IF YES, BRANCH TO INSERT RTN\n         CLC   0(&KEYLEN,14),&ENTRY   CHK FOR DUPL ENTRY\n         BE    $UPDTBL                IF YES, BRANCH TO UPDATE RTN\n         CLI   0(14),X'FF'            CHK FOR END OF TBL\n         BE    $TBLEND                IF YES, BRANCH TO TBLEND RTN\n         LA    14,&ENTLEN.(0,14)      INCR TO NEXT TABLE SLOT\n         B     $SCANTBL               BRANCH BACK TO BG OF LOOP\n$INSTBL  MVC   0(&ENTLEN,14),&ENTRY   MOVE NEW ENTRY INTO TBL\n         LA    15,0                   NEW ENTRY, SET RC = 0\n         B     $PTBLEND               BRANCH OUT OF MACRO\n$UPDTBL  MVC   0(&ENTLEN,14),&ENTRY   REPLACE DUPL ENTRY\n         LA    15,4                   REPLACE ENTRY, SET RC = 4\n         B     $PTBLEND               BRANCH OUT OF MACRO\n$TBLEND  LA    15,8                   END OF TBL, SET RC = 8\n$PTBLEND DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCNTL": {"ttr": 8714, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00)\\x00)\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.6.2\n*\n*\n         MACRO\n&LABEL   RCNTL &RC=,&SA=\n         LCLC  &SVAR\n         AIF   (K'&LABEL LE 8).LABOK\n         MNOTE 0,'LABEL CONTAINS MORE THAN 8 CHARACTERS---MACRO NOT GEN-\n               ERATED'\n         MEXIT\n.LABOK   ANOP\n         AIF   (T'&SA EQ 'O').NOSA\n         AIF   ('&SA'(1,1) EQ '(').SAREG\n&SVAR    SETC  '&SA'(1,8)\n&LABEL   LA    13,&SVAR+4\n         AGO   .CHKRC\n.SAREG   ANOP\n&LABEL   L     13,4(0,&SA(1))\n         AGO   .CHKRC\n.NOSA    ANOP\n&LABEL   L     13,4(0,13)\n.CHKRC   AIF   (T'&RC EQ 'O').NORC\n         AIF   ('&RC'(1,1) EQ '(').RCREG\n         AIF   (T'&RC NE 'N').RCINVAL\n         AIF   (&RC GT 4095).RCINVAL\n         LA    15,&RC\n         AGO   .RCOK\n.RCREG   AIF   (&RC(1) EQ 15).RCOK\n         MNOTE 0,'INVALID REGISTER SPECIFIED FOR RETURN CODE---RC IGNOR-\n               ED'\n         AGO   .NORC\n.RCINVAL MNOTE 0,'RETURN CODE SPECIFIED IS INVALID---RC IGNORED'\n         AGO   .NORC\n.RCOK    L     14,12(0,13)\n         LM    0,12,20(13)\n         BR    14\n         MEXIT\n.NORC    LM    14,12,12(13)\n         BR    14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "READDIR": {"ttr": 8716, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00O\\x00O\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 8.3.3\n*\n*\n         MACRO\n&LABEL   READDIR &DDNAME\n         GBLA  &RDIRSW             USED TO PREVENT DUPL GEN $-AREAS\n         LCLC  &LBL                USED TO GEN UNIQUE LABELS\n&LBL     SETC  '$'.'RDR'.'&SYSNDX'(2,3)   SET LABEL PREFIX\n&LABEL   LM    14,1,&LBL.A         RESTORE REG 14, 15, 0, 1 FROM PREV\n*                                  EXEC OF READDIR MACRO\n         ST    2,&LBL.B            SAVE REG 2\n         B     &LBL.O              BRANCH AROUND CONSTANTS\n&LBL.A   DS    4F                  SAVE AREA FOR REGS 14, 15, 0, 1\n&LBL.B   DS    F                   SAVE AREA FOR REG 2\n&LBL.C   DC    F'0'                AREA TO EXPAND DIR ENTRY SIZE FIELD\n*                                  TO FULLWORD\n         AIF   (&RDIRSW EQ 1).BYPASS   CHECK IF $-AREAS WERE DEFINED\n$MEMBER  DS    CL8                 MEMBER NAME\n$TTRC    DS    CL4                 TTRC FIELD\n&RDIRSW  SETA  1                   INDICATE THAT $MEMBER AND $TTRC\n*                                  ARE DEFINED\n.BYPASS  ANOP\n*        DCB   BLKSIZE=256,LRECL=256,RECFM=F,DDNAME=&DDNAME,           -\n*              MACRF=GM,DSORG=PS,EODAD=&LBL.J\n&LBL.D   DCB   BLKSIZE=256,LRECL=256,RECFM=F,DDNAME=&DDNAME,           -\n               MACRF=GM,DSORG=PS,EODAD=&LBL.J\n&LBL.E   DC    C'0'                OPEN SWITCH\n&LBL.H   DS    CL256               DIRECTORY AREA\n&LBL.N   DC    8XL1'FF'            END OF DIR INDICATOR\n&LBL.O   CLI   &LBL.E,C'1'         CHK IF DIR OPENED\n         BE    &LBL.F              IF YES, BRANCH AROUND OPEN AND\n*                                  FIRST GET\n*        OPEN  &LBL.D              OPEN DIR DCB\n         OPEN  &LBL.D\n         TM    &LBL.D+48,X'10'     CHECK IF PDS JCL DD STMT SPECIFIED\n         BNO   &LBL.P              IF NOT, INDICATE IT\n         MVI   &LBL.E,C'1'         SET OPEN SWITCH\n*        GET   &LBL.D,&LBL.H       GET DIR BLOCK\n&LBL.G   GET   &LBL.D,&LBL.H\n         LA    15,2                START RUNNING DIR BLOCK COUNT\n         LA    1,2(0,1)            INCR REG1 PAST DIR COUNT FIELD\n         LH    14,&LBL.H           LOAD REG14 WITH DIR BLOCK COUNT\n         B     &LBL.I              GET MEMBER NAME\n&LBL.F   MVC   &LBL.C+3(1),11(1)   EXPAND ENTRY SIZE FIELD TO FULLWORD\n         NI    &LBL.C+3,X'1F'      ZERO HIGH ORDER 3 BITS TO ISOLATE\n*                                  USERDATA LENGTH\n         L     2,&LBL.C            LOAD ENTRY USERDATA LEN (HALFWORDS)\n*                                  INTO REG2\n         LA    2,12(2,2)           LOAD ENTRY LENGTH (BYTES) INTO REG2\n         AR    15,2                ADD CURRENT ENTRY LEN TO RUNNING DIR\n*                                  BLOCK COUNT\n         CR    15,14               COMPARE RUNNING DIR BLOCK COUNT TO\n*                                  DIR BLOCK COUNT\n         BNL   &LBL.G              IF NOT LOW, ENTIRE DIR BLK PROCESSED\n         LA    1,0(2,1)            INCR REG1 TO NEXT ENTRY\n&LBL.I   CLC   0(8,1),&LBL.N       COMPARE FOR LOGICAL END OF DIR\n         BE    &LBL.J              IF EQUAL, DIR END\n         MVC   $MEMBER,0(1)        MOVE MEMBER NAME\n         MVC   $TTRC,8(1)          MOVE TTRC FIELD\n         TM    11(1),X'80'         CHK IF MEMBER NAME IS AN ALIAS\n         BO    &LBL.K              IF BIT ON, ALIAS\n         B     &LBL.L              NORMAL END\n&LBL.P   LA    R15,12              INDICATE PDS JCL DD STMT MISSING\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.J   MVI   &LBL.E,C'0'         ZERO OPEN SWITCH\n*        CLOSE &LBL.D              CLOSE DIR DCB\n         CLOSE &LBL.D\n         XC    $MEMBER,$MEMBER     CLEAR MEMBER NAME AT END OF DIR\n         LA    15,8                INDICATE END OF DIR\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.K   STM   14,1,&LBL.A         SAVE REG 14, 15, 1\n         LA    15,4                INDICATE ALIAS\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.L   STM   14,1,&LBL.A         SAVE REG 14, 15, 1\n         LA    15,0                NORMAL END\n         B     &LBL.M              BRANCH OUT OF MACRO\n&LBL.M   L     2,&LBL.B            RESTORE REG2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SNAPA": {"ttr": 8719, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x98\\x00\\x98\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 4.17.3\n*\n*\n         MACRO\n&LABEL   SNAPA &BGADR,&ENDADR,&DATA=O,&SNAP=O\n         GBLA  &SNAPA\n         GBLC  &SNAPA1\n         LCLA  &SUB,&OPT,&JLPA,&CB,&SPLS,&NOADRSW\n         LCLC  &LBL\n&SNAPA   SETA  &SNAPA+1\n&LBL     SETC  '$'.'SNP'.'&SYSNDX'(2,3)\n         AIF   (&SNAPA GT 1).B7\n&SNAPA1  SETC  '&LBL'\n.B7      ANOP\n&LABEL   STM   14,1,&SNAPA1\n         AIF   (&SNAPA GT 1).B1\n         B     &LBL.A\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=W,BLKSIZE=882,LRECL=125,       -\n               DDNAME=SNAPDUMP\n&SNAPA1  DS    4F\n&LBL.A   EQU   *\n         OPEN  (SNAPDCB,(OUTPUT))\n.B1      AIF   ('&SNAP' EQ 'NO').ENDX\n         AIF   (T'&BGADR EQ 'O').NOADR\n         AIF   (T'&ENDADR EQ 'O').NOADR\n         AIF   ('&BGADR'(1,1) EQ '(').BGREG\n         LA    14,&BGADR\n.B6      AIF   ('&ENDADR'(1,1) EQ '(').ENDREG\n         LA    15,&ENDADR\n         AGO   .B2\n.NOADR   ANOP\n&NOADRSW SETA  1\n.B2      ANOP\n         AIF   ('&DATA' EQ 'O').SNAP0\n&SUB     SETA  N'&DATA+1\n.B3      ANOP\n&SUB     SETA  &SUB-1\n         AIF   (&SUB EQ 0).NOMORE\n         AIF   ('&DATA(&SUB)' EQ 'ALL').SNAP1\n         AIF   ('&DATA(&SUB)' EQ 'JLPA').JLPA\n         AIF   ('&DATA(&SUB)' EQ 'CB').CB\n         AIF   ('&DATA(&SUB)' EQ 'SPLS').SPLS\n         MNOTE 'INVALID CODE SPECIFIED---CODE IGNORED'\n         AGO   .B3\n.JLPA    ANOP\n&JLPA    SETA  1\n         AGO   .B3\n.CB      ANOP\n&CB      SETA  1\n         AGO   .B3\n.SPLS    ANOP\n&SPLS    SETA  1\n         AGO   .B3\n.BGREG   AIF   ('&BGADR' EQ '(14)').B6\n         LR    14,&BGADR(1)\n         AGO   .B6\n.ENDREG  AIF   ('&ENDADR' EQ '(15)').B2\n         LR    15,&ENDADR(1)\n         AGO   .B2\n.NOMORE  ANOP\n         AIF   (&JLPA EQ 1).MKJPA\n.B4      AIF   (&CB EQ 1).MKCB\n.B5      AIF   (&SPLS EQ 1).MKSPLS\n         AGO   .CHKOPT\n.MKJPA   ANOP\n&OPT     SETA  &OPT+100\n         AGO   .B4\n.MKCB    ANOP\n&OPT     SETA  &OPT+10\n         AGO   .B5\n.MKSPLS  ANOP\n&OPT     SETA  &OPT+1\n.CHKOPT  AIF   (&OPT EQ 111).SNAP1\n         AIF   (&OPT EQ 110).SNAP2\n         AIF   (&OPT EQ 101).SNAP3\n         AIF   (&OPT EQ 100).SNAP4\n         AIF   (&OPT EQ 11).SNAP5\n         AIF   (&OPT EQ 10).SNAP6\n         AIF   (&OPT EQ 1).SNAP7\n.SNAP0   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP0A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),PDATA=REGS,ID=&SNAPA\n         AGO   .END\n.SNAP0A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=REGS,ID=&SNAPA\n         AGO   .END\n.SNAP1   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP1A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,ALLPA,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP1A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,ALLPA,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP2   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP2A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,ALLPA,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP2A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,ALLPA,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP3   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP3A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),                        -\n               PDATA=(REGS,ALLPA,SPLS),ID=&SNAP\n         AGO   .END\n.SNAP3A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,ALLPA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP4   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP4A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),PDATA=(REGS,ALLPA),     -\n               ID=&SNAPA\n         AGO   .END\n.SNAP4A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,ALLPA),ID=&SNAPA\n         AGO   .END\n.SNAP5   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP5A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP5A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,PSW,SA,SPLS),ID=&SNAPA\n         AGO   .END\n.SNAP6   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP6A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),SDATA=(CB,Q),           -\n               PDATA=(REGS,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP6A  ANOP\n         SNAP  DCB=SNAPDCB,SDATA=(CB,Q),                               -\n               PDATA=(REGS,PSW,SA),ID=&SNAPA\n         AGO   .END\n.SNAP7   ANOP\n         AIF   (&NOADRSW EQ 1).SNAP7A\n         SNAP  DCB=SNAPDCB,STORAGE=((14),(15)),PDATA=(REGS,SPLS),      -\n               ID=&SNAPA\n         AGO   .END\n.SNAP7A  ANOP\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,SPLS),ID=&SNAPA\n.END     ANOP\n*\n         MNOTE *,'ID # FOR THIS SNAP IS &SNAPA'\n*\n.ENDX    LM    14,1,&SNAPA1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRTBL": {"ttr": 8723, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"X\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:58:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 3.3.2\n*\n*\n         MACRO\n&TBLNAME TRTBL &ASTERIK=*,&HYPHEN=-,&PERCENT=%,&PLUS=+,&QUES=?\n&TBLNAME DC    256AL1(*-&TBLNAME)    GEN 256-BYTE TBL OF X'00' TO X'FF'\n         ORG   &TBLNAME+C'*'         SET TBL PTR TO ASTERISK POS\n         DC    C'&ASTERIK'           ASTERISK TRANS CHAR\n         ORG   &TBLNAME+C'-'         SET TBL PTR TO HYPEN POS\n         DC    C'&HYPHEN'            HYPHEN TRANS CHAR\n         ORG   &TBLNAME+C'%'         SET TBL PTR TO PERCENT SIGN POS\n         DC    C'&PERCENT'           PERCENT SIGN TRANS CHAR\n         ORG   &TBLNAME+C'+'         SET TBL PTR TO PLUS SIGN POS\n         DC    C'&PLUS'              PLUS SIGN TRANS CHAR\n         ORG   &TBLNAME+C'?'         SET TBL PTR TO QUESTION MARK POS\n         DC    C'&QUES'              QUESTION MARK TRANS CHAR\n         ORG   &TBLNAME+256          ADJ LOC CTR PASSED END-OF-TBL\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VALNUMB": {"ttr": 8962, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x003\\x003\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 5.5.3\n*\n*\n         MACRO\n&LABEL   VALNUMB &ADR,&LEN\n         LCLC  &LBL\n&LBL     SETC  '$'.'VAL'.'&SYSNDX'(2,3)\n         AIF   (T'&ADR EQ 'O').NOADR\n         AIF   ('&ADR'(1,1) EQ '(').REGA\n         AIF   (T'&LEN EQ 'O').ADRONLY\n         AIF   (T'&LEN NE 'N').INVLEN\n&LABEL   TRT   &ADR.(&LEN),&LBL.A\n         AGO   .BC\n.ADRONLY ANOP\n&LABEL   TRT   &ADR,&LBL.A\n.BC      BC    8,&LBL.B\n         B     &LBL.C\n         AGO   .REST\n.REGA    AIF   (T'&LEN EQ 'O').NOLEN\n         AIF   ('&LEN'(1,1) EQ '(').REGAL\n&LABEL   TRT   0(&LEN,&ADR(1)),&LBL.A\n         BC    8,&LBL.B\n         B     &LBL.C\n         AGO   .REST\n.REGAL   ANOP\n&LABEL   BCTR  &LEN(1),0\n         EX    &LEN(1),&LBL.E\n         LA    &LEN(1),1(0,&LEN(1))\n         BC    8,&LBL.B\n         B     &LBL.C\n&LBL.E   TRT   0(0,&ADR(1)),&LBL.A\n.REST    ANOP\n&LBL.A   DC    256XL1'01'\n         ORG   &LBL.A+C'0'\n         DC    10XL1'00'\n         ORG   &LBL.A+256\n&LBL.B   LA    R15,0\n         B     &LBL.D\n&LBL.C   LA    R15,4\n         B     &LBL.D\n&LBL.D   DS    0H\n         MEXIT\n.NOADR   MNOTE 4,'DATA FIELD ADDRESS NOT SPECIFIED---MACRO NOT GENERATE-\n               D'\n         MEXIT\n.NOLEN   MNOTE 4,'LENGTH NOT SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n.INVLEN  MNOTE 4,'INVALID LENGTH SPECIFIED---MACRO NOT GENERATED'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOREGS": {"ttr": 8964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.6.1\n*\n*\n         MACRO\n&LABEL   WTOREGS &MSG\n         GBLC  &WTOREGS\n         AIF   ('&MSG'(1,1) NE '''').ERR01\n         AIF   ('&WTOREGS' EQ '1').START\n&WTOREGS SETC  '1'\n         WTOREGS0\n.START   STM   0,15,##SVREGS\n         WTO   &MSG\n         BAL   R14,##DSPLY\n         LM    0,15,##SVREGS\n         DS    0H\n         MEXIT\n.ERR01   MNOTE 4,'*** MESSAGE NOT ENCLOSED IN APOSTHOPHIES --- MACRO NO-\n               T GENERATED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOREGS0": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x002O\\x01\\x002O\"Y\\x00w\\x00w\\x00\\x00\\xc3\\xc1\\xd9\\xd4\\xc9\\xd5\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-19T00:00:00", "modifydate": "2000-11-19T22:59:00", "lines": 119, "newlines": 119, "modlines": 0, "user": "CARMINE"}, "text": "*\n* CODING EXAMPLE 2.6.2\n*\n*\n         MACRO\n         WTOREGS0\n         B     ##BYPASS\n*\n##DSPLY  ST    14,##SAVR14\n         LA    10,4\n         LA    11,4\n         LA    15,##SVREGS\n         LA    14,##R00\n##SETLNE LA    0,4\n         BAL   1,##NXTR\n         LA    14,6(0,14)\n         BCT   10,##SETLNE\n         LA    10,4\n         LA    14,4(0,14)\n         BCT   11,##SETLNE\n         B     ##DOWTOS\n*\n##NXTR   MVI   ##BYTE1,X'00'\n         MVI   ##BYTE2,X'00'\n         MVZ   ##BYTE1,0(15)\n         MVN   ##BYTE2,0(15)\n         TR    ##BYTE1,##TRTBL\n         TR    ##BYTE2,##TRTBL\n         MVC   0(1,14),##BYTE1\n         MVC   1(1,14),##BYTE2\n         LA    14,2(0,14)\n         LA    15,1(0,15)\n         BCT   0,##NXTR\n         BR    1\n*\n##DOWTOS LA    R1,##WLST1\n         WTO   MF=(E,(R1))\n         LA    R1,##WLST2\n         WTO   MF=(E,(R1))\n         LA    R1,##WLST3\n         WTO   MF=(E,(R1))\n         LA    R1,##WLST4\n         WTO   MF=(E,(R1))\n         L     14,##SAVR14\n         BR    R14\n*\n         CNOP  0,4\n##WLST1  DC    AL2(##WLST1X-##WLST1)\n         DC    X'8000'\n         DC    C'R00='\n##R00    DS    CL8\n         DC    C'  R01='\n##R01    DC    CL8'XXXXXXXX'\n         DC    C'  R02='\n##R02    DS    CL8\n         DC    C'  R03='\n##R03    DC    CL8'XXXXXXXX'\n##WLST1X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n         CNOP  0,4\n##WLST2  DC    AL2(##WLST2X-##WLST2)\n         DC    X'8000'\n         DC    C'R04='\n##R04    DS    CL8\n         DC    C'  R05='\n##R05    DS    CL8\n         DC    C'  R06='\n##R06    DS    CL8\n         DC    C'  R07='\n##R07    DS    CL8\n##WLST2X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n         CNOP  0,4\n##WLST3  DC    AL2(##WLST3X-##WLST3)\n         DC    X'8000'\n         DC    C'R08='\n##R08    DS    CL8\n         DC    C'  R09='\n##R09    DC    CL8'XXXXXXXX'\n         DC    C'  R10='\n##R10    DS    CL8\n         DC    C'  R11='\n##R11    DS    CL8\n##WLST3X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n         CNOP  0,4\n##WLST4  DC    AL2(##WLST4X-##WLST4)\n         DC    X'8000'\n         DC    C'R12='\n##R12    DS    CL8\n         DC    C'  R13='\n##R13    DS    CL8\n         DC    C'  R14='\n##R14    DS    CL8\n         DC    C'  R15='\n##R15    DS    CL8\n##WLST4X EQU   *\n         DC    X'0000'\n         DC    X'0020'\n*\n##SAVR14 DS    F\n##SVREGS DS    16F\n##BYTE1  DC    X'00'\n##BYTE2  DC    X'00'\n##TRTBL  DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6F1'\n         DC    15XL1'00',X'F2',15XL1'00',X'F3',15XL1'00',X'F4'\n         DC    15XL1'00',X'F5',15XL1'00',X'F6',15XL1'00',X'F7'\n         DC    15XL1'00',X'F8',15XL1'00',X'F9',15XL1'00',X'C1'\n         DC    15XL1'00',X'C2',15XL1'00',X'C3',15XL1'00',X'C4'\n         DC    15XL1'00',X'C5',15XL1'00',X'C6'\n*\n##BYPASS DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT069/FILE069.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT069", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}