{"INMR01": {"INMLRECL": 80, "INMFNODE": "ORIGNODE", "INMFUID": "ORIGUID", "INMTNODE": "DESTNODE", "INMTUID": "DESTUID", "INMFTIME": "20110415122056000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 881790, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 3200, "INMRECFM": "FB", "INMDIR": 20, "INMDSNAM": "JUERGEN.V.ASM", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 3216, "INMBLKSZ": 3220, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"JUERGEN.V.ASM": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 3200, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3220, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0bvD\\x04\\x9a\\xec\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0bvD\\x04\\x9a\\xec\\xd8'", "b'X\\x00%\\xf8\\x00\\x00\\x00L\\x00\\x08\\x00M\\x00\\x07\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"UNFOLDEM": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00 \\x01\\x11\\x10?\\x01\\x11\\x10?#T\\x01\\xb7\\x01\\xad\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2011-04-13T00:00:00", "modifydate": "2011-04-13T23:54:20", "lines": 439, "newlines": 429, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'UNFOLDEM -- UNFOLD FB-80 DATA INTO A LONG BUFFER'\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\nUNFOLDEM CSECT\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    UNFOLDEM                                          *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating a       *\n*      real tape from an AWS-format tape file, which has been       *\n*      folded over into an FB-80 dataset.  The AWS header           *\n*      contains the number of bytes in the next chunk (complete     *\n*      or partial block) of tape data.  Once this quantity is       *\n*      known, and the beginning position of the data has been       *\n*      established (it starts just after the header ends), then     *\n*      the data itself has to be moved into a buffer, in            *\n*      preparation for that data block being written out to a       *\n*      tape.  This program unfolds the correct amount of data,      *\n*      beginning at a known position in the FB-80 file, into        *\n*      the buffer.  The position in the FB-80 file which marks      *\n*      the beginning of the data to be moved, is called the         *\n*      OFFSET into the 80-byte card, and it starts with position    *\n*      +0.                                                          *\n*                                                                   *\n*  INPUTS and OUTPUTS:   Described below.                           *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called AWSIN, which contains its input         *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do GETs from AWSIN, and if necessary, it needs      *\n*      to write messages to SYSPRINT.  The caller has to provide    *\n*      ENTRY AWSIN and ENTRY SYSPRINT statements in front of        *\n*      the AWSIN and SYSPRINT DCBs, respectively.                   *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      UNFAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      UNFAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the UNFAREA.                                        *\n*                                                                   *\n*      The caller does one GET of the FB-80 file, to read an        *\n*      AWS header (that has tape data following it).  Once the      *\n*      AWS header has been read, there should be enough data to     *\n*      supply to the UNFAREA control block, and then this           *\n*      program is called, to complete the move of that tape data    *\n*      to a buffer, and position the FB-80 input just past the      *\n*      data moved, so it should point to the next AWS header.       *\n*                                                                   *\n*      This program does more GETs from the FB-80 input file,       *\n*      until the request for the number of bytes to be moved,       *\n*      is satisfied.                                                *\n*                                                                   *\n*      The following is the layout of the UNFAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      UNFAREA  DS    0F          UNFOLD AREA CONTROL BLOCK         *\n*      *                          ------ ---- ------- -----         *\n*  --> UNFSCARD DC    F'0'        Start address of 80-byte card     *\n*  --> UNFECARD DC    F'0'        End address of 80-byte card       *\n*  --> UNFOFFST DC    F'0'        OFFSET of data to be moved        *\n*  --> UNFBYTES DC    F'0'        Number of bytes to be unfolded    *\n*      UNFBYMVD DC    F'0'        Number of bytes that were moved   *\n*  --> UNFBUFFR DC    F'0'        Current start address in buffer   *\n*  --> UNFBSTRT DC    F'0'        Original start address of buffer  *\n*      UNFINRCD DC    PL7'0'      Number of GETs for AWSIN records  *\n*      UNFLENTH EQU   *-UNFAREA                                     *\n*      *                                                            *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      UNFBUFFR and UNFOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the output data     *\n*      and input data positions, respectively, that are just        *\n*      after the moved data, so as to wait for the next call,       *\n*      to be able to move more data.  UNFBSTRT preserves the        *\n*      very beginning address of the output buffer, whereas         *\n*      UNFBUFFR is a place somewhere within the buffer, which       *\n*      is the start of where the new data is expected to be         *\n*      moved.                                                       *\n*                                                                   *\n*      Since both the caller and this program do GET operations     *\n*      from the input FB-80 file, the count of the number of GETs   *\n*      done, UNFINRCD, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'UNFOLDEM '\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING UNFOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,AWSINV             AWSIN    DCB address in caller\n         ST    R0,AWSINDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to unfold FB-80 data starting at an OFFSET from the     *\n*   beginning of a card, for a certain number of bytes, to a data   *\n*   buffer area whose beginning address is supplied.  More 80-byte  *\n*   records can be read with the GET macro from the FB-80 file, to  *\n*   fulfill the move request.                                       *\n*                                                                   *\n*   Input:   UNFAREA fields are all supplied by the calling         *\n*            program, except for UNFBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            UNFAREA is pointed to by Register 1.                   *\n*                                                                   *\n*            The initial card image which is supplied by the        *\n*            calling program, already is primed with data to be     *\n*            moved (one card's worth of it).  This card contains    *\n*            the starting point for the data to be moved, at an     *\n*            OFFSET (displacement) from the beginning of the card.  *\n*                                                                   *\n*            The input data also contains the address of an         *\n*            output buffer area, which is the target for the        *\n*            (segmented) data moves.  Data will be strung out       *\n*            into this area, one card (or a partial card) at a      *\n*            time.  The current card which is in the input file,    *\n*            which contains the beginning of the data to be         *\n*            moved, has already been loaded into a card image       *\n*            work area pointed to by the calling program.  The      *\n*            OFFSET into this card is where the data to be moved    *\n*            will start.                                            *\n*                                                                   *\n*            It is the responsibility of the calling program to     *\n*            ensure that this routine has access to all of the      *\n*            buffer storage where the data is supposed to be        *\n*            moved to.                                              *\n*                                                                   *\n*   Output:  Data is moved, for the required number of bytes, to    *\n*            the output buffer area.  When more that one card       *\n*            image's worth of data has to be moved, more cards      *\n*            are obtained with the GET macro, from the input file.  *\n*                                                                   *\n*            Ending OFFSET in the FB-80 input file, pointing to     *\n*            just after the data which was moved, in the final      *\n*            card image gotten, is returned to the UNFOFFST field   *\n*            and reported to the caller, in anticipation of the     *\n*            next call to this routine.                             *\n*                                                                   *\n*            Ending address of data in buffer - one byte after      *\n*            the end of the moved data - is returned in the         *\n*            UNFBUFFR field.  The UNFBSTRT field preserves the      *\n*            address of the beginning of the data buffer.           *\n*                                                                   *\n*            A count of bytes actually moved from the FB-80 file    *\n*            to the output buffer area is reported in the UNFBYMVD  *\n*            field.  This must match the byte count of bytes which  *\n*            needed to be moved initially.  That count had been     *\n*            initially supplied by the calling program in the       *\n*            UNFBYTES field.                                        *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nUNFOLD   DS    0H\n         ST    R1,PARMPTR\n         L     R2,=A(UNFBLOCK)\n         USING UNFBLOCK,R2\n         MVC   UNFAREA(UNFLENTH),0(R1)      Move input block to pgm\n         LA    R2,UNFAREA                   And address it.\n         MVC   SAVEBEGC,UNFSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,UNFECARD    Save \"end of card\" address\n         L     R1,UNFSCARD          Address of card\n         MVC   WORKPREV(80),ZEROCARD   Zero prev work area\n         MVC   WORKCURR(80),0(R1)   Move card image to curr work area\n         MVC   UNFBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,UNFSCARD          Point to beginning of card\n         A     R7,UNFOFFST          Add OFFSET to start of input\n         ST    R7,SAVEBEGI          Save where input starts\n         L     R8,SAVEBEGI          Copy beg of input address\n         A     R8,UNFBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n* - - - - - - - - - - - - - - >>    This may be way past the address\n*             of the end of the FB-80 card.  We will decrease this\n*             address as we move bytes from successive cards to the\n*             data buffer, by 80 bytes at a time, as we GET new cards,\n*             until R8 actually falls within the end-of-card address.\n*             We will then use this address to calculate the new\n*             OFFSET for the next piece of data in the FB-80 file.\n*             The new OFFSET is returned to the caller by modifying\n*             the UNFOFFST field in the control block.\n*\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nLOOPSET  DS    0H                   Start moving data\n         L     R3,UNFBUFFR          Point to beginning of buffer\n         ST    R3,SAVEBEGD          Save location in the program.\n         LR    R4,R3                Point R4 to end of data by adding\n         A     R4,UNFBYTES          the number of bytes to the start.\n         ST    R4,SAVEENDD          Save potential end of data location\n         ST    R8,SAVER8TR          Save R8 for trace.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is within the current card.           *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.                       *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         C     R8,SAVEENDC          Is R8 still past end-of-card?\n         BH    LOOPMORE             Yes. Copy till end and GET.\nLOOPSHRT DS    0H                   The move is short, not past end.\n         LR    R6,R8                No. Get byte count to move NOW.\n         SR    R6,R7                Bytes to move\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data to the buffer.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,UNFBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET - save R8\n         S     R6,UNFSCARD          Subtract beginning of card address\n         ST    R6,UNFOFFST          Store the result as new OFFSET\n*        MVC   LINE+1(8),=C'LSHRT2: '\n*        BAL   R9,UNFIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Test if past end\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,UNFBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card gotten\n         MVC   WORKPREV,WORKCURR    Save card image to previous\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWSINDCB         Point to AWSIN DCB in caller\n         GET   (10),WORKCURR        Get a new card image\n         L     R10,SAVER10          Restore R10\n         AP    UNFINRCD,=P'1'       Increment count of AWSIN rcrds read\n         L     R7,SAVEBEGC          Point to beginning addr of workarea\n         MVC   0(80,R7),WORKCURR    Overlay caller's card image\n*        MVC   LINE+1(8),=C'LMORE2: '\n*        BAL   R9,UNFIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R3),0(R7)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE OPERATING SYSTEM\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of UNFAREA in caller\n         MVC   0(UNFLENTH,R10),UNFAREA    Copy changed UNFAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(UNFBLOCK)  Return address of UNFAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H          Diagnostic Data - State of UNFAREA currently\n*\n         HEX   LINE+10,4,UNFSCARD\n         HEX   LINE+20,4,UNFECARD\n         HEX   LINE+30,4,UNFOFFST\n         HEX   LINE+40,4,UNFBYTES\n         HEX   LINE+50,4,UNFBYMVD\n         HEX   LINE+60,4,UNFBUFFR\n         HEX   LINE+70,4,UNFBSTRT\n         HEX   LINE+80,4,SAVER8TR\n         HEX   LINE+90,7,UNFINRCD\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nUNFBLOCK CSECT\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n*\nUNFOLDEM CSECT\nWORKPREV DS    CL80                 Contiguous previous card image\nWORKCURR DS    CL80                 Card image work area\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nLINE2    DC    CL133' '\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    F                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGD DC    F'0'                 Save beg of buffer data address\nSAVEENDD DC    F'0'                 Save end of buffer data address\nSAVEBEGI DC    F'0'                 Save beg address of card input\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVER8TR DC    F'0'                 Save floating Reg 8 which decreases\nSAVEPARM DC    F'0'                 Save CALLER'S UNFAREA ADDRESS\nPARMPTR  DC    F'0'\nSYSPRINV DC    V(SYSPRINT)\nAWSINV   DC    V(AWSIN)\nSYSPRDCB DC    F'0'\nAWSINDCB DC    F'0'\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2TAP$": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x15\\x01\\x010\\x1f\\x01\\x11\\x10?#W\\x00-\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2001-10-28T00:00:00", "modifydate": "2011-04-13T23:57:15", "lines": 45, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=IFOX00,\n// PARM=(OBJECT,NODECK,XREF)\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.MVS38.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.MVS38.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.MACLIB\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.V.ASM(VTT2TAPE)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSGO    DD DISP=SHR,DSN=SBGOLOB.V.OBJ(VTT2TAPE)\n//ASMH EXEC PGM=IFOX00,\n// PARM=(OBJECT,NODECK,XREF)\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.MVS38.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.MVS38.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.MACLIB\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.V.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSGO    DD DISP=SHR,DSN=SBGOLOB.V.OBJ(UNFOLDEM)\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//OBJECT   DD  DISP=SHR,DSN=SBGOLOB.V.OBJ(VTT2TAPE)\n//         DD  DISP=SHR,DSN=SBGOLOB.V.OBJ(UNFOLDEM)\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB470533\n SETCODE AC(0)\n NAME VTT2TA38(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2TAP#": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00@\\x01\\x01(\\x9f\\x01\\x11\\x10?#Y\\x00\\x0f\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2011-04-13T23:59:40", "lines": 15, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//AWSREAD  EXEC PGM=VTT2TA38 PARM=READ\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.V467TS\n//TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=V467TS,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSIN     DD  *\nNEWVOL=V467MT\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2TAPE": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00&\\x01\\x00%O\\x01\\x11\\x10?#H\\x08I\\x07\\x9b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2011-04-13T23:48:26", "lines": 2121, "newlines": 1947, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2TAPE -- COPY AWS FORMAT FILE TO A REAL TAPE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE: VTT2TAPE.   Written by Sam Golob                **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to process P390 and FLEX-ES MVS       **\n**            Virtual Tape data in AWS format.  This data   **\n**            is uploaded to an MVS system as an FB-80      **\n**     card-image file.  The receiving MVS system does      **\n**     not have to be able to handle AWS-format virtual     **\n**     tapes, but it can use this program to read the tape  **\n**     data from this folded AWS-format file, and create    **\n**     a real tape from it.                                 **\n**                                                          **\n**     The OS2 or PC AWS-format tape file that was created  **\n**     by the P390 or FLEX-ES system as a virtual tape, is  **\n**     uploaded to the MVS system as an FB-80 card-image    **\n**     file, with its (continuous stream of) data folded    **\n**     over into 80-byte records, that can be blocked on    **\n**     MVS.  This VTT2TAPE program reads the resulting      **\n**     file, and creates a real output tape using EXCP, on  **\n**     a real tape drive, by filling a buffer and writing   **\n**     out its contents to the real tape.                   **\n**                                                          **\n**     This program is designed to also take input from     **\n**     the FB-80 AWS-format output file, which is produced  **\n**     by the VTT2DISK program.  These two programs,        **\n**     VTT2TAPE and VTT2DISK, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     1.  Since all the tape data is folded into 80-byte   **\n**         record segments, these have to be logically      **\n**         strung together, to be able to correctly write   **\n**         the tape data to tape blocks.                    **\n**                                                          **\n**     2.  First, the program has to correctly jump from    **\n**         one AWS header record to the next, and so        **\n**         proceed through all the headers in the entire    **\n**         tape file, not missing any.  Diagnostic output   **\n**         from this process, is written to the optional    **\n**         SYSTRACE ddname, if it is present in the         **\n**         execution JCL (see below).                       **\n**                                                          **\n**         The first header of an AWS-format tape is the    **\n**         first six bytes of the file.  Once you have      **\n**         the first header, you have the number of bytes   **\n**         of data until the next header, and so forth.     **\n**                                                          **\n**         The UNFOLDEM called program unfolds the data     **\n**         from a chunk of data after an AWS header, and    **\n**         strings it out into an output buffer, after      **\n**         which an EXCP operation writes the entire        **\n**         buffer to tape.  If a block of data is from      **\n**         several chunks, the data pieces are all strung   **\n**         out into the output buffer, and then at the      **\n**         end of the block (flag X'20' in the header),     **\n**         all of the buffer data is written out to tape.   **\n**                                                          **\n**     3.  In the process of jumping from one header to     **\n**         another, the program then moves the correct      **\n**         number of data bytes that are in between the     **\n**         headers, into the output buffer, 80-bytes or     **\n**         less, at a time.  This action depends on the     **\n**         type of header that we have.                     **\n**                                                          **\n**           HEADER TYPE       ACTION                       **\n**           ------ ----       ------                       **\n**           X'80'             Initialize buffer address.   **\n**                             Write chunk of data to       **\n**                              the buffer.                 **\n**                                                          **\n**           X'00'             Write another chunk of data  **\n**                              to the end of the previous  **\n**                              chunk in the buffer.        **\n**                                                          **\n**           X'20'             Add the chunk of data to     **\n**                              the buffer.                 **\n**                             Write out the entire buffer. **\n**                             Initialize the start of      **\n**                              buffer address.             **\n**                                                          **\n**           X'A0'             X'80' and X'20' combined.    **\n**                                                          **\n**           X'40'             Write a tape mark.           **\n**                             Finalize the tape file.      **\n**                             Initialize the output buffer **\n**                              location.                   **\n**                                                          **\n**  Note:  If the output tape is too short, VTT2TAPE        **\n**         attempts to recover by issuing an EOV macro,     **\n**         which calls for a mount of a second tape,        **\n**         as a PRIVATE SCRATCH tape.  More data from the   **\n**         AWS file is written out to the second tape.      **\n**                                                          **\n**         However, there is a catch here.  The second      **\n**         tape does not contain additional labels, as      **\n**         DFP would have written.  The second tape         **\n**         continues with the next block of data, after     **\n**         the last block which was successfully written    **\n**         to the first tape.                               **\n**                                                          **\n**         Therefore, in order to subsequently read the     **\n**         second tape, you have to treat both tapes as     **\n**         two-volume BLP, using JCL similar to this,       **\n**         even if the first tape is SL...                  **\n**                                                          **\n**       //TAPOUT    DD  DISP=OLD,UNIT=TAPE,                **\n**       //          VOL=(,RETAIN,SER=(VOL001,VOL002,etc)), **\n**       //          LABEL=(n,BLP,EXPDT=98000)              **\n**                                                          **\n**         where n (for BLP) would be 3m-1 (where m is      **\n**         the SL file number).                             **\n**                                                          **\n**         Sorry for that.  The reason is because this      **\n**         program writes tape blocks using EXCP, and       **\n**         for the second volume, I'd have to manufacture   **\n**         my own tape labels, and I haven't added such     **\n**         an enhancement at this time.  If BSAM or QSAM    **\n**         created a second SL tape, then the extra EOV     **\n**         and VOL and HDR labels are created by DFP.       **\n**         EXCP contains no such provisions, leaving any    **\n**         extra label creation entirely up to the          **\n**         programmer.                                      **\n**                                                          **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**         In order to make sure that the VTT2TAPE program  **\n**         is doing its job properly, it produces a lot of  **\n**         trace data and status data, as it is reading     **\n**         through the folded FB-80 AWS format tape.  In    **\n**         order not to clutter the summary report, most    **\n**         of this data is written to \"Optional DDNAMEs\".   **\n**                                                          **\n**         Optional DDNAMEs don't have to be coded in the   **\n**         JCL.  But if they are coded, they will contain   **\n**         the extra trace data which VTT2TAPE produces.    **\n**                                                          **\n**         The optional DDNAMEs are SYSFILES, SYSTRACE,     **\n**         SYSMOVED, and SYSIN.                             **\n**                                                          **\n**         Full JCL to run the VTT2TAPE program is as       **\n**         follows:                                         **\n**                                                          **\n**         (But you can code PARM=READ, or                  **\n**            PARM='TVOL(volser)'       or                  **\n**            PARM='TVOL=volser'              )             **\n**                                                          **\n**         If you code, PARM='TVOL.....' to override the    **\n**         volser of the new tape, this may be further      **\n**         overridden by the SYSIN card:  NEWVOL=volser.    **\n**                                                          **\n**       //   jobcard                                       **\n**       //AWSREAD  EXEC PGM=VTT2TAPE                       **\n**       //STEPLIB   DD  DISP=SHR,DSN=your.load.library     **\n**       //AWSIN     DD  DISP=SHR,DSN=folded.aws.file,      **\n**                   DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)  **\n**       //TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=TEST01,  **\n**       //          LABEL=(1,BLP,EXPDT=98000)              **\n**       //SYSPRINT  DD  SYSOUT=*                           **\n**       //SYSFILES  DD  SYSOUT=*                           **\n**       //SYSTRACE  DD  SYSOUT=*                           **\n**       //SYSMOVED  DD  SYSOUT=*                           **\n**       //SYSUDUMP  DD  SYSOUT=*                           **\n**       //SYSIN     DD  *                                  **\n**       NEWVOL=PROD01                                      **\n**       /*                                                 **\n**       //                                                 **\n**                                                          **\n**         where you can leave out SYSTRACE, SYSMOVED,      **\n**         and SYSUDUMP, if you want to.  I'd strongly      **\n**         suggest including (at least) SYSFILES, though.   **\n**                                                          **\n**         If you code NEWVOL=volser in a //SYSIN card,     **\n**         starting in column 1, VTT2TAPE will change       **\n**         the VOLSER in every VOL1 label (should only be   **\n**         one of them) on the tape, to the value you       **\n**         specify.                                         **\n**                                                          **\n**         SYSFILES gives you block counts and byte counts  **\n**         for all files read and written.  SYSFILES also   **\n**         differentiates between label files and data      **\n**         files.                                           **\n**                                                          **\n**         SYSTRACE tells you if you are running through    **\n**         all the AWS headers properly.  SYSMOVED tells    **\n**         you how many bytes were moved from each chunk    **\n**         of data between AWS headers.  SYSUDUMP is        **\n**         there to contain the MVS-produced dump, upon     **\n**         any abnormal termination of the program.         **\n**                                                          **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.1 - Correct Operation of data moves from    **\n**       the AWS file to the output buffer, and produce     **\n**       traces to debug this.  SYSMOVED ddname.            **\n**                                                          **\n**    Version 1.2 - Add byte counts and SYSFILES ddname.    **\n**       Fix AWSTAPE emulator problem when writing a        **\n**       tape mark.  OS/2 AWSTAPE emulator cares what       **\n**       the byte count is in CCW+6, even if the opcode     **\n**       is X'1F'.  Made sure the byte count is always 0    **\n**       when doing EXCP with a \"write tape mark\" opcode.   **\n**                                                          **\n**    Version 1.3 - Check for error conditions on output.   **\n**       Put version number and assembly date into headers. **\n**       Put cumulative byte totals in SYSFILES report.     **\n**                                                          **\n**    Version 1.4 - Differentiate between label files and   **\n**       data files.  Different cumulative byte counts for  **\n**       each.                                              **\n**                                                          **\n**    Version 1.5 - Better SYSFILES report upon volume      **\n**       switch, if the first output tape is too short.     **\n**       Pass null SL files.  Don't stop in the middle of   **\n**       them, because of the two tape marks after the      **\n**       HDR2.                                              **\n**                                                          **\n**    Version 1.6 - Block counts for each file and for the  **\n**       entire tape.                                       **\n**                                                          **\n**    Version 1.7 - Allow PARM=READ, just to get stats.     **\n**                                                          **\n**    Version 1.8 - Make file-level stats reporting into    **\n**       a subroutine.                                      **\n**                                                          **\n**    Version 1.9 - Header validation.  If a header is      **\n**       corrupted, the chain of headers will be broken,    **\n**       and we try to detect this and abort the program,   **\n**       before any significant damage is done to the       **\n**       output file.  We try and keep as much valid data   **\n**       as possible in the output tape.  Add return code   **\n**       indication of different error conditions.          **\n**                                                          **\n**    Version 1.9A - Better messages if this header's       **\n**       previous byte value doesn't match the last         **\n**       header's current byte value.  Pinpoint file and    **\n**       block number in error.  Allow 4-byte version       **\n**       number literal, in preparation for 1.10, etc.      **\n**                                                          **\n**    Version 1.10 -   Optional SYSIN dd name which can     **\n**       contain a card:  NEWVOL=volser   starting in       **\n**       column 1, which overrides the output tape's        **\n**       volume serial.                                     **\n**                                                          **\n**    Version 1.11 -   INAREA now addressed indirectly.     **\n**                                                          **\n**    Version 1.12 -   Logic changed to accommodate chunks  **\n**       of data between headers that are shorter than the  **\n**       tape blocks.  Much of the program has been         **\n**       completely rewritten.  Moves of data between AWS   **\n**       headers to the output buffer, are now done only    **\n**       by the UNFOLDEM called program.  The SYSFILES      **\n**       report has been improved.  The SYSMOVED and        **\n**       SYSTRACE reports now reflect the data associated   **\n**       with each header encountered.                      **\n**                                                          **\n**    Version 1.13 -   Put in ASG enhancement to allow a    **\n**       volser change through a PARM='TVOL=nwvser', or     **\n**       PARM='TVOL(nwvser)'.  Put in a check for short     **\n**       volsers (less than 6 characters) and ran the parm  **\n**       for the volser through a translate table first,    **\n**       to uppercase it and clean it up somewhat.  The     **\n**       volser that is coded in the SYSIN DD card can      **\n**       completely override this, so you still have the    **\n**       freedom to create bizarre volsers if you really    **\n**       want to.  BTW, you do not need to code the new     **\n**       volser in the JCL.  This program does not do a     **\n**       RDJFCB to find out what is in the JCL.             **\n**                                                          **\n**                                                          **\n**  RETURN CODES:                                           **\n**                                                          **\n**    RC =  0 :    Normal Operation                         **\n**                                                          **\n**    RC =  4 :    A Private Scratch tape was asked for,    **\n**                 because the end of the first output      **\n**                 tape was reached.                        **\n**                                                          **\n**    RC =  8 :                                             **\n**                                                          **\n**    RC = 12 :    Program operation had to be aborted      **\n**                 because the chain of AWS headers was     **\n**                 broken in the middle, and an invalid     **\n**                 \"AWS header\" was encountered.  The       **\n**                 program writes out all valid tape        **\n**                 blocks, and then stops action, with a    **\n**                 message that indicates the problem,      **\n**                 and the header found to be in error.     **\n**                 The last tape block written, is the      **\n**                 block before the last correct AWS        **\n**                 header.  This condition probably         **\n**                 occurred because an invalid AWS header   **\n**                 \"current length\" made it impossible      **\n**                 to find the next valid AWS header.       **\n**                                                          **\n**                                                          **\n**    Please note that a higher return code will            **\n**    supersede a lower return code, and that multiple      **\n**    error conditions might exist, if there is a nonzero   **\n**    return code higher than 4.  Look at the SYSFILES      **\n**    report, and the other reports, to determine the       **\n**    exact error(s) present.                               **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n&LLEV    SETC  '1.13'\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\nVTT2TAPE CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2TAPE - AWS FB-80 DISK FILE INPUT TO REAL TAPE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2TAPE,R12,R11,R10,R8\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n         MVC   SVNEWVOL(6),=C'      '    MAKE SVNEWVOL BLANK\n         L     R1,0(,R1)             Get PARM field\n         CLC   =C'TVOL',2(R1)        Is it a Tape volume override?\n         BNE   CHKREAD               No. Then check if \"read only\".\n         MVC   CHKNWVOL(6),7(R1)     Yes. Move chars from PARM=TVOL.\n         TR    CHKNWVOL(6),TRTBLPRT  Translate to clean this up some.\n*\n*  Code to guard against a short volser or leading blanks in the PARM.\n* >> below\n*\n         STM   R2,R5,SAVR2T5         Save 4 registers\n         LA    R3,CHKNWVOL           Load address of source field\n         LA    R4,6                  Load limit of characters moved\n         LA    R5,SVNEWVOL           Load address of target field\n         LR    R2,R5                 Start address of target field\nMVELOOP  DS    0H                    Guard against a short volser.\n         CLI   0(R3),X'00'           Delimiter of hexzeros?\n         BE    MVELEND               Yes, end the move.\n         CLI   0(R3),C' '            Delimiter of blank?\n         BE    MVELEND               Yes, end the move.\n         CLI   0(R3),C')'            Delimiter of close paren?\n         BE    MVELEND               Yes, end the move.\n         MVC   0(1,R5),0(R3)         Move one character over.\n         OI    FLAGNEWV,X'01'        Flag that volser needs change.\n         LA    R3,1(,R3)             Bump source character.\n         LA    R5,1(,R5)             Bump target character.\n         BCT   R4,MVELOOP            Try again if before end.\nMVELEND  DS    0H\n         LM    R2,R5,SAVR2T5         Restore 4 registers\nMOVEEND  DS    0H\n*\n* >> above\n*  Code to guard against a short volser or leading blanks in the PARM.\n*\n* ----- >                            Parm = READ    <--- below\n*    See code for PARM='TVOL=nwvser' which is above, in several places.\n* ----- >\nCHKREAD  CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BNE   COPYTAPE              No. Default is to copy the tape.\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\nCOPYTAPE DS    0H\n* ----- >                            Parm = READ    <--- above\n*\n         L     R15,=V(UNFOLDEM)      UNFOLDEM subprogram\n         ST    R15,SVUNFOLD          Save its entry point\n         L     R0,=A(INAREA)         Address of tape buffer\n         ST    R0,SVINAREA           Store it away for later use.\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE4+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE5+88(31),HEADDLIT\n         MVC   MESSAGE6+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE4+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE5+61(21),LEVELLIT\n         MVC   MESSAGE6+61(21),LEVELLIT\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants and\n         MVI   FLAGSYST,X'00'        No optional ddnames initially.\n         ZAP   INHDRS,=P'0'          Count number of AWS headers\n         ZAP   INTYPE1,=P'0'         Counts of Header Types\n         ZAP   INTYPE2,=P'0'\n         ZAP   INTYPE3,=P'0'\n         ZAP   INTYPE4,=P'0'\n         ZAP   INTYPE5,=P'0'\n         ZAP   FILCOUNT,=P'0'        Initialize file counter\n         MVC   DBIN(8),=D'0'         Initialize byte counters\n         MVC   LBIN(8),=D'0'\n         MVC   DAIN(8),=D'0'\n         MVC   DAINF(8),=D'0'\n         MVC   LBINF(8),=D'0'\n         MVC   DBINF(8),=D'0'\n         MVC   OURRC,=F'0'\n         MVC   MAXRC,=F'0'\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE DDNAME THERE?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       SHOW PRESENCE OF SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       SHOW PRESENCE OF SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       SHOW PRESENCE OF SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       SHOW PRESENCE OF SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n*---------------------------------------------------------------------*\n* -------------- >>>>>>   Look for new output volume name - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    NONSYSIN             No. Then can't open it.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BNE   SYSINLUP              No. Don't use this card.\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         OI    FLAGNEWV,X'01'             And show a new volser here.\n         B     NONSYSIN\nSYSINEND DS    0H\n         CLOSE SYSIN\nNONSYSIN DS    0H\n* -------------- >>>>>>   Look for new output volume name - ABOVE\n*---------------------------------------------------------------------*\n         OPEN  (AWSIN,(INPUT))\n         OPEN  (SYSPRINT,(OUTPUT))\n         TM    READFLAG,X'01'        Is this run READ ONLY?\n         BO    NOTAPOPN              Yes. Don't OPEN output tape.\n         OPEN  (TAPOUT,(OUTPUT))\nNOTAPOPN DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   NOSYSTRC              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE4\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA4\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSTRACE,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\nNOEXTRA4 DS    0H\n         PUT   SYSTRACE,MESSAGE9\n         PUT   SYSTRACE,MESSAG10\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n         PUT   SYSTRACE,MESSAGE8\n*--->>\nNOSYSTRC DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE5\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA5\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSMOVED,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\nNOEXTRA5 DS    0H\n*--->>\nNOSYSFIL DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSMVD              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE6\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA6\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSFILES,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\nNOEXTRA6 DS    0H\n*--->>\nNOSYSMVD DS    0H\n* ----------------------------------------------------------------- *\n*     Write the top Header Line, with the date and time in it.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA1\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSPRINT,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSPRINT,PRTLINE\nNOEXTRA1 DS    0H\n*--->>\n* ----------------------------------------------------------------- *\n*     Start trying to bop through the AWS headers.  The first 6\n*     bytes of the file, is the first header, so we start there.\n* ----------------------------------------------------------------- *\nLOOPSTRT DS    0H                    START OF PROCESSING\n         LA    R7,INCARD             INITIALIZE BEG OF RECORD\n         ST    R7,SAVEBEGC           AND SAVE THIS SETTING.\n* ---------------------------------------------------------------- *\n         LA    R6,INCAEND            INITIALIZE END OF RECORD\n         ST    R6,SAVEENDC           AND SAVE THIS SETTING.\n         LA    R1,80(,R6)            BOP BY ANOTHER RECORD LENGTH\n         ST    R1,SAVEEN80           AND SAVE WHERE THIS IS.\n* ---------------------------------------------------------------- *\n         GET   AWSIN,INCARD           Do the very first GET to find\n*                                     the first header in the file.\n*                                     The first header lets you find\n*                                     all the other headers.\n         AP    UNFINRCD,=P'1'         Update the control block too\n         MVC   INHEADER(6),0(R7)      Got the first header\n* ---------------------------------------------------------------- *\n*     We come here when we know we're at the beginning of an\n*     AWS header record.\n* ---------------------------------------------------------------- *\nGOTHEADR DS    0H                     Got a header record\n* ---------------------------------------------------------------- *\n         MVC   HDRPREVS(2),HDRPREV    SAVE PREVIOUS BLOCK SIZE\n         MVC   HDRLENGS(2),HDRLENG    SAVE SIZE OF NEXT BLOCK\n* ---------------------------------------------------------------- *\n         AP    INHDRS,=P'1'           Count the number of headers.\n         MVC   HEADER(6),INHEADER     Move header to formatting area.\n*--->\n         ST    R9,SAVER9HV            Save link register\n         BAL   R9,VALIDHDR            Make sure header flags are valid\n         L     R9,SAVER9HV            Restore link register\n         TM    HDRVFLAG,X'01'         Is the header in error?\n         BO    HEADRERR               Yes-report condition and end pgm.\n*--->\n*--->       Format the header by interpreting the length fields,\n*--->       and then print the values for diagnosis if necessary.\n*--->\n*--->       HDRLENG contains the true halfword byte count of data\n*--->               following this header.\n*--->       HDRPREV contains the true halfword byte count of data\n*--->               preceding this header.\n*--->\n*--->       In case fullword versions of these quantities are\n*--->       needed, HDRFULLS and HDRPFULS are supplied too.\n*--->\n         MVC   SAVEHDR(6),HEADER      Save a copy of the current header\n         MVC   HDRFILL(2),=X'0000'    Fill in zeros\n         MVC   HDRPRVF(2),=X'0000'      for\n         MVC   HDRLENFL(2),=X'0000'        fullword values\n         MVC   HDRPRVFL(2),=X'0000'           of halfwords.\n         MVC   HDRLENG+1(1),HDRCURLN     REVERSE\n         MVC   HDRLENG(1),HDRCURLN+1        BYTES\n         MVC   HDRPREV+1(1),HDRPRVLN     REVERSE\n         MVC   HDRPREV(1),HDRPRVLN+1        BYTES\n*\n         MVC   PRTLINE,PRTLINE-1      CLEAR PRINT LINE\n         HEX   PRTLINE+8,6,HEADER     UNFAREA at GOTHEADR time display\n         HEX   PRTLINE+28,4,UNFSCARD                            .\n         HEX   PRTLINE+38,4,UNFECARD                            .\n         HEX   PRTLINE+48,4,UNFOFFST                            .\n         HEX   PRTLINE+58,4,UNFBYTES                            .\n         HEX   PRTLINE+68,4,UNFBYMVD                            .\n         HEX   PRTLINE+78,4,UNFBUFFR                            .\n         HEX   PRTLINE+88,4,UNFBSTRT                            .\n         HEX   PRTLINE+98,7,UNFINRCD                            .\n* ---------------------------------------------------------------- *\n*              DETERMINE THE TYPE OF HEADER YOU HAVE\n*                    AND COUNT HOW MANY OF EACH\n* ---------------------------------------------------------------- *\nKINDAHDR DS    0H\n         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?\n         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK\n         AP    INTYPE3,=P'1'          YES. COUNT THIS TYPE\n         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE\nKCHKBEG  DS    0H\n         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?\n         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.\n         AP    INTYPE1,=P'1'          YES. COUNT THIS TYPE\nKCHKEND  DS    0H\n         TM    HDRFLAG1,X'20'         END OF BLOCK?\n         BNO   KINDAH40               NO. CHECK IF END OF FILE\n         AP    INTYPE2,=P'1'          YES. COUNT THIS TYPE\nKINDAHA0 DS    0H\n         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?\n         BNE   KINDAH40               NO. TEST FOR EOF HEADER.\n         AP    INTYPE5,=P'1'          YES. COUNT IT FOR REPORTING.\n         B     KINDAHEN               AND DON'T TEST MORE BITS.\nKINDAH40 DS    0H\n         TM    HDRFLAG1,X'40'         END OF FILE HEADER?\n         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.\n         AP    INTYPE4,=P'1'          YES. COUNT THIS TYPE\n*\n*     Invalid types were already caught by the VALIDHDR routine.\n*\nKINDAHEN DS    0H\n         HEX   PRTLINE+22,1,HDRFLAG1                            .\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         PUT   SYSTRACE,PRTLINE\nNOSYSTR1 DS    0H\n         CLC   SAVEHDR(6),EOTMARK     IS THE HEADER AN EOT MARK?\n         BNE   NOFIN                  NO. DON'T STOP THE PROGRAM.\n         NI    UNEXFLAG,FF-X'01'      TURN OFF UNIT EXCEPTION FLAG\n         TM    FLAGHDRL,X'01'         YES. BUT TEST IF AFTER HDR 1 OR 2\n         BO    NOFIN                  AFTER HDR1 OR HDR2, DON'T END PGM\n         B     FIN                    OTHERWISE END THE PROGRAM.\nNOFIN    DS    0H\n*------------------------------>  Validate Header Quantities  <-- below\n*\n*   This validation checks if the bytes in the \"previous\" byte count\n*   field match the byte count in the \"forward\" field of the previous\n*   header.  If there is an error, it is reported now.\n*\n         CLC   HDRLENGS(2),HDRPREV    Is Prev Length = Last Current ?\n         BE    HDRVALID               Yes. As it should be.\n         MVC   OUTLINE,OUTLINE-1      No. Corrupted headers.\n         MVC   OUTLINE,ERRMESS6       Write nasty message.\n         MVI   OUTLINE+58,C'P'        Display prev hdr quantity.\n         HEX   OUTLINE+60,2,HDRPREV\n         MVI   OUTLINE+66,C'C'        Display last current hdr amount.\n         HEX   OUTLINE+68,2,HDRLENGS\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'        Set RC = 12\n         CLC   MAXRC,OURRC            Is MAXRC higher?\n         BH    SAXERC02               Yes. Keep it.\n         MVC   MAXRC,OURRC            No.  Raise MAXRC to this one.\nSAXERC02 DS    0H\n         TM    FLAGSYST,X'01'         Write nastygram to SYSTRACE.\n         BZ    NOERRX1\n         PUT   SYSTRACE,OUTLINE\nNOERRX1  DS    0H\n         TM    FLAGSYST,X'02'         Write nastygram to SYSMOVED.\n         BZ    NOERRX2\n         PUT   SYSMOVED,OUTLINE\nNOERRX2  DS    0H\n         TM    FLAGSYST,X'04'         Write nastygram to SYSFILES.\n         BZ    NOERRX4\n         PUT   SYSFILES,OUTLINE\nNOERRX4  DS    0H\n         PUT   SYSPRINT,OUTLINE       Write nastygram to SYSPRINT.\n*\n*       Maybe think of ending the program operation here.\n*       REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE\n*\nHDRVALID DS    0H\n*------------------------------>  Validate Header Quantities  <-- above\n*\n*\n* - - - - - - - >>>>>   End of Header Operations....\n* - - - - - - - >>>>>   Now go move the data afterward.\n* ---------------------------------------------------------------- *\n*     At this point, we will begin moving the data that is after\n*     the first header.  Future OFFSETs will be supplied by the\n*     previous call to the UNFOLDEM program.\n* ---------------------------------------------------------------- *\nLOOKINIT DS    0H                Start looking for the data at the\n*                                beginning of the AWSIN tape file.\n         TM    INITFLAG,X'01'    Not the first time here?\n         BO    LOOKIEND          Bypass initializations.\n         OI    INITFLAG,X'01'    Do this only once for the entire tape.\n         MVC   UNFOFFST,=F'6'    Initialize OFFSET to be just past\n*                                the first header in the file.\n         MVC   UNFBUFFR,UNFBSTRT  Init buffer loc to start of buffer\nLOOKIEND DS    0H\n* ---------------------------------------------------------------- *\nMOVEDATA DS    0H                This is the call to UNFOLDEM.\n*                                We fill in the necessary fields.\n*\n*    UNFOLDEM is only intended to move the data between the AWS\n*    headers.  \"After processing\" is controlled by the flags in\n*    the headers.  After each header is processed, we again point\n*    to the data after the headers (if any) and call UNFOLDEM to\n*    move it.\n*\n         MVC   PREVHDR,SAVEHDR     Copy of last header for action later\n         MVC   UNFSCARD,SAVEBEGC   Beginning address of input card\n         MVC   UNFECARD,SAVEENDC   End address of input card\n         XC    UNFBYTES,UNFBYTES   Zero out fullword bytes to be moved\n         MVC   UNFBYTES+2(2),HDRLENG   And move in halfword value\n         L     R1,SVINAREA         Point to address of buffer\n         ST    R1,UNFBSTRT         Store it in beginning buffer field\n         TM    NOWRTFLG,X'01'      Continue data move in same buffer?\n         BO    MOVEBUFF            Yes. Don't reinitialize in buffer.\n         ST    R1,UNFBUFFR         Store it in current buffer field\nMOVEBUFF DS    0H\n*        MVC   LINE+1(8),=C'BEFCALL '\n*        BAL   R9,UNFIMAGE\n         LA    R1,UNFAREA          Point to UNFAREA control block\n         L     R15,SVUNFOLD        Load entry point of UNFOLDEM pgm\n         BALR  R14,R15             Call the program and move data.\n         MVC   UNFAREA(UNFLENTH),0(R1)  Move modified UNFAREA to pgm\n*        MVC   LINE+1(8),=C'AFTCALL '\n*        BAL   R9,UNFIMAGE\n* -- Test for call of LABELCHK -- >   below\n*   We have just moved the bytes.  Now we check if the file is a label.\n         NI    ISLBLFLG,FF-X'01'   Initially assume it's not a label.\n         L     R1,UNFBYMVD         The number of bytes moved just now.\n         C     R1,=X'00000050'     Was it exactly 80?\n         BNE   NOLBLCHK            No. Assume it can't be a label.\n         L     R1,UNFBSTRT         Grab address of data buffer.\n         MVC   TESTLABL(80),0(R1)  Move 80 bytes to the testing area.\n         BAL   R9,LABELCHK         Test to see if it is a label.\n         TM    ISLBLFLG,X'01'      Is it a label?\n         BZ    NOLBLCHK            No. Assume entire file is not labels\n         OI    FILBLFLG,X'01'      Yes. Turn on label flag at the\n*                                   file level.\nNOLBLCHK DS    0H\n* -- Test for call of LABELCHK -- >   above\n* ---------------------------------------------------------------- *\n         BAL   R9,AFTRMOVE       Housekeeping after the data move.\n*        MVC   LINE+1(8),=C'AFTAFTR '\n*        BAL   R9,UNFIMAGE\n         BAL   R9,CHKHEADR       Get new header ready for handling.\n*        MVC   LINE+1(8),=C'AFTCHKH '\n*        BAL   R9,UNFIMAGE\n         B     GOTHEADR          Assume you've got another header.\n* ---------------------------------------------------------------- *\n*          END OF INPUT AWS DATA                                   *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         BAL   R9,WRITTPMK          WRITE FINAL TAPE MARK\n         B     AGLE                 Finish processing\n* ---------------------------------------------------------------- *\nHEADRERR DS    0H\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS5\n         HEX   OUTLINE+58,6,HEADER\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'    RC = 12 for header error.\n         CLC   MAXRC,OURRC        Is MAXRC higher?\n         BH    SAMERC02           Yes. Keep it.\n         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.\nSAMERC02 DS    0H\n         TM    FLAGSYST,X'01'\n         BZ    NOERR01\n         PUT   SYSTRACE,OUTLINE\nNOERR01  DS    0H\n         TM    FLAGSYST,X'02'\n         BZ    NOERR02\n         PUT   SYSMOVED,OUTLINE\nNOERR02  DS    0H\n         TM    FLAGSYST,X'04'\n         BZ    NOERR04\n         PUT   SYSFILES,OUTLINE\nNOERR04  DS    0H\n         PUT   SYSPRINT,OUTLINE\n* ---------------------------------------------------------------- *\nAGLE     DS    0H                   Print the Summary Report\n         BAL   R9,SUMMREPT\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\n         CLOSE AWSIN\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'4'\n         BNH   NOERRPRT\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRPRT DS    0H\n         PUT   SYSPRINT,OUTLINE\n         CLOSE SYSPRINT\n         TM    READFLAG,X'01'       If READ ONLY, don't CLOSE tape.\n         BO    NOTAPCLS\n         CLOSE TAPOUT\nNOTAPCLS DS    0H\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'0'\n         BE    NOERRFIL\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRFIL DS    0H\n         PUT   SYSFILES,OUTLINE\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         MVC   16(4,R13),MAXRC      Load Maximum Return Code\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H                 Take a picture of the UNFAREA now.\n         HEX   LINE+10,4,UNFSCARD    Starting card address.\n         HEX   LINE+20,4,UNFECARD    Ending card address.\n         HEX   LINE+30,4,UNFOFFST    Offset (starting and ending)\n         HEX   LINE+40,4,UNFBYTES    Number of bytes to be moved.\n         HEX   LINE+50,4,UNFBYMVD    Number of bytes that were moved.\n         HEX   LINE+60,4,UNFBUFFR    Current start location in buffer.\n         HEX   LINE+70,4,UNFBSTRT    Location of beginning of buffer.\n         HEX   LINE+80,7,UNFINRCD    Number of GETs done to AWSIN file.\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1           Clear LINE after PUT.\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nCHKHEADR DS    0H                 Position to the next header\n*                                 The idea is to fill the INHEADER\n*                                 field with the correct value.\n         ST    R9,SAVER9CH        Save BAL register\n         L     R1,UNFOFFST        New offset, returned from UNFOLDEM.\n         C     R1,=F'74'          Bigger or equal to 74?\n         BL    CHKHOFSL           No. Just copy header straight.\nCHKHOFSH DS    0H                 Yes. Need to combine with next card.\n         MVC   INCARDP,INCARD     Copy this card to prev 80 byte area.\n         GET   AWSIN,INCARD       GET another card adjacent to previous\n         AP    UNFINRCD,=P'1'     Update UNFAREA field too.\n         LA    R7,INCARDP         Point to two consecutive cards.\n         A     R7,UNFOFFST        Add the returned offset.\n         MVC   INHEADER(6),0(R7)  Move the new header to staging area.\n         LA    R7,6(,R7)          Bump R7 past the new header.\n         S     R7,=A(INCARD)      Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\n         B     CHKHEND            Finish this processing.\nCHKHOFSL DS    0H\n         LA    R7,INCARD          < 74. Header is in original card.\n         LA    R7,0(R1,R7)        Bump by offset - point to new header\n         MVC   INHEADER(6),0(R7)  And move it to staging area.\n         LA    R7,6(,R7)          Bump R7 past the new header.\n         L     R1,=A(INCARD)      Address of current card\n         SR    R7,R1              Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\nCHKHEND  DS    0H\n         L     R9,SAVER9CH        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nAFTRMOVE DS    0H                 After the move, we act on the\n*                                 information from the previous\n*                                 AWS header.\n         ST    R9,SAVER9AF        Save BAL register\n         NI    NOWRTFLG,FF-X'01'  Turn off flag initially\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nAFTTST40 DS    0H                 X'40' means END-OF-FILE\n*                                 So we finish off the file-level stuff\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   TEST TEST TEST:  CHECK IF THERE CAN BE A VALID X'4x'  -------\n         CLI   PRVHFLGS,X'40'     Is there an end-of-file condition?\n         BNE   AFTTSTA0           No. Do next test.\n         BAL   R9,WRITTPMK        Yes. Write a tape mark.\n         AP    FILCOUNT,=P'1'     Count number of files written.\n         BAL   R9,REPTFILE        Report on this file in SYSFILES.\n         ZAP   BLOCKCNT,=P'0'     Zero block count for next file\n         ZAP   FILEBYTS,=P'0'     Zero bytes moved for next file\n         NI    FILBLFLG,FF-X'01'  Turn off Label File indicator\n         XC    DBINF,DBINF        Zero byte count at file level\n         XC    DAINF,DAINF        Zero data bytes at file level\n         XC    LBINF,LBINF        Zero label bytes at file level\n** - SYSMOVED ->>    Record the number of files written  -  BELOW\n         TM    FLAGSYST,X'02'     Is SYSMOVED here and open?\n         BNO   AFTT40WM           No. Don't attempt a print.\n         MVC   OUTLINE,OUTLINE-1         Clear line.\n         MVC   OUTLINE,MESSAG12          Mark END-OF-FILE in SYSMOVED\n         MVC   OUTLINE+38(9),FILEPAT     Move in edit pattern\n         ED    OUTLINE+38(9),FILCOUNT+3  Tell which file number ended\n         PUT   SYSMOVED,OUTLINE\nAFTT40WM DS    0H\n** - SYSMOVED ->>    Record the number of files written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-40: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND           No more processing after this.\n*\nAFTTSTA0 DS    0H                 X'A0' means beg and end of block\n         CLI   PRVHFLGS,X'A0'     Is chunk equal block?\n         BNE   AFTTST80           No. Test for first chunk in block.\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR\n** ---------- >>\n         XC    BLOKBYTS,BLOKBYTS  Zero bytes moved after write\n         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too\n*        MVC   LINE+1(8),=C'AFT-A0: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTTST80 DS    0H                 X'80' means beginning of block\n         CLI   PRVHFLGS,X'80'     Beginning chunk of bigger block?\n         BNE   AFTTST00           No. Do next test.\n         OI    NOWRTFLG,X'01'     Must move buffer start location up\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT80WM                 No, can't write data to it.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT80WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-80: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTTST00 DS    0H                 X'00' means middle chunk of block\n         CLI   PRVHFLGS,X'00'     Is this a middle chunk?\n         BNE   AFTTST20           No. Try next test.\n         OI    NOWRTFLG,X'01'     Must move buffer start location up\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT00WM                 No, can't write data to it.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT00WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-00: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND           Get out - not X'80' or X'20'\nAFTTST20 DS    0H                 X'20' means last chunk of block\n         CLI   PRVHFLGS,X'20'     Is end-of-block on?\n         BNE   AFTRMERR           No. Must be error. Tested all types.\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR\n*                                 Byte stats accumulated by WRITBUFF\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT20WM                 No, can't write data to it.\n         TM    BWRITFLG,X'01'           Already written MESSAGE3?\n         BO    AFTT20NW                 Yes. Don't repeat info here.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT20NW DS    0H\n         NI    BWRITFLG,FF-X'01'        Write MESSAG11 from here on.\nAFTT20WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n         XC    BLOKBYTS,BLOKBYTS  Zero byte count moved after write.\n         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too\n*        MVC   LINE+1(8),=C'AFT-20: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTRMERR DS    0H                 Code any error handling here.\nAFTRMEND DS    0H\n         L     R9,SAVER9AF        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITBUFF DS    0H\n         ST    R9,SAVER9WR        BAL register save for WRITBUFF\n         TM    READFLAG,X'01'     READ ONLY run?\n         BO    WRITREAD           Yes. Don't do the EXCP.\n         LA    R1,TAPOUT          R1=address of current DCB\n         ST    R1,OUTDCBPT        Put it in IOB\n         MVC   OUTCCW+1(3),UNFBSTRT+1   PRIME OUTPUT CCW\n         MVC   OUTCCW+6(2),BLOKBYTS+2    Move length of block\n         MVI   OUTECB,X'00'       Initialize ECB\n         EXCP  OUTIOB             Write out the buffer\n         WAIT  ECB=OUTECB         Wait for write to complete\n         CLI   OUTECB,X'7F'       Write completed normally?\n         BNE   WRITBERR           No - error\nWRITREAD DS    0H\n         AP    BLOCKCNT,=P'1'     Block count for this file\n         AP    BLOCKTOT,=P'1'     Block count for entire tape\n         MVC   UNFBUFFR,UNFBSTRT  Reset buffer start in UNFAREA\n         B     WRITBUFE           OK\nWRITBERR DS    0H\n* --- >  handle eov on output - below\n         NI    UNEXFLAG,FF-X'01'  Clear bit on unit exception flag\n         TM    OUTCSW+4,X'02'     Unit check?\n         BO    OUTERUC            Yes. Handle it.\n         TM    OUTCSW+4,X'01'     Unit exception on write?\n         BZ    OUTERR1            No. Assume data check.\n         OI    UNEXFLAG,X'01'     Flag that we have unit exception\n         MVC   LINE,LINE-1        Clear output line\n         MVC   LINE(133),OUTUNEX  Set unit exception error message\n         B     OUTERR2\nOUTERUC  MVC   LINE(133),OUTEQC   Set unit check error message\n         B     OUTERR2            Continue\nOUTERR1  DS    0H\n         MVC   LINE(133),OUTDCK   Set data check error message\nOUTERR2  DS    0H\n         ST    R2,SAVER2E         Save Registers\n         ST    R4,SAVER4E\n         ST    R5,SAVER5E\n         L     R2,OUTDCBPT        Load DCB address\n         LH    R4,40(,R2)         R4=TIOT offset\n         L     R5,16              R5=CVT\n         L     R5,0(,R5)          R5=TCB words\n         L     R5,4(,R5)          R5=My TCB\n         L     R5,12(,R5)         R5=TIOT\n         AR    R4,R5              R4=TIOT Entry for this output\n         MVC   LINE+34(6),4(R4)   Move DDNAME to message\n         L     R4,16(,R4)         R4=UCB for this output\n         MVC   LINE+47(4),12(R4)  Move unit address to message\n         MVC   LINE+60(6),36(R4)  Move VOLSER to message\n         L     R2,SAVER2E         Restore Registers\n         L     R4,SAVER4E\n         L     R5,SAVER5E\n         TM    UNEXFLAG,X'01'     Was this a Unit Exception only?\n         BNO   OTHERERR           No. Just go on.\nHANDLEOV DS    0H            If Unit Exception, then ask for new volume\n         PUT   SYSPRINT,LINE      Write message\n         BAL   R9,SUMMREPT        Print summary report before doing EOV\n         TM    READFLAG,X'01'     If Read Only, skip EOV macro.\n         BO    OTHERERR\n         MVC   OURRC,=F'4'        Indicate scratch volumes asked for\n         CLC   MAXRC,OURRC        Is MAXRC higher?\n         BH    SAMERC03           Yes. Keep it.\n         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.\nSAMERC03 DS    0H\n         EOV   TAPOUT\nOTHERERR DS    0H\n* --- >  handle eov on output - above\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS2\n         HEX   OUTLINE+34,4,UNFBYMVD    Print Reg 2\n         HEX   OUTLINE+44,2,HDRLENG     Pring Header Length\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFE                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\nWRITBUFE DS    0H                       Stats for data moved\n** ---------- >>    Record the number of bytes written\n         ST    R2,SAVER2N           Save prev contents of Register 2\n         ST    R3,SAVER3N           Save prev contents of Register 3\n         XR    R2,R2                High order is zero\n         L     R2,BLOKBYTS          Load Current Written Byte Count\n         LA    R3,DBIN              Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBINF             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DAINF             This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,LBINF             Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n** -->   label byte counts and data byte counts  <-- **  above\n         L     R2,SAVER2N           Restore prev contents of Register 2\n         L     R3,SAVER3N           Restore prev contents of Register 3\n** ---------- >>    Record the number of bytes written\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAGE3\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT TOTAL BYTES MOVED\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT PREVIOUS LENGTH\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFX                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\n         OI    BWRITFLG,X'01'           Show you've been here\nWRITBUFX DS    0H\n         L     R9,SAVER9WR          BAL register restore for WRITBUFF\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITTPMK DS    0H               Routine to write a tape mark\n         ST    R9,SAVER9WR      BAL register save for WRITTPMK\n         TM    READFLAG,X'01'   Is this run READ ONLY ?\n         BO    WRITTPME         Yes. Bypass entire routine.\n         LA    R1,TAPOUT        R1=address of current DCB\n         ST    R1,OUTDCBPT      Put it in IOB\n         MVI   OUTCCW,X'1F'     Tape Mark opcode\n         MVC   OUTCCWST(2),OUTCCW+6   Store previous move value\n         MVC   OUTCCW+6(2),X'0000'    Shove zeros into length field\n*                                     so AWSTAPE emulator doesn't barf\n         MVI   OUTECB,X'00'     Initialize ECB\n         EXCP  OUTIOB           Write the tape mark\n         WAIT  ECB=OUTECB       Wait for write to complete\n         CLI   OUTECB,X'7F'     Write completed normally?\n         BNE   WRITTPER         No. Indicate tape mark write error.\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST   Restore bytes moved field in CCW\n         B     WRITTPME         Don't indicate error condition\nWRITTPER DS    0H               Tape mark write error display\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS4\n         HEX   OUTLINE+34,4,OUTECB\n         HEX   OUTLINE+44,8,OUTCSW\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST    Restore byte moved field in CCW\nWRITTPME DS    0H\n         L     R9,SAVER9WR      BAL register restore for WRITTPMK\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  Add Byte Count subroutine\n         ST    R9,SAVER9AD         BAL register save for ADDCOUNT\n         ST    R4,SAVER4N          Save and Restore\n         ST    R5,SAVER5N             Work Registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           Else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         L     R4,SAVER4N          Save and Restore\n         L     R5,SAVER5N             Work Registers\nADDCOUNE DS    0H                  End of routine - Return\n         L     R9,SAVER9AD         BAL register restore for ADDCOUNT\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SU               Save BAL register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---- --- --- --->\n         TM    FLAGNEWV,X'01'\n         BZ    NOCHGVSR\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+3(130),MESSAGE7\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\nNOCHGVSR DS    0H\n* >---- --- --- --->\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),UNFINRCD   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INHDRS     NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE1    BEGINNING OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG04\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE2    MIDDLE OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG05\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE3    END OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE4    END OF TAPE HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG07\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE5    END OF TAPE HEADERS\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDLE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\nNOMIDDLE DS    0H\n*** -------- >>>\nNOSUMM05 DS    0H\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDPR\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\nNOMIDDPR DS    0H\n*** -------- >>>\nSUMMREPE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SU         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LC          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         LA    R1,TESTLABL          Point to 80 bytes to be tested.\n         CLC   =C'VOL1',0(R1)       Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   =C'HDR1',0(R1)       Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   =C'HDR2',0(R1)       This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   =C'EOF1',0(R1)       This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   =C'EOF2',0(R1)       This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   =C'EOV1',0(R1)       This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   =C'EOV2',0(R1)       This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   =C'UHL',0(R1)        This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   =C'UTL',0(R1)        This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  Yes. Don't change the volser.\n         CLI   FLAGNEWV,X'01'            Is the flag on, to change vol?\n         BNE   NOCHGVOL                  No. Don't change it.\n         L     R1,SVINAREA               Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAGE7+28(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\nNOCHGVOL DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         L     R1,SVINAREA               Point to INAREA\n         CLC   4(23,R1),ZERO23      WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\n         OI    FLAGHDRL,X'01'\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         OI    FLAGHDRL,X'01'\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOF2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\n         L     R9,SAVER9LC          Restore BAL register\nLABCHEND BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n         ST    R9,SAVER9RP\n*----------->>\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n*--->                   Block counts first  -  above\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    LBLSMSG0                  Yes. Show labels, not data.\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01A      Tell it's labels written.\n         B     ENDSMSG0\nLBLSMSG0 DS    0H\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01B      Tell it's data written.\nENDSMSG0 DS    0H\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3  Put file count in message\n*--->\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    DISLABLS                  Yes. Do the label treatment.\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Cumulative data bytes written\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),DATDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),LABDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINFH          Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBINH           Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\nREPTFEND DS    0H\n         L     R9,SAVER9RP\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nVALIDHDR DS    0H                     VALIDATE HEADER GOTTEN\n         NI    HDRVFLAG,FF-X'01'      Turn off invalid header flag.\n         CLI   HEADER+4,X'A0'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'80'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'20'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'00'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'40'\n         BE    VALIDHEN               Yes. Header is OK.\n         OI    HDRVFLAG,X'01'         Flag found header as invalid.\nVALIDHEN DS    0H\n         BR    R9\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\nOUTCCW   DC    X'01',AL3(0),X'2000',X'FFFF'     OUTPUT AREA OVERLAID\nOUTECB   DC    F'0'\nOUTIOB   DC    X'02000000'\n         DC    A(OUTECB)\nOUTCSW   DC    2F'0'\nOUTCCWPT DC    A(OUTCCW)\nOUTDCBPT DC    A(TAPOUT)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            PADDING\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY AWSIN\nAWSIN    DCB   DDNAME=AWSIN,MACRF=GM,EODAD=FIN,DSORG=PS,LRECL=80\nTAPOUT   DCB   MACRF=(E),DDNAME=TAPOUT,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X 05677\n               EODAD=SYSINEND                                            05678\n         DC    CL8' '\nFF       EQU   X'FF'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL6                     BLOCK HEADER\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRFLAG1 DC    X'00'                    FLAGS BYTE 1...\nHDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD\nHDRF1MOR EQU   X'00'                    ...MIDDLE OF RECORD\nHDRF1EOR EQU   X'20'                    ...END OF RECORD\nHDRF1TMK EQU   X'40'                    ...TAPE MARK\nHDRFLAG2 DC    X'00'                    FLAGS BYTE 2\n* ----------------------------------------------------------------- *\n*\nINHEADER DC    XL6'00'\nUNEXFLAG DC    X'00'                    FLAGS BYTE 1...\n         DC    XL80'00'                 PADDING\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'             Byte count in CCW - saved during WTM\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nBWRITFLG DC    X'00'    MESSAGE3 was already written flag.\n*              X'01'    Don't have to write SYSMOVED message now.\n* ---------- *\nINITFLAG DC    X'00'    First invocation of UNFOLDEM at beg of tape.\n*              X'01'    After the first invocation of UNFOLDEM.\n* ---------- *\nHDRVFLAG DC    X'00'    HEADER IS VALID IF X'00'\n*              X'01'    HEADER IS INVALID--FILE MUST BE CORRUPTED\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nREADFLAG DC    X'00'               This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nISLBLFLG DC    X'00'               80 BYTE BLOCK IS NOT A LABEL\n*              X'01'         80 BYTE BLOCK IS A LABEL\n* ---------- *\nFILBLFLG DC    X'00'               IS THE FILE A LABEL FILE?\n*              X'01'         THIS FILE IS A LABEL FILE\n* ---------- *\nFLAGHDRL DC    X'00'               HEADER LABEL FLAG\n*              X'01'         EOT HEADER IS FOLLOWING A HEADER LABEL\n* ---------- *\nFLAGSYST DC    X'00'           FLAG TO SHOW IF SYSTRACE DD IS THERE\n*              X'01'         //SYSTRACE DD IS THERE\n*              X'02'         //SYSMOVED DD IS THERE\n*              X'04'         //SYSFILES DD IS THERE\n*              X'08'         //SYSIN    DD IS THERE\n* ---------- *\nFLAGNEWV DC    X'00'           FLAG TO SHOW IF A NEW VOLSER PLUGGED IN\n*              X'01'         SVNEWVOL FIELD HAS BEEN SUBSTITUTED.\n* ---------- *\nNOWRTFLG DC    X'00'           FLAG TO SHOW NOT END OF BLOCK\n*              X'01'           ON - HAVE TO CONTINUE IN SAME BUFFER\n* ---------- *\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n* -------------------------------------------- *\nBLOKBYTS DC    F'0'                Count of bytes for block.\nFILEBYTS DC    F'0'                Count of bytes for file.\n* -------------------------------------------- *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHKNWVOL DC    CL6' '              Raw saved volser before syntax check\nDWORD    DC    D'0'\nSAVR2T5  DC    4F'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nINHDRS   DC    PL7'0'\nINTYPE1  DC    PL7'0'\nINTYPE2  DC    PL7'0'\nINTYPE3  DC    PL7'0'\nINTYPE4  DC    PL7'0'\nINTYPE5  DC    PL7'0'\nFILCOUNT DC    PL7'0'\nFERCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLERRCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL43\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Label Bytes'\nDATDISPL DS    0CL43\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data Bytes '\n*\nSAVEEN80 DS    F         Addresses:  80 bytes past record end\nSAVEENDC DS    F                     Record end location\nSAVEBEGC DS    F                     Record beginning location\nBEGDATA  DS    F                     Where this record's data begins\n*\n* below - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\n* ------                      Move count for bytes in the buffer\nBYTEBFWD DS    0F\nBYTEFILL DC    H'0'\nBYTEMOVE DC    H'0'\n* ------\nSVUNFOLD DC    F'0'           Entry point of UNFOLDEM subprogram\nSVINAREA DS    F\nSAVER2E  DS    F\nSAVER4E  DS    F\nSAVER5E  DS    F\nSAVER2N  DS    F              Has to do with byte counting subroutine\nSAVER3N  DS    F              Has to do with byte counting subroutine\nSAVER4B  DS    F              HEX print register save\nSAVER4N  DS    F              Has to do with byte counting subroutine\nSAVER4Q  DS    F              Has to do with byte counting subroutine\nSAVER5N  DS    F              Has to do with byte counting subroutine\n* --- below                   SAVE BAL REGISTER for each subroutine\nSAVER9HV DS    F              Has to do with Header Validation\nSAVER9AD DS    F              Has to do with ADDCOUNT routine\nSAVER9AF DS    F              Has to do with AFTRMOVE routine\nSAVER9WR DS    F              Has to do with WRITBUFF routine\nSAVER9WT DS    F              Has to do with WRITTPMK routine\nSAVER9CH DS    F              Has to do with CHKHEADR routine\nSAVER9LC DS    F              Has to do with LABELCHK routine\nSAVER9RP DS    F              Has to do with REPTFILE routine\nSAVER9SU DS    F              Has to do with SUMMREPT routine\n* --- above                   SAVE BAL REGISTER for each subroutine\n*\n* above - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\nOURRC    DC    F'0'\nMAXRC    DC    F'0'\nHDRBYTES DS    F\nHDRBSAVE DS    F\nSAVER8C2 DS    F\n         DC    C' '\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    BUFFER OVERFLOW ERROR  '\nERRMESS2 DC    CL133'    TAPE OUTPUT WRITE ERROR'\nERRMESS3 DC    CL133'    OFFSET ERROR           '\nERRMESS4 DC    CL133'    TAPE MARK WRITE ERROR  '\nERRMESS5 DC    CL133' >> AWS HEADER IS INVALID - CORRUPTION AT THIS POI-\n               NT >> '\nERRMESS6 DC    CL133' >> AWS HEADER IS INVALID - PREV BYTES - CURR BYTE-\n               S  >> '\n*\n*  -----------------            Tape Output Error Message Texts\nOUTEQC   DC    C' ********** EQUIPMENT CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\nOUTUNEX  DC    C' *********** TAPE HAS ENDED ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- PRIVATE SCRATCH REQUESTED '\n         DC    37C'*'\nOUTDCK   DC    C' **********      DATA CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2TAPE - AWS TAPE FILE TO ACTUAL TAPE CONVERSIO-\n               N PROGRAM  '\nMESSAGE4 DC    CL133'1VTT2TAPE  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE5 DC    CL133'1VTT2TAPE - AWS TAPE DATA MOVE - TRACE AND ERROR R-\n               EPORT  '\nMESSAGE6 DC    CL133'1VTT2TAPE - AWS TAPE FILE REPORT - MOVE AND WRITE -\n               STATS  '\nMESSAGE8 DS    0CL133\n         DC    CL8' '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'UNFSCARD'\n         DC    CL10'UNFECARD'\n         DC    CL10'UNFOFFST'\n         DC    CL10'UNFBYTES'\n         DC    CL10'UNFBYMVD'\n         DC    CL10'UNFBUFFR'\n         DC    CL10'UNFBSTRT'\n         DC    CL14'UNFINRCD'\n         DC    CL21' '\nMESSAGE9 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS GOTTEN BY THE PROGRAM, IN READING THROUGH A TAPE.'\nMESSAG10 DC    CL133'        THE UNFAREA (UNFOLD AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST GOTTEN.-\n               '\n*  -----------------            Diagnostic Info Message Texts\nMESSAGE2 DC    CL133'  OFFSET SIZE AND LOCATION '\nMESSAGE3 DC    CL133'  NUMBER OF BYTES WRITTEN  '\nMESSAGE7 DC    CL133'  VOLSER OVERRIDDEN TO:    '\nMESSAG11 DC    CL133'  NUMBER OF CHUNK BYTES    '\nMESSAG12 DC    CL133'  -- End of File Marker - File Number'\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS IN:  '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS IN:  '\nPRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS   :  '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS   :  '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS   :  '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS :  '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK :  '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01A DC    CL38'     DATA   WRITTEN FOR FILE:         '\nCTMSG01B DC    CL38'     LABELS WRITTEN FOR FILE:         '\nCTMSG02  DC    CL38'     BYTES  WRITTEN FOR FILE:         '\nCTMSG03  DC    CL38'     TOTAL BYTES   MOVED  FOR TAPE  : '\nCTMSG04  DC    CL38'     TOTAL BYTES  WRITTEN FOR TAPE  : '\nCTMSG05  DC    CL38'     TOTAL BYTES  WRITTEN FOR LABELS: '\nCTMSG06  DC    CL38'     TOTAL BYTES  WRITTEN FOR DATA  : '\nCTMSG07  DC    CL38'     BLOCKS WRITTEN FOR FILE:         '\nCTMSG08  DC    CL38'     TOTAL BLOCKS WRITTEN FOR TAPE  : '\n*\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nPRTLINE  DC    CL133' '\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\n* --- >\nSAVEHDR  DS    0CL6\nSAVCURLN DS    XL2\nSAVPRVLN DS    XL2\nSAVHFLGS DS    X\nSAVHREST DS    X\n* --- >\nPREVHDR  DS    0CL6\nPRVCURLN DS    XL2\nPRVPRVLN DS    XL2\nPRVHFLGS DS    X\nPRVHREST DS    X\n* --- >\nEOTMARK  DC    XL6'000000004000'\nDBINF    DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE\nDBINFH   DC    F'0'\nDBINFL   DC    F'0'\nDBIN     DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL\nDBINH    DC    F'0'\nDBINL    DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nLBINF    DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINFH   DC    F'0'\nLBINFL   DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\nDAINF    DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINFH   DC    F'0'\nDAINFL   DC    F'0'\n         DC    CL8' '\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 Extra fullword for safety\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n*      Uppercase alpha and only allow printable characters.\nTRTBLPRT DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'40D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'4040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\n*\nTESTLABL DC    CL80' '\nGETSYSIN DC    CL80' '\nINCARDP  DC    XL80'00'           Previous card-image read\nINCARD   DC    XL80'00'           Current  card-image read\nINCAEND  EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         IEZIOB DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2TST1": {"ttr": 22, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00P\\x01\\x01(\\x9f\\x01\\x014?\\x18\\x14\\x00\\x1d\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2001-12-09T18:14:50", "lines": 29, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*----------------------------------------------------------*//\n//*  MVS CYCLE TEST FOR VTT2TAPE AND VTT2DISK PROGRAMS       *//\n//*----------------------------------------------------------*//\n//AWSREAD  EXEC PGM=VTT2TAPE                  /* CUT A REAL TAPE/\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.T439MU   /* FB-80 AWS TAPE */\n//TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=T439RT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//*\n//AWSWRIT  EXEC PGM=VTT2DISK                  /* MAKE AN AWS TAPE */\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//TAPIN     DD  DISP=OLD,UNIT=582,VOL=SER=T439RT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//AWSOUT    DD  DSN=SBGOLOB.T439MT,DISP=SHR\n//*WSOUT    DD  DSN=SBGOLOB.T439MT,DISP=(NEW,CATLG,DELETE),\n//*         UNIT=SYSALLDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//*         SPACE=(CYL,(301,10),RLSE),VOL=SER=DATA04\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2TST2": {"ttr": 24, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x16\\x01\\x01(\\x9f\\x01\\x014\\x7f\\x19 \\x00\\x1d\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2001-12-13T19:20:16", "lines": 29, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*----------------------------------------------------------*//\n//*  MVS CYCLE TEST FOR VTT2DISK AND VTT2TAPE PROGRAMS       *//\n//*----------------------------------------------------------*//\n//AWSWRIT  EXEC PGM=VTT2DISK                  /* MAKE AN AWS TAPE */\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//TAPIN     DD  DISP=OLD,UNIT=582,VOL=SER=V440MT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//AWSOUT    DD  DSN=SBGOLOB.T440A1,DISP=(NEW,CATLG,DELETE),\n//          UNIT=SYSALLDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//          SPACE=(TRK,(2,2),RLSE),VOL=SER=DATA04\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//*\n//AWSREAD  EXEC PGM=VTT2TAPE                  /* CUT A REAL TAPE/\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.T440A1   /* FB-80 AWS TAPE */\n//TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=T440RT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2TST3": {"ttr": 26, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x002\\x01\\x01(\\x9f\\x01\\x014\\x8f\\t)\\x00\\x1d\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2001-12-14T09:29:32", "lines": 29, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*----------------------------------------------------------*//\n//*  MVS CYCLE TEST FOR VTT2TAPE AND VTT2DISK PROGRAMS       *//\n//*----------------------------------------------------------*//\n//AWSREAD  EXEC PGM=VTT2TAPE                  /* CUT A REAL TAPE/\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.AWSFB80  /* FB-80 AWS TAPE */\n//TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=TSTF80,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//*\n//AWSWRIT  EXEC PGM=VTT2DISK                  /* MAKE AN AWS TAPE */\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//TAPIN     DD  DISP=OLD,UNIT=582,VOL=SER=TSTF80,\n//          LABEL=(1,BLP,EXPDT=98000)\n//AWSOUT    DD  DSN=SBGOLOB.AWSFB80T,DISP=SHR\n//*WSOUT    DD  DSN=SBGOLOB.T439MT,DISP=(NEW,CATLG,DELETE),\n//*         UNIT=SYSALLDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//*         SPACE=(CYL,(301,10),RLSE),VOL=SER=DATA04\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2T2F$": {"ttr": 28, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00!\\x01\\x010\\x1f\\x01\\x05\\x00/\\t&\\x00 \\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2001-10-28T00:00:00", "modifydate": "2005-01-02T09:26:21", "lines": 32, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2T2FK)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,5),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY VTT2T2FK\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2T2FK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2T2F#": {"ttr": 30, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00 \\x01\\x01(\\x9f\\x01\\x05\\x00/\\x13\\x08\\x00\\x10\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2005-01-02T13:08:20", "lines": 16, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//AWSWRIT  EXEC PGM=VTT2T2FK\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//FAKEOUT   DD  DISP=SHR,DSN=SBGOLOB.V467FL\n//TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=V467MU,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//SYSIN     DD  *\nIDRCOFF\nNEWVOL=C467MU\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2T2FK": {"ttr": 32, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00X\\x01\\x00%O\\x01\\x05\\x00/\"\\x06\\t\\x82\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2005-01-02T22:06:58", "lines": 2434, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2T2FK -- READ A REAL TAPE AND CREATE FAKETAPE FILE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE:  VTT2T2FK.   Written by Sam Golob               **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to read in a tape, and create an      **\n**            MVS disk file in \"folded FB-80 FAKETAPE       **\n**            format\".                                      **\n**                                                          **\n**     The output of this program is intended to be input   **\n**     for the VTT2FK2T program.  These two programs,       **\n**     VTT2T2FK and VTT2FK2T, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  OBSERVATION:  Although this program is purely an MVS    **\n**                program, the FAKETAPE output of this      **\n**     program can be downloaded to other systems where     **\n**     the file can actually be interpreted as an emulated  **\n**     tape.  This is one way of transferring tape data to  **\n**     other MVS systems that can read FAKETAPE tape        **\n**     files directly, as though they were tapes.           **\n**                                                          **\n**     For example, you can take mainframe-based tapes      **\n**     on real cartridges and create FAKETAPE-compatible    **\n**     files that can be read on a FLEX-ES system.          **\n**                                                          **\n**     FAKETAPE files do not currently support chunked      **\n**     blocks, but I have preserved the structure of the    **\n**     VTT2DISK program here, so that if chunked blocks     **\n**     will be supported later by FAKETAPE, then it will    **\n**     be relatively easy to put in support for them.  We   **\n**     pretend, in the logic of this program, that there    **\n**     is a maximum chunk size of 65535, so that all 64K    **\n**     blocks will come out with \"chunksize equals          **\n**     blocksize\" treatment.                                **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     Tape data is read into a data buffer in this         **\n**     program.  Each block is read in, and its size        **\n**     is determined.  This size is compared to the 65535   **\n**     byte chunk size, and a decision is made as to what   **\n**     to do.  A FAKETAPE header is made for each chunk.    **\n**     Each FAKETAPE header is folded into FB-80 output,    **\n**     and then the data is folded in afterward, until      **\n**     the block, and its associated FAKETAPE header, is    **\n**     folded in.  Then another tape block is read into     **\n**     the buffer, and the process repeats.                 **\n**                                                          **\n**     When the tape file ends, and a tape mark is read     **\n**     in, a FAKETAPE header with \"zero next bytes\" is      **\n**     constructed.  This indicates a tape mark written.    **\n**     That header is then folded into the FB-80 output     **\n**     dataset after the last data.  The first header for   **\n**     the next file, if any, immediately follows.          **\n**                                                          **\n**     At the end of the tape, an end-of-tape FAKETAPE      **\n**     header is appended to the end of the output          **\n**     file and folded in.  The last FB-80 record           **\n**     is completed with X'30's, if necessary.  This may,   **\n**     depending on how many of them there are, signify     **\n**     more tape marks at the end of the FAKETAPE file.     **\n**     Since the last 80-byte record has to be completed    **\n**     with some kind of data, it seemed that X'30's,       **\n**     which are what FLEX-ES itself produces at the end    **\n**     of FAKETAPE files, are the safest things to put      **\n**     there.                                               **\n**                                                          **\n**     This program was adapted from version 1.12 of the    **\n**     VTT2DISK program, which is part of the Virtual       **\n**     Tape Transportation System (VTTS), copyright (c)     **\n**     2001-2005 by Sam Golob.                              **\n**                                                          **\n**     All of the \"FB-80 folding\" work is now done by the   **\n**     sub-program called FOLDEM.  The FOLDEM program       **\n**     operation is completely controlled by a control      **\n**     block called the FLDAREA control block, which does   **\n**     all of the communication between the main program    **\n**     and the FOLDEM sub-program.  Therefore, monitoring   **\n**     of the folding process is now possible purely by     **\n**     displaying the current status of the FLDAREA         **\n**     fields.  A convenient routine for displaying the     **\n**     status of the FLDAREA fields is the FLDIMAGE         **\n**     routine in either program, which is invoked by:      **\n**                                                          **\n**     BAL   R9,FLDIMAGE                                    **\n**                                                          **\n**     Therefore the fold monitoring displays that used     **\n**     to be in the SYSMOVED DD name, are now obsolete.     **\n**                                                          **\n**     There are two more fields in the FLDAREA control     **\n**     block than in the UNFAREA control block of the       **\n**     UNFOLDEM sub-program that VTT2FK2T uses.  These      **\n**     are:                                                 **\n**                                                          **\n**           FLDBYTOT - bytes left in buffer after the      **\n**                      last chunk of data was folded       **\n**           FLDREADF - propagation of the \"read only\"      **\n**                      flag into the sub-program           **\n**                                                          **\n**     These extra fields are obviously not required by     **\n**     the unfolding process.  The first one is not         **\n**     required because you're doing \"unchunking\" instead   **\n**     of \"chunking\", and you read the existing chunks      **\n**     as they come in; you're not required to create       **\n**     them.  The second one is not required because the    **\n**     main program writes the output (a tape) instead of   **\n**     the sub-program writing the output (an FB-80 file).  **\n**     So in our case, in a READ only situation, the        **\n**     sub-program must know when to NOT produce FAKEOUT    **\n**     output.                                              **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**     In order to make sure that the VTT2T2FK program      **\n**     is doing its job properly, it produces a lot of      **\n**     trace data and status data, as it is creating        **\n**     the folded FB-80 FAKETAPE format tape.  In order     **\n**     not to clutter the summary report, most of this      **\n**     data is written to \"Optional DDNAMEs\".  Starting     **\n**     with version 1.12 of this program, most of the       **\n**     trace data now consists of the state of the FLDAREA  **\n**     control block fields at various stages of program    **\n**     execution.                                           **\n**                                                          **\n**     If you have access to the source code (you are       **\n**     reading it), you can introduce an instruction:       **\n**                                                          **\n**           BAL   R9,FLDIMAGE                              **\n**                                                          **\n**     at any point in the program, as long as SYSPRINT     **\n**     is open.  This should produce any diagnostics you    **\n**     may need, because all FLDAREA fields are displayed.  **\n**                                                          **\n**     Optional DDNAMEs don't have to be coded in the       **\n**     JCL.  But if they are coded, they will contain       **\n**     the extra trace data which VTT2T2FK produces,        **\n**     and the SYSFILES ddname will contain a detailed      **\n**     \"file by file\" report.                               **\n**                                                          **\n**     The SYSFILES report is very useful if you want       **\n**     to do a \"dry run\", with the READ parameter.  If      **\n**     you want to know the structure of a tape without     **\n**     creating the FB-80 output file, the SYSFILES         **\n**     report will tell you what files are on the tape.     **\n**     It will also give you an indication of how big an    **\n**     FB-80 output file you will need on an MVS disk,      **\n**     to contain all the tape data.  See below for         **\n**     details.                                             **\n**                                                          **\n**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **\n**     and SYSIN.  SYSMOVED is now obsolete, although       **\n**     it will produce a dummy report if it is present      **\n**     in the JCL.                                          **\n**                                                          **\n**     SYSIN data is necessary if optional parameters       **\n**     are to be entered, such as:                          **\n**                                                          **\n**     NEWVOL=volser                                        **\n**     READ                                                 **\n**     IDRCOFF                                              **\n**                                                          **\n**     SYSIN keywords have to start in column 1.            **\n**                                                          **\n**     Either READ or IDRCOFF can also be entered in the    **\n**     PARM field of the EXEC card in the JCL.              **\n**                                                          **\n**     Full JCL to run the VTT2T2FK program is as           **\n**     follows:                                             **\n**                                                          **\n**     //   jobcard                                         **\n**     //TAPEREAD EXEC PGM=VTT2T2FK                         **\n**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **\n**     //FAKEOUT   DD  DSN=fb80.folded.faketape,            **\n**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **\n**     //          VOL=SER=volxxx,                          **\n**     //          SPACE=(CYL,(mm,nn),RLSE)                 **\n**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **\n**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **\n**     //          LABEL=(1,BLP,EXPDT=98000)                **\n**     //SYSPRINT  DD  SYSOUT=*                             **\n**     //SYSFILES  DD  SYSOUT=*                             **\n**     //SYSTRACE  DD  SYSOUT=*                             **\n**     //SYSUDUMP  DD  SYSOUT=*                             **\n**     //SYSIN     DD  *                                    **\n**     keywords in column 1                                 **\n**     /*                                                   **\n**                                                          **\n**     where you can leave out SYSTRACE and SYSUDUMP        **\n**     if you want to.  I'd strongly suggest including      **\n**     (at least) SYSFILES, though.                         **\n**                                                          **\n**     SYSTRACE takes a picture of the tape buffer at       **\n**     READ time, and takes a picture of the AWS headers    **\n**     and the FLDAREA control block fields at the time     **\n**     the headers are made.  Since the folding is now      **\n**     done by the FOLDEM subprogram, SYSMOVED, which       **\n**     used to track the data folding process, is now       **\n**     not necessary.  Of course SYSUDUMP is there to       **\n**     contain the MVS-produced dump, upon any abnormal     **\n**     termination of the program.                          **\n**                                                          **\n**     SYSFILES gives you block counts and byte counts      **\n**     for all files read and written.                      **\n**                                                          **\n**     In the SYSPRINT report, there is a count of total    **\n**     number of 80-byte records which the program will     **\n**     (or has) put out.  If you are doing a READ only      **\n**     run, and want to allocate an output file which is    **\n**     the right size, you might use this number, together  **\n**     with the BLKnnnn command from File 296 of the CBT    **\n**     Tape, to produce the following result:               **\n**                                                          **\n**     Say, our program produces:                           **\n**                                                          **\n**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **\n**                                                          **\n**     And you want to allocate space on a 3390.  So you    **\n**     would say:                                           **\n**                                                          **\n**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **\n**                                                          **\n**     Which comes up with the result:                      **\n**                                                          **\n** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **\n**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.12 - Re-architected program to use FOLDEM   **\n**       sub-program for data moves.  The FOLDEM program    **\n**       is driven by the FLDAREA control block, so the     **\n**       trace data consists mostly of the state of the     **\n**       FLDAREA control block fields.  A routine called    **\n**       FLDIMAGE will print all the FLDAREA control block  **\n**       fields on a single SYSPRINT line.                  **\n**                                                          **\n**       Added the possibility of coding program options    **\n**       in the SYSIN DD, which is used if it is present    **\n**       in the JCL.  SYSIN keywords, which must be coded   **\n**       to start in column 1, are currently:               **\n**                                                          **\n**       NEWVOL=volser                                      **\n**       READ                                               **\n**       IDRCOFF                                            **\n**                                                          **\n**       This program was adapted from Version 1.12 of      **\n**       the VTT2DISK program, so its initial version       **\n**       is also called Version 1.12.                       **\n**                                                          **\n**       The NEWVOL=volser keyword in SYSIN, allows you     **\n**       to change the volser in the VOL1 label of the      **\n**       output FAKETAPE tape file.                         **\n**                                                          **\n**       Now, the READ and IDRCOFF keywords of the EXEC     **\n**       PARM field, can also be coded in SYSIN.  They      **\n**       must begin in column 1.  READ allows a dry run     **\n**       of the program which reads the input tape and      **\n**       reports statistics, but which does not produce     **\n**       an output FB-80 AWS file.                          **\n**                                                          **\n**       IDRCOFF looks in the tape standard labels, if      **\n**       there are any, and turns off any \"P\" indicators    **\n**       which tell MVS that this tape was produced on      **\n**       an IDRC-enabled tape drive.  Since the output      **\n**       FB-80 file is not compressed anyway, one wants     **\n**       the power to read the FAKETAPE tape file on a      **\n**       logical 3420 or 3480 tape drive, without MVS       **\n**       telling you that \"the tape has compressed files    **\n**       and I can't read it\" on this particular drive.     **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.  *\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n         GBLC  &DEFCHKC\n         GBLA  &DEFCHNK\n&LLEV    SETC  '1.12'\n* ------------------------------------------------------------------ *\n*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *\n*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *\n* ------------------------------------------------------------------ *\n*   FAKETAPE does not support chunking of blocks, but if the         *\n*   chunk size is set to the largest possible value for a 64K        *\n*   block size limit, all chunksizes will equal the block sizes.     *\n* ------------------------------------------------------------------ *\n&DEFCHNK SETA  65535\n&DEFCHKC SETC  '&DEFCHNK'\n         YREGS\n         EJECT\n** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **\nVTT2T2FK CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2T2FK AMODE 24\nVTT2T2FK RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2T2FK - REAL TAPE TO FOLDED FAKETAPE DISK FILE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001-2005 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2T2FK,R12,R11,R10,R8,R7\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LA    R7,4095(,R8)\n         LA    R7,1(,R7)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n* ----- >                            Parms          <--- below\n         L     R1,0(R1)              Get PARM field\n         CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BE    COPYREAD              Yes. Turn on indicator.\n         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?\n         BE    COPYIDRF              Yes. Say that.\n         B     COPYTAPE              No. Just go on with processing.\nCOPYREAD DS    0H                    READ only?\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     COPYTAPE\nCOPYIDRF DS    0H                    IDRC indicators off?\n         OI    IDRCFLAG,X'01'        Yes. Turn on flag.\n         B     COPYTAPE\n*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.\nCOPYTAPE DS    0H\n* ----- >                            Parms          <--- above\n*\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE3+88(31),HEADDLIT\n         MVC   MESSAGE4+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE2+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE3+61(21),LEVELLIT\n         MVC   MESSAGE4+61(21),LEVELLIT\n***********************************************************************\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants\n         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.\n         MVC   FULLHIGH(2),=X'0000'\n         MVC   CURRBYTE(2),=X'0000'\n         MVC   LASTBYTE(2),=X'0000'\n         MVC   HDRSIZE(4),=F'12'     Set size of header globally.\n         MVC   FLDOFFST(4),=F'0'     Offset is initially zero\n         LA    R1,OUTCARD            Let FOLDEM know about FAKEOUT area\n         ST    R1,FLDSCARD           Beginning of card image output\n         ST    R1,SVBEGCRD\n         LA    R1,80(,R1)            Find end of card\n         ST    R1,FLDECARD           And store it away for the duration\n         ST    R1,SVENDCRD\n         L     R1,=A(INAREA)         Get address of input buffer\n         ST    R1,SVBFAREA           And save it away.\n         ST    R1,FLDBUFFR           Prime these fields\n         ST    R1,FLDBSTRT\n         L     R0,=F'&DEFCHNK'       Set default chunk size.\n         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.\n         ZAP   FLDOUTCT,=P'0'        Zero count of FAKEOUT records.\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n* ----------------------------------------------------------------- *\n* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *\n* ----------------------------------------------------------------- *\n*\n         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.\n*\n* ----------------------------------------------------------------- *\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n* - - - ->  Chunk Size Message - - - ->   below\n*    The purpose of this code is to fill MESSAG14 with information.\n         L     R1,CHNKSIZE                  Load binary Chunk Size\n         XC    DWORD,DWORD                  Clear DWORD to zeros.\n         CVD   R1,DWORD                     Convert to decimal.\n         OI    DWORD+7,X'0F'                Make sign readable.\n         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message\n         ED    MESSAG14+28(8),DWORD+4       Edit the number\n         B     AFCHKDSP                     Branch past constant\nCHPATTRN DC    X'4020202020202120'          8 bytes of pattern\nAFCHKDSP DS    0H\n* - - - ->  Chunk Size Message - - - ->   above\n         TM    READFLAG,X'01'        Read Only run?\n         BO    NOFAKOUT              Yes. Don't OPEN FAKEOUT.\n         OPEN  (FAKEOUT,(OUTPUT))\nNOFAKOUT DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (TAPIN,(INPUT))\n*--->>\n         MVC   MSGLINE1,MSGLINE1-1   Clear optional\n         MVC   MSGLINE2,MSGLINE2-1      message lines\nREADIDRC DS    0H\n         TM    READFLAG,X'01'        READ only run?\n         BZ    IDRCMSG\nREADMSG  DS    0H\n         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'\nIDRCMSG  DS    0H\n         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?\n         BZ    ENDEXMSG\n         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'\nENDEXMSG DS    0H\n*--->>\nTRACERPT DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE      Blank Line\n         PUT   SYSTRACE,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    TRACENOI\n         PUT   SYSTRACE,MSGLINE2     IDRC remove message\nTRACENOI DS    0H\n*        PUT   SYSTRACE,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\nTRACDESC DS    0H\n         PUT   SYSTRACE,MESSAGE8\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE5\n         PUT   SYSTRACE,MESSAGE6\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAG11\n         PUT   SYSTRACE,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE7\n*--->>\nMOVEDRPT DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE      Blank Line\n         PUT   SYSMOVED,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    MOVEDNOI\n         PUT   SYSMOVED,MSGLINE2     IDRC remove message\nMOVEDNOI DS    0H\n*        PUT   SYSMOVED,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAGE9\n         PUT   SYSMOVED,MESSAG10\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAG11\n         PUT   SYSMOVED,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n*--->>\nFILESRPT DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE      Blank Line\n         PUT   SYSFILES,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    FILESNOI\n         PUT   SYSFILES,MSGLINE2     IDRC remove message\nFILESNOI DS    0H\n*        PUT   SYSFILES,MESSAG14\n*--->>\nNOSYSFIL DS    0H\n* ----------------------------------------------------------------- *\n*   Now do the same for SYSPRINT report, which is always there.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         PUT   SYSPRINT,OUTLINE      Blank Line\n         PUT   SYSPRINT,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    PRINTNOI\n         PUT   SYSPRINT,MSGLINE2     IDRC remove message\nPRINTNOI DS    0H\n*        PUT   SYSPRINT,MESSAG14\n*--->>\n*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.\n*        BAL   R9,FLDIMAGE\n*--->>\n* ----------------------------------------------------------------- *\nTAPEREAD DS    0H                      READ a new tape block.\n* ----------------------------------------------------------------- *\n*   You come here every time you do a tape READ.\n* ----------------------------------------------------------------- *\n         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks\n         BAL   R9,READBLOK             Read a block of data\n         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?\n         BO    MAINTPMK                Yes. Take appropriate action.\n* --- >\n         L     R1,CURRBFUL             Fullword number of bytes read\n         C     R1,CHNKSIZE             Bigger than chunk size?\n         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.\n         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.\n         NI    BUFINISH,FF-X'01'       Turn \"buffer finished\" flag off\n         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer\n         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved\n         B     AFTRCHNK                Jump over other alternative\nNOCHUNKS DS    0H\n         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.\n         OI    BUFINISH,X'01'          Buffer is finished in one shot.\n         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total\n         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total\n* --- >                                Label check if HDR - below\nAFTRCHNK DS    0H\n         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?\n         BNE   MAINNOTL                No. Can't be a label.\n         BAL   R9,LABELCHK             Check for labels and their kind.\n         TM    ISLBLFLG,X'01'          Is this record a label?\n         BZ    MAINNOTL                No. Bypass flag setting.\n         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?\n         BZ    MAINNOTH                Neither. Check if EOF or EOV.\n         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.\nMAINNOTH DS    0H\n         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?\n         BZ    MAINNOTL                No. Don't turn off flag.\n         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.\nMAINNOTL DS    0H\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW\n** -->              stuff below is only done per READ.\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,CURRBFUL          Load Current READ Byte Count\n         LA    R3,DBOUTF            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUT             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n** -->              stuff above is only done per READ.\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE\n* --- >                                Label check if HDR - above\n**-------------------------------------------------------------------**\nFOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL\n*                                   THE BUFFER IS EXHAUSTED.\n         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields\n         MVC   FLDECARD,SVENDCRD\n         L     R3,=A(INAREA)           Point to the data buffer\n         ST    R3,FLDBUFFR             Initialize\n         ST    R3,FLDBSTRT                 FLDAREA fields\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n*                                      because we'll have to fold the\n*                                      newly manufactured header.\n**-------------------------------------------------------------------**\nFOLDLOOP DS    0H\n         L     R1,FLDBYTOT          Compare bytes remaining to fold\n         C     R1,CHNKSIZE          To the chunk size.\n         BH    FOLDNCHK             If now less than or equal\n         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off\n         OI    BUFINISH,X'01'       And turn \"buffer finished\" flag on\n         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.\nFOLDNCHK DS    0H\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n         BAL   R9,MAKEHEDR             Create a header with READ info\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER               Point to address of this header\n         ST    R3,FLDBUFFR             Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF             And fold it into FB-80.\n         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA\n         MVC   FLDBYMVD,=F'0'          Initialize bytes folded\n         BAL   R9,FOLDBUFF             And fold it into the output.\n         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block\n** ---------- >>    Record the number of bytes folded - below\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,FLDBYMVD          Load Current folded Byte Count\n         LA    R3,DBOUTFM           Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUTM            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOFLDCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2\n** ---------- >>    Record the number of bytes folded - above\n         TM    CHNKFLAG,X'01'          Are we doing chunks?\n         BZ    TAPEREAD                No. Do another tape read.\n         TM    BUFINISH,X'01'          Have we finished this block?\n         BO    TAPEREAD                Yes. Read another block.\n         B     FOLDLOOP                No. Fold more chunks.\n*\nMAINTPMK DS    0H                   Last read was a T.M.\n         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         BAL   R9,MAKEHEDR          Make a header to show EOF.\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header\n         BAL   R9,REPTFILE          Report Block and Byte Counts\n*--->>\n         MVC   DBOUTF(8),=D'0'      Zero File Byte Count\n         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count\n         ZAP   BLOCKCNT,=P'0'       Zero File Block Count\n*--->>\n         B     TAPEREAD             Read in another tape block.\n*\n* ---------------------------------------------------------------- *\n*          END OF INPUT TAPE DATA                                  *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         OI    TPMKFLAG,X'01'       Force Tape Mark indication.\n         BAL   R9,MAKEHEDR          Make EOT header\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\nBREAKLUP DS    0H\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk\n         TM    READFLAG,X'01'       READ only?\n         BO    NOPUT01              Yes. No output to FAKEOUT.\n         PUT   FAKEOUT,OUTCARD      And write out the last buffer.\nNOPUT01  DS    0H\n         AP    FLDOUTCT,=P'1'       Count the record PUT out.\nWRITSUMM DS    0H\n         BAL   R9,SUMMREPT          Print the summary report.\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\nCLOSEMAL DS    0H                   Close em all.....\n         CLOSE TAPIN\n         TM    READFLAG,X'01'       Is this a READ only run?\n         BO    NOFKOCLS             Can't CLOSE what ain't OPEN.\n         CLOSE FAKEOUT\nNOFKOCLS DS    0H\n         CLOSE SYSPRINT\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n*\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*   Input :  R1 points to 2-byte binary number.  LA    R1,BINNUM\n*   Output:  ASCWORK contains the 4-byte ASCII equivalent.\nASCCNVRT DS    0H\n         ST    R9,SAVER9AC\n         HEX   ASCWORK,2,0(R1)\n         TR    ASCWORK(4),TRASCNUM\nASCCNVRE DS    0H\n         L     R9,SAVER9AC\n         BR    R9\n         DS    CL2\nASCWORK  DS    XL4\n         DS    CL2\nTRASCNUM DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30414243444546303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30313233343536373839303030303030'\nTRTA2E   DS    0D                                                        05559\n         DC    XL16'000102030405060708090A0B0C0D0E0F'                    05560\n         DC    XL16'101112131415161718191A1B1C1D1E1F'                    05561\n         DC    XL16'405A7F7B5B6C507D4D5D5C4E6B604B61'                    05562\n         DC    XL16'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'                    05563\n         DC    XL16'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'                    05564\n         DC    XL16'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'                    05565\n         DC    XL16'79818283848586878889919293949596'                    05566\n         DC    XL16'979899A2A3A4A5A6A7A8A9C04FD0A17F'                    05567\n         DC    XL16'808182838485868788898A8B8C8D8E8F'                    05568\n         DC    XL16'909192939495969798999A9B9C9D9E9F'                    05569\n         DC    XL16'A0A14AB19FB26AB5BBB4AAABB0ADAFBC'                    05570\n         DC    XL16'B08FB2B3BEA0B6B39DB99BB8B7B8B9AB'                    05571\n         DC    XL16'C0C1C2C3C4C59EC7C8C9CACBCCCDCECF'                    05572\n         DC    XL16'ACD1D2D3D4D5D6BFD8D9DADBDCDDAEDF'                    05573\n         DC    XL16'E0E1E2E3E4E59CE7E8E9EAEBECEDEEEF'                    05574\n         DC    XL16'8CF1F2F3F4F5F6E1F8F9FAFBFC8D8EFF'                    05575\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nSCNSYSIN DS    0H                 Routine to extract info from SYSIN.\n         ST    R9,SAVER9SC\n* -------------- >>>>>>   Look for SYSIN cards            - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    SCNSYSIE             No. Then can't open it. So get out.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BE    SYSNWVOL              Yes. Go process the new volume.\n         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?\n         BE    SYSCHUNK                    Looks that way.....\n         CLC   =C'READ ',GETSYSIN\n         BE    SYSREAD\n         CLC   =C'IDRCOFF ',GETSYSIN\n         BE    SYSIDRCO\n         B     SYSINLUP              Look for another card.\nSYSNWVOL DS    0H\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         B     SYSINLUP\nSYSCHUNK DS    0H\n         CLI   GETSYSIN+10,C' '  Is the first number value blank?\n         BE    SYSINLUP          Yes. Ignore entire card.\n         CLI   GETSYSIN+10,X'F0' Smaller than zero?\n         BL    SYSINLUP          Yes. Get another card.\n         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?\n         BH    SYSINLUP          Yes. Get another card.\n         OI    FLAGCHNK,X'01'    Show chunk size default was changed.\n         LA    R15,GETSYSIN+10   Now get the number that was coded.\n         LR    R1,R15            Load R1 with beginning of the number.\nSYSCHNUM DS    0H\n         LA    R15,1(,R15)       Bump to next character.\n         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?\n         BH    SYSCHGNM          Yes. Go get the number.\n         CLI   0(R15),C' '       Not end of card. But is it a blank?\n         BE    SYSCHGNM          Yes. Then get the number.\n         B     SYSCHNUM          Not a blank yet. Step up one place.\nSYSCHGNM DS    0H\n         SR    R15,R1            How many digits is the number?\n         BCTR  R15,0             Lower it by one for EXECUTE.\n         EX    R15,PACK          Copy the number to work area.\n         CVB   R0,WORKA          Convert it to a binary number.\n         ST    R0,CHNKSIZE       And store the value for later use.\n         L     R0,=F'&DEFCHNK'   >>> Force 65535 chunk size.\n         ST    R0,CHNKSIZE       >>> X'FFFF' is the only possibility.\nSYSCHCLG DS    0H\n         B     SYSINLUP          Go look for another card.\nSYSREAD  DS    0H\n         OI    READFLAG,X'01'\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     SYSINLUP\nSYSIDRCO DS    0H\n         OI    IDRCFLAG,X'01'\n         B     SYSINLUP\nSYSINEND DS    0H                No more cards. Close SYSIN DCB.\n         CLOSE SYSIN\n* -------------- >>>>>>   Look for SYSIN cards            - ABOVE\nSCNSYSIE DS    0H\n         L     R9,SAVER9SC\n         BR    R9\n* - - >\nPACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>\nWORKA    DC    D'0'\n* - - >\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*     Routine to read a block of data from the input tape and\n*     save byte counts from it, to make the FAKETAPE headers.\n* ----------------------------------------------------------------- *\nREADBLOK DS    0H\n         ST    R9,SAVER9RB        Save BAL register\n         ST    R2,SAVER2R         Store work registers\n         ST    R3,SAVER3R\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Read\n         WAIT  ECB=INECB          Wait for Read\n         TM    INCSW+4,X'01'      Was TM Read?\n         BO    READTPMK           Yes\n         CLI   INECB,X'7F'        Did Read complete normally?\n         BNE   INERR              No -- error\n         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.\n         AP    BLOCKCNT,=P'1'\n         AP    BLOCKTOT,=P'1'\n         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read\n         XC    FULLWORK,FULLWORK   Clear area completely\n         MVC   HALFWORK(2),INCCW+6   Read length\n         L     R2,FULLWORK           Load R2 with full low order\n         MVC   HALFWORK(2),INCSW+6   Residual byte count\n         L     R3,FULLWORK           Load R3 with full low order\n         SR    R2,R3              R2=Actual length read\n         STH   R2,BYTESCOP        Save quantity of bytes copied\n         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block\n         NI    ISLBLFLG,X'FF'-X'01'  Turn off \"IS LABEL\" flag\n         OI    NWBLKFLG,X'01'        Turn on \"new block\" flag\n         B     READNOTM           This READ was not a Tape Mark\n*\nREADTPMK DS    0H                 This READ was a Tape Mark\n         TM    TPMKFLAG,X'01'     Check if there was another TM before\n         BZ    READTFST           No. First one.\n         OI    TPMKFLAG,X'02'     If two in a row, flag that situation\nREADTFST DS    0H\n         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?\n*\n* --- >                           Null SL file is not EOT - below\n         BNO   NOFIN1               Not 2 T.M. in a row. Go on.\n         TM    FLAGHDRL,X'01'       Test if HDR label was last seen\n         BO    NOFIN0               Yes. Must be null SL file.\n         B     FIN                  Otherwise, valid 2 TMs and EOT.\nNOFIN0   DS    0H\n         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.\nNOFIN1   DS    0H\n* --- >                           Null SL file is not EOT - above\n*\n         AP    FILCOUNT,=P'1'     Add 1 to File Count.\n         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.\n         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.\nREADNOTM DS    0H\n* ---->     for the trace            All READ results should come here\n         MVC   LINE,LINE-1           Clear output line\n         MVC   LINE+1(16),READTRMS   Put in Read Trace message\n         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?\n         BZ    ITSABLOC              No. Mark trace as for a block.\n         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.\n         B     ITSATPMK              And go farther.\nITSABLOC DS    0H\n         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block\nITSATPMK DS    0H\n         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ\n         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header\n         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header\n         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag\n         HEX   LINE+40,12,HEADER     Show the Header last constructed\n         HEX   LINE+68,30,INAREA     Show first 20 bytes of Input Area\n         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?\n         BNO   NOREADT1              No. Can't print trace line.\n         PUT   SYSTRACE,LINE\nNOREADT1 DS    0H                    Trace is finished.\n* ---->     for the trace\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R\n         B     READBEND           and exit normally.\n* -----\nINERR    DS    0H                 READ error on input tape\n         MVC   LINE,LINE-1        Clear print line\n         TM    INCSW+4,X'02'      Unit Check?\n         BZ    INERR1             No - Assume Data Check\n         MVC   LINE(133),INEQC    Set Error Message\n         B     INERR2             Continue\nINERR1   MVC   LINE(133),INDCK    Set Error Message\nINERR2   PUT   SYSPRINT,LINE      Write Error Message\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R         Rewind the tape, and exit.\n         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Rewind and Unload\n         WAIT  ECB=INECB          Wait for Rewind and Unload\n         B     WRITSUMM           Write summary of what was done,\n*                                  and get out of the program.\nREADBEND DS    0H\n         L     R9,SAVER9RB        Restore BAL register\n         BR    R9\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nMAKEHEDR DS    0H\n         ST    R9,SAVER9MH\n* ----------------------------------------------------------------- *\n*     We are forming the new header in the field HEADER.\n*     We assume that the TAPEREAD subroutine was executed first.\n*     We assume that the FLDAREA was previously saved to SAVAREA.\n* ----------------------------------------------------------------- *\n         MVC   HEADER(12),BLNKHEDR     Start fresh.\n         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header\n         MVC   HDRNSTOR(2),CURRBYTE\n         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot\nMAKEWHAT DS    0H                      Manufacture the proper hdr flags\n         TM    TPMKFLAG,X'01'          Has a tape mark been read?\n         BO    MAKETPMH                First test. Make a X'40' header\n         B     MAKEFAKE\nMAKETPMH DS    0H                      Tape mark has been read.\n         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.\nMAKEFAKE DS    0H\n         MVC   HDRCHKWK(2),HDRPRVLN    Create header check field\n         XC    HDRCHKWK(2),HDRCURLN    XOR prev with curr\n* --                                   Convert quantities to ASCII\n         LA    R1,HDRPRVLN             Previous bytes in binary\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKPRV(4),ASCWORK     Stuff into header field\n         LA    R1,HDRCURLN             Current bytes in binary\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKNXT(4),ASCWORK     Stuff into header field\n         LA    R1,HDRCHKWK             XOR of both of them\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKCHK(4),ASCWORK     Stuff into header field\n* --                                   The header is now created\n         MVC   HEADEREB(12),HEADER     Move copy of header to wkarea\n         TR    HEADEREB(12),TRTA2E     Translate into EBCDIC for print\nMAKEHDEN DS    0H\n         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN\n         AP    OUTHDRS,=P'1'           Count this header we've made.\n*----------------------------------------------------------------- *\n*   Now that we've made a header, we do a display.\n*----------------------------------------------------------------- *\n*\nKINDAHEN DS    0H\n         CLC   HDRFKNXT,=X'30303030'\n         BNE   BLOKHEDR\n         AP    OUTTYPE2,=P'1'\n         B     NOTBLOKH\nBLOKHEDR DS    0H\n         AP    OUTTYPE1,=P'1'\nNOTBLOKH DS    0H\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE\n         MVC   OUTLINE+2(4),=C'hdr:'\n         MVC   OUTLINE+8(12),HEADEREB   EBCDIC REPRESENTATION OF HEADER\n         HEX   OUTLINE+28,4,FLDSCARD                            .\n         HEX   OUTLINE+38,4,FLDECARD                            .\n         HEX   OUTLINE+48,4,FLDOFFST                            .\n         HEX   OUTLINE+58,4,FLDBYTES                            .\n         HEX   OUTLINE+68,4,FLDBYTOT                            .\n         HEX   OUTLINE+78,4,FLDBYMVD                            .\n         HEX   OUTLINE+88,4,FLDBUFFR                            .\n         HEX   OUTLINE+98,4,FLDBSTRT                            .\n         HEX   OUTLINE+108,7,FLDOUTCT                           .\n         HEX   OUTLINE+124,1,FLDREADF\n         PUT   SYSTRACE,OUTLINE\nNOSYSTR1 DS    0H\nMAKEHEND DS    0H\n         L     R9,SAVER9MH\n         BR    R9\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*                                                           *\n*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *\n*                                                           *\n*    All FLDAREA field required for call have to be         *\n*    filled in:                                             *\n*                                                           *\n*    FLDSCARD - Initialized to OUTCARD at beg of program    *\n*    FLDECARD - Initialized to OUTCARD+80                   *\n*    FLDOFFST - Initialized to 0, updated by each call      *\n*    FLDBYTES - Set before each call                        *\n*    FLDBYTOT - Set before each call                        *\n*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *\n*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *\n*    FLDBSTRT - Start of input buffer                       *\n*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *\n*    FLDREADF - READFLAG, copied into FLDAREA control blk   *\n*                                                           *\n* --------------------------------------------------------- *\nFOLDBUFF DS    0H\n         ST    R9,SAVER9FB              Save BAL register\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call\n*        BAL   R9,FLDIMAGE\n         LA    R1,FLDAREA\n         L     R15,=V(FOLDEM)           Entry point of FOLDEM program\n         BALR  R14,R15                  Call it.\n*                                       Copy back FLDAREA from FOLDEM\n         ST    R1,NEWFLDA               Save new FLDAREA address\n         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call\n*        BAL   R9,FLDIMAGE\nFOLDBUFE DS    0H\n         L     R9,SAVER9FB              Restore BAL register\n         BR    R9                       Return to caller\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         ST    R9,SAVER9FI\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         L     R9,SAVER9FI\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE\n         ST    R9,SAVER9AD         Save BAL register\n         STM   R4,R5,SAVEADDC      Save work registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         LM    R4,R5,SAVEADDC      Restore work registers\nADDCOUNE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9AD         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LB          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   INAREA(3),=C'UHL'    This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRCV             NO. SKIP ROUTINE.\n         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRCV DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  YES. DON'T CHANGE.\n         LA    R1,INAREA                 Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\n         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.\n         TM    FLAGSYST,X'02'\n         BZ    NCHGMOVD\n         PUT   SYSMOVED,MESSAG13\nNCHGMOVD DS    0H\n         TM    FLAGSYST,X'04'            SYSFILES here?\n         BZ    NCHGFILE                  Nope. Skip a PUT to it.\n         PUT   SYSFILES,MESSAG13         VOLSER overridden message.\n         MVC   OUTLINE,OUTLINE-1         Blank line to separate\n         PUT   SYSFILES,OUTLINE             from the rest of output.\nNCHGFILE DS    0H\nNOCHGVOL DS    0H                        Kludge extra blank like\n         TM    FLAGSYST,X'04'            Is SYSFILES here?\n         BZ    KLUDGE01                  Nope. No PUTs to it.\n         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?\n         BNE   KLUDGE01                  Is overridden, no extra blank.\n         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank\n         PUT   SYSFILES,OUTLINE\nKLUDGE01 DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRH2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRH2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRH2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRF2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRF2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRF2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRv2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRV2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRV2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\nLABCHEND DS    0H                   Return to caller\n         L     R9,SAVER9LB          Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SR               Save BAL Register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n* >---->                                 Display tape total counts\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTMH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST\n         L     R4,DBOUTML                LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD               AND ADD IT IN\n         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06       Total bytes read for data\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\nNOSUMM05 DS    0H\n* >---->\nSUMMREND DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SR         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n*----------->>\n         ST    R9,SAVER9RF\n*--->                   Block counts first  -  below\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n* >---->\n*--->                   Block counts first  -  above\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG01\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFMH        Bytes folded counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n* >--->\n         TM    ISLBLFLG,X'01'\n         BO    DISLABLS\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Data bytes written cumulative to here\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),DATDISPL\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),LABDISPL\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFH         Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         CLC   DBOUTF(8),DBOUTFM\n         BE    RIGHTBYT\n         MVI   CNTLINE+72,C'*'\nRIGHTBYT DS    0H\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBOUTH          Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\n*----------->>\nREPTFEND DS    0H\n         L     R9,SAVER9RF\n         BR    R9\n         EJECT\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\n*              read,addr of data,flags,64K bytes\nRUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW\n         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW\nINCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW\nINECB    DC    F'0'\nINIOB    DC    X'02000000'\n         DC    A(INECB)\nINCSW    DC    2F'0'\nINCCWPT  DC    A(INCCW)\nINDCBPT  DC    A(TAPIN)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            Padding\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY FAKEOUT\nFAKEOUT  DCB   DDNAME=FAKEOUT,MACRF=PM,DSORG=PS,LRECL=80\nTAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X\n               EODAD=SYSINEND\n         DC    CL8' '\nFF       EQU   X'FF'\nBLNKHEDR DC    XL12'303030303030303030303030'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL12                    BLOCK HEADER\nHDRFKPRV DC    XL4'30303030'\nHDRFKNXT DC    XL4'30303030'\nHDRFKCHK DC    XL4'30303030'\n* --- >\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRCHKWK DC    XL2'0000'                XOR CHECK WORK AREA\n* --- >\n*\n         DC    XL80'00'                 PADDING\nHEADEREB DS    XL12\n* ----------------------------------------------------------------- *\n         DC    XL12'00'                 PADDING\nHALFZERO DC    XL2'00'\n         DC    XL12'00'                 PADDING\nHDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF\nHDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF\n         DC    XL12'00'                 PADDING\nBYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nCURRBFUL DS    0F\n         DC    H'0'\nCURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nLASTBFUL DS    0F\n         DC    H'0'\nLASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT\nPARTBFUL DS    0F\n         DC    H'0'\nPARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT\nZEROCARD DC    80X'30'\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nREADFLAG DC    X'00'         This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nNWBLKFLG DC    X'00'         We have just read a new block.\n*              X'01'         Turned off after first chunk write.\n* ---------- *\nIDRCFLAG DC    X'00'         This run is \"IDRC Fix\"  ?\n*              X'01'         Turn off IDRC indicator\n* ---------- *\nFLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED\n*              X'01'          CHUNK SIZE IS NOT BLANK\n* ---------- *\nFLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE\n*              X'01'          //SYSTRACE DD IS THERE\n*              X'02'          //SYSMOVED DD IS THERE\n*              X'04'          //SYSFILES DD IS THERE\n*              X'08'          //SYSIN    DD IS THERE\n* ---------- *\nCHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?\n*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE\n* ---------- *\nBUFINISH DC    X'00'          Have we finished folding entire buffer?\n*              X'01'          Yes. We are now finishing the buffer.\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL\n*              X'00'          DATA IS NOT A LABEL\n*              X'01'          DATA IS A LABEL\n* ---------- *\nTPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark\n*              X'01'          We just read a Tape Mark\n*              X'02'          We previously read a Tape Mark\n* ---------- *\nFLAGHDRL DC    X'00'          Header label flag - Last label was a hdr\n*              X'01'          EOT HEADER is following a HDR1 or HDR2\n* ---------- *\n* -------------------------------------------- *\nFULLWORK DS    0F\nFULLHIGH DC    H'0'\nHALFWORK DC    H'0'                HALFWORD WORK AREA\n         DC    2F'0'               Padding\nFOLDBREG DS    0F                  Fullword - no of bytes to fold\nFOLDHIGH DC    XL2'00'             High order - should be zeros\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHNKSIZE DC    F'65535'            Default is maximum halfword\nLASTLINE DS    0CL80\nLASTHX00 DC    80X'00'\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nDWORD    DC    D'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nOUTHDRS  DC    PL7'0'\nOUTTYPE1 DC    PL7'0'\nOUTTYPE2 DC    PL7'0'\nOUTTYPE3 DC    PL7'0'\nOUTTYPE4 DC    PL7'0'\nOUTTYPE5 DC    PL7'0'\nFILCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nTPMKCNT  DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL38\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Labels'\nDATDISPL DS    0CL38\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data  '\n*\nSVBEGCRD DS    F\nSVENDCRD DS    F\nSVBFAREA DS    F                Address of input buffer\n*\nSAVER2R  DS    F                Save work regs during tape read.\nSAVER3R  DS    F                Save work regs during tape read.\nSAVER4B  DS    F                Register Save for HEX routine\nSAVER4Q  DS    F                Register Save for byte count reperting\nSAVEFOLD DS    6F               Register Save for FOLDEM routine\nSAVEADDC DS    3F               Register Save for ADDCOUNT routine\nSAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE\nSAVER9AD DS    F                Register Save for ADDCOUNT routine\nSAVER9RB DS    F                Register Save for READBLOK routine\nSAVER9RF DS    F                Register Save for REPTFILE routine\nSAVER9LB DS    F                Register Save for LABELCHK routine\nSAVER9SR DS    F                Register Save for SUMMREPT routine\nSAVER9FB DS    F                Register Save for FOLDBUFF routine\nSAVER9FI DS    F                Register Save for FLDIMAGE routine\nSAVER9SC DS    F                Register Save for SCNSYSIN routine\nSAVER9MH DS    F                Register Save for MAKEHEDR routine\nSAVER9AC DS    F                Register Save for ASCCNVRT routine\nNEWFLDA  DS    F\nHDRSIZE  DC    F'12'            SIZE OF A HEADER\nSVBEGDAT DS    F\n*  -----------------\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*  -----------------     JFCB if we'll need RDJFCB later - not used now\nJFCB1    DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\n         DC    C' '\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '\nPRMSG03  DC    CL34'     TOTAL BLOCK HEADERS        : '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '\nCTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '\nCTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '\nCTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '\nCTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '\nCTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '\nCTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '\nCTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2T2FK - REAL TAPE TO FB-80 AWS CONVERSION PROG-\n               RAM  '\nMESSAGE2 DC    CL133'1VTT2T2FK  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE3 DC    CL133'1VTT2T2FK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-\n               R REPORT  '\nMESSAGE4 DC    CL133'1VTT2T2FK - TAPE TO AWS FILE REPORT - READ AND FOL-\n               D STATS  '\nMESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-\n               '\nMESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-\n               '\nMESSAGE7 DS    0CL133\n         DC    CL8'  hdr:  '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'FLDSCARD'\n         DC    CL10'FLDECARD'\n         DC    CL10'FLDOFFST'\n         DC    CL10'FLDBYTES'\n         DC    CL10'FLDBYTOT'\n         DC    CL10'FLDBYMVD'\n         DC    CL10'FLDBUFFR'\n         DC    CL10'FLDBSTRT'\n         DC    CL14'FLDINRCD'\n         DC    CL11' '\nMESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-\n                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-\n               DE. '\nMESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2T2FK, THE SYSMOV-\n               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-\n                 '\nMESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-\n               EPORT.  BOTH \"TAPE READ\" AND \"FOLD DATA\" ARE AVAILABLE T-\n               HERE.'\nMESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -\n               HAVE SOURCE CODE, THEN UNCOMMENT THE \"BEFCALL-\" AND \"AFT-\n               CALL-\" '\nMESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-\n               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -\n                    '\nMESSAG13 DC    CL133'    VOLSER Overridden to:    '\nMESSAG14 DC    CL133'    Chunk Size is set to:    '\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    OFFSET ERROR           '\nINEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '\n         DC    C'TERMINATED '\n         DC    76C'*'\nINDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '\n         DC    82C'*'\n*  -----------------            Trace Message Texts\nREADTRMS DC    CL16'READ TRACE:     '\nFOLDTRMS DC    CL16'FOLD TRACE:     '\nMHDRTRMS DC    CL16'MAKEHEDR TRACE: '\nOSETTRMS DC    CL16'OFFSET TRACE:   '\nBBLKTRMS DC    CL16'BLOCK TRACE:    '\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nLINE     DC    CL133' '           For error messages\n         DC    C' '\nPRTLINE  DC    CL133' '\n         DC    C' '\nMSGLINE1 DC    CL133' '           For READ only message\n         DC    C' '\nMSGLINE2 DC    CL133' '           For IDRC remove message\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\nSAVEHDR  DC    XL6'000000000000'\nEOTMARK  DC    XL12'303030303030303030303030'\n* - - - - >\n*\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\n* - - - - >\n*         Saved Copy of FLDAREA Control Block\n* - - - - >\n*\nSAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nSAVSCARD DC    F'0'         Start address of 80-byte card\nSAVECARD DC    F'0'         End address of 80-byte card\nSAVOFFST DC    F'0'         OFFSET of data in the card\nSAVBYTES DC    F'0'         Number of bytes to be folded now\nSAVBYTOT DC    F'0'         Batch total of bytes left to move\nSAVBYMVD DC    F'0'         Number of bytes folded now\nSAVBUFFR DC    F'0'         Current data start address\nSAVBSTRT DC    F'0'         Original start data address\nSAVOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nSAVREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nSAVLENTH EQU   *-SAVAREA\n*\n* - - - - >\n*    ------------------------ >   Byte Count Save Areas - below\n*\n*                          -- These are doubleword counters --\n*\nDBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ\nDBOUTFH  DC    F'0'\nDBOUTFL  DC    F'0'\nDBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED\nDBOUTFMH DC    F'0'\nDBOUTFML DC    F'0'\nDBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ\nDBOUTH   DC    F'0'\nDBOUTL   DC    F'0'\nDBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED\nDBOUTMH  DC    F'0'\nDBOUTML  DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\n         DC    CL8' '      Extra padding for safety\n*\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n         DC    F'0'               Align, just for the heck of it\nGETSYSIN DC    CL80' '\nOUTCARDP DC    XL80'00'           Previous card-image read\nOUTCARD  DC    XL80'00'           Current  card-image read\nOUTCAEND EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         END\n   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'\nFOLDEM   CSECT\n*  ---------------------------------------------------------------  *\n*\n*   AUTHOR:       Sam Golob\n*\n*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,\n*                 subject to express permissions from the author\n*                 to use this software.  This software is part\n*                 of VTTS (Virtual Tape Transportation System).\n*\n*                 Permission is granted by the author for all\n*                 parts of the VTTS package which are distributed\n*                 on the CBT Tape collection, to be used by\n*                 anyone for their own use, but not for resale\n*                 or for reincorporation within commercial code.\n*\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    FOLDEM                                            *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating an      *\n*      FAKETAPE disk file from a real tape file.    The disk        *\n*      file is data that has been folded over from a buffer,        *\n*      into an FB-80 dataset.                                       *\n*                                                                   *\n*      This program takes buffer data and folds it into FB-80       *\n*      data, starting from a given buffer address, for a given      *\n*      number of bytes.  The data is folded into an 80-byte         *\n*      workarea starting from a given OFFSET address (+0 to +79)    *\n*      into the workarea.  When the workarea has been completely    *\n*      filled and more data is to be written, a PUT is done to      *\n*      write out the data from the 80-byte workarea, and then       *\n*      the workarea is cleared with binary zeros before any         *\n*      additional data is written to it.  An incompletely filled    *\n*      workarea is not written out, and the same is true if the     *\n*      workarea is full but no more data is to be written out.      *\n*      So in that case, the location of the workarea is returned    *\n*      to the caller in field FLDSCARD, and it is the caller's      *\n*      responsibility to do the PUT for the last card.              *\n*                                                                   *\n*  INPUTS and OUTPUTS:                                              *\n*                                                                   *\n*      This program is driven by a control block called FLDAREA,    *\n*      which is updated by both this program and by the caller.     *\n*      See below for more details.                                  *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called FAKEOUT, which receives the output      *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do PUTs to FAKEOUT, and if necessary, it needs      *\n*      to write messages to SYSPRINT.  Therefore the caller has     *\n*      to provide ENTRY FAKEOUT and ENTRY SYSPRINT statements in    *\n*      front of its FAKEOUT and SYSPRINT DCBs, respectively.        *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      FLDAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      FLDAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the caller's copy of FLDAREA, and upon return,      *\n*      R1 is pointed to the updated copy of FLDAREA in this         *\n*      subroutine.  So the caller has to copy it back over its      *\n*      own instance of FLDAREA after the return.                    *\n*                                                                   *\n*      The caller does one tape read, or read of data into a        *\n*      buffer.  From the number of bytes read, the caller will      *\n*      construct a FAKETAPE header which will determine how many    *\n*      bytes should be folded into the FB-80 disk dataset.  This    *\n*      FAKETAPE header is also folded by a call to this program,    *\n*      and then the tape data is folded in afterward, for the       *\n*      number of bytes required by the block size.                  *\n*                                                                   *\n*      This program does one or more PUTs into the FB-80 file,      *\n*      until the request for the number of bytes to be folded,      *\n*      is satisfied.  A PUT is done whenever the FB-80 work area    *\n*      has been filled.  At the end of the fold operation, the new  *\n*      OFFSET into the FB-80 workarea (that has not yet been        *\n*      written out to disk), the number of bytes that have been     *\n*      folded, and the projected start of the next data to be       *\n*      folded, are returned in the fields of the FLDAREA control    *\n*      block.                                                       *\n*                                                                   *\n*      The following is the layout of the FLDAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *\n*      *                         ------ ---- ------- -----          *\n*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *\n*  --> FLDECARD DC    F'0'       End address of 80-byte card        *\n*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *\n*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *\n*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *\n*      FLDBYMVD DC    F'0'       Number of bytes folded now         *\n*  --> FLDBUFFR DC    F'0'       Current data start address         *\n*  --> FLDBSTRT DC    F'0'       Original start data address        *\n*      FLDOUTCT DC    PL7'0'     Number of PUTs for FAKEOUT records *\n*  --> FLDREADF DC    X'00'      This run is \"READ ONLY\"  ?         *\n*      *              X'01'      Yes, read only. (Copied from the   *\n*                                READFLAG byte in the caller.)      *\n*      FLDLENTH EQU   *-FLDAREA                                     *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      FLDBUFFR and FLDOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the input data      *\n*      and output data positions, respectively, that are just       *\n*      after the moved data, to anticipate the next call, so as     *\n*      to be able to move more data.  FLDBSTRT preserves the        *\n*      very beginning address of the input buffer, whereas          *\n*      FLDBUFFR is a place somewhere within the buffer, which       *\n*      is the start from where the new data is expected to be       *\n*      moved.                                                       *\n*                                                                   *\n*      A new field, FLDBYTOT, makes it possible to create           *\n*      chunked blocks, but with FAKETAPE, that doesn't happen,      *\n*      so we have set things up with chunksize always equal 65535   *\n*      so \"chunksize is always equal to blocksize\".  The FLDBYTOT   *\n*      field originally contains the number of bytes in an entire   *\n*      block, and after the entire block has been written, it       *\n*      should be decremented by the number of bytes written, and    *\n*      it would therefore be 0.                                     *\n*                                                                   *\n*      Since both the caller and this program do PUT operations     *\n*      to the output FB-80 file, the count of the number of PUTs    *\n*      done, FLDOUTCT, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nFOLDEM   AMODE 24\nFOLDEM   RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'FOLDEM'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING FOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,FAKEOUTV           FAKEOUT  DCB address in caller\n         ST    R0,FKOUTDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to fold buffer data into an FB-80 file, starting at     *\n*   a given location in the buffer, for a certain number of bytes,  *\n*   and starting at a given OFFSET in the 80-byte workarea to       *\n*   which the buffer data will be written.  When the 80-byte        *\n*   workarea is filled up, a PUT is done to FAKEOUT, and the        *\n*   workarea is cleared with binary zeros for more data to be       *\n*   written.                                                        *\n*                                                                   *\n*   Input:   FLDAREA fields are all supplied by the calling         *\n*            program, except for FLDBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            caller's copy of FLDAREA is pointed to by Register 1.  *\n*                                                                   *\n*            The buffer area containing the data to be folded       *\n*            is supplied by the calling program, as well as the     *\n*            number of bytes that is expected to be folded.         *\n*                                                                   *\n*   Output:  Data from the buffer will be moved into the 80-byte    *\n*            workarea until the workarea is filled.  When the       *\n*            workarea is filled, a PUT will be done to FAKEOUT,     *\n*            and the workarea is cleared to X'00's to make room     *\n*            for more data, when more data is to be written.        *\n*                                                                   *\n*            Ending OFFSET into the 80-byte workarea, pointing to   *\n*            just after the data which has been moved, is returned  *\n*            in the FLDOFFST field.  Upon return to the caller,     *\n*            the FLDBUFFR field is updated to point to the place    *\n*            in the buffer just after the data which has been       *\n*            moved.  The FLDBSTRT field always should point to the  *\n*            beginning of the data buffer, but this is at the       *\n*            discretion of the calling program.                     *\n*                                                                   *\n*            A count of bytes actually moved from the buffer to     *\n*            the 80-byte workarea (and written out by PUTs to the   *\n*            FAKEOUT DD name as is necessary) is calculated by this *\n*            program and returned in the FLDBYMVD field.  Upon      *\n*            return, the number in the FLDBYMVD field should match  *\n*            the number in the FLDBYTES field.                      *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nFOLDIT   DS    0H\n         L     R1,SAVEPARM          Load address of caller's FLDAREA\n         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA\n         USING FLDBLOCK,R2\n         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours\n* - - - - - - - - - -      Load the buffer quantities\n         L     R7,FLDBUFFR          Initialize start of buffer data\n         L     R8,FLDBYTES          Bytes to be moved\n         AR    R8,R7                Add in start buffer address\n         ST    R8,HYPOENDB          Hypothetical end-of-buffer address\n*                                   which is probably the real\n*                                   end-of-data to be moved.\n* - - - - - - - - - -      Load the card quantities\n         MVC   SAVEBEGC,FLDSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,FLDECARD    Save \"end of card\" address\n         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,FLDSCARD          Point to beginning of card\n         A     R7,FLDOFFST          Add OFFSET to start of output\n         ST    R7,SAVEBEGO          Save where output starts\n         L     R8,SAVEBEGO          Copy beg of output address\n         A     R8,FLDBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n         ST    R8,HYPOENDC          Store hypothetical card end address\n*                                   (This may be way past end of card.)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is to within the current card.        *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.  So we have to do     *\n*              iterations.                                        *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         L     R7,SAVEBEGO          Beginning of CARD data\n         L     R8,HYPOENDC          Hypothetical end of CARD data\n         L     R3,FLDBUFFR          Prime R3 with start of buffer data\n         C     R8,SAVEENDC          Is R8 past the end-of-card?\n         BH    LOOPMORE             Yes. Do multiple moves and PUTs.\nLOOPSHRT DS    0H                   No. Do the one move only.\n         LR    R6,R8                Get byte count to move NOW.\n         SR    R6,R7                Bytes to move from buffer to card\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data from buffer to card.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total bytes moved.\n         ST    R1,FLDBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,FLDBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET -\n         S     R6,FLDSCARD          Subtract beginning of card address\n         ST    R6,FLDOFFST          Store the result as new OFFSET\n* -- >\nLOOPTS50 DS    0H\n*                                   If OFFSET > X'4F', card is complete\n         C     R6,=F'80'            Is the new offset exactly X'50'?\n         BNE   LOOPNT50             No. Then current card not complete.\n*                                   Yes. Then PUT out card and init it.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT001             Yes. Can't PUT to FAKEOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT001 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n         XR    R6,R6                Clear R6\n         ST    R6,FLDOFFST          New offset is 0, not X'50'\nLOOPNT50 DS    0H\n* -- >\n         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT\n         S     R1,FLDBYMVD          And subtract bytes already moved\n         ST    R1,FLDBYTOT          To show new total buffer byte count\n*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,FLDBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Test if past end of buffer\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,FLDBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT002             Yes. Then don't produce FAKEOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT002 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE CALLER\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of FLDAREA in caller\n         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nFLDBLOCK CSECT\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\nFOLDEM   CSECT\nWORKAREA DS    CL80                 Card image work area\n         DC    CL4' '               Padding\n         DC    C' '\nLINE     DC    CL133' '             Output line\n         DC    C' '\nLINE2    DC    CL133' '             Second output line if needed\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'30'\nSAVEBEGO DC    F'0'                 Save beg address of card output\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address\nHYPOENDC DC    F'0'                 Hypothetical end address after card\nHYPOENDB DC    F'0'                 Calculated end of buffer address\nSYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB\nFAKEOUTV DC    V(FAKEOUT)           Address of FAKEOUT DCB\nSYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here\nFKOUTDCB DC    F'0'                 FAKEOUT DCB address stored here\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2T201": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00X\\x01\\x00%O\\x01\\x05\\x00/\"\\x06\\t\\x82\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2005-01-02T22:06:58", "lines": 2434, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2T2FK -- READ A REAL TAPE AND CREATE FAKETAPE FILE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE:  VTT2T2FK.   Written by Sam Golob               **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to read in a tape, and create an      **\n**            MVS disk file in \"folded FB-80 FAKETAPE       **\n**            format\".                                      **\n**                                                          **\n**     The output of this program is intended to be input   **\n**     for the VTT2FK2T program.  These two programs,       **\n**     VTT2T2FK and VTT2FK2T, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  OBSERVATION:  Although this program is purely an MVS    **\n**                program, the FAKETAPE output of this      **\n**     program can be downloaded to other systems where     **\n**     the file can actually be interpreted as an emulated  **\n**     tape.  This is one way of transferring tape data to  **\n**     other MVS systems that can read FAKETAPE tape        **\n**     files directly, as though they were tapes.           **\n**                                                          **\n**     For example, you can take mainframe-based tapes      **\n**     on real cartridges and create FAKETAPE-compatible    **\n**     files that can be read on a FLEX-ES system.          **\n**                                                          **\n**     FAKETAPE files do not currently support chunked      **\n**     blocks, but I have preserved the structure of the    **\n**     VTT2DISK program here, so that if chunked blocks     **\n**     will be supported later by FAKETAPE, then it will    **\n**     be relatively easy to put in support for them.  We   **\n**     pretend, in the logic of this program, that there    **\n**     is a maximum chunk size of 65535, so that all 64K    **\n**     blocks will come out with \"chunksize equals          **\n**     blocksize\" treatment.                                **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     Tape data is read into a data buffer in this         **\n**     program.  Each block is read in, and its size        **\n**     is determined.  This size is compared to the 65535   **\n**     byte chunk size, and a decision is made as to what   **\n**     to do.  A FAKETAPE header is made for each chunk.    **\n**     Each FAKETAPE header is folded into FB-80 output,    **\n**     and then the data is folded in afterward, until      **\n**     the block, and its associated FAKETAPE header, is    **\n**     folded in.  Then another tape block is read into     **\n**     the buffer, and the process repeats.                 **\n**                                                          **\n**     When the tape file ends, and a tape mark is read     **\n**     in, a FAKETAPE header with \"zero next bytes\" is      **\n**     constructed.  This indicates a tape mark written.    **\n**     That header is then folded into the FB-80 output     **\n**     dataset after the last data.  The first header for   **\n**     the next file, if any, immediately follows.          **\n**                                                          **\n**     At the end of the tape, an end-of-tape FAKETAPE      **\n**     header is appended to the end of the output          **\n**     file and folded in.  The last FB-80 record           **\n**     is completed with X'30's, if necessary.  This may,   **\n**     depending on how many of them there are, signify     **\n**     more tape marks at the end of the FAKETAPE file.     **\n**     Since the last 80-byte record has to be completed    **\n**     with some kind of data, it seemed that X'30's,       **\n**     which are what FLEX-ES itself produces at the end    **\n**     of FAKETAPE files, are the safest things to put      **\n**     there.                                               **\n**                                                          **\n**     This program was adapted from version 1.12 of the    **\n**     VTT2DISK program, which is part of the Virtual       **\n**     Tape Transportation System (VTTS), copyright (c)     **\n**     2001-2005 by Sam Golob.                              **\n**                                                          **\n**     All of the \"FB-80 folding\" work is now done by the   **\n**     sub-program called FOLDEM.  The FOLDEM program       **\n**     operation is completely controlled by a control      **\n**     block called the FLDAREA control block, which does   **\n**     all of the communication between the main program    **\n**     and the FOLDEM sub-program.  Therefore, monitoring   **\n**     of the folding process is now possible purely by     **\n**     displaying the current status of the FLDAREA         **\n**     fields.  A convenient routine for displaying the     **\n**     status of the FLDAREA fields is the FLDIMAGE         **\n**     routine in either program, which is invoked by:      **\n**                                                          **\n**     BAL   R9,FLDIMAGE                                    **\n**                                                          **\n**     Therefore the fold monitoring displays that used     **\n**     to be in the SYSMOVED DD name, are now obsolete.     **\n**                                                          **\n**     There are two more fields in the FLDAREA control     **\n**     block than in the UNFAREA control block of the       **\n**     UNFOLDEM sub-program that VTT2FK2T uses.  These      **\n**     are:                                                 **\n**                                                          **\n**           FLDBYTOT - bytes left in buffer after the      **\n**                      last chunk of data was folded       **\n**           FLDREADF - propagation of the \"read only\"      **\n**                      flag into the sub-program           **\n**                                                          **\n**     These extra fields are obviously not required by     **\n**     the unfolding process.  The first one is not         **\n**     required because you're doing \"unchunking\" instead   **\n**     of \"chunking\", and you read the existing chunks      **\n**     as they come in; you're not required to create       **\n**     them.  The second one is not required because the    **\n**     main program writes the output (a tape) instead of   **\n**     the sub-program writing the output (an FB-80 file).  **\n**     So in our case, in a READ only situation, the        **\n**     sub-program must know when to NOT produce FAKEOUT    **\n**     output.                                              **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**     In order to make sure that the VTT2T2FK program      **\n**     is doing its job properly, it produces a lot of      **\n**     trace data and status data, as it is creating        **\n**     the folded FB-80 FAKETAPE format tape.  In order     **\n**     not to clutter the summary report, most of this      **\n**     data is written to \"Optional DDNAMEs\".  Starting     **\n**     with version 1.12 of this program, most of the       **\n**     trace data now consists of the state of the FLDAREA  **\n**     control block fields at various stages of program    **\n**     execution.                                           **\n**                                                          **\n**     If you have access to the source code (you are       **\n**     reading it), you can introduce an instruction:       **\n**                                                          **\n**           BAL   R9,FLDIMAGE                              **\n**                                                          **\n**     at any point in the program, as long as SYSPRINT     **\n**     is open.  This should produce any diagnostics you    **\n**     may need, because all FLDAREA fields are displayed.  **\n**                                                          **\n**     Optional DDNAMEs don't have to be coded in the       **\n**     JCL.  But if they are coded, they will contain       **\n**     the extra trace data which VTT2T2FK produces,        **\n**     and the SYSFILES ddname will contain a detailed      **\n**     \"file by file\" report.                               **\n**                                                          **\n**     The SYSFILES report is very useful if you want       **\n**     to do a \"dry run\", with the READ parameter.  If      **\n**     you want to know the structure of a tape without     **\n**     creating the FB-80 output file, the SYSFILES         **\n**     report will tell you what files are on the tape.     **\n**     It will also give you an indication of how big an    **\n**     FB-80 output file you will need on an MVS disk,      **\n**     to contain all the tape data.  See below for         **\n**     details.                                             **\n**                                                          **\n**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **\n**     and SYSIN.  SYSMOVED is now obsolete, although       **\n**     it will produce a dummy report if it is present      **\n**     in the JCL.                                          **\n**                                                          **\n**     SYSIN data is necessary if optional parameters       **\n**     are to be entered, such as:                          **\n**                                                          **\n**     NEWVOL=volser                                        **\n**     READ                                                 **\n**     IDRCOFF                                              **\n**                                                          **\n**     SYSIN keywords have to start in column 1.            **\n**                                                          **\n**     Either READ or IDRCOFF can also be entered in the    **\n**     PARM field of the EXEC card in the JCL.              **\n**                                                          **\n**     Full JCL to run the VTT2T2FK program is as           **\n**     follows:                                             **\n**                                                          **\n**     //   jobcard                                         **\n**     //TAPEREAD EXEC PGM=VTT2T2FK                         **\n**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **\n**     //FAKEOUT   DD  DSN=fb80.folded.faketape,            **\n**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **\n**     //          VOL=SER=volxxx,                          **\n**     //          SPACE=(CYL,(mm,nn),RLSE)                 **\n**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **\n**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **\n**     //          LABEL=(1,BLP,EXPDT=98000)                **\n**     //SYSPRINT  DD  SYSOUT=*                             **\n**     //SYSFILES  DD  SYSOUT=*                             **\n**     //SYSTRACE  DD  SYSOUT=*                             **\n**     //SYSUDUMP  DD  SYSOUT=*                             **\n**     //SYSIN     DD  *                                    **\n**     keywords in column 1                                 **\n**     /*                                                   **\n**                                                          **\n**     where you can leave out SYSTRACE and SYSUDUMP        **\n**     if you want to.  I'd strongly suggest including      **\n**     (at least) SYSFILES, though.                         **\n**                                                          **\n**     SYSTRACE takes a picture of the tape buffer at       **\n**     READ time, and takes a picture of the AWS headers    **\n**     and the FLDAREA control block fields at the time     **\n**     the headers are made.  Since the folding is now      **\n**     done by the FOLDEM subprogram, SYSMOVED, which       **\n**     used to track the data folding process, is now       **\n**     not necessary.  Of course SYSUDUMP is there to       **\n**     contain the MVS-produced dump, upon any abnormal     **\n**     termination of the program.                          **\n**                                                          **\n**     SYSFILES gives you block counts and byte counts      **\n**     for all files read and written.                      **\n**                                                          **\n**     In the SYSPRINT report, there is a count of total    **\n**     number of 80-byte records which the program will     **\n**     (or has) put out.  If you are doing a READ only      **\n**     run, and want to allocate an output file which is    **\n**     the right size, you might use this number, together  **\n**     with the BLKnnnn command from File 296 of the CBT    **\n**     Tape, to produce the following result:               **\n**                                                          **\n**     Say, our program produces:                           **\n**                                                          **\n**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **\n**                                                          **\n**     And you want to allocate space on a 3390.  So you    **\n**     would say:                                           **\n**                                                          **\n**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **\n**                                                          **\n**     Which comes up with the result:                      **\n**                                                          **\n** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **\n**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.12 - Re-architected program to use FOLDEM   **\n**       sub-program for data moves.  The FOLDEM program    **\n**       is driven by the FLDAREA control block, so the     **\n**       trace data consists mostly of the state of the     **\n**       FLDAREA control block fields.  A routine called    **\n**       FLDIMAGE will print all the FLDAREA control block  **\n**       fields on a single SYSPRINT line.                  **\n**                                                          **\n**       Added the possibility of coding program options    **\n**       in the SYSIN DD, which is used if it is present    **\n**       in the JCL.  SYSIN keywords, which must be coded   **\n**       to start in column 1, are currently:               **\n**                                                          **\n**       NEWVOL=volser                                      **\n**       READ                                               **\n**       IDRCOFF                                            **\n**                                                          **\n**       This program was adapted from Version 1.12 of      **\n**       the VTT2DISK program, so its initial version       **\n**       is also called Version 1.12.                       **\n**                                                          **\n**       The NEWVOL=volser keyword in SYSIN, allows you     **\n**       to change the volser in the VOL1 label of the      **\n**       output FAKETAPE tape file.                         **\n**                                                          **\n**       Now, the READ and IDRCOFF keywords of the EXEC     **\n**       PARM field, can also be coded in SYSIN.  They      **\n**       must begin in column 1.  READ allows a dry run     **\n**       of the program which reads the input tape and      **\n**       reports statistics, but which does not produce     **\n**       an output FB-80 AWS file.                          **\n**                                                          **\n**       IDRCOFF looks in the tape standard labels, if      **\n**       there are any, and turns off any \"P\" indicators    **\n**       which tell MVS that this tape was produced on      **\n**       an IDRC-enabled tape drive.  Since the output      **\n**       FB-80 file is not compressed anyway, one wants     **\n**       the power to read the FAKETAPE tape file on a      **\n**       logical 3420 or 3480 tape drive, without MVS       **\n**       telling you that \"the tape has compressed files    **\n**       and I can't read it\" on this particular drive.     **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.  *\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n         GBLC  &DEFCHKC\n         GBLA  &DEFCHNK\n&LLEV    SETC  '1.12'\n* ------------------------------------------------------------------ *\n*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *\n*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *\n* ------------------------------------------------------------------ *\n*   FAKETAPE does not support chunking of blocks, but if the         *\n*   chunk size is set to the largest possible value for a 64K        *\n*   block size limit, all chunksizes will equal the block sizes.     *\n* ------------------------------------------------------------------ *\n&DEFCHNK SETA  65535\n&DEFCHKC SETC  '&DEFCHNK'\n         YREGS\n         EJECT\n** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **\nVTT2T2FK CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2T2FK AMODE 24\nVTT2T2FK RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2T2FK - REAL TAPE TO FOLDED FAKETAPE DISK FILE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001-2005 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2T2FK,R12,R11,R10,R8,R7\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LA    R7,4095(,R8)\n         LA    R7,1(,R7)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n* ----- >                            Parms          <--- below\n         L     R1,0(R1)              Get PARM field\n         CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BE    COPYREAD              Yes. Turn on indicator.\n         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?\n         BE    COPYIDRF              Yes. Say that.\n         B     COPYTAPE              No. Just go on with processing.\nCOPYREAD DS    0H                    READ only?\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     COPYTAPE\nCOPYIDRF DS    0H                    IDRC indicators off?\n         OI    IDRCFLAG,X'01'        Yes. Turn on flag.\n         B     COPYTAPE\n*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.\nCOPYTAPE DS    0H\n* ----- >                            Parms          <--- above\n*\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE3+88(31),HEADDLIT\n         MVC   MESSAGE4+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE2+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE3+61(21),LEVELLIT\n         MVC   MESSAGE4+61(21),LEVELLIT\n***********************************************************************\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants\n         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.\n         MVC   FULLHIGH(2),=X'0000'\n         MVC   CURRBYTE(2),=X'0000'\n         MVC   LASTBYTE(2),=X'0000'\n         MVC   HDRSIZE(4),=F'12'     Set size of header globally.\n         MVC   FLDOFFST(4),=F'0'     Offset is initially zero\n         LA    R1,OUTCARD            Let FOLDEM know about FAKEOUT area\n         ST    R1,FLDSCARD           Beginning of card image output\n         ST    R1,SVBEGCRD\n         LA    R1,80(,R1)            Find end of card\n         ST    R1,FLDECARD           And store it away for the duration\n         ST    R1,SVENDCRD\n         L     R1,=A(INAREA)         Get address of input buffer\n         ST    R1,SVBFAREA           And save it away.\n         ST    R1,FLDBUFFR           Prime these fields\n         ST    R1,FLDBSTRT\n         L     R0,=F'&DEFCHNK'       Set default chunk size.\n         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.\n         ZAP   FLDOUTCT,=P'0'        Zero count of FAKEOUT records.\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n* ----------------------------------------------------------------- *\n* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *\n* ----------------------------------------------------------------- *\n*\n         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.\n*\n* ----------------------------------------------------------------- *\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n* - - - ->  Chunk Size Message - - - ->   below\n*    The purpose of this code is to fill MESSAG14 with information.\n         L     R1,CHNKSIZE                  Load binary Chunk Size\n         XC    DWORD,DWORD                  Clear DWORD to zeros.\n         CVD   R1,DWORD                     Convert to decimal.\n         OI    DWORD+7,X'0F'                Make sign readable.\n         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message\n         ED    MESSAG14+28(8),DWORD+4       Edit the number\n         B     AFCHKDSP                     Branch past constant\nCHPATTRN DC    X'4020202020202120'          8 bytes of pattern\nAFCHKDSP DS    0H\n* - - - ->  Chunk Size Message - - - ->   above\n         TM    READFLAG,X'01'        Read Only run?\n         BO    NOFAKOUT              Yes. Don't OPEN FAKEOUT.\n         OPEN  (FAKEOUT,(OUTPUT))\nNOFAKOUT DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (TAPIN,(INPUT))\n*--->>\n         MVC   MSGLINE1,MSGLINE1-1   Clear optional\n         MVC   MSGLINE2,MSGLINE2-1      message lines\nREADIDRC DS    0H\n         TM    READFLAG,X'01'        READ only run?\n         BZ    IDRCMSG\nREADMSG  DS    0H\n         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'\nIDRCMSG  DS    0H\n         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?\n         BZ    ENDEXMSG\n         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'\nENDEXMSG DS    0H\n*--->>\nTRACERPT DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE      Blank Line\n         PUT   SYSTRACE,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    TRACENOI\n         PUT   SYSTRACE,MSGLINE2     IDRC remove message\nTRACENOI DS    0H\n*        PUT   SYSTRACE,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\nTRACDESC DS    0H\n         PUT   SYSTRACE,MESSAGE8\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE5\n         PUT   SYSTRACE,MESSAGE6\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAG11\n         PUT   SYSTRACE,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE7\n*--->>\nMOVEDRPT DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE      Blank Line\n         PUT   SYSMOVED,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    MOVEDNOI\n         PUT   SYSMOVED,MSGLINE2     IDRC remove message\nMOVEDNOI DS    0H\n*        PUT   SYSMOVED,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAGE9\n         PUT   SYSMOVED,MESSAG10\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAG11\n         PUT   SYSMOVED,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n*--->>\nFILESRPT DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE      Blank Line\n         PUT   SYSFILES,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    FILESNOI\n         PUT   SYSFILES,MSGLINE2     IDRC remove message\nFILESNOI DS    0H\n*        PUT   SYSFILES,MESSAG14\n*--->>\nNOSYSFIL DS    0H\n* ----------------------------------------------------------------- *\n*   Now do the same for SYSPRINT report, which is always there.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         PUT   SYSPRINT,OUTLINE      Blank Line\n         PUT   SYSPRINT,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    PRINTNOI\n         PUT   SYSPRINT,MSGLINE2     IDRC remove message\nPRINTNOI DS    0H\n*        PUT   SYSPRINT,MESSAG14\n*--->>\n*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.\n*        BAL   R9,FLDIMAGE\n*--->>\n* ----------------------------------------------------------------- *\nTAPEREAD DS    0H                      READ a new tape block.\n* ----------------------------------------------------------------- *\n*   You come here every time you do a tape READ.\n* ----------------------------------------------------------------- *\n         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks\n         BAL   R9,READBLOK             Read a block of data\n         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?\n         BO    MAINTPMK                Yes. Take appropriate action.\n* --- >\n         L     R1,CURRBFUL             Fullword number of bytes read\n         C     R1,CHNKSIZE             Bigger than chunk size?\n         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.\n         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.\n         NI    BUFINISH,FF-X'01'       Turn \"buffer finished\" flag off\n         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer\n         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved\n         B     AFTRCHNK                Jump over other alternative\nNOCHUNKS DS    0H\n         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.\n         OI    BUFINISH,X'01'          Buffer is finished in one shot.\n         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total\n         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total\n* --- >                                Label check if HDR - below\nAFTRCHNK DS    0H\n         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?\n         BNE   MAINNOTL                No. Can't be a label.\n         BAL   R9,LABELCHK             Check for labels and their kind.\n         TM    ISLBLFLG,X'01'          Is this record a label?\n         BZ    MAINNOTL                No. Bypass flag setting.\n         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?\n         BZ    MAINNOTH                Neither. Check if EOF or EOV.\n         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.\nMAINNOTH DS    0H\n         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?\n         BZ    MAINNOTL                No. Don't turn off flag.\n         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.\nMAINNOTL DS    0H\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW\n** -->              stuff below is only done per READ.\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,CURRBFUL          Load Current READ Byte Count\n         LA    R3,DBOUTF            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUT             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n** -->              stuff above is only done per READ.\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE\n* --- >                                Label check if HDR - above\n**-------------------------------------------------------------------**\nFOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL\n*                                   THE BUFFER IS EXHAUSTED.\n         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields\n         MVC   FLDECARD,SVENDCRD\n         L     R3,=A(INAREA)           Point to the data buffer\n         ST    R3,FLDBUFFR             Initialize\n         ST    R3,FLDBSTRT                 FLDAREA fields\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n*                                      because we'll have to fold the\n*                                      newly manufactured header.\n**-------------------------------------------------------------------**\nFOLDLOOP DS    0H\n         L     R1,FLDBYTOT          Compare bytes remaining to fold\n         C     R1,CHNKSIZE          To the chunk size.\n         BH    FOLDNCHK             If now less than or equal\n         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off\n         OI    BUFINISH,X'01'       And turn \"buffer finished\" flag on\n         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.\nFOLDNCHK DS    0H\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n         BAL   R9,MAKEHEDR             Create a header with READ info\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER               Point to address of this header\n         ST    R3,FLDBUFFR             Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF             And fold it into FB-80.\n         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA\n         MVC   FLDBYMVD,=F'0'          Initialize bytes folded\n         BAL   R9,FOLDBUFF             And fold it into the output.\n         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block\n** ---------- >>    Record the number of bytes folded - below\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,FLDBYMVD          Load Current folded Byte Count\n         LA    R3,DBOUTFM           Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUTM            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOFLDCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2\n** ---------- >>    Record the number of bytes folded - above\n         TM    CHNKFLAG,X'01'          Are we doing chunks?\n         BZ    TAPEREAD                No. Do another tape read.\n         TM    BUFINISH,X'01'          Have we finished this block?\n         BO    TAPEREAD                Yes. Read another block.\n         B     FOLDLOOP                No. Fold more chunks.\n*\nMAINTPMK DS    0H                   Last read was a T.M.\n         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         BAL   R9,MAKEHEDR          Make a header to show EOF.\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header\n         BAL   R9,REPTFILE          Report Block and Byte Counts\n*--->>\n         MVC   DBOUTF(8),=D'0'      Zero File Byte Count\n         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count\n         ZAP   BLOCKCNT,=P'0'       Zero File Block Count\n*--->>\n         B     TAPEREAD             Read in another tape block.\n*\n* ---------------------------------------------------------------- *\n*          END OF INPUT TAPE DATA                                  *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         OI    TPMKFLAG,X'01'       Force Tape Mark indication.\n         BAL   R9,MAKEHEDR          Make EOT header\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\nBREAKLUP DS    0H\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk\n         TM    READFLAG,X'01'       READ only?\n         BO    NOPUT01              Yes. No output to FAKEOUT.\n         PUT   FAKEOUT,OUTCARD      And write out the last buffer.\nNOPUT01  DS    0H\n         AP    FLDOUTCT,=P'1'       Count the record PUT out.\nWRITSUMM DS    0H\n         BAL   R9,SUMMREPT          Print the summary report.\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\nCLOSEMAL DS    0H                   Close em all.....\n         CLOSE TAPIN\n         TM    READFLAG,X'01'       Is this a READ only run?\n         BO    NOFKOCLS             Can't CLOSE what ain't OPEN.\n         CLOSE FAKEOUT\nNOFKOCLS DS    0H\n         CLOSE SYSPRINT\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n*\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*   Input :  R1 points to 2-byte binary number.  LA    R1,BINNUM\n*   Output:  ASCWORK contains the 4-byte ASCII equivalent.\nASCCNVRT DS    0H\n         ST    R9,SAVER9AC\n         HEX   ASCWORK,2,0(R1)\n         TR    ASCWORK(4),TRASCNUM\nASCCNVRE DS    0H\n         L     R9,SAVER9AC\n         BR    R9\n         DS    CL2\nASCWORK  DS    XL4\n         DS    CL2\nTRASCNUM DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30414243444546303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30313233343536373839303030303030'\nTRTA2E   DS    0D                                                        05559\n         DC    XL16'000102030405060708090A0B0C0D0E0F'                    05560\n         DC    XL16'101112131415161718191A1B1C1D1E1F'                    05561\n         DC    XL16'405A7F7B5B6C507D4D5D5C4E6B604B61'                    05562\n         DC    XL16'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'                    05563\n         DC    XL16'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'                    05564\n         DC    XL16'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'                    05565\n         DC    XL16'79818283848586878889919293949596'                    05566\n         DC    XL16'979899A2A3A4A5A6A7A8A9C04FD0A17F'                    05567\n         DC    XL16'808182838485868788898A8B8C8D8E8F'                    05568\n         DC    XL16'909192939495969798999A9B9C9D9E9F'                    05569\n         DC    XL16'A0A14AB19FB26AB5BBB4AAABB0ADAFBC'                    05570\n         DC    XL16'B08FB2B3BEA0B6B39DB99BB8B7B8B9AB'                    05571\n         DC    XL16'C0C1C2C3C4C59EC7C8C9CACBCCCDCECF'                    05572\n         DC    XL16'ACD1D2D3D4D5D6BFD8D9DADBDCDDAEDF'                    05573\n         DC    XL16'E0E1E2E3E4E59CE7E8E9EAEBECEDEEEF'                    05574\n         DC    XL16'8CF1F2F3F4F5F6E1F8F9FAFBFC8D8EFF'                    05575\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nSCNSYSIN DS    0H                 Routine to extract info from SYSIN.\n         ST    R9,SAVER9SC\n* -------------- >>>>>>   Look for SYSIN cards            - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    SCNSYSIE             No. Then can't open it. So get out.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BE    SYSNWVOL              Yes. Go process the new volume.\n         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?\n         BE    SYSCHUNK                    Looks that way.....\n         CLC   =C'READ ',GETSYSIN\n         BE    SYSREAD\n         CLC   =C'IDRCOFF ',GETSYSIN\n         BE    SYSIDRCO\n         B     SYSINLUP              Look for another card.\nSYSNWVOL DS    0H\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         B     SYSINLUP\nSYSCHUNK DS    0H\n         CLI   GETSYSIN+10,C' '  Is the first number value blank?\n         BE    SYSINLUP          Yes. Ignore entire card.\n         CLI   GETSYSIN+10,X'F0' Smaller than zero?\n         BL    SYSINLUP          Yes. Get another card.\n         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?\n         BH    SYSINLUP          Yes. Get another card.\n         OI    FLAGCHNK,X'01'    Show chunk size default was changed.\n         LA    R15,GETSYSIN+10   Now get the number that was coded.\n         LR    R1,R15            Load R1 with beginning of the number.\nSYSCHNUM DS    0H\n         LA    R15,1(,R15)       Bump to next character.\n         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?\n         BH    SYSCHGNM          Yes. Go get the number.\n         CLI   0(R15),C' '       Not end of card. But is it a blank?\n         BE    SYSCHGNM          Yes. Then get the number.\n         B     SYSCHNUM          Not a blank yet. Step up one place.\nSYSCHGNM DS    0H\n         SR    R15,R1            How many digits is the number?\n         BCTR  R15,0             Lower it by one for EXECUTE.\n         EX    R15,PACK          Copy the number to work area.\n         CVB   R0,WORKA          Convert it to a binary number.\n         ST    R0,CHNKSIZE       And store the value for later use.\n         L     R0,=F'&DEFCHNK'   >>> Force 65535 chunk size.\n         ST    R0,CHNKSIZE       >>> X'FFFF' is the only possibility.\nSYSCHCLG DS    0H\n         B     SYSINLUP          Go look for another card.\nSYSREAD  DS    0H\n         OI    READFLAG,X'01'\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     SYSINLUP\nSYSIDRCO DS    0H\n         OI    IDRCFLAG,X'01'\n         B     SYSINLUP\nSYSINEND DS    0H                No more cards. Close SYSIN DCB.\n         CLOSE SYSIN\n* -------------- >>>>>>   Look for SYSIN cards            - ABOVE\nSCNSYSIE DS    0H\n         L     R9,SAVER9SC\n         BR    R9\n* - - >\nPACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>\nWORKA    DC    D'0'\n* - - >\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*     Routine to read a block of data from the input tape and\n*     save byte counts from it, to make the FAKETAPE headers.\n* ----------------------------------------------------------------- *\nREADBLOK DS    0H\n         ST    R9,SAVER9RB        Save BAL register\n         ST    R2,SAVER2R         Store work registers\n         ST    R3,SAVER3R\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Read\n         WAIT  ECB=INECB          Wait for Read\n         TM    INCSW+4,X'01'      Was TM Read?\n         BO    READTPMK           Yes\n         CLI   INECB,X'7F'        Did Read complete normally?\n         BNE   INERR              No -- error\n         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.\n         AP    BLOCKCNT,=P'1'\n         AP    BLOCKTOT,=P'1'\n         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read\n         XC    FULLWORK,FULLWORK   Clear area completely\n         MVC   HALFWORK(2),INCCW+6   Read length\n         L     R2,FULLWORK           Load R2 with full low order\n         MVC   HALFWORK(2),INCSW+6   Residual byte count\n         L     R3,FULLWORK           Load R3 with full low order\n         SR    R2,R3              R2=Actual length read\n         STH   R2,BYTESCOP        Save quantity of bytes copied\n         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block\n         NI    ISLBLFLG,X'FF'-X'01'  Turn off \"IS LABEL\" flag\n         OI    NWBLKFLG,X'01'        Turn on \"new block\" flag\n         B     READNOTM           This READ was not a Tape Mark\n*\nREADTPMK DS    0H                 This READ was a Tape Mark\n         TM    TPMKFLAG,X'01'     Check if there was another TM before\n         BZ    READTFST           No. First one.\n         OI    TPMKFLAG,X'02'     If two in a row, flag that situation\nREADTFST DS    0H\n         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?\n*\n* --- >                           Null SL file is not EOT - below\n         BNO   NOFIN1               Not 2 T.M. in a row. Go on.\n         TM    FLAGHDRL,X'01'       Test if HDR label was last seen\n         BO    NOFIN0               Yes. Must be null SL file.\n         B     FIN                  Otherwise, valid 2 TMs and EOT.\nNOFIN0   DS    0H\n         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.\nNOFIN1   DS    0H\n* --- >                           Null SL file is not EOT - above\n*\n         AP    FILCOUNT,=P'1'     Add 1 to File Count.\n         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.\n         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.\nREADNOTM DS    0H\n* ---->     for the trace            All READ results should come here\n         MVC   LINE,LINE-1           Clear output line\n         MVC   LINE+1(16),READTRMS   Put in Read Trace message\n         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?\n         BZ    ITSABLOC              No. Mark trace as for a block.\n         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.\n         B     ITSATPMK              And go farther.\nITSABLOC DS    0H\n         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block\nITSATPMK DS    0H\n         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ\n         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header\n         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header\n         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag\n         HEX   LINE+40,12,HEADER     Show the Header last constructed\n         HEX   LINE+68,30,INAREA     Show first 20 bytes of Input Area\n         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?\n         BNO   NOREADT1              No. Can't print trace line.\n         PUT   SYSTRACE,LINE\nNOREADT1 DS    0H                    Trace is finished.\n* ---->     for the trace\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R\n         B     READBEND           and exit normally.\n* -----\nINERR    DS    0H                 READ error on input tape\n         MVC   LINE,LINE-1        Clear print line\n         TM    INCSW+4,X'02'      Unit Check?\n         BZ    INERR1             No - Assume Data Check\n         MVC   LINE(133),INEQC    Set Error Message\n         B     INERR2             Continue\nINERR1   MVC   LINE(133),INDCK    Set Error Message\nINERR2   PUT   SYSPRINT,LINE      Write Error Message\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R         Rewind the tape, and exit.\n         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Rewind and Unload\n         WAIT  ECB=INECB          Wait for Rewind and Unload\n         B     WRITSUMM           Write summary of what was done,\n*                                  and get out of the program.\nREADBEND DS    0H\n         L     R9,SAVER9RB        Restore BAL register\n         BR    R9\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nMAKEHEDR DS    0H\n         ST    R9,SAVER9MH\n* ----------------------------------------------------------------- *\n*     We are forming the new header in the field HEADER.\n*     We assume that the TAPEREAD subroutine was executed first.\n*     We assume that the FLDAREA was previously saved to SAVAREA.\n* ----------------------------------------------------------------- *\n         MVC   HEADER(12),BLNKHEDR     Start fresh.\n         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header\n         MVC   HDRNSTOR(2),CURRBYTE\n         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot\nMAKEWHAT DS    0H                      Manufacture the proper hdr flags\n         TM    TPMKFLAG,X'01'          Has a tape mark been read?\n         BO    MAKETPMH                First test. Make a X'40' header\n         B     MAKEFAKE\nMAKETPMH DS    0H                      Tape mark has been read.\n         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.\nMAKEFAKE DS    0H\n         MVC   HDRCHKWK(2),HDRPRVLN    Create header check field\n         XC    HDRCHKWK(2),HDRCURLN    XOR prev with curr\n* --                                   Convert quantities to ASCII\n         LA    R1,HDRPRVLN             Previous bytes in binary\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKPRV(4),ASCWORK     Stuff into header field\n         LA    R1,HDRCURLN             Current bytes in binary\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKNXT(4),ASCWORK     Stuff into header field\n         LA    R1,HDRCHKWK             XOR of both of them\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKCHK(4),ASCWORK     Stuff into header field\n* --                                   The header is now created\n         MVC   HEADEREB(12),HEADER     Move copy of header to wkarea\n         TR    HEADEREB(12),TRTA2E     Translate into EBCDIC for print\nMAKEHDEN DS    0H\n         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN\n         AP    OUTHDRS,=P'1'           Count this header we've made.\n*----------------------------------------------------------------- *\n*   Now that we've made a header, we do a display.\n*----------------------------------------------------------------- *\n*\nKINDAHEN DS    0H\n         CLC   HDRFKNXT,=X'30303030'\n         BNE   BLOKHEDR\n         AP    OUTTYPE2,=P'1'\n         B     NOTBLOKH\nBLOKHEDR DS    0H\n         AP    OUTTYPE1,=P'1'\nNOTBLOKH DS    0H\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE\n         MVC   OUTLINE+2(4),=C'hdr:'\n         MVC   OUTLINE+8(12),HEADEREB   EBCDIC REPRESENTATION OF HEADER\n         HEX   OUTLINE+28,4,FLDSCARD                            .\n         HEX   OUTLINE+38,4,FLDECARD                            .\n         HEX   OUTLINE+48,4,FLDOFFST                            .\n         HEX   OUTLINE+58,4,FLDBYTES                            .\n         HEX   OUTLINE+68,4,FLDBYTOT                            .\n         HEX   OUTLINE+78,4,FLDBYMVD                            .\n         HEX   OUTLINE+88,4,FLDBUFFR                            .\n         HEX   OUTLINE+98,4,FLDBSTRT                            .\n         HEX   OUTLINE+108,7,FLDOUTCT                           .\n         HEX   OUTLINE+124,1,FLDREADF\n         PUT   SYSTRACE,OUTLINE\nNOSYSTR1 DS    0H\nMAKEHEND DS    0H\n         L     R9,SAVER9MH\n         BR    R9\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*                                                           *\n*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *\n*                                                           *\n*    All FLDAREA field required for call have to be         *\n*    filled in:                                             *\n*                                                           *\n*    FLDSCARD - Initialized to OUTCARD at beg of program    *\n*    FLDECARD - Initialized to OUTCARD+80                   *\n*    FLDOFFST - Initialized to 0, updated by each call      *\n*    FLDBYTES - Set before each call                        *\n*    FLDBYTOT - Set before each call                        *\n*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *\n*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *\n*    FLDBSTRT - Start of input buffer                       *\n*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *\n*    FLDREADF - READFLAG, copied into FLDAREA control blk   *\n*                                                           *\n* --------------------------------------------------------- *\nFOLDBUFF DS    0H\n         ST    R9,SAVER9FB              Save BAL register\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call\n*        BAL   R9,FLDIMAGE\n         LA    R1,FLDAREA\n         L     R15,=V(FOLDEM)           Entry point of FOLDEM program\n         BALR  R14,R15                  Call it.\n*                                       Copy back FLDAREA from FOLDEM\n         ST    R1,NEWFLDA               Save new FLDAREA address\n         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call\n*        BAL   R9,FLDIMAGE\nFOLDBUFE DS    0H\n         L     R9,SAVER9FB              Restore BAL register\n         BR    R9                       Return to caller\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         ST    R9,SAVER9FI\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         L     R9,SAVER9FI\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE\n         ST    R9,SAVER9AD         Save BAL register\n         STM   R4,R5,SAVEADDC      Save work registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         LM    R4,R5,SAVEADDC      Restore work registers\nADDCOUNE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9AD         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LB          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   INAREA(3),=C'UHL'    This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRCV             NO. SKIP ROUTINE.\n         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRCV DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  YES. DON'T CHANGE.\n         LA    R1,INAREA                 Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\n         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.\n         TM    FLAGSYST,X'02'\n         BZ    NCHGMOVD\n         PUT   SYSMOVED,MESSAG13\nNCHGMOVD DS    0H\n         TM    FLAGSYST,X'04'            SYSFILES here?\n         BZ    NCHGFILE                  Nope. Skip a PUT to it.\n         PUT   SYSFILES,MESSAG13         VOLSER overridden message.\n         MVC   OUTLINE,OUTLINE-1         Blank line to separate\n         PUT   SYSFILES,OUTLINE             from the rest of output.\nNCHGFILE DS    0H\nNOCHGVOL DS    0H                        Kludge extra blank like\n         TM    FLAGSYST,X'04'            Is SYSFILES here?\n         BZ    KLUDGE01                  Nope. No PUTs to it.\n         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?\n         BNE   KLUDGE01                  Is overridden, no extra blank.\n         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank\n         PUT   SYSFILES,OUTLINE\nKLUDGE01 DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRH2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRH2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRH2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRF2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRF2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRF2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRv2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRV2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRV2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\nLABCHEND DS    0H                   Return to caller\n         L     R9,SAVER9LB          Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SR               Save BAL Register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n* >---->                                 Display tape total counts\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTMH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST\n         L     R4,DBOUTML                LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD               AND ADD IT IN\n         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06       Total bytes read for data\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\nNOSUMM05 DS    0H\n* >---->\nSUMMREND DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SR         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n*----------->>\n         ST    R9,SAVER9RF\n*--->                   Block counts first  -  below\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n* >---->\n*--->                   Block counts first  -  above\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG01\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFMH        Bytes folded counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n* >--->\n         TM    ISLBLFLG,X'01'\n         BO    DISLABLS\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Data bytes written cumulative to here\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),DATDISPL\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),LABDISPL\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFH         Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         CLC   DBOUTF(8),DBOUTFM\n         BE    RIGHTBYT\n         MVI   CNTLINE+72,C'*'\nRIGHTBYT DS    0H\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBOUTH          Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\n*----------->>\nREPTFEND DS    0H\n         L     R9,SAVER9RF\n         BR    R9\n         EJECT\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\n*              read,addr of data,flags,64K bytes\nRUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW\n         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW\nINCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW\nINECB    DC    F'0'\nINIOB    DC    X'02000000'\n         DC    A(INECB)\nINCSW    DC    2F'0'\nINCCWPT  DC    A(INCCW)\nINDCBPT  DC    A(TAPIN)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            Padding\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY FAKEOUT\nFAKEOUT  DCB   DDNAME=FAKEOUT,MACRF=PM,DSORG=PS,LRECL=80\nTAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X\n               EODAD=SYSINEND\n         DC    CL8' '\nFF       EQU   X'FF'\nBLNKHEDR DC    XL12'303030303030303030303030'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL12                    BLOCK HEADER\nHDRFKPRV DC    XL4'30303030'\nHDRFKNXT DC    XL4'30303030'\nHDRFKCHK DC    XL4'30303030'\n* --- >\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRCHKWK DC    XL2'0000'                XOR CHECK WORK AREA\n* --- >\n*\n         DC    XL80'00'                 PADDING\nHEADEREB DS    XL12\n* ----------------------------------------------------------------- *\n         DC    XL12'00'                 PADDING\nHALFZERO DC    XL2'00'\n         DC    XL12'00'                 PADDING\nHDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF\nHDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF\n         DC    XL12'00'                 PADDING\nBYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nCURRBFUL DS    0F\n         DC    H'0'\nCURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nLASTBFUL DS    0F\n         DC    H'0'\nLASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT\nPARTBFUL DS    0F\n         DC    H'0'\nPARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT\nZEROCARD DC    80X'30'\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nREADFLAG DC    X'00'         This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nNWBLKFLG DC    X'00'         We have just read a new block.\n*              X'01'         Turned off after first chunk write.\n* ---------- *\nIDRCFLAG DC    X'00'         This run is \"IDRC Fix\"  ?\n*              X'01'         Turn off IDRC indicator\n* ---------- *\nFLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED\n*              X'01'          CHUNK SIZE IS NOT BLANK\n* ---------- *\nFLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE\n*              X'01'          //SYSTRACE DD IS THERE\n*              X'02'          //SYSMOVED DD IS THERE\n*              X'04'          //SYSFILES DD IS THERE\n*              X'08'          //SYSIN    DD IS THERE\n* ---------- *\nCHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?\n*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE\n* ---------- *\nBUFINISH DC    X'00'          Have we finished folding entire buffer?\n*              X'01'          Yes. We are now finishing the buffer.\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL\n*              X'00'          DATA IS NOT A LABEL\n*              X'01'          DATA IS A LABEL\n* ---------- *\nTPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark\n*              X'01'          We just read a Tape Mark\n*              X'02'          We previously read a Tape Mark\n* ---------- *\nFLAGHDRL DC    X'00'          Header label flag - Last label was a hdr\n*              X'01'          EOT HEADER is following a HDR1 or HDR2\n* ---------- *\n* -------------------------------------------- *\nFULLWORK DS    0F\nFULLHIGH DC    H'0'\nHALFWORK DC    H'0'                HALFWORD WORK AREA\n         DC    2F'0'               Padding\nFOLDBREG DS    0F                  Fullword - no of bytes to fold\nFOLDHIGH DC    XL2'00'             High order - should be zeros\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHNKSIZE DC    F'65535'            Default is maximum halfword\nLASTLINE DS    0CL80\nLASTHX00 DC    80X'00'\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nDWORD    DC    D'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nOUTHDRS  DC    PL7'0'\nOUTTYPE1 DC    PL7'0'\nOUTTYPE2 DC    PL7'0'\nOUTTYPE3 DC    PL7'0'\nOUTTYPE4 DC    PL7'0'\nOUTTYPE5 DC    PL7'0'\nFILCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nTPMKCNT  DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL38\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Labels'\nDATDISPL DS    0CL38\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data  '\n*\nSVBEGCRD DS    F\nSVENDCRD DS    F\nSVBFAREA DS    F                Address of input buffer\n*\nSAVER2R  DS    F                Save work regs during tape read.\nSAVER3R  DS    F                Save work regs during tape read.\nSAVER4B  DS    F                Register Save for HEX routine\nSAVER4Q  DS    F                Register Save for byte count reperting\nSAVEFOLD DS    6F               Register Save for FOLDEM routine\nSAVEADDC DS    3F               Register Save for ADDCOUNT routine\nSAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE\nSAVER9AD DS    F                Register Save for ADDCOUNT routine\nSAVER9RB DS    F                Register Save for READBLOK routine\nSAVER9RF DS    F                Register Save for REPTFILE routine\nSAVER9LB DS    F                Register Save for LABELCHK routine\nSAVER9SR DS    F                Register Save for SUMMREPT routine\nSAVER9FB DS    F                Register Save for FOLDBUFF routine\nSAVER9FI DS    F                Register Save for FLDIMAGE routine\nSAVER9SC DS    F                Register Save for SCNSYSIN routine\nSAVER9MH DS    F                Register Save for MAKEHEDR routine\nSAVER9AC DS    F                Register Save for ASCCNVRT routine\nNEWFLDA  DS    F\nHDRSIZE  DC    F'12'            SIZE OF A HEADER\nSVBEGDAT DS    F\n*  -----------------\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*  -----------------     JFCB if we'll need RDJFCB later - not used now\nJFCB1    DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\n         DC    C' '\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '\nPRMSG03  DC    CL34'     TOTAL BLOCK HEADERS        : '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '\nCTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '\nCTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '\nCTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '\nCTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '\nCTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '\nCTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '\nCTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2T2FK - REAL TAPE TO FB-80 AWS CONVERSION PROG-\n               RAM  '\nMESSAGE2 DC    CL133'1VTT2T2FK  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE3 DC    CL133'1VTT2T2FK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-\n               R REPORT  '\nMESSAGE4 DC    CL133'1VTT2T2FK - TAPE TO AWS FILE REPORT - READ AND FOL-\n               D STATS  '\nMESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-\n               '\nMESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-\n               '\nMESSAGE7 DS    0CL133\n         DC    CL8'  hdr:  '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'FLDSCARD'\n         DC    CL10'FLDECARD'\n         DC    CL10'FLDOFFST'\n         DC    CL10'FLDBYTES'\n         DC    CL10'FLDBYTOT'\n         DC    CL10'FLDBYMVD'\n         DC    CL10'FLDBUFFR'\n         DC    CL10'FLDBSTRT'\n         DC    CL14'FLDINRCD'\n         DC    CL11' '\nMESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-\n                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-\n               DE. '\nMESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2T2FK, THE SYSMOV-\n               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-\n                 '\nMESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-\n               EPORT.  BOTH \"TAPE READ\" AND \"FOLD DATA\" ARE AVAILABLE T-\n               HERE.'\nMESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -\n               HAVE SOURCE CODE, THEN UNCOMMENT THE \"BEFCALL-\" AND \"AFT-\n               CALL-\" '\nMESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-\n               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -\n                    '\nMESSAG13 DC    CL133'    VOLSER Overridden to:    '\nMESSAG14 DC    CL133'    Chunk Size is set to:    '\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    OFFSET ERROR           '\nINEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '\n         DC    C'TERMINATED '\n         DC    76C'*'\nINDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '\n         DC    82C'*'\n*  -----------------            Trace Message Texts\nREADTRMS DC    CL16'READ TRACE:     '\nFOLDTRMS DC    CL16'FOLD TRACE:     '\nMHDRTRMS DC    CL16'MAKEHEDR TRACE: '\nOSETTRMS DC    CL16'OFFSET TRACE:   '\nBBLKTRMS DC    CL16'BLOCK TRACE:    '\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nLINE     DC    CL133' '           For error messages\n         DC    C' '\nPRTLINE  DC    CL133' '\n         DC    C' '\nMSGLINE1 DC    CL133' '           For READ only message\n         DC    C' '\nMSGLINE2 DC    CL133' '           For IDRC remove message\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\nSAVEHDR  DC    XL6'000000000000'\nEOTMARK  DC    XL12'303030303030303030303030'\n* - - - - >\n*\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\n* - - - - >\n*         Saved Copy of FLDAREA Control Block\n* - - - - >\n*\nSAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nSAVSCARD DC    F'0'         Start address of 80-byte card\nSAVECARD DC    F'0'         End address of 80-byte card\nSAVOFFST DC    F'0'         OFFSET of data in the card\nSAVBYTES DC    F'0'         Number of bytes to be folded now\nSAVBYTOT DC    F'0'         Batch total of bytes left to move\nSAVBYMVD DC    F'0'         Number of bytes folded now\nSAVBUFFR DC    F'0'         Current data start address\nSAVBSTRT DC    F'0'         Original start data address\nSAVOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nSAVREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nSAVLENTH EQU   *-SAVAREA\n*\n* - - - - >\n*    ------------------------ >   Byte Count Save Areas - below\n*\n*                          -- These are doubleword counters --\n*\nDBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ\nDBOUTFH  DC    F'0'\nDBOUTFL  DC    F'0'\nDBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED\nDBOUTFMH DC    F'0'\nDBOUTFML DC    F'0'\nDBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ\nDBOUTH   DC    F'0'\nDBOUTL   DC    F'0'\nDBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED\nDBOUTMH  DC    F'0'\nDBOUTML  DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\n         DC    CL8' '      Extra padding for safety\n*\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n         DC    F'0'               Align, just for the heck of it\nGETSYSIN DC    CL80' '\nOUTCARDP DC    XL80'00'           Previous card-image read\nOUTCARD  DC    XL80'00'           Current  card-image read\nOUTCAEND EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         END\n   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'\nFOLDEM   CSECT\n*  ---------------------------------------------------------------  *\n*\n*   AUTHOR:       Sam Golob\n*\n*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,\n*                 subject to express permissions from the author\n*                 to use this software.  This software is part\n*                 of VTTS (Virtual Tape Transportation System).\n*\n*                 Permission is granted by the author for all\n*                 parts of the VTTS package which are distributed\n*                 on the CBT Tape collection, to be used by\n*                 anyone for their own use, but not for resale\n*                 or for reincorporation within commercial code.\n*\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    FOLDEM                                            *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating an      *\n*      FAKETAPE disk file from a real tape file.    The disk        *\n*      file is data that has been folded over from a buffer,        *\n*      into an FB-80 dataset.                                       *\n*                                                                   *\n*      This program takes buffer data and folds it into FB-80       *\n*      data, starting from a given buffer address, for a given      *\n*      number of bytes.  The data is folded into an 80-byte         *\n*      workarea starting from a given OFFSET address (+0 to +79)    *\n*      into the workarea.  When the workarea has been completely    *\n*      filled and more data is to be written, a PUT is done to      *\n*      write out the data from the 80-byte workarea, and then       *\n*      the workarea is cleared with binary zeros before any         *\n*      additional data is written to it.  An incompletely filled    *\n*      workarea is not written out, and the same is true if the     *\n*      workarea is full but no more data is to be written out.      *\n*      So in that case, the location of the workarea is returned    *\n*      to the caller in field FLDSCARD, and it is the caller's      *\n*      responsibility to do the PUT for the last card.              *\n*                                                                   *\n*  INPUTS and OUTPUTS:                                              *\n*                                                                   *\n*      This program is driven by a control block called FLDAREA,    *\n*      which is updated by both this program and by the caller.     *\n*      See below for more details.                                  *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called FAKEOUT, which receives the output      *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do PUTs to FAKEOUT, and if necessary, it needs      *\n*      to write messages to SYSPRINT.  Therefore the caller has     *\n*      to provide ENTRY FAKEOUT and ENTRY SYSPRINT statements in    *\n*      front of its FAKEOUT and SYSPRINT DCBs, respectively.        *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      FLDAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      FLDAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the caller's copy of FLDAREA, and upon return,      *\n*      R1 is pointed to the updated copy of FLDAREA in this         *\n*      subroutine.  So the caller has to copy it back over its      *\n*      own instance of FLDAREA after the return.                    *\n*                                                                   *\n*      The caller does one tape read, or read of data into a        *\n*      buffer.  From the number of bytes read, the caller will      *\n*      construct a FAKETAPE header which will determine how many    *\n*      bytes should be folded into the FB-80 disk dataset.  This    *\n*      FAKETAPE header is also folded by a call to this program,    *\n*      and then the tape data is folded in afterward, for the       *\n*      number of bytes required by the block size.                  *\n*                                                                   *\n*      This program does one or more PUTs into the FB-80 file,      *\n*      until the request for the number of bytes to be folded,      *\n*      is satisfied.  A PUT is done whenever the FB-80 work area    *\n*      has been filled.  At the end of the fold operation, the new  *\n*      OFFSET into the FB-80 workarea (that has not yet been        *\n*      written out to disk), the number of bytes that have been     *\n*      folded, and the projected start of the next data to be       *\n*      folded, are returned in the fields of the FLDAREA control    *\n*      block.                                                       *\n*                                                                   *\n*      The following is the layout of the FLDAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *\n*      *                         ------ ---- ------- -----          *\n*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *\n*  --> FLDECARD DC    F'0'       End address of 80-byte card        *\n*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *\n*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *\n*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *\n*      FLDBYMVD DC    F'0'       Number of bytes folded now         *\n*  --> FLDBUFFR DC    F'0'       Current data start address         *\n*  --> FLDBSTRT DC    F'0'       Original start data address        *\n*      FLDOUTCT DC    PL7'0'     Number of PUTs for FAKEOUT records *\n*  --> FLDREADF DC    X'00'      This run is \"READ ONLY\"  ?         *\n*      *              X'01'      Yes, read only. (Copied from the   *\n*                                READFLAG byte in the caller.)      *\n*      FLDLENTH EQU   *-FLDAREA                                     *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      FLDBUFFR and FLDOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the input data      *\n*      and output data positions, respectively, that are just       *\n*      after the moved data, to anticipate the next call, so as     *\n*      to be able to move more data.  FLDBSTRT preserves the        *\n*      very beginning address of the input buffer, whereas          *\n*      FLDBUFFR is a place somewhere within the buffer, which       *\n*      is the start from where the new data is expected to be       *\n*      moved.                                                       *\n*                                                                   *\n*      A new field, FLDBYTOT, makes it possible to create           *\n*      chunked blocks, but with FAKETAPE, that doesn't happen,      *\n*      so we have set things up with chunksize always equal 65535   *\n*      so \"chunksize is always equal to blocksize\".  The FLDBYTOT   *\n*      field originally contains the number of bytes in an entire   *\n*      block, and after the entire block has been written, it       *\n*      should be decremented by the number of bytes written, and    *\n*      it would therefore be 0.                                     *\n*                                                                   *\n*      Since both the caller and this program do PUT operations     *\n*      to the output FB-80 file, the count of the number of PUTs    *\n*      done, FLDOUTCT, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nFOLDEM   AMODE 24\nFOLDEM   RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'FOLDEM'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING FOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,FAKEOUTV           FAKEOUT  DCB address in caller\n         ST    R0,FKOUTDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to fold buffer data into an FB-80 file, starting at     *\n*   a given location in the buffer, for a certain number of bytes,  *\n*   and starting at a given OFFSET in the 80-byte workarea to       *\n*   which the buffer data will be written.  When the 80-byte        *\n*   workarea is filled up, a PUT is done to FAKEOUT, and the        *\n*   workarea is cleared with binary zeros for more data to be       *\n*   written.                                                        *\n*                                                                   *\n*   Input:   FLDAREA fields are all supplied by the calling         *\n*            program, except for FLDBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            caller's copy of FLDAREA is pointed to by Register 1.  *\n*                                                                   *\n*            The buffer area containing the data to be folded       *\n*            is supplied by the calling program, as well as the     *\n*            number of bytes that is expected to be folded.         *\n*                                                                   *\n*   Output:  Data from the buffer will be moved into the 80-byte    *\n*            workarea until the workarea is filled.  When the       *\n*            workarea is filled, a PUT will be done to FAKEOUT,     *\n*            and the workarea is cleared to X'00's to make room     *\n*            for more data, when more data is to be written.        *\n*                                                                   *\n*            Ending OFFSET into the 80-byte workarea, pointing to   *\n*            just after the data which has been moved, is returned  *\n*            in the FLDOFFST field.  Upon return to the caller,     *\n*            the FLDBUFFR field is updated to point to the place    *\n*            in the buffer just after the data which has been       *\n*            moved.  The FLDBSTRT field always should point to the  *\n*            beginning of the data buffer, but this is at the       *\n*            discretion of the calling program.                     *\n*                                                                   *\n*            A count of bytes actually moved from the buffer to     *\n*            the 80-byte workarea (and written out by PUTs to the   *\n*            FAKEOUT DD name as is necessary) is calculated by this *\n*            program and returned in the FLDBYMVD field.  Upon      *\n*            return, the number in the FLDBYMVD field should match  *\n*            the number in the FLDBYTES field.                      *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nFOLDIT   DS    0H\n         L     R1,SAVEPARM          Load address of caller's FLDAREA\n         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA\n         USING FLDBLOCK,R2\n         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours\n* - - - - - - - - - -      Load the buffer quantities\n         L     R7,FLDBUFFR          Initialize start of buffer data\n         L     R8,FLDBYTES          Bytes to be moved\n         AR    R8,R7                Add in start buffer address\n         ST    R8,HYPOENDB          Hypothetical end-of-buffer address\n*                                   which is probably the real\n*                                   end-of-data to be moved.\n* - - - - - - - - - -      Load the card quantities\n         MVC   SAVEBEGC,FLDSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,FLDECARD    Save \"end of card\" address\n         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,FLDSCARD          Point to beginning of card\n         A     R7,FLDOFFST          Add OFFSET to start of output\n         ST    R7,SAVEBEGO          Save where output starts\n         L     R8,SAVEBEGO          Copy beg of output address\n         A     R8,FLDBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n         ST    R8,HYPOENDC          Store hypothetical card end address\n*                                   (This may be way past end of card.)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is to within the current card.        *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.  So we have to do     *\n*              iterations.                                        *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         L     R7,SAVEBEGO          Beginning of CARD data\n         L     R8,HYPOENDC          Hypothetical end of CARD data\n         L     R3,FLDBUFFR          Prime R3 with start of buffer data\n         C     R8,SAVEENDC          Is R8 past the end-of-card?\n         BH    LOOPMORE             Yes. Do multiple moves and PUTs.\nLOOPSHRT DS    0H                   No. Do the one move only.\n         LR    R6,R8                Get byte count to move NOW.\n         SR    R6,R7                Bytes to move from buffer to card\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data from buffer to card.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total bytes moved.\n         ST    R1,FLDBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,FLDBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET -\n         S     R6,FLDSCARD          Subtract beginning of card address\n         ST    R6,FLDOFFST          Store the result as new OFFSET\n* -- >\nLOOPTS50 DS    0H\n*                                   If OFFSET > X'4F', card is complete\n         C     R6,=F'80'            Is the new offset exactly X'50'?\n         BNE   LOOPNT50             No. Then current card not complete.\n*                                   Yes. Then PUT out card and init it.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT001             Yes. Can't PUT to FAKEOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT001 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n         XR    R6,R6                Clear R6\n         ST    R6,FLDOFFST          New offset is 0, not X'50'\nLOOPNT50 DS    0H\n* -- >\n         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT\n         S     R1,FLDBYMVD          And subtract bytes already moved\n         ST    R1,FLDBYTOT          To show new total buffer byte count\n*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,FLDBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Test if past end of buffer\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,FLDBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT002             Yes. Then don't produce FAKEOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT002 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE CALLER\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of FLDAREA in caller\n         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nFLDBLOCK CSECT\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\nFOLDEM   CSECT\nWORKAREA DS    CL80                 Card image work area\n         DC    CL4' '               Padding\n         DC    C' '\nLINE     DC    CL133' '             Output line\n         DC    C' '\nLINE2    DC    CL133' '             Second output line if needed\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'30'\nSAVEBEGO DC    F'0'                 Save beg address of card output\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address\nHYPOENDC DC    F'0'                 Hypothetical end address after card\nHYPOENDB DC    F'0'                 Calculated end of buffer address\nSYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB\nFAKEOUTV DC    V(FAKEOUT)           Address of FAKEOUT DCB\nSYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here\nFKOUTDCB DC    F'0'                 FAKEOUT DCB address stored here\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT850/CBT.V500.FILE850.PDS/VASM.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT850/CBT.V500.FILE850.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}