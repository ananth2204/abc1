{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013201000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE877.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE877.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x11'", "DS1TRBAL": "b'\\x19\\x1a'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07\\x97\\x00\\x0e\\x07\\x98\\x00\\x05\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00!\\x01\\x12(?\\x01\\x12(?!\\t\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-10-09T00:00:00", "modifydate": "2012-10-09T21:09:21", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-485"}, "text": "REGULAR CBT TAPE - VERSION 485    FILE:  877\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT485.FILE877\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 30 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,681 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/09/12    21:09:21    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x12&_\\x01\\x12&_\\x17\"\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2012-09-21T00:00:00", "modifydate": "2012-09-21T17:22:53", "lines": 26, "newlines": 26, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  ISPF Edit cursor macros V/B/E\nFrom:     Vladimir Mestovski <v2gri033@us.ibm.com>\nDate:     9/21/2012 8:25 AM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nThese macros allow us to get rid of annoying actions\n(copy,paste,switch screen) when we are in a jcl member and want\nto just quickly open a data set or a member whose name is already\non the screen in View or Edit session/mode.  Having Fn keys\nassigned to run macros (for example F4=V, F16=E) now we can move\nthe cursor to the needed data set name or member and press F4 to\nview or shift+F4 to edit.  (Or you can use any other PF keys.)\n\nProbably CBT already has similar macros but I have not found\nthem. If you think new macros would be useful for people please\naccept my XMI file.\n\nThanks.\n\n(See attached file: VBE.REXX.XMI)\n\nVladimir.\nv2gri033@us.ibm.com\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x17\\x01\\x12&_\\x01\\x12&_\\x16V\\x00\\x1a\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-09-21T00:00:00", "modifydate": "2012-09-21T16:56:17", "lines": 26, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "             ISPF Edit cursor macros V/B/E\n             -----------------------------\n\n Using these macros you can quickly open data sets or its members\n whose names are on your screen in Edit/View mode. Just move the cursor\n to the need name and press Fn assigned early to V(view), E(edit), or\n B(browse).\n\n To assign an Fn key in Edit/View mode, type KEYS in the command line,\n then assign for example F4 and F16 (shift+F4) as follows:\n   F4 . . .  V________________________________________  SHORT   V/E___\n   F16  . .  E________________________________________  SHORT   V/E___\n\n Macros understand and substitute the following JCL variables:\n  - &SYSUID variable\n  - 5 first PROC variables (//P1 PROC HLQ=MDCP,TYPE='PROD',...\n  - SET variables          (//   SET  M=BSPUFI\n\n To activate macros copy V,B,E,VBE members to a library allocated\n with dd-name SYSPROC for your ISPF session. Use TASID 6 or ISRDDN\n in the command line to get info about your SYSPROC libraries.\n\n Best wishes,\n             Vladimir Mestovski,IBA,Minsk,Belarus\n                  v2gri033@us.ibm.com\n                  mestovsky@iba.by\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$SAMPLE": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x016\\x00\\x02\\x01\\x10$_\\x01\\x12'o\\x10!\\x01\\x85\\x01=\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.54", "flags": 0, "createdate": "2010-09-02T00:00:00", "modifydate": "2012-10-02T10:21:02", "lines": 389, "newlines": 317, "modlines": 0, "user": "V2IBAVM"}, "text": "************************************************************************\n* Sample of a MAKE file.\n******************************************Vladimir Mestovski 2012*******\n*\n* MAKE file is input for MAKE tool that executes actions from the file.\n* MAKE tool is started by entering the MAKESUB command in the command\n* line when you opened the file in View or Edit mode. The command\n* saves the current state of the file into a temporary file and submits\n* a MAKESUB job (MAKEnnn) to interpret and execute actions within it\n* (hidden from view lines by X/XX prefix commands are bypassed).\n*\n* MAKE file looks like a collection of different control cards\n* for different environments/applications joined together in one place,\n* no need to create special JCLs for each of them to execute.\n* The first word of make statements indicates the need application\n* to which statements are designed, i.e.\n*       REXX,TSO,QMF,DSN,JCL,SPUFI(DSNTEP2/4),SQL(BSPUFI)\n*\n* Before running of the MAKESUB command use the MAKESCAN command first\n* to find missing continuation signs(+) in the file.\n* Use HILITE REXX to color the file to see if a quote is missing.\n*\n* Since a MAKE file has full data set names it is convenient to use\n* V(view),E(edit),B(browse) macros inside it.\n* Use also SC(SuperC) macro to compare two data sets/members and\n* VDIR macro when you inside of a $DIR$ member to view a member.\n* ALL is a macro that shows all lines with a word pointed by the cursor\n* and hides others.\n*\n* Use KEYS in the command line to assign your F-keys, like this:\n*\n*'F1=SC   F2=ALL     F4=V       F5=Rfind    F9=E/VDIR' <-- Shift+F9\n*\n*               *** I N S T A L L A T I O N ***\n* Before the first use of the tool you should adjust MAKEINI member\n* to specify values for variables. The member contains jcl for MAKEnnn\n* job, adjust it as well.\n* To acivate the MAKE tool copy all members to a library allocated\n* as SYSPROC in your ISPF session or concantenate new library with the\n* tool in LOGON.CLIST or as LOGON Command:\n*       CONCATD FI(SYSPROC) DA('your.lib.REXX') BEFORE SHR\n* If you do not have the SLEEP command in your STEPLIB library you can\n* add the command with SLEEP member, compile job.\n* Note. The file contains PDS with RECFM=F to satisfy XMIT manager.\n*       Although most likely you have other libraries in SYSPROC\n*       with RECFM=V. In this case you should recreate the tool library\n*       with RECFM=V.\n************************************************************************\n*\n*                         'REXX commands'\n*                          -------------\n*\n************************************************************************\n\n* '1. LMCOPY -- Copy Members of a Data Set'\n* +-------------+------------------------------------------------------\n* | REXX LMCOPY | 'DSNfrom(MEMBERfrom)' +\n* |             | 'DSNto(MEMBERto)'     \u00ddREPLACE|BACKUP\u00a8\n* +-------------+------------------------------------------------------\n* where BACKUP moves MEMBERto to the 'DSNto.OBSOLETE' library first\n* (if exists) using LMEXPORT command (see below)\n\nREXX LMCOPY 'MDCT.HOLD.VM.USERPROC(CPE240)' +\n            'MDCT.TEST.USERPROC(CPE240)'    REPLACE\n\n* '2. LMMOVE -- Move Members of a Data Set'\n* +-------------+------------------------------------------------------\n* | REXX LMCOPY | 'DSNfrom(MEMBERfrom)' +\n* |             | 'DSNto(MEMBERto)' \u00ddREPLACE\u00a8\n* +-------------+------------------------------------------------------\n* Once the data has been moved, the MEMBERfrom is deteted.\n\nREXX LMMOVE 'MDCT.HOLD.VM.USERPROC(CPE240)' +\n            'MDCT.TEST.USERPROC(CPE240)'    REPLACE\n\n* '3. LMMREN -- Rename a Data Set Member'\n* +-------------+------------------------------------------------------\n* | REXX LMMREN | 'DSNfrom(MEMBERfrom)' NEWNAME(MBRto)\n* |             |\n* +-------------+------------------------------------------------------\n\nREXX LMMREN 'MDCT.HOLD.VM.USERPROC(CPE240)' NEWNAME(XXX240)\n\n* '4. LMMDEL -- Delete a Member from a Data Set'\n* +-------------+------------------------------------------------------\n* | REXX LMMDEL | 'DSNfrom(MEMBERfrom)'\n* |             |\n* +-------------+------------------------------------------------------\n\nREXX LMMDEL 'MDCT.HOLD.VM.USERPROC(XXX240)'\n\n* '5. LMEXPORT -- Export a Data Set Member'\n* +---------------+----------------------------------------------------\n* | REXX LMEXPORT | 'DSNfrom(MBRfrom)' TO 'DSNobsolete'\n* |               |\n* +---------------+----------------------------------------------------\n* Move the MBRfrom to DSNobsolete with new generated member name\n* like Mnnnnnnn. New and old member names are stored into the $$DIR$$\n* member created automatically if not exists.\n\nREXX   LMEXPORT 'MDCT.TEST.SORTCARD(CPE240U1)' +\n          TO    'MDCT.TEST.SORTCARD.OBSOLETE'\n\n* '6. LMIMPORT -- Import a Data Set Member'\n* +---------------+----------------------------------------------------\n* | REXX LMIMPORT | 'DSNto(MBRto)' FROM 'DSNobsolete' \u00ddREPLACE\u00a8\n* |               |\n* +---------------+----------------------------------------------------\n* Restore the latest MBRto member exported by LMEXPORT.\n\nREXX   LMIMPORT 'MDCT.TEST.USERPROC(CPE240)'   +\n          FROM  'MDCT.TEST.USERPROC.OBSOLETE'  REPLACE\n\n* '7. LMMSTATS -- Change ISPF statistic of a Data Set Member'\n* +---------------+----------------------------------------------------\n* | REXX LMMSTATS | 'DSN(MBR)' USER(id) CREATED(yy/mm/dd)\n* |               | MODDATE(yy/mm/dd) MODTIME(hh:mm)\n* +---------------+----------------------------------------------------\n* Restore the latest MBRto member exported by LMEXPORT.\n\nREXX   LMMSTATS 'MDCT.PROD.C(A1)' USER(V2IBAVM) +\n                CREATED(11/05/26) MODDATE(11/06/20) MODTIME(07:37)\n\n* '8. LMCLONE  -- Clone a Data Set Member'\n* +---------------+----------------------------------------------------\n* | REXX LMCLONE  | 'DSNfrom(MBRfrom)' 'DSNto(MBRto)' \u00ddREPLACE\u00a8\n* |               |\n* +---------------+----------------------------------------------------\n* Copy MBRfrom to MBRto then Edit MBRto using commands in CLONEMBR\n\nSET CLONEMBR='MDCT.HOLD.VM.CLONE(TMDFP)'\n*                                  +--->  C  <HLQ> MDFP\nREXX LMCLONE 'MDCT.TOOLS.CNTL(QMFEXPRT)' +\n             'MDCT.TEMP.SORTCARD(QMFEXPRT)' REPLACE\n\n* '9. LMEDIT   -- Edit a Data Set Member'\n* +---------------+----------------------------------------------------\n* | REXX LMCLONE  | 'DSN(MBR)'\n* |               |\n* +---------------+----------------------------------------------------\n* Edit MBR with commands from CLONEMBR member\n\nSET CLONEMBR='MDCT.HOLD.VM.CLONE(TMDFP)'\nREXX LMCLONE 'MDCT.TEMP.SORTCARD(QMFEXPRT)'\n\n* '10. WSUBMIT  -- SUBMIT a job and wait for its end'\n* +---------------+----------------------------------------------------\n* | REXX WSUBMIT  | 'DSN' \u00ddMAXWAIT=nn\u00a8\n* |               |\n* +---------------+----------------------------------------------------\n* nn - number of seconds of TOTAL time (not CPU). Default is 3600 secs.\n* The command needs SLEEP command available as a TSO command.\n\nREXX WSUBMIT 'MDCT.TEMP.SORTCARD(QMFEXPRT)' MAXWAIT=90000\n\n* '11. QEXPORT  -- Export a QMF object using $$DIR$$ member of DSNto'\n* +---------------+----------------------------------------------------\n* |               | QUERY\n* | REXX QEXPORT  | PROC    QMFname  TO 'DSNto' \u00dd(ERASE\u00a8\n* |               | FORM\n* +---------------+----------------------------------------------------\n* Name of member in DSNto is generated and placed into $$DIR$$ member\n* together with QMFname. ERASE deletes the object in QMF.\n\nSET SSID=DB2A\nREXX    QEXPORT QUERY MDCT.AUDIT_UPDATE_Q +\n                   TO 'MDCT.TEST.QMFLIB'\n\n* '12. QIMPORT  -- Import a QMF object using $$DIR$$ member of DSNto'\n* +---------------+----------------------------------------------------\n* |               | QUERY\n* | REXX QIMPORT  | PROC    QMFname  FROM 'DSNfrom'\n* |               | FORM\n* +---------------+----------------------------------------------------\n* Import the latest member with QMFname in the $$DIR$$ member\n\nSET SSID=DB2E\nREXX    QIMPORT QUERY MDCT.AUDIT_UPDATE_Q +\n                 FROM 'MDCT.TEST.QMFLIB'\n\n************************************************************************\n*\n*                      'DSN/DB2 commands'\n*                      -----------------\n*\n************************************************************************\nSET SSID=DB2A\nDSN -TERM UTILITY ('CPE127') -- no authority\nDSN -DIS DB(TR57VDB1) SPACENAM(T57VT105) LIMIT(*)\nDSN -STOP  DATABASE(TR57VDB1) SPACE(T57VT105)\nDSN -START DATABASE(TR57VDB1) SPACE(T57VT105) ACCESS(RW)\nDSN -DIS DB(TR57VDB1) SPACENAM(T57VT105) LIMIT(*)\nSET SSID=DB2E\nDSN FREE PLAN (BSPUFIV);\nDSN BIND PACKAGE (BYDB2LABE.BSPUFIV) +\nDSN      MEMBER(BSPUFI) DBPROTOCOL(DRDA) +\nDSN      ACTION(REPLACE) ISOLATION(UR) CURRENTDATA(NO) +\nDSN      LIB(MDCT.PROD.DBRMLIB)\nDSN BIND PACKAGE (BYDB2LAB.BSPUFIV) +\nDSN      MEMBER(BSPUFI) DBPROTOCOL(DRDA) +\nDSN      ACTION(REPLACE) ISOLATION(UR) CURRENTDATA(NO) +\nDSN      LIB(MDCT.PROD.DBRMLIB)\nDSN BIND PLAN(BSPUFIV) +\nDSN      PKLIST(BYDB2LABE.BSPUFIV.BSPUFI,BYDB2LAB.BSPUFIV.BSPUFI) +\nDSN      ACT(REP) ISOLATION(UR) RETAIN  CURRENTDATA(NO) SQLRULES(DB2)\n************************************************************************\n*\n*                    'Run SPUFI (DSNTEP2/4)'\n*                     ---------------------\n*\n************************************************************************\nSET SSID=DB2E\nSPUFI SET CURRENT SQLID='MDCT';\nSPUFI DROP ALIAS MDCT.CPEIN_EXP_LOTS222;\nSPUFI CREATE ALIAS MDCT.CPEIN_EXP_LOTS222 FOR CPEIN.EXP_LOTS;\nSET SSID=DB2A\nSPUFI SET CURRENT SQLID='MDQ1T';\nSPUFI GRANT SELECT ON TABLE Q1TIN.UGR_RULES TO TOMU;\n*\nSPUFI SELECT RULE_TYPE, ACTIVE_IND, INT1 AS VERSION_ID\nSPUFI   FROM CPEIN.TOM_RULES\nSPUFI  WHERE RULE_TYPE='COPYHQ1T';\n************************************************************************\n*\n*                       'Run SQL (BSPUFI) -- CBT484.FILE866'\n*                        ----------------\n*\n************************************************************************\nSET SSID=DB2E\nSQL SET CURRENT SQLID='MDCT';\nSQL WRITE CSV FILE 'MDCT.TEMP.CPEIN.RULES.CSV'\nSQL  SELECT * FROM CPEIN.TOM_RULES\nSQL   WHERE RULE_TYPE='COPYHQ1T';\n* and so on ... see CBT484.FILE866\n************************************************************************\n*\n*                      'Run TSO commands'\n*                      -----------------\n*\n************************************************************************\nTSO DEFINE GDG (NAME('MDCT.TEMP.GDGTEST') LIM(7) SCRATCH)\nTSO DELETE 'MDCT.TEMP.GDGTEST' GDG FORCE\n* TSO0 ignores RC<>0\nTSO0 DELETE 'MDCT.HOLD.VM.TEMP2'\nTSO ALLOCATE DSNAME('MDCT.HOLD.VM.TEMP2') +\n             NEW DSORG(PS) RECFM(F,B) LRECL(94) +\n             SPACE(100,100) CYLINDERS RELEASE +\n             UNIT(SYSDA) MAXVOL(15) CATALOG\n* Run OCOPY\nTSO ALLOC FI(I) DA('MDCT.HOLD.VM.DRIVER(Q2DRIVER)') SHR REUSE\nTSO ALLOC FI(O) DA('MDCP.TTR029.DRIVER') SHR REUSE\nTSO OCOPY INDD(I) OUTDD(O)\n* Run a program with SQL\nTSO ALLOCATE FI(ENDMON)  DSN('MDCT.JXRPE245.UNLOAD') OLD RELEASE REUSE\nTSO ALLOCATE FI(SENDMSG) DSN('MDCT.RPE47.SENDMSG')   SHR REUSE\nTSO ALLOCATE FI(SUMMARY) SYSOUT(H) REUSE LRECL(133) RECFM(F,B,A)\nTSO ALLOCATE FI(CONTROL) SYSOUT(H) REUSE LRECL(133) RECFM(F,B,A)\nSET SSID=DB2E\nDSN RUN  PROGRAM(RPE47) PLAN(RPE47) LIB('MDCT.PROD.LOADLIB')\n* REXEC to AIX\nTSO ALLOC FI(NETRC) DA('MDCP.PROD.PASSWORD(TIMIGSP)') REUSE SHR\nTSO REXEC pokxpr1p7.pok.ibm.com +\ncp /u1/tomq2/hold/TTR110A.Q2.CAP.conf +\n   /u1/tomq2/conf/TIM/TTR110A.Q2.CAP.conf +\n;+\ncp /u1/tomq2/hold/TTR110.Q2.CAP.conf +\n   /u1/tomq2/conf/TIM/TTR110.Q2.CAP.conf\n* Submit a job. No wait its end.\nTSO SUBMIT 'MDCT.TEST.CNTL(IEFBR14)'\n* Send DONE note\nTSO XMIT IBMUS.V2GRI033 MSGFILE(DONE)\n* Send a message to an MVS user\nTSO SEND '*** $SAMPLE COMPLETED ***' USER(V2IBAVM)\n* Run FTP\nTSO ALLOC FI(NETRC) DA('MDCV.PROD.PASSWORD(TOMLIB)') SHR REUSE\nSTACK btvlabe.btv.ibm.com\nSTACK quote site filetype=jes\nSTACK get 'MDCT.HOLD.VM.CNTL(IEFBR14)'  XXX (REPLACE\nSTACK QUIT\nTSO FTP\n* and so on...\n************************************************************************\n*'RUN A JCL. If //JOB missed then //userid()||X JOB is added'\n************************************************************************\n************************************************************************\n*\n*                            'Run JCL'\n*                             --------\n*\n************************************************************************\n* If the job fails, MAXRC=12 allows to continue make file\nSET MAXRC=12\n//TTR087Z  JOB ($29HKZA,BIN333,EFK334,DEPTHKZA),'BOB',\n// TIME=(5),MSGLEVEL=(1,1),MSGCLASS=H,NOTIFY=&SYSUID,REGION=4M\n//*\n//RUN    EXEC PGM=IKJEFT01,DYNAMNBR=50\n//SYSTSIN   DD *\n  DSN SYSTEM(DB2E)\n  RUN  PROGRAM(TTR087Z) PLAN(TTR087Z) +\n       LIB('MDCT.PROD.LOADLIB') +\n       PARMS('VERSIONS=7,POS=1,DELAY=1 + ...')\n//FLATFILE  DD  DSN=MDCT.HA.FLATFILE.TTR087Z,DISP=SHR\n//SYSTSPRT  DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//ABEND  EXEC PGM=JTERM,COND=(4,GE,RUN)\n//* The next '// ' must exist to find the end of this jcl\n//\n* Reset MAXRC\nSET MAXRC=4\n* next SET is for JCL w/o JOB card\nSET JCLLIB=MDCT.PROD.USERPROC\n* Run IEBGENER ...\n//COPY00   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=MDCP.TTR029.DRIVER,DISP=SHR\n//SYSUT2   DD DSN=MDCP.TTR029.DRIVER.BACKUP(+1),\n//         DISP=(NEW,CATLG,DELETE),\n//         LIKE=MDCP.TTR029.DRIVER\n//SYSIN DD DUMMY\n//\n************************************************************************\n*\n*                        'Run QMF'\n*                        ---------\n*\n************************************************************************\nSET SSID=DB2E\nQMF    DI TABLE BYDB2LAB.CPEINT.IO_BOMTREE\nQMF    SAVE DATA AS CPEIN.IO_BOMTREE             (CONFIRM=NO\nSET SSID=DB2A\nQMF    DI TABLE CPEIN.TOM_RULES\nQMF    EXPORT DATA TO TOMRULES (C=N\nSET SSID=DB2E\nQMF    IMPORT DATA FROM TOMRULES\nQMF    SAVE   DATA AS   CPEIN.TOM_RULES (CONFIRM=NO\n* Runnig test cases in QMF ....\nQMF ERASE TABLE T (CONFIRM=NO\nQMF IMPORT QUERY FROM 'MDCT.HOLD.VM.MAKETEST(C209Q0)'\nQMF PRINT QUERY         (PAGENO=NO DATETIME=NO WIDTH=132 LENGTH=CONT\nQMF RUN QUERY\nQMF SAVE DATA AS T (CONFIRM=NO\n*\nQMF SET GLOBAL (STAGE_PN='''0000046D6047'''\n#INCLUDE QMF 'MDCT.HOLD.VM.MAKETEST(C209T1)'\n*\nQMF SET GLOBAL (STAGE_PN='''0000070P5710'''\n#INCLUDE QMF 'MDCT.HOLD.VM.MAKETEST(C209T1)'\n* and so on, any QMF commands\n************************************************************************\n*'#INCLUDE external MAKE files:'\n************************************************************************\n*#INCLUDE QMF      'MDCT.HOLD.VM.MAKETEST(QMF1)'\n*#INCLUDE DSN      'MDCT.HOLD.VM.MAKETEST(DSN1)'\n*#INCLUDE SPUFI    'MDCT.HOLD.VM.MAKETEST(SPUFI1)'\n*#INCLUDE MAKE     'MDCT.HOLD.VM.MAKETEST(MAKE1)'\n*#INCLUDE MAKEFILE 'MDCT.HOLD.VM.MAKETEST(MAKE2)'\n\n* Hidden #INCLUDE in jcl... can be used as test automation tool\n* MAKE tool splits job to several ones to run make file between them.\n//*#INCLUDE MAKEFILE 'MDCT.HOLD.VM.MAKETEST(SLPFT32)'\n*\n************************************************************************\n*'Stop processing'\n************************************************************************\nEXIT\n************************************************************************\n*'Make commands to collect this tool'\n************************************************************************\nTSO0 DELETE 'V2IBAVM.CBT484.FILE9NN.XMI'\nTSO0 DELETE 'V2IBAVM.TEMP.REXX'\nTSO ALLOCATE DSNAME('V2IBAVM.TEMP.REXX') +\n             NEW DSORG(PO) DIR(10) RECFM(F,B) LRECL(80) +\n             SPACE(1,1) CYLINDERS RELEASE +\n             UNIT(SYSDA) CATALOG\nTSO ALLOCATE DSNAME('V2IBAVM.CBT484.FILE9NN.XMI') +\n             NEW DSORG(PS) RECFM(F,B) LRECL(80) +\n             SPACE(1,1) CYLINDERS RELEASE +\n             UNIT(SYSDA) CATALOG\nREXX LMCOPY 'MDCT.HOLD.VM.REXX($SAMPLE)'  'V2IBAVM.TEMP.REXX($SAMPLE)'\nREXX LMCOPY 'MDCT.HOLD.VM.REXX(LMCOPY)'   'V2IBAVM.TEMP.REXX(LMCOPY)'\n* * *\nREXX LMCOPY 'MDCT.HOLD.VM.REXX(VDIR)'     'V2IBAVM.TEMP.REXX(VDIR)'\nREXX LMCOPY 'MDCT.PROD.COMPILE(ASLEEP2)'  'V2IBAVM.TEMP.REXX(SLEEP)'\n\nTSO XMIT X.X DA('V2IBAVM.TEMP.REXX') +\n          OUTDA('V2IBAVM.CBT484.FILE9NN.XMI')\n\nTSO XMIT IBMUS.V2GRI033 DA('V2IBAVM.CBT484.FILE9NN.XMI') NOLOG\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE877": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x17\\x01\\x12(?\\x01\\x12(?!\\t\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-10-09T00:00:00", "modifydate": "2012-10-09T21:09:17", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBT-485"}, "text": "//***FILE 877 is from Vladimir Mestovski and contains ISPF edit     *   FILE 877\n//*           macros written in REXX that allow you (by pressing    *   FILE 877\n//*           a PF key) to BROWSE, VIEW, or EDIT a dataset in       *   FILE 877\n//*           ISPF, when the cursor is placed on that dataset name. *   FILE 877\n//*           You just need to copy these REXX programs into a      *   FILE 877\n//*           library in the SYSPROC concatenation, and set PF keys *   FILE 877\n//*           to B, E, or V.                                        *   FILE 877\n//*                                                                 *   FILE 877\n//*       In addition, this file contains Vladimir's MAKE package,  *   FILE 877\n//*       which is a powerful tool to do automate many different    *   FILE 877\n//*       types of tasks, in different enviornments under z/OS.     *   FILE 877\n//*                                                                 *   FILE 877\n//*       Please see member $README for details about the V, B,     *   FILE 877\n//*       and E macros.  Please see member $SAMPLE to better        *   FILE 877\n//*       describe the use of the powerful MAKE package.            *   FILE 877\n//*                                                                 *   FILE 877\n//*           email:  v2gri033@us.ibm.com                           *   FILE 877\n//*                                                                 *   FILE 877\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALL": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01-\\x00)\\x01\\x03\\x14\\x8f\\x01\\x12'o\\x10$\\x00\\xe1\\x00\\x16\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.45", "flags": 0, "createdate": "2003-05-28T00:00:00", "modifydate": "2012-10-02T10:24:29", "lines": 225, "newlines": 22, "modlines": 0, "user": "V2IBAVM"}, "text": "/*Rexx**************** < ISPF Edit ALL macro > ************************/\n/*                                                                    */\n/*                                +-WORD---------+                    */\n/*>>--ALL--+-------------------+--+-CHAR---------+--+-------------+-><*/\n/*         '-string-expression-'  '-PREFIX-------'  '-col1-+------'   */\n/*         '-PROC-or-CALL-or-?-'  '-SUFFIX-------'         '-col2-'   */\n/*                                                                    */\n/* Use the ALL macro to display a specified collection of lines       */\n/* for editing, while excluding others from display.                  */\n/*                                                                    */\n/* 1. Enter ALL on the command line, position the cursor on a word    */\n/*    somewhere on the screen and press ENTER. Only lines with the    */\n/*    word will be displayed.                                         */\n/*    Put the cursor on a point in DCLTABLE.FIELD if you want to      */\n/*    capture both words.                                             */\n/* 2. To make all lines visible starting from needed line put         */\n/*    the cursor on a blank of the line and run ALL.                  */\n/* 3. PROC allows to display all procedure names of a PLI program.    */\n/* 4. CALL allows to display all procedure names and CALL operators   */\n/* 5. Use KEYS command to assign ALL to a function key.               */\n/* 6. Use a string expression if you want to display lines with       */\n/*    different words. Valid boolean operators are \u00ac,&,|,&\u00ac,|\u00ac.       */\n/*                                                                    */\n/* Examples:                     Display all lines                    */\n/*           ALL ABC          -- with ABC chars                       */\n/*           ALL \u00ac'ABC'       -- with out ABC chars                   */\n/*           ALL 'ABC'&'XYZ'  -- with ABC and XYZ chars               */\n/*           ALL \"A'C\"|\"XYZ\"  -- with A'C or XYZ chars                */\n/*           ALL 'ABC'&\u00ac'XYZ' -- with ABC and w/o XYZ chars           */\n/*                                                                    */\n/* Author: Vladimir Mestovski,v2gri033@us.ibm.com,IBA,Minsk,Belarus   */\n/* Version: 1.0 ************************************June 2003**********/\n\ntrace 'o'\n'ISPEXEC CONTROL ERRORS RETURN'\n'ISREDIT MACRO (parms) PROCESS'\nif parms = '?' then Exit (help());\n'ISREDIT (user) = USER_STATE'\n'ISREDIT (hrow,hcol) = CURSOR'\n'ISREDIT (row,col) = CURSOR'; /* say 'row='row 'col='col */\n'ISREDIT (last)    = LINENUM .ZLAST'\n'ISREDIT (lrecl)   = LRECL'\n'ISREDIT (recfm)   = RECFM'\n'ISREDIT (nummode,numtype) = NUMBER'\n'ISREDIT (col1,col2) = BOUNDS'\n'ISREDIT (scan) = SCAN'\n'ISREDIT SCAN OFF'\nworddelimiter  = \" :,;=<>'.|!%\u00ac&*()-+{}\u00dd\u00a8\\/`\"\"\"\n\n/*------------------------ M a i n l i n e ---------------------------*/\n\nIf parms = '' & row > 0 & row <= last,\n              & col > 0 & col <= lrecl Then\nExit (runCsrRequest(row,col));\n\nIf parms = '' Then\nExit (runResetAll());\n\nIf translate(parms) = 'PROC' Then\nExit (runPROCrequest());\n\nIf translate(parms) = 'CALL' Then\nExit (runCALLrequest());\n\ns = getFirstChar(parms)\nif s='' then\nExit (runSimpleRequest(parms));\n\nExit (runFullRequest(parms));\n\n/*--------------------------------------------------------------------*/\nrunResetAll:\n  'ISREDIT RESET'\n  Return (restoreState(0))\n/*--------------------------------------------------------------------*/\nrunPROCrequest:\n  'ISREDIT RESET'\n  'ISREDIT EXCLUDE ALL'\n/*\"ISREDIT FIND 'PROC' ALL WORD X\"*/\n  'ISREDIT FIND : ALL SUFFIX X 2 25'\n  \"ISREDIT EXCLUDE '/*' ALL 1 3\"\n  Return (restoreState(rc));\n/*--------------------------------------------------------------------*/\nrunCALLrequest:\n  'ISREDIT RESET'\n  'ISREDIT EXCLUDE ALL'\n  'ISREDIT FIND : ALL SUFFIX X 2 25'\n  \"ISREDIT FIND 'CALL' ALL WORD X\"\n  \"ISREDIT EXCLUDE '/*' ALL 1 3\"\n  Return (restoreState(rc));\n/*--------------------------------------------------------------------*/\nrunSimpleRequest: parse arg parms\n  if parms = '' then\n  Exit (runResetAll());\n  Call runFirstFind parms;\n  'ISREDIT EXCLUDE ALL'\n  'ISREDIT FIND ALL X' parms\n  Return (restoreState(rc));\n/*--------------------------------------------------------------------*/\nrunFirstFind: parse arg sword;\n  cmdfind = 'ISREDIT FIND FIRST' sword;cmdfind;\n  if rc=4  then Exit (ErrorExit(\"String not found\",cmdfind,rc))\n  if rc=12 then Exit (ErrorExit(\"Put string in quotes\",cmdfind,rc))\n  if rc>12 then Exit (ErrorExit(\"Inconsistent parameters\",cmdfind,rc))\n  Return 0\n/*--------------------------------------------------------------------*/\nrunCsrRequest: parse arg lptr,cpos\n  'ISREDIT (data) = LINE .ZCSR'\n  Return (runSimpleRequest(getCsrWord(data,cpos)));\n/*--------------------------------------------------------------------*/\ngetCsrWord: parse arg feld,cpos;\n  if substr(feld,cpos,1) = '' then\n  Exit (runResetAll());\n  if substr(feld,cpos,1) = '.' then shift=1; else shift=0;\n  Do i=cpos-shift to 1 by -1 ,\n  While (Verify(Substr(feld,i,1),worddelimiter)\u00ac=0);End;\n  Do j=cpos+shift to Length(feld),\n  While (Verify(Substr(feld,j,1),worddelimiter)\u00ac=0);End;\n  If i=j then\n  Exit (ErrorExit('Put cursor on a word','i,j='i feld,4))\n  Return (\"'\"substr(feld,i+1,j-i-1)\"' WORD\")\n/*--------------------------------------------------------------------*/\nrunFullRequest: parse arg parms;\n  Interpret,\n  \"Parse var parms expression \"lastpos(s,parms)+1\" rest\"\n  Parse Var expression operator (s) string (s) expression\n  Do i=1 while (string\u00ac='')\n   rc=runCmds(getCmds(operator,i),s||string||s,strip(rest));\n   Parse Var expression operator (s) string (s) expression\n  End;\n  Return (restoreState(rc));\n/*--------------------------------------------------------------------*/\ngetCmds: parse arg opr,i\n   Select;\n    When opr=''  & i=1 then Return('RESET SCAN FFIND XALL XFIND UPMAX')\n    When opr='\u00ac' & i=1 then Return('RESET XALL XFIND FLIP UPMAX'      )\n    When opr='|'       then Return('XFIND UPMAX'                      )\n    When opr='&'       then Return('NXFIND UPMAX'                     )\n    When opr='&\u00ac'      then Return('FLIP XFIND FLIP UPMAX'            )\n    When opr='|\u00ac'      then Return('NFIND UPMAX')\n    Otherwise\n      Exit (ErrorExit('Invalid operator' opr,'opr='opr 'i='i,12))\n   End;\n   Return ('')\n/*--------------------------------------------------------------------*/\nrunCmds: parse arg commands,string,operands\n  target = string operands\n  Do w = 1 to Words(commands)\n   cmd = Word(commands,w)\n   Select;\n    When cmd = 'RESET'  then 'ISREDIT RESET'\n    When cmd = 'SCAN'   then 'ISREDIT SCAN OFF'\n    When cmd = 'FFIND'  then Call runFirstFind target\n    When cmd = 'XALL'   then 'ISREDIT EXCLUDE ALL'\n    When cmd = 'XFIND'  then 'ISREDIT FIND ALL X' target\n    When cmd = 'FLIP'   then 'ISREDIT FLIP'\n    When cmd = 'UPMAX'  then 'ISREDIT UP MAX'\n    When cmd = 'NXFIND' then\n       do r=0 while (getLine(r,'NX')=0);\n        'ISREDIT FIND .ZCSR .ZCSR NX' target\n         if rc=4 then 'ISREDIT FLIP .ZCSR .ZCSR'\n       end\n    When cmd = 'NFIND'  then\n       do r=0 while (getLine(r,'X')=0);\n        'ISREDIT FIND .ZCSR .ZCSR X' target\n        'ISREDIT FLIP .ZCSR .ZCSR'\n       end\n    Otherwise NOP;\n   End;\n  End;\n  Return rc;\n/*----------- Put the cursor on first/next X or NX data line ---------*/\ngetLine: procedure; parse arg crow,status;\n  if crow /= 0 then\n  'ISREDIT (crow,cpos) = CURSOR'\n  do rr = crow+1 until (xstatus=status|cc/=0)\n  'ISREDIT CURSOR = 'rr '0'; cc=rc;\n  'ISREDIT (xstatus) = XSTATUS .ZCSR'\n  end\n  Return cc\n/*--------------------------------------------------------------------*/\nrestoreState: parse arg src\n  'ISREDIT USER_STATE = (user)'\n  'ISREDIT SCAN = 'scan\n  Select;\n   When hcol=0 then src=1\n   When hrow>last then 'ISREDIT LOCATE .ZL'\n   Otherwise do;\n      'ISREDIT CURSOR = (hrow,hcol)'\n      'ISREDIT LOCATE' hrow\n   end;\n  End\n  Return src\n/*--------------------------------------------------------------------*/\ngetEndColumn:\n  Return('72')\n/*--------------------------------------------------------------------*/\ngetStartColumn:\n  Return('1');\n/*--------------------------------------------------------------------*/\ngetFirstChar:\n  Parse Value Space(parms,0) With s1 2 s2 3 .\n  If s1 ='\u00ac' & (s2 = '\"' | s2 = \"'\") then Return(s2)\n  If s1\u00ac='\u00ac' & (s1 = '\"' | s1 = \"'\") then Return(s1)\n  Return('')\n/*--------------------------------------------------------------------*/\nErrorExit: parse arg zedsmsg,zedlmsg,rcode\n  \"ISREDIT RESET\"\n  \"ISPEXEC SETMSG MSG(ISRZ001)\"\n  Return (restoreState(rcode));\n/*--------------------------------------------------------------------*/\nHelp:\n  Do i = 1 by 1 While (Substr(Sourceline(i),1,2)='/*')\n   say Substr(Sourceline(i),3,67)\n  End\n  Return 0\n/*-Debug.--Calls: rc=sayZCSRline(rc) ---------------------------------*/\nsayZCSRLine: procedure; arg src;\n  trace 'o';\n  'ISREDIT (num) = LINENUM .ZCSR';\n  'ISREDIT (row,col) = CURSOR';\n  'ISREDIT (data) = LINE .ZCSR';\n  'ISREDIT (xstatus) = XSTATUS .ZCSR'\n  say src xstatus num col substr(data,1,50)\n  Return src\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "B": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x12&_\\x01\\x12&_\\x06\\x07\\x00\\x08\\x00\\x08\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-21T00:00:00", "modifydate": "2012-09-21T06:07:15", "lines": 8, "newlines": 8, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* B -- browse member/dataset pointed by the cursor on the screen    */\n/*                                                                   */\n/**************************************** Vladimir Mestovski, 2012 ***/\n\"ISREDIT MACRO\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\"VBE BROWSE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "E": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x12&_\\x01\\x12&_\\x06\\x07\\x00\\x08\\x00\\x08\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-21T00:00:00", "modifydate": "2012-09-21T06:07:31", "lines": 8, "newlines": 8, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* E -- edit a member/dataset pointed by the cursor on the screen    */\n/*                                                                   */\n/**************************************** Vladimir Mestovski, 2012 ***/\n\"ISREDIT MACRO (opt) PROCESS\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\"VBE EDIT\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMCLONE": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01X\\x00I\\x01\\x03\\x10o\\x01\\x12'o\\x10!\\x00/\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.88", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:21:49", "lines": 47, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMCLONE clones a member of a PDS                                  */\n/*                                                                   */\n/*  Format: SET CLONEMBR='DSN(MBRclone)'  <-- define before LMCLONEs */\n/*                                                                   */\n/*          LMCLONE 'DSNfrom(MBRfrom)' 'DSNto(MBRto)' \u00ddREPLACE\u00a8      */\n/*                                                                   */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg dsn1 dsn2 opt\nparse var dsn1 \"'\" DSNfrom \"(\" MBRfrom \")'\"\nparse var dsn2 \"'\" DSNto   \"(\" MBRto   \")'\"\nIf DSNfrom = '' | MBRfrom = '' | DSNto = '' | MBRto = '',\n | (opt<>'REPLACE' & opt<>'') then\ndo; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\nsay \"Allocating input dataset '\"DSNfrom\"'...\"\n\"LMINIT DATAID(DDFROM) DATASET('\"DSNfrom\"') ENQ(SHR)\"\n\"LMOPEN  DATAID(\"DDFROM\") OPTION(INPUT)\"\n\"LMMFIND DATAID(\"DDFROM\") MEMBER(\"MBRfrom\") STATS(YES)\"\n\nsay \"Allocating output dataset '\"DSNto\"'...\"\n\"LMINIT DATAID(DDTO)   DATASET('\"DSNto\"')   ENQ(SHR)\"\n\nsay 'Copying member' MBRfrom 'to ' MBRto '...'\n\"LMCOPY FROMID(\"DDFROM\") FROMMEM(\"MBRfrom\") \",\n             \"TODATAID(\"DDTO\"  )   TOMEM(\"MBRto\")\" opt\nsignal off Error\n\nsay 'Editing 'dsn2' with commands taken from CLONEMBR member'\n\"ISPEXEC EDIT DATASET(\"dsn2\") MACRO(MACRO)\"\nsignal on  Error\n\"LMMSTATS DATAID(\"DDTO\") MEMBER(\"MBRto\") USER(\"ZLUSER\") \",\n         \"CREATED(\"ZLCDATE\") MODDATE(\"ZLMDATE\") MODTIME(\"ZLMTIME\")\"\n\"LMFREE DATAID(\"DDFROM\")\"\n\"LMFREE DATAID(\"DDTO\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMFREE DATAID(\"DDFROM\")\"\n \"LMFREE DATAID(\"DDTO\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMCOPY": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00@\\x01\\x12\\x19?\\x01\\x12'o\\x10!\\x00)\\x00\\x1f\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2012-07-11T00:00:00", "modifydate": "2012-10-02T10:21:40", "lines": 41, "newlines": 31, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMCOPY copies a member of a PDS                                   */\n/*  Format: LMCOPY 'DSNfrom(MBRfrom)' 'DSNto(MBRto)' \u00ddREPLACE|BACKUP\u00a8*/\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg \"'\" dsn1 \"'\" . \"'\" dsn2 \"'\" opt\nparse var dsn1 DSNfrom \"(\" MBRfrom \")\"\nparse var dsn2 DSNto   \"(\" MBRto   \")\"\nIf DSNfrom = '' | MBRfrom = '' | DSNto = '' | MBRto = '',\n | (opt<>'REPLACE' & opt<>'BACKUP' & opt<>'') then\ndo; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\nif opt='BACKUP' then call BackUp;\n\nsay \"Allocating input dataset '\"DSNfrom\"'...\"\n\"LMINIT DATAID(DDFROM) DATASET('\"DSNfrom\"') ENQ(SHR)\"\nsay \"Allocating output dataset '\"DSNto\"'...\"\n\"LMINIT DATAID(DDTO)   DATASET('\"DSNto\"')   ENQ(SHR)\"\nsay 'Copying member' MBRfrom 'to ' MBRto '...'\n\"LMCOPY FROMID(\"DDFROM\") FROMMEM(\"MBRfrom\") \",\n             \"TODATAID(\"DDTO\"  )   TOMEM(\"MBRto\")\" opt\n\"LMFREE DATAID(\"DDFROM\")\"\n\"LMFREE DATAID(\"DDTO\")\"\nExit 0;\n\nBackUP:\n opt='';\n export = \"LMEXPORT '\"dsn2\"' TO '\"DSNto\".OBSOLETE'\";\n say \"Running\" export \"...\"\n signal off Error\n Address TSO export;\n return;\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMFREE DATAID(\"DDFROM\")\"\n \"LMFREE DATAID(\"DDTO\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMEDIT": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01W\\x00\\x01\\x01\\x03\\x10o\\x01\\x12\\'o\\x10\"\\x00!\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.87", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:22:01", "lines": 33, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMEDIT edits a member of a PDS with ISPF commands from CLONEMBR   */\n/*                                                                   */\n/*  Format: SET CLONEMBR='DSN(member)'  <-- define before LMEDITs    */\n/*                                                                   */\n/*          LMEDIT 'DSNwhat(MBRwhat)'                                */\n/*                                                                   */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg dsn1 .\nparse var dsn1 \"'\" DSNwhat \"(\" MBRwhat \")'\"\nIf DSNwhat = '' | MBRwhat = '' then\ndo; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\nsay \"Allocating input dataset '\"DSNwhat\"'...\"\n\"LMINIT DATAID(DDWHAT) DATASET('\"DSNwhat\"') ENQ(SHR)\"\n\"LMOPEN  DATAID(\"DDWHAT\") OPTION(INPUT)\"\n\"LMMFIND DATAID(\"DDWHAT\") MEMBER(\"MBRwhat\") STATS(YES)\"\nsignal off Error\n\"ISPEXEC EDIT DATASET(\"dsn1\") MACRO(MACRO)\"\nsignal on  Error\n\"LMMSTATS DATAID(\"DDWHAT\") MEMBER(\"MBRwhat\") USER(\"ZLUSER\") \",\n         \"CREATED(\"ZLCDATE\") MODDATE(\"ZLMDATE\") MODTIME(\"ZLMTIME\")\"\n\"LMFREE DATAID(\"DDWHAT\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMFREE DATAID(\"DDWHAT\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMEXPORT": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00R\\x01\\x03\\x10o\\x01\\x12(?\\x04)\\x00d\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-09T04:29:52", "lines": 100, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMEXPORT moves  a member to OBSOLETE lib supporting $$DIR$$ mbr   */\n/*  Format: LMEXPORT 'DSNfrom(MBRfrom)' TO 'DSNobsolete'             */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg \"'\" DSNfrom \"(\" member \")'\" 'TO' \"'\" DSNto \"'\" .\nIf DSNfrom = '' | member = '' | DSNto = ''\nthen do; say '*ERROR* Invalid syntax'; exit 8; end\n\nparse var DSNfrom hlq'.'proj'.'type .\no=substr(type,1,1)\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\nsay \"Allocating input '\"DSNfrom\"' ...\"\n\"LMINIT  DATAID(DDfrom) DATASET('\"DSNfrom\"') ENQ(SHR)\"\nsay \"Allocating output dataset '\"DSNto\"'...\"\n\"LMINIT DATAID(DDTO)   DATASET('\"DSNto\"')   ENQ(SHRW)\"\n\"LMOPEN  DATAID(\"DDto\") OPTION(INPUT)\"\nsay 'Finding directory member $$DIR$$ ...'\nsignal Off Error\n\"LMMFIND DATAID(\"DDto\") MEMBER($$DIR$$)\"\nif rc<>0 then do;\n if rc=8 then\n do;\n   signal on Error\n   say '*WARNING* Member $$DIR$$ not found, will create...'\n  \"LMCLOSE DATAID(\"DDto\")\"\n  \"LMOPEN  DATAID(\"DDto\") OPTION(OUTPUT)\"\n  entry1=,\n'NewName  OldName              Installation task              Added'\n  entry2=,\n'-------- -------- ------------------------------------ -------------------'\n  \"LMPUT   DATAID(\"DDto\") DATALOC(entry1) DATALEN(\"length(entry1)\") \",\n           \"MODE(INVAR)\"\n  \"LMPUT   DATAID(\"DDto\") DATALOC(entry2) DATALEN(\"length(entry2)\") \",\n           \"MODE(INVAR)\"\n  ZLCNORC=2; ZLUSER=userid()\n  ZLCDATE=date('O'); ZLMDATE=date('O'); ZLMTIME=time();\n  \"LMMADD  DATAID(\"DDto\") MEMBER($$DIR$$) STATS(YES)\"\n  \"LMCLOSE DATAID(\"DDto\")\"\n  \"LMOPEN  DATAID(\"DDto\") OPTION(INPUT)\"\n  \"LMMFIND DATAID(\"DDto\") MEMBER($$DIR$$)\"\n end;\n else Signal Error\nend;\nsay \"Reading directory member $$DIR$$ ...\"\nSignal Off Error\n  maxN=0\n  entry.0=0\n  entry=copies(' ',80)\n  \"LMGET DATAID(\"DDto\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\ndo i=1 by 1 while rc=0\n  entry.i=entry; entry.0=i\n  parse var entry iNewName .\n  parse var iNewName io 2 innnnnnn .\n  if io=o & datatype(innnnnnn,'W')\n   then maxN=max(maxN,innnnnnn)\n  entry=copies(' ',80)\n  \"LMGET DATAID(\"DDto\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\nend;\nif rc<>8 then Signal Error\n\nSignal On Error\nnNewName=o||right(maxN+1,7,'0')\nsay \"New member name will be\" nNewName\"...\"\ni=entry.0+1; entry.0=i;\n\"ISPEXEC VGET (TASK)\"\nif TASK='' then TASK='Installation TASK not defined'\nentry.i=nNewName left(member,8) left(TASK,36),\n        date('S') time()\n\"LMCLOSE DATAID(\"DDto\")\"\n\nsay 'Moving member' member 'as ' nNewName '...'\n\"LMMOVE FROMID(\"DDFROM\") FROMMEM(\"member\") \",\n             \"TODATAID(\"DDTO\"  )   TOMEM(\"nNewName\")\"\n\n\"LMOPEN  DATAID(\"DDto\") OPTION(OUTPUT)\"\n\nsay \"Updating member $$DIR$$ ...\"\ndo i=1 to entry.0\n  entry=entry.i\n  \"LMPUT   DATAID(\"DDto\") DATALOC(entry) DATALEN(\"length(entry)\") \",\n           \"MODE(INVAR)\"\nend;\nZLCNORC=entry.0; ZLUSER=userid()\n  ZLCDATE=date('O'); ZLMDATE=date('O'); ZLMTIME=time();\n\"LMMREP  DATAID(\"DDto\") MEMBER($$DIR$$) STATS(YES)\"\n\n\"LMCLOSE DATAID(\"DDto\")\"\n\"LMFREE  DATAID(\"DDto\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMCLOSE DATAID(\"DDto\")\"\n \"LMFREE DATAID(\"DDto\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMIMPORT": {"ttr": 786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x18\\x01\\x03\\x10o\\x01\\x12\\'o\\x10\"\\x00<\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:22:18", "lines": 60, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMIMPORT restore a member from OBSOLETE lib                       */\n/*  Format: LMIMPORT 'DSNto(MBRto)' FROM 'DSNobsolete' \u00ddREPLACE\u00a8     */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg \"'\" DSNto \"(\" member \")'\" 'FROM' \"'\" DSNfrom \"'\" opt\nIf DSNfrom = '' | member = '' | DSNto = '' |,\n   (opt <> '' & opt <> 'REPLACE')\nthen do; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\nsay \"Allocating input '\"DSNfrom\"' ...\"\n\"LMINIT  DATAID(DDfrom) DATASET('\"DSNfrom\"') ENQ(SHR)\"\n\nsay \"Allocating output '\"DSNto\"'...\"\n\"LMINIT DATAID(DDTO)   DATASET('\"DSNto\"')   ENQ(SHR)\"\n\n\"LMOPEN  DATAID(\"DDfrom\") OPTION(INPUT)\"\nsay 'Finding directory member $$DIR$$ ...'\n\"LMMFIND DATAID(\"DDfrom\") MEMBER($$DIR$$)\"\n\nsay \"Reading directory member $$DIR$$ ...\"\n\nMBRfrom=''\nsignal off error\n\"LMGET DATAID(\"DDfrom\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\ndo i=1 by 1 while rc=0\n  parse var entry iMBRname imember .\n  if imember = member\n   then do; MBRfrom=iMBRname; ientry=entry; end\n  \"LMGET DATAID(\"DDfrom\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\nend;\nif rc<>8 then Signal Error\nSignal On Error\nif MBRfrom='' then\n do; ZERRLM='No entry for' member 'found'; Signal Error; end\n\nsay \"Found\" ientry\n\n\"LMCLOSE DATAID(\"DDfrom\")\"\n\nsay 'Copying member' MBRfrom 'as ' member '...'\n\"LMCOPY FROMID(\"DDFROM\") FROMMEM(\"MBRfrom\") \",\n       \"TODATAID(\"DDTO\"  ) TOMEM(\"member\")\" opt\n\n\"LMFREE  DATAID(\"DDfrom\")\"\n\"LMFREE  DATAID(\"DDto\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMCLOSE DATAID(\"DDfrom\")\"\n \"LMFREE DATAID(\"DDfrom\")\"\n \"LMFREE DATAID(\"DDto\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMMDEL": {"ttr": 788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01N\\x00&\\x01\\x03\\x10o\\x01\\x12\\'o\\x10\"\\x00\\x1b\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.78", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:22:26", "lines": 27, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMMDEL delete a PDS member                                        */\n/*  Format: LMMDEL 'DSNfrom(MBRfrom)'                                */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg dsn1\nparse var dsn1 \"'\" DSNfrom \"(\" MBRfrom \")'\"\nIf DSNfrom = '' | MBRfrom = '' then\ndo; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\nsay \"Allocating input dataset '\"DSNfrom\"'...\"\n\"LMINIT  DATAID(DDFROM) DATASET('\"DSNfrom\"') ENQ(SHRW)\"\n\"LMOPEN  DATAID(\"DDFROM\") OPTION(OUTPUT)\"\nsay 'Deleting member' MBRfrom '...'\n\"LMMDEL  DATAID(\"DDFROM\") MEMBER(\"MBRfrom\")\"\n\"LMCLOSE DATAID(\"DDFROM\")\"\n\"LMFREE  DATAID(\"DDFROM\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMCLOSE DATAID(\"DDFROM\")\"\n \"LMFREE DATAID(\"DDFROM\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMMOVE": {"ttr": 790, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01L\\x005\\x01\\x03\\x10o\\x01\\x12\\'o\\x10\"\\x00\\x1f\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.76", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:22:35", "lines": 31, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMMOVE move a member to other lib                                 */\n/*  Format: LMMOVE 'DSNfrom(MBRfrom)' 'DSNto(MBRto)' \u00ddREPLACE\u00a8       */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg dsn1 dsn2 opt\nparse var dsn1 \"'\" DSNfrom \"(\" MBRfrom \")'\"\nparse var dsn2 \"'\" DSNto   \"(\" MBRto   \")'\"\nIf DSNfrom = '' | MBRfrom = '' | DSNto = '' | MBRto = '',\n | (opt<>'REPLACE' & opt<>'') then\ndo; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\nsay \"Allocating input dataset '\"DSNfrom\"'...\"\n\"LMINIT DATAID(DDFROM) DATASET('\"DSNfrom\"') ENQ(SHR)\"\nsay \"Allocating output dataset '\"DSNto\"'...\"\n\"LMINIT DATAID(DDTO)   DATASET('\"DSNto\"')   ENQ(SHR)\"\nsay 'Moving member' MBRfrom 'to ' MBRto '...'\n\"LMMOVE FROMID(\"DDFROM\") FROMMEM(\"MBRfrom\") \",\n             \"TODATAID(\"DDTO\"  )   TOMEM(\"MBRto\")\" opt\n\"LMFREE DATAID(\"DDFROM\")\"\n\"LMFREE DATAID(\"DDTO\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMFREE DATAID(\"DDFROM\")\"\n \"LMFREE DATAID(\"DDTO\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMMREN": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01R\\x00E\\x01\\x03\\x10o\\x01\\x12\\'o\\x10\"\\x00\\x1b\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.82", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:22:45", "lines": 27, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* LMMREN rename a member of a PDS                                   */\n/*  Format: LMMREN 'DSNfrom(MBRfrom)' NEWNAME(MBRto)                 */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg dsn1 'NEWNAME(' nMBRname ')' .\nparse var dsn1 \"'\" DSNfrom \"(\" MBRfrom \")'\"\nIf DSNfrom = '' | MBRfrom = '' nMBRname = '' then\ndo; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\nsay \"Allocating input dataset '\"DSNfrom\"'...\"\n\"LMINIT  DATAID(DDFROM) DATASET('\"DSNfrom\"') ENQ(SHRW)\"\n\"LMOPEN  DATAID(\"DDFROM\") OPTION(OUTPUT)\"\nsay \"Renaming\" MBRfrom \"to\" nMBRname\" ...\"\n\"LMMREN  DATAID(\"DDFROM\") MEMBER(\"MBRfrom\") NEWNAME(\"nMBRname\")\"\n\"LMCLOSE DATAID(\"DDFROM\")\"\n\"LMFREE  DATAID(\"DDFROM\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMCLOSE DATAID(\"DDFROM\")\"\n \"LMFREE DATAID(\"DDFROM\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LMMSTATS": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00T\\x01\\x12\\x16?\\x01\\x12\\'o\\x10\"\\x00+\\x00/\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2012-06-11T00:00:00", "modifydate": "2012-10-02T10:22:54", "lines": 43, "newlines": 47, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX*****************************************************************/\n/* LMMSTATS changes ISPF statistic of a member in PDS directory       */\n/* Format:                                                            */\n/*  LMMSTATS 'MDCT.PROD.C(A1)' +                                      */\n/*  USER(id) CREATED(11/05/26) MODDATE(11/06/20) MODTIME(07:37)       */\n/******************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg dsn_member opt\nparse var dsn_member \"'\" DSN \"(\" MBR \")'\"\nIf DSN = '' | MBR = '' then\ndo; say '*ERROR* Invalid syntax'; exit 8; end\nparse var opt 'USER(' id ')' .\nparse var opt 'CREATED(' created ')' .\nparse var opt 'MODDATE(' moddate ')' .\nparse var opt 'MODTIME(' modtime ')' .\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\nsignal on  Error\nsay \"Allocating output dataset '\"DSN\"'...\"\n\"LMINIT DATAID(DD)   DATASET('\"DSN\"')   ENQ(SHR)\"\n\"LMOPEN DATAID(\"DD\") OPTION(INPUT)\"\n\"LMMFIND DATAID(\"DD\") MEMBER(\"MBR\") STATS(YES)\"\nsay \"*** Old: USER(\"ZLUSER\") CREATED(\"ZLCDATE\") MODDATE(\"ZLMDATE\")\",\n         \" MODTIME(\"ZLMTIME\")\";\n  if id<>''      then ZLUSER=id\n  if created<>'' then ZLCDATE=created\n  if moddate<>'' then ZLMDATE=moddate\n  if modtime<>'' then ZLMTIME=modtime\n\"LMMSTATS DATAID(\"DD\") MEMBER(\"MBR\") USER(\"ZLUSER\") \",\n         \"CREATED(\"ZLCDATE\") MODDATE(\"ZLMDATE\") MODTIME(\"ZLMTIME\")\"\n\"LMMFIND DATAID(\"DD\") MEMBER(\"MBR\") STATS(YES)\"\nsay \"*** New: USER(\"ZLUSER\") CREATED(\"ZLCDATE\") MODDATE(\"ZLMDATE\")\",\n         \" MODTIME(\"ZLMTIME\")\";\n\"LMFREE DATAID(\"DD\")\"\nExit 0;\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMFREE DATAID(\"DD\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACRO": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x1c\\x00\\x01\\x01\\x12'_\\x01\\x12'o\\x10#\\x00F\\x00F\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.28", "flags": 0, "createdate": "2012-10-01T00:00:00", "modifydate": "2012-10-02T10:23:01", "lines": 70, "newlines": 70, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* MACRO -- execute ISPF Edit commands from a file                   */\n/*                                                                   */\n/*********************************************************************/\ntrace 'O'\nsignal on Error\n\n\"ISREDIT\" 'MACRO (CLONEMBR) PROCESS'\n\"ISPEXEC\" 'CONTROL ERRORS RETURN'\n\nCLONETYP='';\nif CLONEMBR = '' then\n\"ISPEXEC VGET (CLONEMBR)\"\nif CLONEMBR = '' then do;\n say \"*WARNING* SET CLONEMBR was not specicied\"\n Signal MEND\nend\n\nAddress TSO \"ALLOC FI(MACRO) DA('\"CLONEMBR\"') SHR REUSE\"\nsignal off Error\n\"EXECIO * DISKR MACRO (stem file.\"\n if rc<>0 then do;\n  say '*ERROR* Read Error for' CLONEMBR '-- probably not found'\n  signal Error2\n end\n\nsignal on  Error\ndo i=1 to file.0\n\n file.i=strip(file.i)\n if file.i='' then iterate\n\n if substr(file.i,1,2) = '--' then iterate\n if substr(file.i,1,2) = '/*' then iterate\n if substr(file.i,1,1) = '*'  then iterate\n\n Parse Upper Var file.i cmd w1 w2 w3\n if cmd = 'END'    then leave\n if cmd = 'CANCEL' then Signal Error\n if cmd = 'C' | cmd = 'CHANGE' then Do;\n  /*if CLONETYP = 'BACK' then do; w=w2; w2=w1; w1=w; end;*/\n  /*if w3 = '' then w3 = 'ALL' */\n    file.i=file.i 'ALL'\n End\n\nsignal off Error\n \"ISREDIT\" file.i\n\n if rc>4 then Signal Error\n\n  'ISREDIT (c,nc) = CHANGE_COUNTS'\n  if c=0 then Iterate\n  say strip(file.i) ' -- 'c+0 'string(s) changed'\n  if nc/=0 then do;\n   say '*ERROR* 'nc+0 'string(s) that could not be changed'\n   Signal Error;\n  end;\n\nend\nMEND:\n \"ISREDIT END\"\n \"ISREDIT MEND\"\nExit 0\nError:\n say file.i\nError2:\n \"ISREDIT CANCEL\"\n \"ISREDIT MEND\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKE": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00\\x08\\x01\\x105\\x7f\\x01\\x12'\\x9f\\x08E\\x01\\xd1\\x01\\xbc\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2010-12-23T00:00:00", "modifydate": "2012-10-05T08:45:08", "lines": 465, "newlines": 444, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/* MAKE -- run commands from DD:MAKEFILE                              */\n/*                                                                    */\n/********************************************Vladimir Mestovski 2012***/\ntrace 'O'\nSignal On Error\nSignal On Syntax\narg ssid scan .\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\n\n\"MAKEINI\"\nAddress ISPEXEC \"VGET (mkSSID mkJCLLIB mkSQL mkSPUFI)\";\nTASK=''; sqlid=Userid(); maxrc=4; JCLLIB=mkJCLLIB; JOB='';\nCLONEMBR=''; CLONETYP='';\nif ssid='' then ssid=mkSSID;\nAddress ISPEXEC \"VPUT (ssid TASK sqlid maxrc JCLLIB JOB \",\n                      \"CLONEMBR CLONEMBR)\"\nCall ReadCmdFile;\n\nCall CheckSyntax;\nif scan='YES' then do;\n   say '*** MAKE completed SCAN successfully'\n   Exit 0;\nend;\n\neof=0\ncuri=1\nCall GetCmdGroup\nDo while eof=0\n  Select;\n   When cmd = 'SET'      then Call cmdSET\n   When cmd = 'TSO'      then Call cmdTSO\n   When cmd = 'TSO0'     then Call cmdTSO0\n   When cmd = 'QMF'      then Call cmdQMF\n   When cmd = 'REXX'     then Call cmdREXX\n   When cmd = 'DSN'      then Call cmdDSN\n   When cmd = 'FTP'      then Call cmdFTP\n   When cmd = 'SPUFI'    then Call cmdSPUFI\n   When cmd = 'SQL'      then Call cmdSQL\n   When cmd = 'STACK'    then Call cmdSTACK\n   When cmd = '#INCLUDE' then Call cmdINCLUDE\n   When cmd = '//'       then Call cmdJCL\n   When cmd = '#'        then Call cmdComment\n   When cmd = 'EXIT'     then Leave\n   Otherwise\n     say\n     say '*ERROR*' cmdgroup.1\n     say '*ERROR*' \"'\"cmd\"'\" 'is unknown'\n     Signal Error\n  End\n  Call GetCmdGroup\nEnd\n\n  Address TSO \"END\"\n  Address MVS \"DELSTACK\"\n  say '*** MAKE completed'\n  zispfrc = 0\n  'ISPEXEC VPUT (zispfrc)'\n\nexit 0\n/*-------------------------------------------------------------*/\nCheckSyntax:\n Do s=1 to cmdarray.0\n  if substr(cmdarray.s,1,1) = '#'\n  then Parse Var cmdarray.s . tline\n  else Parse Var cmdarray.s tline\n  if scan='YES' then say right(s,4,'0') tline\n  parse var cmdarray.s cmd .\n  if cmd <> 'SET'      &,\n     cmd <> 'TSO'      &,\n     cmd <> 'TSO0'     &,\n     cmd <> 'QMF'      &,\n     cmd <> 'FTP'      &,\n     cmd <> 'REXX'     &,\n     cmd <> 'DSN'      &,\n     cmd <> 'SPUFI'    &,\n     cmd <> 'SQL'      &,\n     cmd <> 'STACK'    &,\n     cmd <> '#INCLUDE' &,\n     cmd <> 'EXIT'     &,\n     cmd <> '#'        &,\n     cmd <> '//'      then do;\n   if scan<>'YES' then\n   do z=1 to s;\n    if substr(cmdarray.z,1,1) = '#'\n    then Parse Var cmdarray.z . tline\n    else Parse Var cmdarray.z tline\n    say right(z,4,'0') tline\n   end\n   say\n   say '*ERROR*' \"'\"cmd\"'\" 'is unknown',\n  '(not in SET,TSO,TSO0,QMF,REXX,DSN,SPUFI,#INCLUDE,STACK,//,EXIT,FTP)'\n   Signal Error\n  end;\n end;\n return\n\n/*-------------------------------------------------------------*/\nGetCmdGroup:\n if curi > cmdarray.0 then do; eof=1; return; end\n c=1;\n cmdgroup.=;\n cmdgroup.1 = cmdarray.curi\n parse var cmdarray.curi cmd .\n Do curi=curi+1 to cmdarray.0\n  parse var cmdarray.curi cmd2 .\n  if cmd<>cmd2 then leave\n  if cmd='#INCLUDE' then leave\n  c=c+1; cmdgroup.c = cmdarray.curi;\n End\n cmdgroup.0=c\n return\n\n/*-------------------------------------------------------------*/\nReadCmdFile:\n 'EXECIO * DISKR MAKEFILE (STEM cmdfile1. FINIS'\n if rc<> 0 then signal Error\n k=0;\n includes = 1;\n Do while includes > 0\n includes = 0;\n do i=1 to cmdfile1.0\n  if word(cmdfile1.i,1)='#INCLUDE' | word(cmdfile1.i,1)='//*#INCLUDE'\n  then do;\n    if word(cmdfile1.i,1)='//*#INCLUDE' then do;\n     k=k+1; cmdfile.k='//';\n     k=k+1;\n     cmdfile.k = '#INCLUDE' word(cmdfile1.i,2) word(cmdfile1.i,3)\n     includes = 1;\n     iterate;\n    end\n    includes = 1;\n    parse var cmdfile1.i . env dsn .\n   'ALLOC FI(MAKEINCL) DA('dsn') REUSE SHR'\n    if rc<> 0 then signal Error\n   'EXECIO * DISKR MAKEINCL (STEM include. FINIS'\n    if rc<> 0 then signal Error\n    lastword = ' ';\n    do in=1 to include.0;\n     if strip(include.in)='' then iterate\n      k=k+1;\n      if word(include.in,1)=env | env='MAKE' | env='MAKEFILE'\n      then cmdfile.k=strip(include.in)\n      else if env<>'SPUFI' & env<>'SQL' &,\n              (lastword = '+' | lastword = '-')\n           then cmdfile.k=strip(include.in)\n           else  cmdfile.k=env strip(include.in)\n      lastword = word(include.in,words(include.in));\n    end\n  end;\n  else do;\n    k=k+1\n    cmdfile.k=cmdfile1.i\n  end\n end\n cmdfile.0=k\n do i=1 to k; cmdfile1.i = cmdfile.i; end; cmdfile1.0=k; k=0;\n End\n k=0; cmdarray.=; cmdarray.0=0;\n do i=1 to cmdfile.0\n  cmd = ''\n  if substr(cmdfile.i,1,2)='//' then\n   do i=i to cmdfile.0\n     cmd ='// 'substr(cmdfile.i,1,72)\n     k=k+1; cmdarray.k=cmd; cmdarray.0=k;\n     if cmd = '// //' then leave\n   end\n  if i>cmdfile.0 then iterate\n  if cmd = '// //' then iterate\n  if substr(cmdfile.i,1,1)='*' then iterate\n  if substr(cmdfile.i,1,1)='#' then cmdfile.i='# 'cmdfile.i\n  cmd=strip(cmdfile.i)\n  cmdlen=length(cmd)\n  if cmdlen=0 then iterate\n  cmdcont=substr(cmd,cmdlen,1)\n  if cmdcont='+' then\n  do i=i+1 to cmdfile.0\n   parse var cmd cmd '+'\n   if substr(cmdfile.i,1,1)='*' then iterate\n   cmd2=strip(cmdfile.i)\n   if cmdlen=0 then leave\n   cmd=cmd||cmd2\n   cmdlen=length(cmd)\n   cmdcont=substr(cmd,cmdlen,1)\n   if cmdcont<>'+' then leave\n  end;\n  k=k+1; cmdarray.k=cmd; cmdarray.0=k;\n end;\n if cmdarray.0=0 then do;\n   say '*ERROR* Make file does not have any command to execute'\n   Signal Error\n end\n return\n\n/*-------------------------------------------------------------*/\ncmdTSO0:\n Signal Off Error\n do i=1 to cmdgroup.0\n say ''\n say date('S') time() copies('-',50)\n say ''\n   say cmdgroup.i\n   parse var cmdgroup.i . curcmd\n   address TSO curcmd\n end\n return\n/*-------------------------------------------------------------*/\ncmdREXX:\ncmdTSO:\n if maxrc<>0 then Signal Off Error\n do i=1 to cmdgroup.0\n say ''\n say date('S') time() copies('-',50)\n say ''\n   say cmdgroup.i\n   parse var cmdgroup.i . curcmd\n   address TSO curcmd\n   if rc<> 0 then say '*** RC = 'rc\n   if rc<0 | rc>maxrc then Signal Error\n end\n return\n/*-------------------------------------------------------------*/\ncmdSTACK:\n Address MVS \"DELSTACK\"\n do i=1 to cmdgroup.0\n   parse var cmdgroup.i . 7 curcmd\n   say cmdgroup.i\n   QUEUE curcmd\n end\n return\n/*-------------------------------------------------------------*/\ncmdSPUFI:\n say ''\n say date('S') time() copies('-',50)\n say ''\n say \"DSN SYSTEM (\"ssid\")\"\n if maxrc<>0 then Signal Off Error\n do i=1 to cmdgroup.0\n  say cmdgroup.i\n  parse var cmdgroup.i . curcmd\n  if curcmd='' then curcmd=' ';\n  Queue curcmd\n end\n Queue \"END\"\n Queue \"\"\n Address MVS \"EXECIO * DISKW SYSIN (FINIS)\"\n Queue \"RUN\" mkSPUFI \"PARMS('ALIGN(LHS)')\"\n Address TSO \"DSN SYSTEM (\"ssid\")\"\n if rc<> 0 then say '*** RC = 'rc\n if rc<0 | rc>maxrc then Signal Error\n Address MVS \"DELSTACK\"\nreturn\n/*-------------------------------------------------------------*/\ncmdSQL:\n say ''\n say date('S') time() copies('-',50)\n say ''\n say \"DSN SYSTEM (\"ssid\")\"\n if maxrc<>0 then Signal Off Error\n do i=1 to cmdgroup.0\n  say cmdgroup.i\n  parse var cmdgroup.i . curcmd\n  if curcmd='' then curcmd=' ';\n  Queue curcmd\n end\n/* Queue \"END\" */\n Queue \"\"\n Address MVS \"EXECIO * DISKW INSQL (FINIS)\"\n Queue \"RUN\" mkSQL\n Address TSO \"DSN SYSTEM (\"ssid\")\"\n if rc<> 0 then say '*** RC = 'rc\n if rc<0 | rc>maxrc then Signal Error\n Address MVS \"DELSTACK\"\nreturn\n/*-------------------------------------------------------------*/\ncmdComment:\n say ''\n do i=1 to cmdgroup.0\n  parse var cmdgroup.i . curcmd\n  say curcmd\n end\n return\n/*-------------------------------------------------------------*/\ncmdSET:\n say ''\n say date('S') time() copies('-',50)\n say ''\n do i=1 to cmdgroup.0\n   say cmdgroup.i\n   parse var cmdgroup.i . curcmd\n   parse var curcmd label'='val\n   if label = ''  then do;\n    say '*ERROR* Invalid syntax'\n    signal error\n   end\n   Interpret curcmd;\n   'ISPEXEC VPUT ('label')'\n end\n return\n/*-------------------------------------------------------------*/\ncmdINCLUDE:\n say ''\n say date('S') time() copies('-',50)\n say ''\n   say cmdgroup.1\n   parse var cmdgroup.1 . env dsn .\n   'ALLOC FI(MAKEINCL) DA('dsn') REUSE SHR'\n    if rc<> 0 then signal Error\n   'EXECIO * DISKR MAKEINCL (STEM cmdgroup. FINIS'\n    if rc<> 0 then signal Error\n    do i=1 to cmdgroup.0\n     cmdgroup.i=env cmdgroup.i\n    end;\n  Select;\n   When env = 'QMF'     then Call cmdQMF\n   When env = 'SPUFI'   then Call cmdSPUFI\n   When env = 'SQL'     then Call cmdSQL\n   When env = 'DSN'     then Call cmdDSN\n   Otherwise\n     say\n     say '*ERROR*' cmdgroup.1\n     say '*ERROR*' \"'\"env\"'\" 'is unknown, not in QMF,SPUFI,DSN,SQL'\n     Signal Error\n  End\n return\n/*-------------------------------------------------------------*/\ncmdDSN:\n say ''\n say date('S') time() copies('-',50)\n say ''\n parse var cmdgroup.1 w1 w2 '(' w3 ')' .\n if w1='DSN'& w2='SYSTEM'\n  then do; tsocmd = cmdgroup.1;            starti=2;end\n  else do; tsocmd = \"DSN SYSTEM (\"ssid\")\"; starti=1; end\n say tsocmd\n if maxrc<>0 then Signal Off Error\n do i=starti to cmdgroup.0\n  say cmdgroup.i\n  parse var cmdgroup.i . curcmd\n  Queue curcmd\n end\n Queue \"END\"\n Queue \"\"\n Address TSO tsocmd\n if rc<> 0 then say '*** RC = 'rc\n if rc<0 | rc>maxrc then Signal Error\n Address MVS \"DELSTACK\"\nreturn\n/*-------------------------------------------------------------*/\ncmdFTP:\n say ''\n say date('S') time() copies('-',50)\n say ''\n if maxrc<>0 then Signal Off Error\n do i=2 to cmdgroup.0\n  say cmdgroup.i\n  parse var cmdgroup.i . curcmd\n  Queue curcmd\n end\n Queue \"QUIT\"\n Queue \"\"\n Address TSO cmdgroup.1\n if rc<> 0 then say '*** RC = 'rc\n if rc<0 | rc>maxrc then Signal Error\n Address MVS \"DELSTACK\"\nreturn\n/*-------------------------------------------------------------*/\n/*-------------------------------------------------------------*/\ncmdJCL:\n say ''\n say date('S') time() copies('-',50)\n say ''\n jobi = 0; jcl.=''; jcl.0=0;\n do i=1 to cmdgroup.0\n  parse var cmdgroup.i . curcmd\n  if i=1 & word(curcmd,2) <> 'JOB' then\n  do;\n    if JOB = '' then jobname = userid()'X'; else jobname = JOB;\n    JOB = '';\n    do j=1 to 3\n      Address \"ISPEXEC\" 'VGET (mkJCL'j')';\n      jcl.j=value('mkJCL'j)\n      x=SetVar('_mkJOB',jobname)\n      x=SetVar('_mkJCLLIB',JCLLIB)\n      x=SetVar('_sysuid',userid())\n  say jcl.j\n    end;\n    jcl.0=3;\n  end;\n  jobi=jcl.0+1; jcl.jobi=curcmd; say curcmd;  jcl.0=jobi;\n end\n tempjcl = 'TEMP.JCL'\n Signal Off Error\n x=outtrap('o.')\n 'DELETE 'tempjcl\n x=outtrap('OFF')\n Signal On  Error\n Address TSO \"ALLOC FI(TEMPJCL) DA(\"tempjcl\") REUSE NEW CATALOG\",\n             \"UNIT(SYSDA) RECFM(F B) LRECL(80) DSORG(PS) \",\n             \"SPACE(5,5) CYLINDERS RELEASE\"\n \"EXECIO * DISKW TEMPJCL (stem jcl. FINIS\"\n if maxrc<>0 then Signal Off Error\n 'WSUBMIT' tempjcl\n if rc<> 0 then say '*** RC = 'rc\n if rc<0 | rc>maxrc then Signal Error\n x=outtrap('o.')\n 'DELETE 'tempjcl\n x=outtrap('OFF')\nreturn\n\nSetVar: parse arg what,towhat\n  p=index(jcl.j,what);\n  if p>0 then\n  jcl.j=substr(jcl.j,1,p-1)||towhat||substr(jcl.j,p+length(what))\n  return 0;\n/*-------------------------------------------------------------*/\ncmdQMF:\n Signal Off Error\n say ''\n say date('S') time() copies('-',50)\n say ''\n say 'QMF START (S='ssid 'DSQSCMD=DSQSCMDE DSQSMODE=BATCH'\n CALL DSQCIX 'START (S='ssid 'DSQSCMD=DSQSCMDE DSQSMODE=BATCH'\n IF DSQ_RETURN_CODE <> DSQ_SUCCESS THEN CALL PGMEXIT 8\n do i=1 to cmdgroup.0\n   say cmdgroup.i\n   parse var cmdgroup.i . curcmd\n   if substr(curcmd,1,2)='--' then iterate\n   parse var curcmd curcmd ' --' .\n   CALL DSQCIX curcmd\n   IF DSQ_RETURN_CODE <> DSQ_SUCCESS THEN DO;\n    SAY DSQ_MESSAGE_TEXT\n    CALL PGMEXIT 8\n   END;\n   IF WORD(DSQ_MESSAGE_TEXT,1) <> 'OK,' THEN DO;\n    SAY DSQ_MESSAGE_TEXT\n    IF INDEX(DSQ_MESSAGE_TEXT,'ABEND') > 0 THEN\n    CALL PGMEXIT 8\n   END\n end\n CALL DSQCIX 'EXIT'\n return\n PGMEXIT:\n   ARG RETCODE\n   ZERRLM = \"see DSQDEBUG output for detail info.\"\n   say\n   say '*ERROR* RC='DSQ_RETURN_CODE strip(ZERRLM)\n   CALL DSQCIX 'EXIT'\n   Signal Error\n/*-------------------------------------------------------------*/\nError:\n  Address TSO \"END\"\n  Address MVS \"DELSTACK\"\nError2:\n  say\n  say '*ERROR* MAKE failed'\n  say\n  zispfrc = 12\n  'ISPEXEC VPUT (zispfrc)'\n  Exit 0   /* zispfrc */\nSyntax:\n  say 'REXX error' rc 'in line' sigl':' \"ERRORTEXT\"(rc)\n  say \"SOURCELINE\"(sigl)\n  signal Error2\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEINI": {"ttr": 1282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01A\\x00B\\x01\\x11\\x12_\\x01\\x12'\\x9f\\x10\\x16\\x00?\\x00\\x87\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.65", "flags": 0, "createdate": "2011-05-05T00:00:00", "modifydate": "2012-10-05T10:16:42", "lines": 63, "newlines": 135, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* MAKEINI -- '.ini' file for MAKE tool                              */\n/*                                                                   */\n/*  Please adjust assignments before using MAKE tools                */\n/*                                                                   */\n/*************************************** Vladimir Mestovski 2012 *****/\n/*-------------------------------------------------------------------*/\n/*<---------------- S T A R T  OF ADJUSTMENTS ---------------------->*/\n/* 1. JCL variables                                                  */\n/*-------------------------------------------------------------------*/\n dsnload = 'SYS1.DB2A.DSNLOAD'        /* DSN command                 */\ndbrunlib = 'DB2.DB2A.DB2.RUNLIB.LOAD' /* IBM sample programs         */\n sysproc = 'MDCT.HOLD.VM.REXX'        /* this MAKE tool              */\nsleeplib = 'MDCT.HOLD.BPIPE.LINKLIB'  /* SLEEP was added here        */\n/*-------------------------------------------------------------------*/\n/* 2. MAKE variables                                                 */\n/*-------------------------------------------------------------------*/\nmkSSID   = 'DB2E'                            /* DSN SYSTEM(ssid)     */\nmkJCLLIB = 'SYS1.PROCLIB';                   /* default for '//'cmd  */\nmkSQL    = \"PROGRAM(BSPUFI) PLAN(BSPUFI)\",   /* CBT484 FILE866       */\n           \" LIB('MDCT.HOLD.VM.LOADLIB') \";  /* your loadlib         */\nmkSPUFI  = 'PROGRAM(DSNTEP2) PLAN(DSNTEP2)'  /* IBM Sample program   */\n/*-------------------------------------------------------------------*/\n/* 3. Template for a MAKEnnn job submitted by the MAKESUB command    */\n/*-------------------------------------------------------------------*/\nj.1 =\"//_mkJOB JOB ($29HKZA,BIN333,EFK334,DEPTHKZA),'MAKETOOL',\"\nj.2 =\"// TIME=(10),MSGLEVEL=(1,1),MSGCLASS=H,NOTIFY=_sysuid\"\nj.3 =\"// JCLLIB ORDER=(_mkJCLLIB)\"\nj.4 =\"//MAKE    EXEC QMFBATCH,PARM='ISPSTART CMD(%MAKE _mkSSID)'\"\nj.5 =\"//STEPLIB  DD DSN=\"dsnload\",DISP=SHR\"\nj.6 =\"//         DD DSN=\"dbrunlib\",DISP=SHR\"\nj.7 =\"//         DD DSN=\"sleeplib\",DISP=SHR\"\nj.8 =\"//*\"\nj.9 =\"//SYSPROC  DD DSN=\"sysproc\",DISP=SHR\"\nj.10=\"//MAKEFILE DD DSN=_mkCMD,DISP=(OLD,_mkDELETE)\"\nj.11=\"//SYSIN    DD DSN=&&TMP1,DISP=NEW,DSORG=PS,\"\nj.12=\"//            RECFM=FB,LRECL=80,UNIT=SYSDA\"\nj.13=\"//INSQL    DD DSN=&&TMP2,DISP=NEW,DSORG=PS,\"\nj.14=\"//            RECFM=FB,LRECL=80,UNIT=SYSDA\"\nj.15=\"//DSQSPILL DD DSN=&&SPILL,SPACE=(CYL,(1500,500),RLSE),\"\nj.16=\"//            DISP=(,KEEP,DELETE),UNIT=SYSDA,\"\nj.17=\"//            DCB=(LRECL=4096,BLKSIZE=4096,RECFM=F)\"\nj.18=\"//SYSPRINT DD SYSOUT=*,LRECL=1000\"\nj.19=\"//SYSTSPRT DD SYSOUT=*\"\nj.20=\"//SYSTSIN  DD DUMMY\"\nj.21=\"//CEEDUMP  DD DUMMY\"\nj.22=\"//\"\nj.0=22\n/********************** E N D  OF ADJUSTMENTS ************************/\n\nAddress \"ISPEXEC\"\n\"VPUT (mkSSID)   PROFILE\"\n\"VPUT (mkSQL )   PROFILE\"\n\"VPUT (mkSPUFI)  PROFILE\"\n\"VPUT (mkJCLLIB) PROFILE\"\n mkJCL0=j.0\n\"VPUT (mkJCL0)  PROFILE\"\ndo i=1 to j.0\n  interpret 'mkJCL'i'=j.i'\n  \"VPUT (mkJCL\"i\") PROFILE\"\nend;\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKESCAN": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0f\\x001\\x01\\x10&o\\x01\\x12'o\\x10#\\x00\\x0e\\x00g\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.15", "flags": 0, "createdate": "2010-09-23T00:00:00", "modifydate": "2012-10-02T10:23:31", "lines": 14, "newlines": 103, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* MAKESCAN -- check syntax of a make file                           */\n/*                                                                   */\n/* When your make file is on the screen in V/E mode, run MAKESCAN    */\n/* from the the command line to submit a MAKEnn batch job that will  */\n/* check file for missing '+' chars (continuations)                  */\n/*                                                                   */\n/* Note. Excluded lines by X/XX prefix command(s) are ignored.       */\n/******************************************Vladimir Mestovski 2012****/\n\"ISREDIT MACRO (opt) PROCESS\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\nCALL \"MAKESUB\" \"SCAN\"\n\"ISREDIT MEND\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKESUB": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x003\\x01\\x12'\\x9f\\x01\\x12'\\x9f\\tY\\x00\\xa7\\x00\\xb0\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-10-05T00:00:00", "modifydate": "2012-10-05T09:59:33", "lines": 167, "newlines": 176, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* MAKESUB -- Submit a make file.                                    */\n/*                                                                   */\n/*  When you Edit/View a make file, type MAKESUB in the command line */\n/*  to submit a MAKEnnn batch job which will execute the file.       */\n/*                                                                   */\n/* Format:                                                           */\n/*   MAKESUB \u00ddenv \u00ddssid\u00a8\u00a8    i.e \u00ddQMF|SQL|SPUFI|TSO|DSN... \u00ddDB2A\u00a8\u00a8   */\n/*                                                                   */\n/* Note. 1. Excluded lines with X/XX prefix command(s) are bypassed. */\n/*       2. MAKESUB 'dsn' --  format to run as a TSO command.        */\n/****************************************Vladimir Mestovski 2012******/\n\ntrace 'O'\n Parse UPPER SOURCE . cmdtype .\n datedsn = '.J'Date('J')\n timedsn = '.S'Time('S')\n makejob = 'MAKE'Time('M')\n makecmd = Userid()||'.TEMP.MAKE.CMD'||datedsn||timedsn\n makejcl = Userid()||'.TEMP.MAKE.JCL'||datedsn||timedsn\n\n Address \"TSO\"\n \"MAKEINI\"\n mkSSID=''\n \"ISPEXEC VGET (mkSSID)\"\n if mkSSID='' then do;\n  say \"*ERROR* MAKEINI member probably has been corrupted..\"\n  exit 8;\n end;\n\n if arg() > 0 & substr(arg(1),1,1)=\"'\" then do;\n/*------------------ as a TSO command ------------------------------*/\n/* MAKESUB 'dsn'        <-- your make file                          */\n/*------------------------------------------------------------------*/\n  parse upper arg \"'\" makecmd \"'\"\n  x = Outtrap('o.')\n \"DELETE '\"makejcl\"'\"\n 'FREE FI($MAKEJCL)'\n \"ALLOCATE FI($MAKEJCL) DSNAME('\"makejcl\"')\",\n      ' NEW DSORG(PS) RECFM(F,B) LRECL(80) ',\n      ' SPACE(1,1) TRACKS    RELEASE UNIT(SYSDA) CATALOG'\n  x = Outtrap('OFF')\n  Call filljob;\n 'EXECIO * DISKW $MAKEJCL (FINIS STEM jcl.'\n  If rc<> 0 then exit 12\n 'FREE FI($MAKEJCL)'\n \"SUBMIT '\"makejcl\"'\"\n  x = Outtrap('o.')\n \"DELETE '\"makejcl\"'\"\n  x = Outtrap('OFF')\n  Exit 0\nend\n\n/*--------------------- inside View/Edit session -------------------*/\n/* MAKESUB \u00ddenv \u00ddssid\u00a8\u00a8    i.e \u00ddQMF|SQL|SPUFI|TSO..  \u00ddDB2A\u00a8\u00a8        */\n/*------------------------------------------------------------------*/\n if cmdtype='SUBROUTINE' then OPT1=arg(1);\n if cmdtype='COMMAND' then\n \"ISREDIT\" 'MACRO (OPT1) PROCESS';\n \"ISPEXEC\" 'CONTROL ERRORS RETURN'\n 'ISREDIT (user) = USER_STATE'\n 'ISREDIT (hrow,hcol) = CURSOR'\n 'ISREDIT (scan) = SCAN'\n 'ISREDIT SCAN OFF'\n 'ISREDIT (LAST) = LINENUM .ZLAST'\n 'ISREDIT (LRECL) = LRECL'\n\n if datatype(LAST)='CHAR' then do;\n  say \"*ERROR* YOU should remove pending prefix commands first..\"\n  exit 8;\n end;\n\n env = ''\n this_ssid = ''\n if opt1<>'' then do;\n    parse upper var opt1 env this_ssid .\n    env=env||' ';\n end;\n if this_ssid<>'' then mkSSID=this_ssid;\n if env='SCAN'    then do; mkSSID=mkSSID 'YES'; env=''; end;\n if env='PREPARE' then do; env=''; delete='KEEP'; end;\n\n k=0\n do i = 1 to LAST\n  \"ISREDIT\" '(statusx) = XSTATUS' i\n  if statusx = 'X' then iterate\n  \"ISREDIT\" '(DATA) = LINE' i\n  k=k+1\n  lines.k = env||DATA\n end\n lines.0=k\n\n x = Outtrap('o.')\n \"DELETE '\"makecmd\"'\"\n \"DELETE '\"makejcl\"'\"\n 'FREE FI($MAKECMD)'\n 'FREE FI($MAKEJCL)'\n \"ALLOCATE FI($MAKECMD) DSNAME('\"makecmd\"')\",\n     ' NEW DSORG(PS) RECFM(V,B) LRECL(256) ',\n     ' SPACE(1,1) CYLINDERS RELEASE UNIT(SYSDA) CATALOG'\n \"ALLOCATE FI($MAKEJCL) DSNAME('\"makejcl\"')\",\n     ' NEW DSORG(PS) RECFM(F,B) LRECL(80) ',\n     ' SPACE(1,1) TRACKS    RELEASE UNIT(SYSDA) CATALOG'\n x = Outtrap('OFF')\n\n 'EXECIO * DISKW $MAKECMD (FINIS STEM lines.'\n If rc>1   then exit (restoreState(rc))\n 'FREE FI($MAKECMD)'\n\n Call filljob;\n\n 'EXECIO * DISKW $MAKEJCL (FINIS STEM jcl.'\n If rc>1   then exit (restoreState(rc))\n 'FREE FI($MAKEJCL)'\n\n if cmdtype='COMMAND' | OPT1='SCAN' then do;\n  \"SUBMIT '\"makejcl\"'\"\n  x = Outtrap('o.')\n  \"DELETE '\"makejcl\"'\"\n  x = Outtrap('OFF')\n End;\n Else \"ISPEXEC VPUT (makejcl)\"\n\n exit (restoreState(0))\n\n/*--------------------------------------------------------------------*/\nrestoreState: parse arg src\n  'ISREDIT USER_STATE = (user)'\n  'ISREDIT SCAN = 'scan\n  Select;\n   When hcol=0 then src=1\n   When hrow>last then 'ISREDIT LOCATE .ZL'\n   Otherwise 'ISREDIT CURSOR = (hrow,hcol)'\n  End\n if cmdtype='COMMAND' then \"ISREDIT MEND\"\nReturn src\n\n/*--------------------------------------------------------------------*/\nfilljob:\n trace 'O'\n mkJCL0=0;\n Address \"ISPEXEC\"\n 'VGET (mkJCL0)'\n c.0=mkJCL0\n do i=1 to mkJCL0\n  'VGET (mkJCL'i')';\n  c.i=value('mkJCL'i)\n end;\n 'VGET (mkJCLLIB)'\n Do i=1 to c.0\n jcl.i=c.i\n x=SetVar('_mkJOB',makejob)\n x=SetVar('_mkSSID',mkSSID)\n x=SetVar('_mkJCLLIB',mkJCLLIB)\n x=SetVar('_mkCMD',makecmd)\n x=SetVar('_mkDELETE',delete)\n x=SetVar('_sysuid',Userid())\n End;\n jcl.0=c.0\n return;\n\nSetVar: parse arg what,towhat\n  p=index(jcl.i,what);\n  if p>0 then\n  jcl.i=substr(jcl.i,1,p-1)||towhat||substr(jcl.i,p+length(what))\n  return 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QEXPORT": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00H\\x01\\x03\\x10o\\x01\\x12'o\\x10#\\x00}\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:23:48", "lines": 125, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* QEXPORT export a QMF object using $$DIR$$ member                  */\n/*  Format:         QUERY                                            */\n/*          QEXPORT PROC    QMFname  TO 'DSNto' \u00dd(ERASE\u00a8             */\n/*                  FORM                                             */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg QMFobj QMFname ' TO ' \"'\" DSNto \"'\" \"(\" ERASE .\nparse var ERASE ERASE .\nparse var QMFname QMFname .\nIf DSNto = '' | QMFobj = '' ,\n | (QMFobj<>'PROC' & QMFobj<>'QUERY' & QMFobj<>'FORM')\nthen do; say '*ERROR* Invalid syntax'; exit 8; end\nIf ERASE <> '' & ERASE <> 'ERASE'\nthen do; say '*ERROR* Invalid syntax:' ERASE; exit 8; end\n\no=substr(QMFobj,1,1)\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\nsay \"Allocating library '\"DSNto\"' ...\"\n\"LMINIT  DATAID(DDto) DATASET('\"DSNto\"') ENQ(SHRW)\"\n\"LMOPEN  DATAID(\"DDto\") OPTION(INPUT)\"\nsay 'Finding directory member $$DIR$$ ...'\nsignal Off Error\n\"LMMFIND DATAID(\"DDto\") MEMBER($$DIR$$)\"\nif rc<>0 then do;\n if rc=8 then\n do;\n   signal on Error\n   say '*WARNING* Member $$DIR$$ not found, will create...'\n  \"LMCLOSE DATAID(\"DDto\")\"\n  \"LMOPEN  DATAID(\"DDto\") OPTION(OUTPUT)\"\nentry='MBRname  QMFtype QMFname                     Date     Time '\n  \"LMPUT   DATAID(\"DDto\") DATALOC(entry) DATALEN(\"length(entry)\") \",\n           \"MODE(INVAR)\"\nentry='-------- ------- --------------------------- -------- --------'\n  \"LMPUT   DATAID(\"DDto\") DATALOC(entry) DATALEN(\"length(entry)\") \",\n           \"MODE(INVAR)\"\n  ZLCNORC=2; ZLUSER=userid()\n  ZLCDATE=date('O'); ZLMDATE=date('O'); ZLMTIME=time();\n  \"LMMADD  DATAID(\"DDto\") MEMBER($$DIR$$) STATS(YES)\"\n  \"LMCLOSE DATAID(\"DDto\")\"\n  \"LMOPEN  DATAID(\"DDto\") OPTION(INPUT)\"\n  \"LMMFIND DATAID(\"DDto\") MEMBER($$DIR$$)\"\n end;\n else Signal Error\nend;\nsay \"Reading directory member $$DIR$$ ...\"\nSignal Off Error\n  maxN=0\n  entry.0=0\n  entry=copies(' ',79)\n  \"LMGET DATAID(\"DDto\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\ndo i=1 by 1 while rc=0\n  entry.i=entry; entry.0=i\n  parse var entry iMBRname iQMFobj iQMFname .\n  parse var iMBRname io 2 innnnnnn .\n  if io=o & iQMFobj = QMFobj & datatype(innnnnnn,'W')\n   then maxN=max(maxN,innnnnnn)\n  entry=copies(' ',79)\n  \"LMGET DATAID(\"DDto\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\nend;\nif rc<>8 then Signal Error\nSignal On Error\nnMBRname=o||right(maxN+1,7,'0')\nsay \"New member name will be\" nMBRname\"...\"\ni=entry.0+1; entry.0=i;\nentry.i=nMBRname left(QMFobj,7) left(QMFname,max(27,length(QMFname))),\n        date('S') time()\n\"LMCLOSE DATAID(\"DDto\")\"\n\nsay \"Running\" \"EXPORT\" QMFobj QMFname \"TO '\"DSNto\"($$TMP$$)' (C=N\"\n\"VGET (ssid)\";\nSignal Off Error\nCALL DSQCIX 'START (S='ssid 'DSQSCMD=DSQSCMDE DSQSMODE=BATCH'\nIF DSQ_RETURN_CODE <> DSQ_SUCCESS THEN CALL PGMEXIT 8\nCALL DSQCIX \"EXPORT\" QMFobj QMFname \"TO '\"DSNto\"($$TMP$$)' (C=N\"\nIF DSQ_RETURN_CODE <> DSQ_SUCCESS THEN CALL PGMEXIT 8\nCALL DSQCIX \"EXIT\"\nSignal On  Error\n\n\"LMOPEN  DATAID(\"DDto\") OPTION(OUTPUT)\"\n\nsay \"Updating member $$DIR$$ ...\"\ndo i=1 to entry.0\n  entry=entry.i\n  \"LMPUT   DATAID(\"DDto\") DATALOC(entry) DATALEN(\"length(entry)\") \",\n           \"MODE(INVAR)\"\nend;\nZLCNORC=entry.0; ZLUSER=userid()\n  ZLCDATE=date('O'); ZLMDATE=date('O'); ZLMTIME=time();\n\"LMMREP  DATAID(\"DDto\") MEMBER($$DIR$$) STATS(YES)\"\n\nsay \"Renaming $$TMP$$ to \"nMBRname\" ...\"\n\"LMMREN  DATAID(\"DDto\") MEMBER($$TMP$$) NEWNAME(\"nMBRname\")\"\n\n\"LMCLOSE DATAID(\"DDto\")\"\n\"LMFREE  DATAID(\"DDto\")\"\n\nIf ERASE = 'ERASE' then do;\n say \"Running\" \"ERASE\" QMFobj QMFname \"(C=N\"\n Signal Off Error\n CALL DSQCIX 'START (S='ssid 'DSQSCMD=DSQSCMDE DSQSMODE=BATCH'\n IF DSQ_RETURN_CODE <> DSQ_SUCCESS THEN CALL PGMEXIT 8\n CALL DSQCIX \"ERASE\" QMFobj QMFname \"(C=N\"\n IF DSQ_RETURN_CODE <> DSQ_SUCCESS THEN CALL PGMEXIT 8\n CALL DSQCIX \"EXIT\"\n Signal On  Error\nend;\n\nExit 0;\n\nPGMEXIT:\n  ARG RETCODE\n  CALL DSQCIX 'EXIT'\n  ZERRLM = \"see DSQDEBUG output for detail info.\"\n  Signal Error\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMCLOSE DATAID(\"DDto\")\"\n \"LMFREE DATAID(\"DDto\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QIMPORT": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00\\x03\\x01\\x12'o\\x01\\x12'o\\x10$\\x00X\\x00X\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2012-10-02T00:00:00", "modifydate": "2012-10-02T10:24:03", "lines": 88, "newlines": 88, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* QIMPORT import a QMF object using $$DIR$$ member                  */\n/*  Format:         {QUERY}                                          */\n/*          QIMPORT {PROC }  QMFname  FROM 'DSNfrom' \u00ddBACKUP\u00a8        */\n/*                  {FORM }                                          */\n/*                                                                   */\n/* where BACKUP asks to run                                          */\n/*                  {QUERY}                                          */\n/*          QEXPORT {PROC }  QMFname  TO 'DSNfrom.OBSOLETE'          */\n/*                  {FORM }                                          */\n/*****************************************************************VM**/\ntrace 'O'\nsignal on Error\nparse arg QMFobj QMFname ' FROM ' \"'\" DSNfrom \"'\" opt .\nparse var QMFname QMFname .\nIf DSNfrom = '' | QMFobj = '' ,\n | (QMFobj<>'PROC' & QMFobj<>'QUERY' & QMFobj<>'FORM'),\n | (opt<>'' & opt <> 'BACKUP')\nthen do; say '*ERROR* Invalid syntax'; exit 8; end\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\nsay \"Allocating library '\"DSNfrom\"' ...\"\n\"LMINIT  DATAID(DDfrom) DATASET('\"DSNfrom\"') ENQ(SHRW)\"\n\"LMOPEN  DATAID(\"DDfrom\") OPTION(INPUT)\"\n\nsay 'Finding directory member $$DIR$$ ...'\n\"LMMFIND DATAID(\"DDfrom\") MEMBER($$DIR$$)\"\n\nsay \"Reading directory member $$DIR$$ ...\"\nMBRname=''\nsignal off error\n\"LMGET DATAID(\"DDfrom\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\ndo i=1 by 1 while rc=0\n  parse var entry iMBRname iQMFobj iQMFname .\n  if iQMFobj = QMFobj & iQMFname = QMFname\n   then MBRname=iMBRname\n  \"LMGET DATAID(\"DDfrom\") DATALOC(entry) DATALEN(entrylen)\" ,\n           \"MODE(INVAR) MAXLEN(5000)\"\nend;\nif rc<>8 then Signal Error\nSignal On Error\nif MBRname='' then\n do; ZERRLM='No entry for' QMFobj QMFname; Signal Error; end\n\nsay \"Found directory entry with\" MBRname QMFobj QMFname\n\n\"VGET (ssid)\";\nif opt='BACKUP' then Call BackUp;\n\nCall QMF  'START (S='ssid 'DSQSCMD=DSQSCMDE DSQSMODE=BATCH'\nCall QMF  \"IMPORT\" QMFobj \"FROM '\"DSNfrom\"(\"MBRname\")'\"\nCall QMF  \"SAVE\" QMFobj \"AS \" QMFname \"(CONFIRM=NO SHARE=YES\"\nCall QMF  \"EXIT\"\n\n\"LMCLOSE DATAID(\"DDfrom\")\"\n\"LMFREE  DATAID(\"DDfrom\")\"\nExit 0;\n\nQMF:\n  Signal Off Error\n  arg qcmd\n  say \"Running\" qcmd \"...\"\n  CALL DSQCIX qcmd\n  IF DSQ_RETURN_CODE <> DSQ_SUCCESS THEN CALL PGMEXIT 8\nreturn\n\nBackUp:\n opt='';\n export=\"QEXPORT\" QMFobj QMFname,\n          \"TO '\"DSNfrom\".OBSOLETE'\"\n say \"Running\" export \"...\"\n Address TSO export;\n return;\n\nPGMEXIT:\n  ARG RETCODE\n  CALL DSQCIX 'EXIT'\n  ZERRLM = \"see DSQDEBUG output for detail info.\"\n  Signal Error\n\nError:\n say '*ERROR*' strip(ZERRLM)\n \"LMCLOSE DATAID(\"DDfrom\")\"\n \"LMFREE DATAID(\"DDfrom\")\"\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SC": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01#\\x00E\\x01\\x03\\x10o\\x01\\x12'o\\x10$\\x00\\xa7\\x00`\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.35", "flags": 0, "createdate": "2003-04-16T00:00:00", "modifydate": "2012-10-02T10:24:45", "lines": 167, "newlines": 96, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* Name: SC                                                          */\n/*                                                                   */\n/* Author:  V MESTOVSKI                                              */\n/*                                                                   */\n/* Function: SC calls SUPERC for a pair of data set names            */\n/*           where the cursor is currently positioned                */\n/*                                                                   */\n/* Syntax:   From within an view session, enter 'SC' on the command  */\n/*           line, position the cursor on a first dsname (second     */\n/*           one should be on next line under the cursor)            */\n/*           on the screen and press ENTER.                          */\n/*********************************************************************/\n\ntrace 'o'\nsignal on novalue\n\"ISREDIT\" 'MACRO (OPT1) PROCESS'\n\"ISPEXEC\" 'CONTROL ERRORS RETURN'  /* RETURN TO MACRO IF ERROR */\n\nIf opt1 = \"?\" Then\nDo\n  Call help\n  exit\nEnd\nif opt1='' then opt1=arg(1)\nvalid_for_dsn = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@().\"\ndelimiter = \", ='\"\nzedsmsg = ''\nzedlmsg = ''\n\n\"ISREDIT\" '(LPTR,CPOS) = CURSOR'\n\"ISREDIT\" '(DATA) = LINE .ZCSR'\n\"ISREDIT\" '(LAST) = LINENUM .ZLAST'\n\"ISREDIT\" '(LRECL) = LRECL'\n\nIf (lptr > last) |,\n   (lptr+1 > last) |,\n   (lptr < 1) |,\n   (cpos > lrecl) |,\n   (cpos < 1) Then\n  DO\n    zedsmsg = \"Invalid position\"\n    zedlmsg = \"Put cursor on the 1-st DSN\"\n    Signal EXIT2\n  End\nIf Verify(Substr(data,cpos,1),valid_for_dsn) <> 0 Then\n  DO\n    zedsmsg = \"Invalid field\"\n    zedlmsg = \"Cursor is positioned on a field that is not valid for a\",\n               \" data set name\"\n    Signal EXIT2\n  End\n\ndsn1 = embedded_string(cpos data)\nmsg = Sysdsn(\"'\"dsn1\"'\");\nIf msg <> \"OK\" Then\n  DO\n    zedsmsg = msg\n    zedlmsg = \"Could not open data set\" dsn1\n    Signal EXIT2\n  End\n\ndo lptr = lptr+1 to last\n \"ISREDIT\" '(statusx) = XSTATUS' lptr\n if statusx = 'X' then iterate; else leave;\nend;\n\"ISREDIT\" 'CURSOR =' lptr cpos\n\"ISREDIT\" '(LPTR,CPOS) = CURSOR'\n\"ISREDIT\" '(DATA) = LINE .ZCSR'\nIf Verify(Substr(data,cpos,1),valid_for_dsn) <> 0 Then\n  DO\n    zedsmsg = \"Invalid 2nd field\"\n    zedlmsg = \"Cursor is positioned on a field that is not valid for a\",\n               \" data set name\"\n    Signal EXIT2\n  End\ndsn2 = embedded_string(cpos data)\nmsg = Sysdsn(\"'\"dsn2\"'\");\nIf msg <> \"OK\" Then\n  DO\n    zedsmsg = msg\n    zedlmsg = \"Could not open data set\" dsn2\n    Signal EXIT2\n  End\nElse\n  DO\n  trace 'O'\n    Address TSO \"ALLOC FI(NEWDD) DA('\"dsn1\"') REUSE SHR \"\n    Address TSO \"ALLOC FI(OLDDD) DA('\"dsn2\"') REUSE SHR \"\n    Address TSO \"ALLOC FI(SYSIN) DUMMY        REUSE SHR \"\n    listdsn = \"SUPERC.LIST\"\n    if SYSDSN(listdsn) = 'OK' then\n    Address TSO \"ALLOC FI(OUTDD) DA(\"listdsn\") REUSE SHR\"\n    else\n    Address TSO \"ALLOC FI(OUTDD) DA(\"listdsn\") REUSE NEW CATALOG\",\n                \"UNIT(SYSDA) RECFM(F B A) LRECL(133) DSORG(PS) \",\n                \"SPACE(50,50) CYLINDERS RELEASE\"\n\n    Address ispexec \"SELECT PGM(ISRSUPC) PARM(DELTAL,LINECMP)\"\n  trace 'O'\n    if rc >1  then do;\n     zedsmsg = \"SUPERC failed. RC=\"rc\n     zedlmsg = \"SUPERC failed. RC=\"rc\n     Signal EXIT\n    end;\n    \"ISPEXEC VIEW DATASET(SUPERC.LIST)\"\n    if rc <> 0 then do;\n     zedsmsg = \"VIEW failed. RC=\"rc\n     zedlmsg = \"Could not open data set &SYSUID.SUPERC.LIST\"\n     Signal EXIT\n    end\n  End\nEXIT:\n    Address TSO \"FREE  FI(NEWDD)\"\n    Address TSO \"FREE  FI(OLDDD)\"\n    Address TSO \"FREE  FI(SYSIN)\"\n    Address TSO \"FREE  FI(OUTDD)\"\nEXIT2:\n\"ISPEXEC\" 'SETMSG MSG(ISRZ001)'\n\"ISREDIT\" 'CURSOR =' lptr cpos\nexit\n\n/****************************************************************/\n/* Return a string delimited by defined delimiter               */\n/* Arguments:                                                   */\n/*    1. current cursor position                                */\n/*    2. string that contains the embedded string               */\n/****************************************************************/\nembedded_string:\nParse arg position feld\nDo i = cpos to 1 by -1\n  If Verify(Substr(feld,i,1),delimiter) = 0 Then\n  Leave\nEnd\nfrom_pos = i+1\n\nDo i = cpos to lrecl\n  If Verify(Substr(feld,i,1),delimiter) = 0 Then\n  Leave\nEnd\nlaenge = i - from_pos\n\nreturn_string = substr(feld,from_pos,laenge)\n\nif substr(return_string,1,1) = '(' &,\n   substr(return_string,length(return_string),1) = ')' then\nparse var return_string '(' return_string ')'\n\nif substr(return_string,1,8) = '&SYSUID.' then\nreturn_string = userid()||substr(return_string,9)\n\nif opt1<>'' then\nreturn_string = opt1||return_string\n\nReturn return_string\n\n/****************************************************************/\n/* With a little help from my friend....                        */\n/****************************************************************/\nHelp:\n  inline = '/*'\n  Do i = 1 by 1 Until Substr(inline,1,2) <> '/*'\n    inline = Substr(Sourceline(i),1,79)\n    say inline\n  End\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLEEP": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\n\\x00@\\x01\\x10\\x03_\\x01\\x12'o\\x080\\x00]\\x00\\x1a\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.10", "flags": 0, "createdate": "2010-02-04T00:00:00", "modifydate": "2012-10-02T08:30:40", "lines": 93, "newlines": 26, "modlines": 0, "user": "V2IBAVM"}, "text": "//ASLEEP2   JOB ($2919BA,BIN070,FSH334,DEPT19BA),'ASM COMPILER',\n//       NOTIFY=&SYSUID,MSGCLASS=H,MSGLEVEL=(1,1),TIME=5,\n//       REGION=0M\n//*\n// SET LLIB='MDCT.PROD.LOADLIB' <-- ADJUST\n//*\n//C        EXEC PGM=ASMA90\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSIN    DD  *\n         LCLC  &ID\n&ID      SETC  'SLEEP V1R0 / J.J. JOOLEN /'.'&SYSDATE'.' '.'&SYSTIME'.'*\n                - SUSPEND EXECUTION'\n*\n*   Calling sequence:\n*      From TSO/E Clist or Rexx:   'SLEEP   nnnn'\n*                                  nnnn = nr. of seconds to sleep\n*\n*   (c) Hans Joolen\n*       Delft University of Technology\n*       The Netherlands\n*\n*\nSLEEP    CSECT ,\n         SAVE  (14,12),,'&ID'\n         LR    12,15\n         USING SLEEP,12\n*   Chain savearea's\n         LA    11,SVA\n         ST    11,8(,13)\n         ST    13,4(,11)\n         LR    13,11\n*   Process environment for calling TSO/E services\n         LR    2,1               Command processor parameter list\n         USING CPPL,2\n         L     1,=A(PARSROOM)    Parse parameter list\n         USING PPL,1             Structure from DSECT\n         MVC   PPLUPT,CPPLUPT    User profile table\n         MVC   PPLECT,CPPLECT    Environment control table\n         MVC   PPLECB,=A(ECB)    Command Processor's ECB\n         MVC   PPLPCL,=A(PARSLIST)\n         MVC   PPLANS,=A(PDLPTR) Answer area for IKJPARS\n         MVC   PPLCBUF,CPPLCBUF  Command buffer\n         MVC   PPLUWA,=A(0)      User work area (validity check rtn's)\n         DROP  2\n*   Get nr. of seconds and wait\n         LINK  EP=IKJPARS        Reg 1 contains Parse parameter list\n         L     2,PDLPTR          Get pointer to PDL (created by IKJPARS\n         USING IKJPARMD,2\n         L     3,INTVL           PDE within PDL, contains ptr to value\n         L     4,0(,3)           Fullword (because of IKJIDENT/INTEG)\n         MH    4,=H'100'         Stimer wants centiseconds\n         ST    4,0(,3)\n         STIMER WAIT,BINTVL=(3)  Sleep for specified nr. of seconds\n*   Return to calling clist\n         IKJRLSA PDLPTR          Release storage allocated by IKJPARS\n         L     13,SVA+4\n         RETURN (14,12),RC=0\n         PRINT NOGEN\n*   Scan parameter list for IKJPARS\nPARSLIST IKJPARM\nINTVL    IKJIDENT 'interval',PROMPT='nr. of seconds to sleep',INTEG\n         IKJENDP\nSVA      DC    18F'0'\nPDLPTR   DC    A(0)              Receives A(PDL) from IKJPARS\nPARSROOM DC    7A(0)             Room for parse PCL\nECB      DC    A(0)\n         LTORG ,\n         IKJCPPL ,               Command processor parameter list\n         IKJPPL ,                Parse parameter list\n         IKJECT ,                Environment control table\n         IKJUPT ,                User profile table\n         END   SLEEP\n/*\n//L       EXEC PGM=HEWL,PARM='REUS,MAP,LET,LIST,NCAL',COND=(8,LT,C)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,PASS)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&LLIB(SLEEP),DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//*\n//TEST    EXEC PGM=IKJEFT01\n//SYSTSIN  DD  *\nSLEEP 10\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//STEPLIB  DD  DSN=&LLIB,DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "V": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x12&_\\x01\\x12&_\\x06\\x08\\x00\\x08\\x00\\x08\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-21T00:00:00", "modifydate": "2012-09-21T06:08:16", "lines": 8, "newlines": 8, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* V -- view a member/dataset pointed by the cursor on the screen    */\n/*                                                                   */\n/**************************************** Vladimir Mestovski, 2012 ***/\n\"ISREDIT MACRO (opt) PROCESS\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\"VBE VIEW\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VBE": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x12&_\\x01\\x12&_\\x06\\x06\\x00\\xc3\\x00\\xc3\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-09-21T00:00:00", "modifydate": "2012-09-21T06:06:49", "lines": 195, "newlines": 195, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* Name: VBE -- Common part for V,B,E macros                         */\n/*                                                                   */\n/************************************* Vladimir Mestovski, 2012 ******/\n\ntrace 'O'\nsignal on novalue\narg PGMNAME\n\n\"ISPEXEC\" 'CONTROL ERRORS RETURN'  /* RETURN TO MACRO IF ERROR */\n\nvalid_for_dsn = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@().\"\nvalid_for_var = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@\"\ndelimiter_for_dsn = \", ='\"\ndelimiter_for_var = \"().&\"\n\n\"ISREDIT (user) = USER_STATE\"\n\"ISREDIT\" '(LPTR,CPOS) = CURSOR'\n\"ISREDIT\" '(DATA) = LINE .ZCSR'\n\"ISREDIT\" '(LAST) = LINENUM .ZLAST'\n\"ISREDIT\" '(LRECL) = LRECL'\n\nif datatype(LAST)='CHAR' then do;\n say \"*ERROR* YOU should remove any pending line commands\";\n say \"        from the line command area first, then try again...\";\n exit 8;\nend;\n\nIf (lptr > last)  |,\n   (lptr < 1)     |,\n   (cpos > lrecl) |,\n   (cpos < 1) Then\n  DO\n    zedsmsg = \"Invalid position\"\n    zedlmsg = \"Cursor is positioned outside data area\"\n    \"ISREDIT\" 'CURSOR =' lptr cpos\n    \"ISPEXEC\" 'SETMSG MSG(ISRZ001)'\n    exit 0\n  End\n\nIf Verify(Substr(data,cpos,1),valid_for_dsn) <> 0 Then\n  DO\n    zedsmsg = \"Invalid field\"\n    zedlmsg = \"Cursor is positioned on a field that is not valid for a\",\n               \" data set name\"\n    \"ISREDIT\" 'CURSOR =' lptr cpos\n    \"ISPEXEC\" 'SETMSG MSG(ISRZ001)'\n    exit 0\n  End\n\ndsn = get_dsn(cpos data)\n\nmsg = Sysdsn(\"'\"dsn\"'\");\nIf msg <> \"OK\" Then\n  DO\n    zedsmsg = msg\n    zedlmsg = \"Could not open data set\" dsn\n    \"ISREDIT\" 'CURSOR =' lptr cpos\n    \"ISPEXEC\" 'SETMSG MSG(ISRZ001)'\n    exit 0\n  End\nElse\n  DO\n    \"ISPEXEC\" PGMNAME \"DATASET('\"dsn\"')\"\n    if rc  > 4 then do;\n    zedsmsg = PGMNAME \"failed. RC=\"rc\n    zedlmsg = \"Could not open data set\" dsn\n    \"ISREDIT\" 'CURSOR =' lptr cpos\n    \"ISPEXEC\" 'SETMSG MSG(ISRZ001)'\n    exit 0\n    end;\n  End\n\n\"ISREDIT USER_STATE = (user)\"\n\"ISREDIT RESET FIND\"\n\"ISREDIT\" 'CURSOR =' lptr cpos\nexit\n\n/****************************************************************/\n/* Return DSN extracted from a line pointed by the cursor       */\n/* Arguments:                                                   */\n/*    1. current cursor position                                */\n/*    2. string that contains DSN                               */\n/****************************************************************/\nget_dsn:\ntrace 'O'\nParse arg cpos field\n                                        /* Find start position of dsn */\nDo i = cpos to 1 by -1\n  If Verify(Substr(field,i,1),delimiter_for_dsn) = 0 Then Leave\nEnd\nstart = i+1\n                                        /* Find end position of dsn   */\nDo i = cpos to lrecl\n  If Verify(Substr(field,i,1),delimiter_for_dsn) = 0 Then Leave\nEnd\nlen = i-start\n                                        /* Extract dsn                */\ndsn = substr(field,start,len)\n                                        /* Check for (dsn)            */\nif substr(dsn,1,1) = '(' & substr(dsn,length(dsn),1) = ')' then\nparse var dsn '(' dsn ')'\nelse                                    /* Check for (dsn,            */\nif substr(dsn,1,1) = '(' & substr(dsn,length(dsn),1) <> ')' then\nparse var dsn '(' dsn\n                                        /* If no vars, done           */\nif index(dsn,'&')=0 then\nReturn dsn\n                                        /* Start processing &vars     */\n_SYSUID=userid()                        /* Assign &SYSUID             */\n\nif index(dsn,'&')>0 then do;            /* If dsn still has &vars...  */\n Call getSETvars;                       /* Extract SET vars           */\n Call getPROCvars;                      /* Extract PROC vars          */\n Call setVars                           /* Substitute &vars           */\nEnd;\n\nDo while index(dsn,'..')>0;             /* Replace '..' with '.'      */\n parse var dsn beg '..' rest\n dsn=beg||'.'||rest\nEnd;\n\nReturn dsn\n\n/*********************************************************************\\\n| Extract 5 &vars from // PROC card and assign as '_vars'             |\n|  //RPE218  PROC TYPE='CPE',HLQR='MDCP',SYS='DB2A'                   |\n|          _TYPE='CPE'; _HLQR='MDCP' _SYS='DB2A'                      |\n\\*********************************************************************/\ngetPROCvars:\n trace 'O'\n \"ISREDIT FIND FIRST ' PROC ' NX\"\n if rc<>0 then return\n \"ISREDIT RESET FIND\"\n \"ISREDIT (procline) = LINE .ZCSR\"\n if word(procline,2)<>'PROC' then return;\n parse var procline slash . parms .\n if substr(slash,1,2)<>'//' |,\n    substr(slash,1,3)='//*' |,\n    parms='' then return;\n parse Value parms',' with v.1 ',' v.2 ',' v.3 ',' v.4 ',' v.5 ',' .\n do i=1 to 5 while v.i<>'';\n  parse var v.i varc '=' valuec\n  if substr(valuec,1,1)=\"'\" then\n   parse var valuec \"'\" valuec \"'\"\n  interpret \"_\"varc\"='\"valuec\"'\"\nend;\nreturn;\n\n/*********************************************************************\\\n| Extract '&vars' from all SET cards and assign as '_vars'            |\n|  //  SET M=TTR314             _M='TTR314'                           |\n|  //  SET L=&M                 _L='&M'                               |\n\\*********************************************************************/\ngetSETvars:\ntrace 'O'\n\"ISREDIT FIND FIRST ' SET ' NX\"\nDo i=1 by 1 while rc=0\n 'ISREDIT (setline) = LINE .ZCSR'\n parse var setline slash set var.i .\n if substr(slash,1,2)='//' &,\n    substr(slash,3,1)<>'*' &,\n    set='SET' & index(var.i,'=')>0 then do;\n  parse var var.i varc '=' valuec\n  if substr(valuec,1,1)=\"'\" then\n   parse var valuec \"'\" valuec \"'\"\n  interpret \"_\"varc\"='\"valuec\"'\"\n end;\n \"ISREDIT RFIND\"\nEnd;\n\"ISREDIT RESET FIND\"\nreturn;\n\n/*********************************************************************\\\n| Set '&vars' in dsn using '_vars' assigned above.                    |\n| Ten levels of assignmets are allowed.                               |\n|                                                                     |\n\\*********************************************************************/\nsetVars:\n trace 'O'\n Do 10 while index(dsn,'&')>0;\n  parse var dsn beg '&' varx\n  Do i = 1 to length(varx)\n   If Verify(Substr(varx,i,1),delimiter_for_var) = 0 Then Leave\n  End\n  varc='_'substr(varx,1,i-1);\n  rest=substr(varx,i);\n  varc=Value(varc);\n  if substr(varc,1,1)='_' then leave\n  dsn = beg||varc||rest\n End;\n  if substr(varc,1,1)='_' | substr(varc,1,1)='&' then\n  say \"*ERROR* Value for &\"substr(varc,2) \"not found\";\nreturn;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VDIR": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x10 ?\\x01\\x10 ?\\x07!\\x00\\x19\\x00\\x18\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-07-22T00:00:00", "modifydate": "2010-07-22T07:21:21", "lines": 25, "newlines": 24, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/*                                                                   */\n/* VDIR: View a QMF member inside $$DIR$$ member                     */\n/*                                                                   */\n/*********************************************************************/\n\ntrace 'o'\nsignal on novalue\n\"ISREDIT\" 'MACRO (OPT1) PROCESS'\n\"ISPEXEC\" 'CONTROL ERRORS RETURN'  /* RETURN TO MACRO IF ERROR */\n\n\"ISREDIT\" '(LPTR,CPOS) = CURSOR'\n\"ISREDIT\" '(DATA) = LINE .ZCSR'\n\"ISREDIT\" '(DSN) = DATASET'\nParse Var DATA mbr .\n\"ISPEXEC VIEW DATASET('\"dsn\"(\"mbr\")')\"\nif rc <> 0 then do;\nzedsmsg = \"VIEW failed. RC=\"rc\nzedlmsg = \"Could not open data set\" dsn\n\"ISREDIT\" 'CURSOR =' lptr cpos\n\"ISPEXEC\" 'SETMSG MSG(ISRZ001)'\nend;\n\"ISREDIT\" 'CURSOR =' lptr cpos\n\"ISREDIT MEND\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WSUBMIT": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01;\\x00E\\x01\\x10 \\x0f\\x01\\x12'\\x9f\\x07V\\x00P\\x007\\x00\\x00\\xe5\\xf2\\xc9\\xc2\\xc1\\xe5\\xd4@@@\"", "ispf": {"version": "01.59", "flags": 0, "createdate": "2010-07-19T00:00:00", "modifydate": "2012-10-05T07:56:45", "lines": 80, "newlines": 55, "modlines": 0, "user": "V2IBAVM"}, "text": "/*REXX****************************************************************/\n/* SUBMIT a job and wait its end                                     */\n/*****************************************************************VM**/\n trace 'O'\n Signal On Error;\n arg job 'MAXWAIT=' wtime .\n if wtime = '' then wtime=3600\n itime=10\n if wtime<itime then wtime=itime\n Address TSO\n x=outtrap('out.')\n 'SUBMIT' job\n x=outtrap('OFF')\n say out.1\n parse var out.1 . jobid msg\n if msg <> 'SUBMITTED' then Signal Error\n x=outtrap('out.')\n 'STATUS' jobid\n x=outtrap('OFF')\n parse var out.1 . . msg\n say msg\n if msg = 'ON OUTPUT QUEUE' then do;Call CheckOutput; exit 0; end;\n holdmsg=msg\n do wtime/itime while msg = 'WAITING FOR EXECUTION' | msg = 'EXECUTING'\n   'SLEEP' itime\n    x=outtrap('out.')\n   'STATUS' jobid\n    x=outtrap('OFF')\n    parse var out.1 . . msg\n    if holdmsg<>msg then say msg\n    holdmsg=msg\n end\n if msg = 'ON OUTPUT QUEUE'\n then do; Call CheckOutput; exit 0; end;\n if msg = 'EXECUTING'\n then do;\n    say '*ERROR* MAXWAIT='wtime 'is not enough to wait the end of job'\n    Signal Error\n end\n exit 8\nCheckOutput:\n  trace 'O'\n  Signal Off Error\n    x=outtrap('o.')\n  \"DELETE TEMP.OUTLIST\"\n  \"FREE FI(OUTLIST)\"\n    x=outtrap('OFF')\n  Signal On  Error\n  Address TSO \"ALLOCATE FI(OUTLIST) DSNAME(TEMP.OUTLIST) \",\n              \" NEW DSORG(PS) RECFM(F,B) LRECL(132) \",\n              \" SPACE(10,10) CYLINDERS RELEASE \",\n              \" UNIT(SYSDA) MAXVOL(10) CATALOG REUSE\"\n  'OUTPUT' jobid 'HOLD KEEP PRINT(TEMP)'\n  'EXECIO * DISKR OUTLIST (stem o. FINIS'\n  Do j=1 to o.0\n  if index(o.j,'JOB NOT RUN - JCL ERROR') > 0\n   then do; say strip(o.j); Signal Error; end\n  End;\n  Do j=1 to o.0\n  if index(o.j,'JOB FAILED - JCL ERROR') > 0\n   then do; say strip(o.j); Signal Error; end\n  End;\n  Do j=1 to o.0\n  if index(o.j,'IEA995I SYMPTOM DUMP OUTPUT') > 0\n   then do; say strip(o.j); Signal Error; end\n  End;\n  Do j=1 to o.0\n  if index(o.j,'ABEND=SB37 U0000') > 0\n   then do; say strip(o.j); Signal Error; end\n  End;\n\n  Parse var jobid job '(' id ')'\n  Do j=1 to o.0\n  if index(o.j,id||'  GSDMV2') > 0\n    then say strip(o.j);\n  End;\n\n  return;\nError:\n Exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT877/FILE877.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT877", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}