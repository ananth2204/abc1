{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012648000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE719.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE719.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x08'", "DS1TRBAL": "b'B\\x02'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xf5\\x00\\x0b\\x04\\xf6\\x00\\x01\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x18/\\x01\\x05\\x18/\\t\\x14\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-07-01T00:00:00", "modifydate": "2005-07-01T09:14:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-469"}, "text": "REGULAR CBT TAPE - VERSION 469    FILE:  719\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT469.FILE719\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 3 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,281 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/01/05    09:14:44    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE719": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x18/\\x01\\x05\\x18/\\t\\x14\\x00\\x05\\x00\\x05\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-07-01T00:00:00", "modifydate": "2005-07-01T09:14:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "CBT-469"}, "text": "//***FILE 719 is from Greg Smith and contains a program to do       *   FILE 719\n//*           dump/restore for data on an offline disk pack.        *   FILE 719\n//*                                                                 *   FILE 719\n//*           email:  gsmith@nc.rr.com                              *   FILE 719\n//*                                                                 *   FILE 719\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OFFLINDR": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x05\\x14_\\x01\\x05\\x14_\\x147\\x08\\xd8\\x08\\xd8\\x00\\x00\\xc7\\xe2\\xd4\\xc9\\xe3\\xc8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-05-25T00:00:00", "modifydate": "2005-05-25T14:37:29", "lines": 2264, "newlines": 2264, "modlines": 0, "user": "GSMITH"}, "text": "*/* -------------------------------------------------------------------\n*   Dump/Restore an offline eckd dasd device to/from a backup file\n*\n*   Invocation:\n*      //step   EXEC PGM=OFFLINDR,\n*      //       PARM='function,unit,locyl,hicyl,bkddn,msgddn'\n*      //STEPLIB  DD DISP=SHR,DSN=apf.authorized.loadlib\n*      //msgddn   DD SYSOUT=*\n*      //bkddn    DD . . . .\n*\n*     function  Required. 'DUMP' or 'RESTORE', or a prefix of either;\n*               can be mixed case.\n*\n*     unit      Required. Specifies the logically offline eckd dasd\n*               device address that will be dumped or restored.\n*               If 'ASIS' (mixed case) is specified for RESTORE\n*               then the address from the backup file will be used.\n*\n*     locyl     Optional. Specifies the starting cylinder on the unit\n*               (in hex) for the dump or restore.\n*               Default for DUMP is cylinder 0; default for RESTORE\n*               is the low cylinder dumped on the backup file.\n*\n*     hicyl     Optional. Specifies the last cylinder on the unit\n*               (in hex) for the dump or restore.\n*               Default for DUMP is the last primary cylinder on the\n*               unit; default for RESTORE is the last cylinder dumped\n*               on the backup file.\n*\n*     bkddn     Optional.  Specifies the ddname for the backup file.\n*               Default is SYSUT1.  DCB attributes do not have to be\n*               specified, and are ignored if they are.\n*\n*     msgddn    Optional.  Specifies the ddname for the message file.\n*               Default is SYSPRINT.\n*\n*   This program *requires* apf-authorization.  The program only\n*   runs in supervisor state and/or key 0 during initialization and\n*   termination.  During the actual dump or restore the program runs\n*   in key 8 problem state.\n*\n*   The backup file is written/read using QSAM and is a physical\n*   sequential file (dsorg=ps) and contains undefined blocks (recfm=u).\n*   The blocksize is the maximum blocksize allowed for the backup\n*   device (usually blksize=32760).\n*\n*   The first block on the backup file is a 512 byte block that\n*   describes the offline device.  Restores must be made to a like\n*   device type (eg you cannot restore a dumped 3380 to a 3390).\n*\n*   The remainder of the file contains track images as read by the\n*   Read Track (RT) CCW.  A track image is contained in an integral\n*   number of blocks.  Generally, a track image dumped to tape will\n*   contain 1 or 2 blocks, and a track image dumped to dasd will\n*   contain 1 or 2 or 3 blocks.  The extra block for dasd can occur\n*   when a short block is written at the end of the current track,\n*   a 32k block is written at the beginning of the next track, and\n*   the remainder of the track image is written after the 32k block;\n*   that is, there is track balance logic to maximize track\n*   utilization during DUMP.\n*\n*   Dual IOBs are used for the offline dasd unit to allow I/O\n*   concurrency.  Note that DUMP reads a cylinder per EXCP and\n*   RESTORE writes a track per EXCP, so restores will take longer\n*   than dumps.\n*\n*   Notes:\n*   1.  Assembly requires SYS1.MACLIB and SYS1.MODGEN.\n*       Linkedit the program with the RENT and AC(1) options.\n*   2.  The program uses a feature introduced by release 3 of\n*       the High Level Assembler (HLASM).  If your high level\n*       assembler is below this level then you will probably\n*       have to change the several lines that read\n*         USING (OFFLINDR+4095,mainend),ra\n*       to\n*         USING OFFLINDR+4095,ra\n*       This in turn will cause the assembly step to return code 4\n*       instead of code 0, which can be ignored.\n*\n*   Changelog:\n*   0.1.1 29 Nov 2000  -  IDAWs are now used to reduce the virtual\n*                         storage footprint below the 16M line.\n*\n*   Greg Smith\n*   gsmith@nc.rr.com\n*\n* ------------------------------------------------------------------ */\n\n*/* -------------------------------------------------------------------\n*   local macros\n* ------------------------------------------------------------------ */\n         MACRO\n&L      #MSG   &MSG,&TYPE=CALL\n         LCLA  &A,&N,&O\n         LCLC  &C\n         GBLA  &MSG_IX\n         GBLC  &MSGS(256)\n         AIF   ('&TYPE' EQ 'CALL').CALL,                               x\n               ('&TYPE' EQ 'GEN').GEN\n         MNOTE 8,'Invalid type specified'\n         MEXIT\n.*\n.CALL    ANOP\n&MSG_IX  SETA  &MSG_IX+1\n&MSGS(&MSG_IX) SETC '&MSG'\n&L       L     re,=A(#MSG&MSG_IX)\n         LA    rf,L'#MSG&MSG_IX\n&A       SETA  2\n&O       SETA  0\n&N       SETA  N'&SYSLIST\n         AGO   .PL0\n.PLLOOP  ANOP\n         LA    re,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX14\n         LA    rf,&SYSLIST(&A)\n&A       SETA  &A+1\n.PL0     ANOP\n         AIF   (&A GT &N).PLX15\n         LA    r0,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX0\n         LA    r1,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX1\n         STM   re,r1,drwmsgpl+&O\n&O       SETA  &O+16\n         AGO   .PLLOOP\n.PLX14   ST    re,drwmsgpl+&O\n         AGO   .CALL2\n.PLX15   STM   re,rf,drwmsgpl+&O\n         AGO   .CALL2\n.PLX0    STM   re,r0,drwmsgpl+&O\n         AGO   .CALL2\n.PLX1    STM   re,r1,drwmsgpl+&O\n.CALL2   LA    r1,drwmsgpl\n         L     rf,=a(msgr)\n         BALR  re,rf\n         MEXIT\n.*\n.GEN     ANOP\n         AIF   ('&L' EQ '').GENNOL\n&L       DS    0H\n.GENNOL  ANOP\n&A       SETA  1\n.GENLOOP AIF   (&A GT &MSG_IX).MEND\n#MSG&A   DC    C&MSGS(&A)\n&A       SETA  &A+1\n         AGO   .GENLOOP\n.MEND    MEND\n\n*/* -------------------------------------------------------------------\n*   mainline routine\n* ------------------------------------------------------------------ */\nOFFLINDR CSECT ,\nOFFLINDR AMODE 31\nOFFLINDR RMODE ANY\n         B     init-*(,rf)\n         DC    AL1(init-*)\npgmid    DC    CL8'offlindr'\nvrm      DC    X'000101'          version 0 release 1 modlvl 1\n         DC    C' &SYSDATE &SYSTIME '\ninit     SAVE  (14,12)\n         LR    rc,rf              set base reg\n         USING OFFLINDR,rc\n         LA    ra,4095(,rc)       set 2nd base reg\n         USING OFFLINDR+4095,ra\n         LR    r2,r1              copy parm reg\n\n*/* -------------------------------------------------------------------\n*   obtain and initialize workareas\n* ------------------------------------------------------------------ */\n         STORAGE OBTAIN,LENGTH=drwl get work area\n         ST    r1,8(,rd)          chain save areas\n         ST    rd,4(,r1)\n         LR    rd,r1              set area base\n         USING odrw,rd\n         MVC   drwid,=C'odrw'     set area identifier\n         LA    r0,odrw+8          clear the area\n         L     r1,=a(drwl-8)\n         SLR   rf,rf\n         MVCL  r0,re\n         STORAGE OBTAIN,LENGTH=o24wl,LOC=BELOW get 24-bit work area\n         ST    r1,drwo24w         save address\n         LR    rb,r1              set 24-bit area base\n         USING o24w,rb\n         MVC   o24wid,=C'o24w'    set 24-bit area identifier\n         LA    r0,o24w+4          clear the 24-bit area\n         L     r1,=a(o24wl-4)\n         SLR   rf,rf\n         MVCL  r0,re\n\n*/* -------------------------------------------------------------------\n*   process PARM= : <function>,<unit>,<locyl>,<hicyl>,<bkddn>,<msgddn>\n* ------------------------------------------------------------------ */\n         N     r2,=A(X'7fffffff') test parameter reg\n         BZ    Enoparm             invalid parameter list\n         L     r3,0(,r2)          point to parameters\n         N     r3,=A(X'7fffffff')  test parameter reg\n         BZ    Enoparm              invalid parameter list\n         LH    r4,0(,r3)          get length of parameters\n         LTR   r4,r4               test length\n         BNP   Enoparm              invalid parameter list\n         BCTR  r4,0               decrement for EX\n         LA    r3,2(,r3)          point past length\n         SLR   r2,r2              clear TRT register\n\n*/* 1st parm is 'DUMP' or 'RESTORE' or a prefix of either            */\n         XC    drwdw,drwdw        clear double-word work area\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for ','\n*/*      TRT   0(0,r3),delimtab   *** executed ***                   */\n         SR    r1,r3              calculate parameter length\n         SH    r1,=Y(1)            minus one\n         BM    Ebadparm           error if 1st parm is missing\n         CH    r1,=Y(8)           check length\n         BNL   Ebadparm            jumps if not too high\n         EX    r1,parmmvc         copy the parm\n*/*      MVC   drwdw(0),0(r3)     *** executed ***                   */\n         TR    drwdw,upcase       translate to uppercase\n         LA    rf,RESTORE         test for RESTORE\n         EX    r1,parmclc         compare for RESTORE\n*/*      CLC   0(0,rf),drwdw      *** executed ***                   */\n         BE    parm1ok            continue if match\n         OI    drwflags,drwdump   presume dump\n         LA    rf,DUMP            test for DUMP\n         EX    r1,parmclc         compare for DUMP\n         BNE   Ebadparm           error if neither\nparm1ok  LA    r1,2(,r1)          length of parm + ','\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      2nd parm is hex unit address of the offline device or 'ASIS'*/\n         LTR   r4,r4              test for 2nd parm\n         BM    Ebadparm            error if offline device is missing\n         XC    drwdw,drwdw        clear double-word work area\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for ','\n         SR    r1,r3              calculate parameter length\n         SH    r1,=Y(1)            minus one\n         BM    Ebadparm           error if 1st parm is missing\n         CH    r1,=Y(4)           check 2nd parm length\n         BNL   Ebadparm           error if too long\n         EX    r1,parmmvc         copy 2nd parameter\n         TR    drwdw,upcase       convert to uppercase\n         SLR   r5,r5              clear unit address\n         CLC   ASIS,drwdw         'ASIS' specified ?\n         BNE   getunit             no, continue\n         TM    drwflags,drwdump   is this a DUMP ?\n         BO    Ebadparm            yes, 'ASIS' is only good for restore\n         BCTR  r5,0               set unit to x'ffff'\n         B     gotunit            continue\ngetunit  EX    r1,parmhexc        test if all hex digits\n*/*      TRT   drwdw(0),hexchars  *** executed ***                   */\n         BNZ   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n*/*      TR    drwdw(0),hextab    *** executed ***                   */\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n*/*      PACK  drwdw2,drwdw(0)    *** executed ***                   */\n         ICM   r5,3,drwdw2+5      load hex value\ngotunit  STCM  r5,3,drwunit       save unit address\n         LA    r1,2(,r1)          length of parm + ','\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      3rd parm is low cylinder to dump/restore                    */\n         SLR   r1,r1              clear reg 1\n         SLR   r5,r5              init to\n         BCTR  r5,0                -1\n         LTR   r4,r4              test for low cylinder\n         BM    gotlocyl            continue if missing\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for ','\n         SR    r1,r3              calculate parameter length\n         SH    r1,=Y(1)            minus one\n         BM    gotlocyl             continue if missing\n         XC    drwdw,drwdw        clear double-word work area\n         CH    r1,=Y(4)           check 2nd parm length\n         BNL   Ebadparm           error if too long\n         EX    r1,parmmvc         copy 3rd parameter\n         TR    drwdw,upcase       convert to uppercase\n         EX    r1,parmhexc        test if all hex digits\n         BNZ   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n         SLR   r5,r5              clear low cylinder\n         ICM   r5,3,drwdw2+5      load hex value\ngotlocyl STCM  r5,3,drwlocyl      save low cylinder\n         LA    r1,2(,r1)          length of parm + ','\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      4th parm is high cylinder to dump/restore                   */\n         SLR   r1,r1              clear reg 1\n         SLR   r5,r5              init to\n         BCTR  r5,0                -1\n         LTR   r4,r4              test for high cylinder\n         BM    gothicyl            continue if missing\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for ','\n         SR    r1,r3              calculate parameter length\n         SH    r1,=Y(1)            minus one\n         BM    gothicyl            continue if missing\n         CH    r1,=Y(4)           check 2nd parm length\n         BNL   Ebadparm           error if too long\n         XC    drwdw,drwdw        clear double-word work area\n         EX    r1,parmmvc         copy 3rd parameter\n         TR    drwdw,upcase       convert to uppercase\n         EX    r1,parmhexc        test if all hex digits\n         BNZ   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n         SLR   r5,r5              clear low cylinder\n         ICM   r5,3,drwdw2+5      load hex value\ngothicyl STCM  r5,3,drwhicyl      save high cylinder\n         LA    r1,2(,r1)          length of parm + ','\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      5th parm is the backup ddname                               */\n         SLR   r1,r1              clear reg 1\n         MVC   drwbuddn,=CL8'SYSUT1' init backup ddname\n         LTR   r4,r4              test length left\n         BM    gotbuddn            continue if nothing left\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for ','\n         SR    r1,r3              calculate parameter length\n         SH    r1,=Y(1)            minus one\n         BM    gotbuddn            continue if missing\n         CH    r1,=Y(8)           test length\n         BNL   Ebadparm            error if too long\n         XC    drwdw,drwdw        clear double word work area\n         EX    r1,parmmvc         copy 3rd parameter\n         TR    drwdw,upcase       convert to uppercase\n         MVC   drwbuddn,drwdw     copy the backup ddname\ngotbuddn LA    r1,2(,r1)          length of parm + ','\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      6th (and last) parm is the message ddname                   */\n         SLR   r1,r1              clear reg 1\n         MVC   drwprddn,=CL8'SYSPRINT' init message ddname\n         LTR   r4,r4              test length left\n         BM    gotprddn            continue if nothing left\n         LA    r1,1(r3,r4)        point to parameter end\n****     EX    r4,delimtrt        search for ','\n         SR    r1,r3              calculate parameter length\n         SH    r1,=Y(1)            minus one\n         BM    gotprddn            continue if missing\n         CH    r1,=Y(8)           test length\n         BNL   Ebadparm            error if too long\n         XC    drwdw,drwdw        clear double word work area\n         EX    r1,parmmvc         copy 3rd parameter\n         TR    drwdw,upcase       convert to uppercase\n         MVC   drwprddn,drwdw     copy the message ddname\ngotprddn LA    r1,2(,r1)          length of parm + ','\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/* -------------------------------------------------------------------\n*   print initialization message\n* ------------------------------------------------------------------ */\n         TIME  DEC\n         STM   r0,r1,drwctime     get time and date of dump/restore\n         LA    r1,drwctime\n         LA    r0,drwdtime\n         BAL   re,dtime\n         MVC   drwfcn,=CL8'dump'  set function to DUMP\n         TM    drwflags,drwdump    dump function ?\n         BO    *+10                 jumps if yes\n         MVC   drwfcn,=CL8'restore'  else set function to RESTORE\n        #MSG   '%s:8 %d:1.%d:1.%d:1 %s starting on %s:20',             X\n               pgmid,vrm,vrm+1,vrm+2,drwfcn,drwdtime\n\n*/* -------------------------------------------------------------------\n*   open the backup file\n* ------------------------------------------------------------------ */\n         MVC   drwbdcb,budcbo    presume dump dcb\n         TM    drwflags,drwdump   dump function ?\n         BO    *+10                yes, continue\n         MVC   drwbdcb,budcbi       else copy restore dcb\nbdcb     USING IHADCB,drwbdcb\nbdcbe    USING DCBE,drwbdcbe\n         MVC   bdcb.DCBDDNAM,drwbuddn set backup ddname\n         MVC   drwbdcbe,budcbe   copy the backup dcbe\n         LA    r1,drwbdcbe       set backup dcbe address\n         ST    r1,bdcb.DCBDCBE    in the backup dcb\n         DEVTYPE bdcb.DCBDDNAM,drwdevta get device info, max blk size\n         LTR   rf,rf             test devtype return code\n         BNZ   Edevterr           error if non-zero\n         L     r0,drwdevta+4     load maximum block size\n         STCM  r0,3,bdcb.DCBBLKSI      set dcb block size\n         MVC   drwopenl,openl    copy open list\n         TM    drwflags,drwdump  dump function ?\n         BNO   *+8                jumps if not\n         OI    drwopenl,15         else turn on 'output' bits\n         OPEN  (drwbdcb),MODE=31,MF=(E,drwopenl) open the backup file\n         TM    bdcb.DCBOFLGS,DCBOFOPN did backup file open ?\n         BNO   Eopenerr                 no, open error\n\n*/* -------------------------------------------------------------------\n*   if restore, read the header block\n* ------------------------------------------------------------------ */\n         TM    drwflags,drwdump  is this a restore ?\n         BO    notrest            no, continue\n         MVC   bdcbe.DCBEEODA,=A(Einnull)  set end-of-data exit addr\n         GET   drwbdcb            read 1st block\n         CLC   bdcb.DCBLRECL,=Y(odhdrl) check block length\n         BNE   Ebadhdr            error if bad\n         MVC   drwodhdr(256),0(r1) copy the header\n         MVC   drwodhdr+256(256),256(r1)\n         CLC   drwunit,=Y(-1)     default unit ?\n         BNE   *+10                no, continue\n         USING odhdr,drwodhdr\n         MVC   drwunit,odunit       else use dumped unit\nnotrest  DS    0H\n\n*/* -------------------------------------------------------------------\n*   enq on the program id and the device name\n* ------------------------------------------------------------------ */\n         UNPK  drwdw(5),drwunit(3) convert the unit address to char\n         MVC   drwminor,drwdw\n         TR    drwminor,hex2char\n         MVC   drwmajor,pgmid    get program id uppercased\n         TR    drwmajor,upcase\n         MVC   drwenql,enql      copy enq parameter list\n         TM    drwflags,drwdump  dump function ?\n         BO    *+8                yes, shared request\n         NI    drwenql+2,X'7f'     else change to exclusive request\n         ENQ   (drwmajor,drwminor,,L'drwminor,SYSTEMS),                X\n               MF=(E,drwenql)\n         OI    drwflags,drwenqd  indicate resource enqueued\n\n*/* -------------------------------------------------------------------\n*   'fake-open' the offline device\n* ------------------------------------------------------------------ */\n\n*/* -------------------------------------------------------------------\n*   look for the ucb for the unit & make sure it's an offline dasd\n* ------------------------------------------------------------------ */\n         MVC   drwulpl,ulpl       copy ucblook parameter list\n         MODESET MODE=SUP\n         UCBLOOK DEVN=drwunit,UCBPTR=drwucba,PIN,PTOKEN=drwptok,       X\n               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,drwulpl),           X\n               TEXT==C'OFFLINDR offline dasd lookup'\n         STM   rf,r0,drwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,drwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ucblook return code\n         BNZ   Ebaducbl           ucblook error\n         OI    drwflags,drwpin    indicate ucb has been pinned\n         L     r2,drwucba         load ucb addr\n         USING UCBOB,r2\n         CLI   UCBTBYT3,UCB3DACC  check for dasd ucb\n         BNE   Ebaducbt            not a dasd unit\n         TM    UCBSTAT,UCBONLI    is device online ?\n         BO    Ebaducbs            dasd unit is not offline\n\n*/* -------------------------------------------------------------------\n*   if we got a 31-bit address then we need to 'capture' a 24-bit addr\n* ------------------------------------------------------------------ */\n         MVC   drwcucba,drwucba   copy ucb address\n         TM    drwucba,X'ff'      is it a 31 bit address ?\n         BZ    cucbok              no, continue\n         MVC   drwcupl,cupl       copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU CAPTUCB,UCBPTR=drwucba,CAPTPTR=drwcucba,              X\n               MF=(E,drwcupl)     capture a 24-bit ucb addr\n         STM   rf,r0,drwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,drwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ioscapu return code\n         BNZ   Ebaducbc           ioscapu error\n         OI    drwflags,drwcucb   indicate ucb has been captured\ncucbok   DS    0H\n\n*/* -------------------------------------------------------------------\n*   build a dcb for the offline dasd\n* ------------------------------------------------------------------ */\n         MVC   drwodcb,oddcb      copy otptut model dcb\nodcb     USING IHADCB,drwodcb\n         MVC   odcb.DCBMACRF,odcb.DCBMACR copy macro reference bits\n\n*/* -------------------------------------------------------------------\n*   build a deb for the offline dasd\n* ------------------------------------------------------------------ */\n         MODESET MODE=SUP,KEY=ZERO\n         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW\n         ST    r1,drwdeba         save deb address\n         XC    0(DEBLENGTH,r1),0(r1) clear the deb\n         LR    r3,r1              appendage vector table/basic sections\n         USING DEBAVT,r3\n         LA    r4,DEBBASND-DEBAVT(,r3) debdasd section\n         USING DEBDASD,r4\n         LA    r5,DEBDASDE-DEBDASD(,r4) deb extension section\n         USING DEBXTN,r5\n         L     r6,CVTPTR          get cvt address\n         USING CVT,r6\n         L     rf,CVTXAPG         ios appendage vector table\n         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf) copy vector table\n         ST    r5,DEBXTNP         set extension address\n         USING PSA,r0\n         L     r7,PSATOLD         get tcb address\n         USING TCB,r7\n         ST    r7,DEBTCBAD        set tcb address\n         OI    DEBFLGS1,DEBXTNIN  indicate extension exists\n         LA    r0,drwodcb         get dcb address\n         ST    r0,DEBDCBAD        set dcb address\n         MVI   DEBDEBID,15        set deb identifier\n         OC    DEBPROTG,TCBPKF    set protection key\n         ST    r3,DEBAPPAD        set appendage table address\n         MVC   DEBUCBA,drwcucba+1 set ucb address\n         MVC   DEBXLNGH,=Y(DEBXLEN) set extension length\n         LA    r1,DEBBASIC        get basic section address\n         STCM  r1,7,odcb.DCBDEBA  set deb address in the dcb\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         MVC   DEBDEBB,TCBDEB+1   set address next deb\n         LA    r1,DEBBASIC        get basic section address\n         ST    r1,TCBDEB          chain deb to the tcb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n\n*/* -------------------------------------------------------------------\n*   add the deb to the deb list\n* ------------------------------------------------------------------ */\n         DEBCHK drwodcb,TYPE=ADD,AM=EXCP\n         STM   rf,r0,drwretcd\n         MODESET MODE=PROB,KEY=NZERO\n         LM    rf,r0,drwretcd\n         LTR   rf,rf              test debchk add return code\n         BNZ   Ebaddeba            debchk add failed\n         OI    drwflags,drwdebad  indicate deb was added\n\n*/* -------------------------------------------------------------------\n*   build the dasd extent\n* ------------------------------------------------------------------ */\n         MODESET MODE=SUP,KEY=ZERO\n         MVC   DEBUCBAD,drwcucba  set 24-bit ucb addr\n         MVI   DEBDVMOD,0         set device modifier\n         MVC   DEBENDCC,=X'7fff'  set end cylinder\n         MVC   DEBENDHH,=X'00ff'  set end head\n         MVC   DEBNMTRK,=X'7fff'  set number tracks in extent\n         MODESET MODE=PROB,KEY=NZERO\n\n         DROP  r0,r2,r3,r4,r6,r7\n\n*/* -------------------------------------------------------------------\n*   build a couple of iobs\n* ------------------------------------------------------------------ */\ni1       USING IOBSTDRD,drwiob1\n         OI    i1.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,drwoecb1\n         ST    r1,i1.IOBECBPT\n         LA    r1,drwoccw1\n         ST    r1,i1.IOBSTART\n         LA    r1,drwodcb\n         ST    r1,i1.IOBDCBPT\ni2       USING IOBSTDRD,drwiob2\n         OI    i2.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,drwoecb2\n         ST    r1,i2.IOBECBPT\n         LA    r1,drwoccw1\n         LA    r1,drwoccwl(,r1)\n         ST    r1,i2.IOBSTART\n         LA    r1,drwodcb\n         ST    r1,i2.IOBDCBPT\n\n*/* -------------------------------------------------------------------\n*   turn off the 'not ready' bit\n* ------------------------------------------------------------------ */\n         L     r2,drwucba        load ucb addr\n         USING UCBOB,r2\n         TM    UCBFLA,UCBNRY     is 'not ready' bit on ?\n         BNO   nryok              no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         NI    UCBFLA,255-UCBNRY turn off 'not ready' bit\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\n         OI    drwflags,drwnry   indicate we turned the bit off\nnryok    DS    0H\n\n*/* -------------------------------------------------------------------\n*   sense the offline device\n* ------------------------------------------------------------------ */\n         LA    r2,drwoccw1\n         USING CCW0,r2\n\n         MODESET MODE=SUP,KEY=ZERO\n         OI    DEBXFLG2,DEBCHCMP+DEBBYP bypass excp prefixing\n         MODESET MODE=PROB,KEY=NZERO\n\n*/* seek                                                            */\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,SK         set seek command\n         LA    r1,drwzeros\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(6)      set count\n         EXCP  drwiob1\n         WAIT  1,ECB=drwoecb1     wait for SK\n         CLI   drwoecb1,ECBNORM  test post code\n         BNE   Esnserr            error\n\n*/* Sense ID                                                        */\n         XC    drwoecb1,drwoecb1  clear the ecb\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,SNSID      set sense-id command\n         LA    r1,drwsnsid\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'drwsnsid) set count\n         EXCP  drwiob1\n         WAIT  1,ECB=drwoecb1     wait for SNSID\n         CLI   drwoecb1,ECBNORM  test post code\n         BNE   Esnserr            error\n\n*/* Sense                                                           */\n         XC    drwoecb1,drwoecb1  clear the ecb\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,SNS        set sense command\n         LA    r1,drwsns\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'drwsns) set count\n         EXCP  drwiob1\n         WAIT  1,ECB=drwoecb1     wait for SNS\n         CLI   drwoecb1,ECBNORM  test post code\n         BNE   Esnserr            error\n\n*/* Read Device Characteristics                                     */\n         XC    drwoecb1,drwoecb1  clear the ecb\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,RDC        set read-characteristics command\n         LA    r1,drwrdc\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,0         clear flag bits\n         MVC   CCW0CNT,=Y(L'drwrdc) set count\n         EXCP  drwiob1\n         WAIT  1,ECB=drwoecb1     wait for RDC\n         CLI   drwoecb1,ECBNORM  test post code\n         BNE   Esnserr            error\n\n*/* Sense Subsystem Status\n         XC    drwoecb1,drwoecb1  clear the ecb\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,SNSS       set sense-subsystem-status command\n         LA    r1,drwsnss\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'drwsnss)  set count\n         EXCP  drwiob1\n         WAIT  1,ECB=drwoecb1     wait for SNSS\n         CLI   drwoecb1,ECBNORM  test post code\n         BNE   Esnserr            error\n\n         MODESET MODE=SUP,KEY=ZERO\n         NI    DEBXFLG2,255-DEBBYP turn off debbyp bit\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2,r5\n\n*/* -------------------------------------------------------------------\n*   call the function\n* ------------------------------------------------------------------ */\n\n         L     rf,=A(dumpr)      presume backup function\n         TM    drwflags,drwdump\n         BO    *+8                jumps if backup\n         L     rf,=A(restorer)     otherwise restore function\n         BALR  re,rf             call the function\n\n*/* function was successful !!                                       */\n        #MSG   '%s:8 %d:1.%d:1.%d:1 %s successful: device %x4:2  cylindX\n               ers 0x%x4:2 thru 0x%x4:2',                              X\n               pgmid,vrm,vrm+1,vrm+2,drwfcn,drwunit,drwlocyl,drwhicyl\n\n*/* -------------------------------------------------------------------\n*   cleanup and terminate\n* ------------------------------------------------------------------ */\n\nterminat DS    0H\n\n*/* close the backup file                                            */\nbdcb     USING IHADCB,drwbdcb\n         TM    bdcb.DCBOFLGS,DCBOFOPN is backup file open ?\n         BNO   term1                   no, continue\n         CLOSE (drwbdcb),MODE=31,MF=(E,drwopenl)\nterm1    DS    0H\n\n*/* free the i/o areas                                               */\n         L     r1,drwioa         load i/o area addr\n         LTR   r1,r1              any i/o area ?\n         BZ    term2               no, continue\n         L     r2,drwiol            load i/o area length\n         SLL   r2,1                  length of two i/o areas\n         STORAGE RELEASE,ADDR=(1),LENGTH=(r2)\nterm2    DS    0H\n\n*/* call debchk to delete the deb                                    */\n         TM    drwflags,drwdebad was deb added to the deb chain ?\n         BNO   term3              no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK drwodcb,TYPE=DELETE,AM=EXCP delete the deb\n         MODESET MODE=PROB,KEY=NZERO\nterm3    DS    0H\n\n         L     r2,drwdeba        load deb area addr\n         LTR   r2,r2              any deb area ?\n         BZ    term4               no, continue\n\n*/*      remove the deb from the deb chain                           */\n         USING DEBAVT,r2\n         LA    r3,DEBBASIC\n         DROP  r2\n         L     r4,PSATOLD-PSA    get tcb addr\n         USING TCB,r4\n         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)\n         USING DEBBASIC,r4\n         MODESET MODE=SUP,KEY=ZERO\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         SPKA  X'80'\ntermdeb  LR    r4,r5\n         SLR   r5,r5\n         ICM   r5,7,DEBDEBB      addr next deb\n         BZ    termdebx           exit if we didn't found ours\n         CLR   r3,r5             found our deb ?\n         BNE   termdeb            no, keep looking\n         SPKA  0                   need key 0 to update a deb\n         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5) remove the deb\n         DROP  r4\ntermdebx SPKA  0                   need key 0 to update a deb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n\n*/*      free deb storage                                            */\n         MODESET MODE=SUP,KEY=ZERO\n         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230 free the deb storage\n         MODESET MODE=PROB,KEY=NZERO\nterm4    DS    0H\n\n*/*      turn the ucb 'not ready' bit back on if we turned it off    */\n         TM    drwflags,drwnry   did we turn the bit off ?\n         BNO   term5              no, continue\n         L     r2,drwucba        load ucb address\n         USING UCBOB,r2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    UCBFLA,UCBNRY     turn the bit back on\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\nterm5    DS    0H\n\n*/*      uncapture the ucb                                           */\n         TM    drwflags,drwcucb  was ucb captured ?\n         BNO   term6              no, continue\n         MVC   drwcupl,cupl        copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU UCAPTUCB,CAPTPTR=drwcucba,                            X\n               MF=(E,drwcupl)       uncapture the 24-bit ucb addr\n         MODESET MODE=PROB\nterm6    DS    0H\n\n*/*      unpin the ucb                                               */\n         TM    drwflags,drwpin   was ucb pinned ?\n         BNO   term7              no, continue\n         MVC   drwuupl,uupl        copy ucbpin unpin  parameter list\n         MODESET MODE=SUP\n         UCBPIN UNPIN,PTOKEN=drwptok,MF=(E,drwuupl)  unpin the ucb\n         MODESET MODE=PROB\nterm7    DS    0H\n\n*/* close the sysprint file                                          */\npdcb     USING IHADCB,drwpdcb\n         TM    pdcb.DCBOFLGS,DCBOFOPN is sysprint file open ?\n         BNO   term8                    no, continue\n         CLOSE (drwpdcb),MODE=31,MF=(E,drwopenl)\nterm8    DS    0H\n\n*/*      release the enq                                             */\n         TM    drwflags,drwenqd   was enq issued ?\n         BNO   term9\n         DEQ   (drwmajor,drwminor,L'drwminor,SYSTEMS),                 X\n               MF=(E,drwenql)\nterm9    DS    0H\n\n*/*      free the work areas                                         */\n         STORAGE RELEASE,ADDR=(rb),LENGTH=o24wl free 24-bit area\n         LR    r1,rd\n         L     r2,drwrsult\n         L     rd,4(,rd)\n         STORAGE RELEASE,ADDR=(1),LENGTH=drwl   free work area\n\n         LR    rf,r2                            copy result reg\n         RETURN (14,12),RC=(15)\n\n*/* -------------------------------------------------------------------\n*   calculate length of a track image\n* ------------------------------------------------------------------ */\ntrklen   STM   r0,r2,12(rd)       save some regs\n         LR    rf,r1              copy image addr\ntlloop   CLC   =X'ffffffffffffffff',0(rf)  at the end ?\n         BE    tlexit                         yes, exit\n         SLR   r0,r0\n         IC    r0,5(,rf)          key length\n         SLR   r2,r2\n         ICM   r2,3,6(rf)         data length\n         AR    rf,r0              add key length\n         LA    rf,8(rf,r2)        add count and data length\n         B     tlloop\ntlexit   LA    rf,8(,rf)          point past end of track indicator\n         SR    rf,r1              calculate track image length\n         LM    r0,r2,12(rd)       restore work regs\n         BR    re                 return\n\n*/* -------------------------------------------------------------------\n*   return nbr records for a track image or 0 for an incomplete image\n* ------------------------------------------------------------------ */\nchktrk   STM   r0,r3,12(rd)       save some regs\n         SLR   rf,rf              init record count\n         LR    r2,r1              calculate ending address\n         AR    r2,r0               of the track image\n         SH    r2,=Y(8)           backup to beginning of the ff..ff\nctloop   CLC   =X'ffffffffffffffff',0(r1)  at the end ?\n         BE    ctexit                         yes, exit\n         LA    rf,1(,rf)          increment number of records\n         SLR   r0,r0\n         IC    r0,5(,r1)          key length\n         SLR   r3,r3\n         ICM   r3,3,6(r1)         data length\n         AR    r1,r0              add key length\n         LA    r1,8(r1,r3)        add count and data length\n         CR    r1,r2              past end of the buffer ?\n         BNH   ctloop              no, continue\n         SLR   rf,rf              indicate image incomplete\nctexit   LM    r0,r3,12(rd)       restore work regs\n         BR    re                 return\n\n*/* -------------------------------------------------------------------\n*   format date & time\n* ------------------------------------------------------------------ */\ndtime    STM   re,r2,12(rd)       save some regs\n         LR    r2,r0              copy output area address\n         MVI   0(r2),C' '         blank the output area\n         MVC   1(19,r2),0(r2)\n         MVC   11(9,r2),=X'4021207a20207a2020' edit pattern for time\n         ED    11(9,r2),0(r1)     edited time\n         XC    drwdw,drwdw        clear double word work area\n         SLR   rf,rf\n         ICM   rf,3,4(r1)         decimal year\n         SLL   rf,4               shift over a nibble\n         ST    rf,drwdw+4         store in the double word\n         OI    drwdw+7,X'0f'      set bottom nibble\n         AP    drwdw,=P'1900'     calculate the year\n         OI    drwdw+7,X'0f'      fix bottom nibble for unpk\n         UNPK  7(4,r2),drwdw      set the year\n         CVB   rf,drwdw           get binary year\n         N     rf,=A(3)           test for leap year\n         BZ    *+8                 jumps if leap year\n         LA    rf,2                 else set non-leapyr offset\n         ZAP   drwdw,6(2,r1)      get julian day in double word\n         CVB   r0,drwdw           get julian day binary\n         LA    re,dtjtab          point to julian table\ndtfind   CH    r0,8(rf,re)        found table entry ?\n         BNH   dtfound             yes, exit loop\n         LA    re,8(,re)          point to next entry\n         B     dtfind              and loop back\ndtfound  MVC   3(3,r2),4(re)      set month from the table\n         SH    r0,0(rf,re)        calculate day of month\n         CVD   r0,drwdw           get day of month packed\n         L     r0,drwdw+4         load packed day\n         SLL   r0,20              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,0(,r2)          set 1st digit of the month\n         OI    0(r2),C'0'         convert to ebcdic character\n         L     r0,drwdw+4         load packed day\n         SLL   r0,24              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,1(,r2)          set 2nd digit of the month\n         OI    1(r2),C'0'         convert to ebcdic character\n         LM    re,r2,12(rd)       restore regs\n         BR    re                  and thankfully return\ndtjtab   DC    Y(0,0),C'Jan '     Julian date table\n         DC    Y(31,31),C'Feb '\n         DC    Y(60,59),C'Mar '\n         DC    Y(91,90),C'Apr '\n         DC    Y(121,120),C'May '\n         DC    Y(152,151),C'Jun '\n         DC    Y(182,181),C'Jul '\n         DC    Y(213,212),C'Aug '\n         DC    Y(244,243),C'Sep '\n         DC    Y(274,273),C'Oct '\n         DC    Y(305,304),C'Nov '\n         DC    Y(335,334),C'Dec '\n         DC    Y(999,999),C'??? '\n\n*/* -------------------------------------------------------------------\n*   error routines\n* ------------------------------------------------------------------ */\n\nbdc      USING RDCinfo,odrdc\nodc      USING RDCinfo,drwrdc\n\nEnoparm #MSG   'No parameters were specified'\n         B     Eexit\nEbadparm MVC   drwdw4,=CL8' '     init dw to blanks\n         CH    r4,=Y(8)           test parameter length left\n         BNH   *+8                 continue if not too long\n         LA    r4,8                 else reset length\n         SH    r4,=Y(1)           decrement for EX\n         BM    *+4+4+6             bypass copy if nothing left\n         EX    r4,*+4               copy area near the error\n         MVC   drwdw4(0),0(r3)       (executed)\n        #MSG   '** Error in parameters near %s:8',drwdw4\n         B     Eexit\nEdevterr STM   rf,r0,drwretcd\n         CLC   drwretcd(8),=A(4,4)  missing ddname ?\n         BE    Enoddn                yes, noddn error\n        #MSG   '** %s DEVTYPE error, rc=%d, reason=%d',                X\n               drwbuddn,drwretcd,drwrsncd\n         B     Eexit\nEnoddn  #MSG   '** Backup ddname %s not found',drwbuddn\n         B     Eexit\nEopenerr #MSG  '** Backup file %s did not open',drwbuddn\n         B     Eexit\nEbadhdr #MSG   '** Backup file %s header record is not valid',drwbuddn\n         B     Eexit\nEbadvrm #MSG   '** Backup file created by newer dump program: %s %d:1.%X\n               d:1.%d.1',odhdrid,odvrm,odvrm+1,odvrm+2\n         B     Eexit\nEbadloc #MSG   '** Requested low cylinder 0x%x4:2 is before dump low cyX\n               linder 0x%x4:2',drwlocyl,odlocyl\n         B     Eexit\nEbadhic #MSG   '** Requested high cylinder 0x%x4:2 is after dump high cX\n               ylinder 0x%x4:2',drwhicyl,odhicyl\n         B     Eexit\nEbadcyl #MSG   '** Requested low cylinder 0x%x4:2 is after requested hiX\n               gh cylinder 0x%x4:2',drwlocyl,drwhicyl\n         B     Eexit\nEbaducbl CH    RF,=Y(4)\n         BE    Enoucb\n        #MSG   '** UCBLOOK error for unit %x4:2: rc 0x%x rsn 0x%x',    X\n               drwunit,drwretcd,drwrsncd\n         B     Eexit\nEnoucb  #MSG   '** UCB not found for output unit %x4:2',drwunit\n         B     Eexit\nEbaducbt L     r2,drwucba\n         USING UCBOB,r2\n        #MSG   '** UCB for unit %x4:2 is not dasd, type is %x:1',      X\n               drwunit,UCBTBYT3\n         B     Eexit\nEbaducbs #MSG  '** Device %x4:2 is not offline',drwunit\n         B     Eexit\nEbaducbc #MSG  '** IOSCAPU CAPTUCB failed for %x4:2; rc=0x%x rsn=0x%x',X\n               drwunit,drwretcd,drwrsncd\n         B     Eexit\nEbaddeba #MSG  '** DEBCHK ADD for %x4:2 failed; rc=0x%x',              X\n               drwunit,drwretcd\n         B     Eexit\nEsnserr #MSG   '** Sense failed for 0x%x4:2: command %x2:1, CC 0x%x2:1,X\n                Stat 0x%x4:2',drwunit,drwoccw1,drwoecb1,i1.IOBSTBYT\n         B     Eexit\nEioerr   SLR   r2,r2\n         ICM   r2,7,drwtecb+1\n         LA    r0,drwoecb1\n         LA    r3,drwiob1\n         CLR   r0,r2\n         BE    *+8\n         LA    r3,drwiob2\n         USING ECB,r2\n         USING IOBSTDRD,r3\n         MVC   drwdw4,=CL8'reading'\n         TM    drwflags,drwdump\n         BO    *+10\n         MVC   drwdw4,=CL8'writing'\n        #MSG   '** I/O error %s %x4:2 CCHH %x8: CC %x2:1, Stat %x4:2', X\n               drwdw4,drwunit,drwpcchh,ECBCC,IOBSTBYT\n         DROP  r2,r3\n         B     Eexit\nEbadtrk #MSG   '** Bad track image returned by RT on %x4:2',drwunit\n         B     Eexit\nEmisdevt #MSG  '** Device type mis-match: backup file is %x4:2 and unitX\n                %x4:2 is %x4:2',bdc.RDCdevt,drwunit,odc.RDCdevt\n         B     Eexit\nEmishds #MSG  '** Device number of heads mis-match: backup file has %d:X\n               2 and unit %x4:2 has %d',                               X\n               bdc.RDCheads,drwunit,odc.RDCheads\n         B     Eexit\nEmiscyl  SLR   r2,r2\n         ICM   r2,3,odc.RDCprime\n         BCTR  r2,0\n         ST    r2,drwretcd\n        #MSG   '** Requested high cylinder 0x%x4:2 exceeds highest cyliX\n               nder 0x%x4 on unit %x4:2',drwhicyl,drwretcd,drwunit\n         B     Eexit\nEbadlen #MSG   '** Track image size exceeded read cchh %x8 on %s',     X\n               0(r3),drwbuddn\n         B     Eexit\nEinnull #MSG   '** Input file %s is empty',drwbuddn\n         B     Eexit\nEinctrk #MSG   '** %s end-of-file detected while reading track image', X\n               drwunit\n         B     Eexit\nEfileinc #MSG  '** File %s was incomplete, trying to restore to cylindeX\n               r 0x%x4:2 but last CCHH read was 0x%x8',                X\n               drwbuddn,drwhicyl,drwcchh\n         B     Eexit\n\nEexit    MVC   drwrsult,=A(16)    error return code\n         B     terminat           terminate\n\n*/* -------------------------------------------------------------------\n*   literals and constants\n* ------------------------------------------------------------------ */\n         LTORG ,\nRESTORE  DC    C'RESTORE',X'00'\nDUMP     DC    C'DUMP',X'00'\nASIS     DC    C'ASIS',X'00'\ndelimtrt TRT   0(0,r3),delimtab   *** executed ***\nparmmvc  MVC   drwdw(0),0(r3)     *** executed ***\nparmclc  CLC   0(0,rf),drwdw      *** executed ***\nparmhexc TRT   drwdw(0),hexchars  *** executed ***\nparmhex  TR    drwdw(0),hextab    *** executed ***\nparmpack PACK  drwdw2,drwdw(0)    *** executed ***\noddcb    DCB   DDNAME=0,DSORG=PS,MACRF=E\noddcbl   EQU   *-oddcb\nbudcbi   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=GL,RECFM=U,DCBE=budcbe\nbudcbl   EQU   *-budcbi\nbudcbo   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=PL,RECFM=U,DCBE=budcbe\nbudcbe   DCBE  RMODE31=BUFF\nbudcbel  EQU   *-budcbe\nprtdcb   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,DCBE=PRTDCBE\nprtdcbl  EQU   *-prtdcb\nprtdcbe  DCBE  RMODE31=BUFF\nprtdcbel EQU   *-prtdcbe\nopenl    OPEN  (0),MODE=31,MF=L\nopenll   EQU   *-openl\nenql     ENQ   (0,0,S,0,SYSTEMS),MF=L\nenqll    EQU   *-enql\n         UCBLOOK MF=(L,ulpl)\n         UCBPIN MF=(L,uupl)\n         IOSCAPU MF=(L,cupl)\ntbpl     TRKCALC MF=L\ntbpll    EQU   *-tbpl\nhextab   DC    256X'00'\n         ORG   hextab+C'0'\n         DC    AL1(0,1,2,3,4,5,6,7,8,9)\n         ORG   hextab+C'a'\n         DC    AL1(10,11,12,13,14,15)\n         ORG   hextab+C'A'\n         DC    AL1(10,11,12,13,14,15)\n         ORG   hextab+256\ndelimtab DC    256x'0'\n         ORG   delimtab+C','\n         DC    X'ff'\n         ORG   delimtab+256\n         DROP  ,\nhexchars DC    256x'ff'\n         ORG   hexchars+C'a'\n         DC    6x'0'\n         ORG   hexchars+C'A'\n         DC    6x'0'\n         ORG   hexchars+C'0'\n         DC    10x'0'\n         ORG   hexchars+256\nupcase   DC    C' ',255AL1(*-upcase)\n         ORG   upcase+c'a'\n         DC    C'ABCDEFGHI'\n         ORG   upcase+c'j'\n         DC    C'JKLMNOPQR'\n         ORG   upcase+c's'\n         DC    C'STUVWXYZ'\n         ORG   upcase+256\nhex2char EQU   *-240\n         DC    C'0123456789ABCDEF'\n         DROP  ,\nmainend  DS    0D\n\n*/* -------------------------------------------------------------------\n*   Dump routine\n* ------------------------------------------------------------------ */\n         USING odrw,rd\n         USING o24w,rb\n         USING OFFLINDR,rc\n         USING (OFFLINDR+4095,mainend),ra\n         USING dumpr,r9\nodc      USING RDCinfo,drwrdc\n\ndumpr    STM   r0,rf,drwsave0     save caller's registers\n         LR    r9,rf              set local base\n\n*/* -------------------------------------------------------------------\n*   set defaults\n* ------------------------------------------------------------------ */\n         CLC   drwlocyl,=Y(-1)    default low cylinder ?\n         BNE   *+10                no, continue\n         XC    drwlocyl,drwlocyl    else use cylinder 0\n\n         CLC   drwhicyl,=Y(-1)    default high cylinder ?\n         BNE   d_hicok             no, continue\n         SLR   r1,r1                else use\n         ICM   r1,3,odc.RDCprime     primary cylinders\n         BCTR  r1,0                   decrement (relative to 0)\n         STCM  r1,3,drwhicyl\nd_hicok  DS    0H\n\n*/* -------------------------------------------------------------------\n*   build the offline dump header\n* ------------------------------------------------------------------ */\n         USING odhdr,drwodhdr\n         MVC   odhdrid,pgmid     set identifier\n         MVC   odvrm,vrm         set version/release/modlvlv\n         MVC   odtime(8),drwctime set time and date\n         MVC   odunit,drwunit    set offline unit address\n         MVC   odlocyl,drwlocyl  set low cylinder\n         MVC   odhicyl,drwhicyl  set high cylinder\n         MVC   odsnsid,drwsnsid  set sense-id info\n         MVC   odsns,drwsns      set sense info\n         MVC   odrdc,drwrdc      set device characteristics info\n         MVC   odsnss,drwsnss    set sense-subsystem info\n\n        #MSG   'device %x4:2 is a %x4:2 and has %d:2 cylinders',       X\n               drwunit,odc.RDCdevt,odc.RDCprime\n\n*/* -------------------------------------------------------------------\n*   get i/o buffers\n* ------------------------------------------------------------------ */\n         SLR   r3,r3              clear reg 3\n         ICM   r3,7,odc.RDCtrkln  load track size\n         LA    r3,4095(,r3)       round-up\n         SRL   r3,12               to a 4K\n         SLL   r3,12                boundary\n         ST    r3,drwtrksz        remember track size\n         SLR   r4,r4              clear r4\n         ICM   r4,3,odc.RDCheads  load tracks/cylinder\n         ST    r4,drwheads        remember tracks/cylinder\n         MR    r2,r4              size of an i/o area\n         ST    r3,drwiol          save i/o area size\n         SLL   r3,1               size of 2 i/o areas\n         STORAGE OBTAIN,LENGTH=(r3) get the i/o areas\n         ST    r1,drwioa          save i/o area addr\n\n*/* -------------------------------------------------------------------\n*   build the channel programs\n* ------------------------------------------------------------------ */\n         LA    r2,drwoccw1        point to 1st channel program\n         USING CCW0,r2\n         LA    r3,drwlrp1         point to 1st locate record parms\n         USING LRparm,r3\n         L     r4,drwioa          point to 1st i/o area\n         LA    r5,drwoida1        point to 1st idaw list\n         LA    rf,2               build two channel programs\nd_bldcp  XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,DX         set define extent command\n         LA    r1,drwdxa          address of dx area\n         STCM  r1,7,CCW0ADDR      set address\n         MVI   CCW0FLAG,CCW0CC    command chaining\n         MVC   CCW0CNT,=Y(L'drwdxa) set length\n         LA    r2,CCW0END         to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,TIC        set transfer-in-control command\n         LA    r1,CCW0END         address of next ccw\n         STCM  r1,7,CCW0ADDR      set next ccw address\n         LA    r2,CCW0END         to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,LR         set locate record command\n         STCM  r3,7,CCW0ADDR      set address in locate record ccw\n         OI    CCW0FLAG,CCW0CC    command chaining\n         MVC   CCW0CNT,=Y(LRparml) set length\n         MVI   LRop,LRohome+LRrt  set operation byte\n         L     r0,drwheads        number trks/cyls\n         STC   r0,LRcount         set number reads\n         L     r6,drwtrksz        load track size\nd_bldcp2 LA    r2,CCW0END         point to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,RT         set read track command\n         ST    r4,0(,r5)          set address for track image in idaw\n         STCM  r5,7,CCW0ADDR      set address for idaw\n         OI    CCW0FLAG,CCW0SLI+CCW0CC+CCW0IDA set flags\n         STCM  r6,3,CCW0CNT       set size\n         ALR   r4,r6              point to next track image\n         LA    r5,4(,r5)          point to next idaw\n         BCT   r0,d_bldcp2        loop for each track in a cylinder\n         NI    CCW0FLAG,255-CCW0CC unchain last ccw\n         LA    r2,drwoccw1        point to 2nd\n         LA    r2,drwoccwl(,r2)    channel program\n         LA    r3,drwlrp2         point to 2nd locate record parms\n         L     r4,drwioa          point to 2nd\n         AL    r4,drwiol           i/o area\n         LA    r5,drwoida2        point to 2nd idaw list\n         BCT   rf,d_bldcp         build 2nd channel program\n         DROP  r2,r3\n\n*/* -------------------------------------------------------------------\n*   setup the define extent area\n* ------------------------------------------------------------------ */\n         MVI   drwdxa,X'40'       inhibit write operations\n         MVI   drwdxa+1,X'c0'     eckd\n         MVC   drwdxa+8(2),drwlocyl set extents\n         MVC   drwdxa+12(2),drwhicyl\n         SLR   r1,r1\n         ICM   r1,3,odc.RDCheads\n         BCTR  r1,0\n         STCM  r1,3,drwdxa+14\n\n*/* -------------------------------------------------------------------\n*   read a cylinder at a time, flip/flopping iobs\n* ------------------------------------------------------------------ */\n         SLR   r2,r2              iob indicator\n         MVC   drwcchh,=A(-1)     init last cylinder/head\n         SLR   r3,r3\n         ICM   r3,3,drwlocyl      load low cylinder\n         SLR   r4,r4\n         ICM   r4,3,drwhicyl      load hicyl\n\nd_rdloop MVC   drwpcchh,drwcchh   save previous cchh read\n         LR    r0,r3\n         SLL   r0,16\n         STCM  r0,15,drwcchh      set current cchh\n         LA    r5,drwiob1         presume reading from iob 1\n         LTR   r2,r2               test flip/flop indicator\n         BZ    *+8                  jumps if zero\n         LA    r5,drwiob2            otherwise use iob 2\n         USING IOBSTDRD,r5\n\n*/*      read using iob 1 and wait for iob 2 to finish               */\n         CLR   r3,r4              all cylinders dumped ?\n         BH    d_rdwait            yes, bypass excp\n         MVC   IOBCC(4),drwcchh   set seek address\n         SLR   r6,r6\n         ICM   r6,7,IOBSTRTB      get channel program address\n         USING CCW0,r6\n         LA    r6,CCW0END         point past dx ccw\n         LA    r6,CCW0END         point past tic ccw\n         SLR   r7,r7\n         ICM   r7,7,CCW0ADDR      get locate record parm address\n         USING LRparm,r7\n         MVC   LRseek,IOBCC\n         MVC   LRsearch,IOBCC\n         DROP  r6,r7\n         EXCP  IOBSTDRD           read the cylinder\nd_rdwait SLR   r6,r6\n         ICM   r6,7,drwtecb+1     get ecb address to wait on\n         MVC   drwtecb,IOBECBPT    set next ecb address\n         LTR   r6,r6              need to wait ?\n         BZ    d_rdnext            no, bypass the wait\n         USING ECB,r6\n         WAIT  1,ECB=ECB          wait for previous i/o to finish\n         CLI   ECBCC,ECBNORM       test completion code\n         BNE   Eioerr               exit if i/o error\n         DROP  r5,r6\n\n         L     r1,drwioa          point to first i/o area\n         LTR   r2,r2               test flip/flop indicator\n         BNZ   *+8                  jumps if not zero\n         A     r1,drwiol             else point to 2nd i/o area\n\n*/*      write track images for the iob that just finished           */\n         L     r0,drwheads        get number of areas\n         L     rf,=A(d_writer)     addr of write routine\nd_wrtrk  BALR  re,rf                write the area\n         AL    r1,drwtrksz           to next i/o area\n         BCT   r0,d_wrtrk             loop if more areas\n\nd_rdnext X     r2,=A(1)           flip/flop iob indicator\n         CLR   r3,r4               finished reading ?\n         LA    r3,1(,r3)            increment cylinder if not\n         BNH   d_rdloop              loop back\n\n*/* -------------------------------------------------------------------\n*   return\n* ------------------------------------------------------------------ */\n         LM    r0,rf,drwsave0    restore regs\n         BR    re                 and return\n\n         LTORG ,\n         DROP\n\n*/* -------------------------------------------------------------------\n*   dump write routine\n* ------------------------------------------------------------------ */\n         USING odrw,rd\n         USING o24w,rb\n         USING OFFLINDR,rc\n         USING (OFFLINDR+4095,mainend),ra\n         USING d_writer,r9\n         USING IHADCB,drwbdcb\n\nd_writer STM   r0,rf,drwsave1     save regs\n         LR    r9,rf              set local base reg\n         LR    r2,r1              copy area address\n         TM    drwflags,drwhdrw   has the header been written ?\n         BO    d_hdrok             yes, continue\n\n*/*      write the header                                            */\n         LA    r5,odhdrl          length of header\n         STCM  r5,3,DCBLRECL      set lrecl to the length\n         PUT   drwbdcb            issue put\n         LR    r0,r1              copy the header into the buffer\n         LR    r1,r5\n         LA    r4,drwodhdr\n         MVCL  r0,r4\n         OI    drwflags,drwhdrw   indicate header has been written\n\n*/*      calculate track capacity if dasd                            */\n         CLI   drwdevta+2,UCB3DACC is output a dasd ?\n         BNE   d_hdrok              no, continue\n         MVI   drwr,1              record 1\n         MVC   drwdd,=Y(L'drwodhdr) length of record\n         L     r3,DCBDVTBL         device table\n         MVC   drwtbpl,tbpl        copy the parmlist\n         TRKCALC FUNCTN=TRKBAL,DEVTAB=(r3),RKDD=drwrkdd,               X\n               REGSAVE=YES,MF=(E,drwtbpl)\n         STCM  r0,3,drwtkbal      save the track balance\nd_hdrok  DS    0H\n\n*/*      get length of the track image                               */\n         LR    r1,r2              track image address\n         BAL   re,trklen          get track length\n         LTR   r3,rf              test length\n         BZ    Ebadtrk             error if invalid\n\n         USING STAR,drwtbpl\n\n*/*      write the track image, may require multiple puts            */\nd_wloop  LTR   r4,r3              check length left\n         BZ    d_exit              return if everything written\n         CL    r4,drwdevta+4      check length against max length\n         BNH   *+8                 else use\n         L     r4,drwdevta+4        max length\n\n*/*      if dasd, see if it will fit on the track                    */\n         CLI   drwdevta+2,UCB3DACC is output a dasd ?\n         BNE   d_lenok              no, continue\n         SLR   rf,rf\n         IC    rf,drwr             increment record number\n         LA    rf,1(,rf)\n         STC   rf,drwr\n         STCM  r4,3,drwdd          set data length\n         L     r5,DCBDVTBL         device table\n         SLR   r6,r6\n         ICM   r6,3,drwtkbal       get track balance\n         BZ    d_newtrk            new track if no balance\n         MVC   drwtbpl,tbpl        copy the parmlist\n         TRKCALC FUNCTN=TRKBAL,DEVTAB=(r5),RKDD=drwrkdd,BALANCE=(r6),  X\n               MAXSIZE=YES,REGSAVE=YES,MF=(E,drwtbpl)\n         STCM  r0,3,drwtkbal       save the track balance\n         CH    rf,=Y(4)            test return code\n         BL    d_lenok             block fits\n         BE    d_newtrk            no room left on the track\n         LR    r4,r0               copy max length\n         XC    drwtkbal,drwtkbal   zero track balance\n         B     d_lenok             use a shorter block\nd_newtrk MVI   drwr,1              set to record 1\n         TRKCALC FUNCTN=TRKBAL,DEVTAB=(r5),RKDD=drwrkdd,               X\n               REGSAVE=YES,MF=(E,drwtbpl)\n         STCM  r0,3,drwtkbal      save the track balance\nd_lenok  DS    0H\n\n*/*      put the track image                                         */\n         STCM  r4,3,DCBLRECL      set block length\n         PUT   drwbdcb\n         LR    r0,r1              copy the track image\n         LR    r1,r4\n         LR    re,r2\n         LR    rf,r4\n         MVCL  r0,re\n\n         AR    r2,r4              point past data written\n         SR    r3,r4              adjust length left\n         B     d_wloop            loop\n\n*/*      return from writer                                          */\nd_exit   LM    r0,rf,drwsave1     restore regs\n         BR    re                 return\n\n         LTORG ,\n\n*/* -------------------------------------------------------------------\n*   Restore routine\n* ------------------------------------------------------------------ */\n         USING odrw,rd\n         USING o24w,rb\n         USING OFFLINDR,rc\n         USING (OFFLINDR+4095,mainend),ra\n         USING restorer,r9\n         USING IHADCB,drwbdcb\n         USING DCBE,drwbdcbe\n         USING odhdr,drwodhdr\nbdc      USING RDCinfo,odrdc\nodc      USING RDCinfo,drwrdc\n\nrestorer STM   r0,rf,drwsave0     save caller's registers\n         LR    r9,rf              set local base\n\n*/* -------------------------------------------------------------------\n*   describe the backup file\n* ------------------------------------------------------------------ */\n         LA    r1,odtime\n         LA    r0,drwdtime\n         BAL   re,dtime\n        #MSG   'backup taken by %s:8 %d:1.%d:1.%d:1 on %s:20',         X\n               odhdrid,odvrm,odvrm+1,odvrm+2,drwdtime\n        #MSG   'backup unit %x4:2 devtype %x4:2 cyl 0x%x4:2 - 0x%x4:2',X\n               odunit,bdc.RDCdevt,odlocyl,odhicyl\n\n*/* -------------------------------------------------------------------\n*   set defaults\n* ------------------------------------------------------------------ */\n         CLC   drwunit,=Y(-1)     default unit ?\n         BNE   *+10                no, continue\n         MVC   drwunit,odunit       else use dumped unit\n\n         CLC   drwlocyl,=Y(-1)    default low cylinder ?\n         BNE   *+10                no, continue\n         MVC   drwlocyl,odlocyl     else use dumped low cylinder\n\n         CLC   drwhicyl,=Y(-1)    default high cylinder ?\n         BNE   *+10                no, continue\n         MVC   drwhicyl,odhicyl     else use dumped high cylinder\n\n*/* -------------------------------------------------------------------\n*   perform some checks\n* ------------------------------------------------------------------ */\n         CLC   pgmid,odhdrid      header id match ?\n         BNE   Ebadhdr             error if not\n         CLC   vrm(2),odvrm       check version and release\n         BL    Ebadvrm             error if we're back-level\n         CLC   drwlocyl,odlocyl   check low cylinder\n         BL    Ebadloc             error if too low\n         CLC   drwhicyl,odhicyl   check high cylinder\n         BH    Ebadhic             error if too high\n         CLC   drwlocyl,drwhicyl  check specified cylinders\n         BH    Ebadcyl             error if low cyl > high cyl\n\n        #MSG   'device %x4:2 is a %x4:2 and has %d:2 cylinders',       X\n               drwunit,odc.RDCdevt,odc.RDCprime\n\n         CLC   bdc.RDCdevt,odc.RDCdevt check device types\n         BNE   Emisdevt                 error if they don't match\n         CLC   bdc.RDCheads,odc.RDCheads check trks/cyl\n         BNE   Emishds                    error if they don't match\n         CLC   drwhicyl,odc.RDCprime   check hi cylinder\n         BNL   Emiscyl                  error if high cyl too high\n\n*/* -------------------------------------------------------------------\n*   get i/o buffers\n* ------------------------------------------------------------------ */\n         SLR   r2,r2\n         ICM   r2,7,bdc.RDCtrkln       total track length\n         LA    r2,4095(,r2)             round up to a page boundary\n         SRL   r2,12\n         SLL   r2,13                   size for two areas\n         STORAGE OBTAIN,LENGTH=(r2)\n         SRL   r2,1                    get size for one area\n         STM   r1,r2,drwioa            save i/o address, length\n\n*/* -------------------------------------------------------------------\n*   setup the output channel programs\n* ------------------------------------------------------------------ */\n         LA    r2,drwoccw1        point to 1st ccws\n         USING CCW0,r2\n         LA    r3,drwlrp1         point to 1st LR parameters\n         USING LRparm,r3\n         LA    r4,drwoida1        point to 1st idaw list\n         LA    rf,2               build 2 sets of ccws\nr_bldcp  XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,DX         set define extent command\n         LA    r1,drwdxa          address of dx area\n         STCM  r1,7,CCW0ADDR      set address\n         MVI   CCW0FLAG,CCW0CC    command chaining\n         MVC   CCW0CNT,=Y(L'drwdxa) set length\n         LA    r2,CCW0END         to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,TIC        set transfer-in-control command\n         LA    r1,CCW0END         address of next ccw\n         STCM  r1,7,CCW0ADDR      set next ccw address\n         LA    r2,CCW0END         to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         MVI   CCW0CMD,LR         set locate record command\n         STCM  r3,7,CCW0ADDR      set address in locate record ccw\n         OI    CCW0FLAG,CCW0CC    command chaining\n         MVC   CCW0CNT,=Y(LRparml) set length\n         MVI   LRop,LRohome+LRfwrite set operation byte\n         LA    r0,255             build 255 write ccws\n         LA    r1,WR0             1st command is write record zero\nr_bldcp2 LA    r2,CCW0END         point to next ccw\n         XC    CCW0(8),CCW0       clear the ccw\n         STC   r1,CCW0CMD         set read track command\n         STCM  r4,7,CCW0ADDR      set address for idaw\n         LA    r1,WCKD            remaining commands are write ckd\n         LA    r4,4(,r4)          point to next idaw\n         BCT   r0,r_bldcp2        loop back\n         LA    r2,drwoccw1        point to 2nd\n         LA    r2,drwoccwl(,r2)    channel program\n         LA    r3,drwlrp2         point to 2nd LR parameters\n         LA    r4,drwoida2        point to 2nd idaw list\n         BCT   rf,r_bldcp         build 2nd channel program\n         DROP  r2,r3\n\n*/* -------------------------------------------------------------------\n*   setup the define extent area\n* ------------------------------------------------------------------ */\n         MVI   drwdxa,X'c0'       permit all write operations\n         MVI   drwdxa+1,X'c0'     eckd\n         MVC   drwdxa+8(2),drwlocyl set extents\n         MVC   drwdxa+12(2),drwhicyl\n         SLR   r1,r1\n         ICM   r1,3,odc.RDCheads\n         BCTR  r1,0\n         STCM  r1,3,drwdxa+14\n\n*/* -------------------------------------------------------------------\n*   read track images\n* ------------------------------------------------------------------ */\n         SLR   r2,r2                   i/o flip/flop inidicator\n         MVC   drwcchh,=A(-1)          init read cylinder/head\n\nr_rdloop LM    r3,r4,drwioa            point to 1st i/o area\n         LTR   r2,r2                   test indicator\n         BZ    *+6                      jumps if zero\n         AR    r3,r4                     else point to 2nd area\n         LR    r4,r3                   set working area pointer\n         SLR   r5,r5                   set length read\n\n*/* read 1 or more blocks for the current track image                */\n         MVC   DCBEEODA,=A(r_rdeof)    set end-of-data exit addr\nr_rdblk  GET   drwbdcb                 read next block\n         MVC   DCBEEODA,=A(Einctrk)    set end-of-data exit addr\n         SLR   r6,r6\n         ICM   r6,3,DCBLRECL           load length read\n         AR    r5,r6                   length of track image so far\n         C     r5,drwiol               check length\n         BH    Ebadlen                 error if too long\n         LR    re,r4                   copy the block\n         LR    rf,r6\n         LR    r0,r1\n         LR    r1,r6\n         MVCL  re,r0\n         AR    r4,r6                   addr for next block\n         LR    r0,r5\n         LR    r1,r3\n         BAL   re,chktrk               check for entire track\n         LTR   rf,rf\n         BZ    r_rdblk                 loop back\n\n*/* check the cylinder just read                                     */\n         MVC   drwpcchh,drwcchh        remember previous cyl/head\n         MVC   drwcchh,0(r3)           remember cylinder/head read\n         CLC   drwlocyl,drwcchh        at low cylinder yet ?\n         BH    r_rdloop                 no, loop back\n         CLC   drwhicyl,drwcchh        past high cylinder ?\n         BL    r_rdeof                  yes, logical end-of-file\n\n*/* build the output channel program                                 */\n         LA    r4,drwiob1              presume 1st iob\n         LTR   r2,r2                   test indicator\n         BZ    *+8                      jumps if zero\n         LA    r4,drwiob2                else use 2nd iob\n         USING IOBSTDRD,r4\n         MVC   IOBCC(4),drwcchh\n         SLR   r1,r1\n         ICM   r1,7,IOBECBPB           get ecb address\n         XC    0(4,r1),0(r1)           clear the ecb\n         SLR   r5,r5\n         ICM   r5,7,IOBSTRTB           get channel program address\n         USING CCW0,r5\n         LA    r5,CCW0END              point past dx ccw\n         LA    r5,CCW0END              point past tic ccw\n         SLR   r6,r6\n         ICM   r6,7,CCW0ADDR           get locate record parm addr\n         USING LRparm,r6\n         STC   rf,LRcount              set number write ccws\n         MVC   LRseek,IOBCC\n         MVC   LRsearch,IOBCC\n         DROP  r6\nr_wrtcp  LA    r5,CCW0END              point to next ccw\n         SLR   re,re\n         ICM   re,7,CCW0ADDR\n         ST    r3,0(,re)               set address in the idaw\n         SLR   r0,r0\n         IC    r0,5(,r3)               get key length\n         SLR   r1,r1\n         ICM   r1,3,6(r3)              get data length\n         AR    r1,r0\n         LA    r1,8(,r1)               count-key-data length\n         STCM  r1,3,CCW0CNT            set data length\n         MVI   CCW0FLAG,CCW0CC+CCW0IDA set chaining bit and idaw bit\n         AR    r3,r1                   point to next record\n         BCT   rf,r_wrtcp              loop back if more\n         NI    CCW0FLAG,255-CCW0CC     unchain the last ccw\n         DROP  r5\n\n*/* schedule this channel program and wait for the previous one      */\n         EXCP  IOBSTDRD                schedule the channel program\n         SLR   r5,r5\n         ICM   r5,7,drwtecb+1          get wait ecb address\n         MVC   drwtecb,IOBECBPT         set next wait ecb address\n         DROP  r4\n         LTR   r5,r5                     any wait ecb ?\n         BZ    r_rdnext                   no, continue\n         USING ECB,r5\n         WAIT  1,ECB=ECB               wait for previous i/o\n         CLI   ECBCC,ECBNORM           test completion code\n         BNE   Eioerr                  exit if i/o error\n         DROP  r5\n\nr_rdnext X     r2,=A(1)                flip/flop the indicator\n         B     r_rdloop                loop back\n\n*/* -------------------------------------------------------------------\n*   finished reading\n* ------------------------------------------------------------------ */\n\n*/* wait for the last write                                          */\nr_rdeof  SLR   r2,r2\n         ICM   r2,7,drwtecb+1    get ecb addr for last write\n         BZ    r_rdeof1          continue if nothing to wait for\n         XC    drwtecb,drwtecb   clear wait ecb\n         USING ECB,r2\n         WAIT  1,ECB=ECB         wait for last i/o\n         CLI   ECBCC,ECBNORM     check completion code\n         BNE   Eioerr            exit if i/o error\n         DROP  r2\n\n*/* make sure we wrote the last expected track                       */\nr_rdeof1 ICM   r2,3,drwhicyl     get hi cyl\n         SLL   r2,16             shift to upper two bytes\n         SLR   r1,r1\n         ICM   r1,3,odc.RDCheads get number heads\n         BCTR  r1,0              decrement\n         OR    r2,r1             reg 2 has last cchh\n         CL    r2,drwpcchh       was last cchh read ?\n         BE    r_rdeof2           yes, continue\n         CL    r2,drwcchh          was last cchh read ?\n         BNE   Efileinc             no, incomplete file\nr_rdeof2 DS    0H\n\n*/* return                                                           */\n         LM    r0,rf,drwsave0    restore regs\n         BR    re                 and return\n\n         LTORG ,\n         DROP\n\n*/* -------------------------------------------------------------------\n*        subroutine to issue messages\n* ------------------------------------------------------------------ */\n          USING msgr,r9\n          USING odrw,rd\n          USING o24w,rb\n          USING OFFLINDR,rc\n          USING (OFFLINDR+4095,mainend),ra\nmsgr      STM  r0,rf,drwsave1\n          LR   r9,rf\n          USING IHADCB,drwpdcb\n          TM   DCBOFLGS,DCBOFOPN\n          BO   mr_opened            continue if message file is opened\n\n          LR   r2,r1                save reg 1\n          TM   drwflags,drwnoprt    test if no print file\n          BO   mr_ret                return if not\n          CLI  drwprddn,0           print ddname specified yet ?\n          BNE  mr_open2              yes, continue\n          DEVTYPE =C'SYSPRINT',drwdw  is SYSPRINT available ?\n          LR   r1,r2                   restore reg 1\n          LTR  rf,rf                    no, issue WTO\n          BNZ  mr_opened\n          MVC  drwprddn,=C'SYSPRINT'     else use SYSPRINT ddname\nmr_open2  MVC  drwpdcb,prtdcb       copy the model print dcb\n          MVC  DCBDDNAM,drwprddn    set the print ddname\n          MVC  drwpdcbe,prtdcbe     copy model print dcbe\n          LA   r1,drwpdcbe          set dcbe address\n          ST   r1,DCBDCBE            in the dcb\n          OI   drwflags,drwnoprt    presume no print\n          DEVTYPE DCBDDNAM,drwdw    issue devtype for the ddname\n          LTR  rf,rf                test devtype return code\n          BNZ  mr_ret                return if some error\n          L    r1,=A(mr_oxit)       get address of the open exit\n          LA   rf,mr_oxitl          get open exit length\n          BCTR rf,0                 decrement\n          EX   rf,*+4               copy the open exit\n          MVC  drwoxit(0),0(r1)     *** executed ***\n          LA   r1,drwoxit           get open exit addr\n          ST   r1,drwexlst          set in exit list\n          MVI  drwexlst,x'85'       set exit type\n          LA   r1,drwexlst          point to exit list\n          STCM r1,7,DCBEXLSA        set exlst addr in the dcb\n          MVC  drwopenl,openl       copy model open list\n          OPEN (drwpdcb,OUTPUT),MODE=31,MF=(E,drwopenl)\n          TM   DCBOFLGS,DCBOFOPN    did the file open ?\n          BNO  mr_ret                no, return\n          NI   drwflags,255-drwnoprt  else turn off 'noprt' bit\n          LR   r1,r2                restore reg 1\n\nmr_opened LM   r4,r5,0(r1)          pattern addr, length\n\n          BCTR r5,0\n          LA   r3,8(,r1)            first parameter\n          LA   r6,drwmsg\n          MVI  drwmsg,C' '          init msg to blanks\n          MVC  drwmsg+1(L'drwmsg-1),drwmsg\n\nmr_loop   LTR  r5,r5\n          BM   mr_exit\n          LA   r1,1(r4,r5)\n          SLR  r2,r2\n          EX   r5,mr_trt1\n          SR   r1,r4                length scanned\n          BNP  mr_skip1\n          LR   rf,r1\n          BCTR rf,0\n          EX   rf,mr_mvc1           copy literal text\n          AR   r6,r1\nmr_skip1  AR   r4,r1\n          SR   r5,r1\n          BM   mr_exit\n          BP   mr_skip2\n\n          MVC  0(1,r6),0(r4)        string ends in special char\n          LA   r6,1(,r6)\n          B    mr_exit\n\nmr_skip2  B    *(r2)                br on special char type\n          B    mr_pct               '%'\n          B    mr_bs                '\\'\n\nmr_pct    CLI  1(r4),C's'\n          BE   mr_pct_s\n          CLI  1(r4),C'x'\n          BE   mr_pct_x\n          CLI  1(r4),C'd'\n          BE   mr_pct_d\n          MVC  0(1,r6),0(r4)        treat '%' as any other char\n          LA   r6,1(,r6)\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_loop\nmr_pct_s  L    r7,0(,r3)            load string ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%s'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  mr_pct_s3\n          LR   r2,r7                source len = 0, find end of string\nmr_pct_s1 CLI  0(r2),C' '\n          BNH  mr_pct_s2\n          LA   r2,1(,r2)\n          B    mr_pct_s1\nmr_pct_s2 SR   r2,r7\n          BNP  mr_loop\nmr_pct_s3 LR   rf,r2                copy source string to the msg\n          BCTR rf,0\n          EX   rf,mr_mvc2\n          LTR  r1,r1\n          BNZ  mr_pct_s5\n          AR   r6,r2                truncate trailing spaces if\nmr_pct_s4 BCTR r6,0                  target len is 0\n          CLI  0(r6),C' '\n          BNH  mr_pct_s4\n          LA   r6,1(,r6)\n          B    mr_loop\nmr_pct_s5 CR   r1,r2\n          BH   mr_pct_s6\n          AR   r6,r1                truncate the string\n          B    mr_loop\nmr_pct_s6 AR   r6,r2                pad string with trailing blanks\n          SR   r1,r2\nmr_pct_s7 MVI  0(r6),C' '\n          LA   r6,1(,r6)\n          BCT  r1,mr_pct_s7\n          B    mr_loop\n\nmr_pct_x  L    r7,0(,r3)            load hex ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%x'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          EX   r2,mr_pct_x_unpk\n          TR   drwdw,mr_hextab\n          LTR  r1,r1\n          BNZ  mr_pct_x1\n          LA   r1,8                 determine default target len\n          CLC  =C'00',drwdw\n          BNE  mr_pct_x1\n          LA   r1,6\n          CLC  =C'0000',drwdw\n          BNE  mr_pct_x1\n          LA   r1,4\n          CLC  =C'000000',drwdw\n          BNE  mr_pct_x1\n          LA   r1,2\nmr_pct_x1 LA   r7,drwdw+8           copy the hex string to the msg\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_pct_d  L    r7,0(,r3)            load decimal ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%d'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          LA   rf,4\n          SR   rf,r2\n          LA   re,15\n          SRL  re,0(rf)\n          EX   re,mr_pct_d_icm\n          CVD  rf,drwdw\n          MVC  drwdw2(16),=X'40202020202020202020202020202120'\n          ED   drwdw2(16),drwdw\n          LTR  r1,r1\n          BNZ  mr_pct_d2\n          LA   rf,drwdw2+16         default length -\nmr_pct_d1 BCTR rf,0                  truncate leading spaces\n          CLI  0(rf),C' '\n          BH   mr_pct_d1\n          LA   r1,drwdw2+15\n          SR   r1,rf\nmr_pct_d2 LA   r7,drwdw2+16\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_bs     MVC  0(1,r6),1(r4)        copy char following '\\'\n          LA   r6,1(,r6)\n          LA   r4,2(,r4)\n          SH   r5,=Y(2)\n          B    mr_loop\n\nmr_exit   LA   r1,drwmsg\n          SR   r6,r1                calculate msg length\n          BNP  mr_ret\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   *+8\n          LA   r6,1(,r6)            increment for carriage control\n\n          TM   DCBOFLGS,DCBOFOPN\n          BNO  mr_wto\n          TM   DCBRECFM,DCBRECU\n          BO   mr_u\n          TM   DCBRECFM,DCBRECF\n          BO   mr_f\n          TM   DCBRECFM,DCBRECV\n          BO   mr_v\n\nmr_u      CH   r6,DCBBLKSI\n          BNH  *+8\n          LH   r6,DCBBLKSI\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_u1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_u1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_u1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_f      CH   r6,DCBLRECL\n          BNH  *+8\n          LH   r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_f1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_f1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_f1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_v      LA   r6,4(,r6)\n          LH   r1,DCBBLKSI\n          SH   r1,=Y(4)\n          CR   r6,r1\n          BNH  *+6\n          LR   r6,r1\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          STH  r6,0(,r1)\n          XC   2(2,r1),2(r1)\n          LA   r1,4(,r1)\n          SH   r6,=Y(4)\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_v1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_v1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_v1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_wto    LA   r6,4(,r6)\n          STH  r6,drwmsgl\n          MVC  drwmsgl+2(2),=X'8000'\n          LA   r1,drwmsg(r6)\n          MVC  0(4,r1),=X'00000020'\n          WTO  MF=(E,drwmsgl)\n\n\nmr_ret    LM   r0,rf,drwsave1\n          BR   re\n\n*/* -------------------------------------------------------------------\n* message subroutine to get operand lengths\n* ------------------------------------------------------------------ */\n\nmr_op     SLR  r1,r1\n          SLR  r2,r2\nmr_op1    LTR  r5,r5                first number is target length\n          BMR  re\n          CLI  0(r4),C'0'\n          BL   mr_op2\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r1,=Y(10)\n          AR   r1,rf\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_op1\nmr_op2    CLI  0(r4),C':'          second number follows a ':'\n          BNER re\nmr_op3    LA   r4,1(,r4)           second number is source length\n          SH   r5,=Y(1)\n          BMR  re\n          CLI  0(r4),C'0'\n          BLR  re\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r2,=Y(10)\n          AR   r2,rf\n          B    mr_op3\n\n*/* ---------------------------------------------------------------- */\n\nmr_mvc1   MVC  0(0,r6),0(r4)\nmr_trt1   TRT  0(0,r4),mr_tab1\nmr_mvc2   MVC  0(0,r6),0(r7)\nmr_mvc3   MVC  0(0,r1),drwmsg\nmr_pct_x_unpk  UNPK drwdw(9),0(0,r7)\nmr_pct_d_icm   ICM rf,0,0(r7)\nmr_tab1   DC   XL256'0'\n          ORG  mr_tab1+C'%'\n          DC   AL1(4)\n          ORG  mr_tab1+C'\\'\n          DC   AL1(8)\n          ORG  mr_tab1+256\nmr_hextab EQU  *-240\n          DC   C'0123456789abcdef'\n          LTORG ,\n         #MSG  TYPE=GEN           messages\n          DROP ,\n\n*/* -------------------------------------------------------------------\n*   message open exit - relocated to 24 bit storage\n* ------------------------------------------------------------------ */\n\n         USING mr_oxit,rf\n         USING IHADCB,R1\nmr_oxit  CLI   DCBRECFM,0          any record format ?\n         BNE   *+8                  jumps if yes\n         MVI   DCBRECFM,DCBRECV+DCBRECBR else set to 'vb'\n\n         SLR   r0,r0               get a zero\n         CH    r0,DCBLRECL         any lrecl\n         BNE   *+10                 jumps if yes\n         MVC   DCBLRECL,=Y(125)      copy default lrecl\n\n         CH    r0,DCBBLKSI         any blksize\n         BNE   *+10                 jumps if yes\n         MVC   DCBBLKSI,=Y(4096)     copy default blksize\n\n         TM    DCBRECFM,DCBRECU    test record type\n         BO    mr_oxitu             undefined\n         TM    DCBRECFM,DCBRECV    test record type\n         BO    mr_oxitv             variable\n         TM    DCBRECFM,DCBRECF    test record type\n         BO    mr_oxitf             fixed\n         B     mr_oxit0            unknown, return\n\nmr_oxitu MVC   DCBLRECL,DCBBLKSI   undefined, set lrecl from blksize\n         B     mr_oxit0            return\n\nmr_oxitv LH    r3,DCBBLKSI         variable, load blksize\n         LA    r0,4                calculate maximum\n         SR    r3,r0                lrecl\n         CH    r3,DCBLRECL         check against lrecl\n         BNL   mr_oxit0             return if not too high\n         STH   r3,DCBLRECL           else reset to max\n         B     mr_oxit0            return\n\nmr_oxitf LH    r3,DCBBLKSI         fixed, load blksize\n         SLR   r2,r2               clear for divide\n         LH    r0,DCBLRECL         load lrecl\n         DR    r2,r0               divide lrecl into blksize\n         LTR   r2,r2               test if any remainder\n         BZ    mr_oxit0            return if not\n         MH    r3,DCBLRECL         calculate new blksize\n         STH   r3,DCBBLKSI         set new blksize\n\nmr_oxit0 BR    re\n         LTORG ,\nmr_oxitl EQU   *-mr_oxit\n         DROP  ,\n\n*/* -------------------------------------------------------------------\n*   workareas\n* ------------------------------------------------------------------ */\nodrw     DSECT ,                  offline dump/restore workarea\ndrwid    DS    0CL4'odrw'         identifier\ndrwsave  DS    18F                standard save area\ndrwsave0 DS    16F                save area for dumpr/restorer\ndrwsave1 DS    16F                save area for writer\ndrwo24w  DS    A                  24-bit work area address\ndrwrsult DS    F                  result (return) value\ndrwfcn   DS    CL8                function (backup or restore)\ndrwflags DS    X                  flag bits\ndrwdump  EQU   X'80'              function is backup\ndrwpin   EQU   X'40'              offline dasd ucb pinned\ndrwcucb  EQU   X'20'              offline dasd ucb captured\ndrwdebad EQU   X'10'              offline dasd ucb deb added\ndrwnry   EQU   X'08'              offline dasd ucb 'not ready' bit\ndrwenqd  EQU   X'04'              offline dasd enqueued\ndrwhdrw  EQU   X'02'              backup header has been written\ndrwnoprt EQU   X'01'              print ddname not present\ndrwunit  DS    H                  offline unit address\ndrwlocyl DS    H                  low cylinder to dump\ndrwhicyl DS    H                  high cylinder to dump\ndrwpcchh DS    F                  previous cchh written\ndrwcchh  DS    F                  current cchh being written\ndrwtecb  DS    A                  address of ecb to wait on\ndrwretcd DS    F                  return code\ndrwrsncd DS    F                  reason code\ndrwucba  DS    A                  ucb address\ndrwcucba DS    A                  captured ucb address\ndrwdeba  DS    A                  deb address\ndrwmajor DS    CL8                enq major name\ndrwminor DS    CL4                enq minor name\ndrwioa   DS    A                  i/o area address\ndrwiol   DS    F                  i/o area length\ndrwtrksz DS    F                  offline dasd unit track size\ndrwheads DS    F                  offline dasd unit trks/cyl\ndrwptok  DS    D                  ucb pin token\ndrwdevta DS    D                  devtype area\ndrwtkbal DS    H                  trkcalc balance\ndrwrkdd  DS    0F                 trkcalc record key data\ndrwr     DS    X                  trkcalc record\ndrwk     DS    X                  trkcalc key\ndrwdd    DS    XL2                trkcalc data\ndrwctime DS    D                  current date/time\ndrwdtime DS    CL20               dat/time display area\ndrwdw    DS    D                  double word work areas\ndrwdw2   DS    D\ndrwdw3   DS    D\ndrwdw4   DS    D\ndrwbuddn DS    CL8                backup ddname\ndrwbdcbe DS    XL(budcbel)        backup dcbe\n         DS    0D\ndrwprddn DS    CL8                print ddname\ndrwpdcbe DS    XL(prtdcbel)       print dcbe\n         DS    0D\ndrwopenl DS    XL(openll)         open parameter list\n         DS    0D\ndrwulpl  DS    XL(ulpll)          ucblook parameter list\n         DS    0D\ndrwuupl  DS    XL(uupll)          ucbpin unpin parameter list\n         DS    0D\ndrwcupl  DS    XL(cupll)          ioscapu parameter list\n         DS    0D\ndrwtbpl  DS    XL(tbpll)          trkcalc trkbal parameter list\n         DS    0D\ndrwenql  DS    XL(enqll)          enq parameter list\ndrwodhdr DS    XL512              header record\ndrwmsgl  DS    F                  message length (for WTO)\ndrwmsg   DS    CL256              message\ndrwmsgpl DS    24F                message parameter list\ndrwl     EQU   *-odrw\n\no24w     DSECT ,                  24-bit work area\no24wid   DC    CL4'o24w'          identifier\ndrwzeros DS    XL16               24-bit zeroes\ndrwbdcb  DS    XL(budcbl)         backup dcb\ndrwodcb  DS    XL(oddcbl)         offline dasd dcb\ndrwpdcb  DS    XL(prtdcbl)        print dcb\ndrwexlst DS    F                  dcb exit list\ndrwsnsid DS    XL20               device snsid info\ndrwsns   DS    XL32               device sense\ndrwrdc   DS    XL64               device characteristics\ndrwsnss  DS    XL40               device snss info\ndrwoecb1 DS    F                  output ecb 1\ndrwoecb2 DS    F                  output ecb 2\ndrwiob1  DS    XL40               output iob 1\ndrwiob2  DS    XL40               output iob 2\ndrwlrp1  DS    XL16               locate record parameter area 1\ndrwlrp2  DS    XL16               locate record parameter area 2\ndrwdxa   DS    XL16               define extent area\ndrwoxit  DS    XL256              relocated message open exit\ndrwoida1 DS    255A               idaws 1\ndrwoida2 DS    255A               idaws 2\ndrwoccw1 DS    258D               channel program 1\ndrwoccwl EQU   *-drwoccw1         channel program length\ndrwoccw2 DS    258D               channel program 2\no24wl    EQU   *-o24w\n\nodhdr    DSECT ,                  offline dump header\nodhdrid  DS    CL8                header identifier\nodvrm    DS    XL3                version release modlvl\n         DS    X                  [reserved]\nodtime   DS    F                  time of dump\noddate   DS    F                  date of dump\nodunit   DS    H                  offline unit address\nodlocyl  DS    H                  low cylinder to dump\nodhicyl  DS    H                  high cylinder to dump\n         DS    XL6                [reserved]\nodsnsid  DS    XL20               device snsid info\nodsns    DS    XL32               device sense\nodrdc    DS    XL64               device characteristics\nodsnss   DS    XL40               device snss info\nodhdrl   EQU   512\n\nRDCinfo  DSECT ,                  read device characteristics info\nRDCsdt   DS    XL2                storage director type\nRDCsdmi  DS    X                  storage director model information\nRDCdevt  DS    XL2                device type\nRDCdevm  DS    X                  device model\nRDCdasdf DS    XL4                device & storage director facilities\nRDCclass DS    X                  device class code\nRDCtype  DS    X                  device type code\nRDCprime DS    XL2                number of primary cylinders\nRDCheads DS    XL2                tracks per cylinde\nRDCsctrs DS    X                  number of sectors\nRDCtrkln DS    XL3                total track length (usable)\nRDChar0  DS    XL2                length of ha and r0\nRDCtccf  DS    X                  track capacity calculation formula\nRDCfctrs DS    XL5                track capacity calculation factors\nRDCacyl  DS    XL2                address of first alternate cylinder\nRDCacyln DS    XL2                number of alternate tracks\nRDCdcyl  DS    XL2                address of first diagnostic cylinder\nRDCdcyln DS    XL2                number of diagnostic tracks\nRDCscyl  DS    XL2                address of first device support cyl\nRDCscyln DS    XL2                number of device support tracks\nRDCmdrid DS    X                  mdr record id\nRDCobrid DS    X                  obr record id\nRDCsdtc  DS    X                  storage director type code\nRDCrtspl DS    X                  read trackset parameter length\nRDCmaxr0 DS    XL2                maximum record zero data length\n         DS    X                  (reserved)\nRDCtss   DS    X                  track set size\nRDCatccf DS    X                  additional track capacity calc. factr\nRDCrps   DS    XL2                rps sector calculation factors\n         DS    XL3                (reserved)\nRDCgdff  DS    X                  generic device/cu functions/features\n         DS    X                  (reserved -- zeroes)\nRDCrduc  DS    X                  real control unit code\nRDCrdc   DS    X                  real device code\n         DS    XL6                (reserved)\nRDCinfol EQU   *-RDCinfo\n\nLRparm   DSECT ,                  locate record paramete\nLRop     DS    X                  operation byte\nLRocount EQU   B'00000000'        orient count\nLRohome  EQU   B'01000000'        orient home\nLRodata  EQU   B'10000000'        orient data\nLRoindex EQU   B'11000000'        orient index\nLRorient EQU   X'00'              orient\nLRwrite  EQU   X'01'              write data\nLRfwrite EQU   X'03'              format write\nLRread   EQU   X'06'              read data\nLRwt     EQU   X'0b'              write track\nLRrt     EQU   X'0c'              read tracks\nLRrd     EQU   X'16'              read\nLRaux    DS    X                  auxiliary byte\nLRusetlf EQU   B'10000000'        transfer length factor specified\nLRrcccw  EQU   B'00000001'        a read count ccw is suffixed\n         DS    X\nLRcount  DS    X                  count parameter\nLRseek   DS    0XL4               seek addr\nLRseekcc DS    XL2\nLRseekhh DS    XL2\nLRsearch DS    0XL5               search arg\nLRsrchcc DS    XL2\nLRsrchhh DS    XL2\nLRsrchr  DS    X\nLRsector DS    X\nLRtlf    DS    XL2                transfer length factor\nLRparml  EQU   *-LRparm\n\n*/* -------------------------------------------------------------------\n*   dsects\n* ------------------------------------------------------------------ */\n         PRINT NOGEN\n         DCBD  DSORG=PS\n         IHADCBE ,\nUCBDSECT DSECT ,\n         IEFUCBOB ,\n         IEZDEB ,\nDEBLENGTH EQU  (DEBBASND-DEBAVT)+(DEBDASDE-DEBDASD)+DEBXLEN\n         IEZIOB ,\n         IHAECB ,\n         IOSDCCW ,\n         CVT   DSECT=YES\n         IHAPSA ,\n         IKJTCB ,\nSTAR     TRKCALC MF=D\n\n*/* -------------------------------------------------------------------\n*   equates\n* ------------------------------------------------------------------ */\nSK    EQU X'07'\nSNSID EQU X'e4'\nSNS   EQU X'04'\nRDC   EQU X'64'\nSNSS  EQU X'54'\nRT    EQU X'de'\nDX    EQU X'63'\nLR    EQU X'47'\nWR0   EQU X'15'\nWCKD  EQU X'1d'\nTIC   EQU X'08'\n\nr0 EQU 0\nr1 EQU 1\nr2 EQU 2\nr3 EQU 3\nr4 EQU 4\nr5 EQU 5\nr6 EQU 6\nr7 EQU 7\nr8 EQU 8\nr9 EQU 9\nra EQU 10\nrb EQU 11\nrc EQU 12\nrd EQU 13\nre EQU 14\nrf EQU 15\n\n   END ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT719/FILE719.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT719", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}