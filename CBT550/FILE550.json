{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012328000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE550.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE550.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x10'", "DS1TRBAL": "b'g\\xdc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x10\\x00\\n\\x04\\x11\\x00\\x00\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x10_\\x01\\x02\\x10_!B\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-15T00:00:00", "modifydate": "2002-04-15T21:42:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 445    FILE:  550\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT445.FILE550\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 34 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,796 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/15/02    21:42:23    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE$$": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x014/\\x01\\x02\\x04o\\x12\\t\\x00\\x08\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-12-08T00:00:00", "modifydate": "2002-02-15T12:09:02", "lines": 8, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": "\n   These macros are a subset of Dan Snyder's macro collection,\n   which can be considered the \"structured macros\".  These macros\n   accomplish IF-THEN-ELSE and DO loop logic, in assembler programs.\n\n   Dan Snyder's \"more complete\" macro collection is on File 438\n   of the CBT Tape collection.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE$1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x02\\x05\\x8f\\x01\\x02\\x05\\x8f\\x13@\\x00 \\x00$\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-02-27T00:00:00", "modifydate": "2002-02-27T13:40:32", "lines": 32, "newlines": 36, "modlines": 0, "user": "GENTR02"}, "text": "Subject: structured macros\nDate: Mon, 18 Feb 2002 15:31:49 -0500\nFrom: \"Snyder, Dan\" <Dan_Snyder@stercomm.com>\nTo: \"Sam Golob (E-mail)\" <sbgolob@attglobal.net>\n\nWhen I was in the process of making this macro package work, I\nneeded a way to combine OR clauses together and them have them\nrelate as a group to an AND.  In COBOL a programmer can do it by\nnesting clauses within pairs of parentheses, so that's what I did\nwith this package.\n\nThe first character of a conditional phrase must be a '(',\nindicating the presence of subparameters.  If the second\ncharacter is another '(', then that implies the possibility of\nnested conditions.  The IF macro then splits the one or more\nconditional phrases contained within the double parentheses into\nindividual parameters which are then passed to a recursive call\nof the IF macro itself.  If you code:\n\n        IF      ((((((((CLC,FIELDA,FIELDB,E)))))))),THENDO\n\nthen IF will call itself recursively 7 times (note the macro\nlevel expressed in the line number field):\n\n          IF    ((((((((CLC,FIELDA,FIELDB,E)))))))),THENDO\n+         CLC   FIELDA,FIELDB       TWO OPERANDS - SET CONDITION CODE  08-000115\n+         JNE   $MDF0013            B AROUND IF-GROUP IF FALSE         01-000198\n            MVC   FIELDA,FIELDC\n          ENDIF ,\n+$MDF0013 DC    0H'0'               DEFINE END OF DO-GROUP             03-000330\n\nCool, isn't it?\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$READ$$": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x013\\x1f\\x01\\x013\\x1f\\x13)\\x00b\\x00b\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2001-11-27T13:29:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "GENTR02"}, "text": "                               STRUCTURED MACROS\n\n  THESE MACROS CAN HELP YOU CREATE NEW PROGRAMS AND MODIFY EXISTING CODE BY\n  SUPPORTING IF-THEN-ELSE LOGIC WHILE REQUIRING ONLY A SMALL LEARNING CURVE\n  FROM WHAT YOU ALREADY KNOW ABOUT S/390 ASSEMBLER (ASSUMING THAT YOU DO\n  KNOW IT ALREADY).  EACH 'IF' STATEMENT CAN BE ARBITRARILY COMPLEX, AND THE\n  'IF' STATEMENTS CAN BE NESTED AS MANY LEVELS AS YOU MIGHT NEED (CERTAINLY,\n  NO ONE WOULD NEED MORE THAN 255 LEVELS OF NESTING, WOULD SHE?).\n\n  EACH GROUP OF INSTRUCTIONS THAT YOU WANT CONDITIONALLY EXECUTED WOULD BE\n  HEADED BY AN 'IF' MACRO, AND TERMINATED BY AN 'ENDIF' MACRO.\n\n  IN ITS SIMPLIST FORM, THE OPERAND OF THE 'IF' MACRO CONSISTS OF AN OP-CODE,\n  THE FIRST OPERAND ADDRESS, THE SECOND OPERAND ADDRESS, AND A CONDITION. THESE\n  FOUR VALUES MUST BE ENCLOSED WITHIN PARENTHESES, AND FOLLOWING THE OPERANDS\n  MUST BE A COMMA AND THE STATEMENT TERMINATING TERM 'THENDO'.\n\n  THE OP-CODE MAY BE ANY VALID S/390 OP-CODE THAT SETS THE CONDITION CODE. THE\n  FIRST AND SECOND OPERANDS MAY BE ANY VALUES THAT ARE VALID FOR THE INSTRUCTION\n  BEING CREATED. THE CONDITION, SUCH AS 'E' OR 'NO, IS ANY VALUE THAT CAN BE\n  USED IN CREATING AN EXTENDED MNEMONIC BRANCH INSTRUCTION (SUCH AS 'BE' OR\n  'BNO').\n\n  IF YOU CHOOSE 'E' AS THE CONDITION, THEN THE GROUP OF INSTRUCTIONS BETWEEN THE\n  'IF' AND THE 'ENDIF' WILL BE EXECUTED ONLY IF THE CONDITION CODE SET BY THE\n  OP-CODE AND OPERANDS SPECIFIED IS A ZERO.\n\n  IN THE FOLLOWING EXAMPLES, THE HEADING WILL INDICATE THE\n  CONDITIONS IN WHICH THE DO-GROUP WILL BE EXECUTED. IN EACH CASE,\n  AN 'IF' STATEMENT DETERMINES THE CONDITIONS, AND AN 'ENDIF'\n  STATEMENT TERMINATES THE DO-GROUP. COMMENTS EITHER IN THE HEADING\n  OR ON THE APPROPRIATE INSTRUCTIONS WILL INDICATE THE DETAILS.\n       HERE IS AN EXAMPLE:\n\n         IF    (CLC,A,B,NE),THENDO\n\n  THE INSTRUCTIONS BETWEEN THIS 'IF' AND ITS MATCHING 'ENDIF' WILL BE EXECUTED\n  IF THE RESULT OF THE 'CLC' IS A 1 OR 2 (THE NOT-EQUAL CONDITION).\n\n       TO EXECUTE THE DO-GROUP IF EITHER ONE OF TWO CONDITIONS IS\n  TRUE, THE FORMAT IS:\n\n       IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    (CLC,A,B,NE),OR,                                C\n             (CLC,C,D,NE),THENDO\n\n       SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\n  EXAMPLE, THE DO-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\n  IF BOTH THE SECOND AND THIRD ARE TRUE:\n\n       IF    (CLC,A,B,E),OR,                                 C\n             (CLC,C,D,E),AND,                                C\n             (CLC,E,F,E),THENDO\n\n       IF THE DO-GROUP IS TO BE PERFORMED IF THE THIRD IS TRUE AND\n  EITHER THE FIRST OR SECOND IS TRUE, INCLUDE THE TESTS CONNECTED\n  BY THE 'OR' WITHIN ADDITIONAL PARENTHESES:\n\n             * <-NESTING PARENTHESES -> *\n       IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n             (CLC,E,F,E),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    ((CLC,A,B,E),OR,                                C\n             (CLC,C,D,E)),AND,                               C\n             (CLC,E,F,E),THENDO\n\n       GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\n  TO DEFINE THE LOGIC DESIRED.\n       EACH DO-GROUP MUST BE TERMINATED WITH AN 'ENDIF' STATEMENT\n  OR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n       ENDIF ,\n                   - OR -\n       ELSE  ,\n       ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n       ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n       ALTERNATIVELY, A DO-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n       ELSEIF  (CLC,G,H,E),THENDO ...\n\n       ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n       'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n       ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n       GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\n       IF    (...),THENDO            REQUIRED\n       ...\n       ELSEIF (...),THENDO           OPTIONAL (REPEATED AS REQUIRED)\n       ...\n       ELSE  ,                       OPTIONAL\n       ...\n       ENDIF ,                       REQUIRED (OR 'ENDELSE')\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MENDDO1": {"ttr": 525, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    $MENDDO1 &DOGROUP=\n         COPY  $MGBLDEF\n         LCLA  &J\n&$MDGERR SETA  0                   ASSUME NO ERROR\n&J       SETA  &$MDGLVL\n         AIF   (&J GT 0).OK02\n         MNOTE 8,'NO ACTIVE DO-GROUP TO TERMINATE'\n         MNOTE 0,' - MACRO GENERATION ABORTED'\n&$MDGERR SETA  4                   WARN OTHERS\n         MEXIT\n.OK02    AIF   ('&DOGROUP' EQ '').SKIP15\n         AIF   ('&DOGROUP' NE '*ALL*').TEST10 FALL THROUGH IF *ALL*\n&J       SETA  1                   END ALL BUT OUTERMOST DO-GROUP\n         AGO   .SKIP20             ENTER COMMON LOOP\n.TEST10  AIF   ('&DOGROUP' EQ '&$MDGNAM(&J)').SKIP20\n&J       SETA  &J-1\n         AIF   (&J GE 1).TEST10\n         MNOTE 8,'ATTEMPT TO END NON-EXISTANT DO-GROUP ''&DOGROUP'''\n         MNOTE 0,'ALL ACTIVE DO-GROUPS TERMINATED'\n&J       SETA  1\n         AGO   .SKIP20\n.SKIP15  AIF   ('&NAME' EQ '').ENDIT DO NOTHING IF ONLY 1 LEVEL\n&NAME    DC    0H'0'               WELL, MAYBE A TAG...\n         MEXIT\n.SKIP20  AIF   ('&NAME' EQ '').LOOP30\n&NAME    DC    0H'0'               DEFINE END OF DO-GROUP\n.LOOP30  AIF   (&J GE &$MDGLVL).ENDIT END 1 BEFORE LAST LEVEL\n         $MENDDO2                  END 1 LEVEL\n         AIF   (&$MDGERR NE 0).ENDIT QUIT IF ERROR OCCURRED\n         AIF   (&$MDGLVL LE 1).ENDIT\n         AGO   .LOOP30\n.ENDIT   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MENDDO2": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x013\\x1f\\x01\\x02\\x01\\x7f\\x14R\\x00\\x17\\x00\\x16\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2002-01-17T14:52:00", "lines": 23, "newlines": 22, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n         $MENDDO2\n         COPY  $MGBLDEF\n         LCLC  &X\n&$MDGERR SETA  0                   RESET TO 0\n         AIF   (&$MDGLVL GT 0).AOK IF NOT GT 0 THEN NOTHING TO DO\n         MNOTE 8,'ATTEMPT TO END NON-EXISTENT DO-GROUP(S)'\n&$MDGERR SETA  8                   SHOW ERROR OCCURRED\n         MEXIT\n.AOK     AIF   ('&$MLTAG(&$MDGLVL)' EQ '').SKIP10\n         J     &$MLTAG(&$MDGLVL)   RETURN TO 'DO'\n&$MLTAG(&$MDGLVL) SETC ''          NULLIFY\n.SKIP10  ANOP\n&X       SETC  '$MD&$MIFELS(&$MDGLVL)&$MDGSEQ(&$MDGLVL)'\n&X       DC    0H'0'               DEFINE END OF CONDITIONAL GROUP\n&$MCVERB(&$MDGLVL) SETC ''\n         AIF   ('&$MFNBR(&$MDGLVL)' EQ '').SKIP30\n&X       SETC  '$MDF&$MFNBR(&$MDGLVL)'\n&$MFNBR(&$MDGLVL) SETC ''\n&X       DC    0H'0'               DEFINE TAG FOR 'ELSEIF' STATEMENTS\n.SKIP30  ANOP\n&$MDGLVL SETA  &$MDGLVL-1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGBLDEF": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00T\\x01\\x013\\x1f\\x01\\x02\\t_\\x15)\\x00h\\x00\\t\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2002-04-05T15:29:54", "lines": 104, "newlines": 9, "modlines": 0, "user": "GENTR02"}, "text": ".*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* THIS COPY MEMBER CONTAINS THE GLOBAL SET SYMBOLS REQUIRED BY THE  *\n.* MACROS IN THIS LIBRARY. AT IT'S FIRST INVOCATION WITHIN AN        *\n.* ASSEMBLY, IT COPIES 6 MACRO DEFINITIONS THAT ARE CALLED FROM      *\n.* WITHIN THE OTHER MACROS DEFINED IN THE LIBRARY.                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MCPYSW,&$MBLATH,&$MAXRC\n         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC\n         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)\n         GBLC  &$MCVERB(255),&$MC,&$MLOCTR\n         AIF   (&$MCPYSW EQ 1).END999 THIS HOOPLA IS JUST TO PREVENT\n&$MCPYSW SETA  (1)      THESE GUYS FROM APPEARING IN THE MEMBER LIST.\n         AIF   ('&$MLOCTR' NE '').SKIP010 DON'T OVERLAY\n&$MLOCTR SETC  '$$DATA$$'          DEFAULT VALUE FOR DATA LOCTR\n.SKIP010 PUSH  PRINT  *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         PRINT OFF    *=* COPY INTERNAL MACROS INTO THIS ASSEMBLY *=*\n         MACRO\n&NAME    $MENDDO1 &DOGROUP=\n         GBLA  &$MDGLVL,&$MDGERRR\n         GBLC  &$MDGNAM(255)\n         LCLA  &J\n&$MDGERR SETA  0                   ASSUME NO ERROR\n&J       SETA  &$MDGLVL\n         AIF   (&J GT 0).OK02\n   MNOTE 8,'NO ACTIVE CR-GROUP TO TERMINATE - MACRO GENERATION ABORTED'\n&$MDGERR SETA  4                   WARN OTHERS\n         MEXIT\n.OK02    AIF   ('&DOGROUP' EQ '').SKIP15\n         AIF   ('&DOGROUP' NE '*ALL*').TEST10 FALL THROUGH IF *ALL*\n&J       SETA  1                   END ALL BUT OUTERMOST DO-GROUP\n         AGO   .SKIP20             ENTER COMMON LOOP\n.TEST10  AIF   ('&DOGROUP' EQ '&$MDGNAM(&J)').SKIP20\n&J       SETA  &J-1\n         AIF   (&J GE 1).TEST10\n         MNOTE 8,'ATTEMPT TO END NON-EXISTANT DO-GROUP ''&DOGROUP'''\n         MNOTE 0,'ALL ACTIVE DO-GROUPS TERMINATED'\n&J       SETA  1\n         AGO   .SKIP20\n.SKIP15  AIF   ('&NAME' EQ '').ENDIT DO NOTHING IF ONLY 1 LEVEL\n&NAME    DC    0H'0'               WELL, MAYBE A TAG...\n         MEXIT\n.SKIP20  AIF   ('&NAME' EQ '').LOOP30\n&NAME    DC    0H'0'         *=*=* DEFINE END OF DO-GROUP *=*=*\n.LOOP30  AIF   (&J GE &$MDGLVL).ENDIT END 1 BEFORE LAST LEVEL\n         $MENDDO2                  END 1 LEVEL\n         AIF   (&$MDGERR NE 0).ENDIT QUIT IF ERROR OCCURRED\n         AIF   (&$MDGLVL LE 1).ENDIT\n         AGO   .LOOP30\n.ENDIT   MEND\n         MACRO\n         $MENDDO2\n         GBLA  &$MDGLVL,&$MDGERR\n         GBLC  &$MFNBR(31),&$MDGSEQ(255),&$MIFELS(255),&$MLTAG(255)\n         GBLC  &$MCVERB(255)\n         LCLC  &X\n&$MDGERR SETA  0                   RESET TO 0\n         AIF   (&$MDGLVL GT 0).AOK IF NOT GT 0 THEN NOTHING TO DO\n         MNOTE 4,'ATTEMPT TO END NON-EXISTENT DO-GROUP(S)'\n&$MDGERR SETA  4                   SHOW ERROR OCCURRED\n         MEXIT\n.AOK     AIF   ('&$MLTAG(&$MDGLVL)' EQ '').SKIP10\n         J     &$MLTAG(&$MDGLVL)   RETURN TO 'DO'\n&$MLTAG(&$MDGLVL) SETC ''          NULLIFY\n.SKIP10  ANOP\n&X       SETC  '$MD&$MIFELS(&$MDGLVL)&$MDGSEQ(&$MDGLVL)'\n&X       DC    0H'0'         *=*=* DEFINE END OF DO-GROUP *=*=*\n&$MCVERB(&$MDGLVL) SETC ''\n         AIF   ('&$MFNBR(&$MDGLVL)' EQ '').SKIP30\n&X       SETC  '$MDF&$MFNBR(&$MDGLVL)'\n&$MFNBR(&$MDGLVL) SETC ''\n&X       DC    0H'0'               DEFINE TAG FOR 'ELSEIF' STATEMENTS\n.SKIP30  ANOP\n&$MDGLVL SETA  &$MDGLVL-1\n         $MLVLMSG &$MDGLVL,NESTING\n         MEND\n         MACRO\n         $MGFNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         GBLA  &$MRECUR\n         GBLC  &$MFNAM1(31)\n&$MFNAM1(&$MRECUR) SETC  '$MDF&SYSNDX' COMPARE-FAILED TAG\n         MEND\n         MACRO\n         $MGFNBR &DUMMY            CREATE A UNIQUE TAG FOR 'ELSEIF'\n         GBLA  &$MDGLVL\n         GBLC  &$MFNBR(31)\n&$MFNBR(&$MDGLVL) SETC '&SYSNDX'   CREATE UNIQUE SEQUENCE NUMBER\n         MEND\n         MACRO\n         $MGPNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         GBLA  &$MRECUR\n         GBLC  &$MPNAM1(31)\n&$MPNAM1(&$MRECUR) SETC  '$MDP&SYSNDX' COMPARE-SUCCEEDED TAG\n         MEND\n         MACRO\n         $MLVLMSG &LVL,&TYPE       &TYPE MUST BE 'NESTING' OR\n.*                                 . 'RECURSION'\n         GBLA  &$MBLATH            USER CONTROLS MNOTES WITH THIS\n         AIF   (&$MBLATH LT 10).MEND999 NO MNOTE IF < 10\n         AIF   ('&TYPE' EQ 'NESTING').GEN010 ISSUE MNOTE IF EQUAL\n         AIF   (&$MBLATH LT 12).MEND999 NO 'RECURSION' IF < 12\n.GEN010  MNOTE '==> &LVL <== IS CURRENT &TYPE LEVEL'\n.MEND999 MEND\n         POP   PRINT  *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.END999  ANOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGFNAME": {"ttr": 532, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $MGFNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         COPY  $MGBLDEF\n&$MFNAM1(&$MRECUR) SETC  '$MDF&SYSNDX' COMPARE-FAILED TAG\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGFNBR": {"ttr": 534, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $MGFNBR &DUMMY            CREATE A UNIQUE TAG FOR 'ELSEIF'\n         COPY  $MGBLDEF            COPY IN ALL THE SYMBOLS\n&$MFNBR(&$MDGLVL) SETC '&SYSNDX'   CREATE UNIQUE SEQUENCE NUMBER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGPNAME": {"ttr": 536, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $MGPNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         COPY  $MGBLDEF\n&$MPNAM1(&$MRECUR) SETC  '$MDP&SYSNDX' COMPARE-SUCCEEDED TAG\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE550": {"ttr": 538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x01\\x02\\x05\\x8f\\x01\\x02\\x05\\x8f\\x13B\\x00$\\x00$\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-02-27T00:00:00", "modifydate": "2002-02-27T13:42:31", "lines": 36, "newlines": 36, "modlines": 0, "user": "GENTR02"}, "text": "//***FILE 550 is the Structured Assembler Macros collection from    *   FILE 550\n//*           Dan Snyder.  If you have been tempted to use the      *   FILE 550\n//*           IBM HLASM Toolkit set of structured macros, but you   *   FILE 550\n//*           were afraid that you'd have to assemble your code     *   FILE 550\n//*           in a place that wasn't licensed for the Toolkit,      *   FILE 550\n//*           then you might try these macros as an alternative.    *   FILE 550\n//*                                                                 *   FILE 550\n//*           These macros (IF, DO, etc) are not interchangeable    *   FILE 550\n//*           with the IBM macros from the HLASM toolkit.  You      *   FILE 550\n//*           either use ALL THESE, or ALL THEIRS, but don't mix    *   FILE 550\n//*           them....                                              *   FILE 550\n//*                                                                 *   FILE 550\n//*           The advantage of using this set of structured macros  *   FILE 550\n//*           is that they are FREE and that they offer a powerful  *   FILE 550\n//*           method of nesting conditions. You can assemble with   *   FILE 550\n//*           them at any site....                                  *   FILE 550\n//*                                                                 *   FILE 550\n//*           For support, you may contact the author, Dan Snyder,  *   FILE 550\n//*           at:                                                   *   FILE 550\n//*                                                                 *   FILE 550\n//*           email:   dsnyder@elektro.cmhnet.org                   *   FILE 550\n//*                    Dan_Snyder@stercomm.com                      *   FILE 550\n//*                                                                 *   FILE 550\n//*     - - - - - - - - - - - - - - - - - - - - - - - - - - -       *   FILE 550\n//*                                                                 *   FILE 550\n//*     Names of the macros in the Structured Macro Set:            *   FILE 550\n//*                                                                 *   FILE 550\n//*         AFTER    BEGTEST  DO       DOCUMENT DOEXIT              *   FILE 550\n//*         ELSE     ELSEDO   ELSEIF   ENDAFTER ENDELSE             *   FILE 550\n//*         ENDEVERY ENDFIRST ENDIF    ENDO     ENDTEST             *   FILE 550\n//*         EVERY    EXECUTE  FIRST    IF       THENDO              *   FILE 550\n//*                                                                 *   FILE 550\n//*      and the auxiliary copy member to assist these:             *   FILE 550\n//*                                                                 *   FILE 550\n//*         $GBLDEF                                                 *   FILE 550\n//*                                                                 *   FILE 550\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AFTER": {"ttr": 540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x02\\x01\\x01%\\x7f\\x01\\x02\\x07\\x0f\\x13\\x17\\x00\"\\x00\\'\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-09-14T00:00:00", "modifydate": "2002-03-11T13:17:02", "lines": 34, "newlines": 39, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    AFTER &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING\n         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'AFTER' GROUP WILL BE PROC\n               CESSED EACH PASS THROUGH THIS SECTION OF CODE'\n&LCLV    SETC  '0'                 DO EVERY TIME\n.OK30    ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'AFTER'\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n         AIF   ('&LCLV' NE '1').PACKED\n&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?\n         JO    *+12                SKIP OVER IS YES\n         OI    &X,X'01'            ELSE LEAVE TRACKS\n         J     $MDF&SYSNDX           AND BYPASS DO-GROUP\n         AGO   .DEFINE\n.PACKED  ANOP                      I GUESS WE'LL HAVE TO DO DECIMAL...\n&NAME    SP    &X,=P'1'            DECREMENT\n         JNM   $MDF&SYSNDX         B IF NOT YET TIME\n         PACK  &X,=Z'0'            DO EVERY TIME FROM NOW ON\n&$MLOCTR LOCTR                     SET UP WORK AREA\n         AIF   ('&LCLV' NE '1').PACKED2\n&X       DC    X'00'               SET TO X'01' FIRST TIME THROUGH\n         AGO   .INST\n.PACKED2 ANOP\n&X       DC    P'&LCLV'            FREQUENCY COUNTER\n&SYSECT  LOCTR                     BACK TO INSTRUCTION AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BEGTEST": {"ttr": 542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x05\\x01\\x013\\x0f\\x01\\x02\\x07\\x9f\\x10\"\\x009\\x00@\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2001-11-26T00:00:00", "modifydate": "2002-03-20T10:22:05", "lines": 57, "newlines": 64, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    BEGTEST &LVL,                                                 C\n               &PRINT=        CODE 'PRINT=NO' TO SUPPRESS SKIPPED STMTS\n.* OR 'PRINT=YES' TO PRINT SKIPPED STMTS OR CHANGE IT IN THIS MACRO\n.* DEFINITION TO CHANGE IT TO SAY '&PRINT=NO' TO MAKE 'NO' THE DEFAULT\n.*\n.*                              IN 'OPEN' CODE DO ONE OF THE FOLLOWING:\n         GBLA  &TESTLVL         1. SET TO > 0 TO ACTIVATE - OR -\n         GBLC  &$A,&$B,&$C,&$D  2. SET ONE OR MORE TO 'Y' TO ACTIVATE\n         GBLC  &$MPRSW          TO KEEP TRACK OF USER'S PREF\n         LCLA  &I,&J\n         LCLC  &TEXT\n         AIF   ('&PRINT' EQ '').SKIP005 GO IF NO PARM SPECIFIED\n&$MPRSW  SETC  '&PRINT'                SET GLOBAL TO USER'S VALUE\n.SKIP005 AIF   ('&NAME' EQ '').SKIP010\n&NAME    EQU   *\n.SKIP010 AIF   ('&LVL' NE '' AND '&LVL'(1,1) GT 'Z').TEST510\n         AIF   ('&LVL' NE 'A').TEST020 FALL THRU IF 'A'\n         AIF   ('&$A' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.TEST020 AIF   ('&LVL' NE 'B').TEST030 FALL THRU IF 'B'\n         AIF   ('&$B' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.TEST030 AIF   ('&LVL' NE 'C').TEST040 FALL THRU IF 'C'\n         AIF   ('&$C' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.TEST040 AIF   ('&LVL' NE 'D').MSG050  FALL THRU IF 'D'\n         AIF   ('&$D' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.MSG050  MNOTE *,' ---> INVALID CHAR OPERAND &LVL - OPT CODE INCLUDED'\n         AGO   .MEND999\n.TEST510 AIF   (&LVL LE &TESTLVL).MEND999 IF LE THEN INCL THRU ENDTEST\n.LOOP520 AIF   ('&$MPRSW' EQ 'YES').NEXT523 'DEFAULT' IS SUPPRESS\n&TEXT    AREAD NOPRINT            READ STMT AND SUPPRESS PRINT\n         AGO   .NEXT526\n.NEXT523 ANOP\n&TEXT    AREAD NOSTMT            READ AND PRINT STMT BUT NO LINE NUMBER\n.NEXT526 AIF   ('&TEXT'(1,1) EQ '*').LOOP520 SKIP COMMENT STMTS\n&J       SETA  &J+1                    COUNT THIS STMT\n&I       SETA  1                       GET READY TO INSPECT STMT\n.LOOP530 AIF   ('&TEXT'(&I,1) EQ ' ').NEXT540 SCAN PAST NAME FIELD\n&I       SETA  &I+1                    INCR PTR TO NEXT POS\n         AIF   (&I GT 65).LOOP520      GET NEXT STMT IF COL 65\n         AGO   .LOOP530                KEEP SCANNING NAME FIELD\n.NEXT540 AIF   ('&TEXT'(&I,1) NE ' ').NEXT550 SCAN PAST LEADING SPACES\n&I       SETA  &I+1                    INCR TO NEXT POS\n         AIF   (&I GT 65).LOOP520      GET NEXT STMT IF COL 65\n         AGO   .NEXT540                KEEP SCANNING SPACES\n.NEXT550 AIF   ('&TEXT'(&I,8) NE 'ENDTEST ').LOOP520 SECRET KEYWORD?\n&J       SETA  &J-1                    YES - DECREMENT IMAGE COUNT\n         AIF   (&J NE 1).MSG560        FORMAT NICELY\n         MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - 1 STATEMENT SKIX\n               PPED'\n         AGO   .MEND999\n.MSG560  MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - &J STATEMENTS SX\n               KIPPED'\n.MEND999 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DO": {"ttr": 770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00D\\x01\\x013\\x1f\\x01\\x02\\x07\\x9f\\x12T\\x00\\x7f\\x00|\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2002-03-20T12:54:44", "lines": 127, "newlines": 124, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    DO    &VAR,&WHILE=,&UNTIL=,&TEST=BEFORE\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         LCLA  &Y\n         LCLC  &X\n         AIF   ('&TEST' EQ 'BEFORE').TEST10\n         AIF   ('&TEST' EQ 'AFTER').TEST10\n         MNOTE 8,'''TEST=&TEST'' INVALID - ''BEFORE'' ASSUMED'\n.TEST10  AIF   ('&WHILE' NE '').TEST20 GO IF &WHILE SPECIFIED\n         AIF   ('&UNTIL' NE '').TEST22  GO IF &UNTIL SPECIFIED\n         AIF   ('&VAR' NE '').OK30 GO IF &VAR SPECIFIED\n         MNOTE 4,'NO ENDING CONDITION - POSSIBLE UNENDING LOOP'\n         AGO   .OK30               CONTINUE\n.TEST20  AIF   ('&UNTIL' NE '').ERR90 GO IF &UNTIL SPECIFIED\n.TEST22  AIF   ('&VAR' NE '').ERR90 GO IF &VAR SPECIFIED\n         AIF   ('&WHILE' NE '').CONT50\n.OK30    AIF   ('&UNTIL' NE '').CONT60\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'DO'\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n&$MLTAG(&$MDGLVL) SETC '&$MNAME'   SET LOOP RETURN TAG\n         AIF   ('&VAR' EQ '').CLEAN99 GO IF NO &VAR SPECIFIED\n         AIF   ('&VAR'(1,1) GE '0').SELF40 GO IF SELF-DEFINING\n.*                                 - (MUST BE PACKED DECIMAL)\n         AIF   ('&VAR' NE 'FOREVER').NEXT32 GO IF NOT FOREVER\n         AIF   ('&NAME' EQ '').SKIP31\n&NAME    DS    0H                  FALL THRU TO BEGINNING OF DO-GROUP\n.SKIP31  ANOP\n&$MNAME  DS    0H                  BEGINNING OF DO-GROUP\n         AGO   .CLEAN99\n.NEXT32  ANOP\n&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1\n         ZAP   $MDM&SYSNDX,&VAR    PROTECT VARIABLE FROM CHANGE\n         AIF   ('&TEST' NE 'AFTER').SKIP35\n         EX    0,*+8               BUMP BY 1\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP35  ANOP\n&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1\n&$MNAME  SETC  ''                  SET NAME TO NULL\n&X       SETC  '$MDM&SYSNDX'       NAME FOR CELL FOR END VALUE\n         CP    $MDV&SYSNDX,&X      FINISHED?\n         JH    $MDF&SYSNDX         B IF YES\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&Y       SETA  L'&VAR              MAKE SURE OUR VARIABLE IS BIG ENOUGH\n&X       DC    PL(&Y+1)'0'         CELL TO SAVE END VALUE\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&X       DC    PL(&Y+1)'0'         LOOP COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         AGO   .CLEAN99\n.SELF40  ANOP\n&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1\n         AIF   ('&TEST' NE 'AFTER').SKIP46\n         EX    0,*+8               BUMP BY 1\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP46  ANOP\n&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1\n&$MNAME  SETC  ''                  SET NAME TO NULL\n         CP    $MDV&SYSNDX,=P'&VAR' FINISHED?\n         JH    $MDF&SYSNDX         B IF YES\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&X       DC    P'0&VAR'            LOOP COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         AGO   .CLEAN99\n.CONT50  ANOP  &WHILE OPTION WAS SPECIFIED\n&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME\n         AIF   ('&NAME' NE '').CONT52 NO TAG -> NO DC\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n.CONT52  ANOP\n&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER\n&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME\n         AIF   ('&TEST' NE 'AFTER').SKIP53\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP53  AIF   ('&WHILE'(2,1) EQ '(').CONT54\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &WHILE,THENDO       PASS PARMS TO 'IF'\n         AGO   .CLEAN99            WRAP IT UP\n.CONT54  ANOP\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),                C\n               &WHILE(5),&WHILE(6),&WHILE(7),&WHILE(8),                C\n               &WHILE(9),&WHILE(10),&WHILE(11),&WHILE(12),             C\n               &WHILE(13),&WHILE(14),&WHILE(15),&WHILE(16),            C\n               &WHILE(17),&WHILE(18),&WHILE(19),&WHILE(20),            C\n               &WHILE(21),&WHILE(22),&WHILE(23),&WHILE(24)\n         AGO   .CLEAN99\n.CONT60  ANOP  &UNTIL OPTION WAS SPECIFIED\n&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME\n         AIF   ('&NAME' NE '').CONT62 NO TAG -> NO DC\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n.CONT62  ANOP\n&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER\n&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME\n         AIF   ('&TEST' NE 'AFTER').SKIP63\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP63  AIF   ('&UNTIL'(2,1) EQ '(').CONT64\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &UNTIL,THENDO       PASS PARMS TO 'IF'\n         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG\n&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG\n         AGO   .CLEAN99            WRAP IT UP\n.CONT64  ANOP\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &UNTIL(1),&UNTIL(2),&UNTIL(3),&UNTIL(4),                C\n               &UNTIL(5),&UNTIL(6),&UNTIL(7),&UNTIL(8),                C\n               &UNTIL(9),&UNTIL(10),&UNTIL(11),&UNTIL(12),             C\n               &UNTIL(13),&UNTIL(14),&UNTIL(15),&UNTIL(16),            C\n               &UNTIL(17),&UNTIL(18),&UNTIL(19),&UNTIL(20),            C\n               &UNTIL(21),&UNTIL(22),&UNTIL(23),&UNTIL(24)\n         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG\n&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG\n         AGO   .CLEAN99            WRAP IT UP\n.ERR90   MNOTE 12,'MUTUALLY EXCLUSIVE PARAMETERS - MACRO ABORTED'\n         AGO   .MEND990\n.CLEAN99 ANOP\n         AIF   ('&TEST' NE 'AFTER').MEND990\n&X       SETC  '&SYSNDX'           FOR ALIGNMENT PURPOSES ONLY\n$MDD&X   DC    0H'0'               BEGINNING OF DO-GROUP\n.MEND990 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOCUMENT": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00 \\x01\\x01\"o\\x01\\x02\\x07/\\x15I\\x02\\xc3\\x06b\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "2001-08-14T00:00:00", "modifydate": "2002-03-13T15:49:20", "lines": 707, "newlines": 1634, "modlines": 0, "user": "GENTR02"}, "text": "THIS MEMBER IS AN INTRODUCTION TO THE MACRO DEFINITIONS WHICH COMPRISE\nTHE REMAINING MEMBERS OF THIS LIBRARY.  EACH OF THE MACROS HAS BEEN\nTESTED, FOUND TO OPERATE CORRECTLY, AND TO PROVIDE AT LEAST SOME\nMINIMUM AMOUNT OF DESIRABLE FUNCTIONALITY.  IF A PROBLEM CROPS UP,\nEITHER IN YOUR UNDERSTANDING HOW TO USE A PARTICULAR MACRO OR GROUP OF\nMACROS, OR WITH APPARENT PROGRAMMING PROBLEMS WITH THE PACKAGE, PLEASE\nFEEL FREE TO CONTACT THE AUTHOR (NOTE THESE MACROS ARE NOT COPYWRITED):\n\n          DAN SNYDER                  614-847-8212\n          COMPUWARE CORP              dsnyder@elektro.cmhnet.org\n          1103 SCHROCK ROAD, STE 205\n          COLUMBUS, OH 43229\n\nTHE FOLLOWING IS A DESCRIPTION OF THE CATEGORIES THAT THESE MACROS HAVE\nBEEN CLASSIFIED INTO:\n\nINTERNAL - THESE MACROS ARE TYPICALLY USED AS COMMON SERVICE ROUTINES\nBY OTHER MACROS WITHIN THIS LIBRARY.  THEY PROVIDE SERVICES THAT WOULD\nNOT NORMALLY BE CALLED FROM OPEN CODE. THEY ARE AUTOMATICALLY COPIED\nINTO THE ASSEMBLE THE FIRST TIME THAT $GBLDEF IS COPIED INTO A MACRO\nTHAT IS BEING EXPANDED.\n\nSTRUCTURED - MACROS THAT CONTROL THE CONDITIONAL OR REPETITIVE\nEXECUTION OF A GROUP OF INSTRUCTIONS FOLLOWING THE GROUP-INITIATION\nMACRO AND ENDING WITH A GROUP-TERMINATING MACRO. SEVERAL MACROS IN THIS\nFAMILY GENERATE A 'LOCTR' STATEMENT NAMED 'DATA' TO ALLOW THE OUT-OF-LINE\nGENERATION OF REQUIRED CONSTANTS AND VARIABLES.  THE NAME OF THE LOCTR\nCAN BE CHANGED TO LOCAL REQUIREMENTS IN THE $MGBLDEF MEMBER.\n\nDIAGNOSTIC - THE 'BEGTEST' AND 'ENDTEST' MACROS ALLOW YOU TO CONDITIONALLY\nINCLUDE OR EXCLUDE SECTIONS OF CODE FROM A PARTICULAR ASSEMBLY.  THE CODE\nCAN CONTINUE TO EXIST IN THE SOURCE MODULE. YOU COULD INCLUDE ONE\nSECTION OF CODE FOR MVS SYSTEMS, AND ANOTHER FOR VSE.  THIS FACILITY\nPROVIDES A 'STRUCTURED' EQUIVALENT OF HAVING 'AGO' OR 'AIF' STATEMENTS\nTARGETTING LABELLED 'ANOP' STATEMENTS WITHIN YOUR CODE.\n\nGENERAL - THE 'EXECUTE' MACRO ALLOWS THE PROGRAMMER TO CREATE AN 'EX'\nSTATEMENT ON ONE LINE OF CODE.  IT GENERATES A 'LOCTR' STATEMENT NAMED\n'DATA' TO ALLOW THE OUT-OF-LINE GENERATION OF THE 'EX'ECUTED INSTRUCTION.\nTHE NAME OF THE LOCTR AREA CAN BE CHANGED TO LOCAL REQUIREMENTS.\n\nIN EACH OF THE EXAMPLES, IF '<NAME>' IS DISPLAYED IN THE NAME FIELD\nOF A MACRO DEFINITION, THEN THE NAME FIELD IS A SUPPORTED OPTION FOR\nTHAT MACRO.\n\nWHAT FOLLOWS IS A MOSTLY ALPHABETICAL LISTING OF ALL OF THE MACRO\nDEFINITIONS INCLUDED IN THE PACKAGE, WITH ITS IDENTIFYING MACRO TYPE:\n\n$MGBLDEF  INTERNAL (GLOBAL SET SYMBOL DEFINITIONS AND INTERNAL MACROS)\nAFTER     STRUCTURED\nBEGTEST   DIAGNOSTIC\nDO        STRUCTURED\nDOEXIT    STRUCTURED\nDONEXT    STRUCTURED\nELSE      STRUCTURED\nELSEDO    STRUCTURED\nELSEIF    STRUCTURED\nENDAFTER  STRUCTURED\nENDELSE   STRUCTURED\nENDEVERY  STRUCTURED\nENDFIRST  STRUCTURED\nENDIF     STRUCTURED\nENDO      STRUCTURED\nENDTEST   DIAGNOSTIC\nEVERY     STRUCTURED\nEXECUTE   GENERAL\nFIRST     STRUCTURED\nIF        STRUCTURED\nTHENDO    STRUCTURED\n\n                            DIAGNOSTIC\n\nTHE MACROS IN THIS GROUP FURNISH VARIOUS AIDS THAT CAN BE USED IN\nDIAGNOSING THE EXECUTION OF A PROGRAM.  THE 'BEGTEST' AND 'ENDTEST'\nMACROS ALLOW MULTIPLE LINES OF CODE TO BE INCLUDED OR EXCLUDED FROM\nAN ASSEMBLY, BASED ON THE VALUE OF A GLOBAL SET SYMBOL.\n\nBEGTEST\nTHIS MACRO HEADS A GROUP OF INSTRUCTIONS THAT ARE CONDITIONALLY\nINCLUDED OR EXCLUDED FROM A PARTICULAR ASSEMBLY. THE GROUP MUST BE\nTERMINATED WITH AN 'ENDTEST' MACRO.  THE 'BEGTEST' REQUIRES ONE\nPOSITIONAL OPERAND.  IF THE OPERAND IS NUMERIC, THEN THAT VALUE IS\nCOMPARED WITH THE GLOBAL TYPE 'A' SET SYMBOL &TESTLVL.  IF THE OPERAND\nIS GREATER THAN &TESTLVL, THEN THE INSTRUCTIONS BETWEEN THE 'BEGTEST'\nAND 'ENDTEST' ARE EXCLUDED FROM THIS ASSEMBLY, OTHERWISE THEY ARE\nINCLUDED:\n\n          GBLA  &TESTLVL\n &TESTLVL SETA  10\n ...\n<NAME>    BEGTEST 5,PRINT=YES\n          WTO   'HELP'\n<NAME>    ENDTEST ,\n\nIN THIS CASE, THE 'WTO' STATEMENT WILL BE ASSEMBLED.  IF &TESTLVL HAD\nBEEN SET TO 0 (ZERO), THEN THE 'WTO' WOULD HAVE BEEN EXCLUDED FROM\nTHIS ASSEMBLY.  THE PARAMETER 'PRINT=YES' CAUSES EACH STATEMENT\nSKIPPED TO BE LISTED AS A COMMENT (A '-' IS PRINTED IN THE LISTING\nPRECEDING COLUMN 1 OF THE STATEMENT).\n\nBE VERY CAREFUL ABOUT GIVING A NAME TO THE 'ENDTEST' MACRO.  IF YOU\nCODE A BRANCH INSTRUCTION WITH THAT NAME AS THE OPERAND, AND THAT\n'ENDTEST' INSTRUCTION IS OMITTED FROM THE PROGRAM BECAUSE OF THE VALUE\nOF &TESTLVL, THEN YOU WILL GET AN ASSEMBLY ERROR.  IT WOULD BE SAFE TO\nHAVE A BRANCH TO THAT TAG ONLY WITHIN THE GROUP OF INSTRUCTIONS HEADED\nBY THE 'BEGTEST' MACRO.\n\nIF THE VALUE OF THE POSITIONAL OPERAND OF THE 'BEGTEST' IS 'A', 'B',\n'C', OR 'D', THEN THE LOGIC IS BASED ON THE SETTING OF THE GLOBAL TYPE\n'C' SET SYMBOL &$A, &$B, &$C OR &$D RESPECTIVELY:\n\n          GBLC  &$A\n&$A       SETC  'Y'     ANY OTHER VALUE CAUSES EXCLUSION\n...\n<NAME>    BEGTEST A,PRINT=NO\n          WTO   'OPT CODE INCLUDED'\n<NAME>    ENDTEST ,\n\nSINCE THE SET SYMBOL &$A WAS SET TO 'Y', THE 'WTO' WILL BE INCLUDED IN\nTHIS ASSEMBLY.  IF &$A HAD BEEN SET TO ANY OTHER VALUE THEN THE CODE\nWOULD NOT BE INCLUDED IN THIS ASSEMBLY.  THE 'PRINT=NO' PARAMETER\nPREVENTS THE SKIPPED STATEMENTS FROM BEING PRINTED.\n\n&$A       SETC  'N'     ONLY 'Y' CAUSES INCLUSION\n...\n<NAME>    BEGTEST A\n          WTO   'OPT CODE EXCLUDED'\n<NAME>    ENDTEST ,\n\nSINCE THE SET SYMBOL &$A WAS SET TO 'N', THE 'WTO' WILL BE EXCLUDED.\n\nNOTE: WHEN YOU CODE A 'PRINT=YES/NO' PARAMETER ON THE BEGTEST\nSTATEMENT, THAT OPTION REMAINS IN EFFECT FOR THE REMAINING 'BEGTEST'\nMACROS UNTIL ANOTHER 'PRINT=YES/NO' CLAUSE IS ENCOUNTERED. IF YOU\nPREFER TO CONTROL THE PRINTING OF SKIPPED INSTRUCTIONS AT THE\nBEGINNING OF YOUR PROGRAM, YOU MAY DO SO BY:\n\n         GBLC  &$MPRSW\n&$MPRSW  SETC  'NO'       TO SUPPRESS PRINTING SKIPPED INSTRUCTIONS\n&$MPRSW  SETC  'YES'      TO CAUSE THE PRINTING SKIPPED INSTRUCTIONS\n\nCHOOSE THE 'SETC' STATEMENT THAT PROVIDES THE OPTION THAT YOU WANT.\n\nENDTEST\nTHIS ONE NEEDS TO BE USED ONLY IN CONJUNCTION WITH THE 'BEGTEST'\nMACRO. IT IS USED TO END A GROUP OF CONDITIONALLY INCLUDED LINES OF\nCODE. PLEASE SEE THE DOCUMENTATION FOR 'BEGTEST'.\n\nEXECUTE\nTHIS ONE MAKES IT POSSIBLE TO CONSTRUCT AN 'EX' INSTRUCTION WITH ONE\nLINE OF CODE.  IF YOU'VE NEVER USED THE 'EX' INSTRUCTION, YOU'RE\nPROBABLY BETTER OFF SKIPPING THE REST OF THIS 'EXECUTE' DOCUMENTATION.\nIF YOU HAVE ALREADY USED IT, OR IF YOU'RE VERY BRAVE, THEN HERE GOES.\nIT REQUIRES THREE POSITIONAL OPERANDS. THE FIRST IS A GPR (IT DOESN'T\nHAVE TO BE WITHIN PARENTHESES, SINCE IT HAS TO BE A GPR), THE SECOND\nIS THE OP CODE FOR THE INSTRUCTION BEING 'EX'ECUTED, AND THE THIRD\nCONSISTS OF ALL OF THE OPERANDS OF THE INSTRUCTION BEING 'EX'ECUTED,\nAND THEY MUST BE ENCLOSED WITHIN PARENTHESES.\n\n <NAME>   EXECUTE R15,MVC,(FIELDA(0),FIELDB)\n+<NAME>   EX     R15,$EX1234         GENERATED\n+...\n+$EX1234  MVC   FIELDA(0),FIELDB     GENERATED\n\nNOTE THAT THE THIRD OPERAND IS GENERATED OUT-OF-LINE.\n\n                            INTERNAL\n\nTHESE MACRO DEFINITIONS ARE FURNISHED WITHIN THE COPY MEMBER '$MGBLDEF' AND\nARE INCLUDED INTO THE ASSEMBLY THE FIRST TIME THAT A COPY STATEMENT FOR THAT\nMEMBER IS ENCOUNTERED IN YOUR PROGRAM.  THUS THE FIRST 'IF' STATEMENT (OR\nOTHER STRUCTURED MACRO) WILL CAUSE THESE TO BE INCLUDED.\n\n                            STRUCTURED\n\nTHIS SET OF MACROS CAUSES A CONDITIONAL AND/OR REPETITIVE EXECUTION OF\nA GROUP OF ONE OR MORE INSTRUCTIONS.  FOR CONVENIENCE, LET'S CALL A\nGROUP OF INSTRUCTIONS THAT MIGHT OR MIGHT NOT BE EXECUTED ONE TIME, OR\nMULTIPLE TIMES, A 'CR-GROUP', FOR 'C'ONDITIONAL/'R'EPETITIVE.\n\nMNOTE STATEMENTS ARE ISSUED WHEN A POTENTIAL PROBLEM IS DETECTED. IF\nTHE MNOTE CODE IS 0 THEN IT REPRESENTS AN INFORMATIONAL MESSAGE. IF IT\nIS 4, THEN THE CODE GENERATED IS PROBABLY CORRECT, BUT SHOULD BE\nEXAMINED. IF IT IS 8, THEN A LIKELY ERROR EXISTS AND SHOULD BE\nCORRECTED.  IF IT IS 12, THEN THE CODE GENERATED WILL BE INCORRECT\nAND/OR INCOMPLETE, AND THE STATEMENT RESPONSIBLE MUST BE CORRECTED.\n\nIF\nTHIS IS THE HEART OF THE STRUCTURED MACROS. IT SUPPORTS THE\nCONDITIONAL EXECUTION OF A CR-GROUP BASED ON ONE OR MORE TESTS. EACH\nTEST PHRASE, CONTAINED WITHIN PARENTHESES, MUST CONSIST OF AN OP-CODE,\nA FIRST OPERAND, A SECOND OPERAND, AND A CONDITION. (NOTE OP-CODES\nWITH OTHER THAN TWO OPERANDS ARE SUPPORTED, BUT THE OP-CODE MUST\nALWAYS BE FIRST AND THE CONDITION MUST ALWAYS BE LAST WITHIN THE\nPHRASE.)  IN THE SIMPLE CASE, ONE CONDITIONAL PHRASE IS FOLLOWED BY\nA 'THENDO'.  IN COMPLEX CASES, EACH ODD-NUMBERED PARAMETER MUST\nCONTAIN THE INSTRUCTION SETTING THE CONDITION CODE AS SUBPARAMETERS\nWITHIN PARENTHESES, AND EACH EVEN-NUMBERED PARAMETER MUST BE AN\n'OR', AN 'AND', OR THE LAST PHRASE MUST BE A 'THENDO' (IF YOU OMIT\nTHE 'THENDO', THEN YOU WILL GET AN INFORMATIONAL MNOTE STATEMENT):\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO\n            ...\n          ENDIF ,\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),OR,                     X\n                (CLC,FIELDA,FIELDC,E),THENDO\n            ...\n          ENDIF ,\n\nNOTE THAT THE FORMAT OF THE CONDITIONAL PHRASE IS FIXED IN THAT:\n1. THE OP-CODE IS ALWAYS THE FIRST OPERAND\n2. THE CONDITION IS ALWAYS LAST\n3. THE OPERANDS ARE ALWAYS IN THEIR ORDINAL POSITIONS IN BETWEEN\n4. IF YOU SET GLOBAL TYPE A SET SYMBOL &$MBLATH TO A VALUE GREATER\n   THAN ZERO, THEN VARIOUS DIAGNOSTICS ARE MNOTED DURING THE MACRO\n   GENERATION PHASE. IF YOU SET IT TO 10, THEN NESTING IS NOTED\n   (SIMILAR TO COBOL IF-STATEMENT LEVELS LISTED TO THE LEFT OF THE\n   SOURCE STATEMENTS). IF YOU SET IT TO 12, THEN THE RECURSION\n   LEVEL OF THE 'IF' STATEMENT IS MNOTED. TO DO THIS, YOU HAVE TO\n   DEFINE THE SET SYMBOL IN OPEN CODE. THIS GIVES YOU THE\n   COMMUNICATION LINK TO THE SAME NAME DEFINED WITHIN THE MACRO\n   LIBRARY:\n\n         GBLA  &$MBLATH\n&$MBLATH SETA  10              SHOW NESTING LEVELS\n                     - OR -\n&$MBLATH SETA  12              SHOW NESTING AND RECURSION LEVELS\n\nEXAMPLES:\n\n         IF   (UPT,Z),THENDO          INST WITH ZERO OPERANDS\n+        UPT  ,\n+        JNZ   ...\n\n         IF   (SSCH,12,Z),THENDO                ONE OPERAND\n+        SSCH 12\n+        JNZ  ...\n\n         IF   (CLI,LCLSW,C'0',E),THENDO         TWO OPERANDS\n+        CLI  LCLSW,C'0'\n+        JNE  ...\n\n         IF   (SRP,PFIELD1,PFIELD2,5,Z),THENDO  THREE OPERANDS\n+        SRP  PFIELD1,PFIELD2,5\n+        JNZ  ...\n\nIF YOU CODE THE WRONG NUMBER OF PARAMETERS FOR A PARTICULAR OP-CODE,\nTHEN 'THE RESULTS ARE UNPREDICTABLE', ALTHOUGH GENERALLY THE MACRO\nWILL EXPAND WITHOUT NOTING THE ERROR AND YOU WILL GET AN ERROR ON\nTHE GENERATED INSTRUCTION.\n\nNOTE THAT THE OP-CODE 'CLC' WILL BE USED THROUGHOUT THESE EXAMPLES.\nWHEN YOU CODE YOUR PROGRAM, USE WHATEVER INSTRUCTION IS APPORPRIATE,\nSO LONG AS IT IS ONE THAT SETS THE PROCESSOR'S CONDITION CODE FIELD.\nIT COULD EVEN BE A MACRO STATEMENT, SO LONG AS THE CONDITION CODE\nIS SET BY ONE OF THE INSTRUCTIONS GENERATED BY THE MACRO EXPANSION SO\nTHAT IT CAN BE TESTED BY THE BRANCH-ON-CONDITION THAT FOLLOWS.\n\nIN THIS EXAMPLE, IF FIELDA IS EQUAL TO FIELDB, THEN THE CR-GROUP\nWILL BE EXECUTED.  THE CONDITION, CODED AS THE LAST POSITIONAL\nSUB-PARAMETER, CAN BE ANY OF THE EXTENDED BRANCH NMEMONICS:\n\n  E NE H NH L NL M NM O NO P NP Z NZ\n\nIN THE ABOVE EXAMPLE, THE MACRO EXPANDS INTO:\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO\n+<NAME>   CLC   FIELDA,FIELDB    GENERATED\n+         BNE   $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\nNOTE: IN THIS SIMPLE EXAMPLE, THE CONDITION 'E' STATES THAT THE IF-GROUP\nIS TO BE EXECUTED IF THE 'CLC' RESULTS IN AN 'EQUAL'.  TO CAUSE THIS\nLOGIC TO OCCUR, A BRANCH ON THE OPPOSITE CONDITION IS CREATED TO BYPASS\nTHE IF-GROUP, MEANING THAT PROGRAM EXECUTION 'FALLS THROUGH' INTO THE\nIF-GROUP WHEN THE SPECIFIED CONDITION IS MET.\n\nLIKEWISE, FOR THE PHRASE '(CLC,FIELDA,FIELDB,NE)', THE BYPASSING BRANCH\nINSTRUCTION GENERATED WOULD BE A 'BE    $TAG'.\n\nNOTE: '$TAG' INDICATES THAT THE MACRO GENERATION PROCESS WILL GENERATE\nAN UNIQUE TAG, WHOSE NAME BEGINS WITH '$', AND ENDS WITH A UNIQUE NUMBER\nOBTAINED FROM A SYSTEM COUNTER.\n\nIF YOU HAD CODED 'NE' AS THE CONDITION, THEN IT WOULD EXPAND TO:\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,NE),THENDO\n+<NAME>   CLC   FIELDA,FIELDB    GENERATED\n+         BE    $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\n     TO EXECUTE THE CR-GROUP IF EITHER ONE OF TWO CONDITIONS IS\nTRUE, THE FORMAT IS:\n\n <NAME>   IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n     ALTERNATE FORMAT:\n                                                               72\n <NAME>   IF    (CLC,A,B,NE),OR,                                C\n           (CLC,C,D,NE),THENDO\n\n     NOTE THAT, AS SHOWN IN THE EXAMPLES, YOU NEED TO ENCLOSE THE\nCONDITIONAL PHRASES WITHIN PARENTHESES, AND THAT YOU DO NOT\nENCLOSE THE CONNECTING PHRASES ('OR' OR 'AND') OR THE FINAL\n'THENDO' WITHIN PARENTHESES.\n\n     SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\nEXAMPLE, THE CR-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\nIF BOTH THE SECOND AND THIRD ARE TRUE:\n\n <NAME>   IF    (CLC,A,B,E),OR,                                 C\n                (CLC,C,D,E),AND,                                C\n                (CLC,E,F,E),THENDO\n\n     IF YOU NEED TO CREATE A SUB-GROUP OF PHRASES CONNECTED BY\n'OR' CONNECTORS, AND THEN CONNECT THIS SUB-GROUP VIA AN 'AND'\nWITH ANOTHER CONDITION (WHICH MAY ITSELF CONSIST OF ANOTHER\nSUB-GROUP OF CONDITIONS), THEN YOU NEED TO ENCLOSE THE ENTIRE\nSUB-GROUP WITHIN AN ADDITIONAL PAIR OF PARENTHESES:\n\n                * <-NESTING PARENTHESES -> *\n <NAME>   IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n                (CLC,E,F,E),THENDO\n\n     THE AUTHOR OF THESE MACROS PREFERS THE FORMAT:\n\n <NAME>   IF    ((CLC,A,B,E),OR,                                C\n                (CLC,C,D,E)),AND,                               C\n                (CLC,E,F,E),THENDO\n\n     I GUESS THE BOTTOM LINE IS THAT S/390 ASSEMBLER IS SOMEWHAT OF A\nPAIN, NO MATTER HOW YOU FORMAT THE STATEMENTS!\n\n     GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\nTO DEFINE THE LOGIC DESIRED. THE LIMIT IS THE LENGTH OF A SINGLE\nOPERAND SUPPORTED BY THE ASSEMBLER BEING USED.\n\n     NOTE THAT THE CONDITIONAL PHRASES ARE EXECUTED IN THE ORDER\nTHAT THEY ARE WRITTEN.  THEREFORE, IF THERE ARE ONE OR MORE PHRASES\nTHAT MORE OFTEN THAN NOT WOULD RESULT IN AN ABBREVIATED PASS THRU THE\nCONSTRUCT, THEN YOU SHOULD CODE THOSE PHRASES FIRST (MAINTAINING THE\nLOGIC REQUIRED FOR THE DESIRED RESULT, OF COURSE!).\n\n     EACH CR-GROUP MUST BE TERMINATED WITH AN 'ENDO' STATEMENT\nOR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n          ENDIF ,\n                 - OR -\n          ELSE  ,\n     ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n          ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n     ALTERNATIVELY, A CR-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n          ELSEIF  (CLC,G,H,E),THENDO ...\n            ...\n          ELSEIF  (CLC,I,J,E),THENDO ...\n            ...\n          ELSE  ,\n            ...\n          ENDELSE ,\n\n     ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n     'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n     ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n     GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\nTHE 'ELSEIF' IS THE AUTHOR'S CURRENT FEEBLE ATTEMPT AT PROVIDING THE\nFUNCTIONALITY OF THE 'CASE' (C/C++) OR 'EVALUATE' (COBOL).\n\nTHENDO\nTHE SIMPLIST OF THESE IS THE 'THENDO' MACRO THAT MUST BE TERMINATED BY\nAN 'ENDO':\n         CLC   FIELDA,FIELDB\n         THENDO E\n         ...\n         ENDO\n\nTHE STATEMENTS REPRESENTED BY THE '...' WILL BE EXECUTED ONLY IF THE\n'CLC' RESULTED IN AN 'E'. OPTIONALLY YOU MAY CODE AN 'ELSE' STATEMENT,\nAND/OR ONE OR MORE 'ELSEDO' STATEMENTS:\n\n         TRT   FIELDA,TABLE1\n         THENDO L       DO IF NON-ZERO FUNCTION AND NOT LAST ARG\n         ...\n         ELSEDO H       DO IF NON-ZERO FUNCTION AND LAST ARG\n         ...\n         ELSEDO E       DO IF ALL FUNCTION BYTES ZERO\n         ...\n         ENDO\n\nSINCE THE 'TRT' CAN ONLY GENERATE CC'S OF 0, 1, OR 2, THAT LAST\n'ELSEDO E' COULD HAVE BEEN REPLACED BY 'ELSE'.  AT ANY RATE, THIS IS\nA VIABLE WAY TO TEST VALUES OF THE CONDITION CODE THAT ARE SET BY ONE\nINSTRUCTION.  AS YOU WILL SEE WITH THE 'IF' STATEMENT, THE\nINSTRUCTION(S) THAT SET THE CC AND THE TEST FOR THE VALUE OF THE CC\nALL FORM PART OF THE SAME STATEMENT, SO THAT IT IS PROBABLY BETTER\nTO USE THE 'IF' AND 'ELSEIF' WITH INSTRUCTIONS THAT DO NOT MODIFY THEIR\nOPERANDS (SUCH AS 'CLC' OR 'TM' ETC.).\n\nEACH CR-GROUP MUST BE HEADED BY ONE OF THE FOLLOWING MACRO STATEMENTS:\n\n  AFTER      DO     EVERY      FIRST      IF        THENDO\n\nAND MUST BE TERMINATED BY ONE OF THE FOLLOWING:\n\n  ENDAFTER   ENDO   ENDEVERY   ENDFIRST   ENDIF\n\nIT IS SOMEWHAT OVERSIMPLIFYING TO SAY THAT ALL OF THE ENDXXXXX MACROS\nSIMPLY INVOKE 'ENDO', BUT THE TRUTH IS THAT THE INDIVIDUAL ENDXXXXX\nMACROS ARE MORE FOR PROGRAM DOCUMENTATION THAN THEY ARE FOR INTERNAL\nLOGIC DIFFERENCES. SO, IF YOU END AN CR-GROUP WITH AN 'ENDAFTER'\nMACRO, NO DIAGNOSTICS WILL BE ISSUED AND YOUR PROGRAM WILL WORK THE\nSAME AS IF YOU HAD CODED AN 'ENDIF'.\n\nCR-GROUPS MAY BE NESTED TO ANY DESIRED LEVEL:\n\n          IF    ...\n          ...\n            DO    ...\n            ...\n            ENDO  ,\n          ...\n          ENDIF ,\n\nYOU MAY FIND IT EFFECTIVE TO INDENT AT EACH LEVEL OF NESTING, BUT\nBEWARE - THE CONTINUATION COLUMN IS ALWAYS THE SAME (16 IS THE\nDEFAULT).\n\nTHERE ARE TWO ADDITIONAL SIGNIFICANT MACROS THAT CAN BE USED WITHIN\nTHIS PACKAGE OF STRUCTURED PROGRAMMING MACROS.  THE 'ELSEIF' MACRO CAN\nBE USED FOLLOWING AN 'IF' OR ANOTHER 'ELSEIF' MACRO, AND SUPPORTS THE\nSAME TYPES OF LOGIC THAT THE 'IF' MACRO SUPPORTS.  THE 'ELSE' MACRO\nCAN FOLLOW AN 'IF', 'ELSEIF', 'AFTER', 'EVERY' OR 'FIRST' MACRO, AND\nALLOWS ITS CR-GROUP TO BE EXECUTED IF ALL OF THE PRECEDING CR-GROUPS\nWERE NOT EXECUTED.\n\nIN GENERAL, I WOULD SUGGEST THAT YOU NOT CREATE A NAME FIELD FOR A MACRO\nTHAT ENDS A CR-GROUP. IT MIGHT BE PERMISSIBLE IF YOU NEED TO EXIT THE\nCR-GROUP FROM SOMEWHERE DEEP INSIDE IT, BUT AS SOON AS YOU START NAMING\nSTATEMENTS, IT SIGNALS EVEN MORE BAD HABITS TO COME.\n\nAFTER\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE SKIPPED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN EXECUTED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM. AN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'EVERY' AND 'FIRST'.\n\n <NAME>  AFTER 1000000\n            ...\n         ENDAFTER ,\n\nDO\nTHIS ONE PROVIDES REPETITIVE EXECUTION OF A CR-GROUP. THERE ARE\nSEVERAL OPTIONS: THE FIRST IS TO CODE A NUMERIC SELF-DEFINING TERM,\nWHICH CAUSES THE CR-GROUP TO BE EXECUTED THAT NUMBER OF TIMES:\n\n <NAME>   DO    5\n            ...\n          ENDO  ,\n\nA SLIGHT VARIATION IS TO CODE:\n\n <NAME>  DO    FOREVER\n           ...\n         ENDO  ,\n\nTHIS CAUSES THE CR-GROUP TO BE CONTINUOUSLY EXECUTED UNTIL SOMETHING\nEITHER WITHIN THE LOOP OR SOMETHING OUTSIDE THE PROGRAM (TIME\nEXCEEDED, ETC) CAUSES THE LOOP TO BE BROKEN.\n\nIF YOU CODE:\n\n <NAME>  DO    MYVARBL\n           ...\n         ENDO  ,\n\nTHEN 'MYVARBL' MUST BE A PACKED DECIMAL VARIABLE WHICH YOU HAVE\nALREADY INITIALIZED TO THE VALUE FOR THE NUMBER OF TIMES THAT YOU\nWANT THIS CR-GROUP REPEATED. BE VERY CAREFUL ABOUT MODIFYING THIS\nVARIABLE FROM WITHIN THE LOOP. ITS VALUE IS CAPTURED ONLY AT THE\nBEGINNING OF THE EXECUTION OF THE CR-GROUP, AND ANY CHANGE TO THE\nVALUE OF THE VARIABLE WILL TAKE EFFECT THE NEXT TIME THE 'DO'\nSTATEMENT IS ENCOUNTERED.\n\nIF YOU WANT TO REPEAT A CR-GROUP BASED ON ONE OR MORE CONDITIONS,\nTHEN YOU CAN USE EITHER ONE OF THE FOLLOWING:\n\n <NAME>  DO    UNTIL=(...)\n           ...\n         ENDO  ,\n\n         .. OR ..\n\n <NAME>  DO    WHILE=(...)\n           ...\n         ENDO  ,\n\nIN THE FIRST OF THESE TWO EXAMPLES, THE CR-GROUP WILL BE EXECUTED\nREPETITIVELY UNTIL ONE OR MORE OF THE CONDITIONS IS MET. IN THE\nSECOND, IT WILL BE EXECUTED SO LONG AS ONE OR MORE OF THE CONDITIONS\nIS MET.  IN BOTH OF THESE EXAMPLES, THE VALUES WITHIN THE PARENTHESES\nARE THE SAME AS FOR THE 'IF' MACRO. PLEASE SEE ITS DOCUMENTATION FOR\nTHE DETAILS.  THE ONLY DIFFERENCE BETWEEN THE OPERANDS HERE AND FOR\nTHE 'IF' MACRO IS THAT, IF THE CONDITION IS COMPLEX, THAT IS, IF IT\nCONSISTS OF MULTIPLE CONDITIONS CONNECTED WITH 'AND' AND/OR 'OR'\nCLAUSES, THEN THE ENTIRE OPERAND MUST BE ENCLOSED WITHIN ONE\nADDITIONAL LEVEL OF PARENTHESES:\n\n <NAME>   DO    UNTIL=((...),OR,(...))\n                      *              *  <== REQUIRED IF COMPLEX\n            ...\n          ENDO  ,\n\nONE ADDITIONAL KEYWORD OPERAND IS AVAILABLE:\n\n <NAME>   DO    UNTIL=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\n          .. OR ..\n\n <NAME>   DO    WHILE=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\nTHE 'TEST=AFTER' CAUSES THE CR-GROUP TO BE EXECUTED ONE TIME BEFORE\nTHE CONDITIONAL TESTS ARE MADE. DEFAULT IS 'TEST=BEFORE', WHERE THE\nCR-GROUP MIGHT NOT BE EXECUTED EVEN ONCE, DEPENDING ON THE INITIAL\nCONDITIONS.\n\nDOEXIT\nTHE 'DOEXIT' MACRO CAUSES EXECUTION TO TRANSFER TO THE FIRST INSTRUCTION\nFOLLOWING THE MATCHING 'ENDO' STATEMENT:\n\n <NAME>   DO    UNTIL=(...)\n            ...\n            DOEXIT ,\n            ...\n          ENDO  ,\n\nIF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'\nSTATEMENTS, A 'DOEXIT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE\nSTATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:\n\n<NAME>    DO    UNTIL=(...)\n            ...\n            IF    (...),THENDO\n              ...\n              DOEXIT , TRANSFERS TO STATEMENT FOLLOWING .. |\n              ...                                          |\n              DO    WHILE=(...)                            |\n                ...                                        |\n                DOEXIT , TRANSFERS TO STMT FOLLOWING |     |\n                ...                                  |     |\n              ENDO  ,                 <---------------     |\n              ...                                          |\n            ENDIF ,                                        |\n            ...                                            |\n          ENDO  ,                     <---------------------\n\nDONEXT\nTHE 'DONEXT' MACRO TRANSFERS EXECUTION TO THE LOGIC CONTROLLING THE DO\nSTATEMENT FOR THE NEXT ITERATION. DEPENDING ON THE CONDITIONS BEING\nTESTED, THE CR-GROUP MIGHT OR MIGHT NOT BE EXECUTED AGAIN.\n\n <NAME>   DO    UNTIL=(...)\n            ...\n            DONEXT ,\n            ...\n          ENDO  ,\n\nIF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'\nSTATEMENTS, A 'DONEXT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE\nSTATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:\n\n<NAME>    DO    UNTIL=(...)\n            ...\n            IF    (...),THENDO\n              ...\n              DONEXT , TRANSFERS TO STATEMENT FOLLOWING .. |\n              ...                                          |\n              DO    WHILE=(...)                            |\n                ...                                        |\n                DONEXT , TRANSFERS TO STMT FOLLOWING |     |\n                ...                                  |     |\n              ENDO  ,                 <---------------     |\n              ...                                          |\n            ENDIF ,                                        |\n            ...                                            |\n          ENDO  ,                     <---------------------\n\nELSE\nTHIS MACRO MAY BE CODED ONLY WITHIN A CR-GROUP HEADED BY AN 'AFTER',\n'ELSEIF', 'EVERY' OR 'FIRST' CR-GROUP HEADER.  IT CAUSES EXECUTION OF\nITS CR-GROUP IF ALL OF THE PREVIOUS CR-GROUPS HAVE BEEN BYPASSED:\n\n <NAME>   AFTER 1000000\n            ...             EXECUTED AFTER 1,000,000 PASSES\n          ELSE  ,\n            ...             EXECUTED FIRST 1,000,000 PASSES\n          ENDELSE ,\n\nELSEIF\nTHIS MACRO MAY FOLLOW ONLY ANOTHER 'ELSEIF' STATEMENT, OR AN 'IF'\nSTATEMENT. IT SUPPORTS ALL THE OPTIONS OF THE 'IF' STATEMENT. PLEASE\nSEE THE 'IF' STATEMENT FOR THE DETAILS.\n\n <NAME>   IF    (...),THENDO\n            ...\n          ELSEIF (...),THENDO\n            ...\n          ENDELSE ,\n\nENDAFTER\nENDELSE\nENDEVERY\nENDFIRST\nENDIF\nENDO\n\nTHESE MACROS ARE EQUIVALENT, AND SHOULD BE USED TO END THEIR\nRESPECTIVE TYPES OF CR-GROUPS. THE ONE 'INTERESTING' PARAMETER IS THE\n'DOGROUP=' KEYWORD.  IF YOU NAMED A PREVIOUS CR-GROUP HEADER MACRO (SUCH\nAS 'IF' OR 'DO'), AND YOU HAVE NESTED CR-GROUPS, THEN YOU MAY TERMINATE\nMULTIPLE CR-GROUPS WITH ONE 'ENDO' MACRO BY NAMING THE OUTERMOST GROUP\nTHAT YOU WANT TO TERMINATE, AND THEN NAMING THAT GROUP ON THE 'ENDO'\nMACRO:\n\n MAINGRP IF    (...),THENDO\n           ...\n           IF    (...),THENDO\n             ...\n         ENDIF DOGROUP=MAINGRP\n\nIF YOU WANT TO TERMINATE ALL CR-GROUPS, THEN CODE THE 'MAGIC' KEYWORD:\n\n MAINGRP IF    (...),THENDO\n           ...\n           IF    (...),THENDO\n             ...\n         ENDIF DOGROUP=*ALL*\n\nSINCE '*ALL*' IS NOT A VALID ASSEMBLER TAG, IT CAN BE SAFELY USED AS\nTHE FLAG TO INDICATE THAT ALL CURRENT CR-GROUPS ARE TO BE TERMINATED.\n\nEVERY\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED EVERY 'N'TH PASS\nTHROUGH THIS SECTION OF CODE. 'N' MUST BE A NUMERIC SELF-DEFINING TERM.\nAN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'AFTER' AND 'FIRST'.\n\n <NAME>  EVERY 1000000\n            WTO   'ANOTHER 1,000,000 PASSES'\n         ENDEVERY ,\n\nFIRST\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN SKIPPED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM. AN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'AFTER' AND 'FIRST'.\n\n <NAME>  FIRST 1000000\n            ...\n         ENDAFTER ,\n\nITS DESIGNED USE IS TO DO STUFF ONLY ON THE FIRST PASS THROUGH A\nSECTION OF CODE\n\n <NAME>  FIRST 1\n           OPEN  (...)\n         ENDFIRST ,\n\nTHENDO\nTHIS WAS THE ORIGINAL STRUCTURED MACRO OF THIS PACKAGE.  IT IS NOT SO\nPOWERFUL AS THE NEWER ONES, BUT YOU MIGHT FIND SOME USE FOR IT. ITS ONLY\nPOSITIONAL PARAMETER MUST BE ONE OF THE CONDITIONS THAT YOU CAN APPEND\nTO THE 'B' TO CREATE ONE OF THE EXTENDED BRANCH INSTRUCTIONS, SUCH AS\n'E'.  PLEASE REFER TO THE DOCUMENTATION FOR THE 'IF' MACRO FOR A\nCOMPLETE LIST.\n\nTHIS MACRO DEPENDS ON A PREVIOUS INSTRUCTION IN THE PROGRAM, SUCH AS A\n'CLR', TO SET THE CONDITION CODE. ITS CR-GROUP WILL THEN BE EXECUTED IF\nTHE OPERAND SATISFIES THE SETTING OF THE CONDITION CODE:\n\n          CLR   R5,R6\n <NAME>   THENDO E\n            ...\n          ENDO  ,\n\n          -- OR --\n\n          CLC   R5,R6\n <NAME>   THENDO E\n            ...\n          ELSE  ,\n            ...\n          ENDO  ,\n\nIN THIS EXAMPLE, THE FIRST CR-GROUP WILL BE EXECUTED IF R5 = R6, AND\nTHE SECOND WILL BE EXECUTED IF THEY ARE UNEQUAL.\n\nTHAT'S IT, FOLKS. NO OTHER OPTIONS FOR 'THENDO' (OTHER THAN NESTING).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DOEXIT": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00S\\x01\\x02\\x01_\\x01\\x02\\x01o\\t\\x15\\x00\\x0e\\x00\\r\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-01-16T09:15:53", "lines": 14, "newlines": 13, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    DOEXIT &DUMMY             XFER OUT OF INNERMOST DO-GROUP\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         LCLA  &I                  LOCAL INTEGER VARIABLE\n&I       SETA  &$MDGLVL            START AT CURRENT NESTING LEVEL\n.LOOP010 AIF   (&I GT 0).CONT020   CONTINUE IF NOT ALL DONE\n         MNOTE 8,'NO DO-GROUP TO EXIT FROM' OOPS...\n         AGO   .MEND040            ALL WAS FOR NAUGHT\n.CONT020 AIF   ('&$MCVERB(&I)' EQ 'DO').GEN030 IS THIS LEVEL A 'DO'?\n&I       SETA  &I-1                NO - BACK UP TO NEXT OUTER LEVEL\n         AGO   .LOOP010            PROCESS NEXT OUTER GROUP\n.GEN030  ANOP  ,                   DANG, GOT A LIVE ONE!\n&NAME    J     $MDF&$MDGSEQ(&I)    B TO INSTRUCTION FOLLOWING 'ENDO'\n.MEND040 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DONEXT": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x08T\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T08:54:09", "lines": 14, "newlines": 14, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    DONEXT &DUMMY\n         COPY  $MGBLDEF\n         LCLA  &I                  LOCAL INTEGER VARIABLE\n&I       SETA  &$MDGLVL            START AT CURRENT NESTING LEVEL\n.LOOP010 AIF   (&I GT 0).CONT020   CONTINUE IF NOT ALL DONE\n         MNOTE 8,'NO DO-GROUP TO DO NEXT ITERATION' OOPS...\n         AGO   .MEND040            ALL WAS FOR NAUGHT\n.CONT020 AIF   ('&$MCVERB(&I)' EQ 'DO').GEN030 IS THIS LEVEL A 'DO'?\n&I       SETA  &I-1                NO - BACK UP TO NEXT OUTER LEVEL\n         AGO   .LOOP010            PROCESS NEXT OUTER GROUP\n.GEN030  ANOP  ,                   DANG, GOT A LIVE ONE!\n&NAME    J     &$MLTAG(&I)         RETURN TO 'DO' CONTROL\n.MEND040 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSE": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00W\\x01\\x02\\x01_\\x01\\x02\\x06\\x7f\\x16\\t\\x00\\x1c\\x00\\x1b\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-03-08T16:09:57", "lines": 28, "newlines": 27, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ELSE  &DOGROUP=,&MNAME=ELSE  END OF POSITIVE TEST, START OF\n         COPY  $MGBLDEF            . NEGATIVE\n         LCLC  &X                  SET TO 'IF-FAILED' TAG\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''&MNAME'' IS VALID ONLY WITHIN AN IF-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    $MENDDO1 DOGROUP=&DOGROUP\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR\n         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30\n         MNOTE 8,'''&MNAME'' INVALID FOR ''DO'' - ENDO ASSUMED'\n         $MENDDO2 ,                PRETEND NO 'ELSEDO'\n         MEXIT\n.SKIP30  AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40\n         MNOTE 8,'''&MNAME'' INVALID FOLLOWING ''&MNAME'' -'\n         MNOTE '''ENDO'' INVOKED'\n         $MENDDO2                 JUST LIKE NO 'ELSEDO'\n         MEXIT\n.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG\n         AIF   ('&NAME' EQ '').SKIP50\n&NAME    DC    0H'0'         *=*=* BEGINNING OF 'ELSE' GROUP *=*=*\n.SKIP50  ANOP\n&X       DC    0H'0'         *=*=* BEGINNING OF 'ELSE' GROUP *=*=*\n&$MIFELS(&$MDGLVL) SETC 'S'\n&$MCVVERB(&$MDGLVL) SETC '&$MCVVERB(&$MDGLVL).ELSE'\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSEDO": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x08\\x01\\x01\"/\\x01\\x02\\x06\\x7f\\x16\\x10\\x00\\x1d\\x00#\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2001-08-10T00:00:00", "modifydate": "2002-03-08T16:10:08", "lines": 29, "newlines": 35, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ELSEDO &COND\n         COPY  $MGBLDEF\n         LCLC  &X\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ELSEDO'' IS VALID ONLY WITHIN A THENDO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSE'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''DO'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30\n         $MGFNBR  ,                GET A UNIQUE TAG\n.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND IF-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'\n         AIF   ('&NAME' EQ '').SKIP40\n&NAME    DC    0H'0'               DEFINE TAG\n.SKIP40  ANOP\n&X       DC    0H'0'               TAG FOR 'ELSE'\n&X       SETC  '&$MDGNAM(&$MDGLVL)'\n&$MDGLVL SETA  &$MDGLVL-1          SO 'THENDO' CAN BUMP IT UP AGAIN\n         THENDO &COND\n&$MDGNAM(&$MDGLVL) SETC '&X'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSEIF": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00!\\x01\\x01\"/\\x01\\x02\\x06\\x7f\\x16\\x10\\x00$\\x00#\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2001-08-10T00:00:00", "modifydate": "2002-03-08T16:10:21", "lines": 36, "newlines": 35, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ELSEIF &EXP\n         COPY  $MGBLDEF\n         LCLC  &X\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 12,'''ELSEIF'' IS VALID ONLY WITHIN AN IF-GROUP - MACRO C\n               GENERATION TERMINATED'\n         MEXIT\n.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04\n         MNOTE 12,'''ELSEIF'' INVALID FOLLOWING ''ELSE'' STATEMENT - MAC\n               CRO GENERATION TERMINATED'\n         MEXIT\n.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20\n         MNOTE 12,'''ELSEIF'' INVALID FOLLOWING ''DO'' STATEMENT - MACRC\n               O GENERATION TERMINATED'\n         MEXIT\n.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30\n         $MGFNBR  ,                GET A UNIQUE TAG\n.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND ELSEIF-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'\n&$MDGLVL SETA  &$MDGLVL-1          SO 'IF' CAN BUMP IT UP AGAIN\n         $MLVLMSG &$MDGLVL,NESTING\n         AIF   ('&NAME' EQ '').SKIP40\n&NAME    DC    0H'0'         *=*=* BEGINNING OF 'ELSEIF' GROUP *=*=*\n.SKIP40  ANOP\n&X       IF    &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),        C\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        C\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     C\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    C\n               &SYSLIST(17),&SYSLIST(18),&SYSLIST(19),&SYSLIST(20),    C\n               &SYSLIST(21),&SYSLIST(22),&SYSLIST(23),&SYSLIST(24),    C\n               &SYSLIST(25),&SYSLIST(26),&SYSLIST(27),&SYSLIST(28),    C\n               &SYSLIST(29),&SYSLIST(30),&SYSLIST(31),&SYSLIST(32)\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDIF'\n&$MCVERB(&$MDGLVL) SETC 'ELSEIF'   SET NAME FOR 'ENDIF'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDAFTER": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x006\\x01\\x02\\x01_\\x01\\x02\\x06\\x7f\\x16\\x10\\x00\\x12\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-03-08T16:10:36", "lines": 18, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDAFTER &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDAFTER'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'AFTER').CONT010\n         AIF   ('&X' EQ 'AFTERELSE').CONT010\n         MNOTE 4,'''ENDAFTER'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDELSE": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\x02\\x01_\\x01\\x02\\x04o\\x16$\\x00\\x12\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-02-15T16:24:09", "lines": 18, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDELSE &DOGROUP=         INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDELSE'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'ELSE').CONT010\n         AIF   ('&X' EQ 'ELSEIF').CONT010\n         MNOTE 4,'''ENDELSE'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDEVERY": {"ttr": 1044, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x06\\x01\\x02\\x01_\\x01\\x02\\x06\\x7f\\x16\\x11\\x00\\x12\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-03-08T16:11:06", "lines": 18, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDEVERY &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDEVERY'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'EVERY').CONT010\n         AIF   ('&X' EQ 'EVERYELSE').CONT010\n         MNOTE 4,'''ENDEVERY'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDFIRST": {"ttr": 1046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x18\\x01\\x02\\x01_\\x01\\x02\\x06\\x7f\\x16\\x11\\x00\\x12\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-03-08T16:11:18", "lines": 18, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDFIRST &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDFIRST'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'FIRST').CONT010\n         AIF   ('&X' EQ 'FIRSTELSE').CONT010\n         MNOTE 4,'''ENDFIRST'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDIF": {"ttr": 1048, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00(\\x01\\x02\\x01_\\x01\\x02\\x06\\x7f\\x16\\x11\\x00\\r\\x00\\n\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-03-08T16:11:28", "lines": 13, "newlines": 10, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDIF &ELSE,&DOGROUP=\n         COPY  $MGBLDEF\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'IF').CONT010\n         AIF   ('&X' EQ 'IFELSE').CONT010\n         AIF   ('&X' EQ 'ELSEIF').CONT010\n         MNOTE 4,'''ENDIF'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&$MCVERB(&$MDGLVL) SETC 'DO'       FAKE OUT 'ENDO' MACRO\n&NAME    ENDO  &ELSE,DOGROUP=&DOGROUP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDO": {"ttr": 1050, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00Q\\x01\\x02\\x01_\\x01\\x02\\t/\\x10\\t\\x00&\\x00\"\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-04-02T10:09:51", "lines": 38, "newlines": 34, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDO  &ELSE,&DOGROUP=    INTERCHANGEABLE WITH 'ENDELSE' EXCEPT\n         COPY  $MGBLDEF           . FOR 'ENDELSE' CLAUSE\n         LCLC  &X                  SET TO 'IF-FAILED' TAG\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDO'' INVALID OUTSIDE DO-GROUP - MACRO GENERATION C\n               TERMINATED'\n         MEXIT\n.OK02    ANOP\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'DO').OK03\n         MNOTE 4,'''ENDO'' USED TO TERMINATE ''&X'' GROUP'\n.OK03    ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR\n         AIF   ('&ELSE' NE '').NEXT10 NO 'ELSE' - END LAST LEVEL\n         $MENDDO2                 LAST LEVEL FOR THIS PASS\n         MEXIT\n.NEXT10  AIF   ('&ELSE' EQ 'ELSEDO').NEXT20 GO IF LEGIT 'ELSEDO'\n         MNOTE *,'ERROR IN PARM ''&ELSE'' - PARM IGNORED'\n         $MENDDO2                 JUST LIKE NO '&ELSE'\n         MEXIT\n.NEXT20  ANOP\n         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30\n         MNOTE 8,'''ELSEDO'' INVALID FOR ''DO'' - IGNORED'\n         $MENDDO2                 JUST LIKE NO '&ELSE'\n         MEXIT\n.SKIP30  ANOP\n         AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSEDO'' - ''ENDO'' INC\n               VOKED'\n         $MENDDO2                 JUST LIKE NO 'ELSEDO'\n         MEXIT\n.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG\n&X       DC    0H'0'              TAG FOR 'IF' FAILURE\n&$MIFELS(&$MDGLVL) SETC 'S'       SET FOR 'ENDELSE'\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDTEST": {"ttr": 1052, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    ENDTEST &DUMMY\n         AIF   ('&NAME' EQ '').MEND999\n&NAME    DS    0H                  TAG GENERATED BY 'ENDTEST' MACRO\n.MEND999 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EQUATE": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x02\\x06\\x7f\\x01\\x02\\x06\\x7f\\x14D\\x00\\x0b\\x00\\x08\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-03-08T00:00:00", "modifydate": "2002-03-08T14:44:40", "lines": 11, "newlines": 8, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n         EQUATE\n         PUSH  PRINT               *=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         PRINT NOGEN               *=* HIDE REGISTER EQUATES *=*\n&I       SETA  0\n.LOOP010 ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LT 16).LOOP010\n         POP   PRINT               *=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EVERY": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x17\\x01\\x013\\x1f\\x01\\x02\\x07\\x0f\\x13!\\x00\\x17\\x00\\x18\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2002-03-11T13:21:17", "lines": 23, "newlines": 24, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    EVERY &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING\n         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'EVERY' GROUP WILL BE PROC\n               CESSED EACH PASS THROUGH THIS SECTION OF CODE'\n&LCLV    SETC  '1'                 DO EVERY TIME\n.OK30    ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'EVERY'\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&NAME    SP    &X,=P'1'            DECREMENT\n         JP    $MDF&SYSNDX         B IF NOT YET TIME\n         MVC   &X,=P'&LCLV'        RESET\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&X       DC    P'&LCLV'            FREQUENCY COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXECUTE": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x04\\x01\\x01#o\\x01\\x02\\x07\\x8f\\x16$\\x00\\x0f\\x00\\x18\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-08-24T00:00:00", "modifydate": "2002-03-19T16:24:04", "lines": 15, "newlines": 24, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&N       EXECUTE &DUMMY            OPERANDS ACCESSED VIA &SYSLIST(N)\n         COPY  $MGBLDEF            GET STANDARD NAME FOR LOCTR\n         LCLC  &TEMP,&X,&OP        LOCAL SCRATCHPAD VARIABLES\n&X       SETC  '&SYSNDX'           FOR UNIQUENESS\n&N       EX    &SYSLIST(1),$EX&X   DO THE 'EX'ECUTE\n&TEMP    SETC  ','                 THIS WILL ALWAYS WORK\n         AIF   (K'&SYSLIST(3) LT 3).CONT010 GO IF ZERO OPERANDS\n&TEMP    SETC  '&SYSLIST(3)'(2,K'&SYSLIST(3)-2) FAILS IF ZERO OPERANDS\n.CONT010 ANOP\n&OP      SETC  '&SYSLIST(2)'       FOR BREVITY\n&$MLOCTR LOCTR ,                   OUT-OF-LINE STORAGE AREA\n$EX&X    &OP   &TEMP               'EX'ECUTED INSTRUCTION\n&SYSECT  LOCTR ,                   INSTRUCTION AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FIRST": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x04\\x01\\x013\\x1f\\x01\\x02\\x07\\x0f\\x13$\\x00!\\x00\"\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2002-03-11T13:24:04", "lines": 33, "newlines": 34, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    FIRST &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING\n         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'FIRST' GROUP WILL BE PROC\n               CESSED ONLY THE FIRST TIME THROUGH THIS SECTION OF CODE'\n&LCLV    SETC  '1'                 DO EVERY TIME\n.OK30    ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'FIRST'\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n         AIF   ('&LCLV' NE '1').SKIP030\n&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?\n         JO    $MDF&SYSNDX         B IF YES\n         OI    &X,X'01'            LEAVE TRACKS\n&$MLOCTR LOCTR                     ENTER WORK AREA\n&X       DC    X'00'               SET TO X'01' FIRST PASS\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEXIT\n.SKIP030 ANOP\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&NAME    CP    &X,=P'0'            FINISHED?\n         JNH   $MDF&SYSNDX         B IF YES\n         SP    &X,=P'1'            DECREMENT BY 1\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&X       DC    P'&LCLV'            EXECUTION TIMES COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IF": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00P\\x01\\x02\\x05/\\x01\\x02\\x10/\\x161\\x00\\x9b\\x00\\x95\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2002-02-21T00:00:00", "modifydate": "2002-04-12T16:31:50", "lines": 155, "newlines": 149, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    IF    &EXP                MULTIPLE OPERANDS VIA &SYSLIST\n         COPY  $MGBLDEF            BRING IN GLOBAL SET SYMBOLS\n         LCLA  &I,&J,&K            USED TO SCAN &SYSLIST OPERANDS, ETC\n         LCLC  &X,&Y,&OP,&OPND1,&OPND2,&OPND3,&C,&NC\n&$MRECUR SETA  &$MRECUR+1          INCREASE RECURSION COUNT\n         $MLVLMSG &$MRECUR,RECURSION CONDITIONALLY ISSUE MESSAGE\n&I       SETA  1                   SET TO FIRST POSITIONAL\n&$MNAME  SETC  '&NAME'             TAG FOR FIRST TEST\n.LOOP010 AIF   (N'&SYSLIST LT &I).FIN180 GO TO FINISH IF DONE\n         AIF   ('&SYSLIST(&I)'(1,1) NE '(').BADC120 MUST BE '('\n         AIF   ('&SYSLIST(&I)'(2,1) EQ '(').REC080 GO IF NESTED\n&OP      SETC  '&SYSLIST(&I,1)'    OP-CODE IS ALWAYS 1ST SUB-OPERAND\n&J       SETA  N'&SYSLIST(&I)      NUMBER OF SUBPARAMETERS FOR THIS ONE\n         AIF   (&J NE 2).TEST020   GO TEST FOR 1-OPERAND INST\n&$MNAME  &OP   ,                   ZERO OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,2)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.TEST020 ANOP  ,\n&OPND1   SETC  '&SYSLIST(&I,2)'    FIRST (ONLY?) OPERAND\n         AIF   (&J NE 3).TEST030   GO TEST FOR 2-OPERAND INST\n&$MNAME  &OP   &OPND1        ONE OPERAND - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,3)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.TEST030 ANOP  ,\n&OPND2   SETC  '&SYSLIST(&I,3)'    SECOND OPERAND\n         AIF   (&J NE 4).TEST040   GO TEST FOR 3-OPERAND INST\n&$MNAME  &OP   &OPND1,&OPND2 TWO OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,4)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.TEST040 ANOP  ,\n&OPND3   SETC  '&SYSLIST(&I,4)'    THIRD OPERAND\n         AIF   (&J NE 5).ERR050    GO ISSUE ERROR MESSAGE\n&$MNAME  &OP   &OPND1,&OPND2,&OPND3 THREE OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,5)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.ERR050  ANOP  ,\n&K       SETA  ((&I+1)/2)          GET SEQUENCE # OF PHRASE IN ERROR\n         MNOTE 08,'INVALID NUMBER OF PARMS (&J) IN CONDITIONAL PHRASE #*\n               &K &SYSLIST(&I); IT WILL BE OMITTED FROM THE MACRO EXPAN*\n               SION'\n&$MAXRC  SETA  8\n&$MNAME  CLC   *(1),*              PLACE HOLDER\n&$MNAME  SETC  ''                  NO DUPES\n         JNOP  *                   PLACE HOLDER\n&I       SETA  &I+2                INCREMENT\n         AGO   .LOOP010            BACK FOR MORE\n.FING060 ANOP                      COND CODE NOW SET - TEST IT\n&$MNAME  SETC  ''                  C'MON - NO DUPLICATE TAGS, PLEASE\n&$MNC    SETC  'N&$MC'             SET TO 'NOT'-CONDITION CODE\n         AIF   ('&$MC'(1,1) NE 'N').SKIP070 FALL THROUGH IF 'NE' ETC\n&$MNC    SETC  '&$MC'(2,1)         ORIG WAS 'NX' - SET TO 'X'\n.SKIP070 ANOP                       EXAMPLE 'NE' - SET TO 'E'\n         AIF   ('&SYSLIST(&I+2)' EQ '').FIN180 GO IF END OF STATEMENT\n         AIF   ('&SYSLIST(&I+1)' EQ 'OR').OR130 GO IF 'OR'\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR130 GO IF 'AND'\n         MNOTE 8,'TERM ''&SYSLIST(&I+1)'' ACCEPTED AS AN ''OR'' CLAUSE'\n&$MAXRC  SETA  8\n         AGO   .OR130              COMMON FOR 'AND' AND 'OR'\n.REC080  ANOP                      HERE FOR RECURSIVE CALL\n&$MNAME  IF    &SYSLIST(&I,1),&SYSLIST(&I,2),&SYSLIST(&I,3),           C\n               &SYSLIST(&I,4),&SYSLIST(&I,5),&SYSLIST(&I,6),           C\n               &SYSLIST(&I,7),&SYSLIST(&I,8),&SYSLIST(&I,9),           C\n               &SYSLIST(&I,10),&SYSLIST(&I,11),&SYSLIST(&I,12),        C\n               &SYSLIST(&I,13),&SYSLIST(&I,14),&SYSLIST(&I,15),        C\n               &SYSLIST(&I,16),&SYSLIST(&I,17),&SYSLIST(&I,18),        C\n               &SYSLIST(&I,19),&SYSLIST(&I,20),&SYSLIST(&I,21)\n         AIF   ('&$MFNAM1(&$MRECUR+1)' EQ '').REC100 GO IF NO FNAM1(+1)\n         AIF   ('&$MFNAM1(&$MRECUR)' EQ '').REC090 GO IF NO FNAM1\n&X       SETC  '&$MFNAM1(&$MRECUR+1)' TEMP FOR FNAM1(+1)\n&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY\n&X       EQU   &$MFNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC\n         AGO   .REC100             TEST PNAM1\n.REC090  ANOP\n&$MFNAM1(&$MRECUR) SETC '&$MFNAM1(&$MRECUR+1)' PROMOTE\n&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY\n.REC100  AIF   ('&$MPNAM1(&$MRECUR+1)' EQ '').REC110 GO IF NO PNAM1(+1)\n&$MNAME  SETC  '&$MPNAM1(&$MRECUR+1)' QUEUE FOR TEST INSTRUCTION\n&$MPNAM1(&$MRECUR+1) SETC ''       NULLIFY\n.REC110  AIF   ('&SYSLIST(&I+2)' EQ '').FIN180 GO IF END OF STATEMENT\n         AIF   ('&SYSLIST(&I+1)' EQ  'OR').OR130 GO IF 'OR'\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR130 GO IF 'AND'\n         AGO   .FIN180             NOT 'OR' OR 'AND' - ASSUME END\n.BADC120 MNOTE 12,'''&SYSLIST(&I)'' IS NOT A VALID CONDITIONAL PHRASE: C\n               EACH CONDITIONAL PHRASE MUST BE ENCLOSED WITHIN ONE OR MC\n               ORE PAIRS OF PARENTHESES. MACRO GENERATION ABORTED.'\n&$MAXRC  SETA  12\n         AGO   .FIN180             GO WRAP IT UP\n.OR130   ANOP                      COMMON FOR 'OR' AND 'AND'\n&NC      SETC  '&$MNC'             GEN LOCAL VARIABLES FOR\n&C       SETC  '&$MC'              . CONDITION CODE TESTS\n&$MNC    SETC  ''                  NULLIFY THE GLOBAL VARIABLES\n&$MC     SETC  ''                  . SINCE LOCALS WILL BE USED\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').AND160   GO IF 'AND'\n         AIF   ('&$MPNAM1(&$MRECUR)' NE '').OR140 SKIP IF NOT NEEDED\n         $MGPNAME                  GET A NEW 'PNAM1'\n.OR140   J&C   &$MPNAM1(&$MRECUR)  B IF TRUE TO 'PASS' TAG\n&I       SETA  &I+2                BUMP TO NEXT OPERAND\n         AIF   ('&$MNAME' EQ '').OR150 GO IF NO PNAM1 QUEUED\n&$MNAME  EQU   &$MPNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC\n.OR150   ANOP\n&$MNAME  SETC  '&$MFNAM1(&$MRECUR)' QUEUE TAG FOR 'AND' FAILED\n&$MFNAM1(&$MRECUR) SETC ''         NULLIFY TAG\n         AGO   .LOOP010            AND CONTINUE\n.AND160  AIF   ('&$MFNAM1(&$MRECUR)' NE '').AND170 SKIP IF NOT NEEDED\n         $MGFNAME                  GET A NEW 'FNAM1'\n.AND170  J&NC  &$MFNAM1(&$MRECUR)  B IF FALSE TO 'FAIL' TAG\n&I       SETA  &I+2                BUMP TO NEXT\n         AGO   .LOOP010            AND BACK\n.FIN180  AIF   (&$MRECUR GT 1).MEND260 EARLY EXIT FOR RECURSIVE CALL\n         AIF   ('&SYSLIST(&I+1)' EQ 'THENDO').FIN200 THIS IS EXPECTED\n         AIF   ('&$MCVERB(&$MDGLVL+1)' EQ 'DO').FIN200 FOR 'DO' MACRO\n         AIF   (&$MAXRC GT 4).FIN200 SKIP MESSAGE IF SERIOUS ERROR\n         AIF   ('&SYSLIST(&I+1)' EQ '').FIN190 GO ISSUE INFO MNOTE\n         MNOTE 4,'TERM ''&SYSLIST(&I+1)'' ACCEPTED AS END OF ''IF'' STAC\n               TEMENT'\n         AGO   .FIN200\n.FIN190  MNOTE 0,'''IF'' MACRO NOT TERMINATED BY ''THENDO'' CLAUSE; PREC\n               SENCE OF CLAUSE ASSUMED'\n.FIN200  ANOP\n&$MAXRC  SETA  0                   FOR FUTURE GENERATIONS\n&$MDGLVL SETA  &$MDGLVL+1          UP IF-GROUP LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET IF-GROUP SEQUENCE\n&$MIFELS(&$MDGLVL) SETC 'F'        FOR 'IF-FAILED' BRANCH\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDO'\n         AIF   ('&$MCVERB(&$MDGLVL)' NE '').SKIP210 ALREADY DEFINED?\n&$MCVERB(&$MDGLVL) SETC 'IF'       SHOW VERB BEING EXECUTED\n.SKIP210 ANOP\n&NC      SETC  '&$MNC'             SET LOCAL VARIABLE\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG\n         AIF   ('&$MFNAM1(1)' NE '').FIN220 GO IF F-TAG NEEDED\n         AIF   ('&$MNC' EQ '').FIN240 SKIP IF B&NC NOT REQ'D\n         J&NC  &X                  B AROUND IF-GROUP IF FALSE\n&$MNC    SETC  ''                  FOR FUTURES\n         AGO   .FIN240             EXIT\n.FIN220  AIF   ('&$MC' EQ '').FIN230 SKIP IF B&C NOT REQ'D\n         J&NC  &X                  B AROUND IF-GROUP IF FALSE\n&$MNC    SETC  ''                  FOR FUTURES\n.FIN230  ANOP\n&X       SETC  '&$MFNAM1(1)'       GET 'FNAM1' FROM LEVEL 1\n&$MFNAM1(1) SETC ''                NOW NULLIFY IT\n&Y       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG\n&X       EQU   &Y                  EQUATE FOR NESTED LOGIC\n.FIN240  AIF   ('&$MNAME' EQ '').FIN250 GO IF NO TAG QUEUED\n&$MNAME  DC    0H'0'         *=*=* BEGINNING OF CONDITIONAL GROUP *=*=*\n.FIN250  ANOP\n&X       SETC  '&$MPNAM1(1)'       GET 'PNAM1' FROM LEVEL 1\n         AIF   ('&X' EQ '').MEND260 GO IF NO 'PNAM1' FROM LEVEL 1\n&$MPNAM1(1) SETC  ''               NULLIFY\n&X       DC    0H'0'         *=*=* BEGINNING OF CONDITIONAL GROUP *=*=*\n.MEND260 ANOP                      STANDARD EXIT\n&$MRECUR SETA  &$MRECUR-1          REDUCE RECURSION COUNT\n         $MLVLMSG &$MRECUR,RECURSION CONDITIONALLY ISSUE MESSAGE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OMGBLDEF": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "GENTR02"}, "text": "         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MBLATH\n         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC\n         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)\n         GBLC  &$MCVERB(255),&$MC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "THENDO": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x01\\x01\"/\\x01\\x02\\x06\\x7f\\x16\\x13\\x00\\x14\\x00\\x17\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-08-10T00:00:00", "modifydate": "2002-03-08T16:13:00", "lines": 20, "newlines": 23, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    THENDO &COND '&COND' MUST BE CHAR(S) FOLLOWING 'B' OF EXTENDED\n.*             MNEMONICS, EG 'E' OF 'BE' OR 'NO' OF 'BNO', ETC\n         COPY  $MGBLDEF\n         LCLC  &X,&Y\n&Y       SETC  'N&COND'\n         AIF   ('&COND'(1,1) NE 'N').SKIP05\n&Y       SETC  '&COND'(2,1)\n.SKIP05  ANOP\n&$MDGLVL SETA  &$MDGLVL+1          UP DO-GROUP LEVEL\n         $MLVLMSG\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET DO-GROUP SEQUENCE\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET DO-GROUP NAME\n&$MIFELS(&$MDGLVL) SETC 'F'\n         AIF   ('&NAME' NE '').SKIP07\n&$MDGNAM(&$MDGLVL) SETC '$MDG&$MDGSEQ(&$MDGLVL)'\n.SKIP07  J&Y   $MDF&$MDGSEQ(&$MDGLVL) SKIP DO-GROUP IF REL NOT TRUE\n         AIF   ('&NAME' EQ '').SKIP10\n&NAME    DC    0H'0'              NAME OF DO-GROUP\n.SKIP10  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT550/FILE550.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT550", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}